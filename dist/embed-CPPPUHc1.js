function EK(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in e)) {
          const o = Object.getOwnPropertyDescriptor(r, i);
          o && Object.defineProperty(e, i, o.get ? o : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var _K = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Pc(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function TK(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      var i = !1;
      try {
        i = this instanceof r;
      } catch {
      }
      return i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var ek = { exports: {} }, At = {};
var eD;
function AK() {
  if (eD) return At;
  eD = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), i = /* @__PURE__ */ Symbol.for("react.profiler"), o = /* @__PURE__ */ Symbol.for("react.consumer"), s = /* @__PURE__ */ Symbol.for("react.context"), a = /* @__PURE__ */ Symbol.for("react.forward_ref"), c = /* @__PURE__ */ Symbol.for("react.suspense"), u = /* @__PURE__ */ Symbol.for("react.memo"), f = /* @__PURE__ */ Symbol.for("react.lazy"), h = /* @__PURE__ */ Symbol.for("react.activity"), m = Symbol.iterator;
  function g(Z) {
    return Z === null || typeof Z != "object" ? null : (Z = m && Z[m] || Z["@@iterator"], typeof Z == "function" ? Z : null);
  }
  var b = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, x = Object.assign, w = {};
  function S(Z, pe, F) {
    this.props = Z, this.context = pe, this.refs = w, this.updater = F || b;
  }
  S.prototype.isReactComponent = {}, S.prototype.setState = function(Z, pe) {
    if (typeof Z != "object" && typeof Z != "function" && Z != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, Z, pe, "setState");
  }, S.prototype.forceUpdate = function(Z) {
    this.updater.enqueueForceUpdate(this, Z, "forceUpdate");
  };
  function _() {
  }
  _.prototype = S.prototype;
  function M(Z, pe, F) {
    this.props = Z, this.context = pe, this.refs = w, this.updater = F || b;
  }
  var N = M.prototype = new _();
  N.constructor = M, x(N, S.prototype), N.isPureReactComponent = !0;
  var P = Array.isArray;
  function I() {
  }
  var O = { H: null, A: null, T: null, S: null }, L = Object.prototype.hasOwnProperty;
  function U(Z, pe, F) {
    var ee = F.ref;
    return {
      $$typeof: e,
      type: Z,
      key: pe,
      ref: ee !== void 0 ? ee : null,
      props: F
    };
  }
  function B(Z, pe) {
    return U(Z.type, pe, Z.props);
  }
  function G(Z) {
    return typeof Z == "object" && Z !== null && Z.$$typeof === e;
  }
  function Y(Z) {
    var pe = { "=": "=0", ":": "=2" };
    return "$" + Z.replace(/[=:]/g, function(F) {
      return pe[F];
    });
  }
  var he = /\/+/g;
  function ie(Z, pe) {
    return typeof Z == "object" && Z !== null && Z.key != null ? Y("" + Z.key) : pe.toString(36);
  }
  function ne(Z) {
    switch (Z.status) {
      case "fulfilled":
        return Z.value;
      case "rejected":
        throw Z.reason;
      default:
        switch (typeof Z.status == "string" ? Z.then(I, I) : (Z.status = "pending", Z.then(
          function(pe) {
            Z.status === "pending" && (Z.status = "fulfilled", Z.value = pe);
          },
          function(pe) {
            Z.status === "pending" && (Z.status = "rejected", Z.reason = pe);
          }
        )), Z.status) {
          case "fulfilled":
            return Z.value;
          case "rejected":
            throw Z.reason;
        }
    }
    throw Z;
  }
  function H(Z, pe, F, ee, ge) {
    var re = typeof Z;
    (re === "undefined" || re === "boolean") && (Z = null);
    var J = !1;
    if (Z === null) J = !0;
    else
      switch (re) {
        case "bigint":
        case "string":
        case "number":
          J = !0;
          break;
        case "object":
          switch (Z.$$typeof) {
            case e:
            case t:
              J = !0;
              break;
            case f:
              return J = Z._init, H(
                J(Z._payload),
                pe,
                F,
                ee,
                ge
              );
          }
      }
    if (J)
      return ge = ge(Z), J = ee === "" ? "." + ie(Z, 0) : ee, P(ge) ? (F = "", J != null && (F = J.replace(he, "$&/") + "/"), H(ge, pe, F, "", function(Ae) {
        return Ae;
      })) : ge != null && (G(ge) && (ge = B(
        ge,
        F + (ge.key == null || Z && Z.key === ge.key ? "" : ("" + ge.key).replace(
          he,
          "$&/"
        ) + "/") + J
      )), pe.push(ge)), 1;
    J = 0;
    var xe = ee === "" ? "." : ee + ":";
    if (P(Z))
      for (var be = 0; be < Z.length; be++)
        ee = Z[be], re = xe + ie(ee, be), J += H(
          ee,
          pe,
          F,
          re,
          ge
        );
    else if (be = g(Z), typeof be == "function")
      for (Z = be.call(Z), be = 0; !(ee = Z.next()).done; )
        ee = ee.value, re = xe + ie(ee, be++), J += H(
          ee,
          pe,
          F,
          re,
          ge
        );
    else if (re === "object") {
      if (typeof Z.then == "function")
        return H(
          ne(Z),
          pe,
          F,
          ee,
          ge
        );
      throw pe = String(Z), Error(
        "Objects are not valid as a React child (found: " + (pe === "[object Object]" ? "object with keys {" + Object.keys(Z).join(", ") + "}" : pe) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return J;
  }
  function Q(Z, pe, F) {
    if (Z == null) return Z;
    var ee = [], ge = 0;
    return H(Z, ee, "", "", function(re) {
      return pe.call(F, re, ge++);
    }), ee;
  }
  function X(Z) {
    if (Z._status === -1) {
      var pe = Z._result;
      pe = pe(), pe.then(
        function(F) {
          (Z._status === 0 || Z._status === -1) && (Z._status = 1, Z._result = F);
        },
        function(F) {
          (Z._status === 0 || Z._status === -1) && (Z._status = 2, Z._result = F);
        }
      ), Z._status === -1 && (Z._status = 0, Z._result = pe);
    }
    if (Z._status === 1) return Z._result.default;
    throw Z._result;
  }
  var Se = typeof reportError == "function" ? reportError : function(Z) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var pe = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof Z == "object" && Z !== null && typeof Z.message == "string" ? String(Z.message) : String(Z),
        error: Z
      });
      if (!window.dispatchEvent(pe)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", Z);
      return;
    }
    console.error(Z);
  }, W = {
    map: Q,
    forEach: function(Z, pe, F) {
      Q(
        Z,
        function() {
          pe.apply(this, arguments);
        },
        F
      );
    },
    count: function(Z) {
      var pe = 0;
      return Q(Z, function() {
        pe++;
      }), pe;
    },
    toArray: function(Z) {
      return Q(Z, function(pe) {
        return pe;
      }) || [];
    },
    only: function(Z) {
      if (!G(Z))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return Z;
    }
  };
  return At.Activity = h, At.Children = W, At.Component = S, At.Fragment = n, At.Profiler = i, At.PureComponent = M, At.StrictMode = r, At.Suspense = c, At.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = O, At.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(Z) {
      return O.H.useMemoCache(Z);
    }
  }, At.cache = function(Z) {
    return function() {
      return Z.apply(null, arguments);
    };
  }, At.cacheSignal = function() {
    return null;
  }, At.cloneElement = function(Z, pe, F) {
    if (Z == null)
      throw Error(
        "The argument must be a React element, but you passed " + Z + "."
      );
    var ee = x({}, Z.props), ge = Z.key;
    if (pe != null)
      for (re in pe.key !== void 0 && (ge = "" + pe.key), pe)
        !L.call(pe, re) || re === "key" || re === "__self" || re === "__source" || re === "ref" && pe.ref === void 0 || (ee[re] = pe[re]);
    var re = arguments.length - 2;
    if (re === 1) ee.children = F;
    else if (1 < re) {
      for (var J = Array(re), xe = 0; xe < re; xe++)
        J[xe] = arguments[xe + 2];
      ee.children = J;
    }
    return U(Z.type, ge, ee);
  }, At.createContext = function(Z) {
    return Z = {
      $$typeof: s,
      _currentValue: Z,
      _currentValue2: Z,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, Z.Provider = Z, Z.Consumer = {
      $$typeof: o,
      _context: Z
    }, Z;
  }, At.createElement = function(Z, pe, F) {
    var ee, ge = {}, re = null;
    if (pe != null)
      for (ee in pe.key !== void 0 && (re = "" + pe.key), pe)
        L.call(pe, ee) && ee !== "key" && ee !== "__self" && ee !== "__source" && (ge[ee] = pe[ee]);
    var J = arguments.length - 2;
    if (J === 1) ge.children = F;
    else if (1 < J) {
      for (var xe = Array(J), be = 0; be < J; be++)
        xe[be] = arguments[be + 2];
      ge.children = xe;
    }
    if (Z && Z.defaultProps)
      for (ee in J = Z.defaultProps, J)
        ge[ee] === void 0 && (ge[ee] = J[ee]);
    return U(Z, re, ge);
  }, At.createRef = function() {
    return { current: null };
  }, At.forwardRef = function(Z) {
    return { $$typeof: a, render: Z };
  }, At.isValidElement = G, At.lazy = function(Z) {
    return {
      $$typeof: f,
      _payload: { _status: -1, _result: Z },
      _init: X
    };
  }, At.memo = function(Z, pe) {
    return {
      $$typeof: u,
      type: Z,
      compare: pe === void 0 ? null : pe
    };
  }, At.startTransition = function(Z) {
    var pe = O.T, F = {};
    O.T = F;
    try {
      var ee = Z(), ge = O.S;
      ge !== null && ge(F, ee), typeof ee == "object" && ee !== null && typeof ee.then == "function" && ee.then(I, Se);
    } catch (re) {
      Se(re);
    } finally {
      pe !== null && F.types !== null && (pe.types = F.types), O.T = pe;
    }
  }, At.unstable_useCacheRefresh = function() {
    return O.H.useCacheRefresh();
  }, At.use = function(Z) {
    return O.H.use(Z);
  }, At.useActionState = function(Z, pe, F) {
    return O.H.useActionState(Z, pe, F);
  }, At.useCallback = function(Z, pe) {
    return O.H.useCallback(Z, pe);
  }, At.useContext = function(Z) {
    return O.H.useContext(Z);
  }, At.useDebugValue = function() {
  }, At.useDeferredValue = function(Z, pe) {
    return O.H.useDeferredValue(Z, pe);
  }, At.useEffect = function(Z, pe) {
    return O.H.useEffect(Z, pe);
  }, At.useEffectEvent = function(Z) {
    return O.H.useEffectEvent(Z);
  }, At.useId = function() {
    return O.H.useId();
  }, At.useImperativeHandle = function(Z, pe, F) {
    return O.H.useImperativeHandle(Z, pe, F);
  }, At.useInsertionEffect = function(Z, pe) {
    return O.H.useInsertionEffect(Z, pe);
  }, At.useLayoutEffect = function(Z, pe) {
    return O.H.useLayoutEffect(Z, pe);
  }, At.useMemo = function(Z, pe) {
    return O.H.useMemo(Z, pe);
  }, At.useOptimistic = function(Z, pe) {
    return O.H.useOptimistic(Z, pe);
  }, At.useReducer = function(Z, pe, F) {
    return O.H.useReducer(Z, pe, F);
  }, At.useRef = function(Z) {
    return O.H.useRef(Z);
  }, At.useState = function(Z) {
    return O.H.useState(Z);
  }, At.useSyncExternalStore = function(Z, pe, F) {
    return O.H.useSyncExternalStore(
      Z,
      pe,
      F
    );
  }, At.useTransition = function() {
    return O.H.useTransition();
  }, At.version = "19.2.4", At;
}
var tD;
function ud() {
  return tD || (tD = 1, ek.exports = AK()), ek.exports;
}
var k = ud();
const Ne = /* @__PURE__ */ Pc(k), Ix = /* @__PURE__ */ EK({
  __proto__: null,
  default: Ne
}, [k]);
var tk = { exports: {} }, Vp = {}, nk = { exports: {} }, rk = {};
var nD;
function MK() {
  return nD || (nD = 1, (function(e) {
    function t(H, Q) {
      var X = H.length;
      H.push(Q);
      e: for (; 0 < X; ) {
        var Se = X - 1 >>> 1, W = H[Se];
        if (0 < i(W, Q))
          H[Se] = Q, H[X] = W, X = Se;
        else break e;
      }
    }
    function n(H) {
      return H.length === 0 ? null : H[0];
    }
    function r(H) {
      if (H.length === 0) return null;
      var Q = H[0], X = H.pop();
      if (X !== Q) {
        H[0] = X;
        e: for (var Se = 0, W = H.length, Z = W >>> 1; Se < Z; ) {
          var pe = 2 * (Se + 1) - 1, F = H[pe], ee = pe + 1, ge = H[ee];
          if (0 > i(F, X))
            ee < W && 0 > i(ge, F) ? (H[Se] = ge, H[ee] = X, Se = ee) : (H[Se] = F, H[pe] = X, Se = pe);
          else if (ee < W && 0 > i(ge, X))
            H[Se] = ge, H[ee] = X, Se = ee;
          else break e;
        }
      }
      return Q;
    }
    function i(H, Q) {
      var X = H.sortIndex - Q.sortIndex;
      return X !== 0 ? X : H.id - Q.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      e.unstable_now = function() {
        return o.now();
      };
    } else {
      var s = Date, a = s.now();
      e.unstable_now = function() {
        return s.now() - a;
      };
    }
    var c = [], u = [], f = 1, h = null, m = 3, g = !1, b = !1, x = !1, w = !1, S = typeof setTimeout == "function" ? setTimeout : null, _ = typeof clearTimeout == "function" ? clearTimeout : null, M = typeof setImmediate < "u" ? setImmediate : null;
    function N(H) {
      for (var Q = n(u); Q !== null; ) {
        if (Q.callback === null) r(u);
        else if (Q.startTime <= H)
          r(u), Q.sortIndex = Q.expirationTime, t(c, Q);
        else break;
        Q = n(u);
      }
    }
    function P(H) {
      if (x = !1, N(H), !b)
        if (n(c) !== null)
          b = !0, I || (I = !0, Y());
        else {
          var Q = n(u);
          Q !== null && ne(P, Q.startTime - H);
        }
    }
    var I = !1, O = -1, L = 5, U = -1;
    function B() {
      return w ? !0 : !(e.unstable_now() - U < L);
    }
    function G() {
      if (w = !1, I) {
        var H = e.unstable_now();
        U = H;
        var Q = !0;
        try {
          e: {
            b = !1, x && (x = !1, _(O), O = -1), g = !0;
            var X = m;
            try {
              t: {
                for (N(H), h = n(c); h !== null && !(h.expirationTime > H && B()); ) {
                  var Se = h.callback;
                  if (typeof Se == "function") {
                    h.callback = null, m = h.priorityLevel;
                    var W = Se(
                      h.expirationTime <= H
                    );
                    if (H = e.unstable_now(), typeof W == "function") {
                      h.callback = W, N(H), Q = !0;
                      break t;
                    }
                    h === n(c) && r(c), N(H);
                  } else r(c);
                  h = n(c);
                }
                if (h !== null) Q = !0;
                else {
                  var Z = n(u);
                  Z !== null && ne(
                    P,
                    Z.startTime - H
                  ), Q = !1;
                }
              }
              break e;
            } finally {
              h = null, m = X, g = !1;
            }
            Q = void 0;
          }
        } finally {
          Q ? Y() : I = !1;
        }
      }
    }
    var Y;
    if (typeof M == "function")
      Y = function() {
        M(G);
      };
    else if (typeof MessageChannel < "u") {
      var he = new MessageChannel(), ie = he.port2;
      he.port1.onmessage = G, Y = function() {
        ie.postMessage(null);
      };
    } else
      Y = function() {
        S(G, 0);
      };
    function ne(H, Q) {
      O = S(function() {
        H(e.unstable_now());
      }, Q);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(H) {
      H.callback = null;
    }, e.unstable_forceFrameRate = function(H) {
      0 > H || 125 < H ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : L = 0 < H ? Math.floor(1e3 / H) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return m;
    }, e.unstable_next = function(H) {
      switch (m) {
        case 1:
        case 2:
        case 3:
          var Q = 3;
          break;
        default:
          Q = m;
      }
      var X = m;
      m = Q;
      try {
        return H();
      } finally {
        m = X;
      }
    }, e.unstable_requestPaint = function() {
      w = !0;
    }, e.unstable_runWithPriority = function(H, Q) {
      switch (H) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          H = 3;
      }
      var X = m;
      m = H;
      try {
        return Q();
      } finally {
        m = X;
      }
    }, e.unstable_scheduleCallback = function(H, Q, X) {
      var Se = e.unstable_now();
      switch (typeof X == "object" && X !== null ? (X = X.delay, X = typeof X == "number" && 0 < X ? Se + X : Se) : X = Se, H) {
        case 1:
          var W = -1;
          break;
        case 2:
          W = 250;
          break;
        case 5:
          W = 1073741823;
          break;
        case 4:
          W = 1e4;
          break;
        default:
          W = 5e3;
      }
      return W = X + W, H = {
        id: f++,
        callback: Q,
        priorityLevel: H,
        startTime: X,
        expirationTime: W,
        sortIndex: -1
      }, X > Se ? (H.sortIndex = X, t(u, H), n(c) === null && H === n(u) && (x ? (_(O), O = -1) : x = !0, ne(P, X - Se))) : (H.sortIndex = W, t(c, H), b || g || (b = !0, I || (I = !0, Y()))), H;
    }, e.unstable_shouldYield = B, e.unstable_wrapCallback = function(H) {
      var Q = m;
      return function() {
        var X = m;
        m = Q;
        try {
          return H.apply(this, arguments);
        } finally {
          m = X;
        }
      };
    };
  })(rk)), rk;
}
var rD;
function NK() {
  return rD || (rD = 1, nk.exports = MK()), nk.exports;
}
var ik = { exports: {} }, ui = {};
var iD;
function RK() {
  if (iD) return ui;
  iD = 1;
  var e = ud();
  function t(c) {
    var u = "https://react.dev/errors/" + c;
    if (1 < arguments.length) {
      u += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var f = 2; f < arguments.length; f++)
        u += "&args[]=" + encodeURIComponent(arguments[f]);
    }
    return "Minified React error #" + c + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var r = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, i = /* @__PURE__ */ Symbol.for("react.portal");
  function o(c, u, f) {
    var h = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: i,
      key: h == null ? null : "" + h,
      children: c,
      containerInfo: u,
      implementation: f
    };
  }
  var s = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function a(c, u) {
    if (c === "font") return "";
    if (typeof u == "string")
      return u === "use-credentials" ? u : "";
  }
  return ui.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, ui.createPortal = function(c, u) {
    var f = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11)
      throw Error(t(299));
    return o(c, u, null, f);
  }, ui.flushSync = function(c) {
    var u = s.T, f = r.p;
    try {
      if (s.T = null, r.p = 2, c) return c();
    } finally {
      s.T = u, r.p = f, r.d.f();
    }
  }, ui.preconnect = function(c, u) {
    typeof c == "string" && (u ? (u = u.crossOrigin, u = typeof u == "string" ? u === "use-credentials" ? u : "" : void 0) : u = null, r.d.C(c, u));
  }, ui.prefetchDNS = function(c) {
    typeof c == "string" && r.d.D(c);
  }, ui.preinit = function(c, u) {
    if (typeof c == "string" && u && typeof u.as == "string") {
      var f = u.as, h = a(f, u.crossOrigin), m = typeof u.integrity == "string" ? u.integrity : void 0, g = typeof u.fetchPriority == "string" ? u.fetchPriority : void 0;
      f === "style" ? r.d.S(
        c,
        typeof u.precedence == "string" ? u.precedence : void 0,
        {
          crossOrigin: h,
          integrity: m,
          fetchPriority: g
        }
      ) : f === "script" && r.d.X(c, {
        crossOrigin: h,
        integrity: m,
        fetchPriority: g,
        nonce: typeof u.nonce == "string" ? u.nonce : void 0
      });
    }
  }, ui.preinitModule = function(c, u) {
    if (typeof c == "string")
      if (typeof u == "object" && u !== null) {
        if (u.as == null || u.as === "script") {
          var f = a(
            u.as,
            u.crossOrigin
          );
          r.d.M(c, {
            crossOrigin: f,
            integrity: typeof u.integrity == "string" ? u.integrity : void 0,
            nonce: typeof u.nonce == "string" ? u.nonce : void 0
          });
        }
      } else u == null && r.d.M(c);
  }, ui.preload = function(c, u) {
    if (typeof c == "string" && typeof u == "object" && u !== null && typeof u.as == "string") {
      var f = u.as, h = a(f, u.crossOrigin);
      r.d.L(c, f, {
        crossOrigin: h,
        integrity: typeof u.integrity == "string" ? u.integrity : void 0,
        nonce: typeof u.nonce == "string" ? u.nonce : void 0,
        type: typeof u.type == "string" ? u.type : void 0,
        fetchPriority: typeof u.fetchPriority == "string" ? u.fetchPriority : void 0,
        referrerPolicy: typeof u.referrerPolicy == "string" ? u.referrerPolicy : void 0,
        imageSrcSet: typeof u.imageSrcSet == "string" ? u.imageSrcSet : void 0,
        imageSizes: typeof u.imageSizes == "string" ? u.imageSizes : void 0,
        media: typeof u.media == "string" ? u.media : void 0
      });
    }
  }, ui.preloadModule = function(c, u) {
    if (typeof c == "string")
      if (u) {
        var f = a(u.as, u.crossOrigin);
        r.d.m(c, {
          as: typeof u.as == "string" && u.as !== "script" ? u.as : void 0,
          crossOrigin: f,
          integrity: typeof u.integrity == "string" ? u.integrity : void 0
        });
      } else r.d.m(c);
  }, ui.requestFormReset = function(c) {
    r.d.r(c);
  }, ui.unstable_batchedUpdates = function(c, u) {
    return c(u);
  }, ui.useFormState = function(c, u, f) {
    return s.H.useFormState(c, u, f);
  }, ui.useFormStatus = function() {
    return s.H.useHostTransitionStatus();
  }, ui.version = "19.2.4", ui;
}
var oD;
function zx() {
  if (oD) return ik.exports;
  oD = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), ik.exports = RK(), ik.exports;
}
var sD;
function OK() {
  if (sD) return Vp;
  sD = 1;
  var e = NK(), t = ud(), n = zx();
  function r(l) {
    var d = "https://react.dev/errors/" + l;
    if (1 < arguments.length) {
      d += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var p = 2; p < arguments.length; p++)
        d += "&args[]=" + encodeURIComponent(arguments[p]);
    }
    return "Minified React error #" + l + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function i(l) {
    return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11);
  }
  function o(l) {
    var d = l, p = l;
    if (l.alternate) for (; d.return; ) d = d.return;
    else {
      l = d;
      do
        d = l, (d.flags & 4098) !== 0 && (p = d.return), l = d.return;
      while (l);
    }
    return d.tag === 3 ? p : null;
  }
  function s(l) {
    if (l.tag === 13) {
      var d = l.memoizedState;
      if (d === null && (l = l.alternate, l !== null && (d = l.memoizedState)), d !== null) return d.dehydrated;
    }
    return null;
  }
  function a(l) {
    if (l.tag === 31) {
      var d = l.memoizedState;
      if (d === null && (l = l.alternate, l !== null && (d = l.memoizedState)), d !== null) return d.dehydrated;
    }
    return null;
  }
  function c(l) {
    if (o(l) !== l)
      throw Error(r(188));
  }
  function u(l) {
    var d = l.alternate;
    if (!d) {
      if (d = o(l), d === null) throw Error(r(188));
      return d !== l ? null : l;
    }
    for (var p = l, y = d; ; ) {
      var E = p.return;
      if (E === null) break;
      var T = E.alternate;
      if (T === null) {
        if (y = E.return, y !== null) {
          p = y;
          continue;
        }
        break;
      }
      if (E.child === T.child) {
        for (T = E.child; T; ) {
          if (T === p) return c(E), l;
          if (T === y) return c(E), d;
          T = T.sibling;
        }
        throw Error(r(188));
      }
      if (p.return !== y.return) p = E, y = T;
      else {
        for (var j = !1, V = E.child; V; ) {
          if (V === p) {
            j = !0, p = E, y = T;
            break;
          }
          if (V === y) {
            j = !0, y = E, p = T;
            break;
          }
          V = V.sibling;
        }
        if (!j) {
          for (V = T.child; V; ) {
            if (V === p) {
              j = !0, p = T, y = E;
              break;
            }
            if (V === y) {
              j = !0, y = T, p = E;
              break;
            }
            V = V.sibling;
          }
          if (!j) throw Error(r(189));
        }
      }
      if (p.alternate !== y) throw Error(r(190));
    }
    if (p.tag !== 3) throw Error(r(188));
    return p.stateNode.current === p ? l : d;
  }
  function f(l) {
    var d = l.tag;
    if (d === 5 || d === 26 || d === 27 || d === 6) return l;
    for (l = l.child; l !== null; ) {
      if (d = f(l), d !== null) return d;
      l = l.sibling;
    }
    return null;
  }
  var h = Object.assign, m = /* @__PURE__ */ Symbol.for("react.element"), g = /* @__PURE__ */ Symbol.for("react.transitional.element"), b = /* @__PURE__ */ Symbol.for("react.portal"), x = /* @__PURE__ */ Symbol.for("react.fragment"), w = /* @__PURE__ */ Symbol.for("react.strict_mode"), S = /* @__PURE__ */ Symbol.for("react.profiler"), _ = /* @__PURE__ */ Symbol.for("react.consumer"), M = /* @__PURE__ */ Symbol.for("react.context"), N = /* @__PURE__ */ Symbol.for("react.forward_ref"), P = /* @__PURE__ */ Symbol.for("react.suspense"), I = /* @__PURE__ */ Symbol.for("react.suspense_list"), O = /* @__PURE__ */ Symbol.for("react.memo"), L = /* @__PURE__ */ Symbol.for("react.lazy"), U = /* @__PURE__ */ Symbol.for("react.activity"), B = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel"), G = Symbol.iterator;
  function Y(l) {
    return l === null || typeof l != "object" ? null : (l = G && l[G] || l["@@iterator"], typeof l == "function" ? l : null);
  }
  var he = /* @__PURE__ */ Symbol.for("react.client.reference");
  function ie(l) {
    if (l == null) return null;
    if (typeof l == "function")
      return l.$$typeof === he ? null : l.displayName || l.name || null;
    if (typeof l == "string") return l;
    switch (l) {
      case x:
        return "Fragment";
      case S:
        return "Profiler";
      case w:
        return "StrictMode";
      case P:
        return "Suspense";
      case I:
        return "SuspenseList";
      case U:
        return "Activity";
    }
    if (typeof l == "object")
      switch (l.$$typeof) {
        case b:
          return "Portal";
        case M:
          return l.displayName || "Context";
        case _:
          return (l._context.displayName || "Context") + ".Consumer";
        case N:
          var d = l.render;
          return l = l.displayName, l || (l = d.displayName || d.name || "", l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"), l;
        case O:
          return d = l.displayName || null, d !== null ? d : ie(l.type) || "Memo";
        case L:
          d = l._payload, l = l._init;
          try {
            return ie(l(d));
          } catch {
          }
      }
    return null;
  }
  var ne = Array.isArray, H = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Q = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, X = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Se = [], W = -1;
  function Z(l) {
    return { current: l };
  }
  function pe(l) {
    0 > W || (l.current = Se[W], Se[W] = null, W--);
  }
  function F(l, d) {
    W++, Se[W] = l.current, l.current = d;
  }
  var ee = Z(null), ge = Z(null), re = Z(null), J = Z(null);
  function xe(l, d) {
    switch (F(re, d), F(ge, l), F(ee, null), d.nodeType) {
      case 9:
      case 11:
        l = (l = d.documentElement) && (l = l.namespaceURI) ? kO(l) : 0;
        break;
      default:
        if (l = d.tagName, d = d.namespaceURI)
          d = kO(d), l = CO(d, l);
        else
          switch (l) {
            case "svg":
              l = 1;
              break;
            case "math":
              l = 2;
              break;
            default:
              l = 0;
          }
    }
    pe(ee), F(ee, l);
  }
  function be() {
    pe(ee), pe(ge), pe(re);
  }
  function Ae(l) {
    l.memoizedState !== null && F(J, l);
    var d = ee.current, p = CO(d, l.type);
    d !== p && (F(ge, l), F(ee, p));
  }
  function tt(l) {
    ge.current === l && (pe(ee), pe(ge)), J.current === l && (pe(J), Bp._currentValue = X);
  }
  var Ge, nt;
  function _t(l) {
    if (Ge === void 0)
      try {
        throw Error();
      } catch (p) {
        var d = p.stack.trim().match(/\n( *(at )?)/);
        Ge = d && d[1] || "", nt = -1 < p.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < p.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + Ge + l + nt;
  }
  var yn = !1;
  function St(l, d) {
    if (!l || yn) return "";
    yn = !0;
    var p = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var y = {
        DetermineComponentFrameRoot: function() {
          try {
            if (d) {
              var Ie = function() {
                throw Error();
              };
              if (Object.defineProperty(Ie.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(Ie, []);
                } catch (Me) {
                  var Te = Me;
                }
                Reflect.construct(l, [], Ie);
              } else {
                try {
                  Ie.call();
                } catch (Me) {
                  Te = Me;
                }
                l.call(Ie.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (Me) {
                Te = Me;
              }
              (Ie = l()) && typeof Ie.catch == "function" && Ie.catch(function() {
              });
            }
          } catch (Me) {
            if (Me && Te && typeof Me.stack == "string")
              return [Me.stack, Te.stack];
          }
          return [null, null];
        }
      };
      y.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var E = Object.getOwnPropertyDescriptor(
        y.DetermineComponentFrameRoot,
        "name"
      );
      E && E.configurable && Object.defineProperty(
        y.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var T = y.DetermineComponentFrameRoot(), j = T[0], V = T[1];
      if (j && V) {
        var te = j.split(`
`), Ee = V.split(`
`);
        for (E = y = 0; y < te.length && !te[y].includes("DetermineComponentFrameRoot"); )
          y++;
        for (; E < Ee.length && !Ee[E].includes(
          "DetermineComponentFrameRoot"
        ); )
          E++;
        if (y === te.length || E === Ee.length)
          for (y = te.length - 1, E = Ee.length - 1; 1 <= y && 0 <= E && te[y] !== Ee[E]; )
            E--;
        for (; 1 <= y && 0 <= E; y--, E--)
          if (te[y] !== Ee[E]) {
            if (y !== 1 || E !== 1)
              do
                if (y--, E--, 0 > E || te[y] !== Ee[E]) {
                  var Oe = `
` + te[y].replace(" at new ", " at ");
                  return l.displayName && Oe.includes("<anonymous>") && (Oe = Oe.replace("<anonymous>", l.displayName)), Oe;
                }
              while (1 <= y && 0 <= E);
            break;
          }
      }
    } finally {
      yn = !1, Error.prepareStackTrace = p;
    }
    return (p = l ? l.displayName || l.name : "") ? _t(p) : "";
  }
  function Vt(l, d) {
    switch (l.tag) {
      case 26:
      case 27:
      case 5:
        return _t(l.type);
      case 16:
        return _t("Lazy");
      case 13:
        return l.child !== d && d !== null ? _t("Suspense Fallback") : _t("Suspense");
      case 19:
        return _t("SuspenseList");
      case 0:
      case 15:
        return St(l.type, !1);
      case 11:
        return St(l.type.render, !1);
      case 1:
        return St(l.type, !0);
      case 31:
        return _t("Activity");
      default:
        return "";
    }
  }
  function xt(l) {
    try {
      var d = "", p = null;
      do
        d += Vt(l, p), p = l, l = l.return;
      while (l);
      return d;
    } catch (y) {
      return `
Error generating stack: ` + y.message + `
` + y.stack;
    }
  }
  var Kt = Object.prototype.hasOwnProperty, An = e.unstable_scheduleCallback, Nt = e.unstable_cancelCallback, sn = e.unstable_shouldYield, Pn = e.unstable_requestPaint, Mn = e.unstable_now, mt = e.unstable_getCurrentPriorityLevel, ke = e.unstable_ImmediatePriority, Pe = e.unstable_UserBlockingPriority, He = e.unstable_NormalPriority, et = e.unstable_LowPriority, bt = e.unstable_IdlePriority, Ct = e.log, fn = e.unstable_setDisableYieldValue, Lt = null, nn = null;
  function jn(l) {
    if (typeof Ct == "function" && fn(l), nn && typeof nn.setStrictMode == "function")
      try {
        nn.setStrictMode(Lt, l);
      } catch {
      }
  }
  var Ve = Math.clz32 ? Math.clz32 : vd, Ii = Math.log, Ar = Math.LN2;
  function vd(l) {
    return l >>>= 0, l === 0 ? 32 : 31 - (Ii(l) / Ar | 0) | 0;
  }
  var Ke = 256, al = 262144, qc = 4194304;
  function Ko(l) {
    var d = l & 42;
    if (d !== 0) return d;
    switch (l & -l) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return l & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return l & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return l;
    }
  }
  function Gc(l, d, p) {
    var y = l.pendingLanes;
    if (y === 0) return 0;
    var E = 0, T = l.suspendedLanes, j = l.pingedLanes;
    l = l.warmLanes;
    var V = y & 134217727;
    return V !== 0 ? (y = V & ~T, y !== 0 ? E = Ko(y) : (j &= V, j !== 0 ? E = Ko(j) : p || (p = V & ~l, p !== 0 && (E = Ko(p))))) : (V = y & ~T, V !== 0 ? E = Ko(V) : j !== 0 ? E = Ko(j) : p || (p = y & ~l, p !== 0 && (E = Ko(p)))), E === 0 ? 0 : d !== 0 && d !== E && (d & T) === 0 && (T = E & -E, p = d & -d, T >= p || T === 32 && (p & 4194048) !== 0) ? d : E;
  }
  function oa(l, d) {
    return (l.pendingLanes & ~(l.suspendedLanes & ~l.pingedLanes) & d) === 0;
  }
  function a1(l, d) {
    switch (l) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return d + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return d + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function ay() {
    var l = qc;
    return qc <<= 1, (qc & 62914560) === 0 && (qc = 4194304), l;
  }
  function ys(l) {
    for (var d = [], p = 0; 31 > p; p++) d.push(l);
    return d;
  }
  function yo(l, d) {
    l.pendingLanes |= d, d !== 268435456 && (l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0);
  }
  function Vh(l, d, p, y, E, T) {
    var j = l.pendingLanes;
    l.pendingLanes = p, l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0, l.expiredLanes &= p, l.entangledLanes &= p, l.errorRecoveryDisabledLanes &= p, l.shellSuspendCounter = 0;
    var V = l.entanglements, te = l.expirationTimes, Ee = l.hiddenUpdates;
    for (p = j & ~p; 0 < p; ) {
      var Oe = 31 - Ve(p), Ie = 1 << Oe;
      V[Oe] = 0, te[Oe] = -1;
      var Te = Ee[Oe];
      if (Te !== null)
        for (Ee[Oe] = null, Oe = 0; Oe < Te.length; Oe++) {
          var Me = Te[Oe];
          Me !== null && (Me.lane &= -536870913);
        }
      p &= ~Ie;
    }
    y !== 0 && Kc(l, y, 0), T !== 0 && E === 0 && l.tag !== 0 && (l.suspendedLanes |= T & ~(j & ~d));
  }
  function Kc(l, d, p) {
    l.pendingLanes |= d, l.suspendedLanes &= ~d;
    var y = 31 - Ve(d);
    l.entangledLanes |= d, l.entanglements[y] = l.entanglements[y] | 1073741824 | p & 261930;
  }
  function kn(l, d) {
    var p = l.entangledLanes |= d;
    for (l = l.entanglements; p; ) {
      var y = 31 - Ve(p), E = 1 << y;
      E & d | l[y] & d && (l[y] |= d), p &= ~E;
    }
  }
  function sr(l, d) {
    var p = d & -d;
    return p = (p & 42) !== 0 ? 1 : Hh(p), (p & (l.suspendedLanes | d)) !== 0 ? 0 : p;
  }
  function Hh(l) {
    switch (l) {
      case 2:
        l = 1;
        break;
      case 8:
        l = 4;
        break;
      case 32:
        l = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        l = 128;
        break;
      case 268435456:
        l = 134217728;
        break;
      default:
        l = 0;
    }
    return l;
  }
  function ll(l) {
    return l &= -l, 2 < l ? 8 < l ? (l & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function Zc() {
    var l = Q.p;
    return l !== 0 ? l : (l = window.event, l === void 0 ? 32 : GO(l.type));
  }
  function Yc(l, d) {
    var p = Q.p;
    try {
      return Q.p = l, d();
    } finally {
      Q.p = p;
    }
  }
  var vs = Math.random().toString(36).slice(2), Nn = "__reactFiber$" + vs, ar = "__reactProps$" + vs, wi = "__reactContainer$" + vs, cl = "__reactEvents$" + vs, l1 = "__reactListeners$" + vs, bs = "__reactHandles$" + vs, Wh = "__reactResources$" + vs, Xi = "__reactMarker$" + vs;
  function bd(l) {
    delete l[Nn], delete l[ar], delete l[cl], delete l[l1], delete l[bs];
  }
  function xs(l) {
    var d = l[Nn];
    if (d) return d;
    for (var p = l.parentNode; p; ) {
      if (d = p[wi] || p[Nn]) {
        if (p = d.alternate, d.child !== null || p !== null && p.child !== null)
          for (l = RO(l); l !== null; ) {
            if (p = l[Nn]) return p;
            l = RO(l);
          }
        return d;
      }
      l = p, p = l.parentNode;
    }
    return null;
  }
  function vn(l) {
    if (l = l[Nn] || l[wi]) {
      var d = l.tag;
      if (d === 5 || d === 6 || d === 13 || d === 31 || d === 26 || d === 27 || d === 3)
        return l;
    }
    return null;
  }
  function Ji(l) {
    var d = l.tag;
    if (d === 5 || d === 26 || d === 27 || d === 6) return l.stateNode;
    throw Error(r(33));
  }
  function si(l) {
    var d = l[Wh];
    return d || (d = l[Wh] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), d;
  }
  function lr(l) {
    l[Xi] = !0;
  }
  var sa = /* @__PURE__ */ new Set(), Xc = {};
  function Zo(l, d) {
    ws(l, d), ws(l + "Capture", d);
  }
  function ws(l, d) {
    for (Xc[l] = d, l = 0; l < d.length; l++)
      sa.add(d[l]);
  }
  var aa = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), qh = {}, Jc = {};
  function ly(l) {
    return Kt.call(Jc, l) ? !0 : Kt.call(qh, l) ? !1 : aa.test(l) ? Jc[l] = !0 : (qh[l] = !0, !1);
  }
  function Pt(l, d, p) {
    if (ly(d))
      if (p === null) l.removeAttribute(d);
      else {
        switch (typeof p) {
          case "undefined":
          case "function":
          case "symbol":
            l.removeAttribute(d);
            return;
          case "boolean":
            var y = d.toLowerCase().slice(0, 5);
            if (y !== "data-" && y !== "aria-") {
              l.removeAttribute(d);
              return;
            }
        }
        l.setAttribute(d, "" + p);
      }
  }
  function Qc(l, d, p) {
    if (p === null) l.removeAttribute(d);
    else {
      switch (typeof p) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          l.removeAttribute(d);
          return;
      }
      l.setAttribute(d, "" + p);
    }
  }
  function vo(l, d, p, y) {
    if (y === null) l.removeAttribute(p);
    else {
      switch (typeof y) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          l.removeAttribute(p);
          return;
      }
      l.setAttributeNS(d, p, "" + y);
    }
  }
  function qr(l) {
    switch (typeof l) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return l;
      case "object":
        return l;
      default:
        return "";
    }
  }
  function ul(l) {
    var d = l.type;
    return (l = l.nodeName) && l.toLowerCase() === "input" && (d === "checkbox" || d === "radio");
  }
  function cy(l, d, p) {
    var y = Object.getOwnPropertyDescriptor(
      l.constructor.prototype,
      d
    );
    if (!l.hasOwnProperty(d) && typeof y < "u" && typeof y.get == "function" && typeof y.set == "function") {
      var E = y.get, T = y.set;
      return Object.defineProperty(l, d, {
        configurable: !0,
        get: function() {
          return E.call(this);
        },
        set: function(j) {
          p = "" + j, T.call(this, j);
        }
      }), Object.defineProperty(l, d, {
        enumerable: y.enumerable
      }), {
        getValue: function() {
          return p;
        },
        setValue: function(j) {
          p = "" + j;
        },
        stopTracking: function() {
          l._valueTracker = null, delete l[d];
        }
      };
    }
  }
  function xd(l) {
    if (!l._valueTracker) {
      var d = ul(l) ? "checked" : "value";
      l._valueTracker = cy(
        l,
        d,
        "" + l[d]
      );
    }
  }
  function Gh(l) {
    if (!l) return !1;
    var d = l._valueTracker;
    if (!d) return !0;
    var p = d.getValue(), y = "";
    return l && (y = ul(l) ? l.checked ? "true" : "false" : l.value), l = y, l !== p ? (d.setValue(l), !0) : !1;
  }
  function an(l) {
    if (l = l || (typeof document < "u" ? document : void 0), typeof l > "u") return null;
    try {
      return l.activeElement || l.body;
    } catch {
      return l.body;
    }
  }
  var eu = /[\n"\\]/g;
  function jr(l) {
    return l.replace(
      eu,
      function(d) {
        return "\\" + d.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Ss(l, d, p, y, E, T, j, V) {
    l.name = "", j != null && typeof j != "function" && typeof j != "symbol" && typeof j != "boolean" ? l.type = j : l.removeAttribute("type"), d != null ? j === "number" ? (d === 0 && l.value === "" || l.value != d) && (l.value = "" + qr(d)) : l.value !== "" + qr(d) && (l.value = "" + qr(d)) : j !== "submit" && j !== "reset" || l.removeAttribute("value"), d != null ? tu(l, j, qr(d)) : p != null ? tu(l, j, qr(p)) : y != null && l.removeAttribute("value"), E == null && T != null && (l.defaultChecked = !!T), E != null && (l.checked = E && typeof E != "function" && typeof E != "symbol"), V != null && typeof V != "function" && typeof V != "symbol" && typeof V != "boolean" ? l.name = "" + qr(V) : l.removeAttribute("name");
  }
  function wd(l, d, p, y, E, T, j, V) {
    if (T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" && (l.type = T), d != null || p != null) {
      if (!(T !== "submit" && T !== "reset" || d != null)) {
        xd(l);
        return;
      }
      p = p != null ? "" + qr(p) : "", d = d != null ? "" + qr(d) : p, V || d === l.value || (l.value = d), l.defaultValue = d;
    }
    y = y ?? E, y = typeof y != "function" && typeof y != "symbol" && !!y, l.checked = V ? l.checked : !!y, l.defaultChecked = !!y, j != null && typeof j != "function" && typeof j != "symbol" && typeof j != "boolean" && (l.name = j), xd(l);
  }
  function tu(l, d, p) {
    d === "number" && an(l.ownerDocument) === l || l.defaultValue === "" + p || (l.defaultValue = "" + p);
  }
  function Yo(l, d, p, y) {
    if (l = l.options, d) {
      d = {};
      for (var E = 0; E < p.length; E++)
        d["$" + p[E]] = !0;
      for (p = 0; p < l.length; p++)
        E = d.hasOwnProperty("$" + l[p].value), l[p].selected !== E && (l[p].selected = E), E && y && (l[p].defaultSelected = !0);
    } else {
      for (p = "" + qr(p), d = null, E = 0; E < l.length; E++) {
        if (l[E].value === p) {
          l[E].selected = !0, y && (l[E].defaultSelected = !0);
          return;
        }
        d !== null || l[E].disabled || (d = l[E]);
      }
      d !== null && (d.selected = !0);
    }
  }
  function Kh(l, d, p) {
    if (d != null && (d = "" + qr(d), d !== l.value && (l.value = d), p == null)) {
      l.defaultValue !== d && (l.defaultValue = d);
      return;
    }
    l.defaultValue = p != null ? "" + qr(p) : "";
  }
  function nu(l, d, p, y) {
    if (d == null) {
      if (y != null) {
        if (p != null) throw Error(r(92));
        if (ne(y)) {
          if (1 < y.length) throw Error(r(93));
          y = y[0];
        }
        p = y;
      }
      p == null && (p = ""), d = p;
    }
    p = qr(d), l.defaultValue = p, y = l.textContent, y === p && y !== "" && y !== null && (l.value = y), xd(l);
  }
  function la(l, d) {
    if (d) {
      var p = l.firstChild;
      if (p && p === l.lastChild && p.nodeType === 3) {
        p.nodeValue = d;
        return;
      }
    }
    l.textContent = d;
  }
  var c1 = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function Jt(l, d, p) {
    var y = d.indexOf("--") === 0;
    p == null || typeof p == "boolean" || p === "" ? y ? l.setProperty(d, "") : d === "float" ? l.cssFloat = "" : l[d] = "" : y ? l.setProperty(d, p) : typeof p != "number" || p === 0 || c1.has(d) ? d === "float" ? l.cssFloat = p : l[d] = ("" + p).trim() : l[d] = p + "px";
  }
  function Zh(l, d, p) {
    if (d != null && typeof d != "object")
      throw Error(r(62));
    if (l = l.style, p != null) {
      for (var y in p)
        !p.hasOwnProperty(y) || d != null && d.hasOwnProperty(y) || (y.indexOf("--") === 0 ? l.setProperty(y, "") : y === "float" ? l.cssFloat = "" : l[y] = "");
      for (var E in d)
        y = d[E], d.hasOwnProperty(E) && p[E] !== y && Jt(l, E, y);
    } else
      for (var T in d)
        d.hasOwnProperty(T) && Jt(l, T, d[T]);
  }
  function Yh(l) {
    if (l.indexOf("-") === -1) return !1;
    switch (l) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var u1 = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), Si = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Xo(l) {
    return Si.test("" + l) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : l;
  }
  function zi() {
  }
  var bo = null;
  function Sd(l) {
    return l = l.target || l.srcElement || window, l.correspondingUseElement && (l = l.correspondingUseElement), l.nodeType === 3 ? l.parentNode : l;
  }
  var ca = null, In = null;
  function Qi(l) {
    var d = vn(l);
    if (d && (l = d.stateNode)) {
      var p = l[ar] || null;
      e: switch (l = d.stateNode, d.type) {
        case "input":
          if (Ss(
            l,
            p.value,
            p.defaultValue,
            p.defaultValue,
            p.checked,
            p.defaultChecked,
            p.type,
            p.name
          ), d = p.name, p.type === "radio" && d != null) {
            for (p = l; p.parentNode; ) p = p.parentNode;
            for (p = p.querySelectorAll(
              'input[name="' + jr(
                "" + d
              ) + '"][type="radio"]'
            ), d = 0; d < p.length; d++) {
              var y = p[d];
              if (y !== l && y.form === l.form) {
                var E = y[ar] || null;
                if (!E) throw Error(r(90));
                Ss(
                  y,
                  E.value,
                  E.defaultValue,
                  E.defaultValue,
                  E.checked,
                  E.defaultChecked,
                  E.type,
                  E.name
                );
              }
            }
            for (d = 0; d < p.length; d++)
              y = p[d], y.form === l.form && Gh(y);
          }
          break e;
        case "textarea":
          Kh(l, p.value, p.defaultValue);
          break e;
        case "select":
          d = p.value, d != null && Yo(l, !!p.multiple, d, !1);
      }
    }
  }
  var ua = !1;
  function dl(l, d, p) {
    if (ua) return l(d, p);
    ua = !0;
    try {
      var y = l(d);
      return y;
    } finally {
      if (ua = !1, (ca !== null || In !== null) && (Jy(), ca && (d = ca, l = In, In = ca = null, Qi(d), l)))
        for (d = 0; d < l.length; d++) Qi(l[d]);
    }
  }
  function da(l, d) {
    var p = l.stateNode;
    if (p === null) return null;
    var y = p[ar] || null;
    if (y === null) return null;
    p = y[d];
    e: switch (d) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (y = !y.disabled) || (l = l.type, y = !(l === "button" || l === "input" || l === "select" || l === "textarea")), l = !y;
        break e;
      default:
        l = !1;
    }
    if (l) return null;
    if (p && typeof p != "function")
      throw Error(
        r(231, d, typeof p)
      );
    return p;
  }
  var Ir = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Xh = !1;
  if (Ir)
    try {
      var ai = {};
      Object.defineProperty(ai, "passive", {
        get: function() {
          Xh = !0;
        }
      }), window.addEventListener("test", ai, ai), window.removeEventListener("test", ai, ai);
    } catch {
      Xh = !1;
    }
  var xo = null, kd = null, fl = null;
  function hl() {
    if (fl) return fl;
    var l, d = kd, p = d.length, y, E = "value" in xo ? xo.value : xo.textContent, T = E.length;
    for (l = 0; l < p && d[l] === E[l]; l++) ;
    var j = p - l;
    for (y = 1; y <= j && d[p - y] === E[T - y]; y++) ;
    return fl = E.slice(l, 1 < y ? 1 - y : void 0);
  }
  function pl(l) {
    var d = l.keyCode;
    return "charCode" in l ? (l = l.charCode, l === 0 && d === 13 && (l = 13)) : l = d, l === 10 && (l = 13), 32 <= l || l === 13 ? l : 0;
  }
  function ru() {
    return !0;
  }
  function uy() {
    return !1;
  }
  function pr(l) {
    function d(p, y, E, T, j) {
      this._reactName = p, this._targetInst = E, this.type = y, this.nativeEvent = T, this.target = j, this.currentTarget = null;
      for (var V in l)
        l.hasOwnProperty(V) && (p = l[V], this[V] = p ? p(T) : T[V]);
      return this.isDefaultPrevented = (T.defaultPrevented != null ? T.defaultPrevented : T.returnValue === !1) ? ru : uy, this.isPropagationStopped = uy, this;
    }
    return h(d.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var p = this.nativeEvent;
        p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1), this.isDefaultPrevented = ru);
      },
      stopPropagation: function() {
        var p = this.nativeEvent;
        p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0), this.isPropagationStopped = ru);
      },
      persist: function() {
      },
      isPersistent: ru
    }), d;
  }
  var fa = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(l) {
      return l.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Cd = pr(fa), ks = h({}, fa, { view: 0, detail: 0 }), Ed = pr(ks), iu, Jh, ou, _d = h({}, ks, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: ha,
    button: 0,
    buttons: 0,
    relatedTarget: function(l) {
      return l.relatedTarget === void 0 ? l.fromElement === l.srcElement ? l.toElement : l.fromElement : l.relatedTarget;
    },
    movementX: function(l) {
      return "movementX" in l ? l.movementX : (l !== ou && (ou && l.type === "mousemove" ? (iu = l.screenX - ou.screenX, Jh = l.screenY - ou.screenY) : Jh = iu = 0, ou = l), iu);
    },
    movementY: function(l) {
      return "movementY" in l ? l.movementY : Jh;
    }
  }), Td = pr(_d), Qh = h({}, _d, { dataTransfer: 0 }), dy = pr(Qh), Ad = h({}, ks, { relatedTarget: 0 }), ml = pr(Ad), Md = h({}, fa, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), fy = pr(Md), d1 = h({}, fa, {
    clipboardData: function(l) {
      return "clipboardData" in l ? l.clipboardData : window.clipboardData;
    }
  }), gl = pr(d1), ep = h({}, fa, { data: 0 }), Nd = pr(ep), tp = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, np = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, zr = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function su(l) {
    var d = this.nativeEvent;
    return d.getModifierState ? d.getModifierState(l) : (l = zr[l]) ? !!d[l] : !1;
  }
  function ha() {
    return su;
  }
  var hy = h({}, ks, {
    key: function(l) {
      if (l.key) {
        var d = tp[l.key] || l.key;
        if (d !== "Unidentified") return d;
      }
      return l.type === "keypress" ? (l = pl(l), l === 13 ? "Enter" : String.fromCharCode(l)) : l.type === "keydown" || l.type === "keyup" ? np[l.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: ha,
    charCode: function(l) {
      return l.type === "keypress" ? pl(l) : 0;
    },
    keyCode: function(l) {
      return l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
    },
    which: function(l) {
      return l.type === "keypress" ? pl(l) : l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
    }
  }), Rd = pr(hy), py = h({}, _d, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), rp = pr(py), Od = h({}, ks, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: ha
  }), ip = pr(Od), pa = h({}, fa, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), op = pr(pa), sp = h({}, _d, {
    deltaX: function(l) {
      return "deltaX" in l ? l.deltaX : "wheelDeltaX" in l ? -l.wheelDeltaX : 0;
    },
    deltaY: function(l) {
      return "deltaY" in l ? l.deltaY : "wheelDeltaY" in l ? -l.wheelDeltaY : "wheelDelta" in l ? -l.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Dd = pr(sp), ap = h({}, fa, {
    newState: 0,
    oldState: 0
  }), my = pr(ap), f1 = [9, 13, 27, 32], au = Ir && "CompositionEvent" in window, Cs = null;
  Ir && "documentMode" in document && (Cs = document.documentMode);
  var h1 = Ir && "TextEvent" in window && !Cs, Pd = Ir && (!au || Cs && 8 < Cs && 11 >= Cs), jd = " ", gy = !1;
  function lp(l, d) {
    switch (l) {
      case "keyup":
        return f1.indexOf(d.keyCode) !== -1;
      case "keydown":
        return d.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function yy(l) {
    return l = l.detail, typeof l == "object" && "data" in l ? l.data : null;
  }
  var ma = !1;
  function vy(l, d) {
    switch (l) {
      case "compositionend":
        return yy(d);
      case "keypress":
        return d.which !== 32 ? null : (gy = !0, jd);
      case "textInput":
        return l = d.data, l === jd && gy ? null : l;
      default:
        return null;
    }
  }
  function p1(l, d) {
    if (ma)
      return l === "compositionend" || !au && lp(l, d) ? (l = hl(), fl = kd = xo = null, ma = !1, l) : null;
    switch (l) {
      case "paste":
        return null;
      case "keypress":
        if (!(d.ctrlKey || d.altKey || d.metaKey) || d.ctrlKey && d.altKey) {
          if (d.char && 1 < d.char.length)
            return d.char;
          if (d.which) return String.fromCharCode(d.which);
        }
        return null;
      case "compositionend":
        return Pd && d.locale !== "ko" ? null : d.data;
      default:
        return null;
    }
  }
  var by = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Id(l) {
    var d = l && l.nodeName && l.nodeName.toLowerCase();
    return d === "input" ? !!by[l.type] : d === "textarea";
  }
  function cp(l, d, p, y) {
    ca ? In ? In.push(y) : In = [y] : ca = y, d = ov(d, "onChange"), 0 < d.length && (p = new Cd(
      "onChange",
      "change",
      null,
      p,
      y
    ), l.push({ event: p, listeners: d }));
  }
  var yl = null, lu = null;
  function m1(l) {
    yO(l, 0);
  }
  function zd(l) {
    var d = Ji(l);
    if (Gh(d)) return l;
  }
  function cu(l, d) {
    if (l === "change") return d;
  }
  var wo = !1;
  if (Ir) {
    var zn;
    if (Ir) {
      var vl = "oninput" in document;
      if (!vl) {
        var ga = document.createElement("div");
        ga.setAttribute("oninput", "return;"), vl = typeof ga.oninput == "function";
      }
      zn = vl;
    } else zn = !1;
    wo = zn && (!document.documentMode || 9 < document.documentMode);
  }
  function xy() {
    yl && (yl.detachEvent("onpropertychange", Ld), lu = yl = null);
  }
  function Ld(l) {
    if (l.propertyName === "value" && zd(lu)) {
      var d = [];
      cp(
        d,
        lu,
        l,
        Sd(l)
      ), dl(m1, d);
    }
  }
  function wy(l, d, p) {
    l === "focusin" ? (xy(), yl = d, lu = p, yl.attachEvent("onpropertychange", Ld)) : l === "focusout" && xy();
  }
  function ya(l) {
    if (l === "selectionchange" || l === "keyup" || l === "keydown")
      return zd(lu);
  }
  function up(l, d) {
    if (l === "click") return zd(d);
  }
  function bl(l, d) {
    if (l === "input" || l === "change")
      return zd(d);
  }
  function Es(l, d) {
    return l === d && (l !== 0 || 1 / l === 1 / d) || l !== l && d !== d;
  }
  var li = typeof Object.is == "function" ? Object.is : Es;
  function C(l, d) {
    if (li(l, d)) return !0;
    if (typeof l != "object" || l === null || typeof d != "object" || d === null)
      return !1;
    var p = Object.keys(l), y = Object.keys(d);
    if (p.length !== y.length) return !1;
    for (y = 0; y < p.length; y++) {
      var E = p[y];
      if (!Kt.call(d, E) || !li(l[E], d[E]))
        return !1;
    }
    return !0;
  }
  function A(l) {
    for (; l && l.firstChild; ) l = l.firstChild;
    return l;
  }
  function R(l, d) {
    var p = A(l);
    l = 0;
    for (var y; p; ) {
      if (p.nodeType === 3) {
        if (y = l + p.textContent.length, l <= d && y >= d)
          return { node: p, offset: d - l };
        l = y;
      }
      e: {
        for (; p; ) {
          if (p.nextSibling) {
            p = p.nextSibling;
            break e;
          }
          p = p.parentNode;
        }
        p = void 0;
      }
      p = A(p);
    }
  }
  function D(l, d) {
    return l && d ? l === d ? !0 : l && l.nodeType === 3 ? !1 : d && d.nodeType === 3 ? D(l, d.parentNode) : "contains" in l ? l.contains(d) : l.compareDocumentPosition ? !!(l.compareDocumentPosition(d) & 16) : !1 : !1;
  }
  function z(l) {
    l = l != null && l.ownerDocument != null && l.ownerDocument.defaultView != null ? l.ownerDocument.defaultView : window;
    for (var d = an(l.document); d instanceof l.HTMLIFrameElement; ) {
      try {
        var p = typeof d.contentWindow.location.href == "string";
      } catch {
        p = !1;
      }
      if (p) l = d.contentWindow;
      else break;
      d = an(l.document);
    }
    return d;
  }
  function $(l) {
    var d = l && l.nodeName && l.nodeName.toLowerCase();
    return d && (d === "input" && (l.type === "text" || l.type === "search" || l.type === "tel" || l.type === "url" || l.type === "password") || d === "textarea" || l.contentEditable === "true");
  }
  var q = Ir && "documentMode" in document && 11 >= document.documentMode, K = null, se = null, ye = null, ae = !1;
  function oe(l, d, p) {
    var y = p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
    ae || K == null || K !== an(y) || (y = K, "selectionStart" in y && $(y) ? y = { start: y.selectionStart, end: y.selectionEnd } : (y = (y.ownerDocument && y.ownerDocument.defaultView || window).getSelection(), y = {
      anchorNode: y.anchorNode,
      anchorOffset: y.anchorOffset,
      focusNode: y.focusNode,
      focusOffset: y.focusOffset
    }), ye && C(ye, y) || (ye = y, y = ov(se, "onSelect"), 0 < y.length && (d = new Cd(
      "onSelect",
      "select",
      null,
      d,
      p
    ), l.push({ event: d, listeners: y }), d.target = K)));
  }
  function ue(l, d) {
    var p = {};
    return p[l.toLowerCase()] = d.toLowerCase(), p["Webkit" + l] = "webkit" + d, p["Moz" + l] = "moz" + d, p;
  }
  var fe = {
    animationend: ue("Animation", "AnimationEnd"),
    animationiteration: ue("Animation", "AnimationIteration"),
    animationstart: ue("Animation", "AnimationStart"),
    transitionrun: ue("Transition", "TransitionRun"),
    transitionstart: ue("Transition", "TransitionStart"),
    transitioncancel: ue("Transition", "TransitionCancel"),
    transitionend: ue("Transition", "TransitionEnd")
  }, le = {}, ce = {};
  Ir && (ce = document.createElement("div").style, "AnimationEvent" in window || (delete fe.animationend.animation, delete fe.animationiteration.animation, delete fe.animationstart.animation), "TransitionEvent" in window || delete fe.transitionend.transition);
  function we(l) {
    if (le[l]) return le[l];
    if (!fe[l]) return l;
    var d = fe[l], p;
    for (p in d)
      if (d.hasOwnProperty(p) && p in ce)
        return le[l] = d[p];
    return l;
  }
  var _e = we("animationend"), ve = we("animationiteration"), Re = we("animationstart"), ze = we("transitionrun"), We = we("transitionstart"), qe = we("transitioncancel"), Le = we("transitionend"), Xe = /* @__PURE__ */ new Map(), Ze = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Ze.push("scrollEnd");
  function Be(l, d) {
    Xe.set(l, d), Zo(d, [l]);
  }
  var Je = typeof reportError == "function" ? reportError : function(l) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var d = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof l == "object" && l !== null && typeof l.message == "string" ? String(l.message) : String(l),
        error: l
      });
      if (!window.dispatchEvent(d)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", l);
      return;
    }
    console.error(l);
  }, wt = [], Bt = 0, dt = 0;
  function Tt() {
    for (var l = Bt, d = dt = Bt = 0; d < l; ) {
      var p = wt[d];
      wt[d++] = null;
      var y = wt[d];
      wt[d++] = null;
      var E = wt[d];
      wt[d++] = null;
      var T = wt[d];
      if (wt[d++] = null, y !== null && E !== null) {
        var j = y.pending;
        j === null ? E.next = E : (E.next = j.next, j.next = E), y.pending = E;
      }
      T !== 0 && _s(p, E, T);
    }
  }
  function bn(l, d, p, y) {
    wt[Bt++] = l, wt[Bt++] = d, wt[Bt++] = p, wt[Bt++] = y, dt |= y, l.lanes |= y, l = l.alternate, l !== null && (l.lanes |= y);
  }
  function ci(l, d, p, y) {
    return bn(l, d, p, y), xl(l);
  }
  function un(l, d) {
    return bn(l, null, null, d), xl(l);
  }
  function _s(l, d, p) {
    l.lanes |= p;
    var y = l.alternate;
    y !== null && (y.lanes |= p);
    for (var E = !1, T = l.return; T !== null; )
      T.childLanes |= p, y = T.alternate, y !== null && (y.childLanes |= p), T.tag === 22 && (l = T.stateNode, l === null || l._visibility & 1 || (E = !0)), l = T, T = T.return;
    return l.tag === 3 ? (T = l.stateNode, E && d !== null && (E = 31 - Ve(p), l = T.hiddenUpdates, y = l[E], y === null ? l[E] = [d] : y.push(d), d.lane = p | 536870912), T) : null;
  }
  function xl(l) {
    if (50 < Op)
      throw Op = 0, CS = null, Error(r(185));
    for (var d = l.return; d !== null; )
      l = d, d = l.return;
    return l.tag === 3 ? l.stateNode : null;
  }
  var Bd = {};
  function lG(l, d, p, y) {
    this.tag = l, this.key = p, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = d, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = y, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function eo(l, d, p, y) {
    return new lG(l, d, p, y);
  }
  function g1(l) {
    return l = l.prototype, !(!l || !l.isReactComponent);
  }
  function va(l, d) {
    var p = l.alternate;
    return p === null ? (p = eo(
      l.tag,
      d,
      l.key,
      l.mode
    ), p.elementType = l.elementType, p.type = l.type, p.stateNode = l.stateNode, p.alternate = l, l.alternate = p) : (p.pendingProps = d, p.type = l.type, p.flags = 0, p.subtreeFlags = 0, p.deletions = null), p.flags = l.flags & 65011712, p.childLanes = l.childLanes, p.lanes = l.lanes, p.child = l.child, p.memoizedProps = l.memoizedProps, p.memoizedState = l.memoizedState, p.updateQueue = l.updateQueue, d = l.dependencies, p.dependencies = d === null ? null : { lanes: d.lanes, firstContext: d.firstContext }, p.sibling = l.sibling, p.index = l.index, p.ref = l.ref, p.refCleanup = l.refCleanup, p;
  }
  function QN(l, d) {
    l.flags &= 65011714;
    var p = l.alternate;
    return p === null ? (l.childLanes = 0, l.lanes = d, l.child = null, l.subtreeFlags = 0, l.memoizedProps = null, l.memoizedState = null, l.updateQueue = null, l.dependencies = null, l.stateNode = null) : (l.childLanes = p.childLanes, l.lanes = p.lanes, l.child = p.child, l.subtreeFlags = 0, l.deletions = null, l.memoizedProps = p.memoizedProps, l.memoizedState = p.memoizedState, l.updateQueue = p.updateQueue, l.type = p.type, d = p.dependencies, l.dependencies = d === null ? null : {
      lanes: d.lanes,
      firstContext: d.firstContext
    }), l;
  }
  function Sy(l, d, p, y, E, T) {
    var j = 0;
    if (y = l, typeof l == "function") g1(l) && (j = 1);
    else if (typeof l == "string")
      j = hK(
        l,
        p,
        ee.current
      ) ? 26 : l === "html" || l === "head" || l === "body" ? 27 : 5;
    else
      e: switch (l) {
        case U:
          return l = eo(31, p, d, E), l.elementType = U, l.lanes = T, l;
        case x:
          return uu(p.children, E, T, d);
        case w:
          j = 8, E |= 24;
          break;
        case S:
          return l = eo(12, p, d, E | 2), l.elementType = S, l.lanes = T, l;
        case P:
          return l = eo(13, p, d, E), l.elementType = P, l.lanes = T, l;
        case I:
          return l = eo(19, p, d, E), l.elementType = I, l.lanes = T, l;
        default:
          if (typeof l == "object" && l !== null)
            switch (l.$$typeof) {
              case M:
                j = 10;
                break e;
              case _:
                j = 9;
                break e;
              case N:
                j = 11;
                break e;
              case O:
                j = 14;
                break e;
              case L:
                j = 16, y = null;
                break e;
            }
          j = 29, p = Error(
            r(130, l === null ? "null" : typeof l, "")
          ), y = null;
      }
    return d = eo(j, p, d, E), d.elementType = l, d.type = y, d.lanes = T, d;
  }
  function uu(l, d, p, y) {
    return l = eo(7, l, y, d), l.lanes = p, l;
  }
  function y1(l, d, p) {
    return l = eo(6, l, null, d), l.lanes = p, l;
  }
  function eR(l) {
    var d = eo(18, null, null, 0);
    return d.stateNode = l, d;
  }
  function v1(l, d, p) {
    return d = eo(
      4,
      l.children !== null ? l.children : [],
      l.key,
      d
    ), d.lanes = p, d.stateNode = {
      containerInfo: l.containerInfo,
      pendingChildren: null,
      implementation: l.implementation
    }, d;
  }
  var tR = /* @__PURE__ */ new WeakMap();
  function So(l, d) {
    if (typeof l == "object" && l !== null) {
      var p = tR.get(l);
      return p !== void 0 ? p : (d = {
        value: l,
        source: d,
        stack: xt(d)
      }, tR.set(l, d), d);
    }
    return {
      value: l,
      source: d,
      stack: xt(d)
    };
  }
  var $d = [], Ud = 0, ky = null, dp = 0, ko = [], Co = 0, wl = null, Ts = 1, As = "";
  function ba(l, d) {
    $d[Ud++] = dp, $d[Ud++] = ky, ky = l, dp = d;
  }
  function nR(l, d, p) {
    ko[Co++] = Ts, ko[Co++] = As, ko[Co++] = wl, wl = l;
    var y = Ts;
    l = As;
    var E = 32 - Ve(y) - 1;
    y &= ~(1 << E), p += 1;
    var T = 32 - Ve(d) + E;
    if (30 < T) {
      var j = E - E % 5;
      T = (y & (1 << j) - 1).toString(32), y >>= j, E -= j, Ts = 1 << 32 - Ve(d) + E | p << E | y, As = T + l;
    } else
      Ts = 1 << T | p << E | y, As = l;
  }
  function b1(l) {
    l.return !== null && (ba(l, 1), nR(l, 1, 0));
  }
  function x1(l) {
    for (; l === ky; )
      ky = $d[--Ud], $d[Ud] = null, dp = $d[--Ud], $d[Ud] = null;
    for (; l === wl; )
      wl = ko[--Co], ko[Co] = null, As = ko[--Co], ko[Co] = null, Ts = ko[--Co], ko[Co] = null;
  }
  function rR(l, d) {
    ko[Co++] = Ts, ko[Co++] = As, ko[Co++] = wl, Ts = d.id, As = d.overflow, wl = l;
  }
  var Gr = null, Ln = null, Qt = !1, Sl = null, Eo = !1, w1 = Error(r(519));
  function kl(l) {
    var d = Error(
      r(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    throw fp(So(d, l)), w1;
  }
  function iR(l) {
    var d = l.stateNode, p = l.type, y = l.memoizedProps;
    switch (d[Nn] = l, d[ar] = y, p) {
      case "dialog":
        qt("cancel", d), qt("close", d);
        break;
      case "iframe":
      case "object":
      case "embed":
        qt("load", d);
        break;
      case "video":
      case "audio":
        for (p = 0; p < Pp.length; p++)
          qt(Pp[p], d);
        break;
      case "source":
        qt("error", d);
        break;
      case "img":
      case "image":
      case "link":
        qt("error", d), qt("load", d);
        break;
      case "details":
        qt("toggle", d);
        break;
      case "input":
        qt("invalid", d), wd(
          d,
          y.value,
          y.defaultValue,
          y.checked,
          y.defaultChecked,
          y.type,
          y.name,
          !0
        );
        break;
      case "select":
        qt("invalid", d);
        break;
      case "textarea":
        qt("invalid", d), nu(d, y.value, y.defaultValue, y.children);
    }
    p = y.children, typeof p != "string" && typeof p != "number" && typeof p != "bigint" || d.textContent === "" + p || y.suppressHydrationWarning === !0 || wO(d.textContent, p) ? (y.popover != null && (qt("beforetoggle", d), qt("toggle", d)), y.onScroll != null && qt("scroll", d), y.onScrollEnd != null && qt("scrollend", d), y.onClick != null && (d.onclick = zi), d = !0) : d = !1, d || kl(l, !0);
  }
  function oR(l) {
    for (Gr = l.return; Gr; )
      switch (Gr.tag) {
        case 5:
        case 31:
        case 13:
          Eo = !1;
          return;
        case 27:
        case 3:
          Eo = !0;
          return;
        default:
          Gr = Gr.return;
      }
  }
  function Fd(l) {
    if (l !== Gr) return !1;
    if (!Qt) return oR(l), Qt = !0, !1;
    var d = l.tag, p;
    if ((p = d !== 3 && d !== 27) && ((p = d === 5) && (p = l.type, p = !(p !== "form" && p !== "button") || BS(l.type, l.memoizedProps)), p = !p), p && Ln && kl(l), oR(l), d === 13) {
      if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(317));
      Ln = NO(l);
    } else if (d === 31) {
      if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(317));
      Ln = NO(l);
    } else
      d === 27 ? (d = Ln, zl(l.type) ? (l = HS, HS = null, Ln = l) : Ln = d) : Ln = Gr ? To(l.stateNode.nextSibling) : null;
    return !0;
  }
  function du() {
    Ln = Gr = null, Qt = !1;
  }
  function S1() {
    var l = Sl;
    return l !== null && (Ui === null ? Ui = l : Ui.push.apply(
      Ui,
      l
    ), Sl = null), l;
  }
  function fp(l) {
    Sl === null ? Sl = [l] : Sl.push(l);
  }
  var k1 = Z(null), fu = null, xa = null;
  function Cl(l, d, p) {
    F(k1, d._currentValue), d._currentValue = p;
  }
  function wa(l) {
    l._currentValue = k1.current, pe(k1);
  }
  function C1(l, d, p) {
    for (; l !== null; ) {
      var y = l.alternate;
      if ((l.childLanes & d) !== d ? (l.childLanes |= d, y !== null && (y.childLanes |= d)) : y !== null && (y.childLanes & d) !== d && (y.childLanes |= d), l === p) break;
      l = l.return;
    }
  }
  function E1(l, d, p, y) {
    var E = l.child;
    for (E !== null && (E.return = l); E !== null; ) {
      var T = E.dependencies;
      if (T !== null) {
        var j = E.child;
        T = T.firstContext;
        e: for (; T !== null; ) {
          var V = T;
          T = E;
          for (var te = 0; te < d.length; te++)
            if (V.context === d[te]) {
              T.lanes |= p, V = T.alternate, V !== null && (V.lanes |= p), C1(
                T.return,
                p,
                l
              ), y || (j = null);
              break e;
            }
          T = V.next;
        }
      } else if (E.tag === 18) {
        if (j = E.return, j === null) throw Error(r(341));
        j.lanes |= p, T = j.alternate, T !== null && (T.lanes |= p), C1(j, p, l), j = null;
      } else j = E.child;
      if (j !== null) j.return = E;
      else
        for (j = E; j !== null; ) {
          if (j === l) {
            j = null;
            break;
          }
          if (E = j.sibling, E !== null) {
            E.return = j.return, j = E;
            break;
          }
          j = j.return;
        }
      E = j;
    }
  }
  function Vd(l, d, p, y) {
    l = null;
    for (var E = d, T = !1; E !== null; ) {
      if (!T) {
        if ((E.flags & 524288) !== 0) T = !0;
        else if ((E.flags & 262144) !== 0) break;
      }
      if (E.tag === 10) {
        var j = E.alternate;
        if (j === null) throw Error(r(387));
        if (j = j.memoizedProps, j !== null) {
          var V = E.type;
          li(E.pendingProps.value, j.value) || (l !== null ? l.push(V) : l = [V]);
        }
      } else if (E === J.current) {
        if (j = E.alternate, j === null) throw Error(r(387));
        j.memoizedState.memoizedState !== E.memoizedState.memoizedState && (l !== null ? l.push(Bp) : l = [Bp]);
      }
      E = E.return;
    }
    l !== null && E1(
      d,
      l,
      p,
      y
    ), d.flags |= 262144;
  }
  function Cy(l) {
    for (l = l.firstContext; l !== null; ) {
      if (!li(
        l.context._currentValue,
        l.memoizedValue
      ))
        return !0;
      l = l.next;
    }
    return !1;
  }
  function hu(l) {
    fu = l, xa = null, l = l.dependencies, l !== null && (l.firstContext = null);
  }
  function Kr(l) {
    return sR(fu, l);
  }
  function Ey(l, d) {
    return fu === null && hu(l), sR(l, d);
  }
  function sR(l, d) {
    var p = d._currentValue;
    if (d = { context: d, memoizedValue: p, next: null }, xa === null) {
      if (l === null) throw Error(r(308));
      xa = d, l.dependencies = { lanes: 0, firstContext: d }, l.flags |= 524288;
    } else xa = xa.next = d;
    return p;
  }
  var cG = typeof AbortController < "u" ? AbortController : function() {
    var l = [], d = this.signal = {
      aborted: !1,
      addEventListener: function(p, y) {
        l.push(y);
      }
    };
    this.abort = function() {
      d.aborted = !0, l.forEach(function(p) {
        return p();
      });
    };
  }, uG = e.unstable_scheduleCallback, dG = e.unstable_NormalPriority, mr = {
    $$typeof: M,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function _1() {
    return {
      controller: new cG(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function hp(l) {
    l.refCount--, l.refCount === 0 && uG(dG, function() {
      l.controller.abort();
    });
  }
  var pp = null, T1 = 0, Hd = 0, Wd = null;
  function fG(l, d) {
    if (pp === null) {
      var p = pp = [];
      T1 = 0, Hd = NS(), Wd = {
        status: "pending",
        value: void 0,
        then: function(y) {
          p.push(y);
        }
      };
    }
    return T1++, d.then(aR, aR), d;
  }
  function aR() {
    if (--T1 === 0 && pp !== null) {
      Wd !== null && (Wd.status = "fulfilled");
      var l = pp;
      pp = null, Hd = 0, Wd = null;
      for (var d = 0; d < l.length; d++) (0, l[d])();
    }
  }
  function hG(l, d) {
    var p = [], y = {
      status: "pending",
      value: null,
      reason: null,
      then: function(E) {
        p.push(E);
      }
    };
    return l.then(
      function() {
        y.status = "fulfilled", y.value = d;
        for (var E = 0; E < p.length; E++) (0, p[E])(d);
      },
      function(E) {
        for (y.status = "rejected", y.reason = E, E = 0; E < p.length; E++)
          (0, p[E])(void 0);
      }
    ), y;
  }
  var lR = H.S;
  H.S = function(l, d) {
    W2 = Mn(), typeof d == "object" && d !== null && typeof d.then == "function" && fG(l, d), lR !== null && lR(l, d);
  };
  var pu = Z(null);
  function A1() {
    var l = pu.current;
    return l !== null ? l : Cn.pooledCache;
  }
  function _y(l, d) {
    d === null ? F(pu, pu.current) : F(pu, d.pool);
  }
  function cR() {
    var l = A1();
    return l === null ? null : { parent: mr._currentValue, pool: l };
  }
  var qd = Error(r(460)), M1 = Error(r(474)), Ty = Error(r(542)), Ay = { then: function() {
  } };
  function uR(l) {
    return l = l.status, l === "fulfilled" || l === "rejected";
  }
  function dR(l, d, p) {
    switch (p = l[p], p === void 0 ? l.push(d) : p !== d && (d.then(zi, zi), d = p), d.status) {
      case "fulfilled":
        return d.value;
      case "rejected":
        throw l = d.reason, hR(l), l;
      default:
        if (typeof d.status == "string") d.then(zi, zi);
        else {
          if (l = Cn, l !== null && 100 < l.shellSuspendCounter)
            throw Error(r(482));
          l = d, l.status = "pending", l.then(
            function(y) {
              if (d.status === "pending") {
                var E = d;
                E.status = "fulfilled", E.value = y;
              }
            },
            function(y) {
              if (d.status === "pending") {
                var E = d;
                E.status = "rejected", E.reason = y;
              }
            }
          );
        }
        switch (d.status) {
          case "fulfilled":
            return d.value;
          case "rejected":
            throw l = d.reason, hR(l), l;
        }
        throw gu = d, qd;
    }
  }
  function mu(l) {
    try {
      var d = l._init;
      return d(l._payload);
    } catch (p) {
      throw p !== null && typeof p == "object" && typeof p.then == "function" ? (gu = p, qd) : p;
    }
  }
  var gu = null;
  function fR() {
    if (gu === null) throw Error(r(459));
    var l = gu;
    return gu = null, l;
  }
  function hR(l) {
    if (l === qd || l === Ty)
      throw Error(r(483));
  }
  var Gd = null, mp = 0;
  function My(l) {
    var d = mp;
    return mp += 1, Gd === null && (Gd = []), dR(Gd, l, d);
  }
  function gp(l, d) {
    d = d.props.ref, l.ref = d !== void 0 ? d : null;
  }
  function Ny(l, d) {
    throw d.$$typeof === m ? Error(r(525)) : (l = Object.prototype.toString.call(d), Error(
      r(
        31,
        l === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : l
      )
    ));
  }
  function pR(l) {
    function d(me, de) {
      if (l) {
        var Ce = me.deletions;
        Ce === null ? (me.deletions = [de], me.flags |= 16) : Ce.push(de);
      }
    }
    function p(me, de) {
      if (!l) return null;
      for (; de !== null; )
        d(me, de), de = de.sibling;
      return null;
    }
    function y(me) {
      for (var de = /* @__PURE__ */ new Map(); me !== null; )
        me.key !== null ? de.set(me.key, me) : de.set(me.index, me), me = me.sibling;
      return de;
    }
    function E(me, de) {
      return me = va(me, de), me.index = 0, me.sibling = null, me;
    }
    function T(me, de, Ce) {
      return me.index = Ce, l ? (Ce = me.alternate, Ce !== null ? (Ce = Ce.index, Ce < de ? (me.flags |= 67108866, de) : Ce) : (me.flags |= 67108866, de)) : (me.flags |= 1048576, de);
    }
    function j(me) {
      return l && me.alternate === null && (me.flags |= 67108866), me;
    }
    function V(me, de, Ce, je) {
      return de === null || de.tag !== 6 ? (de = y1(Ce, me.mode, je), de.return = me, de) : (de = E(de, Ce), de.return = me, de);
    }
    function te(me, de, Ce, je) {
      var pt = Ce.type;
      return pt === x ? Oe(
        me,
        de,
        Ce.props.children,
        je,
        Ce.key
      ) : de !== null && (de.elementType === pt || typeof pt == "object" && pt !== null && pt.$$typeof === L && mu(pt) === de.type) ? (de = E(de, Ce.props), gp(de, Ce), de.return = me, de) : (de = Sy(
        Ce.type,
        Ce.key,
        Ce.props,
        null,
        me.mode,
        je
      ), gp(de, Ce), de.return = me, de);
    }
    function Ee(me, de, Ce, je) {
      return de === null || de.tag !== 4 || de.stateNode.containerInfo !== Ce.containerInfo || de.stateNode.implementation !== Ce.implementation ? (de = v1(Ce, me.mode, je), de.return = me, de) : (de = E(de, Ce.children || []), de.return = me, de);
    }
    function Oe(me, de, Ce, je, pt) {
      return de === null || de.tag !== 7 ? (de = uu(
        Ce,
        me.mode,
        je,
        pt
      ), de.return = me, de) : (de = E(de, Ce), de.return = me, de);
    }
    function Ie(me, de, Ce) {
      if (typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint")
        return de = y1(
          "" + de,
          me.mode,
          Ce
        ), de.return = me, de;
      if (typeof de == "object" && de !== null) {
        switch (de.$$typeof) {
          case g:
            return Ce = Sy(
              de.type,
              de.key,
              de.props,
              null,
              me.mode,
              Ce
            ), gp(Ce, de), Ce.return = me, Ce;
          case b:
            return de = v1(
              de,
              me.mode,
              Ce
            ), de.return = me, de;
          case L:
            return de = mu(de), Ie(me, de, Ce);
        }
        if (ne(de) || Y(de))
          return de = uu(
            de,
            me.mode,
            Ce,
            null
          ), de.return = me, de;
        if (typeof de.then == "function")
          return Ie(me, My(de), Ce);
        if (de.$$typeof === M)
          return Ie(
            me,
            Ey(me, de),
            Ce
          );
        Ny(me, de);
      }
      return null;
    }
    function Te(me, de, Ce, je) {
      var pt = de !== null ? de.key : null;
      if (typeof Ce == "string" && Ce !== "" || typeof Ce == "number" || typeof Ce == "bigint")
        return pt !== null ? null : V(me, de, "" + Ce, je);
      if (typeof Ce == "object" && Ce !== null) {
        switch (Ce.$$typeof) {
          case g:
            return Ce.key === pt ? te(me, de, Ce, je) : null;
          case b:
            return Ce.key === pt ? Ee(me, de, Ce, je) : null;
          case L:
            return Ce = mu(Ce), Te(me, de, Ce, je);
        }
        if (ne(Ce) || Y(Ce))
          return pt !== null ? null : Oe(me, de, Ce, je, null);
        if (typeof Ce.then == "function")
          return Te(
            me,
            de,
            My(Ce),
            je
          );
        if (Ce.$$typeof === M)
          return Te(
            me,
            de,
            Ey(me, Ce),
            je
          );
        Ny(me, Ce);
      }
      return null;
    }
    function Me(me, de, Ce, je, pt) {
      if (typeof je == "string" && je !== "" || typeof je == "number" || typeof je == "bigint")
        return me = me.get(Ce) || null, V(de, me, "" + je, pt);
      if (typeof je == "object" && je !== null) {
        switch (je.$$typeof) {
          case g:
            return me = me.get(
              je.key === null ? Ce : je.key
            ) || null, te(de, me, je, pt);
          case b:
            return me = me.get(
              je.key === null ? Ce : je.key
            ) || null, Ee(de, me, je, pt);
          case L:
            return je = mu(je), Me(
              me,
              de,
              Ce,
              je,
              pt
            );
        }
        if (ne(je) || Y(je))
          return me = me.get(Ce) || null, Oe(de, me, je, pt, null);
        if (typeof je.then == "function")
          return Me(
            me,
            de,
            Ce,
            My(je),
            pt
          );
        if (je.$$typeof === M)
          return Me(
            me,
            de,
            Ce,
            Ey(de, je),
            pt
          );
        Ny(de, je);
      }
      return null;
    }
    function rt(me, de, Ce, je) {
      for (var pt = null, rn = null, lt = de, Ot = de = 0, Yt = null; lt !== null && Ot < Ce.length; Ot++) {
        lt.index > Ot ? (Yt = lt, lt = null) : Yt = lt.sibling;
        var on = Te(
          me,
          lt,
          Ce[Ot],
          je
        );
        if (on === null) {
          lt === null && (lt = Yt);
          break;
        }
        l && lt && on.alternate === null && d(me, lt), de = T(on, de, Ot), rn === null ? pt = on : rn.sibling = on, rn = on, lt = Yt;
      }
      if (Ot === Ce.length)
        return p(me, lt), Qt && ba(me, Ot), pt;
      if (lt === null) {
        for (; Ot < Ce.length; Ot++)
          lt = Ie(me, Ce[Ot], je), lt !== null && (de = T(
            lt,
            de,
            Ot
          ), rn === null ? pt = lt : rn.sibling = lt, rn = lt);
        return Qt && ba(me, Ot), pt;
      }
      for (lt = y(lt); Ot < Ce.length; Ot++)
        Yt = Me(
          lt,
          me,
          Ot,
          Ce[Ot],
          je
        ), Yt !== null && (l && Yt.alternate !== null && lt.delete(
          Yt.key === null ? Ot : Yt.key
        ), de = T(
          Yt,
          de,
          Ot
        ), rn === null ? pt = Yt : rn.sibling = Yt, rn = Yt);
      return l && lt.forEach(function(Fl) {
        return d(me, Fl);
      }), Qt && ba(me, Ot), pt;
    }
    function vt(me, de, Ce, je) {
      if (Ce == null) throw Error(r(151));
      for (var pt = null, rn = null, lt = de, Ot = de = 0, Yt = null, on = Ce.next(); lt !== null && !on.done; Ot++, on = Ce.next()) {
        lt.index > Ot ? (Yt = lt, lt = null) : Yt = lt.sibling;
        var Fl = Te(me, lt, on.value, je);
        if (Fl === null) {
          lt === null && (lt = Yt);
          break;
        }
        l && lt && Fl.alternate === null && d(me, lt), de = T(Fl, de, Ot), rn === null ? pt = Fl : rn.sibling = Fl, rn = Fl, lt = Yt;
      }
      if (on.done)
        return p(me, lt), Qt && ba(me, Ot), pt;
      if (lt === null) {
        for (; !on.done; Ot++, on = Ce.next())
          on = Ie(me, on.value, je), on !== null && (de = T(on, de, Ot), rn === null ? pt = on : rn.sibling = on, rn = on);
        return Qt && ba(me, Ot), pt;
      }
      for (lt = y(lt); !on.done; Ot++, on = Ce.next())
        on = Me(lt, me, Ot, on.value, je), on !== null && (l && on.alternate !== null && lt.delete(on.key === null ? Ot : on.key), de = T(on, de, Ot), rn === null ? pt = on : rn.sibling = on, rn = on);
      return l && lt.forEach(function(CK) {
        return d(me, CK);
      }), Qt && ba(me, Ot), pt;
    }
    function Sn(me, de, Ce, je) {
      if (typeof Ce == "object" && Ce !== null && Ce.type === x && Ce.key === null && (Ce = Ce.props.children), typeof Ce == "object" && Ce !== null) {
        switch (Ce.$$typeof) {
          case g:
            e: {
              for (var pt = Ce.key; de !== null; ) {
                if (de.key === pt) {
                  if (pt = Ce.type, pt === x) {
                    if (de.tag === 7) {
                      p(
                        me,
                        de.sibling
                      ), je = E(
                        de,
                        Ce.props.children
                      ), je.return = me, me = je;
                      break e;
                    }
                  } else if (de.elementType === pt || typeof pt == "object" && pt !== null && pt.$$typeof === L && mu(pt) === de.type) {
                    p(
                      me,
                      de.sibling
                    ), je = E(de, Ce.props), gp(je, Ce), je.return = me, me = je;
                    break e;
                  }
                  p(me, de);
                  break;
                } else d(me, de);
                de = de.sibling;
              }
              Ce.type === x ? (je = uu(
                Ce.props.children,
                me.mode,
                je,
                Ce.key
              ), je.return = me, me = je) : (je = Sy(
                Ce.type,
                Ce.key,
                Ce.props,
                null,
                me.mode,
                je
              ), gp(je, Ce), je.return = me, me = je);
            }
            return j(me);
          case b:
            e: {
              for (pt = Ce.key; de !== null; ) {
                if (de.key === pt)
                  if (de.tag === 4 && de.stateNode.containerInfo === Ce.containerInfo && de.stateNode.implementation === Ce.implementation) {
                    p(
                      me,
                      de.sibling
                    ), je = E(de, Ce.children || []), je.return = me, me = je;
                    break e;
                  } else {
                    p(me, de);
                    break;
                  }
                else d(me, de);
                de = de.sibling;
              }
              je = v1(Ce, me.mode, je), je.return = me, me = je;
            }
            return j(me);
          case L:
            return Ce = mu(Ce), Sn(
              me,
              de,
              Ce,
              je
            );
        }
        if (ne(Ce))
          return rt(
            me,
            de,
            Ce,
            je
          );
        if (Y(Ce)) {
          if (pt = Y(Ce), typeof pt != "function") throw Error(r(150));
          return Ce = pt.call(Ce), vt(
            me,
            de,
            Ce,
            je
          );
        }
        if (typeof Ce.then == "function")
          return Sn(
            me,
            de,
            My(Ce),
            je
          );
        if (Ce.$$typeof === M)
          return Sn(
            me,
            de,
            Ey(me, Ce),
            je
          );
        Ny(me, Ce);
      }
      return typeof Ce == "string" && Ce !== "" || typeof Ce == "number" || typeof Ce == "bigint" ? (Ce = "" + Ce, de !== null && de.tag === 6 ? (p(me, de.sibling), je = E(de, Ce), je.return = me, me = je) : (p(me, de), je = y1(Ce, me.mode, je), je.return = me, me = je), j(me)) : p(me, de);
    }
    return function(me, de, Ce, je) {
      try {
        mp = 0;
        var pt = Sn(
          me,
          de,
          Ce,
          je
        );
        return Gd = null, pt;
      } catch (lt) {
        if (lt === qd || lt === Ty) throw lt;
        var rn = eo(29, lt, null, me.mode);
        return rn.lanes = je, rn.return = me, rn;
      }
    };
  }
  var yu = pR(!0), mR = pR(!1), El = !1;
  function N1(l) {
    l.updateQueue = {
      baseState: l.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function R1(l, d) {
    l = l.updateQueue, d.updateQueue === l && (d.updateQueue = {
      baseState: l.baseState,
      firstBaseUpdate: l.firstBaseUpdate,
      lastBaseUpdate: l.lastBaseUpdate,
      shared: l.shared,
      callbacks: null
    });
  }
  function _l(l) {
    return { lane: l, tag: 0, payload: null, callback: null, next: null };
  }
  function Tl(l, d, p) {
    var y = l.updateQueue;
    if (y === null) return null;
    if (y = y.shared, (ln & 2) !== 0) {
      var E = y.pending;
      return E === null ? d.next = d : (d.next = E.next, E.next = d), y.pending = d, d = xl(l), _s(l, null, p), d;
    }
    return bn(l, y, d, p), xl(l);
  }
  function yp(l, d, p) {
    if (d = d.updateQueue, d !== null && (d = d.shared, (p & 4194048) !== 0)) {
      var y = d.lanes;
      y &= l.pendingLanes, p |= y, d.lanes = p, kn(l, p);
    }
  }
  function O1(l, d) {
    var p = l.updateQueue, y = l.alternate;
    if (y !== null && (y = y.updateQueue, p === y)) {
      var E = null, T = null;
      if (p = p.firstBaseUpdate, p !== null) {
        do {
          var j = {
            lane: p.lane,
            tag: p.tag,
            payload: p.payload,
            callback: null,
            next: null
          };
          T === null ? E = T = j : T = T.next = j, p = p.next;
        } while (p !== null);
        T === null ? E = T = d : T = T.next = d;
      } else E = T = d;
      p = {
        baseState: y.baseState,
        firstBaseUpdate: E,
        lastBaseUpdate: T,
        shared: y.shared,
        callbacks: y.callbacks
      }, l.updateQueue = p;
      return;
    }
    l = p.lastBaseUpdate, l === null ? p.firstBaseUpdate = d : l.next = d, p.lastBaseUpdate = d;
  }
  var D1 = !1;
  function vp() {
    if (D1) {
      var l = Wd;
      if (l !== null) throw l;
    }
  }
  function bp(l, d, p, y) {
    D1 = !1;
    var E = l.updateQueue;
    El = !1;
    var T = E.firstBaseUpdate, j = E.lastBaseUpdate, V = E.shared.pending;
    if (V !== null) {
      E.shared.pending = null;
      var te = V, Ee = te.next;
      te.next = null, j === null ? T = Ee : j.next = Ee, j = te;
      var Oe = l.alternate;
      Oe !== null && (Oe = Oe.updateQueue, V = Oe.lastBaseUpdate, V !== j && (V === null ? Oe.firstBaseUpdate = Ee : V.next = Ee, Oe.lastBaseUpdate = te));
    }
    if (T !== null) {
      var Ie = E.baseState;
      j = 0, Oe = Ee = te = null, V = T;
      do {
        var Te = V.lane & -536870913, Me = Te !== V.lane;
        if (Me ? (Zt & Te) === Te : (y & Te) === Te) {
          Te !== 0 && Te === Hd && (D1 = !0), Oe !== null && (Oe = Oe.next = {
            lane: 0,
            tag: V.tag,
            payload: V.payload,
            callback: null,
            next: null
          });
          e: {
            var rt = l, vt = V;
            Te = d;
            var Sn = p;
            switch (vt.tag) {
              case 1:
                if (rt = vt.payload, typeof rt == "function") {
                  Ie = rt.call(Sn, Ie, Te);
                  break e;
                }
                Ie = rt;
                break e;
              case 3:
                rt.flags = rt.flags & -65537 | 128;
              case 0:
                if (rt = vt.payload, Te = typeof rt == "function" ? rt.call(Sn, Ie, Te) : rt, Te == null) break e;
                Ie = h({}, Ie, Te);
                break e;
              case 2:
                El = !0;
            }
          }
          Te = V.callback, Te !== null && (l.flags |= 64, Me && (l.flags |= 8192), Me = E.callbacks, Me === null ? E.callbacks = [Te] : Me.push(Te));
        } else
          Me = {
            lane: Te,
            tag: V.tag,
            payload: V.payload,
            callback: V.callback,
            next: null
          }, Oe === null ? (Ee = Oe = Me, te = Ie) : Oe = Oe.next = Me, j |= Te;
        if (V = V.next, V === null) {
          if (V = E.shared.pending, V === null)
            break;
          Me = V, V = Me.next, Me.next = null, E.lastBaseUpdate = Me, E.shared.pending = null;
        }
      } while (!0);
      Oe === null && (te = Ie), E.baseState = te, E.firstBaseUpdate = Ee, E.lastBaseUpdate = Oe, T === null && (E.shared.lanes = 0), Ol |= j, l.lanes = j, l.memoizedState = Ie;
    }
  }
  function gR(l, d) {
    if (typeof l != "function")
      throw Error(r(191, l));
    l.call(d);
  }
  function yR(l, d) {
    var p = l.callbacks;
    if (p !== null)
      for (l.callbacks = null, l = 0; l < p.length; l++)
        gR(p[l], d);
  }
  var Kd = Z(null), Ry = Z(0);
  function vR(l, d) {
    l = Na, F(Ry, l), F(Kd, d), Na = l | d.baseLanes;
  }
  function P1() {
    F(Ry, Na), F(Kd, Kd.current);
  }
  function j1() {
    Na = Ry.current, pe(Kd), pe(Ry);
  }
  var to = Z(null), _o = null;
  function Al(l) {
    var d = l.alternate;
    F(cr, cr.current & 1), F(to, l), _o === null && (d === null || Kd.current !== null || d.memoizedState !== null) && (_o = l);
  }
  function I1(l) {
    F(cr, cr.current), F(to, l), _o === null && (_o = l);
  }
  function bR(l) {
    l.tag === 22 ? (F(cr, cr.current), F(to, l), _o === null && (_o = l)) : Ml();
  }
  function Ml() {
    F(cr, cr.current), F(to, to.current);
  }
  function no(l) {
    pe(to), _o === l && (_o = null), pe(cr);
  }
  var cr = Z(0);
  function Oy(l) {
    for (var d = l; d !== null; ) {
      if (d.tag === 13) {
        var p = d.memoizedState;
        if (p !== null && (p = p.dehydrated, p === null || FS(p) || VS(p)))
          return d;
      } else if (d.tag === 19 && (d.memoizedProps.revealOrder === "forwards" || d.memoizedProps.revealOrder === "backwards" || d.memoizedProps.revealOrder === "unstable_legacy-backwards" || d.memoizedProps.revealOrder === "together")) {
        if ((d.flags & 128) !== 0) return d;
      } else if (d.child !== null) {
        d.child.return = d, d = d.child;
        continue;
      }
      if (d === l) break;
      for (; d.sibling === null; ) {
        if (d.return === null || d.return === l) return null;
        d = d.return;
      }
      d.sibling.return = d.return, d = d.sibling;
    }
    return null;
  }
  var Sa = 0, Rt = null, xn = null, gr = null, Dy = !1, Zd = !1, vu = !1, Py = 0, xp = 0, Yd = null, pG = 0;
  function Jn() {
    throw Error(r(321));
  }
  function z1(l, d) {
    if (d === null) return !1;
    for (var p = 0; p < d.length && p < l.length; p++)
      if (!li(l[p], d[p])) return !1;
    return !0;
  }
  function L1(l, d, p, y, E, T) {
    return Sa = T, Rt = d, d.memoizedState = null, d.updateQueue = null, d.lanes = 0, H.H = l === null || l.memoizedState === null ? n2 : Q1, vu = !1, T = p(y, E), vu = !1, Zd && (T = wR(
      d,
      p,
      y,
      E
    )), xR(l), T;
  }
  function xR(l) {
    H.H = kp;
    var d = xn !== null && xn.next !== null;
    if (Sa = 0, gr = xn = Rt = null, Dy = !1, xp = 0, Yd = null, d) throw Error(r(300));
    l === null || yr || (l = l.dependencies, l !== null && Cy(l) && (yr = !0));
  }
  function wR(l, d, p, y) {
    Rt = l;
    var E = 0;
    do {
      if (Zd && (Yd = null), xp = 0, Zd = !1, 25 <= E) throw Error(r(301));
      if (E += 1, gr = xn = null, l.updateQueue != null) {
        var T = l.updateQueue;
        T.lastEffect = null, T.events = null, T.stores = null, T.memoCache != null && (T.memoCache.index = 0);
      }
      H.H = r2, T = d(p, y);
    } while (Zd);
    return T;
  }
  function mG() {
    var l = H.H, d = l.useState()[0];
    return d = typeof d.then == "function" ? wp(d) : d, l = l.useState()[0], (xn !== null ? xn.memoizedState : null) !== l && (Rt.flags |= 1024), d;
  }
  function B1() {
    var l = Py !== 0;
    return Py = 0, l;
  }
  function $1(l, d, p) {
    d.updateQueue = l.updateQueue, d.flags &= -2053, l.lanes &= ~p;
  }
  function U1(l) {
    if (Dy) {
      for (l = l.memoizedState; l !== null; ) {
        var d = l.queue;
        d !== null && (d.pending = null), l = l.next;
      }
      Dy = !1;
    }
    Sa = 0, gr = xn = Rt = null, Zd = !1, xp = Py = 0, Yd = null;
  }
  function ki() {
    var l = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return gr === null ? Rt.memoizedState = gr = l : gr = gr.next = l, gr;
  }
  function ur() {
    if (xn === null) {
      var l = Rt.alternate;
      l = l !== null ? l.memoizedState : null;
    } else l = xn.next;
    var d = gr === null ? Rt.memoizedState : gr.next;
    if (d !== null)
      gr = d, xn = l;
    else {
      if (l === null)
        throw Rt.alternate === null ? Error(r(467)) : Error(r(310));
      xn = l, l = {
        memoizedState: xn.memoizedState,
        baseState: xn.baseState,
        baseQueue: xn.baseQueue,
        queue: xn.queue,
        next: null
      }, gr === null ? Rt.memoizedState = gr = l : gr = gr.next = l;
    }
    return gr;
  }
  function jy() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function wp(l) {
    var d = xp;
    return xp += 1, Yd === null && (Yd = []), l = dR(Yd, l, d), d = Rt, (gr === null ? d.memoizedState : gr.next) === null && (d = d.alternate, H.H = d === null || d.memoizedState === null ? n2 : Q1), l;
  }
  function Iy(l) {
    if (l !== null && typeof l == "object") {
      if (typeof l.then == "function") return wp(l);
      if (l.$$typeof === M) return Kr(l);
    }
    throw Error(r(438, String(l)));
  }
  function F1(l) {
    var d = null, p = Rt.updateQueue;
    if (p !== null && (d = p.memoCache), d == null) {
      var y = Rt.alternate;
      y !== null && (y = y.updateQueue, y !== null && (y = y.memoCache, y != null && (d = {
        data: y.data.map(function(E) {
          return E.slice();
        }),
        index: 0
      })));
    }
    if (d == null && (d = { data: [], index: 0 }), p === null && (p = jy(), Rt.updateQueue = p), p.memoCache = d, p = d.data[d.index], p === void 0)
      for (p = d.data[d.index] = Array(l), y = 0; y < l; y++)
        p[y] = B;
    return d.index++, p;
  }
  function ka(l, d) {
    return typeof d == "function" ? d(l) : d;
  }
  function zy(l) {
    var d = ur();
    return V1(d, xn, l);
  }
  function V1(l, d, p) {
    var y = l.queue;
    if (y === null) throw Error(r(311));
    y.lastRenderedReducer = p;
    var E = l.baseQueue, T = y.pending;
    if (T !== null) {
      if (E !== null) {
        var j = E.next;
        E.next = T.next, T.next = j;
      }
      d.baseQueue = E = T, y.pending = null;
    }
    if (T = l.baseState, E === null) l.memoizedState = T;
    else {
      d = E.next;
      var V = j = null, te = null, Ee = d, Oe = !1;
      do {
        var Ie = Ee.lane & -536870913;
        if (Ie !== Ee.lane ? (Zt & Ie) === Ie : (Sa & Ie) === Ie) {
          var Te = Ee.revertLane;
          if (Te === 0)
            te !== null && (te = te.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: Ee.action,
              hasEagerState: Ee.hasEagerState,
              eagerState: Ee.eagerState,
              next: null
            }), Ie === Hd && (Oe = !0);
          else if ((Sa & Te) === Te) {
            Ee = Ee.next, Te === Hd && (Oe = !0);
            continue;
          } else
            Ie = {
              lane: 0,
              revertLane: Ee.revertLane,
              gesture: null,
              action: Ee.action,
              hasEagerState: Ee.hasEagerState,
              eagerState: Ee.eagerState,
              next: null
            }, te === null ? (V = te = Ie, j = T) : te = te.next = Ie, Rt.lanes |= Te, Ol |= Te;
          Ie = Ee.action, vu && p(T, Ie), T = Ee.hasEagerState ? Ee.eagerState : p(T, Ie);
        } else
          Te = {
            lane: Ie,
            revertLane: Ee.revertLane,
            gesture: Ee.gesture,
            action: Ee.action,
            hasEagerState: Ee.hasEagerState,
            eagerState: Ee.eagerState,
            next: null
          }, te === null ? (V = te = Te, j = T) : te = te.next = Te, Rt.lanes |= Ie, Ol |= Ie;
        Ee = Ee.next;
      } while (Ee !== null && Ee !== d);
      if (te === null ? j = T : te.next = V, !li(T, l.memoizedState) && (yr = !0, Oe && (p = Wd, p !== null)))
        throw p;
      l.memoizedState = T, l.baseState = j, l.baseQueue = te, y.lastRenderedState = T;
    }
    return E === null && (y.lanes = 0), [l.memoizedState, y.dispatch];
  }
  function H1(l) {
    var d = ur(), p = d.queue;
    if (p === null) throw Error(r(311));
    p.lastRenderedReducer = l;
    var y = p.dispatch, E = p.pending, T = d.memoizedState;
    if (E !== null) {
      p.pending = null;
      var j = E = E.next;
      do
        T = l(T, j.action), j = j.next;
      while (j !== E);
      li(T, d.memoizedState) || (yr = !0), d.memoizedState = T, d.baseQueue === null && (d.baseState = T), p.lastRenderedState = T;
    }
    return [T, y];
  }
  function SR(l, d, p) {
    var y = Rt, E = ur(), T = Qt;
    if (T) {
      if (p === void 0) throw Error(r(407));
      p = p();
    } else p = d();
    var j = !li(
      (xn || E).memoizedState,
      p
    );
    if (j && (E.memoizedState = p, yr = !0), E = E.queue, G1(ER.bind(null, y, E, l), [
      l
    ]), E.getSnapshot !== d || j || gr !== null && gr.memoizedState.tag & 1) {
      if (y.flags |= 2048, Xd(
        9,
        { destroy: void 0 },
        CR.bind(
          null,
          y,
          E,
          p,
          d
        ),
        null
      ), Cn === null) throw Error(r(349));
      T || (Sa & 127) !== 0 || kR(y, d, p);
    }
    return p;
  }
  function kR(l, d, p) {
    l.flags |= 16384, l = { getSnapshot: d, value: p }, d = Rt.updateQueue, d === null ? (d = jy(), Rt.updateQueue = d, d.stores = [l]) : (p = d.stores, p === null ? d.stores = [l] : p.push(l));
  }
  function CR(l, d, p, y) {
    d.value = p, d.getSnapshot = y, _R(d) && TR(l);
  }
  function ER(l, d, p) {
    return p(function() {
      _R(d) && TR(l);
    });
  }
  function _R(l) {
    var d = l.getSnapshot;
    l = l.value;
    try {
      var p = d();
      return !li(l, p);
    } catch {
      return !0;
    }
  }
  function TR(l) {
    var d = un(l, 2);
    d !== null && Fi(d, l, 2);
  }
  function W1(l) {
    var d = ki();
    if (typeof l == "function") {
      var p = l;
      if (l = p(), vu) {
        jn(!0);
        try {
          p();
        } finally {
          jn(!1);
        }
      }
    }
    return d.memoizedState = d.baseState = l, d.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: ka,
      lastRenderedState: l
    }, d;
  }
  function AR(l, d, p, y) {
    return l.baseState = p, V1(
      l,
      xn,
      typeof y == "function" ? y : ka
    );
  }
  function gG(l, d, p, y, E) {
    if ($y(l)) throw Error(r(485));
    if (l = d.action, l !== null) {
      var T = {
        payload: E,
        action: l,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(j) {
          T.listeners.push(j);
        }
      };
      H.T !== null ? p(!0) : T.isTransition = !1, y(T), p = d.pending, p === null ? (T.next = d.pending = T, MR(d, T)) : (T.next = p.next, d.pending = p.next = T);
    }
  }
  function MR(l, d) {
    var p = d.action, y = d.payload, E = l.state;
    if (d.isTransition) {
      var T = H.T, j = {};
      H.T = j;
      try {
        var V = p(E, y), te = H.S;
        te !== null && te(j, V), NR(l, d, V);
      } catch (Ee) {
        q1(l, d, Ee);
      } finally {
        T !== null && j.types !== null && (T.types = j.types), H.T = T;
      }
    } else
      try {
        T = p(E, y), NR(l, d, T);
      } catch (Ee) {
        q1(l, d, Ee);
      }
  }
  function NR(l, d, p) {
    p !== null && typeof p == "object" && typeof p.then == "function" ? p.then(
      function(y) {
        RR(l, d, y);
      },
      function(y) {
        return q1(l, d, y);
      }
    ) : RR(l, d, p);
  }
  function RR(l, d, p) {
    d.status = "fulfilled", d.value = p, OR(d), l.state = p, d = l.pending, d !== null && (p = d.next, p === d ? l.pending = null : (p = p.next, d.next = p, MR(l, p)));
  }
  function q1(l, d, p) {
    var y = l.pending;
    if (l.pending = null, y !== null) {
      y = y.next;
      do
        d.status = "rejected", d.reason = p, OR(d), d = d.next;
      while (d !== y);
    }
    l.action = null;
  }
  function OR(l) {
    l = l.listeners;
    for (var d = 0; d < l.length; d++) (0, l[d])();
  }
  function DR(l, d) {
    return d;
  }
  function PR(l, d) {
    if (Qt) {
      var p = Cn.formState;
      if (p !== null) {
        e: {
          var y = Rt;
          if (Qt) {
            if (Ln) {
              t: {
                for (var E = Ln, T = Eo; E.nodeType !== 8; ) {
                  if (!T) {
                    E = null;
                    break t;
                  }
                  if (E = To(
                    E.nextSibling
                  ), E === null) {
                    E = null;
                    break t;
                  }
                }
                T = E.data, E = T === "F!" || T === "F" ? E : null;
              }
              if (E) {
                Ln = To(
                  E.nextSibling
                ), y = E.data === "F!";
                break e;
              }
            }
            kl(y);
          }
          y = !1;
        }
        y && (d = p[0]);
      }
    }
    return p = ki(), p.memoizedState = p.baseState = d, y = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: DR,
      lastRenderedState: d
    }, p.queue = y, p = QR.bind(
      null,
      Rt,
      y
    ), y.dispatch = p, y = W1(!1), T = J1.bind(
      null,
      Rt,
      !1,
      y.queue
    ), y = ki(), E = {
      state: d,
      dispatch: null,
      action: l,
      pending: null
    }, y.queue = E, p = gG.bind(
      null,
      Rt,
      E,
      T,
      p
    ), E.dispatch = p, y.memoizedState = l, [d, p, !1];
  }
  function jR(l) {
    var d = ur();
    return IR(d, xn, l);
  }
  function IR(l, d, p) {
    if (d = V1(
      l,
      d,
      DR
    )[0], l = zy(ka)[0], typeof d == "object" && d !== null && typeof d.then == "function")
      try {
        var y = wp(d);
      } catch (j) {
        throw j === qd ? Ty : j;
      }
    else y = d;
    d = ur();
    var E = d.queue, T = E.dispatch;
    return p !== d.memoizedState && (Rt.flags |= 2048, Xd(
      9,
      { destroy: void 0 },
      yG.bind(null, E, p),
      null
    )), [y, T, l];
  }
  function yG(l, d) {
    l.action = d;
  }
  function zR(l) {
    var d = ur(), p = xn;
    if (p !== null)
      return IR(d, p, l);
    ur(), d = d.memoizedState, p = ur();
    var y = p.queue.dispatch;
    return p.memoizedState = l, [d, y, !1];
  }
  function Xd(l, d, p, y) {
    return l = { tag: l, create: p, deps: y, inst: d, next: null }, d = Rt.updateQueue, d === null && (d = jy(), Rt.updateQueue = d), p = d.lastEffect, p === null ? d.lastEffect = l.next = l : (y = p.next, p.next = l, l.next = y, d.lastEffect = l), l;
  }
  function LR() {
    return ur().memoizedState;
  }
  function Ly(l, d, p, y) {
    var E = ki();
    Rt.flags |= l, E.memoizedState = Xd(
      1 | d,
      { destroy: void 0 },
      p,
      y === void 0 ? null : y
    );
  }
  function By(l, d, p, y) {
    var E = ur();
    y = y === void 0 ? null : y;
    var T = E.memoizedState.inst;
    xn !== null && y !== null && z1(y, xn.memoizedState.deps) ? E.memoizedState = Xd(d, T, p, y) : (Rt.flags |= l, E.memoizedState = Xd(
      1 | d,
      T,
      p,
      y
    ));
  }
  function BR(l, d) {
    Ly(8390656, 8, l, d);
  }
  function G1(l, d) {
    By(2048, 8, l, d);
  }
  function vG(l) {
    Rt.flags |= 4;
    var d = Rt.updateQueue;
    if (d === null)
      d = jy(), Rt.updateQueue = d, d.events = [l];
    else {
      var p = d.events;
      p === null ? d.events = [l] : p.push(l);
    }
  }
  function $R(l) {
    var d = ur().memoizedState;
    return vG({ ref: d, nextImpl: l }), function() {
      if ((ln & 2) !== 0) throw Error(r(440));
      return d.impl.apply(void 0, arguments);
    };
  }
  function UR(l, d) {
    return By(4, 2, l, d);
  }
  function FR(l, d) {
    return By(4, 4, l, d);
  }
  function VR(l, d) {
    if (typeof d == "function") {
      l = l();
      var p = d(l);
      return function() {
        typeof p == "function" ? p() : d(null);
      };
    }
    if (d != null)
      return l = l(), d.current = l, function() {
        d.current = null;
      };
  }
  function HR(l, d, p) {
    p = p != null ? p.concat([l]) : null, By(4, 4, VR.bind(null, d, l), p);
  }
  function K1() {
  }
  function WR(l, d) {
    var p = ur();
    d = d === void 0 ? null : d;
    var y = p.memoizedState;
    return d !== null && z1(d, y[1]) ? y[0] : (p.memoizedState = [l, d], l);
  }
  function qR(l, d) {
    var p = ur();
    d = d === void 0 ? null : d;
    var y = p.memoizedState;
    if (d !== null && z1(d, y[1]))
      return y[0];
    if (y = l(), vu) {
      jn(!0);
      try {
        l();
      } finally {
        jn(!1);
      }
    }
    return p.memoizedState = [y, d], y;
  }
  function Z1(l, d, p) {
    return p === void 0 || (Sa & 1073741824) !== 0 && (Zt & 261930) === 0 ? l.memoizedState = d : (l.memoizedState = p, l = G2(), Rt.lanes |= l, Ol |= l, p);
  }
  function GR(l, d, p, y) {
    return li(p, d) ? p : Kd.current !== null ? (l = Z1(l, p, y), li(l, d) || (yr = !0), l) : (Sa & 42) === 0 || (Sa & 1073741824) !== 0 && (Zt & 261930) === 0 ? (yr = !0, l.memoizedState = p) : (l = G2(), Rt.lanes |= l, Ol |= l, d);
  }
  function KR(l, d, p, y, E) {
    var T = Q.p;
    Q.p = T !== 0 && 8 > T ? T : 8;
    var j = H.T, V = {};
    H.T = V, J1(l, !1, d, p);
    try {
      var te = E(), Ee = H.S;
      if (Ee !== null && Ee(V, te), te !== null && typeof te == "object" && typeof te.then == "function") {
        var Oe = hG(
          te,
          y
        );
        Sp(
          l,
          d,
          Oe,
          oo(l)
        );
      } else
        Sp(
          l,
          d,
          y,
          oo(l)
        );
    } catch (Ie) {
      Sp(
        l,
        d,
        { then: function() {
        }, status: "rejected", reason: Ie },
        oo()
      );
    } finally {
      Q.p = T, j !== null && V.types !== null && (j.types = V.types), H.T = j;
    }
  }
  function bG() {
  }
  function Y1(l, d, p, y) {
    if (l.tag !== 5) throw Error(r(476));
    var E = ZR(l).queue;
    KR(
      l,
      E,
      d,
      X,
      p === null ? bG : function() {
        return YR(l), p(y);
      }
    );
  }
  function ZR(l) {
    var d = l.memoizedState;
    if (d !== null) return d;
    d = {
      memoizedState: X,
      baseState: X,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ka,
        lastRenderedState: X
      },
      next: null
    };
    var p = {};
    return d.next = {
      memoizedState: p,
      baseState: p,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ka,
        lastRenderedState: p
      },
      next: null
    }, l.memoizedState = d, l = l.alternate, l !== null && (l.memoizedState = d), d;
  }
  function YR(l) {
    var d = ZR(l);
    d.next === null && (d = l.alternate.memoizedState), Sp(
      l,
      d.next.queue,
      {},
      oo()
    );
  }
  function X1() {
    return Kr(Bp);
  }
  function XR() {
    return ur().memoizedState;
  }
  function JR() {
    return ur().memoizedState;
  }
  function xG(l) {
    for (var d = l.return; d !== null; ) {
      switch (d.tag) {
        case 24:
        case 3:
          var p = oo();
          l = _l(p);
          var y = Tl(d, l, p);
          y !== null && (Fi(y, d, p), yp(y, d, p)), d = { cache: _1() }, l.payload = d;
          return;
      }
      d = d.return;
    }
  }
  function wG(l, d, p) {
    var y = oo();
    p = {
      lane: y,
      revertLane: 0,
      gesture: null,
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, $y(l) ? e2(d, p) : (p = ci(l, d, p, y), p !== null && (Fi(p, l, y), t2(p, d, y)));
  }
  function QR(l, d, p) {
    var y = oo();
    Sp(l, d, p, y);
  }
  function Sp(l, d, p, y) {
    var E = {
      lane: y,
      revertLane: 0,
      gesture: null,
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if ($y(l)) e2(d, E);
    else {
      var T = l.alternate;
      if (l.lanes === 0 && (T === null || T.lanes === 0) && (T = d.lastRenderedReducer, T !== null))
        try {
          var j = d.lastRenderedState, V = T(j, p);
          if (E.hasEagerState = !0, E.eagerState = V, li(V, j))
            return bn(l, d, E, 0), Cn === null && Tt(), !1;
        } catch {
        }
      if (p = ci(l, d, E, y), p !== null)
        return Fi(p, l, y), t2(p, d, y), !0;
    }
    return !1;
  }
  function J1(l, d, p, y) {
    if (y = {
      lane: 2,
      revertLane: NS(),
      gesture: null,
      action: y,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, $y(l)) {
      if (d) throw Error(r(479));
    } else
      d = ci(
        l,
        p,
        y,
        2
      ), d !== null && Fi(d, l, 2);
  }
  function $y(l) {
    var d = l.alternate;
    return l === Rt || d !== null && d === Rt;
  }
  function e2(l, d) {
    Zd = Dy = !0;
    var p = l.pending;
    p === null ? d.next = d : (d.next = p.next, p.next = d), l.pending = d;
  }
  function t2(l, d, p) {
    if ((p & 4194048) !== 0) {
      var y = d.lanes;
      y &= l.pendingLanes, p |= y, d.lanes = p, kn(l, p);
    }
  }
  var kp = {
    readContext: Kr,
    use: Iy,
    useCallback: Jn,
    useContext: Jn,
    useEffect: Jn,
    useImperativeHandle: Jn,
    useLayoutEffect: Jn,
    useInsertionEffect: Jn,
    useMemo: Jn,
    useReducer: Jn,
    useRef: Jn,
    useState: Jn,
    useDebugValue: Jn,
    useDeferredValue: Jn,
    useTransition: Jn,
    useSyncExternalStore: Jn,
    useId: Jn,
    useHostTransitionStatus: Jn,
    useFormState: Jn,
    useActionState: Jn,
    useOptimistic: Jn,
    useMemoCache: Jn,
    useCacheRefresh: Jn
  };
  kp.useEffectEvent = Jn;
  var n2 = {
    readContext: Kr,
    use: Iy,
    useCallback: function(l, d) {
      return ki().memoizedState = [
        l,
        d === void 0 ? null : d
      ], l;
    },
    useContext: Kr,
    useEffect: BR,
    useImperativeHandle: function(l, d, p) {
      p = p != null ? p.concat([l]) : null, Ly(
        4194308,
        4,
        VR.bind(null, d, l),
        p
      );
    },
    useLayoutEffect: function(l, d) {
      return Ly(4194308, 4, l, d);
    },
    useInsertionEffect: function(l, d) {
      Ly(4, 2, l, d);
    },
    useMemo: function(l, d) {
      var p = ki();
      d = d === void 0 ? null : d;
      var y = l();
      if (vu) {
        jn(!0);
        try {
          l();
        } finally {
          jn(!1);
        }
      }
      return p.memoizedState = [y, d], y;
    },
    useReducer: function(l, d, p) {
      var y = ki();
      if (p !== void 0) {
        var E = p(d);
        if (vu) {
          jn(!0);
          try {
            p(d);
          } finally {
            jn(!1);
          }
        }
      } else E = d;
      return y.memoizedState = y.baseState = E, l = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: l,
        lastRenderedState: E
      }, y.queue = l, l = l.dispatch = wG.bind(
        null,
        Rt,
        l
      ), [y.memoizedState, l];
    },
    useRef: function(l) {
      var d = ki();
      return l = { current: l }, d.memoizedState = l;
    },
    useState: function(l) {
      l = W1(l);
      var d = l.queue, p = QR.bind(null, Rt, d);
      return d.dispatch = p, [l.memoizedState, p];
    },
    useDebugValue: K1,
    useDeferredValue: function(l, d) {
      var p = ki();
      return Z1(p, l, d);
    },
    useTransition: function() {
      var l = W1(!1);
      return l = KR.bind(
        null,
        Rt,
        l.queue,
        !0,
        !1
      ), ki().memoizedState = l, [!1, l];
    },
    useSyncExternalStore: function(l, d, p) {
      var y = Rt, E = ki();
      if (Qt) {
        if (p === void 0)
          throw Error(r(407));
        p = p();
      } else {
        if (p = d(), Cn === null)
          throw Error(r(349));
        (Zt & 127) !== 0 || kR(y, d, p);
      }
      E.memoizedState = p;
      var T = { value: p, getSnapshot: d };
      return E.queue = T, BR(ER.bind(null, y, T, l), [
        l
      ]), y.flags |= 2048, Xd(
        9,
        { destroy: void 0 },
        CR.bind(
          null,
          y,
          T,
          p,
          d
        ),
        null
      ), p;
    },
    useId: function() {
      var l = ki(), d = Cn.identifierPrefix;
      if (Qt) {
        var p = As, y = Ts;
        p = (y & ~(1 << 32 - Ve(y) - 1)).toString(32) + p, d = "_" + d + "R_" + p, p = Py++, 0 < p && (d += "H" + p.toString(32)), d += "_";
      } else
        p = pG++, d = "_" + d + "r_" + p.toString(32) + "_";
      return l.memoizedState = d;
    },
    useHostTransitionStatus: X1,
    useFormState: PR,
    useActionState: PR,
    useOptimistic: function(l) {
      var d = ki();
      d.memoizedState = d.baseState = l;
      var p = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return d.queue = p, d = J1.bind(
        null,
        Rt,
        !0,
        p
      ), p.dispatch = d, [l, d];
    },
    useMemoCache: F1,
    useCacheRefresh: function() {
      return ki().memoizedState = xG.bind(
        null,
        Rt
      );
    },
    useEffectEvent: function(l) {
      var d = ki(), p = { impl: l };
      return d.memoizedState = p, function() {
        if ((ln & 2) !== 0)
          throw Error(r(440));
        return p.impl.apply(void 0, arguments);
      };
    }
  }, Q1 = {
    readContext: Kr,
    use: Iy,
    useCallback: WR,
    useContext: Kr,
    useEffect: G1,
    useImperativeHandle: HR,
    useInsertionEffect: UR,
    useLayoutEffect: FR,
    useMemo: qR,
    useReducer: zy,
    useRef: LR,
    useState: function() {
      return zy(ka);
    },
    useDebugValue: K1,
    useDeferredValue: function(l, d) {
      var p = ur();
      return GR(
        p,
        xn.memoizedState,
        l,
        d
      );
    },
    useTransition: function() {
      var l = zy(ka)[0], d = ur().memoizedState;
      return [
        typeof l == "boolean" ? l : wp(l),
        d
      ];
    },
    useSyncExternalStore: SR,
    useId: XR,
    useHostTransitionStatus: X1,
    useFormState: jR,
    useActionState: jR,
    useOptimistic: function(l, d) {
      var p = ur();
      return AR(p, xn, l, d);
    },
    useMemoCache: F1,
    useCacheRefresh: JR
  };
  Q1.useEffectEvent = $R;
  var r2 = {
    readContext: Kr,
    use: Iy,
    useCallback: WR,
    useContext: Kr,
    useEffect: G1,
    useImperativeHandle: HR,
    useInsertionEffect: UR,
    useLayoutEffect: FR,
    useMemo: qR,
    useReducer: H1,
    useRef: LR,
    useState: function() {
      return H1(ka);
    },
    useDebugValue: K1,
    useDeferredValue: function(l, d) {
      var p = ur();
      return xn === null ? Z1(p, l, d) : GR(
        p,
        xn.memoizedState,
        l,
        d
      );
    },
    useTransition: function() {
      var l = H1(ka)[0], d = ur().memoizedState;
      return [
        typeof l == "boolean" ? l : wp(l),
        d
      ];
    },
    useSyncExternalStore: SR,
    useId: XR,
    useHostTransitionStatus: X1,
    useFormState: zR,
    useActionState: zR,
    useOptimistic: function(l, d) {
      var p = ur();
      return xn !== null ? AR(p, xn, l, d) : (p.baseState = l, [l, p.queue.dispatch]);
    },
    useMemoCache: F1,
    useCacheRefresh: JR
  };
  r2.useEffectEvent = $R;
  function eS(l, d, p, y) {
    d = l.memoizedState, p = p(y, d), p = p == null ? d : h({}, d, p), l.memoizedState = p, l.lanes === 0 && (l.updateQueue.baseState = p);
  }
  var tS = {
    enqueueSetState: function(l, d, p) {
      l = l._reactInternals;
      var y = oo(), E = _l(y);
      E.payload = d, p != null && (E.callback = p), d = Tl(l, E, y), d !== null && (Fi(d, l, y), yp(d, l, y));
    },
    enqueueReplaceState: function(l, d, p) {
      l = l._reactInternals;
      var y = oo(), E = _l(y);
      E.tag = 1, E.payload = d, p != null && (E.callback = p), d = Tl(l, E, y), d !== null && (Fi(d, l, y), yp(d, l, y));
    },
    enqueueForceUpdate: function(l, d) {
      l = l._reactInternals;
      var p = oo(), y = _l(p);
      y.tag = 2, d != null && (y.callback = d), d = Tl(l, y, p), d !== null && (Fi(d, l, p), yp(d, l, p));
    }
  };
  function i2(l, d, p, y, E, T, j) {
    return l = l.stateNode, typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(y, T, j) : d.prototype && d.prototype.isPureReactComponent ? !C(p, y) || !C(E, T) : !0;
  }
  function o2(l, d, p, y) {
    l = d.state, typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(p, y), typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(p, y), d.state !== l && tS.enqueueReplaceState(d, d.state, null);
  }
  function bu(l, d) {
    var p = d;
    if ("ref" in d) {
      p = {};
      for (var y in d)
        y !== "ref" && (p[y] = d[y]);
    }
    if (l = l.defaultProps) {
      p === d && (p = h({}, p));
      for (var E in l)
        p[E] === void 0 && (p[E] = l[E]);
    }
    return p;
  }
  function s2(l) {
    Je(l);
  }
  function a2(l) {
    console.error(l);
  }
  function l2(l) {
    Je(l);
  }
  function Uy(l, d) {
    try {
      var p = l.onUncaughtError;
      p(d.value, { componentStack: d.stack });
    } catch (y) {
      setTimeout(function() {
        throw y;
      });
    }
  }
  function c2(l, d, p) {
    try {
      var y = l.onCaughtError;
      y(p.value, {
        componentStack: p.stack,
        errorBoundary: d.tag === 1 ? d.stateNode : null
      });
    } catch (E) {
      setTimeout(function() {
        throw E;
      });
    }
  }
  function nS(l, d, p) {
    return p = _l(p), p.tag = 3, p.payload = { element: null }, p.callback = function() {
      Uy(l, d);
    }, p;
  }
  function u2(l) {
    return l = _l(l), l.tag = 3, l;
  }
  function d2(l, d, p, y) {
    var E = p.type.getDerivedStateFromError;
    if (typeof E == "function") {
      var T = y.value;
      l.payload = function() {
        return E(T);
      }, l.callback = function() {
        c2(d, p, y);
      };
    }
    var j = p.stateNode;
    j !== null && typeof j.componentDidCatch == "function" && (l.callback = function() {
      c2(d, p, y), typeof E != "function" && (Dl === null ? Dl = /* @__PURE__ */ new Set([this]) : Dl.add(this));
      var V = y.stack;
      this.componentDidCatch(y.value, {
        componentStack: V !== null ? V : ""
      });
    });
  }
  function SG(l, d, p, y, E) {
    if (p.flags |= 32768, y !== null && typeof y == "object" && typeof y.then == "function") {
      if (d = p.alternate, d !== null && Vd(
        d,
        p,
        E,
        !0
      ), p = to.current, p !== null) {
        switch (p.tag) {
          case 31:
          case 13:
            return _o === null ? Qy() : p.alternate === null && Qn === 0 && (Qn = 3), p.flags &= -257, p.flags |= 65536, p.lanes = E, y === Ay ? p.flags |= 16384 : (d = p.updateQueue, d === null ? p.updateQueue = /* @__PURE__ */ new Set([y]) : d.add(y), TS(l, y, E)), !1;
          case 22:
            return p.flags |= 65536, y === Ay ? p.flags |= 16384 : (d = p.updateQueue, d === null ? (d = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([y])
            }, p.updateQueue = d) : (p = d.retryQueue, p === null ? d.retryQueue = /* @__PURE__ */ new Set([y]) : p.add(y)), TS(l, y, E)), !1;
        }
        throw Error(r(435, p.tag));
      }
      return TS(l, y, E), Qy(), !1;
    }
    if (Qt)
      return d = to.current, d !== null ? ((d.flags & 65536) === 0 && (d.flags |= 256), d.flags |= 65536, d.lanes = E, y !== w1 && (l = Error(r(422), { cause: y }), fp(So(l, p)))) : (y !== w1 && (d = Error(r(423), {
        cause: y
      }), fp(
        So(d, p)
      )), l = l.current.alternate, l.flags |= 65536, E &= -E, l.lanes |= E, y = So(y, p), E = nS(
        l.stateNode,
        y,
        E
      ), O1(l, E), Qn !== 4 && (Qn = 2)), !1;
    var T = Error(r(520), { cause: y });
    if (T = So(T, p), Rp === null ? Rp = [T] : Rp.push(T), Qn !== 4 && (Qn = 2), d === null) return !0;
    y = So(y, p), p = d;
    do {
      switch (p.tag) {
        case 3:
          return p.flags |= 65536, l = E & -E, p.lanes |= l, l = nS(p.stateNode, y, l), O1(p, l), !1;
        case 1:
          if (d = p.type, T = p.stateNode, (p.flags & 128) === 0 && (typeof d.getDerivedStateFromError == "function" || T !== null && typeof T.componentDidCatch == "function" && (Dl === null || !Dl.has(T))))
            return p.flags |= 65536, E &= -E, p.lanes |= E, E = u2(E), d2(
              E,
              l,
              p,
              y
            ), O1(p, E), !1;
      }
      p = p.return;
    } while (p !== null);
    return !1;
  }
  var rS = Error(r(461)), yr = !1;
  function Zr(l, d, p, y) {
    d.child = l === null ? mR(d, null, p, y) : yu(
      d,
      l.child,
      p,
      y
    );
  }
  function f2(l, d, p, y, E) {
    p = p.render;
    var T = d.ref;
    if ("ref" in y) {
      var j = {};
      for (var V in y)
        V !== "ref" && (j[V] = y[V]);
    } else j = y;
    return hu(d), y = L1(
      l,
      d,
      p,
      j,
      T,
      E
    ), V = B1(), l !== null && !yr ? ($1(l, d, E), Ca(l, d, E)) : (Qt && V && b1(d), d.flags |= 1, Zr(l, d, y, E), d.child);
  }
  function h2(l, d, p, y, E) {
    if (l === null) {
      var T = p.type;
      return typeof T == "function" && !g1(T) && T.defaultProps === void 0 && p.compare === null ? (d.tag = 15, d.type = T, p2(
        l,
        d,
        T,
        y,
        E
      )) : (l = Sy(
        p.type,
        null,
        y,
        d,
        d.mode,
        E
      ), l.ref = d.ref, l.return = d, d.child = l);
    }
    if (T = l.child, !dS(l, E)) {
      var j = T.memoizedProps;
      if (p = p.compare, p = p !== null ? p : C, p(j, y) && l.ref === d.ref)
        return Ca(l, d, E);
    }
    return d.flags |= 1, l = va(T, y), l.ref = d.ref, l.return = d, d.child = l;
  }
  function p2(l, d, p, y, E) {
    if (l !== null) {
      var T = l.memoizedProps;
      if (C(T, y) && l.ref === d.ref)
        if (yr = !1, d.pendingProps = y = T, dS(l, E))
          (l.flags & 131072) !== 0 && (yr = !0);
        else
          return d.lanes = l.lanes, Ca(l, d, E);
    }
    return iS(
      l,
      d,
      p,
      y,
      E
    );
  }
  function m2(l, d, p, y) {
    var E = y.children, T = l !== null ? l.memoizedState : null;
    if (l === null && d.stateNode === null && (d.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), y.mode === "hidden") {
      if ((d.flags & 128) !== 0) {
        if (T = T !== null ? T.baseLanes | p : p, l !== null) {
          for (y = d.child = l.child, E = 0; y !== null; )
            E = E | y.lanes | y.childLanes, y = y.sibling;
          y = E & ~T;
        } else y = 0, d.child = null;
        return g2(
          l,
          d,
          T,
          p,
          y
        );
      }
      if ((p & 536870912) !== 0)
        d.memoizedState = { baseLanes: 0, cachePool: null }, l !== null && _y(
          d,
          T !== null ? T.cachePool : null
        ), T !== null ? vR(d, T) : P1(), bR(d);
      else
        return y = d.lanes = 536870912, g2(
          l,
          d,
          T !== null ? T.baseLanes | p : p,
          p,
          y
        );
    } else
      T !== null ? (_y(d, T.cachePool), vR(d, T), Ml(), d.memoizedState = null) : (l !== null && _y(d, null), P1(), Ml());
    return Zr(l, d, E, p), d.child;
  }
  function Cp(l, d) {
    return l !== null && l.tag === 22 || d.stateNode !== null || (d.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), d.sibling;
  }
  function g2(l, d, p, y, E) {
    var T = A1();
    return T = T === null ? null : { parent: mr._currentValue, pool: T }, d.memoizedState = {
      baseLanes: p,
      cachePool: T
    }, l !== null && _y(d, null), P1(), bR(d), l !== null && Vd(l, d, y, !0), d.childLanes = E, null;
  }
  function Fy(l, d) {
    return d = Hy(
      { mode: d.mode, children: d.children },
      l.mode
    ), d.ref = l.ref, l.child = d, d.return = l, d;
  }
  function y2(l, d, p) {
    return yu(d, l.child, null, p), l = Fy(d, d.pendingProps), l.flags |= 2, no(d), d.memoizedState = null, l;
  }
  function kG(l, d, p) {
    var y = d.pendingProps, E = (d.flags & 128) !== 0;
    if (d.flags &= -129, l === null) {
      if (Qt) {
        if (y.mode === "hidden")
          return l = Fy(d, y), d.lanes = 536870912, Cp(null, l);
        if (I1(d), (l = Ln) ? (l = MO(
          l,
          Eo
        ), l = l !== null && l.data === "&" ? l : null, l !== null && (d.memoizedState = {
          dehydrated: l,
          treeContext: wl !== null ? { id: Ts, overflow: As } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, p = eR(l), p.return = d, d.child = p, Gr = d, Ln = null)) : l = null, l === null) throw kl(d);
        return d.lanes = 536870912, null;
      }
      return Fy(d, y);
    }
    var T = l.memoizedState;
    if (T !== null) {
      var j = T.dehydrated;
      if (I1(d), E)
        if (d.flags & 256)
          d.flags &= -257, d = y2(
            l,
            d,
            p
          );
        else if (d.memoizedState !== null)
          d.child = l.child, d.flags |= 128, d = null;
        else throw Error(r(558));
      else if (yr || Vd(l, d, p, !1), E = (p & l.childLanes) !== 0, yr || E) {
        if (y = Cn, y !== null && (j = sr(y, p), j !== 0 && j !== T.retryLane))
          throw T.retryLane = j, un(l, j), Fi(y, l, j), rS;
        Qy(), d = y2(
          l,
          d,
          p
        );
      } else
        l = T.treeContext, Ln = To(j.nextSibling), Gr = d, Qt = !0, Sl = null, Eo = !1, l !== null && rR(d, l), d = Fy(d, y), d.flags |= 4096;
      return d;
    }
    return l = va(l.child, {
      mode: y.mode,
      children: y.children
    }), l.ref = d.ref, d.child = l, l.return = d, l;
  }
  function Vy(l, d) {
    var p = d.ref;
    if (p === null)
      l !== null && l.ref !== null && (d.flags |= 4194816);
    else {
      if (typeof p != "function" && typeof p != "object")
        throw Error(r(284));
      (l === null || l.ref !== p) && (d.flags |= 4194816);
    }
  }
  function iS(l, d, p, y, E) {
    return hu(d), p = L1(
      l,
      d,
      p,
      y,
      void 0,
      E
    ), y = B1(), l !== null && !yr ? ($1(l, d, E), Ca(l, d, E)) : (Qt && y && b1(d), d.flags |= 1, Zr(l, d, p, E), d.child);
  }
  function v2(l, d, p, y, E, T) {
    return hu(d), d.updateQueue = null, p = wR(
      d,
      y,
      p,
      E
    ), xR(l), y = B1(), l !== null && !yr ? ($1(l, d, T), Ca(l, d, T)) : (Qt && y && b1(d), d.flags |= 1, Zr(l, d, p, T), d.child);
  }
  function b2(l, d, p, y, E) {
    if (hu(d), d.stateNode === null) {
      var T = Bd, j = p.contextType;
      typeof j == "object" && j !== null && (T = Kr(j)), T = new p(y, T), d.memoizedState = T.state !== null && T.state !== void 0 ? T.state : null, T.updater = tS, d.stateNode = T, T._reactInternals = d, T = d.stateNode, T.props = y, T.state = d.memoizedState, T.refs = {}, N1(d), j = p.contextType, T.context = typeof j == "object" && j !== null ? Kr(j) : Bd, T.state = d.memoizedState, j = p.getDerivedStateFromProps, typeof j == "function" && (eS(
        d,
        p,
        j,
        y
      ), T.state = d.memoizedState), typeof p.getDerivedStateFromProps == "function" || typeof T.getSnapshotBeforeUpdate == "function" || typeof T.UNSAFE_componentWillMount != "function" && typeof T.componentWillMount != "function" || (j = T.state, typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount(), j !== T.state && tS.enqueueReplaceState(T, T.state, null), bp(d, y, T, E), vp(), T.state = d.memoizedState), typeof T.componentDidMount == "function" && (d.flags |= 4194308), y = !0;
    } else if (l === null) {
      T = d.stateNode;
      var V = d.memoizedProps, te = bu(p, V);
      T.props = te;
      var Ee = T.context, Oe = p.contextType;
      j = Bd, typeof Oe == "object" && Oe !== null && (j = Kr(Oe));
      var Ie = p.getDerivedStateFromProps;
      Oe = typeof Ie == "function" || typeof T.getSnapshotBeforeUpdate == "function", V = d.pendingProps !== V, Oe || typeof T.UNSAFE_componentWillReceiveProps != "function" && typeof T.componentWillReceiveProps != "function" || (V || Ee !== j) && o2(
        d,
        T,
        y,
        j
      ), El = !1;
      var Te = d.memoizedState;
      T.state = Te, bp(d, y, T, E), vp(), Ee = d.memoizedState, V || Te !== Ee || El ? (typeof Ie == "function" && (eS(
        d,
        p,
        Ie,
        y
      ), Ee = d.memoizedState), (te = El || i2(
        d,
        p,
        te,
        y,
        Te,
        Ee,
        j
      )) ? (Oe || typeof T.UNSAFE_componentWillMount != "function" && typeof T.componentWillMount != "function" || (typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount()), typeof T.componentDidMount == "function" && (d.flags |= 4194308)) : (typeof T.componentDidMount == "function" && (d.flags |= 4194308), d.memoizedProps = y, d.memoizedState = Ee), T.props = y, T.state = Ee, T.context = j, y = te) : (typeof T.componentDidMount == "function" && (d.flags |= 4194308), y = !1);
    } else {
      T = d.stateNode, R1(l, d), j = d.memoizedProps, Oe = bu(p, j), T.props = Oe, Ie = d.pendingProps, Te = T.context, Ee = p.contextType, te = Bd, typeof Ee == "object" && Ee !== null && (te = Kr(Ee)), V = p.getDerivedStateFromProps, (Ee = typeof V == "function" || typeof T.getSnapshotBeforeUpdate == "function") || typeof T.UNSAFE_componentWillReceiveProps != "function" && typeof T.componentWillReceiveProps != "function" || (j !== Ie || Te !== te) && o2(
        d,
        T,
        y,
        te
      ), El = !1, Te = d.memoizedState, T.state = Te, bp(d, y, T, E), vp();
      var Me = d.memoizedState;
      j !== Ie || Te !== Me || El || l !== null && l.dependencies !== null && Cy(l.dependencies) ? (typeof V == "function" && (eS(
        d,
        p,
        V,
        y
      ), Me = d.memoizedState), (Oe = El || i2(
        d,
        p,
        Oe,
        y,
        Te,
        Me,
        te
      ) || l !== null && l.dependencies !== null && Cy(l.dependencies)) ? (Ee || typeof T.UNSAFE_componentWillUpdate != "function" && typeof T.componentWillUpdate != "function" || (typeof T.componentWillUpdate == "function" && T.componentWillUpdate(y, Me, te), typeof T.UNSAFE_componentWillUpdate == "function" && T.UNSAFE_componentWillUpdate(
        y,
        Me,
        te
      )), typeof T.componentDidUpdate == "function" && (d.flags |= 4), typeof T.getSnapshotBeforeUpdate == "function" && (d.flags |= 1024)) : (typeof T.componentDidUpdate != "function" || j === l.memoizedProps && Te === l.memoizedState || (d.flags |= 4), typeof T.getSnapshotBeforeUpdate != "function" || j === l.memoizedProps && Te === l.memoizedState || (d.flags |= 1024), d.memoizedProps = y, d.memoizedState = Me), T.props = y, T.state = Me, T.context = te, y = Oe) : (typeof T.componentDidUpdate != "function" || j === l.memoizedProps && Te === l.memoizedState || (d.flags |= 4), typeof T.getSnapshotBeforeUpdate != "function" || j === l.memoizedProps && Te === l.memoizedState || (d.flags |= 1024), y = !1);
    }
    return T = y, Vy(l, d), y = (d.flags & 128) !== 0, T || y ? (T = d.stateNode, p = y && typeof p.getDerivedStateFromError != "function" ? null : T.render(), d.flags |= 1, l !== null && y ? (d.child = yu(
      d,
      l.child,
      null,
      E
    ), d.child = yu(
      d,
      null,
      p,
      E
    )) : Zr(l, d, p, E), d.memoizedState = T.state, l = d.child) : l = Ca(
      l,
      d,
      E
    ), l;
  }
  function x2(l, d, p, y) {
    return du(), d.flags |= 256, Zr(l, d, p, y), d.child;
  }
  var oS = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function sS(l) {
    return { baseLanes: l, cachePool: cR() };
  }
  function aS(l, d, p) {
    return l = l !== null ? l.childLanes & ~p : 0, d && (l |= io), l;
  }
  function w2(l, d, p) {
    var y = d.pendingProps, E = !1, T = (d.flags & 128) !== 0, j;
    if ((j = T) || (j = l !== null && l.memoizedState === null ? !1 : (cr.current & 2) !== 0), j && (E = !0, d.flags &= -129), j = (d.flags & 32) !== 0, d.flags &= -33, l === null) {
      if (Qt) {
        if (E ? Al(d) : Ml(), (l = Ln) ? (l = MO(
          l,
          Eo
        ), l = l !== null && l.data !== "&" ? l : null, l !== null && (d.memoizedState = {
          dehydrated: l,
          treeContext: wl !== null ? { id: Ts, overflow: As } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, p = eR(l), p.return = d, d.child = p, Gr = d, Ln = null)) : l = null, l === null) throw kl(d);
        return VS(l) ? d.lanes = 32 : d.lanes = 536870912, null;
      }
      var V = y.children;
      return y = y.fallback, E ? (Ml(), E = d.mode, V = Hy(
        { mode: "hidden", children: V },
        E
      ), y = uu(
        y,
        E,
        p,
        null
      ), V.return = d, y.return = d, V.sibling = y, d.child = V, y = d.child, y.memoizedState = sS(p), y.childLanes = aS(
        l,
        j,
        p
      ), d.memoizedState = oS, Cp(null, y)) : (Al(d), lS(d, V));
    }
    var te = l.memoizedState;
    if (te !== null && (V = te.dehydrated, V !== null)) {
      if (T)
        d.flags & 256 ? (Al(d), d.flags &= -257, d = cS(
          l,
          d,
          p
        )) : d.memoizedState !== null ? (Ml(), d.child = l.child, d.flags |= 128, d = null) : (Ml(), V = y.fallback, E = d.mode, y = Hy(
          { mode: "visible", children: y.children },
          E
        ), V = uu(
          V,
          E,
          p,
          null
        ), V.flags |= 2, y.return = d, V.return = d, y.sibling = V, d.child = y, yu(
          d,
          l.child,
          null,
          p
        ), y = d.child, y.memoizedState = sS(p), y.childLanes = aS(
          l,
          j,
          p
        ), d.memoizedState = oS, d = Cp(null, y));
      else if (Al(d), VS(V)) {
        if (j = V.nextSibling && V.nextSibling.dataset, j) var Ee = j.dgst;
        j = Ee, y = Error(r(419)), y.stack = "", y.digest = j, fp({ value: y, source: null, stack: null }), d = cS(
          l,
          d,
          p
        );
      } else if (yr || Vd(l, d, p, !1), j = (p & l.childLanes) !== 0, yr || j) {
        if (j = Cn, j !== null && (y = sr(j, p), y !== 0 && y !== te.retryLane))
          throw te.retryLane = y, un(l, y), Fi(j, l, y), rS;
        FS(V) || Qy(), d = cS(
          l,
          d,
          p
        );
      } else
        FS(V) ? (d.flags |= 192, d.child = l.child, d = null) : (l = te.treeContext, Ln = To(
          V.nextSibling
        ), Gr = d, Qt = !0, Sl = null, Eo = !1, l !== null && rR(d, l), d = lS(
          d,
          y.children
        ), d.flags |= 4096);
      return d;
    }
    return E ? (Ml(), V = y.fallback, E = d.mode, te = l.child, Ee = te.sibling, y = va(te, {
      mode: "hidden",
      children: y.children
    }), y.subtreeFlags = te.subtreeFlags & 65011712, Ee !== null ? V = va(
      Ee,
      V
    ) : (V = uu(
      V,
      E,
      p,
      null
    ), V.flags |= 2), V.return = d, y.return = d, y.sibling = V, d.child = y, Cp(null, y), y = d.child, V = l.child.memoizedState, V === null ? V = sS(p) : (E = V.cachePool, E !== null ? (te = mr._currentValue, E = E.parent !== te ? { parent: te, pool: te } : E) : E = cR(), V = {
      baseLanes: V.baseLanes | p,
      cachePool: E
    }), y.memoizedState = V, y.childLanes = aS(
      l,
      j,
      p
    ), d.memoizedState = oS, Cp(l.child, y)) : (Al(d), p = l.child, l = p.sibling, p = va(p, {
      mode: "visible",
      children: y.children
    }), p.return = d, p.sibling = null, l !== null && (j = d.deletions, j === null ? (d.deletions = [l], d.flags |= 16) : j.push(l)), d.child = p, d.memoizedState = null, p);
  }
  function lS(l, d) {
    return d = Hy(
      { mode: "visible", children: d },
      l.mode
    ), d.return = l, l.child = d;
  }
  function Hy(l, d) {
    return l = eo(22, l, null, d), l.lanes = 0, l;
  }
  function cS(l, d, p) {
    return yu(d, l.child, null, p), l = lS(
      d,
      d.pendingProps.children
    ), l.flags |= 2, d.memoizedState = null, l;
  }
  function S2(l, d, p) {
    l.lanes |= d;
    var y = l.alternate;
    y !== null && (y.lanes |= d), C1(l.return, d, p);
  }
  function uS(l, d, p, y, E, T) {
    var j = l.memoizedState;
    j === null ? l.memoizedState = {
      isBackwards: d,
      rendering: null,
      renderingStartTime: 0,
      last: y,
      tail: p,
      tailMode: E,
      treeForkCount: T
    } : (j.isBackwards = d, j.rendering = null, j.renderingStartTime = 0, j.last = y, j.tail = p, j.tailMode = E, j.treeForkCount = T);
  }
  function k2(l, d, p) {
    var y = d.pendingProps, E = y.revealOrder, T = y.tail;
    y = y.children;
    var j = cr.current, V = (j & 2) !== 0;
    if (V ? (j = j & 1 | 2, d.flags |= 128) : j &= 1, F(cr, j), Zr(l, d, y, p), y = Qt ? dp : 0, !V && l !== null && (l.flags & 128) !== 0)
      e: for (l = d.child; l !== null; ) {
        if (l.tag === 13)
          l.memoizedState !== null && S2(l, p, d);
        else if (l.tag === 19)
          S2(l, p, d);
        else if (l.child !== null) {
          l.child.return = l, l = l.child;
          continue;
        }
        if (l === d) break e;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === d)
            break e;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    switch (E) {
      case "forwards":
        for (p = d.child, E = null; p !== null; )
          l = p.alternate, l !== null && Oy(l) === null && (E = p), p = p.sibling;
        p = E, p === null ? (E = d.child, d.child = null) : (E = p.sibling, p.sibling = null), uS(
          d,
          !1,
          E,
          p,
          T,
          y
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (p = null, E = d.child, d.child = null; E !== null; ) {
          if (l = E.alternate, l !== null && Oy(l) === null) {
            d.child = E;
            break;
          }
          l = E.sibling, E.sibling = p, p = E, E = l;
        }
        uS(
          d,
          !0,
          p,
          null,
          T,
          y
        );
        break;
      case "together":
        uS(
          d,
          !1,
          null,
          null,
          void 0,
          y
        );
        break;
      default:
        d.memoizedState = null;
    }
    return d.child;
  }
  function Ca(l, d, p) {
    if (l !== null && (d.dependencies = l.dependencies), Ol |= d.lanes, (p & d.childLanes) === 0)
      if (l !== null) {
        if (Vd(
          l,
          d,
          p,
          !1
        ), (p & d.childLanes) === 0)
          return null;
      } else return null;
    if (l !== null && d.child !== l.child)
      throw Error(r(153));
    if (d.child !== null) {
      for (l = d.child, p = va(l, l.pendingProps), d.child = p, p.return = d; l.sibling !== null; )
        l = l.sibling, p = p.sibling = va(l, l.pendingProps), p.return = d;
      p.sibling = null;
    }
    return d.child;
  }
  function dS(l, d) {
    return (l.lanes & d) !== 0 ? !0 : (l = l.dependencies, !!(l !== null && Cy(l)));
  }
  function CG(l, d, p) {
    switch (d.tag) {
      case 3:
        xe(d, d.stateNode.containerInfo), Cl(d, mr, l.memoizedState.cache), du();
        break;
      case 27:
      case 5:
        Ae(d);
        break;
      case 4:
        xe(d, d.stateNode.containerInfo);
        break;
      case 10:
        Cl(
          d,
          d.type,
          d.memoizedProps.value
        );
        break;
      case 31:
        if (d.memoizedState !== null)
          return d.flags |= 128, I1(d), null;
        break;
      case 13:
        var y = d.memoizedState;
        if (y !== null)
          return y.dehydrated !== null ? (Al(d), d.flags |= 128, null) : (p & d.child.childLanes) !== 0 ? w2(l, d, p) : (Al(d), l = Ca(
            l,
            d,
            p
          ), l !== null ? l.sibling : null);
        Al(d);
        break;
      case 19:
        var E = (l.flags & 128) !== 0;
        if (y = (p & d.childLanes) !== 0, y || (Vd(
          l,
          d,
          p,
          !1
        ), y = (p & d.childLanes) !== 0), E) {
          if (y)
            return k2(
              l,
              d,
              p
            );
          d.flags |= 128;
        }
        if (E = d.memoizedState, E !== null && (E.rendering = null, E.tail = null, E.lastEffect = null), F(cr, cr.current), y) break;
        return null;
      case 22:
        return d.lanes = 0, m2(
          l,
          d,
          p,
          d.pendingProps
        );
      case 24:
        Cl(d, mr, l.memoizedState.cache);
    }
    return Ca(l, d, p);
  }
  function C2(l, d, p) {
    if (l !== null)
      if (l.memoizedProps !== d.pendingProps)
        yr = !0;
      else {
        if (!dS(l, p) && (d.flags & 128) === 0)
          return yr = !1, CG(
            l,
            d,
            p
          );
        yr = (l.flags & 131072) !== 0;
      }
    else
      yr = !1, Qt && (d.flags & 1048576) !== 0 && nR(d, dp, d.index);
    switch (d.lanes = 0, d.tag) {
      case 16:
        e: {
          var y = d.pendingProps;
          if (l = mu(d.elementType), d.type = l, typeof l == "function")
            g1(l) ? (y = bu(l, y), d.tag = 1, d = b2(
              null,
              d,
              l,
              y,
              p
            )) : (d.tag = 0, d = iS(
              null,
              d,
              l,
              y,
              p
            ));
          else {
            if (l != null) {
              var E = l.$$typeof;
              if (E === N) {
                d.tag = 11, d = f2(
                  null,
                  d,
                  l,
                  y,
                  p
                );
                break e;
              } else if (E === O) {
                d.tag = 14, d = h2(
                  null,
                  d,
                  l,
                  y,
                  p
                );
                break e;
              }
            }
            throw d = ie(l) || l, Error(r(306, d, ""));
          }
        }
        return d;
      case 0:
        return iS(
          l,
          d,
          d.type,
          d.pendingProps,
          p
        );
      case 1:
        return y = d.type, E = bu(
          y,
          d.pendingProps
        ), b2(
          l,
          d,
          y,
          E,
          p
        );
      case 3:
        e: {
          if (xe(
            d,
            d.stateNode.containerInfo
          ), l === null) throw Error(r(387));
          y = d.pendingProps;
          var T = d.memoizedState;
          E = T.element, R1(l, d), bp(d, y, null, p);
          var j = d.memoizedState;
          if (y = j.cache, Cl(d, mr, y), y !== T.cache && E1(
            d,
            [mr],
            p,
            !0
          ), vp(), y = j.element, T.isDehydrated)
            if (T = {
              element: y,
              isDehydrated: !1,
              cache: j.cache
            }, d.updateQueue.baseState = T, d.memoizedState = T, d.flags & 256) {
              d = x2(
                l,
                d,
                y,
                p
              );
              break e;
            } else if (y !== E) {
              E = So(
                Error(r(424)),
                d
              ), fp(E), d = x2(
                l,
                d,
                y,
                p
              );
              break e;
            } else
              for (l = d.stateNode.containerInfo, l.nodeType === 9 ? l = l.body : l = l.nodeName === "HTML" ? l.ownerDocument.body : l, Ln = To(l.firstChild), Gr = d, Qt = !0, Sl = null, Eo = !0, p = mR(
                d,
                null,
                y,
                p
              ), d.child = p; p; )
                p.flags = p.flags & -3 | 4096, p = p.sibling;
          else {
            if (du(), y === E) {
              d = Ca(
                l,
                d,
                p
              );
              break e;
            }
            Zr(l, d, y, p);
          }
          d = d.child;
        }
        return d;
      case 26:
        return Vy(l, d), l === null ? (p = jO(
          d.type,
          null,
          d.pendingProps,
          null
        )) ? d.memoizedState = p : Qt || (p = d.type, l = d.pendingProps, y = sv(
          re.current
        ).createElement(p), y[Nn] = d, y[ar] = l, Yr(y, p, l), lr(y), d.stateNode = y) : d.memoizedState = jO(
          d.type,
          l.memoizedProps,
          d.pendingProps,
          l.memoizedState
        ), null;
      case 27:
        return Ae(d), l === null && Qt && (y = d.stateNode = OO(
          d.type,
          d.pendingProps,
          re.current
        ), Gr = d, Eo = !0, E = Ln, zl(d.type) ? (HS = E, Ln = To(y.firstChild)) : Ln = E), Zr(
          l,
          d,
          d.pendingProps.children,
          p
        ), Vy(l, d), l === null && (d.flags |= 4194304), d.child;
      case 5:
        return l === null && Qt && ((E = y = Ln) && (y = eK(
          y,
          d.type,
          d.pendingProps,
          Eo
        ), y !== null ? (d.stateNode = y, Gr = d, Ln = To(y.firstChild), Eo = !1, E = !0) : E = !1), E || kl(d)), Ae(d), E = d.type, T = d.pendingProps, j = l !== null ? l.memoizedProps : null, y = T.children, BS(E, T) ? y = null : j !== null && BS(E, j) && (d.flags |= 32), d.memoizedState !== null && (E = L1(
          l,
          d,
          mG,
          null,
          null,
          p
        ), Bp._currentValue = E), Vy(l, d), Zr(l, d, y, p), d.child;
      case 6:
        return l === null && Qt && ((l = p = Ln) && (p = tK(
          p,
          d.pendingProps,
          Eo
        ), p !== null ? (d.stateNode = p, Gr = d, Ln = null, l = !0) : l = !1), l || kl(d)), null;
      case 13:
        return w2(l, d, p);
      case 4:
        return xe(
          d,
          d.stateNode.containerInfo
        ), y = d.pendingProps, l === null ? d.child = yu(
          d,
          null,
          y,
          p
        ) : Zr(l, d, y, p), d.child;
      case 11:
        return f2(
          l,
          d,
          d.type,
          d.pendingProps,
          p
        );
      case 7:
        return Zr(
          l,
          d,
          d.pendingProps,
          p
        ), d.child;
      case 8:
        return Zr(
          l,
          d,
          d.pendingProps.children,
          p
        ), d.child;
      case 12:
        return Zr(
          l,
          d,
          d.pendingProps.children,
          p
        ), d.child;
      case 10:
        return y = d.pendingProps, Cl(d, d.type, y.value), Zr(l, d, y.children, p), d.child;
      case 9:
        return E = d.type._context, y = d.pendingProps.children, hu(d), E = Kr(E), y = y(E), d.flags |= 1, Zr(l, d, y, p), d.child;
      case 14:
        return h2(
          l,
          d,
          d.type,
          d.pendingProps,
          p
        );
      case 15:
        return p2(
          l,
          d,
          d.type,
          d.pendingProps,
          p
        );
      case 19:
        return k2(l, d, p);
      case 31:
        return kG(l, d, p);
      case 22:
        return m2(
          l,
          d,
          p,
          d.pendingProps
        );
      case 24:
        return hu(d), y = Kr(mr), l === null ? (E = A1(), E === null && (E = Cn, T = _1(), E.pooledCache = T, T.refCount++, T !== null && (E.pooledCacheLanes |= p), E = T), d.memoizedState = { parent: y, cache: E }, N1(d), Cl(d, mr, E)) : ((l.lanes & p) !== 0 && (R1(l, d), bp(d, null, null, p), vp()), E = l.memoizedState, T = d.memoizedState, E.parent !== y ? (E = { parent: y, cache: y }, d.memoizedState = E, d.lanes === 0 && (d.memoizedState = d.updateQueue.baseState = E), Cl(d, mr, y)) : (y = T.cache, Cl(d, mr, y), y !== E.cache && E1(
          d,
          [mr],
          p,
          !0
        ))), Zr(
          l,
          d,
          d.pendingProps.children,
          p
        ), d.child;
      case 29:
        throw d.pendingProps;
    }
    throw Error(r(156, d.tag));
  }
  function Ea(l) {
    l.flags |= 4;
  }
  function fS(l, d, p, y, E) {
    if ((d = (l.mode & 32) !== 0) && (d = !1), d) {
      if (l.flags |= 16777216, (E & 335544128) === E)
        if (l.stateNode.complete) l.flags |= 8192;
        else if (X2()) l.flags |= 8192;
        else
          throw gu = Ay, M1;
    } else l.flags &= -16777217;
  }
  function E2(l, d) {
    if (d.type !== "stylesheet" || (d.state.loading & 4) !== 0)
      l.flags &= -16777217;
    else if (l.flags |= 16777216, !$O(d))
      if (X2()) l.flags |= 8192;
      else
        throw gu = Ay, M1;
  }
  function Wy(l, d) {
    d !== null && (l.flags |= 4), l.flags & 16384 && (d = l.tag !== 22 ? ay() : 536870912, l.lanes |= d, tf |= d);
  }
  function Ep(l, d) {
    if (!Qt)
      switch (l.tailMode) {
        case "hidden":
          d = l.tail;
          for (var p = null; d !== null; )
            d.alternate !== null && (p = d), d = d.sibling;
          p === null ? l.tail = null : p.sibling = null;
          break;
        case "collapsed":
          p = l.tail;
          for (var y = null; p !== null; )
            p.alternate !== null && (y = p), p = p.sibling;
          y === null ? d || l.tail === null ? l.tail = null : l.tail.sibling = null : y.sibling = null;
      }
  }
  function Bn(l) {
    var d = l.alternate !== null && l.alternate.child === l.child, p = 0, y = 0;
    if (d)
      for (var E = l.child; E !== null; )
        p |= E.lanes | E.childLanes, y |= E.subtreeFlags & 65011712, y |= E.flags & 65011712, E.return = l, E = E.sibling;
    else
      for (E = l.child; E !== null; )
        p |= E.lanes | E.childLanes, y |= E.subtreeFlags, y |= E.flags, E.return = l, E = E.sibling;
    return l.subtreeFlags |= y, l.childLanes = p, d;
  }
  function EG(l, d, p) {
    var y = d.pendingProps;
    switch (x1(d), d.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Bn(d), null;
      case 1:
        return Bn(d), null;
      case 3:
        return p = d.stateNode, y = null, l !== null && (y = l.memoizedState.cache), d.memoizedState.cache !== y && (d.flags |= 2048), wa(mr), be(), p.pendingContext && (p.context = p.pendingContext, p.pendingContext = null), (l === null || l.child === null) && (Fd(d) ? Ea(d) : l === null || l.memoizedState.isDehydrated && (d.flags & 256) === 0 || (d.flags |= 1024, S1())), Bn(d), null;
      case 26:
        var E = d.type, T = d.memoizedState;
        return l === null ? (Ea(d), T !== null ? (Bn(d), E2(d, T)) : (Bn(d), fS(
          d,
          E,
          null,
          y,
          p
        ))) : T ? T !== l.memoizedState ? (Ea(d), Bn(d), E2(d, T)) : (Bn(d), d.flags &= -16777217) : (l = l.memoizedProps, l !== y && Ea(d), Bn(d), fS(
          d,
          E,
          l,
          y,
          p
        )), null;
      case 27:
        if (tt(d), p = re.current, E = d.type, l !== null && d.stateNode != null)
          l.memoizedProps !== y && Ea(d);
        else {
          if (!y) {
            if (d.stateNode === null)
              throw Error(r(166));
            return Bn(d), null;
          }
          l = ee.current, Fd(d) ? iR(d) : (l = OO(E, y, p), d.stateNode = l, Ea(d));
        }
        return Bn(d), null;
      case 5:
        if (tt(d), E = d.type, l !== null && d.stateNode != null)
          l.memoizedProps !== y && Ea(d);
        else {
          if (!y) {
            if (d.stateNode === null)
              throw Error(r(166));
            return Bn(d), null;
          }
          if (T = ee.current, Fd(d))
            iR(d);
          else {
            var j = sv(
              re.current
            );
            switch (T) {
              case 1:
                T = j.createElementNS(
                  "http://www.w3.org/2000/svg",
                  E
                );
                break;
              case 2:
                T = j.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  E
                );
                break;
              default:
                switch (E) {
                  case "svg":
                    T = j.createElementNS(
                      "http://www.w3.org/2000/svg",
                      E
                    );
                    break;
                  case "math":
                    T = j.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      E
                    );
                    break;
                  case "script":
                    T = j.createElement("div"), T.innerHTML = "<script><\/script>", T = T.removeChild(
                      T.firstChild
                    );
                    break;
                  case "select":
                    T = typeof y.is == "string" ? j.createElement("select", {
                      is: y.is
                    }) : j.createElement("select"), y.multiple ? T.multiple = !0 : y.size && (T.size = y.size);
                    break;
                  default:
                    T = typeof y.is == "string" ? j.createElement(E, { is: y.is }) : j.createElement(E);
                }
            }
            T[Nn] = d, T[ar] = y;
            e: for (j = d.child; j !== null; ) {
              if (j.tag === 5 || j.tag === 6)
                T.appendChild(j.stateNode);
              else if (j.tag !== 4 && j.tag !== 27 && j.child !== null) {
                j.child.return = j, j = j.child;
                continue;
              }
              if (j === d) break e;
              for (; j.sibling === null; ) {
                if (j.return === null || j.return === d)
                  break e;
                j = j.return;
              }
              j.sibling.return = j.return, j = j.sibling;
            }
            d.stateNode = T;
            e: switch (Yr(T, E, y), E) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                y = !!y.autoFocus;
                break e;
              case "img":
                y = !0;
                break e;
              default:
                y = !1;
            }
            y && Ea(d);
          }
        }
        return Bn(d), fS(
          d,
          d.type,
          l === null ? null : l.memoizedProps,
          d.pendingProps,
          p
        ), null;
      case 6:
        if (l && d.stateNode != null)
          l.memoizedProps !== y && Ea(d);
        else {
          if (typeof y != "string" && d.stateNode === null)
            throw Error(r(166));
          if (l = re.current, Fd(d)) {
            if (l = d.stateNode, p = d.memoizedProps, y = null, E = Gr, E !== null)
              switch (E.tag) {
                case 27:
                case 5:
                  y = E.memoizedProps;
              }
            l[Nn] = d, l = !!(l.nodeValue === p || y !== null && y.suppressHydrationWarning === !0 || wO(l.nodeValue, p)), l || kl(d, !0);
          } else
            l = sv(l).createTextNode(
              y
            ), l[Nn] = d, d.stateNode = l;
        }
        return Bn(d), null;
      case 31:
        if (p = d.memoizedState, l === null || l.memoizedState !== null) {
          if (y = Fd(d), p !== null) {
            if (l === null) {
              if (!y) throw Error(r(318));
              if (l = d.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(557));
              l[Nn] = d;
            } else
              du(), (d.flags & 128) === 0 && (d.memoizedState = null), d.flags |= 4;
            Bn(d), l = !1;
          } else
            p = S1(), l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = p), l = !0;
          if (!l)
            return d.flags & 256 ? (no(d), d) : (no(d), null);
          if ((d.flags & 128) !== 0)
            throw Error(r(558));
        }
        return Bn(d), null;
      case 13:
        if (y = d.memoizedState, l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) {
          if (E = Fd(d), y !== null && y.dehydrated !== null) {
            if (l === null) {
              if (!E) throw Error(r(318));
              if (E = d.memoizedState, E = E !== null ? E.dehydrated : null, !E) throw Error(r(317));
              E[Nn] = d;
            } else
              du(), (d.flags & 128) === 0 && (d.memoizedState = null), d.flags |= 4;
            Bn(d), E = !1;
          } else
            E = S1(), l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = E), E = !0;
          if (!E)
            return d.flags & 256 ? (no(d), d) : (no(d), null);
        }
        return no(d), (d.flags & 128) !== 0 ? (d.lanes = p, d) : (p = y !== null, l = l !== null && l.memoizedState !== null, p && (y = d.child, E = null, y.alternate !== null && y.alternate.memoizedState !== null && y.alternate.memoizedState.cachePool !== null && (E = y.alternate.memoizedState.cachePool.pool), T = null, y.memoizedState !== null && y.memoizedState.cachePool !== null && (T = y.memoizedState.cachePool.pool), T !== E && (y.flags |= 2048)), p !== l && p && (d.child.flags |= 8192), Wy(d, d.updateQueue), Bn(d), null);
      case 4:
        return be(), l === null && PS(d.stateNode.containerInfo), Bn(d), null;
      case 10:
        return wa(d.type), Bn(d), null;
      case 19:
        if (pe(cr), y = d.memoizedState, y === null) return Bn(d), null;
        if (E = (d.flags & 128) !== 0, T = y.rendering, T === null)
          if (E) Ep(y, !1);
          else {
            if (Qn !== 0 || l !== null && (l.flags & 128) !== 0)
              for (l = d.child; l !== null; ) {
                if (T = Oy(l), T !== null) {
                  for (d.flags |= 128, Ep(y, !1), l = T.updateQueue, d.updateQueue = l, Wy(d, l), d.subtreeFlags = 0, l = p, p = d.child; p !== null; )
                    QN(p, l), p = p.sibling;
                  return F(
                    cr,
                    cr.current & 1 | 2
                  ), Qt && ba(d, y.treeForkCount), d.child;
                }
                l = l.sibling;
              }
            y.tail !== null && Mn() > Yy && (d.flags |= 128, E = !0, Ep(y, !1), d.lanes = 4194304);
          }
        else {
          if (!E)
            if (l = Oy(T), l !== null) {
              if (d.flags |= 128, E = !0, l = l.updateQueue, d.updateQueue = l, Wy(d, l), Ep(y, !0), y.tail === null && y.tailMode === "hidden" && !T.alternate && !Qt)
                return Bn(d), null;
            } else
              2 * Mn() - y.renderingStartTime > Yy && p !== 536870912 && (d.flags |= 128, E = !0, Ep(y, !1), d.lanes = 4194304);
          y.isBackwards ? (T.sibling = d.child, d.child = T) : (l = y.last, l !== null ? l.sibling = T : d.child = T, y.last = T);
        }
        return y.tail !== null ? (l = y.tail, y.rendering = l, y.tail = l.sibling, y.renderingStartTime = Mn(), l.sibling = null, p = cr.current, F(
          cr,
          E ? p & 1 | 2 : p & 1
        ), Qt && ba(d, y.treeForkCount), l) : (Bn(d), null);
      case 22:
      case 23:
        return no(d), j1(), y = d.memoizedState !== null, l !== null ? l.memoizedState !== null !== y && (d.flags |= 8192) : y && (d.flags |= 8192), y ? (p & 536870912) !== 0 && (d.flags & 128) === 0 && (Bn(d), d.subtreeFlags & 6 && (d.flags |= 8192)) : Bn(d), p = d.updateQueue, p !== null && Wy(d, p.retryQueue), p = null, l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (p = l.memoizedState.cachePool.pool), y = null, d.memoizedState !== null && d.memoizedState.cachePool !== null && (y = d.memoizedState.cachePool.pool), y !== p && (d.flags |= 2048), l !== null && pe(pu), null;
      case 24:
        return p = null, l !== null && (p = l.memoizedState.cache), d.memoizedState.cache !== p && (d.flags |= 2048), wa(mr), Bn(d), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(r(156, d.tag));
  }
  function _G(l, d) {
    switch (x1(d), d.tag) {
      case 1:
        return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
      case 3:
        return wa(mr), be(), l = d.flags, (l & 65536) !== 0 && (l & 128) === 0 ? (d.flags = l & -65537 | 128, d) : null;
      case 26:
      case 27:
      case 5:
        return tt(d), null;
      case 31:
        if (d.memoizedState !== null) {
          if (no(d), d.alternate === null)
            throw Error(r(340));
          du();
        }
        return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
      case 13:
        if (no(d), l = d.memoizedState, l !== null && l.dehydrated !== null) {
          if (d.alternate === null)
            throw Error(r(340));
          du();
        }
        return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
      case 19:
        return pe(cr), null;
      case 4:
        return be(), null;
      case 10:
        return wa(d.type), null;
      case 22:
      case 23:
        return no(d), j1(), l !== null && pe(pu), l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
      case 24:
        return wa(mr), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function _2(l, d) {
    switch (x1(d), d.tag) {
      case 3:
        wa(mr), be();
        break;
      case 26:
      case 27:
      case 5:
        tt(d);
        break;
      case 4:
        be();
        break;
      case 31:
        d.memoizedState !== null && no(d);
        break;
      case 13:
        no(d);
        break;
      case 19:
        pe(cr);
        break;
      case 10:
        wa(d.type);
        break;
      case 22:
      case 23:
        no(d), j1(), l !== null && pe(pu);
        break;
      case 24:
        wa(mr);
    }
  }
  function _p(l, d) {
    try {
      var p = d.updateQueue, y = p !== null ? p.lastEffect : null;
      if (y !== null) {
        var E = y.next;
        p = E;
        do {
          if ((p.tag & l) === l) {
            y = void 0;
            var T = p.create, j = p.inst;
            y = T(), j.destroy = y;
          }
          p = p.next;
        } while (p !== E);
      }
    } catch (V) {
      pn(d, d.return, V);
    }
  }
  function Nl(l, d, p) {
    try {
      var y = d.updateQueue, E = y !== null ? y.lastEffect : null;
      if (E !== null) {
        var T = E.next;
        y = T;
        do {
          if ((y.tag & l) === l) {
            var j = y.inst, V = j.destroy;
            if (V !== void 0) {
              j.destroy = void 0, E = d;
              var te = p, Ee = V;
              try {
                Ee();
              } catch (Oe) {
                pn(
                  E,
                  te,
                  Oe
                );
              }
            }
          }
          y = y.next;
        } while (y !== T);
      }
    } catch (Oe) {
      pn(d, d.return, Oe);
    }
  }
  function T2(l) {
    var d = l.updateQueue;
    if (d !== null) {
      var p = l.stateNode;
      try {
        yR(d, p);
      } catch (y) {
        pn(l, l.return, y);
      }
    }
  }
  function A2(l, d, p) {
    p.props = bu(
      l.type,
      l.memoizedProps
    ), p.state = l.memoizedState;
    try {
      p.componentWillUnmount();
    } catch (y) {
      pn(l, d, y);
    }
  }
  function Tp(l, d) {
    try {
      var p = l.ref;
      if (p !== null) {
        switch (l.tag) {
          case 26:
          case 27:
          case 5:
            var y = l.stateNode;
            break;
          case 30:
            y = l.stateNode;
            break;
          default:
            y = l.stateNode;
        }
        typeof p == "function" ? l.refCleanup = p(y) : p.current = y;
      }
    } catch (E) {
      pn(l, d, E);
    }
  }
  function Ms(l, d) {
    var p = l.ref, y = l.refCleanup;
    if (p !== null)
      if (typeof y == "function")
        try {
          y();
        } catch (E) {
          pn(l, d, E);
        } finally {
          l.refCleanup = null, l = l.alternate, l != null && (l.refCleanup = null);
        }
      else if (typeof p == "function")
        try {
          p(null);
        } catch (E) {
          pn(l, d, E);
        }
      else p.current = null;
  }
  function M2(l) {
    var d = l.type, p = l.memoizedProps, y = l.stateNode;
    try {
      e: switch (d) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          p.autoFocus && y.focus();
          break e;
        case "img":
          p.src ? y.src = p.src : p.srcSet && (y.srcset = p.srcSet);
      }
    } catch (E) {
      pn(l, l.return, E);
    }
  }
  function hS(l, d, p) {
    try {
      var y = l.stateNode;
      KG(y, l.type, p, d), y[ar] = d;
    } catch (E) {
      pn(l, l.return, E);
    }
  }
  function N2(l) {
    return l.tag === 5 || l.tag === 3 || l.tag === 26 || l.tag === 27 && zl(l.type) || l.tag === 4;
  }
  function pS(l) {
    e: for (; ; ) {
      for (; l.sibling === null; ) {
        if (l.return === null || N2(l.return)) return null;
        l = l.return;
      }
      for (l.sibling.return = l.return, l = l.sibling; l.tag !== 5 && l.tag !== 6 && l.tag !== 18; ) {
        if (l.tag === 27 && zl(l.type) || l.flags & 2 || l.child === null || l.tag === 4) continue e;
        l.child.return = l, l = l.child;
      }
      if (!(l.flags & 2)) return l.stateNode;
    }
  }
  function mS(l, d, p) {
    var y = l.tag;
    if (y === 5 || y === 6)
      l = l.stateNode, d ? (p.nodeType === 9 ? p.body : p.nodeName === "HTML" ? p.ownerDocument.body : p).insertBefore(l, d) : (d = p.nodeType === 9 ? p.body : p.nodeName === "HTML" ? p.ownerDocument.body : p, d.appendChild(l), p = p._reactRootContainer, p != null || d.onclick !== null || (d.onclick = zi));
    else if (y !== 4 && (y === 27 && zl(l.type) && (p = l.stateNode, d = null), l = l.child, l !== null))
      for (mS(l, d, p), l = l.sibling; l !== null; )
        mS(l, d, p), l = l.sibling;
  }
  function qy(l, d, p) {
    var y = l.tag;
    if (y === 5 || y === 6)
      l = l.stateNode, d ? p.insertBefore(l, d) : p.appendChild(l);
    else if (y !== 4 && (y === 27 && zl(l.type) && (p = l.stateNode), l = l.child, l !== null))
      for (qy(l, d, p), l = l.sibling; l !== null; )
        qy(l, d, p), l = l.sibling;
  }
  function R2(l) {
    var d = l.stateNode, p = l.memoizedProps;
    try {
      for (var y = l.type, E = d.attributes; E.length; )
        d.removeAttributeNode(E[0]);
      Yr(d, y, p), d[Nn] = l, d[ar] = p;
    } catch (T) {
      pn(l, l.return, T);
    }
  }
  var _a = !1, vr = !1, gS = !1, O2 = typeof WeakSet == "function" ? WeakSet : Set, Lr = null;
  function TG(l, d) {
    if (l = l.containerInfo, zS = hv, l = z(l), $(l)) {
      if ("selectionStart" in l)
        var p = {
          start: l.selectionStart,
          end: l.selectionEnd
        };
      else
        e: {
          p = (p = l.ownerDocument) && p.defaultView || window;
          var y = p.getSelection && p.getSelection();
          if (y && y.rangeCount !== 0) {
            p = y.anchorNode;
            var E = y.anchorOffset, T = y.focusNode;
            y = y.focusOffset;
            try {
              p.nodeType, T.nodeType;
            } catch {
              p = null;
              break e;
            }
            var j = 0, V = -1, te = -1, Ee = 0, Oe = 0, Ie = l, Te = null;
            t: for (; ; ) {
              for (var Me; Ie !== p || E !== 0 && Ie.nodeType !== 3 || (V = j + E), Ie !== T || y !== 0 && Ie.nodeType !== 3 || (te = j + y), Ie.nodeType === 3 && (j += Ie.nodeValue.length), (Me = Ie.firstChild) !== null; )
                Te = Ie, Ie = Me;
              for (; ; ) {
                if (Ie === l) break t;
                if (Te === p && ++Ee === E && (V = j), Te === T && ++Oe === y && (te = j), (Me = Ie.nextSibling) !== null) break;
                Ie = Te, Te = Ie.parentNode;
              }
              Ie = Me;
            }
            p = V === -1 || te === -1 ? null : { start: V, end: te };
          } else p = null;
        }
      p = p || { start: 0, end: 0 };
    } else p = null;
    for (LS = { focusedElem: l, selectionRange: p }, hv = !1, Lr = d; Lr !== null; )
      if (d = Lr, l = d.child, (d.subtreeFlags & 1028) !== 0 && l !== null)
        l.return = d, Lr = l;
      else
        for (; Lr !== null; ) {
          switch (d = Lr, T = d.alternate, l = d.flags, d.tag) {
            case 0:
              if ((l & 4) !== 0 && (l = d.updateQueue, l = l !== null ? l.events : null, l !== null))
                for (p = 0; p < l.length; p++)
                  E = l[p], E.ref.impl = E.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((l & 1024) !== 0 && T !== null) {
                l = void 0, p = d, E = T.memoizedProps, T = T.memoizedState, y = p.stateNode;
                try {
                  var rt = bu(
                    p.type,
                    E
                  );
                  l = y.getSnapshotBeforeUpdate(
                    rt,
                    T
                  ), y.__reactInternalSnapshotBeforeUpdate = l;
                } catch (vt) {
                  pn(
                    p,
                    p.return,
                    vt
                  );
                }
              }
              break;
            case 3:
              if ((l & 1024) !== 0) {
                if (l = d.stateNode.containerInfo, p = l.nodeType, p === 9)
                  US(l);
                else if (p === 1)
                  switch (l.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      US(l);
                      break;
                    default:
                      l.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((l & 1024) !== 0) throw Error(r(163));
          }
          if (l = d.sibling, l !== null) {
            l.return = d.return, Lr = l;
            break;
          }
          Lr = d.return;
        }
  }
  function D2(l, d, p) {
    var y = p.flags;
    switch (p.tag) {
      case 0:
      case 11:
      case 15:
        Aa(l, p), y & 4 && _p(5, p);
        break;
      case 1:
        if (Aa(l, p), y & 4)
          if (l = p.stateNode, d === null)
            try {
              l.componentDidMount();
            } catch (j) {
              pn(p, p.return, j);
            }
          else {
            var E = bu(
              p.type,
              d.memoizedProps
            );
            d = d.memoizedState;
            try {
              l.componentDidUpdate(
                E,
                d,
                l.__reactInternalSnapshotBeforeUpdate
              );
            } catch (j) {
              pn(
                p,
                p.return,
                j
              );
            }
          }
        y & 64 && T2(p), y & 512 && Tp(p, p.return);
        break;
      case 3:
        if (Aa(l, p), y & 64 && (l = p.updateQueue, l !== null)) {
          if (d = null, p.child !== null)
            switch (p.child.tag) {
              case 27:
              case 5:
                d = p.child.stateNode;
                break;
              case 1:
                d = p.child.stateNode;
            }
          try {
            yR(l, d);
          } catch (j) {
            pn(p, p.return, j);
          }
        }
        break;
      case 27:
        d === null && y & 4 && R2(p);
      case 26:
      case 5:
        Aa(l, p), d === null && y & 4 && M2(p), y & 512 && Tp(p, p.return);
        break;
      case 12:
        Aa(l, p);
        break;
      case 31:
        Aa(l, p), y & 4 && I2(l, p);
        break;
      case 13:
        Aa(l, p), y & 4 && z2(l, p), y & 64 && (l = p.memoizedState, l !== null && (l = l.dehydrated, l !== null && (p = IG.bind(
          null,
          p
        ), nK(l, p))));
        break;
      case 22:
        if (y = p.memoizedState !== null || _a, !y) {
          d = d !== null && d.memoizedState !== null || vr, E = _a;
          var T = vr;
          _a = y, (vr = d) && !T ? Ma(
            l,
            p,
            (p.subtreeFlags & 8772) !== 0
          ) : Aa(l, p), _a = E, vr = T;
        }
        break;
      case 30:
        break;
      default:
        Aa(l, p);
    }
  }
  function P2(l) {
    var d = l.alternate;
    d !== null && (l.alternate = null, P2(d)), l.child = null, l.deletions = null, l.sibling = null, l.tag === 5 && (d = l.stateNode, d !== null && bd(d)), l.stateNode = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
  }
  var Wn = null, Li = !1;
  function Ta(l, d, p) {
    for (p = p.child; p !== null; )
      j2(l, d, p), p = p.sibling;
  }
  function j2(l, d, p) {
    if (nn && typeof nn.onCommitFiberUnmount == "function")
      try {
        nn.onCommitFiberUnmount(Lt, p);
      } catch {
      }
    switch (p.tag) {
      case 26:
        vr || Ms(p, d), Ta(
          l,
          d,
          p
        ), p.memoizedState ? p.memoizedState.count-- : p.stateNode && (p = p.stateNode, p.parentNode.removeChild(p));
        break;
      case 27:
        vr || Ms(p, d);
        var y = Wn, E = Li;
        zl(p.type) && (Wn = p.stateNode, Li = !1), Ta(
          l,
          d,
          p
        ), Ip(p.stateNode), Wn = y, Li = E;
        break;
      case 5:
        vr || Ms(p, d);
      case 6:
        if (y = Wn, E = Li, Wn = null, Ta(
          l,
          d,
          p
        ), Wn = y, Li = E, Wn !== null)
          if (Li)
            try {
              (Wn.nodeType === 9 ? Wn.body : Wn.nodeName === "HTML" ? Wn.ownerDocument.body : Wn).removeChild(p.stateNode);
            } catch (T) {
              pn(
                p,
                d,
                T
              );
            }
          else
            try {
              Wn.removeChild(p.stateNode);
            } catch (T) {
              pn(
                p,
                d,
                T
              );
            }
        break;
      case 18:
        Wn !== null && (Li ? (l = Wn, TO(
          l.nodeType === 9 ? l.body : l.nodeName === "HTML" ? l.ownerDocument.body : l,
          p.stateNode
        ), uf(l)) : TO(Wn, p.stateNode));
        break;
      case 4:
        y = Wn, E = Li, Wn = p.stateNode.containerInfo, Li = !0, Ta(
          l,
          d,
          p
        ), Wn = y, Li = E;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Nl(2, p, d), vr || Nl(4, p, d), Ta(
          l,
          d,
          p
        );
        break;
      case 1:
        vr || (Ms(p, d), y = p.stateNode, typeof y.componentWillUnmount == "function" && A2(
          p,
          d,
          y
        )), Ta(
          l,
          d,
          p
        );
        break;
      case 21:
        Ta(
          l,
          d,
          p
        );
        break;
      case 22:
        vr = (y = vr) || p.memoizedState !== null, Ta(
          l,
          d,
          p
        ), vr = y;
        break;
      default:
        Ta(
          l,
          d,
          p
        );
    }
  }
  function I2(l, d) {
    if (d.memoizedState === null && (l = d.alternate, l !== null && (l = l.memoizedState, l !== null))) {
      l = l.dehydrated;
      try {
        uf(l);
      } catch (p) {
        pn(d, d.return, p);
      }
    }
  }
  function z2(l, d) {
    if (d.memoizedState === null && (l = d.alternate, l !== null && (l = l.memoizedState, l !== null && (l = l.dehydrated, l !== null))))
      try {
        uf(l);
      } catch (p) {
        pn(d, d.return, p);
      }
  }
  function AG(l) {
    switch (l.tag) {
      case 31:
      case 13:
      case 19:
        var d = l.stateNode;
        return d === null && (d = l.stateNode = new O2()), d;
      case 22:
        return l = l.stateNode, d = l._retryCache, d === null && (d = l._retryCache = new O2()), d;
      default:
        throw Error(r(435, l.tag));
    }
  }
  function Gy(l, d) {
    var p = AG(l);
    d.forEach(function(y) {
      if (!p.has(y)) {
        p.add(y);
        var E = zG.bind(null, l, y);
        y.then(E, E);
      }
    });
  }
  function Bi(l, d) {
    var p = d.deletions;
    if (p !== null)
      for (var y = 0; y < p.length; y++) {
        var E = p[y], T = l, j = d, V = j;
        e: for (; V !== null; ) {
          switch (V.tag) {
            case 27:
              if (zl(V.type)) {
                Wn = V.stateNode, Li = !1;
                break e;
              }
              break;
            case 5:
              Wn = V.stateNode, Li = !1;
              break e;
            case 3:
            case 4:
              Wn = V.stateNode.containerInfo, Li = !0;
              break e;
          }
          V = V.return;
        }
        if (Wn === null) throw Error(r(160));
        j2(T, j, E), Wn = null, Li = !1, T = E.alternate, T !== null && (T.return = null), E.return = null;
      }
    if (d.subtreeFlags & 13886)
      for (d = d.child; d !== null; )
        L2(d, l), d = d.sibling;
  }
  var Jo = null;
  function L2(l, d) {
    var p = l.alternate, y = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Bi(d, l), $i(l), y & 4 && (Nl(3, l, l.return), _p(3, l), Nl(5, l, l.return));
        break;
      case 1:
        Bi(d, l), $i(l), y & 512 && (vr || p === null || Ms(p, p.return)), y & 64 && _a && (l = l.updateQueue, l !== null && (y = l.callbacks, y !== null && (p = l.shared.hiddenCallbacks, l.shared.hiddenCallbacks = p === null ? y : p.concat(y))));
        break;
      case 26:
        var E = Jo;
        if (Bi(d, l), $i(l), y & 512 && (vr || p === null || Ms(p, p.return)), y & 4) {
          var T = p !== null ? p.memoizedState : null;
          if (y = l.memoizedState, p === null)
            if (y === null)
              if (l.stateNode === null) {
                e: {
                  y = l.type, p = l.memoizedProps, E = E.ownerDocument || E;
                  t: switch (y) {
                    case "title":
                      T = E.getElementsByTagName("title")[0], (!T || T[Xi] || T[Nn] || T.namespaceURI === "http://www.w3.org/2000/svg" || T.hasAttribute("itemprop")) && (T = E.createElement(y), E.head.insertBefore(
                        T,
                        E.querySelector("head > title")
                      )), Yr(T, y, p), T[Nn] = l, lr(T), y = T;
                      break e;
                    case "link":
                      var j = LO(
                        "link",
                        "href",
                        E
                      ).get(y + (p.href || ""));
                      if (j) {
                        for (var V = 0; V < j.length; V++)
                          if (T = j[V], T.getAttribute("href") === (p.href == null || p.href === "" ? null : p.href) && T.getAttribute("rel") === (p.rel == null ? null : p.rel) && T.getAttribute("title") === (p.title == null ? null : p.title) && T.getAttribute("crossorigin") === (p.crossOrigin == null ? null : p.crossOrigin)) {
                            j.splice(V, 1);
                            break t;
                          }
                      }
                      T = E.createElement(y), Yr(T, y, p), E.head.appendChild(T);
                      break;
                    case "meta":
                      if (j = LO(
                        "meta",
                        "content",
                        E
                      ).get(y + (p.content || ""))) {
                        for (V = 0; V < j.length; V++)
                          if (T = j[V], T.getAttribute("content") === (p.content == null ? null : "" + p.content) && T.getAttribute("name") === (p.name == null ? null : p.name) && T.getAttribute("property") === (p.property == null ? null : p.property) && T.getAttribute("http-equiv") === (p.httpEquiv == null ? null : p.httpEquiv) && T.getAttribute("charset") === (p.charSet == null ? null : p.charSet)) {
                            j.splice(V, 1);
                            break t;
                          }
                      }
                      T = E.createElement(y), Yr(T, y, p), E.head.appendChild(T);
                      break;
                    default:
                      throw Error(r(468, y));
                  }
                  T[Nn] = l, lr(T), y = T;
                }
                l.stateNode = y;
              } else
                BO(
                  E,
                  l.type,
                  l.stateNode
                );
            else
              l.stateNode = zO(
                E,
                y,
                l.memoizedProps
              );
          else
            T !== y ? (T === null ? p.stateNode !== null && (p = p.stateNode, p.parentNode.removeChild(p)) : T.count--, y === null ? BO(
              E,
              l.type,
              l.stateNode
            ) : zO(
              E,
              y,
              l.memoizedProps
            )) : y === null && l.stateNode !== null && hS(
              l,
              l.memoizedProps,
              p.memoizedProps
            );
        }
        break;
      case 27:
        Bi(d, l), $i(l), y & 512 && (vr || p === null || Ms(p, p.return)), p !== null && y & 4 && hS(
          l,
          l.memoizedProps,
          p.memoizedProps
        );
        break;
      case 5:
        if (Bi(d, l), $i(l), y & 512 && (vr || p === null || Ms(p, p.return)), l.flags & 32) {
          E = l.stateNode;
          try {
            la(E, "");
          } catch (rt) {
            pn(l, l.return, rt);
          }
        }
        y & 4 && l.stateNode != null && (E = l.memoizedProps, hS(
          l,
          E,
          p !== null ? p.memoizedProps : E
        )), y & 1024 && (gS = !0);
        break;
      case 6:
        if (Bi(d, l), $i(l), y & 4) {
          if (l.stateNode === null)
            throw Error(r(162));
          y = l.memoizedProps, p = l.stateNode;
          try {
            p.nodeValue = y;
          } catch (rt) {
            pn(l, l.return, rt);
          }
        }
        break;
      case 3:
        if (cv = null, E = Jo, Jo = av(d.containerInfo), Bi(d, l), Jo = E, $i(l), y & 4 && p !== null && p.memoizedState.isDehydrated)
          try {
            uf(d.containerInfo);
          } catch (rt) {
            pn(l, l.return, rt);
          }
        gS && (gS = !1, B2(l));
        break;
      case 4:
        y = Jo, Jo = av(
          l.stateNode.containerInfo
        ), Bi(d, l), $i(l), Jo = y;
        break;
      case 12:
        Bi(d, l), $i(l);
        break;
      case 31:
        Bi(d, l), $i(l), y & 4 && (y = l.updateQueue, y !== null && (l.updateQueue = null, Gy(l, y)));
        break;
      case 13:
        Bi(d, l), $i(l), l.child.flags & 8192 && l.memoizedState !== null != (p !== null && p.memoizedState !== null) && (Zy = Mn()), y & 4 && (y = l.updateQueue, y !== null && (l.updateQueue = null, Gy(l, y)));
        break;
      case 22:
        E = l.memoizedState !== null;
        var te = p !== null && p.memoizedState !== null, Ee = _a, Oe = vr;
        if (_a = Ee || E, vr = Oe || te, Bi(d, l), vr = Oe, _a = Ee, $i(l), y & 8192)
          e: for (d = l.stateNode, d._visibility = E ? d._visibility & -2 : d._visibility | 1, E && (p === null || te || _a || vr || xu(l)), p = null, d = l; ; ) {
            if (d.tag === 5 || d.tag === 26) {
              if (p === null) {
                te = p = d;
                try {
                  if (T = te.stateNode, E)
                    j = T.style, typeof j.setProperty == "function" ? j.setProperty("display", "none", "important") : j.display = "none";
                  else {
                    V = te.stateNode;
                    var Ie = te.memoizedProps.style, Te = Ie != null && Ie.hasOwnProperty("display") ? Ie.display : null;
                    V.style.display = Te == null || typeof Te == "boolean" ? "" : ("" + Te).trim();
                  }
                } catch (rt) {
                  pn(te, te.return, rt);
                }
              }
            } else if (d.tag === 6) {
              if (p === null) {
                te = d;
                try {
                  te.stateNode.nodeValue = E ? "" : te.memoizedProps;
                } catch (rt) {
                  pn(te, te.return, rt);
                }
              }
            } else if (d.tag === 18) {
              if (p === null) {
                te = d;
                try {
                  var Me = te.stateNode;
                  E ? AO(Me, !0) : AO(te.stateNode, !1);
                } catch (rt) {
                  pn(te, te.return, rt);
                }
              }
            } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === l) && d.child !== null) {
              d.child.return = d, d = d.child;
              continue;
            }
            if (d === l) break e;
            for (; d.sibling === null; ) {
              if (d.return === null || d.return === l) break e;
              p === d && (p = null), d = d.return;
            }
            p === d && (p = null), d.sibling.return = d.return, d = d.sibling;
          }
        y & 4 && (y = l.updateQueue, y !== null && (p = y.retryQueue, p !== null && (y.retryQueue = null, Gy(l, p))));
        break;
      case 19:
        Bi(d, l), $i(l), y & 4 && (y = l.updateQueue, y !== null && (l.updateQueue = null, Gy(l, y)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Bi(d, l), $i(l);
    }
  }
  function $i(l) {
    var d = l.flags;
    if (d & 2) {
      try {
        for (var p, y = l.return; y !== null; ) {
          if (N2(y)) {
            p = y;
            break;
          }
          y = y.return;
        }
        if (p == null) throw Error(r(160));
        switch (p.tag) {
          case 27:
            var E = p.stateNode, T = pS(l);
            qy(l, T, E);
            break;
          case 5:
            var j = p.stateNode;
            p.flags & 32 && (la(j, ""), p.flags &= -33);
            var V = pS(l);
            qy(l, V, j);
            break;
          case 3:
          case 4:
            var te = p.stateNode.containerInfo, Ee = pS(l);
            mS(
              l,
              Ee,
              te
            );
            break;
          default:
            throw Error(r(161));
        }
      } catch (Oe) {
        pn(l, l.return, Oe);
      }
      l.flags &= -3;
    }
    d & 4096 && (l.flags &= -4097);
  }
  function B2(l) {
    if (l.subtreeFlags & 1024)
      for (l = l.child; l !== null; ) {
        var d = l;
        B2(d), d.tag === 5 && d.flags & 1024 && d.stateNode.reset(), l = l.sibling;
      }
  }
  function Aa(l, d) {
    if (d.subtreeFlags & 8772)
      for (d = d.child; d !== null; )
        D2(l, d.alternate, d), d = d.sibling;
  }
  function xu(l) {
    for (l = l.child; l !== null; ) {
      var d = l;
      switch (d.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Nl(4, d, d.return), xu(d);
          break;
        case 1:
          Ms(d, d.return);
          var p = d.stateNode;
          typeof p.componentWillUnmount == "function" && A2(
            d,
            d.return,
            p
          ), xu(d);
          break;
        case 27:
          Ip(d.stateNode);
        case 26:
        case 5:
          Ms(d, d.return), xu(d);
          break;
        case 22:
          d.memoizedState === null && xu(d);
          break;
        case 30:
          xu(d);
          break;
        default:
          xu(d);
      }
      l = l.sibling;
    }
  }
  function Ma(l, d, p) {
    for (p = p && (d.subtreeFlags & 8772) !== 0, d = d.child; d !== null; ) {
      var y = d.alternate, E = l, T = d, j = T.flags;
      switch (T.tag) {
        case 0:
        case 11:
        case 15:
          Ma(
            E,
            T,
            p
          ), _p(4, T);
          break;
        case 1:
          if (Ma(
            E,
            T,
            p
          ), y = T, E = y.stateNode, typeof E.componentDidMount == "function")
            try {
              E.componentDidMount();
            } catch (Ee) {
              pn(y, y.return, Ee);
            }
          if (y = T, E = y.updateQueue, E !== null) {
            var V = y.stateNode;
            try {
              var te = E.shared.hiddenCallbacks;
              if (te !== null)
                for (E.shared.hiddenCallbacks = null, E = 0; E < te.length; E++)
                  gR(te[E], V);
            } catch (Ee) {
              pn(y, y.return, Ee);
            }
          }
          p && j & 64 && T2(T), Tp(T, T.return);
          break;
        case 27:
          R2(T);
        case 26:
        case 5:
          Ma(
            E,
            T,
            p
          ), p && y === null && j & 4 && M2(T), Tp(T, T.return);
          break;
        case 12:
          Ma(
            E,
            T,
            p
          );
          break;
        case 31:
          Ma(
            E,
            T,
            p
          ), p && j & 4 && I2(E, T);
          break;
        case 13:
          Ma(
            E,
            T,
            p
          ), p && j & 4 && z2(E, T);
          break;
        case 22:
          T.memoizedState === null && Ma(
            E,
            T,
            p
          ), Tp(T, T.return);
          break;
        case 30:
          break;
        default:
          Ma(
            E,
            T,
            p
          );
      }
      d = d.sibling;
    }
  }
  function yS(l, d) {
    var p = null;
    l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (p = l.memoizedState.cachePool.pool), l = null, d.memoizedState !== null && d.memoizedState.cachePool !== null && (l = d.memoizedState.cachePool.pool), l !== p && (l != null && l.refCount++, p != null && hp(p));
  }
  function vS(l, d) {
    l = null, d.alternate !== null && (l = d.alternate.memoizedState.cache), d = d.memoizedState.cache, d !== l && (d.refCount++, l != null && hp(l));
  }
  function Qo(l, d, p, y) {
    if (d.subtreeFlags & 10256)
      for (d = d.child; d !== null; )
        $2(
          l,
          d,
          p,
          y
        ), d = d.sibling;
  }
  function $2(l, d, p, y) {
    var E = d.flags;
    switch (d.tag) {
      case 0:
      case 11:
      case 15:
        Qo(
          l,
          d,
          p,
          y
        ), E & 2048 && _p(9, d);
        break;
      case 1:
        Qo(
          l,
          d,
          p,
          y
        );
        break;
      case 3:
        Qo(
          l,
          d,
          p,
          y
        ), E & 2048 && (l = null, d.alternate !== null && (l = d.alternate.memoizedState.cache), d = d.memoizedState.cache, d !== l && (d.refCount++, l != null && hp(l)));
        break;
      case 12:
        if (E & 2048) {
          Qo(
            l,
            d,
            p,
            y
          ), l = d.stateNode;
          try {
            var T = d.memoizedProps, j = T.id, V = T.onPostCommit;
            typeof V == "function" && V(
              j,
              d.alternate === null ? "mount" : "update",
              l.passiveEffectDuration,
              -0
            );
          } catch (te) {
            pn(d, d.return, te);
          }
        } else
          Qo(
            l,
            d,
            p,
            y
          );
        break;
      case 31:
        Qo(
          l,
          d,
          p,
          y
        );
        break;
      case 13:
        Qo(
          l,
          d,
          p,
          y
        );
        break;
      case 23:
        break;
      case 22:
        T = d.stateNode, j = d.alternate, d.memoizedState !== null ? T._visibility & 2 ? Qo(
          l,
          d,
          p,
          y
        ) : Ap(l, d) : T._visibility & 2 ? Qo(
          l,
          d,
          p,
          y
        ) : (T._visibility |= 2, Jd(
          l,
          d,
          p,
          y,
          (d.subtreeFlags & 10256) !== 0 || !1
        )), E & 2048 && yS(j, d);
        break;
      case 24:
        Qo(
          l,
          d,
          p,
          y
        ), E & 2048 && vS(d.alternate, d);
        break;
      default:
        Qo(
          l,
          d,
          p,
          y
        );
    }
  }
  function Jd(l, d, p, y, E) {
    for (E = E && ((d.subtreeFlags & 10256) !== 0 || !1), d = d.child; d !== null; ) {
      var T = l, j = d, V = p, te = y, Ee = j.flags;
      switch (j.tag) {
        case 0:
        case 11:
        case 15:
          Jd(
            T,
            j,
            V,
            te,
            E
          ), _p(8, j);
          break;
        case 23:
          break;
        case 22:
          var Oe = j.stateNode;
          j.memoizedState !== null ? Oe._visibility & 2 ? Jd(
            T,
            j,
            V,
            te,
            E
          ) : Ap(
            T,
            j
          ) : (Oe._visibility |= 2, Jd(
            T,
            j,
            V,
            te,
            E
          )), E && Ee & 2048 && yS(
            j.alternate,
            j
          );
          break;
        case 24:
          Jd(
            T,
            j,
            V,
            te,
            E
          ), E && Ee & 2048 && vS(j.alternate, j);
          break;
        default:
          Jd(
            T,
            j,
            V,
            te,
            E
          );
      }
      d = d.sibling;
    }
  }
  function Ap(l, d) {
    if (d.subtreeFlags & 10256)
      for (d = d.child; d !== null; ) {
        var p = l, y = d, E = y.flags;
        switch (y.tag) {
          case 22:
            Ap(p, y), E & 2048 && yS(
              y.alternate,
              y
            );
            break;
          case 24:
            Ap(p, y), E & 2048 && vS(y.alternate, y);
            break;
          default:
            Ap(p, y);
        }
        d = d.sibling;
      }
  }
  var Mp = 8192;
  function Qd(l, d, p) {
    if (l.subtreeFlags & Mp)
      for (l = l.child; l !== null; )
        U2(
          l,
          d,
          p
        ), l = l.sibling;
  }
  function U2(l, d, p) {
    switch (l.tag) {
      case 26:
        Qd(
          l,
          d,
          p
        ), l.flags & Mp && l.memoizedState !== null && pK(
          p,
          Jo,
          l.memoizedState,
          l.memoizedProps
        );
        break;
      case 5:
        Qd(
          l,
          d,
          p
        );
        break;
      case 3:
      case 4:
        var y = Jo;
        Jo = av(l.stateNode.containerInfo), Qd(
          l,
          d,
          p
        ), Jo = y;
        break;
      case 22:
        l.memoizedState === null && (y = l.alternate, y !== null && y.memoizedState !== null ? (y = Mp, Mp = 16777216, Qd(
          l,
          d,
          p
        ), Mp = y) : Qd(
          l,
          d,
          p
        ));
        break;
      default:
        Qd(
          l,
          d,
          p
        );
    }
  }
  function F2(l) {
    var d = l.alternate;
    if (d !== null && (l = d.child, l !== null)) {
      d.child = null;
      do
        d = l.sibling, l.sibling = null, l = d;
      while (l !== null);
    }
  }
  function Np(l) {
    var d = l.deletions;
    if ((l.flags & 16) !== 0) {
      if (d !== null)
        for (var p = 0; p < d.length; p++) {
          var y = d[p];
          Lr = y, H2(
            y,
            l
          );
        }
      F2(l);
    }
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; )
        V2(l), l = l.sibling;
  }
  function V2(l) {
    switch (l.tag) {
      case 0:
      case 11:
      case 15:
        Np(l), l.flags & 2048 && Nl(9, l, l.return);
        break;
      case 3:
        Np(l);
        break;
      case 12:
        Np(l);
        break;
      case 22:
        var d = l.stateNode;
        l.memoizedState !== null && d._visibility & 2 && (l.return === null || l.return.tag !== 13) ? (d._visibility &= -3, Ky(l)) : Np(l);
        break;
      default:
        Np(l);
    }
  }
  function Ky(l) {
    var d = l.deletions;
    if ((l.flags & 16) !== 0) {
      if (d !== null)
        for (var p = 0; p < d.length; p++) {
          var y = d[p];
          Lr = y, H2(
            y,
            l
          );
        }
      F2(l);
    }
    for (l = l.child; l !== null; ) {
      switch (d = l, d.tag) {
        case 0:
        case 11:
        case 15:
          Nl(8, d, d.return), Ky(d);
          break;
        case 22:
          p = d.stateNode, p._visibility & 2 && (p._visibility &= -3, Ky(d));
          break;
        default:
          Ky(d);
      }
      l = l.sibling;
    }
  }
  function H2(l, d) {
    for (; Lr !== null; ) {
      var p = Lr;
      switch (p.tag) {
        case 0:
        case 11:
        case 15:
          Nl(8, p, d);
          break;
        case 23:
        case 22:
          if (p.memoizedState !== null && p.memoizedState.cachePool !== null) {
            var y = p.memoizedState.cachePool.pool;
            y != null && y.refCount++;
          }
          break;
        case 24:
          hp(p.memoizedState.cache);
      }
      if (y = p.child, y !== null) y.return = p, Lr = y;
      else
        e: for (p = l; Lr !== null; ) {
          y = Lr;
          var E = y.sibling, T = y.return;
          if (P2(y), y === p) {
            Lr = null;
            break e;
          }
          if (E !== null) {
            E.return = T, Lr = E;
            break e;
          }
          Lr = T;
        }
    }
  }
  var MG = {
    getCacheForType: function(l) {
      var d = Kr(mr), p = d.data.get(l);
      return p === void 0 && (p = l(), d.data.set(l, p)), p;
    },
    cacheSignal: function() {
      return Kr(mr).controller.signal;
    }
  }, NG = typeof WeakMap == "function" ? WeakMap : Map, ln = 0, Cn = null, Wt = null, Zt = 0, hn = 0, ro = null, Rl = !1, ef = !1, bS = !1, Na = 0, Qn = 0, Ol = 0, wu = 0, xS = 0, io = 0, tf = 0, Rp = null, Ui = null, wS = !1, Zy = 0, W2 = 0, Yy = 1 / 0, Xy = null, Dl = null, Mr = 0, Pl = null, nf = null, Ra = 0, SS = 0, kS = null, q2 = null, Op = 0, CS = null;
  function oo() {
    return (ln & 2) !== 0 && Zt !== 0 ? Zt & -Zt : H.T !== null ? NS() : Zc();
  }
  function G2() {
    if (io === 0)
      if ((Zt & 536870912) === 0 || Qt) {
        var l = al;
        al <<= 1, (al & 3932160) === 0 && (al = 262144), io = l;
      } else io = 536870912;
    return l = to.current, l !== null && (l.flags |= 32), io;
  }
  function Fi(l, d, p) {
    (l === Cn && (hn === 2 || hn === 9) || l.cancelPendingCommit !== null) && (rf(l, 0), jl(
      l,
      Zt,
      io,
      !1
    )), yo(l, p), ((ln & 2) === 0 || l !== Cn) && (l === Cn && ((ln & 2) === 0 && (wu |= p), Qn === 4 && jl(
      l,
      Zt,
      io,
      !1
    )), Ns(l));
  }
  function K2(l, d, p) {
    if ((ln & 6) !== 0) throw Error(r(327));
    var y = !p && (d & 127) === 0 && (d & l.expiredLanes) === 0 || oa(l, d), E = y ? DG(l, d) : _S(l, d, !0), T = y;
    do {
      if (E === 0) {
        ef && !y && jl(l, d, 0, !1);
        break;
      } else {
        if (p = l.current.alternate, T && !RG(p)) {
          E = _S(l, d, !1), T = !1;
          continue;
        }
        if (E === 2) {
          if (T = d, l.errorRecoveryDisabledLanes & T)
            var j = 0;
          else
            j = l.pendingLanes & -536870913, j = j !== 0 ? j : j & 536870912 ? 536870912 : 0;
          if (j !== 0) {
            d = j;
            e: {
              var V = l;
              E = Rp;
              var te = V.current.memoizedState.isDehydrated;
              if (te && (rf(V, j).flags |= 256), j = _S(
                V,
                j,
                !1
              ), j !== 2) {
                if (bS && !te) {
                  V.errorRecoveryDisabledLanes |= T, wu |= T, E = 4;
                  break e;
                }
                T = Ui, Ui = E, T !== null && (Ui === null ? Ui = T : Ui.push.apply(
                  Ui,
                  T
                ));
              }
              E = j;
            }
            if (T = !1, E !== 2) continue;
          }
        }
        if (E === 1) {
          rf(l, 0), jl(l, d, 0, !0);
          break;
        }
        e: {
          switch (y = l, T = E, T) {
            case 0:
            case 1:
              throw Error(r(345));
            case 4:
              if ((d & 4194048) !== d) break;
            case 6:
              jl(
                y,
                d,
                io,
                !Rl
              );
              break e;
            case 2:
              Ui = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r(329));
          }
          if ((d & 62914560) === d && (E = Zy + 300 - Mn(), 10 < E)) {
            if (jl(
              y,
              d,
              io,
              !Rl
            ), Gc(y, 0, !0) !== 0) break e;
            Ra = d, y.timeoutHandle = EO(
              Z2.bind(
                null,
                y,
                p,
                Ui,
                Xy,
                wS,
                d,
                io,
                wu,
                tf,
                Rl,
                T,
                "Throttled",
                -0,
                0
              ),
              E
            );
            break e;
          }
          Z2(
            y,
            p,
            Ui,
            Xy,
            wS,
            d,
            io,
            wu,
            tf,
            Rl,
            T,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Ns(l);
  }
  function Z2(l, d, p, y, E, T, j, V, te, Ee, Oe, Ie, Te, Me) {
    if (l.timeoutHandle = -1, Ie = d.subtreeFlags, Ie & 8192 || (Ie & 16785408) === 16785408) {
      Ie = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: zi
      }, U2(
        d,
        T,
        Ie
      );
      var rt = (T & 62914560) === T ? Zy - Mn() : (T & 4194048) === T ? W2 - Mn() : 0;
      if (rt = mK(
        Ie,
        rt
      ), rt !== null) {
        Ra = T, l.cancelPendingCommit = rt(
          rO.bind(
            null,
            l,
            d,
            T,
            p,
            y,
            E,
            j,
            V,
            te,
            Oe,
            Ie,
            null,
            Te,
            Me
          )
        ), jl(l, T, j, !Ee);
        return;
      }
    }
    rO(
      l,
      d,
      T,
      p,
      y,
      E,
      j,
      V,
      te
    );
  }
  function RG(l) {
    for (var d = l; ; ) {
      var p = d.tag;
      if ((p === 0 || p === 11 || p === 15) && d.flags & 16384 && (p = d.updateQueue, p !== null && (p = p.stores, p !== null)))
        for (var y = 0; y < p.length; y++) {
          var E = p[y], T = E.getSnapshot;
          E = E.value;
          try {
            if (!li(T(), E)) return !1;
          } catch {
            return !1;
          }
        }
      if (p = d.child, d.subtreeFlags & 16384 && p !== null)
        p.return = d, d = p;
      else {
        if (d === l) break;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === l) return !0;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
    }
    return !0;
  }
  function jl(l, d, p, y) {
    d &= ~xS, d &= ~wu, l.suspendedLanes |= d, l.pingedLanes &= ~d, y && (l.warmLanes |= d), y = l.expirationTimes;
    for (var E = d; 0 < E; ) {
      var T = 31 - Ve(E), j = 1 << T;
      y[T] = -1, E &= ~j;
    }
    p !== 0 && Kc(l, p, d);
  }
  function Jy() {
    return (ln & 6) === 0 ? (Dp(0), !1) : !0;
  }
  function ES() {
    if (Wt !== null) {
      if (hn === 0)
        var l = Wt.return;
      else
        l = Wt, xa = fu = null, U1(l), Gd = null, mp = 0, l = Wt;
      for (; l !== null; )
        _2(l.alternate, l), l = l.return;
      Wt = null;
    }
  }
  function rf(l, d) {
    var p = l.timeoutHandle;
    p !== -1 && (l.timeoutHandle = -1, XG(p)), p = l.cancelPendingCommit, p !== null && (l.cancelPendingCommit = null, p()), Ra = 0, ES(), Cn = l, Wt = p = va(l.current, null), Zt = d, hn = 0, ro = null, Rl = !1, ef = oa(l, d), bS = !1, tf = io = xS = wu = Ol = Qn = 0, Ui = Rp = null, wS = !1, (d & 8) !== 0 && (d |= d & 32);
    var y = l.entangledLanes;
    if (y !== 0)
      for (l = l.entanglements, y &= d; 0 < y; ) {
        var E = 31 - Ve(y), T = 1 << E;
        d |= l[E], y &= ~T;
      }
    return Na = d, Tt(), p;
  }
  function Y2(l, d) {
    Rt = null, H.H = kp, d === qd || d === Ty ? (d = fR(), hn = 3) : d === M1 ? (d = fR(), hn = 4) : hn = d === rS ? 8 : d !== null && typeof d == "object" && typeof d.then == "function" ? 6 : 1, ro = d, Wt === null && (Qn = 1, Uy(
      l,
      So(d, l.current)
    ));
  }
  function X2() {
    var l = to.current;
    return l === null ? !0 : (Zt & 4194048) === Zt ? _o === null : (Zt & 62914560) === Zt || (Zt & 536870912) !== 0 ? l === _o : !1;
  }
  function J2() {
    var l = H.H;
    return H.H = kp, l === null ? kp : l;
  }
  function Q2() {
    var l = H.A;
    return H.A = MG, l;
  }
  function Qy() {
    Qn = 4, Rl || (Zt & 4194048) !== Zt && to.current !== null || (ef = !0), (Ol & 134217727) === 0 && (wu & 134217727) === 0 || Cn === null || jl(
      Cn,
      Zt,
      io,
      !1
    );
  }
  function _S(l, d, p) {
    var y = ln;
    ln |= 2;
    var E = J2(), T = Q2();
    (Cn !== l || Zt !== d) && (Xy = null, rf(l, d)), d = !1;
    var j = Qn;
    e: do
      try {
        if (hn !== 0 && Wt !== null) {
          var V = Wt, te = ro;
          switch (hn) {
            case 8:
              ES(), j = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              to.current === null && (d = !0);
              var Ee = hn;
              if (hn = 0, ro = null, of(l, V, te, Ee), p && ef) {
                j = 0;
                break e;
              }
              break;
            default:
              Ee = hn, hn = 0, ro = null, of(l, V, te, Ee);
          }
        }
        OG(), j = Qn;
        break;
      } catch (Oe) {
        Y2(l, Oe);
      }
    while (!0);
    return d && l.shellSuspendCounter++, xa = fu = null, ln = y, H.H = E, H.A = T, Wt === null && (Cn = null, Zt = 0, Tt()), j;
  }
  function OG() {
    for (; Wt !== null; ) eO(Wt);
  }
  function DG(l, d) {
    var p = ln;
    ln |= 2;
    var y = J2(), E = Q2();
    Cn !== l || Zt !== d ? (Xy = null, Yy = Mn() + 500, rf(l, d)) : ef = oa(
      l,
      d
    );
    e: do
      try {
        if (hn !== 0 && Wt !== null) {
          d = Wt;
          var T = ro;
          t: switch (hn) {
            case 1:
              hn = 0, ro = null, of(l, d, T, 1);
              break;
            case 2:
            case 9:
              if (uR(T)) {
                hn = 0, ro = null, tO(d);
                break;
              }
              d = function() {
                hn !== 2 && hn !== 9 || Cn !== l || (hn = 7), Ns(l);
              }, T.then(d, d);
              break e;
            case 3:
              hn = 7;
              break e;
            case 4:
              hn = 5;
              break e;
            case 7:
              uR(T) ? (hn = 0, ro = null, tO(d)) : (hn = 0, ro = null, of(l, d, T, 7));
              break;
            case 5:
              var j = null;
              switch (Wt.tag) {
                case 26:
                  j = Wt.memoizedState;
                case 5:
                case 27:
                  var V = Wt;
                  if (j ? $O(j) : V.stateNode.complete) {
                    hn = 0, ro = null;
                    var te = V.sibling;
                    if (te !== null) Wt = te;
                    else {
                      var Ee = V.return;
                      Ee !== null ? (Wt = Ee, ev(Ee)) : Wt = null;
                    }
                    break t;
                  }
              }
              hn = 0, ro = null, of(l, d, T, 5);
              break;
            case 6:
              hn = 0, ro = null, of(l, d, T, 6);
              break;
            case 8:
              ES(), Qn = 6;
              break e;
            default:
              throw Error(r(462));
          }
        }
        PG();
        break;
      } catch (Oe) {
        Y2(l, Oe);
      }
    while (!0);
    return xa = fu = null, H.H = y, H.A = E, ln = p, Wt !== null ? 0 : (Cn = null, Zt = 0, Tt(), Qn);
  }
  function PG() {
    for (; Wt !== null && !sn(); )
      eO(Wt);
  }
  function eO(l) {
    var d = C2(l.alternate, l, Na);
    l.memoizedProps = l.pendingProps, d === null ? ev(l) : Wt = d;
  }
  function tO(l) {
    var d = l, p = d.alternate;
    switch (d.tag) {
      case 15:
      case 0:
        d = v2(
          p,
          d,
          d.pendingProps,
          d.type,
          void 0,
          Zt
        );
        break;
      case 11:
        d = v2(
          p,
          d,
          d.pendingProps,
          d.type.render,
          d.ref,
          Zt
        );
        break;
      case 5:
        U1(d);
      default:
        _2(p, d), d = Wt = QN(d, Na), d = C2(p, d, Na);
    }
    l.memoizedProps = l.pendingProps, d === null ? ev(l) : Wt = d;
  }
  function of(l, d, p, y) {
    xa = fu = null, U1(d), Gd = null, mp = 0;
    var E = d.return;
    try {
      if (SG(
        l,
        E,
        d,
        p,
        Zt
      )) {
        Qn = 1, Uy(
          l,
          So(p, l.current)
        ), Wt = null;
        return;
      }
    } catch (T) {
      if (E !== null) throw Wt = E, T;
      Qn = 1, Uy(
        l,
        So(p, l.current)
      ), Wt = null;
      return;
    }
    d.flags & 32768 ? (Qt || y === 1 ? l = !0 : ef || (Zt & 536870912) !== 0 ? l = !1 : (Rl = l = !0, (y === 2 || y === 9 || y === 3 || y === 6) && (y = to.current, y !== null && y.tag === 13 && (y.flags |= 16384))), nO(d, l)) : ev(d);
  }
  function ev(l) {
    var d = l;
    do {
      if ((d.flags & 32768) !== 0) {
        nO(
          d,
          Rl
        );
        return;
      }
      l = d.return;
      var p = EG(
        d.alternate,
        d,
        Na
      );
      if (p !== null) {
        Wt = p;
        return;
      }
      if (d = d.sibling, d !== null) {
        Wt = d;
        return;
      }
      Wt = d = l;
    } while (d !== null);
    Qn === 0 && (Qn = 5);
  }
  function nO(l, d) {
    do {
      var p = _G(l.alternate, l);
      if (p !== null) {
        p.flags &= 32767, Wt = p;
        return;
      }
      if (p = l.return, p !== null && (p.flags |= 32768, p.subtreeFlags = 0, p.deletions = null), !d && (l = l.sibling, l !== null)) {
        Wt = l;
        return;
      }
      Wt = l = p;
    } while (l !== null);
    Qn = 6, Wt = null;
  }
  function rO(l, d, p, y, E, T, j, V, te) {
    l.cancelPendingCommit = null;
    do
      tv();
    while (Mr !== 0);
    if ((ln & 6) !== 0) throw Error(r(327));
    if (d !== null) {
      if (d === l.current) throw Error(r(177));
      if (T = d.lanes | d.childLanes, T |= dt, Vh(
        l,
        p,
        T,
        j,
        V,
        te
      ), l === Cn && (Wt = Cn = null, Zt = 0), nf = d, Pl = l, Ra = p, SS = T, kS = E, q2 = y, (d.subtreeFlags & 10256) !== 0 || (d.flags & 10256) !== 0 ? (l.callbackNode = null, l.callbackPriority = 0, LG(He, function() {
        return lO(), null;
      })) : (l.callbackNode = null, l.callbackPriority = 0), y = (d.flags & 13878) !== 0, (d.subtreeFlags & 13878) !== 0 || y) {
        y = H.T, H.T = null, E = Q.p, Q.p = 2, j = ln, ln |= 4;
        try {
          TG(l, d, p);
        } finally {
          ln = j, Q.p = E, H.T = y;
        }
      }
      Mr = 1, iO(), oO(), sO();
    }
  }
  function iO() {
    if (Mr === 1) {
      Mr = 0;
      var l = Pl, d = nf, p = (d.flags & 13878) !== 0;
      if ((d.subtreeFlags & 13878) !== 0 || p) {
        p = H.T, H.T = null;
        var y = Q.p;
        Q.p = 2;
        var E = ln;
        ln |= 4;
        try {
          L2(d, l);
          var T = LS, j = z(l.containerInfo), V = T.focusedElem, te = T.selectionRange;
          if (j !== V && V && V.ownerDocument && D(
            V.ownerDocument.documentElement,
            V
          )) {
            if (te !== null && $(V)) {
              var Ee = te.start, Oe = te.end;
              if (Oe === void 0 && (Oe = Ee), "selectionStart" in V)
                V.selectionStart = Ee, V.selectionEnd = Math.min(
                  Oe,
                  V.value.length
                );
              else {
                var Ie = V.ownerDocument || document, Te = Ie && Ie.defaultView || window;
                if (Te.getSelection) {
                  var Me = Te.getSelection(), rt = V.textContent.length, vt = Math.min(te.start, rt), Sn = te.end === void 0 ? vt : Math.min(te.end, rt);
                  !Me.extend && vt > Sn && (j = Sn, Sn = vt, vt = j);
                  var me = R(
                    V,
                    vt
                  ), de = R(
                    V,
                    Sn
                  );
                  if (me && de && (Me.rangeCount !== 1 || Me.anchorNode !== me.node || Me.anchorOffset !== me.offset || Me.focusNode !== de.node || Me.focusOffset !== de.offset)) {
                    var Ce = Ie.createRange();
                    Ce.setStart(me.node, me.offset), Me.removeAllRanges(), vt > Sn ? (Me.addRange(Ce), Me.extend(de.node, de.offset)) : (Ce.setEnd(de.node, de.offset), Me.addRange(Ce));
                  }
                }
              }
            }
            for (Ie = [], Me = V; Me = Me.parentNode; )
              Me.nodeType === 1 && Ie.push({
                element: Me,
                left: Me.scrollLeft,
                top: Me.scrollTop
              });
            for (typeof V.focus == "function" && V.focus(), V = 0; V < Ie.length; V++) {
              var je = Ie[V];
              je.element.scrollLeft = je.left, je.element.scrollTop = je.top;
            }
          }
          hv = !!zS, LS = zS = null;
        } finally {
          ln = E, Q.p = y, H.T = p;
        }
      }
      l.current = d, Mr = 2;
    }
  }
  function oO() {
    if (Mr === 2) {
      Mr = 0;
      var l = Pl, d = nf, p = (d.flags & 8772) !== 0;
      if ((d.subtreeFlags & 8772) !== 0 || p) {
        p = H.T, H.T = null;
        var y = Q.p;
        Q.p = 2;
        var E = ln;
        ln |= 4;
        try {
          D2(l, d.alternate, d);
        } finally {
          ln = E, Q.p = y, H.T = p;
        }
      }
      Mr = 3;
    }
  }
  function sO() {
    if (Mr === 4 || Mr === 3) {
      Mr = 0, Pn();
      var l = Pl, d = nf, p = Ra, y = q2;
      (d.subtreeFlags & 10256) !== 0 || (d.flags & 10256) !== 0 ? Mr = 5 : (Mr = 0, nf = Pl = null, aO(l, l.pendingLanes));
      var E = l.pendingLanes;
      if (E === 0 && (Dl = null), ll(p), d = d.stateNode, nn && typeof nn.onCommitFiberRoot == "function")
        try {
          nn.onCommitFiberRoot(
            Lt,
            d,
            void 0,
            (d.current.flags & 128) === 128
          );
        } catch {
        }
      if (y !== null) {
        d = H.T, E = Q.p, Q.p = 2, H.T = null;
        try {
          for (var T = l.onRecoverableError, j = 0; j < y.length; j++) {
            var V = y[j];
            T(V.value, {
              componentStack: V.stack
            });
          }
        } finally {
          H.T = d, Q.p = E;
        }
      }
      (Ra & 3) !== 0 && tv(), Ns(l), E = l.pendingLanes, (p & 261930) !== 0 && (E & 42) !== 0 ? l === CS ? Op++ : (Op = 0, CS = l) : Op = 0, Dp(0);
    }
  }
  function aO(l, d) {
    (l.pooledCacheLanes &= d) === 0 && (d = l.pooledCache, d != null && (l.pooledCache = null, hp(d)));
  }
  function tv() {
    return iO(), oO(), sO(), lO();
  }
  function lO() {
    if (Mr !== 5) return !1;
    var l = Pl, d = SS;
    SS = 0;
    var p = ll(Ra), y = H.T, E = Q.p;
    try {
      Q.p = 32 > p ? 32 : p, H.T = null, p = kS, kS = null;
      var T = Pl, j = Ra;
      if (Mr = 0, nf = Pl = null, Ra = 0, (ln & 6) !== 0) throw Error(r(331));
      var V = ln;
      if (ln |= 4, V2(T.current), $2(
        T,
        T.current,
        j,
        p
      ), ln = V, Dp(0, !1), nn && typeof nn.onPostCommitFiberRoot == "function")
        try {
          nn.onPostCommitFiberRoot(Lt, T);
        } catch {
        }
      return !0;
    } finally {
      Q.p = E, H.T = y, aO(l, d);
    }
  }
  function cO(l, d, p) {
    d = So(p, d), d = nS(l.stateNode, d, 2), l = Tl(l, d, 2), l !== null && (yo(l, 2), Ns(l));
  }
  function pn(l, d, p) {
    if (l.tag === 3)
      cO(l, l, p);
    else
      for (; d !== null; ) {
        if (d.tag === 3) {
          cO(
            d,
            l,
            p
          );
          break;
        } else if (d.tag === 1) {
          var y = d.stateNode;
          if (typeof d.type.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && (Dl === null || !Dl.has(y))) {
            l = So(p, l), p = u2(2), y = Tl(d, p, 2), y !== null && (d2(
              p,
              y,
              d,
              l
            ), yo(y, 2), Ns(y));
            break;
          }
        }
        d = d.return;
      }
  }
  function TS(l, d, p) {
    var y = l.pingCache;
    if (y === null) {
      y = l.pingCache = new NG();
      var E = /* @__PURE__ */ new Set();
      y.set(d, E);
    } else
      E = y.get(d), E === void 0 && (E = /* @__PURE__ */ new Set(), y.set(d, E));
    E.has(p) || (bS = !0, E.add(p), l = jG.bind(null, l, d, p), d.then(l, l));
  }
  function jG(l, d, p) {
    var y = l.pingCache;
    y !== null && y.delete(d), l.pingedLanes |= l.suspendedLanes & p, l.warmLanes &= ~p, Cn === l && (Zt & p) === p && (Qn === 4 || Qn === 3 && (Zt & 62914560) === Zt && 300 > Mn() - Zy ? (ln & 2) === 0 && rf(l, 0) : xS |= p, tf === Zt && (tf = 0)), Ns(l);
  }
  function uO(l, d) {
    d === 0 && (d = ay()), l = un(l, d), l !== null && (yo(l, d), Ns(l));
  }
  function IG(l) {
    var d = l.memoizedState, p = 0;
    d !== null && (p = d.retryLane), uO(l, p);
  }
  function zG(l, d) {
    var p = 0;
    switch (l.tag) {
      case 31:
      case 13:
        var y = l.stateNode, E = l.memoizedState;
        E !== null && (p = E.retryLane);
        break;
      case 19:
        y = l.stateNode;
        break;
      case 22:
        y = l.stateNode._retryCache;
        break;
      default:
        throw Error(r(314));
    }
    y !== null && y.delete(d), uO(l, p);
  }
  function LG(l, d) {
    return An(l, d);
  }
  var nv = null, sf = null, AS = !1, rv = !1, MS = !1, Il = 0;
  function Ns(l) {
    l !== sf && l.next === null && (sf === null ? nv = sf = l : sf = sf.next = l), rv = !0, AS || (AS = !0, $G());
  }
  function Dp(l, d) {
    if (!MS && rv) {
      MS = !0;
      do
        for (var p = !1, y = nv; y !== null; ) {
          if (l !== 0) {
            var E = y.pendingLanes;
            if (E === 0) var T = 0;
            else {
              var j = y.suspendedLanes, V = y.pingedLanes;
              T = (1 << 31 - Ve(42 | l) + 1) - 1, T &= E & ~(j & ~V), T = T & 201326741 ? T & 201326741 | 1 : T ? T | 2 : 0;
            }
            T !== 0 && (p = !0, pO(y, T));
          } else
            T = Zt, T = Gc(
              y,
              y === Cn ? T : 0,
              y.cancelPendingCommit !== null || y.timeoutHandle !== -1
            ), (T & 3) === 0 || oa(y, T) || (p = !0, pO(y, T));
          y = y.next;
        }
      while (p);
      MS = !1;
    }
  }
  function BG() {
    dO();
  }
  function dO() {
    rv = AS = !1;
    var l = 0;
    Il !== 0 && YG() && (l = Il);
    for (var d = Mn(), p = null, y = nv; y !== null; ) {
      var E = y.next, T = fO(y, d);
      T === 0 ? (y.next = null, p === null ? nv = E : p.next = E, E === null && (sf = p)) : (p = y, (l !== 0 || (T & 3) !== 0) && (rv = !0)), y = E;
    }
    Mr !== 0 && Mr !== 5 || Dp(l), Il !== 0 && (Il = 0);
  }
  function fO(l, d) {
    for (var p = l.suspendedLanes, y = l.pingedLanes, E = l.expirationTimes, T = l.pendingLanes & -62914561; 0 < T; ) {
      var j = 31 - Ve(T), V = 1 << j, te = E[j];
      te === -1 ? ((V & p) === 0 || (V & y) !== 0) && (E[j] = a1(V, d)) : te <= d && (l.expiredLanes |= V), T &= ~V;
    }
    if (d = Cn, p = Zt, p = Gc(
      l,
      l === d ? p : 0,
      l.cancelPendingCommit !== null || l.timeoutHandle !== -1
    ), y = l.callbackNode, p === 0 || l === d && (hn === 2 || hn === 9) || l.cancelPendingCommit !== null)
      return y !== null && y !== null && Nt(y), l.callbackNode = null, l.callbackPriority = 0;
    if ((p & 3) === 0 || oa(l, p)) {
      if (d = p & -p, d === l.callbackPriority) return d;
      switch (y !== null && Nt(y), ll(p)) {
        case 2:
        case 8:
          p = Pe;
          break;
        case 32:
          p = He;
          break;
        case 268435456:
          p = bt;
          break;
        default:
          p = He;
      }
      return y = hO.bind(null, l), p = An(p, y), l.callbackPriority = d, l.callbackNode = p, d;
    }
    return y !== null && y !== null && Nt(y), l.callbackPriority = 2, l.callbackNode = null, 2;
  }
  function hO(l, d) {
    if (Mr !== 0 && Mr !== 5)
      return l.callbackNode = null, l.callbackPriority = 0, null;
    var p = l.callbackNode;
    if (tv() && l.callbackNode !== p)
      return null;
    var y = Zt;
    return y = Gc(
      l,
      l === Cn ? y : 0,
      l.cancelPendingCommit !== null || l.timeoutHandle !== -1
    ), y === 0 ? null : (K2(l, y, d), fO(l, Mn()), l.callbackNode != null && l.callbackNode === p ? hO.bind(null, l) : null);
  }
  function pO(l, d) {
    if (tv()) return null;
    K2(l, d, !0);
  }
  function $G() {
    JG(function() {
      (ln & 6) !== 0 ? An(
        ke,
        BG
      ) : dO();
    });
  }
  function NS() {
    if (Il === 0) {
      var l = Hd;
      l === 0 && (l = Ke, Ke <<= 1, (Ke & 261888) === 0 && (Ke = 256)), Il = l;
    }
    return Il;
  }
  function mO(l) {
    return l == null || typeof l == "symbol" || typeof l == "boolean" ? null : typeof l == "function" ? l : Xo("" + l);
  }
  function gO(l, d) {
    var p = d.ownerDocument.createElement("input");
    return p.name = d.name, p.value = d.value, l.id && p.setAttribute("form", l.id), d.parentNode.insertBefore(p, d), l = new FormData(l), p.parentNode.removeChild(p), l;
  }
  function UG(l, d, p, y, E) {
    if (d === "submit" && p && p.stateNode === E) {
      var T = mO(
        (E[ar] || null).action
      ), j = y.submitter;
      j && (d = (d = j[ar] || null) ? mO(d.formAction) : j.getAttribute("formAction"), d !== null && (T = d, j = null));
      var V = new Cd(
        "action",
        "action",
        null,
        y,
        E
      );
      l.push({
        event: V,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (y.defaultPrevented) {
                if (Il !== 0) {
                  var te = j ? gO(E, j) : new FormData(E);
                  Y1(
                    p,
                    {
                      pending: !0,
                      data: te,
                      method: E.method,
                      action: T
                    },
                    null,
                    te
                  );
                }
              } else
                typeof T == "function" && (V.preventDefault(), te = j ? gO(E, j) : new FormData(E), Y1(
                  p,
                  {
                    pending: !0,
                    data: te,
                    method: E.method,
                    action: T
                  },
                  T,
                  te
                ));
            },
            currentTarget: E
          }
        ]
      });
    }
  }
  for (var RS = 0; RS < Ze.length; RS++) {
    var OS = Ze[RS], FG = OS.toLowerCase(), VG = OS[0].toUpperCase() + OS.slice(1);
    Be(
      FG,
      "on" + VG
    );
  }
  Be(_e, "onAnimationEnd"), Be(ve, "onAnimationIteration"), Be(Re, "onAnimationStart"), Be("dblclick", "onDoubleClick"), Be("focusin", "onFocus"), Be("focusout", "onBlur"), Be(ze, "onTransitionRun"), Be(We, "onTransitionStart"), Be(qe, "onTransitionCancel"), Be(Le, "onTransitionEnd"), ws("onMouseEnter", ["mouseout", "mouseover"]), ws("onMouseLeave", ["mouseout", "mouseover"]), ws("onPointerEnter", ["pointerout", "pointerover"]), ws("onPointerLeave", ["pointerout", "pointerover"]), Zo(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Zo(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Zo("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Zo(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Zo(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Zo(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Pp = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), HG = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Pp)
  );
  function yO(l, d) {
    d = (d & 4) !== 0;
    for (var p = 0; p < l.length; p++) {
      var y = l[p], E = y.event;
      y = y.listeners;
      e: {
        var T = void 0;
        if (d)
          for (var j = y.length - 1; 0 <= j; j--) {
            var V = y[j], te = V.instance, Ee = V.currentTarget;
            if (V = V.listener, te !== T && E.isPropagationStopped())
              break e;
            T = V, E.currentTarget = Ee;
            try {
              T(E);
            } catch (Oe) {
              Je(Oe);
            }
            E.currentTarget = null, T = te;
          }
        else
          for (j = 0; j < y.length; j++) {
            if (V = y[j], te = V.instance, Ee = V.currentTarget, V = V.listener, te !== T && E.isPropagationStopped())
              break e;
            T = V, E.currentTarget = Ee;
            try {
              T(E);
            } catch (Oe) {
              Je(Oe);
            }
            E.currentTarget = null, T = te;
          }
      }
    }
  }
  function qt(l, d) {
    var p = d[cl];
    p === void 0 && (p = d[cl] = /* @__PURE__ */ new Set());
    var y = l + "__bubble";
    p.has(y) || (vO(d, l, 2, !1), p.add(y));
  }
  function DS(l, d, p) {
    var y = 0;
    d && (y |= 4), vO(
      p,
      l,
      y,
      d
    );
  }
  var iv = "_reactListening" + Math.random().toString(36).slice(2);
  function PS(l) {
    if (!l[iv]) {
      l[iv] = !0, sa.forEach(function(p) {
        p !== "selectionchange" && (HG.has(p) || DS(p, !1, l), DS(p, !0, l));
      });
      var d = l.nodeType === 9 ? l : l.ownerDocument;
      d === null || d[iv] || (d[iv] = !0, DS("selectionchange", !1, d));
    }
  }
  function vO(l, d, p, y) {
    switch (GO(d)) {
      case 2:
        var E = vK;
        break;
      case 8:
        E = bK;
        break;
      default:
        E = ZS;
    }
    p = E.bind(
      null,
      d,
      p,
      l
    ), E = void 0, !Xh || d !== "touchstart" && d !== "touchmove" && d !== "wheel" || (E = !0), y ? E !== void 0 ? l.addEventListener(d, p, {
      capture: !0,
      passive: E
    }) : l.addEventListener(d, p, !0) : E !== void 0 ? l.addEventListener(d, p, {
      passive: E
    }) : l.addEventListener(d, p, !1);
  }
  function jS(l, d, p, y, E) {
    var T = y;
    if ((d & 1) === 0 && (d & 2) === 0 && y !== null)
      e: for (; ; ) {
        if (y === null) return;
        var j = y.tag;
        if (j === 3 || j === 4) {
          var V = y.stateNode.containerInfo;
          if (V === E) break;
          if (j === 4)
            for (j = y.return; j !== null; ) {
              var te = j.tag;
              if ((te === 3 || te === 4) && j.stateNode.containerInfo === E)
                return;
              j = j.return;
            }
          for (; V !== null; ) {
            if (j = xs(V), j === null) return;
            if (te = j.tag, te === 5 || te === 6 || te === 26 || te === 27) {
              y = T = j;
              continue e;
            }
            V = V.parentNode;
          }
        }
        y = y.return;
      }
    dl(function() {
      var Ee = T, Oe = Sd(p), Ie = [];
      e: {
        var Te = Xe.get(l);
        if (Te !== void 0) {
          var Me = Cd, rt = l;
          switch (l) {
            case "keypress":
              if (pl(p) === 0) break e;
            case "keydown":
            case "keyup":
              Me = Rd;
              break;
            case "focusin":
              rt = "focus", Me = ml;
              break;
            case "focusout":
              rt = "blur", Me = ml;
              break;
            case "beforeblur":
            case "afterblur":
              Me = ml;
              break;
            case "click":
              if (p.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Me = Td;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Me = dy;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Me = ip;
              break;
            case _e:
            case ve:
            case Re:
              Me = fy;
              break;
            case Le:
              Me = op;
              break;
            case "scroll":
            case "scrollend":
              Me = Ed;
              break;
            case "wheel":
              Me = Dd;
              break;
            case "copy":
            case "cut":
            case "paste":
              Me = gl;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Me = rp;
              break;
            case "toggle":
            case "beforetoggle":
              Me = my;
          }
          var vt = (d & 4) !== 0, Sn = !vt && (l === "scroll" || l === "scrollend"), me = vt ? Te !== null ? Te + "Capture" : null : Te;
          vt = [];
          for (var de = Ee, Ce; de !== null; ) {
            var je = de;
            if (Ce = je.stateNode, je = je.tag, je !== 5 && je !== 26 && je !== 27 || Ce === null || me === null || (je = da(de, me), je != null && vt.push(
              jp(de, je, Ce)
            )), Sn) break;
            de = de.return;
          }
          0 < vt.length && (Te = new Me(
            Te,
            rt,
            null,
            p,
            Oe
          ), Ie.push({ event: Te, listeners: vt }));
        }
      }
      if ((d & 7) === 0) {
        e: {
          if (Te = l === "mouseover" || l === "pointerover", Me = l === "mouseout" || l === "pointerout", Te && p !== bo && (rt = p.relatedTarget || p.fromElement) && (xs(rt) || rt[wi]))
            break e;
          if ((Me || Te) && (Te = Oe.window === Oe ? Oe : (Te = Oe.ownerDocument) ? Te.defaultView || Te.parentWindow : window, Me ? (rt = p.relatedTarget || p.toElement, Me = Ee, rt = rt ? xs(rt) : null, rt !== null && (Sn = o(rt), vt = rt.tag, rt !== Sn || vt !== 5 && vt !== 27 && vt !== 6) && (rt = null)) : (Me = null, rt = Ee), Me !== rt)) {
            if (vt = Td, je = "onMouseLeave", me = "onMouseEnter", de = "mouse", (l === "pointerout" || l === "pointerover") && (vt = rp, je = "onPointerLeave", me = "onPointerEnter", de = "pointer"), Sn = Me == null ? Te : Ji(Me), Ce = rt == null ? Te : Ji(rt), Te = new vt(
              je,
              de + "leave",
              Me,
              p,
              Oe
            ), Te.target = Sn, Te.relatedTarget = Ce, je = null, xs(Oe) === Ee && (vt = new vt(
              me,
              de + "enter",
              rt,
              p,
              Oe
            ), vt.target = Ce, vt.relatedTarget = Sn, je = vt), Sn = je, Me && rt)
              t: {
                for (vt = WG, me = Me, de = rt, Ce = 0, je = me; je; je = vt(je))
                  Ce++;
                je = 0;
                for (var pt = de; pt; pt = vt(pt))
                  je++;
                for (; 0 < Ce - je; )
                  me = vt(me), Ce--;
                for (; 0 < je - Ce; )
                  de = vt(de), je--;
                for (; Ce--; ) {
                  if (me === de || de !== null && me === de.alternate) {
                    vt = me;
                    break t;
                  }
                  me = vt(me), de = vt(de);
                }
                vt = null;
              }
            else vt = null;
            Me !== null && bO(
              Ie,
              Te,
              Me,
              vt,
              !1
            ), rt !== null && Sn !== null && bO(
              Ie,
              Sn,
              rt,
              vt,
              !0
            );
          }
        }
        e: {
          if (Te = Ee ? Ji(Ee) : window, Me = Te.nodeName && Te.nodeName.toLowerCase(), Me === "select" || Me === "input" && Te.type === "file")
            var rn = cu;
          else if (Id(Te))
            if (wo)
              rn = bl;
            else {
              rn = ya;
              var lt = wy;
            }
          else
            Me = Te.nodeName, !Me || Me.toLowerCase() !== "input" || Te.type !== "checkbox" && Te.type !== "radio" ? Ee && Yh(Ee.elementType) && (rn = cu) : rn = up;
          if (rn && (rn = rn(l, Ee))) {
            cp(
              Ie,
              rn,
              p,
              Oe
            );
            break e;
          }
          lt && lt(l, Te, Ee), l === "focusout" && Ee && Te.type === "number" && Ee.memoizedProps.value != null && tu(Te, "number", Te.value);
        }
        switch (lt = Ee ? Ji(Ee) : window, l) {
          case "focusin":
            (Id(lt) || lt.contentEditable === "true") && (K = lt, se = Ee, ye = null);
            break;
          case "focusout":
            ye = se = K = null;
            break;
          case "mousedown":
            ae = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            ae = !1, oe(Ie, p, Oe);
            break;
          case "selectionchange":
            if (q) break;
          case "keydown":
          case "keyup":
            oe(Ie, p, Oe);
        }
        var Ot;
        if (au)
          e: {
            switch (l) {
              case "compositionstart":
                var Yt = "onCompositionStart";
                break e;
              case "compositionend":
                Yt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Yt = "onCompositionUpdate";
                break e;
            }
            Yt = void 0;
          }
        else
          ma ? lp(l, p) && (Yt = "onCompositionEnd") : l === "keydown" && p.keyCode === 229 && (Yt = "onCompositionStart");
        Yt && (Pd && p.locale !== "ko" && (ma || Yt !== "onCompositionStart" ? Yt === "onCompositionEnd" && ma && (Ot = hl()) : (xo = Oe, kd = "value" in xo ? xo.value : xo.textContent, ma = !0)), lt = ov(Ee, Yt), 0 < lt.length && (Yt = new Nd(
          Yt,
          l,
          null,
          p,
          Oe
        ), Ie.push({ event: Yt, listeners: lt }), Ot ? Yt.data = Ot : (Ot = yy(p), Ot !== null && (Yt.data = Ot)))), (Ot = h1 ? vy(l, p) : p1(l, p)) && (Yt = ov(Ee, "onBeforeInput"), 0 < Yt.length && (lt = new Nd(
          "onBeforeInput",
          "beforeinput",
          null,
          p,
          Oe
        ), Ie.push({
          event: lt,
          listeners: Yt
        }), lt.data = Ot)), UG(
          Ie,
          l,
          Ee,
          p,
          Oe
        );
      }
      yO(Ie, d);
    });
  }
  function jp(l, d, p) {
    return {
      instance: l,
      listener: d,
      currentTarget: p
    };
  }
  function ov(l, d) {
    for (var p = d + "Capture", y = []; l !== null; ) {
      var E = l, T = E.stateNode;
      if (E = E.tag, E !== 5 && E !== 26 && E !== 27 || T === null || (E = da(l, p), E != null && y.unshift(
        jp(l, E, T)
      ), E = da(l, d), E != null && y.push(
        jp(l, E, T)
      )), l.tag === 3) return y;
      l = l.return;
    }
    return [];
  }
  function WG(l) {
    if (l === null) return null;
    do
      l = l.return;
    while (l && l.tag !== 5 && l.tag !== 27);
    return l || null;
  }
  function bO(l, d, p, y, E) {
    for (var T = d._reactName, j = []; p !== null && p !== y; ) {
      var V = p, te = V.alternate, Ee = V.stateNode;
      if (V = V.tag, te !== null && te === y) break;
      V !== 5 && V !== 26 && V !== 27 || Ee === null || (te = Ee, E ? (Ee = da(p, T), Ee != null && j.unshift(
        jp(p, Ee, te)
      )) : E || (Ee = da(p, T), Ee != null && j.push(
        jp(p, Ee, te)
      ))), p = p.return;
    }
    j.length !== 0 && l.push({ event: d, listeners: j });
  }
  var qG = /\r\n?/g, GG = /\u0000|\uFFFD/g;
  function xO(l) {
    return (typeof l == "string" ? l : "" + l).replace(qG, `
`).replace(GG, "");
  }
  function wO(l, d) {
    return d = xO(d), xO(l) === d;
  }
  function wn(l, d, p, y, E, T) {
    switch (p) {
      case "children":
        typeof y == "string" ? d === "body" || d === "textarea" && y === "" || la(l, y) : (typeof y == "number" || typeof y == "bigint") && d !== "body" && la(l, "" + y);
        break;
      case "className":
        Qc(l, "class", y);
        break;
      case "tabIndex":
        Qc(l, "tabindex", y);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Qc(l, p, y);
        break;
      case "style":
        Zh(l, y, T);
        break;
      case "data":
        if (d !== "object") {
          Qc(l, "data", y);
          break;
        }
      case "src":
      case "href":
        if (y === "" && (d !== "a" || p !== "href")) {
          l.removeAttribute(p);
          break;
        }
        if (y == null || typeof y == "function" || typeof y == "symbol" || typeof y == "boolean") {
          l.removeAttribute(p);
          break;
        }
        y = Xo("" + y), l.setAttribute(p, y);
        break;
      case "action":
      case "formAction":
        if (typeof y == "function") {
          l.setAttribute(
            p,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof T == "function" && (p === "formAction" ? (d !== "input" && wn(l, d, "name", E.name, E, null), wn(
            l,
            d,
            "formEncType",
            E.formEncType,
            E,
            null
          ), wn(
            l,
            d,
            "formMethod",
            E.formMethod,
            E,
            null
          ), wn(
            l,
            d,
            "formTarget",
            E.formTarget,
            E,
            null
          )) : (wn(l, d, "encType", E.encType, E, null), wn(l, d, "method", E.method, E, null), wn(l, d, "target", E.target, E, null)));
        if (y == null || typeof y == "symbol" || typeof y == "boolean") {
          l.removeAttribute(p);
          break;
        }
        y = Xo("" + y), l.setAttribute(p, y);
        break;
      case "onClick":
        y != null && (l.onclick = zi);
        break;
      case "onScroll":
        y != null && qt("scroll", l);
        break;
      case "onScrollEnd":
        y != null && qt("scrollend", l);
        break;
      case "dangerouslySetInnerHTML":
        if (y != null) {
          if (typeof y != "object" || !("__html" in y))
            throw Error(r(61));
          if (p = y.__html, p != null) {
            if (E.children != null) throw Error(r(60));
            l.innerHTML = p;
          }
        }
        break;
      case "multiple":
        l.multiple = y && typeof y != "function" && typeof y != "symbol";
        break;
      case "muted":
        l.muted = y && typeof y != "function" && typeof y != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (y == null || typeof y == "function" || typeof y == "boolean" || typeof y == "symbol") {
          l.removeAttribute("xlink:href");
          break;
        }
        p = Xo("" + y), l.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          p
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        y != null && typeof y != "function" && typeof y != "symbol" ? l.setAttribute(p, "" + y) : l.removeAttribute(p);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        y && typeof y != "function" && typeof y != "symbol" ? l.setAttribute(p, "") : l.removeAttribute(p);
        break;
      case "capture":
      case "download":
        y === !0 ? l.setAttribute(p, "") : y !== !1 && y != null && typeof y != "function" && typeof y != "symbol" ? l.setAttribute(p, y) : l.removeAttribute(p);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        y != null && typeof y != "function" && typeof y != "symbol" && !isNaN(y) && 1 <= y ? l.setAttribute(p, y) : l.removeAttribute(p);
        break;
      case "rowSpan":
      case "start":
        y == null || typeof y == "function" || typeof y == "symbol" || isNaN(y) ? l.removeAttribute(p) : l.setAttribute(p, y);
        break;
      case "popover":
        qt("beforetoggle", l), qt("toggle", l), Pt(l, "popover", y);
        break;
      case "xlinkActuate":
        vo(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          y
        );
        break;
      case "xlinkArcrole":
        vo(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          y
        );
        break;
      case "xlinkRole":
        vo(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          y
        );
        break;
      case "xlinkShow":
        vo(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          y
        );
        break;
      case "xlinkTitle":
        vo(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          y
        );
        break;
      case "xlinkType":
        vo(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          y
        );
        break;
      case "xmlBase":
        vo(
          l,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          y
        );
        break;
      case "xmlLang":
        vo(
          l,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          y
        );
        break;
      case "xmlSpace":
        vo(
          l,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          y
        );
        break;
      case "is":
        Pt(l, "is", y);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < p.length) || p[0] !== "o" && p[0] !== "O" || p[1] !== "n" && p[1] !== "N") && (p = u1.get(p) || p, Pt(l, p, y));
    }
  }
  function IS(l, d, p, y, E, T) {
    switch (p) {
      case "style":
        Zh(l, y, T);
        break;
      case "dangerouslySetInnerHTML":
        if (y != null) {
          if (typeof y != "object" || !("__html" in y))
            throw Error(r(61));
          if (p = y.__html, p != null) {
            if (E.children != null) throw Error(r(60));
            l.innerHTML = p;
          }
        }
        break;
      case "children":
        typeof y == "string" ? la(l, y) : (typeof y == "number" || typeof y == "bigint") && la(l, "" + y);
        break;
      case "onScroll":
        y != null && qt("scroll", l);
        break;
      case "onScrollEnd":
        y != null && qt("scrollend", l);
        break;
      case "onClick":
        y != null && (l.onclick = zi);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!Xc.hasOwnProperty(p))
          e: {
            if (p[0] === "o" && p[1] === "n" && (E = p.endsWith("Capture"), d = p.slice(2, E ? p.length - 7 : void 0), T = l[ar] || null, T = T != null ? T[p] : null, typeof T == "function" && l.removeEventListener(d, T, E), typeof y == "function")) {
              typeof T != "function" && T !== null && (p in l ? l[p] = null : l.hasAttribute(p) && l.removeAttribute(p)), l.addEventListener(d, y, E);
              break e;
            }
            p in l ? l[p] = y : y === !0 ? l.setAttribute(p, "") : Pt(l, p, y);
          }
    }
  }
  function Yr(l, d, p) {
    switch (d) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        qt("error", l), qt("load", l);
        var y = !1, E = !1, T;
        for (T in p)
          if (p.hasOwnProperty(T)) {
            var j = p[T];
            if (j != null)
              switch (T) {
                case "src":
                  y = !0;
                  break;
                case "srcSet":
                  E = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, d));
                default:
                  wn(l, d, T, j, p, null);
              }
          }
        E && wn(l, d, "srcSet", p.srcSet, p, null), y && wn(l, d, "src", p.src, p, null);
        return;
      case "input":
        qt("invalid", l);
        var V = T = j = E = null, te = null, Ee = null;
        for (y in p)
          if (p.hasOwnProperty(y)) {
            var Oe = p[y];
            if (Oe != null)
              switch (y) {
                case "name":
                  E = Oe;
                  break;
                case "type":
                  j = Oe;
                  break;
                case "checked":
                  te = Oe;
                  break;
                case "defaultChecked":
                  Ee = Oe;
                  break;
                case "value":
                  T = Oe;
                  break;
                case "defaultValue":
                  V = Oe;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Oe != null)
                    throw Error(r(137, d));
                  break;
                default:
                  wn(l, d, y, Oe, p, null);
              }
          }
        wd(
          l,
          T,
          V,
          te,
          Ee,
          j,
          E,
          !1
        );
        return;
      case "select":
        qt("invalid", l), y = j = T = null;
        for (E in p)
          if (p.hasOwnProperty(E) && (V = p[E], V != null))
            switch (E) {
              case "value":
                T = V;
                break;
              case "defaultValue":
                j = V;
                break;
              case "multiple":
                y = V;
              default:
                wn(l, d, E, V, p, null);
            }
        d = T, p = j, l.multiple = !!y, d != null ? Yo(l, !!y, d, !1) : p != null && Yo(l, !!y, p, !0);
        return;
      case "textarea":
        qt("invalid", l), T = E = y = null;
        for (j in p)
          if (p.hasOwnProperty(j) && (V = p[j], V != null))
            switch (j) {
              case "value":
                y = V;
                break;
              case "defaultValue":
                E = V;
                break;
              case "children":
                T = V;
                break;
              case "dangerouslySetInnerHTML":
                if (V != null) throw Error(r(91));
                break;
              default:
                wn(l, d, j, V, p, null);
            }
        nu(l, y, E, T);
        return;
      case "option":
        for (te in p)
          p.hasOwnProperty(te) && (y = p[te], y != null) && (te === "selected" ? l.selected = y && typeof y != "function" && typeof y != "symbol" : wn(l, d, te, y, p, null));
        return;
      case "dialog":
        qt("beforetoggle", l), qt("toggle", l), qt("cancel", l), qt("close", l);
        break;
      case "iframe":
      case "object":
        qt("load", l);
        break;
      case "video":
      case "audio":
        for (y = 0; y < Pp.length; y++)
          qt(Pp[y], l);
        break;
      case "image":
        qt("error", l), qt("load", l);
        break;
      case "details":
        qt("toggle", l);
        break;
      case "embed":
      case "source":
      case "link":
        qt("error", l), qt("load", l);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (Ee in p)
          if (p.hasOwnProperty(Ee) && (y = p[Ee], y != null))
            switch (Ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, d));
              default:
                wn(l, d, Ee, y, p, null);
            }
        return;
      default:
        if (Yh(d)) {
          for (Oe in p)
            p.hasOwnProperty(Oe) && (y = p[Oe], y !== void 0 && IS(
              l,
              d,
              Oe,
              y,
              p,
              void 0
            ));
          return;
        }
    }
    for (V in p)
      p.hasOwnProperty(V) && (y = p[V], y != null && wn(l, d, V, y, p, null));
  }
  function KG(l, d, p, y) {
    switch (d) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var E = null, T = null, j = null, V = null, te = null, Ee = null, Oe = null;
        for (Me in p) {
          var Ie = p[Me];
          if (p.hasOwnProperty(Me) && Ie != null)
            switch (Me) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                te = Ie;
              default:
                y.hasOwnProperty(Me) || wn(l, d, Me, null, y, Ie);
            }
        }
        for (var Te in y) {
          var Me = y[Te];
          if (Ie = p[Te], y.hasOwnProperty(Te) && (Me != null || Ie != null))
            switch (Te) {
              case "type":
                T = Me;
                break;
              case "name":
                E = Me;
                break;
              case "checked":
                Ee = Me;
                break;
              case "defaultChecked":
                Oe = Me;
                break;
              case "value":
                j = Me;
                break;
              case "defaultValue":
                V = Me;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (Me != null)
                  throw Error(r(137, d));
                break;
              default:
                Me !== Ie && wn(
                  l,
                  d,
                  Te,
                  Me,
                  y,
                  Ie
                );
            }
        }
        Ss(
          l,
          j,
          V,
          te,
          Ee,
          Oe,
          T,
          E
        );
        return;
      case "select":
        Me = j = V = Te = null;
        for (T in p)
          if (te = p[T], p.hasOwnProperty(T) && te != null)
            switch (T) {
              case "value":
                break;
              case "multiple":
                Me = te;
              default:
                y.hasOwnProperty(T) || wn(
                  l,
                  d,
                  T,
                  null,
                  y,
                  te
                );
            }
        for (E in y)
          if (T = y[E], te = p[E], y.hasOwnProperty(E) && (T != null || te != null))
            switch (E) {
              case "value":
                Te = T;
                break;
              case "defaultValue":
                V = T;
                break;
              case "multiple":
                j = T;
              default:
                T !== te && wn(
                  l,
                  d,
                  E,
                  T,
                  y,
                  te
                );
            }
        d = V, p = j, y = Me, Te != null ? Yo(l, !!p, Te, !1) : !!y != !!p && (d != null ? Yo(l, !!p, d, !0) : Yo(l, !!p, p ? [] : "", !1));
        return;
      case "textarea":
        Me = Te = null;
        for (V in p)
          if (E = p[V], p.hasOwnProperty(V) && E != null && !y.hasOwnProperty(V))
            switch (V) {
              case "value":
                break;
              case "children":
                break;
              default:
                wn(l, d, V, null, y, E);
            }
        for (j in y)
          if (E = y[j], T = p[j], y.hasOwnProperty(j) && (E != null || T != null))
            switch (j) {
              case "value":
                Te = E;
                break;
              case "defaultValue":
                Me = E;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (E != null) throw Error(r(91));
                break;
              default:
                E !== T && wn(l, d, j, E, y, T);
            }
        Kh(l, Te, Me);
        return;
      case "option":
        for (var rt in p)
          Te = p[rt], p.hasOwnProperty(rt) && Te != null && !y.hasOwnProperty(rt) && (rt === "selected" ? l.selected = !1 : wn(
            l,
            d,
            rt,
            null,
            y,
            Te
          ));
        for (te in y)
          Te = y[te], Me = p[te], y.hasOwnProperty(te) && Te !== Me && (Te != null || Me != null) && (te === "selected" ? l.selected = Te && typeof Te != "function" && typeof Te != "symbol" : wn(
            l,
            d,
            te,
            Te,
            y,
            Me
          ));
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var vt in p)
          Te = p[vt], p.hasOwnProperty(vt) && Te != null && !y.hasOwnProperty(vt) && wn(l, d, vt, null, y, Te);
        for (Ee in y)
          if (Te = y[Ee], Me = p[Ee], y.hasOwnProperty(Ee) && Te !== Me && (Te != null || Me != null))
            switch (Ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (Te != null)
                  throw Error(r(137, d));
                break;
              default:
                wn(
                  l,
                  d,
                  Ee,
                  Te,
                  y,
                  Me
                );
            }
        return;
      default:
        if (Yh(d)) {
          for (var Sn in p)
            Te = p[Sn], p.hasOwnProperty(Sn) && Te !== void 0 && !y.hasOwnProperty(Sn) && IS(
              l,
              d,
              Sn,
              void 0,
              y,
              Te
            );
          for (Oe in y)
            Te = y[Oe], Me = p[Oe], !y.hasOwnProperty(Oe) || Te === Me || Te === void 0 && Me === void 0 || IS(
              l,
              d,
              Oe,
              Te,
              y,
              Me
            );
          return;
        }
    }
    for (var me in p)
      Te = p[me], p.hasOwnProperty(me) && Te != null && !y.hasOwnProperty(me) && wn(l, d, me, null, y, Te);
    for (Ie in y)
      Te = y[Ie], Me = p[Ie], !y.hasOwnProperty(Ie) || Te === Me || Te == null && Me == null || wn(l, d, Ie, Te, y, Me);
  }
  function SO(l) {
    switch (l) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function ZG() {
    if (typeof performance.getEntriesByType == "function") {
      for (var l = 0, d = 0, p = performance.getEntriesByType("resource"), y = 0; y < p.length; y++) {
        var E = p[y], T = E.transferSize, j = E.initiatorType, V = E.duration;
        if (T && V && SO(j)) {
          for (j = 0, V = E.responseEnd, y += 1; y < p.length; y++) {
            var te = p[y], Ee = te.startTime;
            if (Ee > V) break;
            var Oe = te.transferSize, Ie = te.initiatorType;
            Oe && SO(Ie) && (te = te.responseEnd, j += Oe * (te < V ? 1 : (V - Ee) / (te - Ee)));
          }
          if (--y, d += 8 * (T + j) / (E.duration / 1e3), l++, 10 < l) break;
        }
      }
      if (0 < l) return d / l / 1e6;
    }
    return navigator.connection && (l = navigator.connection.downlink, typeof l == "number") ? l : 5;
  }
  var zS = null, LS = null;
  function sv(l) {
    return l.nodeType === 9 ? l : l.ownerDocument;
  }
  function kO(l) {
    switch (l) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function CO(l, d) {
    if (l === 0)
      switch (d) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return l === 1 && d === "foreignObject" ? 0 : l;
  }
  function BS(l, d) {
    return l === "textarea" || l === "noscript" || typeof d.children == "string" || typeof d.children == "number" || typeof d.children == "bigint" || typeof d.dangerouslySetInnerHTML == "object" && d.dangerouslySetInnerHTML !== null && d.dangerouslySetInnerHTML.__html != null;
  }
  var $S = null;
  function YG() {
    var l = window.event;
    return l && l.type === "popstate" ? l === $S ? !1 : ($S = l, !0) : ($S = null, !1);
  }
  var EO = typeof setTimeout == "function" ? setTimeout : void 0, XG = typeof clearTimeout == "function" ? clearTimeout : void 0, _O = typeof Promise == "function" ? Promise : void 0, JG = typeof queueMicrotask == "function" ? queueMicrotask : typeof _O < "u" ? function(l) {
    return _O.resolve(null).then(l).catch(QG);
  } : EO;
  function QG(l) {
    setTimeout(function() {
      throw l;
    });
  }
  function zl(l) {
    return l === "head";
  }
  function TO(l, d) {
    var p = d, y = 0;
    do {
      var E = p.nextSibling;
      if (l.removeChild(p), E && E.nodeType === 8)
        if (p = E.data, p === "/$" || p === "/&") {
          if (y === 0) {
            l.removeChild(E), uf(d);
            return;
          }
          y--;
        } else if (p === "$" || p === "$?" || p === "$~" || p === "$!" || p === "&")
          y++;
        else if (p === "html")
          Ip(l.ownerDocument.documentElement);
        else if (p === "head") {
          p = l.ownerDocument.head, Ip(p);
          for (var T = p.firstChild; T; ) {
            var j = T.nextSibling, V = T.nodeName;
            T[Xi] || V === "SCRIPT" || V === "STYLE" || V === "LINK" && T.rel.toLowerCase() === "stylesheet" || p.removeChild(T), T = j;
          }
        } else
          p === "body" && Ip(l.ownerDocument.body);
      p = E;
    } while (p);
    uf(d);
  }
  function AO(l, d) {
    var p = l;
    l = 0;
    do {
      var y = p.nextSibling;
      if (p.nodeType === 1 ? d ? (p._stashedDisplay = p.style.display, p.style.display = "none") : (p.style.display = p._stashedDisplay || "", p.getAttribute("style") === "" && p.removeAttribute("style")) : p.nodeType === 3 && (d ? (p._stashedText = p.nodeValue, p.nodeValue = "") : p.nodeValue = p._stashedText || ""), y && y.nodeType === 8)
        if (p = y.data, p === "/$") {
          if (l === 0) break;
          l--;
        } else
          p !== "$" && p !== "$?" && p !== "$~" && p !== "$!" || l++;
      p = y;
    } while (p);
  }
  function US(l) {
    var d = l.firstChild;
    for (d && d.nodeType === 10 && (d = d.nextSibling); d; ) {
      var p = d;
      switch (d = d.nextSibling, p.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          US(p), bd(p);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (p.rel.toLowerCase() === "stylesheet") continue;
      }
      l.removeChild(p);
    }
  }
  function eK(l, d, p, y) {
    for (; l.nodeType === 1; ) {
      var E = p;
      if (l.nodeName.toLowerCase() !== d.toLowerCase()) {
        if (!y && (l.nodeName !== "INPUT" || l.type !== "hidden"))
          break;
      } else if (y) {
        if (!l[Xi])
          switch (d) {
            case "meta":
              if (!l.hasAttribute("itemprop")) break;
              return l;
            case "link":
              if (T = l.getAttribute("rel"), T === "stylesheet" && l.hasAttribute("data-precedence"))
                break;
              if (T !== E.rel || l.getAttribute("href") !== (E.href == null || E.href === "" ? null : E.href) || l.getAttribute("crossorigin") !== (E.crossOrigin == null ? null : E.crossOrigin) || l.getAttribute("title") !== (E.title == null ? null : E.title))
                break;
              return l;
            case "style":
              if (l.hasAttribute("data-precedence")) break;
              return l;
            case "script":
              if (T = l.getAttribute("src"), (T !== (E.src == null ? null : E.src) || l.getAttribute("type") !== (E.type == null ? null : E.type) || l.getAttribute("crossorigin") !== (E.crossOrigin == null ? null : E.crossOrigin)) && T && l.hasAttribute("async") && !l.hasAttribute("itemprop"))
                break;
              return l;
            default:
              return l;
          }
      } else if (d === "input" && l.type === "hidden") {
        var T = E.name == null ? null : "" + E.name;
        if (E.type === "hidden" && l.getAttribute("name") === T)
          return l;
      } else return l;
      if (l = To(l.nextSibling), l === null) break;
    }
    return null;
  }
  function tK(l, d, p) {
    if (d === "") return null;
    for (; l.nodeType !== 3; )
      if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !p || (l = To(l.nextSibling), l === null)) return null;
    return l;
  }
  function MO(l, d) {
    for (; l.nodeType !== 8; )
      if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !d || (l = To(l.nextSibling), l === null)) return null;
    return l;
  }
  function FS(l) {
    return l.data === "$?" || l.data === "$~";
  }
  function VS(l) {
    return l.data === "$!" || l.data === "$?" && l.ownerDocument.readyState !== "loading";
  }
  function nK(l, d) {
    var p = l.ownerDocument;
    if (l.data === "$~") l._reactRetry = d;
    else if (l.data !== "$?" || p.readyState !== "loading")
      d();
    else {
      var y = function() {
        d(), p.removeEventListener("DOMContentLoaded", y);
      };
      p.addEventListener("DOMContentLoaded", y), l._reactRetry = y;
    }
  }
  function To(l) {
    for (; l != null; l = l.nextSibling) {
      var d = l.nodeType;
      if (d === 1 || d === 3) break;
      if (d === 8) {
        if (d = l.data, d === "$" || d === "$!" || d === "$?" || d === "$~" || d === "&" || d === "F!" || d === "F")
          break;
        if (d === "/$" || d === "/&") return null;
      }
    }
    return l;
  }
  var HS = null;
  function NO(l) {
    l = l.nextSibling;
    for (var d = 0; l; ) {
      if (l.nodeType === 8) {
        var p = l.data;
        if (p === "/$" || p === "/&") {
          if (d === 0)
            return To(l.nextSibling);
          d--;
        } else
          p !== "$" && p !== "$!" && p !== "$?" && p !== "$~" && p !== "&" || d++;
      }
      l = l.nextSibling;
    }
    return null;
  }
  function RO(l) {
    l = l.previousSibling;
    for (var d = 0; l; ) {
      if (l.nodeType === 8) {
        var p = l.data;
        if (p === "$" || p === "$!" || p === "$?" || p === "$~" || p === "&") {
          if (d === 0) return l;
          d--;
        } else p !== "/$" && p !== "/&" || d++;
      }
      l = l.previousSibling;
    }
    return null;
  }
  function OO(l, d, p) {
    switch (d = sv(p), l) {
      case "html":
        if (l = d.documentElement, !l) throw Error(r(452));
        return l;
      case "head":
        if (l = d.head, !l) throw Error(r(453));
        return l;
      case "body":
        if (l = d.body, !l) throw Error(r(454));
        return l;
      default:
        throw Error(r(451));
    }
  }
  function Ip(l) {
    for (var d = l.attributes; d.length; )
      l.removeAttributeNode(d[0]);
    bd(l);
  }
  var Ao = /* @__PURE__ */ new Map(), DO = /* @__PURE__ */ new Set();
  function av(l) {
    return typeof l.getRootNode == "function" ? l.getRootNode() : l.nodeType === 9 ? l : l.ownerDocument;
  }
  var Oa = Q.d;
  Q.d = {
    f: rK,
    r: iK,
    D: oK,
    C: sK,
    L: aK,
    m: lK,
    X: uK,
    S: cK,
    M: dK
  };
  function rK() {
    var l = Oa.f(), d = Jy();
    return l || d;
  }
  function iK(l) {
    var d = vn(l);
    d !== null && d.tag === 5 && d.type === "form" ? YR(d) : Oa.r(l);
  }
  var af = typeof document > "u" ? null : document;
  function PO(l, d, p) {
    var y = af;
    if (y && typeof d == "string" && d) {
      var E = jr(d);
      E = 'link[rel="' + l + '"][href="' + E + '"]', typeof p == "string" && (E += '[crossorigin="' + p + '"]'), DO.has(E) || (DO.add(E), l = { rel: l, crossOrigin: p, href: d }, y.querySelector(E) === null && (d = y.createElement("link"), Yr(d, "link", l), lr(d), y.head.appendChild(d)));
    }
  }
  function oK(l) {
    Oa.D(l), PO("dns-prefetch", l, null);
  }
  function sK(l, d) {
    Oa.C(l, d), PO("preconnect", l, d);
  }
  function aK(l, d, p) {
    Oa.L(l, d, p);
    var y = af;
    if (y && l && d) {
      var E = 'link[rel="preload"][as="' + jr(d) + '"]';
      d === "image" && p && p.imageSrcSet ? (E += '[imagesrcset="' + jr(
        p.imageSrcSet
      ) + '"]', typeof p.imageSizes == "string" && (E += '[imagesizes="' + jr(
        p.imageSizes
      ) + '"]')) : E += '[href="' + jr(l) + '"]';
      var T = E;
      switch (d) {
        case "style":
          T = lf(l);
          break;
        case "script":
          T = cf(l);
      }
      Ao.has(T) || (l = h(
        {
          rel: "preload",
          href: d === "image" && p && p.imageSrcSet ? void 0 : l,
          as: d
        },
        p
      ), Ao.set(T, l), y.querySelector(E) !== null || d === "style" && y.querySelector(zp(T)) || d === "script" && y.querySelector(Lp(T)) || (d = y.createElement("link"), Yr(d, "link", l), lr(d), y.head.appendChild(d)));
    }
  }
  function lK(l, d) {
    Oa.m(l, d);
    var p = af;
    if (p && l) {
      var y = d && typeof d.as == "string" ? d.as : "script", E = 'link[rel="modulepreload"][as="' + jr(y) + '"][href="' + jr(l) + '"]', T = E;
      switch (y) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          T = cf(l);
      }
      if (!Ao.has(T) && (l = h({ rel: "modulepreload", href: l }, d), Ao.set(T, l), p.querySelector(E) === null)) {
        switch (y) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (p.querySelector(Lp(T)))
              return;
        }
        y = p.createElement("link"), Yr(y, "link", l), lr(y), p.head.appendChild(y);
      }
    }
  }
  function cK(l, d, p) {
    Oa.S(l, d, p);
    var y = af;
    if (y && l) {
      var E = si(y).hoistableStyles, T = lf(l);
      d = d || "default";
      var j = E.get(T);
      if (!j) {
        var V = { loading: 0, preload: null };
        if (j = y.querySelector(
          zp(T)
        ))
          V.loading = 5;
        else {
          l = h(
            { rel: "stylesheet", href: l, "data-precedence": d },
            p
          ), (p = Ao.get(T)) && WS(l, p);
          var te = j = y.createElement("link");
          lr(te), Yr(te, "link", l), te._p = new Promise(function(Ee, Oe) {
            te.onload = Ee, te.onerror = Oe;
          }), te.addEventListener("load", function() {
            V.loading |= 1;
          }), te.addEventListener("error", function() {
            V.loading |= 2;
          }), V.loading |= 4, lv(j, d, y);
        }
        j = {
          type: "stylesheet",
          instance: j,
          count: 1,
          state: V
        }, E.set(T, j);
      }
    }
  }
  function uK(l, d) {
    Oa.X(l, d);
    var p = af;
    if (p && l) {
      var y = si(p).hoistableScripts, E = cf(l), T = y.get(E);
      T || (T = p.querySelector(Lp(E)), T || (l = h({ src: l, async: !0 }, d), (d = Ao.get(E)) && qS(l, d), T = p.createElement("script"), lr(T), Yr(T, "link", l), p.head.appendChild(T)), T = {
        type: "script",
        instance: T,
        count: 1,
        state: null
      }, y.set(E, T));
    }
  }
  function dK(l, d) {
    Oa.M(l, d);
    var p = af;
    if (p && l) {
      var y = si(p).hoistableScripts, E = cf(l), T = y.get(E);
      T || (T = p.querySelector(Lp(E)), T || (l = h({ src: l, async: !0, type: "module" }, d), (d = Ao.get(E)) && qS(l, d), T = p.createElement("script"), lr(T), Yr(T, "link", l), p.head.appendChild(T)), T = {
        type: "script",
        instance: T,
        count: 1,
        state: null
      }, y.set(E, T));
    }
  }
  function jO(l, d, p, y) {
    var E = (E = re.current) ? av(E) : null;
    if (!E) throw Error(r(446));
    switch (l) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof p.precedence == "string" && typeof p.href == "string" ? (d = lf(p.href), p = si(
          E
        ).hoistableStyles, y = p.get(d), y || (y = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, p.set(d, y)), y) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (p.rel === "stylesheet" && typeof p.href == "string" && typeof p.precedence == "string") {
          l = lf(p.href);
          var T = si(
            E
          ).hoistableStyles, j = T.get(l);
          if (j || (E = E.ownerDocument || E, j = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, T.set(l, j), (T = E.querySelector(
            zp(l)
          )) && !T._p && (j.instance = T, j.state.loading = 5), Ao.has(l) || (p = {
            rel: "preload",
            as: "style",
            href: p.href,
            crossOrigin: p.crossOrigin,
            integrity: p.integrity,
            media: p.media,
            hrefLang: p.hrefLang,
            referrerPolicy: p.referrerPolicy
          }, Ao.set(l, p), T || fK(
            E,
            l,
            p,
            j.state
          ))), d && y === null)
            throw Error(r(528, ""));
          return j;
        }
        if (d && y !== null)
          throw Error(r(529, ""));
        return null;
      case "script":
        return d = p.async, p = p.src, typeof p == "string" && d && typeof d != "function" && typeof d != "symbol" ? (d = cf(p), p = si(
          E
        ).hoistableScripts, y = p.get(d), y || (y = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, p.set(d, y)), y) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(r(444, l));
    }
  }
  function lf(l) {
    return 'href="' + jr(l) + '"';
  }
  function zp(l) {
    return 'link[rel="stylesheet"][' + l + "]";
  }
  function IO(l) {
    return h({}, l, {
      "data-precedence": l.precedence,
      precedence: null
    });
  }
  function fK(l, d, p, y) {
    l.querySelector('link[rel="preload"][as="style"][' + d + "]") ? y.loading = 1 : (d = l.createElement("link"), y.preload = d, d.addEventListener("load", function() {
      return y.loading |= 1;
    }), d.addEventListener("error", function() {
      return y.loading |= 2;
    }), Yr(d, "link", p), lr(d), l.head.appendChild(d));
  }
  function cf(l) {
    return '[src="' + jr(l) + '"]';
  }
  function Lp(l) {
    return "script[async]" + l;
  }
  function zO(l, d, p) {
    if (d.count++, d.instance === null)
      switch (d.type) {
        case "style":
          var y = l.querySelector(
            'style[data-href~="' + jr(p.href) + '"]'
          );
          if (y)
            return d.instance = y, lr(y), y;
          var E = h({}, p, {
            "data-href": p.href,
            "data-precedence": p.precedence,
            href: null,
            precedence: null
          });
          return y = (l.ownerDocument || l).createElement(
            "style"
          ), lr(y), Yr(y, "style", E), lv(y, p.precedence, l), d.instance = y;
        case "stylesheet":
          E = lf(p.href);
          var T = l.querySelector(
            zp(E)
          );
          if (T)
            return d.state.loading |= 4, d.instance = T, lr(T), T;
          y = IO(p), (E = Ao.get(E)) && WS(y, E), T = (l.ownerDocument || l).createElement("link"), lr(T);
          var j = T;
          return j._p = new Promise(function(V, te) {
            j.onload = V, j.onerror = te;
          }), Yr(T, "link", y), d.state.loading |= 4, lv(T, p.precedence, l), d.instance = T;
        case "script":
          return T = cf(p.src), (E = l.querySelector(
            Lp(T)
          )) ? (d.instance = E, lr(E), E) : (y = p, (E = Ao.get(T)) && (y = h({}, p), qS(y, E)), l = l.ownerDocument || l, E = l.createElement("script"), lr(E), Yr(E, "link", y), l.head.appendChild(E), d.instance = E);
        case "void":
          return null;
        default:
          throw Error(r(443, d.type));
      }
    else
      d.type === "stylesheet" && (d.state.loading & 4) === 0 && (y = d.instance, d.state.loading |= 4, lv(y, p.precedence, l));
    return d.instance;
  }
  function lv(l, d, p) {
    for (var y = p.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), E = y.length ? y[y.length - 1] : null, T = E, j = 0; j < y.length; j++) {
      var V = y[j];
      if (V.dataset.precedence === d) T = V;
      else if (T !== E) break;
    }
    T ? T.parentNode.insertBefore(l, T.nextSibling) : (d = p.nodeType === 9 ? p.head : p, d.insertBefore(l, d.firstChild));
  }
  function WS(l, d) {
    l.crossOrigin == null && (l.crossOrigin = d.crossOrigin), l.referrerPolicy == null && (l.referrerPolicy = d.referrerPolicy), l.title == null && (l.title = d.title);
  }
  function qS(l, d) {
    l.crossOrigin == null && (l.crossOrigin = d.crossOrigin), l.referrerPolicy == null && (l.referrerPolicy = d.referrerPolicy), l.integrity == null && (l.integrity = d.integrity);
  }
  var cv = null;
  function LO(l, d, p) {
    if (cv === null) {
      var y = /* @__PURE__ */ new Map(), E = cv = /* @__PURE__ */ new Map();
      E.set(p, y);
    } else
      E = cv, y = E.get(p), y || (y = /* @__PURE__ */ new Map(), E.set(p, y));
    if (y.has(l)) return y;
    for (y.set(l, null), p = p.getElementsByTagName(l), E = 0; E < p.length; E++) {
      var T = p[E];
      if (!(T[Xi] || T[Nn] || l === "link" && T.getAttribute("rel") === "stylesheet") && T.namespaceURI !== "http://www.w3.org/2000/svg") {
        var j = T.getAttribute(d) || "";
        j = l + j;
        var V = y.get(j);
        V ? V.push(T) : y.set(j, [T]);
      }
    }
    return y;
  }
  function BO(l, d, p) {
    l = l.ownerDocument || l, l.head.insertBefore(
      p,
      d === "title" ? l.querySelector("head > title") : null
    );
  }
  function hK(l, d, p) {
    if (p === 1 || d.itemProp != null) return !1;
    switch (l) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof d.precedence != "string" || typeof d.href != "string" || d.href === "")
          break;
        return !0;
      case "link":
        if (typeof d.rel != "string" || typeof d.href != "string" || d.href === "" || d.onLoad || d.onError)
          break;
        return d.rel === "stylesheet" ? (l = d.disabled, typeof d.precedence == "string" && l == null) : !0;
      case "script":
        if (d.async && typeof d.async != "function" && typeof d.async != "symbol" && !d.onLoad && !d.onError && d.src && typeof d.src == "string")
          return !0;
    }
    return !1;
  }
  function $O(l) {
    return !(l.type === "stylesheet" && (l.state.loading & 3) === 0);
  }
  function pK(l, d, p, y) {
    if (p.type === "stylesheet" && (typeof y.media != "string" || matchMedia(y.media).matches !== !1) && (p.state.loading & 4) === 0) {
      if (p.instance === null) {
        var E = lf(y.href), T = d.querySelector(
          zp(E)
        );
        if (T) {
          d = T._p, d !== null && typeof d == "object" && typeof d.then == "function" && (l.count++, l = uv.bind(l), d.then(l, l)), p.state.loading |= 4, p.instance = T, lr(T);
          return;
        }
        T = d.ownerDocument || d, y = IO(y), (E = Ao.get(E)) && WS(y, E), T = T.createElement("link"), lr(T);
        var j = T;
        j._p = new Promise(function(V, te) {
          j.onload = V, j.onerror = te;
        }), Yr(T, "link", y), p.instance = T;
      }
      l.stylesheets === null && (l.stylesheets = /* @__PURE__ */ new Map()), l.stylesheets.set(p, d), (d = p.state.preload) && (p.state.loading & 3) === 0 && (l.count++, p = uv.bind(l), d.addEventListener("load", p), d.addEventListener("error", p));
    }
  }
  var GS = 0;
  function mK(l, d) {
    return l.stylesheets && l.count === 0 && fv(l, l.stylesheets), 0 < l.count || 0 < l.imgCount ? function(p) {
      var y = setTimeout(function() {
        if (l.stylesheets && fv(l, l.stylesheets), l.unsuspend) {
          var T = l.unsuspend;
          l.unsuspend = null, T();
        }
      }, 6e4 + d);
      0 < l.imgBytes && GS === 0 && (GS = 62500 * ZG());
      var E = setTimeout(
        function() {
          if (l.waitingForImages = !1, l.count === 0 && (l.stylesheets && fv(l, l.stylesheets), l.unsuspend)) {
            var T = l.unsuspend;
            l.unsuspend = null, T();
          }
        },
        (l.imgBytes > GS ? 50 : 800) + d
      );
      return l.unsuspend = p, function() {
        l.unsuspend = null, clearTimeout(y), clearTimeout(E);
      };
    } : null;
  }
  function uv() {
    if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
      if (this.stylesheets) fv(this, this.stylesheets);
      else if (this.unsuspend) {
        var l = this.unsuspend;
        this.unsuspend = null, l();
      }
    }
  }
  var dv = null;
  function fv(l, d) {
    l.stylesheets = null, l.unsuspend !== null && (l.count++, dv = /* @__PURE__ */ new Map(), d.forEach(gK, l), dv = null, uv.call(l));
  }
  function gK(l, d) {
    if (!(d.state.loading & 4)) {
      var p = dv.get(l);
      if (p) var y = p.get(null);
      else {
        p = /* @__PURE__ */ new Map(), dv.set(l, p);
        for (var E = l.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), T = 0; T < E.length; T++) {
          var j = E[T];
          (j.nodeName === "LINK" || j.getAttribute("media") !== "not all") && (p.set(j.dataset.precedence, j), y = j);
        }
        y && p.set(null, y);
      }
      E = d.instance, j = E.getAttribute("data-precedence"), T = p.get(j) || y, T === y && p.set(null, E), p.set(j, E), this.count++, y = uv.bind(this), E.addEventListener("load", y), E.addEventListener("error", y), T ? T.parentNode.insertBefore(E, T.nextSibling) : (l = l.nodeType === 9 ? l.head : l, l.insertBefore(E, l.firstChild)), d.state.loading |= 4;
    }
  }
  var Bp = {
    $$typeof: M,
    Provider: null,
    Consumer: null,
    _currentValue: X,
    _currentValue2: X,
    _threadCount: 0
  };
  function yK(l, d, p, y, E, T, j, V, te) {
    this.tag = 1, this.containerInfo = l, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = ys(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ys(0), this.hiddenUpdates = ys(null), this.identifierPrefix = y, this.onUncaughtError = E, this.onCaughtError = T, this.onRecoverableError = j, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = te, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function UO(l, d, p, y, E, T, j, V, te, Ee, Oe, Ie) {
    return l = new yK(
      l,
      d,
      p,
      j,
      te,
      Ee,
      Oe,
      Ie,
      V
    ), d = 1, T === !0 && (d |= 24), T = eo(3, null, null, d), l.current = T, T.stateNode = l, d = _1(), d.refCount++, l.pooledCache = d, d.refCount++, T.memoizedState = {
      element: y,
      isDehydrated: p,
      cache: d
    }, N1(T), l;
  }
  function FO(l) {
    return l ? (l = Bd, l) : Bd;
  }
  function VO(l, d, p, y, E, T) {
    E = FO(E), y.context === null ? y.context = E : y.pendingContext = E, y = _l(d), y.payload = { element: p }, T = T === void 0 ? null : T, T !== null && (y.callback = T), p = Tl(l, y, d), p !== null && (Fi(p, l, d), yp(p, l, d));
  }
  function HO(l, d) {
    if (l = l.memoizedState, l !== null && l.dehydrated !== null) {
      var p = l.retryLane;
      l.retryLane = p !== 0 && p < d ? p : d;
    }
  }
  function KS(l, d) {
    HO(l, d), (l = l.alternate) && HO(l, d);
  }
  function WO(l) {
    if (l.tag === 13 || l.tag === 31) {
      var d = un(l, 67108864);
      d !== null && Fi(d, l, 67108864), KS(l, 67108864);
    }
  }
  function qO(l) {
    if (l.tag === 13 || l.tag === 31) {
      var d = oo();
      d = Hh(d);
      var p = un(l, d);
      p !== null && Fi(p, l, d), KS(l, d);
    }
  }
  var hv = !0;
  function vK(l, d, p, y) {
    var E = H.T;
    H.T = null;
    var T = Q.p;
    try {
      Q.p = 2, ZS(l, d, p, y);
    } finally {
      Q.p = T, H.T = E;
    }
  }
  function bK(l, d, p, y) {
    var E = H.T;
    H.T = null;
    var T = Q.p;
    try {
      Q.p = 8, ZS(l, d, p, y);
    } finally {
      Q.p = T, H.T = E;
    }
  }
  function ZS(l, d, p, y) {
    if (hv) {
      var E = YS(y);
      if (E === null)
        jS(
          l,
          d,
          y,
          pv,
          p
        ), KO(l, y);
      else if (wK(
        E,
        l,
        d,
        p,
        y
      ))
        y.stopPropagation();
      else if (KO(l, y), d & 4 && -1 < xK.indexOf(l)) {
        for (; E !== null; ) {
          var T = vn(E);
          if (T !== null)
            switch (T.tag) {
              case 3:
                if (T = T.stateNode, T.current.memoizedState.isDehydrated) {
                  var j = Ko(T.pendingLanes);
                  if (j !== 0) {
                    var V = T;
                    for (V.pendingLanes |= 2, V.entangledLanes |= 2; j; ) {
                      var te = 1 << 31 - Ve(j);
                      V.entanglements[1] |= te, j &= ~te;
                    }
                    Ns(T), (ln & 6) === 0 && (Yy = Mn() + 500, Dp(0));
                  }
                }
                break;
              case 31:
              case 13:
                V = un(T, 2), V !== null && Fi(V, T, 2), Jy(), KS(T, 2);
            }
          if (T = YS(y), T === null && jS(
            l,
            d,
            y,
            pv,
            p
          ), T === E) break;
          E = T;
        }
        E !== null && y.stopPropagation();
      } else
        jS(
          l,
          d,
          y,
          null,
          p
        );
    }
  }
  function YS(l) {
    return l = Sd(l), XS(l);
  }
  var pv = null;
  function XS(l) {
    if (pv = null, l = xs(l), l !== null) {
      var d = o(l);
      if (d === null) l = null;
      else {
        var p = d.tag;
        if (p === 13) {
          if (l = s(d), l !== null) return l;
          l = null;
        } else if (p === 31) {
          if (l = a(d), l !== null) return l;
          l = null;
        } else if (p === 3) {
          if (d.stateNode.current.memoizedState.isDehydrated)
            return d.tag === 3 ? d.stateNode.containerInfo : null;
          l = null;
        } else d !== l && (l = null);
      }
    }
    return pv = l, null;
  }
  function GO(l) {
    switch (l) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (mt()) {
          case ke:
            return 2;
          case Pe:
            return 8;
          case He:
          case et:
            return 32;
          case bt:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var JS = !1, Ll = null, Bl = null, $l = null, $p = /* @__PURE__ */ new Map(), Up = /* @__PURE__ */ new Map(), Ul = [], xK = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function KO(l, d) {
    switch (l) {
      case "focusin":
      case "focusout":
        Ll = null;
        break;
      case "dragenter":
      case "dragleave":
        Bl = null;
        break;
      case "mouseover":
      case "mouseout":
        $l = null;
        break;
      case "pointerover":
      case "pointerout":
        $p.delete(d.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Up.delete(d.pointerId);
    }
  }
  function Fp(l, d, p, y, E, T) {
    return l === null || l.nativeEvent !== T ? (l = {
      blockedOn: d,
      domEventName: p,
      eventSystemFlags: y,
      nativeEvent: T,
      targetContainers: [E]
    }, d !== null && (d = vn(d), d !== null && WO(d)), l) : (l.eventSystemFlags |= y, d = l.targetContainers, E !== null && d.indexOf(E) === -1 && d.push(E), l);
  }
  function wK(l, d, p, y, E) {
    switch (d) {
      case "focusin":
        return Ll = Fp(
          Ll,
          l,
          d,
          p,
          y,
          E
        ), !0;
      case "dragenter":
        return Bl = Fp(
          Bl,
          l,
          d,
          p,
          y,
          E
        ), !0;
      case "mouseover":
        return $l = Fp(
          $l,
          l,
          d,
          p,
          y,
          E
        ), !0;
      case "pointerover":
        var T = E.pointerId;
        return $p.set(
          T,
          Fp(
            $p.get(T) || null,
            l,
            d,
            p,
            y,
            E
          )
        ), !0;
      case "gotpointercapture":
        return T = E.pointerId, Up.set(
          T,
          Fp(
            Up.get(T) || null,
            l,
            d,
            p,
            y,
            E
          )
        ), !0;
    }
    return !1;
  }
  function ZO(l) {
    var d = xs(l.target);
    if (d !== null) {
      var p = o(d);
      if (p !== null) {
        if (d = p.tag, d === 13) {
          if (d = s(p), d !== null) {
            l.blockedOn = d, Yc(l.priority, function() {
              qO(p);
            });
            return;
          }
        } else if (d === 31) {
          if (d = a(p), d !== null) {
            l.blockedOn = d, Yc(l.priority, function() {
              qO(p);
            });
            return;
          }
        } else if (d === 3 && p.stateNode.current.memoizedState.isDehydrated) {
          l.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
          return;
        }
      }
    }
    l.blockedOn = null;
  }
  function mv(l) {
    if (l.blockedOn !== null) return !1;
    for (var d = l.targetContainers; 0 < d.length; ) {
      var p = YS(l.nativeEvent);
      if (p === null) {
        p = l.nativeEvent;
        var y = new p.constructor(
          p.type,
          p
        );
        bo = y, p.target.dispatchEvent(y), bo = null;
      } else
        return d = vn(p), d !== null && WO(d), l.blockedOn = p, !1;
      d.shift();
    }
    return !0;
  }
  function YO(l, d, p) {
    mv(l) && p.delete(d);
  }
  function SK() {
    JS = !1, Ll !== null && mv(Ll) && (Ll = null), Bl !== null && mv(Bl) && (Bl = null), $l !== null && mv($l) && ($l = null), $p.forEach(YO), Up.forEach(YO);
  }
  function gv(l, d) {
    l.blockedOn === d && (l.blockedOn = null, JS || (JS = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      SK
    )));
  }
  var yv = null;
  function XO(l) {
    yv !== l && (yv = l, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        yv === l && (yv = null);
        for (var d = 0; d < l.length; d += 3) {
          var p = l[d], y = l[d + 1], E = l[d + 2];
          if (typeof y != "function") {
            if (XS(y || p) === null)
              continue;
            break;
          }
          var T = vn(p);
          T !== null && (l.splice(d, 3), d -= 3, Y1(
            T,
            {
              pending: !0,
              data: E,
              method: p.method,
              action: y
            },
            y,
            E
          ));
        }
      }
    ));
  }
  function uf(l) {
    function d(te) {
      return gv(te, l);
    }
    Ll !== null && gv(Ll, l), Bl !== null && gv(Bl, l), $l !== null && gv($l, l), $p.forEach(d), Up.forEach(d);
    for (var p = 0; p < Ul.length; p++) {
      var y = Ul[p];
      y.blockedOn === l && (y.blockedOn = null);
    }
    for (; 0 < Ul.length && (p = Ul[0], p.blockedOn === null); )
      ZO(p), p.blockedOn === null && Ul.shift();
    if (p = (l.ownerDocument || l).$$reactFormReplay, p != null)
      for (y = 0; y < p.length; y += 3) {
        var E = p[y], T = p[y + 1], j = E[ar] || null;
        if (typeof T == "function")
          j || XO(p);
        else if (j) {
          var V = null;
          if (T && T.hasAttribute("formAction")) {
            if (E = T, j = T[ar] || null)
              V = j.formAction;
            else if (XS(E) !== null) continue;
          } else V = j.action;
          typeof V == "function" ? p[y + 1] = V : (p.splice(y, 3), y -= 3), XO(p);
        }
      }
  }
  function JO() {
    function l(T) {
      T.canIntercept && T.info === "react-transition" && T.intercept({
        handler: function() {
          return new Promise(function(j) {
            return E = j;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function d() {
      E !== null && (E(), E = null), y || setTimeout(p, 20);
    }
    function p() {
      if (!y && !navigation.transition) {
        var T = navigation.currentEntry;
        T && T.url != null && navigation.navigate(T.url, {
          state: T.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if (typeof navigation == "object") {
      var y = !1, E = null;
      return navigation.addEventListener("navigate", l), navigation.addEventListener("navigatesuccess", d), navigation.addEventListener("navigateerror", d), setTimeout(p, 100), function() {
        y = !0, navigation.removeEventListener("navigate", l), navigation.removeEventListener("navigatesuccess", d), navigation.removeEventListener("navigateerror", d), E !== null && (E(), E = null);
      };
    }
  }
  function QS(l) {
    this._internalRoot = l;
  }
  vv.prototype.render = QS.prototype.render = function(l) {
    var d = this._internalRoot;
    if (d === null) throw Error(r(409));
    var p = d.current, y = oo();
    VO(p, y, l, d, null, null);
  }, vv.prototype.unmount = QS.prototype.unmount = function() {
    var l = this._internalRoot;
    if (l !== null) {
      this._internalRoot = null;
      var d = l.containerInfo;
      VO(l.current, 2, null, l, null, null), Jy(), d[wi] = null;
    }
  };
  function vv(l) {
    this._internalRoot = l;
  }
  vv.prototype.unstable_scheduleHydration = function(l) {
    if (l) {
      var d = Zc();
      l = { blockedOn: null, target: l, priority: d };
      for (var p = 0; p < Ul.length && d !== 0 && d < Ul[p].priority; p++) ;
      Ul.splice(p, 0, l), p === 0 && ZO(l);
    }
  };
  var QO = t.version;
  if (QO !== "19.2.4")
    throw Error(
      r(
        527,
        QO,
        "19.2.4"
      )
    );
  Q.findDOMNode = function(l) {
    var d = l._reactInternals;
    if (d === void 0)
      throw typeof l.render == "function" ? Error(r(188)) : (l = Object.keys(l).join(","), Error(r(268, l)));
    return l = u(d), l = l !== null ? f(l) : null, l = l === null ? null : l.stateNode, l;
  };
  var kK = {
    bundleType: 0,
    version: "19.2.4",
    rendererPackageName: "react-dom",
    currentDispatcherRef: H,
    reconcilerVersion: "19.2.4"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var bv = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!bv.isDisabled && bv.supportsFiber)
      try {
        Lt = bv.inject(
          kK
        ), nn = bv;
      } catch {
      }
  }
  return Vp.createRoot = function(l, d) {
    if (!i(l)) throw Error(r(299));
    var p = !1, y = "", E = s2, T = a2, j = l2;
    return d != null && (d.unstable_strictMode === !0 && (p = !0), d.identifierPrefix !== void 0 && (y = d.identifierPrefix), d.onUncaughtError !== void 0 && (E = d.onUncaughtError), d.onCaughtError !== void 0 && (T = d.onCaughtError), d.onRecoverableError !== void 0 && (j = d.onRecoverableError)), d = UO(
      l,
      1,
      !1,
      null,
      null,
      p,
      y,
      null,
      E,
      T,
      j,
      JO
    ), l[wi] = d.current, PS(l), new QS(d);
  }, Vp.hydrateRoot = function(l, d, p) {
    if (!i(l)) throw Error(r(299));
    var y = !1, E = "", T = s2, j = a2, V = l2, te = null;
    return p != null && (p.unstable_strictMode === !0 && (y = !0), p.identifierPrefix !== void 0 && (E = p.identifierPrefix), p.onUncaughtError !== void 0 && (T = p.onUncaughtError), p.onCaughtError !== void 0 && (j = p.onCaughtError), p.onRecoverableError !== void 0 && (V = p.onRecoverableError), p.formState !== void 0 && (te = p.formState)), d = UO(
      l,
      1,
      !0,
      d,
      p ?? null,
      y,
      E,
      te,
      T,
      j,
      V,
      JO
    ), d.context = FO(null), p = d.current, y = oo(), y = Hh(y), E = _l(y), E.callback = null, Tl(p, E, y), p = y, d.current.lanes = p, yo(d, p), Ns(d), l[wi] = d.current, PS(l), new vv(d);
  }, Vp.version = "19.2.4", Vp;
}
var aD;
function DK() {
  if (aD) return tk.exports;
  aD = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), tk.exports = OK(), tk.exports;
}
var S3 = DK();
const PK = /* @__PURE__ */ Pc(S3);
var ok = { exports: {} }, Hp = {};
var lD;
function jK() {
  if (lD) return Hp;
  lD = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.fragment");
  function n(r, i, o) {
    var s = null;
    if (o !== void 0 && (s = "" + o), i.key !== void 0 && (s = "" + i.key), "key" in i) {
      o = {};
      for (var a in i)
        a !== "key" && (o[a] = i[a]);
    } else o = i;
    return i = o.ref, {
      $$typeof: e,
      type: r,
      key: s,
      ref: i !== void 0 ? i : null,
      props: o
    };
  }
  return Hp.Fragment = t, Hp.jsx = n, Hp.jsxs = n, Hp;
}
var cD;
function IK() {
  return cD || (cD = 1, ok.exports = jK()), ok.exports;
}
var v = IK(), zK = /* @__PURE__ */ Symbol.for("preact-signals");
function IT() {
  if (Vf > 1)
    Vf--;
  else {
    for (var e, t = !1; wm !== void 0; ) {
      var n = wm;
      for (wm = void 0, wE++; n !== void 0; ) {
        var r = n.o;
        if (n.o = void 0, n.f &= -3, !(8 & n.f) && E3(n)) try {
          n.c();
        } catch (i) {
          t || (e = i, t = !0);
        }
        n = r;
      }
    }
    if (wE = 0, Vf--, t) throw e;
  }
}
var dn = void 0;
function k3(e) {
  var t = dn;
  dn = void 0;
  try {
    return e();
  } finally {
    dn = t;
  }
}
var wm = void 0, Vf = 0, wE = 0, H0 = 0;
function C3(e) {
  if (dn !== void 0) {
    var t = e.n;
    if (t === void 0 || t.t !== dn)
      return t = { i: 0, S: e, p: dn.s, n: void 0, t: dn, e: void 0, x: void 0, r: t }, dn.s !== void 0 && (dn.s.n = t), dn.s = t, e.n = t, 32 & dn.f && e.S(t), t;
    if (t.i === -1)
      return t.i = 0, t.n !== void 0 && (t.n.p = t.p, t.p !== void 0 && (t.p.n = t.n), t.p = dn.s, t.n = void 0, dn.s.n = t, dn.s = t), t;
  }
}
function yi(e, t) {
  this.v = e, this.i = 0, this.n = void 0, this.t = void 0, this.W = t?.watched, this.Z = t?.unwatched, this.name = t?.name;
}
yi.prototype.brand = zK;
yi.prototype.h = function() {
  return !0;
};
yi.prototype.S = function(e) {
  var t = this, n = this.t;
  n !== e && e.e === void 0 && (e.x = n, this.t = e, n !== void 0 ? n.e = e : k3(function() {
    var r;
    (r = t.W) == null || r.call(t);
  }));
};
yi.prototype.U = function(e) {
  var t = this;
  if (this.t !== void 0) {
    var n = e.e, r = e.x;
    n !== void 0 && (n.x = r, e.e = void 0), r !== void 0 && (r.e = n, e.x = void 0), e === this.t && (this.t = r, r === void 0 && k3(function() {
      var i;
      (i = t.Z) == null || i.call(t);
    }));
  }
};
yi.prototype.subscribe = function(e) {
  var t = this;
  return M3(function() {
    var n = t.value, r = dn;
    dn = void 0;
    try {
      e(n);
    } finally {
      dn = r;
    }
  }, { name: "sub" });
};
yi.prototype.valueOf = function() {
  return this.value;
};
yi.prototype.toString = function() {
  return this.value + "";
};
yi.prototype.toJSON = function() {
  return this.value;
};
yi.prototype.peek = function() {
  var e = dn;
  dn = void 0;
  try {
    return this.value;
  } finally {
    dn = e;
  }
};
Object.defineProperty(yi.prototype, "value", { get: function() {
  var e = C3(this);
  return e !== void 0 && (e.i = this.i), this.v;
}, set: function(e) {
  if (e !== this.v) {
    if (wE > 100) throw new Error("Cycle detected");
    this.v = e, this.i++, H0++, Vf++;
    try {
      for (var t = this.t; t !== void 0; t = t.x) t.t.N();
    } finally {
      IT();
    }
  }
} });
function uD(e, t) {
  return new yi(e, t);
}
function E3(e) {
  for (var t = e.s; t !== void 0; t = t.n) if (t.S.i !== t.i || !t.S.h() || t.S.i !== t.i) return !0;
  return !1;
}
function _3(e) {
  for (var t = e.s; t !== void 0; t = t.n) {
    var n = t.S.n;
    if (n !== void 0 && (t.r = n), t.S.n = t, t.i = -1, t.n === void 0) {
      e.s = t;
      break;
    }
  }
}
function T3(e) {
  for (var t = e.s, n = void 0; t !== void 0; ) {
    var r = t.p;
    t.i === -1 ? (t.S.U(t), r !== void 0 && (r.n = t.n), t.n !== void 0 && (t.n.p = r)) : n = t, t.S.n = t.r, t.r !== void 0 && (t.r = void 0), t = r;
  }
  e.s = n;
}
function xh(e, t) {
  yi.call(this, void 0), this.x = e, this.s = void 0, this.g = H0 - 1, this.f = 4, this.W = t?.watched, this.Z = t?.unwatched, this.name = t?.name;
}
xh.prototype = new yi();
xh.prototype.h = function() {
  if (this.f &= -3, 1 & this.f) return !1;
  if ((36 & this.f) == 32 || (this.f &= -5, this.g === H0)) return !0;
  if (this.g = H0, this.f |= 1, this.i > 0 && !E3(this))
    return this.f &= -2, !0;
  var e = dn;
  try {
    _3(this), dn = this;
    var t = this.x();
    (16 & this.f || this.v !== t || this.i === 0) && (this.v = t, this.f &= -17, this.i++);
  } catch (n) {
    this.v = n, this.f |= 16, this.i++;
  }
  return dn = e, T3(this), this.f &= -2, !0;
};
xh.prototype.S = function(e) {
  if (this.t === void 0) {
    this.f |= 36;
    for (var t = this.s; t !== void 0; t = t.n) t.S.S(t);
  }
  yi.prototype.S.call(this, e);
};
xh.prototype.U = function(e) {
  if (this.t !== void 0 && (yi.prototype.U.call(this, e), this.t === void 0)) {
    this.f &= -33;
    for (var t = this.s; t !== void 0; t = t.n) t.S.U(t);
  }
};
xh.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var e = this.t; e !== void 0; e = e.x) e.t.N();
  }
};
Object.defineProperty(xh.prototype, "value", { get: function() {
  if (1 & this.f) throw new Error("Cycle detected");
  var e = C3(this);
  if (this.h(), e !== void 0 && (e.i = this.i), 16 & this.f) throw this.v;
  return this.v;
} });
function A3(e) {
  var t = e.u;
  if (e.u = void 0, typeof t == "function") {
    Vf++;
    var n = dn;
    dn = void 0;
    try {
      t();
    } catch (r) {
      throw e.f &= -2, e.f |= 8, zT(e), r;
    } finally {
      dn = n, IT();
    }
  }
}
function zT(e) {
  for (var t = e.s; t !== void 0; t = t.n) t.S.U(t);
  e.x = void 0, e.s = void 0, A3(e);
}
function LK(e) {
  if (dn !== this) throw new Error("Out-of-order effect");
  T3(this), dn = e, this.f &= -2, 8 & this.f && zT(this), IT();
}
function wh(e, t) {
  this.x = e, this.u = void 0, this.s = void 0, this.o = void 0, this.f = 32, this.name = t?.name;
}
wh.prototype.c = function() {
  var e = this.S();
  try {
    if (8 & this.f || this.x === void 0) return;
    var t = this.x();
    typeof t == "function" && (this.u = t);
  } finally {
    e();
  }
};
wh.prototype.S = function() {
  if (1 & this.f) throw new Error("Cycle detected");
  this.f |= 1, this.f &= -9, A3(this), _3(this), Vf++;
  var e = dn;
  return dn = this, LK.bind(this, e);
};
wh.prototype.N = function() {
  2 & this.f || (this.f |= 2, this.o = wm, wm = this);
};
wh.prototype.d = function() {
  this.f |= 8, 1 & this.f || zT(this);
};
wh.prototype.dispose = function() {
  this.d();
};
function M3(e, t) {
  var n = new wh(e, t);
  try {
    n.c();
  } catch (i) {
    throw n.d(), i;
  }
  var r = n.d.bind(n);
  return r[Symbol.dispose] = r, r;
}
var sk = { exports: {} }, ak = {};
var dD;
function BK() {
  if (dD) return ak;
  dD = 1;
  var e = ud();
  function t(h, m) {
    return h === m && (h !== 0 || 1 / h === 1 / m) || h !== h && m !== m;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, s = e.useDebugValue;
  function a(h, m) {
    var g = m(), b = r({ inst: { value: g, getSnapshot: m } }), x = b[0].inst, w = b[1];
    return o(
      function() {
        x.value = g, x.getSnapshot = m, c(x) && w({ inst: x });
      },
      [h, g, m]
    ), i(
      function() {
        return c(x) && w({ inst: x }), h(function() {
          c(x) && w({ inst: x });
        });
      },
      [h]
    ), s(g), g;
  }
  function c(h) {
    var m = h.getSnapshot;
    h = h.value;
    try {
      var g = m();
      return !n(h, g);
    } catch {
      return !0;
    }
  }
  function u(h, m) {
    return m();
  }
  var f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? u : a;
  return ak.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : f, ak;
}
var fD;
function N3() {
  return fD || (fD = 1, sk.exports = BK()), sk.exports;
}
var th = N3(), $K = k.version.split(".").map(Number)[0], UK = /* @__PURE__ */ Symbol.for($K >= 19 ? "react.transitional.element" : "react.element"), FK = typeof window < "u" && !!window.__PREACT_SIGNALS_DEVTOOLS__, Ou, R3 = Symbol.dispose || /* @__PURE__ */ Symbol.for("Symbol.dispose");
function lk(e, t) {
  var n = t.effect.S();
  return Ou = t, VK.bind(t, e, n);
}
function VK(e, t) {
  t(), Ou = e;
}
var hD, SE, pD = function() {
}, HK = ((hD = { o: 0, effect: { s: void 0, c: function() {
}, S: function() {
  return pD;
}, d: function() {
} }, subscribe: function() {
  return pD;
}, getSnapshot: function() {
  return 0;
}, S: function() {
}, f: function() {
} })[R3] = function() {
}, hD), WK = Promise.prototype.then.bind(Promise.resolve());
function qK() {
  SE || (SE = WK(O3));
}
function O3() {
  var e;
  SE = void 0, (e = Ou) == null || e.f();
}
var GK = typeof window < "u" ? k.useLayoutEffect : k.useEffect;
function D3(e, t) {
  e === void 0 && (e = 0), qK();
  var n = k.useRef();
  n.current == null && (typeof window > "u" ? n.current = HK : n.current = (function(i, o) {
    var s, a, c, u, f = 0, h = M3(function() {
      a = this;
    }, { name: "Component" });
    return a.c = function() {
      if (f = f + 1 | 0, FK) {
        var m;
        (m = a.y) == null || m.call(a);
      }
      u && u();
    }, (s = { o: i, effect: a, subscribe: function(m) {
      return u = m, function() {
        f = f + 1 | 0, u = void 0, h();
      };
    }, getSnapshot: function() {
      return f;
    }, S: function() {
      if (Ou != null) {
        var m = Ou.o, g = this.o;
        m == 0 && g == 0 || m == 0 && g == 1 ? (Ou.f(), c = lk(void 0, this)) : m == 1 && g == 0 || m == 2 && g == 0 || (c = lk(Ou, this));
      } else c = lk(void 0, this);
    }, f: function() {
      var m = c;
      c = void 0, m?.();
    } })[R3] = function() {
      this.f();
    }, s;
  })(e));
  var r = n.current;
  return th.useSyncExternalStore(r.subscribe, r.getSnapshot, r.getSnapshot), r.S(), e === 0 && GK(O3), r;
}
Object.defineProperties(yi.prototype, { $$typeof: { configurable: !0, value: UK }, type: { configurable: !0, value: function(e) {
  var t = e.data, n = D3(1);
  try {
    return t.value;
  } finally {
    n.f();
  }
} }, props: { configurable: !0, get: function() {
  return { data: this };
} }, ref: { configurable: !0, value: null } });
function P3(e, t) {
  return D3(e);
}
const j3 = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim();
const KK = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const ZK = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, r) => r ? r.toUpperCase() : n.toLowerCase()
);
const mD = (e) => {
  const t = ZK(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
};
var YK = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
const XK = (e) => {
  for (const t in e)
    if (t.startsWith("aria-") || t === "role" || t === "title")
      return !0;
  return !1;
};
const JK = k.forwardRef(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: i = "",
    children: o,
    iconNode: s,
    ...a
  }, c) => k.createElement(
    "svg",
    {
      ref: c,
      ...YK,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: r ? Number(n) * 24 / Number(t) : n,
      className: j3("lucide", i),
      ...!o && !XK(a) && { "aria-hidden": "true" },
      ...a
    },
    [
      ...s.map(([u, f]) => k.createElement(u, f)),
      ...Array.isArray(o) ? o : [o]
    ]
  )
);
const ut = (e, t) => {
  const n = k.forwardRef(
    ({ className: r, ...i }, o) => k.createElement(JK, {
      ref: o,
      iconNode: t,
      className: j3(
        `lucide-${KK(mD(e))}`,
        `lucide-${e}`,
        r
      ),
      ...i
    })
  );
  return n.displayName = mD(e), n;
};
const QK = [
  ["path", { d: "m3 16 4 4 4-4", key: "1co6wj" }],
  ["path", { d: "M7 20V4", key: "1yoxec" }],
  ["path", { d: "m21 8-4-4-4 4", key: "1c9v7m" }],
  ["path", { d: "M17 4v16", key: "7dpous" }]
], eZ = ut("arrow-down-up", QK);
const tZ = [
  ["path", { d: "M7 7h10v10", key: "1tivn9" }],
  ["path", { d: "M7 17 17 7", key: "1vkiza" }]
], nZ = ut("arrow-up-right", tZ);
const rZ = [
  ["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }],
  ["path", { d: "M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8", key: "7n84p3" }]
], I3 = ut("at-sign", rZ);
const iZ = [
  [
    "path",
    {
      d: "M17 3a2 2 0 0 1 2 2v15a1 1 0 0 1-1.496.868l-4.512-2.578a2 2 0 0 0-1.984 0l-4.512 2.578A1 1 0 0 1 5 20V5a2 2 0 0 1 2-2z",
      key: "oz39mx"
    }
  ],
  ["path", { d: "m9 10 2 2 4-4", key: "1gnqz4" }]
], oZ = ut("bookmark-check", iZ);
const sZ = [
  [
    "path",
    {
      d: "M17 3a2 2 0 0 1 2 2v15a1 1 0 0 1-1.496.868l-4.512-2.578a2 2 0 0 0-1.984 0l-4.512 2.578A1 1 0 0 1 5 20V5a2 2 0 0 1 2-2z",
      key: "oz39mx"
    }
  ]
], z3 = ut("bookmark", sZ);
const aZ = [
  ["path", { d: "M12 6V2H8", key: "1155em" }],
  ["path", { d: "M15 11v2", key: "i11awn" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "M20 12h2", key: "1q8mjw" }],
  [
    "path",
    {
      d: "M20 16a2 2 0 0 1-2 2H8.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 4 20.286V8a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2z",
      key: "11gyqh"
    }
  ],
  ["path", { d: "M9 11v2", key: "1ueba0" }]
], LT = ut("bot-message-square", aZ);
const lZ = [
  ["path", { d: "M12 8V4H8", key: "hb8ula" }],
  ["rect", { width: "16", height: "12", x: "4", y: "8", rx: "2", key: "enze0r" }],
  ["path", { d: "M2 14h2", key: "vft8re" }],
  ["path", { d: "M20 14h2", key: "4cs60a" }],
  ["path", { d: "M15 13v2", key: "1xurst" }],
  ["path", { d: "M9 13v2", key: "rq6x2g" }]
], cZ = ut("bot", lZ);
const uZ = [
  [
    "path",
    {
      d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",
      key: "hh9hay"
    }
  ],
  ["path", { d: "m3.3 7 8.7 5 8.7-5", key: "g66t2b" }],
  ["path", { d: "M12 22V12", key: "d0xqtd" }]
], dZ = ut("box", uZ);
const fZ = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], Sc = ut("check", fZ);
const hZ = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], Ag = ut("chevron-down", hZ);
const pZ = [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]], mZ = ut("chevron-left", pZ);
const gZ = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]], Mg = ut("chevron-right", gZ);
const yZ = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], vZ = ut("chevron-up", yZ);
const bZ = [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
], xZ = ut("circle-check-big", bZ);
const wZ = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "10", x2: "10", y1: "15", y2: "9", key: "c1nkhi" }],
  ["line", { x1: "14", x2: "14", y1: "15", y2: "9", key: "h65svq" }]
], SZ = ut("circle-pause", wZ);
const kZ = [
  ["path", { d: "M12 13v8", key: "1l5pq0" }],
  ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242", key: "1pljnt" }],
  ["path", { d: "m8 17 4-4 4 4", key: "1quai1" }]
], CZ = ut("cloud-upload", kZ);
const EZ = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
], kc = ut("copy", EZ);
const _Z = [
  ["path", { d: "M12 15V3", key: "m9g1x1" }],
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["path", { d: "m7 10 5 5 5-5", key: "brsn70" }]
], kE = ut("download", _Z);
const TZ = [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }],
  ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }]
], AZ = ut("ellipsis-vertical", TZ);
const MZ = [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
], NZ = ut("external-link", MZ);
const RZ = [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], BT = ut("eye", RZ);
const OZ = [
  [
    "path",
    { d: "M12 6a2 2 0 0 1 3.414-1.414l6 6a2 2 0 0 1 0 2.828l-6 6A2 2 0 0 1 12 18z", key: "b19h5q" }
  ],
  [
    "path",
    { d: "M2 6a2 2 0 0 1 3.414-1.414l6 6a2 2 0 0 1 0 2.828l-6 6A2 2 0 0 1 2 18z", key: "h7h5ge" }
  ]
], DZ = ut("fast-forward", OZ);
const PZ = [
  [
    "path",
    {
      d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",
      key: "1oefj6"
    }
  ],
  ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }],
  ["path", { d: "M8 13h2", key: "yr2amv" }],
  ["path", { d: "M14 13h2", key: "un5t4a" }],
  ["path", { d: "M8 17h2", key: "2yhykz" }],
  ["path", { d: "M14 17h2", key: "10kma7" }]
], jZ = ut("file-spreadsheet", PZ);
const IZ = [
  [
    "path",
    {
      d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",
      key: "1oefj6"
    }
  ],
  ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
], zZ = ut("file-text", IZ);
const LZ = [
  [
    "path",
    {
      d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",
      key: "1oefj6"
    }
  ],
  ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }]
], BZ = ut("file", LZ);
const $Z = [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
], UZ = ut("grip-vertical", $Z);
const FZ = [
  ["line", { x1: "4", x2: "20", y1: "9", y2: "9", key: "4lhtct" }],
  ["line", { x1: "4", x2: "20", y1: "15", y2: "15", key: "vyu0kd" }],
  ["line", { x1: "10", x2: "8", y1: "3", y2: "21", key: "1ggp8o" }],
  ["line", { x1: "16", x2: "14", y1: "3", y2: "21", key: "weycgp" }]
], VZ = ut("hash", FZ);
const HZ = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
], WZ = ut("image", HZ);
const qZ = [
  [
    "path",
    {
      d: "M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5",
      key: "1gvzjb"
    }
  ],
  ["path", { d: "M9 18h6", key: "x1upvd" }],
  ["path", { d: "M10 22h4", key: "ceow96" }]
], GZ = ut("lightbulb", qZ);
const KZ = [
  ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }],
  ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]
], ZZ = ut("link", KZ);
const YZ = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]], Zs = ut("loader-circle", YZ);
const XZ = [
  ["path", { d: "M12 2v4", key: "3427ic" }],
  ["path", { d: "m16.2 7.8 2.9-2.9", key: "r700ao" }],
  ["path", { d: "M18 12h4", key: "wj9ykh" }],
  ["path", { d: "m16.2 16.2 2.9 2.9", key: "1bxg5t" }],
  ["path", { d: "M12 18v4", key: "jadmvz" }],
  ["path", { d: "m4.9 19.1 2.9-2.9", key: "bwix9q" }],
  ["path", { d: "M2 12h4", key: "j09sii" }],
  ["path", { d: "m4.9 4.9 2.9 2.9", key: "giyufr" }]
], $T = ut("loader", XZ);
const JZ = [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "m21 3-7 7", key: "1l2asr" }],
  ["path", { d: "m3 21 7-7", key: "tjx5ai" }],
  ["path", { d: "M9 21H3v-6", key: "wtvkvv" }]
], gD = ut("maximize-2", JZ);
const QZ = [
  ["path", { d: "M4 5h16", key: "1tepv9" }],
  ["path", { d: "M4 12h16", key: "1lakjw" }],
  ["path", { d: "M4 19h16", key: "1djgab" }]
], eY = ut("menu", QZ);
const tY = [
  [
    "path",
    {
      d: "M2.992 16.342a2 2 0 0 1 .094 1.167l-1.065 3.29a1 1 0 0 0 1.236 1.168l3.413-.998a2 2 0 0 1 1.099.092 10 10 0 1 0-4.777-4.719",
      key: "1sd12s"
    }
  ]
], nY = ut("message-circle", tY);
const rY = [
  [
    "path",
    {
      d: "M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z",
      key: "18887p"
    }
  ],
  ["path", { d: "M7 11h10", key: "1twpyw" }],
  ["path", { d: "M7 15h6", key: "d9of3u" }],
  ["path", { d: "M7 7h8", key: "af5zfr" }]
], iY = ut("message-square-text", rY);
const oY = [
  [
    "path",
    {
      d: "M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z",
      key: "18887p"
    }
  ]
], yD = ut("message-square", oY);
const sY = [
  ["path", { d: "M12 19v3", key: "npa21l" }],
  ["path", { d: "M15 9.34V5a3 3 0 0 0-5.68-1.33", key: "1gzdoj" }],
  ["path", { d: "M16.95 16.95A7 7 0 0 1 5 12v-2", key: "cqa7eg" }],
  ["path", { d: "M18.89 13.23A7 7 0 0 0 19 12v-2", key: "16hl24" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }],
  ["path", { d: "M9 9v3a3 3 0 0 0 5.12 2.12", key: "r2i35w" }]
], aY = ut("mic-off", sY);
const lY = [
  ["path", { d: "M12 19v3", key: "npa21l" }],
  ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
  ["rect", { x: "9", y: "2", width: "6", height: "13", rx: "3", key: "s6n7sd" }]
], cY = ut("mic", lY);
const uY = [
  ["path", { d: "m14 10 7-7", key: "oa77jy" }],
  ["path", { d: "M20 10h-6V4", key: "mjg0md" }],
  ["path", { d: "m3 21 7-7", key: "tjx5ai" }],
  ["path", { d: "M4 14h6v6", key: "rmj7iw" }]
], vD = ut("minimize-2", uY);
const dY = [
  ["rect", { x: "14", y: "3", width: "5", height: "18", rx: "1", key: "kaeet6" }],
  ["rect", { x: "5", y: "3", width: "5", height: "18", rx: "1", key: "1wsw3u" }]
], fY = ut("pause", dY);
const hY = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
], pY = ut("plus", hY);
const mY = [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
], gY = ut("refresh-cw", mY);
const yY = [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
], UT = ut("rotate-ccw", yY);
const vY = [
  ["path", { d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8", key: "1p45f6" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }]
], bY = ut("rotate-cw", vY);
const xY = [
  ["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }],
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]
], wY = ut("search", xY);
const SY = [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
], kY = ut("send", SY);
const CY = [
  ["rect", { width: "20", height: "8", x: "2", y: "2", rx: "2", ry: "2", key: "ngkwjq" }],
  ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2", ry: "2", key: "iecqi9" }],
  ["line", { x1: "6", x2: "6.01", y1: "6", y2: "6", key: "16zg32" }],
  ["line", { x1: "6", x2: "6.01", y1: "18", y2: "18", key: "nzw8ys" }]
], bD = ut("server", CY);
const EY = [
  [
    "path",
    {
      d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
      key: "1i5ecw"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], L3 = ut("settings", EY);
const _Y = [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ],
  ["path", { d: "M12 8v4", key: "1got3b" }],
  ["path", { d: "M12 16h.01", key: "1drbdi" }]
], W0 = ut("shield-alert", _Y);
const TY = [
  ["circle", { cx: "8", cy: "21", r: "1", key: "jimo8o" }],
  ["circle", { cx: "19", cy: "21", r: "1", key: "13723u" }],
  [
    "path",
    {
      d: "M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",
      key: "9zh506"
    }
  ]
], AY = ut("shopping-cart", TY);
const MY = [
  [
    "path",
    {
      d: "M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z",
      key: "1s2grr"
    }
  ],
  ["path", { d: "M20 2v4", key: "1rf3ol" }],
  ["path", { d: "M22 4h-4", key: "gwowj6" }],
  ["circle", { cx: "4", cy: "20", r: "2", key: "6kqj1y" }]
], NY = ut("sparkles", MY);
const RY = [
  ["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }],
  [
    "path",
    {
      d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
      key: "ohrbg2"
    }
  ]
], OY = ut("square-pen", RY);
const DY = [
  ["path", { d: "M15 21v-5a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v5", key: "slp6dd" }],
  [
    "path",
    {
      d: "M17.774 10.31a1.12 1.12 0 0 0-1.549 0 2.5 2.5 0 0 1-3.451 0 1.12 1.12 0 0 0-1.548 0 2.5 2.5 0 0 1-3.452 0 1.12 1.12 0 0 0-1.549 0 2.5 2.5 0 0 1-3.77-3.248l2.889-4.184A2 2 0 0 1 7 2h10a2 2 0 0 1 1.653.873l2.895 4.192a2.5 2.5 0 0 1-3.774 3.244",
      key: "o0xfot"
    }
  ],
  ["path", { d: "M4 10.95V19a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8.05", key: "wn3emo" }]
], PY = ut("store", DY);
const jY = [
  ["polyline", { points: "14.5 17.5 3 6 3 3 6 3 17.5 14.5", key: "1hfsw2" }],
  ["line", { x1: "13", x2: "19", y1: "19", y2: "13", key: "1vrmhu" }],
  ["line", { x1: "16", x2: "20", y1: "16", y2: "20", key: "1bron3" }],
  ["line", { x1: "19", x2: "21", y1: "21", y2: "19", key: "13pww6" }],
  ["polyline", { points: "14.5 6.5 18 3 21 3 21 6 17.5 9.5", key: "hbey2j" }],
  ["line", { x1: "5", x2: "9", y1: "14", y2: "18", key: "1hf58s" }],
  ["line", { x1: "7", x2: "4", y1: "17", y2: "20", key: "pidxm4" }],
  ["line", { x1: "3", x2: "5", y1: "19", y2: "21", key: "1pehsh" }]
], IY = ut("swords", jY);
const zY = [
  ["path", { d: "M10 11v6", key: "nco0om" }],
  ["path", { d: "M14 11v6", key: "outv1u" }],
  ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6", key: "miytrc" }],
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2", key: "e791ji" }]
], B3 = ut("trash-2", zY);
const LY = [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
], BY = ut("triangle-alert", LY);
const $Y = [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["path", { d: "M16 3.128a4 4 0 0 1 0 7.744", key: "16gr8j" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
], UY = ut("users", $Y);
const FY = [
  ["rect", { width: "8", height: "8", x: "3", y: "3", rx: "2", key: "by2w9f" }],
  ["path", { d: "M7 11v4a2 2 0 0 0 2 2h4", key: "xkn7yn" }],
  ["rect", { width: "8", height: "8", x: "13", y: "13", rx: "2", key: "1cgmvn" }]
], VY = ut("workflow", FY);
const HY = [
  [
    "path",
    {
      d: "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.106-3.105c.32-.322.863-.22.983.218a6 6 0 0 1-8.259 7.057l-7.91 7.91a1 1 0 0 1-2.999-3l7.91-7.91a6 6 0 0 1 7.057-8.259c.438.12.54.662.219.984z",
      key: "1ngwbx"
    }
  ]
], q0 = ut("wrench", HY);
const WY = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
], Ng = ut("x", WY);
var tl = zx();
const $3 = /* @__PURE__ */ Pc(tl);
function xD(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function nl(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const o = xD(i, t);
      return !n && typeof o == "function" && (n = !0), o;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const o = r[i];
          typeof o == "function" ? o() : xD(e[i], null);
        }
      };
  };
}
function Ft(...e) {
  return k.useCallback(nl(...e), e);
}
// @__NO_SIDE_EFFECTS__
function qY(e) {
  const t = /* @__PURE__ */ GY(e), n = k.forwardRef((r, i) => {
    const { children: o, ...s } = r, a = k.Children.toArray(o), c = a.find(ZY);
    if (c) {
      const u = c.props.children, f = a.map((h) => h === c ? k.Children.count(u) > 1 ? k.Children.only(null) : k.isValidElement(u) ? u.props.children : null : h);
      return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: k.isValidElement(u) ? k.cloneElement(u, void 0, f) : null });
    }
    return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: o });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function GY(e) {
  const t = k.forwardRef((n, r) => {
    const { children: i, ...o } = n;
    if (k.isValidElement(i)) {
      const s = XY(i), a = YY(o, i.props);
      return i.type !== k.Fragment && (a.ref = r ? nl(r, s) : s), k.cloneElement(i, a);
    }
    return k.Children.count(i) > 1 ? k.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var KY = /* @__PURE__ */ Symbol("radix.slottable");
function ZY(e) {
  return k.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === KY;
}
function YY(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...a) => {
      const c = o(...a);
      return i(...a), c;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function XY(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var JY = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Et = JY.reduce((e, t) => {
  const n = /* @__PURE__ */ qY(`Primitive.${t}`), r = k.forwardRef((i, o) => {
    const { asChild: s, ...a } = i, c = s ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ v.jsx(c, { ...a, ref: o });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function U3(e, t) {
  e && tl.flushSync(() => e.dispatchEvent(t));
}
var Er = globalThis?.document ? k.useLayoutEffect : () => {
};
function QY(e, t) {
  return k.useReducer((n, r) => t[n][r] ?? n, e);
}
var Di = (e) => {
  const { present: t, children: n } = e, r = eX(t), i = typeof n == "function" ? n({ present: r.isPresent }) : k.Children.only(n), o = Ft(r.ref, tX(i));
  return typeof n == "function" || r.isPresent ? k.cloneElement(i, { ref: o }) : null;
};
Di.displayName = "Presence";
function eX(e) {
  const [t, n] = k.useState(), r = k.useRef(null), i = k.useRef(e), o = k.useRef("none"), s = e ? "mounted" : "unmounted", [a, c] = QY(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return k.useEffect(() => {
    const u = xv(r.current);
    o.current = a === "mounted" ? u : "none";
  }, [a]), Er(() => {
    const u = r.current, f = i.current;
    if (f !== e) {
      const m = o.current, g = xv(u);
      e ? c("MOUNT") : g === "none" || u?.display === "none" ? c("UNMOUNT") : c(f && m !== g ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, c]), Er(() => {
    if (t) {
      let u;
      const f = t.ownerDocument.defaultView ?? window, h = (g) => {
        const x = xv(r.current).includes(CSS.escape(g.animationName));
        if (g.target === t && x && (c("ANIMATION_END"), !i.current)) {
          const w = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", u = f.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = w);
          });
        }
      }, m = (g) => {
        g.target === t && (o.current = xv(r.current));
      };
      return t.addEventListener("animationstart", m), t.addEventListener("animationcancel", h), t.addEventListener("animationend", h), () => {
        f.clearTimeout(u), t.removeEventListener("animationstart", m), t.removeEventListener("animationcancel", h), t.removeEventListener("animationend", h);
      };
    } else
      c("ANIMATION_END");
  }, [t, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: k.useCallback((u) => {
      r.current = u ? getComputedStyle(u) : null, n(u);
    }, [])
  };
}
function xv(e) {
  return e?.animationName || "none";
}
function tX(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function nX(e, t) {
  const n = k.createContext(t), r = (o) => {
    const { children: s, ...a } = o, c = k.useMemo(() => a, Object.values(a));
    return /* @__PURE__ */ v.jsx(n.Provider, { value: c, children: s });
  };
  r.displayName = e + "Provider";
  function i(o) {
    const s = k.useContext(n);
    if (s) return s;
    if (t !== void 0) return t;
    throw new Error(`\`${o}\` must be used within \`${e}\``);
  }
  return [r, i];
}
function ps(e, t = []) {
  let n = [];
  function r(o, s) {
    const a = k.createContext(s), c = n.length;
    n = [...n, s];
    const u = (h) => {
      const { scope: m, children: g, ...b } = h, x = m?.[e]?.[c] || a, w = k.useMemo(() => b, Object.values(b));
      return /* @__PURE__ */ v.jsx(x.Provider, { value: w, children: g });
    };
    u.displayName = o + "Provider";
    function f(h, m) {
      const g = m?.[e]?.[c] || a, b = k.useContext(g);
      if (b) return b;
      if (s !== void 0) return s;
      throw new Error(`\`${h}\` must be used within \`${o}\``);
    }
    return [u, f];
  }
  const i = () => {
    const o = n.map((s) => k.createContext(s));
    return function(a) {
      const c = a?.[e] || o;
      return k.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: c } }),
        [a, c]
      );
    };
  };
  return i.scopeName = e, [r, rX(i, ...t)];
}
function rX(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(o) {
      const s = r.reduce((a, { useScope: c, scopeName: u }) => {
        const h = c(o)[`__scope${u}`];
        return { ...a, ...h };
      }, {});
      return k.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Dr(e) {
  const t = k.useRef(e);
  return k.useEffect(() => {
    t.current = e;
  }), k.useMemo(() => (...n) => t.current?.(...n), []);
}
var iX = k.createContext(void 0);
function Lx(e) {
  const t = k.useContext(iX);
  return e || t || "ltr";
}
function CE(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function Ye(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e?.(i), n === !1 || !i.defaultPrevented)
      return t?.(i);
  };
}
function oX(e, t) {
  return k.useReducer((n, r) => t[n][r] ?? n, e);
}
var FT = "ScrollArea", [F3] = ps(FT), [sX, qo] = F3(FT), V3 = k.forwardRef(
  (e, t) => {
    const {
      __scopeScrollArea: n,
      type: r = "hover",
      dir: i,
      scrollHideDelay: o = 600,
      ...s
    } = e, [a, c] = k.useState(null), [u, f] = k.useState(null), [h, m] = k.useState(null), [g, b] = k.useState(null), [x, w] = k.useState(null), [S, _] = k.useState(0), [M, N] = k.useState(0), [P, I] = k.useState(!1), [O, L] = k.useState(!1), U = Ft(t, (G) => c(G)), B = Lx(i);
    return /* @__PURE__ */ v.jsx(
      sX,
      {
        scope: n,
        type: r,
        dir: B,
        scrollHideDelay: o,
        scrollArea: a,
        viewport: u,
        onViewportChange: f,
        content: h,
        onContentChange: m,
        scrollbarX: g,
        onScrollbarXChange: b,
        scrollbarXEnabled: P,
        onScrollbarXEnabledChange: I,
        scrollbarY: x,
        onScrollbarYChange: w,
        scrollbarYEnabled: O,
        onScrollbarYEnabledChange: L,
        onCornerWidthChange: _,
        onCornerHeightChange: N,
        children: /* @__PURE__ */ v.jsx(
          Et.div,
          {
            dir: B,
            ...s,
            ref: U,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": S + "px",
              "--radix-scroll-area-corner-height": M + "px",
              ...e.style
            }
          }
        )
      }
    );
  }
);
V3.displayName = FT;
var H3 = "ScrollAreaViewport", W3 = k.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, children: r, nonce: i, ...o } = e, s = qo(H3, n), a = k.useRef(null), c = Ft(t, a, s.onViewportChange);
    return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: i
        }
      ),
      /* @__PURE__ */ v.jsx(
        Et.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...o,
          ref: c,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: s.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: s.scrollbarYEnabled ? "scroll" : "hidden",
            ...e.style
          },
          children: /* @__PURE__ */ v.jsx("div", { ref: s.onContentChange, style: { minWidth: "100%", display: "table" }, children: r })
        }
      )
    ] });
  }
);
W3.displayName = H3;
var ta = "ScrollAreaScrollbar", q3 = k.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, i = qo(ta, e.__scopeScrollArea), { onScrollbarXEnabledChange: o, onScrollbarYEnabledChange: s } = i, a = e.orientation === "horizontal";
    return k.useEffect(() => (a ? o(!0) : s(!0), () => {
      a ? o(!1) : s(!1);
    }), [a, o, s]), i.type === "hover" ? /* @__PURE__ */ v.jsx(aX, { ...r, ref: t, forceMount: n }) : i.type === "scroll" ? /* @__PURE__ */ v.jsx(lX, { ...r, ref: t, forceMount: n }) : i.type === "auto" ? /* @__PURE__ */ v.jsx(G3, { ...r, ref: t, forceMount: n }) : i.type === "always" ? /* @__PURE__ */ v.jsx(VT, { ...r, ref: t }) : null;
  }
);
q3.displayName = ta;
var aX = k.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, i = qo(ta, e.__scopeScrollArea), [o, s] = k.useState(!1);
  return k.useEffect(() => {
    const a = i.scrollArea;
    let c = 0;
    if (a) {
      const u = () => {
        window.clearTimeout(c), s(!0);
      }, f = () => {
        c = window.setTimeout(() => s(!1), i.scrollHideDelay);
      };
      return a.addEventListener("pointerenter", u), a.addEventListener("pointerleave", f), () => {
        window.clearTimeout(c), a.removeEventListener("pointerenter", u), a.removeEventListener("pointerleave", f);
      };
    }
  }, [i.scrollArea, i.scrollHideDelay]), /* @__PURE__ */ v.jsx(Di, { present: n || o, children: /* @__PURE__ */ v.jsx(
    G3,
    {
      "data-state": o ? "visible" : "hidden",
      ...r,
      ref: t
    }
  ) });
}), lX = k.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, i = qo(ta, e.__scopeScrollArea), o = e.orientation === "horizontal", s = $x(() => c("SCROLL_END"), 100), [a, c] = oX("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return k.useEffect(() => {
    if (a === "idle") {
      const u = window.setTimeout(() => c("HIDE"), i.scrollHideDelay);
      return () => window.clearTimeout(u);
    }
  }, [a, i.scrollHideDelay, c]), k.useEffect(() => {
    const u = i.viewport, f = o ? "scrollLeft" : "scrollTop";
    if (u) {
      let h = u[f];
      const m = () => {
        const g = u[f];
        h !== g && (c("SCROLL"), s()), h = g;
      };
      return u.addEventListener("scroll", m), () => u.removeEventListener("scroll", m);
    }
  }, [i.viewport, o, c, s]), /* @__PURE__ */ v.jsx(Di, { present: n || a !== "hidden", children: /* @__PURE__ */ v.jsx(
    VT,
    {
      "data-state": a === "hidden" ? "hidden" : "visible",
      ...r,
      ref: t,
      onPointerEnter: Ye(e.onPointerEnter, () => c("POINTER_ENTER")),
      onPointerLeave: Ye(e.onPointerLeave, () => c("POINTER_LEAVE"))
    }
  ) });
}), G3 = k.forwardRef((e, t) => {
  const n = qo(ta, e.__scopeScrollArea), { forceMount: r, ...i } = e, [o, s] = k.useState(!1), a = e.orientation === "horizontal", c = $x(() => {
    if (n.viewport) {
      const u = n.viewport.offsetWidth < n.viewport.scrollWidth, f = n.viewport.offsetHeight < n.viewport.scrollHeight;
      s(a ? u : f);
    }
  }, 10);
  return nh(n.viewport, c), nh(n.content, c), /* @__PURE__ */ v.jsx(Di, { present: r || o, children: /* @__PURE__ */ v.jsx(
    VT,
    {
      "data-state": o ? "visible" : "hidden",
      ...i,
      ref: t
    }
  ) });
}), VT = k.forwardRef((e, t) => {
  const { orientation: n = "vertical", ...r } = e, i = qo(ta, e.__scopeScrollArea), o = k.useRef(null), s = k.useRef(0), [a, c] = k.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), u = J3(a.viewport, a.content), f = {
    ...r,
    sizes: a,
    onSizesChange: c,
    hasThumb: u > 0 && u < 1,
    onThumbChange: (m) => o.current = m,
    onThumbPointerUp: () => s.current = 0,
    onThumbPointerDown: (m) => s.current = m
  };
  function h(m, g) {
    return pX(m, s.current, a, g);
  }
  return n === "horizontal" ? /* @__PURE__ */ v.jsx(
    cX,
    {
      ...f,
      ref: t,
      onThumbPositionChange: () => {
        if (i.viewport && o.current) {
          const m = i.viewport.scrollLeft, g = wD(m, a, i.dir);
          o.current.style.transform = `translate3d(${g}px, 0, 0)`;
        }
      },
      onWheelScroll: (m) => {
        i.viewport && (i.viewport.scrollLeft = m);
      },
      onDragScroll: (m) => {
        i.viewport && (i.viewport.scrollLeft = h(m, i.dir));
      }
    }
  ) : n === "vertical" ? /* @__PURE__ */ v.jsx(
    uX,
    {
      ...f,
      ref: t,
      onThumbPositionChange: () => {
        if (i.viewport && o.current) {
          const m = i.viewport.scrollTop, g = wD(m, a);
          o.current.style.transform = `translate3d(0, ${g}px, 0)`;
        }
      },
      onWheelScroll: (m) => {
        i.viewport && (i.viewport.scrollTop = m);
      },
      onDragScroll: (m) => {
        i.viewport && (i.viewport.scrollTop = h(m));
      }
    }
  ) : null;
}), cX = k.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: r, ...i } = e, o = qo(ta, e.__scopeScrollArea), [s, a] = k.useState(), c = k.useRef(null), u = Ft(t, c, o.onScrollbarXChange);
  return k.useEffect(() => {
    c.current && a(getComputedStyle(c.current));
  }, [c]), /* @__PURE__ */ v.jsx(
    Z3,
    {
      "data-orientation": "horizontal",
      ...i,
      ref: u,
      sizes: n,
      style: {
        bottom: 0,
        left: o.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: o.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": Bx(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (f) => e.onThumbPointerDown(f.x),
      onDragScroll: (f) => e.onDragScroll(f.x),
      onWheelScroll: (f, h) => {
        if (o.viewport) {
          const m = o.viewport.scrollLeft + f.deltaX;
          e.onWheelScroll(m), e4(m, h) && f.preventDefault();
        }
      },
      onResize: () => {
        c.current && o.viewport && s && r({
          content: o.viewport.scrollWidth,
          viewport: o.viewport.offsetWidth,
          scrollbar: {
            size: c.current.clientWidth,
            paddingStart: K0(s.paddingLeft),
            paddingEnd: K0(s.paddingRight)
          }
        });
      }
    }
  );
}), uX = k.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: r, ...i } = e, o = qo(ta, e.__scopeScrollArea), [s, a] = k.useState(), c = k.useRef(null), u = Ft(t, c, o.onScrollbarYChange);
  return k.useEffect(() => {
    c.current && a(getComputedStyle(c.current));
  }, [c]), /* @__PURE__ */ v.jsx(
    Z3,
    {
      "data-orientation": "vertical",
      ...i,
      ref: u,
      sizes: n,
      style: {
        top: 0,
        right: o.dir === "ltr" ? 0 : void 0,
        left: o.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": Bx(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (f) => e.onThumbPointerDown(f.y),
      onDragScroll: (f) => e.onDragScroll(f.y),
      onWheelScroll: (f, h) => {
        if (o.viewport) {
          const m = o.viewport.scrollTop + f.deltaY;
          e.onWheelScroll(m), e4(m, h) && f.preventDefault();
        }
      },
      onResize: () => {
        c.current && o.viewport && s && r({
          content: o.viewport.scrollHeight,
          viewport: o.viewport.offsetHeight,
          scrollbar: {
            size: c.current.clientHeight,
            paddingStart: K0(s.paddingTop),
            paddingEnd: K0(s.paddingBottom)
          }
        });
      }
    }
  );
}), [dX, K3] = F3(ta), Z3 = k.forwardRef((e, t) => {
  const {
    __scopeScrollArea: n,
    sizes: r,
    hasThumb: i,
    onThumbChange: o,
    onThumbPointerUp: s,
    onThumbPointerDown: a,
    onThumbPositionChange: c,
    onDragScroll: u,
    onWheelScroll: f,
    onResize: h,
    ...m
  } = e, g = qo(ta, n), [b, x] = k.useState(null), w = Ft(t, (U) => x(U)), S = k.useRef(null), _ = k.useRef(""), M = g.viewport, N = r.content - r.viewport, P = Dr(f), I = Dr(c), O = $x(h, 10);
  function L(U) {
    if (S.current) {
      const B = U.clientX - S.current.left, G = U.clientY - S.current.top;
      u({ x: B, y: G });
    }
  }
  return k.useEffect(() => {
    const U = (B) => {
      const G = B.target;
      b?.contains(G) && P(B, N);
    };
    return document.addEventListener("wheel", U, { passive: !1 }), () => document.removeEventListener("wheel", U, { passive: !1 });
  }, [M, b, N, P]), k.useEffect(I, [r, I]), nh(b, O), nh(g.content, O), /* @__PURE__ */ v.jsx(
    dX,
    {
      scope: n,
      scrollbar: b,
      hasThumb: i,
      onThumbChange: Dr(o),
      onThumbPointerUp: Dr(s),
      onThumbPositionChange: I,
      onThumbPointerDown: Dr(a),
      children: /* @__PURE__ */ v.jsx(
        Et.div,
        {
          ...m,
          ref: w,
          style: { position: "absolute", ...m.style },
          onPointerDown: Ye(e.onPointerDown, (U) => {
            U.button === 0 && (U.target.setPointerCapture(U.pointerId), S.current = b.getBoundingClientRect(), _.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", g.viewport && (g.viewport.style.scrollBehavior = "auto"), L(U));
          }),
          onPointerMove: Ye(e.onPointerMove, L),
          onPointerUp: Ye(e.onPointerUp, (U) => {
            const B = U.target;
            B.hasPointerCapture(U.pointerId) && B.releasePointerCapture(U.pointerId), document.body.style.webkitUserSelect = _.current, g.viewport && (g.viewport.style.scrollBehavior = ""), S.current = null;
          })
        }
      )
    }
  );
}), G0 = "ScrollAreaThumb", Y3 = k.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, i = K3(G0, e.__scopeScrollArea);
    return /* @__PURE__ */ v.jsx(Di, { present: n || i.hasThumb, children: /* @__PURE__ */ v.jsx(fX, { ref: t, ...r }) });
  }
), fX = k.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, style: r, ...i } = e, o = qo(G0, n), s = K3(G0, n), { onThumbPositionChange: a } = s, c = Ft(
      t,
      (h) => s.onThumbChange(h)
    ), u = k.useRef(void 0), f = $x(() => {
      u.current && (u.current(), u.current = void 0);
    }, 100);
    return k.useEffect(() => {
      const h = o.viewport;
      if (h) {
        const m = () => {
          if (f(), !u.current) {
            const g = mX(h, a);
            u.current = g, a();
          }
        };
        return a(), h.addEventListener("scroll", m), () => h.removeEventListener("scroll", m);
      }
    }, [o.viewport, f, a]), /* @__PURE__ */ v.jsx(
      Et.div,
      {
        "data-state": s.hasThumb ? "visible" : "hidden",
        ...i,
        ref: c,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...r
        },
        onPointerDownCapture: Ye(e.onPointerDownCapture, (h) => {
          const g = h.target.getBoundingClientRect(), b = h.clientX - g.left, x = h.clientY - g.top;
          s.onThumbPointerDown({ x: b, y: x });
        }),
        onPointerUp: Ye(e.onPointerUp, s.onThumbPointerUp)
      }
    );
  }
);
Y3.displayName = G0;
var HT = "ScrollAreaCorner", X3 = k.forwardRef(
  (e, t) => {
    const n = qo(HT, e.__scopeScrollArea), r = !!(n.scrollbarX && n.scrollbarY);
    return n.type !== "scroll" && r ? /* @__PURE__ */ v.jsx(hX, { ...e, ref: t }) : null;
  }
);
X3.displayName = HT;
var hX = k.forwardRef((e, t) => {
  const { __scopeScrollArea: n, ...r } = e, i = qo(HT, n), [o, s] = k.useState(0), [a, c] = k.useState(0), u = !!(o && a);
  return nh(i.scrollbarX, () => {
    const f = i.scrollbarX?.offsetHeight || 0;
    i.onCornerHeightChange(f), c(f);
  }), nh(i.scrollbarY, () => {
    const f = i.scrollbarY?.offsetWidth || 0;
    i.onCornerWidthChange(f), s(f);
  }), u ? /* @__PURE__ */ v.jsx(
    Et.div,
    {
      ...r,
      ref: t,
      style: {
        width: o,
        height: a,
        position: "absolute",
        right: i.dir === "ltr" ? 0 : void 0,
        left: i.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...e.style
      }
    }
  ) : null;
});
function K0(e) {
  return e ? parseInt(e, 10) : 0;
}
function J3(e, t) {
  const n = e / t;
  return isNaN(n) ? 0 : n;
}
function Bx(e) {
  const t = J3(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, r = (e.scrollbar.size - n) * t;
  return Math.max(r, 18);
}
function pX(e, t, n, r = "ltr") {
  const i = Bx(n), o = i / 2, s = t || o, a = i - s, c = n.scrollbar.paddingStart + s, u = n.scrollbar.size - n.scrollbar.paddingEnd - a, f = n.content - n.viewport, h = r === "ltr" ? [0, f] : [f * -1, 0];
  return Q3([c, u], h)(e);
}
function wD(e, t, n = "ltr") {
  const r = Bx(t), i = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, o = t.scrollbar.size - i, s = t.content - t.viewport, a = o - r, c = n === "ltr" ? [0, s] : [s * -1, 0], u = CE(e, c);
  return Q3([0, s], [0, a])(u);
}
function Q3(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function e4(e, t) {
  return e > 0 && e < t;
}
var mX = (e, t = () => {
}) => {
  let n = { left: e.scrollLeft, top: e.scrollTop }, r = 0;
  return (function i() {
    const o = { left: e.scrollLeft, top: e.scrollTop }, s = n.left !== o.left, a = n.top !== o.top;
    (s || a) && t(), n = o, r = window.requestAnimationFrame(i);
  })(), () => window.cancelAnimationFrame(r);
};
function $x(e, t) {
  const n = Dr(e), r = k.useRef(0);
  return k.useEffect(() => () => window.clearTimeout(r.current), []), k.useCallback(() => {
    window.clearTimeout(r.current), r.current = window.setTimeout(n, t);
  }, [n, t]);
}
function nh(e, t) {
  const n = Dr(t);
  Er(() => {
    let r = 0;
    if (e) {
      const i = new ResizeObserver(() => {
        cancelAnimationFrame(r), r = window.requestAnimationFrame(n);
      });
      return i.observe(e), () => {
        window.cancelAnimationFrame(r), i.unobserve(e);
      };
    }
  }, [e, n]);
}
var gX = V3, yX = W3, vX = X3;
function t4(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = t4(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function pc() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = t4(e)) && (r && (r += " "), r += t);
  return r;
}
const bX = (e, t) => {
  const n = new Array(e.length + t.length);
  for (let r = 0; r < e.length; r++)
    n[r] = e[r];
  for (let r = 0; r < t.length; r++)
    n[e.length + r] = t[r];
  return n;
}, xX = (e, t) => ({
  classGroupId: e,
  validator: t
}), n4 = (e = /* @__PURE__ */ new Map(), t = null, n) => ({
  nextPart: e,
  validators: t,
  classGroupId: n
}), Z0 = "-", SD = [], wX = "arbitrary..", SX = (e) => {
  const t = CX(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: r
  } = e;
  return {
    getClassGroupId: (s) => {
      if (s.startsWith("[") && s.endsWith("]"))
        return kX(s);
      const a = s.split(Z0), c = a[0] === "" && a.length > 1 ? 1 : 0;
      return r4(a, c, t);
    },
    getConflictingClassGroupIds: (s, a) => {
      if (a) {
        const c = r[s], u = n[s];
        return c ? u ? bX(u, c) : c : u || SD;
      }
      return n[s] || SD;
    }
  };
}, r4 = (e, t, n) => {
  if (e.length - t === 0)
    return n.classGroupId;
  const i = e[t], o = n.nextPart.get(i);
  if (o) {
    const u = r4(e, t + 1, o);
    if (u) return u;
  }
  const s = n.validators;
  if (s === null)
    return;
  const a = t === 0 ? e.join(Z0) : e.slice(t).join(Z0), c = s.length;
  for (let u = 0; u < c; u++) {
    const f = s[u];
    if (f.validator(a))
      return f.classGroupId;
  }
}, kX = (e) => e.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const t = e.slice(1, -1), n = t.indexOf(":"), r = t.slice(0, n);
  return r ? wX + r : void 0;
})(), CX = (e) => {
  const {
    theme: t,
    classGroups: n
  } = e;
  return EX(n, t);
}, EX = (e, t) => {
  const n = n4();
  for (const r in e) {
    const i = e[r];
    WT(i, n, r, t);
  }
  return n;
}, WT = (e, t, n, r) => {
  const i = e.length;
  for (let o = 0; o < i; o++) {
    const s = e[o];
    _X(s, t, n, r);
  }
}, _X = (e, t, n, r) => {
  if (typeof e == "string") {
    TX(e, t, n);
    return;
  }
  if (typeof e == "function") {
    AX(e, t, n, r);
    return;
  }
  MX(e, t, n, r);
}, TX = (e, t, n) => {
  const r = e === "" ? t : i4(t, e);
  r.classGroupId = n;
}, AX = (e, t, n, r) => {
  if (NX(e)) {
    WT(e(r), t, n, r);
    return;
  }
  t.validators === null && (t.validators = []), t.validators.push(xX(n, e));
}, MX = (e, t, n, r) => {
  const i = Object.entries(e), o = i.length;
  for (let s = 0; s < o; s++) {
    const [a, c] = i[s];
    WT(c, i4(t, a), n, r);
  }
}, i4 = (e, t) => {
  let n = e;
  const r = t.split(Z0), i = r.length;
  for (let o = 0; o < i; o++) {
    const s = r[o];
    let a = n.nextPart.get(s);
    a || (a = n4(), n.nextPart.set(s, a)), n = a;
  }
  return n;
}, NX = (e) => "isThemeGetter" in e && e.isThemeGetter === !0, RX = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  const i = (o, s) => {
    n[o] = s, t++, t > e && (t = 0, r = n, n = /* @__PURE__ */ Object.create(null));
  };
  return {
    get(o) {
      let s = n[o];
      if (s !== void 0)
        return s;
      if ((s = r[o]) !== void 0)
        return i(o, s), s;
    },
    set(o, s) {
      o in n ? n[o] = s : i(o, s);
    }
  };
}, EE = "!", kD = ":", OX = [], CD = (e, t, n, r, i) => ({
  modifiers: e,
  hasImportantModifier: t,
  baseClassName: n,
  maybePostfixModifierPosition: r,
  isExternal: i
}), DX = (e) => {
  const {
    prefix: t,
    experimentalParseClassName: n
  } = e;
  let r = (i) => {
    const o = [];
    let s = 0, a = 0, c = 0, u;
    const f = i.length;
    for (let x = 0; x < f; x++) {
      const w = i[x];
      if (s === 0 && a === 0) {
        if (w === kD) {
          o.push(i.slice(c, x)), c = x + 1;
          continue;
        }
        if (w === "/") {
          u = x;
          continue;
        }
      }
      w === "[" ? s++ : w === "]" ? s-- : w === "(" ? a++ : w === ")" && a--;
    }
    const h = o.length === 0 ? i : i.slice(c);
    let m = h, g = !1;
    h.endsWith(EE) ? (m = h.slice(0, -1), g = !0) : (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      h.startsWith(EE) && (m = h.slice(1), g = !0)
    );
    const b = u && u > c ? u - c : void 0;
    return CD(o, g, m, b);
  };
  if (t) {
    const i = t + kD, o = r;
    r = (s) => s.startsWith(i) ? o(s.slice(i.length)) : CD(OX, !1, s, void 0, !0);
  }
  if (n) {
    const i = r;
    r = (o) => n({
      className: o,
      parseClassName: i
    });
  }
  return r;
}, PX = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.orderSensitiveModifiers.forEach((n, r) => {
    t.set(n, 1e6 + r);
  }), (n) => {
    const r = [];
    let i = [];
    for (let o = 0; o < n.length; o++) {
      const s = n[o], a = s[0] === "[", c = t.has(s);
      a || c ? (i.length > 0 && (i.sort(), r.push(...i), i = []), r.push(s)) : i.push(s);
    }
    return i.length > 0 && (i.sort(), r.push(...i)), r;
  };
}, jX = (e) => ({
  cache: RX(e.cacheSize),
  parseClassName: DX(e),
  sortModifiers: PX(e),
  ...SX(e)
}), IX = /\s+/, zX = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: r,
    getConflictingClassGroupIds: i,
    sortModifiers: o
  } = t, s = [], a = e.trim().split(IX);
  let c = "";
  for (let u = a.length - 1; u >= 0; u -= 1) {
    const f = a[u], {
      isExternal: h,
      modifiers: m,
      hasImportantModifier: g,
      baseClassName: b,
      maybePostfixModifierPosition: x
    } = n(f);
    if (h) {
      c = f + (c.length > 0 ? " " + c : c);
      continue;
    }
    let w = !!x, S = r(w ? b.substring(0, x) : b);
    if (!S) {
      if (!w) {
        c = f + (c.length > 0 ? " " + c : c);
        continue;
      }
      if (S = r(b), !S) {
        c = f + (c.length > 0 ? " " + c : c);
        continue;
      }
      w = !1;
    }
    const _ = m.length === 0 ? "" : m.length === 1 ? m[0] : o(m).join(":"), M = g ? _ + EE : _, N = M + S;
    if (s.indexOf(N) > -1)
      continue;
    s.push(N);
    const P = i(S, w);
    for (let I = 0; I < P.length; ++I) {
      const O = P[I];
      s.push(M + O);
    }
    c = f + (c.length > 0 ? " " + c : c);
  }
  return c;
}, LX = (...e) => {
  let t = 0, n, r, i = "";
  for (; t < e.length; )
    (n = e[t++]) && (r = o4(n)) && (i && (i += " "), i += r);
  return i;
}, o4 = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let r = 0; r < e.length; r++)
    e[r] && (t = o4(e[r])) && (n && (n += " "), n += t);
  return n;
}, BX = (e, ...t) => {
  let n, r, i, o;
  const s = (c) => {
    const u = t.reduce((f, h) => h(f), e());
    return n = jX(u), r = n.cache.get, i = n.cache.set, o = a, a(c);
  }, a = (c) => {
    const u = r(c);
    if (u)
      return u;
    const f = zX(c, n);
    return i(c, f), f;
  };
  return o = s, (...c) => o(LX(...c));
}, $X = [], Nr = (e) => {
  const t = (n) => n[e] || $X;
  return t.isThemeGetter = !0, t;
}, s4 = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, a4 = /^\((?:(\w[\w-]*):)?(.+)\)$/i, UX = /^\d+\/\d+$/, FX = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, VX = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, HX = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, WX = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, qX = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, df = (e) => UX.test(e), $t = (e) => !!e && !Number.isNaN(Number(e)), Vl = (e) => !!e && Number.isInteger(Number(e)), ck = (e) => e.endsWith("%") && $t(e.slice(0, -1)), Da = (e) => FX.test(e), GX = () => !0, KX = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  VX.test(e) && !HX.test(e)
), l4 = () => !1, ZX = (e) => WX.test(e), YX = (e) => qX.test(e), XX = (e) => !it(e) && !ot(e), JX = (e) => Sh(e, d4, l4), it = (e) => s4.test(e), Su = (e) => Sh(e, f4, KX), uk = (e) => Sh(e, rJ, $t), ED = (e) => Sh(e, c4, l4), QX = (e) => Sh(e, u4, YX), wv = (e) => Sh(e, h4, ZX), ot = (e) => a4.test(e), Wp = (e) => kh(e, f4), eJ = (e) => kh(e, iJ), _D = (e) => kh(e, c4), tJ = (e) => kh(e, d4), nJ = (e) => kh(e, u4), Sv = (e) => kh(e, h4, !0), Sh = (e, t, n) => {
  const r = s4.exec(e);
  return r ? r[1] ? t(r[1]) : n(r[2]) : !1;
}, kh = (e, t, n = !1) => {
  const r = a4.exec(e);
  return r ? r[1] ? t(r[1]) : n : !1;
}, c4 = (e) => e === "position" || e === "percentage", u4 = (e) => e === "image" || e === "url", d4 = (e) => e === "length" || e === "size" || e === "bg-size", f4 = (e) => e === "length", rJ = (e) => e === "number", iJ = (e) => e === "family-name", h4 = (e) => e === "shadow", oJ = () => {
  const e = Nr("color"), t = Nr("font"), n = Nr("text"), r = Nr("font-weight"), i = Nr("tracking"), o = Nr("leading"), s = Nr("breakpoint"), a = Nr("container"), c = Nr("spacing"), u = Nr("radius"), f = Nr("shadow"), h = Nr("inset-shadow"), m = Nr("text-shadow"), g = Nr("drop-shadow"), b = Nr("blur"), x = Nr("perspective"), w = Nr("aspect"), S = Nr("ease"), _ = Nr("animate"), M = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], N = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], P = () => [...N(), ot, it], I = () => ["auto", "hidden", "clip", "visible", "scroll"], O = () => ["auto", "contain", "none"], L = () => [ot, it, c], U = () => [df, "full", "auto", ...L()], B = () => [Vl, "none", "subgrid", ot, it], G = () => ["auto", {
    span: ["full", Vl, ot, it]
  }, Vl, ot, it], Y = () => [Vl, "auto", ot, it], he = () => ["auto", "min", "max", "fr", ot, it], ie = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], ne = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], H = () => ["auto", ...L()], Q = () => [df, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...L()], X = () => [e, ot, it], Se = () => [...N(), _D, ED, {
    position: [ot, it]
  }], W = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], Z = () => ["auto", "cover", "contain", tJ, JX, {
    size: [ot, it]
  }], pe = () => [ck, Wp, Su], F = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    u,
    ot,
    it
  ], ee = () => ["", $t, Wp, Su], ge = () => ["solid", "dashed", "dotted", "double"], re = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], J = () => [$t, ck, _D, ED], xe = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    b,
    ot,
    it
  ], be = () => ["none", $t, ot, it], Ae = () => ["none", $t, ot, it], tt = () => [$t, ot, it], Ge = () => [df, "full", ...L()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [Da],
      breakpoint: [Da],
      color: [GX],
      container: [Da],
      "drop-shadow": [Da],
      ease: ["in", "out", "in-out"],
      font: [XX],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [Da],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [Da],
      shadow: [Da],
      spacing: ["px", $t],
      text: [Da],
      "text-shadow": [Da],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", df, it, ot, w]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [$t, it, ot, a]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": M()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": M()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: P()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: I()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": I()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": I()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: O()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": O()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": O()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: U()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": U()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": U()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: U()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: U()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: U()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: U()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: U()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: U()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [Vl, "auto", ot, it]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [df, "full", "auto", a, ...L()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [$t, df, "auto", "initial", "none", it]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", $t, ot, it]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", $t, ot, it]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [Vl, "first", "last", "none", ot, it]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": B()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: G()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": Y()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": Y()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": B()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: G()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": Y()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": Y()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": he()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": he()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: L()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": L()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": L()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...ie(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...ne(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...ne()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ie()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...ne(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...ne(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": ie()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...ne(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...ne()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: L()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: L()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: L()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: L()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: L()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: L()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: L()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: L()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: L()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: H()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: H()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: H()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: H()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: H()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: H()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: H()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: H()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: H()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": L()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": L()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: Q()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [a, "screen", ...Q()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          a,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...Q()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          a,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [s]
          },
          ...Q()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...Q()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...Q()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...Q()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", n, Wp, Su]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [r, ot, uk]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", ck, it]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [eJ, it, t]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [i, ot, it]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [$t, "none", ot, uk]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          o,
          ...L()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ot, it]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", ot, it]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: X()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: X()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...ge(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [$t, "from-font", "auto", ot, Su]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: X()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [$t, "auto", ot, it]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: L()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ot, it]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ot, it]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: Se()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: W()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: Z()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, Vl, ot, it],
          radial: ["", ot, it],
          conic: [Vl, ot, it]
        }, nJ, QX]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: X()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: pe()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: pe()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: pe()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: X()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: X()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: X()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: F()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": F()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": F()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": F()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": F()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": F()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": F()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": F()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": F()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": F()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": F()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": F()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": F()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": F()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": F()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: ee()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": ee()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": ee()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": ee()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": ee()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": ee()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": ee()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": ee()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": ee()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": ee()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": ee()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...ge(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...ge(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: X()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": X()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": X()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": X()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": X()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": X()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": X()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": X()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": X()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: X()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...ge(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [$t, ot, it]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", $t, Wp, Su]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: X()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          f,
          Sv,
          wv
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: X()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", h, Sv, wv]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": X()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: ee()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: X()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [$t, Su]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": X()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": ee()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": X()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", m, Sv, wv]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": X()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [$t, ot, it]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...re(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": re()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [$t]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": J()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": J()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": X()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": X()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": J()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": J()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": X()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": X()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": J()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": J()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": X()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": X()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": J()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": J()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": X()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": X()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": J()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": J()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": X()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": X()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": J()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": J()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": X()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": X()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": J()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": J()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": X()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": X()
      }],
      "mask-image-radial": [{
        "mask-radial": [ot, it]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": J()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": J()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": X()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": X()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": N()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [$t]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": J()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": J()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": X()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": X()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: Se()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: W()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: Z()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", ot, it]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          ot,
          it
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: xe()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [$t, ot, it]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [$t, ot, it]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          g,
          Sv,
          wv
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": X()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", $t, ot, it]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [$t, ot, it]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", $t, ot, it]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [$t, ot, it]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", $t, ot, it]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          ot,
          it
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": xe()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [$t, ot, it]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [$t, ot, it]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", $t, ot, it]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [$t, ot, it]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", $t, ot, it]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [$t, ot, it]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [$t, ot, it]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", $t, ot, it]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": L()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": L()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": L()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", ot, it]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [$t, "initial", ot, it]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", S, ot, it]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [$t, ot, it]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", _, ot, it]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [x, ot, it]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": P()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: be()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": be()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": be()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": be()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: Ae()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": Ae()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": Ae()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": Ae()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: tt()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": tt()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": tt()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [ot, it, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: P()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: Ge()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": Ge()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": Ge()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": Ge()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: X()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: X()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ot, it]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": L()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": L()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": L()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": L()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": L()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": L()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": L()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": L()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": L()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": L()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": L()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": L()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": L()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": L()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": L()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": L()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": L()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": L()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ot, it]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...X()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [$t, Wp, Su, uk]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...X()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, sJ = /* @__PURE__ */ BX(oJ);
function at(...e) {
  return sJ(pc(e));
}
function qT({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsxs(
    gX,
    {
      "data-slot": "scroll-area",
      className: at("relative", e),
      ...n,
      children: [
        /* @__PURE__ */ v.jsx(
          yX,
          {
            "data-slot": "scroll-area-viewport",
            className: "focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1",
            children: t
          }
        ),
        /* @__PURE__ */ v.jsx(aJ, {}),
        /* @__PURE__ */ v.jsx(vX, {})
      ]
    }
  );
}
function aJ({
  className: e,
  orientation: t = "vertical",
  ...n
}) {
  return /* @__PURE__ */ v.jsx(
    q3,
    {
      "data-slot": "scroll-area-scrollbar",
      orientation: t,
      className: at(
        "flex touch-none p-px transition-colors select-none",
        t === "vertical" && "h-full w-2.5 border-l border-l-transparent",
        t === "horizontal" && "h-2.5 flex-col border-t border-t-transparent",
        e
      ),
      ...n,
      children: /* @__PURE__ */ v.jsx(
        Y3,
        {
          "data-slot": "scroll-area-thumb",
          className: "bg-border relative flex-1 rounded-full"
        }
      )
    }
  );
}
const GT = k.createContext({});
function Rg(e) {
  const t = k.useRef(null);
  return t.current === null && (t.current = e()), t.current;
}
const p4 = typeof window < "u", KT = p4 ? k.useLayoutEffect : k.useEffect, Ux = /* @__PURE__ */ k.createContext(null);
function ZT(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function Og(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
const Ys = (e, t, n) => n > t ? t : n < e ? e : n;
let YT = () => {
};
const Za = {}, m4 = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
function g4(e) {
  return typeof e == "object" && e !== null;
}
const y4 = (e) => /^0[^.\s]+$/u.test(e);
// @__NO_SIDE_EFFECTS__
function XT(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const $o = /* @__NO_SIDE_EFFECTS__ */ (e) => e, lJ = (e, t) => (n) => t(e(n)), Dg = (...e) => e.reduce(lJ), rh = /* @__NO_SIDE_EFFECTS__ */ (e, t, n) => {
  const r = t - e;
  return r === 0 ? 1 : (n - e) / r;
};
class JT {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return ZT(this.subscriptions, t), () => Og(this.subscriptions, t);
  }
  notify(t, n, r) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](t, n, r);
      else
        for (let o = 0; o < i; o++) {
          const s = this.subscriptions[o];
          s && s(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const qs = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, Lo = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3;
function v4(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const cJ = (e, t, n) => {
  const r = t - e;
  return ((n - e) % r + r) % r + e;
}, b4 = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, uJ = 1e-7, dJ = 12;
function fJ(e, t, n, r, i) {
  let o, s, a = 0;
  do
    s = t + (n - t) / 2, o = b4(s, r, i) - e, o > 0 ? n = s : t = s;
  while (Math.abs(o) > uJ && ++a < dJ);
  return s;
}
function Pg(e, t, n, r) {
  if (e === t && n === r)
    return $o;
  const i = (o) => fJ(o, 0, 1, e, n);
  return (o) => o === 0 || o === 1 ? o : b4(i(o), t, r);
}
const x4 = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, w4 = (e) => (t) => 1 - e(1 - t), S4 = /* @__PURE__ */ Pg(0.33, 1.53, 0.69, 0.99), QT = /* @__PURE__ */ w4(S4), k4 = /* @__PURE__ */ x4(QT), C4 = (e) => (e *= 2) < 1 ? 0.5 * QT(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), eA = (e) => 1 - Math.sin(Math.acos(e)), E4 = w4(eA), _4 = x4(eA), hJ = /* @__PURE__ */ Pg(0.42, 0, 1, 1), pJ = /* @__PURE__ */ Pg(0, 0, 0.58, 1), T4 = /* @__PURE__ */ Pg(0.42, 0, 0.58, 1), A4 = (e) => Array.isArray(e) && typeof e[0] != "number";
function M4(e, t) {
  return A4(e) ? e[cJ(0, e.length, t)] : e;
}
const N4 = (e) => Array.isArray(e) && typeof e[0] == "number", mJ = {
  linear: $o,
  easeIn: hJ,
  easeInOut: T4,
  easeOut: pJ,
  circIn: eA,
  circInOut: _4,
  circOut: E4,
  backIn: QT,
  backInOut: k4,
  backOut: S4,
  anticipate: C4
}, gJ = (e) => typeof e == "string", TD = (e) => {
  if (N4(e)) {
    YT(e.length === 4);
    const [t, n, r, i] = e;
    return Pg(t, n, r, i);
  } else if (gJ(e))
    return mJ[e];
  return e;
}, kv = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function yJ(e, t) {
  let n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), i = !1, o = !1;
  const s = /* @__PURE__ */ new WeakSet();
  let a = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function c(f) {
    s.has(f) && (u.schedule(f), e()), f(a);
  }
  const u = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (f, h = !1, m = !1) => {
      const b = m && i ? n : r;
      return h && s.add(f), b.has(f) || b.add(f), f;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (f) => {
      r.delete(f), s.delete(f);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (f) => {
      if (a = f, i) {
        o = !0;
        return;
      }
      i = !0, [n, r] = [r, n], n.forEach(c), n.clear(), i = !1, o && (o = !1, u.process(f));
    }
  };
  return u;
}
const vJ = 40;
function R4(e, t) {
  let n = !1, r = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, o = () => n = !0, s = kv.reduce((M, N) => (M[N] = yJ(o), M), {}), { setup: a, read: c, resolveKeyframes: u, preUpdate: f, update: h, preRender: m, render: g, postRender: b } = s, x = () => {
    const M = Za.useManualTiming ? i.timestamp : performance.now();
    n = !1, Za.useManualTiming || (i.delta = r ? 1e3 / 60 : Math.max(Math.min(M - i.timestamp, vJ), 1)), i.timestamp = M, i.isProcessing = !0, a.process(i), c.process(i), u.process(i), f.process(i), h.process(i), m.process(i), g.process(i), b.process(i), i.isProcessing = !1, n && t && (r = !1, e(x));
  }, w = () => {
    n = !0, r = !0, i.isProcessing || e(x);
  };
  return { schedule: kv.reduce((M, N) => {
    const P = s[N];
    return M[N] = (I, O = !1, L = !1) => (n || w(), P.schedule(I, O, L)), M;
  }, {}), cancel: (M) => {
    for (let N = 0; N < kv.length; N++)
      s[kv[N]].cancel(M);
  }, state: i, steps: s };
}
const { schedule: _n, cancel: Ya, state: Qr, steps: dk } = /* @__PURE__ */ R4(typeof requestAnimationFrame < "u" ? requestAnimationFrame : $o, !0);
let p0;
function bJ() {
  p0 = void 0;
}
const Mi = {
  now: () => (p0 === void 0 && Mi.set(Qr.isProcessing || Za.useManualTiming ? Qr.timestamp : performance.now()), p0),
  set: (e) => {
    p0 = e, queueMicrotask(bJ);
  }
}, O4 = (e) => (t) => typeof t == "string" && t.startsWith(e), D4 = /* @__PURE__ */ O4("--"), xJ = /* @__PURE__ */ O4("var(--"), tA = (e) => xJ(e) ? wJ.test(e.split("/*")[0].trim()) : !1, wJ = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
function AD(e) {
  return typeof e != "string" ? !1 : e.split("/*")[0].includes("var(--");
}
const Ch = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, Wm = {
  ...Ch,
  transform: (e) => Ys(0, 1, e)
}, Cv = {
  ...Ch,
  default: 1
}, Sm = (e) => Math.round(e * 1e5) / 1e5, nA = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function SJ(e) {
  return e == null;
}
const kJ = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, rA = (e, t) => (n) => !!(typeof n == "string" && kJ.test(n) && n.startsWith(e) || t && !SJ(n) && Object.prototype.hasOwnProperty.call(n, t)), P4 = (e, t, n) => (r) => {
  if (typeof r != "string")
    return r;
  const [i, o, s, a] = r.match(nA);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(o),
    [n]: parseFloat(s),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, CJ = (e) => Ys(0, 255, e), fk = {
  ...Ch,
  transform: (e) => Math.round(CJ(e))
}, Du = {
  test: /* @__PURE__ */ rA("rgb", "red"),
  parse: /* @__PURE__ */ P4("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + fk.transform(e) + ", " + fk.transform(t) + ", " + fk.transform(n) + ", " + Sm(Wm.transform(r)) + ")"
};
function EJ(e) {
  let t = "", n = "", r = "", i = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const _E = {
  test: /* @__PURE__ */ rA("#"),
  parse: EJ,
  transform: Du.transform
}, jg = /* @__NO_SIDE_EFFECTS__ */ (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), Kl = /* @__PURE__ */ jg("deg"), Gs = /* @__PURE__ */ jg("%"), st = /* @__PURE__ */ jg("px"), _J = /* @__PURE__ */ jg("vh"), TJ = /* @__PURE__ */ jg("vw"), MD = {
  ...Gs,
  parse: (e) => Gs.parse(e) / 100,
  transform: (e) => Gs.transform(e * 100)
}, Of = {
  test: /* @__PURE__ */ rA("hsl", "hue"),
  parse: /* @__PURE__ */ P4("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + Gs.transform(Sm(t)) + ", " + Gs.transform(Sm(n)) + ", " + Sm(Wm.transform(r)) + ")"
}, Sr = {
  test: (e) => Du.test(e) || _E.test(e) || Of.test(e),
  parse: (e) => Du.test(e) ? Du.parse(e) : Of.test(e) ? Of.parse(e) : _E.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? Du.transform(e) : Of.transform(e),
  getAnimatableNone: (e) => {
    const t = Sr.parse(e);
    return t.alpha = 0, Sr.transform(t);
  }
}, AJ = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function MJ(e) {
  return isNaN(e) && typeof e == "string" && (e.match(nA)?.length || 0) + (e.match(AJ)?.length || 0) > 0;
}
const j4 = "number", I4 = "color", NJ = "var", RJ = "var(", ND = "${}", OJ = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function qm(e) {
  const t = e.toString(), n = [], r = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let o = 0;
  const a = t.replace(OJ, (c) => (Sr.test(c) ? (r.color.push(o), i.push(I4), n.push(Sr.parse(c))) : c.startsWith(RJ) ? (r.var.push(o), i.push(NJ), n.push(c)) : (r.number.push(o), i.push(j4), n.push(parseFloat(c))), ++o, ND)).split(ND);
  return { values: n, split: a, indexes: r, types: i };
}
function z4(e) {
  return qm(e).values;
}
function L4(e) {
  const { split: t, types: n } = qm(e), r = t.length;
  return (i) => {
    let o = "";
    for (let s = 0; s < r; s++)
      if (o += t[s], i[s] !== void 0) {
        const a = n[s];
        a === j4 ? o += Sm(i[s]) : a === I4 ? o += Sr.transform(i[s]) : o += i[s];
      }
    return o;
  };
}
const DJ = (e) => typeof e == "number" ? 0 : Sr.test(e) ? Sr.getAnimatableNone(e) : e;
function PJ(e) {
  const t = z4(e);
  return L4(e)(t.map(DJ));
}
const Cc = {
  test: MJ,
  parse: z4,
  createTransformer: L4,
  getAnimatableNone: PJ
};
function hk(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function jJ({ hue: e, saturation: t, lightness: n, alpha: r }) {
  e /= 360, t /= 100, n /= 100;
  let i = 0, o = 0, s = 0;
  if (!t)
    i = o = s = n;
  else {
    const a = n < 0.5 ? n * (1 + t) : n + t - n * t, c = 2 * n - a;
    i = hk(c, a, e + 1 / 3), o = hk(c, a, e), s = hk(c, a, e - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(o * 255),
    blue: Math.round(s * 255),
    alpha: r
  };
}
function Y0(e, t) {
  return (n) => n > 0 ? t : e;
}
const Gn = (e, t, n) => e + (t - e) * n, pk = (e, t, n) => {
  const r = e * e, i = n * (t * t - r) + r;
  return i < 0 ? 0 : Math.sqrt(i);
}, IJ = [_E, Du, Of], zJ = (e) => IJ.find((t) => t.test(e));
function RD(e) {
  const t = zJ(e);
  if (!t)
    return !1;
  let n = t.parse(e);
  return t === Of && (n = jJ(n)), n;
}
const OD = (e, t) => {
  const n = RD(e), r = RD(t);
  if (!n || !r)
    return Y0(e, t);
  const i = { ...n };
  return (o) => (i.red = pk(n.red, r.red, o), i.green = pk(n.green, r.green, o), i.blue = pk(n.blue, r.blue, o), i.alpha = Gn(n.alpha, r.alpha, o), Du.transform(i));
}, TE = /* @__PURE__ */ new Set(["none", "hidden"]);
function LJ(e, t) {
  return TE.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function BJ(e, t) {
  return (n) => Gn(e, t, n);
}
function iA(e) {
  return typeof e == "number" ? BJ : typeof e == "string" ? tA(e) ? Y0 : Sr.test(e) ? OD : FJ : Array.isArray(e) ? B4 : typeof e == "object" ? Sr.test(e) ? OD : $J : Y0;
}
function B4(e, t) {
  const n = [...e], r = n.length, i = e.map((o, s) => iA(o)(o, t[s]));
  return (o) => {
    for (let s = 0; s < r; s++)
      n[s] = i[s](o);
    return n;
  };
}
function $J(e, t) {
  const n = { ...e, ...t }, r = {};
  for (const i in n)
    e[i] !== void 0 && t[i] !== void 0 && (r[i] = iA(e[i])(e[i], t[i]));
  return (i) => {
    for (const o in r)
      n[o] = r[o](i);
    return n;
  };
}
function UJ(e, t) {
  const n = [], r = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < t.values.length; i++) {
    const o = t.types[i], s = e.indexes[o][r[o]], a = e.values[s] ?? 0;
    n[i] = a, r[o]++;
  }
  return n;
}
const FJ = (e, t) => {
  const n = Cc.createTransformer(t), r = qm(e), i = qm(t);
  return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? TE.has(e) && !i.values.length || TE.has(t) && !r.values.length ? LJ(e, t) : Dg(B4(UJ(r, i), i.values), n) : Y0(e, t);
};
function $4(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? Gn(e, t, n) : iA(e)(e, t);
}
const VJ = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: (n = !0) => _n.update(t, n),
    stop: () => Ya(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Qr.isProcessing ? Qr.timestamp : Mi.now()
  };
}, U4 = (e, t, n = 10) => {
  let r = "";
  const i = Math.max(Math.round(t / n), 2);
  for (let o = 0; o < i; o++)
    r += Math.round(e(o / (i - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
}, X0 = 2e4;
function oA(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < X0; )
    t += n, r = e.next(t);
  return t >= X0 ? 1 / 0 : t;
}
function F4(e, t = 100, n) {
  const r = n({ ...e, keyframes: [0, t] }), i = Math.min(oA(r), X0);
  return {
    type: "keyframes",
    ease: (o) => r.next(i * o).value / t,
    duration: /* @__PURE__ */ Lo(i)
  };
}
const HJ = 5;
function V4(e, t, n) {
  const r = Math.max(t - HJ, 0);
  return v4(n - e(r), t - r);
}
const tr = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, mk = 1e-3;
function WJ({ duration: e = tr.duration, bounce: t = tr.bounce, velocity: n = tr.velocity, mass: r = tr.mass }) {
  let i, o, s = 1 - t;
  s = Ys(tr.minDamping, tr.maxDamping, s), e = Ys(tr.minDuration, tr.maxDuration, /* @__PURE__ */ Lo(e)), s < 1 ? (i = (u) => {
    const f = u * s, h = f * e, m = f - n, g = AE(u, s), b = Math.exp(-h);
    return mk - m / g * b;
  }, o = (u) => {
    const h = u * s * e, m = h * n + n, g = Math.pow(s, 2) * Math.pow(u, 2) * e, b = Math.exp(-h), x = AE(Math.pow(u, 2), s);
    return (-i(u) + mk > 0 ? -1 : 1) * ((m - g) * b) / x;
  }) : (i = (u) => {
    const f = Math.exp(-u * e), h = (u - n) * e + 1;
    return -mk + f * h;
  }, o = (u) => {
    const f = Math.exp(-u * e), h = (n - u) * (e * e);
    return f * h;
  });
  const a = 5 / e, c = GJ(i, o, a);
  if (e = /* @__PURE__ */ qs(e), isNaN(c))
    return {
      stiffness: tr.stiffness,
      damping: tr.damping,
      duration: e
    };
  {
    const u = Math.pow(c, 2) * r;
    return {
      stiffness: u,
      damping: s * 2 * Math.sqrt(r * u),
      duration: e
    };
  }
}
const qJ = 12;
function GJ(e, t, n) {
  let r = n;
  for (let i = 1; i < qJ; i++)
    r = r - e(r) / t(r);
  return r;
}
function AE(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const KJ = ["duration", "bounce"], ZJ = ["stiffness", "damping", "mass"];
function DD(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function YJ(e) {
  let t = {
    velocity: tr.velocity,
    stiffness: tr.stiffness,
    damping: tr.damping,
    mass: tr.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!DD(e, ZJ) && DD(e, KJ))
    if (e.visualDuration) {
      const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, o = 2 * Ys(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i);
      t = {
        ...t,
        mass: tr.mass,
        stiffness: i,
        damping: o
      };
    } else {
      const n = WJ(e);
      t = {
        ...t,
        ...n,
        mass: tr.mass
      }, t.isResolvedFromDuration = !0;
    }
  return t;
}
function Gm(e = tr.visualDuration, t = tr.bounce) {
  const n = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: t
  } : e;
  let { restSpeed: r, restDelta: i } = n;
  const o = n.keyframes[0], s = n.keyframes[n.keyframes.length - 1], a = { done: !1, value: o }, { stiffness: c, damping: u, mass: f, duration: h, velocity: m, isResolvedFromDuration: g } = YJ({
    ...n,
    velocity: -/* @__PURE__ */ Lo(n.velocity || 0)
  }), b = m || 0, x = u / (2 * Math.sqrt(c * f)), w = s - o, S = /* @__PURE__ */ Lo(Math.sqrt(c / f)), _ = Math.abs(w) < 5;
  r || (r = _ ? tr.restSpeed.granular : tr.restSpeed.default), i || (i = _ ? tr.restDelta.granular : tr.restDelta.default);
  let M;
  if (x < 1) {
    const P = AE(S, x);
    M = (I) => {
      const O = Math.exp(-x * S * I);
      return s - O * ((b + x * S * w) / P * Math.sin(P * I) + w * Math.cos(P * I));
    };
  } else if (x === 1)
    M = (P) => s - Math.exp(-S * P) * (w + (b + S * w) * P);
  else {
    const P = S * Math.sqrt(x * x - 1);
    M = (I) => {
      const O = Math.exp(-x * S * I), L = Math.min(P * I, 300);
      return s - O * ((b + x * S * w) * Math.sinh(L) + P * w * Math.cosh(L)) / P;
    };
  }
  const N = {
    calculatedDuration: g && h || null,
    next: (P) => {
      const I = M(P);
      if (g)
        a.done = P >= h;
      else {
        let O = P === 0 ? b : 0;
        x < 1 && (O = P === 0 ? /* @__PURE__ */ qs(b) : V4(M, P, I));
        const L = Math.abs(O) <= r, U = Math.abs(s - I) <= i;
        a.done = L && U;
      }
      return a.value = a.done ? s : I, a;
    },
    toString: () => {
      const P = Math.min(oA(N), X0), I = U4((O) => N.next(P * O).value, P, 30);
      return P + "ms " + I;
    },
    toTransition: () => {
    }
  };
  return N;
}
Gm.applyToOptions = (e) => {
  const t = F4(e, 100, Gm);
  return e.ease = t.ease, e.duration = /* @__PURE__ */ qs(t.duration), e.type = "keyframes", e;
};
function ME({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: s, min: a, max: c, restDelta: u = 0.5, restSpeed: f }) {
  const h = e[0], m = {
    done: !1,
    value: h
  }, g = (L) => a !== void 0 && L < a || c !== void 0 && L > c, b = (L) => a === void 0 ? c : c === void 0 || Math.abs(a - L) < Math.abs(c - L) ? a : c;
  let x = n * t;
  const w = h + x, S = s === void 0 ? w : s(w);
  S !== w && (x = S - h);
  const _ = (L) => -x * Math.exp(-L / r), M = (L) => S + _(L), N = (L) => {
    const U = _(L), B = M(L);
    m.done = Math.abs(U) <= u, m.value = m.done ? S : B;
  };
  let P, I;
  const O = (L) => {
    g(m.value) && (P = L, I = Gm({
      keyframes: [m.value, b(m.value)],
      velocity: V4(M, L, m.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: o,
      restDelta: u,
      restSpeed: f
    }));
  };
  return O(0), {
    calculatedDuration: null,
    next: (L) => {
      let U = !1;
      return !I && P === void 0 && (U = !0, N(L), O(L)), P !== void 0 && L >= P ? I.next(L - P) : (!U && N(L), m);
    }
  };
}
function XJ(e, t, n) {
  const r = [], i = n || Za.mix || $4, o = e.length - 1;
  for (let s = 0; s < o; s++) {
    let a = i(e[s], e[s + 1]);
    if (t) {
      const c = Array.isArray(t) ? t[s] || $o : t;
      a = Dg(c, a);
    }
    r.push(a);
  }
  return r;
}
function H4(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const o = e.length;
  if (YT(o === t.length), o === 1)
    return () => t[0];
  if (o === 2 && t[0] === t[1])
    return () => t[1];
  const s = e[0] === e[1];
  e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const a = XJ(t, r, i), c = a.length, u = (f) => {
    if (s && f < e[0])
      return t[0];
    let h = 0;
    if (c > 1)
      for (; h < e.length - 2 && !(f < e[h + 1]); h++)
        ;
    const m = /* @__PURE__ */ rh(e[h], e[h + 1], f);
    return a[h](m);
  };
  return n ? (f) => u(Ys(e[0], e[o - 1], f)) : u;
}
function W4(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    const i = /* @__PURE__ */ rh(0, t, r);
    e.push(Gn(n, 1, i));
  }
}
function q4(e) {
  const t = [0];
  return W4(t, e.length - 1), t;
}
function JJ(e, t) {
  return e.map((n) => n * t);
}
function QJ(e, t) {
  return e.map(() => t || T4).splice(0, e.length - 1);
}
function km({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
  const i = A4(r) ? r.map(TD) : TD(r), o = {
    done: !1,
    value: t[0]
  }, s = JJ(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : q4(t),
    e
  ), a = H4(s, t, {
    ease: Array.isArray(i) ? i : QJ(t, i)
  });
  return {
    calculatedDuration: e,
    next: (c) => (o.value = a(c), o.done = c >= e, o)
  };
}
const eQ = (e) => e !== null;
function sA(e, { repeat: t, repeatType: n = "loop" }, r, i = 1) {
  const o = e.filter(eQ), a = i < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : o.length - 1;
  return !a || r === void 0 ? o[a] : r;
}
const tQ = {
  decay: ME,
  inertia: ME,
  tween: km,
  keyframes: km,
  spring: Gm
};
function G4(e) {
  typeof e.type == "string" && (e.type = tQ[e.type]);
}
class aA {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
}
const nQ = (e) => e / 100;
class lA extends aA {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      const { motionValue: n } = this.options;
      n && n.updatedAt !== Mi.now() && this.tick(Mi.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.());
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    G4(t);
    const { type: n = km, repeat: r = 0, repeatDelay: i = 0, repeatType: o, velocity: s = 0 } = t;
    let { keyframes: a } = t;
    const c = n || km;
    c !== km && typeof a[0] != "number" && (this.mixKeyframes = Dg(nQ, $4(a[0], a[1])), a = [0, 100]);
    const u = c({ ...t, keyframes: a });
    o === "mirror" && (this.mirroredGenerator = c({
      ...t,
      keyframes: [...a].reverse(),
      velocity: -s
    })), u.calculatedDuration === null && (u.calculatedDuration = oA(u));
    const { calculatedDuration: f } = u;
    this.calculatedDuration = f, this.resolvedDuration = f + i, this.totalDuration = this.resolvedDuration * (r + 1) - i, this.generator = u;
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(t, n = !1) {
    const { generator: r, totalDuration: i, mixKeyframes: o, mirroredGenerator: s, resolvedDuration: a, calculatedDuration: c } = this;
    if (this.startTime === null)
      return r.next(0);
    const { delay: u = 0, keyframes: f, repeat: h, repeatType: m, repeatDelay: g, type: b, onUpdate: x, finalKeyframe: w } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - i / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
    const S = this.currentTime - u * (this.playbackSpeed >= 0 ? 1 : -1), _ = this.playbackSpeed >= 0 ? S < 0 : S > i;
    this.currentTime = Math.max(S, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = i);
    let M = this.currentTime, N = r;
    if (h) {
      const L = Math.min(this.currentTime, i) / a;
      let U = Math.floor(L), B = L % 1;
      !B && L >= 1 && (B = 1), B === 1 && U--, U = Math.min(U, h + 1), U % 2 && (m === "reverse" ? (B = 1 - B, g && (B -= g / a)) : m === "mirror" && (N = s)), M = Ys(0, 1, B) * a;
    }
    const P = _ ? { done: !1, value: f[0] } : N.next(M);
    o && (P.value = o(P.value));
    let { done: I } = P;
    !_ && c !== null && (I = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0);
    const O = this.holdTime === null && (this.state === "finished" || this.state === "running" && I);
    return O && b !== ME && (P.value = sA(f, this.options, w, this.speed)), x && x(P.value), O && this.finish(), P;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return /* @__PURE__ */ Lo(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ Lo(t);
  }
  get time() {
    return /* @__PURE__ */ Lo(this.currentTime);
  }
  set time(t) {
    t = /* @__PURE__ */ qs(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), this.driver?.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(Mi.now());
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = /* @__PURE__ */ Lo(this.currentTime));
  }
  play() {
    if (this.isStopped)
      return;
    const { driver: t = VJ, startTime: n } = this.options;
    this.driver || (this.driver = t((i) => this.tick(i))), this.options.onPlay?.();
    const r = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = r) : this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime || (this.startTime = n ?? r), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(Mi.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.();
  }
  cancel() {
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), t.observe(this);
  }
}
function rQ(e) {
  for (let t = 1; t < e.length; t++)
    e[t] ?? (e[t] = e[t - 1]);
}
const Pu = (e) => e * 180 / Math.PI, NE = (e) => {
  const t = Pu(Math.atan2(e[1], e[0]));
  return RE(t);
}, iQ = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
  rotate: NE,
  rotateZ: NE,
  skewX: (e) => Pu(Math.atan(e[1])),
  skewY: (e) => Pu(Math.atan(e[2])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2
}, RE = (e) => (e = e % 360, e < 0 && (e += 360), e), PD = NE, jD = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]), ID = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]), oQ = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: jD,
  scaleY: ID,
  scale: (e) => (jD(e) + ID(e)) / 2,
  rotateX: (e) => RE(Pu(Math.atan2(e[6], e[5]))),
  rotateY: (e) => RE(Pu(Math.atan2(-e[2], e[0]))),
  rotateZ: PD,
  rotate: PD,
  skewX: (e) => Pu(Math.atan(e[4])),
  skewY: (e) => Pu(Math.atan(e[1])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2
};
function OE(e) {
  return e.includes("scale") ? 1 : 0;
}
function DE(e, t) {
  if (!e || e === "none")
    return OE(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let r, i;
  if (n)
    r = oQ, i = n;
  else {
    const a = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    r = iQ, i = a;
  }
  if (!i)
    return OE(t);
  const o = r[t], s = i[1].split(",").map(aQ);
  return typeof o == "function" ? o(s) : s[o];
}
const sQ = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return DE(n, t);
};
function aQ(e) {
  return parseFloat(e.trim());
}
const Eh = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], _h = new Set(Eh), zD = (e) => e === Ch || e === st, lQ = /* @__PURE__ */ new Set(["x", "y", "z"]), cQ = Eh.filter((e) => !lQ.has(e));
function uQ(e) {
  const t = [];
  return cQ.forEach((n) => {
    const r = e.getValue(n);
    r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const cc = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: (e, { transform: t }) => DE(t, "x"),
  y: (e, { transform: t }) => DE(t, "y")
};
cc.translateX = cc.x;
cc.translateY = cc.y;
const $u = /* @__PURE__ */ new Set();
let PE = !1, jE = !1, IE = !1;
function K4() {
  if (jE) {
    const e = Array.from($u).filter((r) => r.needsMeasurement), t = new Set(e.map((r) => r.element)), n = /* @__PURE__ */ new Map();
    t.forEach((r) => {
      const i = uQ(r);
      i.length && (n.set(r, i), r.render());
    }), e.forEach((r) => r.measureInitialState()), t.forEach((r) => {
      r.render();
      const i = n.get(r);
      i && i.forEach(([o, s]) => {
        r.getValue(o)?.set(s);
      });
    }), e.forEach((r) => r.measureEndState()), e.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  jE = !1, PE = !1, $u.forEach((e) => e.complete(IE)), $u.clear();
}
function Z4() {
  $u.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (jE = !0);
  });
}
function dQ() {
  IE = !0, Z4(), K4(), IE = !1;
}
class cA {
  constructor(t, n, r, i, o, s = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = o, this.isAsync = s;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? ($u.add(this), PE || (PE = !0, _n.read(Z4), _n.resolveKeyframes(K4))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this;
    if (t[0] === null) {
      const o = i?.get(), s = t[t.length - 1];
      if (o !== void 0)
        t[0] = o;
      else if (r && n) {
        const a = r.readValue(n, s);
        a != null && (t[0] = a);
      }
      t[0] === void 0 && (t[0] = s), i && o === void 0 && i.set(t[0]);
    }
    rQ(t);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(t = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), $u.delete(this);
  }
  cancel() {
    this.state === "scheduled" && ($u.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const fQ = (e) => e.startsWith("--");
function hQ(e, t, n) {
  fQ(t) ? e.style.setProperty(t, n) : e.style[t] = n;
}
const pQ = /* @__PURE__ */ XT(() => window.ScrollTimeline !== void 0), mQ = {};
function gQ(e, t) {
  const n = /* @__PURE__ */ XT(e);
  return () => mQ[t] ?? n();
}
const Y4 = /* @__PURE__ */ gQ(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), im = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, LD = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ im([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ im([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ im([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ im([0.33, 1.53, 0.69, 0.99])
};
function X4(e, t) {
  if (e)
    return typeof e == "function" ? Y4() ? U4(e, t) : "ease-out" : N4(e) ? im(e) : Array.isArray(e) ? e.map((n) => X4(n, t) || LD.easeOut) : LD[e];
}
function yQ(e, t, n, { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: s = "loop", ease: a = "easeOut", times: c } = {}, u = void 0) {
  const f = {
    [t]: n
  };
  c && (f.offset = c);
  const h = X4(a, i);
  Array.isArray(h) && (f.easing = h);
  const m = {
    delay: r,
    duration: i,
    easing: Array.isArray(h) ? "linear" : h,
    fill: "both",
    iterations: o + 1,
    direction: s === "reverse" ? "alternate" : "normal"
  };
  return u && (m.pseudoElement = u), e.animate(f, m);
}
function uA(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
function vQ({ type: e, ...t }) {
  return uA(e) && Y4() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
class bQ extends aA {
  constructor(t) {
    if (super(), this.finishedTime = null, this.isStopped = !1, this.manualStartTime = null, !t)
      return;
    const { element: n, name: r, keyframes: i, pseudoElement: o, allowFlatten: s = !1, finalKeyframe: a, onComplete: c } = t;
    this.isPseudoElement = !!o, this.allowFlatten = s, this.options = t, YT(typeof t.type != "string");
    const u = vQ(t);
    this.animation = yQ(n, r, i, u, o), u.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !o) {
        const f = sA(i, this.options, a, this.speed);
        this.updateMotionValue ? this.updateMotionValue(f) : hQ(n, r, f), this.animation.cancel();
      }
      c?.(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.manualStartTime = null, this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    const t = this.options?.element;
    !this.isPseudoElement && t?.isConnected && this.animation.commitStyles?.();
  }
  get duration() {
    const t = this.animation.effect?.getComputedTiming?.().duration || 0;
    return /* @__PURE__ */ Lo(Number(t));
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ Lo(t);
  }
  get time() {
    return /* @__PURE__ */ Lo(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    this.manualStartTime = null, this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ qs(t);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), this.animation.playbackRate = t;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return this.manualStartTime ?? Number(this.animation.startTime);
  }
  set startTime(t) {
    this.manualStartTime = this.animation.startTime = t;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: t, observe: n }) {
    return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, t && pQ() ? (this.animation.timeline = t, $o) : n(this);
  }
}
const J4 = {
  anticipate: C4,
  backInOut: k4,
  circInOut: _4
};
function xQ(e) {
  return e in J4;
}
function wQ(e) {
  typeof e.ease == "string" && xQ(e.ease) && (e.ease = J4[e.ease]);
}
const gk = 10;
class SQ extends bQ {
  constructor(t) {
    wQ(t), G4(t), super(t), t.startTime !== void 0 && (this.startTime = t.startTime), this.options = t;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read committed styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: r, onComplete: i, element: o, ...s } = this.options;
    if (!n)
      return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const a = new lA({
      ...s,
      autoplay: !1
    }), c = Math.max(gk, Mi.now() - this.startTime), u = Ys(0, gk, c - gk);
    n.setWithVelocity(a.sample(Math.max(0, c - u)).value, a.sample(c).value, u), a.stop();
  }
}
const BD = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(Cc.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function kQ(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function CQ(e, t, n, r) {
  const i = e[0];
  if (i === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const o = e[e.length - 1], s = BD(i, t), a = BD(o, t);
  return !s || !a ? !1 : kQ(e) || (n === "spring" || uA(n)) && r;
}
function zE(e) {
  e.duration = 0, e.type = "keyframes";
}
const EQ = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), _Q = /* @__PURE__ */ XT(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function TQ(e) {
  const { motionValue: t, name: n, repeatDelay: r, repeatType: i, damping: o, type: s } = e;
  if (!(t?.owner?.current instanceof HTMLElement))
    return !1;
  const { onUpdate: c, transformTemplate: u } = t.owner.getProps();
  return _Q() && n && EQ.has(n) && (n !== "transform" || !u) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !c && !r && i !== "mirror" && o !== 0 && s !== "inertia";
}
const AQ = 40;
class MQ extends aA {
  constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: o = 0, repeatType: s = "loop", keyframes: a, name: c, motionValue: u, element: f, ...h }) {
    super(), this.stop = () => {
      this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel();
    }, this.createdAt = Mi.now();
    const m = {
      autoplay: t,
      delay: n,
      type: r,
      repeat: i,
      repeatDelay: o,
      repeatType: s,
      name: c,
      motionValue: u,
      element: f,
      ...h
    }, g = f?.KeyframeResolver || cA;
    this.keyframeResolver = new g(a, (b, x, w) => this.onKeyframesResolved(b, x, m, !w), c, u, f), this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(t, n, r, i) {
    this.keyframeResolver = void 0;
    const { name: o, type: s, velocity: a, delay: c, isHandoff: u, onUpdate: f } = r;
    this.resolvedAt = Mi.now(), CQ(t, o, s, a) || ((Za.instantAnimations || !c) && f?.(sA(t, r, n)), t[0] = t[t.length - 1], zE(r), r.repeat = 0);
    const m = {
      startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > AQ ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...r,
      keyframes: t
    }, g = !u && TQ(m), b = m.motionValue?.owner?.current, x = g ? new SQ({
      ...m,
      element: b
    }) : new lA(m);
    x.finished.then(() => {
      this.notifyFinished();
    }).catch($o), this.pendingTimeline && (this.stopTimeline = x.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = x;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    return this._animation || (this.keyframeResolver?.resume(), dQ()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();
  }
}
class NQ {
  constructor(t) {
    this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((t) => t.finished));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(t) {
    return this.animations[0][t];
  }
  setAll(t, n) {
    for (let r = 0; r < this.animations.length; r++)
      this.animations[r][t] = n;
  }
  attachTimeline(t) {
    const n = this.animations.map((r) => r.attachTimeline(t));
    return () => {
      n.forEach((r, i) => {
        r && r(), this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(t) {
    this.setAll("time", t);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(t) {
    this.setAll("speed", t);
  }
  get state() {
    return this.getAll("state");
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    return $D(this.animations, "duration");
  }
  get iterationDuration() {
    return $D(this.animations, "iterationDuration");
  }
  runAll(t) {
    this.animations.forEach((n) => n[t]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function $D(e, t) {
  let n = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r][t];
    i !== null && i > n && (n = i);
  }
  return n;
}
class RQ extends NQ {
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
}
function Q4(e, t, n, r = 0, i = 1) {
  const o = Array.from(e).sort((u, f) => u.sortNodePosition(f)).indexOf(t), s = e.size, a = (s - 1) * r;
  return typeof n == "function" ? n(o, s) : i === 1 ? o * r : a - o * r;
}
const OQ = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function DQ(e) {
  const t = OQ.exec(e);
  if (!t)
    return [,];
  const [, n, r, i] = t;
  return [`--${n ?? r}`, i];
}
function eB(e, t, n = 1) {
  const [r, i] = DQ(e);
  if (!r)
    return;
  const o = window.getComputedStyle(t).getPropertyValue(r);
  if (o) {
    const s = o.trim();
    return m4(s) ? parseFloat(s) : s;
  }
  return tA(i) ? eB(i, t, n + 1) : i;
}
const PQ = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, jQ = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), IQ = {
  type: "keyframes",
  duration: 0.8
}, zQ = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, LQ = (e, { keyframes: t }) => t.length > 2 ? IQ : _h.has(e) ? e.startsWith("scale") ? jQ(t[1]) : PQ : zQ, BQ = (e) => e !== null;
function $Q(e, { repeat: t, repeatType: n = "loop" }, r) {
  const i = e.filter(BQ), o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
  return i[o];
}
function dA(e, t) {
  return e?.[t] ?? e?.default ?? e;
}
function UQ({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: c, elapsed: u, ...f }) {
  return !!Object.keys(f).length;
}
const fA = (e, t, n, r = {}, i, o) => (s) => {
  const a = dA(r, e) || {}, c = a.delay || r.delay || 0;
  let { elapsed: u = 0 } = r;
  u = u - /* @__PURE__ */ qs(c);
  const f = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...a,
    delay: -u,
    onUpdate: (m) => {
      t.set(m), a.onUpdate && a.onUpdate(m);
    },
    onComplete: () => {
      s(), a.onComplete && a.onComplete();
    },
    name: e,
    motionValue: t,
    element: o ? void 0 : i
  };
  UQ(a) || Object.assign(f, LQ(e, f)), f.duration && (f.duration = /* @__PURE__ */ qs(f.duration)), f.repeatDelay && (f.repeatDelay = /* @__PURE__ */ qs(f.repeatDelay)), f.from !== void 0 && (f.keyframes[0] = f.from);
  let h = !1;
  if ((f.type === !1 || f.duration === 0 && !f.repeatDelay) && (zE(f), f.delay === 0 && (h = !0)), (Za.instantAnimations || Za.skipAnimations || i?.shouldSkipAnimations) && (h = !0, zE(f), f.delay = 0), f.allowFlatten = !a.type && !a.ease, h && !o && t.get() !== void 0) {
    const m = $Q(f.keyframes, a);
    if (m !== void 0) {
      _n.update(() => {
        f.onUpdate(m), f.onComplete();
      });
      return;
    }
  }
  return a.isSync ? new lA(f) : new MQ(f);
};
function UD(e) {
  const t = [{}, {}];
  return e?.values.forEach((n, r) => {
    t[0][r] = n.get(), t[1][r] = n.getVelocity();
  }), t;
}
function hA(e, t, n, r) {
  if (typeof t == "function") {
    const [i, o] = UD(r);
    t = t(n !== void 0 ? n : e.custom, i, o);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [i, o] = UD(r);
    t = t(n !== void 0 ? n : e.custom, i, o);
  }
  return t;
}
function Hf(e, t, n) {
  const r = e.getProps();
  return hA(r, t, n !== void 0 ? n : r.custom, e);
}
const tB = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...Eh
]), FD = 30, FQ = (e) => !isNaN(parseFloat(e)), Cm = {
  current: void 0
};
class VQ {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(t, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r) => {
      const i = Mi.now();
      if (this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents))
        for (const o of this.dependents)
          o.dirty();
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = Mi.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = FQ(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new JT());
    const r = this.events[t].add(n);
    return t === "change" ? () => {
      r(), _n.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t) {
    this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t);
  }
  setWithVelocity(t, n, r) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return Cm.current && Cm.current.push(this), this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = Mi.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > FD)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, FD);
    return v4(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Ec(e, t) {
  return new VQ(e, t);
}
const LE = (e) => Array.isArray(e);
function HQ(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Ec(n));
}
function WQ(e) {
  return LE(e) ? e[e.length - 1] || 0 : e;
}
function qQ(e, t) {
  const n = Hf(e, t);
  let { transitionEnd: r = {}, transition: i = {}, ...o } = n || {};
  o = { ...o, ...r };
  for (const s in o) {
    const a = WQ(o[s]);
    HQ(e, s, a);
  }
}
const Fr = (e) => !!(e && e.getVelocity);
function GQ(e) {
  return !!(Fr(e) && e.add);
}
function BE(e, t) {
  const n = e.getValue("willChange");
  if (GQ(n))
    return n.add(t);
  if (!n && Za.WillChange) {
    const r = new Za.WillChange("auto");
    e.addValue("willChange", r), r.add(t);
  }
}
function pA(e) {
  return e.replace(/([A-Z])/g, (t) => `-${t.toLowerCase()}`);
}
const KQ = "framerAppearId", nB = "data-" + pA(KQ);
function rB(e) {
  return e.props[nB];
}
function ZQ({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r;
}
function mA(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  let { transition: o = e.getDefaultTransition(), transitionEnd: s, ...a } = t;
  const c = o?.reduceMotion;
  r && (o = r);
  const u = [], f = i && e.animationState && e.animationState.getState()[i];
  for (const h in a) {
    const m = e.getValue(h, e.latestValues[h] ?? null), g = a[h];
    if (g === void 0 || f && ZQ(f, h))
      continue;
    const b = {
      delay: n,
      ...dA(o || {}, h)
    }, x = m.get();
    if (x !== void 0 && !m.isAnimating && !Array.isArray(g) && g === x && !b.velocity)
      continue;
    let w = !1;
    if (window.MotionHandoffAnimation) {
      const M = rB(e);
      if (M) {
        const N = window.MotionHandoffAnimation(M, h, _n);
        N !== null && (b.startTime = N, w = !0);
      }
    }
    BE(e, h);
    const S = c ?? e.shouldReduceMotion;
    m.start(fA(h, m, g, S && tB.has(h) ? { type: !1 } : b, e, w));
    const _ = m.animation;
    _ && u.push(_);
  }
  return s && Promise.all(u).then(() => {
    _n.update(() => {
      s && qQ(e, s);
    });
  }), u;
}
function $E(e, t, n = {}) {
  const r = Hf(e, t, n.type === "exit" ? e.presenceContext?.custom : void 0);
  let { transition: i = e.getDefaultTransition() || {} } = r || {};
  n.transitionOverride && (i = n.transitionOverride);
  const o = r ? () => Promise.all(mA(e, r, n)) : () => Promise.resolve(), s = e.variantChildren && e.variantChildren.size ? (c = 0) => {
    const { delayChildren: u = 0, staggerChildren: f, staggerDirection: h } = i;
    return YQ(e, t, c, u, f, h, n);
  } : () => Promise.resolve(), { when: a } = i;
  if (a) {
    const [c, u] = a === "beforeChildren" ? [o, s] : [s, o];
    return c().then(() => u());
  } else
    return Promise.all([o(), s(n.delay)]);
}
function YQ(e, t, n = 0, r = 0, i = 0, o = 1, s) {
  const a = [];
  for (const c of e.variantChildren)
    c.notify("AnimationStart", t), a.push($E(c, t, {
      ...s,
      delay: n + (typeof r == "function" ? 0 : r) + Q4(e.variantChildren, c, r, i, o)
    }).then(() => c.notify("AnimationComplete", t)));
  return Promise.all(a);
}
function XQ(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const i = t.map((o) => $E(e, o, n));
    r = Promise.all(i);
  } else if (typeof t == "string")
    r = $E(e, t, n);
  else {
    const i = typeof t == "function" ? Hf(e, t, n.custom) : t;
    r = Promise.all(mA(e, i, n));
  }
  return r.then(() => {
    e.notify("AnimationComplete", t);
  });
}
const JQ = {
  test: (e) => e === "auto",
  parse: (e) => e
}, iB = (e) => (t) => t.test(e), oB = [Ch, st, Gs, Kl, TJ, _J, JQ], VD = (e) => oB.find(iB(e));
function QQ(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || y4(e) : !0;
}
const eee = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function tee(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [r] = n.match(nA) || [];
  if (!r)
    return e;
  const i = n.replace(r, "");
  let o = eee.has(t) ? 1 : 0;
  return r !== n && (o *= 100), t + "(" + o + i + ")";
}
const nee = /\b([a-z-]*)\(.*?\)/gu, UE = {
  ...Cc,
  getAnimatableNone: (e) => {
    const t = e.match(nee);
    return t ? t.map(tee).join(" ") : e;
  }
}, HD = {
  ...Ch,
  transform: Math.round
}, ree = {
  rotate: Kl,
  rotateX: Kl,
  rotateY: Kl,
  rotateZ: Kl,
  scale: Cv,
  scaleX: Cv,
  scaleY: Cv,
  scaleZ: Cv,
  skew: Kl,
  skewX: Kl,
  skewY: Kl,
  distance: st,
  translateX: st,
  translateY: st,
  translateZ: st,
  x: st,
  y: st,
  z: st,
  perspective: st,
  transformPerspective: st,
  opacity: Wm,
  originX: MD,
  originY: MD,
  originZ: st
}, gA = {
  // Border props
  borderWidth: st,
  borderTopWidth: st,
  borderRightWidth: st,
  borderBottomWidth: st,
  borderLeftWidth: st,
  borderRadius: st,
  borderTopLeftRadius: st,
  borderTopRightRadius: st,
  borderBottomRightRadius: st,
  borderBottomLeftRadius: st,
  // Positioning props
  width: st,
  maxWidth: st,
  height: st,
  maxHeight: st,
  top: st,
  right: st,
  bottom: st,
  left: st,
  inset: st,
  insetBlock: st,
  insetBlockStart: st,
  insetBlockEnd: st,
  insetInline: st,
  insetInlineStart: st,
  insetInlineEnd: st,
  // Spacing props
  padding: st,
  paddingTop: st,
  paddingRight: st,
  paddingBottom: st,
  paddingLeft: st,
  paddingBlock: st,
  paddingBlockStart: st,
  paddingBlockEnd: st,
  paddingInline: st,
  paddingInlineStart: st,
  paddingInlineEnd: st,
  margin: st,
  marginTop: st,
  marginRight: st,
  marginBottom: st,
  marginLeft: st,
  marginBlock: st,
  marginBlockStart: st,
  marginBlockEnd: st,
  marginInline: st,
  marginInlineStart: st,
  marginInlineEnd: st,
  // Typography
  fontSize: st,
  // Misc
  backgroundPositionX: st,
  backgroundPositionY: st,
  ...ree,
  zIndex: HD,
  // SVG
  fillOpacity: Wm,
  strokeOpacity: Wm,
  numOctaves: HD
}, iee = {
  ...gA,
  // Color props
  color: Sr,
  backgroundColor: Sr,
  outlineColor: Sr,
  fill: Sr,
  stroke: Sr,
  // Border props
  borderColor: Sr,
  borderTopColor: Sr,
  borderRightColor: Sr,
  borderBottomColor: Sr,
  borderLeftColor: Sr,
  filter: UE,
  WebkitFilter: UE
}, sB = (e) => iee[e];
function aB(e, t) {
  let n = sB(e);
  return n !== UE && (n = Cc), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const oee = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function see(e, t, n) {
  let r = 0, i;
  for (; r < e.length && !i; ) {
    const o = e[r];
    typeof o == "string" && !oee.has(o) && qm(o).values.length && (i = e[r]), r++;
  }
  if (i && n)
    for (const o of t)
      e[o] = aB(n, i);
}
class aee extends cA {
  constructor(t, n, r, i, o) {
    super(t, n, r, i, o, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let f = 0; f < t.length; f++) {
      let h = t[f];
      if (typeof h == "string" && (h = h.trim(), tA(h))) {
        const m = eB(h, n.current);
        m !== void 0 && (t[f] = m), f === t.length - 1 && (this.finalKeyframe = h);
      }
    }
    if (this.resolveNoneKeyframes(), !tB.has(r) || t.length !== 2)
      return;
    const [i, o] = t, s = VD(i), a = VD(o), c = AD(i), u = AD(o);
    if (c !== u && cc[r]) {
      this.needsMeasurement = !0;
      return;
    }
    if (s !== a)
      if (zD(s) && zD(a))
        for (let f = 0; f < t.length; f++) {
          const h = t[f];
          typeof h == "string" && (t[f] = parseFloat(h));
        }
      else cc[r] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, r = [];
    for (let i = 0; i < t.length; i++)
      (t[i] === null || QQ(t[i])) && r.push(i);
    r.length && see(t, r, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: r } = this;
    if (!t || !t.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = cc[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const i = n[n.length - 1];
    i !== void 0 && t.getValue(r, i).jump(i, !1);
  }
  measureEndState() {
    const { element: t, name: n, unresolvedKeyframes: r } = this;
    if (!t || !t.current)
      return;
    const i = t.getValue(n);
    i && i.jump(this.measuredOrigin, !1);
    const o = r.length - 1, s = r[o];
    r[o] = cc[n](t.measureViewportBox(), window.getComputedStyle(t.current)), s !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = s), this.removedTransforms?.length && this.removedTransforms.forEach(([a, c]) => {
      t.getValue(a).set(c);
    }), this.resolveNoneKeyframes();
  }
}
function lB(e, t, n) {
  if (e == null)
    return [];
  if (e instanceof EventTarget)
    return [e];
  if (typeof e == "string") {
    let r = document;
    t && (r = t.current);
    const i = n?.[e] ?? r.querySelectorAll(e);
    return i ? Array.from(i) : [];
  }
  return Array.from(e).filter((r) => r != null);
}
const cB = (e, t) => t && typeof e == "number" ? t.transform(e) : e;
function FE(e) {
  return g4(e) && "offsetHeight" in e;
}
const { schedule: yA } = /* @__PURE__ */ R4(queueMicrotask, !1), rs = {
  x: !1,
  y: !1
};
function uB() {
  return rs.x || rs.y;
}
function lee(e) {
  return e === "x" || e === "y" ? rs[e] ? null : (rs[e] = !0, () => {
    rs[e] = !1;
  }) : rs.x || rs.y ? null : (rs.x = rs.y = !0, () => {
    rs.x = rs.y = !1;
  });
}
function dB(e, t) {
  const n = lB(e), r = new AbortController(), i = {
    passive: !0,
    ...t,
    signal: r.signal
  };
  return [n, i, () => r.abort()];
}
function WD(e) {
  return !(e.pointerType === "touch" || uB());
}
function cee(e, t, n = {}) {
  const [r, i, o] = dB(e, n), s = (a) => {
    if (!WD(a))
      return;
    const { target: c } = a, u = t(c, a);
    if (typeof u != "function" || !c)
      return;
    const f = (h) => {
      WD(h) && (u(h), c.removeEventListener("pointerleave", f));
    };
    c.addEventListener("pointerleave", f, i);
  };
  return r.forEach((a) => {
    a.addEventListener("pointerenter", s, i);
  }), o;
}
const fB = (e, t) => t ? e === t ? !0 : fB(e, t.parentElement) : !1, vA = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, uee = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function dee(e) {
  return uee.has(e.tagName) || e.isContentEditable === !0;
}
const fee = /* @__PURE__ */ new Set(["INPUT", "SELECT", "TEXTAREA"]);
function hee(e) {
  return fee.has(e.tagName) || e.isContentEditable === !0;
}
const m0 = /* @__PURE__ */ new WeakSet();
function qD(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function yk(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const pee = (e, t) => {
  const n = e.currentTarget;
  if (!n)
    return;
  const r = qD(() => {
    if (m0.has(n))
      return;
    yk(n, "down");
    const i = qD(() => {
      yk(n, "up");
    }), o = () => yk(n, "cancel");
    n.addEventListener("keyup", i, t), n.addEventListener("blur", o, t);
  });
  n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t);
};
function GD(e) {
  return vA(e) && !uB();
}
function mee(e, t, n = {}) {
  const [r, i, o] = dB(e, n), s = (a) => {
    const c = a.currentTarget;
    if (!GD(a))
      return;
    m0.add(c);
    const u = t(c, a), f = (g, b) => {
      window.removeEventListener("pointerup", h), window.removeEventListener("pointercancel", m), m0.has(c) && m0.delete(c), GD(g) && typeof u == "function" && u(g, { success: b });
    }, h = (g) => {
      f(g, c === window || c === document || n.useGlobalTarget || fB(c, g.target));
    }, m = (g) => {
      f(g, !1);
    };
    window.addEventListener("pointerup", h, i), window.addEventListener("pointercancel", m, i);
  };
  return r.forEach((a) => {
    (n.useGlobalTarget ? window : a).addEventListener("pointerdown", s, i), FE(a) && (a.addEventListener("focus", (u) => pee(u, i)), !dee(a) && !a.hasAttribute("tabindex") && (a.tabIndex = 0));
  }), o;
}
function bA(e) {
  return g4(e) && "ownerSVGElement" in e;
}
function hB(e) {
  return bA(e) && e.tagName === "svg";
}
function gee(...e) {
  const t = !Array.isArray(e[0]), n = t ? 0 : -1, r = e[0 + n], i = e[1 + n], o = e[2 + n], s = e[3 + n], a = H4(i, o, s);
  return t ? a(r) : a;
}
const yee = [...oB, Sr, Cc], vee = (e) => yee.find(iB(e)), KD = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Df = () => ({
  x: KD(),
  y: KD()
}), ZD = () => ({ min: 0, max: 0 }), xr = () => ({
  x: ZD(),
  y: ZD()
}), VE = { current: null }, pB = { current: !1 }, bee = typeof window < "u";
function xee() {
  if (pB.current = !0, !!bee)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => VE.current = e.matches;
      e.addEventListener("change", t), t();
    } else
      VE.current = !1;
}
const Km = /* @__PURE__ */ new WeakMap();
function Fx(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function Zm(e) {
  return typeof e == "string" || Array.isArray(e);
}
const xA = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], wA = ["initial", ...xA];
function Vx(e) {
  return Fx(e.animate) || wA.some((t) => Zm(e[t]));
}
function mB(e) {
  return !!(Vx(e) || e.variants);
}
function wee(e, t, n) {
  for (const r in t) {
    const i = t[r], o = n[r];
    if (Fr(i))
      e.addValue(r, i);
    else if (Fr(o))
      e.addValue(r, Ec(i, { owner: e }));
    else if (o !== i)
      if (e.hasValue(r)) {
        const s = e.getValue(r);
        s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i);
      } else {
        const s = e.getStaticValue(r);
        e.addValue(r, Ec(s !== void 0 ? s : i, { owner: e }));
      }
  }
  for (const r in n)
    t[r] === void 0 && e.removeValue(r);
  return t;
}
const YD = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
let J0 = {};
function gB(e) {
  J0 = e;
}
function See() {
  return J0;
}
class yB {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, r) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: i, skipAnimations: o, blockInitialAnimation: s, visualState: a }, c = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.shouldSkipAnimations = !1, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = cA, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const g = Mi.now();
      this.renderScheduledAt < g && (this.renderScheduledAt = g, _n.render(this.render, !1, !0));
    };
    const { latestValues: u, renderState: f } = a;
    this.latestValues = u, this.baseTarget = { ...u }, this.initialValues = n.initial ? { ...u } : {}, this.renderState = f, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.skipAnimationsConfig = o, this.options = c, this.blockInitialAnimation = !!s, this.isControllingVariants = Vx(n), this.isVariantNode = mB(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: h, ...m } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const g in m) {
      const b = m[g];
      u[g] !== void 0 && Fr(b) && b.set(u[g]);
    }
  }
  mount(t) {
    this.current = t, Km.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), this.reducedMotionConfig === "never" ? this.shouldReduceMotion = !1 : this.reducedMotionConfig === "always" ? this.shouldReduceMotion = !0 : (pB.current || xee(), this.shouldReduceMotion = VE.current), this.shouldSkipAnimations = this.skipAnimationsConfig ?? !1, this.parent?.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), Ya(this.notifyUpdate), Ya(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features) {
      const n = this.features[t];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  addChild(t) {
    this.children.add(t), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(t);
  }
  removeChild(t) {
    this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t);
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const r = _h.has(t);
    r && this.onBindTransform && this.onBindTransform();
    const i = n.on("change", (s) => {
      this.latestValues[t] = s, this.props.onUpdate && _n.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let o;
    typeof window < "u" && window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      i(), o && o(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in J0) {
      const n = J0[t];
      if (!n)
        continue;
      const { isEnabled: r, Feature: i } = n;
      if (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)), this.features[t]) {
        const o = this.features[t];
        o.isMounted ? o.update() : (o.mount(), o.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : xr();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < YD.length; r++) {
      const i = YD[r];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const o = "on" + i, s = t[o];
      s && (this.propEventSubscriptions[i] = this.on(i, s));
    }
    this.prevMotionValues = wee(this, this.scrapeMotionValuesFromProps(t, this.prevProps || {}, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const r = this.values.get(t);
    n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let r = this.values.get(t);
    return r === void 0 && n !== void 0 && (r = Ec(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return r != null && (typeof r == "string" && (m4(r) || y4(r)) ? r = parseFloat(r) : !vee(r) && Cc.test(n) && (r = aB(t, n)), this.setBaseTarget(t, Fr(r) ? r.get() : r)), Fr(r) ? r.get() : r;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    const { initial: n } = this.props;
    let r;
    if (typeof n == "string" || typeof n == "object") {
      const o = hA(this.props, n, this.presenceContext?.custom);
      o && (r = o[t]);
    }
    if (n && r !== void 0)
      return r;
    const i = this.getBaseTargetFromProps(this.props, t);
    return i !== void 0 && !Fr(i) ? i : this.initialValues[t] !== void 0 && r === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new JT()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
  scheduleRenderMicrotask() {
    yA.render(this.render);
  }
}
class vB extends yB {
  constructor() {
    super(...arguments), this.KeyframeResolver = aee;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    const r = t.style;
    return r ? r[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    Fr(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
class jc {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
function bB({ top: e, left: t, right: n, bottom: r }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: r }
  };
}
function kee({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function Cee(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function vk(e) {
  return e === void 0 || e === 1;
}
function HE({ scale: e, scaleX: t, scaleY: n }) {
  return !vk(e) || !vk(t) || !vk(n);
}
function Au(e) {
  return HE(e) || xB(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function xB(e) {
  return XD(e.x) || XD(e.y);
}
function XD(e) {
  return e && e !== "0%";
}
function Q0(e, t, n) {
  const r = e - n, i = t * r;
  return n + i;
}
function JD(e, t, n, r, i) {
  return i !== void 0 && (e = Q0(e, i, r)), Q0(e, n, r) + t;
}
function WE(e, t = 0, n = 1, r, i) {
  e.min = JD(e.min, t, n, r, i), e.max = JD(e.max, t, n, r, i);
}
function wB(e, { x: t, y: n }) {
  WE(e.x, t.translate, t.scale, t.originPoint), WE(e.y, n.translate, n.scale, n.originPoint);
}
const QD = 0.999999999999, eP = 1.0000000000001;
function Eee(e, t, n, r = !1) {
  const i = n.length;
  if (!i)
    return;
  t.x = t.y = 1;
  let o, s;
  for (let a = 0; a < i; a++) {
    o = n[a], s = o.projectionDelta;
    const { visualElement: c } = o.options;
    c && c.props.style && c.props.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && jf(e, {
      x: -o.scroll.offset.x,
      y: -o.scroll.offset.y
    }), s && (t.x *= s.x.scale, t.y *= s.y.scale, wB(e, s)), r && Au(o.latestValues) && jf(e, o.latestValues));
  }
  t.x < eP && t.x > QD && (t.x = 1), t.y < eP && t.y > QD && (t.y = 1);
}
function Pf(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function tP(e, t, n, r, i = 0.5) {
  const o = Gn(e.min, e.max, i);
  WE(e, t, n, o, r);
}
function jf(e, t) {
  tP(e.x, t.x, t.scaleX, t.scale, t.originX), tP(e.y, t.y, t.scaleY, t.scale, t.originY);
}
function SB(e, t) {
  return bB(Cee(e.getBoundingClientRect(), t));
}
function _ee(e, t, n) {
  const r = SB(e, n), { scroll: i } = t;
  return i && (Pf(r.x, i.offset.x), Pf(r.y, i.offset.y)), r;
}
const Tee = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, Aee = Eh.length;
function Mee(e, t, n) {
  let r = "", i = !0;
  for (let o = 0; o < Aee; o++) {
    const s = Eh[o], a = e[s];
    if (a === void 0)
      continue;
    let c = !0;
    if (typeof a == "number")
      c = a === (s.startsWith("scale") ? 1 : 0);
    else {
      const u = parseFloat(a);
      c = s.startsWith("scale") ? u === 1 : u === 0;
    }
    if (!c || n) {
      const u = cB(a, gA[s]);
      if (!c) {
        i = !1;
        const f = Tee[s] || s;
        r += `${f}(${u}) `;
      }
      n && (t[s] = u);
    }
  }
  return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r;
}
function SA(e, t, n) {
  const { style: r, vars: i, transformOrigin: o } = e;
  let s = !1, a = !1;
  for (const c in t) {
    const u = t[c];
    if (_h.has(c)) {
      s = !0;
      continue;
    } else if (D4(c)) {
      i[c] = u;
      continue;
    } else {
      const f = cB(u, gA[c]);
      c.startsWith("origin") ? (a = !0, o[c] = f) : r[c] = f;
    }
  }
  if (t.transform || (s || n ? r.transform = Mee(t, e.transform, n) : r.transform && (r.transform = "none")), a) {
    const { originX: c = "50%", originY: u = "50%", originZ: f = 0 } = o;
    r.transformOrigin = `${c} ${u} ${f}`;
  }
}
function kB(e, { style: t, vars: n }, r, i) {
  const o = e.style;
  let s;
  for (s in t)
    o[s] = t[s];
  i?.applyProjectionStyles(o, r);
  for (s in n)
    o.setProperty(s, n[s]);
}
function nP(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const qp = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (st.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = nP(e, t.target.x), r = nP(e, t.target.y);
    return `${n}% ${r}%`;
  }
}, Nee = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const r = e, i = Cc.parse(e);
    if (i.length > 5)
      return r;
    const o = Cc.createTransformer(e), s = typeof i[0] != "number" ? 1 : 0, a = n.x.scale * t.x, c = n.y.scale * t.y;
    i[0 + s] /= a, i[1 + s] /= c;
    const u = Gn(a, c, 0.5);
    return typeof i[2 + s] == "number" && (i[2 + s] /= u), typeof i[3 + s] == "number" && (i[3 + s] /= u), o(i);
  }
}, qE = {
  borderRadius: {
    ...qp,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: qp,
  borderTopRightRadius: qp,
  borderBottomLeftRadius: qp,
  borderBottomRightRadius: qp,
  boxShadow: Nee
};
function CB(e, { layout: t, layoutId: n }) {
  return _h.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!qE[e] || e === "opacity");
}
function kA(e, t, n) {
  const r = e.style, i = t?.style, o = {};
  if (!r)
    return o;
  for (const s in r)
    (Fr(r[s]) || i && Fr(i[s]) || CB(s, e) || n?.getValue(s)?.liveStyle !== void 0) && (o[s] = r[s]);
  return o;
}
function Ree(e) {
  return window.getComputedStyle(e);
}
class EB extends vB {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = kB;
  }
  readValueFromInstance(t, n) {
    if (_h.has(n))
      return this.projection?.isProjecting ? OE(n) : sQ(t, n);
    {
      const r = Ree(t), i = (D4(n) ? r.getPropertyValue(n) : r[n]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return SB(t, n);
  }
  build(t, n, r) {
    SA(t, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return kA(t, n, r);
  }
}
function Oee(e, t) {
  return e in t;
}
class Dee extends yB {
  constructor() {
    super(...arguments), this.type = "object";
  }
  readValueFromInstance(t, n) {
    if (Oee(n, t)) {
      const r = t[n];
      if (typeof r == "string" || typeof r == "number")
        return r;
    }
  }
  getBaseTargetFromProps() {
  }
  removeValueFromRenderState(t, n) {
    delete n.output[t];
  }
  measureInstanceViewportBox() {
    return xr();
  }
  build(t, n) {
    Object.assign(t.output, n);
  }
  renderInstance(t, { output: n }) {
    Object.assign(t, n);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
const Pee = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, jee = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Iee(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1;
  const o = i ? Pee : jee;
  e[o.offset] = `${-r}`, e[o.array] = `${t} ${n}`;
}
const zee = [
  "offsetDistance",
  "offsetPath",
  "offsetRotate",
  "offsetAnchor"
];
function _B(e, {
  attrX: t,
  attrY: n,
  attrScale: r,
  pathLength: i,
  pathSpacing: o = 1,
  pathOffset: s = 0,
  // This is object creation, which we try to avoid per-frame.
  ...a
}, c, u, f) {
  if (SA(e, a, u), c) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: h, style: m } = e;
  h.transform && (m.transform = h.transform, delete h.transform), (m.transform || h.transformOrigin) && (m.transformOrigin = h.transformOrigin ?? "50% 50%", delete h.transformOrigin), m.transform && (m.transformBox = f?.transformBox ?? "fill-box", delete h.transformBox);
  for (const g of zee)
    h[g] !== void 0 && (m[g] = h[g], delete h[g]);
  t !== void 0 && (h.x = t), n !== void 0 && (h.y = n), r !== void 0 && (h.scale = r), i !== void 0 && Iee(h, i, o, s, !1);
}
const TB = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]), AB = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function Lee(e, t, n, r) {
  kB(e, t, void 0, r);
  for (const i in t.attrs)
    e.setAttribute(TB.has(i) ? i : pA(i), t.attrs[i]);
}
function MB(e, t, n) {
  const r = kA(e, t, n);
  for (const i in e)
    if (Fr(e[i]) || Fr(t[i])) {
      const o = Eh.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      r[o] = e[i];
    }
  return r;
}
class NB extends vB {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = xr;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (_h.has(n)) {
      const r = sB(n);
      return r && r.default || 0;
    }
    return n = TB.has(n) ? n : pA(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return MB(t, n, r);
  }
  build(t, n, r) {
    _B(t, n, this.isSVGTag, r.transformTemplate, r.style);
  }
  renderInstance(t, n, r, i) {
    Lee(t, n, r, i);
  }
  mount(t) {
    this.isSVGTag = AB(t.tagName), super.mount(t);
  }
}
const Bee = wA.length;
function RB(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const n = e.parent ? RB(e.parent) || {} : {};
    return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
  }
  const t = {};
  for (let n = 0; n < Bee; n++) {
    const r = wA[n], i = e.props[r];
    (Zm(i) || i === !1) && (t[r] = i);
  }
  return t;
}
function OB(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const $ee = [...xA].reverse(), Uee = xA.length;
function Fee(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => XQ(e, n, r)));
}
function Vee(e) {
  let t = Fee(e), n = rP(), r = !0;
  const i = (c) => (u, f) => {
    const h = Hf(e, f, c === "exit" ? e.presenceContext?.custom : void 0);
    if (h) {
      const { transition: m, transitionEnd: g, ...b } = h;
      u = { ...u, ...b, ...g };
    }
    return u;
  };
  function o(c) {
    t = c(e);
  }
  function s(c) {
    const { props: u } = e, f = RB(e.parent) || {}, h = [], m = /* @__PURE__ */ new Set();
    let g = {}, b = 1 / 0;
    for (let w = 0; w < Uee; w++) {
      const S = $ee[w], _ = n[S], M = u[S] !== void 0 ? u[S] : f[S], N = Zm(M), P = S === c ? _.isActive : null;
      P === !1 && (b = w);
      let I = M === f[S] && M !== u[S] && N;
      if (I && r && e.manuallyAnimateOnMount && (I = !1), _.protectedKeys = { ...g }, // If it isn't active and hasn't *just* been set as inactive
      !_.isActive && P === null || // If we didn't and don't have any defined prop for this animation type
      !M && !_.prevProp || // Or if the prop doesn't define an animation
      Fx(M) || typeof M == "boolean")
        continue;
      const O = Hee(_.prevProp, M);
      let L = O || // If we're making this variant active, we want to always make it active
      S === c && _.isActive && !I && N || // If we removed a higher-priority variant (i is in reverse order)
      w > b && N, U = !1;
      const B = Array.isArray(M) ? M : [M];
      let G = B.reduce(i(S), {});
      P === !1 && (G = {});
      const { prevResolvedValues: Y = {} } = _, he = {
        ...Y,
        ...G
      }, ie = (Q) => {
        L = !0, m.has(Q) && (U = !0, m.delete(Q)), _.needsAnimating[Q] = !0;
        const X = e.getValue(Q);
        X && (X.liveStyle = !1);
      };
      for (const Q in he) {
        const X = G[Q], Se = Y[Q];
        if (g.hasOwnProperty(Q))
          continue;
        let W = !1;
        LE(X) && LE(Se) ? W = !OB(X, Se) : W = X !== Se, W ? X != null ? ie(Q) : m.add(Q) : X !== void 0 && m.has(Q) ? ie(Q) : _.protectedKeys[Q] = !0;
      }
      _.prevProp = M, _.prevResolvedValues = G, _.isActive && (g = { ...g, ...G }), r && e.blockInitialAnimation && (L = !1);
      const ne = I && O;
      L && (!ne || U) && h.push(...B.map((Q) => {
        const X = { type: S };
        if (typeof Q == "string" && r && !ne && e.manuallyAnimateOnMount && e.parent) {
          const { parent: Se } = e, W = Hf(Se, Q);
          if (Se.enteringChildren && W) {
            const { delayChildren: Z } = W.transition || {};
            X.delay = Q4(Se.enteringChildren, e, Z);
          }
        }
        return {
          animation: Q,
          options: X
        };
      }));
    }
    if (m.size) {
      const w = {};
      if (typeof u.initial != "boolean") {
        const S = Hf(e, Array.isArray(u.initial) ? u.initial[0] : u.initial);
        S && S.transition && (w.transition = S.transition);
      }
      m.forEach((S) => {
        const _ = e.getBaseTarget(S), M = e.getValue(S);
        M && (M.liveStyle = !0), w[S] = _ ?? null;
      }), h.push({ animation: w });
    }
    let x = !!h.length;
    return r && (u.initial === !1 || u.initial === u.animate) && !e.manuallyAnimateOnMount && (x = !1), r = !1, x ? t(h) : Promise.resolve();
  }
  function a(c, u) {
    if (n[c].isActive === u)
      return Promise.resolve();
    e.variantChildren?.forEach((h) => h.animationState?.setActive(c, u)), n[c].isActive = u;
    const f = s(c);
    for (const h in n)
      n[h].protectedKeys = {};
    return f;
  }
  return {
    animateChanges: s,
    setActive: a,
    setAnimateFunction: o,
    getState: () => n,
    reset: () => {
      n = rP();
    }
  };
}
function Hee(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !OB(t, e) : !1;
}
function ku(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function rP() {
  return {
    animate: ku(!0),
    whileInView: ku(),
    whileHover: ku(),
    whileTap: ku(),
    whileDrag: ku(),
    whileFocus: ku(),
    exit: ku()
  };
}
function iP(e, t) {
  e.min = t.min, e.max = t.max;
}
function es(e, t) {
  iP(e.x, t.x), iP(e.y, t.y);
}
function oP(e, t) {
  e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin;
}
const DB = 1e-4, Wee = 1 - DB, qee = 1 + DB, PB = 0.01, Gee = 0 - PB, Kee = 0 + PB;
function Ni(e) {
  return e.max - e.min;
}
function Zee(e, t, n) {
  return Math.abs(e - t) <= n;
}
function sP(e, t, n, r = 0.5) {
  e.origin = r, e.originPoint = Gn(t.min, t.max, e.origin), e.scale = Ni(n) / Ni(t), e.translate = Gn(n.min, n.max, e.origin) - e.originPoint, (e.scale >= Wee && e.scale <= qee || isNaN(e.scale)) && (e.scale = 1), (e.translate >= Gee && e.translate <= Kee || isNaN(e.translate)) && (e.translate = 0);
}
function Em(e, t, n, r) {
  sP(e.x, t.x, n.x, r ? r.originX : void 0), sP(e.y, t.y, n.y, r ? r.originY : void 0);
}
function aP(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + Ni(t);
}
function Yee(e, t, n) {
  aP(e.x, t.x, n.x), aP(e.y, t.y, n.y);
}
function lP(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + Ni(t);
}
function eb(e, t, n) {
  lP(e.x, t.x, n.x), lP(e.y, t.y, n.y);
}
function cP(e, t, n, r, i) {
  return e -= t, e = Q0(e, 1 / n, r), i !== void 0 && (e = Q0(e, 1 / i, r)), e;
}
function Xee(e, t = 0, n = 1, r = 0.5, i, o = e, s = e) {
  if (Gs.test(t) && (t = parseFloat(t), t = Gn(s.min, s.max, t / 100) - s.min), typeof t != "number")
    return;
  let a = Gn(o.min, o.max, r);
  e === o && (a -= t), e.min = cP(e.min, t, n, a, i), e.max = cP(e.max, t, n, a, i);
}
function uP(e, t, [n, r, i], o, s) {
  Xee(e, t[n], t[r], t[i], t.scale, o, s);
}
const Jee = ["x", "scaleX", "originX"], Qee = ["y", "scaleY", "originY"];
function dP(e, t, n, r) {
  uP(e.x, t, Jee, n ? n.x : void 0, r ? r.x : void 0), uP(e.y, t, Qee, n ? n.y : void 0, r ? r.y : void 0);
}
function fP(e) {
  return e.translate === 0 && e.scale === 1;
}
function jB(e) {
  return fP(e.x) && fP(e.y);
}
function hP(e, t) {
  return e.min === t.min && e.max === t.max;
}
function ete(e, t) {
  return hP(e.x, t.x) && hP(e.y, t.y);
}
function pP(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function IB(e, t) {
  return pP(e.x, t.x) && pP(e.y, t.y);
}
function mP(e) {
  return Ni(e.x) / Ni(e.y);
}
function gP(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
function Oo(e) {
  return [e("x"), e("y")];
}
function tte(e, t, n) {
  let r = "";
  const i = e.x.translate / t.x, o = e.y.translate / t.y, s = n?.z || 0;
  if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { transformPerspective: u, rotate: f, rotateX: h, rotateY: m, skewX: g, skewY: b } = n;
    u && (r = `perspective(${u}px) ${r}`), f && (r += `rotate(${f}deg) `), h && (r += `rotateX(${h}deg) `), m && (r += `rotateY(${m}deg) `), g && (r += `skewX(${g}deg) `), b && (r += `skewY(${b}deg) `);
  }
  const a = e.x.scale * t.x, c = e.y.scale * t.y;
  return (a !== 1 || c !== 1) && (r += `scale(${a}, ${c})`), r || "none";
}
const zB = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], nte = zB.length, yP = (e) => typeof e == "string" ? parseFloat(e) : e, vP = (e) => typeof e == "number" || st.test(e);
function rte(e, t, n, r, i, o) {
  i ? (e.opacity = Gn(0, n.opacity ?? 1, ite(r)), e.opacityExit = Gn(t.opacity ?? 1, 0, ote(r))) : o && (e.opacity = Gn(t.opacity ?? 1, n.opacity ?? 1, r));
  for (let s = 0; s < nte; s++) {
    const a = `border${zB[s]}Radius`;
    let c = bP(t, a), u = bP(n, a);
    if (c === void 0 && u === void 0)
      continue;
    c || (c = 0), u || (u = 0), c === 0 || u === 0 || vP(c) === vP(u) ? (e[a] = Math.max(Gn(yP(c), yP(u), r), 0), (Gs.test(u) || Gs.test(c)) && (e[a] += "%")) : e[a] = u;
  }
  (t.rotate || n.rotate) && (e.rotate = Gn(t.rotate || 0, n.rotate || 0, r));
}
function bP(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const ite = /* @__PURE__ */ LB(0, 0.5, E4), ote = /* @__PURE__ */ LB(0.5, 0.95, $o);
function LB(e, t, n) {
  return (r) => r < e ? 0 : r > t ? 1 : n(/* @__PURE__ */ rh(e, t, r));
}
function BB(e, t, n) {
  const r = Fr(e) ? e : Ec(e);
  return r.start(fA("", r, t, n)), r.animation;
}
function Ym(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
}
const ste = (e, t) => e.depth - t.depth;
class ate {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    ZT(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    Og(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(ste), this.isDirty = !1, this.children.forEach(t);
  }
}
function lte(e, t) {
  const n = Mi.now(), r = ({ timestamp: i }) => {
    const o = i - n;
    o >= t && (Ya(r), e(o - t));
  };
  return _n.setup(r, !0), () => Ya(r);
}
function g0(e) {
  return Fr(e) ? e.get() : e;
}
class cte {
  constructor() {
    this.members = [];
  }
  add(t) {
    ZT(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (Og(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((i) => t === i);
    if (n === 0)
      return !1;
    let r;
    for (let i = n; i >= 0; i--) {
      const o = this.members[i];
      if (o.isPresent !== !1) {
        r = o;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(t, n) {
    const r = this.lead;
    if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) {
      r.instance && r.scheduleRender(), t.scheduleRender();
      const i = r.options.layoutDependency, o = t.options.layoutDependency;
      i !== void 0 && o !== void 0 && i === o || (t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0));
      const { crossfade: a } = t.options;
      a === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: r } = t;
      n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
const y0 = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
}, bk = ["", "X", "Y", "Z"], ute = 1e3;
let dte = 0;
function xk(e, t, n, r) {
  const { latestValues: i } = t;
  i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0));
}
function $B(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: t } = e.options;
  if (!t)
    return;
  const n = rB(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: i, layoutId: o } = e.options;
    window.MotionCancelOptimisedAnimation(n, "transform", _n, !(i || o));
  }
  const { parent: r } = e;
  r && !r.hasCheckedOptimisedAppear && $B(r);
}
function UB({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) {
  return class {
    constructor(s = {}, a = t?.()) {
      this.id = dte++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(pte), this.nodes.forEach(vte), this.nodes.forEach(bte), this.nodes.forEach(mte);
      }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = s, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let c = 0; c < this.path.length; c++)
        this.path[c].shouldResetTransform = !0;
      this.root === this && (this.nodes = new ate());
    }
    addEventListener(s, a) {
      return this.eventHandlers.has(s) || this.eventHandlers.set(s, new JT()), this.eventHandlers.get(s).add(a);
    }
    notifyListeners(s, ...a) {
      const c = this.eventHandlers.get(s);
      c && c.notify(...a);
    }
    hasListeners(s) {
      return this.eventHandlers.has(s);
    }
    /**
     * Lifecycles
     */
    mount(s) {
      if (this.instance)
        return;
      this.isSVG = bA(s) && !hB(s), this.instance = s;
      const { layoutId: a, layout: c, visualElement: u } = this.options;
      if (u && !u.current && u.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (c || a) && (this.isLayoutDirty = !0), e) {
        let f, h = 0;
        const m = () => this.root.updateBlockedByResize = !1;
        _n.read(() => {
          h = window.innerWidth;
        }), e(s, () => {
          const g = window.innerWidth;
          g !== h && (h = g, this.root.updateBlockedByResize = !0, f && f(), f = lte(m, 250), y0.hasAnimatedSinceResize && (y0.hasAnimatedSinceResize = !1, this.nodes.forEach(SP)));
        });
      }
      a && this.root.registerSharedNode(a, this), this.options.animate !== !1 && u && (a || c) && this.addEventListener("didUpdate", ({ delta: f, hasLayoutChanged: h, hasRelativeLayoutChanged: m, layout: g }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const b = this.options.transition || u.getDefaultTransition() || Cte, { onLayoutAnimationStart: x, onLayoutAnimationComplete: w } = u.getProps(), S = !this.targetLayout || !IB(this.targetLayout, g), _ = !h && m;
        if (this.options.layoutRoot || this.resumeFrom || _ || h && (S || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const M = {
            ...dA(b, "layout"),
            onPlay: x,
            onComplete: w
          };
          (u.shouldReduceMotion || this.options.layoutRoot) && (M.delay = 0, M.type = !1), this.startAnimation(M), this.setAnimationOrigin(f, _);
        } else
          h || SP(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = g;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const s = this.getStack();
      s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), Ya(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(xte), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: s } = this.options;
      return s && s.getProps().transformTemplate;
    }
    willUpdate(s = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && $B(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let f = 0; f < this.path.length; f++) {
        const h = this.path[f];
        h.shouldResetTransform = !0, h.updateScroll("snapshot"), h.options.layoutRoot && h.willUpdate(!1);
      }
      const { layoutId: a, layout: c } = this.options;
      if (a === void 0 && !c)
        return;
      const u = this.getTransformTemplate();
      this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(xP);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(wP);
        return;
      }
      this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(yte), this.nodes.forEach(fte), this.nodes.forEach(hte)) : this.nodes.forEach(wP), this.clearAllSnapshots();
      const a = Mi.now();
      Qr.delta = Ys(0, 1e3 / 60, a - Qr.timestamp), Qr.timestamp = a, Qr.isProcessing = !0, dk.update.process(Qr), dk.preRender.process(Qr), dk.render.process(Qr), Qr.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, yA.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(gte), this.sharedNodes.forEach(wte);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, _n.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      _n.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !Ni(this.snapshot.measuredBox.x) && !Ni(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let c = 0; c < this.path.length; c++)
          this.path[c].updateScroll();
      const s = this.layout;
      this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = xr(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0);
    }
    updateScroll(s = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a && this.instance) {
        const c = r(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: s,
          isRoot: c,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : c
        };
      }
    }
    resetTransform() {
      if (!i)
        return;
      const s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !jB(this.projectionDelta), c = this.getTransformTemplate(), u = c ? c(this.latestValues, "") : void 0, f = u !== this.prevTransformTemplateValue;
      s && this.instance && (a || Au(this.latestValues) || f) && (i(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(s = !0) {
      const a = this.measurePageBox();
      let c = this.removeElementScroll(a);
      return s && (c = this.removeTransform(c)), Ete(c), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: c,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: s } = this.options;
      if (!s)
        return xr();
      const a = s.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(_te))) {
        const { scroll: u } = this.root;
        u && (Pf(a.x, u.offset.x), Pf(a.y, u.offset.y));
      }
      return a;
    }
    removeElementScroll(s) {
      const a = xr();
      if (es(a, s), this.scroll?.wasRoot)
        return a;
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c], { scroll: f, options: h } = u;
        u !== this.root && f && h.layoutScroll && (f.wasRoot && es(a, s), Pf(a.x, f.offset.x), Pf(a.y, f.offset.y));
      }
      return a;
    }
    applyTransform(s, a = !1) {
      const c = xr();
      es(c, s);
      for (let u = 0; u < this.path.length; u++) {
        const f = this.path[u];
        !a && f.options.layoutScroll && f.scroll && f !== f.root && jf(c, {
          x: -f.scroll.offset.x,
          y: -f.scroll.offset.y
        }), Au(f.latestValues) && jf(c, f.latestValues);
      }
      return Au(this.latestValues) && jf(c, this.latestValues), c;
    }
    removeTransform(s) {
      const a = xr();
      es(a, s);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        if (!u.instance || !Au(u.latestValues))
          continue;
        HE(u.latestValues) && u.updateSnapshot();
        const f = xr(), h = u.measurePageBox();
        es(f, h), dP(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, f);
      }
      return Au(this.latestValues) && dP(a, this.latestValues), a;
    }
    setTargetDelta(s) {
      this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(s) {
      this.options = {
        ...this.options,
        ...s,
        crossfade: s.crossfade !== void 0 ? s.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Qr.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(s = !1) {
      const a = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty);
      const c = !!this.resumingFrom || this !== a;
      if (!(s || c && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: f, layoutId: h } = this.options;
      if (!this.layout || !(f || h))
        return;
      this.resolvedRelativeTargetAt = Qr.timestamp;
      const m = this.getClosestProjectingParent();
      m && this.linkedParentVersion !== m.layoutVersion && !m.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (m && m.layout ? this.createRelativeTarget(m, this.layout.layoutBox, m.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = xr(), this.targetWithTransforms = xr()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Yee(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : es(this.target, this.layout.layoutBox), wB(this.target, this.targetDelta)) : es(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, m && !!m.resumingFrom == !!this.resumingFrom && !m.options.layoutScroll && m.target && this.animationProgress !== 1 ? this.createRelativeTarget(m, this.target, m.target) : this.relativeParent = this.relativeTarget = void 0));
    }
    getClosestProjectingParent() {
      if (!(!this.parent || HE(this.parent.latestValues) || xB(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    createRelativeTarget(s, a, c) {
      this.relativeParent = s, this.linkedParentVersion = s.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = xr(), this.relativeTargetOrigin = xr(), eb(this.relativeTargetOrigin, a, c), es(this.relativeTarget, this.relativeTargetOrigin);
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      const s = this.getLead(), a = !!this.resumingFrom || this !== s;
      let c = !0;
      if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (c = !1), a && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === Qr.timestamp && (c = !1), c)
        return;
      const { layout: u, layoutId: f } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || f))
        return;
      es(this.layoutCorrected, this.layout.layoutBox);
      const h = this.treeScale.x, m = this.treeScale.y;
      Eee(this.layoutCorrected, this.treeScale, this.path, a), s.layout && !s.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (s.target = s.layout.layoutBox, s.targetWithTransforms = xr());
      const { target: g } = s;
      if (!g) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (oP(this.prevProjectionDelta.x, this.projectionDelta.x), oP(this.prevProjectionDelta.y, this.projectionDelta.y)), Em(this.projectionDelta, this.layoutCorrected, g, this.latestValues), (this.treeScale.x !== h || this.treeScale.y !== m || !gP(this.projectionDelta.x, this.prevProjectionDelta.x) || !gP(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", g));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(s = !0) {
      if (this.options.visualElement?.scheduleRender(), s) {
        const a = this.getStack();
        a && a.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = Df(), this.projectionDelta = Df(), this.projectionDeltaWithTransform = Df();
    }
    setAnimationOrigin(s, a = !1) {
      const c = this.snapshot, u = c ? c.latestValues : {}, f = { ...this.latestValues }, h = Df();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const m = xr(), g = c ? c.source : void 0, b = this.layout ? this.layout.source : void 0, x = g !== b, w = this.getStack(), S = !w || w.members.length <= 1, _ = !!(x && !S && this.options.crossfade === !0 && !this.path.some(kte));
      this.animationProgress = 0;
      let M;
      this.mixTargetDelta = (N) => {
        const P = N / 1e3;
        kP(h.x, s.x, P), kP(h.y, s.y, P), this.setTargetDelta(h), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (eb(m, this.layout.layoutBox, this.relativeParent.layout.layoutBox), Ste(this.relativeTarget, this.relativeTargetOrigin, m, P), M && ete(this.relativeTarget, M) && (this.isProjectionDirty = !1), M || (M = xr()), es(M, this.relativeTarget)), x && (this.animationValues = f, rte(f, u, this.latestValues, P, _, S)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = P;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(s) {
      this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (Ya(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = _n.update(() => {
        y0.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = Ec(0)), this.currentAnimation = BB(this.motionValue, [0, 1e3], {
          ...s,
          velocity: 0,
          isSync: !0,
          onUpdate: (a) => {
            this.mixTargetDelta(a), s.onUpdate && s.onUpdate(a);
          },
          onStop: () => {
          },
          onComplete: () => {
            s.onComplete && s.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const s = this.getStack();
      s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(ute), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const s = this.getLead();
      let { targetWithTransforms: a, target: c, layout: u, latestValues: f } = s;
      if (!(!a || !c || !u)) {
        if (this !== s && this.layout && u && FB(this.options.animationType, this.layout.layoutBox, u.layoutBox)) {
          c = this.target || xr();
          const h = Ni(this.layout.layoutBox.x);
          c.x.min = s.target.x.min, c.x.max = c.x.min + h;
          const m = Ni(this.layout.layoutBox.y);
          c.y.min = s.target.y.min, c.y.max = c.y.min + m;
        }
        es(a, c), jf(a, f), Em(this.projectionDeltaWithTransform, this.layoutCorrected, a, f);
      }
    }
    registerSharedNode(s, a) {
      this.sharedNodes.has(s) || this.sharedNodes.set(s, new cte()), this.sharedNodes.get(s).add(a);
      const u = a.options.initialPromotionConfig;
      a.promote({
        transition: u ? u.transition : void 0,
        preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const s = this.getStack();
      return s ? s.lead === this : !0;
    }
    getLead() {
      const { layoutId: s } = this.options;
      return s ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId: s } = this.options;
      return s ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId: s } = this.options;
      if (s)
        return this.root.sharedNodes.get(s);
    }
    promote({ needsReset: s, transition: a, preserveFollowOpacity: c } = {}) {
      const u = this.getStack();
      u && u.promote(this, c), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const s = this.getStack();
      return s ? s.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: s } = this.options;
      if (!s)
        return;
      let a = !1;
      const { latestValues: c } = s;
      if ((c.z || c.rotate || c.rotateX || c.rotateY || c.rotateZ || c.skewX || c.skewY) && (a = !0), !a)
        return;
      const u = {};
      c.z && xk("z", s, u, this.animationValues);
      for (let f = 0; f < bk.length; f++)
        xk(`rotate${bk[f]}`, s, u, this.animationValues), xk(`skew${bk[f]}`, s, u, this.animationValues);
      s.render();
      for (const f in u)
        s.setStaticValue(f, u[f]), this.animationValues && (this.animationValues[f] = u[f]);
      s.scheduleRender();
    }
    applyProjectionStyles(s, a) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        s.visibility = "hidden";
        return;
      }
      const c = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = !1, s.visibility = "", s.opacity = "", s.pointerEvents = g0(a?.pointerEvents) || "", s.transform = c ? c(this.latestValues, "") : "none";
        return;
      }
      const u = this.getLead();
      if (!this.projectionDelta || !this.layout || !u.target) {
        this.options.layoutId && (s.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, s.pointerEvents = g0(a?.pointerEvents) || ""), this.hasProjected && !Au(this.latestValues) && (s.transform = c ? c({}, "") : "none", this.hasProjected = !1);
        return;
      }
      s.visibility = "";
      const f = u.animationValues || u.latestValues;
      this.applyTransformsToTarget();
      let h = tte(this.projectionDeltaWithTransform, this.treeScale, f);
      c && (h = c(f, h)), s.transform = h;
      const { x: m, y: g } = this.projectionDelta;
      s.transformOrigin = `${m.origin * 100}% ${g.origin * 100}% 0`, u.animationValues ? s.opacity = u === this ? f.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : s.opacity = u === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0;
      for (const b in qE) {
        if (f[b] === void 0)
          continue;
        const { correct: x, applyTo: w, isCSSVariable: S } = qE[b], _ = h === "none" ? f[b] : x(f[b], u);
        if (w) {
          const M = w.length;
          for (let N = 0; N < M; N++)
            s[w[N]] = _;
        } else
          S ? this.options.visualElement.renderState.vars[b] = _ : s[b] = _;
      }
      this.options.layoutId && (s.pointerEvents = u === this ? g0(a?.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((s) => s.currentAnimation?.stop()), this.root.nodes.forEach(xP), this.root.sharedNodes.clear();
    }
  };
}
function fte(e) {
  e.updateLayout();
}
function hte(e) {
  const t = e.resumeFrom?.snapshot || e.snapshot;
  if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: r } = e.layout, { animationType: i } = e.options, o = t.source !== e.layout.source;
    i === "size" ? Oo((f) => {
      const h = o ? t.measuredBox[f] : t.layoutBox[f], m = Ni(h);
      h.min = n[f].min, h.max = h.min + m;
    }) : FB(i, t.layoutBox, n) && Oo((f) => {
      const h = o ? t.measuredBox[f] : t.layoutBox[f], m = Ni(n[f]);
      h.max = h.min + m, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[f].max = e.relativeTarget[f].min + m);
    });
    const s = Df();
    Em(s, n, t.layoutBox);
    const a = Df();
    o ? Em(a, e.applyTransform(r, !0), t.measuredBox) : Em(a, n, t.layoutBox);
    const c = !jB(s);
    let u = !1;
    if (!e.resumeFrom) {
      const f = e.getClosestProjectingParent();
      if (f && !f.resumeFrom) {
        const { snapshot: h, layout: m } = f;
        if (h && m) {
          const g = xr();
          eb(g, t.layoutBox, h.layoutBox);
          const b = xr();
          eb(b, n, m.layoutBox), IB(g, b) || (u = !0), f.options.layoutRoot && (e.relativeTarget = b, e.relativeTargetOrigin = g, e.relativeParent = f);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: n,
      snapshot: t,
      delta: a,
      layoutDelta: s,
      hasLayoutChanged: c,
      hasRelativeLayoutChanged: u
    });
  } else if (e.isLead()) {
    const { onExitComplete: n } = e.options;
    n && n();
  }
  e.options.transition = void 0;
}
function pte(e) {
  e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function mte(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function gte(e) {
  e.clearSnapshot();
}
function xP(e) {
  e.clearMeasurements();
}
function wP(e) {
  e.isLayoutDirty = !1;
}
function yte(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function SP(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function vte(e) {
  e.resolveTargetDelta();
}
function bte(e) {
  e.calcProjection();
}
function xte(e) {
  e.resetSkewAndRotation();
}
function wte(e) {
  e.removeLeadSnapshot();
}
function kP(e, t, n) {
  e.translate = Gn(t.translate, 0, n), e.scale = Gn(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function CP(e, t, n, r) {
  e.min = Gn(t.min, n.min, r), e.max = Gn(t.max, n.max, r);
}
function Ste(e, t, n, r) {
  CP(e.x, t.x, n.x, r), CP(e.y, t.y, n.y, r);
}
function kte(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const Cte = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, EP = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), _P = EP("applewebkit/") && !EP("chrome/") ? Math.round : $o;
function TP(e) {
  e.min = _P(e.min), e.max = _P(e.max);
}
function Ete(e) {
  TP(e.x), TP(e.y);
}
function FB(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !Zee(mP(t), mP(n), 0.2);
}
function _te(e) {
  return e !== e.root && e.scroll?.wasRoot;
}
const Tte = UB({
  attachResizeListener: (e, t) => Ym(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body?.scrollLeft || 0,
    y: document.documentElement.scrollTop || document.body?.scrollTop || 0
  }),
  checkIsScrollRoot: () => !0
}), wk = {
  current: void 0
}, VB = UB({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!wk.current) {
      const e = new Tte({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), wk.current = e;
    }
    return wk.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), Hx = k.createContext({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
});
function AP(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function Ate(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const o = AP(i, t);
      return !n && typeof o == "function" && (n = !0), o;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const o = r[i];
          typeof o == "function" ? o() : AP(e[i], null);
        }
      };
  };
}
function Mte(...e) {
  return k.useCallback(Ate(...e), e);
}
class Nte extends k.Component {
  getSnapshotBeforeUpdate(t) {
    const n = this.props.childRef.current;
    if (n && t.isPresent && !this.props.isPresent) {
      const r = n.offsetParent, i = FE(r) && r.offsetWidth || 0, o = FE(r) && r.offsetHeight || 0, s = this.props.sizeRef.current;
      s.height = n.offsetHeight || 0, s.width = n.offsetWidth || 0, s.top = n.offsetTop, s.left = n.offsetLeft, s.right = i - s.width - s.left, s.bottom = o - s.height - s.top;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function Rte({ children: e, isPresent: t, anchorX: n, anchorY: r, root: i }) {
  const o = k.useId(), s = k.useRef(null), a = k.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }), { nonce: c } = k.useContext(Hx), u = e.props?.ref ?? e?.ref, f = Mte(s, u);
  return k.useInsertionEffect(() => {
    const { width: h, height: m, top: g, left: b, right: x, bottom: w } = a.current;
    if (t || !s.current || !h || !m)
      return;
    const S = n === "left" ? `left: ${b}` : `right: ${x}`, _ = r === "bottom" ? `bottom: ${w}` : `top: ${g}`;
    s.current.dataset.motionPopId = o;
    const M = document.createElement("style");
    c && (M.nonce = c);
    const N = i ?? document.head;
    return N.appendChild(M), M.sheet && M.sheet.insertRule(`
          [data-motion-pop-id="${o}"] {
            position: absolute !important;
            width: ${h}px !important;
            height: ${m}px !important;
            ${S}px !important;
            ${_}px !important;
          }
        `), () => {
      N.contains(M) && N.removeChild(M);
    };
  }, [t]), v.jsx(Nte, { isPresent: t, childRef: s, sizeRef: a, children: k.cloneElement(e, { ref: f }) });
}
const Ote = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s, anchorX: a, anchorY: c, root: u }) => {
  const f = Rg(Dte), h = k.useId();
  let m = !0, g = k.useMemo(() => (m = !1, {
    id: h,
    initial: t,
    isPresent: n,
    custom: i,
    onExitComplete: (b) => {
      f.set(b, !0);
      for (const x of f.values())
        if (!x)
          return;
      r && r();
    },
    register: (b) => (f.set(b, !1), () => f.delete(b))
  }), [n, f, r]);
  return o && m && (g = { ...g }), k.useMemo(() => {
    f.forEach((b, x) => f.set(x, !1));
  }, [n]), k.useEffect(() => {
    !n && !f.size && r && r();
  }, [n]), s === "popLayout" && (e = v.jsx(Rte, { isPresent: n, anchorX: a, anchorY: c, root: u, children: e })), v.jsx(Ux.Provider, { value: g, children: e });
};
function Dte() {
  return /* @__PURE__ */ new Map();
}
function HB(e = !0) {
  const t = k.useContext(Ux);
  if (t === null)
    return [!0, null];
  const { isPresent: n, onExitComplete: r, register: i } = t, o = k.useId();
  k.useEffect(() => {
    if (e)
      return i(o);
  }, [e]);
  const s = k.useCallback(() => e && r && r(o), [o, r, e]);
  return !n && r ? [!1, s] : [!0];
}
const Ev = (e) => e.key || "";
function MP(e) {
  const t = [];
  return k.Children.forEach(e, (n) => {
    k.isValidElement(n) && t.push(n);
  }), t;
}
const CA = ({ children: e, custom: t, initial: n = !0, onExitComplete: r, presenceAffectsLayout: i = !0, mode: o = "sync", propagate: s = !1, anchorX: a = "left", anchorY: c = "top", root: u }) => {
  const [f, h] = HB(s), m = k.useMemo(() => MP(e), [e]), g = s && !f ? [] : m.map(Ev), b = k.useRef(!0), x = k.useRef(m), w = Rg(() => /* @__PURE__ */ new Map()), S = k.useRef(/* @__PURE__ */ new Set()), [_, M] = k.useState(m), [N, P] = k.useState(m);
  KT(() => {
    b.current = !1, x.current = m;
    for (let L = 0; L < N.length; L++) {
      const U = Ev(N[L]);
      g.includes(U) ? (w.delete(U), S.current.delete(U)) : w.get(U) !== !0 && w.set(U, !1);
    }
  }, [N, g.length, g.join("-")]);
  const I = [];
  if (m !== _) {
    let L = [...m];
    for (let U = 0; U < N.length; U++) {
      const B = N[U], G = Ev(B);
      g.includes(G) || (L.splice(U, 0, B), I.push(B));
    }
    return o === "wait" && I.length && (L = I), P(MP(L)), M(m), null;
  }
  const { forceRender: O } = k.useContext(GT);
  return v.jsx(v.Fragment, { children: N.map((L) => {
    const U = Ev(L), B = s && !f ? !1 : m === N || g.includes(U), G = () => {
      if (S.current.has(U))
        return;
      if (S.current.add(U), w.has(U))
        w.set(U, !0);
      else
        return;
      let Y = !0;
      w.forEach((he) => {
        he || (Y = !1);
      }), Y && (O?.(), P(x.current), s && h?.(), r && r());
    };
    return v.jsx(Ote, { isPresent: B, initial: !b.current || n ? void 0 : !1, custom: t, presenceAffectsLayout: i, mode: o, root: u, onExitComplete: B ? void 0 : G, anchorX: a, anchorY: c, children: L }, U);
  }) });
}, WB = k.createContext({ strict: !1 }), NP = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
let RP = !1;
function Pte() {
  if (RP)
    return;
  const e = {};
  for (const t in NP)
    e[t] = {
      isEnabled: (n) => NP[t].some((r) => !!n[r])
    };
  gB(e), RP = !0;
}
function qB() {
  return Pte(), See();
}
function jte(e) {
  const t = qB();
  for (const n in e)
    t[n] = {
      ...t[n],
      ...e[n]
    };
  gB(t);
}
const Ite = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function tb(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || Ite.has(e);
}
let GB = (e) => !tb(e);
function zte(e) {
  typeof e == "function" && (GB = (t) => t.startsWith("on") ? !tb(t) : e(t));
}
try {
  zte(require("@emotion/is-prop-valid").default);
} catch {
}
function Lte(e, t, n) {
  const r = {};
  for (const i in e)
    i === "values" && typeof e.values == "object" || (GB(i) || n === !0 && tb(i) || !t && !tb(i) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
  return r;
}
const Wx = /* @__PURE__ */ k.createContext({});
function Bte(e, t) {
  if (Vx(e)) {
    const { initial: n, animate: r } = e;
    return {
      initial: n === !1 || Zm(n) ? n : void 0,
      animate: Zm(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function $te(e) {
  const { initial: t, animate: n } = Bte(e, k.useContext(Wx));
  return k.useMemo(() => ({ initial: t, animate: n }), [OP(t), OP(n)]);
}
function OP(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const EA = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function KB(e, t, n) {
  for (const r in t)
    !Fr(t[r]) && !CB(r, n) && (e[r] = t[r]);
}
function Ute({ transformTemplate: e }, t) {
  return k.useMemo(() => {
    const n = EA();
    return SA(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function Fte(e, t) {
  const n = e.style || {}, r = {};
  return KB(r, n, e), Object.assign(r, Ute(e, t)), r;
}
function Vte(e, t) {
  const n = {}, r = Fte(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
const ZB = () => ({
  ...EA(),
  attrs: {}
});
function Hte(e, t, n, r) {
  const i = k.useMemo(() => {
    const o = ZB();
    return _B(o, t, AB(r), e.transformTemplate, e.style), {
      ...o.attrs,
      style: { ...o.style }
    };
  }, [t]);
  if (e.style) {
    const o = {};
    KB(o, e.style, e), i.style = { ...o, ...i.style };
  }
  return i;
}
const Wte = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function _A(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(Wte.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(e))
    )
  );
}
function qte(e, t, n, { latestValues: r }, i, o = !1, s) {
  const c = (s ?? _A(e) ? Hte : Vte)(t, r, i, e), u = Lte(t, typeof e == "string", o), f = e !== k.Fragment ? { ...u, ...c, ref: n } : {}, { children: h } = t, m = k.useMemo(() => Fr(h) ? h.get() : h, [h]);
  return k.createElement(e, {
    ...f,
    children: m
  });
}
function Gte({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, i) {
  return {
    latestValues: Kte(n, r, i, e),
    renderState: t()
  };
}
function Kte(e, t, n, r) {
  const i = {}, o = r(e, {});
  for (const m in o)
    i[m] = g0(o[m]);
  let { initial: s, animate: a } = e;
  const c = Vx(e), u = mB(e);
  t && u && !c && e.inherit !== !1 && (s === void 0 && (s = t.initial), a === void 0 && (a = t.animate));
  let f = n ? n.initial === !1 : !1;
  f = f || s === !1;
  const h = f ? a : s;
  if (h && typeof h != "boolean" && !Fx(h)) {
    const m = Array.isArray(h) ? h : [h];
    for (let g = 0; g < m.length; g++) {
      const b = hA(e, m[g]);
      if (b) {
        const { transitionEnd: x, transition: w, ...S } = b;
        for (const _ in S) {
          let M = S[_];
          if (Array.isArray(M)) {
            const N = f ? M.length - 1 : 0;
            M = M[N];
          }
          M !== null && (i[_] = M);
        }
        for (const _ in x)
          i[_] = x[_];
      }
    }
  }
  return i;
}
const YB = (e) => (t, n) => {
  const r = k.useContext(Wx), i = k.useContext(Ux), o = () => Gte(e, t, r, i);
  return n ? o() : Rg(o);
}, Zte = /* @__PURE__ */ YB({
  scrapeMotionValuesFromProps: kA,
  createRenderState: EA
}), Yte = /* @__PURE__ */ YB({
  scrapeMotionValuesFromProps: MB,
  createRenderState: ZB
}), Xte = /* @__PURE__ */ Symbol.for("motionComponentSymbol");
function Jte(e, t, n) {
  const r = k.useRef(n);
  k.useInsertionEffect(() => {
    r.current = n;
  });
  const i = k.useRef(null);
  return k.useCallback((o) => {
    o && e.onMount?.(o), t && (o ? t.mount(o) : t.unmount());
    const s = r.current;
    if (typeof s == "function")
      if (o) {
        const a = s(o);
        typeof a == "function" && (i.current = a);
      } else i.current ? (i.current(), i.current = null) : s(o);
    else s && (s.current = o);
  }, [t]);
}
const XB = k.createContext({});
function om(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function Qte(e, t, n, r, i, o) {
  const { visualElement: s } = k.useContext(Wx), a = k.useContext(WB), c = k.useContext(Ux), u = k.useContext(Hx), f = u.reducedMotion, h = u.skipAnimations, m = k.useRef(null), g = k.useRef(!1);
  r = r || a.renderer, !m.current && r && (m.current = r(e, {
    visualState: t,
    parent: s,
    props: n,
    presenceContext: c,
    blockInitialAnimation: c ? c.initial === !1 : !1,
    reducedMotionConfig: f,
    skipAnimations: h,
    isSVG: o
  }), g.current && m.current && (m.current.manuallyAnimateOnMount = !0));
  const b = m.current, x = k.useContext(XB);
  b && !b.projection && i && (b.type === "html" || b.type === "svg") && ene(m.current, n, i, x);
  const w = k.useRef(!1);
  k.useInsertionEffect(() => {
    b && w.current && b.update(n, c);
  });
  const S = n[nB], _ = k.useRef(!!S && !window.MotionHandoffIsComplete?.(S) && window.MotionHasOptimisedAnimation?.(S));
  return KT(() => {
    g.current = !0, b && (w.current = !0, window.MotionIsMounted = !0, b.updateFeatures(), b.scheduleRenderMicrotask(), _.current && b.animationState && b.animationState.animateChanges());
  }), k.useEffect(() => {
    b && (!_.current && b.animationState && b.animationState.animateChanges(), _.current && (queueMicrotask(() => {
      window.MotionHandoffMarkAsComplete?.(S);
    }), _.current = !1), b.enteringChildren = void 0);
  }), b;
}
function ene(e, t, n, r) {
  const { layoutId: i, layout: o, drag: s, dragConstraints: a, layoutScroll: c, layoutRoot: u, layoutCrossfade: f } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : JB(e.parent)), e.projection.setOptions({
    layoutId: i,
    layout: o,
    alwaysMeasureLayout: !!s || a && om(a),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof o == "string" ? o : "both",
    initialPromotionConfig: r,
    crossfade: f,
    layoutScroll: c,
    layoutRoot: u
  });
}
function JB(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : JB(e.parent);
}
function Sk(e, { forwardMotionProps: t = !1, type: n } = {}, r, i) {
  r && jte(r);
  const o = n ? n === "svg" : _A(e), s = o ? Yte : Zte;
  function a(u, f) {
    let h;
    const m = {
      ...k.useContext(Hx),
      ...u,
      layoutId: tne(u)
    }, { isStatic: g } = m, b = $te(u), x = s(u, g);
    if (!g && p4) {
      nne();
      const w = rne(m);
      h = w.MeasureLayout, b.visualElement = Qte(e, x, m, i, w.ProjectionNode, o);
    }
    return v.jsxs(Wx.Provider, { value: b, children: [h && b.visualElement ? v.jsx(h, { visualElement: b.visualElement, ...m }) : null, qte(e, u, Jte(x, b.visualElement, f), x, g, t, o)] });
  }
  a.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`;
  const c = k.forwardRef(a);
  return c[Xte] = e, c;
}
function tne({ layoutId: e }) {
  const t = k.useContext(GT).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function nne(e, t) {
  k.useContext(WB).strict;
}
function rne(e) {
  const t = qB(), { drag: n, layout: r } = t;
  if (!n && !r)
    return {};
  const i = { ...n, ...r };
  return {
    MeasureLayout: n?.isEnabled(e) || r?.isEnabled(e) ? i.MeasureLayout : void 0,
    ProjectionNode: i.ProjectionNode
  };
}
function ine(e, t) {
  if (typeof Proxy > "u")
    return Sk;
  const n = /* @__PURE__ */ new Map(), r = (o, s) => Sk(o, s, e, t), i = (o, s) => r(o, s);
  return new Proxy(i, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (o, s) => s === "create" ? r : (n.has(s) || n.set(s, Sk(s, void 0, e, t)), n.get(s))
  });
}
const one = (e, t) => t.isSVG ?? _A(e) ? new NB(t) : new EB(t, {
  allowProjection: e !== k.Fragment
});
class sne extends jc {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = Vee(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    Fx(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    this.node.animationState.reset(), this.unmountControls?.();
  }
}
let ane = 0;
class lne extends jc {
  constructor() {
    super(...arguments), this.id = ane++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === r)
      return;
    const i = this.node.animationState.setActive("exit", !t);
    n && !t && i.then(() => {
      n(this.id);
    });
  }
  mount() {
    const { register: t, onExitComplete: n } = this.node.presenceContext || {};
    n && n(this.id), t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const cne = {
  animation: {
    Feature: sne
  },
  exit: {
    Feature: lne
  }
};
function Ig(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
const une = (e) => (t) => vA(t) && e(t, Ig(t));
function _m(e, t, n, r) {
  return Ym(e, t, une(n), r);
}
const QB = ({ current: e }) => e ? e.ownerDocument.defaultView : null, DP = (e, t) => Math.abs(e - t);
function dne(e, t) {
  const n = DP(e.x, t.x), r = DP(e.y, t.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
const PP = /* @__PURE__ */ new Set(["auto", "scroll"]);
class e6 {
  constructor(t, n, { transformPagePoint: r, contextWindow: i = window, dragSnapToOrigin: o = !1, distanceThreshold: s = 3, element: a } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.scrollPositions = /* @__PURE__ */ new Map(), this.removeScrollListeners = null, this.onElementScroll = (g) => {
      this.handleScroll(g.target);
    }, this.onWindowScroll = () => {
      this.handleScroll(window);
    }, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const g = Ck(this.lastMoveEventInfo, this.history), b = this.startEvent !== null, x = dne(g.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!b && !x)
        return;
      const { point: w } = g, { timestamp: S } = Qr;
      this.history.push({ ...w, timestamp: S });
      const { onStart: _, onMove: M } = this.handlers;
      b || (_ && _(this.lastMoveEvent, g), this.startEvent = this.lastMoveEvent), M && M(this.lastMoveEvent, g);
    }, this.handlePointerMove = (g, b) => {
      this.lastMoveEvent = g, this.lastMoveEventInfo = kk(b, this.transformPagePoint), _n.update(this.updatePoint, !0);
    }, this.handlePointerUp = (g, b) => {
      this.end();
      const { onEnd: x, onSessionEnd: w, resumeAnimation: S } = this.handlers;
      if ((this.dragSnapToOrigin || !this.startEvent) && S && S(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const _ = Ck(g.type === "pointercancel" ? this.lastMoveEventInfo : kk(b, this.transformPagePoint), this.history);
      this.startEvent && x && x(g, _), w && w(g, _);
    }, !vA(t))
      return;
    this.dragSnapToOrigin = o, this.handlers = n, this.transformPagePoint = r, this.distanceThreshold = s, this.contextWindow = i || window;
    const c = Ig(t), u = kk(c, this.transformPagePoint), { point: f } = u, { timestamp: h } = Qr;
    this.history = [{ ...f, timestamp: h }];
    const { onSessionStart: m } = n;
    m && m(t, Ck(u, this.history)), this.removeListeners = Dg(_m(this.contextWindow, "pointermove", this.handlePointerMove), _m(this.contextWindow, "pointerup", this.handlePointerUp), _m(this.contextWindow, "pointercancel", this.handlePointerUp)), a && this.startScrollTracking(a);
  }
  /**
   * Start tracking scroll on ancestors and window.
   */
  startScrollTracking(t) {
    let n = t.parentElement;
    for (; n; ) {
      const r = getComputedStyle(n);
      (PP.has(r.overflowX) || PP.has(r.overflowY)) && this.scrollPositions.set(n, {
        x: n.scrollLeft,
        y: n.scrollTop
      }), n = n.parentElement;
    }
    this.scrollPositions.set(window, {
      x: window.scrollX,
      y: window.scrollY
    }), window.addEventListener("scroll", this.onElementScroll, {
      capture: !0,
      passive: !0
    }), window.addEventListener("scroll", this.onWindowScroll, {
      passive: !0
    }), this.removeScrollListeners = () => {
      window.removeEventListener("scroll", this.onElementScroll, {
        capture: !0
      }), window.removeEventListener("scroll", this.onWindowScroll);
    };
  }
  /**
   * Handle scroll compensation during drag.
   *
   * For element scroll: adjusts history origin since pageX/pageY doesn't change.
   * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.
   */
  handleScroll(t) {
    const n = this.scrollPositions.get(t);
    if (!n)
      return;
    const r = t === window, i = r ? { x: window.scrollX, y: window.scrollY } : {
      x: t.scrollLeft,
      y: t.scrollTop
    }, o = { x: i.x - n.x, y: i.y - n.y };
    o.x === 0 && o.y === 0 || (r ? this.lastMoveEventInfo && (this.lastMoveEventInfo.point.x += o.x, this.lastMoveEventInfo.point.y += o.y) : this.history.length > 0 && (this.history[0].x -= o.x, this.history[0].y -= o.y), this.scrollPositions.set(t, i), _n.update(this.updatePoint, !0));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), this.removeScrollListeners && this.removeScrollListeners(), this.scrollPositions.clear(), Ya(this.updatePoint);
  }
}
function kk(e, t) {
  return t ? { point: t(e.point) } : e;
}
function jP(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function Ck({ point: e }, t) {
  return {
    point: e,
    delta: jP(e, t6(t)),
    offset: jP(e, fne(t)),
    velocity: hne(t, 0.1)
  };
}
function fne(e) {
  return e[0];
}
function t6(e) {
  return e[e.length - 1];
}
function hne(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, r = null;
  const i = t6(e);
  for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > /* @__PURE__ */ qs(t))); )
    n--;
  if (!r)
    return { x: 0, y: 0 };
  const o = /* @__PURE__ */ Lo(i.timestamp - r.timestamp);
  if (o === 0)
    return { x: 0, y: 0 };
  const s = {
    x: (i.x - r.x) / o,
    y: (i.y - r.y) / o
  };
  return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s;
}
function pne(e, { min: t, max: n }, r) {
  return t !== void 0 && e < t ? e = r ? Gn(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? Gn(n, e, r.max) : Math.min(e, n)), e;
}
function IP(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function mne(e, { top: t, left: n, bottom: r, right: i }) {
  return {
    x: IP(e.x, n, i),
    y: IP(e.y, t, r)
  };
}
function zP(e, t) {
  let n = t.min - e.min, r = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r };
}
function gne(e, t) {
  return {
    x: zP(e.x, t.x),
    y: zP(e.y, t.y)
  };
}
function yne(e, t) {
  let n = 0.5;
  const r = Ni(e), i = Ni(t);
  return i > r ? n = /* @__PURE__ */ rh(t.min, t.max - r, e.min) : r > i && (n = /* @__PURE__ */ rh(e.min, e.max - i, t.min)), Ys(0, 1, n);
}
function vne(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const GE = 0.35;
function bne(e = GE) {
  return e === !1 ? e = 0 : e === !0 && (e = GE), {
    x: LP(e, "left", "right"),
    y: LP(e, "top", "bottom")
  };
}
function LP(e, t, n) {
  return {
    min: BP(e, t),
    max: BP(e, n)
  };
}
function BP(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const xne = /* @__PURE__ */ new WeakMap();
class wne {
  constructor(t) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = xr(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1, distanceThreshold: r } = {}) {
    const { presenceContext: i } = this.visualElement;
    if (i && i.isPresent === !1)
      return;
    const o = (h) => {
      n ? (this.stopAnimation(), this.snapToCursor(Ig(h).point)) : this.pauseAnimation();
    }, s = (h, m) => {
      this.stopAnimation();
      const { drag: g, dragPropagation: b, onDragStart: x } = this.getProps();
      if (g && !b && (this.openDragLock && this.openDragLock(), this.openDragLock = lee(g), !this.openDragLock))
        return;
      this.latestPointerEvent = h, this.latestPanInfo = m, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Oo((S) => {
        let _ = this.getAxisMotionValue(S).get() || 0;
        if (Gs.test(_)) {
          const { projection: M } = this.visualElement;
          if (M && M.layout) {
            const N = M.layout.layoutBox[S];
            N && (_ = Ni(N) * (parseFloat(_) / 100));
          }
        }
        this.originPoint[S] = _;
      }), x && _n.update(() => x(h, m), !1, !0), BE(this.visualElement, "transform");
      const { animationState: w } = this.visualElement;
      w && w.setActive("whileDrag", !0);
    }, a = (h, m) => {
      this.latestPointerEvent = h, this.latestPanInfo = m;
      const { dragPropagation: g, dragDirectionLock: b, onDirectionLock: x, onDrag: w } = this.getProps();
      if (!g && !this.openDragLock)
        return;
      const { offset: S } = m;
      if (b && this.currentDirection === null) {
        this.currentDirection = Sne(S), this.currentDirection !== null && x && x(this.currentDirection);
        return;
      }
      this.updateAxis("x", m.point, S), this.updateAxis("y", m.point, S), this.visualElement.render(), w && _n.update(() => w(h, m), !1, !0);
    }, c = (h, m) => {
      this.latestPointerEvent = h, this.latestPanInfo = m, this.stop(h, m), this.latestPointerEvent = null, this.latestPanInfo = null;
    }, u = () => Oo((h) => this.getAnimationState(h) === "paused" && this.getAxisMotionValue(h).animation?.play()), { dragSnapToOrigin: f } = this.getProps();
    this.panSession = new e6(t, {
      onSessionStart: o,
      onStart: s,
      onMove: a,
      onSessionEnd: c,
      resumeAnimation: u
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: f,
      distanceThreshold: r,
      contextWindow: QB(this.visualElement),
      element: this.visualElement.current
    });
  }
  /**
   * @internal
   */
  stop(t, n) {
    const r = t || this.latestPointerEvent, i = n || this.latestPanInfo, o = this.isDragging;
    if (this.cancel(), !o || !i || !r)
      return;
    const { velocity: s } = i;
    this.startAnimation(s);
    const { onDragEnd: a } = this.getProps();
    a && _n.postRender(() => a(r, i));
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.endPanSession();
    const { dragPropagation: r } = this.getProps();
    !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1);
  }
  /**
   * Clean up the pan session without modifying other drag state.
   * This is used during unmount to ensure event listeners are removed
   * without affecting projection animations or drag locks.
   * @internal
   */
  endPanSession() {
    this.panSession && this.panSession.end(), this.panSession = void 0;
  }
  updateAxis(t, n, r) {
    const { drag: i } = this.getProps();
    if (!r || !_v(t, i, this.currentDirection))
      return;
    const o = this.getAxisMotionValue(t);
    let s = this.originPoint[t] + r[t];
    this.constraints && this.constraints[t] && (s = pne(s, this.constraints[t], this.elastic[t])), o.set(s);
  }
  resolveConstraints() {
    const { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, i = this.constraints;
    t && om(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = mne(r.layoutBox, t) : this.constraints = !1, this.elastic = bne(n), i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && Oo((o) => {
      this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = vne(r.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !om(t))
      return !1;
    const r = t.current, { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const o = _ee(r, i.root, this.visualElement.getTransformPagePoint());
    let s = gne(i.layout.layoutBox, o);
    if (n) {
      const a = n(kee(s));
      this.hasMutatedConstraints = !!a, a && (s = bB(a));
    }
    return s;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: o, dragSnapToOrigin: s, onDragTransitionEnd: a } = this.getProps(), c = this.constraints || {}, u = Oo((f) => {
      if (!_v(f, n, this.currentDirection))
        return;
      let h = c && c[f] || {};
      s && (h = { min: 0, max: 0 });
      const m = i ? 200 : 1e6, g = i ? 40 : 1e7, b = {
        type: "inertia",
        velocity: r ? t[f] : 0,
        bounceStiffness: m,
        bounceDamping: g,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...o,
        ...h
      };
      return this.startAxisValueAnimation(f, b);
    });
    return Promise.all(u).then(a);
  }
  startAxisValueAnimation(t, n) {
    const r = this.getAxisMotionValue(t);
    return BE(this.visualElement, t), r.start(fA(t, r, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    Oo((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    Oo((t) => this.getAxisMotionValue(t).animation?.pause());
  }
  getAnimationState(t) {
    return this.getAxisMotionValue(t).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), i = r[n];
    return i || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    Oo((n) => {
      const { drag: r } = this.getProps();
      if (!_v(n, r, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, o = this.getAxisMotionValue(n);
      if (i && i.layout) {
        const { min: s, max: a } = i.layout.layoutBox[n], c = o.get() || 0;
        o.set(t[n] - Gn(s, a, 0.5) + c);
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement;
    if (!om(n) || !r || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    Oo((s) => {
      const a = this.getAxisMotionValue(s);
      if (a && this.constraints !== !1) {
        const c = a.get();
        i[s] = yne({ min: c, max: c }, this.constraints[s]);
      }
    });
    const { transformTemplate: o } = this.visualElement.getProps();
    this.visualElement.current.style.transform = o ? o({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Oo((s) => {
      if (!_v(s, t, null))
        return;
      const a = this.getAxisMotionValue(s), { min: c, max: u } = this.constraints[s];
      a.set(Gn(c, u, i[s]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    xne.set(this.visualElement, this);
    const t = this.visualElement.current, n = _m(t, "pointerdown", (c) => {
      const { drag: u, dragListener: f = !0 } = this.getProps(), h = c.target, m = h !== t && hee(h);
      u && f && !m && this.start(c);
    }), r = () => {
      const { dragConstraints: c } = this.getProps();
      om(c) && c.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: i } = this.visualElement, o = i.addEventListener("measure", r);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), _n.read(r);
    const s = Ym(window, "resize", () => this.scalePositionWithinConstraints()), a = i.addEventListener("didUpdate", (({ delta: c, hasLayoutChanged: u }) => {
      this.isDragging && u && (Oo((f) => {
        const h = this.getAxisMotionValue(f);
        h && (this.originPoint[f] += c[f].translate, h.set(h.get() + c[f].translate));
      }), this.visualElement.render());
    }));
    return () => {
      s(), n(), o(), a && a();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: o = !1, dragElastic: s = GE, dragMomentum: a = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: i,
      dragConstraints: o,
      dragElastic: s,
      dragMomentum: a
    };
  }
}
function _v(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function Sne(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class kne extends jc {
  constructor(t) {
    super(t), this.removeGroupControls = $o, this.removeListeners = $o, this.controls = new wne(t);
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || $o;
  }
  update() {
    const { dragControls: t } = this.node.getProps(), { dragControls: n } = this.node.prevProps || {};
    t !== n && (this.removeGroupControls(), t && (this.removeGroupControls = t.subscribe(this.controls)));
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners(), this.controls.isDragging || this.controls.endPanSession();
  }
}
const Ek = (e) => (t, n) => {
  e && _n.update(() => e(t, n), !1, !0);
};
class Cne extends jc {
  constructor() {
    super(...arguments), this.removePointerDownListener = $o;
  }
  onPointerDown(t) {
    this.session = new e6(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: QB(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps();
    return {
      onSessionStart: Ek(t),
      onStart: Ek(n),
      onMove: Ek(r),
      onEnd: (o, s) => {
        delete this.session, i && _n.postRender(() => i(o, s));
      }
    };
  }
  mount() {
    this.removePointerDownListener = _m(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
let _k = !1;
class Ene extends k.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: o } = t;
    o && (n.group && n.group.add(o), r && r.register && i && r.register(o), _k && o.root.didUpdate(), o.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), o.setOptions({
      ...o.options,
      layoutDependency: this.props.layoutDependency,
      onExitComplete: () => this.safeToRemove()
    })), y0.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: r, drag: i, isPresent: o } = this.props, { projection: s } = r;
    return s && (s.isPresent = o, t.layoutDependency !== n && s.setOptions({
      ...s.options,
      layoutDependency: n
    }), _k = !0, i || t.layoutDependency !== n || n === void 0 || t.isPresent !== o ? s.willUpdate() : this.safeToRemove(), t.isPresent !== o && (o ? s.promote() : s.relegate() || _n.postRender(() => {
      const a = s.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), yA.postRender(() => {
      !t.currentAnimation && t.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = t;
    _k = !0, i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function n6(e) {
  const [t, n] = HB(), r = k.useContext(GT);
  return v.jsx(Ene, { ...e, layoutGroup: r, switchLayoutGroup: k.useContext(XB), isPresent: t, safeToRemove: n });
}
const _ne = {
  pan: {
    Feature: Cne
  },
  drag: {
    Feature: kne,
    ProjectionNode: VB,
    MeasureLayout: n6
  }
};
function $P(e, t, n) {
  const { props: r } = e;
  e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const i = "onHover" + n, o = r[i];
  o && _n.postRender(() => o(t, Ig(t)));
}
class Tne extends jc {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = cee(t, (n, r) => ($P(this.node, r, "Start"), (i) => $P(this.node, i, "End"))));
  }
  unmount() {
  }
}
class Ane extends jc {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Dg(Ym(this.node.current, "focus", () => this.onFocus()), Ym(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function UP(e, t, n) {
  const { props: r } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled)
    return;
  e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const i = "onTap" + (n === "End" ? "" : n), o = r[i];
  o && _n.postRender(() => o(t, Ig(t)));
}
class Mne extends jc {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = mee(t, (n, r) => (UP(this.node, r, "Start"), (i, { success: o }) => UP(this.node, i, o ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const KE = /* @__PURE__ */ new WeakMap(), Tk = /* @__PURE__ */ new WeakMap(), Nne = (e) => {
  const t = KE.get(e.target);
  t && t(e);
}, Rne = (e) => {
  e.forEach(Nne);
};
function One({ root: e, ...t }) {
  const n = e || document;
  Tk.has(n) || Tk.set(n, {});
  const r = Tk.get(n), i = JSON.stringify(t);
  return r[i] || (r[i] = new IntersectionObserver(Rne, { root: e, ...t })), r[i];
}
function Dne(e, t, n) {
  const r = One(t);
  return KE.set(e, n), r.observe(e), () => {
    KE.delete(e), r.unobserve(e);
  };
}
const Pne = {
  some: 0,
  all: 1
};
class jne extends jc {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: o } = t, s = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof i == "number" ? i : Pne[i]
    }, a = (c) => {
      const { isIntersecting: u } = c;
      if (this.isInView === u || (this.isInView = u, o && !u && this.hasEnteredView))
        return;
      u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u);
      const { onViewportEnter: f, onViewportLeave: h } = this.node.getProps(), m = u ? f : h;
      m && m(c);
    };
    return Dne(this.node.current, s, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(Ine(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function Ine({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const zne = {
  inView: {
    Feature: jne
  },
  tap: {
    Feature: Mne
  },
  focus: {
    Feature: Ane
  },
  hover: {
    Feature: Tne
  }
}, Lne = {
  layout: {
    ProjectionNode: VB,
    MeasureLayout: n6
  }
}, Bne = {
  ...cne,
  ...zne,
  ..._ne,
  ...Lne
}, Wf = /* @__PURE__ */ ine(Bne, one);
function r6(e) {
  const t = Rg(() => Ec(e)), { isStatic: n } = k.useContext(Hx);
  if (n) {
    const [, r] = k.useState(e);
    k.useEffect(() => t.on("change", r), []);
  }
  return t;
}
function i6(e, t) {
  const n = r6(t()), r = () => n.set(t());
  return r(), KT(() => {
    const i = () => _n.preRender(r, !1, !0), o = e.map((s) => s.on("change", i));
    return () => {
      o.forEach((s) => s()), Ya(r);
    };
  }), n;
}
function $ne(e) {
  Cm.current = [], e();
  const t = i6(Cm.current, e);
  return Cm.current = void 0, t;
}
function Une(e, t, n, r) {
  if (typeof e == "function")
    return $ne(e);
  const o = typeof t == "function" ? t : gee(t, n, r);
  return Array.isArray(e) ? FP(e, o) : FP([e], ([s]) => o(s));
}
function FP(e, t) {
  const n = Rg(() => []);
  return i6(e, () => {
    n.length = 0;
    const r = e.length;
    for (let i = 0; i < r; i++)
      n[i] = e[i].get();
    return t(n);
  });
}
function TA(e) {
  return typeof e == "object" && !Array.isArray(e);
}
function o6(e, t, n, r) {
  return e == null ? [] : typeof e == "string" && TA(t) ? lB(e, n, r) : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e.filter((i) => i != null) : [e];
}
function Fne(e, t, n) {
  return e * (t + 1);
}
function VP(e, t, n, r) {
  return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : t.startsWith("<") ? Math.max(0, n + parseFloat(t.slice(1))) : r.get(t) ?? e;
}
function Vne(e, t, n) {
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    i.at > t && i.at < n && (Og(e, i), r--);
  }
}
function Hne(e, t, n, r, i, o) {
  Vne(e, i, o);
  for (let s = 0; s < t.length; s++)
    e.push({
      value: t[s],
      at: Gn(i, o, r[s]),
      easing: M4(n, s)
    });
}
function Wne(e, t) {
  for (let n = 0; n < e.length; n++)
    e[n] = e[n] / (t + 1);
}
function qne(e, t) {
  return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at;
}
const Gne = "easeInOut";
function Kne(e, { defaultTransition: t = {}, ...n } = {}, r, i) {
  const o = t.duration || 0.3, s = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), c = {}, u = /* @__PURE__ */ new Map();
  let f = 0, h = 0, m = 0;
  for (let g = 0; g < e.length; g++) {
    const b = e[g];
    if (typeof b == "string") {
      u.set(b, h);
      continue;
    } else if (!Array.isArray(b)) {
      u.set(b.name, VP(h, b.at, f, u));
      continue;
    }
    let [x, w, S = {}] = b;
    S.at !== void 0 && (h = VP(h, S.at, f, u));
    let _ = 0;
    const M = (N, P, I, O = 0, L = 0) => {
      const U = Zne(N), { delay: B = 0, times: G = q4(U), type: Y = t.type || "keyframes", repeat: he, repeatType: ie, repeatDelay: ne = 0, ...H } = P;
      let { ease: Q = t.ease || "easeOut", duration: X } = P;
      const Se = typeof B == "function" ? B(O, L) : B, W = U.length, Z = uA(Y) ? Y : i?.[Y || "keyframes"];
      if (W <= 2 && Z) {
        let ge = 100;
        if (W === 2 && Jne(U)) {
          const xe = U[1] - U[0];
          ge = Math.abs(xe);
        }
        const re = {
          ...t,
          ...H
        };
        X !== void 0 && (re.duration = /* @__PURE__ */ qs(X));
        const J = F4(re, ge, Z);
        Q = J.ease, X = J.duration;
      }
      X ?? (X = o);
      const pe = h + Se;
      G.length === 1 && G[0] === 0 && (G[1] = 1);
      const F = G.length - U.length;
      if (F > 0 && W4(G, F), U.length === 1 && U.unshift(null), he) {
        X = Fne(X, he);
        const ge = [...U], re = [...G];
        Q = Array.isArray(Q) ? [...Q] : [Q];
        const J = [...Q];
        for (let xe = 0; xe < he; xe++) {
          U.push(...ge);
          for (let be = 0; be < ge.length; be++)
            G.push(re[be] + (xe + 1)), Q.push(be === 0 ? "linear" : M4(J, be - 1));
        }
        Wne(G, he);
      }
      const ee = pe + X;
      Hne(I, U, Q, G, pe, ee), _ = Math.max(Se + X, _), m = Math.max(ee, m);
    };
    if (Fr(x)) {
      const N = HP(x, a);
      M(w, S, WP("default", N));
    } else {
      const N = o6(x, w, r, c), P = N.length;
      for (let I = 0; I < P; I++) {
        w = w, S = S;
        const O = N[I], L = HP(O, a);
        for (const U in w)
          M(w[U], Yne(S, U), WP(U, L), I, P);
      }
    }
    f = h, h += _;
  }
  return a.forEach((g, b) => {
    for (const x in g) {
      const w = g[x];
      w.sort(qne);
      const S = [], _ = [], M = [];
      for (let O = 0; O < w.length; O++) {
        const { at: L, value: U, easing: B } = w[O];
        S.push(U), _.push(/* @__PURE__ */ rh(0, m, L)), M.push(B || "easeOut");
      }
      _[0] !== 0 && (_.unshift(0), S.unshift(S[0]), M.unshift(Gne)), _[_.length - 1] !== 1 && (_.push(1), S.push(null)), s.has(b) || s.set(b, {
        keyframes: {},
        transition: {}
      });
      const N = s.get(b);
      N.keyframes[x] = S;
      const { type: P, ...I } = t;
      N.transition[x] = {
        ...I,
        duration: m,
        ease: M,
        times: _,
        ...n
      };
    }
  }), s;
}
function HP(e, t) {
  return !t.has(e) && t.set(e, {}), t.get(e);
}
function WP(e, t) {
  return t[e] || (t[e] = []), t[e];
}
function Zne(e) {
  return Array.isArray(e) ? e : [e];
}
function Yne(e, t) {
  return e && e[t] ? {
    ...e,
    ...e[t]
  } : { ...e };
}
const Xne = (e) => typeof e == "number", Jne = (e) => e.every(Xne);
function Qne(e) {
  const t = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, n = bA(e) && !hB(e) ? new NB(t) : new EB(t);
  n.mount(e), Km.set(e, n);
}
function ere(e) {
  const t = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  }, n = new Dee(t);
  n.mount(e), Km.set(e, n);
}
function tre(e, t) {
  return Fr(e) || typeof e == "number" || typeof e == "string" && !TA(t);
}
function s6(e, t, n, r) {
  const i = [];
  if (tre(e, t))
    i.push(BB(e, TA(t) && t.default || t, n && (n.default || n)));
  else {
    if (e == null)
      return i;
    const o = o6(e, t, r), s = o.length;
    for (let a = 0; a < s; a++) {
      const c = o[a], u = c instanceof Element ? Qne : ere;
      Km.has(c) || u(c);
      const f = Km.get(c), h = { ...n };
      "delay" in h && typeof h.delay == "function" && (h.delay = h.delay(a, s)), i.push(...mA(f, { ...t, transition: h }, {}));
    }
  }
  return i;
}
function nre(e, t, n) {
  const r = [], i = e.map((s) => {
    if (Array.isArray(s) && typeof s[0] == "function") {
      const a = s[0], c = Ec(0);
      return c.on("change", a), s.length === 1 ? [c, [0, 1]] : s.length === 2 ? [c, [0, 1], s[1]] : [c, s[1], s[2]];
    }
    return s;
  });
  return Kne(i, t, n, { spring: Gm }).forEach(({ keyframes: s, transition: a }, c) => {
    r.push(...s6(c, s, a));
  }), r;
}
function rre(e) {
  return Array.isArray(e) && e.some(Array.isArray);
}
function ire(e = {}) {
  const { scope: t, reduceMotion: n } = e;
  function r(i, o, s) {
    let a = [], c;
    if (rre(i))
      a = nre(i, n !== void 0 ? { reduceMotion: n, ...o } : o, t);
    else {
      const { onComplete: f, ...h } = s || {};
      typeof f == "function" && (c = f), a = s6(i, o, n !== void 0 ? { reduceMotion: n, ...h } : h, t);
    }
    const u = new RQ(a);
    return c && u.finished.then(c), t && (t.animations.push(u), u.finished.then(() => {
      Og(t.animations, u);
    })), u;
  }
  return r;
}
const ore = ire();
var sre = /* @__PURE__ */ Symbol.for("react.lazy"), nb = Ix[" use ".trim().toString()];
function are(e) {
  return typeof e == "object" && e !== null && "then" in e;
}
function a6(e) {
  return e != null && typeof e == "object" && "$$typeof" in e && e.$$typeof === sre && "_payload" in e && are(e._payload);
}
// @__NO_SIDE_EFFECTS__
function qx(e) {
  const t = /* @__PURE__ */ lre(e), n = k.forwardRef((r, i) => {
    let { children: o, ...s } = r;
    a6(o) && typeof nb == "function" && (o = nb(o._payload));
    const a = k.Children.toArray(o), c = a.find(ure);
    if (c) {
      const u = c.props.children, f = a.map((h) => h === c ? k.Children.count(u) > 1 ? k.Children.only(null) : k.isValidElement(u) ? u.props.children : null : h);
      return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: k.isValidElement(u) ? k.cloneElement(u, void 0, f) : null });
    }
    return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: o });
  });
  return n.displayName = `${e}.Slot`, n;
}
var l6 = /* @__PURE__ */ qx("Slot");
// @__NO_SIDE_EFFECTS__
function lre(e) {
  const t = k.forwardRef((n, r) => {
    let { children: i, ...o } = n;
    if (a6(i) && typeof nb == "function" && (i = nb(i._payload)), k.isValidElement(i)) {
      const s = fre(i), a = dre(o, i.props);
      return i.type !== k.Fragment && (a.ref = r ? nl(r, s) : s), k.cloneElement(i, a);
    }
    return k.Children.count(i) > 1 ? k.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var cre = /* @__PURE__ */ Symbol("radix.slottable");
function ure(e) {
  return k.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === cre;
}
function dre(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...a) => {
      const c = o(...a);
      return i(...a), c;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function fre(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
const qP = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, GP = pc, AA = (e, t) => (n) => {
  var r;
  if (t?.variants == null) return GP(e, n?.class, n?.className);
  const { variants: i, defaultVariants: o } = t, s = Object.keys(i).map((u) => {
    const f = n?.[u], h = o?.[u];
    if (f === null) return null;
    const m = qP(f) || qP(h);
    return i[u][m];
  }), a = n && Object.entries(n).reduce((u, f) => {
    let [h, m] = f;
    return m === void 0 || (u[h] = m), u;
  }, {}), c = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((u, f) => {
    let { class: h, className: m, ...g } = f;
    return Object.entries(g).every((b) => {
      let [x, w] = b;
      return Array.isArray(w) ? w.includes({
        ...o,
        ...a
      }[x]) : {
        ...o,
        ...a
      }[x] === w;
    }) ? [
      ...u,
      h,
      m
    ] : u;
  }, []);
  return GP(e, s, c, n?.class, n?.className);
};
function hre({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    Zs,
    {
      role: "status",
      "aria-label": "Loading",
      className: at("size-4 animate-spin", e),
      ...t
    }
  );
}
const pre = AA(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
function Ht({
  className: e,
  variant: t,
  size: n,
  asChild: r = !1,
  isLoading: i = !1,
  ...o
}) {
  const s = r ? l6 : "button";
  return /* @__PURE__ */ v.jsxs(
    s,
    {
      "data-slot": "button",
      className: at(pre({ variant: t, size: n, className: e })),
      ...o,
      children: [
        o.children,
        " ",
        i && /* @__PURE__ */ v.jsx(hre, {})
      ]
    }
  );
}
function mre(e, t = globalThis?.document) {
  const n = Dr(e);
  k.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var gre = "DismissableLayer", ZE = "dismissableLayer.update", yre = "dismissableLayer.pointerDownOutside", vre = "dismissableLayer.focusOutside", KP, c6 = k.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), zg = k.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: o,
      onInteractOutside: s,
      onDismiss: a,
      ...c
    } = e, u = k.useContext(c6), [f, h] = k.useState(null), m = f?.ownerDocument ?? globalThis?.document, [, g] = k.useState({}), b = Ft(t, (O) => h(O)), x = Array.from(u.layers), [w] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), S = x.indexOf(w), _ = f ? x.indexOf(f) : -1, M = u.layersWithOutsidePointerEventsDisabled.size > 0, N = _ >= S, P = wre((O) => {
      const L = O.target, U = [...u.branches].some((B) => B.contains(L));
      !N || U || (i?.(O), s?.(O), O.defaultPrevented || a?.());
    }, m), I = Sre((O) => {
      const L = O.target;
      [...u.branches].some((B) => B.contains(L)) || (o?.(O), s?.(O), O.defaultPrevented || a?.());
    }, m);
    return mre((O) => {
      _ === u.layers.size - 1 && (r?.(O), !O.defaultPrevented && a && (O.preventDefault(), a()));
    }, m), k.useEffect(() => {
      if (f)
        return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (KP = m.body.style.pointerEvents, m.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(f)), u.layers.add(f), ZP(), () => {
          n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (m.body.style.pointerEvents = KP);
        };
    }, [f, m, n, u]), k.useEffect(() => () => {
      f && (u.layers.delete(f), u.layersWithOutsidePointerEventsDisabled.delete(f), ZP());
    }, [f, u]), k.useEffect(() => {
      const O = () => g({});
      return document.addEventListener(ZE, O), () => document.removeEventListener(ZE, O);
    }, []), /* @__PURE__ */ v.jsx(
      Et.div,
      {
        ...c,
        ref: b,
        style: {
          pointerEvents: M ? N ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Ye(e.onFocusCapture, I.onFocusCapture),
        onBlurCapture: Ye(e.onBlurCapture, I.onBlurCapture),
        onPointerDownCapture: Ye(
          e.onPointerDownCapture,
          P.onPointerDownCapture
        )
      }
    );
  }
);
zg.displayName = gre;
var bre = "DismissableLayerBranch", xre = k.forwardRef((e, t) => {
  const n = k.useContext(c6), r = k.useRef(null), i = Ft(t, r);
  return k.useEffect(() => {
    const o = r.current;
    if (o)
      return n.branches.add(o), () => {
        n.branches.delete(o);
      };
  }, [n.branches]), /* @__PURE__ */ v.jsx(Et.div, { ...e, ref: i });
});
xre.displayName = bre;
function wre(e, t = globalThis?.document) {
  const n = Dr(e), r = k.useRef(!1), i = k.useRef(() => {
  });
  return k.useEffect(() => {
    const o = (a) => {
      if (a.target && !r.current) {
        let c = function() {
          u6(
            yre,
            n,
            u,
            { discrete: !0 }
          );
        };
        const u = { originalEvent: a };
        a.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = c, t.addEventListener("click", i.current, { once: !0 })) : c();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      t.addEventListener("pointerdown", o);
    }, 0);
    return () => {
      window.clearTimeout(s), t.removeEventListener("pointerdown", o), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function Sre(e, t = globalThis?.document) {
  const n = Dr(e), r = k.useRef(!1);
  return k.useEffect(() => {
    const i = (o) => {
      o.target && !r.current && u6(vre, n, { originalEvent: o }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function ZP() {
  const e = new CustomEvent(ZE);
  document.dispatchEvent(e);
}
function u6(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? U3(i, o) : i.dispatchEvent(o);
}
var kre = Ix[" useId ".trim().toString()] || (() => {
}), Cre = 0;
function Uo(e) {
  const [t, n] = k.useState(kre());
  return Er(() => {
    n((r) => r ?? String(Cre++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
const Ere = ["top", "right", "bottom", "left"], _c = Math.min, co = Math.max, rb = Math.round, Tv = Math.floor, Ks = (e) => ({
  x: e,
  y: e
}), _re = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Tre = {
  start: "end",
  end: "start"
};
function YE(e, t, n) {
  return co(e, _c(t, n));
}
function Xa(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Ja(e) {
  return e.split("-")[0];
}
function Th(e) {
  return e.split("-")[1];
}
function MA(e) {
  return e === "x" ? "y" : "x";
}
function NA(e) {
  return e === "y" ? "height" : "width";
}
const Are = /* @__PURE__ */ new Set(["top", "bottom"]);
function Hs(e) {
  return Are.has(Ja(e)) ? "y" : "x";
}
function RA(e) {
  return MA(Hs(e));
}
function Mre(e, t, n) {
  n === void 0 && (n = !1);
  const r = Th(e), i = RA(e), o = NA(i);
  let s = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (s = ib(s)), [s, ib(s)];
}
function Nre(e) {
  const t = ib(e);
  return [XE(e), t, XE(t)];
}
function XE(e) {
  return e.replace(/start|end/g, (t) => Tre[t]);
}
const YP = ["left", "right"], XP = ["right", "left"], Rre = ["top", "bottom"], Ore = ["bottom", "top"];
function Dre(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? XP : YP : t ? YP : XP;
    case "left":
    case "right":
      return t ? Rre : Ore;
    default:
      return [];
  }
}
function Pre(e, t, n, r) {
  const i = Th(e);
  let o = Dre(Ja(e), n === "start", r);
  return i && (o = o.map((s) => s + "-" + i), t && (o = o.concat(o.map(XE)))), o;
}
function ib(e) {
  return e.replace(/left|right|bottom|top/g, (t) => _re[t]);
}
function jre(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function d6(e) {
  return typeof e != "number" ? jre(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function ob(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
function JP(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const o = Hs(t), s = RA(t), a = NA(s), c = Ja(t), u = o === "y", f = r.x + r.width / 2 - i.width / 2, h = r.y + r.height / 2 - i.height / 2, m = r[a] / 2 - i[a] / 2;
  let g;
  switch (c) {
    case "top":
      g = {
        x: f,
        y: r.y - i.height
      };
      break;
    case "bottom":
      g = {
        x: f,
        y: r.y + r.height
      };
      break;
    case "right":
      g = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      g = {
        x: r.x - i.width,
        y: h
      };
      break;
    default:
      g = {
        x: r.x,
        y: r.y
      };
  }
  switch (Th(t)) {
    case "start":
      g[s] -= m * (n && u ? -1 : 1);
      break;
    case "end":
      g[s] += m * (n && u ? -1 : 1);
      break;
  }
  return g;
}
async function Ire(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: o,
    rects: s,
    elements: a,
    strategy: c
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: h = "floating",
    altBoundary: m = !1,
    padding: g = 0
  } = Xa(t, e), b = d6(g), w = a[m ? h === "floating" ? "reference" : "floating" : h], S = ob(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(w))) == null || n ? w : w.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: f,
    strategy: c
  })), _ = h === "floating" ? {
    x: r,
    y: i,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, M = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), N = await (o.isElement == null ? void 0 : o.isElement(M)) ? await (o.getScale == null ? void 0 : o.getScale(M)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, P = ob(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: _,
    offsetParent: M,
    strategy: c
  }) : _);
  return {
    top: (S.top - P.top + b.top) / N.y,
    bottom: (P.bottom - S.bottom + b.bottom) / N.y,
    left: (S.left - P.left + b.left) / N.x,
    right: (P.right - S.right + b.right) / N.x
  };
}
const zre = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: s
  } = n, a = o.filter(Boolean), c = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let u = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: f,
    y: h
  } = JP(u, r, c), m = r, g = {}, b = 0;
  for (let w = 0; w < a.length; w++) {
    var x;
    const {
      name: S,
      fn: _
    } = a[w], {
      x: M,
      y: N,
      data: P,
      reset: I
    } = await _({
      x: f,
      y: h,
      initialPlacement: r,
      placement: m,
      strategy: i,
      middlewareData: g,
      rects: u,
      platform: {
        ...s,
        detectOverflow: (x = s.detectOverflow) != null ? x : Ire
      },
      elements: {
        reference: e,
        floating: t
      }
    });
    f = M ?? f, h = N ?? h, g = {
      ...g,
      [S]: {
        ...g[S],
        ...P
      }
    }, I && b <= 50 && (b++, typeof I == "object" && (I.placement && (m = I.placement), I.rects && (u = I.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : I.rects), {
      x: f,
      y: h
    } = JP(u, m, c)), w = -1);
  }
  return {
    x: f,
    y: h,
    placement: m,
    strategy: i,
    middlewareData: g
  };
}, Lre = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: o,
      platform: s,
      elements: a,
      middlewareData: c
    } = t, {
      element: u,
      padding: f = 0
    } = Xa(e, t) || {};
    if (u == null)
      return {};
    const h = d6(f), m = {
      x: n,
      y: r
    }, g = RA(i), b = NA(g), x = await s.getDimensions(u), w = g === "y", S = w ? "top" : "left", _ = w ? "bottom" : "right", M = w ? "clientHeight" : "clientWidth", N = o.reference[b] + o.reference[g] - m[g] - o.floating[b], P = m[g] - o.reference[g], I = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));
    let O = I ? I[M] : 0;
    (!O || !await (s.isElement == null ? void 0 : s.isElement(I))) && (O = a.floating[M] || o.floating[b]);
    const L = N / 2 - P / 2, U = O / 2 - x[b] / 2 - 1, B = _c(h[S], U), G = _c(h[_], U), Y = B, he = O - x[b] - G, ie = O / 2 - x[b] / 2 + L, ne = YE(Y, ie, he), H = !c.arrow && Th(i) != null && ie !== ne && o.reference[b] / 2 - (ie < Y ? B : G) - x[b] / 2 < 0, Q = H ? ie < Y ? ie - Y : ie - he : 0;
    return {
      [g]: m[g] + Q,
      data: {
        [g]: ne,
        centerOffset: ie - ne - Q,
        ...H && {
          alignmentOffset: Q
        }
      },
      reset: H
    };
  }
}), Bre = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        middlewareData: o,
        rects: s,
        initialPlacement: a,
        platform: c,
        elements: u
      } = t, {
        mainAxis: f = !0,
        crossAxis: h = !0,
        fallbackPlacements: m,
        fallbackStrategy: g = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: x = !0,
        ...w
      } = Xa(e, t);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const S = Ja(i), _ = Hs(a), M = Ja(a) === a, N = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)), P = m || (M || !x ? [ib(a)] : Nre(a)), I = b !== "none";
      !m && I && P.push(...Pre(a, x, b, N));
      const O = [a, ...P], L = await c.detectOverflow(t, w), U = [];
      let B = ((r = o.flip) == null ? void 0 : r.overflows) || [];
      if (f && U.push(L[S]), h) {
        const ie = Mre(i, s, N);
        U.push(L[ie[0]], L[ie[1]]);
      }
      if (B = [...B, {
        placement: i,
        overflows: U
      }], !U.every((ie) => ie <= 0)) {
        var G, Y;
        const ie = (((G = o.flip) == null ? void 0 : G.index) || 0) + 1, ne = O[ie];
        if (ne && (!(h === "alignment" ? _ !== Hs(ne) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        B.every((X) => Hs(X.placement) === _ ? X.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ie,
              overflows: B
            },
            reset: {
              placement: ne
            }
          };
        let H = (Y = B.filter((Q) => Q.overflows[0] <= 0).sort((Q, X) => Q.overflows[1] - X.overflows[1])[0]) == null ? void 0 : Y.placement;
        if (!H)
          switch (g) {
            case "bestFit": {
              var he;
              const Q = (he = B.filter((X) => {
                if (I) {
                  const Se = Hs(X.placement);
                  return Se === _ || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Se === "y";
                }
                return !0;
              }).map((X) => [X.placement, X.overflows.filter((Se) => Se > 0).reduce((Se, W) => Se + W, 0)]).sort((X, Se) => X[1] - Se[1])[0]) == null ? void 0 : he[0];
              Q && (H = Q);
              break;
            }
            case "initialPlacement":
              H = a;
              break;
          }
        if (i !== H)
          return {
            reset: {
              placement: H
            }
          };
      }
      return {};
    }
  };
};
function QP(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function ej(e) {
  return Ere.some((t) => e[t] >= 0);
}
const $re = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n,
        platform: r
      } = t, {
        strategy: i = "referenceHidden",
        ...o
      } = Xa(e, t);
      switch (i) {
        case "referenceHidden": {
          const s = await r.detectOverflow(t, {
            ...o,
            elementContext: "reference"
          }), a = QP(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: a,
              referenceHidden: ej(a)
            }
          };
        }
        case "escaped": {
          const s = await r.detectOverflow(t, {
            ...o,
            altBoundary: !0
          }), a = QP(s, n.floating);
          return {
            data: {
              escapedOffsets: a,
              escaped: ej(a)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, f6 = /* @__PURE__ */ new Set(["left", "top"]);
async function Ure(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), s = Ja(n), a = Th(n), c = Hs(n) === "y", u = f6.has(s) ? -1 : 1, f = o && c ? -1 : 1, h = Xa(t, e);
  let {
    mainAxis: m,
    crossAxis: g,
    alignmentAxis: b
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return a && typeof b == "number" && (g = a === "end" ? b * -1 : b), c ? {
    x: g * f,
    y: m * u
  } : {
    x: m * u,
    y: g * f
  };
}
const Fre = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: o,
        placement: s,
        middlewareData: a
      } = t, c = await Ure(t, e);
      return s === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
        x: i + c.x,
        y: o + c.y,
        data: {
          ...c,
          placement: s
        }
      };
    }
  };
}, Vre = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i,
        platform: o
      } = t, {
        mainAxis: s = !0,
        crossAxis: a = !1,
        limiter: c = {
          fn: (S) => {
            let {
              x: _,
              y: M
            } = S;
            return {
              x: _,
              y: M
            };
          }
        },
        ...u
      } = Xa(e, t), f = {
        x: n,
        y: r
      }, h = await o.detectOverflow(t, u), m = Hs(Ja(i)), g = MA(m);
      let b = f[g], x = f[m];
      if (s) {
        const S = g === "y" ? "top" : "left", _ = g === "y" ? "bottom" : "right", M = b + h[S], N = b - h[_];
        b = YE(M, b, N);
      }
      if (a) {
        const S = m === "y" ? "top" : "left", _ = m === "y" ? "bottom" : "right", M = x + h[S], N = x - h[_];
        x = YE(M, x, N);
      }
      const w = c.fn({
        ...t,
        [g]: b,
        [m]: x
      });
      return {
        ...w,
        data: {
          x: w.x - n,
          y: w.y - r,
          enabled: {
            [g]: s,
            [m]: a
          }
        }
      };
    }
  };
}, Hre = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: i,
        rects: o,
        middlewareData: s
      } = t, {
        offset: a = 0,
        mainAxis: c = !0,
        crossAxis: u = !0
      } = Xa(e, t), f = {
        x: n,
        y: r
      }, h = Hs(i), m = MA(h);
      let g = f[m], b = f[h];
      const x = Xa(a, t), w = typeof x == "number" ? {
        mainAxis: x,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...x
      };
      if (c) {
        const M = m === "y" ? "height" : "width", N = o.reference[m] - o.floating[M] + w.mainAxis, P = o.reference[m] + o.reference[M] - w.mainAxis;
        g < N ? g = N : g > P && (g = P);
      }
      if (u) {
        var S, _;
        const M = m === "y" ? "width" : "height", N = f6.has(Ja(i)), P = o.reference[h] - o.floating[M] + (N && ((S = s.offset) == null ? void 0 : S[h]) || 0) + (N ? 0 : w.crossAxis), I = o.reference[h] + o.reference[M] + (N ? 0 : ((_ = s.offset) == null ? void 0 : _[h]) || 0) - (N ? w.crossAxis : 0);
        b < P ? b = P : b > I && (b = I);
      }
      return {
        [m]: g,
        [h]: b
      };
    }
  };
}, Wre = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        rects: o,
        platform: s,
        elements: a
      } = t, {
        apply: c = () => {
        },
        ...u
      } = Xa(e, t), f = await s.detectOverflow(t, u), h = Ja(i), m = Th(i), g = Hs(i) === "y", {
        width: b,
        height: x
      } = o.floating;
      let w, S;
      h === "top" || h === "bottom" ? (w = h, S = m === (await (s.isRTL == null ? void 0 : s.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (S = h, w = m === "end" ? "top" : "bottom");
      const _ = x - f.top - f.bottom, M = b - f.left - f.right, N = _c(x - f[w], _), P = _c(b - f[S], M), I = !t.middlewareData.shift;
      let O = N, L = P;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (L = M), (r = t.middlewareData.shift) != null && r.enabled.y && (O = _), I && !m) {
        const B = co(f.left, 0), G = co(f.right, 0), Y = co(f.top, 0), he = co(f.bottom, 0);
        g ? L = b - 2 * (B !== 0 || G !== 0 ? B + G : co(f.left, f.right)) : O = x - 2 * (Y !== 0 || he !== 0 ? Y + he : co(f.top, f.bottom));
      }
      await c({
        ...t,
        availableWidth: L,
        availableHeight: O
      });
      const U = await s.getDimensions(a.floating);
      return b !== U.width || x !== U.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Gx() {
  return typeof window < "u";
}
function Ah(e) {
  return h6(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function ho(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function na(e) {
  var t;
  return (t = (h6(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function h6(e) {
  return Gx() ? e instanceof Node || e instanceof ho(e).Node : !1;
}
function fs(e) {
  return Gx() ? e instanceof Element || e instanceof ho(e).Element : !1;
}
function Xs(e) {
  return Gx() ? e instanceof HTMLElement || e instanceof ho(e).HTMLElement : !1;
}
function tj(e) {
  return !Gx() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof ho(e).ShadowRoot;
}
const qre = /* @__PURE__ */ new Set(["inline", "contents"]);
function Lg(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = hs(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !qre.has(i);
}
const Gre = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Kre(e) {
  return Gre.has(Ah(e));
}
const Zre = [":popover-open", ":modal"];
function Kx(e) {
  return Zre.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const Yre = ["transform", "translate", "scale", "rotate", "perspective"], Xre = ["transform", "translate", "scale", "rotate", "perspective", "filter"], Jre = ["paint", "layout", "strict", "content"];
function OA(e) {
  const t = DA(), n = fs(e) ? hs(e) : e;
  return Yre.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || Xre.some((r) => (n.willChange || "").includes(r)) || Jre.some((r) => (n.contain || "").includes(r));
}
function Qre(e) {
  let t = Tc(e);
  for (; Xs(t) && !ih(t); ) {
    if (OA(t))
      return t;
    if (Kx(t))
      return null;
    t = Tc(t);
  }
  return null;
}
function DA() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const eie = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function ih(e) {
  return eie.has(Ah(e));
}
function hs(e) {
  return ho(e).getComputedStyle(e);
}
function Zx(e) {
  return fs(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Tc(e) {
  if (Ah(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    tj(e) && e.host || // Fallback.
    na(e)
  );
  return tj(t) ? t.host : t;
}
function p6(e) {
  const t = Tc(e);
  return ih(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Xs(t) && Lg(t) ? t : p6(t);
}
function Xm(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = p6(e), o = i === ((r = e.ownerDocument) == null ? void 0 : r.body), s = ho(i);
  if (o) {
    const a = JE(s);
    return t.concat(s, s.visualViewport || [], Lg(i) ? i : [], a && n ? Xm(a) : []);
  }
  return t.concat(i, Xm(i, [], n));
}
function JE(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function m6(e) {
  const t = hs(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = Xs(e), o = i ? e.offsetWidth : n, s = i ? e.offsetHeight : r, a = rb(n) !== o || rb(r) !== s;
  return a && (n = o, r = s), {
    width: n,
    height: r,
    $: a
  };
}
function PA(e) {
  return fs(e) ? e : e.contextElement;
}
function qf(e) {
  const t = PA(e);
  if (!Xs(t))
    return Ks(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = m6(t);
  let s = (o ? rb(n.width) : n.width) / r, a = (o ? rb(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const tie = /* @__PURE__ */ Ks(0);
function g6(e) {
  const t = ho(e);
  return !DA() || !t.visualViewport ? tie : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function nie(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== ho(e) ? !1 : t;
}
function Zu(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), o = PA(e);
  let s = Ks(1);
  t && (r ? fs(r) && (s = qf(r)) : s = qf(e));
  const a = nie(o, n, r) ? g6(o) : Ks(0);
  let c = (i.left + a.x) / s.x, u = (i.top + a.y) / s.y, f = i.width / s.x, h = i.height / s.y;
  if (o) {
    const m = ho(o), g = r && fs(r) ? ho(r) : r;
    let b = m, x = JE(b);
    for (; x && r && g !== b; ) {
      const w = qf(x), S = x.getBoundingClientRect(), _ = hs(x), M = S.left + (x.clientLeft + parseFloat(_.paddingLeft)) * w.x, N = S.top + (x.clientTop + parseFloat(_.paddingTop)) * w.y;
      c *= w.x, u *= w.y, f *= w.x, h *= w.y, c += M, u += N, b = ho(x), x = JE(b);
    }
  }
  return ob({
    width: f,
    height: h,
    x: c,
    y: u
  });
}
function Yx(e, t) {
  const n = Zx(e).scrollLeft;
  return t ? t.left + n : Zu(na(e)).left + n;
}
function y6(e, t) {
  const n = e.getBoundingClientRect(), r = n.left + t.scrollLeft - Yx(e, n), i = n.top + t.scrollTop;
  return {
    x: r,
    y: i
  };
}
function rie(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const o = i === "fixed", s = na(r), a = t ? Kx(t.floating) : !1;
  if (r === s || a && o)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = Ks(1);
  const f = Ks(0), h = Xs(r);
  if ((h || !h && !o) && ((Ah(r) !== "body" || Lg(s)) && (c = Zx(r)), Xs(r))) {
    const g = Zu(r);
    u = qf(r), f.x = g.x + r.clientLeft, f.y = g.y + r.clientTop;
  }
  const m = s && !h && !o ? y6(s, c) : Ks(0);
  return {
    width: n.width * u.x,
    height: n.height * u.y,
    x: n.x * u.x - c.scrollLeft * u.x + f.x + m.x,
    y: n.y * u.y - c.scrollTop * u.y + f.y + m.y
  };
}
function iie(e) {
  return Array.from(e.getClientRects());
}
function oie(e) {
  const t = na(e), n = Zx(e), r = e.ownerDocument.body, i = co(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = co(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + Yx(e);
  const a = -n.scrollTop;
  return hs(r).direction === "rtl" && (s += co(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: o,
    x: s,
    y: a
  };
}
const nj = 25;
function sie(e, t) {
  const n = ho(e), r = na(e), i = n.visualViewport;
  let o = r.clientWidth, s = r.clientHeight, a = 0, c = 0;
  if (i) {
    o = i.width, s = i.height;
    const f = DA();
    (!f || f && t === "fixed") && (a = i.offsetLeft, c = i.offsetTop);
  }
  const u = Yx(r);
  if (u <= 0) {
    const f = r.ownerDocument, h = f.body, m = getComputedStyle(h), g = f.compatMode === "CSS1Compat" && parseFloat(m.marginLeft) + parseFloat(m.marginRight) || 0, b = Math.abs(r.clientWidth - h.clientWidth - g);
    b <= nj && (o -= b);
  } else u <= nj && (o += u);
  return {
    width: o,
    height: s,
    x: a,
    y: c
  };
}
const aie = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function lie(e, t) {
  const n = Zu(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = Xs(e) ? qf(e) : Ks(1), s = e.clientWidth * o.x, a = e.clientHeight * o.y, c = i * o.x, u = r * o.y;
  return {
    width: s,
    height: a,
    x: c,
    y: u
  };
}
function rj(e, t, n) {
  let r;
  if (t === "viewport")
    r = sie(e, n);
  else if (t === "document")
    r = oie(na(e));
  else if (fs(t))
    r = lie(t, n);
  else {
    const i = g6(e);
    r = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return ob(r);
}
function v6(e, t) {
  const n = Tc(e);
  return n === t || !fs(n) || ih(n) ? !1 : hs(n).position === "fixed" || v6(n, t);
}
function cie(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Xm(e, [], !1).filter((a) => fs(a) && Ah(a) !== "body"), i = null;
  const o = hs(e).position === "fixed";
  let s = o ? Tc(e) : e;
  for (; fs(s) && !ih(s); ) {
    const a = hs(s), c = OA(s);
    !c && a.position === "fixed" && (i = null), (o ? !c && !i : !c && a.position === "static" && !!i && aie.has(i.position) || Lg(s) && !c && v6(e, s)) ? r = r.filter((f) => f !== s) : i = a, s = Tc(s);
  }
  return t.set(e, r), r;
}
function uie(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const s = [...n === "clippingAncestors" ? Kx(t) ? [] : cie(t, this._c) : [].concat(n), r], a = s[0], c = s.reduce((u, f) => {
    const h = rj(t, f, i);
    return u.top = co(h.top, u.top), u.right = _c(h.right, u.right), u.bottom = _c(h.bottom, u.bottom), u.left = co(h.left, u.left), u;
  }, rj(t, a, i));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function die(e) {
  const {
    width: t,
    height: n
  } = m6(e);
  return {
    width: t,
    height: n
  };
}
function fie(e, t, n) {
  const r = Xs(t), i = na(t), o = n === "fixed", s = Zu(e, !0, o, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = Ks(0);
  function u() {
    c.x = Yx(i);
  }
  if (r || !r && !o)
    if ((Ah(t) !== "body" || Lg(i)) && (a = Zx(t)), r) {
      const g = Zu(t, !0, o, t);
      c.x = g.x + t.clientLeft, c.y = g.y + t.clientTop;
    } else i && u();
  o && !r && i && u();
  const f = i && !r && !o ? y6(i, a) : Ks(0), h = s.left + a.scrollLeft - c.x - f.x, m = s.top + a.scrollTop - c.y - f.y;
  return {
    x: h,
    y: m,
    width: s.width,
    height: s.height
  };
}
function Ak(e) {
  return hs(e).position === "static";
}
function ij(e, t) {
  if (!Xs(e) || hs(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return na(e) === n && (n = n.ownerDocument.body), n;
}
function b6(e, t) {
  const n = ho(e);
  if (Kx(e))
    return n;
  if (!Xs(e)) {
    let i = Tc(e);
    for (; i && !ih(i); ) {
      if (fs(i) && !Ak(i))
        return i;
      i = Tc(i);
    }
    return n;
  }
  let r = ij(e, t);
  for (; r && Kre(r) && Ak(r); )
    r = ij(r, t);
  return r && ih(r) && Ak(r) && !OA(r) ? n : r || Qre(e) || n;
}
const hie = async function(e) {
  const t = this.getOffsetParent || b6, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: fie(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function pie(e) {
  return hs(e).direction === "rtl";
}
const mie = {
  convertOffsetParentRelativeRectToViewportRelativeRect: rie,
  getDocumentElement: na,
  getClippingRect: uie,
  getOffsetParent: b6,
  getElementRects: hie,
  getClientRects: iie,
  getDimensions: die,
  getScale: qf,
  isElement: fs,
  isRTL: pie
};
function x6(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function gie(e, t) {
  let n = null, r;
  const i = na(e);
  function o() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
  }
  function s(a, c) {
    a === void 0 && (a = !1), c === void 0 && (c = 1), o();
    const u = e.getBoundingClientRect(), {
      left: f,
      top: h,
      width: m,
      height: g
    } = u;
    if (a || t(), !m || !g)
      return;
    const b = Tv(h), x = Tv(i.clientWidth - (f + m)), w = Tv(i.clientHeight - (h + g)), S = Tv(f), M = {
      rootMargin: -b + "px " + -x + "px " + -w + "px " + -S + "px",
      threshold: co(0, _c(1, c)) || 1
    };
    let N = !0;
    function P(I) {
      const O = I[0].intersectionRatio;
      if (O !== c) {
        if (!N)
          return s();
        O ? s(!1, O) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      O === 1 && !x6(u, e.getBoundingClientRect()) && s(), N = !1;
    }
    try {
      n = new IntersectionObserver(P, {
        ...M,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(P, M);
    }
    n.observe(e);
  }
  return s(!0), o;
}
function yie(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, u = PA(e), f = i || o ? [...u ? Xm(u) : [], ...Xm(t)] : [];
  f.forEach((S) => {
    i && S.addEventListener("scroll", n, {
      passive: !0
    }), o && S.addEventListener("resize", n);
  });
  const h = u && a ? gie(u, n) : null;
  let m = -1, g = null;
  s && (g = new ResizeObserver((S) => {
    let [_] = S;
    _ && _.target === u && g && (g.unobserve(t), cancelAnimationFrame(m), m = requestAnimationFrame(() => {
      var M;
      (M = g) == null || M.observe(t);
    })), n();
  }), u && !c && g.observe(u), g.observe(t));
  let b, x = c ? Zu(e) : null;
  c && w();
  function w() {
    const S = Zu(e);
    x && !x6(x, S) && n(), x = S, b = requestAnimationFrame(w);
  }
  return n(), () => {
    var S;
    f.forEach((_) => {
      i && _.removeEventListener("scroll", n), o && _.removeEventListener("resize", n);
    }), h?.(), (S = g) == null || S.disconnect(), g = null, c && cancelAnimationFrame(b);
  };
}
const vie = Fre, bie = Vre, xie = Bre, wie = Wre, Sie = $re, oj = Lre, kie = Hre, Cie = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: mie,
    ...n
  }, o = {
    ...i.platform,
    _c: r
  };
  return zre(e, t, {
    ...i,
    platform: o
  });
};
var Eie = typeof document < "u", _ie = function() {
}, v0 = Eie ? k.useLayoutEffect : _ie;
function sb(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!sb(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && e.$$typeof) && !sb(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function w6(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function sj(e, t) {
  const n = w6(e);
  return Math.round(t * n) / n;
}
function Mk(e) {
  const t = k.useRef(e);
  return v0(() => {
    t.current = e;
  }), t;
}
function Tie(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: o,
      floating: s
    } = {},
    transform: a = !0,
    whileElementsMounted: c,
    open: u
  } = e, [f, h] = k.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [m, g] = k.useState(r);
  sb(m, r) || g(r);
  const [b, x] = k.useState(null), [w, S] = k.useState(null), _ = k.useCallback((X) => {
    X !== I.current && (I.current = X, x(X));
  }, []), M = k.useCallback((X) => {
    X !== O.current && (O.current = X, S(X));
  }, []), N = o || b, P = s || w, I = k.useRef(null), O = k.useRef(null), L = k.useRef(f), U = c != null, B = Mk(c), G = Mk(i), Y = Mk(u), he = k.useCallback(() => {
    if (!I.current || !O.current)
      return;
    const X = {
      placement: t,
      strategy: n,
      middleware: m
    };
    G.current && (X.platform = G.current), Cie(I.current, O.current, X).then((Se) => {
      const W = {
        ...Se,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: Y.current !== !1
      };
      ie.current && !sb(L.current, W) && (L.current = W, tl.flushSync(() => {
        h(W);
      }));
    });
  }, [m, t, n, G, Y]);
  v0(() => {
    u === !1 && L.current.isPositioned && (L.current.isPositioned = !1, h((X) => ({
      ...X,
      isPositioned: !1
    })));
  }, [u]);
  const ie = k.useRef(!1);
  v0(() => (ie.current = !0, () => {
    ie.current = !1;
  }), []), v0(() => {
    if (N && (I.current = N), P && (O.current = P), N && P) {
      if (B.current)
        return B.current(N, P, he);
      he();
    }
  }, [N, P, he, B, U]);
  const ne = k.useMemo(() => ({
    reference: I,
    floating: O,
    setReference: _,
    setFloating: M
  }), [_, M]), H = k.useMemo(() => ({
    reference: N,
    floating: P
  }), [N, P]), Q = k.useMemo(() => {
    const X = {
      position: n,
      left: 0,
      top: 0
    };
    if (!H.floating)
      return X;
    const Se = sj(H.floating, f.x), W = sj(H.floating, f.y);
    return a ? {
      ...X,
      transform: "translate(" + Se + "px, " + W + "px)",
      ...w6(H.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: Se,
      top: W
    };
  }, [n, a, H.floating, f.x, f.y]);
  return k.useMemo(() => ({
    ...f,
    update: he,
    refs: ne,
    elements: H,
    floatingStyles: Q
  }), [f, he, ne, H, Q]);
}
const Aie = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: i
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? oj({
        element: r.current,
        padding: i
      }).fn(n) : {} : r ? oj({
        element: r,
        padding: i
      }).fn(n) : {};
    }
  };
}, Mie = (e, t) => ({
  ...vie(e),
  options: [e, t]
}), Nie = (e, t) => ({
  ...bie(e),
  options: [e, t]
}), Rie = (e, t) => ({
  ...kie(e),
  options: [e, t]
}), Oie = (e, t) => ({
  ...xie(e),
  options: [e, t]
}), Die = (e, t) => ({
  ...wie(e),
  options: [e, t]
}), Pie = (e, t) => ({
  ...Sie(e),
  options: [e, t]
}), jie = (e, t) => ({
  ...Aie(e),
  options: [e, t]
});
var Iie = "Arrow", S6 = k.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: i = 5, ...o } = e;
  return /* @__PURE__ */ v.jsx(
    Et.svg,
    {
      ...o,
      ref: t,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ v.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
S6.displayName = Iie;
var zie = S6;
function jA(e) {
  const [t, n] = k.useState(void 0);
  return Er(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const o = i[0];
        let s, a;
        if ("borderBoxSize" in o) {
          const c = o.borderBoxSize, u = Array.isArray(c) ? c[0] : c;
          s = u.inlineSize, a = u.blockSize;
        } else
          s = e.offsetWidth, a = e.offsetHeight;
        n({ width: s, height: a });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var IA = "Popper", [k6, Mh] = ps(IA), [Lie, C6] = k6(IA), E6 = (e) => {
  const { __scopePopper: t, children: n } = e, [r, i] = k.useState(null);
  return /* @__PURE__ */ v.jsx(Lie, { scope: t, anchor: r, onAnchorChange: i, children: n });
};
E6.displayName = IA;
var _6 = "PopperAnchor", T6 = k.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...i } = e, o = C6(_6, n), s = k.useRef(null), a = Ft(t, s), c = k.useRef(null);
    return k.useEffect(() => {
      const u = c.current;
      c.current = r?.current || s.current, u !== c.current && o.onAnchorChange(c.current);
    }), r ? null : /* @__PURE__ */ v.jsx(Et.div, { ...i, ref: a });
  }
);
T6.displayName = _6;
var zA = "PopperContent", [Bie, $ie] = k6(zA), A6 = k.forwardRef(
  (e, t) => {
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: i = 0,
      align: o = "center",
      alignOffset: s = 0,
      arrowPadding: a = 0,
      avoidCollisions: c = !0,
      collisionBoundary: u = [],
      collisionPadding: f = 0,
      sticky: h = "partial",
      hideWhenDetached: m = !1,
      updatePositionStrategy: g = "optimized",
      onPlaced: b,
      ...x
    } = e, w = C6(zA, n), [S, _] = k.useState(null), M = Ft(t, (J) => _(J)), [N, P] = k.useState(null), I = jA(N), O = I?.width ?? 0, L = I?.height ?? 0, U = r + (o !== "center" ? "-" + o : ""), B = typeof f == "number" ? f : { top: 0, right: 0, bottom: 0, left: 0, ...f }, G = Array.isArray(u) ? u : [u], Y = G.length > 0, he = {
      padding: B,
      boundary: G.filter(Fie),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: Y
    }, { refs: ie, floatingStyles: ne, placement: H, isPositioned: Q, middlewareData: X } = Tie({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: U,
      whileElementsMounted: (...J) => yie(...J, {
        animationFrame: g === "always"
      }),
      elements: {
        reference: w.anchor
      },
      middleware: [
        Mie({ mainAxis: i + L, alignmentAxis: s }),
        c && Nie({
          mainAxis: !0,
          crossAxis: !1,
          limiter: h === "partial" ? Rie() : void 0,
          ...he
        }),
        c && Oie({ ...he }),
        Die({
          ...he,
          apply: ({ elements: J, rects: xe, availableWidth: be, availableHeight: Ae }) => {
            const { width: tt, height: Ge } = xe.reference, nt = J.floating.style;
            nt.setProperty("--radix-popper-available-width", `${be}px`), nt.setProperty("--radix-popper-available-height", `${Ae}px`), nt.setProperty("--radix-popper-anchor-width", `${tt}px`), nt.setProperty("--radix-popper-anchor-height", `${Ge}px`);
          }
        }),
        N && jie({ element: N, padding: a }),
        Vie({ arrowWidth: O, arrowHeight: L }),
        m && Pie({ strategy: "referenceHidden", ...he })
      ]
    }), [Se, W] = R6(H), Z = Dr(b);
    Er(() => {
      Q && Z?.();
    }, [Q, Z]);
    const pe = X.arrow?.x, F = X.arrow?.y, ee = X.arrow?.centerOffset !== 0, [ge, re] = k.useState();
    return Er(() => {
      S && re(window.getComputedStyle(S).zIndex);
    }, [S]), /* @__PURE__ */ v.jsx(
      "div",
      {
        ref: ie.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...ne,
          transform: Q ? ne.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: ge,
          "--radix-popper-transform-origin": [
            X.transformOrigin?.x,
            X.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...X.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ v.jsx(
          Bie,
          {
            scope: n,
            placedSide: Se,
            onArrowChange: P,
            arrowX: pe,
            arrowY: F,
            shouldHideArrow: ee,
            children: /* @__PURE__ */ v.jsx(
              Et.div,
              {
                "data-side": Se,
                "data-align": W,
                ...x,
                ref: M,
                style: {
                  ...x.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: Q ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
A6.displayName = zA;
var M6 = "PopperArrow", Uie = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, N6 = k.forwardRef(function(t, n) {
  const { __scopePopper: r, ...i } = t, o = $ie(M6, r), s = Uie[o.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ v.jsx(
      "span",
      {
        ref: o.onArrowChange,
        style: {
          position: "absolute",
          left: o.arrowX,
          top: o.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[o.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[o.placedSide],
          visibility: o.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ v.jsx(
          zie,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
N6.displayName = M6;
function Fie(e) {
  return e !== null;
}
var Vie = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    const { placement: n, rects: r, middlewareData: i } = t, s = i.arrow?.centerOffset !== 0, a = s ? 0 : e.arrowWidth, c = s ? 0 : e.arrowHeight, [u, f] = R6(n), h = { start: "0%", center: "50%", end: "100%" }[f], m = (i.arrow?.x ?? 0) + a / 2, g = (i.arrow?.y ?? 0) + c / 2;
    let b = "", x = "";
    return u === "bottom" ? (b = s ? h : `${m}px`, x = `${-c}px`) : u === "top" ? (b = s ? h : `${m}px`, x = `${r.floating.height + c}px`) : u === "right" ? (b = `${-c}px`, x = s ? h : `${g}px`) : u === "left" && (b = `${r.floating.width + c}px`, x = s ? h : `${g}px`), { data: { x: b, y: x } };
  }
});
function R6(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var Xx = E6, LA = T6, BA = A6, $A = N6, Hie = "Portal", Bg = k.forwardRef((e, t) => {
  const { container: n, ...r } = e, [i, o] = k.useState(!1);
  Er(() => o(!0), []);
  const s = n || i && globalThis?.document?.body;
  return s ? $3.createPortal(/* @__PURE__ */ v.jsx(Et.div, { ...r, ref: t }), s) : null;
});
Bg.displayName = Hie;
var Wie = /* @__PURE__ */ Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function qie(e) {
  const t = ({ children: n }) => /* @__PURE__ */ v.jsx(v.Fragment, { children: n });
  return t.displayName = `${e}.Slottable`, t.__radixId = Wie, t;
}
var Gie = Ix[" useInsertionEffect ".trim().toString()] || Er;
function Qa({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: r
}) {
  const [i, o, s] = Kie({
    defaultProp: t,
    onChange: n
  }), a = e !== void 0, c = a ? e : i;
  {
    const f = k.useRef(e !== void 0);
    k.useEffect(() => {
      const h = f.current;
      h !== a && console.warn(
        `${r} is changing from ${h ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), f.current = a;
    }, [a, r]);
  }
  const u = k.useCallback(
    (f) => {
      if (a) {
        const h = Zie(f) ? f(e) : f;
        h !== e && s.current?.(h);
      } else
        o(f);
    },
    [a, e, o, s]
  );
  return [c, u];
}
function Kie({
  defaultProp: e,
  onChange: t
}) {
  const [n, r] = k.useState(e), i = k.useRef(n), o = k.useRef(t);
  return Gie(() => {
    o.current = t;
  }, [t]), k.useEffect(() => {
    i.current !== n && (o.current?.(n), i.current = n);
  }, [n, i]), [n, r, o];
}
function Zie(e) {
  return typeof e == "function";
}
var O6 = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), Yie = "VisuallyHidden", D6 = k.forwardRef(
  (e, t) => /* @__PURE__ */ v.jsx(
    Et.span,
    {
      ...e,
      ref: t,
      style: { ...O6, ...e.style }
    }
  )
);
D6.displayName = Yie;
var Xie = D6, [Jx] = ps("Tooltip", [
  Mh
]), Qx = Mh(), P6 = "TooltipProvider", Jie = 700, QE = "tooltip.open", [Qie, UA] = Jx(P6), j6 = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: n = Jie,
    skipDelayDuration: r = 300,
    disableHoverableContent: i = !1,
    children: o
  } = e, s = k.useRef(!0), a = k.useRef(!1), c = k.useRef(0);
  return k.useEffect(() => {
    const u = c.current;
    return () => window.clearTimeout(u);
  }, []), /* @__PURE__ */ v.jsx(
    Qie,
    {
      scope: t,
      isOpenDelayedRef: s,
      delayDuration: n,
      onOpen: k.useCallback(() => {
        window.clearTimeout(c.current), s.current = !1;
      }, []),
      onClose: k.useCallback(() => {
        window.clearTimeout(c.current), c.current = window.setTimeout(
          () => s.current = !0,
          r
        );
      }, [r]),
      isPointerInTransitRef: a,
      onPointerInTransitChange: k.useCallback((u) => {
        a.current = u;
      }, []),
      disableHoverableContent: i,
      children: o
    }
  );
};
j6.displayName = P6;
var Jm = "Tooltip", [eoe, $g] = Jx(Jm), I6 = (e) => {
  const {
    __scopeTooltip: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    disableHoverableContent: s,
    delayDuration: a
  } = e, c = UA(Jm, e.__scopeTooltip), u = Qx(t), [f, h] = k.useState(null), m = Uo(), g = k.useRef(0), b = s ?? c.disableHoverableContent, x = a ?? c.delayDuration, w = k.useRef(!1), [S, _] = Qa({
    prop: r,
    defaultProp: i ?? !1,
    onChange: (O) => {
      O ? (c.onOpen(), document.dispatchEvent(new CustomEvent(QE))) : c.onClose(), o?.(O);
    },
    caller: Jm
  }), M = k.useMemo(() => S ? w.current ? "delayed-open" : "instant-open" : "closed", [S]), N = k.useCallback(() => {
    window.clearTimeout(g.current), g.current = 0, w.current = !1, _(!0);
  }, [_]), P = k.useCallback(() => {
    window.clearTimeout(g.current), g.current = 0, _(!1);
  }, [_]), I = k.useCallback(() => {
    window.clearTimeout(g.current), g.current = window.setTimeout(() => {
      w.current = !0, _(!0), g.current = 0;
    }, x);
  }, [x, _]);
  return k.useEffect(() => () => {
    g.current && (window.clearTimeout(g.current), g.current = 0);
  }, []), /* @__PURE__ */ v.jsx(Xx, { ...u, children: /* @__PURE__ */ v.jsx(
    eoe,
    {
      scope: t,
      contentId: m,
      open: S,
      stateAttribute: M,
      trigger: f,
      onTriggerChange: h,
      onTriggerEnter: k.useCallback(() => {
        c.isOpenDelayedRef.current ? I() : N();
      }, [c.isOpenDelayedRef, I, N]),
      onTriggerLeave: k.useCallback(() => {
        b ? P() : (window.clearTimeout(g.current), g.current = 0);
      }, [P, b]),
      onOpen: N,
      onClose: P,
      disableHoverableContent: b,
      children: n
    }
  ) });
};
I6.displayName = Jm;
var e_ = "TooltipTrigger", FA = k.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = $g(e_, n), o = UA(e_, n), s = Qx(n), a = k.useRef(null), c = Ft(t, a, i.onTriggerChange), u = k.useRef(!1), f = k.useRef(!1), h = k.useCallback(() => u.current = !1, []);
    return k.useEffect(() => () => document.removeEventListener("pointerup", h), [h]), /* @__PURE__ */ v.jsx(LA, { asChild: !0, ...s, children: /* @__PURE__ */ v.jsx(
      Et.button,
      {
        "aria-describedby": i.open ? i.contentId : void 0,
        "data-state": i.stateAttribute,
        ...r,
        ref: c,
        onPointerMove: Ye(e.onPointerMove, (m) => {
          m.pointerType !== "touch" && !f.current && !o.isPointerInTransitRef.current && (i.onTriggerEnter(), f.current = !0);
        }),
        onPointerLeave: Ye(e.onPointerLeave, () => {
          i.onTriggerLeave(), f.current = !1;
        }),
        onPointerDown: Ye(e.onPointerDown, () => {
          i.open && i.onClose(), u.current = !0, document.addEventListener("pointerup", h, { once: !0 });
        }),
        onFocus: Ye(e.onFocus, () => {
          u.current || i.onOpen();
        }),
        onBlur: Ye(e.onBlur, i.onClose),
        onClick: Ye(e.onClick, i.onClose)
      }
    ) });
  }
);
FA.displayName = e_;
var VA = "TooltipPortal", [toe, noe] = Jx(VA, {
  forceMount: void 0
}), z6 = (e) => {
  const { __scopeTooltip: t, forceMount: n, children: r, container: i } = e, o = $g(VA, t);
  return /* @__PURE__ */ v.jsx(toe, { scope: t, forceMount: n, children: /* @__PURE__ */ v.jsx(Di, { present: n || o.open, children: /* @__PURE__ */ v.jsx(Bg, { asChild: !0, container: i, children: r }) }) });
};
z6.displayName = VA;
var oh = "TooltipContent", ew = k.forwardRef(
  (e, t) => {
    const n = noe(oh, e.__scopeTooltip), { forceMount: r = n.forceMount, side: i = "top", ...o } = e, s = $g(oh, e.__scopeTooltip);
    return /* @__PURE__ */ v.jsx(Di, { present: r || s.open, children: s.disableHoverableContent ? /* @__PURE__ */ v.jsx(L6, { side: i, ...o, ref: t }) : /* @__PURE__ */ v.jsx(roe, { side: i, ...o, ref: t }) });
  }
), roe = k.forwardRef((e, t) => {
  const n = $g(oh, e.__scopeTooltip), r = UA(oh, e.__scopeTooltip), i = k.useRef(null), o = Ft(t, i), [s, a] = k.useState(null), { trigger: c, onClose: u } = n, f = i.current, { onPointerInTransitChange: h } = r, m = k.useCallback(() => {
    a(null), h(!1);
  }, [h]), g = k.useCallback(
    (b, x) => {
      const w = b.currentTarget, S = { x: b.clientX, y: b.clientY }, _ = aoe(S, w.getBoundingClientRect()), M = loe(S, _), N = coe(x.getBoundingClientRect()), P = doe([...M, ...N]);
      a(P), h(!0);
    },
    [h]
  );
  return k.useEffect(() => () => m(), [m]), k.useEffect(() => {
    if (c && f) {
      const b = (w) => g(w, f), x = (w) => g(w, c);
      return c.addEventListener("pointerleave", b), f.addEventListener("pointerleave", x), () => {
        c.removeEventListener("pointerleave", b), f.removeEventListener("pointerleave", x);
      };
    }
  }, [c, f, g, m]), k.useEffect(() => {
    if (s) {
      const b = (x) => {
        const w = x.target, S = { x: x.clientX, y: x.clientY }, _ = c?.contains(w) || f?.contains(w), M = !uoe(S, s);
        _ ? m() : M && (m(), u());
      };
      return document.addEventListener("pointermove", b), () => document.removeEventListener("pointermove", b);
    }
  }, [c, f, s, u, m]), /* @__PURE__ */ v.jsx(L6, { ...e, ref: o });
}), [ioe, ooe] = Jx(Jm, { isInside: !1 }), soe = /* @__PURE__ */ qie("TooltipContent"), L6 = k.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": i,
      onEscapeKeyDown: o,
      onPointerDownOutside: s,
      ...a
    } = e, c = $g(oh, n), u = Qx(n), { onClose: f } = c;
    return k.useEffect(() => (document.addEventListener(QE, f), () => document.removeEventListener(QE, f)), [f]), k.useEffect(() => {
      if (c.trigger) {
        const h = (m) => {
          m.target?.contains(c.trigger) && f();
        };
        return window.addEventListener("scroll", h, { capture: !0 }), () => window.removeEventListener("scroll", h, { capture: !0 });
      }
    }, [c.trigger, f]), /* @__PURE__ */ v.jsx(
      zg,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: o,
        onPointerDownOutside: s,
        onFocusOutside: (h) => h.preventDefault(),
        onDismiss: f,
        children: /* @__PURE__ */ v.jsxs(
          BA,
          {
            "data-state": c.stateAttribute,
            ...u,
            ...a,
            ref: t,
            style: {
              ...a.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ v.jsx(soe, { children: r }),
              /* @__PURE__ */ v.jsx(ioe, { scope: n, isInside: !0, children: /* @__PURE__ */ v.jsx(Xie, { id: c.contentId, role: "tooltip", children: i || r }) })
            ]
          }
        )
      }
    );
  }
);
ew.displayName = oh;
var B6 = "TooltipArrow", $6 = k.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = Qx(n);
    return ooe(
      B6,
      n
    ).isInside ? null : /* @__PURE__ */ v.jsx($A, { ...i, ...r, ref: t });
  }
);
$6.displayName = B6;
function aoe(e, t) {
  const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), i = Math.abs(t.right - e.x), o = Math.abs(t.left - e.x);
  switch (Math.min(n, r, i, o)) {
    case o:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function loe(e, t, n = 5) {
  const r = [];
  switch (t) {
    case "top":
      r.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      r.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return r;
}
function coe(e) {
  const { top: t, right: n, bottom: r, left: i } = e;
  return [
    { x: i, y: t },
    { x: n, y: t },
    { x: n, y: r },
    { x: i, y: r }
  ];
}
function uoe(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const a = t[o], c = t[s], u = a.x, f = a.y, h = c.x, m = c.y;
    f > r != m > r && n < (h - u) * (r - f) / (m - f) + u && (i = !i);
  }
  return i;
}
function doe(e) {
  const t = e.slice();
  return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), foe(t);
}
function foe(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    for (; t.length >= 2; ) {
      const o = t[t.length - 1], s = t[t.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) t.pop();
      else break;
    }
    t.push(i);
  }
  t.pop();
  const n = [];
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1], s = n[n.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var hoe = j6, poe = I6, moe = FA, goe = z6, yoe = ew, voe = $6;
function Nh({
  delayDuration: e = 0,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    hoe,
    {
      "data-slot": "tooltip-provider",
      delayDuration: e,
      ...t
    }
  );
}
function Gi({ ...e }) {
  return /* @__PURE__ */ v.jsx(Nh, { children: /* @__PURE__ */ v.jsx(poe, { "data-slot": "tooltip", ...e }) });
}
function fo({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(moe, { "data-slot": "tooltip-trigger", ...e });
}
function Bo({
  className: e,
  sideOffset: t = 0,
  hasArrow: n = !1,
  children: r,
  ...i
}) {
  return /* @__PURE__ */ v.jsx(goe, { children: /* @__PURE__ */ v.jsxs(
    yoe,
    {
      "data-slot": "tooltip-content",
      sideOffset: t,
      className: at(
        "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
        e
      ),
      ...i,
      children: [
        r,
        /* @__PURE__ */ v.jsx(
          voe,
          {
            className: "bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] opacity-0 bg-transparent"
          }
        )
      ]
    }
  ) });
}
const boe = AA(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function Rh({
  className: e,
  variant: t,
  asChild: n = !1,
  ...r
}) {
  const i = n ? l6 : "span";
  return /* @__PURE__ */ v.jsx(
    i,
    {
      "data-slot": "badge",
      className: at(boe({ variant: t }), e),
      ...r
    }
  );
}
var Nk = "focusScope.autoFocusOnMount", Rk = "focusScope.autoFocusOnUnmount", aj = { bubbles: !1, cancelable: !0 }, xoe = "FocusScope", tw = k.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: o,
    ...s
  } = e, [a, c] = k.useState(null), u = Dr(i), f = Dr(o), h = k.useRef(null), m = Ft(t, (x) => c(x)), g = k.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  k.useEffect(() => {
    if (r) {
      let x = function(M) {
        if (g.paused || !a) return;
        const N = M.target;
        a.contains(N) ? h.current = N : Zl(h.current, { select: !0 });
      }, w = function(M) {
        if (g.paused || !a) return;
        const N = M.relatedTarget;
        N !== null && (a.contains(N) || Zl(h.current, { select: !0 }));
      }, S = function(M) {
        if (document.activeElement === document.body)
          for (const P of M)
            P.removedNodes.length > 0 && Zl(a);
      };
      document.addEventListener("focusin", x), document.addEventListener("focusout", w);
      const _ = new MutationObserver(S);
      return a && _.observe(a, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", x), document.removeEventListener("focusout", w), _.disconnect();
      };
    }
  }, [r, a, g.paused]), k.useEffect(() => {
    if (a) {
      cj.add(g);
      const x = document.activeElement;
      if (!a.contains(x)) {
        const S = new CustomEvent(Nk, aj);
        a.addEventListener(Nk, u), a.dispatchEvent(S), S.defaultPrevented || (woe(_oe(U6(a)), { select: !0 }), document.activeElement === x && Zl(a));
      }
      return () => {
        a.removeEventListener(Nk, u), setTimeout(() => {
          const S = new CustomEvent(Rk, aj);
          a.addEventListener(Rk, f), a.dispatchEvent(S), S.defaultPrevented || Zl(x ?? document.body, { select: !0 }), a.removeEventListener(Rk, f), cj.remove(g);
        }, 0);
      };
    }
  }, [a, u, f, g]);
  const b = k.useCallback(
    (x) => {
      if (!n && !r || g.paused) return;
      const w = x.key === "Tab" && !x.altKey && !x.ctrlKey && !x.metaKey, S = document.activeElement;
      if (w && S) {
        const _ = x.currentTarget, [M, N] = Soe(_);
        M && N ? !x.shiftKey && S === N ? (x.preventDefault(), n && Zl(M, { select: !0 })) : x.shiftKey && S === M && (x.preventDefault(), n && Zl(N, { select: !0 })) : S === _ && x.preventDefault();
      }
    },
    [n, r, g.paused]
  );
  return /* @__PURE__ */ v.jsx(Et.div, { tabIndex: -1, ...s, ref: m, onKeyDown: b });
});
tw.displayName = xoe;
function woe(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Zl(r, { select: t }), document.activeElement !== n) return;
}
function Soe(e) {
  const t = U6(e), n = lj(t, e), r = lj(t.reverse(), e);
  return [n, r];
}
function U6(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function lj(e, t) {
  for (const n of e)
    if (!koe(n, { upTo: t })) return n;
}
function koe(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function Coe(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Zl(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && Coe(e) && t && e.select();
  }
}
var cj = Eoe();
function Eoe() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && n?.pause(), e = uj(e, t), e.unshift(t);
    },
    remove(t) {
      e = uj(e, t), e[0]?.resume();
    }
  };
}
function uj(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function _oe(e) {
  return e.filter((t) => t.tagName !== "A");
}
var Ok = 0;
function HA() {
  k.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? dj()), document.body.insertAdjacentElement("beforeend", e[1] ?? dj()), Ok++, () => {
      Ok === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), Ok--;
    };
  }, []);
}
function dj() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Fs = function() {
  return Fs = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, Fs.apply(this, arguments);
};
function F6(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function Toe(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, o; r < i; r++)
    (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]);
  return e.concat(o || Array.prototype.slice.call(t));
}
var b0 = "right-scroll-bar-position", x0 = "width-before-scroll-bar", Aoe = "with-scroll-bars-hidden", Moe = "--removed-body-scroll-bar-size";
function Dk(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function Noe(e, t) {
  var n = k.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var Roe = typeof window < "u" ? k.useLayoutEffect : k.useEffect, fj = /* @__PURE__ */ new WeakMap();
function Ooe(e, t) {
  var n = Noe(null, function(r) {
    return e.forEach(function(i) {
      return Dk(i, r);
    });
  });
  return Roe(function() {
    var r = fj.get(n);
    if (r) {
      var i = new Set(r), o = new Set(e), s = n.current;
      i.forEach(function(a) {
        o.has(a) || Dk(a, null);
      }), o.forEach(function(a) {
        i.has(a) || Dk(a, s);
      });
    }
    fj.set(n, e);
  }, [e]), n;
}
function Doe(e) {
  return e;
}
function Poe(e, t) {
  t === void 0 && (t = Doe);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(o) {
      var s = t(o, r);
      return n.push(s), function() {
        n = n.filter(function(a) {
          return a !== s;
        });
      };
    },
    assignSyncMedium: function(o) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(o);
      }
      n = {
        push: function(a) {
          return o(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(o) {
      r = !0;
      var s = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(o), s = n;
      }
      var c = function() {
        var f = s;
        s = [], f.forEach(o);
      }, u = function() {
        return Promise.resolve().then(c);
      };
      u(), n = {
        push: function(f) {
          s.push(f), u();
        },
        filter: function(f) {
          return s = s.filter(f), n;
        }
      };
    }
  };
  return i;
}
function joe(e) {
  e === void 0 && (e = {});
  var t = Poe(null);
  return t.options = Fs({ async: !0, ssr: !1 }, e), t;
}
var V6 = function(e) {
  var t = e.sideCar, n = F6(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return k.createElement(r, Fs({}, n));
};
V6.isSideCarExport = !0;
function Ioe(e, t) {
  return e.useMedium(t), V6;
}
var H6 = joe(), Pk = function() {
}, nw = k.forwardRef(function(e, t) {
  var n = k.useRef(null), r = k.useState({
    onScrollCapture: Pk,
    onWheelCapture: Pk,
    onTouchMoveCapture: Pk
  }), i = r[0], o = r[1], s = e.forwardProps, a = e.children, c = e.className, u = e.removeScrollBar, f = e.enabled, h = e.shards, m = e.sideCar, g = e.noRelative, b = e.noIsolation, x = e.inert, w = e.allowPinchZoom, S = e.as, _ = S === void 0 ? "div" : S, M = e.gapMode, N = F6(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), P = m, I = Ooe([n, t]), O = Fs(Fs({}, N), i);
  return k.createElement(
    k.Fragment,
    null,
    f && k.createElement(P, { sideCar: H6, removeScrollBar: u, shards: h, noRelative: g, noIsolation: b, inert: x, setCallbacks: o, allowPinchZoom: !!w, lockRef: n, gapMode: M }),
    s ? k.cloneElement(k.Children.only(a), Fs(Fs({}, O), { ref: I })) : k.createElement(_, Fs({}, O, { className: c, ref: I }), a)
  );
});
nw.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
nw.classNames = {
  fullWidth: x0,
  zeroRight: b0
};
var zoe = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Loe() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = zoe();
  return t && e.setAttribute("nonce", t), e;
}
function Boe(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function $oe(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var Uoe = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = Loe()) && (Boe(t, n), $oe(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, Foe = function() {
  var e = Uoe();
  return function(t, n) {
    k.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, W6 = function() {
  var e = Foe(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, Voe = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, jk = function(e) {
  return parseInt(e || "", 10) || 0;
}, Hoe = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [jk(n), jk(r), jk(i)];
}, Woe = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return Voe;
  var t = Hoe(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, qoe = W6(), Gf = "data-scroll-locked", Goe = function(e, t, n, r) {
  var i = e.left, o = e.top, s = e.right, a = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(Aoe, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(Gf, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(b0, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(x0, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(b0, " .").concat(b0, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(x0, " .").concat(x0, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Gf, `] {
    `).concat(Moe, ": ").concat(a, `px;
  }
`);
}, hj = function() {
  var e = parseInt(document.body.getAttribute(Gf) || "0", 10);
  return isFinite(e) ? e : 0;
}, Koe = function() {
  k.useEffect(function() {
    return document.body.setAttribute(Gf, (hj() + 1).toString()), function() {
      var e = hj() - 1;
      e <= 0 ? document.body.removeAttribute(Gf) : document.body.setAttribute(Gf, e.toString());
    };
  }, []);
}, Zoe = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r;
  Koe();
  var o = k.useMemo(function() {
    return Woe(i);
  }, [i]);
  return k.createElement(qoe, { styles: Goe(o, !t, i, n ? "" : "!important") });
}, t_ = !1;
if (typeof window < "u")
  try {
    var Av = Object.defineProperty({}, "passive", {
      get: function() {
        return t_ = !0, !0;
      }
    });
    window.addEventListener("test", Av, Av), window.removeEventListener("test", Av, Av);
  } catch {
    t_ = !1;
  }
var ff = t_ ? { passive: !1 } : !1, Yoe = function(e) {
  return e.tagName === "TEXTAREA";
}, q6 = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Yoe(e) && n[t] === "visible")
  );
}, Xoe = function(e) {
  return q6(e, "overflowY");
}, Joe = function(e) {
  return q6(e, "overflowX");
}, pj = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = G6(e, r);
    if (i) {
      var o = K6(e, r), s = o[1], a = o[2];
      if (s > a)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, Qoe = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, ese = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, G6 = function(e, t) {
  return e === "v" ? Xoe(t) : Joe(t);
}, K6 = function(e, t) {
  return e === "v" ? Qoe(t) : ese(t);
}, tse = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, nse = function(e, t, n, r, i) {
  var o = tse(e, window.getComputedStyle(t).direction), s = o * r, a = n.target, c = t.contains(a), u = !1, f = s > 0, h = 0, m = 0;
  do {
    if (!a)
      break;
    var g = K6(e, a), b = g[0], x = g[1], w = g[2], S = x - w - o * b;
    (b || S) && G6(e, a) && (h += S, m += b);
    var _ = a.parentNode;
    a = _ && _.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? _.host : _;
  } while (
    // portaled content
    !c && a !== document.body || // self content
    c && (t.contains(a) || t === a)
  );
  return (f && Math.abs(h) < 1 || !f && Math.abs(m) < 1) && (u = !0), u;
}, Mv = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, mj = function(e) {
  return [e.deltaX, e.deltaY];
}, gj = function(e) {
  return e && "current" in e ? e.current : e;
}, rse = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, ise = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, ose = 0, hf = [];
function sse(e) {
  var t = k.useRef([]), n = k.useRef([0, 0]), r = k.useRef(), i = k.useState(ose++)[0], o = k.useState(W6)[0], s = k.useRef(e);
  k.useEffect(function() {
    s.current = e;
  }, [e]), k.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var x = Toe([e.lockRef.current], (e.shards || []).map(gj), !0).filter(Boolean);
      return x.forEach(function(w) {
        return w.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), x.forEach(function(w) {
          return w.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var a = k.useCallback(function(x, w) {
    if ("touches" in x && x.touches.length === 2 || x.type === "wheel" && x.ctrlKey)
      return !s.current.allowPinchZoom;
    var S = Mv(x), _ = n.current, M = "deltaX" in x ? x.deltaX : _[0] - S[0], N = "deltaY" in x ? x.deltaY : _[1] - S[1], P, I = x.target, O = Math.abs(M) > Math.abs(N) ? "h" : "v";
    if ("touches" in x && O === "h" && I.type === "range")
      return !1;
    var L = window.getSelection(), U = L && L.anchorNode, B = U ? U === I || U.contains(I) : !1;
    if (B)
      return !1;
    var G = pj(O, I);
    if (!G)
      return !0;
    if (G ? P = O : (P = O === "v" ? "h" : "v", G = pj(O, I)), !G)
      return !1;
    if (!r.current && "changedTouches" in x && (M || N) && (r.current = P), !P)
      return !0;
    var Y = r.current || P;
    return nse(Y, w, x, Y === "h" ? M : N);
  }, []), c = k.useCallback(function(x) {
    var w = x;
    if (!(!hf.length || hf[hf.length - 1] !== o)) {
      var S = "deltaY" in w ? mj(w) : Mv(w), _ = t.current.filter(function(P) {
        return P.name === w.type && (P.target === w.target || w.target === P.shadowParent) && rse(P.delta, S);
      })[0];
      if (_ && _.should) {
        w.cancelable && w.preventDefault();
        return;
      }
      if (!_) {
        var M = (s.current.shards || []).map(gj).filter(Boolean).filter(function(P) {
          return P.contains(w.target);
        }), N = M.length > 0 ? a(w, M[0]) : !s.current.noIsolation;
        N && w.cancelable && w.preventDefault();
      }
    }
  }, []), u = k.useCallback(function(x, w, S, _) {
    var M = { name: x, delta: w, target: S, should: _, shadowParent: ase(S) };
    t.current.push(M), setTimeout(function() {
      t.current = t.current.filter(function(N) {
        return N !== M;
      });
    }, 1);
  }, []), f = k.useCallback(function(x) {
    n.current = Mv(x), r.current = void 0;
  }, []), h = k.useCallback(function(x) {
    u(x.type, mj(x), x.target, a(x, e.lockRef.current));
  }, []), m = k.useCallback(function(x) {
    u(x.type, Mv(x), x.target, a(x, e.lockRef.current));
  }, []);
  k.useEffect(function() {
    return hf.push(o), e.setCallbacks({
      onScrollCapture: h,
      onWheelCapture: h,
      onTouchMoveCapture: m
    }), document.addEventListener("wheel", c, ff), document.addEventListener("touchmove", c, ff), document.addEventListener("touchstart", f, ff), function() {
      hf = hf.filter(function(x) {
        return x !== o;
      }), document.removeEventListener("wheel", c, ff), document.removeEventListener("touchmove", c, ff), document.removeEventListener("touchstart", f, ff);
    };
  }, []);
  var g = e.removeScrollBar, b = e.inert;
  return k.createElement(
    k.Fragment,
    null,
    b ? k.createElement(o, { styles: ise(i) }) : null,
    g ? k.createElement(Zoe, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function ase(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const lse = Ioe(H6, sse);
var rw = k.forwardRef(function(e, t) {
  return k.createElement(nw, Fs({}, e, { ref: t, sideCar: lse }));
});
rw.classNames = nw.classNames;
var cse = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, pf = /* @__PURE__ */ new WeakMap(), Nv = /* @__PURE__ */ new WeakMap(), Rv = {}, Ik = 0, Z6 = function(e) {
  return e && (e.host || Z6(e.parentNode));
}, use = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = Z6(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, dse = function(e, t, n, r) {
  var i = use(t, Array.isArray(e) ? e : [e]);
  Rv[n] || (Rv[n] = /* @__PURE__ */ new WeakMap());
  var o = Rv[n], s = [], a = /* @__PURE__ */ new Set(), c = new Set(i), u = function(h) {
    !h || a.has(h) || (a.add(h), u(h.parentNode));
  };
  i.forEach(u);
  var f = function(h) {
    !h || c.has(h) || Array.prototype.forEach.call(h.children, function(m) {
      if (a.has(m))
        f(m);
      else
        try {
          var g = m.getAttribute(r), b = g !== null && g !== "false", x = (pf.get(m) || 0) + 1, w = (o.get(m) || 0) + 1;
          pf.set(m, x), o.set(m, w), s.push(m), x === 1 && b && Nv.set(m, !0), w === 1 && m.setAttribute(n, "true"), b || m.setAttribute(r, "true");
        } catch (S) {
          console.error("aria-hidden: cannot operate on ", m, S);
        }
    });
  };
  return f(t), a.clear(), Ik++, function() {
    s.forEach(function(h) {
      var m = pf.get(h) - 1, g = o.get(h) - 1;
      pf.set(h, m), o.set(h, g), m || (Nv.has(h) || h.removeAttribute(r), Nv.delete(h)), g || h.removeAttribute(n);
    }), Ik--, Ik || (pf = /* @__PURE__ */ new WeakMap(), pf = /* @__PURE__ */ new WeakMap(), Nv = /* @__PURE__ */ new WeakMap(), Rv = {});
  };
}, WA = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = cse(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live], script"))), dse(r, i, n, "aria-hidden")) : function() {
    return null;
  };
};
// @__NO_SIDE_EFFECTS__
function fse(e) {
  const t = /* @__PURE__ */ hse(e), n = k.forwardRef((r, i) => {
    const { children: o, ...s } = r, a = k.Children.toArray(o), c = a.find(mse);
    if (c) {
      const u = c.props.children, f = a.map((h) => h === c ? k.Children.count(u) > 1 ? k.Children.only(null) : k.isValidElement(u) ? u.props.children : null : h);
      return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: k.isValidElement(u) ? k.cloneElement(u, void 0, f) : null });
    }
    return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: o });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function hse(e) {
  const t = k.forwardRef((n, r) => {
    const { children: i, ...o } = n;
    if (k.isValidElement(i)) {
      const s = yse(i), a = gse(o, i.props);
      return i.type !== k.Fragment && (a.ref = r ? nl(r, s) : s), k.cloneElement(i, a);
    }
    return k.Children.count(i) > 1 ? k.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var pse = /* @__PURE__ */ Symbol("radix.slottable");
function mse(e) {
  return k.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === pse;
}
function gse(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...a) => {
      const c = o(...a);
      return i(...a), c;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function yse(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var iw = "Dialog", [Y6] = ps(iw), [vse, ms] = Y6(iw), X6 = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    modal: s = !0
  } = e, a = k.useRef(null), c = k.useRef(null), [u, f] = Qa({
    prop: r,
    defaultProp: i ?? !1,
    onChange: o,
    caller: iw
  });
  return /* @__PURE__ */ v.jsx(
    vse,
    {
      scope: t,
      triggerRef: a,
      contentRef: c,
      contentId: Uo(),
      titleId: Uo(),
      descriptionId: Uo(),
      open: u,
      onOpenChange: f,
      onOpenToggle: k.useCallback(() => f((h) => !h), [f]),
      modal: s,
      children: n
    }
  );
};
X6.displayName = iw;
var J6 = "DialogTrigger", Q6 = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = ms(J6, n), o = Ft(t, i.triggerRef);
    return /* @__PURE__ */ v.jsx(
      Et.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": KA(i.open),
        ...r,
        ref: o,
        onClick: Ye(e.onClick, i.onOpenToggle)
      }
    );
  }
);
Q6.displayName = J6;
var qA = "DialogPortal", [bse, e$] = Y6(qA, {
  forceMount: void 0
}), t$ = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: i } = e, o = ms(qA, t);
  return /* @__PURE__ */ v.jsx(bse, { scope: t, forceMount: n, children: k.Children.map(r, (s) => /* @__PURE__ */ v.jsx(Di, { present: n || o.open, children: /* @__PURE__ */ v.jsx(Bg, { asChild: !0, container: i, children: s }) })) });
};
t$.displayName = qA;
var ab = "DialogOverlay", n$ = k.forwardRef(
  (e, t) => {
    const n = e$(ab, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = ms(ab, e.__scopeDialog);
    return o.modal ? /* @__PURE__ */ v.jsx(Di, { present: r || o.open, children: /* @__PURE__ */ v.jsx(wse, { ...i, ref: t }) }) : null;
  }
);
n$.displayName = ab;
var xse = /* @__PURE__ */ fse("DialogOverlay.RemoveScroll"), wse = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = ms(ab, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ v.jsx(rw, { as: xse, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ v.jsx(
        Et.div,
        {
          "data-state": KA(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), Yu = "DialogContent", r$ = k.forwardRef(
  (e, t) => {
    const n = e$(Yu, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = ms(Yu, e.__scopeDialog);
    return /* @__PURE__ */ v.jsx(Di, { present: r || o.open, children: o.modal ? /* @__PURE__ */ v.jsx(Sse, { ...i, ref: t }) : /* @__PURE__ */ v.jsx(kse, { ...i, ref: t }) });
  }
);
r$.displayName = Yu;
var Sse = k.forwardRef(
  (e, t) => {
    const n = ms(Yu, e.__scopeDialog), r = k.useRef(null), i = Ft(t, n.contentRef, r);
    return k.useEffect(() => {
      const o = r.current;
      if (o) return WA(o);
    }, []), /* @__PURE__ */ v.jsx(
      i$,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ye(e.onCloseAutoFocus, (o) => {
          o.preventDefault(), n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: Ye(e.onPointerDownOutside, (o) => {
          const s = o.detail.originalEvent, a = s.button === 0 && s.ctrlKey === !0;
          (s.button === 2 || a) && o.preventDefault();
        }),
        onFocusOutside: Ye(
          e.onFocusOutside,
          (o) => o.preventDefault()
        )
      }
    );
  }
), kse = k.forwardRef(
  (e, t) => {
    const n = ms(Yu, e.__scopeDialog), r = k.useRef(!1), i = k.useRef(!1);
    return /* @__PURE__ */ v.jsx(
      i$,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (o) => {
          e.onCloseAutoFocus?.(o), o.defaultPrevented || (r.current || n.triggerRef.current?.focus(), o.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (o) => {
          e.onInteractOutside?.(o), o.defaultPrevented || (r.current = !0, o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const s = o.target;
          n.triggerRef.current?.contains(s) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
        }
      }
    );
  }
), i$ = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, ...s } = e, a = ms(Yu, n), c = k.useRef(null), u = Ft(t, c);
    return HA(), /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(
        tw,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: o,
          children: /* @__PURE__ */ v.jsx(
            zg,
            {
              role: "dialog",
              id: a.contentId,
              "aria-describedby": a.descriptionId,
              "aria-labelledby": a.titleId,
              "data-state": KA(a.open),
              ...s,
              ref: u,
              onDismiss: () => a.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
        /* @__PURE__ */ v.jsx(Cse, { titleId: a.titleId }),
        /* @__PURE__ */ v.jsx(_se, { contentRef: c, descriptionId: a.descriptionId })
      ] })
    ] });
  }
), GA = "DialogTitle", o$ = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = ms(GA, n);
    return /* @__PURE__ */ v.jsx(Et.h2, { id: i.titleId, ...r, ref: t });
  }
);
o$.displayName = GA;
var s$ = "DialogDescription", a$ = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = ms(s$, n);
    return /* @__PURE__ */ v.jsx(Et.p, { id: i.descriptionId, ...r, ref: t });
  }
);
a$.displayName = s$;
var l$ = "DialogClose", c$ = k.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = ms(l$, n);
    return /* @__PURE__ */ v.jsx(
      Et.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Ye(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
c$.displayName = l$;
function KA(e) {
  return e ? "open" : "closed";
}
var u$ = "DialogTitleWarning", [MLe, d$] = nX(u$, {
  contentName: Yu,
  titleName: GA,
  docsSlug: "dialog"
}), Cse = ({ titleId: e }) => {
  const t = d$(u$), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return k.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, Ese = "DialogDescriptionWarning", _se = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${d$(Ese).contentName}}.`;
  return k.useEffect(() => {
    const i = e.current?.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, Tse = X6, Ase = Q6, Mse = t$, Nse = n$, Rse = r$, Ose = o$, Dse = a$, Pse = c$;
function Oh({ ...e }) {
  return /* @__PURE__ */ v.jsx(Tse, { "data-slot": "dialog", ...e });
}
function f$({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Ase, { "data-slot": "dialog-trigger", ...e });
}
function h$({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Mse, { "data-slot": "dialog-portal", ...e });
}
function jse({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Nse,
    {
      "data-slot": "dialog-overlay",
      className: at(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        e
      ),
      ...t
    }
  );
}
function Dh({
  className: e,
  children: t,
  showCloseButton: n = !0,
  ...r
}) {
  return /* @__PURE__ */ v.jsxs(h$, { "data-slot": "dialog-portal", children: [
    /* @__PURE__ */ v.jsx(jse, {}),
    /* @__PURE__ */ v.jsxs(
      Rse,
      {
        "data-slot": "dialog-content",
        className: at(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-[1000] grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          e
        ),
        ...r,
        onCloseAutoFocus: (i) => {
          i.preventDefault(), document.body.style.pointerEvents = "";
        },
        children: [
          t,
          n && /* @__PURE__ */ v.jsxs(
            Pse,
            {
              "data-slot": "dialog-close",
              className: "ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
              children: [
                /* @__PURE__ */ v.jsx(Ng, {}),
                /* @__PURE__ */ v.jsx("span", { className: "sr-only", children: "Close" })
              ]
            }
          )
        ]
      }
    )
  ] });
}
function Ug({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "dialog-header",
      className: at("flex flex-col gap-2 text-center sm:text-left", e),
      ...t
    }
  );
}
function p$({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "dialog-footer",
      className: at(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        e
      ),
      ...t
    }
  );
}
function Ph({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Ose,
    {
      "data-slot": "dialog-title",
      className: at("text-lg leading-none font-semibold", e),
      ...t
    }
  );
}
function m$({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Dse,
    {
      "data-slot": "dialog-description",
      className: at("text-muted-foreground text-sm", e),
      ...t
    }
  );
}
var Ise = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], zse = Ise.reduce((e, t) => {
  const n = /* @__PURE__ */ qx(`Primitive.${t}`), r = k.forwardRef((i, o) => {
    const { asChild: s, ...a } = i, c = s ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ v.jsx(c, { ...a, ref: o });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Lse = "Label", g$ = k.forwardRef((e, t) => /* @__PURE__ */ v.jsx(
  zse.label,
  {
    ...e,
    ref: t,
    onMouseDown: (n) => {
      n.target.closest("button, input, select, textarea") || (e.onMouseDown?.(n), !n.defaultPrevented && n.detail > 1 && n.preventDefault());
    }
  }
));
g$.displayName = Lse;
var Bse = g$;
function $se({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Bse,
    {
      "data-slot": "label",
      className: at(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        e
      ),
      ...t
    }
  );
}
const Use = { "gpt-4.1": "openai/gpt-4.1", "gpt-4.1-mini": "openai/gpt-4.1-mini", "gpt-4o-mini": "openai/gpt-4o-mini", "gpt-4o": "openai/gpt-4o", "gpt-5": "openai/gpt-5", "gpt-5.1": "openai/gpt-5.1", "gpt-5-mini": "openai/gpt-5-mini", "gpt-5-nano": "openai/gpt-5-nano", "gpt-oss-120b": "openai/gpt-oss-120b", "gpt-2.5-flash": "openai/gpt-2.5-flash" }, Fse = { "gemini-2.5-flash-lite": "google/gemini-2.5-flash-lite", "gemini-2.5-flash": "google/gemini-2.5-flash", "gemini-2.5-pro": "google/gemini-2.5-pro", "gemini-2.0-flash": "google/gemini-2.0-flash" }, Vse = { "claude-sonnet-4.5": "anthropic/claude-sonnet-4.5", "claude-sonnet-4": "anthropic/claude-sonnet-4", "claude-3.7-sonnet": "anthropic/claude-3.7-sonnet" }, Hse = { "grok-4-fast-reasoning": "xai/grok-4-fast-reasoning", "grok-4-fast-non-reasoning": "xai/grok-4-fast-non-reasoning" }, Wse = { "llama-4-maverick": "meta/llama-4-maverick" }, qse = { "deepseek-v3.1": "deepseek/deepseek-v3.1" }, Gse = { "gemma3-1b": "ollama/gemma3:1b", "gemma3-4b": "ollama/gemma3:4b", "gemma3-12b": "ollama/gemma3:12b" }, Kse = { "gpt-oss-20b-free": "openai/gpt-oss-20b:free", "qwen3-8b-free": "qwen/qwen3-8b:free", "qwen3-14b-free": "qwen/qwen3-14b:free", "qwen3-coder-free": "qwen/qwen3-coder:free", "deepseek-r1-free": "deepseek/deepseek-r1-0528:free", "deepseek-v3-free": "deepseek/deepseek-chat-v3-0324:free", "gemini-2.0-flash-exp-free": "google/gemini-2.0-flash-exp:free" }, Zse = {
  openai: Use,
  google: Fse,
  anthropic: Vse,
  xai: Hse,
  meta: Wse,
  deepseek: qse,
  ollama: Gse,
  openRouter: Kse
};
function Yse(e) {
  if (typeof document > "u") return;
  let t = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
  n.type = "text/css", t.appendChild(n), n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e));
}
Array(12).fill(0);
let n_ = 1;
class Xse {
  constructor() {
    this.subscribe = (t) => (this.subscribers.push(t), () => {
      const n = this.subscribers.indexOf(t);
      this.subscribers.splice(n, 1);
    }), this.publish = (t) => {
      this.subscribers.forEach((n) => n(t));
    }, this.addToast = (t) => {
      this.publish(t), this.toasts = [
        ...this.toasts,
        t
      ];
    }, this.create = (t) => {
      var n;
      const { message: r, ...i } = t, o = typeof t?.id == "number" || ((n = t.id) == null ? void 0 : n.length) > 0 ? t.id : n_++, s = this.toasts.find((c) => c.id === o), a = t.dismissible === void 0 ? !0 : t.dismissible;
      return this.dismissedToasts.has(o) && this.dismissedToasts.delete(o), s ? this.toasts = this.toasts.map((c) => c.id === o ? (this.publish({
        ...c,
        ...t,
        id: o,
        title: r
      }), {
        ...c,
        ...t,
        id: o,
        dismissible: a,
        title: r
      }) : c) : this.addToast({
        title: r,
        ...i,
        dismissible: a,
        id: o
      }), o;
    }, this.dismiss = (t) => (t ? (this.dismissedToasts.add(t), requestAnimationFrame(() => this.subscribers.forEach((n) => n({
      id: t,
      dismiss: !0
    })))) : this.toasts.forEach((n) => {
      this.subscribers.forEach((r) => r({
        id: n.id,
        dismiss: !0
      }));
    }), t), this.message = (t, n) => this.create({
      ...n,
      message: t
    }), this.error = (t, n) => this.create({
      ...n,
      message: t,
      type: "error"
    }), this.success = (t, n) => this.create({
      ...n,
      type: "success",
      message: t
    }), this.info = (t, n) => this.create({
      ...n,
      type: "info",
      message: t
    }), this.warning = (t, n) => this.create({
      ...n,
      type: "warning",
      message: t
    }), this.loading = (t, n) => this.create({
      ...n,
      type: "loading",
      message: t
    }), this.promise = (t, n) => {
      if (!n)
        return;
      let r;
      n.loading !== void 0 && (r = this.create({
        ...n,
        promise: t,
        type: "loading",
        message: n.loading,
        description: typeof n.description != "function" ? n.description : void 0
      }));
      const i = Promise.resolve(t instanceof Function ? t() : t);
      let o = r !== void 0, s;
      const a = i.then(async (u) => {
        if (s = [
          "resolve",
          u
        ], Ne.isValidElement(u))
          o = !1, this.create({
            id: r,
            type: "default",
            message: u
          });
        else if (Qse(u) && !u.ok) {
          o = !1;
          const h = typeof n.error == "function" ? await n.error(`HTTP error! status: ${u.status}`) : n.error, m = typeof n.description == "function" ? await n.description(`HTTP error! status: ${u.status}`) : n.description, b = typeof h == "object" && !Ne.isValidElement(h) ? h : {
            message: h
          };
          this.create({
            id: r,
            type: "error",
            description: m,
            ...b
          });
        } else if (u instanceof Error) {
          o = !1;
          const h = typeof n.error == "function" ? await n.error(u) : n.error, m = typeof n.description == "function" ? await n.description(u) : n.description, b = typeof h == "object" && !Ne.isValidElement(h) ? h : {
            message: h
          };
          this.create({
            id: r,
            type: "error",
            description: m,
            ...b
          });
        } else if (n.success !== void 0) {
          o = !1;
          const h = typeof n.success == "function" ? await n.success(u) : n.success, m = typeof n.description == "function" ? await n.description(u) : n.description, b = typeof h == "object" && !Ne.isValidElement(h) ? h : {
            message: h
          };
          this.create({
            id: r,
            type: "success",
            description: m,
            ...b
          });
        }
      }).catch(async (u) => {
        if (s = [
          "reject",
          u
        ], n.error !== void 0) {
          o = !1;
          const f = typeof n.error == "function" ? await n.error(u) : n.error, h = typeof n.description == "function" ? await n.description(u) : n.description, g = typeof f == "object" && !Ne.isValidElement(f) ? f : {
            message: f
          };
          this.create({
            id: r,
            type: "error",
            description: h,
            ...g
          });
        }
      }).finally(() => {
        o && (this.dismiss(r), r = void 0), n.finally == null || n.finally.call(n);
      }), c = () => new Promise((u, f) => a.then(() => s[0] === "reject" ? f(s[1]) : u(s[1])).catch(f));
      return typeof r != "string" && typeof r != "number" ? {
        unwrap: c
      } : Object.assign(r, {
        unwrap: c
      });
    }, this.custom = (t, n) => {
      const r = n?.id || n_++;
      return this.create({
        jsx: t(r),
        id: r,
        ...n
      }), r;
    }, this.getActiveToasts = () => this.toasts.filter((t) => !this.dismissedToasts.has(t.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
}
const Po = new Xse(), Jse = (e, t) => {
  const n = t?.id || n_++;
  return Po.addToast({
    title: e,
    ...t,
    id: n
  }), n;
}, Qse = (e) => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", eae = Jse, tae = () => Po.toasts, nae = () => Po.getActiveToasts(), cn = Object.assign(eae, {
  success: Po.success,
  info: Po.info,
  warning: Po.warning,
  error: Po.error,
  custom: Po.custom,
  message: Po.message,
  promise: Po.promise,
  dismiss: Po.dismiss,
  loading: Po.loading
}, {
  getHistory: tae,
  getToasts: nae
});
Yse("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}");
// @__NO_SIDE_EFFECTS__
function yj(e) {
  const t = /* @__PURE__ */ rae(e), n = k.forwardRef((r, i) => {
    const { children: o, ...s } = r, a = k.Children.toArray(o), c = a.find(oae);
    if (c) {
      const u = c.props.children, f = a.map((h) => h === c ? k.Children.count(u) > 1 ? k.Children.only(null) : k.isValidElement(u) ? u.props.children : null : h);
      return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: k.isValidElement(u) ? k.cloneElement(u, void 0, f) : null });
    }
    return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: o });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function rae(e) {
  const t = k.forwardRef((n, r) => {
    const { children: i, ...o } = n;
    if (k.isValidElement(i)) {
      const s = aae(i), a = sae(o, i.props);
      return i.type !== k.Fragment && (a.ref = r ? nl(r, s) : s), k.cloneElement(i, a);
    }
    return k.Children.count(i) > 1 ? k.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var iae = /* @__PURE__ */ Symbol("radix.slottable");
function oae(e) {
  return k.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === iae;
}
function sae(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...a) => {
      const c = o(...a);
      return i(...a), c;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function aae(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function ZA(e) {
  const t = e + "CollectionProvider", [n, r] = ps(t), [i, o] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s = (x) => {
    const { scope: w, children: S } = x, _ = Ne.useRef(null), M = Ne.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ v.jsx(i, { scope: w, itemMap: M, collectionRef: _, children: S });
  };
  s.displayName = t;
  const a = e + "CollectionSlot", c = /* @__PURE__ */ yj(a), u = Ne.forwardRef(
    (x, w) => {
      const { scope: S, children: _ } = x, M = o(a, S), N = Ft(w, M.collectionRef);
      return /* @__PURE__ */ v.jsx(c, { ref: N, children: _ });
    }
  );
  u.displayName = a;
  const f = e + "CollectionItemSlot", h = "data-radix-collection-item", m = /* @__PURE__ */ yj(f), g = Ne.forwardRef(
    (x, w) => {
      const { scope: S, children: _, ...M } = x, N = Ne.useRef(null), P = Ft(w, N), I = o(f, S);
      return Ne.useEffect(() => (I.itemMap.set(N, { ref: N, ...M }), () => {
        I.itemMap.delete(N);
      })), /* @__PURE__ */ v.jsx(m, { [h]: "", ref: P, children: _ });
    }
  );
  g.displayName = f;
  function b(x) {
    const w = o(e + "CollectionConsumer", x);
    return Ne.useCallback(() => {
      const _ = w.collectionRef.current;
      if (!_) return [];
      const M = Array.from(_.querySelectorAll(`[${h}]`));
      return Array.from(w.itemMap.values()).sort(
        (I, O) => M.indexOf(I.ref.current) - M.indexOf(O.ref.current)
      );
    }, [w.collectionRef, w.itemMap]);
  }
  return [
    { Provider: s, Slot: u, ItemSlot: g },
    b,
    r
  ];
}
// @__NO_SIDE_EFFECTS__
function lae(e) {
  const t = /* @__PURE__ */ cae(e), n = k.forwardRef((r, i) => {
    const { children: o, ...s } = r, a = k.Children.toArray(o), c = a.find(dae);
    if (c) {
      const u = c.props.children, f = a.map((h) => h === c ? k.Children.count(u) > 1 ? k.Children.only(null) : k.isValidElement(u) ? u.props.children : null : h);
      return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: k.isValidElement(u) ? k.cloneElement(u, void 0, f) : null });
    }
    return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: o });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function cae(e) {
  const t = k.forwardRef((n, r) => {
    const { children: i, ...o } = n;
    if (k.isValidElement(i)) {
      const s = hae(i), a = fae(o, i.props);
      return i.type !== k.Fragment && (a.ref = r ? nl(r, s) : s), k.cloneElement(i, a);
    }
    return k.Children.count(i) > 1 ? k.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var uae = /* @__PURE__ */ Symbol("radix.slottable");
function dae(e) {
  return k.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === uae;
}
function fae(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...a) => {
      const c = o(...a);
      return i(...a), c;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function hae(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function YA(e) {
  const t = k.useRef({ value: e, previous: e });
  return k.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var pae = [" ", "Enter", "ArrowUp", "ArrowDown"], mae = [" ", "Enter"], Xu = "Select", [ow, sw, gae] = ZA(Xu), [jh] = ps(Xu, [
  gae,
  Mh
]), aw = Mh(), [yae, Ic] = jh(Xu), [vae, bae] = jh(Xu), y$ = (e) => {
  const {
    __scopeSelect: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    value: s,
    defaultValue: a,
    onValueChange: c,
    dir: u,
    name: f,
    autoComplete: h,
    disabled: m,
    required: g,
    form: b
  } = e, x = aw(t), [w, S] = k.useState(null), [_, M] = k.useState(null), [N, P] = k.useState(!1), I = Lx(u), [O, L] = Qa({
    prop: r,
    defaultProp: i ?? !1,
    onChange: o,
    caller: Xu
  }), [U, B] = Qa({
    prop: s,
    defaultProp: a,
    onChange: c,
    caller: Xu
  }), G = k.useRef(null), Y = w ? b || !!w.closest("form") : !0, [he, ie] = k.useState(/* @__PURE__ */ new Set()), ne = Array.from(he).map((H) => H.props.value).join(";");
  return /* @__PURE__ */ v.jsx(Xx, { ...x, children: /* @__PURE__ */ v.jsxs(
    yae,
    {
      required: g,
      scope: t,
      trigger: w,
      onTriggerChange: S,
      valueNode: _,
      onValueNodeChange: M,
      valueNodeHasChildren: N,
      onValueNodeHasChildrenChange: P,
      contentId: Uo(),
      value: U,
      onValueChange: B,
      open: O,
      onOpenChange: L,
      dir: I,
      triggerPointerDownPosRef: G,
      disabled: m,
      children: [
        /* @__PURE__ */ v.jsx(ow.Provider, { scope: t, children: /* @__PURE__ */ v.jsx(
          vae,
          {
            scope: e.__scopeSelect,
            onNativeOptionAdd: k.useCallback((H) => {
              ie((Q) => new Set(Q).add(H));
            }, []),
            onNativeOptionRemove: k.useCallback((H) => {
              ie((Q) => {
                const X = new Set(Q);
                return X.delete(H), X;
              });
            }, []),
            children: n
          }
        ) }),
        Y ? /* @__PURE__ */ v.jsxs(
          U$,
          {
            "aria-hidden": !0,
            required: g,
            tabIndex: -1,
            name: f,
            autoComplete: h,
            value: U,
            onChange: (H) => B(H.target.value),
            disabled: m,
            form: b,
            children: [
              U === void 0 ? /* @__PURE__ */ v.jsx("option", { value: "" }) : null,
              Array.from(he)
            ]
          },
          ne
        ) : null
      ]
    }
  ) });
};
y$.displayName = Xu;
var v$ = "SelectTrigger", b$ = k.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, disabled: r = !1, ...i } = e, o = aw(n), s = Ic(v$, n), a = s.disabled || r, c = Ft(t, s.onTriggerChange), u = sw(n), f = k.useRef("touch"), [h, m, g] = V$((x) => {
      const w = u().filter((M) => !M.disabled), S = w.find((M) => M.value === s.value), _ = H$(w, x, S);
      _ !== void 0 && s.onValueChange(_.value);
    }), b = (x) => {
      a || (s.onOpenChange(!0), g()), x && (s.triggerPointerDownPosRef.current = {
        x: Math.round(x.pageX),
        y: Math.round(x.pageY)
      });
    };
    return /* @__PURE__ */ v.jsx(LA, { asChild: !0, ...o, children: /* @__PURE__ */ v.jsx(
      Et.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": s.contentId,
        "aria-expanded": s.open,
        "aria-required": s.required,
        "aria-autocomplete": "none",
        dir: s.dir,
        "data-state": s.open ? "open" : "closed",
        disabled: a,
        "data-disabled": a ? "" : void 0,
        "data-placeholder": F$(s.value) ? "" : void 0,
        ...i,
        ref: c,
        onClick: Ye(i.onClick, (x) => {
          x.currentTarget.focus(), f.current !== "mouse" && b(x);
        }),
        onPointerDown: Ye(i.onPointerDown, (x) => {
          f.current = x.pointerType;
          const w = x.target;
          w.hasPointerCapture(x.pointerId) && w.releasePointerCapture(x.pointerId), x.button === 0 && x.ctrlKey === !1 && x.pointerType === "mouse" && (b(x), x.preventDefault());
        }),
        onKeyDown: Ye(i.onKeyDown, (x) => {
          const w = h.current !== "";
          !(x.ctrlKey || x.altKey || x.metaKey) && x.key.length === 1 && m(x.key), !(w && x.key === " ") && pae.includes(x.key) && (b(), x.preventDefault());
        })
      }
    ) });
  }
);
b$.displayName = v$;
var x$ = "SelectValue", w$ = k.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: r, style: i, children: o, placeholder: s = "", ...a } = e, c = Ic(x$, n), { onValueNodeHasChildrenChange: u } = c, f = o !== void 0, h = Ft(t, c.onValueNodeChange);
    return Er(() => {
      u(f);
    }, [u, f]), /* @__PURE__ */ v.jsx(
      Et.span,
      {
        ...a,
        ref: h,
        style: { pointerEvents: "none" },
        children: F$(c.value) ? /* @__PURE__ */ v.jsx(v.Fragment, { children: s }) : o
      }
    );
  }
);
w$.displayName = x$;
var xae = "SelectIcon", S$ = k.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, children: r, ...i } = e;
    return /* @__PURE__ */ v.jsx(Et.span, { "aria-hidden": !0, ...i, ref: t, children: r || "" });
  }
);
S$.displayName = xae;
var wae = "SelectPortal", k$ = (e) => /* @__PURE__ */ v.jsx(Bg, { asChild: !0, ...e });
k$.displayName = wae;
var Ju = "SelectContent", C$ = k.forwardRef(
  (e, t) => {
    const n = Ic(Ju, e.__scopeSelect), [r, i] = k.useState();
    if (Er(() => {
      i(new DocumentFragment());
    }, []), !n.open) {
      const o = r;
      return o ? tl.createPortal(
        /* @__PURE__ */ v.jsx(E$, { scope: e.__scopeSelect, children: /* @__PURE__ */ v.jsx(ow.Slot, { scope: e.__scopeSelect, children: /* @__PURE__ */ v.jsx("div", { children: e.children }) }) }),
        o
      ) : null;
    }
    return /* @__PURE__ */ v.jsx(_$, { ...e, ref: t });
  }
);
C$.displayName = Ju;
var is = 10, [E$, zc] = jh(Ju), Sae = "SelectContentImpl", kae = /* @__PURE__ */ lae("SelectContent.RemoveScroll"), _$ = k.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      position: r = "item-aligned",
      onCloseAutoFocus: i,
      onEscapeKeyDown: o,
      onPointerDownOutside: s,
      //
      // PopperContent props
      side: a,
      sideOffset: c,
      align: u,
      alignOffset: f,
      arrowPadding: h,
      collisionBoundary: m,
      collisionPadding: g,
      sticky: b,
      hideWhenDetached: x,
      avoidCollisions: w,
      //
      ...S
    } = e, _ = Ic(Ju, n), [M, N] = k.useState(null), [P, I] = k.useState(null), O = Ft(t, (J) => N(J)), [L, U] = k.useState(null), [B, G] = k.useState(
      null
    ), Y = sw(n), [he, ie] = k.useState(!1), ne = k.useRef(!1);
    k.useEffect(() => {
      if (M) return WA(M);
    }, [M]), HA();
    const H = k.useCallback(
      (J) => {
        const [xe, ...be] = Y().map((Ge) => Ge.ref.current), [Ae] = be.slice(-1), tt = document.activeElement;
        for (const Ge of J)
          if (Ge === tt || (Ge?.scrollIntoView({ block: "nearest" }), Ge === xe && P && (P.scrollTop = 0), Ge === Ae && P && (P.scrollTop = P.scrollHeight), Ge?.focus(), document.activeElement !== tt)) return;
      },
      [Y, P]
    ), Q = k.useCallback(
      () => H([L, M]),
      [H, L, M]
    );
    k.useEffect(() => {
      he && Q();
    }, [he, Q]);
    const { onOpenChange: X, triggerPointerDownPosRef: Se } = _;
    k.useEffect(() => {
      if (M) {
        let J = { x: 0, y: 0 };
        const xe = (Ae) => {
          J = {
            x: Math.abs(Math.round(Ae.pageX) - (Se.current?.x ?? 0)),
            y: Math.abs(Math.round(Ae.pageY) - (Se.current?.y ?? 0))
          };
        }, be = (Ae) => {
          J.x <= 10 && J.y <= 10 ? Ae.preventDefault() : M.contains(Ae.target) || X(!1), document.removeEventListener("pointermove", xe), Se.current = null;
        };
        return Se.current !== null && (document.addEventListener("pointermove", xe), document.addEventListener("pointerup", be, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", xe), document.removeEventListener("pointerup", be, { capture: !0 });
        };
      }
    }, [M, X, Se]), k.useEffect(() => {
      const J = () => X(!1);
      return window.addEventListener("blur", J), window.addEventListener("resize", J), () => {
        window.removeEventListener("blur", J), window.removeEventListener("resize", J);
      };
    }, [X]);
    const [W, Z] = V$((J) => {
      const xe = Y().filter((tt) => !tt.disabled), be = xe.find((tt) => tt.ref.current === document.activeElement), Ae = H$(xe, J, be);
      Ae && setTimeout(() => Ae.ref.current.focus());
    }), pe = k.useCallback(
      (J, xe, be) => {
        const Ae = !ne.current && !be;
        (_.value !== void 0 && _.value === xe || Ae) && (U(J), Ae && (ne.current = !0));
      },
      [_.value]
    ), F = k.useCallback(() => M?.focus(), [M]), ee = k.useCallback(
      (J, xe, be) => {
        const Ae = !ne.current && !be;
        (_.value !== void 0 && _.value === xe || Ae) && G(J);
      },
      [_.value]
    ), ge = r === "popper" ? r_ : T$, re = ge === r_ ? {
      side: a,
      sideOffset: c,
      align: u,
      alignOffset: f,
      arrowPadding: h,
      collisionBoundary: m,
      collisionPadding: g,
      sticky: b,
      hideWhenDetached: x,
      avoidCollisions: w
    } : {};
    return /* @__PURE__ */ v.jsx(
      E$,
      {
        scope: n,
        content: M,
        viewport: P,
        onViewportChange: I,
        itemRefCallback: pe,
        selectedItem: L,
        onItemLeave: F,
        itemTextRefCallback: ee,
        focusSelectedItem: Q,
        selectedItemText: B,
        position: r,
        isPositioned: he,
        searchRef: W,
        children: /* @__PURE__ */ v.jsx(rw, { as: kae, allowPinchZoom: !0, children: /* @__PURE__ */ v.jsx(
          tw,
          {
            asChild: !0,
            trapped: _.open,
            onMountAutoFocus: (J) => {
              J.preventDefault();
            },
            onUnmountAutoFocus: Ye(i, (J) => {
              _.trigger?.focus({ preventScroll: !0 }), J.preventDefault();
            }),
            children: /* @__PURE__ */ v.jsx(
              zg,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: o,
                onPointerDownOutside: s,
                onFocusOutside: (J) => J.preventDefault(),
                onDismiss: () => _.onOpenChange(!1),
                children: /* @__PURE__ */ v.jsx(
                  ge,
                  {
                    role: "listbox",
                    id: _.contentId,
                    "data-state": _.open ? "open" : "closed",
                    dir: _.dir,
                    onContextMenu: (J) => J.preventDefault(),
                    ...S,
                    ...re,
                    onPlaced: () => ie(!0),
                    ref: O,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...S.style
                    },
                    onKeyDown: Ye(S.onKeyDown, (J) => {
                      const xe = J.ctrlKey || J.altKey || J.metaKey;
                      if (J.key === "Tab" && J.preventDefault(), !xe && J.key.length === 1 && Z(J.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(J.key)) {
                        let Ae = Y().filter((tt) => !tt.disabled).map((tt) => tt.ref.current);
                        if (["ArrowUp", "End"].includes(J.key) && (Ae = Ae.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(J.key)) {
                          const tt = J.target, Ge = Ae.indexOf(tt);
                          Ae = Ae.slice(Ge + 1);
                        }
                        setTimeout(() => H(Ae)), J.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
_$.displayName = Sae;
var Cae = "SelectItemAlignedPosition", T$ = k.forwardRef((e, t) => {
  const { __scopeSelect: n, onPlaced: r, ...i } = e, o = Ic(Ju, n), s = zc(Ju, n), [a, c] = k.useState(null), [u, f] = k.useState(null), h = Ft(t, (O) => f(O)), m = sw(n), g = k.useRef(!1), b = k.useRef(!0), { viewport: x, selectedItem: w, selectedItemText: S, focusSelectedItem: _ } = s, M = k.useCallback(() => {
    if (o.trigger && o.valueNode && a && u && x && w && S) {
      const O = o.trigger.getBoundingClientRect(), L = u.getBoundingClientRect(), U = o.valueNode.getBoundingClientRect(), B = S.getBoundingClientRect();
      if (o.dir !== "rtl") {
        const tt = B.left - L.left, Ge = U.left - tt, nt = O.left - Ge, _t = O.width + nt, yn = Math.max(_t, L.width), St = window.innerWidth - is, Vt = CE(Ge, [
          is,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(is, St - yn)
        ]);
        a.style.minWidth = _t + "px", a.style.left = Vt + "px";
      } else {
        const tt = L.right - B.right, Ge = window.innerWidth - U.right - tt, nt = window.innerWidth - O.right - Ge, _t = O.width + nt, yn = Math.max(_t, L.width), St = window.innerWidth - is, Vt = CE(Ge, [
          is,
          Math.max(is, St - yn)
        ]);
        a.style.minWidth = _t + "px", a.style.right = Vt + "px";
      }
      const G = m(), Y = window.innerHeight - is * 2, he = x.scrollHeight, ie = window.getComputedStyle(u), ne = parseInt(ie.borderTopWidth, 10), H = parseInt(ie.paddingTop, 10), Q = parseInt(ie.borderBottomWidth, 10), X = parseInt(ie.paddingBottom, 10), Se = ne + H + he + X + Q, W = Math.min(w.offsetHeight * 5, Se), Z = window.getComputedStyle(x), pe = parseInt(Z.paddingTop, 10), F = parseInt(Z.paddingBottom, 10), ee = O.top + O.height / 2 - is, ge = Y - ee, re = w.offsetHeight / 2, J = w.offsetTop + re, xe = ne + H + J, be = Se - xe;
      if (xe <= ee) {
        const tt = G.length > 0 && w === G[G.length - 1].ref.current;
        a.style.bottom = "0px";
        const Ge = u.clientHeight - x.offsetTop - x.offsetHeight, nt = Math.max(
          ge,
          re + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (tt ? F : 0) + Ge + Q
        ), _t = xe + nt;
        a.style.height = _t + "px";
      } else {
        const tt = G.length > 0 && w === G[0].ref.current;
        a.style.top = "0px";
        const nt = Math.max(
          ee,
          ne + x.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (tt ? pe : 0) + re
        ) + be;
        a.style.height = nt + "px", x.scrollTop = xe - ee + x.offsetTop;
      }
      a.style.margin = `${is}px 0`, a.style.minHeight = W + "px", a.style.maxHeight = Y + "px", r?.(), requestAnimationFrame(() => g.current = !0);
    }
  }, [
    m,
    o.trigger,
    o.valueNode,
    a,
    u,
    x,
    w,
    S,
    o.dir,
    r
  ]);
  Er(() => M(), [M]);
  const [N, P] = k.useState();
  Er(() => {
    u && P(window.getComputedStyle(u).zIndex);
  }, [u]);
  const I = k.useCallback(
    (O) => {
      O && b.current === !0 && (M(), _?.(), b.current = !1);
    },
    [M, _]
  );
  return /* @__PURE__ */ v.jsx(
    _ae,
    {
      scope: n,
      contentWrapper: a,
      shouldExpandOnScrollRef: g,
      onScrollButtonChange: I,
      children: /* @__PURE__ */ v.jsx(
        "div",
        {
          ref: c,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: N
          },
          children: /* @__PURE__ */ v.jsx(
            Et.div,
            {
              ...i,
              ref: h,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...i.style
              }
            }
          )
        }
      )
    }
  );
});
T$.displayName = Cae;
var Eae = "SelectPopperPosition", r_ = k.forwardRef((e, t) => {
  const {
    __scopeSelect: n,
    align: r = "start",
    collisionPadding: i = is,
    ...o
  } = e, s = aw(n);
  return /* @__PURE__ */ v.jsx(
    BA,
    {
      ...s,
      ...o,
      ref: t,
      align: r,
      collisionPadding: i,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...o.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
r_.displayName = Eae;
var [_ae, XA] = jh(Ju, {}), i_ = "SelectViewport", A$ = k.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, nonce: r, ...i } = e, o = zc(i_, n), s = XA(i_, n), a = Ft(t, o.onViewportChange), c = k.useRef(0);
    return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: r
        }
      ),
      /* @__PURE__ */ v.jsx(ow.Slot, { scope: n, children: /* @__PURE__ */ v.jsx(
        Et.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...i,
          ref: a,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...i.style
          },
          onScroll: Ye(i.onScroll, (u) => {
            const f = u.currentTarget, { contentWrapper: h, shouldExpandOnScrollRef: m } = s;
            if (m?.current && h) {
              const g = Math.abs(c.current - f.scrollTop);
              if (g > 0) {
                const b = window.innerHeight - is * 2, x = parseFloat(h.style.minHeight), w = parseFloat(h.style.height), S = Math.max(x, w);
                if (S < b) {
                  const _ = S + g, M = Math.min(b, _), N = _ - M;
                  h.style.height = M + "px", h.style.bottom === "0px" && (f.scrollTop = N > 0 ? N : 0, h.style.justifyContent = "flex-end");
                }
              }
            }
            c.current = f.scrollTop;
          })
        }
      ) })
    ] });
  }
);
A$.displayName = i_;
var M$ = "SelectGroup", [Tae, Aae] = jh(M$), N$ = k.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, i = Uo();
    return /* @__PURE__ */ v.jsx(Tae, { scope: n, id: i, children: /* @__PURE__ */ v.jsx(Et.div, { role: "group", "aria-labelledby": i, ...r, ref: t }) });
  }
);
N$.displayName = M$;
var R$ = "SelectLabel", O$ = k.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, i = Aae(R$, n);
    return /* @__PURE__ */ v.jsx(Et.div, { id: i.id, ...r, ref: t });
  }
);
O$.displayName = R$;
var lb = "SelectItem", [Mae, D$] = jh(lb), P$ = k.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      value: r,
      disabled: i = !1,
      textValue: o,
      ...s
    } = e, a = Ic(lb, n), c = zc(lb, n), u = a.value === r, [f, h] = k.useState(o ?? ""), [m, g] = k.useState(!1), b = Ft(
      t,
      (_) => c.itemRefCallback?.(_, r, i)
    ), x = Uo(), w = k.useRef("touch"), S = () => {
      i || (a.onValueChange(r), a.onOpenChange(!1));
    };
    if (r === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ v.jsx(
      Mae,
      {
        scope: n,
        value: r,
        disabled: i,
        textId: x,
        isSelected: u,
        onItemTextChange: k.useCallback((_) => {
          h((M) => M || (_?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ v.jsx(
          ow.ItemSlot,
          {
            scope: n,
            value: r,
            disabled: i,
            textValue: f,
            children: /* @__PURE__ */ v.jsx(
              Et.div,
              {
                role: "option",
                "aria-labelledby": x,
                "data-highlighted": m ? "" : void 0,
                "aria-selected": u && m,
                "data-state": u ? "checked" : "unchecked",
                "aria-disabled": i || void 0,
                "data-disabled": i ? "" : void 0,
                tabIndex: i ? void 0 : -1,
                ...s,
                ref: b,
                onFocus: Ye(s.onFocus, () => g(!0)),
                onBlur: Ye(s.onBlur, () => g(!1)),
                onClick: Ye(s.onClick, () => {
                  w.current !== "mouse" && S();
                }),
                onPointerUp: Ye(s.onPointerUp, () => {
                  w.current === "mouse" && S();
                }),
                onPointerDown: Ye(s.onPointerDown, (_) => {
                  w.current = _.pointerType;
                }),
                onPointerMove: Ye(s.onPointerMove, (_) => {
                  w.current = _.pointerType, i ? c.onItemLeave?.() : w.current === "mouse" && _.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: Ye(s.onPointerLeave, (_) => {
                  _.currentTarget === document.activeElement && c.onItemLeave?.();
                }),
                onKeyDown: Ye(s.onKeyDown, (_) => {
                  c.searchRef?.current !== "" && _.key === " " || (mae.includes(_.key) && S(), _.key === " " && _.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
P$.displayName = lb;
var sm = "SelectItemText", j$ = k.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: r, style: i, ...o } = e, s = Ic(sm, n), a = zc(sm, n), c = D$(sm, n), u = bae(sm, n), [f, h] = k.useState(null), m = Ft(
      t,
      (S) => h(S),
      c.onItemTextChange,
      (S) => a.itemTextRefCallback?.(S, c.value, c.disabled)
    ), g = f?.textContent, b = k.useMemo(
      () => /* @__PURE__ */ v.jsx("option", { value: c.value, disabled: c.disabled, children: g }, c.value),
      [c.disabled, c.value, g]
    ), { onNativeOptionAdd: x, onNativeOptionRemove: w } = u;
    return Er(() => (x(b), () => w(b)), [x, w, b]), /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(Et.span, { id: c.textId, ...o, ref: m }),
      c.isSelected && s.valueNode && !s.valueNodeHasChildren ? tl.createPortal(o.children, s.valueNode) : null
    ] });
  }
);
j$.displayName = sm;
var I$ = "SelectItemIndicator", z$ = k.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return D$(I$, n).isSelected ? /* @__PURE__ */ v.jsx(Et.span, { "aria-hidden": !0, ...r, ref: t }) : null;
  }
);
z$.displayName = I$;
var o_ = "SelectScrollUpButton", L$ = k.forwardRef((e, t) => {
  const n = zc(o_, e.__scopeSelect), r = XA(o_, e.__scopeSelect), [i, o] = k.useState(!1), s = Ft(t, r.onScrollButtonChange);
  return Er(() => {
    if (n.viewport && n.isPositioned) {
      let a = function() {
        const u = c.scrollTop > 0;
        o(u);
      };
      const c = n.viewport;
      return a(), c.addEventListener("scroll", a), () => c.removeEventListener("scroll", a);
    }
  }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ v.jsx(
    $$,
    {
      ...e,
      ref: s,
      onAutoScroll: () => {
        const { viewport: a, selectedItem: c } = n;
        a && c && (a.scrollTop = a.scrollTop - c.offsetHeight);
      }
    }
  ) : null;
});
L$.displayName = o_;
var s_ = "SelectScrollDownButton", B$ = k.forwardRef((e, t) => {
  const n = zc(s_, e.__scopeSelect), r = XA(s_, e.__scopeSelect), [i, o] = k.useState(!1), s = Ft(t, r.onScrollButtonChange);
  return Er(() => {
    if (n.viewport && n.isPositioned) {
      let a = function() {
        const u = c.scrollHeight - c.clientHeight, f = Math.ceil(c.scrollTop) < u;
        o(f);
      };
      const c = n.viewport;
      return a(), c.addEventListener("scroll", a), () => c.removeEventListener("scroll", a);
    }
  }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ v.jsx(
    $$,
    {
      ...e,
      ref: s,
      onAutoScroll: () => {
        const { viewport: a, selectedItem: c } = n;
        a && c && (a.scrollTop = a.scrollTop + c.offsetHeight);
      }
    }
  ) : null;
});
B$.displayName = s_;
var $$ = k.forwardRef((e, t) => {
  const { __scopeSelect: n, onAutoScroll: r, ...i } = e, o = zc("SelectScrollButton", n), s = k.useRef(null), a = sw(n), c = k.useCallback(() => {
    s.current !== null && (window.clearInterval(s.current), s.current = null);
  }, []);
  return k.useEffect(() => () => c(), [c]), Er(() => {
    a().find((f) => f.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [a]), /* @__PURE__ */ v.jsx(
    Et.div,
    {
      "aria-hidden": !0,
      ...i,
      ref: t,
      style: { flexShrink: 0, ...i.style },
      onPointerDown: Ye(i.onPointerDown, () => {
        s.current === null && (s.current = window.setInterval(r, 50));
      }),
      onPointerMove: Ye(i.onPointerMove, () => {
        o.onItemLeave?.(), s.current === null && (s.current = window.setInterval(r, 50));
      }),
      onPointerLeave: Ye(i.onPointerLeave, () => {
        c();
      })
    }
  );
}), Nae = "SelectSeparator", Rae = k.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return /* @__PURE__ */ v.jsx(Et.div, { "aria-hidden": !0, ...r, ref: t });
  }
);
Rae.displayName = Nae;
var a_ = "SelectArrow", Oae = k.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, i = aw(n), o = Ic(a_, n), s = zc(a_, n);
    return o.open && s.position === "popper" ? /* @__PURE__ */ v.jsx($A, { ...i, ...r, ref: t }) : null;
  }
);
Oae.displayName = a_;
var Dae = "SelectBubbleInput", U$ = k.forwardRef(
  ({ __scopeSelect: e, value: t, ...n }, r) => {
    const i = k.useRef(null), o = Ft(r, i), s = YA(t);
    return k.useEffect(() => {
      const a = i.current;
      if (!a) return;
      const c = window.HTMLSelectElement.prototype, f = Object.getOwnPropertyDescriptor(
        c,
        "value"
      ).set;
      if (s !== t && f) {
        const h = new Event("change", { bubbles: !0 });
        f.call(a, t), a.dispatchEvent(h);
      }
    }, [s, t]), /* @__PURE__ */ v.jsx(
      Et.select,
      {
        ...n,
        style: { ...O6, ...n.style },
        ref: o,
        defaultValue: t
      }
    );
  }
);
U$.displayName = Dae;
function F$(e) {
  return e === "" || e === void 0;
}
function V$(e) {
  const t = Dr(e), n = k.useRef(""), r = k.useRef(0), i = k.useCallback(
    (s) => {
      const a = n.current + s;
      t(a), (function c(u) {
        n.current = u, window.clearTimeout(r.current), u !== "" && (r.current = window.setTimeout(() => c(""), 1e3));
      })(a);
    },
    [t]
  ), o = k.useCallback(() => {
    n.current = "", window.clearTimeout(r.current);
  }, []);
  return k.useEffect(() => () => window.clearTimeout(r.current), []), [n, i, o];
}
function H$(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let s = Pae(e, Math.max(o, 0));
  i.length === 1 && (s = s.filter((u) => u !== n));
  const c = s.find(
    (u) => u.textValue.toLowerCase().startsWith(i.toLowerCase())
  );
  return c !== n ? c : void 0;
}
function Pae(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var jae = y$, Iae = b$, zae = w$, Lae = S$, Bae = k$, $ae = C$, Uae = A$, Fae = N$, Vae = O$, Hae = P$, Wae = j$, qae = z$, Gae = L$, Kae = B$;
function Zae({ ...e }) {
  return /* @__PURE__ */ v.jsx(jae, { "data-slot": "select", ...e });
}
function Yae({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Fae, { "data-slot": "select-group", ...e });
}
function Xae({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(zae, { "data-slot": "select-value", ...e });
}
function Jae({
  className: e,
  size: t = "default",
  children: n,
  ...r
}) {
  return /* @__PURE__ */ v.jsxs(
    Iae,
    {
      "data-slot": "select-trigger",
      "data-size": t,
      className: at(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ v.jsx(Lae, { asChild: !0, children: /* @__PURE__ */ v.jsx(Ag, { className: "size-4 opacity-50" }) })
      ]
    }
  );
}
function Qae({
  className: e,
  children: t,
  position: n = "popper",
  ...r
}) {
  return /* @__PURE__ */ v.jsx(Bae, { children: /* @__PURE__ */ v.jsxs(
    $ae,
    {
      "data-slot": "select-content",
      className: at(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
        n === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        e
      ),
      position: n,
      ...r,
      children: [
        /* @__PURE__ */ v.jsx(nle, {}),
        /* @__PURE__ */ v.jsx(
          Uae,
          {
            className: at(
              "p-1",
              n === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
            ),
            children: t
          }
        ),
        /* @__PURE__ */ v.jsx(rle, {})
      ]
    }
  ) });
}
function ele({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Vae,
    {
      "data-slot": "select-label",
      className: at("text-muted-foreground px-2 py-1.5 text-xs", e),
      ...t
    }
  );
}
function tle({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsxs(
    Hae,
    {
      "data-slot": "select-item",
      className: at(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        e
      ),
      ...n,
      children: [
        /* @__PURE__ */ v.jsx("span", { className: "absolute right-2 flex size-3.5 items-center justify-center", children: /* @__PURE__ */ v.jsx(qae, { children: /* @__PURE__ */ v.jsx(Sc, { className: "size-4" }) }) }),
        /* @__PURE__ */ v.jsx(Wae, { children: t })
      ]
    }
  );
}
function nle({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Gae,
    {
      "data-slot": "select-scroll-up-button",
      className: at("flex cursor-default items-center justify-center py-1", e),
      ...t,
      children: /* @__PURE__ */ v.jsx(vZ, { className: "size-4" })
    }
  );
}
function rle({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Kae,
    {
      "data-slot": "select-scroll-down-button",
      className: at("flex cursor-default items-center justify-center py-1", e),
      ...t,
      children: /* @__PURE__ */ v.jsx(Ag, { className: "size-4" })
    }
  );
}
const W$ = "gpt-4.1", cb = {
  ALLOWED_MCP_SERVERS: "allowed-mcp-servers",
  AI_USE_NEXT_SUGGESTION: "ai-use-next-suggestion"
}, ile = ({
  open: e,
  onOpenChange: t,
  setApiKeyByName: n
}) => {
  const [r, i] = k.useState(localStorage.getItem("ai-name") || W$), [o, s] = k.useState([]);
  k.useEffect(() => {
    const c = [];
    Object.entries(Zse).forEach(([u, f]) => {
      c.push({ provider: u, models: Object.keys(f) });
    }), s(c);
  }, []);
  const a = async () => {
    try {
      cn.success("Settings saved successfully"), n && await n(r), t(!1);
    } catch (c) {
      cn.error(c?.message || "Failed to save setting");
    }
  };
  return /* @__PURE__ */ v.jsx(Oh, { open: e, onOpenChange: t, children: /* @__PURE__ */ v.jsxs(Dh, { className: "max-w-sm", children: [
    /* @__PURE__ */ v.jsxs(Ug, { children: [
      /* @__PURE__ */ v.jsx(Ph, { children: "Settings" }),
      /* @__PURE__ */ v.jsx(m$, { className: "text-xs text-muted-foreground italic", children: "Configure your chatbot connection and identity. Your API key is kept locally and never shared." })
    ] }),
    /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 py-1", children: [
      /* @__PURE__ */ v.jsx($se, { htmlFor: "openai-name", children: "Model name" }),
      /* @__PURE__ */ v.jsxs(Zae, { value: r, onValueChange: i, children: [
        /* @__PURE__ */ v.jsx(Jae, { id: "openai-name", className: "w-full", children: /* @__PURE__ */ v.jsx(Xae, { placeholder: "Select a model" }) }),
        /* @__PURE__ */ v.jsx(
          Qae,
          {
            position: "popper",
            className: "z-[9999] max-h-[30vh] overflow-y-auto",
            children: o.map((c) => /* @__PURE__ */ v.jsxs(Yae, { children: [
              /* @__PURE__ */ v.jsx(ele, { children: c.provider }),
              c.models.map((u) => /* @__PURE__ */ v.jsx(tle, { value: u, children: u }, u))
            ] }, c.provider))
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ v.jsx(p$, { children: /* @__PURE__ */ v.jsx(Ht, { onClick: a, type: "button", children: "Save" }) })
  ] }) });
};
function sh({ className: e }) {
  return /* @__PURE__ */ v.jsxs(
    "svg",
    {
      "aria-hidden": "true",
      viewBox: "0 0 24 24",
      version: "1.1",
      className: e,
      "data-view-component": "true",
      children: [
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "currentColor",
            d: "M15.688 2.343a2.588 2.588 0 00-3.61 0l-9.626 9.44a.863.863 0 01-1.203 0 .823.823 0 010-1.18l9.626-9.44a4.313 4.313 0 016.016 0 4.116 4.116 0 011.204 3.54 4.3 4.3 0 013.609 1.18l.05.05a4.115 4.115 0 010 5.9l-8.706 8.537a.274.274 0 000 .393l1.788 1.754a.823.823 0 010 1.18.863.863 0 01-1.203 0l-1.788-1.753a1.92 1.92 0 010-2.754l8.706-8.538a2.47 2.47 0 000-3.54l-.05-.049a2.588 2.588 0 00-3.607-.003l-7.172 7.034-.002.002-.098.097a.863.863 0 01-1.204 0 .823.823 0 010-1.18l7.273-7.133a2.47 2.47 0 00-.003-3.537z"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "currentColor",
            d: "M14.485 4.703a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a4.115 4.115 0 000 5.9 4.314 4.314 0 006.016 0l7.12-6.982a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a2.588 2.588 0 01-3.61 0 2.47 2.47 0 010-3.54l7.12-6.982z"
          }
        )
      ]
    }
  );
}
function q$(e) {
  const t = e.trim().replace(/\/$/, "");
  return t ? /\/api\/v1$/.test(t) ? t : `${t}/api/v1` : "http://localhost:5000/api/v1";
}
function ole() {
  return "http://localhost:5000";
}
let Wa = q$(ole()), Ws = `${Wa}/mcp`, Fg = `${Wa}/thread`;
function sle(e) {
  Wa = q$(e), Ws = `${Wa}/mcp`, Fg = `${Wa}/thread`;
}
function ale(e) {
  const t = e.trim();
  if (!(t.startsWith("{") && t.endsWith("}") || t.startsWith("[") && t.endsWith("]"))) return { success: !1, data: e };
  try {
    return { success: !0, data: JSON.parse(e) };
  } catch {
    return { success: !1, data: e };
  }
}
function lle(e) {
  try {
    navigator.clipboard?.writeText(e);
  } catch {
  }
}
const Qu = k.memo(function({
  data: t,
  name: n,
  initialExpandDepth: r = 2,
  framed: i = !1,
  expandAll: o = !1
}) {
  const s = k.useMemo(() => {
    if (typeof t == "string") {
      const c = ale(t);
      return c.success ? c.data : t;
    }
    return t;
  }, [t]), a = k.useMemo(() => {
    try {
      return typeof s == "string" ? s : JSON.stringify(s, null, 2);
    } catch {
      return String(s);
    }
  }, [s]);
  return /* @__PURE__ */ v.jsxs(
    "div",
    {
      className: pc(
        "text-sm transition-all duration-300 w-full",
        i && "rounded-lg border bg-card overflow-hidden"
      ),
      children: [
        i && /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 px-3 py-2 border-b bg-muted/40", children: [
          /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground font-medium", children: n ?? "JSON" }),
          /* @__PURE__ */ v.jsx("div", { className: "flex-1" }),
          /* @__PURE__ */ v.jsx(
            "button",
            {
              className: "text-xs px-2 py-1 rounded border bg-background hover:bg-secondary",
              onClick: () => lle(a),
              title: "Copy JSON",
              children: "Copy"
            }
          )
        ] }),
        /* @__PURE__ */ v.jsx("div", { className: pc(i ? "px-3 py-3" : ""), children: /* @__PURE__ */ v.jsx(
          cle,
          {
            data: s,
            name: n,
            depth: 0,
            initialExpandDepth: r,
            expandAll: o
          }
        ) })
      ]
    }
  );
}), cle = k.memo(function e({
  data: t,
  name: n,
  depth: r,
  initialExpandDepth: i,
  expandAll: o = !1
}) {
  const a = ((m) => m === null ? "null" : Array.isArray(m) ? "array" : typeof m == "object" ? "object" : typeof m == "string" ? "string" : typeof m == "number" ? "number" : typeof m == "boolean" ? "boolean" : "undefined")(t), [c, u] = k.useState(
    a === "string" ? !!o : o ? !0 : r < i
  );
  k.useEffect(() => {
    u(
      a === "string" ? !!o : o ? !0 : r < i
    );
  }, [a, o, i, r, t]);
  const f = {
    key: "text-muted-foreground",
    string: "text-emerald-400",
    number: "text-sky-400",
    boolean: "text-amber-400",
    null: "text-fuchsia-400",
    undefined: "text-zinc-400",
    punct: "text-muted-foreground"
  }, h = n ? /* @__PURE__ */ v.jsxs("span", { className: pc("mr-1", f.key), children: [
    n,
    ":"
  ] }) : null;
  if (a === "object" || a === "array") {
    const m = a === "array", g = m ? t : Object.entries(t), b = g.length === 0, x = m ? "[" : "{", w = m ? "]" : "}";
    return b ? /* @__PURE__ */ v.jsxs("div", { className: "flex items-center", children: [
      h,
      /* @__PURE__ */ v.jsx("span", { className: f.punct, children: m ? "[]" : "{}" })
    ] }) : /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
      /* @__PURE__ */ v.jsxs(
        "div",
        {
          className: "flex items-center gap-1 rounded cursor-pointer hover:bg-input/30 px-1 -mx-1",
          onClick: () => u((S) => !S),
          title: c ? "Collapse" : "Expand",
          children: [
            h,
            c ? /* @__PURE__ */ v.jsx("span", { className: f.punct, children: x }) : /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
              /* @__PURE__ */ v.jsx("span", { className: f.punct, children: m ? "[  ]" : "{  }" }),
              /* @__PURE__ */ v.jsxs("span", { className: "ml-1 text-muted-foreground", children: [
                g.length,
                " ",
                g.length === 1 ? "item" : "items"
              ] })
            ] })
          ]
        }
      ),
      c && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
        /* @__PURE__ */ v.jsx("div", { className: "pl-3 ml-3 border-l border-border/60", children: m ? g.map((S, _) => /* @__PURE__ */ v.jsx("div", { className: "my-1", children: /* @__PURE__ */ v.jsx(
          e,
          {
            data: S,
            name: String(_),
            depth: r + 1,
            initialExpandDepth: i,
            expandAll: o
          }
        ) }, _)) : g.map(([S, _]) => /* @__PURE__ */ v.jsx("div", { className: "my-1", children: /* @__PURE__ */ v.jsx(
          e,
          {
            data: _,
            name: S,
            depth: r + 1,
            initialExpandDepth: i,
            expandAll: o
          }
        ) }, S)) }),
        /* @__PURE__ */ v.jsx("span", { className: pc("mt-0.5", f.punct), children: w })
      ] })
    ] });
  }
  if (a === "string") {
    const m = t, g = 120;
    return m.length > g ? /* @__PURE__ */ v.jsx(
      ule,
      {
        label: h,
        value: m,
        styles: f,
        max: g,
        initialOpen: o
      }
    ) : /* @__PURE__ */ v.jsxs("div", { className: "flex items-start", children: [
      h,
      /* @__PURE__ */ v.jsxs(
        "pre",
        {
          className: pc(
            f.string,
            "whitespace-pre-wrap break-words"
          ),
          children: [
            '"',
            m,
            '"'
          ]
        }
      )
    ] });
  }
  return /* @__PURE__ */ v.jsxs("div", { className: "flex items-start", children: [
    h,
    a === "number" && /* @__PURE__ */ v.jsx("span", { className: f.number, children: String(t) }),
    a === "boolean" && /* @__PURE__ */ v.jsx("span", { className: f.boolean, children: String(t) }),
    a === "null" && /* @__PURE__ */ v.jsx("span", { className: f.null, children: "null" }),
    a === "undefined" && /* @__PURE__ */ v.jsx("span", { className: f.undefined, children: "undefined" })
  ] });
});
function ule({
  label: e,
  value: t,
  styles: n,
  max: r,
  initialOpen: i = !1
}) {
  const [o, s] = k.useState(i);
  return /* @__PURE__ */ v.jsxs("div", { className: "flex items-start", children: [
    e,
    /* @__PURE__ */ v.jsx(
      "pre",
      {
        className: pc(
          n.string,
          "whitespace-pre-wrap wrap-break-word cursor-pointer hover:text-green-400"
        ),
        onClick: () => s((a) => !a),
        title: o ? "Collapse" : "Expand",
        children: o ? `"${t}"` : `"${t.slice(0, r)}..."`
      }
    )
  ] });
}
const dle = {
  "Content-Type": "application/json"
};
let fle = null;
function hle() {
  if (typeof window > "u") return null;
  const e = window.__CHATBOT_CONFIG__;
  return !e || typeof e != "object" ? null : e;
}
async function ple() {
  const e = hle();
  try {
    const t = e?.getAuthToken;
    if (typeof t == "function") {
      const n = await t();
      if (typeof n == "string" && n.trim()) return n.trim();
    }
  } catch {
  }
  if (typeof e?.authToken == "string" && e.authToken.trim())
    return e.authToken.trim();
  try {
    const n = await window?.Clerk?.session?.getToken?.();
    if (typeof n == "string" && n.trim()) return n.trim();
  } catch {
  }
  try {
    const t = localStorage.getItem("access_token") ?? localStorage.getItem("token") ?? localStorage.getItem("jwt") ?? "";
    return t && t.trim() ? t.trim() : null;
  } catch {
    return null;
  }
}
async function Lc() {
  const e = await ple();
  return {
    ...dle,
    ...e ? { Authorization: `Bearer ${e}` } : {}
  };
}
const mle = async (e, t) => {
  const n = await Lc(), r = await fetch(e, {
    redirect: "follow",
    cache: "no-store",
    ...t,
    headers: {
      ...n,
      ...t?.headers
    }
  });
  if (!r.ok) {
    let i;
    try {
      i = await r.json();
    } catch {
      i = { message: `Request failed with status ${r.status}` };
    }
    const o = new Error(
      i.message || "An error occurred while fetching the data."
    );
    throw Object.assign(o, { info: i, status: r.status }), o;
  }
  return r.json();
}, ah = (e) => typeof e == "string", gle = (e) => Object(e) === e, yle = (e) => {
  try {
    if (typeof e == "string") {
      const t = e.trim();
      return JSON.parse(t), !0;
    } else if (gle(e))
      return !0;
    return !1;
  } catch {
    return !1;
  }
}, NLe = () => {
  let e;
  const t = (n, r = 200) => (clearTimeout(e), e = setTimeout(() => n(), r), e);
  return t.clear = () => {
    clearTimeout(e);
  }, t;
};
function vle() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e) => {
    const t = Math.random() * 16 | 0;
    return (e === "x" ? t : t & 3 | 8).toString(16);
  });
}
function ble(e) {
  return e == null ? "unknown error" : typeof e == "string" ? e : e instanceof Error ? e.message : JSON.stringify(e);
}
function G$(e) {
  return {
    map: (t) => Object.fromEntries(
      Object.entries(e).map(([n, r]) => [n, t(r, n)])
    ),
    filter: (t) => Object.fromEntries(
      Object.entries(e).filter(([n, r]) => t(r, n))
    ),
    forEach: (t) => {
      Object.entries(e).forEach(([n, r]) => t(r, n));
    },
    some: (t) => Object.entries(e).some(([n, r]) => t(r, n)),
    every: (t) => Object.entries(e).every(([n, r]) => t(r, n)),
    find(t) {
      return Object.entries(e).find(([n, r]) => t(r, n))?.[1];
    },
    getByPath(t) {
      let n = e;
      return t.find((r) => (n = n?.[r], !n)), n;
    },
    setByPath(t, n) {
      return t.reduce((r, i, o) => o == t.length - 1 ? (r[i] = n, r) : (r[i] ??= {}, r[i]), e), e;
    }
  };
}
function RLe(e, t) {
  let n = e, r = 1;
  for (; t.includes(n); ) {
    const i = e.replace(/\d+$/, "");
    if (e !== i) {
      const s = parseInt(e.match(/\d+$/)?.[0] || "0");
      n = i + (s + r);
    } else
      n = i + r;
    r++;
  }
  return n;
}
function vj(e) {
  return e ? e.startsWith("user_") ? e.replace("user_", "") : e : null;
}
const ub = (e, t) => (cn.error(`${e?.name || "Error"}`, {
  description: /* @__PURE__ */ v.jsx("div", { className: "my-4 max-h-[340px] overflow-y-auto", children: /* @__PURE__ */ v.jsx(Qu, { data: ble(e) }) }),
  id: t
}), e), xle = k.createContext(null);
function ra() {
  const e = k.useContext(xle);
  if (!e)
    throw new Error("useAppStore must be used within an AppProvider");
  return e;
}
const K$ = 0, Z$ = 1, Y$ = 2, bj = 3;
var xj = Object.prototype.hasOwnProperty;
function l_(e, t) {
  var n, r;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((r = e.length) === t.length)
        for (; r-- && l_(e[r], t[r]); ) ;
      return r === -1;
    }
    if (!n || typeof e == "object") {
      r = 0;
      for (n in e)
        if (xj.call(e, n) && ++r && !xj.call(t, n) || !(n in t) || !l_(e[n], t[n])) return !1;
      return Object.keys(t).length === r;
    }
  }
  return e !== e && t !== t;
}
const Ua = /* @__PURE__ */ new WeakMap(), Va = () => {
}, hi = (
  /*#__NOINLINE__*/
  Va()
), c_ = Object, Xt = (e) => e === hi, Vs = (e) => typeof e == "function", Ac = (e, t) => ({
  ...e,
  ...t
}), X$ = (e) => Vs(e.then), zk = {}, Ov = {}, JA = "undefined", Vg = typeof window != JA, u_ = typeof document != JA, wle = Vg && "Deno" in window, Sle = () => Vg && typeof window.requestAnimationFrame != JA, J$ = (e, t) => {
  const n = Ua.get(e);
  return [
    // Getter
    () => !Xt(t) && e.get(t) || zk,
    // Setter
    (r) => {
      if (!Xt(t)) {
        const i = e.get(t);
        t in Ov || (Ov[t] = i), n[5](t, Ac(i, r), i || zk);
      }
    },
    // Subscriber
    n[6],
    // Get server cache snapshot
    () => !Xt(t) && t in Ov ? Ov[t] : !Xt(t) && e.get(t) || zk
  ];
};
let d_ = !0;
const kle = () => d_, [f_, h_] = Vg && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  Va,
  Va
], Cle = () => {
  const e = u_ && document.visibilityState;
  return Xt(e) || e !== "hidden";
}, Ele = (e) => (u_ && document.addEventListener("visibilitychange", e), f_("focus", e), () => {
  u_ && document.removeEventListener("visibilitychange", e), h_("focus", e);
}), _le = (e) => {
  const t = () => {
    d_ = !0, e();
  }, n = () => {
    d_ = !1;
  };
  return f_("online", t), f_("offline", n), () => {
    h_("online", t), h_("offline", n);
  };
}, Tle = {
  isOnline: kle,
  isVisible: Cle
}, Ale = {
  initFocus: Ele,
  initReconnect: _le
}, wj = !Ne.useId, Kf = !Vg || wle, Mle = (e) => Sle() ? window.requestAnimationFrame(e) : setTimeout(e, 1), Lk = Kf ? k.useEffect : k.useLayoutEffect, Bk = typeof navigator < "u" && navigator.connection, Sj = !Kf && Bk && ([
  "slow-2g",
  "2g"
].includes(Bk.effectiveType) || Bk.saveData), Dv = /* @__PURE__ */ new WeakMap(), Nle = (e) => c_.prototype.toString.call(e), $k = (e, t) => e === `[object ${t}]`;
let Rle = 0;
const p_ = (e) => {
  const t = typeof e, n = Nle(e), r = $k(n, "Date"), i = $k(n, "RegExp"), o = $k(n, "Object");
  let s, a;
  if (c_(e) === e && !r && !i) {
    if (s = Dv.get(e), s) return s;
    if (s = ++Rle + "~", Dv.set(e, s), Array.isArray(e)) {
      for (s = "@", a = 0; a < e.length; a++)
        s += p_(e[a]) + ",";
      Dv.set(e, s);
    }
    if (o) {
      s = "#";
      const c = c_.keys(e).sort();
      for (; !Xt(a = c.pop()); )
        Xt(e[a]) || (s += a + ":" + p_(e[a]) + ",");
      Dv.set(e, s);
    }
  } else
    s = r ? e.toJSON() : t == "symbol" ? e.toString() : t == "string" ? JSON.stringify(e) : "" + e;
  return s;
}, QA = (e) => {
  if (Vs(e))
    try {
      e = e();
    } catch {
      e = "";
    }
  const t = e;
  return e = typeof e == "string" ? e : (Array.isArray(e) ? e.length : e) ? p_(e) : "", [
    e,
    t
  ];
};
let Ole = 0;
const m_ = () => ++Ole;
async function Q$(...e) {
  const [t, n, r, i] = e, o = Ac({
    populateCache: !0,
    throwOnError: !0
  }, typeof i == "boolean" ? {
    revalidate: i
  } : i || {});
  let s = o.populateCache;
  const a = o.rollbackOnError;
  let c = o.optimisticData;
  const u = (m) => typeof a == "function" ? a(m) : a !== !1, f = o.throwOnError;
  if (Vs(n)) {
    const m = n, g = [], b = t.keys();
    for (const x of b)
      // Skip the special useSWRInfinite and useSWRSubscription keys.
      !/^\$(inf|sub)\$/.test(x) && m(t.get(x)._k) && g.push(x);
    return Promise.all(g.map(h));
  }
  return h(n);
  async function h(m) {
    const [g] = QA(m);
    if (!g) return;
    const [b, x] = J$(t, g), [w, S, _, M] = Ua.get(t), N = () => {
      const ie = w[g];
      return (Vs(o.revalidate) ? o.revalidate(b().data, m) : o.revalidate !== !1) && (delete _[g], delete M[g], ie && ie[0]) ? ie[0](Y$).then(() => b().data) : b().data;
    };
    if (e.length < 3)
      return N();
    let P = r, I, O = !1;
    const L = m_();
    S[g] = [
      L,
      0
    ];
    const U = !Xt(c), B = b(), G = B.data, Y = B._c, he = Xt(Y) ? G : Y;
    if (U && (c = Vs(c) ? c(he, G) : c, x({
      data: c,
      _c: he
    })), Vs(P))
      try {
        P = P(he);
      } catch (ie) {
        I = ie, O = !0;
      }
    if (P && X$(P))
      if (P = await P.catch((ie) => {
        I = ie, O = !0;
      }), L !== S[g][0]) {
        if (O) throw I;
        return P;
      } else O && U && u(I) && (s = !0, x({
        data: he,
        _c: hi
      }));
    if (s && !O)
      if (Vs(s)) {
        const ie = s(P, he);
        x({
          data: ie,
          error: hi,
          _c: hi
        });
      } else
        x({
          data: P,
          error: hi,
          _c: hi
        });
    if (S[g][1] = m_(), Promise.resolve(N()).then(() => {
      x({
        _c: hi
      });
    }), O) {
      if (f) throw I;
      return;
    }
    return P;
  }
}
const kj = (e, t) => {
  for (const n in e)
    e[n][0] && e[n][0](t);
}, Dle = (e, t) => {
  if (!Ua.has(e)) {
    const n = Ac(Ale, t), r = /* @__PURE__ */ Object.create(null), i = Q$.bind(hi, e);
    let o = Va;
    const s = /* @__PURE__ */ Object.create(null), a = (f, h) => {
      const m = s[f] || [];
      return s[f] = m, m.push(h), () => m.splice(m.indexOf(h), 1);
    }, c = (f, h, m) => {
      e.set(f, h);
      const g = s[f];
      if (g)
        for (const b of g)
          b(h, m);
    }, u = () => {
      if (!Ua.has(e) && (Ua.set(e, [
        r,
        /* @__PURE__ */ Object.create(null),
        /* @__PURE__ */ Object.create(null),
        /* @__PURE__ */ Object.create(null),
        i,
        c,
        a
      ]), !Kf)) {
        const f = n.initFocus(setTimeout.bind(hi, kj.bind(hi, r, K$))), h = n.initReconnect(setTimeout.bind(hi, kj.bind(hi, r, Z$)));
        o = () => {
          f && f(), h && h(), Ua.delete(e);
        };
      }
    };
    return u(), [
      e,
      i,
      u,
      o
    ];
  }
  return [
    e,
    Ua.get(e)[4]
  ];
}, Ple = (e, t, n, r, i) => {
  const o = n.errorRetryCount, s = i.retryCount, a = ~~((Math.random() + 0.5) * (1 << (s < 8 ? s : 8))) * n.errorRetryInterval;
  !Xt(o) && s > o || setTimeout(r, a, i);
}, jle = l_, [e9, g_] = Dle(/* @__PURE__ */ new Map()), Ile = Ac(
  {
    // events
    onLoadingSlow: Va,
    onSuccess: Va,
    onError: Va,
    onErrorRetry: Ple,
    onDiscarded: Va,
    // switches
    revalidateOnFocus: !0,
    revalidateOnReconnect: !0,
    revalidateIfStale: !0,
    shouldRetryOnError: !0,
    // timeouts
    errorRetryInterval: Sj ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: Sj ? 5e3 : 3e3,
    // providers
    compare: jle,
    isPaused: () => !1,
    cache: e9,
    mutate: g_,
    fallback: {}
  },
  // use web preset by default
  Tle
), zle = (e, t) => {
  const n = Ac(e, t);
  if (t) {
    const { use: r, fallback: i } = e, { use: o, fallback: s } = t;
    r && o && (n.use = r.concat(o)), i && s && (n.fallback = Ac(i, s));
  }
  return n;
}, Lle = k.createContext({}), Ble = "$inf$", t9 = Vg && window.__SWR_DEVTOOLS_USE__, $le = t9 ? window.__SWR_DEVTOOLS_USE__ : [], Ule = () => {
  t9 && (window.__SWR_DEVTOOLS_REACT__ = Ne);
}, Fle = (e) => Vs(e[1]) ? [
  e[0],
  e[1],
  e[2] || {}
] : [
  e[0],
  null,
  (e[1] === null ? e[2] : e[1]) || {}
], n9 = () => {
  const e = k.useContext(Lle);
  return k.useMemo(() => Ac(Ile, e), [
    e
  ]);
}, Vle = (e) => (t, n, r) => e(t, n && ((...o) => {
  const [s] = QA(t), [, , , a] = Ua.get(e9);
  if (s.startsWith(Ble))
    return n(...o);
  const c = a[s];
  return Xt(c) ? n(...o) : (delete a[s], c);
}), r), Hle = $le.concat(Vle), Wle = (e) => function(...n) {
  const r = n9(), [i, o, s] = Fle(n), a = zle(r, s);
  let c = e;
  const { use: u } = a, f = (u || []).concat(Hle);
  for (let h = f.length; h--; )
    c = f[h](c);
  return c(i, o || a.fetcher || null, a);
}, qle = (e, t, n) => {
  const r = t[e] || (t[e] = []);
  return r.push(n), () => {
    const i = r.indexOf(n);
    i >= 0 && (r[i] = r[r.length - 1], r.pop());
  };
};
Ule();
const Uk = Ne.use || // This extra generic is to avoid TypeScript mixing up the generic and JSX sytax
// and emitting an error.
// We assume that this is only for the `use(thenable)` case, not `use(context)`.
// https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45
((e) => {
  switch (e.status) {
    case "pending":
      throw e;
    case "fulfilled":
      return e.value;
    case "rejected":
      throw e.reason;
    default:
      throw e.status = "pending", e.then((t) => {
        e.status = "fulfilled", e.value = t;
      }, (t) => {
        e.status = "rejected", e.reason = t;
      }), e;
  }
}), Fk = {
  dedupe: !0
}, Cj = Promise.resolve(hi), Gle = () => Va, Kle = (e, t, n) => {
  const { cache: r, compare: i, suspense: o, fallbackData: s, revalidateOnMount: a, revalidateIfStale: c, refreshInterval: u, refreshWhenHidden: f, refreshWhenOffline: h, keepPreviousData: m, strictServerPrefetchWarning: g } = n, [b, x, w, S] = Ua.get(r), [_, M] = QA(e), N = k.useRef(!1), P = k.useRef(!1), I = k.useRef(_), O = k.useRef(t), L = k.useRef(n), U = () => L.current, B = () => U().isVisible() && U().isOnline(), [G, Y, he, ie] = J$(r, _), ne = k.useRef({}).current, H = Xt(s) ? Xt(n.fallback) ? hi : n.fallback[_] : s, Q = (St, Vt) => {
    for (const xt in ne) {
      const Kt = xt;
      if (Kt === "data") {
        if (!i(St[Kt], Vt[Kt]) && (!Xt(St[Kt]) || !i(re, Vt[Kt])))
          return !1;
      } else if (Vt[Kt] !== St[Kt])
        return !1;
    }
    return !0;
  }, X = !N.current, Se = k.useMemo(() => {
    const St = G(), Vt = ie(), xt = (sn) => {
      const Pn = Ac(sn);
      return delete Pn._k, (() => {
        if (!_ || !t || U().isPaused()) return !1;
        if (X && !Xt(a)) return a;
        const mt = Xt(H) ? Pn.data : H;
        return Xt(mt) || c;
      })() ? {
        isValidating: !0,
        isLoading: !0,
        ...Pn
      } : Pn;
    }, Kt = xt(St), An = St === Vt ? Kt : xt(Vt);
    let Nt = Kt;
    return [
      () => {
        const sn = xt(G());
        return Q(sn, Nt) ? (Nt.data = sn.data, Nt.isLoading = sn.isLoading, Nt.isValidating = sn.isValidating, Nt.error = sn.error, Nt) : (Nt = sn, sn);
      },
      () => An
    ];
  }, [
    r,
    _
  ]), W = th.useSyncExternalStore(k.useCallback(
    (St) => he(_, (Vt, xt) => {
      Q(xt, Vt) || St();
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      r,
      _
    ]
  ), Se[0], Se[1]), Z = b[_] && b[_].length > 0, pe = W.data, F = Xt(pe) ? H && X$(H) ? Uk(H) : H : pe, ee = W.error, ge = k.useRef(F), re = m ? Xt(pe) ? Xt(ge.current) ? F : ge.current : pe : F, J = _ && Xt(F), xe = k.useRef(null);
  !Kf && // getServerSnapshot is only called during hydration
  // eslint-disable-next-line react-hooks/rules-of-hooks
  th.useSyncExternalStore(Gle, () => (xe.current = !1, xe), () => (xe.current = !0, xe));
  const be = xe.current;
  g && be && !o && J && console.warn(`Missing pre-initiated data for serialized key "${_}" during server-side rendering. Data fetching should be initiated on the server and provided to SWR via fallback data. You can set "strictServerPrefetchWarning: false" to disable this warning.`);
  const Ae = !_ || !t || U().isPaused() || Z && !Xt(ee) ? !1 : X && !Xt(a) ? a : o ? Xt(F) ? !1 : c : Xt(F) || c, tt = Xt(W.isValidating) ? Ae : W.isValidating, Ge = Xt(W.isLoading) ? Ae : W.isLoading, nt = k.useCallback(
    async (St) => {
      const Vt = O.current;
      if (!_ || !Vt || P.current || U().isPaused())
        return !1;
      let xt, Kt, An = !0;
      const Nt = St || {}, sn = !w[_] || !Nt.dedupe, Pn = () => wj ? !P.current && _ === I.current && N.current : _ === I.current, Mn = {
        isValidating: !1,
        isLoading: !1
      }, mt = () => {
        Y(Mn);
      }, ke = () => {
        const He = w[_];
        He && He[1] === Kt && delete w[_];
      }, Pe = {
        isValidating: !0
      };
      Xt(G().data) && (Pe.isLoading = !0);
      try {
        if (sn && (Y(Pe), n.loadingTimeout && Xt(G().data) && setTimeout(() => {
          An && Pn() && U().onLoadingSlow(_, n);
        }, n.loadingTimeout), w[_] = [
          Vt(M),
          m_()
        ]), [xt, Kt] = w[_], xt = await xt, sn && setTimeout(ke, n.dedupingInterval), !w[_] || w[_][1] !== Kt)
          return sn && Pn() && U().onDiscarded(_), !1;
        Mn.error = hi;
        const He = x[_];
        if (!Xt(He) && // case 1
        (Kt <= He[0] || // case 2
        Kt <= He[1] || // case 3
        He[1] === 0))
          return mt(), sn && Pn() && U().onDiscarded(_), !1;
        const et = G().data;
        Mn.data = i(et, xt) ? et : xt, sn && Pn() && U().onSuccess(xt, _, n);
      } catch (He) {
        ke();
        const et = U(), { shouldRetryOnError: bt } = et;
        et.isPaused() || (Mn.error = He, sn && Pn() && (et.onError(He, _, et), (bt === !0 || Vs(bt) && bt(He)) && (!U().revalidateOnFocus || !U().revalidateOnReconnect || B()) && et.onErrorRetry(He, _, et, (Ct) => {
          const fn = b[_];
          fn && fn[0] && fn[0](bj, Ct);
        }, {
          retryCount: (Nt.retryCount || 0) + 1,
          dedupe: !0
        })));
      }
      return An = !1, mt(), !0;
    },
    // `setState` is immutable, and `eventsCallback`, `fnArg`, and
    // `keyValidating` are depending on `key`, so we can exclude them from
    // the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // `useSWR('key', () => fetch('/api/'), { suspense: true })`
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      _,
      r
    ]
  ), _t = k.useCallback(
    // Use callback to make sure `keyRef.current` returns latest result every time
    (...St) => Q$(r, I.current, ...St),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (Lk(() => {
    O.current = t, L.current = n, Xt(pe) || (ge.current = pe);
  }), Lk(() => {
    if (!_) return;
    const St = nt.bind(hi, Fk);
    let Vt = 0;
    U().revalidateOnFocus && (Vt = Date.now() + U().focusThrottleInterval);
    const Kt = qle(_, b, (An, Nt = {}) => {
      if (An == K$) {
        const sn = Date.now();
        U().revalidateOnFocus && sn > Vt && B() && (Vt = sn + U().focusThrottleInterval, St());
      } else if (An == Z$)
        U().revalidateOnReconnect && B() && St();
      else {
        if (An == Y$)
          return nt();
        if (An == bj)
          return nt(Nt);
      }
    });
    return P.current = !1, I.current = _, N.current = !0, Y({
      _k: M
    }), Ae && (w[_] || (Xt(F) || Kf ? St() : Mle(St))), () => {
      P.current = !0, Kt();
    };
  }, [
    _
  ]), Lk(() => {
    let St;
    function Vt() {
      const Kt = Vs(u) ? u(G().data) : u;
      Kt && St !== -1 && (St = setTimeout(xt, Kt));
    }
    function xt() {
      !G().error && (f || U().isVisible()) && (h || U().isOnline()) ? nt(Fk).then(Vt) : Vt();
    }
    return Vt(), () => {
      St && (clearTimeout(St), St = -1);
    };
  }, [
    u,
    f,
    h,
    _
  ]), k.useDebugValue(re), o) {
    if (!wj && Kf && J)
      throw new Error("Fallback data is required when using Suspense in SSR.");
    J && (O.current = t, L.current = n, P.current = !1);
    const St = S[_], Vt = !Xt(St) && J ? _t(St) : Cj;
    if (Uk(Vt), !Xt(ee) && J)
      throw ee;
    const xt = J ? nt(Fk) : Cj;
    !Xt(re) && J && (xt.status = "fulfilled", xt.value = !0), Uk(xt);
  }
  return {
    mutate: _t,
    get data() {
      return ne.data = !0, re;
    },
    get error() {
      return ne.error = !0, ee;
    },
    get isValidating() {
      return ne.isValidating = !0, tt;
    },
    get isLoading() {
      return ne.isLoading = !0, Ge;
    }
  };
}, Zle = Wle(Kle);
function r9(e) {
  const t = ra(), n = async (i, o) => {
    const s = await mle(i, o);
    return Array.isArray(s) ? s : s && Array.isArray(s.servers) ? s.servers : [];
  }, r = Zle(`${Ws}/list`, n, {
    revalidateOnFocus: !1,
    errorRetryCount: 0,
    focusThrottleInterval: 1e3 * 60 * 5,
    // ensure returned data is an array for consumers
    fallbackData: [],
    onError: ub,
    onSuccess: (i) => {
      if (!Array.isArray(i)) {
        t.chatbotServerStore.mcpServerList.value = [];
        return;
      }
      const o = new Set(i.map((s) => String(s.id)));
      t.chatbotServerStore.mcpServerList.value = i, t.chatbotServerStore.allowedMcpServers.value = G$(t.chatbotServerStore.allowedMcpServers.value || {}).filter(
        (s, a) => o.has(String(a))
      );
    },
    ...e
  });
  return k.useEffect(() => {
    (async () => {
      try {
        const i = await Lc();
        t.chatbotServerStore.loadMcpServersInBackground({
          token: null,
          baseUrl: "",
          headers: i
          // Pass full headers including auth
        });
      } catch (i) {
        console.warn("Failed to get auth headers for worker:", i), t.chatbotServerStore.loadMcpServersInBackground();
      }
    })();
  }, [t.chatbotServerStore]), r;
}
function i9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card",
      className: at(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        e
      ),
      ...t
    }
  );
}
function o9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-header",
      className: at(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        e
      ),
      ...t
    }
  );
}
function Yle({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-title",
      className: at("leading-none font-semibold", e),
      ...t
    }
  );
}
function Xle({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-description",
      className: at("text-muted-foreground text-sm", e),
      ...t
    }
  );
}
function s9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-content",
      className: at("px-6", e),
      ...t
    }
  );
}
function eM({ className: e, type: t, ...n }) {
  return /* @__PURE__ */ v.jsx(
    "input",
    {
      type: t,
      "data-slot": "input",
      className: at(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-sm border bg-transparent px-3 py-1 text-xs shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50",
        "focus:border-input focus-visible:border-input",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        e
      ),
      ...n
    }
  );
}
var Jle = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Qle = Jle.reduce((e, t) => {
  const n = /* @__PURE__ */ qx(`Primitive.${t}`), r = k.forwardRef((i, o) => {
    const { asChild: s, ...a } = i, c = s ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ v.jsx(c, { ...a, ref: o });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), ece = "Separator", Ej = "horizontal", tce = ["horizontal", "vertical"], tM = k.forwardRef((e, t) => {
  const { decorative: n, orientation: r = Ej, ...i } = e, o = nce(r) ? r : Ej, a = n ? { role: "none" } : { "aria-orientation": o === "vertical" ? o : void 0, role: "separator" };
  return /* @__PURE__ */ v.jsx(
    Qle.div,
    {
      "data-orientation": o,
      ...a,
      ...i,
      ref: t
    }
  );
});
tM.displayName = ece;
function nce(e) {
  return tce.includes(e);
}
var rce = tM;
function db({
  className: e,
  orientation: t = "horizontal",
  decorative: n = !0,
  ...r
}) {
  return /* @__PURE__ */ v.jsx(
    rce,
    {
      "data-slot": "separator",
      decorative: n,
      orientation: t,
      className: at(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        e
      ),
      ...r
    }
  );
}
const ice = (e) => {
  if (!e) return !0;
  const t = e.properties || e;
  return Object.keys(t).length === 0;
}, oce = ({
  tool: e,
  children: t,
  serverId: n,
  onUpdate: r
}) => /* @__PURE__ */ v.jsxs(Oh, { children: [
  /* @__PURE__ */ v.jsx(f$, { asChild: !0, children: t }),
  /* @__PURE__ */ v.jsx(h$, { children: /* @__PURE__ */ v.jsx(Dh, { className: "sm:max-w-[800px] fixed p-10 overflow-hidden", children: /* @__PURE__ */ v.jsx(
    sce,
    {
      onUpdate: r,
      tool: e,
      serverId: n
    }
  ) }) })
] });
function sce({
  tool: e,
  title: t
  // serverId,
  // onUpdate,
}) {
  return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col overflow-y-auto h-[70vh]", children: [
    /* @__PURE__ */ v.jsxs("div", { className: "space-y-6 pb-4", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3", children: [
        /* @__PURE__ */ v.jsx("div", { className: "shrink-0 w-8 h-8 rounded-lg bg-primary/10 flex items-center justify-center", children: /* @__PURE__ */ v.jsx(
          "svg",
          {
            className: "w-4 h-4 text-primary",
            fill: "none",
            strokeWidth: "2",
            stroke: "currentColor",
            viewBox: "0 0 24 24",
            children: /* @__PURE__ */ v.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M11.42 15.17L17.25 21A2.652 2.652 0 0021 17.25l-5.877-5.877M11.42 15.17l2.496-3.03c.317-.384.74-.626 1.208-.766M11.42 15.17l-4.655 5.653a2.548 2.548 0 11-3.586-3.586l6.837-5.63m5.108-.233c.55-.164 1.163-.188 1.743-.14a4.5 4.5 0 004.486-6.336l-3.276 3.277a3.004 3.004 0 01-2.25-2.25l3.276-3.276a4.5 4.5 0 00-6.336 4.486c.091 1.076-.071 2.264-.904 2.95l-.102.085m-1.745 1.437L5.909 7.5H4.5L2.25 3.75l1.5-1.5L7.5 4.5v1.409l4.26 4.26m-1.745 1.437l1.745-1.437m6.615 8.206L15.75 15.75M4.867 19.125h.008v.008h-.008v-.008z" })
          }
        ) }),
        /* @__PURE__ */ v.jsx(Ph, { className: "text-xl font-normal tracking-tight", children: t || e.name })
      ] }),
      /* @__PURE__ */ v.jsx("div", { className: "space-y-2", children: /* @__PURE__ */ v.jsx(m$, { className: "text-sm leading-relaxed text-foreground/90 whitespace-pre-wrap", children: e.description }) })
    ] }),
    /* @__PURE__ */ v.jsx(db, { className: "my-6" }),
    /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-2 mb-3", children: /* @__PURE__ */ v.jsx("h5", { className: "text-sm font-normal text-foreground/90", children: "Input Schema" }) }),
    e.inputSchema ? /* @__PURE__ */ v.jsx("div", { className: "overflow-y-auto max-h-[40vh] space-y-3", children: ice(e.inputSchema) ? /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground", children: "No schema properties available" }) : /* @__PURE__ */ v.jsx(Qu, { data: e.inputSchema?.properties || e.inputSchema }) }) : /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground", children: "No schema properties available" }),
    /* @__PURE__ */ v.jsx("div", { className: "absolute left-0 right-0 bottom-0 h-12 bg-linear-to-t from-background to-transparent pointer-events-none z-10" })
  ] });
}
const ace = k.memo(
  ({ tools: e, serverId: t, searchQuery: n = "" }) => {
    const r = k.useMemo(() => {
      if (!n.trim()) return e;
      const i = n.toLowerCase();
      return e.filter(
        (o) => o.name.toLowerCase().includes(i) || o.description?.toLowerCase().includes(i)
      );
    }, [e, n]);
    return /* @__PURE__ */ v.jsx("div", { className: "space-y-2 pr-2", children: r.length > 0 ? r.map((i) => /* @__PURE__ */ v.jsxs(
      "div",
      {
        className: "flex items-start gap-2 bg-secondary rounded-md p-2 hover:bg-input transition-colors",
        children: [
          /* @__PURE__ */ v.jsx(oce, { tool: i, serverId: t, children: /* @__PURE__ */ v.jsxs("div", { className: "flex-1 min-w-0 cursor-pointer", children: [
            /* @__PURE__ */ v.jsx("p", { className: "font-medium text-sm mb-1 truncate", children: i.name }),
            /* @__PURE__ */ v.jsx("p", { className: "text-xs text-muted-foreground line-clamp-1", children: i.description })
          ] }) }),
          /* @__PURE__ */ v.jsx("div", { className: "flex items-center px-1 justify-center self-stretch", children: /* @__PURE__ */ v.jsx(Mg, { size: 16 }) })
        ]
      },
      i.name
    )) : /* @__PURE__ */ v.jsxs("div", { className: "text-center py-6 text-sm text-muted-foreground", children: [
      'No tools found matching "',
      n,
      '"'
    ] }) });
  }
), lce = AA(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive: "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function a9({
  className: e,
  variant: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "alert",
      role: "alert",
      className: at(lce({ variant: t }), e),
      ...n
    }
  );
}
function l9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "alert-title",
      className: at(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        e
      ),
      ...t
    }
  );
}
function c9({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "alert-description",
      className: at(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        e
      ),
      ...t
    }
  );
}
const u9 = k.memo(({ error: e }) => /* @__PURE__ */ v.jsx("div", { className: "px-6 pb-2", children: /* @__PURE__ */ v.jsxs(a9, { variant: "destructive", className: "border-destructive", children: [
  /* @__PURE__ */ v.jsx(l9, { children: "Error" }),
  /* @__PURE__ */ v.jsx(c9, { className: "whitespace-pre-wrap wrap-break-word", children: e })
] }) }));
u9.displayName = "ErrorAlert";
function cce({ className: e }) {
  return /* @__PURE__ */ v.jsx(
    "svg",
    {
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      className: e,
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      "aria-hidden": "true",
      children: /* @__PURE__ */ v.jsx(
        "path",
        {
          d: "M15.6729 3.91287C16.8918 2.69392 18.8682 2.69392 20.0871 3.91287C21.3061 5.13182 21.3061 7.10813 20.0871 8.32708L14.1499 14.2643C13.3849 15.0293 12.3925 15.5255 11.3215 15.6785L9.14142 15.9899C8.82983 16.0344 8.51546 15.9297 8.29289 15.7071C8.07033 15.4845 7.96554 15.1701 8.01005 14.8586L8.32149 12.6785C8.47449 11.6075 8.97072 10.615 9.7357 9.85006L15.6729 3.91287ZM18.6729 5.32708C18.235 4.88918 17.525 4.88918 17.0871 5.32708L11.1499 11.2643C10.6909 11.7233 10.3932 12.3187 10.3014 12.9613L10.1785 13.8215L11.0386 13.6986C11.6812 13.6068 12.2767 13.3091 12.7357 12.8501L18.6729 6.91287C19.1108 6.47497 19.1108 5.76499 18.6729 5.32708ZM11 3.99929C11.0004 4.55157 10.5531 4.99963 10.0008 5.00007C9.00227 5.00084 8.29769 5.00827 7.74651 5.06064C7.20685 5.11191 6.88488 5.20117 6.63803 5.32695C6.07354 5.61457 5.6146 6.07351 5.32698 6.63799C5.19279 6.90135 5.10062 7.24904 5.05118 7.8542C5.00078 8.47105 5 9.26336 5 10.4V13.6C5 14.7366 5.00078 15.5289 5.05118 16.1457C5.10062 16.7509 5.19279 17.0986 5.32698 17.3619C5.6146 17.9264 6.07354 18.3854 6.63803 18.673C6.90138 18.8072 7.24907 18.8993 7.85424 18.9488C8.47108 18.9992 9.26339 19 10.4 19H13.6C14.7366 19 15.5289 18.9992 16.1458 18.9488C16.7509 18.8993 17.0986 18.8072 17.362 18.673C17.9265 18.3854 18.3854 17.9264 18.673 17.3619C18.7988 17.1151 18.8881 16.7931 18.9393 16.2535C18.9917 15.7023 18.9991 14.9977 18.9999 13.9992C19.0003 13.4469 19.4484 12.9995 20.0007 13C20.553 13.0004 21.0003 13.4485 20.9999 14.0007C20.9991 14.9789 20.9932 15.7808 20.9304 16.4426C20.8664 17.116 20.7385 17.7136 20.455 18.2699C19.9757 19.2107 19.2108 19.9756 18.27 20.455C17.6777 20.7568 17.0375 20.8826 16.3086 20.9421C15.6008 21 14.7266 21 13.6428 21H10.3572C9.27339 21 8.39925 21 7.69138 20.9421C6.96253 20.8826 6.32234 20.7568 5.73005 20.455C4.78924 19.9756 4.02433 19.2107 3.54497 18.2699C3.24318 17.6776 3.11737 17.0374 3.05782 16.3086C2.99998 15.6007 2.99999 14.7266 3 13.6428V10.3572C2.99999 9.27337 2.99998 8.39922 3.05782 7.69134C3.11737 6.96249 3.24318 6.3223 3.54497 5.73001C4.02433 4.7892 4.78924 4.0243 5.73005 3.54493C6.28633 3.26149 6.88399 3.13358 7.55735 3.06961C8.21919 3.00673 9.02103 3.00083 9.99922 3.00007C10.5515 2.99964 10.9996 3.447 11 3.99929Z",
          fill: "currentColor"
        }
      )
    }
  );
}
function ri(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function el(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function y_({
  pathname: e = "/",
  search: t = "",
  hash: n = ""
}) {
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e;
}
function nM(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && (t.hash = e.substring(n), e = e.substring(0, n));
    let r = e.indexOf("?");
    r >= 0 && (t.search = e.substring(r), e = e.substring(0, r)), e && (t.pathname = e);
  }
  return t;
}
function d9(e, t, n = "/") {
  return uce(e, t, n, !1);
}
function uce(e, t, n, r) {
  let i = typeof t == "string" ? nM(t) : t, o = Mc(i.pathname || "/", n);
  if (o == null)
    return null;
  let s = f9(e);
  dce(s);
  let a = null;
  for (let c = 0; a == null && c < s.length; ++c) {
    let u = Sce(o);
    a = xce(
      s[c],
      u,
      r
    );
  }
  return a;
}
function f9(e, t = [], n = [], r = "", i = !1) {
  let o = (s, a, c = i, u) => {
    let f = {
      relativePath: u === void 0 ? s.path || "" : u,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: a,
      route: s
    };
    if (f.relativePath.startsWith("/")) {
      if (!f.relativePath.startsWith(r) && c)
        return;
      ri(
        f.relativePath.startsWith(r),
        `Absolute route path "${f.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      ), f.relativePath = f.relativePath.slice(r.length);
    }
    let h = qa([r, f.relativePath]), m = n.concat(f);
    s.children && s.children.length > 0 && (ri(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      s.index !== !0,
      `Index routes must not have child routes. Please remove all child routes from route path "${h}".`
    ), f9(
      s.children,
      t,
      m,
      h,
      c
    )), !(s.path == null && !s.index) && t.push({
      path: h,
      score: vce(h, s.index),
      routesMeta: m
    });
  };
  return e.forEach((s, a) => {
    if (s.path === "" || !s.path?.includes("?"))
      o(s, a);
    else
      for (let c of h9(s.path))
        o(s, a, !0, c);
  }), t;
}
function h9(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, "");
  if (r.length === 0)
    return i ? [o, ""] : [o];
  let s = h9(r.join("/")), a = [];
  return a.push(
    ...s.map(
      (c) => c === "" ? o : [o, c].join("/")
    )
  ), i && a.push(...s), a.map(
    (c) => e.startsWith("/") && c === "" ? "/" : c
  );
}
function dce(e) {
  e.sort(
    (t, n) => t.score !== n.score ? n.score - t.score : bce(
      t.routesMeta.map((r) => r.childrenIndex),
      n.routesMeta.map((r) => r.childrenIndex)
    )
  );
}
var fce = /^:[\w-]+$/, hce = 3, pce = 2, mce = 1, gce = 10, yce = -2, _j = (e) => e === "*";
function vce(e, t) {
  let n = e.split("/"), r = n.length;
  return n.some(_j) && (r += yce), t && (r += pce), n.filter((i) => !_j(i)).reduce(
    (i, o) => i + (fce.test(o) ? hce : o === "" ? mce : gce),
    r
  );
}
function bce(e, t) {
  return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function xce(e, t, n = !1) {
  let { routesMeta: r } = e, i = {}, o = "/", s = [];
  for (let a = 0; a < r.length; ++a) {
    let c = r[a], u = a === r.length - 1, f = o === "/" ? t : t.slice(o.length) || "/", h = fb(
      { path: c.relativePath, caseSensitive: c.caseSensitive, end: u },
      f
    ), m = c.route;
    if (!h && u && n && !r[r.length - 1].route.index && (h = fb(
      {
        path: c.relativePath,
        caseSensitive: c.caseSensitive,
        end: !1
      },
      f
    )), !h)
      return null;
    Object.assign(i, h.params), s.push({
      // TODO: Can this as be avoided?
      params: i,
      pathname: qa([o, h.pathname]),
      pathnameBase: _ce(
        qa([o, h.pathnameBase])
      ),
      route: m
    }), h.pathnameBase !== "/" && (o = qa([o, h.pathnameBase]));
  }
  return s;
}
function fb(e, t) {
  typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 });
  let [n, r] = wce(
    e.path,
    e.caseSensitive,
    e.end
  ), i = t.match(n);
  if (!i) return null;
  let o = i[0], s = o.replace(/(.)\/+$/, "$1"), a = i.slice(1);
  return {
    params: r.reduce(
      (u, { paramName: f, isOptional: h }, m) => {
        if (f === "*") {
          let b = a[m] || "";
          s = o.slice(0, o.length - b.length).replace(/(.)\/+$/, "$1");
        }
        const g = a[m];
        return h && !g ? u[f] = void 0 : u[f] = (g || "").replace(/%2F/g, "/"), u;
      },
      {}
    ),
    pathname: o,
    pathnameBase: s,
    pattern: e
  };
}
function wce(e, t = !1, n = !0) {
  el(
    e === "*" || !e.endsWith("*") || e.endsWith("/*"),
    `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`
  );
  let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (s, a, c) => (r.push({ paramName: a, isOptional: c != null }), c ? "/?([^\\/]+)?" : "/([^\\/]+)")
  ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  return e.endsWith("*") ? (r.push({ paramName: "*" }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r];
}
function Sce(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return el(
      !1,
      `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`
    ), e;
  }
}
function Mc(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/";
}
var kce = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
function Cce(e, t = "/") {
  let {
    pathname: n,
    search: r = "",
    hash: i = ""
  } = typeof e == "string" ? nM(e) : e, o;
  return n ? (n = n.replace(/\/\/+/g, "/"), n.startsWith("/") ? o = Tj(n.substring(1), "/") : o = Tj(n, t)) : o = t, {
    pathname: o,
    search: Tce(r),
    hash: Ace(i)
  };
}
function Tj(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((i) => {
    i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
  }), n.length > 1 ? n.join("/") : "/";
}
function Vk(e, t, n, r) {
  return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(
    r
  )}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function Ece(e) {
  return e.filter(
    (t, n) => n === 0 || t.route.path && t.route.path.length > 0
  );
}
function p9(e) {
  let t = Ece(e);
  return t.map(
    (n, r) => r === t.length - 1 ? n.pathname : n.pathnameBase
  );
}
function m9(e, t, n, r = !1) {
  let i;
  typeof e == "string" ? i = nM(e) : (i = { ...e }, ri(
    !i.pathname || !i.pathname.includes("?"),
    Vk("?", "pathname", "search", i)
  ), ri(
    !i.pathname || !i.pathname.includes("#"),
    Vk("#", "pathname", "hash", i)
  ), ri(
    !i.search || !i.search.includes("#"),
    Vk("#", "search", "hash", i)
  ));
  let o = e === "" || i.pathname === "", s = o ? "/" : i.pathname, a;
  if (s == null)
    a = n;
  else {
    let h = t.length - 1;
    if (!r && s.startsWith("..")) {
      let m = s.split("/");
      for (; m[0] === ".."; )
        m.shift(), h -= 1;
      i.pathname = m.join("/");
    }
    a = h >= 0 ? t[h] : "/";
  }
  let c = Cce(i, a), u = s && s !== "/" && s.endsWith("/"), f = (o || s === ".") && n.endsWith("/");
  return !c.pathname.endsWith("/") && (u || f) && (c.pathname += "/"), c;
}
var qa = (e) => e.join("/").replace(/\/\/+/g, "/"), _ce = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), Tce = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, Ace = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, Mce = class {
  constructor(e, t, n, r = !1) {
    this.status = e, this.statusText = t || "", this.internal = r, n instanceof Error ? (this.data = n.toString(), this.error = n) : this.data = n;
  }
};
function Nce(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
function Rce(e) {
  return e.map((t) => t.route.path).filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/";
}
var g9 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
function y9(e, t) {
  let n = e;
  if (typeof n != "string" || !kce.test(n))
    return {
      absoluteURL: void 0,
      isExternal: !1,
      to: n
    };
  let r = n, i = !1;
  if (g9)
    try {
      let o = new URL(window.location.href), s = n.startsWith("//") ? new URL(o.protocol + n) : new URL(n), a = Mc(s.pathname, t);
      s.origin === o.origin && a != null ? n = a + s.search + s.hash : i = !0;
    } catch {
      el(
        !1,
        `<Link to="${n}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
      );
    }
  return {
    absoluteURL: r,
    isExternal: i,
    to: n
  };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var v9 = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
new Set(
  v9
);
var Oce = [
  "GET",
  ...v9
];
new Set(Oce);
var Ih = k.createContext(null);
Ih.displayName = "DataRouter";
var lw = k.createContext(null);
lw.displayName = "DataRouterState";
var Dce = k.createContext(!1), b9 = k.createContext({
  isTransitioning: !1
});
b9.displayName = "ViewTransition";
var Pce = k.createContext(
  /* @__PURE__ */ new Map()
);
Pce.displayName = "Fetchers";
var jce = k.createContext(null);
jce.displayName = "Await";
var gs = k.createContext(
  null
);
gs.displayName = "Navigation";
var rM = k.createContext(
  null
);
rM.displayName = "Location";
var rl = k.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
rl.displayName = "Route";
var iM = k.createContext(null);
iM.displayName = "RouteError";
var x9 = "REACT_ROUTER_ERROR", Ice = "REDIRECT", zce = "ROUTE_ERROR_RESPONSE";
function Lce(e) {
  if (e.startsWith(`${x9}:${Ice}:{`))
    try {
      let t = JSON.parse(e.slice(28));
      if (typeof t == "object" && t && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.location == "string" && typeof t.reloadDocument == "boolean" && typeof t.replace == "boolean")
        return t;
    } catch {
    }
}
function Bce(e) {
  if (e.startsWith(
    `${x9}:${zce}:{`
  ))
    try {
      let t = JSON.parse(e.slice(40));
      if (typeof t == "object" && t && typeof t.status == "number" && typeof t.statusText == "string")
        return new Mce(
          t.status,
          t.statusText,
          t.data
        );
    } catch {
    }
}
function $ce(e, { relative: t } = {}) {
  ri(
    cw(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: n, navigator: r } = k.useContext(gs), { hash: i, pathname: o, search: s } = Hg(e, { relative: t }), a = o;
  return n !== "/" && (a = o === "/" ? n : qa([n, o])), r.createHref({ pathname: a, search: s, hash: i });
}
function cw() {
  return k.useContext(rM) != null;
}
function dd() {
  return ri(
    cw(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ), k.useContext(rM).location;
}
var w9 = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function S9(e) {
  k.useContext(gs).static || k.useLayoutEffect(e);
}
function k9() {
  let { isDataRoute: e } = k.useContext(rl);
  return e ? Qce() : Uce();
}
function Uce() {
  ri(
    cw(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let e = k.useContext(Ih), { basename: t, navigator: n } = k.useContext(gs), { matches: r } = k.useContext(rl), { pathname: i } = dd(), o = JSON.stringify(p9(r)), s = k.useRef(!1);
  return S9(() => {
    s.current = !0;
  }), k.useCallback(
    (c, u = {}) => {
      if (el(s.current, w9), !s.current) return;
      if (typeof c == "number") {
        n.go(c);
        return;
      }
      let f = m9(
        c,
        JSON.parse(o),
        i,
        u.relative === "path"
      );
      e == null && t !== "/" && (f.pathname = f.pathname === "/" ? t : qa([t, f.pathname])), (u.replace ? n.replace : n.push)(
        f,
        u.state,
        u
      );
    },
    [
      t,
      n,
      o,
      i,
      e
    ]
  );
}
k.createContext(null);
function Hg(e, { relative: t } = {}) {
  let { matches: n } = k.useContext(rl), { pathname: r } = dd(), i = JSON.stringify(p9(n));
  return k.useMemo(
    () => m9(
      e,
      JSON.parse(i),
      r,
      t === "path"
    ),
    [e, i, r, t]
  );
}
function Fce(e, t, n, r, i) {
  ri(
    cw(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: o } = k.useContext(gs), { matches: s } = k.useContext(rl), a = s[s.length - 1], c = a ? a.params : {}, u = a ? a.pathname : "/", f = a ? a.pathnameBase : "/", h = a && a.route;
  {
    let _ = h && h.path || "";
    E9(
      u,
      !h || _.endsWith("*") || _.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${_}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${_}"> to <Route path="${_ === "/" ? "*" : `${_}/*`}">.`
    );
  }
  let m = dd(), g;
  g = m;
  let b = g.pathname || "/", x = b;
  if (f !== "/") {
    let _ = f.replace(/^\//, "").split("/");
    x = "/" + b.replace(/^\//, "").split("/").slice(_.length).join("/");
  }
  let w = d9(e, { pathname: x });
  return el(
    h || w != null,
    `No routes matched location "${g.pathname}${g.search}${g.hash}" `
  ), el(
    w == null || w[w.length - 1].route.element !== void 0 || w[w.length - 1].route.Component !== void 0 || w[w.length - 1].route.lazy !== void 0,
    `Matched leaf route at location "${g.pathname}${g.search}${g.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
  ), Gce(
    w && w.map(
      (_) => Object.assign({}, _, {
        params: Object.assign({}, c, _.params),
        pathname: qa([
          f,
          // Re-encode pathnames that were decoded inside matchRoutes.
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          o.encodeLocation ? o.encodeLocation(
            _.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : _.pathname
        ]),
        pathnameBase: _.pathnameBase === "/" ? f : qa([
          f,
          // Re-encode pathnames that were decoded inside matchRoutes
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          o.encodeLocation ? o.encodeLocation(
            _.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : _.pathnameBase
        ])
      })
    ),
    s,
    n,
    r,
    i
  );
}
function Vce() {
  let e = Jce(), t = Nce(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, r = "rgba(200,200,200, 0.5)", i = { padding: "0.5rem", backgroundColor: r }, o = { padding: "2px 4px", backgroundColor: r }, s = null;
  return console.error(
    "Error handled by React Router default ErrorBoundary:",
    e
  ), s = /* @__PURE__ */ k.createElement(k.Fragment, null, /* @__PURE__ */ k.createElement("p", null, " Hey developer "), /* @__PURE__ */ k.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ k.createElement("code", { style: o }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ k.createElement("code", { style: o }, "errorElement"), " prop on your route.")), /* @__PURE__ */ k.createElement(k.Fragment, null, /* @__PURE__ */ k.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ k.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? /* @__PURE__ */ k.createElement("pre", { style: i }, n) : null, s);
}
var Hce = /* @__PURE__ */ k.createElement(Vce, null), C9 = class extends k.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    this.props.onError ? this.props.onError(e, t) : console.error(
      "React Router caught the following error during render",
      e
    );
  }
  render() {
    let e = this.state.error;
    if (this.context && typeof e == "object" && e && "digest" in e && typeof e.digest == "string") {
      const n = Bce(e.digest);
      n && (e = n);
    }
    let t = e !== void 0 ? /* @__PURE__ */ k.createElement(rl.Provider, { value: this.props.routeContext }, /* @__PURE__ */ k.createElement(
      iM.Provider,
      {
        value: e,
        children: this.props.component
      }
    )) : this.props.children;
    return this.context ? /* @__PURE__ */ k.createElement(Wce, { error: e }, t) : t;
  }
};
C9.contextType = Dce;
var Hk = /* @__PURE__ */ new WeakMap();
function Wce({
  children: e,
  error: t
}) {
  let { basename: n } = k.useContext(gs);
  if (typeof t == "object" && t && "digest" in t && typeof t.digest == "string") {
    let r = Lce(t.digest);
    if (r) {
      let i = Hk.get(t);
      if (i) throw i;
      let o = y9(r.location, n);
      if (g9 && !Hk.get(t))
        if (o.isExternal || r.reloadDocument)
          window.location.href = o.absoluteURL || o.to;
        else {
          const s = Promise.resolve().then(
            () => window.__reactRouterDataRouter.navigate(o.to, {
              replace: r.replace
            })
          );
          throw Hk.set(t, s), s;
        }
      return /* @__PURE__ */ k.createElement(
        "meta",
        {
          httpEquiv: "refresh",
          content: `0;url=${o.absoluteURL || o.to}`
        }
      );
    }
  }
  return e;
}
function qce({ routeContext: e, match: t, children: n }) {
  let r = k.useContext(Ih);
  return r && r.static && r.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ k.createElement(rl.Provider, { value: e }, n);
}
function Gce(e, t = [], n = null, r = null, i = null) {
  if (e == null) {
    if (!n)
      return null;
    if (n.errors)
      e = n.matches;
    else if (t.length === 0 && !n.initialized && n.matches.length > 0)
      e = n.matches;
    else
      return null;
  }
  let o = e, s = n?.errors;
  if (s != null) {
    let f = o.findIndex(
      (h) => h.route.id && s?.[h.route.id] !== void 0
    );
    ri(
      f >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        s
      ).join(",")}`
    ), o = o.slice(
      0,
      Math.min(o.length, f + 1)
    );
  }
  let a = !1, c = -1;
  if (n)
    for (let f = 0; f < o.length; f++) {
      let h = o[f];
      if ((h.route.HydrateFallback || h.route.hydrateFallbackElement) && (c = f), h.route.id) {
        let { loaderData: m, errors: g } = n, b = h.route.loader && !m.hasOwnProperty(h.route.id) && (!g || g[h.route.id] === void 0);
        if (h.route.lazy || b) {
          a = !0, c >= 0 ? o = o.slice(0, c + 1) : o = [o[0]];
          break;
        }
      }
    }
  let u = n && r ? (f, h) => {
    r(f, {
      location: n.location,
      params: n.matches?.[0]?.params ?? {},
      unstable_pattern: Rce(n.matches),
      errorInfo: h
    });
  } : void 0;
  return o.reduceRight(
    (f, h, m) => {
      let g, b = !1, x = null, w = null;
      n && (g = s && h.route.id ? s[h.route.id] : void 0, x = h.route.errorElement || Hce, a && (c < 0 && m === 0 ? (E9(
        "route-fallback",
        !1,
        "No `HydrateFallback` element provided to render during initial hydration"
      ), b = !0, w = null) : c === m && (b = !0, w = h.route.hydrateFallbackElement || null)));
      let S = t.concat(o.slice(0, m + 1)), _ = () => {
        let M;
        return g ? M = x : b ? M = w : h.route.Component ? M = /* @__PURE__ */ k.createElement(h.route.Component, null) : h.route.element ? M = h.route.element : M = f, /* @__PURE__ */ k.createElement(
          qce,
          {
            match: h,
            routeContext: {
              outlet: f,
              matches: S,
              isDataRoute: n != null
            },
            children: M
          }
        );
      };
      return n && (h.route.ErrorBoundary || h.route.errorElement || m === 0) ? /* @__PURE__ */ k.createElement(
        C9,
        {
          location: n.location,
          revalidation: n.revalidation,
          component: x,
          error: g,
          children: _(),
          routeContext: { outlet: null, matches: S, isDataRoute: !0 },
          onError: u
        }
      ) : _();
    },
    null
  );
}
function oM(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function Kce(e) {
  let t = k.useContext(Ih);
  return ri(t, oM(e)), t;
}
function Zce(e) {
  let t = k.useContext(lw);
  return ri(t, oM(e)), t;
}
function Yce(e) {
  let t = k.useContext(rl);
  return ri(t, oM(e)), t;
}
function sM(e) {
  let t = Yce(e), n = t.matches[t.matches.length - 1];
  return ri(
    n.route.id,
    `${e} can only be used on routes that contain a unique "id"`
  ), n.route.id;
}
function Xce() {
  return sM(
    "useRouteId"
    /* UseRouteId */
  );
}
function Jce() {
  let e = k.useContext(iM), t = Zce(
    "useRouteError"
    /* UseRouteError */
  ), n = sM(
    "useRouteError"
    /* UseRouteError */
  );
  return e !== void 0 ? e : t.errors?.[n];
}
function Qce() {
  let { router: e } = Kce(
    "useNavigate"
    /* UseNavigateStable */
  ), t = sM(
    "useNavigate"
    /* UseNavigateStable */
  ), n = k.useRef(!1);
  return S9(() => {
    n.current = !0;
  }), k.useCallback(
    async (i, o = {}) => {
      el(n.current, w9), n.current && (typeof i == "number" ? await e.navigate(i) : await e.navigate(i, { fromRouteId: t, ...o }));
    },
    [e, t]
  );
}
var Aj = {};
function E9(e, t, n) {
  !t && !Aj[e] && (Aj[e] = !0, el(!1, n));
}
k.memo(eue);
function eue({
  routes: e,
  future: t,
  state: n,
  onError: r
}) {
  return Fce(e, void 0, n, r, t);
}
var w0 = "get", S0 = "application/x-www-form-urlencoded";
function uw(e) {
  return typeof HTMLElement < "u" && e instanceof HTMLElement;
}
function tue(e) {
  return uw(e) && e.tagName.toLowerCase() === "button";
}
function nue(e) {
  return uw(e) && e.tagName.toLowerCase() === "form";
}
function rue(e) {
  return uw(e) && e.tagName.toLowerCase() === "input";
}
function iue(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function oue(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !iue(e);
}
var Pv = null;
function sue() {
  if (Pv === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), Pv = !1;
    } catch {
      Pv = !0;
    }
  return Pv;
}
var aue = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function Wk(e) {
  return e != null && !aue.has(e) ? (el(
    !1,
    `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${S0}"`
  ), null) : e;
}
function lue(e, t) {
  let n, r, i, o, s;
  if (nue(e)) {
    let a = e.getAttribute("action");
    r = a ? Mc(a, t) : null, n = e.getAttribute("method") || w0, i = Wk(e.getAttribute("enctype")) || S0, o = new FormData(e);
  } else if (tue(e) || rue(e) && (e.type === "submit" || e.type === "image")) {
    let a = e.form;
    if (a == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let c = e.getAttribute("formaction") || a.getAttribute("action");
    if (r = c ? Mc(c, t) : null, n = e.getAttribute("formmethod") || a.getAttribute("method") || w0, i = Wk(e.getAttribute("formenctype")) || Wk(a.getAttribute("enctype")) || S0, o = new FormData(a, e), !sue()) {
      let { name: u, type: f, value: h } = e;
      if (f === "image") {
        let m = u ? `${u}.` : "";
        o.append(`${m}x`, "0"), o.append(`${m}y`, "0");
      } else u && o.append(u, h);
    }
  } else {
    if (uw(e))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    n = w0, r = null, i = S0, s = e;
  }
  return o && i === "text/plain" && (s = o, o = void 0), { action: r, method: n.toLowerCase(), encType: i, formData: o, body: s };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function aM(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function cue(e, t, n, r) {
  let i = typeof e == "string" ? new URL(
    e,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window > "u" ? "server://singlefetch/" : window.location.origin
  ) : e;
  return n ? i.pathname.endsWith("/") ? i.pathname = `${i.pathname}_.${r}` : i.pathname = `${i.pathname}.${r}` : i.pathname === "/" ? i.pathname = `_root.${r}` : t && Mc(i.pathname, t) === "/" ? i.pathname = `${t.replace(/\/$/, "")}/_root.${r}` : i.pathname = `${i.pathname.replace(/\/$/, "")}.${r}`, i;
}
async function uue(e, t) {
  if (e.id in t)
    return t[e.id];
  try {
    let n = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e.module
    );
    return t[e.id] = n, n;
  } catch (n) {
    return console.error(
      `Error loading route module \`${e.module}\`, reloading page...`
    ), console.error(n), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
    });
  }
}
function due(e) {
  return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string";
}
async function fue(e, t, n) {
  let r = await Promise.all(
    e.map(async (i) => {
      let o = t.routes[i.route.id];
      if (o) {
        let s = await uue(o, n);
        return s.links ? s.links() : [];
      }
      return [];
    })
  );
  return gue(
    r.flat(1).filter(due).filter((i) => i.rel === "stylesheet" || i.rel === "preload").map(
      (i) => i.rel === "stylesheet" ? { ...i, rel: "prefetch", as: "style" } : { ...i, rel: "prefetch" }
    )
  );
}
function Mj(e, t, n, r, i, o) {
  let s = (c, u) => n[u] ? c.route.id !== n[u].route.id : !0, a = (c, u) => (
    // param change, /users/123 -> /users/456
    n[u].pathname !== c.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    n[u].route.path?.endsWith("*") && n[u].params["*"] !== c.params["*"]
  );
  return o === "assets" ? t.filter(
    (c, u) => s(c, u) || a(c, u)
  ) : o === "data" ? t.filter((c, u) => {
    let f = r.routes[c.route.id];
    if (!f || !f.hasLoader)
      return !1;
    if (s(c, u) || a(c, u))
      return !0;
    if (c.route.shouldRevalidate) {
      let h = c.route.shouldRevalidate({
        currentUrl: new URL(
          i.pathname + i.search + i.hash,
          window.origin
        ),
        currentParams: n[0]?.params || {},
        nextUrl: new URL(e, window.origin),
        nextParams: c.params,
        defaultShouldRevalidate: !0
      });
      if (typeof h == "boolean")
        return h;
    }
    return !0;
  }) : [];
}
function hue(e, t, { includeHydrateFallback: n } = {}) {
  return pue(
    e.map((r) => {
      let i = t.routes[r.route.id];
      if (!i) return [];
      let o = [i.module];
      return i.clientActionModule && (o = o.concat(i.clientActionModule)), i.clientLoaderModule && (o = o.concat(i.clientLoaderModule)), n && i.hydrateFallbackModule && (o = o.concat(i.hydrateFallbackModule)), i.imports && (o = o.concat(i.imports)), o;
    }).flat(1)
  );
}
function pue(e) {
  return [...new Set(e)];
}
function mue(e) {
  let t = {}, n = Object.keys(e).sort();
  for (let r of n)
    t[r] = e[r];
  return t;
}
function gue(e, t) {
  let n = /* @__PURE__ */ new Set();
  return new Set(t), e.reduce((r, i) => {
    let o = JSON.stringify(mue(i));
    return n.has(o) || (n.add(o), r.push({ key: o, link: i })), r;
  }, []);
}
function _9() {
  let e = k.useContext(Ih);
  return aM(
    e,
    "You must render this element inside a <DataRouterContext.Provider> element"
  ), e;
}
function yue() {
  let e = k.useContext(lw);
  return aM(
    e,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  ), e;
}
var lM = k.createContext(void 0);
lM.displayName = "FrameworkContext";
function T9() {
  let e = k.useContext(lM);
  return aM(
    e,
    "You must render this element inside a <HydratedRouter> element"
  ), e;
}
function vue(e, t) {
  let n = k.useContext(lM), [r, i] = k.useState(!1), [o, s] = k.useState(!1), { onFocus: a, onBlur: c, onMouseEnter: u, onMouseLeave: f, onTouchStart: h } = t, m = k.useRef(null);
  k.useEffect(() => {
    if (e === "render" && s(!0), e === "viewport") {
      let x = (S) => {
        S.forEach((_) => {
          s(_.isIntersecting);
        });
      }, w = new IntersectionObserver(x, { threshold: 0.5 });
      return m.current && w.observe(m.current), () => {
        w.disconnect();
      };
    }
  }, [e]), k.useEffect(() => {
    if (r) {
      let x = setTimeout(() => {
        s(!0);
      }, 100);
      return () => {
        clearTimeout(x);
      };
    }
  }, [r]);
  let g = () => {
    i(!0);
  }, b = () => {
    i(!1), s(!1);
  };
  return n ? e !== "intent" ? [o, m, {}] : [
    o,
    m,
    {
      onFocus: Gp(a, g),
      onBlur: Gp(c, b),
      onMouseEnter: Gp(u, g),
      onMouseLeave: Gp(f, b),
      onTouchStart: Gp(h, g)
    }
  ] : [!1, m, {}];
}
function Gp(e, t) {
  return (n) => {
    e && e(n), n.defaultPrevented || t(n);
  };
}
function bue({ page: e, ...t }) {
  let { router: n } = _9(), r = k.useMemo(
    () => d9(n.routes, e, n.basename),
    [n.routes, e, n.basename]
  );
  return r ? /* @__PURE__ */ k.createElement(wue, { page: e, matches: r, ...t }) : null;
}
function xue(e) {
  let { manifest: t, routeModules: n } = T9(), [r, i] = k.useState([]);
  return k.useEffect(() => {
    let o = !1;
    return fue(e, t, n).then(
      (s) => {
        o || i(s);
      }
    ), () => {
      o = !0;
    };
  }, [e, t, n]), r;
}
function wue({
  page: e,
  matches: t,
  ...n
}) {
  let r = dd(), { future: i, manifest: o, routeModules: s } = T9(), { basename: a } = _9(), { loaderData: c, matches: u } = yue(), f = k.useMemo(
    () => Mj(
      e,
      t,
      u,
      o,
      r,
      "data"
    ),
    [e, t, u, o, r]
  ), h = k.useMemo(
    () => Mj(
      e,
      t,
      u,
      o,
      r,
      "assets"
    ),
    [e, t, u, o, r]
  ), m = k.useMemo(() => {
    if (e === r.pathname + r.search + r.hash)
      return [];
    let x = /* @__PURE__ */ new Set(), w = !1;
    if (t.forEach((_) => {
      let M = o.routes[_.route.id];
      !M || !M.hasLoader || (!f.some((N) => N.route.id === _.route.id) && _.route.id in c && s[_.route.id]?.shouldRevalidate || M.hasClientLoader ? w = !0 : x.add(_.route.id));
    }), x.size === 0)
      return [];
    let S = cue(
      e,
      a,
      i.unstable_trailingSlashAwareDataRequests,
      "data"
    );
    return w && x.size > 0 && S.searchParams.set(
      "_routes",
      t.filter((_) => x.has(_.route.id)).map((_) => _.route.id).join(",")
    ), [S.pathname + S.search];
  }, [
    a,
    i.unstable_trailingSlashAwareDataRequests,
    c,
    r,
    o,
    f,
    t,
    e,
    s
  ]), g = k.useMemo(
    () => hue(h, o),
    [h, o]
  ), b = xue(h);
  return /* @__PURE__ */ k.createElement(k.Fragment, null, m.map((x) => /* @__PURE__ */ k.createElement("link", { key: x, rel: "prefetch", as: "fetch", href: x, ...n })), g.map((x) => /* @__PURE__ */ k.createElement("link", { key: x, rel: "modulepreload", href: x, ...n })), b.map(({ key: x, link: w }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ k.createElement(
      "link",
      {
        key: x,
        nonce: n.nonce,
        ...w,
        crossOrigin: w.crossOrigin ?? n.crossOrigin
      }
    )
  )));
}
function Sue(...e) {
  return (t) => {
    e.forEach((n) => {
      typeof n == "function" ? n(t) : n != null && (n.current = t);
    });
  };
}
var kue = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
  kue && (window.__reactRouterVersion = // @ts-expect-error
  "7.13.0");
} catch {
}
var A9 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, dw = k.forwardRef(
  function({
    onClick: t,
    discover: n = "render",
    prefetch: r = "none",
    relative: i,
    reloadDocument: o,
    replace: s,
    state: a,
    target: c,
    to: u,
    preventScrollReset: f,
    viewTransition: h,
    unstable_defaultShouldRevalidate: m,
    ...g
  }, b) {
    let { basename: x, unstable_useTransitions: w } = k.useContext(gs), S = typeof u == "string" && A9.test(u), _ = y9(u, x);
    u = _.to;
    let M = $ce(u, { relative: i }), [N, P, I] = vue(
      r,
      g
    ), O = Tue(u, {
      replace: s,
      state: a,
      target: c,
      preventScrollReset: f,
      relative: i,
      viewTransition: h,
      unstable_defaultShouldRevalidate: m,
      unstable_useTransitions: w
    });
    function L(B) {
      t && t(B), B.defaultPrevented || O(B);
    }
    let U = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ k.createElement(
        "a",
        {
          ...g,
          ...I,
          href: _.absoluteURL || M,
          onClick: _.isExternal || o ? t : L,
          ref: Sue(b, P),
          target: c,
          "data-discover": !S && n === "render" ? "true" : void 0
        }
      )
    );
    return N && !S ? /* @__PURE__ */ k.createElement(k.Fragment, null, U, /* @__PURE__ */ k.createElement(bue, { page: M })) : U;
  }
);
dw.displayName = "Link";
var Cue = k.forwardRef(
  function({
    "aria-current": t = "page",
    caseSensitive: n = !1,
    className: r = "",
    end: i = !1,
    style: o,
    to: s,
    viewTransition: a,
    children: c,
    ...u
  }, f) {
    let h = Hg(s, { relative: u.relative }), m = dd(), g = k.useContext(lw), { navigator: b, basename: x } = k.useContext(gs), w = g != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    Oue(h) && a === !0, S = b.encodeLocation ? b.encodeLocation(h).pathname : h.pathname, _ = m.pathname, M = g && g.navigation && g.navigation.location ? g.navigation.location.pathname : null;
    n || (_ = _.toLowerCase(), M = M ? M.toLowerCase() : null, S = S.toLowerCase()), M && x && (M = Mc(M, x) || M);
    const N = S !== "/" && S.endsWith("/") ? S.length - 1 : S.length;
    let P = _ === S || !i && _.startsWith(S) && _.charAt(N) === "/", I = M != null && (M === S || !i && M.startsWith(S) && M.charAt(S.length) === "/"), O = {
      isActive: P,
      isPending: I,
      isTransitioning: w
    }, L = P ? t : void 0, U;
    typeof r == "function" ? U = r(O) : U = [
      r,
      P ? "active" : null,
      I ? "pending" : null,
      w ? "transitioning" : null
    ].filter(Boolean).join(" ");
    let B = typeof o == "function" ? o(O) : o;
    return /* @__PURE__ */ k.createElement(
      dw,
      {
        ...u,
        "aria-current": L,
        className: U,
        ref: f,
        style: B,
        to: s,
        viewTransition: a
      },
      typeof c == "function" ? c(O) : c
    );
  }
);
Cue.displayName = "NavLink";
var Eue = k.forwardRef(
  ({
    discover: e = "render",
    fetcherKey: t,
    navigate: n,
    reloadDocument: r,
    replace: i,
    state: o,
    method: s = w0,
    action: a,
    onSubmit: c,
    relative: u,
    preventScrollReset: f,
    viewTransition: h,
    unstable_defaultShouldRevalidate: m,
    ...g
  }, b) => {
    let { unstable_useTransitions: x } = k.useContext(gs), w = Nue(), S = Rue(a, { relative: u }), _ = s.toLowerCase() === "get" ? "get" : "post", M = typeof a == "string" && A9.test(a), N = (P) => {
      if (c && c(P), P.defaultPrevented) return;
      P.preventDefault();
      let I = P.nativeEvent.submitter, O = I?.getAttribute("formmethod") || s, L = () => w(I || P.currentTarget, {
        fetcherKey: t,
        method: O,
        navigate: n,
        replace: i,
        state: o,
        relative: u,
        preventScrollReset: f,
        viewTransition: h,
        unstable_defaultShouldRevalidate: m
      });
      x && n !== !1 ? k.startTransition(() => L()) : L();
    };
    return /* @__PURE__ */ k.createElement(
      "form",
      {
        ref: b,
        method: _,
        action: S,
        onSubmit: r ? c : N,
        ...g,
        "data-discover": !M && e === "render" ? "true" : void 0
      }
    );
  }
);
Eue.displayName = "Form";
function _ue(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function M9(e) {
  let t = k.useContext(Ih);
  return ri(t, _ue(e)), t;
}
function Tue(e, {
  target: t,
  replace: n,
  state: r,
  preventScrollReset: i,
  relative: o,
  viewTransition: s,
  unstable_defaultShouldRevalidate: a,
  unstable_useTransitions: c
} = {}) {
  let u = k9(), f = dd(), h = Hg(e, { relative: o });
  return k.useCallback(
    (m) => {
      if (oue(m, t)) {
        m.preventDefault();
        let g = n !== void 0 ? n : y_(f) === y_(h), b = () => u(e, {
          replace: g,
          state: r,
          preventScrollReset: i,
          relative: o,
          viewTransition: s,
          unstable_defaultShouldRevalidate: a
        });
        c ? k.startTransition(() => b()) : b();
      }
    },
    [
      f,
      u,
      h,
      n,
      r,
      t,
      e,
      i,
      o,
      s,
      a,
      c
    ]
  );
}
var Aue = 0, Mue = () => `__${String(++Aue)}__`;
function Nue() {
  let { router: e } = M9(
    "useSubmit"
    /* UseSubmit */
  ), { basename: t } = k.useContext(gs), n = Xce(), r = e.fetch, i = e.navigate;
  return k.useCallback(
    async (o, s = {}) => {
      let { action: a, method: c, encType: u, formData: f, body: h } = lue(
        o,
        t
      );
      if (s.navigate === !1) {
        let m = s.fetcherKey || Mue();
        await r(m, n, s.action || a, {
          unstable_defaultShouldRevalidate: s.unstable_defaultShouldRevalidate,
          preventScrollReset: s.preventScrollReset,
          formData: f,
          body: h,
          formMethod: s.method || c,
          formEncType: s.encType || u,
          flushSync: s.flushSync
        });
      } else
        await i(s.action || a, {
          unstable_defaultShouldRevalidate: s.unstable_defaultShouldRevalidate,
          preventScrollReset: s.preventScrollReset,
          formData: f,
          body: h,
          formMethod: s.method || c,
          formEncType: s.encType || u,
          replace: s.replace,
          state: s.state,
          fromRouteId: n,
          flushSync: s.flushSync,
          viewTransition: s.viewTransition
        });
    },
    [r, i, t, n]
  );
}
function Rue(e, { relative: t } = {}) {
  let { basename: n } = k.useContext(gs), r = k.useContext(rl);
  ri(r, "useFormAction must be used inside a RouteContext");
  let [i] = r.matches.slice(-1), o = { ...Hg(e || ".", { relative: t }) }, s = dd();
  if (e == null) {
    o.search = s.search;
    let a = new URLSearchParams(o.search), c = a.getAll("index");
    if (c.some((f) => f === "")) {
      a.delete("index"), c.filter((h) => h).forEach((h) => a.append("index", h));
      let f = a.toString();
      o.search = f ? `?${f}` : "";
    }
  }
  return (!e || e === ".") && i.route.index && (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (o.pathname = o.pathname === "/" ? n : qa([n, o.pathname])), y_(o);
}
function Oue(e, { relative: t } = {}) {
  let n = k.useContext(b9);
  ri(
    n != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: r } = M9(
    "useViewTransitionState"
    /* useViewTransitionState */
  ), i = Hg(e, { relative: t });
  if (!n.isTransitioning)
    return !1;
  let o = Mc(n.currentLocation.pathname, r) || n.currentLocation.pathname, s = Mc(n.nextLocation.pathname, r) || n.nextLocation.pathname;
  return fb(i.pathname, s) != null || fb(i.pathname, o) != null;
}
function Due({
  isOwner: e,
  isBookmarked: t = !1,
  editHref: n,
  onBookmarkToggle: r,
  onDelete: i,
  renderActions: o,
  isVisibilityChangeLoading: s = !1,
  isBookmarkToggleLoading: a = !1,
  isDeleteLoading: c = !1,
  disabled: u = !1
}) {
  const f = k.useMemo(
    () => s || a || c,
    [s, a, c]
  ), h = k9();
  return /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-0.5", children: [
    !e && r && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsxs(Gi, { children: [
        /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
          Ht,
          {
            variant: "ghost",
            size: "icon",
            className: "h-8 w-8 rounded-md text-muted-foreground hover:text-foreground hover:bg-accent/50 transition-all cursor-pointer disabled:opacity-50",
            "data-testid": "bookmark-button",
            disabled: f || u,
            onClick: (m) => {
              m.preventDefault(), m.stopPropagation(), r(t);
            },
            children: a ? /* @__PURE__ */ v.jsx(Zs, { className: "h-3.5 w-3.5 animate-spin" }) : t ? /* @__PURE__ */ v.jsx(oZ, { className: "h-3.5 w-3.5 fill-current" }) : /* @__PURE__ */ v.jsx(z3, { className: "h-3.5 w-3.5" })
          }
        ) }),
        /* @__PURE__ */ v.jsx(Bo, { side: "bottom", className: "text-xs", children: t ? "Remove bookmark" : "Add bookmark" })
      ] }),
      /* @__PURE__ */ v.jsx(db, { orientation: "vertical", className: "h-4 mx-0.5" })
    ] }),
    e && n && /* @__PURE__ */ v.jsxs(Gi, { children: [
      /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
        Ht,
        {
          variant: "ghost",
          size: "icon",
          className: "h-8 w-8 rounded-md text-muted-foreground hover:text-foreground hover:bg-accent/50 transition-all cursor-pointer disabled:opacity-50",
          disabled: f || u,
          onClick: (m) => {
            m.preventDefault(), m.stopPropagation(), h(n);
          },
          children: /* @__PURE__ */ v.jsx(cce, { className: "h-3.5 w-3.5" })
        }
      ) }),
      /* @__PURE__ */ v.jsx(Bo, { side: "bottom", className: "text-xs", children: "Edit" })
    ] }),
    e && o && o(),
    e && i && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      n && /* @__PURE__ */ v.jsx(db, { orientation: "vertical", className: "h-4 mx-0.5" }),
      /* @__PURE__ */ v.jsxs(Gi, { children: [
        /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
          Ht,
          {
            variant: "ghost",
            size: "icon",
            className: "h-8 w-8 rounded-md text-muted-foreground hover:text-destructive hover:bg-destructive/10 transition-all cursor-pointer disabled:opacity-50",
            disabled: f || u,
            onClick: (m) => {
              m.preventDefault(), m.stopPropagation(), i();
            },
            children: c ? /* @__PURE__ */ v.jsx(Zs, { className: "h-3.5 w-3.5 animate-spin" }) : /* @__PURE__ */ v.jsx(B3, { className: "h-3.5 w-3.5" })
          }
        ) }),
        /* @__PURE__ */ v.jsx(Bo, { side: "bottom", className: "text-xs", children: "Delete" })
      ] })
    ] })
  ] });
}
async function Pue(e) {
  const t = await Lc(), n = await fetch(`${Ws}/${encodeURIComponent(e)}`, {
    method: "DELETE",
    headers: t
  });
  if (!n.ok) throw new Error(`Failed to delete MCP server (${n.status})`);
}
async function jue(e) {
  const t = await Lc(), n = await fetch(`${Ws}/${encodeURIComponent(e)}/refresh`, {
    method: "POST",
    headers: t
  });
  if (!n.ok) throw new Error(`Failed to refresh MCP server (${n.status})`);
  return n.json().catch(() => null);
}
function Iue({ className: e }) {
  return /* @__PURE__ */ v.jsxs(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      id: "Playwright--Streamline-Svg-Logos",
      height: "24",
      width: "24",
      className: e,
      children: [
        /* @__PURE__ */ v.jsx("desc", { children: "Playwright Streamline Icon: https://streamlinehq.com" }),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#2d4552",
            d: "M7.99585 13.141725c-0.87725 0.248975 -1.452775 0.685475 -1.8319 1.12165 0.363125 -0.317775 0.849525 -0.609425 1.505675 -0.795425 0.6711 -0.1902 1.243625 -0.188825 1.7167 -0.09755v-0.369925c-0.40355 -0.0369 -0.866225 -0.0075 -1.390475 0.14125Zm-1.872 -3.109775 -3.25795 0.858325s0.059375 0.083875 0.1693 0.195775l2.76235 -0.727875s-0.03915 0.5044 -0.379075 0.9556c0.643 -0.486475 0.705375 -1.281825 0.705375 -1.281825Zm2.727125 7.65675C4.26615 18.923575 1.8404825 13.61025 1.1060875 10.852425c-0.3393 -1.273 -0.487415 -2.2371 -0.5268925 -2.859275 -0.0042425 -0.0646 -0.0022825 -0.11905 0.002285 -0.16895 -0.237835 0.01435 -0.3517015 0.137975 -0.328535 0.49525 0.0394775 0.621825 0.187595 1.585875 0.526895 2.859275C1.5139075 13.936125 3.9399 19.24945 8.52475 18.0146c0.99795 -0.26885 1.747675 -0.758525 2.310475 -1.383625 -0.51875 0.468525 -1.168 0.8375 -1.98425 1.057725Zm0.861575 -10.90855v0.3263h1.79835c-0.0369 -0.115525 -0.074075 -0.219625 -0.110975 -0.3263h-1.687375Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#2d4552",
            d: "M11.9129 9.46735c0.80875 0.229675 1.2365 0.7967 1.462575 1.2985l0.90175 0.2561s-0.123 -1.756175 -1.711525 -2.2074c-1.486075 -0.422225 -2.400575 0.8257 -2.5118 0.9872 0.4323 -0.308 1.063575 -0.56015 1.859 -0.3344Zm7.178175 1.3066c-1.487425 -0.424125 -2.401575 0.8264 -2.511175 0.985625 0.432625 -0.307625 1.063575 -0.559875 1.85865 -0.3331 0.80745 0.23005 1.23485 0.796375 1.461625 1.298525l0.90305 0.25705s-0.125 -1.756525 -1.71215 -2.2081Zm-0.8959 4.6305 -7.501475 -2.097125s0.0812 0.411725 0.3928 0.94485l6.3159 1.765675c0.519975 -0.30085 0.792775 -0.6134 0.792775 -0.6134ZM12.994375 19.918475C7.054675 18.326 7.77275 10.758025 8.733875 7.171825c0.395725 -1.4779 0.802575 -2.576375 1.13995 -3.312725 -0.2013 -0.041425 -0.368025 0.0646 -0.532775 0.39965 -0.358225 0.726575 -0.8163 1.90955 -1.259625 3.5656 -0.96085 3.586125 -1.67895 11.15385 4.2605 12.746325 2.79955 0.75 4.980475 -0.3899 6.60625 -2.18005 -1.543175 1.3977 -3.513425 2.181325 -5.9538 1.52785Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#e2574c",
            d: "M9.7126 15.915175V14.388l-4.243175 1.2032s0.313525 -1.82175 2.526475 -2.4495c0.6711 -0.1902 1.2437 -0.1889 1.7167 -0.09755V6.780125h2.124575c-0.231325 -0.714825 -0.4551 -1.26515 -0.64305 -1.64755 -0.310925 -0.632925 -0.62965 -0.21335 -1.35325 0.39185 -0.50965 0.425775 -1.797675 1.33405 -3.7359 1.85635 -1.938275 0.522625 -3.50525 0.384025 -4.15906 0.2708 -0.9268825 -0.1599 -1.4116925 -0.36345 -1.3663375 0.34155 0.03947 0.621825 0.187595 1.58595 0.5268925 2.859275C1.8405325 13.609875 4.266525 18.9232 8.85135 17.68835c1.197625 -0.3227 2.04295 -0.960525 2.6289 -1.7735h-1.76765v0.000325ZM2.865625 10.89025l3.258275 -0.858325s-0.094975 1.25345 -1.31645 1.57545c-1.2218 0.321675 -1.941825 -0.717125 -1.941825 -0.717125Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#2ead33",
            d: "M21.975075 6.8525c-0.84695 0.148475 -2.878875 0.33345 -5.389975 -0.339625 -2.5118 -0.672675 -4.17835 -1.849175 -4.838625 -2.402175 -0.936 -0.783975 -1.347725 -1.328825 -1.752925 -0.5047 -0.358225 0.726875 -0.816325 1.909875 -1.259725 3.565925 -0.960775 3.586125 -1.67885 11.15385 4.260525 12.7463 5.938125 1.591125 9.09945 -5.322175 10.0603 -8.908625 0.4434 -1.655725 0.637825 -2.9095 0.691325 -3.717925 0.061 -0.915775 -0.568025 -0.64995 -1.7709 -0.439175ZM10.0418 9.81945s0.936 -1.45575 2.523525 -1.00455c1.588525 0.451225 1.711525 2.207425 1.711525 2.207425l-4.23505 -1.202875ZM13.917 16.352c-2.79235 -0.817975 -3.223 -3.04465 -3.223 -3.04465l7.501125 2.0972c0 -0.00035 -1.5141 1.755175 -4.278125 0.94745Zm2.6521 -4.57605s0.9347 -1.45475 2.521925 -1.00225c1.587175 0.4519 1.71215 2.2081 1.71215 2.2081l-4.234075 -1.20585Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#d65348",
            d: "M8.2299 14.808525 5.4695 15.590875s0.29985 -1.708225 2.33335 -2.385175l-1.563075 -5.865975 -0.135075 0.04105c-1.93825 0.5227 -3.505225 0.384025 -4.15903 0.2708 -0.9268775 -0.159825 -1.411685 -0.36345 -1.3663375 0.341625 0.0394775 0.621825 0.187595 1.585875 0.5268925 2.85925 0.7340675 2.757425 3.160075 8.07075 7.744875 6.8359l0.135075 -0.042425 -0.756275 -2.8374ZM2.8657 10.8903l3.258275 -0.858375s-0.094975 1.25345 -1.316425 1.57545c-1.221825 0.321675 -1.94185 -0.717075 -1.94185 -0.717075Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#1d8d22",
            d: "m14.04295 16.382625 -0.1263 -0.0307c-2.792325 -0.8179 -3.223 -3.044575 -3.223 -3.044575l3.86805 1.0812 2.047825 -7.86915 -0.024775 -0.006525c-2.5118 -0.672675 -4.17825 -1.849175 -4.838625 -2.402175 -0.936 -0.783975 -1.347725 -1.328825 -1.752925 -0.5047 -0.357875 0.726875 -0.815975 1.909875 -1.259375 3.565925 -0.960775 3.586125 -1.67885 11.15385 4.260525 12.74625l0.121725 0.027425 0.926875 -3.562975ZM10.0418 9.819475s0.936 -1.455775 2.523525 -1.004575c1.588525 0.451225 1.711525 2.207425 1.711525 2.207425l-4.23505 -1.20285Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#c04b41",
            d: "m8.37055 14.7683 -0.740275 0.2101c0.174875 0.9859 0.483125 1.93205 0.966975 2.7679 0.0842 -0.0186 0.167725 -0.034575 0.2535 -0.058075 0.2248 -0.06065 0.43325 -0.13575 0.63395 -0.21765 -0.5406 -0.802225 -0.898225 -1.726175 -1.11415 -2.702275Zm-0.289075 -6.9439c-0.3804 1.419825 -0.720725 3.46345 -0.62705 5.51325 0.167675 -0.072775 0.3448 -0.140575 0.54155 -0.1964l0.13705 -0.030625c-0.167075 -2.189525 0.194075 -4.4207 0.600925 -5.93875 0.103125 -0.384025 0.206525 -0.741225 0.3096 -1.07435 -0.166025 0.105675 -0.3448 0.213975 -0.548425 0.32555 -0.137325 0.42385 -0.276 0.887125 -0.41365 1.401325Z",
            strokeWidth: "0.25"
          }
        )
      ]
    }
  );
}
function zue({ className: e }) {
  return /* @__PURE__ */ v.jsx(
    "img",
    {
      className: e,
      src: "https://avatars.githubusercontent.com/u/133959746?s=48&v=4",
      alt: "PageIndex logo"
    }
  );
}
function Lue({ className: e }) {
  return /* @__PURE__ */ v.jsx("svg", { className: e, viewBox: "0 0 317.68 137.05", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ v.jsx("path", { fill: "currentColor", d: "M25.99,135.17c-2.06,0-4.14-.68-5.86-2.09-3.98-3.24-4.58-9.1-1.34-13.08l46.64-57.29c.2-.24.41-.48.63-.7,9.83-9.83,9.83-25.82,0-35.65-4.72-4.72-14.94-9.06-26.23-7.43-6.74.97-16.09,4.54-22.37,16.06-2.46,4.51-8.11,6.17-12.61,3.71C.34,36.25-1.32,30.61,1.14,26.1,8.91,11.84,21.71,2.76,37.18.53c15.58-2.25,32.08,2.73,42.03,12.68,16.96,16.96,17.07,44.48.35,61.59l-46.36,56.94c-1.84,2.26-4.52,3.43-7.22,3.43ZM186.55,127.75v-24.69c0-5.14-4.16-9.3-9.3-9.3h-54.32l60.87-76.33c3.2-4.01,2.54-9.86-1.47-13.06-4.01-3.2-9.86-2.55-13.06,1.47l-72.91,91.42c-2.23,2.79-2.66,6.61-1.11,9.83,1.55,3.22,4.81,5.26,8.38,5.26h64.33v15.4c0,5.14,4.16,9.3,9.3,9.3s9.3-4.16,9.3-9.3ZM230.44,102.08l66.95-83.6c3.21-4.01,2.56-9.86-1.44-13.07-4.01-3.21-9.86-2.56-13.07,1.44l-50.39,62.93V10.16c0-5.14-4.16-9.3-9.3-9.3s-9.3,4.16-9.3,9.3v86.11c0,3.95,2.49,7.47,6.22,8.77,1.01.35,2.05.53,3.08.53,2.77,0,5.46-1.24,7.26-3.49ZM314.93,131.23c3.64-3.62,3.67-9.5.05-13.15l-59.63-60.08c-3.62-3.64-9.5-3.67-13.15-.05-3.64,3.62-3.67,9.5-.05,13.15l59.63,60.08c1.82,1.83,4.21,2.75,6.6,2.75s4.74-.9,6.55-2.7Z" }) });
}
const hb = [
  {
    name: "24KTwin-Editor-MCP-Remote",
    label: "24K Twin Editor MCP Remote",
    config: {
      type: "http",
      url: "https://dev.24kstudio.surbana.tech/mcp-remote/mcp"
    },
    icon: Lue
  },
  {
    name: "playwright",
    label: "Playwright",
    config: {
      command: "npx",
      args: ["@playwright/mcp@latest"]
    },
    icon: Iue
  },
  {
    name: "pageindex",
    label: "PageIndex",
    config: {
      type: "http",
      url: "https://mcp.pageindex.ai/mcp"
    },
    icon: zue
  }
];
function Bue() {
  const e = (t, n) => {
    t.preventDefault(), t.stopPropagation();
    const r = new URLSearchParams();
    r.set("name", n.name), r.set("config", JSON.stringify(n.config)), window.open(`/chat-bot/mcp/create?${r.toString()}`, "_blank");
  };
  return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-4", children: [
    /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col items-center justify-center space-y-4 my-20", children: [
      /* @__PURE__ */ v.jsxs("h3", { className: "text-2xl md:text-4xl font-semibold flex items-center gap-3", children: [
        /* @__PURE__ */ v.jsx(sh, { className: "fill-foreground size-6 hidden sm:block" }),
        "Connect Your First Server"
      ] }),
      /* @__PURE__ */ v.jsx("p", { className: "text-muted-foreground max-w-md", children: "Add MCP servers to unlock powerful AI integrations" }),
      /* @__PURE__ */ v.jsx(
        dw,
        {
          to: "/chat-bot/mcp/create",
          className: "cursor-pointer",
          children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-xl font-bold overflow-hidden ", children: [
            "Add MCP Server",
            /* @__PURE__ */ v.jsx(nZ, { className: "size-6" })
          ] })
        }
      )
    ] }),
    /* @__PURE__ */ v.jsx("div", { className: "flex gap-2 flex-wrap justify-center", children: hb.map((t) => {
      const n = t.icon;
      return /* @__PURE__ */ v.jsxs(
        Ht,
        {
          variant: "secondary",
          className: "hover:-translate-y-0.5 transition-all duration-300 cursor-pointer flex items-center",
          onClick: (r) => e(r, t),
          children: [
            /* @__PURE__ */ v.jsx(n, { className: "h-6 w-6 my-auto text-primary-foreground stroke-primary-foreground" }),
            t.label
          ]
        },
        t.name
      );
    }) })
  ] });
}
const $ue = 2500, N9 = (e) => e.toLowerCase().replace(/[^a-z0-9]/g, ""), Uue = new Map(
  hb.map((e) => [N9(e.name), e.icon])
), Nj = k.memo(function({
  id: t,
  config: n,
  error: r,
  status: i,
  name: o,
  toolInfo: s,
  visibility: a,
  authorizationUrl: c,
  icon: u
}) {
  const { mutate: f } = n9(), [h, m] = k.useState(!1), [g, b] = k.useState(!1), [x, w] = k.useState(""), [S, _] = k.useState(!1), M = k.useRef(null), N = k.useMemo(() => h || g || i === "loading", [h, g, i]), P = i === "authorizing", I = P && !!c, O = k.useMemo(() => r ? ah(r) ? r : JSON.stringify(r) : null, [r]), L = N9(o ?? ""), U = Uue.get(L), B = u?.value?.trim(), G = u?.style?.backgroundColor, Y = !!B && (/^(data:image\/|https?:\/\/|\/)/i.test(B) || /\.(svg|png|jpe?g|webp|gif)$/i.test(B)), he = k.useCallback(async (Se) => {
    try {
      m(!0), await jue(Se), await f(`${Ws}/list`);
    } catch (W) {
      ub(W);
    } finally {
      m(!1);
    }
  }, [f]), ie = k.useCallback(
    () => {
    },
    [t]
  ), ne = k.useCallback(async () => {
    try {
      b(!0), await Pue(t), await f(`${Ws}/list`);
    } catch (Se) {
      ub(Se);
    } finally {
      b(!1);
    }
  }, [t, f]), H = k.useCallback(() => {
    M.current !== null && (window.clearInterval(M.current), M.current = null), _(!1);
  }, []), Q = k.useCallback(() => {
    M.current === null && (M.current = window.setInterval(() => {
      f(`${Ws}/list`);
    }, $ue), _(!0));
  }, [f]);
  k.useEffect(() => {
    (!P || r) && H();
  }, [r, P, H]), k.useEffect(() => {
    if (!P) return;
    const Se = sessionStorage.getItem("mcp:auto-authorize");
    Se && String(Se) === String(t) && (sessionStorage.removeItem("mcp:auto-authorize"), Q());
  }, [t, P, Q]), k.useEffect(() => H, [H]);
  const X = k.useCallback(() => {
    c && (window.open(c, "_blank", "noopener,noreferrer"), Q()), f(`${Ws}/list`);
  }, [c, f, Q]);
  return /* @__PURE__ */ v.jsxs(
    i9,
    {
      className: "relative hover:border-foreground/20 transition-colors bg-secondary/40",
      "data-testid": "mcp-server-card",
      "data-featured": a === "public",
      children: [
        N && /* @__PURE__ */ v.jsx("div", { className: "animate-pulse z-50 absolute inset-0 bg-background/50 flex items-center justify-center w-full h-full pointer-events-auto" }),
        /* @__PURE__ */ v.jsxs(
          o9,
          {
            className: "flex items-center gap-3 mb-2",
            children: [
              N && /* @__PURE__ */ v.jsx($T, { className: "size-4 z-20 animate-spin mr-1" }),
              /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3", children: [
                /* @__PURE__ */ v.jsx(
                  "div",
                  {
                    className: "flex h-8 w-8 items-center justify-center rounded-xl border border-border/70 bg-muted/60",
                    style: G ? { backgroundColor: G } : void 0,
                    children: Y ? /* @__PURE__ */ v.jsx(
                      "img",
                      {
                        src: B,
                        alt: `${o} logo`,
                        className: "h-4 w-4 object-contain"
                      }
                    ) : B ? /* @__PURE__ */ v.jsx("span", { className: "text-base leading-none", children: B }) : U ? /* @__PURE__ */ v.jsx(U, { className: "size-4" }) : /* @__PURE__ */ v.jsx(sh, { className: "size-4 text-muted-foreground" })
                  }
                ),
                /* @__PURE__ */ v.jsx("h4", { className: "font-bold text-xs sm:text-lg flex items-center gap-1", children: o })
              ] }),
              /* @__PURE__ */ v.jsx("div", { className: "flex-1" }),
              P && /* @__PURE__ */ v.jsxs(
                Ht,
                {
                  variant: "outline",
                  size: "sm",
                  className: "gap-2 cursor-pointer",
                  onClick: X,
                  disabled: !I,
                  children: [
                    /* @__PURE__ */ v.jsx(W0, { className: "size-3.5" }),
                    "Authorize"
                  ]
                }
              ),
              /* @__PURE__ */ v.jsx("div", { className: "h-4", children: /* @__PURE__ */ v.jsx(tM, { orientation: "vertical" }) }),
              /* @__PURE__ */ v.jsxs(Gi, { children: [
                /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
                  Ht,
                  {
                    variant: "ghost",
                    size: "icon",
                    onClick: () => he(t),
                    className: "cursor-pointer",
                    disabled: N,
                    children: h ? /* @__PURE__ */ v.jsx(Zs, { className: "size-4 animate-spin" }) : /* @__PURE__ */ v.jsx(bY, { className: "size-3.5 " })
                  }
                ) }),
                /* @__PURE__ */ v.jsx(ew, { children: "Refresh" })
              ] }),
              /* @__PURE__ */ v.jsx(
                Due,
                {
                  type: "mcp",
                  visibility: a === "public" ? "public" : "private",
                  isOwner: !0,
                  canChangeVisibility: !0,
                  editHref: `/chat-bot/mcp/modify?id=${encodeURIComponent(t)}&name=${encodeURIComponent(o)}&config=${encodeURIComponent(JSON.stringify(n))}`,
                  onVisibilityChange: ie,
                  onDelete: ne,
                  isVisibilityChangeLoading: !1,
                  isDeleteLoading: g,
                  disabled: N,
                  renderActions: () => null
                }
              )
            ]
          },
          `header-${i}-${P}`
        ),
        P && /* @__PURE__ */ v.jsxs("div", { className: "px-6 pb-2 text-xs text-muted-foreground flex items-center gap-2", children: [
          /* @__PURE__ */ v.jsx(W0, { className: "size-3.5" }),
          S ? "Waiting for authorization to complete." : "Pending authorization."
        ] }),
        O && /* @__PURE__ */ v.jsx(u9, { error: O }),
        /* @__PURE__ */ v.jsx("div", { className: "relative hidden sm:flex w-full", children: /* @__PURE__ */ v.jsxs(s9, { className: "flex min-w-0 w-full flex-row text-sm max-h-80 overflow-hidden border-r-0", children: [
          /* @__PURE__ */ v.jsxs("div", { className: "w-1/2 min-w-0 flex flex-col pr-2 border-r border-border", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 mb-2 pt-2 pb-1 z-10", children: [
              /* @__PURE__ */ v.jsx(L3, { size: 14, className: "text-muted-foreground" }),
              /* @__PURE__ */ v.jsx("h5", { className: "text-muted-foreground text-sm font-medium", children: "Configuration Preview" })
            ] }),
            /* @__PURE__ */ v.jsx("div", { className: "flex-1 overflow-y-auto", children: /* @__PURE__ */ v.jsx(Qu, { data: n }) })
          ] }),
          /* @__PURE__ */ v.jsxs("div", { className: "w-1/2 min-w-0 flex flex-col pl-4", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 mb-2 pt-2 pb-1 z-10", children: [
              /* @__PURE__ */ v.jsx(q0, { size: 14, className: "text-muted-foreground" }),
              /* @__PURE__ */ v.jsxs("h5", { className: "text-muted-foreground text-sm font-medium", children: [
                "Available Tools ",
                s.length > 0 ? `(${s.length})` : ""
              ] })
            ] }),
            /* @__PURE__ */ v.jsxs("div", { className: "relative mb-3", children: [
              /* @__PURE__ */ v.jsx(wY, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" }),
              /* @__PURE__ */ v.jsx(
                eM,
                {
                  type: "text",
                  placeholder: "Search tools...",
                  value: x,
                  onChange: (Se) => w(Se.target.value),
                  className: "pl-9 h-8 text-sm"
                }
              )
            ] }),
            /* @__PURE__ */ v.jsx("div", { className: "flex-1 overflow-y-auto", children: s.length > 0 ? /* @__PURE__ */ v.jsx(ace, { tools: s, serverId: t, searchQuery: x }) : /* @__PURE__ */ v.jsx("div", { className: "bg-secondary/30 rounded-md p-3 text-center", children: /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground", children: "No tools available" }) }) })
          ] })
        ] }) })
      ]
    },
    `mcp-card-${t}-${i}`
  );
});
var qk = "rovingFocusGroup.onEntryFocus", Fue = { bubbles: !1, cancelable: !0 }, Wg = "RovingFocusGroup", [v_, R9, Vue] = ZA(Wg), [Hue, O9] = ps(
  Wg,
  [Vue]
), [Wue, que] = Hue(Wg), D9 = k.forwardRef(
  (e, t) => /* @__PURE__ */ v.jsx(v_.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ v.jsx(v_.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ v.jsx(Gue, { ...e, ref: t }) }) })
);
D9.displayName = Wg;
var Gue = k.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: i = !1,
    dir: o,
    currentTabStopId: s,
    defaultCurrentTabStopId: a,
    onCurrentTabStopIdChange: c,
    onEntryFocus: u,
    preventScrollOnEntryFocus: f = !1,
    ...h
  } = e, m = k.useRef(null), g = Ft(t, m), b = Lx(o), [x, w] = Qa({
    prop: s,
    defaultProp: a ?? null,
    onChange: c,
    caller: Wg
  }), [S, _] = k.useState(!1), M = Dr(u), N = R9(n), P = k.useRef(!1), [I, O] = k.useState(0);
  return k.useEffect(() => {
    const L = m.current;
    if (L)
      return L.addEventListener(qk, M), () => L.removeEventListener(qk, M);
  }, [M]), /* @__PURE__ */ v.jsx(
    Wue,
    {
      scope: n,
      orientation: r,
      dir: b,
      loop: i,
      currentTabStopId: x,
      onItemFocus: k.useCallback(
        (L) => w(L),
        [w]
      ),
      onItemShiftTab: k.useCallback(() => _(!0), []),
      onFocusableItemAdd: k.useCallback(
        () => O((L) => L + 1),
        []
      ),
      onFocusableItemRemove: k.useCallback(
        () => O((L) => L - 1),
        []
      ),
      children: /* @__PURE__ */ v.jsx(
        Et.div,
        {
          tabIndex: S || I === 0 ? -1 : 0,
          "data-orientation": r,
          ...h,
          ref: g,
          style: { outline: "none", ...e.style },
          onMouseDown: Ye(e.onMouseDown, () => {
            P.current = !0;
          }),
          onFocus: Ye(e.onFocus, (L) => {
            const U = !P.current;
            if (L.target === L.currentTarget && U && !S) {
              const B = new CustomEvent(qk, Fue);
              if (L.currentTarget.dispatchEvent(B), !B.defaultPrevented) {
                const G = N().filter((H) => H.focusable), Y = G.find((H) => H.active), he = G.find((H) => H.id === x), ne = [Y, he, ...G].filter(
                  Boolean
                ).map((H) => H.ref.current);
                I9(ne, f);
              }
            }
            P.current = !1;
          }),
          onBlur: Ye(e.onBlur, () => _(!1))
        }
      )
    }
  );
}), P9 = "RovingFocusGroupItem", j9 = k.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: i = !1,
      tabStopId: o,
      children: s,
      ...a
    } = e, c = Uo(), u = o || c, f = que(P9, n), h = f.currentTabStopId === u, m = R9(n), { onFocusableItemAdd: g, onFocusableItemRemove: b, currentTabStopId: x } = f;
    return k.useEffect(() => {
      if (r)
        return g(), () => b();
    }, [r, g, b]), /* @__PURE__ */ v.jsx(
      v_.ItemSlot,
      {
        scope: n,
        id: u,
        focusable: r,
        active: i,
        children: /* @__PURE__ */ v.jsx(
          Et.span,
          {
            tabIndex: h ? 0 : -1,
            "data-orientation": f.orientation,
            ...a,
            ref: t,
            onMouseDown: Ye(e.onMouseDown, (w) => {
              r ? f.onItemFocus(u) : w.preventDefault();
            }),
            onFocus: Ye(e.onFocus, () => f.onItemFocus(u)),
            onKeyDown: Ye(e.onKeyDown, (w) => {
              if (w.key === "Tab" && w.shiftKey) {
                f.onItemShiftTab();
                return;
              }
              if (w.target !== w.currentTarget) return;
              const S = Yue(w, f.orientation, f.dir);
              if (S !== void 0) {
                if (w.metaKey || w.ctrlKey || w.altKey || w.shiftKey) return;
                w.preventDefault();
                let M = m().filter((N) => N.focusable).map((N) => N.ref.current);
                if (S === "last") M.reverse();
                else if (S === "prev" || S === "next") {
                  S === "prev" && M.reverse();
                  const N = M.indexOf(w.currentTarget);
                  M = f.loop ? Xue(M, N + 1) : M.slice(N + 1);
                }
                setTimeout(() => I9(M));
              }
            }),
            children: typeof s == "function" ? s({ isCurrentTabStop: h, hasTabStop: x != null }) : s
          }
        )
      }
    );
  }
);
j9.displayName = P9;
var Kue = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Zue(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function Yue(e, t, n) {
  const r = Zue(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return Kue[r];
}
function I9(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function Xue(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var Jue = D9, Que = j9;
// @__NO_SIDE_EFFECTS__
function ede(e) {
  const t = /* @__PURE__ */ tde(e), n = k.forwardRef((r, i) => {
    const { children: o, ...s } = r, a = k.Children.toArray(o), c = a.find(rde);
    if (c) {
      const u = c.props.children, f = a.map((h) => h === c ? k.Children.count(u) > 1 ? k.Children.only(null) : k.isValidElement(u) ? u.props.children : null : h);
      return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: k.isValidElement(u) ? k.cloneElement(u, void 0, f) : null });
    }
    return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: o });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function tde(e) {
  const t = k.forwardRef((n, r) => {
    const { children: i, ...o } = n;
    if (k.isValidElement(i)) {
      const s = ode(i), a = ide(o, i.props);
      return i.type !== k.Fragment && (a.ref = r ? nl(r, s) : s), k.cloneElement(i, a);
    }
    return k.Children.count(i) > 1 ? k.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var nde = /* @__PURE__ */ Symbol("radix.slottable");
function rde(e) {
  return k.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === nde;
}
function ide(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...a) => {
      const c = o(...a);
      return i(...a), c;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function ode(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var b_ = ["Enter", " "], sde = ["ArrowDown", "PageUp", "Home"], z9 = ["ArrowUp", "PageDown", "End"], ade = [...sde, ...z9], lde = {
  ltr: [...b_, "ArrowRight"],
  rtl: [...b_, "ArrowLeft"]
}, cde = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, qg = "Menu", [Qm, ude, dde] = ZA(qg), [fd, L9] = ps(qg, [
  dde,
  Mh,
  O9
]), Gg = Mh(), B9 = O9(), [$9, Bc] = fd(qg), [fde, Kg] = fd(qg), U9 = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: i, onOpenChange: o, modal: s = !0 } = e, a = Gg(t), [c, u] = k.useState(null), f = k.useRef(!1), h = Dr(o), m = Lx(i);
  return k.useEffect(() => {
    const g = () => {
      f.current = !0, document.addEventListener("pointerdown", b, { capture: !0, once: !0 }), document.addEventListener("pointermove", b, { capture: !0, once: !0 });
    }, b = () => f.current = !1;
    return document.addEventListener("keydown", g, { capture: !0 }), () => {
      document.removeEventListener("keydown", g, { capture: !0 }), document.removeEventListener("pointerdown", b, { capture: !0 }), document.removeEventListener("pointermove", b, { capture: !0 });
    };
  }, []), /* @__PURE__ */ v.jsx(Xx, { ...a, children: /* @__PURE__ */ v.jsx(
    $9,
    {
      scope: t,
      open: n,
      onOpenChange: h,
      content: c,
      onContentChange: u,
      children: /* @__PURE__ */ v.jsx(
        fde,
        {
          scope: t,
          onClose: k.useCallback(() => h(!1), [h]),
          isUsingKeyboardRef: f,
          dir: m,
          modal: s,
          children: r
        }
      )
    }
  ) });
};
U9.displayName = qg;
var hde = "MenuAnchor", cM = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = Gg(n);
    return /* @__PURE__ */ v.jsx(LA, { ...i, ...r, ref: t });
  }
);
cM.displayName = hde;
var uM = "MenuPortal", [pde, F9] = fd(uM, {
  forceMount: void 0
}), V9 = (e) => {
  const { __scopeMenu: t, forceMount: n, children: r, container: i } = e, o = Bc(uM, t);
  return /* @__PURE__ */ v.jsx(pde, { scope: t, forceMount: n, children: /* @__PURE__ */ v.jsx(Di, { present: n || o.open, children: /* @__PURE__ */ v.jsx(Bg, { asChild: !0, container: i, children: r }) }) });
};
V9.displayName = uM;
var Fo = "MenuContent", [mde, dM] = fd(Fo), H9 = k.forwardRef(
  (e, t) => {
    const n = F9(Fo, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = Bc(Fo, e.__scopeMenu), s = Kg(Fo, e.__scopeMenu);
    return /* @__PURE__ */ v.jsx(Qm.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ v.jsx(Di, { present: r || o.open, children: /* @__PURE__ */ v.jsx(Qm.Slot, { scope: e.__scopeMenu, children: s.modal ? /* @__PURE__ */ v.jsx(gde, { ...i, ref: t }) : /* @__PURE__ */ v.jsx(yde, { ...i, ref: t }) }) }) });
  }
), gde = k.forwardRef(
  (e, t) => {
    const n = Bc(Fo, e.__scopeMenu), r = k.useRef(null), i = Ft(t, r);
    return k.useEffect(() => {
      const o = r.current;
      if (o) return WA(o);
    }, []), /* @__PURE__ */ v.jsx(
      fM,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Ye(
          e.onFocusOutside,
          (o) => o.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), yde = k.forwardRef((e, t) => {
  const n = Bc(Fo, e.__scopeMenu);
  return /* @__PURE__ */ v.jsx(
    fM,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), vde = /* @__PURE__ */ ede("MenuContent.ScrollLock"), fM = k.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: i,
      onOpenAutoFocus: o,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: a,
      onEntryFocus: c,
      onEscapeKeyDown: u,
      onPointerDownOutside: f,
      onFocusOutside: h,
      onInteractOutside: m,
      onDismiss: g,
      disableOutsideScroll: b,
      ...x
    } = e, w = Bc(Fo, n), S = Kg(Fo, n), _ = Gg(n), M = B9(n), N = ude(n), [P, I] = k.useState(null), O = k.useRef(null), L = Ft(t, O, w.onContentChange), U = k.useRef(0), B = k.useRef(""), G = k.useRef(0), Y = k.useRef(null), he = k.useRef("right"), ie = k.useRef(0), ne = b ? rw : k.Fragment, H = b ? { as: vde, allowPinchZoom: !0 } : void 0, Q = (Se) => {
      const W = B.current + Se, Z = N().filter((J) => !J.disabled), pe = document.activeElement, F = Z.find((J) => J.ref.current === pe)?.textValue, ee = Z.map((J) => J.textValue), ge = Nde(ee, W, F), re = Z.find((J) => J.textValue === ge)?.ref.current;
      (function J(xe) {
        B.current = xe, window.clearTimeout(U.current), xe !== "" && (U.current = window.setTimeout(() => J(""), 1e3));
      })(W), re && setTimeout(() => re.focus());
    };
    k.useEffect(() => () => window.clearTimeout(U.current), []), HA();
    const X = k.useCallback((Se) => he.current === Y.current?.side && Ode(Se, Y.current?.area), []);
    return /* @__PURE__ */ v.jsx(
      mde,
      {
        scope: n,
        searchRef: B,
        onItemEnter: k.useCallback(
          (Se) => {
            X(Se) && Se.preventDefault();
          },
          [X]
        ),
        onItemLeave: k.useCallback(
          (Se) => {
            X(Se) || (O.current?.focus(), I(null));
          },
          [X]
        ),
        onTriggerLeave: k.useCallback(
          (Se) => {
            X(Se) && Se.preventDefault();
          },
          [X]
        ),
        pointerGraceTimerRef: G,
        onPointerGraceIntentChange: k.useCallback((Se) => {
          Y.current = Se;
        }, []),
        children: /* @__PURE__ */ v.jsx(ne, { ...H, children: /* @__PURE__ */ v.jsx(
          tw,
          {
            asChild: !0,
            trapped: i,
            onMountAutoFocus: Ye(o, (Se) => {
              Se.preventDefault(), O.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: s,
            children: /* @__PURE__ */ v.jsx(
              zg,
              {
                asChild: !0,
                disableOutsidePointerEvents: a,
                onEscapeKeyDown: u,
                onPointerDownOutside: f,
                onFocusOutside: h,
                onInteractOutside: m,
                onDismiss: g,
                children: /* @__PURE__ */ v.jsx(
                  Jue,
                  {
                    asChild: !0,
                    ...M,
                    dir: S.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: P,
                    onCurrentTabStopIdChange: I,
                    onEntryFocus: Ye(c, (Se) => {
                      S.isUsingKeyboardRef.current || Se.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ v.jsx(
                      BA,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": aU(w.open),
                        "data-radix-menu-content": "",
                        dir: S.dir,
                        ..._,
                        ...x,
                        ref: L,
                        style: { outline: "none", ...x.style },
                        onKeyDown: Ye(x.onKeyDown, (Se) => {
                          const Z = Se.target.closest("[data-radix-menu-content]") === Se.currentTarget, pe = Se.ctrlKey || Se.altKey || Se.metaKey, F = Se.key.length === 1;
                          Z && (Se.key === "Tab" && Se.preventDefault(), !pe && F && Q(Se.key));
                          const ee = O.current;
                          if (Se.target !== ee || !ade.includes(Se.key)) return;
                          Se.preventDefault();
                          const re = N().filter((J) => !J.disabled).map((J) => J.ref.current);
                          z9.includes(Se.key) && re.reverse(), Ade(re);
                        }),
                        onBlur: Ye(e.onBlur, (Se) => {
                          Se.currentTarget.contains(Se.target) || (window.clearTimeout(U.current), B.current = "");
                        }),
                        onPointerMove: Ye(
                          e.onPointerMove,
                          eg((Se) => {
                            const W = Se.target, Z = ie.current !== Se.clientX;
                            if (Se.currentTarget.contains(W) && Z) {
                              const pe = Se.clientX > ie.current ? "right" : "left";
                              he.current = pe, ie.current = Se.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
H9.displayName = Fo;
var bde = "MenuGroup", hM = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ v.jsx(Et.div, { role: "group", ...r, ref: t });
  }
);
hM.displayName = bde;
var xde = "MenuLabel", W9 = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ v.jsx(Et.div, { ...r, ref: t });
  }
);
W9.displayName = xde;
var pb = "MenuItem", Rj = "menu.itemSelect", fw = k.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...i } = e, o = k.useRef(null), s = Kg(pb, e.__scopeMenu), a = dM(pb, e.__scopeMenu), c = Ft(t, o), u = k.useRef(!1), f = () => {
      const h = o.current;
      if (!n && h) {
        const m = new CustomEvent(Rj, { bubbles: !0, cancelable: !0 });
        h.addEventListener(Rj, (g) => r?.(g), { once: !0 }), U3(h, m), m.defaultPrevented ? u.current = !1 : s.onClose();
      }
    };
    return /* @__PURE__ */ v.jsx(
      q9,
      {
        ...i,
        ref: c,
        disabled: n,
        onClick: Ye(e.onClick, f),
        onPointerDown: (h) => {
          e.onPointerDown?.(h), u.current = !0;
        },
        onPointerUp: Ye(e.onPointerUp, (h) => {
          u.current || h.currentTarget?.click();
        }),
        onKeyDown: Ye(e.onKeyDown, (h) => {
          const m = a.searchRef.current !== "";
          n || m && h.key === " " || b_.includes(h.key) && (h.currentTarget.click(), h.preventDefault());
        })
      }
    );
  }
);
fw.displayName = pb;
var q9 = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: i, ...o } = e, s = dM(pb, n), a = B9(n), c = k.useRef(null), u = Ft(t, c), [f, h] = k.useState(!1), [m, g] = k.useState("");
    return k.useEffect(() => {
      const b = c.current;
      b && g((b.textContent ?? "").trim());
    }, [o.children]), /* @__PURE__ */ v.jsx(
      Qm.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: i ?? m,
        children: /* @__PURE__ */ v.jsx(Que, { asChild: !0, ...a, focusable: !r, children: /* @__PURE__ */ v.jsx(
          Et.div,
          {
            role: "menuitem",
            "data-highlighted": f ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...o,
            ref: u,
            onPointerMove: Ye(
              e.onPointerMove,
              eg((b) => {
                r ? s.onItemLeave(b) : (s.onItemEnter(b), b.defaultPrevented || b.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Ye(
              e.onPointerLeave,
              eg((b) => s.onItemLeave(b))
            ),
            onFocus: Ye(e.onFocus, () => h(!0)),
            onBlur: Ye(e.onBlur, () => h(!1))
          }
        ) })
      }
    );
  }
), wde = "MenuCheckboxItem", G9 = k.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...i } = e;
    return /* @__PURE__ */ v.jsx(J9, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ v.jsx(
      fw,
      {
        role: "menuitemcheckbox",
        "aria-checked": mb(n) ? "mixed" : n,
        ...i,
        ref: t,
        "data-state": gM(n),
        onSelect: Ye(
          i.onSelect,
          () => r?.(mb(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
G9.displayName = wde;
var K9 = "MenuRadioGroup", [Sde, kde] = fd(
  K9,
  { value: void 0, onValueChange: () => {
  } }
), Z9 = k.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...i } = e, o = Dr(r);
    return /* @__PURE__ */ v.jsx(Sde, { scope: e.__scopeMenu, value: n, onValueChange: o, children: /* @__PURE__ */ v.jsx(hM, { ...i, ref: t }) });
  }
);
Z9.displayName = K9;
var Y9 = "MenuRadioItem", X9 = k.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, i = kde(Y9, e.__scopeMenu), o = n === i.value;
    return /* @__PURE__ */ v.jsx(J9, { scope: e.__scopeMenu, checked: o, children: /* @__PURE__ */ v.jsx(
      fw,
      {
        role: "menuitemradio",
        "aria-checked": o,
        ...r,
        ref: t,
        "data-state": gM(o),
        onSelect: Ye(
          r.onSelect,
          () => i.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
X9.displayName = Y9;
var pM = "MenuItemIndicator", [J9, Cde] = fd(
  pM,
  { checked: !1 }
), Q9 = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...i } = e, o = Cde(pM, n);
    return /* @__PURE__ */ v.jsx(
      Di,
      {
        present: r || mb(o.checked) || o.checked === !0,
        children: /* @__PURE__ */ v.jsx(
          Et.span,
          {
            ...i,
            ref: t,
            "data-state": gM(o.checked)
          }
        )
      }
    );
  }
);
Q9.displayName = pM;
var Ede = "MenuSeparator", eU = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ v.jsx(
      Et.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
eU.displayName = Ede;
var _de = "MenuArrow", tU = k.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = Gg(n);
    return /* @__PURE__ */ v.jsx($A, { ...i, ...r, ref: t });
  }
);
tU.displayName = _de;
var mM = "MenuSub", [Tde, nU] = fd(mM), rU = (e) => {
  const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: i } = e, o = Bc(mM, t), s = Gg(t), [a, c] = k.useState(null), [u, f] = k.useState(null), h = Dr(i);
  return k.useEffect(() => (o.open === !1 && h(!1), () => h(!1)), [o.open, h]), /* @__PURE__ */ v.jsx(Xx, { ...s, children: /* @__PURE__ */ v.jsx(
    $9,
    {
      scope: t,
      open: r,
      onOpenChange: h,
      content: u,
      onContentChange: f,
      children: /* @__PURE__ */ v.jsx(
        Tde,
        {
          scope: t,
          contentId: Uo(),
          triggerId: Uo(),
          trigger: a,
          onTriggerChange: c,
          children: n
        }
      )
    }
  ) });
};
rU.displayName = mM;
var am = "MenuSubTrigger", iU = k.forwardRef(
  (e, t) => {
    const n = Bc(am, e.__scopeMenu), r = Kg(am, e.__scopeMenu), i = nU(am, e.__scopeMenu), o = dM(am, e.__scopeMenu), s = k.useRef(null), { pointerGraceTimerRef: a, onPointerGraceIntentChange: c } = o, u = { __scopeMenu: e.__scopeMenu }, f = k.useCallback(() => {
      s.current && window.clearTimeout(s.current), s.current = null;
    }, []);
    return k.useEffect(() => f, [f]), k.useEffect(() => {
      const h = a.current;
      return () => {
        window.clearTimeout(h), c(null);
      };
    }, [a, c]), /* @__PURE__ */ v.jsx(cM, { asChild: !0, ...u, children: /* @__PURE__ */ v.jsx(
      q9,
      {
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": i.contentId,
        "data-state": aU(n.open),
        ...e,
        ref: nl(t, i.onTriggerChange),
        onClick: (h) => {
          e.onClick?.(h), !(e.disabled || h.defaultPrevented) && (h.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Ye(
          e.onPointerMove,
          eg((h) => {
            o.onItemEnter(h), !h.defaultPrevented && !e.disabled && !n.open && !s.current && (o.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => {
              n.onOpenChange(!0), f();
            }, 100));
          })
        ),
        onPointerLeave: Ye(
          e.onPointerLeave,
          eg((h) => {
            f();
            const m = n.content?.getBoundingClientRect();
            if (m) {
              const g = n.content?.dataset.side, b = g === "right", x = b ? -5 : 5, w = m[b ? "left" : "right"], S = m[b ? "right" : "left"];
              o.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: h.clientX + x, y: h.clientY },
                  { x: w, y: m.top },
                  { x: S, y: m.top },
                  { x: S, y: m.bottom },
                  { x: w, y: m.bottom }
                ],
                side: g
              }), window.clearTimeout(a.current), a.current = window.setTimeout(
                () => o.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (o.onTriggerLeave(h), h.defaultPrevented) return;
              o.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Ye(e.onKeyDown, (h) => {
          const m = o.searchRef.current !== "";
          e.disabled || m && h.key === " " || lde[r.dir].includes(h.key) && (n.onOpenChange(!0), n.content?.focus(), h.preventDefault());
        })
      }
    ) });
  }
);
iU.displayName = am;
var oU = "MenuSubContent", sU = k.forwardRef(
  (e, t) => {
    const n = F9(Fo, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = Bc(Fo, e.__scopeMenu), s = Kg(Fo, e.__scopeMenu), a = nU(oU, e.__scopeMenu), c = k.useRef(null), u = Ft(t, c);
    return /* @__PURE__ */ v.jsx(Qm.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ v.jsx(Di, { present: r || o.open, children: /* @__PURE__ */ v.jsx(Qm.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ v.jsx(
      fM,
      {
        id: a.contentId,
        "aria-labelledby": a.triggerId,
        ...i,
        ref: u,
        align: "start",
        side: s.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (f) => {
          s.isUsingKeyboardRef.current && c.current?.focus(), f.preventDefault();
        },
        onCloseAutoFocus: (f) => f.preventDefault(),
        onFocusOutside: Ye(e.onFocusOutside, (f) => {
          f.target !== a.trigger && o.onOpenChange(!1);
        }),
        onEscapeKeyDown: Ye(e.onEscapeKeyDown, (f) => {
          s.onClose(), f.preventDefault();
        }),
        onKeyDown: Ye(e.onKeyDown, (f) => {
          const h = f.currentTarget.contains(f.target), m = cde[s.dir].includes(f.key);
          h && m && (o.onOpenChange(!1), a.trigger?.focus(), f.preventDefault());
        })
      }
    ) }) }) });
  }
);
sU.displayName = oU;
function aU(e) {
  return e ? "open" : "closed";
}
function mb(e) {
  return e === "indeterminate";
}
function gM(e) {
  return mb(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function Ade(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function Mde(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function Nde(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let s = Mde(e, Math.max(o, 0));
  i.length === 1 && (s = s.filter((u) => u !== n));
  const c = s.find(
    (u) => u.toLowerCase().startsWith(i.toLowerCase())
  );
  return c !== n ? c : void 0;
}
function Rde(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const a = t[o], c = t[s], u = a.x, f = a.y, h = c.x, m = c.y;
    f > r != m > r && n < (h - u) * (r - f) / (m - f) + u && (i = !i);
  }
  return i;
}
function Ode(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return Rde(n, t);
}
function eg(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var Dde = U9, Pde = cM, jde = V9, Ide = H9, zde = hM, Lde = W9, Bde = fw, $de = G9, Ude = Z9, Fde = X9, Vde = Q9, Hde = eU, Wde = tU, qde = rU, Gde = iU, Kde = sU, hw = "DropdownMenu", [Zde] = ps(
  hw,
  [L9]
), vi = L9(), [Yde, lU] = Zde(hw), cU = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: i,
    defaultOpen: o,
    onOpenChange: s,
    modal: a = !0
  } = e, c = vi(t), u = k.useRef(null), [f, h] = Qa({
    prop: i,
    defaultProp: o ?? !1,
    onChange: s,
    caller: hw
  });
  return /* @__PURE__ */ v.jsx(
    Yde,
    {
      scope: t,
      triggerId: Uo(),
      triggerRef: u,
      contentId: Uo(),
      open: f,
      onOpenChange: h,
      onOpenToggle: k.useCallback(() => h((m) => !m), [h]),
      modal: a,
      children: /* @__PURE__ */ v.jsx(Dde, { ...c, open: f, onOpenChange: h, dir: r, modal: a, children: n })
    }
  );
};
cU.displayName = hw;
var uU = "DropdownMenuTrigger", dU = k.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...i } = e, o = lU(uU, n), s = vi(n);
    return /* @__PURE__ */ v.jsx(Pde, { asChild: !0, ...s, children: /* @__PURE__ */ v.jsx(
      Et.button,
      {
        type: "button",
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": o.open,
        "aria-controls": o.open ? o.contentId : void 0,
        "data-state": o.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...i,
        ref: nl(t, o.triggerRef),
        onPointerDown: Ye(e.onPointerDown, (a) => {
          !r && a.button === 0 && a.ctrlKey === !1 && (o.onOpenToggle(), o.open || a.preventDefault());
        }),
        onKeyDown: Ye(e.onKeyDown, (a) => {
          r || (["Enter", " "].includes(a.key) && o.onOpenToggle(), a.key === "ArrowDown" && o.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault());
        })
      }
    ) });
  }
);
dU.displayName = uU;
var Xde = "DropdownMenuPortal", fU = (e) => {
  const { __scopeDropdownMenu: t, ...n } = e, r = vi(t);
  return /* @__PURE__ */ v.jsx(jde, { ...r, ...n });
};
fU.displayName = Xde;
var hU = "DropdownMenuContent", pU = k.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = lU(hU, n), o = vi(n), s = k.useRef(!1);
    return /* @__PURE__ */ v.jsx(
      Ide,
      {
        id: i.contentId,
        "aria-labelledby": i.triggerId,
        ...o,
        ...r,
        ref: t,
        onCloseAutoFocus: Ye(e.onCloseAutoFocus, (a) => {
          s.current || i.triggerRef.current?.focus(), s.current = !1, a.preventDefault();
        }),
        onInteractOutside: Ye(e.onInteractOutside, (a) => {
          const c = a.detail.originalEvent, u = c.button === 0 && c.ctrlKey === !0, f = c.button === 2 || u;
          (!i.modal || f) && (s.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
pU.displayName = hU;
var Jde = "DropdownMenuGroup", mU = k.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
    return /* @__PURE__ */ v.jsx(zde, { ...i, ...r, ref: t });
  }
);
mU.displayName = Jde;
var Qde = "DropdownMenuLabel", gU = k.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
    return /* @__PURE__ */ v.jsx(Lde, { ...i, ...r, ref: t });
  }
);
gU.displayName = Qde;
var efe = "DropdownMenuItem", yU = k.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
    return /* @__PURE__ */ v.jsx(Bde, { ...i, ...r, ref: t });
  }
);
yU.displayName = efe;
var tfe = "DropdownMenuCheckboxItem", vU = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx($de, { ...i, ...r, ref: t });
});
vU.displayName = tfe;
var nfe = "DropdownMenuRadioGroup", rfe = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(Ude, { ...i, ...r, ref: t });
});
rfe.displayName = nfe;
var ife = "DropdownMenuRadioItem", ofe = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(Fde, { ...i, ...r, ref: t });
});
ofe.displayName = ife;
var sfe = "DropdownMenuItemIndicator", bU = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(Vde, { ...i, ...r, ref: t });
});
bU.displayName = sfe;
var afe = "DropdownMenuSeparator", xU = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(Hde, { ...i, ...r, ref: t });
});
xU.displayName = afe;
var lfe = "DropdownMenuArrow", cfe = k.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
    return /* @__PURE__ */ v.jsx(Wde, { ...i, ...r, ref: t });
  }
);
cfe.displayName = lfe;
var ufe = (e) => {
  const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: i, defaultOpen: o } = e, s = vi(t), [a, c] = Qa({
    prop: r,
    defaultProp: o ?? !1,
    onChange: i,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ v.jsx(qde, { ...s, open: a, onOpenChange: c, children: n });
}, dfe = "DropdownMenuSubTrigger", wU = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(Gde, { ...i, ...r, ref: t });
});
wU.displayName = dfe;
var ffe = "DropdownMenuSubContent", SU = k.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(
    Kde,
    {
      ...i,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
SU.displayName = ffe;
var hfe = cU, pfe = dU, kU = fU, mfe = pU, gfe = mU, yfe = gU, vfe = yU, bfe = vU, xfe = bU, CU = xU, wfe = ufe, Sfe = wU, kfe = SU;
function ed({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(hfe, { "data-slot": "dropdown-menu", ...e });
}
function Cfe({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(kU, { "data-slot": "dropdown-menu-portal", ...e });
}
function td({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(
    pfe,
    {
      "data-slot": "dropdown-menu-trigger",
      ...e
    }
  );
}
function nd({
  className: e,
  sideOffset: t = 4,
  ...n
}) {
  return /* @__PURE__ */ v.jsx(kU, { children: /* @__PURE__ */ v.jsx(
    mfe,
    {
      "data-slot": "dropdown-menu-content",
      sideOffset: t,
      className: at(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
        e
      ),
      ...n,
      onCloseAutoFocus: (r) => {
        r.preventDefault(), document.body.style.pointerEvents = "";
      }
    }
  ) });
}
function Efe({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(gfe, { "data-slot": "dropdown-menu-group", ...e });
}
function ls({
  className: e,
  inset: t,
  variant: n = "default",
  ...r
}) {
  return /* @__PURE__ */ v.jsx(
    vfe,
    {
      "data-slot": "dropdown-menu-item",
      "data-inset": t,
      "data-variant": n,
      className: at(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...r
    }
  );
}
function _fe({
  className: e,
  children: t,
  checked: n,
  ...r
}) {
  return /* @__PURE__ */ v.jsxs(
    bfe,
    {
      "data-slot": "dropdown-menu-checkbox-item",
      className: at(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      checked: n,
      ...r,
      children: [
        /* @__PURE__ */ v.jsx("span", { className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center", children: /* @__PURE__ */ v.jsx(xfe, { children: /* @__PURE__ */ v.jsx(Sc, { className: "size-4" }) }) }),
        t
      ]
    }
  );
}
function Tfe({
  className: e,
  inset: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsx(
    yfe,
    {
      "data-slot": "dropdown-menu-label",
      "data-inset": t,
      className: at("px-2 py-1.5 text-sm font-medium data-[inset]:pl-8", e),
      ...n
    }
  );
}
function gb({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    CU,
    {
      "data-slot": "dropdown-menu-separator",
      className: at("bg-border -mx-1 my-1 h-px", e),
      ...t
    }
  );
}
function Afe({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(wfe, { "data-slot": "dropdown-menu-sub", ...e });
}
function Mfe({
  className: e,
  inset: t,
  children: n,
  ...r
}) {
  return /* @__PURE__ */ v.jsxs(
    Sfe,
    {
      "data-slot": "dropdown-menu-sub-trigger",
      "data-inset": t,
      className: at(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        e
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ v.jsx(Mg, { className: "ml-auto size-4" })
      ]
    }
  );
}
function Nfe({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    kfe,
    {
      "data-slot": "dropdown-menu-sub-content",
      className: at(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        e
      ),
      ...t
    }
  );
}
var Rfe = class EU extends Error {
  static kind = "ClerkError";
  clerkError = !0;
  code;
  longMessage;
  docsUrl;
  cause;
  get name() {
    return this.constructor.name;
  }
  constructor(t) {
    super(new.target.formatMessage(new.target.kind, t.message, t.code, t.docsUrl), { cause: t.cause }), Object.setPrototypeOf(this, EU.prototype), this.code = t.code, this.docsUrl = t.docsUrl, this.longMessage = t.longMessage, this.cause = t.cause;
  }
  toString() {
    return `[${this.name}]
Message:${this.message}`;
  }
  static formatMessage(t, n, r, i) {
    const o = "Clerk:", s = new RegExp(o.replace(" ", "\\s*"), "i");
    return n = n.replace(s, ""), n = `${o} ${n.trim()}

(code="${r}")

`, i && (n += `

Docs: ${i}`), n;
  }
};
const Ofe = Object.freeze({
  InvalidProxyUrlErrorMessage: "The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})",
  InvalidPublishableKeyErrorMessage: "The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})",
  MissingPublishableKeyErrorMessage: "Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.",
  MissingSecretKeyErrorMessage: "Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.",
  MissingClerkProvider: "{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider"
});
function _U({ packageName: e, customMessages: t }) {
  let n = e;
  function r(o, s) {
    if (!s) return `${n}: ${o}`;
    let a = o;
    const c = o.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);
    for (const u of c) {
      const f = (s[u[1]] || "").toString();
      a = a.replace(`{{${u[1]}}}`, f);
    }
    return `${n}: ${a}`;
  }
  const i = {
    ...Ofe,
    ...t
  };
  return {
    setPackageName({ packageName: o }) {
      return typeof o == "string" && (n = o), this;
    },
    setMessages({ customMessages: o }) {
      return Object.assign(i, o || {}), this;
    },
    throwInvalidPublishableKeyError(o) {
      throw new Error(r(i.InvalidPublishableKeyErrorMessage, o));
    },
    throwInvalidProxyUrl(o) {
      throw new Error(r(i.InvalidProxyUrlErrorMessage, o));
    },
    throwMissingPublishableKeyError() {
      throw new Error(r(i.MissingPublishableKeyErrorMessage));
    },
    throwMissingSecretKeyError() {
      throw new Error(r(i.MissingSecretKeyErrorMessage));
    },
    throwMissingClerkProviderError(o) {
      throw new Error(r(i.MissingClerkProvider, o));
    },
    throw(o) {
      throw new Error(r(o));
    }
  };
}
var x_ = class TU extends Rfe {
  static kind = "ClerkRuntimeError";
  /**
  * @deprecated Use `clerkError` property instead. This property is maintained for backward compatibility.
  */
  clerkRuntimeError = !0;
  constructor(t, n) {
    super({
      ...n,
      message: t
    }), Object.setPrototypeOf(this, TU.prototype);
  }
};
const Dfe = [
  ".lcl.dev",
  ".stg.dev",
  ".lclstage.dev",
  ".stgstage.dev",
  ".dev.lclclerk.com",
  ".stg.lclclerk.com",
  ".accounts.lclclerk.com",
  "accountsstage.dev",
  "accounts.dev"
], AU = (e) => typeof atob < "u" && typeof atob == "function" ? atob(e) : typeof global < "u" && global.Buffer ? new global.Buffer(e, "base64").toString() : e, MU = "pk_live_", Pfe = "pk_test_";
function NU(e) {
  if (!e.endsWith("$")) return !1;
  const t = e.slice(0, -1);
  return t.includes("$") ? !1 : t.includes(".");
}
function Oj(e, t = {}) {
  if (e = e || "", !e || !Dj(e)) {
    if (t.fatal && !e) throw new Error("Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys");
    if (t.fatal && !Dj(e)) throw new Error("Publishable key not valid.");
    return null;
  }
  const n = e.startsWith(MU) ? "production" : "development";
  let r;
  try {
    r = AU(e.split("_")[2]);
  } catch {
    if (t.fatal) throw new Error("Publishable key not valid: Failed to decode key.");
    return null;
  }
  if (!NU(r)) {
    if (t.fatal) throw new Error("Publishable key not valid: Decoded key has invalid format.");
    return null;
  }
  let i = r.slice(0, -1);
  return t.proxyUrl ? i = t.proxyUrl : n !== "development" && t.domain && t.isSatellite && (i = `clerk.${t.domain}`), {
    instanceType: n,
    frontendApi: i
  };
}
function Dj(e = "") {
  try {
    if (!(e.startsWith(MU) || e.startsWith(Pfe))) return !1;
    const t = e.split("_");
    if (t.length !== 3) return !1;
    const n = t[2];
    return n ? NU(AU(n)) : !1;
  } catch {
    return !1;
  }
}
function jfe() {
  const e = /* @__PURE__ */ new Map();
  return { isDevOrStagingUrl: (t) => {
    if (!t) return !1;
    const n = typeof t == "string" ? t : t.hostname;
    let r = e.get(n);
    return r === void 0 && (r = Dfe.some((i) => n.endsWith(i)), e.set(n, r)), r;
  } };
}
const Ife = "METHOD_CALLED", zfe = 0.1;
function Lfe(e, t) {
  return {
    event: Ife,
    eventSamplingRate: zfe,
    payload: {
      method: e,
      ...t
    }
  };
}
var Pj = Object.prototype.hasOwnProperty;
function jj(e, t, n) {
  for (n of e.keys())
    if (Tm(n, t)) return n;
}
function Tm(e, t) {
  var n, r, i;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((r = e.length) === t.length)
        for (; r-- && Tm(e[r], t[r]); ) ;
      return r === -1;
    }
    if (n === Set) {
      if (e.size !== t.size)
        return !1;
      for (r of e)
        if (i = r, i && typeof i == "object" && (i = jj(t, i), !i) || !t.has(i)) return !1;
      return !0;
    }
    if (n === Map) {
      if (e.size !== t.size)
        return !1;
      for (r of e)
        if (i = r[0], i && typeof i == "object" && (i = jj(t, i), !i) || !Tm(r[1], t.get(i)))
          return !1;
      return !0;
    }
    if (n === ArrayBuffer)
      e = new Uint8Array(e), t = new Uint8Array(t);
    else if (n === DataView) {
      if ((r = e.byteLength) === t.byteLength)
        for (; r-- && e.getInt8(r) === t.getInt8(r); ) ;
      return r === -1;
    }
    if (ArrayBuffer.isView(e)) {
      if ((r = e.byteLength) === t.byteLength)
        for (; r-- && e[r] === t[r]; ) ;
      return r === -1;
    }
    if (!n || typeof e == "object") {
      r = 0;
      for (n in e)
        if (Pj.call(e, n) && ++r && !Pj.call(t, n) || !(n in t) || !Tm(e[n], t[n])) return !1;
      return Object.keys(t).length === r;
    }
  }
  return e !== e && t !== t;
}
function Bfe(e, t) {
  if (!e) throw typeof t == "string" ? new Error(t) : /* @__PURE__ */ new Error(`${t.displayName} not found`);
}
const il = (e, t) => {
  const { assertCtxFn: n = Bfe } = {}, r = Ne.createContext(void 0);
  return r.displayName = e, [
    r,
    () => {
      const s = Ne.useContext(r);
      return n(s, `${e} not found`), s.value;
    },
    () => {
      const s = Ne.useContext(r);
      return s ? s.value : {};
    }
  ];
}, [$fe, RU] = il("ClerkInstanceContext"), [OLe, Ufe] = il("UserContext");
il("ClientContext");
il("SessionContext");
Ne.createContext({});
il("CheckoutContext");
il("OrganizationContext");
function OU(e) {
  if (!Ne.useContext($fe)) {
    if (typeof e == "function") {
      e();
      return;
    }
    throw new Error(`${e} can only be used within the <ClerkProvider /> component.

Possible fixes:
1. Ensure that the <ClerkProvider /> is correctly wrapping your application where this component is used.
2. Check for multiple versions of the \`@clerk/shared\` package in your project. Use a tool like \`npm ls @clerk/shared\` to identify multiple versions, and update your dependencies to only rely on one.

Learn more: https://clerk.com/docs/components/clerk-provider`.trim());
  }
}
typeof window < "u" ? Ne.useLayoutEffect : Ne.useEffect;
const Ij = "useUser";
function DU() {
  OU(Ij);
  const e = Ufe();
  return RU().telemetry?.record(Lfe(Ij)), e === void 0 ? {
    isLoaded: !1,
    isSignedIn: void 0,
    user: void 0
  } : e === null ? {
    isLoaded: !0,
    isSignedIn: !1,
    user: null
  } : {
    isLoaded: !0,
    isSignedIn: !0,
    user: e
  };
}
const zj = Tm, Ffe = (e) => {
  const t = k.useRef(e);
  return k.useEffect(() => {
    t.current = e;
  }, [e]), t.current;
}, so = (e, t, n) => {
  const r = !!n, i = k.useRef(n);
  k.useEffect(() => {
    i.current = n;
  }, [n]), k.useEffect(() => {
    if (!r || !e) return () => {
    };
    const o = (...s) => {
      i.current && i.current(...s);
    };
    return e.on(t, o), () => {
      e.off(t, o);
    };
  }, [
    r,
    t,
    e,
    i
  ]);
}, PU = Ne.createContext(null);
PU.displayName = "ElementsContext";
const Vfe = (e, t) => {
  if (!e) throw new Error(`Could not find Elements context; You need to wrap the part of your app that ${t} in an <Elements> provider.`);
  return e;
}, yb = (e) => e !== null && typeof e == "object", Hfe = (e, t, n) => yb(e) ? Object.keys(e).reduce((r, i) => {
  const o = !yb(t) || !jU(e[i], t[i]);
  return n.includes(i) ? (o && console.warn(`Unsupported prop change: options.${i} is not a mutable property.`), r) : o ? {
    ...r || {},
    [i]: e[i]
  } : r;
}, null) : null, Lj = "[object Object]", jU = (e, t) => {
  if (!yb(e) || !yb(t)) return e === t;
  const n = Array.isArray(e);
  if (n !== Array.isArray(t)) return !1;
  const r = Object.prototype.toString.call(e) === Lj;
  if (r !== (Object.prototype.toString.call(t) === Lj)) return !1;
  if (!r && !n) return e === t;
  const i = Object.keys(e), o = Object.keys(t);
  if (i.length !== o.length) return !1;
  const s = {};
  for (let h = 0; h < i.length; h += 1) s[i[h]] = !0;
  for (let h = 0; h < o.length; h += 1) s[o[h]] = !0;
  const a = Object.keys(s);
  if (a.length !== i.length) return !1;
  const c = e, u = t, f = (h) => jU(c[h], u[h]);
  return a.every(f);
}, Bj = (e) => Vfe(Ne.useContext(PU), e), Wfe = (e) => e.charAt(0).toUpperCase() + e.slice(1), qfe = (e, t) => {
  const n = `${Wfe(e)}Element`, o = t ? (s) => {
    Bj(`mounts <${n}>`);
    const { id: a, className: c } = s;
    return /* @__PURE__ */ Ne.createElement("div", {
      id: a,
      className: c
    });
  } : ({ id: s, className: a, fallback: c, options: u = {}, onBlur: f, onFocus: h, onReady: m, onChange: g, onEscape: b, onClick: x, onLoadError: w, onLoaderStart: S, onNetworksChange: _, onConfirm: M, onCancel: N, onShippingAddressChange: P, onShippingRateChange: I }) => {
    const O = Bj(`mounts <${n}>`), L = "elements" in O ? O.elements : null, [U, B] = Ne.useState(null), G = Ne.useRef(null), Y = Ne.useRef(null), [he, ie] = k.useState(!1);
    so(U, "blur", f), so(U, "focus", h), so(U, "escape", b), so(U, "click", x), so(U, "loaderror", w), so(U, "loaderstart", S), so(U, "networkschange", _), so(U, "confirm", M), so(U, "cancel", N), so(U, "shippingaddresschange", P), so(U, "shippingratechange", I), so(U, "change", g);
    let ne;
    m && (ne = () => {
      ie(!0), m(U);
    }), so(U, "ready", ne), Ne.useLayoutEffect(() => {
      if (G.current === null && Y.current !== null && L) {
        let Q = null;
        L && (Q = L.create(e, u)), G.current = Q, B(Q), Q && Q.mount(Y.current);
      }
    }, [L, u]);
    const H = Ffe(u);
    return Ne.useEffect(() => {
      if (!G.current) return;
      const Q = Hfe(u, H, ["paymentRequest"]);
      Q && "update" in G.current && G.current.update(Q);
    }, [u, H]), Ne.useLayoutEffect(() => () => {
      if (G.current && typeof G.current.destroy == "function") try {
        G.current.destroy(), G.current = null;
      } catch {
      }
    }, []), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, !he && c, /* @__PURE__ */ Ne.createElement("div", {
      id: s,
      style: {
        height: he ? "unset" : "0px",
        visibility: he ? "visible" : "hidden"
      },
      className: a,
      ref: Y
    }));
  };
  return o.displayName = n, o.__elementType = e, o;
};
qfe("payment", typeof window > "u");
il("PaymentElementContext");
il("StripeUtilsContext");
var Uu = _U({ packageName: "@clerk/clerk-react" });
function Gfe(e) {
  Uu.setMessages(e).setPackageName(e);
}
il("AuthContext");
var Kfe = RU, Zfe = (e) => `You've passed multiple children components to <${e}/>. You can only pass a single child component or text.`, Gk = "Unsupported usage of isSatellite, domain or proxyUrl. The usage of isSatellite, domain or proxyUrl as function is not supported in non-browser environments.", Yfe = "<UserProfile.Page /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.", Xfe = "<UserProfile.Link /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.", Jfe = "<OrganizationProfile.Page /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.", Qfe = "<OrganizationProfile.Link /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.", ehe = (e) => `<${e} /> can only accept <${e}.Page /> and <${e}.Link /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.`, the = (e) => `Missing props. <${e}.Page /> component requires the following props: url, label, labelIcon, alongside with children to be rendered inside the page.`, nhe = (e) => `Missing props. <${e}.Link /> component requires the following props: url, label and labelIcon.`, rhe = "<UserButton /> can only accept <UserButton.UserProfilePage />, <UserButton.UserProfileLink /> and <UserButton.MenuItems /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.", ihe = "<UserButton.MenuItems /> component can only accept <UserButton.Action /> and <UserButton.Link /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.", ohe = "<UserButton.MenuItems /> component needs to be a direct child of `<UserButton />`.", she = "<UserButton.Action /> component needs to be a direct child of `<UserButton.MenuItems />`.", ahe = "<UserButton.Link /> component needs to be a direct child of `<UserButton.MenuItems />`.", lhe = "Missing props. <UserButton.Link /> component requires the following props: href, label and labelIcon.", che = "Missing props. <UserButton.Action /> component requires the following props: label.", uhe = (e) => {
  OU(() => {
    Uu.throwMissingClerkProviderError({ source: e });
  });
}, Dn = (e, t) => {
  const r = (typeof t == "string" ? t : t?.component) || e.displayName || e.name || "Component";
  e.displayName = r;
  const i = typeof t == "string" ? void 0 : t, o = (s) => {
    uhe(r || "withClerk");
    const a = Kfe();
    return !a.loaded && !i?.renderWhileLoading ? null : /* @__PURE__ */ Ne.createElement(
      e,
      {
        ...s,
        component: r,
        clerk: a
      }
    );
  };
  return o.displayName = `withClerk(${r})`, o;
};
const dhe = () => {
  try {
    return !1;
  } catch {
  }
  return !1;
}, fhe = () => {
  try {
    return !1;
  } catch {
  }
  return !1;
}, hhe = () => {
  try {
    return !0;
  } catch {
  }
  return !1;
}, $j = /* @__PURE__ */ new Set(), yM = (e, t, n) => {
  const r = fhe() || hhe(), i = e;
  $j.has(i) || r || ($j.add(i), console.warn(`Clerk - DEPRECATION WARNING: "${e}" is deprecated and will be removed in the next major release.
${t}`));
};
Dn(({ clerk: e, ...t }) => {
  const { client: n, session: r } = e, i = n.signedInSessions ? n.signedInSessions.length > 0 : (
    // Compat for clerk-js<5.54.0 (which was released with the `signedInSessions` property)
    n.activeSessions && n.activeSessions.length > 0
  );
  return Ne.useEffect(() => {
    r === null && i ? e.redirectToAfterSignOut() : e.redirectToSignIn(t);
  }, []), null;
}, "RedirectToSignIn");
Dn(({ clerk: e, ...t }) => (Ne.useEffect(() => {
  e.redirectToSignUp(t);
}, []), null), "RedirectToSignUp");
Dn(({ clerk: e, ...t }) => (Ne.useEffect(() => {
  e.redirectToTasks(t);
}, []), null), "RedirectToTasks");
Dn(({ clerk: e }) => (Ne.useEffect(() => {
  yM("RedirectToUserProfile", "Use the `redirectToUserProfile()` method instead."), e.redirectToUserProfile();
}, []), null), "RedirectToUserProfile");
Dn(({ clerk: e }) => (Ne.useEffect(() => {
  yM("RedirectToOrganizationProfile", "Use the `redirectToOrganizationProfile()` method instead."), e.redirectToOrganizationProfile();
}, []), null), "RedirectToOrganizationProfile");
Dn(({ clerk: e }) => (Ne.useEffect(() => {
  yM("RedirectToCreateOrganization", "Use the `redirectToCreateOrganization()` method instead."), e.redirectToCreateOrganization();
}, []), null), "RedirectToCreateOrganization");
Dn(
  ({ clerk: e, ...t }) => (Ne.useEffect(() => {
    e.handleRedirectCallback(t);
  }, []), null),
  "AuthenticateWithRedirectCallback"
);
function Kk(e, t, n) {
  if (typeof e == "function") return e(t);
  if (typeof e < "u") return e;
  if (typeof n < "u") return n;
}
const Ti = (e) => {
  dhe() && console.error(`Clerk: ${e}`);
}, Uj = (e, ...t) => {
  const n = { ...e };
  for (const r of t) delete n[r];
  return n;
};
var pw = (e) => (t) => {
  try {
    return Ne.Children.only(e);
  } catch {
    return Uu.throw(Zfe(t));
  }
}, mw = (e, t) => (e || (e = t), typeof e == "string" && (e = /* @__PURE__ */ Ne.createElement("button", null, e)), e), gw = (e) => (...t) => {
  if (e && typeof e == "function")
    return e(...t);
};
function phe(e) {
  return typeof e == "function";
}
var Am = (e) => {
  const [t, n] = k.useState(/* @__PURE__ */ new Map());
  return e.map((r) => ({
    id: r.id,
    mount: (i) => n((o) => new Map(o).set(String(r.id), i)),
    unmount: () => n((i) => {
      const o = new Map(i);
      return o.set(String(r.id), null), o;
    }),
    portal: () => {
      const i = t.get(String(r.id));
      return i ? tl.createPortal(r.component, i) : null;
    }
  }));
}, _i = (e, t) => !!e && Ne.isValidElement(e) && e?.type === t, IU = (e, t) => BU(
  {
    children: e,
    reorderItemsLabels: ["account", "security", "billing", "apiKeys"],
    LinkComponent: Yg,
    PageComponent: Zg,
    MenuItemsComponent: vw,
    componentName: "UserProfile"
  },
  t
), zU = (e, t) => BU(
  {
    children: e,
    reorderItemsLabels: ["general", "members", "billing", "apiKeys"],
    LinkComponent: xw,
    PageComponent: bw,
    componentName: "OrganizationProfile"
  },
  t
), LU = (e) => {
  const t = [], n = [
    xw,
    bw,
    vw,
    Zg,
    Yg
  ];
  return Ne.Children.forEach(e, (r) => {
    n.some((i) => _i(r, i)) || t.push(r);
  }), t;
}, BU = (e, t) => {
  const { children: n, LinkComponent: r, PageComponent: i, MenuItemsComponent: o, reorderItemsLabels: s, componentName: a } = e, { allowForAnyChildren: c = !1 } = t || {}, u = [];
  Ne.Children.forEach(n, (_) => {
    if (!_i(_, i) && !_i(_, r) && !_i(_, o)) {
      _ && !c && Ti(ehe(a));
      return;
    }
    const { props: M } = _, { children: N, label: P, url: I, labelIcon: O } = M;
    if (_i(_, i))
      if (Fj(M, s))
        u.push({ label: P });
      else if (Zk(M))
        u.push({ label: P, labelIcon: O, children: N, url: I });
      else {
        Ti(the(a));
        return;
      }
    if (_i(_, r))
      if (Yk(M))
        u.push({ label: P, labelIcon: O, url: I });
      else {
        Ti(nhe(a));
        return;
      }
  });
  const f = [], h = [], m = [];
  u.forEach((_, M) => {
    if (Zk(_)) {
      f.push({ component: _.children, id: M }), h.push({ component: _.labelIcon, id: M });
      return;
    }
    Yk(_) && m.push({ component: _.labelIcon, id: M });
  });
  const g = Am(f), b = Am(h), x = Am(m), w = [], S = [];
  return u.forEach((_, M) => {
    if (Fj(_, s)) {
      w.push({ label: _.label });
      return;
    }
    if (Zk(_)) {
      const {
        portal: N,
        mount: P,
        unmount: I
      } = g.find((B) => B.id === M), {
        portal: O,
        mount: L,
        unmount: U
      } = b.find((B) => B.id === M);
      w.push({ label: _.label, url: _.url, mount: P, unmount: I, mountIcon: L, unmountIcon: U }), S.push(N), S.push(O);
      return;
    }
    if (Yk(_)) {
      const {
        portal: N,
        mount: P,
        unmount: I
      } = x.find((O) => O.id === M);
      w.push({ label: _.label, url: _.url, mountIcon: P, unmountIcon: I }), S.push(N);
      return;
    }
  }), { customPages: w, customPagesPortals: S };
}, Fj = (e, t) => {
  const { children: n, label: r, url: i, labelIcon: o } = e;
  return !n && !i && !o && t.some((s) => s === r);
}, Zk = (e) => {
  const { children: t, label: n, url: r, labelIcon: i } = e;
  return !!t && !!r && !!i && !!n;
}, Yk = (e) => {
  const { children: t, label: n, url: r, labelIcon: i } = e;
  return !t && !!r && !!i && !!n;
}, mhe = (e, t) => {
  var n;
  return ghe({
    children: e,
    reorderItemsLabels: ["manageAccount", "signOut"],
    MenuItemsComponent: vw,
    MenuActionComponent: UU,
    MenuLinkComponent: FU,
    UserProfileLinkComponent: Yg,
    UserProfilePageComponent: Zg,
    allowForAnyChildren: (n = t?.allowForAnyChildren) != null ? n : !1
  });
}, ghe = ({
  children: e,
  MenuItemsComponent: t,
  MenuActionComponent: n,
  MenuLinkComponent: r,
  UserProfileLinkComponent: i,
  UserProfilePageComponent: o,
  reorderItemsLabels: s,
  allowForAnyChildren: a = !1
}) => {
  const c = [], u = [], f = [];
  Ne.Children.forEach(e, (x) => {
    if (!_i(x, t) && !_i(x, i) && !_i(x, o)) {
      x && !a && Ti(rhe);
      return;
    }
    if (_i(x, i) || _i(x, o))
      return;
    const { props: w } = x;
    Ne.Children.forEach(w.children, (S) => {
      if (!_i(S, n) && !_i(S, r)) {
        S && Ti(ihe);
        return;
      }
      const { props: _ } = S, { label: M, labelIcon: N, href: P, onClick: I, open: O } = _;
      if (_i(S, n))
        if (Vj(_, s))
          c.push({ label: M });
        else if (Xk(_)) {
          const L = {
            label: M,
            labelIcon: N
          };
          if (I !== void 0)
            c.push({
              ...L,
              onClick: I
            });
          else if (O !== void 0)
            c.push({
              ...L,
              open: O.startsWith("/") ? O : `/${O}`
            });
          else {
            Ti("Custom menu item must have either onClick or open property");
            return;
          }
        } else {
          Ti(che);
          return;
        }
      if (_i(S, r))
        if (Jk(_))
          c.push({ label: M, labelIcon: N, href: P });
        else {
          Ti(lhe);
          return;
        }
    });
  });
  const h = [], m = [];
  c.forEach((x, w) => {
    Xk(x) && h.push({ component: x.labelIcon, id: w }), Jk(x) && m.push({ component: x.labelIcon, id: w });
  });
  const g = Am(h), b = Am(m);
  return c.forEach((x, w) => {
    if (Vj(x, s) && u.push({
      label: x.label
    }), Xk(x)) {
      const {
        portal: S,
        mount: _,
        unmount: M
      } = g.find((P) => P.id === w), N = {
        label: x.label,
        mountIcon: _,
        unmountIcon: M
      };
      "onClick" in x ? N.onClick = x.onClick : "open" in x && (N.open = x.open), u.push(N), f.push(S);
    }
    if (Jk(x)) {
      const {
        portal: S,
        mount: _,
        unmount: M
      } = b.find((N) => N.id === w);
      u.push({
        label: x.label,
        href: x.href,
        mountIcon: _,
        unmountIcon: M
      }), f.push(S);
    }
  }), { customMenuItems: u, customMenuItemsPortals: f };
}, Vj = (e, t) => {
  const { children: n, label: r, onClick: i, labelIcon: o } = e;
  return !n && !i && !o && t.some((s) => s === r);
}, Xk = (e) => {
  const { label: t, labelIcon: n, onClick: r, open: i } = e;
  return !!n && !!t && (typeof r == "function" || typeof i == "string");
}, Jk = (e) => {
  const { label: t, href: n, labelIcon: r } = e;
  return !!n && !!r && !!t;
}, yhe = (e) => {
  const t = e?.isReady;
  return (n) => new Promise((r, i) => {
    const { root: o = document?.body, selector: s, timeout: a = 0 } = n;
    if (!o) {
      i(new Error("No root element provided"));
      return;
    }
    let c = o;
    if (s && (c = o?.querySelector(s)), t(c, s)) {
      r();
      return;
    }
    const u = new MutationObserver((f) => {
      for (const h of f)
        if (!c && s && (c = o?.querySelector(s)), (e.childList && h.type === "childList" || e.attributes && h.type === "attributes") && t(c, s)) {
          u.disconnect(), r();
          return;
        }
    });
    u.observe(o, e), a > 0 && setTimeout(() => {
      u.disconnect(), i(new Error(`Timeout waiting for ${s}`));
    }, a);
  });
}, vhe = yhe({
  childList: !0,
  subtree: !0,
  isReady: (e, t) => {
    var n;
    return !!e?.childElementCount && ((n = e?.matches) == null ? void 0 : n.call(e, t)) && e.childElementCount > 0;
  }
});
function Pi(e, t) {
  const n = k.useRef(), [r, i] = k.useState("rendering");
  return k.useEffect(() => {
    if (!e)
      throw new Error("Clerk: no component name provided, unable to detect mount.");
    if (typeof window < "u" && !n.current) {
      const o = `[data-clerk-component="${e}"]`, s = t?.selector;
      n.current = vhe({
        selector: s ? (
          // Allows for `[data-clerk-component="xxxx"][data-some-attribute="123"] .my-class`
          o + s
        ) : o
      }).then(() => {
        i("rendered");
      }).catch(() => {
        i("error");
      });
    }
  }, [e, t?.selector]), r;
}
var jv = (e) => "mount" in e, Hj = (e) => "open" in e, Wj = (e) => e?.map(({ mountIcon: t, unmountIcon: n, ...r }) => r), oi = class extends Ne.PureComponent {
  constructor() {
    super(...arguments), this.rootRef = Ne.createRef();
  }
  componentDidUpdate(e) {
    var t, n, r, i;
    if (!jv(e) || !jv(this.props))
      return;
    const o = Uj(e.props, "customPages", "customMenuItems", "children"), s = Uj(this.props.props, "customPages", "customMenuItems", "children"), a = ((t = o.customPages) == null ? void 0 : t.length) !== ((n = s.customPages) == null ? void 0 : n.length), c = ((r = o.customMenuItems) == null ? void 0 : r.length) !== ((i = s.customMenuItems) == null ? void 0 : i.length), u = Wj(e.props.customMenuItems), f = Wj(this.props.props.customMenuItems);
    (!zj(o, s) || !zj(u, f) || a || c) && this.rootRef.current && this.props.updateProps({ node: this.rootRef.current, props: this.props.props });
  }
  componentDidMount() {
    this.rootRef.current && (jv(this.props) && this.props.mount(this.rootRef.current, this.props.props), Hj(this.props) && this.props.open(this.props.props));
  }
  componentWillUnmount() {
    this.rootRef.current && (jv(this.props) && this.props.unmount(this.rootRef.current), Hj(this.props) && this.props.close());
  }
  render() {
    const { hideRootHtmlElement: e = !1 } = this.props, t = {
      ref: this.rootRef,
      ...this.props.rootProps,
      ...this.props.component && { "data-clerk-component": this.props.component }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, !e && /* @__PURE__ */ Ne.createElement("div", { ...t }), this.props.children);
  }
}, yw = (e) => {
  var t, n;
  return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, (t = e?.customPagesPortals) == null ? void 0 : t.map((r, i) => k.createElement(r, { key: i })), (n = e?.customMenuItemsPortals) == null ? void 0 : n.map((r, i) => k.createElement(r, { key: i })));
};
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountSignIn,
        unmount: e.unmountSignIn,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "SignIn", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountSignUp,
        unmount: e.unmountSignUp,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "SignUp", renderWhileLoading: !0 }
);
function Zg({ children: e }) {
  return Ti(Yfe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function Yg({ children: e }) {
  return Ti(Xfe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
var bhe = Dn(
  ({
    clerk: e,
    component: t,
    fallback: n,
    ...r
  }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    }, { customPages: a, customPagesPortals: c } = IU(r.children);
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountUserProfile,
        unmount: e.unmountUserProfile,
        updateProps: e.__unstable__updateProps,
        props: { ...r, customPages: a },
        rootProps: s
      },
      /* @__PURE__ */ Ne.createElement(yw, { customPagesPortals: c })
    ));
  },
  { component: "UserProfile", renderWhileLoading: !0 }
);
Object.assign(bhe, {
  Page: Zg,
  Link: Yg
});
var $U = k.createContext({
  mount: () => {
  },
  unmount: () => {
  },
  updateProps: () => {
  }
}), xhe = Dn(
  ({
    clerk: e,
    component: t,
    fallback: n,
    ...r
  }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    }, { customPages: a, customPagesPortals: c } = IU(r.children, {
      allowForAnyChildren: !!r.__experimental_asProvider
    }), u = { ...r.userProfileProps, customPages: a }, { customMenuItems: f, customMenuItemsPortals: h } = mhe(r.children, {
      allowForAnyChildren: !!r.__experimental_asProvider
    }), m = LU(r.children), g = {
      mount: e.mountUserButton,
      unmount: e.unmountUserButton,
      updateProps: e.__unstable__updateProps,
      props: { ...r, userProfileProps: u, customMenuItems: f }
    }, b = {
      customPagesPortals: c,
      customMenuItemsPortals: h
    };
    return /* @__PURE__ */ Ne.createElement($U.Provider, { value: g }, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        ...g,
        hideRootHtmlElement: !!r.__experimental_asProvider,
        rootProps: s
      },
      r.__experimental_asProvider ? m : null,
      /* @__PURE__ */ Ne.createElement(yw, { ...b })
    ));
  },
  { component: "UserButton", renderWhileLoading: !0 }
);
function vw({ children: e }) {
  return Ti(ohe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function UU({ children: e }) {
  return Ti(she), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function FU({ children: e }) {
  return Ti(ahe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function whe(e) {
  const t = k.useContext($U), n = {
    ...t,
    props: {
      ...t.props,
      ...e
    }
  };
  return /* @__PURE__ */ Ne.createElement(oi, { ...n });
}
Object.assign(xhe, {
  UserProfilePage: Zg,
  UserProfileLink: Yg,
  MenuItems: vw,
  Action: UU,
  Link: FU,
  __experimental_Outlet: whe
});
function bw({ children: e }) {
  return Ti(Jfe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function xw({ children: e }) {
  return Ti(Qfe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
var She = Dn(
  ({
    clerk: e,
    component: t,
    fallback: n,
    ...r
  }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    }, { customPages: a, customPagesPortals: c } = zU(r.children);
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountOrganizationProfile,
        unmount: e.unmountOrganizationProfile,
        updateProps: e.__unstable__updateProps,
        props: { ...r, customPages: a },
        rootProps: s
      },
      /* @__PURE__ */ Ne.createElement(yw, { customPagesPortals: c })
    ));
  },
  { component: "OrganizationProfile", renderWhileLoading: !0 }
);
Object.assign(She, {
  Page: bw,
  Link: xw
});
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountCreateOrganization,
        unmount: e.unmountCreateOrganization,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "CreateOrganization", renderWhileLoading: !0 }
);
var VU = k.createContext({
  mount: () => {
  },
  unmount: () => {
  },
  updateProps: () => {
  }
}), khe = Dn(
  ({
    clerk: e,
    component: t,
    fallback: n,
    ...r
  }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    }, { customPages: a, customPagesPortals: c } = zU(r.children, {
      allowForAnyChildren: !!r.__experimental_asProvider
    }), u = { ...r.organizationProfileProps, customPages: a }, f = LU(r.children), h = {
      mount: e.mountOrganizationSwitcher,
      unmount: e.unmountOrganizationSwitcher,
      updateProps: e.__unstable__updateProps,
      props: { ...r, organizationProfileProps: u },
      rootProps: s,
      component: t
    };
    return e.__experimental_prefetchOrganizationSwitcher(), /* @__PURE__ */ Ne.createElement(VU.Provider, { value: h }, /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        ...h,
        hideRootHtmlElement: !!r.__experimental_asProvider
      },
      r.__experimental_asProvider ? f : null,
      /* @__PURE__ */ Ne.createElement(yw, { customPagesPortals: c })
    )));
  },
  { component: "OrganizationSwitcher", renderWhileLoading: !0 }
);
function Che(e) {
  const t = k.useContext(VU), n = {
    ...t,
    props: {
      ...t.props,
      ...e
    }
  };
  return /* @__PURE__ */ Ne.createElement(oi, { ...n });
}
Object.assign(khe, {
  OrganizationProfilePage: bw,
  OrganizationProfileLink: xw,
  __experimental_Outlet: Che
});
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountOrganizationList,
        unmount: e.unmountOrganizationList,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "OrganizationList", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        open: e.openGoogleOneTap,
        close: e.closeGoogleOneTap,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "GoogleOneTap", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountWaitlist,
        unmount: e.unmountWaitlist,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "Waitlist", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t, {
      // This attribute is added to the PricingTable root element after we've successfully fetched the plans asynchronously.
      selector: '[data-component-status="ready"]'
    }) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountPricingTable,
        unmount: e.unmountPricingTable,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "PricingTable", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountAPIKeys,
        unmount: e.unmountAPIKeys,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "ApiKeys", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountUserAvatar,
        unmount: e.unmountUserAvatar,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "UserAvatar", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountTaskChooseOrganization,
        unmount: e.unmountTaskChooseOrganization,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "TaskChooseOrganization", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountTaskResetPassword,
        unmount: e.unmountTaskResetPassword,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "TaskResetPassword", renderWhileLoading: !0 }
);
var HU = (e) => {
  throw TypeError(e);
}, vM = (e, t, n) => t.has(e) || HU("Cannot " + n), $n = (e, t, n) => (vM(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Yl = (e, t, n) => t.has(e) ? HU("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), Cu = (e, t, n, r) => (vM(e, t, "write to private field"), t.set(e, n), n), Qk = (e, t, n) => (vM(e, t, "access private method"), n);
const Ehe = {
  initialDelay: 125,
  maxDelayBetweenRetries: 0,
  factor: 2,
  shouldRetry: (e, t) => t < 5,
  retryImmediately: !1,
  jitter: !0
}, _he = 100, WU = async (e) => new Promise((t) => setTimeout(t, e)), qU = (e, t) => t ? e * (1 + Math.random()) : e, The = (e) => {
  let t = 0;
  const n = () => {
    const r = e.initialDelay, i = e.factor;
    let o = r * Math.pow(i, t);
    return o = qU(o, e.jitter), Math.min(e.maxDelayBetweenRetries || o, o);
  };
  return async () => {
    await WU(n()), t++;
  };
}, Ahe = async (e, t = {}) => {
  let n = 0;
  const { shouldRetry: r, initialDelay: i, maxDelayBetweenRetries: o, factor: s, retryImmediately: a, jitter: c, onBeforeRetry: u } = {
    ...Ehe,
    ...t
  }, f = The({
    initialDelay: i,
    maxDelayBetweenRetries: o,
    factor: s,
    jitter: c
  });
  for (; ; ) try {
    return await e();
  } catch (h) {
    if (n++, !r(h, n)) throw h;
    u && await u(n), a && n === 1 ? await WU(qU(_he, c)) : await f();
  }
}, Mhe = "loadScript cannot be called when document does not exist", Nhe = "loadScript cannot be called without a src";
async function Rhe(e = "", t) {
  const { async: n, defer: r, beforeLoad: i, crossOrigin: o, nonce: s } = t || {};
  return Ahe(() => new Promise((c, u) => {
    e || u(new Error(Nhe)), (!document || !document.body) && u(new Error(Mhe));
    const f = document.createElement("script");
    o && f.setAttribute("crossorigin", o), f.async = n || !1, f.defer = r || !1, f.addEventListener("load", () => {
      f.remove(), c(f);
    }), f.addEventListener("error", (h) => {
      f.remove(), u(h.error ?? /* @__PURE__ */ new Error(`failed to load script: ${e}`));
    }), f.src = e, f.nonce = s, i?.(f), document.body.appendChild(f);
  }), { shouldRetry: (c, u) => u <= 5 });
}
function Ohe(e) {
  return e ? Dhe(e) || GU(e) : !0;
}
function Dhe(e) {
  return /^http(s)?:\/\//.test(e || "");
}
function GU(e) {
  return e.startsWith("/");
}
function Phe(e) {
  return e ? GU(e) ? new URL(e, window.location.origin).toString() : e : "";
}
function jhe(e) {
  if (!e) return "";
  let t;
  if (e.match(/^(clerk\.)+\w*$/)) t = /(clerk\.)*(?=clerk\.)/;
  else {
    if (e.match(/\.clerk.accounts/)) return e;
    t = /^(clerk\.)*/gi;
  }
  return `clerk.${e.replace(t, "")}`;
}
const Ihe = (e, t = "5.122.0") => {
  if (e) return e;
  const n = zhe(t);
  return n ? n === "snapshot" ? "5.122.0" : n : Lhe(t);
}, zhe = (e) => e.trim().replace(/^v/, "").match(/-(.+?)(\.|$)/)?.[1], Lhe = (e) => e.trim().replace(/^v/, "").split(".")[0], KU = "failed_to_load_clerk_js", Bhe = "failed_to_load_clerk_js_timeout", w_ = "Failed to load Clerk", { isDevOrStagingUrl: $he } = jfe(), ZU = _U({ packageName: "@clerk/shared" });
function Uhe(e) {
  ZU.setPackageName({ packageName: e });
}
function S_() {
  if (typeof window > "u" || !window.Clerk) return !1;
  const e = window.Clerk;
  return typeof e == "object" && typeof e.load == "function";
}
function Fhe(e) {
  if (typeof window > "u" || !window.performance) return !1;
  const t = performance.getEntriesByName(e, "resource");
  if (t.length === 0) return !1;
  const n = t[t.length - 1];
  return n.transferSize === 0 && n.decodedBodySize === 0 && (n.responseEnd === 0 || n.responseEnd > 0 && n.responseStart > 0 || "responseStatus" in n && (n.responseStatus >= 400 || n.responseStatus === 0));
}
function qj(e, t) {
  return new Promise((n, r) => {
    let i = !1;
    const o = (f, h) => {
      clearTimeout(f), clearInterval(h);
    };
    t?.addEventListener("error", () => {
      o(c, u), r(new x_(w_, { code: KU }));
    });
    const s = () => {
      i || S_() && (i = !0, o(c, u), n(null));
    }, c = setTimeout(() => {
      i || (i = !0, o(c, u), S_() ? n(null) : r(new x_(w_, { code: Bhe })));
    }, e);
    s();
    const u = setInterval(() => {
      if (i) {
        clearInterval(u);
        return;
      }
      s();
    }, 100);
  });
}
const Vhe = async (e) => {
  const t = e?.scriptLoadTimeout ?? 15e3;
  if (S_()) return null;
  if (!e?.publishableKey)
    return ZU.throwMissingPublishableKeyError(), null;
  const n = Hhe(e), r = document.querySelector("script[data-clerk-js-script]");
  if (r) if (Fhe(n)) r.remove();
  else try {
    return await qj(t, r), null;
  } catch {
    r.remove();
  }
  const i = qj(t);
  return Rhe(n, {
    async: !0,
    crossOrigin: "anonymous",
    nonce: e.nonce,
    beforeLoad: qhe(e)
  }).catch((o) => {
    throw new x_(w_ + (o.message ? `, ${o.message}` : ""), {
      code: KU,
      cause: o
    });
  }), i;
}, Hhe = (e) => {
  const { clerkJSUrl: t, clerkJSVariant: n, clerkJSVersion: r, proxyUrl: i, domain: o, publishableKey: s } = e;
  if (t) return t;
  let a = "";
  i && Ohe(i) ? a = Phe(i).replace(/http(s)?:\/\//, "") : o && !$he(Oj(s)?.frontendApi || "") ? a = jhe(o) : a = Oj(s)?.frontendApi || "";
  const c = n ? `${n.replace(/\.+$/, "")}.` : "", u = Ihe(r);
  return `https://${a}/npm/@clerk/clerk-js@${u}/dist/clerk.${c}browser.js`;
}, Whe = (e) => {
  const t = {};
  return e.publishableKey && (t["data-clerk-publishable-key"] = e.publishableKey), e.proxyUrl && (t["data-clerk-proxy-url"] = e.proxyUrl), e.domain && (t["data-clerk-domain"] = e.domain), e.nonce && (t.nonce = e.nonce), t;
}, qhe = (e) => (t) => {
  const n = Whe(e);
  for (const r in n) t.setAttribute(r, n[r]);
};
function vb() {
  return typeof window < "u";
}
const Gj = (e, t, n, r, i) => {
  const { notify: o } = i || {};
  let s = e.get(n);
  s || (s = [], e.set(n, s)), s.push(r), o && t.has(n) && r(t.get(n));
}, Kj = (e, t, n) => (e.get(t) || []).map((r) => r(n)), Zj = (e, t, n) => {
  const r = e.get(t);
  r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : e.set(t, []));
}, Ghe = () => {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    on: (...i) => Gj(e, t, ...i),
    prioritizedOn: (...i) => Gj(n, t, ...i),
    emit: (i, o) => {
      t.set(i, o), Kj(n, i, o), Kj(e, i, o);
    },
    off: (...i) => Zj(e, ...i),
    prioritizedOff: (...i) => Zj(n, ...i),
    internal: { retrieveListeners: (i) => e.get(i) || [] }
  };
}, Iv = { Status: "status" }, Khe = () => Ghe();
typeof window < "u" && !window.global && (window.global = typeof global > "u" ? window : global);
Dn(
  ({ clerk: e, children: t, ...n }) => {
    const {
      // @ts-expect-error - appearance is a valid prop for SignInProps & SignInButtonPropsModal
      appearance: r,
      signUpFallbackRedirectUrl: i,
      forceRedirectUrl: o,
      fallbackRedirectUrl: s,
      signUpForceRedirectUrl: a,
      mode: c,
      initialValues: u,
      withSignUp: f,
      oauthFlow: h,
      ...m
    } = n;
    t = mw(t, "Sign in");
    const g = pw(t)("SignInButton"), b = () => {
      const S = {
        forceRedirectUrl: o,
        fallbackRedirectUrl: s,
        signUpFallbackRedirectUrl: i,
        signUpForceRedirectUrl: a,
        initialValues: u,
        withSignUp: f,
        oauthFlow: h
      };
      return c === "modal" ? e.openSignIn({ ...S, appearance: r }) : e.redirectToSignIn({
        ...S,
        signInFallbackRedirectUrl: s,
        signInForceRedirectUrl: o
      });
    }, w = { ...m, onClick: async (S) => (g && typeof g == "object" && "props" in g && await gw(g.props.onClick)(S), b()) };
    return Ne.cloneElement(g, w);
  },
  { component: "SignInButton", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, children: t, ...n }) => {
    const { redirectUrl: r, ...i } = n;
    t = mw(t, "Sign in with Metamask");
    const o = pw(t)("SignInWithMetamaskButton"), s = async () => {
      async function u() {
        await e.authenticateWithMetamask({ redirectUrl: r || void 0 });
      }
      u();
    }, c = { ...i, onClick: async (u) => (await gw(o.props.onClick)(u), s()) };
    return Ne.cloneElement(o, c);
  },
  { component: "SignInWithMetamask", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, children: t, ...n }) => {
    const { redirectUrl: r = "/", signOutOptions: i, ...o } = n;
    t = mw(t, "Sign out");
    const s = pw(t)("SignOutButton"), a = () => e.signOut({ redirectUrl: r, ...i }), u = { ...o, onClick: async (f) => (await gw(s.props.onClick)(f), a()) };
    return Ne.cloneElement(s, u);
  },
  { component: "SignOutButton", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, children: t, ...n }) => {
    const {
      // @ts-expect-error - appearance is a valid prop for SignUpProps & SignUpButtonPropsModal
      appearance: r,
      // @ts-expect-error - unsafeMetadata is a valid prop for SignUpProps & SignUpButtonPropsModal
      unsafeMetadata: i,
      fallbackRedirectUrl: o,
      forceRedirectUrl: s,
      signInFallbackRedirectUrl: a,
      signInForceRedirectUrl: c,
      mode: u,
      initialValues: f,
      oauthFlow: h,
      ...m
    } = n;
    t = mw(t, "Sign up");
    const g = pw(t)("SignUpButton"), b = () => {
      const S = {
        fallbackRedirectUrl: o,
        forceRedirectUrl: s,
        signInFallbackRedirectUrl: a,
        signInForceRedirectUrl: c,
        initialValues: f,
        oauthFlow: h
      };
      return u === "modal" ? e.openSignUp({
        ...S,
        appearance: r,
        unsafeMetadata: i
      }) : e.redirectToSignUp({
        ...S,
        signUpFallbackRedirectUrl: o,
        signUpForceRedirectUrl: s
      });
    }, w = { ...m, onClick: async (S) => (g && typeof g == "object" && "props" in g && await gw(g.props.onClick)(S), b()) };
    return Ne.cloneElement(g, w);
  },
  { component: "SignUpButton", renderWhileLoading: !0 }
);
var Zhe = () => ({
  fields: {
    identifier: null,
    password: null,
    code: null
  },
  raw: null,
  global: null
}), Yhe = () => ({
  fields: {
    firstName: null,
    lastName: null,
    emailAddress: null,
    phoneNumber: null,
    password: null,
    username: null,
    code: null,
    captcha: null,
    legalAccepted: null
  },
  raw: null,
  global: null
}), Xhe = class {
  constructor(e) {
    this.isomorphicClerk = e, this.signInSignalProxy = this.buildSignInProxy(), this.signUpSignalProxy = this.buildSignUpProxy();
  }
  signInSignal() {
    return this.signInSignalProxy;
  }
  signUpSignal() {
    return this.signUpSignalProxy;
  }
  buildSignInProxy() {
    const e = this.gateProperty.bind(this), t = () => this.client.signIn.__internal_future;
    return {
      errors: Zhe(),
      fetchStatus: "idle",
      signIn: {
        status: "needs_identifier",
        availableStrategies: [],
        isTransferable: !1,
        get id() {
          return e(t, "id", void 0);
        },
        get supportedFirstFactors() {
          return e(t, "supportedFirstFactors", []);
        },
        get supportedSecondFactors() {
          return e(t, "supportedSecondFactors", []);
        },
        get secondFactorVerification() {
          return e(t, "secondFactorVerification", {
            status: null,
            error: null,
            expireAt: null,
            externalVerificationRedirectURL: null,
            nonce: null,
            attempts: null,
            message: null,
            strategy: null,
            verifiedAtClient: null,
            verifiedFromTheSameClient: () => !1,
            __internal_toSnapshot: () => {
              throw new Error("__internal_toSnapshot called before Clerk is loaded");
            },
            pathRoot: "",
            reload: () => {
              throw new Error("__internal_toSnapshot called before Clerk is loaded");
            }
          });
        },
        get identifier() {
          return e(t, "identifier", null);
        },
        get createdSessionId() {
          return e(t, "createdSessionId", null);
        },
        get userData() {
          return e(t, "userData", {});
        },
        get firstFactorVerification() {
          return e(t, "firstFactorVerification", {
            status: null,
            error: null,
            expireAt: null,
            externalVerificationRedirectURL: null,
            nonce: null,
            attempts: null,
            message: null,
            strategy: null,
            verifiedAtClient: null,
            verifiedFromTheSameClient: () => !1,
            __internal_toSnapshot: () => {
              throw new Error("__internal_toSnapshot called before Clerk is loaded");
            },
            pathRoot: "",
            reload: () => {
              throw new Error("__internal_toSnapshot called before Clerk is loaded");
            }
          });
        },
        create: this.gateMethod(t, "create"),
        password: this.gateMethod(t, "password"),
        sso: this.gateMethod(t, "sso"),
        finalize: this.gateMethod(t, "finalize"),
        emailCode: this.wrapMethods(() => t().emailCode, ["sendCode", "verifyCode"]),
        emailLink: this.wrapStruct(
          () => t().emailLink,
          ["sendLink", "waitForVerification"],
          ["verification"],
          { verification: null }
        ),
        resetPasswordEmailCode: this.wrapMethods(() => t().resetPasswordEmailCode, [
          "sendCode",
          "verifyCode",
          "submitPassword"
        ]),
        phoneCode: this.wrapMethods(() => t().phoneCode, ["sendCode", "verifyCode"]),
        mfa: this.wrapMethods(() => t().mfa, [
          "sendPhoneCode",
          "verifyPhoneCode",
          "verifyTOTP",
          "verifyBackupCode"
        ]),
        ticket: this.gateMethod(t, "ticket"),
        passkey: this.gateMethod(t, "passkey"),
        web3: this.gateMethod(t, "web3")
      }
    };
  }
  buildSignUpProxy() {
    const e = this.gateProperty.bind(this), t = this.gateMethod.bind(this), n = this.wrapMethods.bind(this), r = () => this.client.signUp.__internal_future;
    return {
      errors: Yhe(),
      fetchStatus: "idle",
      signUp: {
        get id() {
          return e(r, "id", void 0);
        },
        get requiredFields() {
          return e(r, "requiredFields", []);
        },
        get optionalFields() {
          return e(r, "optionalFields", []);
        },
        get missingFields() {
          return e(r, "missingFields", []);
        },
        get username() {
          return e(r, "username", null);
        },
        get firstName() {
          return e(r, "firstName", null);
        },
        get lastName() {
          return e(r, "lastName", null);
        },
        get emailAddress() {
          return e(r, "emailAddress", null);
        },
        get phoneNumber() {
          return e(r, "phoneNumber", null);
        },
        get web3Wallet() {
          return e(r, "web3Wallet", null);
        },
        get hasPassword() {
          return e(r, "hasPassword", !1);
        },
        get unsafeMetadata() {
          return e(r, "unsafeMetadata", {});
        },
        get createdSessionId() {
          return e(r, "createdSessionId", null);
        },
        get createdUserId() {
          return e(r, "createdUserId", null);
        },
        get abandonAt() {
          return e(r, "abandonAt", null);
        },
        get legalAcceptedAt() {
          return e(r, "legalAcceptedAt", null);
        },
        get locale() {
          return e(r, "locale", null);
        },
        get status() {
          return e(r, "status", "missing_requirements");
        },
        get unverifiedFields() {
          return e(r, "unverifiedFields", []);
        },
        get isTransferable() {
          return e(r, "isTransferable", !1);
        },
        create: t(r, "create"),
        update: t(r, "update"),
        sso: t(r, "sso"),
        password: t(r, "password"),
        ticket: t(r, "ticket"),
        web3: t(r, "web3"),
        finalize: t(r, "finalize"),
        verifications: n(() => r().verifications, [
          "sendEmailCode",
          "verifyEmailCode",
          "sendPhoneCode",
          "verifyPhoneCode"
        ])
      }
    };
  }
  __internal_effect(e) {
    throw new Error("__internal_effect called before Clerk is loaded");
  }
  __internal_computed(e) {
    throw new Error("__internal_computed called before Clerk is loaded");
  }
  get client() {
    const e = this.isomorphicClerk.client;
    if (!e)
      throw new Error("Clerk client not ready");
    return e;
  }
  gateProperty(e, t, n) {
    return !vb() || !this.isomorphicClerk.loaded ? n : e()[t];
  }
  gateMethod(e, t) {
    return (async (...n) => {
      if (!vb())
        return Uu.throw(`Attempted to call a method (${t}) that is not supported on the server.`);
      this.isomorphicClerk.loaded || await new Promise((i) => this.isomorphicClerk.addOnLoaded(i));
      const r = e();
      return r[t].apply(r, n);
    });
  }
  wrapMethods(e, t) {
    return Object.fromEntries(t.map((n) => [n, this.gateMethod(e, n)]));
  }
  wrapStruct(e, t, n, r) {
    const i = {};
    for (const o of t)
      i[o] = this.gateMethod(e, o);
    for (const o of n)
      Object.defineProperty(i, o, {
        get: () => this.gateProperty(e, o, r[o]),
        enumerable: !0
      });
    return i;
  }
};
typeof globalThis.__BUILD_DISABLE_RHC__ > "u" && (globalThis.__BUILD_DISABLE_RHC__ = !1);
var Jhe = {
  name: "@clerk/clerk-react",
  version: "5.60.0",
  environment: "production"
}, k0, kf, Cf, Xl, Os, C0, ec, lm, E0, Qhe = class YU {
  constructor(t) {
    Yl(this, lm), this.clerkjs = null, this.preopenOneTap = null, this.preopenUserVerification = null, this.preopenEnableOrganizationsPrompt = null, this.preopenSignIn = null, this.preopenCheckout = null, this.preopenPlanDetails = null, this.preopenSubscriptionDetails = null, this.preopenSignUp = null, this.preopenUserProfile = null, this.preopenOrganizationProfile = null, this.preopenCreateOrganization = null, this.preOpenWaitlist = null, this.premountSignInNodes = /* @__PURE__ */ new Map(), this.premountSignUpNodes = /* @__PURE__ */ new Map(), this.premountUserAvatarNodes = /* @__PURE__ */ new Map(), this.premountUserProfileNodes = /* @__PURE__ */ new Map(), this.premountUserButtonNodes = /* @__PURE__ */ new Map(), this.premountOrganizationProfileNodes = /* @__PURE__ */ new Map(), this.premountCreateOrganizationNodes = /* @__PURE__ */ new Map(), this.premountOrganizationSwitcherNodes = /* @__PURE__ */ new Map(), this.premountOrganizationListNodes = /* @__PURE__ */ new Map(), this.premountMethodCalls = /* @__PURE__ */ new Map(), this.premountWaitlistNodes = /* @__PURE__ */ new Map(), this.premountPricingTableNodes = /* @__PURE__ */ new Map(), this.premountAPIKeysNodes = /* @__PURE__ */ new Map(), this.premountOAuthConsentNodes = /* @__PURE__ */ new Map(), this.premountTaskChooseOrganizationNodes = /* @__PURE__ */ new Map(), this.premountTaskResetPasswordNodes = /* @__PURE__ */ new Map(), this.premountAddListenerCalls = /* @__PURE__ */ new Map(), this.loadedListeners = [], Yl(this, k0, "loading"), Yl(this, kf), Yl(this, Cf), Yl(this, Xl), Yl(this, Os, Khe()), Yl(this, C0), this.buildSignInUrl = (i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildSignInUrl(i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildSignInUrl", o);
    }, this.buildSignUpUrl = (i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildSignUpUrl(i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildSignUpUrl", o);
    }, this.buildAfterSignInUrl = (...i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildAfterSignInUrl(...i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildAfterSignInUrl", o);
    }, this.buildAfterSignUpUrl = (...i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildAfterSignUpUrl(...i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildAfterSignUpUrl", o);
    }, this.buildAfterSignOutUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildAfterSignOutUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildAfterSignOutUrl", i);
    }, this.buildNewSubscriptionRedirectUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildNewSubscriptionRedirectUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildNewSubscriptionRedirectUrl", i);
    }, this.buildAfterMultiSessionSingleSignOutUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildAfterMultiSessionSingleSignOutUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildAfterMultiSessionSingleSignOutUrl", i);
    }, this.buildUserProfileUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildUserProfileUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildUserProfileUrl", i);
    }, this.buildCreateOrganizationUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildCreateOrganizationUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildCreateOrganizationUrl", i);
    }, this.buildOrganizationProfileUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildOrganizationProfileUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildOrganizationProfileUrl", i);
    }, this.buildWaitlistUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildWaitlistUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildWaitlistUrl", i);
    }, this.buildTasksUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildTasksUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildTasksUrl", i);
    }, this.buildUrlWithAuth = (i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildUrlWithAuth(i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildUrlWithAuth", o);
    }, this.handleUnauthenticated = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.handleUnauthenticated();
      };
      this.clerkjs && this.loaded ? i() : this.premountMethodCalls.set("handleUnauthenticated", i);
    }, this.on = (...i) => {
      var o;
      if ((o = this.clerkjs) != null && o.on)
        return this.clerkjs.on(...i);
      $n(this, Os).on(...i);
    }, this.off = (...i) => {
      var o;
      if ((o = this.clerkjs) != null && o.off)
        return this.clerkjs.off(...i);
      $n(this, Os).off(...i);
    }, this.addOnLoaded = (i) => {
      this.loadedListeners.push(i), this.loaded && this.emitLoaded();
    }, this.emitLoaded = () => {
      this.loadedListeners.forEach((i) => i()), this.loadedListeners = [];
    }, this.beforeLoad = (i) => {
      if (!i)
        throw new Error("Failed to hydrate latest Clerk JS");
    }, this.hydrateClerkJS = (i) => {
      var o, s;
      if (!i)
        throw new Error("Failed to hydrate latest Clerk JS");
      return this.clerkjs = i, this.premountMethodCalls.forEach((a) => a()), this.premountAddListenerCalls.forEach((a, c) => {
        a.nativeUnsubscribe = i.addListener(c);
      }), (o = $n(this, Os).internal.retrieveListeners("status")) == null || o.forEach((a) => {
        this.on("status", a, { notify: !0 });
      }), (s = $n(this, Os).internal.retrieveListeners("queryClientStatus")) == null || s.forEach((a) => {
        this.on("queryClientStatus", a, { notify: !0 });
      }), this.preopenSignIn !== null && i.openSignIn(this.preopenSignIn), this.preopenCheckout !== null && i.__internal_openCheckout(this.preopenCheckout), this.preopenPlanDetails !== null && i.__internal_openPlanDetails(this.preopenPlanDetails), this.preopenSubscriptionDetails !== null && i.__internal_openSubscriptionDetails(this.preopenSubscriptionDetails), this.preopenSignUp !== null && i.openSignUp(this.preopenSignUp), this.preopenUserProfile !== null && i.openUserProfile(this.preopenUserProfile), this.preopenUserVerification !== null && i.__internal_openReverification(this.preopenUserVerification), this.preopenOneTap !== null && i.openGoogleOneTap(this.preopenOneTap), this.preopenOrganizationProfile !== null && i.openOrganizationProfile(this.preopenOrganizationProfile), this.preopenCreateOrganization !== null && i.openCreateOrganization(this.preopenCreateOrganization), this.preOpenWaitlist !== null && i.openWaitlist(this.preOpenWaitlist), this.preopenEnableOrganizationsPrompt && i.__internal_openEnableOrganizationsPrompt(this.preopenEnableOrganizationsPrompt), this.premountSignInNodes.forEach((a, c) => {
        i.mountSignIn(c, a);
      }), this.premountSignUpNodes.forEach((a, c) => {
        i.mountSignUp(c, a);
      }), this.premountUserProfileNodes.forEach((a, c) => {
        i.mountUserProfile(c, a);
      }), this.premountUserAvatarNodes.forEach((a, c) => {
        i.mountUserAvatar(c, a);
      }), this.premountUserButtonNodes.forEach((a, c) => {
        i.mountUserButton(c, a);
      }), this.premountOrganizationListNodes.forEach((a, c) => {
        i.mountOrganizationList(c, a);
      }), this.premountWaitlistNodes.forEach((a, c) => {
        i.mountWaitlist(c, a);
      }), this.premountPricingTableNodes.forEach((a, c) => {
        i.mountPricingTable(c, a);
      }), this.premountAPIKeysNodes.forEach((a, c) => {
        i.mountAPIKeys(c, a);
      }), this.premountOAuthConsentNodes.forEach((a, c) => {
        i.__internal_mountOAuthConsent(c, a);
      }), this.premountTaskChooseOrganizationNodes.forEach((a, c) => {
        i.mountTaskChooseOrganization(c, a);
      }), this.premountTaskResetPasswordNodes.forEach((a, c) => {
        i.mountTaskResetPassword(c, a);
      }), typeof this.clerkjs.status > "u" && $n(this, Os).emit(Iv.Status, "ready"), this.emitLoaded(), this.clerkjs;
    }, this.__experimental_checkout = (...i) => {
      var o;
      return (o = this.clerkjs) == null ? void 0 : o.__experimental_checkout(...i);
    }, this.__unstable__updateProps = async (i) => {
      const o = await Qk(this, lm, E0).call(this);
      if (o && "__unstable__updateProps" in o)
        return o.__unstable__updateProps(i);
    }, this.setActive = (i) => this.clerkjs ? this.clerkjs.setActive(i) : Promise.reject(), this.openSignIn = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openSignIn(i) : this.preopenSignIn = i;
    }, this.closeSignIn = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeSignIn() : this.preopenSignIn = null;
    }, this.__internal_openCheckout = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openCheckout(i) : this.preopenCheckout = i;
    }, this.__internal_closeCheckout = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closeCheckout() : this.preopenCheckout = null;
    }, this.__internal_openPlanDetails = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openPlanDetails(i) : this.preopenPlanDetails = i;
    }, this.__internal_closePlanDetails = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closePlanDetails() : this.preopenPlanDetails = null;
    }, this.__internal_openSubscriptionDetails = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openSubscriptionDetails(i) : this.preopenSubscriptionDetails = i ?? null;
    }, this.__internal_closeSubscriptionDetails = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closeSubscriptionDetails() : this.preopenSubscriptionDetails = null;
    }, this.__internal_openReverification = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openReverification(i) : this.preopenUserVerification = i;
    }, this.__internal_closeReverification = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closeReverification() : this.preopenUserVerification = null;
    }, this.__internal_openEnableOrganizationsPrompt = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openEnableOrganizationsPrompt(i) : this.preopenEnableOrganizationsPrompt = i;
    }, this.__internal_closeEnableOrganizationsPrompt = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closeEnableOrganizationsPrompt() : this.preopenEnableOrganizationsPrompt = null;
    }, this.openGoogleOneTap = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openGoogleOneTap(i) : this.preopenOneTap = i;
    }, this.closeGoogleOneTap = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeGoogleOneTap() : this.preopenOneTap = null;
    }, this.openUserProfile = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openUserProfile(i) : this.preopenUserProfile = i;
    }, this.closeUserProfile = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeUserProfile() : this.preopenUserProfile = null;
    }, this.openOrganizationProfile = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openOrganizationProfile(i) : this.preopenOrganizationProfile = i;
    }, this.closeOrganizationProfile = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeOrganizationProfile() : this.preopenOrganizationProfile = null;
    }, this.openCreateOrganization = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openCreateOrganization(i) : this.preopenCreateOrganization = i;
    }, this.closeCreateOrganization = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeCreateOrganization() : this.preopenCreateOrganization = null;
    }, this.openWaitlist = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openWaitlist(i) : this.preOpenWaitlist = i;
    }, this.closeWaitlist = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeWaitlist() : this.preOpenWaitlist = null;
    }, this.openSignUp = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openSignUp(i) : this.preopenSignUp = i;
    }, this.closeSignUp = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeSignUp() : this.preopenSignUp = null;
    }, this.mountSignIn = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountSignIn(i, o) : this.premountSignInNodes.set(i, o);
    }, this.unmountSignIn = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountSignIn(i) : this.premountSignInNodes.delete(i);
    }, this.mountSignUp = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountSignUp(i, o) : this.premountSignUpNodes.set(i, o);
    }, this.unmountSignUp = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountSignUp(i) : this.premountSignUpNodes.delete(i);
    }, this.mountUserAvatar = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountUserAvatar(i, o) : this.premountUserAvatarNodes.set(i, o);
    }, this.unmountUserAvatar = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountUserAvatar(i) : this.premountUserAvatarNodes.delete(i);
    }, this.mountUserProfile = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountUserProfile(i, o) : this.premountUserProfileNodes.set(i, o);
    }, this.unmountUserProfile = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountUserProfile(i) : this.premountUserProfileNodes.delete(i);
    }, this.mountOrganizationProfile = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountOrganizationProfile(i, o) : this.premountOrganizationProfileNodes.set(i, o);
    }, this.unmountOrganizationProfile = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountOrganizationProfile(i) : this.premountOrganizationProfileNodes.delete(i);
    }, this.mountCreateOrganization = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountCreateOrganization(i, o) : this.premountCreateOrganizationNodes.set(i, o);
    }, this.unmountCreateOrganization = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountCreateOrganization(i) : this.premountCreateOrganizationNodes.delete(i);
    }, this.mountOrganizationSwitcher = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountOrganizationSwitcher(i, o) : this.premountOrganizationSwitcherNodes.set(i, o);
    }, this.unmountOrganizationSwitcher = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountOrganizationSwitcher(i) : this.premountOrganizationSwitcherNodes.delete(i);
    }, this.__experimental_prefetchOrganizationSwitcher = () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.__experimental_prefetchOrganizationSwitcher();
      };
      this.clerkjs && this.loaded ? i() : this.premountMethodCalls.set("__experimental_prefetchOrganizationSwitcher", i);
    }, this.mountOrganizationList = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountOrganizationList(i, o) : this.premountOrganizationListNodes.set(i, o);
    }, this.unmountOrganizationList = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountOrganizationList(i) : this.premountOrganizationListNodes.delete(i);
    }, this.mountUserButton = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountUserButton(i, o) : this.premountUserButtonNodes.set(i, o);
    }, this.unmountUserButton = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountUserButton(i) : this.premountUserButtonNodes.delete(i);
    }, this.mountWaitlist = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountWaitlist(i, o) : this.premountWaitlistNodes.set(i, o);
    }, this.unmountWaitlist = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountWaitlist(i) : this.premountWaitlistNodes.delete(i);
    }, this.mountPricingTable = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountPricingTable(i, o) : this.premountPricingTableNodes.set(i, o);
    }, this.unmountPricingTable = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountPricingTable(i) : this.premountPricingTableNodes.delete(i);
    }, this.mountAPIKeys = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountAPIKeys(i, o) : this.premountAPIKeysNodes.set(i, o);
    }, this.unmountAPIKeys = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountAPIKeys(i) : this.premountAPIKeysNodes.delete(i);
    }, this.__internal_mountOAuthConsent = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_mountOAuthConsent(i, o) : this.premountOAuthConsentNodes.set(i, o);
    }, this.__internal_unmountOAuthConsent = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_unmountOAuthConsent(i) : this.premountOAuthConsentNodes.delete(i);
    }, this.mountTaskChooseOrganization = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountTaskChooseOrganization(i, o) : this.premountTaskChooseOrganizationNodes.set(i, o);
    }, this.unmountTaskChooseOrganization = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountTaskChooseOrganization(i) : this.premountTaskChooseOrganizationNodes.delete(i);
    }, this.mountTaskResetPassword = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountTaskResetPassword(i, o) : this.premountTaskResetPasswordNodes.set(i, o);
    }, this.unmountTaskResetPassword = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountTaskResetPassword(i) : this.premountTaskResetPasswordNodes.delete(i);
    }, this.addListener = (i) => {
      if (this.clerkjs)
        return this.clerkjs.addListener(i);
      {
        const o = () => {
          var s;
          const a = this.premountAddListenerCalls.get(i);
          a && ((s = a.nativeUnsubscribe) == null || s.call(a), this.premountAddListenerCalls.delete(i));
        };
        return this.premountAddListenerCalls.set(i, { unsubscribe: o, nativeUnsubscribe: void 0 }), o;
      }
    }, this.navigate = (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.navigate(i);
      };
      this.clerkjs && this.loaded ? o() : this.premountMethodCalls.set("navigate", o);
    }, this.redirectWithAuth = async (...i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.redirectWithAuth(...i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("redirectWithAuth", o);
    }, this.redirectToSignIn = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.redirectToSignIn(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("redirectToSignIn", o);
    }, this.redirectToSignUp = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.redirectToSignUp(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("redirectToSignUp", o);
    }, this.redirectToUserProfile = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToUserProfile();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToUserProfile", i);
    }, this.redirectToAfterSignUp = () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToAfterSignUp();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToAfterSignUp", i);
    }, this.redirectToAfterSignIn = () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToAfterSignIn();
      };
      this.clerkjs && this.loaded ? i() : this.premountMethodCalls.set("redirectToAfterSignIn", i);
    }, this.redirectToAfterSignOut = () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToAfterSignOut();
      };
      this.clerkjs && this.loaded ? i() : this.premountMethodCalls.set("redirectToAfterSignOut", i);
    }, this.redirectToOrganizationProfile = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToOrganizationProfile();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToOrganizationProfile", i);
    }, this.redirectToCreateOrganization = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToCreateOrganization();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToCreateOrganization", i);
    }, this.redirectToWaitlist = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToWaitlist();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToWaitlist", i);
    }, this.redirectToTasks = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.redirectToTasks(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("redirectToTasks", o);
    }, this.handleRedirectCallback = async (i) => {
      var o;
      const s = () => {
        var a;
        return (a = this.clerkjs) == null ? void 0 : a.handleRedirectCallback(i);
      };
      this.clerkjs && this.loaded ? (o = s()) == null || o.catch(() => {
      }) : this.premountMethodCalls.set("handleRedirectCallback", s);
    }, this.handleGoogleOneTapCallback = async (i, o) => {
      var s;
      const a = () => {
        var c;
        return (c = this.clerkjs) == null ? void 0 : c.handleGoogleOneTapCallback(i, o);
      };
      this.clerkjs && this.loaded ? (s = a()) == null || s.catch(() => {
      }) : this.premountMethodCalls.set("handleGoogleOneTapCallback", a);
    }, this.handleEmailLinkVerification = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.handleEmailLinkVerification(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("handleEmailLinkVerification", o);
    }, this.authenticateWithMetamask = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithMetamask(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithMetamask", o);
    }, this.authenticateWithCoinbaseWallet = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithCoinbaseWallet(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithCoinbaseWallet", o);
    }, this.authenticateWithBase = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithBase(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithBase", o);
    }, this.authenticateWithOKXWallet = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithOKXWallet(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithOKXWallet", o);
    }, this.authenticateWithSolana = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithSolana(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithSolana", o);
    }, this.authenticateWithWeb3 = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithWeb3(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithWeb3", o);
    }, this.authenticateWithGoogleOneTap = async (i) => (await Qk(this, lm, E0).call(this)).authenticateWithGoogleOneTap(i), this.__internal_loadStripeJs = async () => (await Qk(this, lm, E0).call(this)).__internal_loadStripeJs(), this.createOrganization = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.createOrganization(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("createOrganization", o);
    }, this.getOrganization = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.getOrganization(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("getOrganization", o);
    }, this.joinWaitlist = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.joinWaitlist(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("joinWaitlist", o);
    }, this.signOut = async (...i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.signOut(...i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("signOut", o);
    }, this.__internal_attemptToEnableEnvironmentSetting = (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.__internal_attemptToEnableEnvironmentSetting(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("__internal_attemptToEnableEnvironmentSetting", o);
    };
    const { Clerk: n = null, publishableKey: r } = t || {};
    Cu(this, Xl, r), Cu(this, Cf, t?.proxyUrl), Cu(this, kf, t?.domain), this.options = t, this.Clerk = n, this.mode = vb() ? "browser" : "server", Cu(this, C0, new Xhe(this)), this.options.sdkMetadata || (this.options.sdkMetadata = Jhe), $n(this, Os).emit(Iv.Status, "loading"), $n(this, Os).prioritizedOn(Iv.Status, (i) => Cu(this, k0, i)), $n(this, Xl) && this.loadClerkJS();
  }
  get publishableKey() {
    return $n(this, Xl);
  }
  get loaded() {
    var t;
    return ((t = this.clerkjs) == null ? void 0 : t.loaded) || !1;
  }
  get status() {
    var t;
    return this.clerkjs ? ((t = this.clerkjs) == null ? void 0 : t.status) || /**
    * Support older clerk-js versions.
    * If clerk-js is available but `.status` is missing it we need to fallback to `.loaded`.
    * Since "degraded" an "error" did not exist before,
    * map "loaded" to "ready" and "not loaded" to "loading".
    */
    (this.clerkjs.loaded ? "ready" : "loading") : $n(this, k0);
  }
  static getOrCreateInstance(t) {
    return (!vb() || !$n(this, ec) || t.Clerk && $n(this, ec).Clerk !== t.Clerk || // Allow hot swapping PKs on the client
    $n(this, ec).publishableKey !== t.publishableKey) && Cu(this, ec, new YU(t)), $n(this, ec);
  }
  static clearInstance() {
    Cu(this, ec, null);
  }
  get domain() {
    return typeof window < "u" && window.location ? Kk($n(this, kf), new URL(window.location.href), "") : typeof $n(this, kf) == "function" ? Uu.throw(Gk) : $n(this, kf) || "";
  }
  get proxyUrl() {
    return typeof window < "u" && window.location ? Kk($n(this, Cf), new URL(window.location.href), "") : typeof $n(this, Cf) == "function" ? Uu.throw(Gk) : $n(this, Cf) || "";
  }
  /**
   * Accesses private options from the `Clerk` instance and defaults to
   * `IsomorphicClerk` options when in SSR context.
   *  @internal
   */
  __internal_getOption(t) {
    var n, r;
    return (n = this.clerkjs) != null && n.__internal_getOption ? (r = this.clerkjs) == null ? void 0 : r.__internal_getOption(t) : this.options[t];
  }
  get sdkMetadata() {
    var t;
    return ((t = this.clerkjs) == null ? void 0 : t.sdkMetadata) || this.options.sdkMetadata || void 0;
  }
  get instanceType() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.instanceType;
  }
  get frontendApi() {
    var t;
    return ((t = this.clerkjs) == null ? void 0 : t.frontendApi) || "";
  }
  get isStandardBrowser() {
    var t;
    return ((t = this.clerkjs) == null ? void 0 : t.isStandardBrowser) || this.options.standardBrowser || !1;
  }
  get __internal_queryClient() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.__internal_queryClient;
  }
  get isSatellite() {
    return typeof window < "u" && window.location ? Kk(this.options.isSatellite, new URL(window.location.href), !1) : typeof this.options.isSatellite == "function" ? Uu.throw(Gk) : !1;
  }
  async loadClerkJS() {
    var t;
    if (!(this.mode !== "browser" || this.loaded)) {
      typeof window < "u" && (window.__clerk_publishable_key = $n(this, Xl), window.__clerk_proxy_url = this.proxyUrl, window.__clerk_domain = this.domain);
      try {
        if (this.Clerk) {
          let n;
          phe(this.Clerk) ? (n = new this.Clerk($n(this, Xl), {
            proxyUrl: this.proxyUrl,
            domain: this.domain
          }), this.beforeLoad(n), await n.load(this.options)) : (n = this.Clerk, n.loaded || (this.beforeLoad(n), await n.load(this.options))), global.Clerk = n;
        } else if (!__BUILD_DISABLE_RHC__) {
          if (global.Clerk || await Vhe({
            ...this.options,
            publishableKey: $n(this, Xl),
            proxyUrl: this.proxyUrl,
            domain: this.domain,
            nonce: this.options.nonce
          }), !global.Clerk)
            throw new Error("Failed to download latest ClerkJS. Contact support@clerk.com.");
          this.beforeLoad(global.Clerk), await global.Clerk.load(this.options);
        }
        return (t = global.Clerk) != null && t.loaded ? this.hydrateClerkJS(global.Clerk) : void 0;
      } catch (n) {
        const r = n;
        $n(this, Os).emit(Iv.Status, "error"), console.error(r.stack || r.message || r);
        return;
      }
    }
  }
  get version() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.version;
  }
  get client() {
    if (this.clerkjs)
      return this.clerkjs.client;
  }
  get session() {
    if (this.clerkjs)
      return this.clerkjs.session;
  }
  get user() {
    if (this.clerkjs)
      return this.clerkjs.user;
  }
  get organization() {
    if (this.clerkjs)
      return this.clerkjs.organization;
  }
  get telemetry() {
    if (this.clerkjs)
      return this.clerkjs.telemetry;
  }
  get __unstable__environment() {
    if (this.clerkjs)
      return this.clerkjs.__unstable__environment;
  }
  get isSignedIn() {
    return this.clerkjs ? this.clerkjs.isSignedIn : !1;
  }
  get billing() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.billing;
  }
  get __internal_state() {
    return this.loaded && this.clerkjs ? this.clerkjs.__internal_state : $n(this, C0);
  }
  get apiKeys() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.apiKeys;
  }
  __unstable__setEnvironment(...t) {
    if (this.clerkjs && "__unstable__setEnvironment" in this.clerkjs)
      this.clerkjs.__unstable__setEnvironment(t);
    else
      return;
  }
};
k0 = /* @__PURE__ */ new WeakMap();
kf = /* @__PURE__ */ new WeakMap();
Cf = /* @__PURE__ */ new WeakMap();
Xl = /* @__PURE__ */ new WeakMap();
Os = /* @__PURE__ */ new WeakMap();
C0 = /* @__PURE__ */ new WeakMap();
ec = /* @__PURE__ */ new WeakMap();
lm = /* @__PURE__ */ new WeakSet();
E0 = function() {
  return new Promise((e) => {
    this.addOnLoaded(() => e(this.clerkjs));
  });
};
Yl(Qhe, ec);
Gfe({ packageName: "@clerk/clerk-react" });
Uhe("@clerk/clerk-react");
const epe = ({
  message: e = "Loading...",
  size: t = "md",
  variant: n = "dots"
}) => {
  const r = {
    sm: "h-1 w-1",
    md: "h-2 w-2",
    lg: "h-3 w-3"
  }, i = {
    sm: "gap-1",
    md: "gap-1.5",
    lg: "gap-2"
  }, o = {
    sm: "text-[10px]",
    md: "text-xs",
    lg: "text-sm"
  }, s = () => /* @__PURE__ */ v.jsxs("div", { className: `flex items-center ${i[t]}`, children: [
    /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${r[t]} animate-pulse rounded-full bg-primary`,
        style: { animationDelay: "0ms", animationDuration: "1s" }
      }
    ),
    /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${r[t]} animate-pulse rounded-full bg-primary`,
        style: { animationDelay: "150ms", animationDuration: "1s" }
      }
    ),
    /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${r[t]} animate-pulse rounded-full bg-primary`,
        style: { animationDelay: "300ms", animationDuration: "1s" }
      }
    )
  ] }), a = () => {
    const h = {
      sm: "h-4 w-4",
      md: "h-6 w-6",
      lg: "h-8 w-8"
    };
    return /* @__PURE__ */ v.jsx(
      "div",
      {
        className: `${h[t]} animate-spin rounded-full border-2 border-primary border-t-transparent`
      }
    );
  }, c = () => {
    const h = {
      sm: "h-4 w-4",
      md: "h-6 w-6",
      lg: "h-8 w-8"
    };
    return /* @__PURE__ */ v.jsxs("div", { className: "relative flex items-center justify-center", children: [
      /* @__PURE__ */ v.jsx(
        "span",
        {
          className: `${h[t]} absolute animate-ping rounded-full bg-primary/40`
        }
      ),
      /* @__PURE__ */ v.jsx("span", { className: `${h[t]} relative rounded-full bg-primary` })
    ] });
  }, u = () => {
    const h = {
      sm: "h-3",
      md: "h-4",
      lg: "h-5"
    }, m = {
      sm: "w-0.5",
      md: "w-1",
      lg: "w-1.5"
    };
    return /* @__PURE__ */ v.jsx("div", { className: `flex items-end ${i[t]}`, children: [0, 1, 2, 3].map((g) => /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${m[t]} ${h[t]} animate-pulse rounded-sm bg-primary`,
        style: {
          animationDelay: `${g * 100}ms`,
          animationDuration: "0.8s"
        }
      },
      g
    )) });
  }, f = () => {
    switch (n) {
      case "spinner":
        return a();
      case "pulse":
        return c();
      case "bars":
        return u();
      default:
        return s();
    }
  };
  return /* @__PURE__ */ v.jsxs("div", { className: "inline-flex items-center gap-2", children: [
    f(),
    e && /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${o[t]} tracking-wide text-muted-foreground`,
        children: e
      }
    )
  ] });
}, tpe = (e = /* @__PURE__ */ new Date()) => e.toLocaleTimeString("en-GB", { hour12: !1 }), npe = [
  "",
  "                                                   ",
  "                  24K TWIN EDITOR                  ",
  "                                                   ",
  "         Advanced Development Environment          ",
  "                                                   ",
  "                                                   ",
  "         Initializing System Components...         ",
  "                                                   ",
  ""
], rpe = [
  { lines: ["[SYSTEM] Initializing connection..."], tone: "muted", delay: 500 },
  { lines: ["[SYSTEM] Loading application modules..."], tone: "muted", delay: 850 },
  { lines: npe, tone: "banner", delay: 1200, timestamp: !1 },
  { lines: ["[CORE] Allocating resources..."], tone: "muted", delay: 900 },
  { lines: ["[CORE] Configuring environment..."], tone: "muted", delay: 950 },
  { lines: ["[ENGINE] Starting twin editor engine..."], tone: "normal", delay: 800 },
  { lines: ["[ENGINE] Mounting components..."], tone: "normal", delay: 850 },
  { lines: ["[UI] Rendering interface..."], tone: "normal", delay: 850 },
  { lines: ["[READY] All systems operational"], tone: "accent", delay: 850 },
  {
    lines: ["[STATUS] Twin Editor is ready for development"],
    tone: "accent",
    delay: 1100
  }
], ipe = {
  muted: "text-muted-foreground/60",
  normal: "text-foreground/85",
  accent: "text-primary font-semibold drop-shadow-[0_0_8px_hsl(var(--primary)/0.45)]",
  banner: "text-primary/70 font-semibold"
}, ope = () => {
  const [e, t] = k.useState([]), n = k.useRef(null), r = k.useRef(0);
  return k.useEffect(() => {
    const i = [];
    let o = 0;
    return t([]), rpe.forEach((s) => {
      o += s.delay, i.push(
        window.setTimeout(() => {
          const a = tpe();
          t((c) => {
            const u = [...c];
            return s.tone === "banner" ? (r.current += 1, u.push({
              id: String(r.current),
              message: s.lines.join(`
`),
              timestamp: s.timestamp === !1 ? void 0 : a,
              tone: s.tone ?? "normal"
            }), u) : (s.lines.forEach((f) => {
              r.current += 1, u.push({
                id: String(r.current),
                message: f,
                timestamp: s.timestamp === !1 ? void 0 : a,
                tone: s.tone ?? "normal"
              });
            }), u);
          });
        }, o)
      );
    }), () => {
      i.forEach((s) => window.clearTimeout(s));
    };
  }, []), k.useEffect(() => {
    const i = n.current;
    i && (i.scrollTop = i.scrollHeight);
  }, [e]), /* @__PURE__ */ v.jsxs(
    "section",
    {
      className: "relative w-full text-foreground",
      style: { fontFamily: '"Titillium Web", "Titillium_Web", sans-serif' },
      children: [
        /* @__PURE__ */ v.jsx(
          "div",
          {
            ref: n,
            role: "log",
            "aria-live": "polite",
            className: "no-scrollbar max-w-full overflow-x-auto overflow-y-auto pr-2 font-mono text-[11px] leading-snug text-foreground/80",
            children: e.length ? /* @__PURE__ */ v.jsx("div", { className: "flex flex-col gap-1", children: e.map((i) => /* @__PURE__ */ v.jsxs(
              "div",
              {
                className: "flex items-start gap-2 px-2 py-1 transition-colors hover:bg-primary/10 animate-logEntry",
                children: [
                  i.timestamp ? /* @__PURE__ */ v.jsx("span", { className: "w-[64px] shrink-0 text-primary/60 tabular-nums", children: i.timestamp }) : null,
                  /* @__PURE__ */ v.jsx("span", { className: `whitespace-pre ${ipe[i.tone]}`, children: i.message })
                ]
              },
              i.id
            )) }) : /* @__PURE__ */ v.jsx("div", { className: "text-muted-foreground", children: "Awaiting telemetry..." })
          }
        ),
        /* @__PURE__ */ v.jsx("div", { className: "mt-2 flex items-center gap-2 text-[10px] uppercase tracking-[0.3em] text-muted-foreground/60", children: /* @__PURE__ */ v.jsx(epe, { variant: "bars", size: "sm", message: "Initializing" }) })
      ]
    }
  );
};
function spe({ message: e }) {
  const { user: t } = DU(), {
    data: n,
    isLoading: r,
    isValidating: i
  } = r9(), { myServers: o, featuredServers: s } = k.useMemo(() => {
    if (!n) return { myServers: [], featuredServers: [] };
    const S = (N, P) => N.status === P.status ? 0 : N.status === "authorizing" ? -1 : P.status === "authorizing" ? 1 : 0, _ = n.filter((N) => N.userId === vj(t?.id)).sort(S), M = n.filter((N) => N.userId !== vj(t?.id) && N.visibility === "public").sort(S);
    return { myServers: _, featuredServers: M };
  }, [n]), a = k.useMemo(() => [...hb].sort(() => 0.5 - Math.random()).slice(0, 5), []), [c, u] = k.useState(!1), [f, h] = k.useState(!1), [m, g] = k.useState(!1), b = (S) => {
    const _ = new URLSearchParams();
    _.set("name", S.name), _.set("config", JSON.stringify(S.config)), window.open("/chat-bot/mcp/create?" + _.toString(), "_blank");
  }, x = (S) => {
    h(S), S && g(!1);
  }, w = (S) => {
    g(S), S && h(!1);
  };
  return k.useEffect(() => {
    if (i) {
      u(!1);
      const S = setTimeout(() => u(!0), 500);
      return () => clearTimeout(S);
    }
    u(!1);
  }, [i]), k.useEffect(() => {
    e && cn(/* @__PURE__ */ v.jsx("p", { className: "whitespace-pre-wrap break-all", children: e }), {
      id: "mcp-list-message"
    });
  }, []), /* @__PURE__ */ v.jsx(v.Fragment, { children: /* @__PURE__ */ v.jsx(qT, { className: "h-full w-full z-40 bg-gradient-to-b from-background via-background to-muted/30", children: /* @__PURE__ */ v.jsx("div", { className: "flex-1 relative w-full mx-auto", children: /* @__PURE__ */ v.jsx("div", { className: "w-full mx-auto px-4 sm:px-6 lg:px-8 py-8", children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-8", children: [
    /* @__PURE__ */ v.jsxs("header", { className: "relative z-10 rounded-2xl border border-border/60 bg-gradient-to-br from-card/90 via-card/90 to-muted/40 p-6 sm:p-8 shadow-sm backdrop-blur", children: [
      /* @__PURE__ */ v.jsx("div", { className: "pointer-events-none absolute -top-20 right-0 h-56 w-56 rounded-full bg-primary/10 blur-3xl" }),
      /* @__PURE__ */ v.jsx("div", { className: "pointer-events-none absolute -bottom-24 left-0 h-56 w-56 rounded-full bg-muted/40 blur-3xl" }),
      /* @__PURE__ */ v.jsxs("div", { className: "relative flex flex-col gap-6", children: [
        /* @__PURE__ */ v.jsxs("div", { className: "flex flex-wrap items-center gap-3 text-xs uppercase tracking-wide text-muted-foreground", children: [
          /* @__PURE__ */ v.jsx("span", { className: "rounded-full border border-border/60 bg-muted/50 px-3 py-1 font-semibold", children: "MCP Directory" }),
          /* @__PURE__ */ v.jsxs("span", { className: "rounded-full border border-border/60 bg-muted/50 px-3 py-1 font-semibold", children: [
            o.length + s.length,
            " servers"
          ] }),
          c && i && !r && /* @__PURE__ */ v.jsxs("span", { className: "inline-flex items-center gap-2 rounded-full border border-border/60 bg-muted/50 px-3 py-1 font-semibold", children: [
            "Refreshing",
            /* @__PURE__ */ v.jsx(Zs, { className: "size-3 animate-spin" })
          ] })
        ] }),
        /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col lg:flex-row lg:items-end lg:justify-between gap-6", children: [
          /* @__PURE__ */ v.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ v.jsx("h1", { className: "text-3xl md:text-4xl font-semibold flex items-center gap-3", children: "MCP Servers" }),
            /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground max-w-2xl", children: "Browse your MCP connections, manage visibility, and launch new integrations with confidence." })
          ] }),
          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-wrap items-center gap-2", children: [
            n?.length ? /* @__PURE__ */ v.jsxs(
              ed,
              {
                open: f,
                onOpenChange: x,
                children: [
                  /* @__PURE__ */ v.jsx(td, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
                    Ht,
                    {
                      variant: "outline",
                      className: "gap-2 border-border/60 bg-card/80 shadow-sm transition-all hover:bg-card/90 hover:shadow-md cursor-pointer",
                      children: [
                        /* @__PURE__ */ v.jsx("div", { className: "flex -space-x-2 cursor-pointer", children: a.map((S, _) => {
                          const M = S.icon;
                          return /* @__PURE__ */ v.jsx(
                            "div",
                            {
                              className: "relative rounded-full border border-border/60 bg-muted/60 p-1",
                              style: {
                                zIndex: a.length - _
                              },
                              children: /* @__PURE__ */ v.jsx(M, { className: "size-3" })
                            },
                            S.name
                          );
                        }) }),
                        "Recommended MCPs"
                      ]
                    }
                  ) }),
                  /* @__PURE__ */ v.jsx(nd, { align: "end", className: "w-56 p-2 z-1000 bg-popover text-popover-foreground border-border/60 shadow-lg", children: hb.map((S) => {
                    const _ = S.icon;
                    return /* @__PURE__ */ v.jsxs(
                      ls,
                      {
                        onClick: () => b(S),
                        className: "cursor-pointer flex items-center gap-3 rounded-lg px-3 py-2.5 text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
                        children: [
                          /* @__PURE__ */ v.jsx(_, { className: "size-4" }),
                          /* @__PURE__ */ v.jsx("span", { children: S.label })
                        ]
                      },
                      S.name
                    );
                  }) })
                ]
              }
            ) : null,
            /* @__PURE__ */ v.jsxs(
              Ht,
              {
                className: "gap-2 font-semibold shadow-sm transition-all hover:shadow-md cursor-pointer",
                variant: "default",
                "data-testid": "add-mcp-server-button",
                onClick: () => window.open("/chat-bot/mcp/create", "_blank"),
                children: [
                  /* @__PURE__ */ v.jsx(sh, { className: "fill-foreground size-3.5" }),
                  "Add MCP Server"
                ]
              }
            ),
            /* @__PURE__ */ v.jsxs(
              ed,
              {
                open: m,
                onOpenChange: w,
                children: [
                  /* @__PURE__ */ v.jsx(td, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
                    Ht,
                    {
                      className: "gap-2 font-semibold border-border/60 bg-card/80 shadow-sm transition-all hover:bg-card/90 hover:shadow-md cursor-pointer",
                      variant: "outline",
                      "data-testid": "marketplace-button",
                      children: [
                        /* @__PURE__ */ v.jsx(PY, { className: "size-3.5" }),
                        "Marketplace"
                      ]
                    }
                  ) }),
                  /* @__PURE__ */ v.jsxs(nd, { align: "end", className: "w-56 p-2 z-1000 bg-popover text-popover-foreground border-border/60 shadow-lg", children: [
                    /* @__PURE__ */ v.jsxs(
                      ls,
                      {
                        onClick: () => window.open("https://smithery.ai/", "_blank"),
                        className: "cursor-pointer flex items-center gap-3 rounded-lg px-3 py-2.5 text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
                        children: [
                          /* @__PURE__ */ v.jsx(NY, { className: "size-4 text-primary" }),
                          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
                            /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "Smithery.ai" }),
                            /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "3,700+ servers" })
                          ] })
                        ]
                      }
                    ),
                    /* @__PURE__ */ v.jsxs(
                      ls,
                      {
                        onClick: () => window.open("https://www.pulsemcp.com/servers", "_blank"),
                        className: "cursor-pointer flex items-center gap-3 rounded-lg px-3 py-2.5 text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
                        children: [
                          /* @__PURE__ */ v.jsx(UY, { className: "size-4 text-primary" }),
                          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
                            /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "PulseMCP" }),
                            /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Community servers" })
                          ] })
                        ]
                      }
                    ),
                    /* @__PURE__ */ v.jsxs(
                      ls,
                      {
                        onClick: () => window.open("https://mcpmarket.com/", "_blank"),
                        className: "cursor-pointer flex items-center gap-3 rounded-lg px-3 py-2.5 text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
                        children: [
                          /* @__PURE__ */ v.jsx(AY, { className: "size-4 text-primary" }),
                          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
                            /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "MCP Market" }),
                            /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Server marketplace" })
                          ] })
                        ]
                      }
                    )
                  ] })
                ]
              }
            )
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ v.jsx("main", { className: "space-y-8", children: r ? /* @__PURE__ */ v.jsx("div", { className: "space-y-6", children: /* @__PURE__ */ v.jsx(ope, {}) }) : o?.length || s?.length ? /* @__PURE__ */ v.jsxs(
      "div",
      {
        className: "flex flex-col gap-8",
        "data-testid": "mcp-servers-section",
        children: [
          o?.length > 0 && /* @__PURE__ */ v.jsxs("section", { className: "rounded-2xl border border-border/60 bg-card/80 p-6 shadow-sm", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-4", children: [
              /* @__PURE__ */ v.jsxs("h2", { className: "text-lg font-semibold", children: [
                "My MCP Servers ",
                o.length > 0 ? `(${o.length})` : ""
              ] }),
              /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Private workspace" })
            ] }),
            /* @__PURE__ */ v.jsx(
              "div",
              {
                className: "mt-6 flex flex-col gap-6",
                "data-testid": "my-mcp-servers-section",
                children: o.map((S) => /* @__PURE__ */ v.jsx(Nj, { ...S, user: t }, S.id))
              }
            )
          ] }),
          s?.length > 0 && /* @__PURE__ */ v.jsxs("section", { className: "rounded-2xl border border-border/60 bg-card/80 p-6 shadow-sm", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-4", children: [
              /* @__PURE__ */ v.jsx("h2", { className: "text-lg font-semibold", children: "Featured MCP Servers" }),
              /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Curated by community" })
            ] }),
            /* @__PURE__ */ v.jsx(
              "div",
              {
                className: "mt-6 flex flex-col gap-6",
                "data-testid": "featured-mcp-servers-section",
                children: s.map((S) => /* @__PURE__ */ v.jsx(Nj, { ...S, user: t }, S.id))
              }
            )
          ] })
        ]
      }
    ) : /* @__PURE__ */ v.jsx(Bue, {}) })
  ] }) }) }) }) });
}
const ape = ({
  onClose: e,
  title: t = "Chatbot",
  version: n = "v1",
  setApiKeyByName: r,
  onToggleSidebar: i,
  isSidebarOpen: o = !1
}) => {
  const [s, a] = k.useState(!1), [c, u] = k.useState(!1);
  return /* @__PURE__ */ v.jsxs(Nh, { delayDuration: 150, children: [
    /* @__PURE__ */ v.jsxs("div", { className: "chatbot-drag-handle bg-background h-12 px-4 flex items-center justify-between border-b rounded-t-2xl cursor-grab active:cursor-grabbing", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ v.jsx("div", { className: "h-7 w-7 inline-flex items-center justify-center rounded-lg bg-blue-100 dark:bg-[#1abcfe]/10", children: /* @__PURE__ */ v.jsx(iY, { className: "h-4 w-4 text-blue-500 dark:text-[#1abcfe]" }) }),
        /* @__PURE__ */ v.jsx("h3", { className: "text-base font-semibold leading-none text-neutral-900 dark:text-white", children: t }),
        /* @__PURE__ */ v.jsx(Rh, { variant: "outline", className: "hidden sm:inline-flex border-blue-200 text-blue-500 bg-transparent dark:border-[#1abcfe]/40 dark:text-[#1abcfe]", children: n })
      ] }),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-1", children: [
        i && /* @__PURE__ */ v.jsxs(Gi, { children: [
          /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-blue-500 cursor-pointer",
              onClick: i,
              "aria-label": o ? "Hide chat history" : "Show chat history",
              children: /* @__PURE__ */ v.jsx(eY, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ v.jsx(Bo, { children: o ? "Hide chat history" : "Show chat history" })
        ] }),
        /* @__PURE__ */ v.jsxs(Gi, { children: [
          /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-blue-500 cursor-pointer",
              "aria-label": "Open settings",
              onClick: () => a(!0),
              children: /* @__PURE__ */ v.jsx(L3, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ v.jsx(Bo, { children: "Settings" })
        ] }),
        /* @__PURE__ */ v.jsxs(Gi, { children: [
          /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-foreground cursor-pointer",
              onClick: () => u(!0),
              "aria-label": "MCP Configuration",
              children: /* @__PURE__ */ v.jsx(sh, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ v.jsx(Bo, { children: "MCP Configuration" })
        ] }),
        /* @__PURE__ */ v.jsxs(Gi, { children: [
          /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-foreground cursor-pointer",
              onClick: e,
              "aria-label": "Close",
              children: /* @__PURE__ */ v.jsx(Ng, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ v.jsx(Bo, { children: "Close" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ v.jsx(
      ile,
      {
        open: s,
        onOpenChange: a,
        setApiKeyByName: r
      }
    ),
    /* @__PURE__ */ v.jsx(Oh, { open: c, onOpenChange: u, children: /* @__PURE__ */ v.jsxs(Dh, { className: "w-[90vw]! max-w-[1400px]! max-h-[85vh] overflow-hidden p-0 flex flex-col", children: [
      /* @__PURE__ */ v.jsx(Ug, { className: "px-8 pt-6 pb-4 border-b bg-linear-to-r from-background to-muted/20", children: /* @__PURE__ */ v.jsxs(Ph, { className: "flex items-center gap-3 text-xl font-bold", children: [
        /* @__PURE__ */ v.jsx("div", { className: "p-2 rounded-lg bg-primary/10", children: /* @__PURE__ */ v.jsx(sh, { className: "h-6 w-6 text-primary" }) }),
        "MCP Configuration"
      ] }) }),
      /* @__PURE__ */ v.jsx("div", { className: "overflow-y-auto px-4 flex-1", children: /* @__PURE__ */ v.jsx(spe, {}) })
    ] }) })
  ] });
};
async function ww() {
  throw new Error("Auth token getter not initialized. Call initAuthTokenGetter() first.");
}
async function lpe(e) {
  if (!e) throw new Error("Missing threadId");
  const t = await ww(), n = await fetch(`${Fg}/${e}`, { method: "DELETE", headers: t });
  if (!n.ok) {
    const r = await n.json().catch(() => ({}));
    throw new Error(r?.error || "Server error");
  }
  return await n.json();
}
async function XU() {
  const e = await ww(), t = await fetch(`${Fg}`, { headers: e });
  if (!t.ok) {
    const n = await t.json().catch(() => ({}));
    throw new Error(n?.error || "Server error");
  }
  return await t.json();
}
async function cpe(e, t) {
  if (!e) throw new Error("Missing threadId");
  if (!t || !t.trim()) throw new Error("Title cannot be empty");
  const n = await ww(), r = await fetch(`${Fg}/${e}`, {
    method: "PATCH",
    headers: n,
    body: JSON.stringify({
      title: t.trim()
    })
  });
  if (!r.ok) {
    const i = await r.json().catch(() => ({}));
    throw new Error(i?.error || "Failed to update thread title");
  }
  return await r.json();
}
async function Yj(e, t) {
  if (!e) throw new Error("Missing threadId");
  const n = await ww(), r = new URLSearchParams();
  t?.limit && r.append("limit", t.limit.toString()), t?.cursor && r.append("cursor", t.cursor), t?.direction && r.append("direction", t.direction);
  const i = `${Fg}/${e}/messages${r.toString() ? `?${r.toString()}` : ""}`, o = await fetch(i, { headers: n });
  if (!o.ok) {
    const s = await o.json().catch(() => ({}));
    throw new Error(s?.error || "Failed to fetch messages");
  }
  return await o.json();
}
const Xr = [];
for (let e = 0; e < 256; ++e)
  Xr.push((e + 256).toString(16).slice(1));
function upe(e, t = 0) {
  return (Xr[e[t + 0]] + Xr[e[t + 1]] + Xr[e[t + 2]] + Xr[e[t + 3]] + "-" + Xr[e[t + 4]] + Xr[e[t + 5]] + "-" + Xr[e[t + 6]] + Xr[e[t + 7]] + "-" + Xr[e[t + 8]] + Xr[e[t + 9]] + "-" + Xr[e[t + 10]] + Xr[e[t + 11]] + Xr[e[t + 12]] + Xr[e[t + 13]] + Xr[e[t + 14]] + Xr[e[t + 15]]).toLowerCase();
}
let eC;
const dpe = new Uint8Array(16);
function fpe() {
  if (!eC) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    eC = crypto.getRandomValues.bind(crypto);
  }
  return eC(dpe);
}
const hpe = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Xj = { randomUUID: hpe };
function ppe(e, t, n) {
  e = e || {};
  const r = e.random ?? e.rng?.() ?? fpe();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, upe(r);
}
function JU(e, t, n) {
  return Xj.randomUUID && !e ? Xj.randomUUID() : ppe(e);
}
function mpe() {
  return `temp-${JU()}`;
}
function tg(e) {
  return e.startsWith("temp-");
}
function gpe(e) {
  if (!tg(e))
    throw new Error(`Invalid temporary thread ID: ${e}`);
  return e.substring(5);
}
function ype({ open: e, onConfirm: t, onCancel: n }) {
  return /* @__PURE__ */ v.jsx(Oh, { open: e, onOpenChange: n, children: /* @__PURE__ */ v.jsxs(Dh, { className: "max-w-md", children: [
    /* @__PURE__ */ v.jsxs(Ug, { children: [
      /* @__PURE__ */ v.jsx(Ph, { children: "Delete Conversation" }),
      /* @__PURE__ */ v.jsx("p", { className: "text-xs italic text-muted-foreground mt-1", children: "Are you sure you want to delete this conversation? This action is irreversible and you will not be able to recover the deleted messages." })
    ] }),
    /* @__PURE__ */ v.jsxs(p$, { children: [
      /* @__PURE__ */ v.jsx(Ht, { variant: "outline", onClick: n, type: "button", className: "cursor-pointer", children: "Cancel" }),
      /* @__PURE__ */ v.jsx(Ht, { variant: "destructive", onClick: t, type: "button", className: "cursor-pointer", children: "Delete Conversation" })
    ] })
  ] }) });
}
const QU = ({
  message: e = "Loading..."
}) => /* @__PURE__ */ v.jsx("div", { className: "flex items-center justify-center h-full m-auto p-4", children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col items-center gap-3", children: [
  /* @__PURE__ */ v.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-primary" }),
  /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground", children: e })
] }) }), e8 = ({
  id: e,
  name: t,
  versionId: n,
  classUri: r,
  copyContent: i,
  onIsolate: o,
  onReset: s,
  onCopy: a,
  position: c = "absolute",
  buttonSize: u = "md"
}) => {
  const f = u === "sm" ? "w-3 h-3" : "w-3.5 h-3.5", h = c === "absolute" ? "absolute -top-7 left-0 inline-flex items-center gap-2 bg-popover border rounded-md shadow-lg px-1.5 py-1 z-50 cursor-pointer whitespace-nowrap" : "inline-flex items-center gap-1 ml-1", m = (x) => {
    if (x.preventDefault(), x.stopPropagation(), o)
      o();
    else {
      const w = new CustomEvent("entity-isolate", {
        detail: { id: e, name: t, classUri: r, versionId: n }
      });
      window.dispatchEvent(w), cn.success(`Isolated ${t}`);
    }
  }, g = (x) => {
    if (x.preventDefault(), x.stopPropagation(), s)
      s();
    else {
      const w = new CustomEvent("entity-reset-visibility", {
        detail: { id: e, name: t }
      });
      window.dispatchEvent(w), cn.success("Reset visibility");
    }
  }, b = (x) => {
    if (x.preventDefault(), x.stopPropagation(), a)
      a();
    else {
      const w = i || e;
      navigator.clipboard.writeText(w).then(() => {
        cn.success("Copied");
      }).catch(() => {
        cn.error("Failed to copy");
      });
    }
  };
  return /* @__PURE__ */ v.jsxs("span", { className: h, children: [
    /* @__PURE__ */ v.jsx(
      "button",
      {
        onClick: m,
        onMouseDown: (x) => x.preventDefault(),
        className: "p-0.5 hover:bg-blue-500/20 rounded transition-colors text-foreground",
        title: "Isolate",
        children: /* @__PURE__ */ v.jsx(BT, { className: f })
      }
    ),
    /* @__PURE__ */ v.jsx(
      "button",
      {
        onClick: g,
        onMouseDown: (x) => x.preventDefault(),
        className: "p-0.5 hover:bg-blue-500/20 rounded transition-colors text-foreground",
        title: "Reset visibility",
        children: /* @__PURE__ */ v.jsx(UT, { className: f })
      }
    ),
    /* @__PURE__ */ v.jsx(
      "button",
      {
        onClick: b,
        onMouseDown: (x) => x.preventDefault(),
        className: "p-0.5 hover:bg-blue-500/20 rounded transition-colors text-foreground",
        title: "Copy",
        children: /* @__PURE__ */ v.jsx(kc, { className: f })
      }
    )
  ] });
}, Jj = ({ entity: e, onClick: t, exists: n = !0, onlyText: r = !1 }) => {
  const [i, o] = k.useState(!1), s = () => {
    const h = [
      `Name: ${e.name}`,
      e.id ? `Element ID: ${e.id}` : null,
      e.versionId ? `Version ID: ${e.versionId}` : null,
      e.classUri ? `Class: ${e.classUri}` : null
    ].filter(Boolean).join(`
`);
    navigator.clipboard.writeText(h).then(() => {
      cn.success("Copied entity info");
    }).catch(() => {
      cn.error("Failed to copy");
    });
  }, a = () => {
    if (!n) {
      s();
      return;
    }
    if (!n) return;
    const h = new CustomEvent("entity-zoom-select", {
      detail: { id: e.id, name: e.name, classUri: e.classUri, versionId: e.versionId }
    });
    window.dispatchEvent(h), t && n && t(e);
  }, c = (h) => {
    if (h.preventDefault(), h.stopPropagation(), !e.id || !n) return;
    const m = new CustomEvent("entity-zoom-select", {
      detail: { id: e.id, name: e.name, classUri: e.classUri, versionId: e.versionId }
    });
    window.dispatchEvent(m);
  }, u = () => {
    if (o(!0), !e.id || !n) return;
    const h = new CustomEvent("entity-hover", {
      detail: { id: e.id, name: e.name, classUri: e.classUri, versionId: e.versionId, hover: !0 }
    });
    window.dispatchEvent(h);
  }, f = () => {
    if (o(!1), !e.id || !n) return;
    const h = new CustomEvent("entity-hover", {
      detail: { id: e.id, name: e.name, classUri: e.classUri, versionId: e.versionId, hover: !1 }
    });
    window.dispatchEvent(h);
  };
  return /* @__PURE__ */ v.jsx(Nh, { children: /* @__PURE__ */ v.jsxs(Gi, { delayDuration: 200, children: [
    /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
      "span",
      {
        className: "relative inline-block",
        onMouseEnter: u,
        onMouseLeave: f,
        children: [
          /* @__PURE__ */ v.jsxs(
            Rh,
            {
              variant: "default",
              className: at(
                // base
                "inline-flex items-center gap-1.5 mx-0.5 h-5 transition-all hover:text-green-500",
                //onlyText mode
                r ? at(
                  "bg-transparent border-0 shadow-none p-0 transition-colors cursor-pointer",
                  n ? "text-teal-600  hover:underline underline-offset-2" : "text-gray-400"
                ) : [
                  "cursor-pointer  mt-1 rounded-sm shadow-inner text-md font-medium",
                  n ? "bg-teal-900/90 text-white border-teal-600" : "bg-gray-600/50 text-gray-400 border-gray-500"
                ]
              ),
              onClick: a,
              onDoubleClick: c,
              children: [
                !r && /* @__PURE__ */ v.jsx(dZ, { className: "w-2 h-2 opacity-90 shrink-0" }),
                /* @__PURE__ */ v.jsx("span", { className: at("truncate max-w-40", r && "max-w-none"), children: e.name })
              ]
            }
          ),
          i && e.id && n && /* @__PURE__ */ v.jsx(
            e8,
            {
              id: e.id,
              name: e.name,
              versionId: e.versionId,
              classUri: e.classUri,
              position: "absolute",
              buttonSize: "md",
              onCopy: s
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ v.jsx(Bo, { side: "top", sideOffset: 20, className: "max-w-md bg-popover border shadow-lg", children: /* @__PURE__ */ v.jsxs("div", { className: "space-y-2 text-xs p-1", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-semibold text-muted-foreground min-w-20", children: "Name:" }),
        /* @__PURE__ */ v.jsx("span", { className: "text-foreground", children: e.name })
      ] }),
      e.id && /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-semibold text-muted-foreground min-w-20", children: "Element ID:" }),
        /* @__PURE__ */ v.jsx("code", { className: "bg-muted px-1.5 py-0.5 rounded text-xs font-mono break-all text-green-500", children: e.id })
      ] }),
      e.versionId && /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-semibold text-muted-foreground min-w-20", children: "Version ID:" }),
        /* @__PURE__ */ v.jsx("code", { className: "bg-muted px-1.5 py-0.5 rounded text-xs font-mono break-all", children: e.versionId })
      ] }),
      e.classUri && /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-semibold text-muted-foreground min-w-20", children: "Class:" }),
        /* @__PURE__ */ v.jsx("span", { className: "text-foreground", children: e.classUri })
      ] })
    ] }) })
  ] }) });
}, vpe = ({ uuid: e, onClick: t, exists: n = !0, onlyText: r = !1 }) => {
  const [i, o] = k.useState(!1), s = () => {
    const f = window.getSelection();
    if (f && f.toString().length > 0)
      return;
    if (!n) {
      const m = new CustomEvent("copy-content-by-onclick", {
        detail: { id: e, name: e }
      });
      window.dispatchEvent(m);
      return;
    }
    const h = new CustomEvent("entity-zoom-select", {
      detail: { id: e, name: e }
    });
    window.dispatchEvent(h), t && t(e);
  }, a = (f) => {
    const h = window.getSelection();
    if (h && h.toString().length > 0 || (f.preventDefault(), f.stopPropagation(), !n)) return;
    const m = new CustomEvent("entity-zoom-select", {
      detail: { id: e, name: e }
    });
    window.dispatchEvent(m);
  }, c = () => {
    if (o(!0), !n) return;
    const f = new CustomEvent("entity-hover", {
      detail: { id: e, name: e, hover: !0 }
    });
    window.dispatchEvent(f);
  }, u = () => {
    if (o(!1), !n) return;
    const f = new CustomEvent("entity-hover", {
      detail: { id: e, name: e, hover: !1 }
    });
    window.dispatchEvent(f);
  };
  return /* @__PURE__ */ v.jsx(Nh, { children: /* @__PURE__ */ v.jsxs(Gi, { delayDuration: 200, children: [
    /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
      "span",
      {
        className: "relative inline-block",
        onMouseEnter: c,
        onMouseLeave: u,
        children: [
          /* @__PURE__ */ v.jsxs(
            "span",
            {
              className: at(
                "cursor-pointer inline-flex items-center gap-1 font-mono text-sm select-text rounded-sm transition-colors bg-accent px-1 mt-1",
                n ? "text-blue-600 hover:text-green-500" : "text-gray-400",
                !r && (n ? "underline decoration-dotted underline-offset-2" : "no-underline")
              ),
              onClick: s,
              onDoubleClick: a,
              children: [
                /* @__PURE__ */ v.jsx(VZ, { className: "w-3.5 h-3.5 shrink-0" }),
                /* @__PURE__ */ v.jsx("span", { className: "w-full select-text", children: e })
              ]
            }
          ),
          i && n && /* @__PURE__ */ v.jsx(
            e8,
            {
              id: e,
              name: e,
              copyContent: e
            }
          )
        ]
      }
    ) }),
    n && /* @__PURE__ */ v.jsx(Bo, { side: "top", sideOffset: 20, className: "max-w-md bg-popover border shadow-lg", children: /* @__PURE__ */ v.jsxs("div", { className: "space-y-2 text-xs p-1", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-medium text-muted-foreground min-w-20", children: "UUID:" }),
        /* @__PURE__ */ v.jsx("code", { className: "bg-muted px-1.5 py-0.5 rounded text-xs font-mono break-all", children: /* @__PURE__ */ v.jsx("span", { className: "text-sm text-green-500", children: e }) })
      ] }),
      /* @__PURE__ */ v.jsx("div", { className: "text-muted-foreground text-xs", children: "Double-click to zoom  Hover to highlight" })
    ] }) })
  ] }) });
}, ng = ({ text: e, onEntityClick: t, onlyText: n = !1 }) => {
  const { editorViewerStore: { models: { entities: r } } } = ra(), i = r?.value ?? {}, o = (w) => w in i, s = (w) => {
    const S = Object.values(i).find((_) => _?.name === w);
    return S ? {
      name: S.name,
      id: S.id,
      classUri: S.classUri
    } : null;
  }, a = /\[Name:\s*([^,\]]+?)(?:,\s*Element Id:\s*([^:\]]+?))?(?::\s*VersionId:\s*([^\]]+?))?\]/g, c = /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi, u = Object.values(i).map((w) => w?.name).filter(Boolean), f = (w) => w.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), h = u.sort((w, S) => S.length - w.length), m = [];
  let g;
  for (; (g = a.exec(e)) !== null; ) {
    const w = g[1]?.trim() || "Entity", S = g[2]?.trim() || void 0, _ = g[3]?.trim() || void 0;
    m.push({
      index: g.index,
      length: g[0].length,
      type: "entity",
      data: { name: w, id: S, versionId: _ }
    });
  }
  for (; (g = c.exec(e)) !== null; ) {
    const w = g[0];
    m.some(
      (_) => _.type === "entity" && g.index >= _.index && g.index < _.index + _.length
    ) || m.push({
      index: g.index,
      length: g[0].length,
      type: "uuid",
      data: { name: w, id: w }
    });
  }
  for (const w of h) {
    if (!w || w.length < 3) continue;
    const S = new RegExp(`\\b${f(w)}\\b`, "gi");
    let _;
    for (; (_ = S.exec(e)) !== null; )
      if (!m.some(
        (N) => _.index >= N.index && _.index < N.index + N.length
      )) {
        const N = s(w);
        N && m.push({
          index: _.index,
          length: _[0].length,
          type: "name",
          data: N
        });
      }
  }
  m.sort((w, S) => w.index - S.index);
  const b = [];
  let x = 0;
  for (const w of m)
    w.index > x && b.push(e.slice(x, w.index)), b.push({
      type: w.type,
      entity: w.data
    }), x = w.index + w.length;
  return x < e.length && b.push(e.slice(x)), /* @__PURE__ */ v.jsx(v.Fragment, { children: b.map((w, S) => {
    if (typeof w == "string")
      return /* @__PURE__ */ v.jsx("span", { children: w }, S);
    if (w.type === "name")
      return /* @__PURE__ */ v.jsx(
        Jj,
        {
          entity: w.entity,
          onClick: n ? void 0 : t,
          exists: !0,
          onlyText: n
        },
        S
      );
    if (w.type === "uuid") {
      const M = o(w.entity.id);
      return /* @__PURE__ */ v.jsx(
        vpe,
        {
          uuid: w.entity.id,
          onClick: n ? void 0 : () => t?.(w.entity),
          exists: typeof M == "boolean" ? M : !0,
          onlyText: n
        },
        S
      );
    }
    const _ = w.entity.id ? o(w.entity.id) : !0;
    return /* @__PURE__ */ v.jsx(
      Jj,
      {
        entity: w.entity,
        onClick: n ? void 0 : t,
        exists: typeof _ == "boolean" ? _ : !0,
        onlyText: n
      },
      S
    );
  }) });
}, bpe = ({
  isOpen: e,
  onThreadSelect: t,
  onNewThread: n,
  className: r
}) => {
  const [i, o] = k.useState(!1), [s, a] = k.useState(null), [c, u] = k.useState(!1), [f, h] = k.useState(null), [m, g] = k.useState(null), [b, x] = k.useState(""), [w, S] = k.useState(""), [_, M] = k.useState(
    /* @__PURE__ */ new Set()
  ), [N, P] = k.useState(
    /* @__PURE__ */ new Set()
  ), [I, O] = k.useState(null), L = k.useRef(null), {
    chatbotStore: {
      storeThreads: U,
      isNewThread: B,
      currentThreadId: G,
      threadMessages: Y,
      isLoadingThread: he
    }
  } = ra();
  k.useEffect(() => {
    e && ie();
  }, [e]), k.useEffect(() => {
    const re = U.value.map(
      (be) => String(be?.id ?? "")
    ), J = new Set(re.filter(Boolean)), xe = re.filter(
      (be) => !N.has(be)
    );
    if (xe.length > 0) {
      M(new Set(xe.map(String)));
      const be = setTimeout(() => {
        M(/* @__PURE__ */ new Set());
      }, 400);
      return () => clearTimeout(be);
    }
    (N.size !== J.size || !Array.from(J).every((be) => N.has(be))) && P(J);
  }, [U.value]), k.useEffect(() => {
    m && L.current && setTimeout(() => {
      L.current?.focus();
    }, 0);
  }, [m]);
  const ie = async () => {
    try {
      o(!0);
      const re = await XU(), J = U.value.filter((be) => be.isTemporary);
      let xe = [];
      re.ok ? xe = re.threads : (console.warn("API did not return an array, received:", re), xe = []), U.value = [...J, ...xe];
    } catch {
      U.value = [], cn.error("Failed to load conversation list, please try again later.");
    } finally {
      o(!1);
    }
  }, ne = (re, J) => {
    J.stopPropagation(), h(re), u(!0);
  }, H = async () => {
    if (f)
      try {
        a(f), await new Promise((re) => setTimeout(re, 300)), await lpe(f), U.value = U.value.filter(
          (re) => re.id !== f
        ), G.value === f && (G.value = "", B.value = !0, O(null)), Y.value = { [f]: [] };
      } catch (re) {
        console.error("Failed to delete thread:", re), cn.error("Failed to delete conversation");
      } finally {
        u(!1), a(null), h(null), cn.success("Conversation deleted");
      }
  }, Q = () => {
    u(!1), h(null);
  }, X = () => {
    const re = mpe();
    O(re), n?.(re), t(re);
  }, Se = async (re) => {
    const J = U.value.find((xe) => xe.id === re);
    if (!J || !J.title) {
      cn.error("No title to copy");
      return;
    }
    try {
      await navigator.clipboard.writeText(J.title), cn.success("Title copied to clipboard");
    } catch (xe) {
      console.error("Failed to copy title:", xe), cn.error("Failed to copy title");
    }
  }, W = (re) => {
    const J = U.value.find((xe) => xe.id === re);
    if (J) {
      const xe = J.title || "";
      g(re), x(xe), S(xe);
    }
  }, Z = async (re) => {
    const J = b.trim();
    if (!J) {
      cn.error("Title cannot be empty"), pe();
      return;
    }
    if (J === w.trim()) {
      pe();
      return;
    }
    try {
      await cpe(re, J);
      const xe = U.value.map(
        (be) => be.id === re ? { ...be, title: J } : be
      );
      U.value = xe, g(null), x(""), S(""), cn.success("Conversation renamed successfully");
    } catch (xe) {
      console.error("Failed to rename thread:", xe), cn.error("Failed to rename conversation");
    }
  }, pe = () => {
    g(null), x(""), S("");
  }, F = (re) => {
    const J = new Date(re), xe = /* @__PURE__ */ new Date(), be = new Date(xe.getFullYear(), xe.getMonth(), xe.getDate()), Ae = new Date(
      J.getFullYear(),
      J.getMonth(),
      J.getDate()
    ), tt = new Date(be);
    tt.setDate(tt.getDate() - 1);
    const Ge = be.getTime() - Ae.getTime(), nt = Math.floor(Ge / (1e3 * 60 * 60 * 24));
    return nt === 0 ? "Today" : nt === 1 ? "Yesterday" : nt < 7 ? "Last 7 days" : nt < 30 ? "Last 30 days" : "Older";
  }, ee = (re) => {
    const J = {
      Today: [],
      Yesterday: [],
      "Last 7 days": [],
      "Last 30 days": [],
      Older: []
    };
    return re.forEach((xe) => {
      const be = F(xe.updatedAt);
      J[be].push(xe);
    }), J;
  }, ge = k.useMemo(() => {
    const re = U.value;
    return window.addThreadToSidebar = re, ee(re);
  }, [U.value, B.value, i]);
  return e ? /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
    /* @__PURE__ */ v.jsx(
      ype,
      {
        open: c,
        onConfirm: H,
        onCancel: Q
      }
    ),
    /* @__PURE__ */ v.jsx(Nh, { delayDuration: 50, children: /* @__PURE__ */ v.jsxs(
      "div",
      {
        className: at(
          " h-full flex flex-col bg-background border-r border-border",
          r
        ),
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "w-full p-4 border-b border-border shrink-0", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-2 flex-wrap", children: [
              /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ v.jsx(yD, { className: "h-5 w-5 text-blue-500" }),
                /* @__PURE__ */ v.jsx("h3", { className: "font-semibold text-foreground", children: "Conversations" })
              ] }),
              /* @__PURE__ */ v.jsxs(Gi, { children: [
                /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
                  Ht,
                  {
                    variant: "ghost",
                    size: "icon",
                    className: "h-4 w-4 p-1 text-revert transition-colors hover:bg-blue-100 hover:text-blue-600 dark:hover:bg-blue-950/20 cursor-pointer",
                    onClick: X,
                    disabled: i,
                    "aria-label": "Create new conversation",
                    children: /* @__PURE__ */ v.jsx(pY, { className: "h-4 w-4" })
                  }
                ) }),
                /* @__PURE__ */ v.jsx(Bo, { children: "Create new conversation" })
              ] })
            ] }),
            /* @__PURE__ */ v.jsxs("p", { className: "text-sm text-muted-foreground mt-1", children: [
              U.value.length,
              " saved conversations"
            ] })
          ] }),
          /* @__PURE__ */ v.jsx("div", { className: "flex-1 w-full min-h-0", children: /* @__PURE__ */ v.jsx(qT, { className: "h-full w-full", children: i ? /* @__PURE__ */ v.jsx(QU, { message: "Loading conversations..." }) : U.value.length === 0 ? /* @__PURE__ */ v.jsxs("div", { className: "p-4 text-center text-muted-foreground", children: [
            /* @__PURE__ */ v.jsx(yD, { className: "h-12 w-12 mx-auto mb-2 opacity-50" }),
            /* @__PURE__ */ v.jsx("p", { children: "No conversations yet" }),
            /* @__PURE__ */ v.jsx("p", { className: "text-xs mt-1", children: "Start chatting to create your first conversation" })
          ] }) : /* @__PURE__ */ v.jsx("div", { className: "w-full px-2 py-1 ", children: Object.entries(ge).map(
            ([re, J]) => J.length === 0 ? null : /* @__PURE__ */ v.jsxs("div", { className: "mb-4 w-full ", children: [
              /* @__PURE__ */ v.jsx("h5", { className: "text-xs font-semibold text-muted-foreground px-3 py-2 uppercase tracking-wide", children: re }),
              J.map((xe) => /* @__PURE__ */ v.jsx(
                "div",
                {
                  className: at(
                    "group relative w-full p-2 rounded-lg cursor-pointer transition-all duration-300 ",
                    "hover:bg-blue-50/80 hover:shadow-sm ",
                    "dark:hover:bg-blue-950/30",
                    I === xe.id || G.value === xe.id ? "bg-blue-50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800 shadow-sm" : "border border-transparent",
                    s === xe.id && "animate-slideOutLeft opacity-0 scale-95",
                    _.has(xe.id) && "animate-slideInLeft"
                  ),
                  onClick: () => {
                    O(xe.id), t(xe.id);
                  },
                  children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-start justify-between gap-2 w-full min-w-0", children: [
                    /* @__PURE__ */ v.jsx(
                      "div",
                      {
                        className: "flex-1 min-w-0 overflow-visible p-0",
                        onDoubleClick: (be) => {
                          be.stopPropagation(), he.value || W(xe.id);
                        },
                        children: /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-2 mb-1 w-full ", children: m === xe.id ? /* @__PURE__ */ v.jsx(
                          eM,
                          {
                            ref: L,
                            type: "text",
                            value: b,
                            onChange: (be) => x(be.target.value),
                            onBlur: () => {
                              Z(xe.id);
                            },
                            onKeyDown: (be) => {
                              be.key === "Enter" ? (be.preventDefault(), Z(xe.id)) : be.key === "Escape" && (be.preventDefault(), pe());
                            },
                            onClick: (be) => be.stopPropagation(),
                            className: "h-9 text-sm font-semibold px-2 py-1 border-blue-400 focus:border-blue-500 focus:ring-blue-500 dark:border-blue-600 dark:focus:border-blue-500",
                            autoFocus: !0
                          }
                        ) : (
                          // Thread title
                          /* @__PURE__ */ v.jsx("div", { className: "text-ellipsis text-sm text-foreground break-all cursor-pointer w-full hover:bg-inherit dark:hover:bg-neutral-800/50 rounded transition-colors", children: /* @__PURE__ */ v.jsx(ng, { text: xe.title || "New conversation", onlyText: !0 }) })
                        ) })
                      }
                    ),
                    /* @__PURE__ */ v.jsxs(ed, { children: [
                      /* @__PURE__ */ v.jsx(td, { asChild: !0, children: /* @__PURE__ */ v.jsx(
                        Ht,
                        {
                          variant: "ghost",
                          size: "icon",
                          className: at(
                            "h-6 w-6 shrink-0 opacity-0 group-hover:opacity-100 transition-opacity",
                            "hover:bg-neutral-200 dark:hover:bg-neutral-700"
                          ),
                          onClick: (be) => be.stopPropagation(),
                          children: /* @__PURE__ */ v.jsx(AZ, { className: "h-4 w-4" })
                        }
                      ) }),
                      /* @__PURE__ */ v.jsxs(
                        nd,
                        {
                          align: "end",
                          className: "w-48",
                          children: [
                            /* @__PURE__ */ v.jsxs(
                              ls,
                              {
                                onClick: (be) => {
                                  be.stopPropagation(), Se(xe.id);
                                },
                                className: "cursor-pointer",
                                children: [
                                  /* @__PURE__ */ v.jsx(kc, { className: "h-4 w-4 mr-2" }),
                                  "Copy conversation"
                                ]
                              }
                            ),
                            /* @__PURE__ */ v.jsxs(
                              ls,
                              {
                                onClick: (be) => {
                                  be.stopPropagation(), W(xe.id);
                                },
                                className: "cursor-pointer",
                                children: [
                                  /* @__PURE__ */ v.jsx(OY, { className: "h-4 w-4 mr-2" }),
                                  "Rename"
                                ]
                              }
                            ),
                            /* @__PURE__ */ v.jsxs(
                              ls,
                              {
                                onClick: (be) => {
                                  be.stopPropagation(), ne(xe.id, be);
                                },
                                className: "cursor-pointer text-red-600 focus:text-red-600 dark:text-red-400 dark:focus:text-red-400",
                                disabled: s === xe.id,
                                children: [
                                  /* @__PURE__ */ v.jsx(B3, { className: "h-4 w-4 mr-2" }),
                                  "Delete"
                                ]
                              }
                            )
                          ]
                        }
                      )
                    ] })
                  ] })
                },
                xe.id
              ))
            ] }, re)
          ) }) }) })
        ]
      }
    ) })
  ] }) : null;
}, xpe = (e) => {
  const { setMessages: t } = e, {
    chatbotStore: {
      fetchMessagesForThread: n,
      threadMessages: r,
      setTempThread: i,
      isLoadingThread: o,
      // loadThreadList,
      isNewThread: s,
      currentThreadId: a
    },
    chatbotThreadStore: { threadMentions: c }
  } = ra();
  return {
    handleThreadSelect: async (h) => {
      if (a.value !== h)
        try {
          if (c.value = {}, e.stop?.(), a.value = h, Object.prototype.hasOwnProperty.call(
            r.value,
            h
          )) {
            s.value = tg(h), o.value = !1, t(r.value[h] || []);
            return;
          }
          t([]), o.value = !0, await n(h);
          const g = r.value[h] || [];
          t(g);
        } catch (m) {
          console.error("Failed to select thread:", m), cn.error("Failed to load conversation");
        }
    },
    handleNewThread: (h) => {
      tg(h) && (i(h), c.value = {});
    }
  };
};
class wpe {
  steps = [];
  currentThreadId = null;
  displaySteps = uD([]);
  isEnabled = uD(!0);
  // Control flag to enable/disable logging
  // Store steps history for each message
  messageStepsHistory = /* @__PURE__ */ new Map();
  currentMessageId = null;
  maxMessageHistory = 50;
  startLogging(t, n) {
    this.currentThreadId = t, this.currentMessageId = n || `msg-${Date.now()}`, this.steps = [], this.displaySteps.value = [], this.log("start", { threadId: t, messageId: this.currentMessageId });
  }
  log(t, n) {
    if (!this.isEnabled.value) return;
    if (t === "chunk") {
      this.updateDisplaySteps(t, n);
      return;
    }
    const r = {
      timestamp: Date.now(),
      type: t,
      data: n
    };
    this.steps.push(r), console.log(
      `${{
        start: "",
        planning: "",
        tool_call: "",
        tool_result: "",
        chunk: "",
        finish: "",
        error: ""
      }[t]} [AI Step - ${t.toUpperCase()}]`,
      n
    ), this.updateDisplaySteps(t, n);
  }
  updateDisplaySteps(t, n) {
    const r = [...this.displaySteps.value];
    switch (t) {
      case "start":
        this.displaySteps.value = [{
          id: `step-${Date.now()}`,
          type: "processing",
          message: "Starting AI processing...",
          timestamp: Date.now()
        }];
        break;
      case "planning":
        r.push({
          id: `step-${Date.now()}`,
          type: "processing",
          message: " Planning strategy...",
          details: n.strategy || n.message,
          timestamp: Date.now()
        }), this.displaySteps.value = r;
        break;
      case "tool_call":
        const o = {
          read_file: " Reading file",
          write_file: " Writing file",
          grep_search: " Searching code",
          semantic_search: " Semantic search",
          replace_string_in_file: " Editing file",
          run_in_terminal: " Running command",
          file_search: " Finding files",
          get_errors: " Checking errors",
          list_dir: " Listing directory"
        }[n.toolName] || ` ${n.toolName}`, s = n.args?.filePath || n.args?.query || n.args?.command || (n.args ? Object.keys(n.args).join(", ") : "");
        r.push({
          id: `step-${Date.now()}`,
          type: "tool_call",
          message: o,
          details: s ? String(s).substring(0, 60) : void 0,
          timestamp: Date.now()
        }), this.displaySteps.value = r;
        break;
      case "tool_result":
        for (let c = r.length - 1; c >= 0; c--)
          if (r[c].type === "tool_call") {
            r[c] = {
              ...r[c],
              type: "complete"
            };
            break;
          }
        this.displaySteps.value = r;
        break;
      case "chunk":
        const a = r.findIndex((c) => c.type === "processing");
        a !== -1 && (r[a] = {
          ...r[a],
          message: "Generating response...",
          details: n.content ? n.content.substring(0, 50) + "..." : void 0
        }, this.displaySteps.value = r);
        break;
      case "finish":
        r.push({
          id: `step-${Date.now()}`,
          type: "complete",
          message: "Response completed",
          details: n.usage ? `Tokens: ${n.usage.totalTokens || "N/A"}` : void 0,
          timestamp: Date.now()
        }), this.displaySteps.value = r, this.currentMessageId && (this.messageStepsHistory.set(this.currentMessageId, [...r]), this.pruneMessageHistory()), setTimeout(() => {
          this.displaySteps.value = [];
        }, 3e3);
        break;
      case "error":
        r.push({
          id: `step-${Date.now()}`,
          type: "error",
          message: "Error occurred",
          details: n.message,
          timestamp: Date.now()
        }), this.displaySteps.value = r;
        break;
    }
  }
  getSteps() {
    return this.steps;
  }
  exportSteps() {
    return {
      threadId: this.currentThreadId,
      steps: this.steps,
      duration: this.steps.length > 0 ? this.steps[this.steps.length - 1].timestamp - this.steps[0].timestamp : 0
    };
  }
  clear() {
    this.steps = [], this.currentThreadId = null, this.displaySteps.value = [];
  }
  // Methods to enable/disable the UI logger
  enable() {
    this.isEnabled.value = !0;
  }
  disable() {
    this.isEnabled.value = !1, this.displaySteps.value = [];
  }
  toggle() {
    this.isEnabled.value = !this.isEnabled.value, this.isEnabled.value || (this.displaySteps.value = []);
  }
  // Log planning/strategy step
  logPlanning(t) {
    this.log("planning", { strategy: t });
  }
  // Log with custom message
  logCustomStep(t, n) {
    const r = [...this.displaySteps.value];
    r.push({
      id: `step-${Date.now()}`,
      type: "processing",
      message: t,
      details: n,
      timestamp: Date.now()
    }), this.displaySteps.value = r;
  }
  // Get steps history for a specific message
  getMessageSteps(t) {
    return this.messageStepsHistory.get(t);
  }
  // Get all steps history
  getAllMessageSteps() {
    return this.messageStepsHistory;
  }
  // Format steps as text for display
  formatStepsAsText(t) {
    const n = this.messageStepsHistory.get(t);
    return !n || n.length === 0 ? "" : n.filter((r) => r.type !== "processing").map((r) => `${r.type === "complete" ? "" : r.type === "error" ? "" : ""} ${r.message}${r.details ? ` (${r.details})` : ""}`).join(`
`);
  }
  // Clear specific message history
  clearMessageHistory(t) {
    this.messageStepsHistory.delete(t);
  }
  // Clear all history
  clearAllHistory() {
    this.messageStepsHistory.clear();
  }
  pruneMessageHistory() {
    for (; this.messageStepsHistory.size > this.maxMessageHistory; ) {
      const t = this.messageStepsHistory.keys().next().value;
      if (!t) break;
      this.messageStepsHistory.delete(t);
    }
  }
}
const La = new wpe(), Spe = (e) => {
  let t = !1;
  return {
    onStart: (n) => {
      t = !1, La.startLogging(e, n);
    },
    onToolCall: (n) => {
      t || (La.startLogging(e, n.toolCallId), t = !0), La.log("tool_call", {
        toolCallId: n.toolCallId,
        toolName: n.toolName,
        args: n.args
      });
    },
    onChunk: (n) => {
      !t && n?.delta?.content && (La.startLogging(e), t = !0), n?.delta?.content && La.log("chunk", {
        content: n.delta.content,
        role: n.delta.role
      });
    },
    onFinish: (n) => {
      La.log("finish", {
        messageId: n.id,
        finishReason: n.finishReason,
        usage: n.usage,
        toolCalls: n.toolCalls?.length || 0
      });
      const r = La.exportSteps();
      console.log(" AI Execution Summary:", r), t = !1;
    },
    onError: (n) => {
      La.log("error", {
        message: n.message,
        stack: n.stack
      }), t = !1;
    }
  };
}, kpe = (e, t, n, r) => {
  const i = k.useRef(null), o = k.useRef(null), s = k.useRef(null), a = k.useRef(null), c = k.useCallback((u = !0) => {
    requestAnimationFrame(() => {
      const f = i.current?.querySelector("[data-radix-scroll-area-viewport]");
      f && f.scrollTo({
        top: f.scrollHeight,
        behavior: u ? "smooth" : "auto"
      });
    });
  }, []);
  return k.useEffect(() => {
    if (!n || !r || !s.current) return;
    a.current && a.current.disconnect();
    const u = i.current?.querySelector("[data-radix-scroll-area-viewport]");
    return a.current = new IntersectionObserver(
      (f) => {
        f[0].isIntersecting && n();
      },
      {
        root: u,
        rootMargin: "100px",
        threshold: 0.1
      }
    ), a.current.observe(s.current), () => a.current?.disconnect();
  }, [n, r]), k.useEffect(() => {
    e.length > 0 && !t && c(!1);
  }, [e.length, t, c]), {
    scrollAreaRef: i,
    containerRef: o,
    topSentinelRef: s,
    scrollToBottom: c
  };
};
var _0 = { exports: {} }, Cpe = _0.exports, Qj;
function Epe() {
  return Qj || (Qj = 1, (function(e, t) {
    ((n, r) => {
      e.exports = r();
    })(Cpe, function() {
      var n = function(C, A) {
        return (n = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? function(R, D) {
          R.__proto__ = D;
        } : function(R, D) {
          for (var z in D) Object.prototype.hasOwnProperty.call(D, z) && (R[z] = D[z]);
        }))(C, A);
      }, r = function() {
        return (r = Object.assign || function(C) {
          for (var A, R = 1, D = arguments.length; R < D; R++) for (var z in A = arguments[R]) Object.prototype.hasOwnProperty.call(A, z) && (C[z] = A[z]);
          return C;
        }).apply(this, arguments);
      };
      function i(C, A, R) {
        for (var D, z = 0, $ = A.length; z < $; z++) !D && z in A || ((D = D || Array.prototype.slice.call(A, 0, z))[z] = A[z]);
        return C.concat(D || Array.prototype.slice.call(A));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : _K, s = Object.keys, a = Array.isArray;
      function c(C, A) {
        return typeof A == "object" && s(A).forEach(function(R) {
          C[R] = A[R];
        }), C;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var u = Object.getPrototypeOf, f = {}.hasOwnProperty;
      function h(C, A) {
        return f.call(C, A);
      }
      function m(C, A) {
        typeof A == "function" && (A = A(u(C))), (typeof Reflect > "u" ? s : Reflect.ownKeys)(A).forEach(function(R) {
          b(C, R, A[R]);
        });
      }
      var g = Object.defineProperty;
      function b(C, A, R, D) {
        g(C, A, c(R && h(R, "get") && typeof R.get == "function" ? { get: R.get, set: R.set, configurable: !0 } : { value: R, configurable: !0, writable: !0 }, D));
      }
      function x(C) {
        return { from: function(A) {
          return C.prototype = Object.create(A.prototype), b(C.prototype, "constructor", C), { extend: m.bind(null, C.prototype) };
        } };
      }
      var w = Object.getOwnPropertyDescriptor, S = [].slice;
      function _(C, A, R) {
        return S.call(C, A, R);
      }
      function M(C, A) {
        return A(C);
      }
      function N(C) {
        if (!C) throw new Error("Assertion Failed");
      }
      function P(C) {
        o.setImmediate ? setImmediate(C) : setTimeout(C, 0);
      }
      function I(C, A) {
        if (typeof A == "string" && h(C, A)) return C[A];
        if (!A) return C;
        if (typeof A != "string") {
          for (var R = [], D = 0, z = A.length; D < z; ++D) {
            var $ = I(C, A[D]);
            R.push($);
          }
          return R;
        }
        var q, K = A.indexOf(".");
        return K === -1 || (q = C[A.substr(0, K)]) == null ? void 0 : I(q, A.substr(K + 1));
      }
      function O(C, A, R) {
        if (C && A !== void 0 && !("isFrozen" in Object && Object.isFrozen(C))) if (typeof A != "string" && "length" in A) {
          N(typeof R != "string" && "length" in R);
          for (var D = 0, z = A.length; D < z; ++D) O(C, A[D], R[D]);
        } else {
          var $, q, K = A.indexOf(".");
          K !== -1 ? ($ = A.substr(0, K), (K = A.substr(K + 1)) === "" ? R === void 0 ? a(C) && !isNaN(parseInt($)) ? C.splice($, 1) : delete C[$] : C[$] = R : O(q = (q = C[$]) && h(C, $) ? q : C[$] = {}, K, R)) : R === void 0 ? a(C) && !isNaN(parseInt(A)) ? C.splice(A, 1) : delete C[A] : C[A] = R;
        }
      }
      function L(C) {
        var A, R = {};
        for (A in C) h(C, A) && (R[A] = C[A]);
        return R;
      }
      var U = [].concat;
      function B(C) {
        return U.apply([], C);
      }
      var pe = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(B([8, 16, 32, 64].map(function(C) {
        return ["Int", "Uint", "Float"].map(function(A) {
          return A + C + "Array";
        });
      }))).filter(function(C) {
        return o[C];
      }), G = new Set(pe.map(function(C) {
        return o[C];
      })), Y = null;
      function he(C) {
        return Y = /* @__PURE__ */ new WeakMap(), C = (function A(R) {
          if (!R || typeof R != "object") return R;
          var D = Y.get(R);
          if (D) return D;
          if (a(R)) {
            D = [], Y.set(R, D);
            for (var z = 0, $ = R.length; z < $; ++z) D.push(A(R[z]));
          } else if (G.has(R.constructor)) D = R;
          else {
            var q, K = u(R);
            for (q in D = K === Object.prototype ? {} : Object.create(K), Y.set(R, D), R) h(R, q) && (D[q] = A(R[q]));
          }
          return D;
        })(C), Y = null, C;
      }
      var ie = {}.toString;
      function ne(C) {
        return ie.call(C).slice(8, -1);
      }
      var H = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Q = typeof H == "symbol" ? function(C) {
        var A;
        return C != null && (A = C[H]) && A.apply(C);
      } : function() {
        return null;
      };
      function X(C, A) {
        A = C.indexOf(A), 0 <= A && C.splice(A, 1);
      }
      var Se = {};
      function W(C) {
        var A, R, D, z;
        if (arguments.length === 1) {
          if (a(C)) return C.slice();
          if (this === Se && typeof C == "string") return [C];
          if (z = Q(C)) for (R = []; !(D = z.next()).done; ) R.push(D.value);
          else {
            if (C == null) return [C];
            if (typeof (A = C.length) != "number") return [C];
            for (R = new Array(A); A--; ) R[A] = C[A];
          }
        } else for (A = arguments.length, R = new Array(A); A--; ) R[A] = arguments[A];
        return R;
      }
      var Z = typeof Symbol < "u" ? function(C) {
        return C[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, pe = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], ke = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(pe), F = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function ee(C, A) {
        this.name = C, this.message = A;
      }
      function ge(C, A) {
        return C + ". Errors: " + Object.keys(A).map(function(R) {
          return A[R].toString();
        }).filter(function(R, D, z) {
          return z.indexOf(R) === D;
        }).join(`
`);
      }
      function re(C, A, R, D) {
        this.failures = A, this.failedKeys = D, this.successCount = R, this.message = ge(C, A);
      }
      function J(C, A) {
        this.name = "BulkError", this.failures = Object.keys(A).map(function(R) {
          return A[R];
        }), this.failuresByPos = A, this.message = ge(C, this.failures);
      }
      x(ee).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), x(re).from(ee), x(J).from(ee);
      var xe = ke.reduce(function(C, A) {
        return C[A] = A + "Error", C;
      }, {}), be = ee, Ae = ke.reduce(function(C, A) {
        var R = A + "Error";
        function D(z, $) {
          this.name = R, z ? typeof z == "string" ? (this.message = "".concat(z).concat($ ? `
 ` + $ : ""), this.inner = $ || null) : typeof z == "object" && (this.message = "".concat(z.name, " ").concat(z.message), this.inner = z) : (this.message = F[A] || R, this.inner = null);
        }
        return x(D).from(be), C[A] = D, C;
      }, {}), tt = (Ae.Syntax = SyntaxError, Ae.Type = TypeError, Ae.Range = RangeError, pe.reduce(function(C, A) {
        return C[A + "Error"] = Ae[A], C;
      }, {}));
      pe = ke.reduce(function(C, A) {
        return ["Syntax", "Type", "Range"].indexOf(A) === -1 && (C[A + "Error"] = Ae[A]), C;
      }, {});
      function Ge() {
      }
      function nt(C) {
        return C;
      }
      function _t(C, A) {
        return C == null || C === nt ? A : function(R) {
          return A(C(R));
        };
      }
      function yn(C, A) {
        return function() {
          C.apply(this, arguments), A.apply(this, arguments);
        };
      }
      function St(C, A) {
        return C === Ge ? A : function() {
          var R = C.apply(this, arguments), D = (R !== void 0 && (arguments[0] = R), this.onsuccess), z = this.onerror, $ = (this.onsuccess = null, this.onerror = null, A.apply(this, arguments));
          return D && (this.onsuccess = this.onsuccess ? yn(D, this.onsuccess) : D), z && (this.onerror = this.onerror ? yn(z, this.onerror) : z), $ !== void 0 ? $ : R;
        };
      }
      function Vt(C, A) {
        return C === Ge ? A : function() {
          C.apply(this, arguments);
          var R = this.onsuccess, D = this.onerror;
          this.onsuccess = this.onerror = null, A.apply(this, arguments), R && (this.onsuccess = this.onsuccess ? yn(R, this.onsuccess) : R), D && (this.onerror = this.onerror ? yn(D, this.onerror) : D);
        };
      }
      function xt(C, A) {
        return C === Ge ? A : function(z) {
          var D = C.apply(this, arguments), z = (c(z, D), this.onsuccess), $ = this.onerror, q = (this.onsuccess = null, this.onerror = null, A.apply(this, arguments));
          return z && (this.onsuccess = this.onsuccess ? yn(z, this.onsuccess) : z), $ && (this.onerror = this.onerror ? yn($, this.onerror) : $), D === void 0 ? q === void 0 ? void 0 : q : c(D, q);
        };
      }
      function Kt(C, A) {
        return C === Ge ? A : function() {
          return A.apply(this, arguments) !== !1 && C.apply(this, arguments);
        };
      }
      function An(C, A) {
        return C === Ge ? A : function() {
          var R = C.apply(this, arguments);
          if (R && typeof R.then == "function") {
            for (var D = this, z = arguments.length, $ = new Array(z); z--; ) $[z] = arguments[z];
            return R.then(function() {
              return A.apply(D, $);
            });
          }
          return A.apply(this, arguments);
        };
      }
      pe.ModifyError = re, pe.DexieError = ee, pe.BulkError = J;
      var Nt = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function sn(C) {
        Nt = C;
      }
      var Pn = {}, Mn = 100, mt = typeof Promise > "u" ? [] : (ke = Promise.resolve(), typeof crypto < "u" && crypto.subtle ? [mt = crypto.subtle.digest("SHA-512", new Uint8Array([0])), u(mt), ke] : [ke, u(ke), ke]), ke = mt[0], ga = mt[1], ga = ga && ga.then, Pe = ke && ke.constructor, He = !!mt[2], et = function(C, A) {
        Ii.push([C, A]), Ct && (queueMicrotask(ay), Ct = !1);
      }, bt = !0, Ct = !0, fn = [], Lt = [], nn = nt, jn = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Ge, pgp: !1, env: {}, finalize: Ge }, Ve = jn, Ii = [], Ar = 0, vd = [];
      function Ke(C) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var A = this._PSD = Ve;
        if (typeof C != "function") {
          if (C !== Pn) throw new TypeError("Not a function");
          this._state = arguments[1], this._value = arguments[2], this._state === !1 && Ko(this, this._value);
        } else this._state = null, this._value = null, ++A.ref, (function R(D, z) {
          try {
            z(function($) {
              if (D._state === null) {
                if ($ === D) throw new TypeError("A promise cannot be resolved with itself.");
                var q = D._lib && ys();
                $ && typeof $.then == "function" ? R(D, function(K, se) {
                  $ instanceof Ke ? $._then(K, se) : $.then(K, se);
                }) : (D._state = !0, D._value = $, Gc(D)), q && yo();
              }
            }, Ko.bind(null, D));
          } catch ($) {
            Ko(D, $);
          }
        })(this, C);
      }
      var al = { get: function() {
        var C = Ve, A = Yc;
        function R(D, z) {
          var $ = this, q = !C.global && (C !== Ve || A !== Yc), K = q && !wi(), se = new Ke(function(ye, ae) {
            oa($, new qc(bd(D, C, q, K), bd(z, C, q, K), ye, ae, C));
          });
          return this._consoleTask && (se._consoleTask = this._consoleTask), se;
        }
        return R.prototype = Pn, R;
      }, set: function(C) {
        b(this, "then", C && C.prototype === Pn ? al : { get: function() {
          return C;
        }, set: al.set });
      } };
      function qc(C, A, R, D, z) {
        this.onFulfilled = typeof C == "function" ? C : null, this.onRejected = typeof A == "function" ? A : null, this.resolve = R, this.reject = D, this.psd = z;
      }
      function Ko(C, A) {
        var R, D;
        Lt.push(A), C._state === null && (R = C._lib && ys(), A = nn(A), C._state = !1, C._value = A, D = C, fn.some(function(z) {
          return z._value === D._value;
        }) || fn.push(D), Gc(C), R) && yo();
      }
      function Gc(C) {
        var A = C._listeners;
        C._listeners = [];
        for (var R = 0, D = A.length; R < D; ++R) oa(C, A[R]);
        var z = C._PSD;
        --z.ref || z.finalize(), Ar === 0 && (++Ar, et(function() {
          --Ar == 0 && Vh();
        }, []));
      }
      function oa(C, A) {
        if (C._state === null) C._listeners.push(A);
        else {
          var R = C._state ? A.onFulfilled : A.onRejected;
          if (R === null) return (C._state ? A.resolve : A.reject)(C._value);
          ++A.psd.ref, ++Ar, et(a1, [R, C, A]);
        }
      }
      function a1(C, A, R) {
        try {
          var D, z = A._value;
          !A._state && Lt.length && (Lt = []), D = Nt && A._consoleTask ? A._consoleTask.run(function() {
            return C(z);
          }) : C(z), A._state || Lt.indexOf(z) !== -1 || (($) => {
            for (var q = fn.length; q; ) if (fn[--q]._value === $._value) return fn.splice(q, 1);
          })(A), R.resolve(D);
        } catch ($) {
          R.reject($);
        } finally {
          --Ar == 0 && Vh(), --R.psd.ref || R.psd.finalize();
        }
      }
      function ay() {
        Xi(jn, function() {
          ys() && yo();
        });
      }
      function ys() {
        var C = bt;
        return Ct = bt = !1, C;
      }
      function yo() {
        var C, A, R;
        do
          for (; 0 < Ii.length; ) for (C = Ii, Ii = [], R = C.length, A = 0; A < R; ++A) {
            var D = C[A];
            D[0].apply(null, D[1]);
          }
        while (0 < Ii.length);
        Ct = bt = !0;
      }
      function Vh() {
        for (var C = fn, A = (fn = [], C.forEach(function(D) {
          D._PSD.onunhandled.call(null, D._value, D);
        }), vd.slice(0)), R = A.length; R; ) A[--R]();
      }
      function Kc(C) {
        return new Ke(Pn, !1, C);
      }
      function kn(C, A) {
        var R = Ve;
        return function() {
          var D = ys(), z = Ve;
          try {
            return bs(R, !0), C.apply(this, arguments);
          } catch ($) {
            A && A($);
          } finally {
            bs(z, !1), D && yo();
          }
        };
      }
      m(Ke.prototype, { then: al, _then: function(C, A) {
        oa(this, new qc(null, null, C, A, Ve));
      }, catch: function(C) {
        var A, R;
        return arguments.length === 1 ? this.then(null, C) : (A = C, R = arguments[1], typeof A == "function" ? this.then(null, function(D) {
          return (D instanceof A ? R : Kc)(D);
        }) : this.then(null, function(D) {
          return (D && D.name === A ? R : Kc)(D);
        }));
      }, finally: function(C) {
        return this.then(function(A) {
          return Ke.resolve(C()).then(function() {
            return A;
          });
        }, function(A) {
          return Ke.resolve(C()).then(function() {
            return Kc(A);
          });
        });
      }, timeout: function(C, A) {
        var R = this;
        return C < 1 / 0 ? new Ke(function(D, z) {
          var $ = setTimeout(function() {
            return z(new Ae.Timeout(A));
          }, C);
          R.then(D, z).finally(clearTimeout.bind(null, $));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && b(Ke.prototype, Symbol.toStringTag, "Dexie.Promise"), jn.env = Wh(), m(Ke, { all: function() {
        var C = W.apply(null, arguments).map(cl);
        return new Ke(function(A, R) {
          C.length === 0 && A([]);
          var D = C.length;
          C.forEach(function(z, $) {
            return Ke.resolve(z).then(function(q) {
              C[$] = q, --D || A(C);
            }, R);
          });
        });
      }, resolve: function(C) {
        return C instanceof Ke ? C : C && typeof C.then == "function" ? new Ke(function(A, R) {
          C.then(A, R);
        }) : new Ke(Pn, !0, C);
      }, reject: Kc, race: function() {
        var C = W.apply(null, arguments).map(cl);
        return new Ke(function(A, R) {
          C.map(function(D) {
            return Ke.resolve(D).then(A, R);
          });
        });
      }, PSD: { get: function() {
        return Ve;
      }, set: function(C) {
        return Ve = C;
      } }, totalEchoes: { get: function() {
        return Yc;
      } }, newPSD: Nn, usePSD: Xi, scheduler: { get: function() {
        return et;
      }, set: function(C) {
        et = C;
      } }, rejectionMapper: { get: function() {
        return nn;
      }, set: function(C) {
        nn = C;
      } }, follow: function(C, A) {
        return new Ke(function(R, D) {
          return Nn(function(z, $) {
            var q = Ve;
            q.unhandleds = [], q.onunhandled = $, q.finalize = yn(function() {
              var K, se = this;
              K = function() {
                se.unhandleds.length === 0 ? z() : $(se.unhandleds[0]);
              }, vd.push(function ye() {
                K(), vd.splice(vd.indexOf(ye), 1);
              }), ++Ar, et(function() {
                --Ar == 0 && Vh();
              }, []);
            }, q.finalize), C();
          }, A, R, D);
        });
      } }), Pe && (Pe.allSettled && b(Ke, "allSettled", function() {
        var C = W.apply(null, arguments).map(cl);
        return new Ke(function(A) {
          C.length === 0 && A([]);
          var R = C.length, D = new Array(R);
          C.forEach(function(z, $) {
            return Ke.resolve(z).then(function(q) {
              return D[$] = { status: "fulfilled", value: q };
            }, function(q) {
              return D[$] = { status: "rejected", reason: q };
            }).then(function() {
              return --R || A(D);
            });
          });
        });
      }), Pe.any && typeof AggregateError < "u" && b(Ke, "any", function() {
        var C = W.apply(null, arguments).map(cl);
        return new Ke(function(A, R) {
          C.length === 0 && R(new AggregateError([]));
          var D = C.length, z = new Array(D);
          C.forEach(function($, q) {
            return Ke.resolve($).then(function(K) {
              return A(K);
            }, function(K) {
              z[q] = K, --D || R(new AggregateError(z));
            });
          });
        });
      }), Pe.withResolvers) && (Ke.withResolvers = Pe.withResolvers);
      var sr = { awaits: 0, echoes: 0, id: 0 }, Hh = 0, ll = [], Zc = 0, Yc = 0, vs = 0;
      function Nn(C, q, R, D) {
        var z = Ve, $ = Object.create(z), q = ($.parent = z, $.ref = 0, $.global = !1, $.id = ++vs, jn.env, $.env = He ? { Promise: Ke, PromiseProp: { value: Ke, configurable: !0, writable: !0 }, all: Ke.all, race: Ke.race, allSettled: Ke.allSettled, any: Ke.any, resolve: Ke.resolve, reject: Ke.reject } : {}, q && c($, q), ++z.ref, $.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, Xi($, C, R, D));
        return $.ref === 0 && $.finalize(), q;
      }
      function ar() {
        return sr.id || (sr.id = ++Hh), ++sr.awaits, sr.echoes += Mn, sr.id;
      }
      function wi() {
        return !!sr.awaits && (--sr.awaits == 0 && (sr.id = 0), sr.echoes = sr.awaits * Mn, !0);
      }
      function cl(C) {
        return sr.echoes && C && C.constructor === Pe ? (ar(), C.then(function(A) {
          return wi(), A;
        }, function(A) {
          return wi(), vn(A);
        })) : C;
      }
      function l1() {
        var C = ll[ll.length - 1];
        ll.pop(), bs(C, !1);
      }
      function bs(C, A) {
        var R, D, z = Ve;
        (A ? !sr.echoes || Zc++ && C === Ve : !Zc || --Zc && C === Ve) || queueMicrotask(A ? (function($) {
          ++Yc, sr.echoes && --sr.echoes != 0 || (sr.echoes = sr.awaits = sr.id = 0), ll.push(Ve), bs($, !0);
        }).bind(null, C) : l1), C !== Ve && (Ve = C, z === jn && (jn.env = Wh()), He) && (R = jn.env.Promise, D = C.env, z.global || C.global) && (Object.defineProperty(o, "Promise", D.PromiseProp), R.all = D.all, R.race = D.race, R.resolve = D.resolve, R.reject = D.reject, D.allSettled && (R.allSettled = D.allSettled), D.any) && (R.any = D.any);
      }
      function Wh() {
        var C = o.Promise;
        return He ? { Promise: C, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: C.all, race: C.race, allSettled: C.allSettled, any: C.any, resolve: C.resolve, reject: C.reject } : {};
      }
      function Xi(C, A, R, D, z) {
        var $ = Ve;
        try {
          return bs(C, !0), A(R, D, z);
        } finally {
          bs($, !1);
        }
      }
      function bd(C, A, R, D) {
        return typeof C != "function" ? C : function() {
          var z = Ve;
          R && ar(), bs(A, !0);
          try {
            return C.apply(this, arguments);
          } finally {
            bs(z, !1), D && queueMicrotask(wi);
          }
        };
      }
      function xs(C) {
        Promise === Pe && sr.echoes === 0 ? Zc === 0 ? C() : enqueueNativeMicroTask(C) : setTimeout(C, 0);
      }
      ("" + ga).indexOf("[native code]") === -1 && (ar = wi = Ge);
      var vn = Ke.reject, Ji = "", si = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", lr = "String expected.", sa = [], Xc = "__dbnames", Zo = "readonly", ws = "readwrite";
      function aa(C, A) {
        return C ? A ? function() {
          return C.apply(this, arguments) && A.apply(this, arguments);
        } : C : A;
      }
      var qh = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Jc(C) {
        return typeof C != "string" || /\./.test(C) ? function(A) {
          return A;
        } : function(A) {
          return A[C] === void 0 && C in A && delete (A = he(A))[C], A;
        };
      }
      function ly() {
        throw Ae.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Pt(C, A) {
        try {
          var R = Qc(C), D = Qc(A);
          if (R !== D) return R === "Array" ? 1 : D === "Array" ? -1 : R === "binary" ? 1 : D === "binary" ? -1 : R === "string" ? 1 : D === "string" ? -1 : R === "Date" ? 1 : D !== "Date" ? NaN : -1;
          switch (R) {
            case "number":
            case "Date":
            case "string":
              return A < C ? 1 : C < A ? -1 : 0;
            case "binary":
              for (var z = vo(C), $ = vo(A), q = z.length, K = $.length, se = q < K ? q : K, ye = 0; ye < se; ++ye) if (z[ye] !== $[ye]) return z[ye] < $[ye] ? -1 : 1;
              return q === K ? 0 : q < K ? -1 : 1;
            case "Array":
              for (var ae = C, oe = A, ue = ae.length, fe = oe.length, le = ue < fe ? ue : fe, ce = 0; ce < le; ++ce) {
                var we = Pt(ae[ce], oe[ce]);
                if (we !== 0) return we;
              }
              return ue === fe ? 0 : ue < fe ? -1 : 1;
          }
        } catch {
        }
        return NaN;
      }
      function Qc(C) {
        var A = typeof C;
        return A == "object" && (ArrayBuffer.isView(C) || (A = ne(C)) === "ArrayBuffer") ? "binary" : A;
      }
      function vo(C) {
        return C instanceof Uint8Array ? C : ArrayBuffer.isView(C) ? new Uint8Array(C.buffer, C.byteOffset, C.byteLength) : new Uint8Array(C);
      }
      function qr(C, A, R) {
        var D = C.schema.yProps;
        return D ? (A && 0 < R.numFailures && (A = A.filter(function(z, $) {
          return !R.failures[$];
        })), Promise.all(D.map(function(z) {
          return z = z.updatesTable, A ? C.db.table(z).where("k").anyOf(A).delete() : C.db.table(z).clear();
        })).then(function() {
          return R;
        })) : R;
      }
      cy.prototype.execute = function(C) {
        var A = this["@@propmod"];
        if (A.add !== void 0) {
          var R = A.add;
          if (a(R)) return i(i([], a(C) ? C : [], !0), R).sort();
          if (typeof R == "number") return (Number(C) || 0) + R;
          if (typeof R == "bigint") try {
            return BigInt(C) + R;
          } catch {
            return BigInt(0) + R;
          }
          throw new TypeError("Invalid term ".concat(R));
        }
        if (A.remove !== void 0) {
          var D = A.remove;
          if (a(D)) return a(C) ? C.filter(function(z) {
            return !D.includes(z);
          }).sort() : [];
          if (typeof D == "number") return Number(C) - D;
          if (typeof D == "bigint") try {
            return BigInt(C) - D;
          } catch {
            return BigInt(0) - D;
          }
          throw new TypeError("Invalid subtrahend ".concat(D));
        }
        return R = (R = A.replacePrefix) == null ? void 0 : R[0], R && typeof C == "string" && C.startsWith(R) ? A.replacePrefix[1] + C.substring(R.length) : C;
      };
      var ul = cy;
      function cy(C) {
        this["@@propmod"] = C;
      }
      function xd(C, A) {
        for (var R = s(A), D = R.length, z = !1, $ = 0; $ < D; ++$) {
          var q = R[$], K = A[q], se = I(C, q);
          K instanceof ul ? (O(C, q, K.execute(se)), z = !0) : se !== K && (O(C, q, K), z = !0);
        }
        return z;
      }
      an.prototype._trans = function(C, A, R) {
        var D = this._tx || Ve.trans, z = this.name, $ = Nt && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(C === "readonly" ? "read" : "write", " ").concat(this.name));
        function q(ye, ae, oe) {
          if (oe.schema[z]) return A(oe.idbtrans, oe);
          throw new Ae.NotFound("Table " + z + " not part of transaction");
        }
        var K = ys();
        try {
          var se = D && D.db._novip === this.db._novip ? D === Ve.trans ? D._promise(C, q, R) : Nn(function() {
            return D._promise(C, q, R);
          }, { trans: D, transless: Ve.transless || Ve }) : (function ye(ae, oe, ue, fe) {
            if (ae.idbdb && (ae._state.openComplete || Ve.letThrough || ae._vip)) {
              var le = ae._createTransaction(oe, ue, ae._dbSchema);
              try {
                le.create(), ae._state.PR1398_maxLoop = 3;
              } catch (ce) {
                return ce.name === xe.InvalidState && ae.isOpen() && 0 < --ae._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), ae.close({ disableAutoOpen: !1 }), ae.open().then(function() {
                  return ye(ae, oe, ue, fe);
                })) : vn(ce);
              }
              return le._promise(oe, function(ce, we) {
                return Nn(function() {
                  return Ve.trans = le, fe(ce, we, le);
                });
              }).then(function(ce) {
                if (oe === "readwrite") try {
                  le.idbtrans.commit();
                } catch {
                }
                return oe === "readonly" ? ce : le._completion.then(function() {
                  return ce;
                });
              });
            }
            if (ae._state.openComplete) return vn(new Ae.DatabaseClosed(ae._state.dbOpenError));
            if (!ae._state.isBeingOpened) {
              if (!ae._state.autoOpen) return vn(new Ae.DatabaseClosed());
              ae.open().catch(Ge);
            }
            return ae._state.dbReadyPromise.then(function() {
              return ye(ae, oe, ue, fe);
            });
          })(this.db, C, [this.name], q);
          return $ && (se._consoleTask = $, se = se.catch(function(ye) {
            return console.trace(ye), vn(ye);
          })), se;
        } finally {
          K && yo();
        }
      }, an.prototype.get = function(C, A) {
        var R = this;
        return C && C.constructor === Object ? this.where(C).first(A) : C == null ? vn(new Ae.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(D) {
          return R.core.get({ trans: D, key: C }).then(function(z) {
            return R.hook.reading.fire(z);
          });
        }).then(A);
      }, an.prototype.where = function(C) {
        if (typeof C == "string") return new this.db.WhereClause(this, C);
        if (a(C)) return new this.db.WhereClause(this, "[".concat(C.join("+"), "]"));
        var A = s(C);
        if (A.length === 1) return this.where(A[0]).equals(C[A[0]]);
        var R = this.schema.indexes.concat(this.schema.primKey).filter(function(K) {
          if (K.compound && A.every(function(ye) {
            return 0 <= K.keyPath.indexOf(ye);
          })) {
            for (var se = 0; se < A.length; ++se) if (A.indexOf(K.keyPath[se]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(K, se) {
          return K.keyPath.length - se.keyPath.length;
        })[0];
        if (R && this.db._maxKey !== Ji) return q = R.keyPath.slice(0, A.length), this.where(q).equals(q.map(function(K) {
          return C[K];
        }));
        !R && Nt && console.warn("The query ".concat(JSON.stringify(C), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(A.join("+"), "]"));
        var D = this.schema.idxByName;
        function z(K, se) {
          return Pt(K, se) === 0;
        }
        var q = A.reduce(function(ae, se) {
          var ye = ae[0], ae = ae[1], oe = D[se], ue = C[se];
          return [ye || oe, ye || !oe ? aa(ae, oe && oe.multi ? function(fe) {
            return fe = I(fe, se), a(fe) && fe.some(function(le) {
              return z(ue, le);
            });
          } : function(fe) {
            return z(ue, I(fe, se));
          }) : ae];
        }, [null, null]), $ = q[0], q = q[1];
        return $ ? this.where($.name).equals(C[$.keyPath]).filter(q) : R ? this.filter(q) : this.where(A).equals("");
      }, an.prototype.filter = function(C) {
        return this.toCollection().and(C);
      }, an.prototype.count = function(C) {
        return this.toCollection().count(C);
      }, an.prototype.offset = function(C) {
        return this.toCollection().offset(C);
      }, an.prototype.limit = function(C) {
        return this.toCollection().limit(C);
      }, an.prototype.each = function(C) {
        return this.toCollection().each(C);
      }, an.prototype.toArray = function(C) {
        return this.toCollection().toArray(C);
      }, an.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, an.prototype.orderBy = function(C) {
        return new this.db.Collection(new this.db.WhereClause(this, a(C) ? "[".concat(C.join("+"), "]") : C));
      }, an.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, an.prototype.mapToClass = function(C) {
        for (var A = this.db, R = this.name, D = ((this.schema.mappedClass = C).prototype instanceof ly && (C = ((q) => {
          var K = ae, se = q;
          if (typeof se != "function" && se !== null) throw new TypeError("Class extends value " + String(se) + " is not a constructor or null");
          function ye() {
            this.constructor = K;
          }
          function ae() {
            return q !== null && q.apply(this, arguments) || this;
          }
          return n(K, se), K.prototype = se === null ? Object.create(se) : (ye.prototype = se.prototype, new ye()), Object.defineProperty(ae.prototype, "db", { get: function() {
            return A;
          }, enumerable: !1, configurable: !0 }), ae.prototype.table = function() {
            return R;
          }, ae;
        })(C)), /* @__PURE__ */ new Set()), z = C.prototype; z; z = u(z)) Object.getOwnPropertyNames(z).forEach(function(q) {
          return D.add(q);
        });
        function $(q) {
          if (!q) return q;
          var K, se = Object.create(C.prototype);
          for (K in q) if (!D.has(K)) try {
            se[K] = q[K];
          } catch {
          }
          return se;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = $, this.hook("reading", $), C;
      }, an.prototype.defineClass = function() {
        return this.mapToClass(function(C) {
          c(this, C);
        });
      }, an.prototype.add = function(C, A) {
        var R = this, D = this.schema.primKey, z = D.auto, $ = D.keyPath, q = C;
        return $ && z && (q = Jc($)(C)), this._trans("readwrite", function(K) {
          return R.core.mutate({ trans: K, type: "add", keys: A != null ? [A] : null, values: [q] });
        }).then(function(K) {
          return K.numFailures ? Ke.reject(K.failures[0]) : K.lastResult;
        }).then(function(K) {
          if ($) try {
            O(C, $, K);
          } catch {
          }
          return K;
        });
      }, an.prototype.upsert = function(C, A) {
        var R = this, D = this.schema.primKey.keyPath;
        return this._trans("readwrite", function(z) {
          return R.core.get({ trans: z, key: C }).then(function($) {
            var q = $ ?? {};
            return xd(q, A), D && O(q, D, C), R.core.mutate({ trans: z, type: "put", values: [q], keys: [C], upsert: !0, updates: { keys: [C], changeSpecs: [A] } }).then(function(K) {
              return K.numFailures ? Ke.reject(K.failures[0]) : !!$;
            });
          });
        });
      }, an.prototype.update = function(C, A) {
        return typeof C != "object" || a(C) ? this.where(":id").equals(C).modify(A) : (C = I(C, this.schema.primKey.keyPath)) === void 0 ? vn(new Ae.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(C).modify(A);
      }, an.prototype.put = function(C, A) {
        var R = this, D = this.schema.primKey, z = D.auto, $ = D.keyPath, q = C;
        return $ && z && (q = Jc($)(C)), this._trans("readwrite", function(K) {
          return R.core.mutate({ trans: K, type: "put", values: [q], keys: A != null ? [A] : null });
        }).then(function(K) {
          return K.numFailures ? Ke.reject(K.failures[0]) : K.lastResult;
        }).then(function(K) {
          if ($) try {
            O(C, $, K);
          } catch {
          }
          return K;
        });
      }, an.prototype.delete = function(C) {
        var A = this;
        return this._trans("readwrite", function(R) {
          return A.core.mutate({ trans: R, type: "delete", keys: [C] }).then(function(D) {
            return qr(A, [C], D);
          }).then(function(D) {
            return D.numFailures ? Ke.reject(D.failures[0]) : void 0;
          });
        });
      }, an.prototype.clear = function() {
        var C = this;
        return this._trans("readwrite", function(A) {
          return C.core.mutate({ trans: A, type: "deleteRange", range: qh }).then(function(R) {
            return qr(C, null, R);
          });
        }).then(function(A) {
          return A.numFailures ? Ke.reject(A.failures[0]) : void 0;
        });
      }, an.prototype.bulkGet = function(C) {
        var A = this;
        return this._trans("readonly", function(R) {
          return A.core.getMany({ keys: C, trans: R }).then(function(D) {
            return D.map(function(z) {
              return A.hook.reading.fire(z);
            });
          });
        });
      }, an.prototype.bulkAdd = function(C, A, R) {
        var D = this, z = Array.isArray(A) ? A : void 0, $ = (R = R || (z ? void 0 : A)) ? R.allKeys : void 0;
        return this._trans("readwrite", function(q) {
          var K = D.schema.primKey, ye = K.auto, K = K.keyPath;
          if (K && z) throw new Ae.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (z && z.length !== C.length) throw new Ae.InvalidArgument("Arguments objects and keys must have the same length");
          var se = C.length, ye = K && ye ? C.map(Jc(K)) : C;
          return D.core.mutate({ trans: q, type: "add", keys: z, values: ye, wantResults: $ }).then(function(ae) {
            var oe = ae.numFailures, ue = ae.failures;
            if (oe === 0) return $ ? ae.results : ae.lastResult;
            throw new J("".concat(D.name, ".bulkAdd(): ").concat(oe, " of ").concat(se, " operations failed"), ue);
          });
        });
      }, an.prototype.bulkPut = function(C, A, R) {
        var D = this, z = Array.isArray(A) ? A : void 0, $ = (R = R || (z ? void 0 : A)) ? R.allKeys : void 0;
        return this._trans("readwrite", function(q) {
          var K = D.schema.primKey, ye = K.auto, K = K.keyPath;
          if (K && z) throw new Ae.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (z && z.length !== C.length) throw new Ae.InvalidArgument("Arguments objects and keys must have the same length");
          var se = C.length, ye = K && ye ? C.map(Jc(K)) : C;
          return D.core.mutate({ trans: q, type: "put", keys: z, values: ye, wantResults: $ }).then(function(ae) {
            var oe = ae.numFailures, ue = ae.failures;
            if (oe === 0) return $ ? ae.results : ae.lastResult;
            throw new J("".concat(D.name, ".bulkPut(): ").concat(oe, " of ").concat(se, " operations failed"), ue);
          });
        });
      }, an.prototype.bulkUpdate = function(C) {
        var A = this, R = this.core, D = C.map(function(q) {
          return q.key;
        }), z = C.map(function(q) {
          return q.changes;
        }), $ = [];
        return this._trans("readwrite", function(q) {
          return R.getMany({ trans: q, keys: D, cache: "clone" }).then(function(K) {
            var se = [], ye = [], ae = (C.forEach(function(oe, ue) {
              var fe = oe.key, le = oe.changes, ce = K[ue];
              if (ce) {
                for (var we = 0, _e = Object.keys(le); we < _e.length; we++) {
                  var ve = _e[we], Re = le[ve];
                  if (ve === A.schema.primKey.keyPath) {
                    if (Pt(Re, fe) !== 0) throw new Ae.Constraint("Cannot update primary key in bulkUpdate()");
                  } else O(ce, ve, Re);
                }
                $.push(ue), se.push(fe), ye.push(ce);
              }
            }), se.length);
            return R.mutate({ trans: q, type: "put", keys: se, values: ye, updates: { keys: D, changeSpecs: z } }).then(function(oe) {
              var ue = oe.numFailures, fe = oe.failures;
              if (ue === 0) return ae;
              for (var le = 0, ce = Object.keys(fe); le < ce.length; le++) {
                var we, _e = ce[le], ve = $[Number(_e)];
                ve != null && (we = fe[_e], delete fe[_e], fe[ve] = we);
              }
              throw new J("".concat(A.name, ".bulkUpdate(): ").concat(ue, " of ").concat(ae, " operations failed"), fe);
            });
          });
        });
      }, an.prototype.bulkDelete = function(C) {
        var A = this, R = C.length;
        return this._trans("readwrite", function(D) {
          return A.core.mutate({ trans: D, type: "delete", keys: C }).then(function(z) {
            return qr(A, C, z);
          });
        }).then(function(D) {
          var z = D.numFailures, $ = D.failures;
          if (z === 0) return D.lastResult;
          throw new J("".concat(A.name, ".bulkDelete(): ").concat(z, " of ").concat(R, " operations failed"), $);
        });
      };
      var Gh = an;
      function an() {
      }
      function eu(C) {
        function A(q, K) {
          if (K) {
            for (var se = arguments.length, ye = new Array(se - 1); --se; ) ye[se - 1] = arguments[se];
            return R[q].subscribe.apply(null, ye), C;
          }
          if (typeof q == "string") return R[q];
        }
        var R = {};
        A.addEventType = $;
        for (var D = 1, z = arguments.length; D < z; ++D) $(arguments[D]);
        return A;
        function $(q, K, se) {
          var ye, ae;
          if (typeof q != "object") return K = K || Kt, ae = { subscribers: [], fire: se = se || Ge, subscribe: function(oe) {
            ae.subscribers.indexOf(oe) === -1 && (ae.subscribers.push(oe), ae.fire = K(ae.fire, oe));
          }, unsubscribe: function(oe) {
            ae.subscribers = ae.subscribers.filter(function(ue) {
              return ue !== oe;
            }), ae.fire = ae.subscribers.reduce(K, se);
          } }, R[q] = A[q] = ae;
          s(ye = q).forEach(function(oe) {
            var ue = ye[oe];
            if (a(ue)) $(oe, ye[oe][0], ye[oe][1]);
            else {
              if (ue !== "asap") throw new Ae.InvalidArgument("Invalid event config");
              var fe = $(oe, nt, function() {
                for (var le = arguments.length, ce = new Array(le); le--; ) ce[le] = arguments[le];
                fe.subscribers.forEach(function(we) {
                  P(function() {
                    we.apply(null, ce);
                  });
                });
              });
            }
          });
        }
      }
      function jr(C, A) {
        return x(A).from({ prototype: C }), A;
      }
      function Ss(C, A) {
        return !(C.filter || C.algorithm || C.or) && (A ? C.justLimit : !C.replayFilter);
      }
      function wd(C, A) {
        C.filter = aa(C.filter, A);
      }
      function tu(C, A, R) {
        var D = C.replayFilter;
        C.replayFilter = D ? function() {
          return aa(D(), A());
        } : A, C.justLimit = R && !D;
      }
      function Yo(C, A) {
        if (C.isPrimKey) return A.primaryKey;
        var R = A.getIndexByKeyPath(C.index);
        if (R) return R;
        throw new Ae.Schema("KeyPath " + C.index + " on object store " + A.name + " is not indexed");
      }
      function Kh(C, A, R) {
        var D = Yo(C, A.schema);
        return A.openCursor({ trans: R, values: !C.keysOnly, reverse: C.dir === "prev", unique: !!C.unique, query: { index: D, range: C.range } });
      }
      function nu(C, A, R, D) {
        var z, $, q = C.replayFilter ? aa(C.filter, C.replayFilter()) : C.filter;
        return C.or ? (z = {}, $ = function(K, se, ye) {
          var ae, oe;
          q && !q(se, ye, function(ue) {
            return se.stop(ue);
          }, function(ue) {
            return se.fail(ue);
          }) || ((oe = "" + (ae = se.primaryKey)) == "[object ArrayBuffer]" && (oe = "" + new Uint8Array(ae)), h(z, oe)) || (z[oe] = !0, A(K, se, ye));
        }, Promise.all([C.or._iterate($, R), la(Kh(C, D, R), C.algorithm, $, !C.keysOnly && C.valueMapper)])) : la(Kh(C, D, R), aa(C.algorithm, q), A, !C.keysOnly && C.valueMapper);
      }
      function la(C, A, R, D) {
        var z = kn(D ? function($, q, K) {
          return R(D($), q, K);
        } : R);
        return C.then(function($) {
          if ($) return $.start(function() {
            var q = function() {
              return $.continue();
            };
            A && !A($, function(K) {
              return q = K;
            }, function(K) {
              $.stop(K), q = Ge;
            }, function(K) {
              $.fail(K), q = Ge;
            }) || z($.value, $, function(K) {
              return q = K;
            }), q();
          });
        });
      }
      Jt.prototype._read = function(C, A) {
        var R = this._ctx;
        return R.error ? R.table._trans(null, vn.bind(null, R.error)) : R.table._trans("readonly", C).then(A);
      }, Jt.prototype._write = function(C) {
        var A = this._ctx;
        return A.error ? A.table._trans(null, vn.bind(null, A.error)) : A.table._trans("readwrite", C, "locked");
      }, Jt.prototype._addAlgorithm = function(C) {
        var A = this._ctx;
        A.algorithm = aa(A.algorithm, C);
      }, Jt.prototype._iterate = function(C, A) {
        return nu(this._ctx, C, A, this._ctx.table.core);
      }, Jt.prototype.clone = function(C) {
        var A = Object.create(this.constructor.prototype), R = Object.create(this._ctx);
        return C && c(R, C), A._ctx = R, A;
      }, Jt.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Jt.prototype.each = function(C) {
        var A = this._ctx;
        return this._read(function(R) {
          return nu(A, C, R, A.table.core);
        });
      }, Jt.prototype.count = function(C) {
        var A = this;
        return this._read(function(R) {
          var D, z = A._ctx, $ = z.table.core;
          return Ss(z, !0) ? $.count({ trans: R, query: { index: Yo(z, $.schema), range: z.range } }).then(function(q) {
            return Math.min(q, z.limit);
          }) : (D = 0, nu(z, function() {
            return ++D, !1;
          }, R, $).then(function() {
            return D;
          }));
        }).then(C);
      }, Jt.prototype.sortBy = function(C, A) {
        var R = C.split(".").reverse(), D = R[0], z = R.length - 1;
        function $(se, ye) {
          return ye ? $(se[R[ye]], ye - 1) : se[D];
        }
        var q = this._ctx.dir === "next" ? 1 : -1;
        function K(se, ye) {
          return Pt($(se, z), $(ye, z)) * q;
        }
        return this.toArray(function(se) {
          return se.sort(K);
        }).then(A);
      }, Jt.prototype.toArray = function(C) {
        var A = this;
        return this._read(function(R) {
          var D, z, $, q = A._ctx;
          return q.dir === "next" && Ss(q, !0) && 0 < q.limit ? (D = q.valueMapper, z = Yo(q, q.table.core.schema), q.table.core.query({ trans: R, limit: q.limit, values: !0, query: { index: z, range: q.range } }).then(function(K) {
            return K = K.result, D ? K.map(D) : K;
          })) : ($ = [], nu(q, function(K) {
            return $.push(K);
          }, R, q.table.core).then(function() {
            return $;
          }));
        }, C);
      }, Jt.prototype.offset = function(C) {
        var A = this._ctx;
        return C <= 0 || (A.offset += C, Ss(A) ? tu(A, function() {
          var R = C;
          return function(D, z) {
            return R === 0 || (R === 1 ? --R : z(function() {
              D.advance(R), R = 0;
            }), !1);
          };
        }) : tu(A, function() {
          var R = C;
          return function() {
            return --R < 0;
          };
        })), this;
      }, Jt.prototype.limit = function(C) {
        return this._ctx.limit = Math.min(this._ctx.limit, C), tu(this._ctx, function() {
          var A = C;
          return function(R, D, z) {
            return --A <= 0 && D(z), 0 <= A;
          };
        }, !0), this;
      }, Jt.prototype.until = function(C, A) {
        return wd(this._ctx, function(R, D, z) {
          return !C(R.value) || (D(z), A);
        }), this;
      }, Jt.prototype.first = function(C) {
        return this.limit(1).toArray(function(A) {
          return A[0];
        }).then(C);
      }, Jt.prototype.last = function(C) {
        return this.reverse().first(C);
      }, Jt.prototype.filter = function(C) {
        var A;
        return wd(this._ctx, function(R) {
          return C(R.value);
        }), (A = this._ctx).isMatch = aa(A.isMatch, C), this;
      }, Jt.prototype.and = function(C) {
        return this.filter(C);
      }, Jt.prototype.or = function(C) {
        return new this.db.WhereClause(this._ctx.table, C, this);
      }, Jt.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Jt.prototype.desc = function() {
        return this.reverse();
      }, Jt.prototype.eachKey = function(C) {
        var A = this._ctx;
        return A.keysOnly = !A.isMatch, this.each(function(R, D) {
          C(D.key, D);
        });
      }, Jt.prototype.eachUniqueKey = function(C) {
        return this._ctx.unique = "unique", this.eachKey(C);
      }, Jt.prototype.eachPrimaryKey = function(C) {
        var A = this._ctx;
        return A.keysOnly = !A.isMatch, this.each(function(R, D) {
          C(D.primaryKey, D);
        });
      }, Jt.prototype.keys = function(C) {
        var A = this._ctx, R = (A.keysOnly = !A.isMatch, []);
        return this.each(function(D, z) {
          R.push(z.key);
        }).then(function() {
          return R;
        }).then(C);
      }, Jt.prototype.primaryKeys = function(C) {
        var A = this._ctx;
        if (A.dir === "next" && Ss(A, !0) && 0 < A.limit) return this._read(function(D) {
          var z = Yo(A, A.table.core.schema);
          return A.table.core.query({ trans: D, values: !1, limit: A.limit, query: { index: z, range: A.range } });
        }).then(function(D) {
          return D.result;
        }).then(C);
        A.keysOnly = !A.isMatch;
        var R = [];
        return this.each(function(D, z) {
          R.push(z.primaryKey);
        }).then(function() {
          return R;
        }).then(C);
      }, Jt.prototype.uniqueKeys = function(C) {
        return this._ctx.unique = "unique", this.keys(C);
      }, Jt.prototype.firstKey = function(C) {
        return this.limit(1).keys(function(A) {
          return A[0];
        }).then(C);
      }, Jt.prototype.lastKey = function(C) {
        return this.reverse().firstKey(C);
      }, Jt.prototype.distinct = function() {
        var C, A = this._ctx, A = A.index && A.table.schema.idxByName[A.index];
        return A && A.multi && (C = {}, wd(this._ctx, function(D) {
          var D = D.primaryKey.toString(), z = h(C, D);
          return C[D] = !0, !z;
        })), this;
      }, Jt.prototype.modify = function(C) {
        var A = this, R = this._ctx;
        return this._write(function(D) {
          function z(ce, we) {
            var _e = we.failures;
            ue += ce - we.numFailures;
            for (var ve = 0, Re = s(_e); ve < Re.length; ve++) {
              var ze = Re[ve];
              oe.push(_e[ze]);
            }
          }
          var $ = typeof C == "function" ? C : function(ce) {
            return xd(ce, C);
          }, q = R.table.core, ae = q.schema.primaryKey, K = ae.outbound, se = ae.extractKey, ye = 200, ae = A.db._options.modifyChunkSize, oe = (ae && (ye = typeof ae == "object" ? ae[q.name] || ae["*"] || 200 : ae), []), ue = 0, fe = [], le = C === Zh;
          return A.clone().primaryKeys().then(function(ce) {
            function we(ve) {
              var Re = Math.min(ye, ce.length - ve), ze = ce.slice(ve, ve + Re);
              return (le ? Promise.resolve([]) : q.getMany({ trans: D, keys: ze, cache: "immutable" })).then(function(We) {
                var qe = [], Le = [], Xe = K ? [] : null, Ze = le ? ze : [];
                if (!le) for (var Be = 0; Be < Re; ++Be) {
                  var Je = We[Be], wt = { value: he(Je), primKey: ce[ve + Be] };
                  $.call(wt, wt.value, wt) !== !1 && (wt.value == null ? Ze.push(ce[ve + Be]) : K || Pt(se(Je), se(wt.value)) === 0 ? (Le.push(wt.value), K && Xe.push(ce[ve + Be])) : (Ze.push(ce[ve + Be]), qe.push(wt.value)));
                }
                return Promise.resolve(0 < qe.length && q.mutate({ trans: D, type: "add", values: qe }).then(function(Bt) {
                  for (var dt in Bt.failures) Ze.splice(parseInt(dt), 1);
                  z(qe.length, Bt);
                })).then(function() {
                  return (0 < Le.length || _e && typeof C == "object") && q.mutate({ trans: D, type: "put", keys: Xe, values: Le, criteria: _e, changeSpec: typeof C != "function" && C, isAdditionalChunk: 0 < ve }).then(function(Bt) {
                    return z(Le.length, Bt);
                  });
                }).then(function() {
                  return (0 < Ze.length || _e && le) && q.mutate({ trans: D, type: "delete", keys: Ze, criteria: _e, isAdditionalChunk: 0 < ve }).then(function(Bt) {
                    return qr(R.table, Ze, Bt);
                  }).then(function(Bt) {
                    return z(Ze.length, Bt);
                  });
                }).then(function() {
                  return ce.length > ve + Re && we(ve + ye);
                });
              });
            }
            var _e = Ss(R) && R.limit === 1 / 0 && (typeof C != "function" || le) && { index: R.index, range: R.range };
            return we(0).then(function() {
              if (0 < oe.length) throw new re("Error modifying one or more objects", oe, ue, fe);
              return ce.length;
            });
          });
        });
      }, Jt.prototype.delete = function() {
        var C = this._ctx, A = C.range;
        return !Ss(C) || C.table.schema.yProps || !C.isPrimKey && A.type !== 3 ? this.modify(Zh) : this._write(function(R) {
          var D = C.table.core.schema.primaryKey, z = A;
          return C.table.core.count({ trans: R, query: { index: D, range: z } }).then(function($) {
            return C.table.core.mutate({ trans: R, type: "deleteRange", range: z }).then(function(se) {
              var K = se.failures, se = se.numFailures;
              if (se) throw new re("Could not delete some values", Object.keys(K).map(function(ye) {
                return K[ye];
              }), $ - se);
              return $ - se;
            });
          });
        });
      };
      var c1 = Jt;
      function Jt() {
      }
      var Zh = function(C, A) {
        return A.value = null;
      };
      function Yh(C, A) {
        return C < A ? -1 : C === A ? 0 : 1;
      }
      function u1(C, A) {
        return A < C ? -1 : C === A ? 0 : 1;
      }
      function Si(C, A, R) {
        return C = C instanceof ca ? new C.Collection(C) : C, C._ctx.error = new (R || TypeError)(A), C;
      }
      function Xo(C) {
        return new C.Collection(C, function() {
          return Sd("");
        }).limit(0);
      }
      function zi(fe, A, R, D) {
        var z, $, q, K, se, ye, ae, oe = R.length;
        if (!R.every(function(ce) {
          return typeof ce == "string";
        })) return Si(fe, lr);
        function ue(ce) {
          z = ce === "next" ? function(_e) {
            return _e.toUpperCase();
          } : function(_e) {
            return _e.toLowerCase();
          }, $ = ce === "next" ? function(_e) {
            return _e.toLowerCase();
          } : function(_e) {
            return _e.toUpperCase();
          }, q = ce === "next" ? Yh : u1;
          var we = R.map(function(_e) {
            return { lower: $(_e), upper: z(_e) };
          }).sort(function(_e, ve) {
            return q(_e.lower, ve.lower);
          });
          K = we.map(function(_e) {
            return _e.upper;
          }), se = we.map(function(_e) {
            return _e.lower;
          }), ae = (ye = ce) === "next" ? "" : D;
        }
        ue("next");
        var fe = new fe.Collection(fe, function() {
          return bo(K[0], se[oe - 1] + D);
        }), le = (fe._ondirectionchange = function(ce) {
          ue(ce);
        }, 0);
        return fe._addAlgorithm(function(ce, we, _e) {
          var ve = ce.key;
          if (typeof ve == "string") {
            var Re = $(ve);
            if (A(Re, se, le)) return !0;
            for (var ze = null, We = le; We < oe; ++We) {
              var qe = ((Le, Xe, Ze, Be, Je, wt) => {
                for (var Bt = Math.min(Le.length, Be.length), dt = -1, Tt = 0; Tt < Bt; ++Tt) {
                  var bn = Xe[Tt];
                  if (bn !== Be[Tt]) return Je(Le[Tt], Ze[Tt]) < 0 ? Le.substr(0, Tt) + Ze[Tt] + Ze.substr(Tt + 1) : Je(Le[Tt], Be[Tt]) < 0 ? Le.substr(0, Tt) + Be[Tt] + Ze.substr(Tt + 1) : 0 <= dt ? Le.substr(0, dt) + Xe[dt] + Ze.substr(dt + 1) : null;
                  Je(Le[Tt], bn) < 0 && (dt = Tt);
                }
                return Bt < Be.length && wt === "next" ? Le + Ze.substr(Le.length) : Bt < Le.length && wt === "prev" ? Le.substr(0, Ze.length) : dt < 0 ? null : Le.substr(0, dt) + Be[dt] + Ze.substr(dt + 1);
              })(ve, Re, K[We], se[We], q, ye);
              qe === null && ze === null ? le = We + 1 : (ze === null || 0 < q(ze, qe)) && (ze = qe);
            }
            we(ze !== null ? function() {
              ce.continue(ze + ae);
            } : _e);
          }
          return !1;
        }), fe;
      }
      function bo(C, A, R, D) {
        return { type: 2, lower: C, upper: A, lowerOpen: R, upperOpen: D };
      }
      function Sd(C) {
        return { type: 1, lower: C, upper: C };
      }
      Object.defineProperty(In.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), In.prototype.between = function(C, A, R, D) {
        R = R !== !1, D = D === !0;
        try {
          return 0 < this._cmp(C, A) || this._cmp(C, A) === 0 && (R || D) && (!R || !D) ? Xo(this) : new this.Collection(this, function() {
            return bo(C, A, !R, !D);
          });
        } catch {
          return Si(this, si);
        }
      }, In.prototype.equals = function(C) {
        return C == null ? Si(this, si) : new this.Collection(this, function() {
          return Sd(C);
        });
      }, In.prototype.above = function(C) {
        return C == null ? Si(this, si) : new this.Collection(this, function() {
          return bo(C, void 0, !0);
        });
      }, In.prototype.aboveOrEqual = function(C) {
        return C == null ? Si(this, si) : new this.Collection(this, function() {
          return bo(C, void 0, !1);
        });
      }, In.prototype.below = function(C) {
        return C == null ? Si(this, si) : new this.Collection(this, function() {
          return bo(void 0, C, !1, !0);
        });
      }, In.prototype.belowOrEqual = function(C) {
        return C == null ? Si(this, si) : new this.Collection(this, function() {
          return bo(void 0, C);
        });
      }, In.prototype.startsWith = function(C) {
        return typeof C != "string" ? Si(this, lr) : this.between(C, C + Ji, !0, !0);
      }, In.prototype.startsWithIgnoreCase = function(C) {
        return C === "" ? this.startsWith(C) : zi(this, function(A, R) {
          return A.indexOf(R[0]) === 0;
        }, [C], Ji);
      }, In.prototype.equalsIgnoreCase = function(C) {
        return zi(this, function(A, R) {
          return A === R[0];
        }, [C], "");
      }, In.prototype.anyOfIgnoreCase = function() {
        var C = W.apply(Se, arguments);
        return C.length === 0 ? Xo(this) : zi(this, function(A, R) {
          return R.indexOf(A) !== -1;
        }, C, "");
      }, In.prototype.startsWithAnyOfIgnoreCase = function() {
        var C = W.apply(Se, arguments);
        return C.length === 0 ? Xo(this) : zi(this, function(A, R) {
          return R.some(function(D) {
            return A.indexOf(D) === 0;
          });
        }, C, Ji);
      }, In.prototype.anyOf = function() {
        var C, A, R = this, D = W.apply(Se, arguments), z = this._cmp;
        try {
          D.sort(z);
        } catch {
          return Si(this, si);
        }
        return D.length === 0 ? Xo(this) : ((C = new this.Collection(this, function() {
          return bo(D[0], D[D.length - 1]);
        }))._ondirectionchange = function($) {
          z = $ === "next" ? R._ascending : R._descending, D.sort(z);
        }, A = 0, C._addAlgorithm(function($, q, K) {
          for (var se = $.key; 0 < z(se, D[A]); ) if (++A === D.length) return q(K), !1;
          return z(se, D[A]) === 0 || (q(function() {
            $.continue(D[A]);
          }), !1);
        }), C);
      }, In.prototype.notEqual = function(C) {
        return this.inAnyRange([[-1 / 0, C], [C, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, In.prototype.noneOf = function() {
        var C = W.apply(Se, arguments);
        if (C.length === 0) return new this.Collection(this);
        try {
          C.sort(this._ascending);
        } catch {
          return Si(this, si);
        }
        var A = C.reduce(function(R, D) {
          return R ? R.concat([[R[R.length - 1][1], D]]) : [[-1 / 0, D]];
        }, null);
        return A.push([C[C.length - 1], this.db._maxKey]), this.inAnyRange(A, { includeLowers: !1, includeUppers: !1 });
      }, In.prototype.inAnyRange = function(C, _e) {
        var R = this, D = this._cmp, z = this._ascending, $ = this._descending, q = this._min, K = this._max;
        if (C.length === 0) return Xo(this);
        if (!C.every(function(ve) {
          return ve[0] !== void 0 && ve[1] !== void 0 && z(ve[0], ve[1]) <= 0;
        })) return Si(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Ae.InvalidArgument);
        var se = !_e || _e.includeLowers !== !1, ye = _e && _e.includeUppers === !0, ae, oe = z;
        function ue(ve, Re) {
          return oe(ve[0], Re[0]);
        }
        try {
          (ae = C.reduce(function(ve, Re) {
            for (var ze = 0, We = ve.length; ze < We; ++ze) {
              var qe = ve[ze];
              if (D(Re[0], qe[1]) < 0 && 0 < D(Re[1], qe[0])) {
                qe[0] = q(qe[0], Re[0]), qe[1] = K(qe[1], Re[1]);
                break;
              }
            }
            return ze === We && ve.push(Re), ve;
          }, [])).sort(ue);
        } catch {
          return Si(this, si);
        }
        var fe = 0, le = ye ? function(ve) {
          return 0 < z(ve, ae[fe][1]);
        } : function(ve) {
          return 0 <= z(ve, ae[fe][1]);
        }, ce = se ? function(ve) {
          return 0 < $(ve, ae[fe][0]);
        } : function(ve) {
          return 0 <= $(ve, ae[fe][0]);
        }, we = le, _e = new this.Collection(this, function() {
          return bo(ae[0][0], ae[ae.length - 1][1], !se, !ye);
        });
        return _e._ondirectionchange = function(ve) {
          oe = ve === "next" ? (we = le, z) : (we = ce, $), ae.sort(ue);
        }, _e._addAlgorithm(function(ve, Re, ze) {
          for (var We, qe = ve.key; we(qe); ) if (++fe === ae.length) return Re(ze), !1;
          return !le(We = qe) && !ce(We) || (R._cmp(qe, ae[fe][1]) === 0 || R._cmp(qe, ae[fe][0]) === 0 || Re(function() {
            oe === z ? ve.continue(ae[fe][0]) : ve.continue(ae[fe][1]);
          }), !1);
        }), _e;
      }, In.prototype.startsWithAnyOf = function() {
        var C = W.apply(Se, arguments);
        return C.every(function(A) {
          return typeof A == "string";
        }) ? C.length === 0 ? Xo(this) : this.inAnyRange(C.map(function(A) {
          return [A, A + Ji];
        })) : Si(this, "startsWithAnyOf() only works with strings");
      };
      var ca = In;
      function In() {
      }
      function Qi(C) {
        return kn(function(A) {
          return ua(A), C(A.target.error), !1;
        });
      }
      function ua(C) {
        C.stopPropagation && C.stopPropagation(), C.preventDefault && C.preventDefault();
      }
      var dl = "storagemutated", da = "x-storagemutated-1", Ir = eu(null, dl), Xh = (ai.prototype._lock = function() {
        return N(!Ve.global), ++this._reculock, this._reculock !== 1 || Ve.global || (Ve.lockOwnerFor = this), this;
      }, ai.prototype._unlock = function() {
        if (N(!Ve.global), --this._reculock == 0) for (Ve.global || (Ve.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var C = this._blockedFuncs.shift();
          try {
            Xi(C[1], C[0]);
          } catch {
          }
        }
        return this;
      }, ai.prototype._locked = function() {
        return this._reculock && Ve.lockOwnerFor !== this;
      }, ai.prototype.create = function(C) {
        var A = this;
        if (this.mode) {
          var R = this.db.idbdb, D = this.db._state.dbOpenError;
          if (N(!this.idbtrans), !C && !R) switch (D && D.name) {
            case "DatabaseClosedError":
              throw new Ae.DatabaseClosed(D);
            case "MissingAPIError":
              throw new Ae.MissingAPI(D.message, D);
            default:
              throw new Ae.OpenFailed(D);
          }
          if (!this.active) throw new Ae.TransactionInactive();
          N(this._completion._state === null), (C = this.idbtrans = C || (this.db.core || R).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = kn(function(z) {
            ua(z), A._reject(C.error);
          }), C.onabort = kn(function(z) {
            ua(z), A.active && A._reject(new Ae.Abort(C.error)), A.active = !1, A.on("abort").fire(z);
          }), C.oncomplete = kn(function() {
            A.active = !1, A._resolve(), "mutatedParts" in C && Ir.storagemutated.fire(C.mutatedParts);
          });
        }
        return this;
      }, ai.prototype._promise = function(C, A, R) {
        var D, z = this;
        return C === "readwrite" && this.mode !== "readwrite" ? vn(new Ae.ReadOnly("Transaction is readonly")) : this.active ? this._locked() ? new Ke(function($, q) {
          z._blockedFuncs.push([function() {
            z._promise(C, A, R).then($, q);
          }, Ve]);
        }) : R ? Nn(function() {
          var $ = new Ke(function(q, K) {
            z._lock();
            var se = A(q, K, z);
            se && se.then && se.then(q, K);
          });
          return $.finally(function() {
            return z._unlock();
          }), $._lib = !0, $;
        }) : ((D = new Ke(function($, q) {
          var K = A($, q, z);
          K && K.then && K.then($, q);
        }))._lib = !0, D) : vn(new Ae.TransactionInactive());
      }, ai.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, ai.prototype.waitFor = function(C) {
        var A, R = this._root(), D = Ke.resolve(C), z = (R._waitingFor ? R._waitingFor = R._waitingFor.then(function() {
          return D;
        }) : (R._waitingFor = D, R._waitingQueue = [], A = R.idbtrans.objectStore(R.storeNames[0]), (function $() {
          for (++R._spinCount; R._waitingQueue.length; ) R._waitingQueue.shift()();
          R._waitingFor && (A.get(-1 / 0).onsuccess = $);
        })()), R._waitingFor);
        return new Ke(function($, q) {
          D.then(function(K) {
            return R._waitingQueue.push(kn($.bind(null, K)));
          }, function(K) {
            return R._waitingQueue.push(kn(q.bind(null, K)));
          }).finally(function() {
            R._waitingFor === z && (R._waitingFor = null);
          });
        });
      }, ai.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Ae.Abort()));
      }, ai.prototype.table = function(C) {
        var A = this._memoizedTables || (this._memoizedTables = {});
        if (h(A, C)) return A[C];
        var R = this.schema[C];
        if (R) return (R = new this.db.Table(C, R, this)).core = this.db.core.table(C), A[C] = R;
        throw new Ae.NotFound("Table " + C + " not part of transaction");
      }, ai);
      function ai() {
      }
      function xo(C, A, R, D, z, $, q, K) {
        return { name: C, keyPath: A, unique: R, multi: D, auto: z, compound: $, src: (R && !q ? "&" : "") + (D ? "*" : "") + (z ? "++" : "") + kd(A), type: K };
      }
      function kd(C) {
        return typeof C == "string" ? C : C ? "[" + [].join.call(C, "+") + "]" : "";
      }
      function fl(C, A, R) {
        return { name: C, primKey: A, indexes: R, mappedClass: null, idxByName: (D = function(z) {
          return [z.name, z];
        }, R.reduce(function(z, $, q) {
          return $ = D($, q), $ && (z[$[0]] = $[1]), z;
        }, {})) };
        var D;
      }
      var hl = function(C) {
        try {
          return C.only([[]]), hl = function() {
            return [[]];
          }, [[]];
        } catch {
          return hl = function() {
            return Ji;
          }, Ji;
        }
      };
      function pl(C) {
        return C == null ? function() {
        } : typeof C == "string" ? (A = C).split(".").length === 1 ? function(R) {
          return R[A];
        } : function(R) {
          return I(R, A);
        } : function(R) {
          return I(R, C);
        };
        var A;
      }
      function ru(C) {
        return [].slice.call(C);
      }
      var uy = 0;
      function pr(C) {
        return C == null ? ":id" : typeof C == "string" ? C : "[".concat(C.join("+"), "]");
      }
      function fa(C, A, se) {
        function D(le) {
          if (le.type === 3) return null;
          if (le.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var oe = le.lower, ue = le.upper, fe = le.lowerOpen, le = le.upperOpen;
          return oe === void 0 ? ue === void 0 ? null : A.upperBound(ue, !!le) : ue === void 0 ? A.lowerBound(oe, !!fe) : A.bound(oe, ue, !!fe, !!le);
        }
        function z(ae) {
          var oe, ue = ae.name;
          return { name: ue, schema: ae, mutate: function(fe) {
            var le = fe.trans, ce = fe.type, we = fe.keys, _e = fe.values, ve = fe.range;
            return new Promise(function(Re, ze) {
              Re = kn(Re);
              var We = le.objectStore(ue), qe = We.keyPath == null, Le = ce === "put" || ce === "add";
              if (!Le && ce !== "delete" && ce !== "deleteRange") throw new Error("Invalid operation type: " + ce);
              var Xe, Ze = (we || _e || { length: 1 }).length;
              if (we && _e && we.length !== _e.length) throw new Error("Given keys array must have same length as given values array.");
              if (Ze === 0) return Re({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function Be(un) {
                ++Bt, ua(un);
              }
              var Je = [], wt = [], Bt = 0;
              if (ce === "deleteRange") {
                if (ve.type === 4) return Re({ numFailures: Bt, failures: wt, results: [], lastResult: void 0 });
                ve.type === 3 ? Je.push(Xe = We.clear()) : Je.push(Xe = We.delete(D(ve)));
              } else {
                var qe = Le ? qe ? [_e, we] : [_e, null] : [we, null], dt = qe[0], Tt = qe[1];
                if (Le) for (var bn = 0; bn < Ze; ++bn) Je.push(Xe = Tt && Tt[bn] !== void 0 ? We[ce](dt[bn], Tt[bn]) : We[ce](dt[bn])), Xe.onerror = Be;
                else for (bn = 0; bn < Ze; ++bn) Je.push(Xe = We[ce](dt[bn])), Xe.onerror = Be;
              }
              function ci(un) {
                un = un.target.result, Je.forEach(function(_s, xl) {
                  return _s.error != null && (wt[xl] = _s.error);
                }), Re({ numFailures: Bt, failures: wt, results: ce === "delete" ? we : Je.map(function(_s) {
                  return _s.result;
                }), lastResult: un });
              }
              Xe.onerror = function(un) {
                Be(un), ci(un);
              }, Xe.onsuccess = ci;
            });
          }, getMany: function(fe) {
            var le = fe.trans, ce = fe.keys;
            return new Promise(function(we, _e) {
              we = kn(we);
              for (var ve, Re = le.objectStore(ue), ze = ce.length, We = new Array(ze), qe = 0, Le = 0, Xe = function(Je) {
                Je = Je.target, We[Je._pos] = Je.result, ++Le === qe && we(We);
              }, Ze = Qi(_e), Be = 0; Be < ze; ++Be) ce[Be] != null && ((ve = Re.get(ce[Be]))._pos = Be, ve.onsuccess = Xe, ve.onerror = Ze, ++qe);
              qe === 0 && we(We);
            });
          }, get: function(fe) {
            var le = fe.trans, ce = fe.key;
            return new Promise(function(we, _e) {
              we = kn(we);
              var ve = le.objectStore(ue).get(ce);
              ve.onsuccess = function(Re) {
                return we(Re.target.result);
              }, ve.onerror = Qi(_e);
            });
          }, query: (oe = K, function(fe) {
            return new Promise(function(le, ce) {
              le = kn(le);
              var we, _e, ve, Le = fe.trans, Re = fe.values, ze = fe.limit, qe = fe.query, We = ze === 1 / 0 ? void 0 : ze, Xe = qe.index, qe = qe.range, Le = Le.objectStore(ue), Le = Xe.isPrimaryKey ? Le : Le.index(Xe.name), Xe = D(qe);
              if (ze === 0) return le({ result: [] });
              oe ? ((qe = Re ? Le.getAll(Xe, We) : Le.getAllKeys(Xe, We)).onsuccess = function(Ze) {
                return le({ result: Ze.target.result });
              }, qe.onerror = Qi(ce)) : (we = 0, _e = !Re && "openKeyCursor" in Le ? Le.openKeyCursor(Xe) : Le.openCursor(Xe), ve = [], _e.onsuccess = function(Ze) {
                var Be = _e.result;
                return !Be || (ve.push(Re ? Be.value : Be.primaryKey), ++we === ze) ? le({ result: ve }) : void Be.continue();
              }, _e.onerror = Qi(ce));
            });
          }), openCursor: function(fe) {
            var le = fe.trans, ce = fe.values, we = fe.query, _e = fe.reverse, ve = fe.unique;
            return new Promise(function(Re, ze) {
              Re = kn(Re);
              var Le = we.index, We = we.range, qe = le.objectStore(ue), qe = Le.isPrimaryKey ? qe : qe.index(Le.name), Le = _e ? ve ? "prevunique" : "prev" : ve ? "nextunique" : "next", Xe = !ce && "openKeyCursor" in qe ? qe.openKeyCursor(D(We), Le) : qe.openCursor(D(We), Le);
              Xe.onerror = Qi(ze), Xe.onsuccess = kn(function(Ze) {
                var Be, Je, wt, Bt, dt = Xe.result;
                dt ? (dt.___id = ++uy, dt.done = !1, Be = dt.continue.bind(dt), Je = (Je = dt.continuePrimaryKey) && Je.bind(dt), wt = dt.advance.bind(dt), Bt = function() {
                  throw new Error("Cursor not stopped");
                }, dt.trans = le, dt.stop = dt.continue = dt.continuePrimaryKey = dt.advance = function() {
                  throw new Error("Cursor not started");
                }, dt.fail = kn(ze), dt.next = function() {
                  var Tt = this, bn = 1;
                  return this.start(function() {
                    return bn-- ? Tt.continue() : Tt.stop();
                  }).then(function() {
                    return Tt;
                  });
                }, dt.start = function(Tt) {
                  function bn() {
                    if (Xe.result) try {
                      Tt();
                    } catch (un) {
                      dt.fail(un);
                    }
                    else dt.done = !0, dt.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, dt.stop();
                  }
                  var ci = new Promise(function(un, _s) {
                    un = kn(un), Xe.onerror = Qi(_s), dt.fail = _s, dt.stop = function(xl) {
                      dt.stop = dt.continue = dt.continuePrimaryKey = dt.advance = Bt, un(xl);
                    };
                  });
                  return Xe.onsuccess = kn(function(un) {
                    Xe.onsuccess = bn, bn();
                  }), dt.continue = Be, dt.continuePrimaryKey = Je, dt.advance = wt, bn(), ci;
                }, Re(dt)) : Re(null);
              }, ze);
            });
          }, count: function(fe) {
            var le = fe.query, ce = fe.trans, we = le.index, _e = le.range;
            return new Promise(function(ve, Re) {
              var ze = ce.objectStore(ue), ze = we.isPrimaryKey ? ze : ze.index(we.name), We = D(_e), We = We ? ze.count(We) : ze.count();
              We.onsuccess = kn(function(qe) {
                return ve(qe.target.result);
              }), We.onerror = Qi(Re);
            });
          } };
        }
        $ = se, q = ru((se = C).objectStoreNames);
        var $, se = { schema: { name: se.name, tables: q.map(function(ae) {
          return $.objectStore(ae);
        }).map(function(ae) {
          var oe = ae.keyPath, ue = ae.autoIncrement, le = a(oe), fe = {}, le = { name: ae.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: oe == null, compound: le, keyPath: oe, autoIncrement: ue, unique: !0, extractKey: pl(oe) }, indexes: ru(ae.indexNames).map(function(ce) {
            return ae.index(ce);
          }).map(function(ve) {
            var Re = ve.name, we = ve.unique, _e = ve.multiEntry, ve = ve.keyPath, Re = { name: Re, compound: a(ve), keyPath: ve, unique: we, multiEntry: _e, extractKey: pl(ve) };
            return fe[pr(ve)] = Re;
          }), getIndexByKeyPath: function(ce) {
            return fe[pr(ce)];
          } };
          return fe[":id"] = le.primaryKey, oe != null && (fe[pr(oe)] = le.primaryKey), le;
        }) }, hasGetAll: 0 < q.length && "getAll" in $.objectStore(q[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }, q = se.schema, K = se.hasGetAll, se = q.tables.map(z), ye = {};
        return se.forEach(function(ae) {
          return ye[ae.name] = ae;
        }), { stack: "dbcore", transaction: C.transaction.bind(C), table: function(ae) {
          if (ye[ae]) return ye[ae];
          throw new Error("Table '".concat(ae, "' not found"));
        }, MIN_KEY: -1 / 0, MAX_KEY: hl(A), schema: q };
      }
      function Cd(C, A, R, D) {
        return R = R.IDBKeyRange, A = fa(A, R, D), { dbcore: C.dbcore.reduce(function(z, $) {
          return $ = $.create, r(r({}, z), $(z));
        }, A) };
      }
      function ks(C, A) {
        var R = A.db, R = Cd(C._middlewares, R, C._deps, A);
        C.core = R.dbcore, C.tables.forEach(function(D) {
          var z = D.name;
          C.core.schema.tables.some(function($) {
            return $.name === z;
          }) && (D.core = C.core.table(z), C[z] instanceof C.Table) && (C[z].core = D.core);
        });
      }
      function Ed(C, A, R, D) {
        R.forEach(function(z) {
          var $ = D[z];
          A.forEach(function(q) {
            var K = (function se(ye, ae) {
              return w(ye, ae) || (ye = u(ye)) && se(ye, ae);
            })(q, z);
            (!K || "value" in K && K.value === void 0) && (q === C.Transaction.prototype || q instanceof C.Transaction ? b(q, z, { get: function() {
              return this.table(z);
            }, set: function(se) {
              g(this, z, { value: se, writable: !0, configurable: !0, enumerable: !0 });
            } }) : q[z] = new C.Table(z, $));
          });
        });
      }
      function iu(C, A) {
        A.forEach(function(R) {
          for (var D in R) R[D] instanceof C.Table && delete R[D];
        });
      }
      function Jh(C, A) {
        return C._cfg.version - A._cfg.version;
      }
      function ou(C, A, R, D) {
        var z = C._dbSchema, $ = (R.objectStoreNames.contains("$meta") && !z.$meta && (z.$meta = fl("$meta", fy("")[0], []), C._storeNames.push("$meta")), C._createTransaction("readwrite", C._storeNames, z)), q = ($.create(R), $._completion.catch(D), $._reject.bind($)), K = Ve.transless || Ve;
        Nn(function() {
          if (Ve.trans = $, Ve.transless = K, A !== 0) return ks(C, R), ye = A, ((se = $).storeNames.includes("$meta") ? se.table("$meta").get("version").then(function(ae) {
            return ae ?? ye;
          }) : Ke.resolve(ye)).then(function(we) {
            var oe = C, ue = we, fe = $, le = R, ce = [], we = oe._versions, _e = oe._dbSchema = ml(0, oe.idbdb, le);
            return (we = we.filter(function(ve) {
              return ve._cfg.version >= ue;
            })).length === 0 ? Ke.resolve() : (we.forEach(function(ve) {
              ce.push(function() {
                var Re, ze, We, qe = _e, Le = ve._cfg.dbschema, Xe = (Md(oe, qe, le), Md(oe, Le, le), _e = oe._dbSchema = Le, Td(qe, Le)), Ze = (Xe.add.forEach(function(Be) {
                  Qh(le, Be[0], Be[1].primKey, Be[1].indexes);
                }), Xe.change.forEach(function(Be) {
                  if (Be.recreate) throw new Ae.Upgrade("Not yet support for changing primary key");
                  var Je = le.objectStore(Be.name);
                  Be.add.forEach(function(wt) {
                    return Ad(Je, wt);
                  }), Be.change.forEach(function(wt) {
                    Je.deleteIndex(wt.name), Ad(Je, wt);
                  }), Be.del.forEach(function(wt) {
                    return Je.deleteIndex(wt);
                  });
                }), ve._cfg.contentUpgrade);
                if (Ze && ve._cfg.version > ue) return ks(oe, le), fe._memoizedTables = {}, Re = L(Le), Xe.del.forEach(function(Be) {
                  Re[Be] = qe[Be];
                }), iu(oe, [oe.Transaction.prototype]), Ed(oe, [oe.Transaction.prototype], s(Re), Re), fe.schema = Re, (ze = Z(Ze)) && ar(), Le = Ke.follow(function() {
                  var Be;
                  (We = Ze(fe)) && ze && (Be = wi.bind(null, null), We.then(Be, Be));
                }), We && typeof We.then == "function" ? Ke.resolve(We) : Le.then(function() {
                  return We;
                });
              }), ce.push(function(Re) {
                var ze, We, qe = ve._cfg.dbschema;
                ze = qe, We = Re, [].slice.call(We.db.objectStoreNames).forEach(function(Le) {
                  return ze[Le] == null && We.db.deleteObjectStore(Le);
                }), iu(oe, [oe.Transaction.prototype]), Ed(oe, [oe.Transaction.prototype], oe._storeNames, oe._dbSchema), fe.schema = oe._dbSchema;
              }), ce.push(function(Re) {
                oe.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(oe.idbdb.version / 10) === ve._cfg.version ? (oe.idbdb.deleteObjectStore("$meta"), delete oe._dbSchema.$meta, oe._storeNames = oe._storeNames.filter(function(ze) {
                  return ze !== "$meta";
                })) : Re.objectStore("$meta").put(ve._cfg.version, "version"));
              });
            }), (function ve() {
              return ce.length ? Ke.resolve(ce.shift()(fe.idbtrans)).then(ve) : Ke.resolve();
            })().then(function() {
              dy(_e, le);
            }));
          }).catch(q);
          var se, ye;
          s(z).forEach(function(ae) {
            Qh(R, ae, z[ae].primKey, z[ae].indexes);
          }), ks(C, R), Ke.follow(function() {
            return C.on.populate.fire($);
          }).catch(q);
        });
      }
      function _d(C, A) {
        dy(C._dbSchema, A), A.db.version % 10 != 0 || A.objectStoreNames.contains("$meta") || A.db.createObjectStore("$meta").add(Math.ceil(A.db.version / 10 - 1), "version");
        var R = ml(0, C.idbdb, A);
        Md(C, C._dbSchema, A);
        for (var D = 0, z = Td(R, C._dbSchema).change; D < z.length; D++) {
          var $ = ((q) => {
            if (q.change.length || q.recreate) return console.warn("Unable to patch indexes of table ".concat(q.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var K = A.objectStore(q.name);
            q.add.forEach(function(se) {
              Nt && console.debug("Dexie upgrade patch: Creating missing index ".concat(q.name, ".").concat(se.src)), Ad(K, se);
            });
          })(z[D]);
          if (typeof $ == "object") return $.value;
        }
      }
      function Td(C, A) {
        var R, D = { del: [], add: [], change: [] };
        for (R in C) A[R] || D.del.push(R);
        for (R in A) {
          var z = C[R], $ = A[R];
          if (z) {
            var q = { name: R, def: $, recreate: !1, del: [], add: [], change: [] };
            if ("" + (z.primKey.keyPath || "") != "" + ($.primKey.keyPath || "") || z.primKey.auto !== $.primKey.auto) q.recreate = !0, D.change.push(q);
            else {
              var K = z.idxByName, se = $.idxByName, ye = void 0;
              for (ye in K) se[ye] || q.del.push(ye);
              for (ye in se) {
                var ae = K[ye], oe = se[ye];
                ae ? ae.src !== oe.src && q.change.push(oe) : q.add.push(oe);
              }
              (0 < q.del.length || 0 < q.add.length || 0 < q.change.length) && D.change.push(q);
            }
          } else D.add.push([R, $]);
        }
        return D;
      }
      function Qh(C, A, R, D) {
        var z = C.db.createObjectStore(A, R.keyPath ? { keyPath: R.keyPath, autoIncrement: R.auto } : { autoIncrement: R.auto });
        D.forEach(function($) {
          return Ad(z, $);
        });
      }
      function dy(C, A) {
        s(C).forEach(function(R) {
          A.db.objectStoreNames.contains(R) || (Nt && console.debug("Dexie: Creating missing table", R), Qh(A, R, C[R].primKey, C[R].indexes));
        });
      }
      function Ad(C, A) {
        C.createIndex(A.name, A.keyPath, { unique: A.unique, multiEntry: A.multi });
      }
      function ml(C, A, R) {
        var D = {};
        return _(A.objectStoreNames, 0).forEach(function(z) {
          for (var $ = R.objectStore(z), q = xo(kd(ye = $.keyPath), ye || "", !0, !1, !!$.autoIncrement, ye && typeof ye != "string", !0), K = [], se = 0; se < $.indexNames.length; ++se) {
            var ae = $.index($.indexNames[se]), ye = ae.keyPath, ae = xo(ae.name, ye, !!ae.unique, !!ae.multiEntry, !1, ye && typeof ye != "string", !1);
            K.push(ae);
          }
          D[z] = fl(z, q, K);
        }), D;
      }
      function Md(C, A, R) {
        for (var D = R.db.objectStoreNames, z = 0; z < D.length; ++z) {
          var $ = D[z], q = R.objectStore($);
          C._hasGetAll = "getAll" in q;
          for (var K = 0; K < q.indexNames.length; ++K) {
            var se, ye = q.indexNames[K], ae = q.index(ye).keyPath, ae = typeof ae == "string" ? ae : "[" + _(ae).join("+") + "]";
            A[$] && (se = A[$].idxByName[ae]) && (se.name = ye, delete A[$].idxByName[ae], A[$].idxByName[ye] = se);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (C._hasGetAll = !1);
      }
      function fy(C) {
        return C.split(",").map(function(A, R) {
          var z = A.split(":"), D = (D = z[1]) == null ? void 0 : D.trim(), z = (A = z[0].trim()).replace(/([&*]|\+\+)/g, ""), $ = /^\[/.test(z) ? z.match(/^\[(.*)\]$/)[1].split("+") : z;
          return xo(z, $ || null, /\&/.test(A), /\*/.test(A), /\+\+/.test(A), a($), R === 0, D);
        });
      }
      gl.prototype._createTableSchema = fl, gl.prototype._parseIndexSyntax = fy, gl.prototype._parseStoresSpec = function(C, A) {
        var R = this;
        s(C).forEach(function(D) {
          if (C[D] !== null) {
            var z = R._parseIndexSyntax(C[D]), $ = z.shift();
            if (!$) throw new Ae.Schema("Invalid schema for table " + D + ": " + C[D]);
            if ($.unique = !0, $.multi) throw new Ae.Schema("Primary key cannot be multiEntry*");
            z.forEach(function(q) {
              if (q.auto) throw new Ae.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!q.keyPath) throw new Ae.Schema("Index must have a name and cannot be an empty string");
            }), $ = R._createTableSchema(D, $, z), A[D] = $;
          }
        });
      }, gl.prototype.stores = function(R) {
        var A = this.db, R = (this._cfg.storesSource = this._cfg.storesSource ? c(this._cfg.storesSource, R) : R, A._versions), D = {}, z = {};
        return R.forEach(function($) {
          c(D, $._cfg.storesSource), z = $._cfg.dbschema = {}, $._parseStoresSpec(D, z);
        }), A._dbSchema = z, iu(A, [A._allTables, A, A.Transaction.prototype]), Ed(A, [A._allTables, A, A.Transaction.prototype, this._cfg.tables], s(z), z), A._storeNames = s(z), this;
      }, gl.prototype.upgrade = function(C) {
        return this._cfg.contentUpgrade = An(this._cfg.contentUpgrade || Ge, C), this;
      };
      var d1 = gl;
      function gl() {
      }
      function ep(C, A) {
        var R = C._dbNamesDB;
        return R || (R = C._dbNamesDB = new wo(Xc, { addons: [], indexedDB: C, IDBKeyRange: A })).version(1).stores({ dbnames: "name" }), R.table("dbnames");
      }
      function Nd(C) {
        return C && typeof C.databases == "function";
      }
      function tp(C) {
        return Nn(function() {
          return Ve.letThrough = !0, C();
        });
      }
      function np(C) {
        return !("from" in C);
      }
      var zr = function(C, A) {
        var R;
        if (!this) return R = new zr(), C && "d" in C && c(R, C), R;
        c(this, arguments.length ? { d: 1, from: C, to: 1 < arguments.length ? A : C } : { d: 0 });
      };
      function su(C, A, R) {
        var D = Pt(A, R);
        if (!isNaN(D)) {
          if (0 < D) throw RangeError();
          if (np(C)) return c(C, { from: A, to: R, d: 1 });
          var D = C.l, z = C.r;
          if (Pt(R, C.from) < 0) return D ? su(D, A, R) : C.l = { from: A, to: R, d: 1, l: null, r: null }, py(C);
          if (0 < Pt(A, C.to)) return z ? su(z, A, R) : C.r = { from: A, to: R, d: 1, l: null, r: null }, py(C);
          Pt(A, C.from) < 0 && (C.from = A, C.l = null, C.d = z ? z.d + 1 : 1), 0 < Pt(R, C.to) && (C.to = R, C.r = null, C.d = C.l ? C.l.d + 1 : 1), A = !C.r, D && !C.l && ha(C, D), z && A && ha(C, z);
        }
      }
      function ha(C, A) {
        np(A) || (function R(D, z) {
          var $ = z.from, q = z.l, K = z.r;
          su(D, $, z.to), q && R(D, q), K && R(D, K);
        })(C, A);
      }
      function hy(C, A) {
        var R = Rd(A), D = R.next();
        if (!D.done) for (var z = D.value, $ = Rd(C), q = $.next(z.from), K = q.value; !D.done && !q.done; ) {
          if (Pt(K.from, z.to) <= 0 && 0 <= Pt(K.to, z.from)) return !0;
          Pt(z.from, K.from) < 0 ? z = (D = R.next(K.from)).value : K = (q = $.next(z.from)).value;
        }
        return !1;
      }
      function Rd(C) {
        var A = np(C) ? null : { s: 0, n: C };
        return { next: function(R) {
          for (var D = 0 < arguments.length; A; ) switch (A.s) {
            case 0:
              if (A.s = 1, D) for (; A.n.l && Pt(R, A.n.from) < 0; ) A = { up: A, n: A.n.l, s: 1 };
              else for (; A.n.l; ) A = { up: A, n: A.n.l, s: 1 };
            case 1:
              if (A.s = 2, !D || Pt(R, A.n.to) <= 0) return { value: A.n, done: !1 };
            case 2:
              if (A.n.r) {
                A.s = 3, A = { up: A, n: A.n.r, s: 0 };
                continue;
              }
            case 3:
              A = A.up;
          }
          return { done: !0 };
        } };
      }
      function py(C) {
        var A, R, D, z = (((z = C.r) == null ? void 0 : z.d) || 0) - (((z = C.l) == null ? void 0 : z.d) || 0), z = 1 < z ? "r" : z < -1 ? "l" : "";
        z && (A = z == "r" ? "l" : "r", R = r({}, C), D = C[z], C.from = D.from, C.to = D.to, C[z] = D[z], R[z] = D[A], (C[A] = R).d = rp(R)), C.d = rp(C);
      }
      function rp(R) {
        var A = R.r, R = R.l;
        return (A ? R ? Math.max(A.d, R.d) : A.d : R ? R.d : 0) + 1;
      }
      function Od(C, A) {
        return s(A).forEach(function(R) {
          C[R] ? ha(C[R], A[R]) : C[R] = (function D(z) {
            var $, q, K = {};
            for ($ in z) h(z, $) && (q = z[$], K[$] = !q || typeof q != "object" || G.has(q.constructor) ? q : D(q));
            return K;
          })(A[R]);
        }), C;
      }
      function ip(C, A) {
        return C.all || A.all || Object.keys(C).some(function(R) {
          return A[R] && hy(A[R], C[R]);
        });
      }
      m(zr.prototype, ((ke = { add: function(C) {
        return ha(this, C), this;
      }, addKey: function(C) {
        return su(this, C, C), this;
      }, addKeys: function(C) {
        var A = this;
        return C.forEach(function(R) {
          return su(A, R, R);
        }), this;
      }, hasKey: function(C) {
        var A = Rd(this).next(C).value;
        return A && Pt(A.from, C) <= 0 && 0 <= Pt(A.to, C);
      } })[H] = function() {
        return Rd(this);
      }, ke));
      var pa = {}, op = {}, sp = !1;
      function Dd(C) {
        Od(op, C), sp || (sp = !0, setTimeout(function() {
          sp = !1, ap(op, !(op = {}));
        }, 0));
      }
      function ap(C, A) {
        A === void 0 && (A = !1);
        var R = /* @__PURE__ */ new Set();
        if (C.all) for (var D = 0, z = Object.values(pa); D < z.length; D++) my(K = z[D], C, R, A);
        else for (var $ in C) {
          var q, K, $ = /^idb\:\/\/(.*)\/(.*)\//.exec($);
          $ && (q = $[1], $ = $[2], K = pa["idb://".concat(q, "/").concat($)]) && my(K, C, R, A);
        }
        R.forEach(function(se) {
          return se();
        });
      }
      function my(C, A, R, D) {
        for (var z = [], $ = 0, q = Object.entries(C.queries.query); $ < q.length; $++) {
          for (var K = q[$], se = K[0], ye = [], ae = 0, oe = K[1]; ae < oe.length; ae++) {
            var ue = oe[ae];
            ip(A, ue.obsSet) ? ue.subscribers.forEach(function(we) {
              return R.add(we);
            }) : D && ye.push(ue);
          }
          D && z.push([se, ye]);
        }
        if (D) for (var fe = 0, le = z; fe < le.length; fe++) {
          var ce = le[fe], se = ce[0], ye = ce[1];
          C.queries.query[se] = ye;
        }
      }
      function f1(C) {
        var A = C._state, R = C._deps.indexedDB;
        if (A.isBeingOpened || C.idbdb) return A.dbReadyPromise.then(function() {
          return A.dbOpenError ? vn(A.dbOpenError) : C;
        });
        A.isBeingOpened = !0, A.dbOpenError = null, A.openComplete = !1;
        var D = A.openCanceller, z = Math.round(10 * C.verno), $ = !1;
        function q() {
          if (A.openCanceller !== D) throw new Ae.DatabaseClosed("db.open() was cancelled");
        }
        function K() {
          return new Ke(function(ue, fe) {
            if (q(), !R) throw new Ae.MissingAPI();
            var le = C.name, ce = A.autoSchema || !z ? R.open(le) : R.open(le, z);
            if (!ce) throw new Ae.MissingAPI();
            ce.onerror = Qi(fe), ce.onblocked = kn(C._fireOnBlocked), ce.onupgradeneeded = kn(function(we) {
              var _e;
              ae = ce.transaction, A.autoSchema && !C._options.allowEmptyDB ? (ce.onerror = ua, ae.abort(), ce.result.close(), (_e = R.deleteDatabase(le)).onsuccess = _e.onerror = kn(function() {
                fe(new Ae.NoSuchDatabase("Database ".concat(le, " doesnt exist")));
              })) : (ae.onerror = Qi(fe), _e = we.oldVersion > Math.pow(2, 62) ? 0 : we.oldVersion, oe = _e < 1, C.idbdb = ce.result, $ && _d(C, ae), ou(C, _e / 10, ae, fe));
            }, fe), ce.onsuccess = kn(function() {
              ae = null;
              var we, _e, ve, Re, ze, We, qe = C.idbdb = ce.result, Le = _(qe.objectStoreNames);
              if (0 < Le.length) try {
                var Xe = qe.transaction((ze = Le).length === 1 ? ze[0] : ze, "readonly");
                if (A.autoSchema) We = qe, Re = Xe, (ve = C).verno = We.version / 10, Re = ve._dbSchema = ml(0, We, Re), ve._storeNames = _(We.objectStoreNames, 0), Ed(ve, [ve._allTables], s(Re), Re);
                else if (Md(C, C._dbSchema, Xe), _e = Xe, ((_e = Td(ml(0, (we = C).idbdb, _e), we._dbSchema)).add.length || _e.change.some(function(Ze) {
                  return Ze.add.length || Ze.change.length;
                })) && !$) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), qe.close(), z = qe.version + 1, $ = !0, ue(K());
                ks(C, Xe);
              } catch {
              }
              sa.push(C), qe.onversionchange = kn(function(Ze) {
                A.vcFired = !0, C.on("versionchange").fire(Ze);
              }), qe.onclose = kn(function() {
                C.close({ disableAutoOpen: !1 });
              }), oe && (Le = C._deps, ze = le, Nd(We = Le.indexedDB) || ze === Xc || ep(We, Le.IDBKeyRange).put({ name: ze }).catch(Ge)), ue();
            }, fe);
          }).catch(function(ue) {
            switch (ue?.name) {
              case "UnknownError":
                if (0 < A.PR1398_maxLoop) return A.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), K();
                break;
              case "VersionError":
                if (0 < z) return z = 0, K();
            }
            return Ke.reject(ue);
          });
        }
        var se, ye = A.dbReadyResolve, ae = null, oe = !1;
        return Ke.race([D, (typeof navigator > "u" ? Ke.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(ue) {
          function fe() {
            return indexedDB.databases().finally(ue);
          }
          se = setInterval(fe, 100), fe();
        }).finally(function() {
          return clearInterval(se);
        }) : Promise.resolve()).then(K)]).then(function() {
          return q(), A.onReadyBeingFired = [], Ke.resolve(tp(function() {
            return C.on.ready.fire(C.vip);
          })).then(function ue() {
            var fe;
            if (0 < A.onReadyBeingFired.length) return fe = A.onReadyBeingFired.reduce(An, Ge), A.onReadyBeingFired = [], Ke.resolve(tp(function() {
              return fe(C.vip);
            })).then(ue);
          });
        }).finally(function() {
          A.openCanceller === D && (A.onReadyBeingFired = null, A.isBeingOpened = !1);
        }).catch(function(ue) {
          A.dbOpenError = ue;
          try {
            ae && ae.abort();
          } catch {
          }
          return D === A.openCanceller && C._close(), vn(ue);
        }).finally(function() {
          A.openComplete = !0, ye();
        }).then(function() {
          var ue;
          return oe && (ue = {}, C.tables.forEach(function(fe) {
            fe.schema.indexes.forEach(function(le) {
              le.name && (ue["idb://".concat(C.name, "/").concat(fe.name, "/").concat(le.name)] = new zr(-1 / 0, [[[]]]));
            }), ue["idb://".concat(C.name, "/").concat(fe.name, "/")] = ue["idb://".concat(C.name, "/").concat(fe.name, "/:dels")] = new zr(-1 / 0, [[[]]]);
          }), Ir(dl).fire(ue), ap(ue, !0)), C;
        });
      }
      function au(C) {
        function A($) {
          return C.next($);
        }
        var R = z(A), D = z(function($) {
          return C.throw($);
        });
        function z($) {
          return function(K) {
            var K = $(K), se = K.value;
            return K.done ? se : se && typeof se.then == "function" ? se.then(R, D) : a(se) ? Promise.all(se).then(R, D) : R(se);
          };
        }
        return z(A)();
      }
      function Cs(C, A, R) {
        for (var D = a(C) ? C.slice() : [C], z = 0; z < R; ++z) D.push(A);
        return D;
      }
      var h1 = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(C) {
        return r(r({}, C), { table: function(D) {
          var R = C.table(D), D = R.schema, z = {}, $ = [];
          function q(ue, fe, le) {
            var ve = pr(ue), ce = z[ve] = z[ve] || [], we = ue == null ? 0 : typeof ue == "string" ? 1 : ue.length, _e = 0 < fe, ve = r(r({}, le), { name: _e ? "".concat(ve, "(virtual-from:").concat(le.name, ")") : le.name, lowLevelIndex: le, isVirtual: _e, keyTail: fe, keyLength: we, extractKey: pl(ue), unique: !_e && le.unique });
            return ce.push(ve), ve.isPrimaryKey || $.push(ve), 1 < we && q(we === 2 ? ue[0] : ue.slice(0, we - 1), fe + 1, le), ce.sort(function(Re, ze) {
              return Re.keyTail - ze.keyTail;
            }), ve;
          }
          var K = q(D.primaryKey.keyPath, 0, D.primaryKey);
          z[":id"] = [K];
          for (var se = 0, ye = D.indexes; se < ye.length; se++) {
            var ae = ye[se];
            q(ae.keyPath, 0, ae);
          }
          function oe(ue) {
            var fe, le = ue.query.index;
            return le.isVirtual ? r(r({}, ue), { query: { index: le.lowLevelIndex, range: (fe = ue.query.range, le = le.keyTail, { type: fe.type === 1 ? 2 : fe.type, lower: Cs(fe.lower, fe.lowerOpen ? C.MAX_KEY : C.MIN_KEY, le), lowerOpen: !0, upper: Cs(fe.upper, fe.upperOpen ? C.MIN_KEY : C.MAX_KEY, le), upperOpen: !0 }) } }) : ue;
          }
          return r(r({}, R), { schema: r(r({}, D), { primaryKey: K, indexes: $, getIndexByKeyPath: function(ue) {
            return (ue = z[pr(ue)]) && ue[0];
          } }), count: function(ue) {
            return R.count(oe(ue));
          }, query: function(ue) {
            return R.query(oe(ue));
          }, openCursor: function(ue) {
            var fe = ue.query.index, le = fe.keyTail, ce = fe.keyLength;
            return fe.isVirtual ? R.openCursor(oe(ue)).then(function(_e) {
              return _e && we(_e);
            }) : R.openCursor(ue);
            function we(_e) {
              return Object.create(_e, { continue: { value: function(ve) {
                ve != null ? _e.continue(Cs(ve, ue.reverse ? C.MAX_KEY : C.MIN_KEY, le)) : ue.unique ? _e.continue(_e.key.slice(0, ce).concat(ue.reverse ? C.MIN_KEY : C.MAX_KEY, le)) : _e.continue();
              } }, continuePrimaryKey: { value: function(ve, Re) {
                _e.continuePrimaryKey(Cs(ve, C.MAX_KEY, le), Re);
              } }, primaryKey: { get: function() {
                return _e.primaryKey;
              } }, key: { get: function() {
                var ve = _e.key;
                return ce === 1 ? ve[0] : ve.slice(0, ce);
              } }, value: { get: function() {
                return _e.value;
              } } });
            }
          } });
        } });
      } };
      function Pd(C, A, R, D) {
        return R = R || {}, D = D || "", s(C).forEach(function(z) {
          var $, q, K;
          h(A, z) ? ($ = C[z], q = A[z], typeof $ == "object" && typeof q == "object" && $ && q ? (K = ne($)) !== ne(q) ? R[D + z] = A[z] : K === "Object" ? Pd($, q, R, D + z + ".") : $ !== q && (R[D + z] = A[z]) : $ !== q && (R[D + z] = A[z])) : R[D + z] = void 0;
        }), s(A).forEach(function(z) {
          h(C, z) || (R[D + z] = A[z]);
        }), R;
      }
      function jd(C, A) {
        return A.type === "delete" ? A.keys : A.keys || A.values.map(C.extractKey);
      }
      var gy = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(C) {
        return r(r({}, C), { table: function(A) {
          var R = C.table(A), D = R.schema.primaryKey;
          return r(r({}, R), { mutate: function(z) {
            var $ = Ve.trans, q = $.table(A).hook, K = q.deleting, se = q.creating, ye = q.updating;
            switch (z.type) {
              case "add":
                if (se.fire === Ge) break;
                return $._promise("readwrite", function() {
                  return ae(z);
                }, !0);
              case "put":
                if (se.fire === Ge && ye.fire === Ge) break;
                return $._promise("readwrite", function() {
                  return ae(z);
                }, !0);
              case "delete":
                if (K.fire === Ge) break;
                return $._promise("readwrite", function() {
                  return ae(z);
                }, !0);
              case "deleteRange":
                if (K.fire === Ge) break;
                return $._promise("readwrite", function() {
                  return (function oe(ue, fe, le) {
                    return R.query({ trans: ue, values: !1, query: { index: D, range: fe }, limit: le }).then(function(ce) {
                      var we = ce.result;
                      return ae({ type: "delete", keys: we, trans: ue }).then(function(_e) {
                        return 0 < _e.numFailures ? Promise.reject(_e.failures[0]) : we.length < le ? { failures: [], numFailures: 0, lastResult: void 0 } : oe(ue, r(r({}, fe), { lower: we[we.length - 1], lowerOpen: !0 }), le);
                      });
                    });
                  })(z.trans, z.range, 1e4);
                }, !0);
            }
            return R.mutate(z);
            function ae(oe) {
              var ue, fe, le, ce = Ve.trans, we = oe.keys || jd(D, oe);
              if (we) return (oe = oe.type === "add" || oe.type === "put" ? r(r({}, oe), { keys: we }) : r({}, oe)).type !== "delete" && (oe.values = i([], oe.values)), oe.keys && (oe.keys = i([], oe.keys)), ue = R, le = we, ((fe = oe).type === "add" ? Promise.resolve([]) : ue.getMany({ trans: fe.trans, keys: le, cache: "immutable" })).then(function(_e) {
                var ve = we.map(function(Re, ze) {
                  var We, qe, Le, Xe = _e[ze], Ze = { onerror: null, onsuccess: null };
                  return oe.type === "delete" ? K.fire.call(Ze, Re, Xe, ce) : oe.type === "add" || Xe === void 0 ? (We = se.fire.call(Ze, Re, oe.values[ze], ce), Re == null && We != null && (oe.keys[ze] = Re = We, D.outbound || O(oe.values[ze], D.keyPath, Re))) : (We = Pd(Xe, oe.values[ze]), (qe = ye.fire.call(Ze, We, Re, Xe, ce)) && (Le = oe.values[ze], Object.keys(qe).forEach(function(Be) {
                    h(Le, Be) ? Le[Be] = qe[Be] : O(Le, Be, qe[Be]);
                  }))), Ze;
                });
                return R.mutate(oe).then(function(Re) {
                  for (var ze = Re.failures, We = Re.results, qe = Re.numFailures, Re = Re.lastResult, Le = 0; Le < we.length; ++Le) {
                    var Xe = (We || we)[Le], Ze = ve[Le];
                    Xe == null ? Ze.onerror && Ze.onerror(ze[Le]) : Ze.onsuccess && Ze.onsuccess(oe.type === "put" && _e[Le] ? oe.values[Le] : Xe);
                  }
                  return { failures: ze, results: We, numFailures: qe, lastResult: Re };
                }).catch(function(Re) {
                  return ve.forEach(function(ze) {
                    return ze.onerror && ze.onerror(Re);
                  }), Promise.reject(Re);
                });
              });
              throw new Error("Keys missing");
            }
          } });
        } });
      } };
      function lp(C, A, R) {
        try {
          if (!A || A.keys.length < C.length) return null;
          for (var D = [], z = 0, $ = 0; z < A.keys.length && $ < C.length; ++z) Pt(A.keys[z], C[$]) === 0 && (D.push(R ? he(A.values[z]) : A.values[z]), ++$);
          return D.length === C.length ? D : null;
        } catch {
          return null;
        }
      }
      var yy = { stack: "dbcore", level: -1, create: function(C) {
        return { table: function(A) {
          var R = C.table(A);
          return r(r({}, R), { getMany: function(D) {
            var z;
            return D.cache ? (z = lp(D.keys, D.trans._cache, D.cache === "clone")) ? Ke.resolve(z) : R.getMany(D).then(function($) {
              return D.trans._cache = { keys: D.keys, values: D.cache === "clone" ? he($) : $ }, $;
            }) : R.getMany(D);
          }, mutate: function(D) {
            return D.type !== "add" && (D.trans._cache = null), R.mutate(D);
          } });
        } };
      } };
      function ma(C, A) {
        return C.trans.mode === "readonly" && !!C.subscr && !C.trans.explicit && C.trans.db._options.cache !== "disabled" && !A.schema.primaryKey.outbound;
      }
      function vy(C, A) {
        switch (C) {
          case "query":
            return A.values && !A.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var p1 = { stack: "dbcore", level: 0, name: "Observability", create: function(C) {
        var A = C.schema.name, R = new zr(C.MIN_KEY, C.MAX_KEY);
        return r(r({}, C), { transaction: function(D, z, $) {
          if (Ve.subscr && z !== "readonly") throw new Ae.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(Ve.querier));
          return C.transaction(D, z, $);
        }, table: function(D) {
          function z(we) {
            var ce, we = we.query;
            return [ce = we.index, new zr((ce = (we = we.range).lower) != null ? ce : C.MIN_KEY, (ce = we.upper) != null ? ce : C.MAX_KEY)];
          }
          var $ = C.table(D), q = $.schema, K = q.primaryKey, se = q.indexes, ye = K.extractKey, ae = K.outbound, oe = K.autoIncrement && se.filter(function(le) {
            return le.compound && le.keyPath.includes(K.keyPath);
          }), ue = r(r({}, $), { mutate: function(le) {
            function ce(Je) {
              return Je = "idb://".concat(A, "/").concat(D, "/").concat(Je), ze[Je] || (ze[Je] = new zr());
            }
            var we, _e, ve, Re = le.trans, ze = le.mutatedParts || (le.mutatedParts = {}), We = ce(""), qe = ce(":dels"), Le = le.type, Ze = le.type === "deleteRange" ? [le.range] : le.type === "delete" ? [le.keys] : le.values.length < 50 ? [jd(K, le).filter(function(Je) {
              return Je;
            }), le.values] : [], Xe = Ze[0], Ze = Ze[1], Be = le.trans._cache;
            return a(Xe) ? (We.addKeys(Xe), (Le = Le === "delete" || Xe.length === Ze.length ? lp(Xe, Be) : null) || qe.addKeys(Xe), (Le || Ze) && (we = ce, _e = Le, ve = Ze, q.indexes.forEach(function(Je) {
              var wt = we(Je.name || "");
              function Bt(Tt) {
                return Tt != null ? Je.extractKey(Tt) : null;
              }
              function dt(Tt) {
                Je.multiEntry && a(Tt) ? Tt.forEach(function(bn) {
                  return wt.addKey(bn);
                }) : wt.addKey(Tt);
              }
              (_e || ve).forEach(function(Tt, un) {
                var ci = _e && Bt(_e[un]), un = ve && Bt(ve[un]);
                Pt(ci, un) !== 0 && (ci != null && dt(ci), un != null) && dt(un);
              });
            }))) : Xe ? (Ze = { from: (Be = Xe.lower) != null ? Be : C.MIN_KEY, to: (Le = Xe.upper) != null ? Le : C.MAX_KEY }, qe.add(Ze), We.add(Ze)) : (We.add(R), qe.add(R), q.indexes.forEach(function(Je) {
              return ce(Je.name).add(R);
            })), $.mutate(le).then(function(Je) {
              return !Xe || le.type !== "add" && le.type !== "put" || (We.addKeys(Je.results), oe && oe.forEach(function(wt) {
                for (var Bt = le.values.map(function(ci) {
                  return wt.extractKey(ci);
                }), dt = wt.keyPath.findIndex(function(ci) {
                  return ci === K.keyPath;
                }), Tt = 0, bn = Je.results.length; Tt < bn; ++Tt) Bt[Tt][dt] = Je.results[Tt];
                ce(wt.name).addKeys(Bt);
              })), Re.mutatedParts = Od(Re.mutatedParts || {}, ze), Je;
            });
          } }), fe = { get: function(le) {
            return [K, new zr(le.key)];
          }, getMany: function(le) {
            return [K, new zr().addKeys(le.keys)];
          }, count: z, query: z, openCursor: z };
          return s(fe).forEach(function(le) {
            ue[le] = function(ce) {
              var we = Ve.subscr, _e = !!we, ve = ma(Ve, $) && vy(le, ce) ? ce.obsSet = {} : we;
              if (_e) {
                var Re, we = function(Ze) {
                  return Ze = "idb://".concat(A, "/").concat(D, "/").concat(Ze), ve[Ze] || (ve[Ze] = new zr());
                }, ze = we(""), We = we(":dels"), _e = fe[le](ce), qe = _e[0], _e = _e[1];
                if ((le === "query" && qe.isPrimaryKey && !ce.values ? We : we(qe.name || "")).add(_e), !qe.isPrimaryKey) {
                  if (le !== "count") return Re = le === "query" && ae && ce.values && $.query(r(r({}, ce), { values: !1 })), $[le].apply(this, arguments).then(function(Ze) {
                    if (le === "query") {
                      if (ae && ce.values) return Re.then(function(Bt) {
                        return Bt = Bt.result, ze.addKeys(Bt), Ze;
                      });
                      var Be = ce.values ? Ze.result.map(ye) : Ze.result;
                      (ce.values ? ze : We).addKeys(Be);
                    } else {
                      var Je, wt;
                      if (le === "openCursor") return wt = ce.values, (Je = Ze) && Object.create(Je, { key: { get: function() {
                        return We.addKey(Je.primaryKey), Je.key;
                      } }, primaryKey: { get: function() {
                        var Bt = Je.primaryKey;
                        return We.addKey(Bt), Bt;
                      } }, value: { get: function() {
                        return wt && ze.addKey(Je.primaryKey), Je.value;
                      } } });
                    }
                    return Ze;
                  });
                  We.add(R);
                }
              }
              return $[le].apply(this, arguments);
            };
          }), ue;
        } });
      } };
      function by(C, A, R) {
        var D;
        return R.numFailures === 0 ? A : A.type === "deleteRange" || (D = A.keys ? A.keys.length : "values" in A && A.values ? A.values.length : 1, R.numFailures === D) ? null : (D = r({}, A), a(D.keys) && (D.keys = D.keys.filter(function(z, $) {
          return !($ in R.failures);
        })), "values" in D && a(D.values) && (D.values = D.values.filter(function(z, $) {
          return !($ in R.failures);
        })), D);
      }
      function Id(C, A) {
        return R = C, ((D = A).lower === void 0 || (D.lowerOpen ? 0 < Pt(R, D.lower) : 0 <= Pt(R, D.lower))) && (R = C, (D = A).upper === void 0 || (D.upperOpen ? Pt(R, D.upper) < 0 : Pt(R, D.upper) <= 0));
        var R, D;
      }
      function cp(C, A, R, D, z, $) {
        var q, K, se, ye, ae, oe;
        return !R || R.length === 0 || (q = A.query.index, K = q.multiEntry, se = A.query.range, ye = D.schema.primaryKey.extractKey, ae = q.extractKey, oe = (q.lowLevelIndex || q).extractKey, (D = R.reduce(function(ue, fe) {
          var le = ue, ce = [];
          if (fe.type === "add" || fe.type === "put") for (var we = new zr(), _e = fe.values.length - 1; 0 <= _e; --_e) {
            var ve, Re = fe.values[_e], ze = ye(Re);
            !we.hasKey(ze) && (ve = ae(Re), K && a(ve) ? ve.some(function(Ze) {
              return Id(Ze, se);
            }) : Id(ve, se)) && (we.addKey(ze), ce.push(Re));
          }
          switch (fe.type) {
            case "add":
              var We = new zr().addKeys(A.values ? ue.map(function(Be) {
                return ye(Be);
              }) : ue), le = ue.concat(A.values ? ce.filter(function(Be) {
                return Be = ye(Be), !We.hasKey(Be) && (We.addKey(Be), !0);
              }) : ce.map(function(Be) {
                return ye(Be);
              }).filter(function(Be) {
                return !We.hasKey(Be) && (We.addKey(Be), !0);
              }));
              break;
            case "put":
              var qe = new zr().addKeys(fe.values.map(function(Be) {
                return ye(Be);
              }));
              le = ue.filter(function(Be) {
                return !qe.hasKey(A.values ? ye(Be) : Be);
              }).concat(A.values ? ce : ce.map(function(Be) {
                return ye(Be);
              }));
              break;
            case "delete":
              var Le = new zr().addKeys(fe.keys);
              le = ue.filter(function(Be) {
                return !Le.hasKey(A.values ? ye(Be) : Be);
              });
              break;
            case "deleteRange":
              var Xe = fe.range;
              le = ue.filter(function(Be) {
                return !Id(ye(Be), Xe);
              });
          }
          return le;
        }, C)) === C) ? C : (D.sort(function(ue, fe) {
          return Pt(oe(ue), oe(fe)) || Pt(ye(ue), ye(fe));
        }), A.limit && A.limit < 1 / 0 && (D.length > A.limit ? D.length = A.limit : C.length === A.limit && D.length < A.limit && (z.dirty = !0)), $ ? Object.freeze(D) : D);
      }
      function yl(C, A) {
        return Pt(C.lower, A.lower) === 0 && Pt(C.upper, A.upper) === 0 && !!C.lowerOpen == !!A.lowerOpen && !!C.upperOpen == !!A.upperOpen;
      }
      function lu(C, A) {
        return ((R, D, z, $) => {
          if (R === void 0) return D !== void 0 ? -1 : 0;
          if (D === void 0) return 1;
          if ((R = Pt(R, D)) === 0) {
            if (z && $) return 0;
            if (z) return 1;
            if ($) return -1;
          }
          return R;
        })(C.lower, A.lower, C.lowerOpen, A.lowerOpen) <= 0 && 0 <= ((R, D, z, $) => {
          if (R === void 0) return D !== void 0 ? 1 : 0;
          if (D === void 0) return -1;
          if ((R = Pt(R, D)) === 0) {
            if (z && $) return 0;
            if (z) return -1;
            if ($) return 1;
          }
          return R;
        })(C.upper, A.upper, C.upperOpen, A.upperOpen);
      }
      function m1(C, A, R, D) {
        C.subscribers.add(R), D.addEventListener("abort", function() {
          var z, $;
          C.subscribers.delete(R), C.subscribers.size === 0 && (z = C, $ = A, setTimeout(function() {
            z.subscribers.size === 0 && X($, z);
          }, 3e3));
        });
      }
      var zd = { stack: "dbcore", level: 0, name: "Cache", create: function(C) {
        var A = C.schema.name;
        return r(r({}, C), { transaction: function(R, D, z) {
          var $, q, K = C.transaction(R, D, z);
          return D === "readwrite" && (z = ($ = new AbortController()).signal, K.addEventListener("abort", (q = function(se) {
            return function() {
              if ($.abort(), D === "readwrite") {
                for (var ye = /* @__PURE__ */ new Set(), ae = 0, oe = R; ae < oe.length; ae++) {
                  var ue = oe[ae], fe = pa["idb://".concat(A, "/").concat(ue)];
                  if (fe) {
                    var le = C.table(ue), ce = fe.optimisticOps.filter(function(Je) {
                      return Je.trans === K;
                    });
                    if (K._explicit && se && K.mutatedParts) for (var we = 0, _e = Object.values(fe.queries.query); we < _e.length; we++) for (var ve = 0, Re = (qe = _e[we]).slice(); ve < Re.length; ve++) ip((Le = Re[ve]).obsSet, K.mutatedParts) && (X(qe, Le), Le.subscribers.forEach(function(Je) {
                      return ye.add(Je);
                    }));
                    else if (0 < ce.length) {
                      fe.optimisticOps = fe.optimisticOps.filter(function(Je) {
                        return Je.trans !== K;
                      });
                      for (var ze = 0, We = Object.values(fe.queries.query); ze < We.length; ze++) for (var qe, Le, Xe, Ze = 0, Be = (qe = We[ze]).slice(); Ze < Be.length; Ze++) (Le = Be[Ze]).res != null && K.mutatedParts && (se && !Le.dirty ? (Xe = Object.isFrozen(Le.res), Xe = cp(Le.res, Le.req, ce, le, Le, Xe), Le.dirty ? (X(qe, Le), Le.subscribers.forEach(function(Je) {
                        return ye.add(Je);
                      })) : Xe !== Le.res && (Le.res = Xe, Le.promise = Ke.resolve({ result: Xe }))) : (Le.dirty && X(qe, Le), Le.subscribers.forEach(function(Je) {
                        return ye.add(Je);
                      })));
                    }
                  }
                }
                ye.forEach(function(Je) {
                  return Je();
                });
              }
            };
          })(!1), { signal: z }), K.addEventListener("error", q(!1), { signal: z }), K.addEventListener("complete", q(!0), { signal: z })), K;
        }, table: function(R) {
          var D = C.table(R), z = D.schema.primaryKey;
          return r(r({}, D), { mutate: function($) {
            var q, K = Ve.trans;
            return !z.outbound && K.db._options.cache !== "disabled" && !K.explicit && K.idbtrans.mode === "readwrite" && (q = pa["idb://".concat(A, "/").concat(R)]) ? (K = D.mutate($), $.type !== "add" && $.type !== "put" || !(50 <= $.values.length || jd(z, $).some(function(se) {
              return se == null;
            })) ? (q.optimisticOps.push($), $.mutatedParts && Dd($.mutatedParts), K.then(function(se) {
              0 < se.numFailures && (X(q.optimisticOps, $), (se = by(0, $, se)) && q.optimisticOps.push(se), $.mutatedParts) && Dd($.mutatedParts);
            }), K.catch(function() {
              X(q.optimisticOps, $), $.mutatedParts && Dd($.mutatedParts);
            })) : K.then(function(se) {
              var ye = by(0, r(r({}, $), { values: $.values.map(function(ae, oe) {
                var ue;
                return se.failures[oe] ? ae : (O(ue = (ue = z.keyPath) != null && ue.includes(".") ? he(ae) : r({}, ae), z.keyPath, se.results[oe]), ue);
              }) }), se);
              q.optimisticOps.push(ye), queueMicrotask(function() {
                return $.mutatedParts && Dd($.mutatedParts);
              });
            }), K) : D.mutate($);
          }, query: function($) {
            var q, K, se, ye, ae, oe, ue;
            return ma(Ve, D) && vy("query", $) ? (q = ((se = Ve.trans) == null ? void 0 : se.db._options.cache) === "immutable", K = (se = Ve).requery, se = se.signal, oe = ((fe, le, ce, we) => {
              var _e = pa["idb://".concat(fe, "/").concat(le)];
              if (!_e) return [];
              if (!(fe = _e.queries[ce])) return [null, !1, _e, null];
              var ve = fe[(we.query ? we.query.index.name : null) || ""];
              if (!ve) return [null, !1, _e, null];
              switch (ce) {
                case "query":
                  var Re = ve.find(function(ze) {
                    return ze.req.limit === we.limit && ze.req.values === we.values && yl(ze.req.query.range, we.query.range);
                  });
                  return Re ? [Re, !0, _e, ve] : [ve.find(function(ze) {
                    return ("limit" in ze.req ? ze.req.limit : 1 / 0) >= we.limit && (!we.values || ze.req.values) && lu(ze.req.query.range, we.query.range);
                  }), !1, _e, ve];
                case "count":
                  return Re = ve.find(function(ze) {
                    return yl(ze.req.query.range, we.query.range);
                  }), [Re, !!Re, _e, ve];
              }
            })(A, R, "query", $), ue = oe[0], ye = oe[2], ae = oe[3], ue && oe[1] ? ue.obsSet = $.obsSet : (oe = D.query($).then(function(fe) {
              var le = fe.result;
              if (ue && (ue.res = le), q) {
                for (var ce = 0, we = le.length; ce < we; ++ce) Object.freeze(le[ce]);
                Object.freeze(le);
              } else fe.result = he(le);
              return fe;
            }).catch(function(fe) {
              return ae && ue && X(ae, ue), Promise.reject(fe);
            }), ue = { obsSet: $.obsSet, promise: oe, subscribers: /* @__PURE__ */ new Set(), type: "query", req: $, dirty: !1 }, ae ? ae.push(ue) : (ae = [ue], (ye = ye || (pa["idb://".concat(A, "/").concat(R)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[$.query.index.name || ""] = ae)), m1(ue, ae, K, se), ue.promise.then(function(fe) {
              return { result: cp(fe.result, $, ye?.optimisticOps, D, ue, q) };
            })) : D.query($);
          } });
        } });
      } };
      function cu(C, A) {
        return new Proxy(C, { get: function(R, D, z) {
          return D === "db" ? A : Reflect.get(R, D, z);
        } });
      }
      zn.prototype.version = function(C) {
        if (isNaN(C) || C < 0.1) throw new Ae.Type("Given version is not a positive number");
        if (C = Math.round(10 * C) / 10, this.idbdb || this._state.isBeingOpened) throw new Ae.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, C);
        var A = this._versions, R = A.filter(function(D) {
          return D._cfg.version === C;
        })[0];
        return R || (R = new this.Version(C), A.push(R), A.sort(Jh), R.stores({}), this._state.autoSchema = !1), R;
      }, zn.prototype._whenReady = function(C) {
        var A = this;
        return this.idbdb && (this._state.openComplete || Ve.letThrough || this._vip) ? C() : new Ke(function(R, D) {
          if (A._state.openComplete) return D(new Ae.DatabaseClosed(A._state.dbOpenError));
          if (!A._state.isBeingOpened) {
            if (!A._state.autoOpen) return void D(new Ae.DatabaseClosed());
            A.open().catch(Ge);
          }
          A._state.dbReadyPromise.then(R, D);
        }).then(C);
      }, zn.prototype.use = function(z) {
        var A = z.stack, R = z.create, D = z.level, z = z.name, $ = (z && this.unuse({ stack: A, name: z }), this._middlewares[A] || (this._middlewares[A] = []));
        return $.push({ stack: A, create: R, level: D ?? 10, name: z }), $.sort(function(q, K) {
          return q.level - K.level;
        }), this;
      }, zn.prototype.unuse = function(C) {
        var A = C.stack, R = C.name, D = C.create;
        return A && this._middlewares[A] && (this._middlewares[A] = this._middlewares[A].filter(function(z) {
          return D ? z.create !== D : !!R && z.name !== R;
        })), this;
      }, zn.prototype.open = function() {
        var C = this;
        return Xi(jn, function() {
          return f1(C);
        });
      }, zn.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var C = this._state, A = sa.indexOf(this);
        if (0 <= A && sa.splice(A, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        C.isBeingOpened || (C.dbReadyPromise = new Ke(function(R) {
          C.dbReadyResolve = R;
        }), C.openCanceller = new Ke(function(R, D) {
          C.cancelOpen = D;
        }));
      }, zn.prototype.close = function(A) {
        var A = (A === void 0 ? { disableAutoOpen: !0 } : A).disableAutoOpen, R = this._state;
        A ? (R.isBeingOpened && R.cancelOpen(new Ae.DatabaseClosed()), this._close(), R.autoOpen = !1, R.dbOpenError = new Ae.DatabaseClosed()) : (this._close(), R.autoOpen = this._options.autoOpen || R.isBeingOpened, R.openComplete = !1, R.dbOpenError = null);
      }, zn.prototype.delete = function(C) {
        var A = this, R = (C === void 0 && (C = { disableAutoOpen: !0 }), 0 < arguments.length && typeof arguments[0] != "object"), D = this._state;
        return new Ke(function(z, $) {
          function q() {
            A.close(C);
            var K = A._deps.indexedDB.deleteDatabase(A.name);
            K.onsuccess = kn(function() {
              var se, ye, ae;
              se = A._deps, ye = A.name, Nd(ae = se.indexedDB) || ye === Xc || ep(ae, se.IDBKeyRange).delete(ye).catch(Ge), z();
            }), K.onerror = Qi($), K.onblocked = A._fireOnBlocked;
          }
          if (R) throw new Ae.InvalidArgument("Invalid closeOptions argument to db.delete()");
          D.isBeingOpened ? D.dbReadyPromise.then(q) : q();
        });
      }, zn.prototype.backendDB = function() {
        return this.idbdb;
      }, zn.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, zn.prototype.hasBeenClosed = function() {
        var C = this._state.dbOpenError;
        return C && C.name === "DatabaseClosed";
      }, zn.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, zn.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(zn.prototype, "tables", { get: function() {
        var C = this;
        return s(this._allTables).map(function(A) {
          return C._allTables[A];
        });
      }, enumerable: !1, configurable: !0 }), zn.prototype.transaction = function() {
        var C = (function(A, R, D) {
          var z = arguments.length;
          if (z < 2) throw new Ae.InvalidArgument("Too few arguments");
          for (var $ = new Array(z - 1); --z; ) $[z - 1] = arguments[z];
          return D = $.pop(), [A, B($), D];
        }).apply(this, arguments);
        return this._transaction.apply(this, C);
      }, zn.prototype._transaction = function(C, A, R) {
        var D, z, $ = this, q = Ve.trans, K = (q && q.db === this && C.indexOf("!") === -1 || (q = null), C.indexOf("?") !== -1);
        C = C.replace("!", "").replace("?", "");
        try {
          if (z = A.map(function(ye) {
            if (ye = ye instanceof $.Table ? ye.name : ye, typeof ye != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return ye;
          }), C == "r" || C === Zo) D = Zo;
          else {
            if (C != "rw" && C != ws) throw new Ae.InvalidArgument("Invalid transaction mode: " + C);
            D = ws;
          }
          if (q) {
            if (q.mode === Zo && D === ws) {
              if (!K) throw new Ae.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              q = null;
            }
            q && z.forEach(function(ye) {
              if (q && q.storeNames.indexOf(ye) === -1) {
                if (!K) throw new Ae.SubTransaction("Table " + ye + " not included in parent transaction.");
                q = null;
              }
            }), K && q && !q.active && (q = null);
          }
        } catch (ye) {
          return q ? q._promise(null, function(ae, oe) {
            oe(ye);
          }) : vn(ye);
        }
        var se = (function ye(ae, oe, ue, fe, le) {
          return Ke.resolve().then(function() {
            var ve = Ve.transless || Ve, ce = ae._createTransaction(oe, ue, ae._dbSchema, fe), ve = (ce.explicit = !0, { trans: ce, transless: ve });
            if (fe) ce.idbtrans = fe.idbtrans;
            else try {
              ce.create(), ce.idbtrans._explicit = !0, ae._state.PR1398_maxLoop = 3;
            } catch (Re) {
              return Re.name === xe.InvalidState && ae.isOpen() && 0 < --ae._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), ae.close({ disableAutoOpen: !1 }), ae.open().then(function() {
                return ye(ae, oe, ue, null, le);
              })) : vn(Re);
            }
            var we, _e = Z(le), ve = (_e && ar(), Ke.follow(function() {
              var Re;
              (we = le.call(ce, ce)) && (_e ? (Re = wi.bind(null, null), we.then(Re, Re)) : typeof we.next == "function" && typeof we.throw == "function" && (we = au(we)));
            }, ve));
            return (we && typeof we.then == "function" ? Ke.resolve(we).then(function(Re) {
              return ce.active ? Re : vn(new Ae.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : ve.then(function() {
              return we;
            })).then(function(Re) {
              return fe && ce._resolve(), ce._completion.then(function() {
                return Re;
              });
            }).catch(function(Re) {
              return ce._reject(Re), vn(Re);
            });
          });
        }).bind(null, this, D, z, q, R);
        return q ? q._promise(D, se, "lock") : Ve.trans ? Xi(Ve.transless, function() {
          return $._whenReady(se);
        }) : this._whenReady(se);
      }, zn.prototype.table = function(C) {
        if (h(this._allTables, C)) return this._allTables[C];
        throw new Ae.InvalidTable("Table ".concat(C, " does not exist"));
      };
      var wo = zn;
      function zn(C, A) {
        var R, D, z, $, q, K = this, se = (this._middlewares = {}, this.verno = 0, zn.dependencies), se = (this._options = A = r({ addons: zn.addons, autoOpen: !0, indexedDB: se.indexedDB, IDBKeyRange: se.IDBKeyRange, cache: "cloned" }, A), this._deps = { indexedDB: A.indexedDB, IDBKeyRange: A.IDBKeyRange }, A.addons), ye = (this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this, { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Ge, dbReadyPromise: null, cancelOpen: Ge, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: A.autoOpen }), ae = (ye.dbReadyPromise = new Ke(function(oe) {
          ye.dbReadyResolve = oe;
        }), ye.openCanceller = new Ke(function(oe, ue) {
          ye.cancelOpen = ue;
        }), this._state = ye, this.name = C, this.on = eu(this, "populate", "blocked", "versionchange", "close", { ready: [An, Ge] }), this.once = function(oe, ue) {
          var fe = function() {
            for (var le = [], ce = 0; ce < arguments.length; ce++) le[ce] = arguments[ce];
            K.on(oe).unsubscribe(fe), ue.apply(K, le);
          };
          return K.on(oe, fe);
        }, this.on.ready.subscribe = M(this.on.ready.subscribe, function(oe) {
          return function(ue, fe) {
            zn.vip(function() {
              var le, ce = K._state;
              ce.openComplete ? (ce.dbOpenError || Ke.resolve().then(ue), fe && oe(ue)) : ce.onReadyBeingFired ? (ce.onReadyBeingFired.push(ue), fe && oe(ue)) : (oe(ue), le = K, fe || oe(function we() {
                le.on.ready.unsubscribe(ue), le.on.ready.unsubscribe(we);
              }));
            });
          };
        }), this.Collection = (R = this, jr(c1.prototype, function(we, ce) {
          this.db = R;
          var fe = qh, le = null;
          if (ce) try {
            fe = ce();
          } catch (ve) {
            le = ve;
          }
          var ce = we._ctx, we = ce.table, _e = we.hook.reading.fire;
          this._ctx = { table: we, index: ce.index, isPrimKey: !ce.index || we.schema.primKey.keyPath && ce.index === we.schema.primKey.name, range: fe, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: le, or: ce.or, valueMapper: _e !== nt ? _e : null };
        })), this.Table = (D = this, jr(Gh.prototype, function(oe, ue, fe) {
          this.db = D, this._tx = fe, this.name = oe, this.schema = ue, this.hook = D._allTables[oe] ? D._allTables[oe].hook : eu(null, { creating: [St, Ge], reading: [_t, nt], updating: [xt, Ge], deleting: [Vt, Ge] });
        })), this.Transaction = (z = this, jr(Xh.prototype, function(oe, ue, fe, le, ce) {
          var we = this;
          oe !== "readonly" && ue.forEach(function(_e) {
            _e = (_e = fe[_e]) == null ? void 0 : _e.yProps, _e && (ue = ue.concat(_e.map(function(ve) {
              return ve.updatesTable;
            })));
          }), this.db = z, this.mode = oe, this.storeNames = ue, this.schema = fe, this.chromeTransactionDurability = le, this.idbtrans = null, this.on = eu(this, "complete", "error", "abort"), this.parent = ce || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Ke(function(_e, ve) {
            we._resolve = _e, we._reject = ve;
          }), this._completion.then(function() {
            we.active = !1, we.on.complete.fire();
          }, function(_e) {
            var ve = we.active;
            return we.active = !1, we.on.error.fire(_e), we.parent ? we.parent._reject(_e) : ve && we.idbtrans && we.idbtrans.abort(), vn(_e);
          });
        })), this.Version = ($ = this, jr(d1.prototype, function(oe) {
          this.db = $, this._cfg = { version: oe, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (q = this, jr(ca.prototype, function(oe, ue, fe) {
          if (this.db = q, this._ctx = { table: oe, index: ue === ":id" ? null : ue, or: fe }, this._cmp = this._ascending = Pt, this._descending = function(le, ce) {
            return Pt(ce, le);
          }, this._max = function(le, ce) {
            return 0 < Pt(le, ce) ? le : ce;
          }, this._min = function(le, ce) {
            return Pt(le, ce) < 0 ? le : ce;
          }, this._IDBKeyRange = q._deps.IDBKeyRange, !this._IDBKeyRange) throw new Ae.MissingAPI();
        })), this.on("versionchange", function(oe) {
          0 < oe.newVersion ? console.warn("Another connection wants to upgrade database '".concat(K.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(K.name, "'. Closing db now to resume the delete request.")), K.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(oe) {
          !oe.newVersion || oe.newVersion < oe.oldVersion ? console.warn("Dexie.delete('".concat(K.name, "') was blocked")) : console.warn("Upgrade '".concat(K.name, "' blocked by other connection holding version ").concat(oe.oldVersion / 10));
        }), this._maxKey = hl(A.IDBKeyRange), this._createTransaction = function(oe, ue, fe, le) {
          return new K.Transaction(oe, ue, fe, K._options.chromeTransactionDurability, le);
        }, this._fireOnBlocked = function(oe) {
          K.on("blocked").fire(oe), sa.filter(function(ue) {
            return ue.name === K.name && ue !== K && !ue._state.vcFired;
          }).map(function(ue) {
            return ue.on("versionchange").fire(oe);
          });
        }, this.use(yy), this.use(zd), this.use(p1), this.use(h1), this.use(gy), new Proxy(this, { get: function(oe, ue, fe) {
          var le;
          return ue === "_vip" || (ue === "table" ? function(ce) {
            return cu(K.table(ce), ae);
          } : (le = Reflect.get(oe, ue, fe)) instanceof Gh ? cu(le, ae) : ue === "tables" ? le.map(function(ce) {
            return cu(ce, ae);
          }) : ue === "_createTransaction" ? function() {
            return cu(le.apply(this, arguments), ae);
          } : le);
        } }));
        this.vip = ae, se.forEach(function(oe) {
          return oe(K);
        });
      }
      var vl, ga = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", xy = (Ld.prototype.subscribe = function(C, A, R) {
        return this._subscribe(C && typeof C != "function" ? C : { next: C, error: A, complete: R });
      }, Ld.prototype[ga] = function() {
        return this;
      }, Ld);
      function Ld(C) {
        this._subscribe = C;
      }
      try {
        vl = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        vl = { indexedDB: null, IDBKeyRange: null };
      }
      function wy(C) {
        var A, R = !1, D = new xy(function(z) {
          var $ = Z(C), q, K = !1, se = {}, ye = {}, ae = { get closed() {
            return K;
          }, unsubscribe: function() {
            K || (K = !0, q && q.abort(), oe && Ir.storagemutated.unsubscribe(fe));
          } }, oe = (z.start && z.start(ae), !1), ue = function() {
            return xs(le);
          }, fe = function(ce) {
            Od(se, ce), ip(ye, se) && ue();
          }, le = function() {
            var ce, we, _e;
            !K && vl.indexedDB && (se = {}, ce = {}, q && q.abort(), q = new AbortController(), _e = ((ve) => {
              var Re = ys();
              try {
                $ && ar();
                var ze = Nn(C, ve);
                return ze = $ ? ze.finally(wi) : ze;
              } finally {
                Re && yo();
              }
            })(we = { subscr: ce, signal: q.signal, requery: ue, querier: C, trans: null }), Promise.resolve(_e).then(function(ve) {
              R = !0, A = ve, K || we.signal.aborted || (se = {}, ((Re) => {
                for (var ze in Re) if (h(Re, ze)) return;
                return 1;
              })(ye = ce) || oe || (Ir(dl, fe), oe = !0), xs(function() {
                return !K && z.next && z.next(ve);
              }));
            }, function(ve) {
              R = !1, ["DatabaseClosedError", "AbortError"].includes(ve?.name) || K || xs(function() {
                K || z.error && z.error(ve);
              });
            }));
          };
          return setTimeout(ue, 0), ae;
        });
        return D.hasValue = function() {
          return R;
        }, D.getValue = function() {
          return A;
        }, D;
      }
      var ya = wo;
      function up(C) {
        var A = Es;
        try {
          Es = !0, Ir.storagemutated.fire(C), ap(C, !0);
        } finally {
          Es = A;
        }
      }
      m(ya, r(r({}, pe), { delete: function(C) {
        return new ya(C, { addons: [] }).delete();
      }, exists: function(C) {
        return new ya(C, { addons: [] }).open().then(function(A) {
          return A.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(C) {
        try {
          return A = ya.dependencies, R = A.indexedDB, A = A.IDBKeyRange, (Nd(R) ? Promise.resolve(R.databases()).then(function(D) {
            return D.map(function(z) {
              return z.name;
            }).filter(function(z) {
              return z !== Xc;
            });
          }) : ep(R, A).toCollection().primaryKeys()).then(C);
        } catch {
          return vn(new Ae.MissingAPI());
        }
        var A, R;
      }, defineClass: function() {
        return function(C) {
          c(this, C);
        };
      }, ignoreTransaction: function(C) {
        return Ve.trans ? Xi(Ve.transless, C) : C();
      }, vip: tp, async: function(C) {
        return function() {
          try {
            var A = au(C.apply(this, arguments));
            return A && typeof A.then == "function" ? A : Ke.resolve(A);
          } catch (R) {
            return vn(R);
          }
        };
      }, spawn: function(C, A, R) {
        try {
          var D = au(C.apply(R, A || []));
          return D && typeof D.then == "function" ? D : Ke.resolve(D);
        } catch (z) {
          return vn(z);
        }
      }, currentTransaction: { get: function() {
        return Ve.trans || null;
      } }, waitFor: function(C, A) {
        return C = Ke.resolve(typeof C == "function" ? ya.ignoreTransaction(C) : C).timeout(A || 6e4), Ve.trans ? Ve.trans.waitFor(C) : C;
      }, Promise: Ke, debug: { get: function() {
        return Nt;
      }, set: function(C) {
        sn(C);
      } }, derive: x, extend: c, props: m, override: M, Events: eu, on: Ir, liveQuery: wy, extendObservabilitySet: Od, getByKeyPath: I, setByKeyPath: O, delByKeyPath: function(C, A) {
        typeof A == "string" ? O(C, A, void 0) : "length" in A && [].map.call(A, function(R) {
          O(C, R, void 0);
        });
      }, shallowClone: L, deepClone: he, getObjectDiff: Pd, cmp: Pt, asap: P, minKey: -1 / 0, addons: [], connections: sa, errnames: xe, dependencies: vl, cache: pa, semVer: "4.3.0", version: "4.3.0".split(".").map(function(C) {
        return parseInt(C);
      }).reduce(function(C, A, R) {
        return C + A / Math.pow(10, 2 * R);
      }) })), ya.maxKey = hl(ya.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Ir(dl, function(C) {
        Es || (C = new CustomEvent(da, { detail: C }), Es = !0, dispatchEvent(C), Es = !1);
      }), addEventListener(da, function(C) {
        C = C.detail, Es || up(C);
      }));
      var bl, Es = !1, li = function() {
      };
      return typeof BroadcastChannel < "u" && ((li = function() {
        (bl = new BroadcastChannel(da)).onmessage = function(C) {
          return C.data && up(C.data);
        };
      })(), typeof bl.unref == "function" && bl.unref(), Ir(dl, function(C) {
        Es || bl.postMessage(C);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(C) {
        if (!wo.disableBfCache && C.persisted) {
          Nt && console.debug("Dexie: handling persisted pagehide"), bl?.close();
          for (var A = 0, R = sa; A < R.length; A++) R[A].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(C) {
        !wo.disableBfCache && C.persisted && (Nt && console.debug("Dexie: handling persisted pageshow"), li(), up({ all: new zr(-1 / 0, [[]]) }));
      })), Ke.rejectionMapper = function(C, A) {
        return !C || C instanceof ee || C instanceof TypeError || C instanceof SyntaxError || !C.name || !tt[C.name] ? C : (A = new tt[C.name](A || C.message, C), "stack" in C && b(A, "stack", { get: function() {
          return this.inner.stack;
        } }), A);
      }, sn(Nt), r(wo, Object.freeze({ __proto__: null, Dexie: wo, Entity: ly, PropModification: ul, RangeSet: zr, add: function(C) {
        return new ul({ add: C });
      }, cmp: Pt, default: wo, liveQuery: wy, mergeRanges: ha, rangesOverlap: hy, remove: function(C) {
        return new ul({ remove: C });
      }, replacePrefix: function(C, A) {
        return new ul({ replacePrefix: [C, A] });
      } }), { default: wo }), wo;
    });
  })(_0)), _0.exports;
}
var _pe = Epe();
const k_ = /* @__PURE__ */ Pc(_pe), eI = /* @__PURE__ */ Symbol.for("Dexie"), uc = globalThis[eI] || (globalThis[eI] = k_);
if (k_.semVer !== uc.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${k_.semVer} and ${uc.semVer}`);
const {
  liveQuery: DLe,
  mergeRanges: PLe,
  rangesOverlap: jLe,
  RangeSet: ILe,
  cmp: zLe,
  Entity: LLe,
  PropModification: BLe,
  replacePrefix: $Le,
  add: ULe,
  remove: FLe,
  DexieYProvider: VLe
} = uc;
class Tpe extends uc {
  messages;
  threads;
  constructor() {
    super("ChatbotDB"), this.version(1).stores({
      messages: "id, threadId, createdAt, [threadId+createdAt]",
      threads: "id, lastMessageAt"
    });
  }
}
const Vi = new Tpe(), ss = {
  /**
   * Save messages to IndexedDB
   */
  async saveMessages(e, t) {
    const n = t.map((r) => ({
      id: r.id,
      threadId: e,
      role: r.role,
      parts: r.parts || [],
      metadata: r.metadata,
      createdAt: r.createdAt || /* @__PURE__ */ new Date()
    }));
    if (await Vi.messages.bulkPut(n), t.length > 0) {
      const r = t[t.length - 1], i = ss.extractTextFromMessage(r);
      await Vi.threads.put({
        id: e,
        lastMessageText: i,
        lastMessageAt: r.createdAt || /* @__PURE__ */ new Date(),
        messageCount: t.length
      });
    }
  },
  /**
   * Get messages from IndexedDB
   */
  async getMessages(e, t) {
    return t && t > 0 ? (await Vi.messages.where("[threadId+createdAt]").between([e, uc.minKey], [e, uc.maxKey]).reverse().limit(t).toArray()).reverse() : Vi.messages.where("threadId").equals(e).sortBy("createdAt");
  },
  /**
   * Get paginated messages (for infinite scroll)
   */
  async getMessagesPaginated(e, t, n = 20) {
    return (await Vi.messages.where("[threadId+createdAt]").between(
      [e, /* @__PURE__ */ new Date(0)],
      [e, t]
    ).reverse().limit(n).toArray()).reverse();
  },
  /**
   * Delete old messages to free up space
   */
  async pruneOldMessages(e, t = 100) {
    const r = await Vi.messages.where("threadId").equals(e).count() - t;
    if (r <= 0) return;
    const i = await Vi.messages.where("[threadId+createdAt]").between([e, uc.minKey], [e, uc.maxKey]).limit(r).primaryKeys();
    i.length > 0 && await Vi.messages.bulkDelete(i);
  },
  /**
   * Delete all messages for a thread
   */
  async deleteThread(e) {
    await Vi.messages.where("threadId").equals(e).delete(), await Vi.threads.delete(e);
  },
  /**
   * Get thread metadata
   */
  async getThreadMetadata(e) {
    return await Vi.threads.get(e);
  },
  /**
   * Get all threads metadata
   */
  async getAllThreads() {
    return await Vi.threads.orderBy("lastMessageAt").reverse().toArray();
  },
  /**
   * Extract text from message for preview
   */
  extractTextFromMessage(e) {
    if (!e.parts || e.parts.length === 0) return "";
    const t = e.parts.find((n) => n.type === "text");
    return t && typeof t.text == "string" ? t.text.substring(0, 100) : "";
  },
  /**
   * Get database size estimation
   */
  async getStorageStats() {
    const e = await Vi.messages.count(), t = await Vi.threads.count(), n = e * 3 * 1024, r = this.formatBytes(n);
    return {
      messageCount: e,
      threadCount: t,
      estimatedSize: r
    };
  },
  formatBytes(e) {
    if (e === 0) return "0 Bytes";
    const t = 1024, n = ["Bytes", "KB", "MB", "GB"], r = Math.floor(Math.log(e) / Math.log(t));
    return Math.round(e / Math.pow(t, r) * 100) / 100 + " " + n[r];
  }
}, tC = 3e4, tI = 5;
function Ape(e, t = 50, n = !0) {
  const [r, i] = k.useState([]), [o, s] = k.useState({
    nextCursor: null,
    hasMore: !0,
    isLoading: !1,
    isLoadingMore: !1,
    isFromCache: !1
  }), a = k.useRef(!1), c = k.useRef(e), u = k.useRef(
    /* @__PURE__ */ new Map()
  );
  k.useEffect(() => {
    if (c.current !== e) {
      c.current = e;
      const m = u.current.get(e);
      if (m && Date.now() - m.updatedAt < tC) {
        i(m.messages), s(m.pagination), a.current = !1;
        return;
      }
      i([]), s({
        nextCursor: null,
        hasMore: !0,
        isLoading: !1,
        isLoadingMore: !1,
        isFromCache: !1
      }), a.current = !1;
    }
  }, [e]), k.useEffect(() => {
    if (!n || o.isLoading || o.isLoadingMore || r.length === 0 && o.nextCursor === null && o.hasMore && !o.isFromCache) return;
    const g = Date.now(), b = u.current, x = [];
    if (b.forEach((w, S) => {
      g - w.updatedAt > tC && x.push(S);
    }), x.forEach((w) => b.delete(w)), b.size >= tI) {
      const S = Array.from(b.entries()).sort((_, M) => M[1].updatedAt - _[1].updatedAt).slice(0, tI);
      b.clear(), S.forEach(([_, M]) => b.set(_, M));
    }
    b.set(e, {
      messages: r,
      pagination: o,
      updatedAt: g
    });
  }, [n, e, r, o]), k.useEffect(() => {
    if (!n || r.length > 0 || a.current) return;
    const m = u.current.get(e);
    if (m && Date.now() - m.updatedAt < tC) {
      console.log(" Using in-memory cache, skipping load");
      return;
    }
    (async () => {
      const b = e;
      console.log(" Starting load initial messages..."), a.current = !0, s((x) => ({ ...x, isLoading: !0 }));
      try {
        console.time(" Load from IndexedDB");
        const x = await ss.getMessages(b, t);
        if (console.timeEnd(" Load from IndexedDB"), c.current !== b) return;
        if (x.length > 0) {
          console.log(" Using IndexedDB cache, skipping server fetch");
          const S = x.map((_) => ({
            id: _.id,
            role: _.role,
            parts: _.parts,
            metadata: _.metadata,
            createdAt: _.createdAt
          }));
          i(S), s({
            nextCursor: null,
            hasMore: x.length >= t,
            isLoading: !1,
            isLoadingMore: !1,
            isFromCache: !0
          }), a.current = !1;
          return;
        }
        console.log(" No cached messages found, fetching from server..."), console.time(" Load from Server");
        const w = await Yj(b, { limit: t });
        if (console.timeEnd(" Load from Server"), c.current !== b) return;
        i(w.messages || []), s({
          nextCursor: w.nextCursor,
          hasMore: w.hasMore,
          isLoading: !1,
          isLoadingMore: !1,
          isFromCache: !1
        }), w.messages && w.messages.length > 0 && (console.time(" Save to IndexedDB"), await ss.saveMessages(b, w.messages), console.timeEnd(" Save to IndexedDB"));
      } catch (x) {
        console.error(" Failed to load messages:", x), s((w) => ({ ...w, isLoading: !1 }));
      } finally {
        a.current = !1;
      }
    })();
  }, [n, e, t, r.length]);
  const f = k.useCallback(async () => {
    if (!n || a.current || !o.hasMore || !o.nextCursor)
      return;
    const m = e;
    a.current = !0, s((g) => ({ ...g, isLoadingMore: !0 }));
    try {
      const g = r[0];
      if (g && g.createdAt) {
        console.time(" Load more from IndexedDB");
        const x = await ss.getMessagesPaginated(
          m,
          g.createdAt,
          t
        );
        if (console.timeEnd(" Load more from IndexedDB"), c.current !== m) return;
        if (x.length > 0) {
          const w = x.map((S) => ({
            id: S.id,
            role: S.role,
            parts: S.parts,
            metadata: S.metadata,
            createdAt: S.createdAt
          }));
          i((S) => {
            const _ = new Set(S.map((N) => N.id));
            return [...w.filter((N) => !_.has(N.id)), ...S];
          });
        }
      }
      console.time(" Load more from Server");
      const b = await Yj(m, {
        limit: t,
        cursor: o.nextCursor,
        direction: "older"
      });
      if (console.timeEnd(" Load more from Server"), c.current !== m) return;
      i((x) => {
        const w = new Set(x.map((_) => _.id)), S = (b.messages || []).filter((_) => !w.has(_.id));
        return [...x, ...S];
      }), s((x) => ({
        ...x,
        nextCursor: b.nextCursor,
        hasMore: b.hasMore,
        isLoadingMore: !1
      })), b.messages && b.messages.length > 0 && (console.time(" Save more to IndexedDB"), await ss.saveMessages(m, b.messages), console.timeEnd(" Save more to IndexedDB"));
    } catch (g) {
      console.error(" Failed to load more messages:", g), s((b) => ({ ...b, isLoadingMore: !1 }));
    } finally {
      a.current = !1;
    }
  }, [n, e, t, o.hasMore, o.nextCursor, r]), h = k.useCallback(() => {
    i([]), s({
      nextCursor: null,
      hasMore: !0,
      isLoading: !1,
      isLoadingMore: !1,
      isFromCache: !1
    }), a.current = !1;
  }, []);
  return {
    messages: r,
    pagination: o,
    loadMore: f,
    reset: h
  };
}
function Mpe(e) {
  k.useEffect(() => {
    try {
      localStorage.setItem(cb.AI_USE_NEXT_SUGGESTION, JSON.stringify(e.value));
    } catch (t) {
      console.error("Error saving useNextSuggestion to localStorage:", t);
    }
  }, [e.value]), k.useEffect(() => {
    try {
      const t = localStorage.getItem(cb.AI_USE_NEXT_SUGGESTION);
      t !== null && (e.value = JSON.parse(t));
    } catch (t) {
      console.error("Error loading useNextSuggestion from localStorage:", t);
    }
  }, [e]);
}
function Npe({
  threadId: e,
  enabled: t = !0,
  maxInMemory: n = 20
}) {
  const [r, i] = k.useState(!1), [o, s] = k.useState(null), a = k.useCallback(
    async (m) => {
      if (!(!t || !e))
        try {
          i(!0), s(null), await ss.saveMessages(e, m), await ss.pruneOldMessages(e, 500);
        } catch (g) {
          console.error("Failed to save messages to IndexedDB:", g), s(g);
        } finally {
          i(!1);
        }
    },
    [e, t, n]
  ), c = k.useCallback(
    async (m) => {
      if (!t || !e) return [];
      try {
        i(!0), s(null);
        const g = m ?? n;
        return (await ss.getMessages(
          e,
          g
        )).map((x) => ({
          id: x.id,
          role: x.role,
          parts: x.parts,
          metadata: x.metadata,
          createdAt: x.createdAt
        }));
      } catch (g) {
        return console.error("Failed to load messages from IndexedDB:", g), s(g), [];
      } finally {
        i(!1);
      }
    },
    [e, t, n]
  ), u = k.useCallback(
    async (m, g = 20) => {
      if (!t || !e) return [];
      try {
        return (await ss.getMessagesPaginated(
          e,
          m,
          g
        )).map((x) => ({
          id: x.id,
          role: x.role,
          parts: x.parts,
          metadata: x.metadata,
          createdAt: x.createdAt
        }));
      } catch (b) {
        return console.error("Failed to load older messages from IndexedDB:", b), s(b), [];
      }
    },
    [e, t]
  ), f = k.useCallback(async () => {
    if (!(!t || !e))
      try {
        await ss.deleteThread(e);
      } catch (m) {
        console.error("Failed to delete thread from IndexedDB:", m), s(m);
      }
  }, [e, t]), h = k.useCallback(async () => {
    if (!t) return null;
    try {
      return await ss.getStorageStats();
    } catch (m) {
      return console.error("Failed to get storage stats:", m), null;
    }
  }, [t]);
  return {
    saveMessages: a,
    loadMessages: c,
    loadOlderMessages: u,
    deleteThread: f,
    getStorageStats: h,
    isLoading: r,
    error: o
  };
}
var t8 = "vercel.ai.error", Rpe = Symbol.for(t8), nI, rI, Js = class n8 extends (rI = Error, nI = Rpe, rI) {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: t,
    message: n,
    cause: r
  }) {
    super(n), this[nI] = !0, this.name = t, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(t) {
    return n8.hasMarker(t, t8);
  }
  static hasMarker(t, n) {
    const r = Symbol.for(n);
    return t != null && typeof t == "object" && r in t && typeof t[r] == "boolean" && t[r] === !0;
  }
};
function bM(e) {
  return e == null ? "unknown error" : typeof e == "string" ? e : e instanceof Error ? e.message : JSON.stringify(e);
}
var r8 = "AI_InvalidArgumentError", i8 = `vercel.ai.error.${r8}`, Ope = Symbol.for(i8), iI, oI, Dpe = class extends (oI = Js, iI = Ope, oI) {
  constructor({
    message: e,
    cause: t,
    argument: n
  }) {
    super({ name: r8, message: e, cause: t }), this[iI] = !0, this.argument = n;
  }
  static isInstance(e) {
    return Js.hasMarker(e, i8);
  }
}, o8 = "AI_JSONParseError", s8 = `vercel.ai.error.${o8}`, Ppe = Symbol.for(s8), sI, aI, lI = class extends (aI = Js, sI = Ppe, aI) {
  constructor({ text: e, cause: t }) {
    super({
      name: o8,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${bM(t)}`,
      cause: t
    }), this[sI] = !0, this.text = e;
  }
  static isInstance(e) {
    return Js.hasMarker(e, s8);
  }
}, a8 = "AI_TypeValidationError", l8 = `vercel.ai.error.${a8}`, jpe = Symbol.for(l8), cI, uI, bb = class C_ extends (uI = Js, cI = jpe, uI) {
  constructor({ value: t, cause: n }) {
    super({
      name: a8,
      message: `Type validation failed: Value: ${JSON.stringify(t)}.
Error message: ${bM(n)}`,
      cause: n
    }), this[cI] = !0, this.value = t;
  }
  static isInstance(t) {
    return Js.hasMarker(t, l8);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: t,
    cause: n
  }) {
    return C_.isInstance(n) && n.value === t ? n : new C_({ value: t, cause: n });
  }
};
class dI extends Error {
  constructor(t, n) {
    super(t), this.name = "ParseError", this.type = n.type, this.field = n.field, this.value = n.value, this.line = n.line;
  }
}
function nC(e) {
}
function Ipe(e) {
  if (typeof e == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent: t = nC, onError: n = nC, onRetry: r = nC, onComment: i } = e;
  let o = "", s = !0, a, c = "", u = "";
  function f(x) {
    const w = s ? x.replace(/^\xEF\xBB\xBF/, "") : x, [S, _] = zpe(`${o}${w}`);
    for (const M of S)
      h(M);
    o = _, s = !1;
  }
  function h(x) {
    if (x === "") {
      g();
      return;
    }
    if (x.startsWith(":")) {
      i && i(x.slice(x.startsWith(": ") ? 2 : 1));
      return;
    }
    const w = x.indexOf(":");
    if (w !== -1) {
      const S = x.slice(0, w), _ = x[w + 1] === " " ? 2 : 1, M = x.slice(w + _);
      m(S, M, x);
      return;
    }
    m(x, "", x);
  }
  function m(x, w, S) {
    switch (x) {
      case "event":
        u = w;
        break;
      case "data":
        c = `${c}${w}
`;
        break;
      case "id":
        a = w.includes("\0") ? void 0 : w;
        break;
      case "retry":
        /^\d+$/.test(w) ? r(parseInt(w, 10)) : n(
          new dI(`Invalid \`retry\` value: "${w}"`, {
            type: "invalid-retry",
            value: w,
            line: S
          })
        );
        break;
      default:
        n(
          new dI(
            `Unknown field "${x.length > 20 ? `${x.slice(0, 20)}` : x}"`,
            { type: "unknown-field", field: x, value: w, line: S }
          )
        );
        break;
    }
  }
  function g() {
    c.length > 0 && t({
      id: a,
      event: u || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: c.endsWith(`
`) ? c.slice(0, -1) : c
    }), a = void 0, c = "", u = "";
  }
  function b(x = {}) {
    o && x.consume && h(o), s = !0, a = void 0, c = "", u = "", o = "";
  }
  return { feed: f, reset: b };
}
function zpe(e) {
  const t = [];
  let n = "", r = 0;
  for (; r < e.length; ) {
    const i = e.indexOf("\r", r), o = e.indexOf(`
`, r);
    let s = -1;
    if (i !== -1 && o !== -1 ? s = Math.min(i, o) : i !== -1 ? i === e.length - 1 ? s = -1 : s = i : o !== -1 && (s = o), s === -1) {
      n = e.slice(r);
      break;
    } else {
      const a = e.slice(r, s);
      t.push(a), r = s + 1, e[r - 1] === "\r" && e[r] === `
` && r++;
    }
  }
  return [t, n];
}
class Lpe extends TransformStream {
  constructor({ onError: t, onRetry: n, onComment: r } = {}) {
    let i;
    super({
      start(o) {
        i = Ipe({
          onEvent: (s) => {
            o.enqueue(s);
          },
          onError(s) {
            t === "terminate" ? o.error(s) : typeof t == "function" && t(s);
          },
          onRetry: n,
          onComment: r
        });
      },
      transform(o) {
        i.feed(o);
      }
    });
  }
}
function De(e, t, n) {
  function r(a, c) {
    if (a._zod || Object.defineProperty(a, "_zod", {
      value: {
        def: c,
        constr: s,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), a._zod.traits.has(e))
      return;
    a._zod.traits.add(e), t(a, c);
    const u = s.prototype, f = Object.keys(u);
    for (let h = 0; h < f.length; h++) {
      const m = f[h];
      m in a || (a[m] = u[m].bind(a));
    }
  }
  const i = n?.Parent ?? Object;
  class o extends i {
  }
  Object.defineProperty(o, "name", { value: e });
  function s(a) {
    var c;
    const u = n?.Parent ? new o() : this;
    r(u, a), (c = u._zod).deferred ?? (c.deferred = []);
    for (const f of u._zod.deferred)
      f();
    return u;
  }
  return Object.defineProperty(s, "init", { value: r }), Object.defineProperty(s, Symbol.hasInstance, {
    value: (a) => n?.Parent && a instanceof n.Parent ? !0 : a?._zod?.traits?.has(e)
  }), Object.defineProperty(s, "name", { value: e }), s;
}
class Zf extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class c8 extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
}
const u8 = {};
function Nc(e) {
  return u8;
}
function d8(e) {
  const t = Object.values(e).filter((r) => typeof r == "number");
  return Object.entries(e).filter(([r, i]) => t.indexOf(+r) === -1).map(([r, i]) => i);
}
function E_(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function Sw(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function xM(e) {
  return e == null;
}
function wM(e) {
  const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function Bpe(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = t.toString();
  let i = (r.split(".")[1] || "").length;
  if (i === 0 && /\d?e-\d?/.test(r)) {
    const c = r.match(/\d?e-(\d?)/);
    c?.[1] && (i = Number.parseInt(c[1]));
  }
  const o = n > i ? n : i, s = Number.parseInt(e.toFixed(o).replace(".", "")), a = Number.parseInt(t.toFixed(o).replace(".", ""));
  return s % a / 10 ** o;
}
const fI = /* @__PURE__ */ Symbol("evaluating");
function en(e, t, n) {
  let r;
  Object.defineProperty(e, t, {
    get() {
      if (r !== fI)
        return r === void 0 && (r = fI, r = n()), r;
    },
    set(i) {
      Object.defineProperty(e, t, {
        value: i
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function hd(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function $c(...e) {
  const t = {};
  for (const n of e) {
    const r = Object.getOwnPropertyDescriptors(n);
    Object.assign(t, r);
  }
  return Object.defineProperties({}, t);
}
function hI(e) {
  return JSON.stringify(e);
}
function $pe(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const f8 = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function rg(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const Upe = Sw(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function lh(e) {
  if (rg(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0 || typeof t != "function")
    return !0;
  const n = t.prototype;
  return !(rg(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
function h8(e) {
  return lh(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
const Fpe = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function ch(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Uc(e, t, n) {
  const r = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (r._zod.parent = e), r;
}
function ct(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function Vpe(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const Hpe = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function Wpe(e, t) {
  const n = e._zod.def, r = n.checks;
  if (r && r.length > 0)
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  const o = $c(e._zod.def, {
    get shape() {
      const s = {};
      for (const a in t) {
        if (!(a in n.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        t[a] && (s[a] = n.shape[a]);
      }
      return hd(this, "shape", s), s;
    },
    checks: []
  });
  return Uc(e, o);
}
function qpe(e, t) {
  const n = e._zod.def, r = n.checks;
  if (r && r.length > 0)
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  const o = $c(e._zod.def, {
    get shape() {
      const s = { ...e._zod.def.shape };
      for (const a in t) {
        if (!(a in n.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        t[a] && delete s[a];
      }
      return hd(this, "shape", s), s;
    },
    checks: []
  });
  return Uc(e, o);
}
function Gpe(e, t) {
  if (!lh(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const n = e._zod.def.checks;
  if (n && n.length > 0) {
    const o = e._zod.def.shape;
    for (const s in t)
      if (Object.getOwnPropertyDescriptor(o, s) !== void 0)
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  const i = $c(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape, ...t };
      return hd(this, "shape", o), o;
    }
  });
  return Uc(e, i);
}
function Kpe(e, t) {
  if (!lh(t))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const n = $c(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t };
      return hd(this, "shape", r), r;
    }
  });
  return Uc(e, n);
}
function Zpe(e, t) {
  const n = $c(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t._zod.def.shape };
      return hd(this, "shape", r), r;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return Uc(e, n);
}
function Ype(e, t, n) {
  const i = t._zod.def.checks;
  if (i && i.length > 0)
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  const s = $c(t._zod.def, {
    get shape() {
      const a = t._zod.def.shape, c = { ...a };
      if (n)
        for (const u in n) {
          if (!(u in a))
            throw new Error(`Unrecognized key: "${u}"`);
          n[u] && (c[u] = e ? new e({
            type: "optional",
            innerType: a[u]
          }) : a[u]);
        }
      else
        for (const u in a)
          c[u] = e ? new e({
            type: "optional",
            innerType: a[u]
          }) : a[u];
      return hd(this, "shape", c), c;
    },
    checks: []
  });
  return Uc(t, s);
}
function Xpe(e, t, n) {
  const r = $c(t._zod.def, {
    get shape() {
      const i = t._zod.def.shape, o = { ...i };
      if (n)
        for (const s in n) {
          if (!(s in o))
            throw new Error(`Unrecognized key: "${s}"`);
          n[s] && (o[s] = new e({
            type: "nonoptional",
            innerType: i[s]
          }));
        }
      else
        for (const s in i)
          o[s] = new e({
            type: "nonoptional",
            innerType: i[s]
          });
      return hd(this, "shape", o), o;
    }
  });
  return Uc(t, r);
}
function If(e, t = 0) {
  if (e.aborted === !0)
    return !0;
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n]?.continue !== !0)
      return !0;
  return !1;
}
function zf(e, t) {
  return t.map((n) => {
    var r;
    return (r = n).path ?? (r.path = []), n.path.unshift(e), n;
  });
}
function zv(e) {
  return typeof e == "string" ? e : e?.message;
}
function Rc(e, t, n) {
  const r = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const i = zv(e.inst?._zod.def?.error?.(e)) ?? zv(t?.error?.(e)) ?? zv(n.customError?.(e)) ?? zv(n.localeError?.(e)) ?? "Invalid input";
    r.message = i;
  }
  return delete r.inst, delete r.continue, t?.reportInput || delete r.input, r;
}
function SM(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function ig(...e) {
  const [t, n, r] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: n,
    inst: r
  } : { ...t };
}
const p8 = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, E_, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, m8 = De("$ZodError", p8), g8 = De("$ZodError", p8, { Parent: Error });
function Jpe(e, t = (n) => n.message) {
  const n = {}, r = [];
  for (const i of e.issues)
    i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
  return { formErrors: r, fieldErrors: n };
}
function Qpe(e, t = (n) => n.message) {
  const n = { _errors: [] }, r = (i) => {
    for (const o of i.issues)
      if (o.code === "invalid_union" && o.errors.length)
        o.errors.map((s) => r({ issues: s }));
      else if (o.code === "invalid_key")
        r({ issues: o.issues });
      else if (o.code === "invalid_element")
        r({ issues: o.issues });
      else if (o.path.length === 0)
        n._errors.push(t(o));
      else {
        let s = n, a = 0;
        for (; a < o.path.length; ) {
          const c = o.path[a];
          a === o.path.length - 1 ? (s[c] = s[c] || { _errors: [] }, s[c]._errors.push(t(o))) : s[c] = s[c] || { _errors: [] }, s = s[c], a++;
        }
      }
  };
  return r(e), n;
}
const kM = (e) => (t, n, r, i) => {
  const o = r ? Object.assign(r, { async: !1 }) : { async: !1 }, s = t._zod.run({ value: n, issues: [] }, o);
  if (s instanceof Promise)
    throw new Zf();
  if (s.issues.length) {
    const a = new (i?.Err ?? e)(s.issues.map((c) => Rc(c, o, Nc())));
    throw f8(a, i?.callee), a;
  }
  return s.value;
}, CM = (e) => async (t, n, r, i) => {
  const o = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let s = t._zod.run({ value: n, issues: [] }, o);
  if (s instanceof Promise && (s = await s), s.issues.length) {
    const a = new (i?.Err ?? e)(s.issues.map((c) => Rc(c, o, Nc())));
    throw f8(a, i?.callee), a;
  }
  return s.value;
}, kw = (e) => (t, n, r) => {
  const i = r ? { ...r, async: !1 } : { async: !1 }, o = t._zod.run({ value: n, issues: [] }, i);
  if (o instanceof Promise)
    throw new Zf();
  return o.issues.length ? {
    success: !1,
    error: new (e ?? m8)(o.issues.map((s) => Rc(s, i, Nc())))
  } : { success: !0, data: o.value };
}, eme = /* @__PURE__ */ kw(g8), Cw = (e) => async (t, n, r) => {
  const i = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let o = t._zod.run({ value: n, issues: [] }, i);
  return o instanceof Promise && (o = await o), o.issues.length ? {
    success: !1,
    error: new e(o.issues.map((s) => Rc(s, i, Nc())))
  } : { success: !0, data: o.value };
}, tme = /* @__PURE__ */ Cw(g8), nme = (e) => (t, n, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return kM(e)(t, n, i);
}, rme = (e) => (t, n, r) => kM(e)(t, n, r), ime = (e) => async (t, n, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return CM(e)(t, n, i);
}, ome = (e) => async (t, n, r) => CM(e)(t, n, r), sme = (e) => (t, n, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return kw(e)(t, n, i);
}, ame = (e) => (t, n, r) => kw(e)(t, n, r), lme = (e) => async (t, n, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Cw(e)(t, n, i);
}, cme = (e) => async (t, n, r) => Cw(e)(t, n, r), ume = /^[cC][^\s-]{8,}$/, dme = /^[0-9a-z]+$/, fme = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, hme = /^[0-9a-vA-V]{20}$/, pme = /^[A-Za-z0-9]{27}$/, mme = /^[a-zA-Z0-9_-]{21}$/, gme = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, yme = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, pI = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, vme = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, bme = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function xme() {
  return new RegExp(bme, "u");
}
const wme = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Sme = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, kme = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, Cme = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Eme = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, y8 = /^[A-Za-z0-9_-]*$/, _me = /^\+[1-9]\d{6,14}$/, v8 = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", Tme = /* @__PURE__ */ new RegExp(`^${v8}$`);
function b8(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function Ame(e) {
  return new RegExp(`^${b8(e)}$`);
}
function Mme(e) {
  const t = b8({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const r = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${v8}T(?:${r})$`);
}
const Nme = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, Rme = /^-?\d+$/, x8 = /^-?\d+(?:\.\d+)?$/, Ome = /^(?:true|false)$/i, Dme = /^null$/i, Pme = /^[^A-Z]*$/, jme = /^[^a-z]*$/, Zi = /* @__PURE__ */ De("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), w8 = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, S8 = /* @__PURE__ */ De("$ZodCheckLessThan", (e, t) => {
  Zi.init(e, t);
  const n = w8[typeof t.value];
  e._zod.onattach.push((r) => {
    const i = r._zod.bag, o = (t.inclusive ? i.maximum : i.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < o && (t.inclusive ? i.maximum = t.value : i.exclusiveMaximum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value <= t.value : r.value < t.value) || r.issues.push({
      origin: n,
      code: "too_big",
      maximum: typeof t.value == "object" ? t.value.getTime() : t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), k8 = /* @__PURE__ */ De("$ZodCheckGreaterThan", (e, t) => {
  Zi.init(e, t);
  const n = w8[typeof t.value];
  e._zod.onattach.push((r) => {
    const i = r._zod.bag, o = (t.inclusive ? i.minimum : i.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > o && (t.inclusive ? i.minimum = t.value : i.exclusiveMinimum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value >= t.value : r.value > t.value) || r.issues.push({
      origin: n,
      code: "too_small",
      minimum: typeof t.value == "object" ? t.value.getTime() : t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), Ime = /* @__PURE__ */ De("$ZodCheckMultipleOf", (e, t) => {
  Zi.init(e, t), e._zod.onattach.push((n) => {
    var r;
    (r = n._zod.bag).multipleOf ?? (r.multipleOf = t.value);
  }), e._zod.check = (n) => {
    if (typeof n.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof n.value == "bigint" ? n.value % t.value === BigInt(0) : Bpe(n.value, t.value) === 0) || n.issues.push({
      origin: typeof n.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), zme = /* @__PURE__ */ De("$ZodCheckNumberFormat", (e, t) => {
  Zi.init(e, t), t.format = t.format || "float64";
  const n = t.format?.includes("int"), r = n ? "int" : "number", [i, o] = Hpe[t.format];
  e._zod.onattach.push((s) => {
    const a = s._zod.bag;
    a.format = t.format, a.minimum = i, a.maximum = o, n && (a.pattern = Rme);
  }), e._zod.check = (s) => {
    const a = s.value;
    if (n) {
      if (!Number.isInteger(a)) {
        s.issues.push({
          expected: r,
          format: t.format,
          code: "invalid_type",
          continue: !1,
          input: a,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(a)) {
        a > 0 ? s.issues.push({
          input: a,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          inclusive: !0,
          continue: !t.abort
        }) : s.issues.push({
          input: a,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          inclusive: !0,
          continue: !t.abort
        });
        return;
      }
    }
    a < i && s.issues.push({
      origin: "number",
      input: a,
      code: "too_small",
      minimum: i,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), a > o && s.issues.push({
      origin: "number",
      input: a,
      code: "too_big",
      maximum: o,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    });
  };
}), Lme = /* @__PURE__ */ De("$ZodCheckMaxLength", (e, t) => {
  var n;
  Zi.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const i = r.value;
    return !xM(i) && i.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const i = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < i && (r._zod.bag.maximum = t.maximum);
  }), e._zod.check = (r) => {
    const i = r.value;
    if (i.length <= t.maximum)
      return;
    const s = SM(i);
    r.issues.push({
      origin: s,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: i,
      inst: e,
      continue: !t.abort
    });
  };
}), Bme = /* @__PURE__ */ De("$ZodCheckMinLength", (e, t) => {
  var n;
  Zi.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const i = r.value;
    return !xM(i) && i.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const i = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > i && (r._zod.bag.minimum = t.minimum);
  }), e._zod.check = (r) => {
    const i = r.value;
    if (i.length >= t.minimum)
      return;
    const s = SM(i);
    r.issues.push({
      origin: s,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: i,
      inst: e,
      continue: !t.abort
    });
  };
}), $me = /* @__PURE__ */ De("$ZodCheckLengthEquals", (e, t) => {
  var n;
  Zi.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const i = r.value;
    return !xM(i) && i.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.minimum = t.length, i.maximum = t.length, i.length = t.length;
  }), e._zod.check = (r) => {
    const i = r.value, o = i.length;
    if (o === t.length)
      return;
    const s = SM(i), a = o > t.length;
    r.issues.push({
      origin: s,
      ...a ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Ew = /* @__PURE__ */ De("$ZodCheckStringFormat", (e, t) => {
  var n, r;
  Zi.init(e, t), e._zod.onattach.push((i) => {
    const o = i._zod.bag;
    o.format = t.format, t.pattern && (o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(t.pattern));
  }), t.pattern ? (n = e._zod).check ?? (n.check = (i) => {
    t.pattern.lastIndex = 0, !t.pattern.test(i.value) && i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: i.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (r = e._zod).check ?? (r.check = () => {
  });
}), Ume = /* @__PURE__ */ De("$ZodCheckRegex", (e, t) => {
  Ew.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: n.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), Fme = /* @__PURE__ */ De("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = Pme), Ew.init(e, t);
}), Vme = /* @__PURE__ */ De("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = jme), Ew.init(e, t);
}), Hme = /* @__PURE__ */ De("$ZodCheckIncludes", (e, t) => {
  Zi.init(e, t);
  const n = ch(t.includes), r = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = r, e._zod.onattach.push((i) => {
    const o = i._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(r);
  }), e._zod.check = (i) => {
    i.value.includes(t.includes, t.position) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Wme = /* @__PURE__ */ De("$ZodCheckStartsWith", (e, t) => {
  Zi.init(e, t);
  const n = new RegExp(`^${ch(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.startsWith(t.prefix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), qme = /* @__PURE__ */ De("$ZodCheckEndsWith", (e, t) => {
  Zi.init(e, t);
  const n = new RegExp(`.*${ch(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.endsWith(t.suffix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Gme = /* @__PURE__ */ De("$ZodCheckOverwrite", (e, t) => {
  Zi.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
class Kme {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const r = t.split(`
`).filter((s) => s), i = Math.min(...r.map((s) => s.length - s.trimStart().length)), o = r.map((s) => s.slice(i)).map((s) => " ".repeat(this.indent * 2) + s);
    for (const s of o)
      this.content.push(s);
  }
  compile() {
    const t = Function, n = this?.args, i = [...(this?.content ?? [""]).map((o) => `  ${o}`)];
    return new t(...n, i.join(`
`));
  }
}
const Zme = {
  major: 4,
  minor: 3,
  patch: 6
}, Vn = /* @__PURE__ */ De("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = Zme;
  const r = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && r.unshift(e);
  for (const i of r)
    for (const o of i._zod.onattach)
      o(e);
  if (r.length === 0)
    (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const i = (s, a, c) => {
      let u = If(s), f;
      for (const h of a) {
        if (h._zod.def.when) {
          if (!h._zod.def.when(s))
            continue;
        } else if (u)
          continue;
        const m = s.issues.length, g = h._zod.check(s);
        if (g instanceof Promise && c?.async === !1)
          throw new Zf();
        if (f || g instanceof Promise)
          f = (f ?? Promise.resolve()).then(async () => {
            await g, s.issues.length !== m && (u || (u = If(s, m)));
          });
        else {
          if (s.issues.length === m)
            continue;
          u || (u = If(s, m));
        }
      }
      return f ? f.then(() => s) : s;
    }, o = (s, a, c) => {
      if (If(s))
        return s.aborted = !0, s;
      const u = i(a, r, c);
      if (u instanceof Promise) {
        if (c.async === !1)
          throw new Zf();
        return u.then((f) => e._zod.parse(f, c));
      }
      return e._zod.parse(u, c);
    };
    e._zod.run = (s, a) => {
      if (a.skipChecks)
        return e._zod.parse(s, a);
      if (a.direction === "backward") {
        const u = e._zod.parse({ value: s.value, issues: [] }, { ...a, skipChecks: !0 });
        return u instanceof Promise ? u.then((f) => o(f, s, a)) : o(u, s, a);
      }
      const c = e._zod.parse(s, a);
      if (c instanceof Promise) {
        if (a.async === !1)
          throw new Zf();
        return c.then((u) => i(u, r, a));
      }
      return i(c, r, a);
    };
  }
  en(e, "~standard", () => ({
    validate: (i) => {
      try {
        const o = eme(e, i);
        return o.success ? { value: o.data } : { issues: o.error?.issues };
      } catch {
        return tme(e, i).then((s) => s.success ? { value: s.data } : { issues: s.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), EM = /* @__PURE__ */ De("$ZodString", (e, t) => {
  Vn.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? Nme(e._zod.bag), e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), Kn = /* @__PURE__ */ De("$ZodStringFormat", (e, t) => {
  Ew.init(e, t), EM.init(e, t);
}), Yme = /* @__PURE__ */ De("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = yme), Kn.init(e, t);
}), Xme = /* @__PURE__ */ De("$ZodUUID", (e, t) => {
  if (t.version) {
    const r = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (r === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = pI(r));
  } else
    t.pattern ?? (t.pattern = pI());
  Kn.init(e, t);
}), Jme = /* @__PURE__ */ De("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = vme), Kn.init(e, t);
}), Qme = /* @__PURE__ */ De("$ZodURL", (e, t) => {
  Kn.init(e, t), e._zod.check = (n) => {
    try {
      const r = n.value.trim(), i = new URL(r);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(i.hostname) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: t.hostname.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(i.protocol.endsWith(":") ? i.protocol.slice(0, -1) : i.protocol) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? n.value = i.href : n.value = r;
      return;
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "url",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), ege = /* @__PURE__ */ De("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = xme()), Kn.init(e, t);
}), tge = /* @__PURE__ */ De("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = mme), Kn.init(e, t);
}), nge = /* @__PURE__ */ De("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = ume), Kn.init(e, t);
}), rge = /* @__PURE__ */ De("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = dme), Kn.init(e, t);
}), ige = /* @__PURE__ */ De("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = fme), Kn.init(e, t);
}), oge = /* @__PURE__ */ De("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = hme), Kn.init(e, t);
}), sge = /* @__PURE__ */ De("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = pme), Kn.init(e, t);
}), age = /* @__PURE__ */ De("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = Mme(t)), Kn.init(e, t);
}), lge = /* @__PURE__ */ De("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = Tme), Kn.init(e, t);
}), cge = /* @__PURE__ */ De("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = Ame(t)), Kn.init(e, t);
}), uge = /* @__PURE__ */ De("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = gme), Kn.init(e, t);
}), dge = /* @__PURE__ */ De("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = wme), Kn.init(e, t), e._zod.bag.format = "ipv4";
}), fge = /* @__PURE__ */ De("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = Sme), Kn.init(e, t), e._zod.bag.format = "ipv6", e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), hge = /* @__PURE__ */ De("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = kme), Kn.init(e, t);
}), pge = /* @__PURE__ */ De("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = Cme), Kn.init(e, t), e._zod.check = (n) => {
    const r = n.value.split("/");
    try {
      if (r.length !== 2)
        throw new Error();
      const [i, o] = r;
      if (!o)
        throw new Error();
      const s = Number(o);
      if (`${s}` !== o)
        throw new Error();
      if (s < 0 || s > 128)
        throw new Error();
      new URL(`http://[${i}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function C8(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const mge = /* @__PURE__ */ De("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = Eme), Kn.init(e, t), e._zod.bag.contentEncoding = "base64", e._zod.check = (n) => {
    C8(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function gge(e) {
  if (!y8.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (r) => r === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return C8(n);
}
const yge = /* @__PURE__ */ De("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = y8), Kn.init(e, t), e._zod.bag.contentEncoding = "base64url", e._zod.check = (n) => {
    gge(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), vge = /* @__PURE__ */ De("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = _me), Kn.init(e, t);
});
function bge(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3)
      return !1;
    const [r] = n;
    if (!r)
      return !1;
    const i = JSON.parse(atob(r));
    return !("typ" in i && i?.typ !== "JWT" || !i.alg || t && (!("alg" in i) || i.alg !== t));
  } catch {
    return !1;
  }
}
const xge = /* @__PURE__ */ De("$ZodJWT", (e, t) => {
  Kn.init(e, t), e._zod.check = (n) => {
    bge(n.value, t.alg) || n.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), E8 = /* @__PURE__ */ De("$ZodNumber", (e, t) => {
  Vn.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? x8, e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = Number(n.value);
      } catch {
      }
    const i = n.value;
    if (typeof i == "number" && !Number.isNaN(i) && Number.isFinite(i))
      return n;
    const o = typeof i == "number" ? Number.isNaN(i) ? "NaN" : Number.isFinite(i) ? void 0 : "Infinity" : void 0;
    return n.issues.push({
      expected: "number",
      code: "invalid_type",
      input: i,
      inst: e,
      ...o ? { received: o } : {}
    }), n;
  };
}), wge = /* @__PURE__ */ De("$ZodNumberFormat", (e, t) => {
  zme.init(e, t), E8.init(e, t);
}), Sge = /* @__PURE__ */ De("$ZodBoolean", (e, t) => {
  Vn.init(e, t), e._zod.pattern = Ome, e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = !!n.value;
      } catch {
      }
    const i = n.value;
    return typeof i == "boolean" || n.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: i,
      inst: e
    }), n;
  };
}), kge = /* @__PURE__ */ De("$ZodNull", (e, t) => {
  Vn.init(e, t), e._zod.pattern = Dme, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (n, r) => {
    const i = n.value;
    return i === null || n.issues.push({
      expected: "null",
      code: "invalid_type",
      input: i,
      inst: e
    }), n;
  };
}), Cge = /* @__PURE__ */ De("$ZodUnknown", (e, t) => {
  Vn.init(e, t), e._zod.parse = (n) => n;
}), Ege = /* @__PURE__ */ De("$ZodNever", (e, t) => {
  Vn.init(e, t), e._zod.parse = (n, r) => (n.issues.push({
    expected: "never",
    code: "invalid_type",
    input: n.value,
    inst: e
  }), n);
});
function mI(e, t, n) {
  e.issues.length && t.issues.push(...zf(n, e.issues)), t.value[n] = e.value;
}
const _ge = /* @__PURE__ */ De("$ZodArray", (e, t) => {
  Vn.init(e, t), e._zod.parse = (n, r) => {
    const i = n.value;
    if (!Array.isArray(i))
      return n.issues.push({
        expected: "array",
        code: "invalid_type",
        input: i,
        inst: e
      }), n;
    n.value = Array(i.length);
    const o = [];
    for (let s = 0; s < i.length; s++) {
      const a = i[s], c = t.element._zod.run({
        value: a,
        issues: []
      }, r);
      c instanceof Promise ? o.push(c.then((u) => mI(u, n, s))) : mI(c, n, s);
    }
    return o.length ? Promise.all(o).then(() => n) : n;
  };
});
function xb(e, t, n, r, i) {
  if (e.issues.length) {
    if (i && !(n in r))
      return;
    t.issues.push(...zf(n, e.issues));
  }
  e.value === void 0 ? n in r && (t.value[n] = void 0) : t.value[n] = e.value;
}
function _8(e) {
  const t = Object.keys(e.shape);
  for (const r of t)
    if (!e.shape?.[r]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${r}": expected a Zod schema`);
  const n = Vpe(e.shape);
  return {
    ...e,
    keys: t,
    keySet: new Set(t),
    numKeys: t.length,
    optionalKeys: new Set(n)
  };
}
function T8(e, t, n, r, i, o) {
  const s = [], a = i.keySet, c = i.catchall._zod, u = c.def.type, f = c.optout === "optional";
  for (const h in t) {
    if (a.has(h))
      continue;
    if (u === "never") {
      s.push(h);
      continue;
    }
    const m = c.run({ value: t[h], issues: [] }, r);
    m instanceof Promise ? e.push(m.then((g) => xb(g, n, h, t, f))) : xb(m, n, h, t, f);
  }
  return s.length && n.issues.push({
    code: "unrecognized_keys",
    keys: s,
    input: t,
    inst: o
  }), e.length ? Promise.all(e).then(() => n) : n;
}
const Tge = /* @__PURE__ */ De("$ZodObject", (e, t) => {
  if (Vn.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
    const a = t.shape;
    Object.defineProperty(t, "shape", {
      get: () => {
        const c = { ...a };
        return Object.defineProperty(t, "shape", {
          value: c
        }), c;
      }
    });
  }
  const r = Sw(() => _8(t));
  en(e._zod, "propValues", () => {
    const a = t.shape, c = {};
    for (const u in a) {
      const f = a[u]._zod;
      if (f.values) {
        c[u] ?? (c[u] = /* @__PURE__ */ new Set());
        for (const h of f.values)
          c[u].add(h);
      }
    }
    return c;
  });
  const i = rg, o = t.catchall;
  let s;
  e._zod.parse = (a, c) => {
    s ?? (s = r.value);
    const u = a.value;
    if (!i(u))
      return a.issues.push({
        expected: "object",
        code: "invalid_type",
        input: u,
        inst: e
      }), a;
    a.value = {};
    const f = [], h = s.shape;
    for (const m of s.keys) {
      const g = h[m], b = g._zod.optout === "optional", x = g._zod.run({ value: u[m], issues: [] }, c);
      x instanceof Promise ? f.push(x.then((w) => xb(w, a, m, u, b))) : xb(x, a, m, u, b);
    }
    return o ? T8(f, u, a, c, r.value, e) : f.length ? Promise.all(f).then(() => a) : a;
  };
}), Age = /* @__PURE__ */ De("$ZodObjectJIT", (e, t) => {
  Tge.init(e, t);
  const n = e._zod.parse, r = Sw(() => _8(t)), i = (m) => {
    const g = new Kme(["shape", "payload", "ctx"]), b = r.value, x = (M) => {
      const N = hI(M);
      return `shape[${N}]._zod.run({ value: input[${N}], issues: [] }, ctx)`;
    };
    g.write("const input = payload.value;");
    const w = /* @__PURE__ */ Object.create(null);
    let S = 0;
    for (const M of b.keys)
      w[M] = `key_${S++}`;
    g.write("const newResult = {};");
    for (const M of b.keys) {
      const N = w[M], P = hI(M), O = m[M]?._zod?.optout === "optional";
      g.write(`const ${N} = ${x(M)};`), O ? g.write(`
        if (${N}.issues.length) {
          if (${P} in input) {
            payload.issues = payload.issues.concat(${N}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${P}, ...iss.path] : [${P}]
            })));
          }
        }
        
        if (${N}.value === undefined) {
          if (${P} in input) {
            newResult[${P}] = undefined;
          }
        } else {
          newResult[${P}] = ${N}.value;
        }
        
      `) : g.write(`
        if (${N}.issues.length) {
          payload.issues = payload.issues.concat(${N}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${P}, ...iss.path] : [${P}]
          })));
        }
        
        if (${N}.value === undefined) {
          if (${P} in input) {
            newResult[${P}] = undefined;
          }
        } else {
          newResult[${P}] = ${N}.value;
        }
        
      `);
    }
    g.write("payload.value = newResult;"), g.write("return payload;");
    const _ = g.compile();
    return (M, N) => _(m, M, N);
  };
  let o;
  const s = rg, a = !u8.jitless, u = a && Upe.value, f = t.catchall;
  let h;
  e._zod.parse = (m, g) => {
    h ?? (h = r.value);
    const b = m.value;
    return s(b) ? a && u && g?.async === !1 && g.jitless !== !0 ? (o || (o = i(t.shape)), m = o(m, g), f ? T8([], b, m, g, h, e) : m) : n(m, g) : (m.issues.push({
      expected: "object",
      code: "invalid_type",
      input: b,
      inst: e
    }), m);
  };
});
function gI(e, t, n, r) {
  for (const o of e)
    if (o.issues.length === 0)
      return t.value = o.value, t;
  const i = e.filter((o) => !If(o));
  return i.length === 1 ? (t.value = i[0].value, i[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: n,
    errors: e.map((o) => o.issues.map((s) => Rc(s, r, Nc())))
  }), t);
}
const A8 = /* @__PURE__ */ De("$ZodUnion", (e, t) => {
  Vn.init(e, t), en(e._zod, "optin", () => t.options.some((i) => i._zod.optin === "optional") ? "optional" : void 0), en(e._zod, "optout", () => t.options.some((i) => i._zod.optout === "optional") ? "optional" : void 0), en(e._zod, "values", () => {
    if (t.options.every((i) => i._zod.values))
      return new Set(t.options.flatMap((i) => Array.from(i._zod.values)));
  }), en(e._zod, "pattern", () => {
    if (t.options.every((i) => i._zod.pattern)) {
      const i = t.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${i.map((o) => wM(o.source)).join("|")})$`);
    }
  });
  const n = t.options.length === 1, r = t.options[0]._zod.run;
  e._zod.parse = (i, o) => {
    if (n)
      return r(i, o);
    let s = !1;
    const a = [];
    for (const c of t.options) {
      const u = c._zod.run({
        value: i.value,
        issues: []
      }, o);
      if (u instanceof Promise)
        a.push(u), s = !0;
      else {
        if (u.issues.length === 0)
          return u;
        a.push(u);
      }
    }
    return s ? Promise.all(a).then((c) => gI(c, i, e, o)) : gI(a, i, e, o);
  };
}), Mge = /* @__PURE__ */ De("$ZodDiscriminatedUnion", (e, t) => {
  t.inclusive = !1, A8.init(e, t);
  const n = e._zod.parse;
  en(e._zod, "propValues", () => {
    const i = {};
    for (const o of t.options) {
      const s = o._zod.propValues;
      if (!s || Object.keys(s).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(o)}"`);
      for (const [a, c] of Object.entries(s)) {
        i[a] || (i[a] = /* @__PURE__ */ new Set());
        for (const u of c)
          i[a].add(u);
      }
    }
    return i;
  });
  const r = Sw(() => {
    const i = t.options, o = /* @__PURE__ */ new Map();
    for (const s of i) {
      const a = s._zod.propValues?.[t.discriminator];
      if (!a || a.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(s)}"`);
      for (const c of a) {
        if (o.has(c))
          throw new Error(`Duplicate discriminator value "${String(c)}"`);
        o.set(c, s);
      }
    }
    return o;
  });
  e._zod.parse = (i, o) => {
    const s = i.value;
    if (!rg(s))
      return i.issues.push({
        code: "invalid_type",
        expected: "object",
        input: s,
        inst: e
      }), i;
    const a = r.value.get(s?.[t.discriminator]);
    return a ? a._zod.run(i, o) : t.unionFallback ? n(i, o) : (i.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: t.discriminator,
      input: s,
      path: [t.discriminator],
      inst: e
    }), i);
  };
}), Nge = /* @__PURE__ */ De("$ZodIntersection", (e, t) => {
  Vn.init(e, t), e._zod.parse = (n, r) => {
    const i = n.value, o = t.left._zod.run({ value: i, issues: [] }, r), s = t.right._zod.run({ value: i, issues: [] }, r);
    return o instanceof Promise || s instanceof Promise ? Promise.all([o, s]).then(([c, u]) => yI(n, c, u)) : yI(n, o, s);
  };
});
function __(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (lh(e) && lh(t)) {
    const n = Object.keys(t), r = Object.keys(e).filter((o) => n.indexOf(o) !== -1), i = { ...e, ...t };
    for (const o of r) {
      const s = __(e[o], t[o]);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [o, ...s.mergeErrorPath]
        };
      i[o] = s.data;
    }
    return { valid: !0, data: i };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const i = e[r], o = t[r], s = __(i, o);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...s.mergeErrorPath]
        };
      n.push(s.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function yI(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  let i;
  for (const a of t.issues)
    if (a.code === "unrecognized_keys") {
      i ?? (i = a);
      for (const c of a.keys)
        r.has(c) || r.set(c, {}), r.get(c).l = !0;
    } else
      e.issues.push(a);
  for (const a of n.issues)
    if (a.code === "unrecognized_keys")
      for (const c of a.keys)
        r.has(c) || r.set(c, {}), r.get(c).r = !0;
    else
      e.issues.push(a);
  const o = [...r].filter(([, a]) => a.l && a.r).map(([a]) => a);
  if (o.length && i && e.issues.push({ ...i, keys: o }), If(e))
    return e;
  const s = __(t.value, n.value);
  if (!s.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(s.mergeErrorPath)}`);
  return e.value = s.data, e;
}
const Rge = /* @__PURE__ */ De("$ZodRecord", (e, t) => {
  Vn.init(e, t), e._zod.parse = (n, r) => {
    const i = n.value;
    if (!lh(i))
      return n.issues.push({
        expected: "record",
        code: "invalid_type",
        input: i,
        inst: e
      }), n;
    const o = [], s = t.keyType._zod.values;
    if (s) {
      n.value = {};
      const a = /* @__PURE__ */ new Set();
      for (const u of s)
        if (typeof u == "string" || typeof u == "number" || typeof u == "symbol") {
          a.add(typeof u == "number" ? u.toString() : u);
          const f = t.valueType._zod.run({ value: i[u], issues: [] }, r);
          f instanceof Promise ? o.push(f.then((h) => {
            h.issues.length && n.issues.push(...zf(u, h.issues)), n.value[u] = h.value;
          })) : (f.issues.length && n.issues.push(...zf(u, f.issues)), n.value[u] = f.value);
        }
      let c;
      for (const u in i)
        a.has(u) || (c = c ?? [], c.push(u));
      c && c.length > 0 && n.issues.push({
        code: "unrecognized_keys",
        input: i,
        inst: e,
        keys: c
      });
    } else {
      n.value = {};
      for (const a of Reflect.ownKeys(i)) {
        if (a === "__proto__")
          continue;
        let c = t.keyType._zod.run({ value: a, issues: [] }, r);
        if (c instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (typeof a == "string" && x8.test(a) && c.issues.length) {
          const h = t.keyType._zod.run({ value: Number(a), issues: [] }, r);
          if (h instanceof Promise)
            throw new Error("Async schemas not supported in object keys currently");
          h.issues.length === 0 && (c = h);
        }
        if (c.issues.length) {
          t.mode === "loose" ? n.value[a] = i[a] : n.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: c.issues.map((h) => Rc(h, r, Nc())),
            input: a,
            path: [a],
            inst: e
          });
          continue;
        }
        const f = t.valueType._zod.run({ value: i[a], issues: [] }, r);
        f instanceof Promise ? o.push(f.then((h) => {
          h.issues.length && n.issues.push(...zf(a, h.issues)), n.value[c.value] = h.value;
        })) : (f.issues.length && n.issues.push(...zf(a, f.issues)), n.value[c.value] = f.value);
      }
    }
    return o.length ? Promise.all(o).then(() => n) : n;
  };
}), Oge = /* @__PURE__ */ De("$ZodEnum", (e, t) => {
  Vn.init(e, t);
  const n = d8(t.entries), r = new Set(n);
  e._zod.values = r, e._zod.pattern = new RegExp(`^(${n.filter((i) => Fpe.has(typeof i)).map((i) => typeof i == "string" ? ch(i) : i.toString()).join("|")})$`), e._zod.parse = (i, o) => {
    const s = i.value;
    return r.has(s) || i.issues.push({
      code: "invalid_value",
      values: n,
      input: s,
      inst: e
    }), i;
  };
}), Dge = /* @__PURE__ */ De("$ZodLiteral", (e, t) => {
  if (Vn.init(e, t), t.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  const n = new Set(t.values);
  e._zod.values = n, e._zod.pattern = new RegExp(`^(${t.values.map((r) => typeof r == "string" ? ch(r) : r ? ch(r.toString()) : String(r)).join("|")})$`), e._zod.parse = (r, i) => {
    const o = r.value;
    return n.has(o) || r.issues.push({
      code: "invalid_value",
      values: t.values,
      input: o,
      inst: e
    }), r;
  };
}), Pge = /* @__PURE__ */ De("$ZodTransform", (e, t) => {
  Vn.init(e, t), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      throw new c8(e.constructor.name);
    const i = t.transform(n.value, n);
    if (r.async)
      return (i instanceof Promise ? i : Promise.resolve(i)).then((s) => (n.value = s, n));
    if (i instanceof Promise)
      throw new Zf();
    return n.value = i, n;
  };
});
function vI(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
const M8 = /* @__PURE__ */ De("$ZodOptional", (e, t) => {
  Vn.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", en(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), en(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${wM(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, r) => {
    if (t.innerType._zod.optin === "optional") {
      const i = t.innerType._zod.run(n, r);
      return i instanceof Promise ? i.then((o) => vI(o, n.value)) : vI(i, n.value);
    }
    return n.value === void 0 ? n : t.innerType._zod.run(n, r);
  };
}), jge = /* @__PURE__ */ De("$ZodExactOptional", (e, t) => {
  M8.init(e, t), en(e._zod, "values", () => t.innerType._zod.values), en(e._zod, "pattern", () => t.innerType._zod.pattern), e._zod.parse = (n, r) => t.innerType._zod.run(n, r);
}), Ige = /* @__PURE__ */ De("$ZodNullable", (e, t) => {
  Vn.init(e, t), en(e._zod, "optin", () => t.innerType._zod.optin), en(e._zod, "optout", () => t.innerType._zod.optout), en(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${wM(n.source)}|null)$`) : void 0;
  }), en(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, r) => n.value === null ? n : t.innerType._zod.run(n, r);
}), zge = /* @__PURE__ */ De("$ZodDefault", (e, t) => {
  Vn.init(e, t), e._zod.optin = "optional", en(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    if (n.value === void 0)
      return n.value = t.defaultValue, n;
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((o) => bI(o, t)) : bI(i, t);
  };
});
function bI(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const Lge = /* @__PURE__ */ De("$ZodPrefault", (e, t) => {
  Vn.init(e, t), e._zod.optin = "optional", en(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => (r.direction === "backward" || n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, r));
}), Bge = /* @__PURE__ */ De("$ZodNonOptional", (e, t) => {
  Vn.init(e, t), en(e._zod, "values", () => {
    const n = t.innerType._zod.values;
    return n ? new Set([...n].filter((r) => r !== void 0)) : void 0;
  }), e._zod.parse = (n, r) => {
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((o) => xI(o, e)) : xI(i, e);
  };
});
function xI(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const $ge = /* @__PURE__ */ De("$ZodCatch", (e, t) => {
  Vn.init(e, t), en(e._zod, "optin", () => t.innerType._zod.optin), en(e._zod, "optout", () => t.innerType._zod.optout), en(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((o) => (n.value = o.value, o.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: o.issues.map((s) => Rc(s, r, Nc()))
      },
      input: n.value
    }), n.issues = []), n)) : (n.value = i.value, i.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: i.issues.map((o) => Rc(o, r, Nc()))
      },
      input: n.value
    }), n.issues = []), n);
  };
}), Uge = /* @__PURE__ */ De("$ZodPipe", (e, t) => {
  Vn.init(e, t), en(e._zod, "values", () => t.in._zod.values), en(e._zod, "optin", () => t.in._zod.optin), en(e._zod, "optout", () => t.out._zod.optout), en(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, r) => {
    if (r.direction === "backward") {
      const o = t.out._zod.run(n, r);
      return o instanceof Promise ? o.then((s) => Lv(s, t.in, r)) : Lv(o, t.in, r);
    }
    const i = t.in._zod.run(n, r);
    return i instanceof Promise ? i.then((o) => Lv(o, t.out, r)) : Lv(i, t.out, r);
  };
});
function Lv(e, t, n) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, n);
}
const Fge = /* @__PURE__ */ De("$ZodReadonly", (e, t) => {
  Vn.init(e, t), en(e._zod, "propValues", () => t.innerType._zod.propValues), en(e._zod, "values", () => t.innerType._zod.values), en(e._zod, "optin", () => t.innerType?._zod?.optin), en(e._zod, "optout", () => t.innerType?._zod?.optout), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then(wI) : wI(i);
  };
});
function wI(e) {
  return e.value = Object.freeze(e.value), e;
}
const Vge = /* @__PURE__ */ De("$ZodLazy", (e, t) => {
  Vn.init(e, t), en(e._zod, "innerType", () => t.getter()), en(e._zod, "pattern", () => e._zod.innerType?._zod?.pattern), en(e._zod, "propValues", () => e._zod.innerType?._zod?.propValues), en(e._zod, "optin", () => e._zod.innerType?._zod?.optin ?? void 0), en(e._zod, "optout", () => e._zod.innerType?._zod?.optout ?? void 0), e._zod.parse = (n, r) => e._zod.innerType._zod.run(n, r);
}), Hge = /* @__PURE__ */ De("$ZodCustom", (e, t) => {
  Zi.init(e, t), Vn.init(e, t), e._zod.parse = (n, r) => n, e._zod.check = (n) => {
    const r = n.value, i = t.fn(r);
    if (i instanceof Promise)
      return i.then((o) => SI(o, n, r, e));
    SI(i, n, r, e);
  };
});
function SI(e, t, n, r) {
  if (!e) {
    const i = {
      code: "custom",
      input: n,
      inst: r,
      // incorporates params.error into issue reporting
      path: [...r._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !r._zod.def.abort
      // params: inst._zod.def.params,
    };
    r._zod.def.params && (i.params = r._zod.def.params), t.issues.push(ig(i));
  }
}
var kI;
class Wge {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    const r = n[0];
    return this._map.set(t, r), r && typeof r == "object" && "id" in r && this._idmap.set(r.id, t), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const n = this._map.get(t);
    return n && typeof n == "object" && "id" in n && this._idmap.delete(n.id), this._map.delete(t), this;
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const r = { ...this.get(n) ?? {} };
      delete r.id;
      const i = { ...r, ...this._map.get(t) };
      return Object.keys(i).length ? i : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function qge() {
  return new Wge();
}
(kI = globalThis).__zod_globalRegistry ?? (kI.__zod_globalRegistry = qge());
const cm = globalThis.__zod_globalRegistry;
// @__NO_SIDE_EFFECTS__
function Gge(e, t) {
  return new e({
    type: "string",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Kge(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function CI(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Zge(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Yge(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Xge(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Jge(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Qge(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function eye(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function tye(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function nye(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function rye(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function iye(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function oye(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function sye(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function aye(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function lye(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function cye(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function uye(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function dye(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function fye(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function hye(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function pye(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function mye(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function gye(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function yye(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function vye(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function bye(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function xye(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function wye(e, t) {
  return new e({
    type: "boolean",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Sye(e, t) {
  return new e({
    type: "null",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function kye(e) {
  return new e({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function Cye(e, t) {
  return new e({
    type: "never",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function EI(e, t) {
  return new S8({
    check: "less_than",
    ...ct(t),
    value: e,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function rC(e, t) {
  return new S8({
    check: "less_than",
    ...ct(t),
    value: e,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function _I(e, t) {
  return new k8({
    check: "greater_than",
    ...ct(t),
    value: e,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function iC(e, t) {
  return new k8({
    check: "greater_than",
    ...ct(t),
    value: e,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function TI(e, t) {
  return new Ime({
    check: "multiple_of",
    ...ct(t),
    value: e
  });
}
// @__NO_SIDE_EFFECTS__
function N8(e, t) {
  return new Lme({
    check: "max_length",
    ...ct(t),
    maximum: e
  });
}
// @__NO_SIDE_EFFECTS__
function wb(e, t) {
  return new Bme({
    check: "min_length",
    ...ct(t),
    minimum: e
  });
}
// @__NO_SIDE_EFFECTS__
function R8(e, t) {
  return new $me({
    check: "length_equals",
    ...ct(t),
    length: e
  });
}
// @__NO_SIDE_EFFECTS__
function Eye(e, t) {
  return new Ume({
    check: "string_format",
    format: "regex",
    ...ct(t),
    pattern: e
  });
}
// @__NO_SIDE_EFFECTS__
function _ye(e) {
  return new Fme({
    check: "string_format",
    format: "lowercase",
    ...ct(e)
  });
}
// @__NO_SIDE_EFFECTS__
function Tye(e) {
  return new Vme({
    check: "string_format",
    format: "uppercase",
    ...ct(e)
  });
}
// @__NO_SIDE_EFFECTS__
function Aye(e, t) {
  return new Hme({
    check: "string_format",
    format: "includes",
    ...ct(t),
    includes: e
  });
}
// @__NO_SIDE_EFFECTS__
function Mye(e, t) {
  return new Wme({
    check: "string_format",
    format: "starts_with",
    ...ct(t),
    prefix: e
  });
}
// @__NO_SIDE_EFFECTS__
function Nye(e, t) {
  return new qme({
    check: "string_format",
    format: "ends_with",
    ...ct(t),
    suffix: e
  });
}
// @__NO_SIDE_EFFECTS__
function zh(e) {
  return new Gme({
    check: "overwrite",
    tx: e
  });
}
// @__NO_SIDE_EFFECTS__
function Rye(e) {
  return /* @__PURE__ */ zh((t) => t.normalize(e));
}
// @__NO_SIDE_EFFECTS__
function Oye() {
  return /* @__PURE__ */ zh((e) => e.trim());
}
// @__NO_SIDE_EFFECTS__
function Dye() {
  return /* @__PURE__ */ zh((e) => e.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function Pye() {
  return /* @__PURE__ */ zh((e) => e.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function jye() {
  return /* @__PURE__ */ zh((e) => $pe(e));
}
// @__NO_SIDE_EFFECTS__
function Iye(e, t, n) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...ct(n)
  });
}
// @__NO_SIDE_EFFECTS__
function zye(e, t, n) {
  const r = ct(n);
  return r.abort ?? (r.abort = !0), new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...r
  });
}
// @__NO_SIDE_EFFECTS__
function Lye(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...ct(n)
  });
}
// @__NO_SIDE_EFFECTS__
function Bye(e) {
  const t = /* @__PURE__ */ $ye((n) => (n.addIssue = (r) => {
    if (typeof r == "string")
      n.issues.push(ig(r, n.value, t._zod.def));
    else {
      const i = r;
      i.fatal && (i.continue = !1), i.code ?? (i.code = "custom"), i.input ?? (i.input = n.value), i.inst ?? (i.inst = t), i.continue ?? (i.continue = !t._zod.def.abort), n.issues.push(ig(i));
    }
  }, e(n.value, n)));
  return t;
}
// @__NO_SIDE_EFFECTS__
function $ye(e, t) {
  const n = new Zi({
    check: "custom",
    ...ct(t)
  });
  return n._zod.check = e, n;
}
function Sb(e) {
  let t = e?.target ?? "draft-2020-12";
  return t === "draft-4" && (t = "draft-04"), t === "draft-7" && (t = "draft-07"), {
    processors: e.processors ?? {},
    metadataRegistry: e?.metadata ?? cm,
    target: t,
    unrepresentable: e?.unrepresentable ?? "throw",
    override: e?.override ?? (() => {
    }),
    io: e?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: e?.cycles ?? "ref",
    reused: e?.reused ?? "inline",
    external: e?.external ?? void 0
  };
}
function On(e, t, n = { path: [], schemaPath: [] }) {
  var r;
  const i = e._zod.def, o = t.seen.get(e);
  if (o)
    return o.count++, n.schemaPath.includes(e) && (o.cycle = n.path), o.schema;
  const s = { schema: {}, count: 1, cycle: void 0, path: n.path };
  t.seen.set(e, s);
  const a = e._zod.toJSONSchema?.();
  if (a)
    s.schema = a;
  else {
    const f = {
      ...n,
      schemaPath: [...n.schemaPath, e],
      path: n.path
    };
    if (e._zod.processJSONSchema)
      e._zod.processJSONSchema(t, s.schema, f);
    else {
      const m = s.schema, g = t.processors[i.type];
      if (!g)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${i.type}`);
      g(e, t, m, f);
    }
    const h = e._zod.parent;
    h && (s.ref || (s.ref = h), On(h, t, f), t.seen.get(h).isParent = !0);
  }
  const c = t.metadataRegistry.get(e);
  return c && Object.assign(s.schema, c), t.io === "input" && Ei(e) && (delete s.schema.examples, delete s.schema.default), t.io === "input" && s.schema._prefault && ((r = s.schema).default ?? (r.default = s.schema._prefault)), delete s.schema._prefault, t.seen.get(e).schema;
}
function kb(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const r = /* @__PURE__ */ new Map();
  for (const s of e.seen.entries()) {
    const a = e.metadataRegistry.get(s[0])?.id;
    if (a) {
      const c = r.get(a);
      if (c && c !== s[0])
        throw new Error(`Duplicate schema id "${a}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      r.set(a, s[0]);
    }
  }
  const i = (s) => {
    const a = e.target === "draft-2020-12" ? "$defs" : "definitions";
    if (e.external) {
      const h = e.external.registry.get(s[0])?.id, m = e.external.uri ?? ((b) => b);
      if (h)
        return { ref: m(h) };
      const g = s[1].defId ?? s[1].schema.id ?? `schema${e.counter++}`;
      return s[1].defId = g, { defId: g, ref: `${m("__shared")}#/${a}/${g}` };
    }
    if (s[1] === n)
      return { ref: "#" };
    const u = `#/${a}/`, f = s[1].schema.id ?? `__schema${e.counter++}`;
    return { defId: f, ref: u + f };
  }, o = (s) => {
    if (s[1].schema.$ref)
      return;
    const a = s[1], { ref: c, defId: u } = i(s);
    a.def = { ...a.schema }, u && (a.defId = u);
    const f = a.schema;
    for (const h in f)
      delete f[h];
    f.$ref = c;
  };
  if (e.cycles === "throw")
    for (const s of e.seen.entries()) {
      const a = s[1];
      if (a.cycle)
        throw new Error(`Cycle detected: #/${a.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (const s of e.seen.entries()) {
    const a = s[1];
    if (t === s[0]) {
      o(s);
      continue;
    }
    if (e.external) {
      const u = e.external.registry.get(s[0])?.id;
      if (t !== s[0] && u) {
        o(s);
        continue;
      }
    }
    if (e.metadataRegistry.get(s[0])?.id) {
      o(s);
      continue;
    }
    if (a.cycle) {
      o(s);
      continue;
    }
    if (a.count > 1 && e.reused === "ref") {
      o(s);
      continue;
    }
  }
}
function Cb(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const r = (s) => {
    const a = e.seen.get(s);
    if (a.ref === null)
      return;
    const c = a.def ?? a.schema, u = { ...c }, f = a.ref;
    if (a.ref = null, f) {
      r(f);
      const m = e.seen.get(f), g = m.schema;
      if (g.$ref && (e.target === "draft-07" || e.target === "draft-04" || e.target === "openapi-3.0") ? (c.allOf = c.allOf ?? [], c.allOf.push(g)) : Object.assign(c, g), Object.assign(c, u), s._zod.parent === f)
        for (const x in c)
          x === "$ref" || x === "allOf" || x in u || delete c[x];
      if (g.$ref && m.def)
        for (const x in c)
          x === "$ref" || x === "allOf" || x in m.def && JSON.stringify(c[x]) === JSON.stringify(m.def[x]) && delete c[x];
    }
    const h = s._zod.parent;
    if (h && h !== f) {
      r(h);
      const m = e.seen.get(h);
      if (m?.schema.$ref && (c.$ref = m.schema.$ref, m.def))
        for (const g in c)
          g === "$ref" || g === "allOf" || g in m.def && JSON.stringify(c[g]) === JSON.stringify(m.def[g]) && delete c[g];
    }
    e.override({
      zodSchema: s,
      jsonSchema: c,
      path: a.path ?? []
    });
  };
  for (const s of [...e.seen.entries()].reverse())
    r(s[0]);
  const i = {};
  if (e.target === "draft-2020-12" ? i.$schema = "https://json-schema.org/draft/2020-12/schema" : e.target === "draft-07" ? i.$schema = "http://json-schema.org/draft-07/schema#" : e.target === "draft-04" ? i.$schema = "http://json-schema.org/draft-04/schema#" : e.target, e.external?.uri) {
    const s = e.external.registry.get(t)?.id;
    if (!s)
      throw new Error("Schema is missing an `id` property");
    i.$id = e.external.uri(s);
  }
  Object.assign(i, n.def ?? n.schema);
  const o = e.external?.defs ?? {};
  for (const s of e.seen.entries()) {
    const a = s[1];
    a.def && a.defId && (o[a.defId] = a.def);
  }
  e.external || Object.keys(o).length > 0 && (e.target === "draft-2020-12" ? i.$defs = o : i.definitions = o);
  try {
    const s = JSON.parse(JSON.stringify(i));
    return Object.defineProperty(s, "~standard", {
      value: {
        ...t["~standard"],
        jsonSchema: {
          input: Eb(t, "input", e.processors),
          output: Eb(t, "output", e.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), s;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function Ei(e, t) {
  const n = t ?? { seen: /* @__PURE__ */ new Set() };
  if (n.seen.has(e))
    return !1;
  n.seen.add(e);
  const r = e._zod.def;
  if (r.type === "transform")
    return !0;
  if (r.type === "array")
    return Ei(r.element, n);
  if (r.type === "set")
    return Ei(r.valueType, n);
  if (r.type === "lazy")
    return Ei(r.getter(), n);
  if (r.type === "promise" || r.type === "optional" || r.type === "nonoptional" || r.type === "nullable" || r.type === "readonly" || r.type === "default" || r.type === "prefault")
    return Ei(r.innerType, n);
  if (r.type === "intersection")
    return Ei(r.left, n) || Ei(r.right, n);
  if (r.type === "record" || r.type === "map")
    return Ei(r.keyType, n) || Ei(r.valueType, n);
  if (r.type === "pipe")
    return Ei(r.in, n) || Ei(r.out, n);
  if (r.type === "object") {
    for (const i in r.shape)
      if (Ei(r.shape[i], n))
        return !0;
    return !1;
  }
  if (r.type === "union") {
    for (const i of r.options)
      if (Ei(i, n))
        return !0;
    return !1;
  }
  if (r.type === "tuple") {
    for (const i of r.items)
      if (Ei(i, n))
        return !0;
    return !!(r.rest && Ei(r.rest, n));
  }
  return !1;
}
const Uye = (e, t = {}) => (n) => {
  const r = Sb({ ...n, processors: t });
  return On(e, r), kb(r, e), Cb(r, e);
}, Eb = (e, t, n = {}) => (r) => {
  const { libraryOptions: i, target: o } = r ?? {}, s = Sb({ ...i ?? {}, target: o, io: t, processors: n });
  return On(e, s), kb(s, e), Cb(s, e);
}, Fye = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, O8 = (e, t, n, r) => {
  const i = n;
  i.type = "string";
  const { minimum: o, maximum: s, format: a, patterns: c, contentEncoding: u } = e._zod.bag;
  if (typeof o == "number" && (i.minLength = o), typeof s == "number" && (i.maxLength = s), a && (i.format = Fye[a] ?? a, i.format === "" && delete i.format, a === "time" && delete i.format), u && (i.contentEncoding = u), c && c.size > 0) {
    const f = [...c];
    f.length === 1 ? i.pattern = f[0].source : f.length > 1 && (i.allOf = [
      ...f.map((h) => ({
        ...t.target === "draft-07" || t.target === "draft-04" || t.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: h.source
      }))
    ]);
  }
}, D8 = (e, t, n, r) => {
  const i = n, { minimum: o, maximum: s, format: a, multipleOf: c, exclusiveMaximum: u, exclusiveMinimum: f } = e._zod.bag;
  typeof a == "string" && a.includes("int") ? i.type = "integer" : i.type = "number", typeof f == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (i.minimum = f, i.exclusiveMinimum = !0) : i.exclusiveMinimum = f), typeof o == "number" && (i.minimum = o, typeof f == "number" && t.target !== "draft-04" && (f >= o ? delete i.minimum : delete i.exclusiveMinimum)), typeof u == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (i.maximum = u, i.exclusiveMaximum = !0) : i.exclusiveMaximum = u), typeof s == "number" && (i.maximum = s, typeof u == "number" && t.target !== "draft-04" && (u <= s ? delete i.maximum : delete i.exclusiveMaximum)), typeof c == "number" && (i.multipleOf = c);
}, P8 = (e, t, n, r) => {
  n.type = "boolean";
}, Vye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("BigInt cannot be represented in JSON Schema");
}, Hye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Symbols cannot be represented in JSON Schema");
}, j8 = (e, t, n, r) => {
  t.target === "openapi-3.0" ? (n.type = "string", n.nullable = !0, n.enum = [null]) : n.type = "null";
}, Wye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Undefined cannot be represented in JSON Schema");
}, qye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Void cannot be represented in JSON Schema");
}, I8 = (e, t, n, r) => {
  n.not = {};
}, Gye = (e, t, n, r) => {
}, z8 = (e, t, n, r) => {
}, Kye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Date cannot be represented in JSON Schema");
}, L8 = (e, t, n, r) => {
  const i = e._zod.def, o = d8(i.entries);
  o.every((s) => typeof s == "number") && (n.type = "number"), o.every((s) => typeof s == "string") && (n.type = "string"), n.enum = o;
}, B8 = (e, t, n, r) => {
  const i = e._zod.def, o = [];
  for (const s of i.values)
    if (s === void 0) {
      if (t.unrepresentable === "throw")
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof s == "bigint") {
      if (t.unrepresentable === "throw")
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      o.push(Number(s));
    } else
      o.push(s);
  if (o.length !== 0) if (o.length === 1) {
    const s = o[0];
    n.type = s === null ? "null" : typeof s, t.target === "draft-04" || t.target === "openapi-3.0" ? n.enum = [s] : n.const = s;
  } else
    o.every((s) => typeof s == "number") && (n.type = "number"), o.every((s) => typeof s == "string") && (n.type = "string"), o.every((s) => typeof s == "boolean") && (n.type = "boolean"), o.every((s) => s === null) && (n.type = "null"), n.enum = o;
}, Zye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("NaN cannot be represented in JSON Schema");
}, Yye = (e, t, n, r) => {
  const i = n, o = e._zod.pattern;
  if (!o)
    throw new Error("Pattern not found in template literal");
  i.type = "string", i.pattern = o.source;
}, Xye = (e, t, n, r) => {
  const i = n, o = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  }, { minimum: s, maximum: a, mime: c } = e._zod.bag;
  s !== void 0 && (o.minLength = s), a !== void 0 && (o.maxLength = a), c ? c.length === 1 ? (o.contentMediaType = c[0], Object.assign(i, o)) : (Object.assign(i, o), i.anyOf = c.map((u) => ({ contentMediaType: u }))) : Object.assign(i, o);
}, Jye = (e, t, n, r) => {
  n.type = "boolean";
}, $8 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, Qye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Function types cannot be represented in JSON Schema");
}, U8 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, eve = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Map cannot be represented in JSON Schema");
}, tve = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Set cannot be represented in JSON Schema");
}, F8 = (e, t, n, r) => {
  const i = n, o = e._zod.def, { minimum: s, maximum: a } = e._zod.bag;
  typeof s == "number" && (i.minItems = s), typeof a == "number" && (i.maxItems = a), i.type = "array", i.items = On(o.element, t, { ...r, path: [...r.path, "items"] });
}, V8 = (e, t, n, r) => {
  const i = n, o = e._zod.def;
  i.type = "object", i.properties = {};
  const s = o.shape;
  for (const u in s)
    i.properties[u] = On(s[u], t, {
      ...r,
      path: [...r.path, "properties", u]
    });
  const a = new Set(Object.keys(s)), c = new Set([...a].filter((u) => {
    const f = o.shape[u]._zod;
    return t.io === "input" ? f.optin === void 0 : f.optout === void 0;
  }));
  c.size > 0 && (i.required = Array.from(c)), o.catchall?._zod.def.type === "never" ? i.additionalProperties = !1 : o.catchall ? o.catchall && (i.additionalProperties = On(o.catchall, t, {
    ...r,
    path: [...r.path, "additionalProperties"]
  })) : t.io === "output" && (i.additionalProperties = !1);
}, H8 = (e, t, n, r) => {
  const i = e._zod.def, o = i.inclusive === !1, s = i.options.map((a, c) => On(a, t, {
    ...r,
    path: [...r.path, o ? "oneOf" : "anyOf", c]
  }));
  o ? n.oneOf = s : n.anyOf = s;
}, W8 = (e, t, n, r) => {
  const i = e._zod.def, o = On(i.left, t, {
    ...r,
    path: [...r.path, "allOf", 0]
  }), s = On(i.right, t, {
    ...r,
    path: [...r.path, "allOf", 1]
  }), a = (u) => "allOf" in u && Object.keys(u).length === 1, c = [
    ...a(o) ? o.allOf : [o],
    ...a(s) ? s.allOf : [s]
  ];
  n.allOf = c;
}, nve = (e, t, n, r) => {
  const i = n, o = e._zod.def;
  i.type = "array";
  const s = t.target === "draft-2020-12" ? "prefixItems" : "items", a = t.target === "draft-2020-12" || t.target === "openapi-3.0" ? "items" : "additionalItems", c = o.items.map((m, g) => On(m, t, {
    ...r,
    path: [...r.path, s, g]
  })), u = o.rest ? On(o.rest, t, {
    ...r,
    path: [...r.path, a, ...t.target === "openapi-3.0" ? [o.items.length] : []]
  }) : null;
  t.target === "draft-2020-12" ? (i.prefixItems = c, u && (i.items = u)) : t.target === "openapi-3.0" ? (i.items = {
    anyOf: c
  }, u && i.items.anyOf.push(u), i.minItems = c.length, u || (i.maxItems = c.length)) : (i.items = c, u && (i.additionalItems = u));
  const { minimum: f, maximum: h } = e._zod.bag;
  typeof f == "number" && (i.minItems = f), typeof h == "number" && (i.maxItems = h);
}, q8 = (e, t, n, r) => {
  const i = n, o = e._zod.def;
  i.type = "object";
  const s = o.keyType, c = s._zod.bag?.patterns;
  if (o.mode === "loose" && c && c.size > 0) {
    const f = On(o.valueType, t, {
      ...r,
      path: [...r.path, "patternProperties", "*"]
    });
    i.patternProperties = {};
    for (const h of c)
      i.patternProperties[h.source] = f;
  } else
    (t.target === "draft-07" || t.target === "draft-2020-12") && (i.propertyNames = On(o.keyType, t, {
      ...r,
      path: [...r.path, "propertyNames"]
    })), i.additionalProperties = On(o.valueType, t, {
      ...r,
      path: [...r.path, "additionalProperties"]
    });
  const u = s._zod.values;
  if (u) {
    const f = [...u].filter((h) => typeof h == "string" || typeof h == "number");
    f.length > 0 && (i.required = f);
  }
}, G8 = (e, t, n, r) => {
  const i = e._zod.def, o = On(i.innerType, t, r), s = t.seen.get(e);
  t.target === "openapi-3.0" ? (s.ref = i.innerType, n.nullable = !0) : n.anyOf = [o, { type: "null" }];
}, K8 = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType;
}, Z8 = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType, n.default = JSON.parse(JSON.stringify(i.defaultValue));
}, Y8 = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType, t.io === "input" && (n._prefault = JSON.parse(JSON.stringify(i.defaultValue)));
}, X8 = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType;
  let s;
  try {
    s = i.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  n.default = s;
}, J8 = (e, t, n, r) => {
  const i = e._zod.def, o = t.io === "input" ? i.in._zod.def.type === "transform" ? i.out : i.in : i.out;
  On(o, t, r);
  const s = t.seen.get(e);
  s.ref = o;
}, Q8 = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType, n.readOnly = !0;
}, rve = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType;
}, _M = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType;
}, eF = (e, t, n, r) => {
  const i = e._zod.innerType;
  On(i, t, r);
  const o = t.seen.get(e);
  o.ref = i;
}, AI = {
  string: O8,
  number: D8,
  boolean: P8,
  bigint: Vye,
  symbol: Hye,
  null: j8,
  undefined: Wye,
  void: qye,
  never: I8,
  any: Gye,
  unknown: z8,
  date: Kye,
  enum: L8,
  literal: B8,
  nan: Zye,
  template_literal: Yye,
  file: Xye,
  success: Jye,
  custom: $8,
  function: Qye,
  transform: U8,
  map: eve,
  set: tve,
  array: F8,
  object: V8,
  union: H8,
  intersection: W8,
  tuple: nve,
  record: q8,
  nullable: G8,
  nonoptional: K8,
  default: Z8,
  prefault: Y8,
  catch: X8,
  pipe: J8,
  readonly: Q8,
  promise: rve,
  optional: _M,
  lazy: eF
};
function ive(e, t) {
  if ("_idmap" in e) {
    const r = e, i = Sb({ ...t, processors: AI }), o = {};
    for (const c of r._idmap.entries()) {
      const [u, f] = c;
      On(f, i);
    }
    const s = {}, a = {
      registry: r,
      uri: t?.uri,
      defs: o
    };
    i.external = a;
    for (const c of r._idmap.entries()) {
      const [u, f] = c;
      kb(i, f), s[u] = Cb(i, f);
    }
    if (Object.keys(o).length > 0) {
      const c = i.target === "draft-2020-12" ? "$defs" : "definitions";
      s.__shared = {
        [c]: o
      };
    }
    return { schemas: s };
  }
  const n = Sb({ ...t, processors: AI });
  return On(e, n), kb(n, e), Cb(n, e);
}
const ove = /* @__PURE__ */ De("ZodISODateTime", (e, t) => {
  age.init(e, t), Xn.init(e, t);
});
function sve(e) {
  return /* @__PURE__ */ mye(ove, e);
}
const ave = /* @__PURE__ */ De("ZodISODate", (e, t) => {
  lge.init(e, t), Xn.init(e, t);
});
function lve(e) {
  return /* @__PURE__ */ gye(ave, e);
}
const cve = /* @__PURE__ */ De("ZodISOTime", (e, t) => {
  cge.init(e, t), Xn.init(e, t);
});
function uve(e) {
  return /* @__PURE__ */ yye(cve, e);
}
const dve = /* @__PURE__ */ De("ZodISODuration", (e, t) => {
  uge.init(e, t), Xn.init(e, t);
});
function fve(e) {
  return /* @__PURE__ */ vye(dve, e);
}
const hve = (e, t) => {
  m8.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (n) => Qpe(e, n)
      // enumerable: false,
    },
    flatten: {
      value: (n) => Jpe(e, n)
      // enumerable: false,
    },
    addIssue: {
      value: (n) => {
        e.issues.push(n), e.message = JSON.stringify(e.issues, E_, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (n) => {
        e.issues.push(...n), e.message = JSON.stringify(e.issues, E_, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, Go = De("ZodError", hve, {
  Parent: Error
}), pve = /* @__PURE__ */ kM(Go), mve = /* @__PURE__ */ CM(Go), gve = /* @__PURE__ */ kw(Go), tF = /* @__PURE__ */ Cw(Go), yve = /* @__PURE__ */ nme(Go), vve = /* @__PURE__ */ rme(Go), bve = /* @__PURE__ */ ime(Go), xve = /* @__PURE__ */ ome(Go), wve = /* @__PURE__ */ sme(Go), Sve = /* @__PURE__ */ ame(Go), kve = /* @__PURE__ */ lme(Go), Cve = /* @__PURE__ */ cme(Go), Hn = /* @__PURE__ */ De("ZodType", (e, t) => (Vn.init(e, t), Object.assign(e["~standard"], {
  jsonSchema: {
    input: Eb(e, "input"),
    output: Eb(e, "output")
  }
}), e.toJSONSchema = Uye(e, {}), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone($c(t, {
  checks: [
    ...t.checks ?? [],
    ...n.map((r) => typeof r == "function" ? { _zod: { check: r, def: { check: "custom" }, onattach: [] } } : r)
  ]
}), {
  parent: !0
}), e.with = e.check, e.clone = (n, r) => Uc(e, n, r), e.brand = () => e, e.register = ((n, r) => (n.add(e, r), e)), e.parse = (n, r) => pve(e, n, r, { callee: e.parse }), e.safeParse = (n, r) => gve(e, n, r), e.parseAsync = async (n, r) => mve(e, n, r, { callee: e.parseAsync }), e.safeParseAsync = async (n, r) => tF(e, n, r), e.spa = e.safeParseAsync, e.encode = (n, r) => yve(e, n, r), e.decode = (n, r) => vve(e, n, r), e.encodeAsync = async (n, r) => bve(e, n, r), e.decodeAsync = async (n, r) => xve(e, n, r), e.safeEncode = (n, r) => wve(e, n, r), e.safeDecode = (n, r) => Sve(e, n, r), e.safeEncodeAsync = async (n, r) => kve(e, n, r), e.safeDecodeAsync = async (n, r) => Cve(e, n, r), e.refine = (n, r) => e.check(x0e(n, r)), e.superRefine = (n) => e.check(w0e(n)), e.overwrite = (n) => e.check(/* @__PURE__ */ zh(n)), e.optional = () => RI(e), e.exactOptional = () => s0e(e), e.nullable = () => OI(e), e.nullish = () => RI(OI(e)), e.nonoptional = (n) => f0e(e, n), e.array = () => Lh(e), e.or = (n) => Wo([e, n]), e.and = (n) => e0e(e, n), e.transform = (n) => DI(e, i0e(n)), e.default = (n) => c0e(e, n), e.prefault = (n) => d0e(e, n), e.catch = (n) => p0e(e, n), e.pipe = (n) => DI(e, n), e.readonly = () => y0e(e), e.describe = (n) => {
  const r = e.clone();
  return cm.add(r, { description: n }), r;
}, Object.defineProperty(e, "description", {
  get() {
    return cm.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...n) => {
  if (n.length === 0)
    return cm.get(e);
  const r = e.clone();
  return cm.add(r, n[0]), r;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e.apply = (n) => n(e), e)), nF = /* @__PURE__ */ De("_ZodString", (e, t) => {
  EM.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (r, i, o) => O8(e, r, i);
  const n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...r) => e.check(/* @__PURE__ */ Eye(...r)), e.includes = (...r) => e.check(/* @__PURE__ */ Aye(...r)), e.startsWith = (...r) => e.check(/* @__PURE__ */ Mye(...r)), e.endsWith = (...r) => e.check(/* @__PURE__ */ Nye(...r)), e.min = (...r) => e.check(/* @__PURE__ */ wb(...r)), e.max = (...r) => e.check(/* @__PURE__ */ N8(...r)), e.length = (...r) => e.check(/* @__PURE__ */ R8(...r)), e.nonempty = (...r) => e.check(/* @__PURE__ */ wb(1, ...r)), e.lowercase = (r) => e.check(/* @__PURE__ */ _ye(r)), e.uppercase = (r) => e.check(/* @__PURE__ */ Tye(r)), e.trim = () => e.check(/* @__PURE__ */ Oye()), e.normalize = (...r) => e.check(/* @__PURE__ */ Rye(...r)), e.toLowerCase = () => e.check(/* @__PURE__ */ Dye()), e.toUpperCase = () => e.check(/* @__PURE__ */ Pye()), e.slugify = () => e.check(/* @__PURE__ */ jye());
}), Eve = /* @__PURE__ */ De("ZodString", (e, t) => {
  EM.init(e, t), nF.init(e, t), e.email = (n) => e.check(/* @__PURE__ */ Kge(_ve, n)), e.url = (n) => e.check(/* @__PURE__ */ Qge(Tve, n)), e.jwt = (n) => e.check(/* @__PURE__ */ pye(Fve, n)), e.emoji = (n) => e.check(/* @__PURE__ */ eye(Ave, n)), e.guid = (n) => e.check(/* @__PURE__ */ CI(MI, n)), e.uuid = (n) => e.check(/* @__PURE__ */ Zge(Bv, n)), e.uuidv4 = (n) => e.check(/* @__PURE__ */ Yge(Bv, n)), e.uuidv6 = (n) => e.check(/* @__PURE__ */ Xge(Bv, n)), e.uuidv7 = (n) => e.check(/* @__PURE__ */ Jge(Bv, n)), e.nanoid = (n) => e.check(/* @__PURE__ */ tye(Mve, n)), e.guid = (n) => e.check(/* @__PURE__ */ CI(MI, n)), e.cuid = (n) => e.check(/* @__PURE__ */ nye(Nve, n)), e.cuid2 = (n) => e.check(/* @__PURE__ */ rye(Rve, n)), e.ulid = (n) => e.check(/* @__PURE__ */ iye(Ove, n)), e.base64 = (n) => e.check(/* @__PURE__ */ dye(Bve, n)), e.base64url = (n) => e.check(/* @__PURE__ */ fye($ve, n)), e.xid = (n) => e.check(/* @__PURE__ */ oye(Dve, n)), e.ksuid = (n) => e.check(/* @__PURE__ */ sye(Pve, n)), e.ipv4 = (n) => e.check(/* @__PURE__ */ aye(jve, n)), e.ipv6 = (n) => e.check(/* @__PURE__ */ lye(Ive, n)), e.cidrv4 = (n) => e.check(/* @__PURE__ */ cye(zve, n)), e.cidrv6 = (n) => e.check(/* @__PURE__ */ uye(Lve, n)), e.e164 = (n) => e.check(/* @__PURE__ */ hye(Uve, n)), e.datetime = (n) => e.check(sve(n)), e.date = (n) => e.check(lve(n)), e.time = (n) => e.check(uve(n)), e.duration = (n) => e.check(fve(n));
});
function gt(e) {
  return /* @__PURE__ */ Gge(Eve, e);
}
const Xn = /* @__PURE__ */ De("ZodStringFormat", (e, t) => {
  Kn.init(e, t), nF.init(e, t);
}), _ve = /* @__PURE__ */ De("ZodEmail", (e, t) => {
  Jme.init(e, t), Xn.init(e, t);
}), MI = /* @__PURE__ */ De("ZodGUID", (e, t) => {
  Yme.init(e, t), Xn.init(e, t);
}), Bv = /* @__PURE__ */ De("ZodUUID", (e, t) => {
  Xme.init(e, t), Xn.init(e, t);
}), Tve = /* @__PURE__ */ De("ZodURL", (e, t) => {
  Qme.init(e, t), Xn.init(e, t);
}), Ave = /* @__PURE__ */ De("ZodEmoji", (e, t) => {
  ege.init(e, t), Xn.init(e, t);
}), Mve = /* @__PURE__ */ De("ZodNanoID", (e, t) => {
  tge.init(e, t), Xn.init(e, t);
}), Nve = /* @__PURE__ */ De("ZodCUID", (e, t) => {
  nge.init(e, t), Xn.init(e, t);
}), Rve = /* @__PURE__ */ De("ZodCUID2", (e, t) => {
  rge.init(e, t), Xn.init(e, t);
}), Ove = /* @__PURE__ */ De("ZodULID", (e, t) => {
  ige.init(e, t), Xn.init(e, t);
}), Dve = /* @__PURE__ */ De("ZodXID", (e, t) => {
  oge.init(e, t), Xn.init(e, t);
}), Pve = /* @__PURE__ */ De("ZodKSUID", (e, t) => {
  sge.init(e, t), Xn.init(e, t);
}), jve = /* @__PURE__ */ De("ZodIPv4", (e, t) => {
  dge.init(e, t), Xn.init(e, t);
}), Ive = /* @__PURE__ */ De("ZodIPv6", (e, t) => {
  fge.init(e, t), Xn.init(e, t);
}), zve = /* @__PURE__ */ De("ZodCIDRv4", (e, t) => {
  hge.init(e, t), Xn.init(e, t);
}), Lve = /* @__PURE__ */ De("ZodCIDRv6", (e, t) => {
  pge.init(e, t), Xn.init(e, t);
}), Bve = /* @__PURE__ */ De("ZodBase64", (e, t) => {
  mge.init(e, t), Xn.init(e, t);
}), $ve = /* @__PURE__ */ De("ZodBase64URL", (e, t) => {
  yge.init(e, t), Xn.init(e, t);
}), Uve = /* @__PURE__ */ De("ZodE164", (e, t) => {
  vge.init(e, t), Xn.init(e, t);
}), Fve = /* @__PURE__ */ De("ZodJWT", (e, t) => {
  xge.init(e, t), Xn.init(e, t);
}), rF = /* @__PURE__ */ De("ZodNumber", (e, t) => {
  E8.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (r, i, o) => D8(e, r, i), e.gt = (r, i) => e.check(/* @__PURE__ */ _I(r, i)), e.gte = (r, i) => e.check(/* @__PURE__ */ iC(r, i)), e.min = (r, i) => e.check(/* @__PURE__ */ iC(r, i)), e.lt = (r, i) => e.check(/* @__PURE__ */ EI(r, i)), e.lte = (r, i) => e.check(/* @__PURE__ */ rC(r, i)), e.max = (r, i) => e.check(/* @__PURE__ */ rC(r, i)), e.int = (r) => e.check(NI(r)), e.safe = (r) => e.check(NI(r)), e.positive = (r) => e.check(/* @__PURE__ */ _I(0, r)), e.nonnegative = (r) => e.check(/* @__PURE__ */ iC(0, r)), e.negative = (r) => e.check(/* @__PURE__ */ EI(0, r)), e.nonpositive = (r) => e.check(/* @__PURE__ */ rC(0, r)), e.multipleOf = (r, i) => e.check(/* @__PURE__ */ TI(r, i)), e.step = (r, i) => e.check(/* @__PURE__ */ TI(r, i)), e.finite = () => e;
  const n = e._zod.bag;
  e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? 0.5), e.isFinite = !0, e.format = n.format ?? null;
});
function Vve(e) {
  return /* @__PURE__ */ bye(rF, e);
}
const Hve = /* @__PURE__ */ De("ZodNumberFormat", (e, t) => {
  wge.init(e, t), rF.init(e, t);
});
function NI(e) {
  return /* @__PURE__ */ xye(Hve, e);
}
const Wve = /* @__PURE__ */ De("ZodBoolean", (e, t) => {
  Sge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => P8(e, n, r);
});
function Wi(e) {
  return /* @__PURE__ */ wye(Wve, e);
}
const qve = /* @__PURE__ */ De("ZodNull", (e, t) => {
  kge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => j8(e, n, r);
});
function Gve(e) {
  return /* @__PURE__ */ Sye(qve, e);
}
const Kve = /* @__PURE__ */ De("ZodUnknown", (e, t) => {
  Cge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => z8();
});
function Us() {
  return /* @__PURE__ */ kye(Kve);
}
const Zve = /* @__PURE__ */ De("ZodNever", (e, t) => {
  Ege.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => I8(e, n, r);
});
function iF(e) {
  return /* @__PURE__ */ Cye(Zve, e);
}
const Yve = /* @__PURE__ */ De("ZodArray", (e, t) => {
  _ge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => F8(e, n, r, i), e.element = t.element, e.min = (n, r) => e.check(/* @__PURE__ */ wb(n, r)), e.nonempty = (n) => e.check(/* @__PURE__ */ wb(1, n)), e.max = (n, r) => e.check(/* @__PURE__ */ N8(n, r)), e.length = (n, r) => e.check(/* @__PURE__ */ R8(n, r)), e.unwrap = () => e.element;
});
function Lh(e, t) {
  return /* @__PURE__ */ Iye(Yve, e, t);
}
const oF = /* @__PURE__ */ De("ZodObject", (e, t) => {
  Age.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => V8(e, n, r, i), en(e, "shape", () => t.shape), e.keyof = () => aF(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: Us() }), e.loose = () => e.clone({ ...e._zod.def, catchall: Us() }), e.strict = () => e.clone({ ...e._zod.def, catchall: iF() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => Gpe(e, n), e.safeExtend = (n) => Kpe(e, n), e.merge = (n) => Zpe(e, n), e.pick = (n) => Wpe(e, n), e.omit = (n) => qpe(e, n), e.partial = (...n) => Ype(lF, e, n[0]), e.required = (...n) => Xpe(cF, e, n[0]);
});
function ei(e, t) {
  const n = {
    type: "object",
    shape: e ?? {},
    ...ct(t)
  };
  return new oF(n);
}
function Yn(e, t) {
  return new oF({
    type: "object",
    shape: e,
    catchall: iF(),
    ...ct(t)
  });
}
const sF = /* @__PURE__ */ De("ZodUnion", (e, t) => {
  A8.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => H8(e, n, r, i), e.options = t.options;
});
function Wo(e, t) {
  return new sF({
    type: "union",
    options: e,
    ...ct(t)
  });
}
const Xve = /* @__PURE__ */ De("ZodDiscriminatedUnion", (e, t) => {
  sF.init(e, t), Mge.init(e, t);
});
function Jve(e, t, n) {
  return new Xve({
    type: "union",
    options: t,
    discriminator: e,
    ...ct(n)
  });
}
const Qve = /* @__PURE__ */ De("ZodIntersection", (e, t) => {
  Nge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => W8(e, n, r, i);
});
function e0e(e, t) {
  return new Qve({
    type: "intersection",
    left: e,
    right: t
  });
}
const t0e = /* @__PURE__ */ De("ZodRecord", (e, t) => {
  Rge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => q8(e, n, r, i), e.keyType = t.keyType, e.valueType = t.valueType;
});
function T_(e, t, n) {
  return new t0e({
    type: "record",
    keyType: e,
    valueType: t,
    ...ct(n)
  });
}
const A_ = /* @__PURE__ */ De("ZodEnum", (e, t) => {
  Oge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (r, i, o) => L8(e, r, i), e.enum = t.entries, e.options = Object.values(t.entries);
  const n = new Set(Object.keys(t.entries));
  e.extract = (r, i) => {
    const o = {};
    for (const s of r)
      if (n.has(s))
        o[s] = t.entries[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new A_({
      ...t,
      checks: [],
      ...ct(i),
      entries: o
    });
  }, e.exclude = (r, i) => {
    const o = { ...t.entries };
    for (const s of r)
      if (n.has(s))
        delete o[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new A_({
      ...t,
      checks: [],
      ...ct(i),
      entries: o
    });
  };
});
function aF(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((r) => [r, r])) : e;
  return new A_({
    type: "enum",
    entries: n,
    ...ct(t)
  });
}
const n0e = /* @__PURE__ */ De("ZodLiteral", (e, t) => {
  Dge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => B8(e, n, r), e.values = new Set(t.values), Object.defineProperty(e, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function Ut(e, t) {
  return new n0e({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...ct(t)
  });
}
const r0e = /* @__PURE__ */ De("ZodTransform", (e, t) => {
  Pge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => U8(e, n), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      throw new c8(e.constructor.name);
    n.addIssue = (o) => {
      if (typeof o == "string")
        n.issues.push(ig(o, n.value, t));
      else {
        const s = o;
        s.fatal && (s.continue = !1), s.code ?? (s.code = "custom"), s.input ?? (s.input = n.value), s.inst ?? (s.inst = e), n.issues.push(ig(s));
      }
    };
    const i = t.transform(n.value, n);
    return i instanceof Promise ? i.then((o) => (n.value = o, n)) : (n.value = i, n);
  };
});
function i0e(e) {
  return new r0e({
    type: "transform",
    transform: e
  });
}
const lF = /* @__PURE__ */ De("ZodOptional", (e, t) => {
  M8.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => _M(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function RI(e) {
  return new lF({
    type: "optional",
    innerType: e
  });
}
const o0e = /* @__PURE__ */ De("ZodExactOptional", (e, t) => {
  jge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => _M(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function s0e(e) {
  return new o0e({
    type: "optional",
    innerType: e
  });
}
const a0e = /* @__PURE__ */ De("ZodNullable", (e, t) => {
  Ige.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => G8(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function OI(e) {
  return new a0e({
    type: "nullable",
    innerType: e
  });
}
const l0e = /* @__PURE__ */ De("ZodDefault", (e, t) => {
  zge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => Z8(e, n, r, i), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function c0e(e, t) {
  return new l0e({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : h8(t);
    }
  });
}
const u0e = /* @__PURE__ */ De("ZodPrefault", (e, t) => {
  Lge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => Y8(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function d0e(e, t) {
  return new u0e({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : h8(t);
    }
  });
}
const cF = /* @__PURE__ */ De("ZodNonOptional", (e, t) => {
  Bge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => K8(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function f0e(e, t) {
  return new cF({
    type: "nonoptional",
    innerType: e,
    ...ct(t)
  });
}
const h0e = /* @__PURE__ */ De("ZodCatch", (e, t) => {
  $ge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => X8(e, n, r, i), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function p0e(e, t) {
  return new h0e({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const m0e = /* @__PURE__ */ De("ZodPipe", (e, t) => {
  Uge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => J8(e, n, r, i), e.in = t.in, e.out = t.out;
});
function DI(e, t) {
  return new m0e({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const g0e = /* @__PURE__ */ De("ZodReadonly", (e, t) => {
  Fge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => Q8(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function y0e(e) {
  return new g0e({
    type: "readonly",
    innerType: e
  });
}
const v0e = /* @__PURE__ */ De("ZodLazy", (e, t) => {
  Vge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => eF(e, n, r, i), e.unwrap = () => e._zod.def.getter();
});
function b0e(e) {
  return new v0e({
    type: "lazy",
    getter: e
  });
}
const TM = /* @__PURE__ */ De("ZodCustom", (e, t) => {
  Hge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => $8(e, n);
});
function uF(e, t) {
  return /* @__PURE__ */ zye(TM, e ?? (() => !0), t);
}
function x0e(e, t = {}) {
  return /* @__PURE__ */ Lye(TM, e, t);
}
function w0e(e) {
  return /* @__PURE__ */ Bye(e);
}
function _b(e, t = {}) {
  const n = new TM({
    type: "custom",
    check: "custom",
    fn: (r) => r instanceof e,
    abort: !0,
    ...ct(t)
  });
  return n._zod.bag.Class = e, n._zod.check = (r) => {
    r.value instanceof e || r.issues.push({
      code: "invalid_type",
      expected: e.name,
      input: r.value,
      inst: n,
      path: [...n._zod.def.path ?? []]
    });
  }, n;
}
var og;
(function(e) {
  e.assertEqual = (i) => {
  };
  function t(i) {
  }
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (i) => {
    const o = {};
    for (const s of i)
      o[s] = s;
    return o;
  }, e.getValidEnumValues = (i) => {
    const o = e.objectKeys(i).filter((a) => typeof i[i[a]] != "number"), s = {};
    for (const a of o)
      s[a] = i[a];
    return e.objectValues(s);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(o) {
    return i[o];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const o = [];
    for (const s in i)
      Object.prototype.hasOwnProperty.call(i, s) && o.push(s);
    return o;
  }, e.find = (i, o) => {
    for (const s of i)
      if (o(s))
        return s;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && Number.isFinite(i) && Math.floor(i) === i;
  function r(i, o = " | ") {
    return i.map((s) => typeof s == "string" ? `'${s}'` : s).join(o);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (i, o) => typeof o == "bigint" ? o.toString() : o;
})(og || (og = {}));
var PI;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(PI || (PI = {}));
og.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
og.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class Tb extends Error {
  get errors() {
    return this.issues;
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  format(t) {
    const n = t || function(o) {
      return o.message;
    }, r = { _errors: [] }, i = (o) => {
      for (const s of o.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(i);
        else if (s.code === "invalid_return_type")
          i(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          i(s.argumentsError);
        else if (s.path.length === 0)
          r._errors.push(n(s));
        else {
          let a = r, c = 0;
          for (; c < s.path.length; ) {
            const u = s.path[c];
            c === s.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(n(s))) : a[u] = a[u] || { _errors: [] }, a = a[u], c++;
          }
        }
    };
    return i(this), r;
  }
  static assert(t) {
    if (!(t instanceof Tb))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, og.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = /* @__PURE__ */ Object.create(null), r = [];
    for (const i of this.issues)
      if (i.path.length > 0) {
        const o = i.path[0];
        n[o] = n[o] || [], n[o].push(t(i));
      } else
        r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
Tb.create = (e) => new Tb(e);
var jI;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
})(jI || (jI = {}));
var Mt;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Mt || (Mt = {}));
var Xg = ({
  prefix: e,
  size: t = 16,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: r = "-"
} = {}) => {
  const i = () => {
    const o = n.length, s = new Array(t);
    for (let a = 0; a < t; a++)
      s[a] = n[Math.random() * o | 0];
    return s.join("");
  };
  if (e == null)
    return i;
  if (n.includes(r))
    throw new Dpe({
      argument: "separator",
      message: `The separator "${r}" must not be part of the alphabet "${n}".`
    });
  return () => `${e}${r}${i()}`;
}, S0e = Xg();
function II(e = globalThis) {
  var t, n, r;
  return e.window ? "runtime/browser" : (t = e.navigator) != null && t.userAgent ? `runtime/${e.navigator.userAgent.toLowerCase()}` : (r = (n = e.process) == null ? void 0 : n.versions) != null && r.node ? `runtime/node.js/${e.process.version.substring(0)}` : e.EdgeRuntime ? "runtime/vercel-edge" : "runtime/unknown";
}
function Mu(e) {
  if (e == null)
    return {};
  const t = {};
  if (e instanceof Headers)
    e.forEach((n, r) => {
      t[r.toLowerCase()] = n;
    });
  else {
    Array.isArray(e) || (e = Object.entries(e));
    for (const [n, r] of e)
      r != null && (t[n.toLowerCase()] = r);
  }
  return t;
}
function zI(e, ...t) {
  const n = new Headers(Mu(e)), r = n.get("user-agent") || "";
  return n.set(
    "user-agent",
    [r, ...t].filter(Boolean).join(" ")
  ), Object.fromEntries(n.entries());
}
var k0e = /"__proto__"\s*:/, C0e = /"constructor"\s*:/;
function LI(e) {
  const t = JSON.parse(e);
  return t === null || typeof t != "object" || k0e.test(e) === !1 && C0e.test(e) === !1 ? t : E0e(t);
}
function E0e(e) {
  let t = [e];
  for (; t.length; ) {
    const n = t;
    t = [];
    for (const r of n) {
      if (Object.prototype.hasOwnProperty.call(r, "__proto__"))
        throw new SyntaxError("Object contains forbidden prototype property");
      if (Object.prototype.hasOwnProperty.call(r, "constructor") && Object.prototype.hasOwnProperty.call(r.constructor, "prototype"))
        throw new SyntaxError("Object contains forbidden prototype property");
      for (const i in r) {
        const o = r[i];
        o && typeof o == "object" && t.push(o);
      }
    }
  }
  return e;
}
function _0e(e) {
  const { stackTraceLimit: t } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch {
    return LI(e);
  }
  try {
    return LI(e);
  } finally {
    Error.stackTraceLimit = t;
  }
}
var Ab = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function T0e(e) {
  return { [Ab]: !0, validate: e };
}
function A0e(e) {
  return typeof e == "object" && e !== null && Ab in e && e[Ab] === !0 && "validate" in e;
}
function M0e(e) {
  let t;
  return () => (t == null && (t = e()), t);
}
function N0e(e) {
  return A0e(e) ? e : typeof e == "function" ? e() : R0e(e);
}
function R0e(e) {
  return T0e(async (t) => {
    const n = await e["~standard"].validate(t);
    return n.issues == null ? { success: !0, value: n.value } : {
      success: !1,
      error: new bb({
        value: t,
        cause: n.issues
      })
    };
  });
}
async function BI({
  value: e,
  schema: t
}) {
  const n = await AM({ value: e, schema: t });
  if (!n.success)
    throw bb.wrap({ value: e, cause: n.error });
  return n.value;
}
async function AM({
  value: e,
  schema: t
}) {
  const n = N0e(t);
  try {
    if (n.validate == null)
      return { success: !0, value: e, rawValue: e };
    const r = await n.validate(e);
    return r.success ? { success: !0, value: r.value, rawValue: e } : {
      success: !1,
      error: bb.wrap({ value: e, cause: r.error }),
      rawValue: e
    };
  } catch (r) {
    return {
      success: !1,
      error: bb.wrap({ value: e, cause: r }),
      rawValue: e
    };
  }
}
async function Mb({
  text: e,
  schema: t
}) {
  try {
    const n = _0e(e);
    return t == null ? { success: !0, value: n, rawValue: n } : await AM({ value: n, schema: t });
  } catch (n) {
    return {
      success: !1,
      error: lI.isInstance(n) ? n : new lI({ text: e, cause: n }),
      rawValue: void 0
    };
  }
}
function O0e({
  stream: e,
  schema: t
}) {
  return e.pipeThrough(new TextDecoderStream()).pipeThrough(new Lpe()).pipeThrough(
    new TransformStream({
      async transform({ data: n }, r) {
        n !== "[DONE]" && r.enqueue(await Mb({ text: n, schema: t }));
      }
    })
  );
}
async function mf(e) {
  return typeof e == "function" && (e = e()), Promise.resolve(e);
}
function T0(e) {
  if (e.type === "object") {
    e.additionalProperties = !1;
    const t = e.properties;
    if (t != null)
      for (const n in t)
        t[n] = T0(
          t[n]
        );
  }
  return e.type === "array" && e.items != null && (Array.isArray(e.items) ? e.items = e.items.map(
    (t) => T0(t)
  ) : e.items = T0(
    e.items
  )), e;
}
var D0e = (e, t) => {
  let n = 0;
  for (; n < e.length && n < t.length && e[n] === t[n]; n++)
    ;
  return [(e.length - n).toString(), ...t.slice(n)].join("/");
}, P0e = /* @__PURE__ */ Symbol(
  "Let zodToJsonSchema decide on which parser to use"
), $I = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, j0e = (e) => typeof e == "string" ? {
  ...$I,
  name: e
} : {
  ...$I,
  ...e
};
function go() {
  return {};
}
function I0e(e, t) {
  var n, r, i;
  const o = {
    type: "array"
  };
  return (n = e.type) != null && n._def && ((i = (r = e.type) == null ? void 0 : r._def) == null ? void 0 : i.typeName) !== Mt.ZodAny && (o.items = gn(e.type._def, {
    ...t,
    currentPath: [...t.currentPath, "items"]
  })), e.minLength && (o.minItems = e.minLength.value), e.maxLength && (o.maxItems = e.maxLength.value), e.exactLength && (o.minItems = e.exactLength.value, o.maxItems = e.exactLength.value), o;
}
function z0e(e) {
  const t = {
    type: "integer",
    format: "int64"
  };
  if (!e.checks) return t;
  for (const n of e.checks)
    switch (n.kind) {
      case "min":
        n.inclusive ? t.minimum = n.value : t.exclusiveMinimum = n.value;
        break;
      case "max":
        n.inclusive ? t.maximum = n.value : t.exclusiveMaximum = n.value;
        break;
      case "multipleOf":
        t.multipleOf = n.value;
        break;
    }
  return t;
}
function L0e() {
  return { type: "boolean" };
}
function dF(e, t) {
  return gn(e.type._def, t);
}
var B0e = (e, t) => gn(e.innerType._def, t);
function fF(e, t, n) {
  const r = n ?? t.dateStrategy;
  if (Array.isArray(r))
    return {
      anyOf: r.map((i, o) => fF(e, t, i))
    };
  switch (r) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return $0e(e);
  }
}
var $0e = (e) => {
  const t = {
    type: "integer",
    format: "unix-time"
  };
  for (const n of e.checks)
    switch (n.kind) {
      case "min":
        t.minimum = n.value;
        break;
      case "max":
        t.maximum = n.value;
        break;
    }
  return t;
};
function U0e(e, t) {
  return {
    ...gn(e.innerType._def, t),
    default: e.defaultValue()
  };
}
function F0e(e, t) {
  return t.effectStrategy === "input" ? gn(e.schema._def, t) : go();
}
function V0e(e) {
  return {
    type: "string",
    enum: Array.from(e.values)
  };
}
var H0e = (e) => "type" in e && e.type === "string" ? !1 : "allOf" in e;
function W0e(e, t) {
  const n = [
    gn(e.left._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "0"]
    }),
    gn(e.right._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "1"]
    })
  ].filter((i) => !!i), r = [];
  return n.forEach((i) => {
    if (H0e(i))
      r.push(...i.allOf);
    else {
      let o = i;
      if ("additionalProperties" in i && i.additionalProperties === !1) {
        const { additionalProperties: s, ...a } = i;
        o = a;
      }
      r.push(o);
    }
  }), r.length ? { allOf: r } : void 0;
}
function q0e(e) {
  const t = typeof e.value;
  return t !== "bigint" && t !== "number" && t !== "boolean" && t !== "string" ? {
    type: Array.isArray(e.value) ? "array" : "object"
  } : {
    type: t === "bigint" ? "integer" : t,
    const: e.value
  };
}
var oC = void 0, ts = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (oC === void 0 && (oC = RegExp(
    "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
    "u"
  )), oC),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function hF(e, t) {
  const n = {
    type: "string"
  };
  if (e.checks)
    for (const r of e.checks)
      switch (r.kind) {
        case "min":
          n.minLength = typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value;
          break;
        case "max":
          n.maxLength = typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value;
          break;
        case "email":
          switch (t.emailStrategy) {
            case "format:email":
              ns(n, "email", r.message, t);
              break;
            case "format:idn-email":
              ns(n, "idn-email", r.message, t);
              break;
            case "pattern:zod":
              Ci(n, ts.email, r.message, t);
              break;
          }
          break;
        case "url":
          ns(n, "uri", r.message, t);
          break;
        case "uuid":
          ns(n, "uuid", r.message, t);
          break;
        case "regex":
          Ci(n, r.regex, r.message, t);
          break;
        case "cuid":
          Ci(n, ts.cuid, r.message, t);
          break;
        case "cuid2":
          Ci(n, ts.cuid2, r.message, t);
          break;
        case "startsWith":
          Ci(
            n,
            RegExp(`^${sC(r.value, t)}`),
            r.message,
            t
          );
          break;
        case "endsWith":
          Ci(
            n,
            RegExp(`${sC(r.value, t)}$`),
            r.message,
            t
          );
          break;
        case "datetime":
          ns(n, "date-time", r.message, t);
          break;
        case "date":
          ns(n, "date", r.message, t);
          break;
        case "time":
          ns(n, "time", r.message, t);
          break;
        case "duration":
          ns(n, "duration", r.message, t);
          break;
        case "length":
          n.minLength = typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value, n.maxLength = typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value;
          break;
        case "includes": {
          Ci(
            n,
            RegExp(sC(r.value, t)),
            r.message,
            t
          );
          break;
        }
        case "ip": {
          r.version !== "v6" && ns(n, "ipv4", r.message, t), r.version !== "v4" && ns(n, "ipv6", r.message, t);
          break;
        }
        case "base64url":
          Ci(n, ts.base64url, r.message, t);
          break;
        case "jwt":
          Ci(n, ts.jwt, r.message, t);
          break;
        case "cidr": {
          r.version !== "v6" && Ci(n, ts.ipv4Cidr, r.message, t), r.version !== "v4" && Ci(n, ts.ipv6Cidr, r.message, t);
          break;
        }
        case "emoji":
          Ci(n, ts.emoji(), r.message, t);
          break;
        case "ulid": {
          Ci(n, ts.ulid, r.message, t);
          break;
        }
        case "base64": {
          switch (t.base64Strategy) {
            case "format:binary": {
              ns(n, "binary", r.message, t);
              break;
            }
            case "contentEncoding:base64": {
              n.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              Ci(n, ts.base64, r.message, t);
              break;
            }
          }
          break;
        }
        case "nanoid":
          Ci(n, ts.nanoid, r.message, t);
      }
  return n;
}
function sC(e, t) {
  return t.patternStrategy === "escape" ? K0e(e) : e;
}
var G0e = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function K0e(e) {
  let t = "";
  for (let n = 0; n < e.length; n++)
    G0e.has(e[n]) || (t += "\\"), t += e[n];
  return t;
}
function ns(e, t, n, r) {
  var i;
  e.format || (i = e.anyOf) != null && i.some((o) => o.format) ? (e.anyOf || (e.anyOf = []), e.format && (e.anyOf.push({
    format: e.format
  }), delete e.format), e.anyOf.push({
    format: t,
    ...n && r.errorMessages && { errorMessage: { format: n } }
  })) : e.format = t;
}
function Ci(e, t, n, r) {
  var i;
  e.pattern || (i = e.allOf) != null && i.some((o) => o.pattern) ? (e.allOf || (e.allOf = []), e.pattern && (e.allOf.push({
    pattern: e.pattern
  }), delete e.pattern), e.allOf.push({
    pattern: UI(t, r),
    ...n && r.errorMessages && { errorMessage: { pattern: n } }
  })) : e.pattern = UI(t, r);
}
function UI(e, t) {
  var n;
  if (!t.applyRegexFlags || !e.flags)
    return e.source;
  const r = {
    i: e.flags.includes("i"),
    // Case-insensitive
    m: e.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: e.flags.includes("s")
    // `.` matches newlines
  }, i = r.i ? e.source.toLowerCase() : e.source;
  let o = "", s = !1, a = !1, c = !1;
  for (let u = 0; u < i.length; u++) {
    if (s) {
      o += i[u], s = !1;
      continue;
    }
    if (r.i) {
      if (a) {
        if (i[u].match(/[a-z]/)) {
          c ? (o += i[u], o += `${i[u - 2]}-${i[u]}`.toUpperCase(), c = !1) : i[u + 1] === "-" && ((n = i[u + 2]) != null && n.match(/[a-z]/)) ? (o += i[u], c = !0) : o += `${i[u]}${i[u].toUpperCase()}`;
          continue;
        }
      } else if (i[u].match(/[a-z]/)) {
        o += `[${i[u]}${i[u].toUpperCase()}]`;
        continue;
      }
    }
    if (r.m) {
      if (i[u] === "^") {
        o += `(^|(?<=[\r
]))`;
        continue;
      } else if (i[u] === "$") {
        o += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (r.s && i[u] === ".") {
      o += a ? `${i[u]}\r
` : `[${i[u]}\r
]`;
      continue;
    }
    o += i[u], i[u] === "\\" ? s = !0 : a && i[u] === "]" ? a = !1 : !a && i[u] === "[" && (a = !0);
  }
  try {
    new RegExp(o);
  } catch {
    return console.warn(
      `Could not convert regex pattern at ${t.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    ), e.source;
  }
  return o;
}
function pF(e, t) {
  var n, r, i, o, s, a;
  const c = {
    type: "object",
    additionalProperties: (n = gn(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    })) != null ? n : t.allowedAdditionalProperties
  };
  if (((r = e.keyType) == null ? void 0 : r._def.typeName) === Mt.ZodString && ((i = e.keyType._def.checks) != null && i.length)) {
    const { type: u, ...f } = hF(e.keyType._def, t);
    return {
      ...c,
      propertyNames: f
    };
  } else {
    if (((o = e.keyType) == null ? void 0 : o._def.typeName) === Mt.ZodEnum)
      return {
        ...c,
        propertyNames: {
          enum: e.keyType._def.values
        }
      };
    if (((s = e.keyType) == null ? void 0 : s._def.typeName) === Mt.ZodBranded && e.keyType._def.type._def.typeName === Mt.ZodString && ((a = e.keyType._def.type._def.checks) != null && a.length)) {
      const { type: u, ...f } = dF(
        e.keyType._def,
        t
      );
      return {
        ...c,
        propertyNames: f
      };
    }
  }
  return c;
}
function Z0e(e, t) {
  if (t.mapStrategy === "record")
    return pF(e, t);
  const n = gn(e.keyType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "0"]
  }) || go(), r = gn(e.valueType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "1"]
  }) || go();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, r],
      minItems: 2,
      maxItems: 2
    }
  };
}
function Y0e(e) {
  const t = e.values, r = Object.keys(e.values).filter((o) => typeof t[t[o]] != "number").map((o) => t[o]), i = Array.from(
    new Set(r.map((o) => typeof o))
  );
  return {
    type: i.length === 1 ? i[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: r
  };
}
function X0e() {
  return { not: go() };
}
function J0e() {
  return {
    type: "null"
  };
}
var M_ = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function Q0e(e, t) {
  const n = e.options instanceof Map ? Array.from(e.options.values()) : e.options;
  if (n.every(
    (r) => r._def.typeName in M_ && (!r._def.checks || !r._def.checks.length)
  )) {
    const r = n.reduce((i, o) => {
      const s = M_[o._def.typeName];
      return s && !i.includes(s) ? [...i, s] : i;
    }, []);
    return {
      type: r.length > 1 ? r : r[0]
    };
  } else if (n.every((r) => r._def.typeName === "ZodLiteral" && !r.description)) {
    const r = n.reduce(
      (i, o) => {
        const s = typeof o._def.value;
        switch (s) {
          case "string":
          case "number":
          case "boolean":
            return [...i, s];
          case "bigint":
            return [...i, "integer"];
          case "object":
            if (o._def.value === null) return [...i, "null"];
          default:
            return i;
        }
      },
      []
    );
    if (r.length === n.length) {
      const i = r.filter((o, s, a) => a.indexOf(o) === s);
      return {
        type: i.length > 1 ? i : i[0],
        enum: n.reduce(
          (o, s) => o.includes(s._def.value) ? o : [...o, s._def.value],
          []
        )
      };
    }
  } else if (n.every((r) => r._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce(
        (r, i) => [
          ...r,
          ...i._def.values.filter((o) => !r.includes(o))
        ],
        []
      )
    };
  return ebe(e, t);
}
var ebe = (e, t) => {
  const n = (e.options instanceof Map ? Array.from(e.options.values()) : e.options).map(
    (r, i) => gn(r._def, {
      ...t,
      currentPath: [...t.currentPath, "anyOf", `${i}`]
    })
  ).filter(
    (r) => !!r && (!t.strictUnions || typeof r == "object" && Object.keys(r).length > 0)
  );
  return n.length ? { anyOf: n } : void 0;
};
function tbe(e, t) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    e.innerType._def.typeName
  ) && (!e.innerType._def.checks || !e.innerType._def.checks.length))
    return {
      type: [
        M_[e.innerType._def.typeName],
        "null"
      ]
    };
  const n = gn(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "0"]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function nbe(e) {
  const t = {
    type: "number"
  };
  if (!e.checks) return t;
  for (const n of e.checks)
    switch (n.kind) {
      case "int":
        t.type = "integer";
        break;
      case "min":
        n.inclusive ? t.minimum = n.value : t.exclusiveMinimum = n.value;
        break;
      case "max":
        n.inclusive ? t.maximum = n.value : t.exclusiveMaximum = n.value;
        break;
      case "multipleOf":
        t.multipleOf = n.value;
        break;
    }
  return t;
}
function rbe(e, t) {
  const n = {
    type: "object",
    properties: {}
  }, r = [], i = e.shape();
  for (const s in i) {
    let a = i[s];
    if (a === void 0 || a._def === void 0)
      continue;
    const c = obe(a), u = gn(a._def, {
      ...t,
      currentPath: [...t.currentPath, "properties", s],
      propertyPath: [...t.currentPath, "properties", s]
    });
    u !== void 0 && (n.properties[s] = u, c || r.push(s));
  }
  r.length && (n.required = r);
  const o = ibe(e, t);
  return o !== void 0 && (n.additionalProperties = o), n;
}
function ibe(e, t) {
  if (e.catchall._def.typeName !== "ZodNever")
    return gn(e.catchall._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    });
  switch (e.unknownKeys) {
    case "passthrough":
      return t.allowedAdditionalProperties;
    case "strict":
      return t.rejectedAdditionalProperties;
    case "strip":
      return t.removeAdditionalStrategy === "strict" ? t.allowedAdditionalProperties : t.rejectedAdditionalProperties;
  }
}
function obe(e) {
  try {
    return e.isOptional();
  } catch {
    return !0;
  }
}
var sbe = (e, t) => {
  var n;
  if (t.currentPath.toString() === ((n = t.propertyPath) == null ? void 0 : n.toString()))
    return gn(e.innerType._def, t);
  const r = gn(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "1"]
  });
  return r ? { anyOf: [{ not: go() }, r] } : go();
}, abe = (e, t) => {
  if (t.pipeStrategy === "input")
    return gn(e.in._def, t);
  if (t.pipeStrategy === "output")
    return gn(e.out._def, t);
  const n = gn(e.in._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", "0"]
  }), r = gn(e.out._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", n ? "1" : "0"]
  });
  return {
    allOf: [n, r].filter((i) => i !== void 0)
  };
};
function lbe(e, t) {
  return gn(e.type._def, t);
}
function cbe(e, t) {
  const r = {
    type: "array",
    uniqueItems: !0,
    items: gn(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "items"]
    })
  };
  return e.minSize && (r.minItems = e.minSize.value), e.maxSize && (r.maxItems = e.maxSize.value), r;
}
function ube(e, t) {
  return e.rest ? {
    type: "array",
    minItems: e.items.length,
    items: e.items.map(
      (n, r) => gn(n._def, {
        ...t,
        currentPath: [...t.currentPath, "items", `${r}`]
      })
    ).reduce(
      (n, r) => r === void 0 ? n : [...n, r],
      []
    ),
    additionalItems: gn(e.rest._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: e.items.length,
    maxItems: e.items.length,
    items: e.items.map(
      (n, r) => gn(n._def, {
        ...t,
        currentPath: [...t.currentPath, "items", `${r}`]
      })
    ).reduce(
      (n, r) => r === void 0 ? n : [...n, r],
      []
    )
  };
}
function dbe() {
  return {
    not: go()
  };
}
function fbe() {
  return go();
}
var hbe = (e, t) => gn(e.innerType._def, t), pbe = (e, t, n) => {
  switch (t) {
    case Mt.ZodString:
      return hF(e, n);
    case Mt.ZodNumber:
      return nbe(e);
    case Mt.ZodObject:
      return rbe(e, n);
    case Mt.ZodBigInt:
      return z0e(e);
    case Mt.ZodBoolean:
      return L0e();
    case Mt.ZodDate:
      return fF(e, n);
    case Mt.ZodUndefined:
      return dbe();
    case Mt.ZodNull:
      return J0e();
    case Mt.ZodArray:
      return I0e(e, n);
    case Mt.ZodUnion:
    case Mt.ZodDiscriminatedUnion:
      return Q0e(e, n);
    case Mt.ZodIntersection:
      return W0e(e, n);
    case Mt.ZodTuple:
      return ube(e, n);
    case Mt.ZodRecord:
      return pF(e, n);
    case Mt.ZodLiteral:
      return q0e(e);
    case Mt.ZodEnum:
      return V0e(e);
    case Mt.ZodNativeEnum:
      return Y0e(e);
    case Mt.ZodNullable:
      return tbe(e, n);
    case Mt.ZodOptional:
      return sbe(e, n);
    case Mt.ZodMap:
      return Z0e(e, n);
    case Mt.ZodSet:
      return cbe(e, n);
    case Mt.ZodLazy:
      return () => e.getter()._def;
    case Mt.ZodPromise:
      return lbe(e, n);
    case Mt.ZodNaN:
    case Mt.ZodNever:
      return X0e();
    case Mt.ZodEffects:
      return F0e(e, n);
    case Mt.ZodAny:
      return go();
    case Mt.ZodUnknown:
      return fbe();
    case Mt.ZodDefault:
      return U0e(e, n);
    case Mt.ZodBranded:
      return dF(e, n);
    case Mt.ZodReadonly:
      return hbe(e, n);
    case Mt.ZodCatch:
      return B0e(e, n);
    case Mt.ZodPipeline:
      return abe(e, n);
    case Mt.ZodFunction:
    case Mt.ZodVoid:
    case Mt.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((r) => {
      })();
  }
};
function gn(e, t, n = !1) {
  var r;
  const i = t.seen.get(e);
  if (t.override) {
    const c = (r = t.override) == null ? void 0 : r.call(
      t,
      e,
      t,
      i,
      n
    );
    if (c !== P0e)
      return c;
  }
  if (i && !n) {
    const c = mbe(i, t);
    if (c !== void 0)
      return c;
  }
  const o = { def: e, path: t.currentPath, jsonSchema: void 0 };
  t.seen.set(e, o);
  const s = pbe(e, e.typeName, t), a = typeof s == "function" ? gn(s(), t) : s;
  if (a && gbe(e, t, a), t.postProcess) {
    const c = t.postProcess(a, e, t);
    return o.jsonSchema = a, c;
  }
  return o.jsonSchema = a, a;
}
var mbe = (e, t) => {
  switch (t.$refStrategy) {
    case "root":
      return { $ref: e.path.join("/") };
    case "relative":
      return { $ref: D0e(t.currentPath, e.path) };
    case "none":
    case "seen":
      return e.path.length < t.currentPath.length && e.path.every((n, r) => t.currentPath[r] === n) ? (console.warn(
        `Recursive reference detected at ${t.currentPath.join(
          "/"
        )}! Defaulting to any`
      ), go()) : t.$refStrategy === "seen" ? go() : void 0;
  }
}, gbe = (e, t, n) => (e.description && (n.description = e.description), n), ybe = (e) => {
  const t = j0e(e), n = t.name !== void 0 ? [...t.basePath, t.definitionPath, t.name] : t.basePath;
  return {
    ...t,
    currentPath: n,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(t.definitions).map(([r, i]) => [
        i._def,
        {
          def: i._def,
          path: [...t.basePath, t.definitionPath, r],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
}, vbe = (e, t) => {
  var n;
  const r = ybe(t);
  let i = typeof t == "object" && t.definitions ? Object.entries(t.definitions).reduce(
    (u, [f, h]) => {
      var m;
      return {
        ...u,
        [f]: (m = gn(
          h._def,
          {
            ...r,
            currentPath: [...r.basePath, r.definitionPath, f]
          },
          !0
        )) != null ? m : go()
      };
    },
    {}
  ) : void 0;
  const o = typeof t == "string" ? t : t?.nameStrategy === "title" ? void 0 : t?.name, s = (n = gn(
    e._def,
    o === void 0 ? r : {
      ...r,
      currentPath: [...r.basePath, r.definitionPath, o]
    },
    !1
  )) != null ? n : go(), a = typeof t == "object" && t.name !== void 0 && t.nameStrategy === "title" ? t.name : void 0;
  a !== void 0 && (s.title = a);
  const c = o === void 0 ? i ? {
    ...s,
    [r.definitionPath]: i
  } : s : {
    $ref: [
      ...r.$refStrategy === "relative" ? [] : r.basePath,
      r.definitionPath,
      o
    ].join("/"),
    [r.definitionPath]: {
      ...i,
      [o]: s
    }
  };
  return c.$schema = "http://json-schema.org/draft-07/schema#", c;
}, bbe = vbe;
function xbe(e, t) {
  var n;
  const r = (n = void 0) != null ? n : !1;
  return MM(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => bbe(e, {
      $refStrategy: r ? "root" : "none"
    }),
    {
      validate: async (i) => {
        const o = await e.safeParseAsync(i);
        return o.success ? { success: !0, value: o.data } : { success: !1, error: o.error };
      }
    }
  );
}
function wbe(e, t) {
  var n;
  const r = (n = void 0) != null ? n : !1;
  return MM(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => T0(
      ive(e, {
        target: "draft-7",
        io: "input",
        reused: r ? "ref" : "inline"
      })
    ),
    {
      validate: async (i) => {
        const o = await tF(e, i);
        return o.success ? { success: !0, value: o.data } : { success: !1, error: o.error };
      }
    }
  );
}
function Sbe(e) {
  return "_zod" in e;
}
function mF(e, t) {
  return Sbe(e) ? wbe(e) : xbe(e);
}
var N_ = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function MM(e, {
  validate: t
} = {}) {
  return {
    [N_]: !0,
    _type: void 0,
    // should never be used directly
    [Ab]: !0,
    get jsonSchema() {
      return typeof e == "function" && (e = e()), e;
    },
    validate: t
  };
}
function kbe(e) {
  return typeof e == "object" && e !== null && N_ in e && e[N_] === !0 && "jsonSchema" in e && "validate" in e;
}
function Cbe(e) {
  return e == null ? MM({
    properties: {},
    additionalProperties: !1
  }) : kbe(e) ? e : typeof e == "function" ? e() : mF(e);
}
var Ebe = Object.defineProperty, _be = (e, t) => {
  for (var n in t)
    Ebe(e, n, { get: t[n], enumerable: !0 });
}, gF = "AI_NoObjectGeneratedError", yF = `vercel.ai.error.${gF}`, Tbe = Symbol.for(yF), vF, FI = class extends Js {
  constructor({
    message: e = "No object generated.",
    cause: t,
    text: n,
    response: r,
    usage: i,
    finishReason: o
  }) {
    super({ name: gF, message: e, cause: t }), this[vF] = !0, this.text = n, this.response = r, this.usage = i, this.finishReason = o;
  }
  static isInstance(e) {
    return Js.hasMarker(e, yF);
  }
};
vF = Tbe;
var bF = "AI_MessageConversionError", xF = `vercel.ai.error.${bF}`, Abe = Symbol.for(xF), wF, Mbe = class extends Js {
  constructor({
    originalMessage: e,
    message: t
  }) {
    super({ name: bF, message: t }), this[wF] = !0, this.originalMessage = e;
  }
  static isInstance(e) {
    return Js.hasMarker(e, xF);
  }
};
wF = Abe;
var VI = "5.0.126", SF = Wo([
  gt(),
  _b(Uint8Array),
  _b(ArrayBuffer),
  uF(
    // Buffer might not be available in some environments such as CloudFlare:
    (e) => {
      var t, n;
      return (n = (t = globalThis.Buffer) == null ? void 0 : t.isBuffer(e)) != null ? n : !1;
    },
    { message: "Must be a Buffer" }
  )
]), sg = b0e(
  () => Wo([
    Gve(),
    gt(),
    Vve(),
    Wi(),
    T_(gt(), sg),
    Lh(sg)
  ])
), fr = T_(
  gt(),
  T_(gt(), sg)
), kF = ei({
  type: Ut("text"),
  text: gt(),
  providerOptions: fr.optional()
}), Nbe = ei({
  type: Ut("image"),
  image: Wo([SF, _b(URL)]),
  mediaType: gt().optional(),
  providerOptions: fr.optional()
}), CF = ei({
  type: Ut("file"),
  data: Wo([SF, _b(URL)]),
  filename: gt().optional(),
  mediaType: gt(),
  providerOptions: fr.optional()
}), Rbe = ei({
  type: Ut("reasoning"),
  text: gt(),
  providerOptions: fr.optional()
}), Obe = ei({
  type: Ut("tool-call"),
  toolCallId: gt(),
  toolName: gt(),
  input: Us(),
  providerOptions: fr.optional(),
  providerExecuted: Wi().optional()
}), Dbe = Jve("type", [
  ei({
    type: Ut("text"),
    value: gt()
  }),
  ei({
    type: Ut("json"),
    value: sg
  }),
  ei({
    type: Ut("error-text"),
    value: gt()
  }),
  ei({
    type: Ut("error-json"),
    value: sg
  }),
  ei({
    type: Ut("content"),
    value: Lh(
      Wo([
        ei({
          type: Ut("text"),
          text: gt()
        }),
        ei({
          type: Ut("media"),
          data: gt(),
          mediaType: gt()
        })
      ])
    )
  })
]), EF = ei({
  type: Ut("tool-result"),
  toolCallId: gt(),
  toolName: gt(),
  output: Dbe,
  providerOptions: fr.optional()
}), Pbe = ei(
  {
    role: Ut("system"),
    content: gt(),
    providerOptions: fr.optional()
  }
), jbe = ei({
  role: Ut("user"),
  content: Wo([
    gt(),
    Lh(Wo([kF, Nbe, CF]))
  ]),
  providerOptions: fr.optional()
}), Ibe = ei({
  role: Ut("assistant"),
  content: Wo([
    gt(),
    Lh(
      Wo([
        kF,
        CF,
        Rbe,
        Obe,
        EF
      ])
    )
  ]),
  providerOptions: fr.optional()
}), zbe = ei({
  role: Ut("tool"),
  content: Lh(EF),
  providerOptions: fr.optional()
});
Wo([
  Pbe,
  jbe,
  Ibe,
  zbe
]);
function HI({
  output: e,
  tool: t,
  errorMode: n
}) {
  return n === "text" ? { type: "error-text", value: bM(e) } : n === "json" ? { type: "error-json", value: WI(e) } : t?.toModelOutput ? t.toModelOutput(e) : typeof e == "string" ? { type: "text", value: e } : { type: "json", value: WI(e) };
}
function WI(e) {
  return e === void 0 ? null : e;
}
Xg({
  prefix: "aitxt",
  size: 24
});
(class extends TransformStream {
  constructor() {
    super({
      transform(e, t) {
        t.enqueue(`data: ${JSON.stringify(e)}

`);
      },
      flush(e) {
        e.enqueue(`data: [DONE]

`);
      }
    });
  }
});
var Lbe = M0e(
  () => mF(
    Wo([
      Yn({
        type: Ut("text-start"),
        id: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("text-delta"),
        id: gt(),
        delta: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("text-end"),
        id: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("error"),
        errorText: gt()
      }),
      Yn({
        type: Ut("tool-input-start"),
        toolCallId: gt(),
        toolName: gt(),
        providerExecuted: Wi().optional(),
        dynamic: Wi().optional()
      }),
      Yn({
        type: Ut("tool-input-delta"),
        toolCallId: gt(),
        inputTextDelta: gt()
      }),
      Yn({
        type: Ut("tool-input-available"),
        toolCallId: gt(),
        toolName: gt(),
        input: Us(),
        providerExecuted: Wi().optional(),
        providerMetadata: fr.optional(),
        dynamic: Wi().optional()
      }),
      Yn({
        type: Ut("tool-input-error"),
        toolCallId: gt(),
        toolName: gt(),
        input: Us(),
        providerExecuted: Wi().optional(),
        providerMetadata: fr.optional(),
        dynamic: Wi().optional(),
        errorText: gt()
      }),
      Yn({
        type: Ut("tool-output-available"),
        toolCallId: gt(),
        output: Us(),
        providerExecuted: Wi().optional(),
        dynamic: Wi().optional(),
        preliminary: Wi().optional()
      }),
      Yn({
        type: Ut("tool-output-error"),
        toolCallId: gt(),
        errorText: gt(),
        providerExecuted: Wi().optional(),
        dynamic: Wi().optional()
      }),
      Yn({
        type: Ut("reasoning-start"),
        id: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("reasoning-delta"),
        id: gt(),
        delta: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("reasoning-end"),
        id: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("source-url"),
        sourceId: gt(),
        url: gt(),
        title: gt().optional(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("source-document"),
        sourceId: gt(),
        mediaType: gt(),
        title: gt(),
        filename: gt().optional(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("file"),
        url: gt(),
        mediaType: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: uF(
          (e) => typeof e == "string" && e.startsWith("data-"),
          { message: 'Type must start with "data-"' }
        ),
        id: gt().optional(),
        data: Us(),
        transient: Wi().optional()
      }),
      Yn({
        type: Ut("start-step")
      }),
      Yn({
        type: Ut("finish-step")
      }),
      Yn({
        type: Ut("start"),
        messageId: gt().optional(),
        messageMetadata: Us().optional()
      }),
      Yn({
        type: Ut("finish"),
        finishReason: aF([
          "stop",
          "length",
          "content-filter",
          "tool-calls",
          "error",
          "other",
          "unknown"
        ]).optional(),
        messageMetadata: Us().optional()
      }),
      Yn({
        type: Ut("abort")
      }),
      Yn({
        type: Ut("message-metadata"),
        messageMetadata: Us()
      })
    ])
  )
);
function Bbe(e) {
  return e.type.startsWith("data-");
}
function _F(e, t) {
  if (e === void 0 && t === void 0)
    return;
  if (e === void 0)
    return t;
  if (t === void 0)
    return e;
  const n = { ...e };
  for (const r in t)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      const i = t[r];
      if (i === void 0)
        continue;
      const o = r in e ? e[r] : void 0, s = i !== null && typeof i == "object" && !Array.isArray(i) && !(i instanceof Date) && !(i instanceof RegExp), a = o != null && typeof o == "object" && !Array.isArray(o) && !(o instanceof Date) && !(o instanceof RegExp);
      s && a ? n[r] = _F(
        o,
        i
      ) : n[r] = i;
    }
  return n;
}
function $be(e) {
  const t = ["ROOT"];
  let n = -1, r = null;
  function i(c, u, f) {
    switch (c) {
      case '"': {
        n = u, t.pop(), t.push(f), t.push("INSIDE_STRING");
        break;
      }
      case "f":
      case "t":
      case "n": {
        n = u, r = u, t.pop(), t.push(f), t.push("INSIDE_LITERAL");
        break;
      }
      case "-": {
        t.pop(), t.push(f), t.push("INSIDE_NUMBER");
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9": {
        n = u, t.pop(), t.push(f), t.push("INSIDE_NUMBER");
        break;
      }
      case "{": {
        n = u, t.pop(), t.push(f), t.push("INSIDE_OBJECT_START");
        break;
      }
      case "[": {
        n = u, t.pop(), t.push(f), t.push("INSIDE_ARRAY_START");
        break;
      }
    }
  }
  function o(c, u) {
    switch (c) {
      case ",": {
        t.pop(), t.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        n = u, t.pop();
        break;
      }
    }
  }
  function s(c, u) {
    switch (c) {
      case ",": {
        t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        n = u, t.pop();
        break;
      }
    }
  }
  for (let c = 0; c < e.length; c++) {
    const u = e[c];
    switch (t[t.length - 1]) {
      case "ROOT":
        i(u, c, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (u) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            n = c, t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        u === '"' && (t.pop(), t.push("INSIDE_OBJECT_KEY"));
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        u === '"' && (t.pop(), t.push("INSIDE_OBJECT_AFTER_KEY"));
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        u === ":" && (t.pop(), t.push("INSIDE_OBJECT_BEFORE_VALUE"));
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        i(u, c, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        o(u, c);
        break;
      }
      case "INSIDE_STRING": {
        switch (u) {
          case '"': {
            t.pop(), n = c;
            break;
          }
          case "\\": {
            t.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default:
            n = c;
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        u === "]" ? (n = c, t.pop()) : (n = c, i(u, c, "INSIDE_ARRAY_AFTER_VALUE"));
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (u) {
          case ",": {
            t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            n = c, t.pop();
            break;
          }
          default: {
            n = c;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        i(u, c, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        t.pop(), n = c;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (u) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            n = c;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".":
            break;
          case ",": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && s(u, c), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && o(u, c);
            break;
          }
          case "}": {
            t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && o(u, c);
            break;
          }
          case "]": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && s(u, c);
            break;
          }
          default: {
            t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const h = e.substring(r, c + 1);
        !"false".startsWith(h) && !"true".startsWith(h) && !"null".startsWith(h) ? (t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" ? o(u, c) : t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && s(u, c)) : n = c;
        break;
      }
    }
  }
  let a = e.slice(0, n + 1);
  for (let c = t.length - 1; c >= 0; c--)
    switch (t[c]) {
      case "INSIDE_STRING": {
        a += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        a += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        a += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const f = e.substring(r, e.length);
        "true".startsWith(f) ? a += "true".slice(f.length) : "false".startsWith(f) ? a += "false".slice(f.length) : "null".startsWith(f) && (a += "null".slice(f.length));
      }
    }
  return a;
}
async function TF(e) {
  if (e === void 0)
    return { value: void 0, state: "undefined-input" };
  let t = await Mb({ text: e });
  return t.success ? { value: t.value, state: "successful-parse" } : (t = await Mb({ text: $be(e) }), t.success ? { value: t.value, state: "repaired-parse" } : { value: void 0, state: "failed-parse" });
}
function aC(e) {
  return e.type.startsWith("data-");
}
function lC(e) {
  return e.type === "text";
}
function cC(e) {
  return e.type === "file";
}
function qI(e) {
  return e.type === "reasoning";
}
function Fu(e) {
  return e.type.startsWith("tool-");
}
function NM(e) {
  return e.type === "dynamic-tool";
}
function ag(e) {
  return Fu(e) || NM(e);
}
function lg(e) {
  return e.type.split("-").slice(1).join("-");
}
function Ube(e) {
  return NM(e) ? e.toolName : lg(e);
}
function Fbe({
  lastMessage: e,
  messageId: t
}) {
  return {
    message: e?.role === "assistant" ? e : {
      id: t,
      metadata: void 0,
      role: "assistant",
      parts: []
    },
    activeTextParts: {},
    activeReasoningParts: {},
    partialToolCalls: {}
  };
}
function Vbe({
  stream: e,
  messageMetadataSchema: t,
  dataPartSchemas: n,
  runUpdateMessageJob: r,
  onError: i,
  onToolCall: o,
  onData: s
}) {
  return e.pipeThrough(
    new TransformStream({
      async transform(a, c) {
        await r(async ({ state: u, write: f }) => {
          var h, m, g, b;
          function x(N) {
            const I = u.message.parts.filter(Fu).find(
              (O) => O.toolCallId === N
            );
            if (I == null)
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available"
              );
            return I;
          }
          function w(N) {
            const I = u.message.parts.filter(
              (O) => O.type === "dynamic-tool"
            ).find(
              (O) => O.toolCallId === N
            );
            if (I == null)
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available"
              );
            return I;
          }
          function S(N) {
            var P;
            const I = u.message.parts.find(
              (U) => Fu(U) && U.toolCallId === N.toolCallId
            ), O = N, L = I;
            I != null ? (I.state = N.state, L.input = O.input, L.output = O.output, L.errorText = O.errorText, L.rawInput = O.rawInput, L.preliminary = O.preliminary, L.providerExecuted = (P = O.providerExecuted) != null ? P : I.providerExecuted, O.providerMetadata != null && I.state === "input-available" && (I.callProviderMetadata = O.providerMetadata)) : u.message.parts.push({
              type: `tool-${N.toolName}`,
              toolCallId: N.toolCallId,
              state: N.state,
              input: O.input,
              output: O.output,
              rawInput: O.rawInput,
              errorText: O.errorText,
              providerExecuted: O.providerExecuted,
              preliminary: O.preliminary,
              ...O.providerMetadata != null ? { callProviderMetadata: O.providerMetadata } : {}
            });
          }
          function _(N) {
            var P, I;
            const O = u.message.parts.find(
              (B) => B.type === "dynamic-tool" && B.toolCallId === N.toolCallId
            ), L = N, U = O;
            O != null ? (O.state = N.state, U.toolName = N.toolName, U.input = L.input, U.output = L.output, U.errorText = L.errorText, U.rawInput = (P = L.rawInput) != null ? P : U.rawInput, U.preliminary = L.preliminary, U.providerExecuted = (I = L.providerExecuted) != null ? I : O.providerExecuted, L.providerMetadata != null && O.state === "input-available" && (O.callProviderMetadata = L.providerMetadata)) : u.message.parts.push({
              type: "dynamic-tool",
              toolName: N.toolName,
              toolCallId: N.toolCallId,
              state: N.state,
              input: L.input,
              output: L.output,
              errorText: L.errorText,
              preliminary: L.preliminary,
              providerExecuted: L.providerExecuted,
              ...L.providerMetadata != null ? { callProviderMetadata: L.providerMetadata } : {}
            });
          }
          async function M(N) {
            if (N != null) {
              const P = u.message.metadata != null ? _F(u.message.metadata, N) : N;
              t != null && await BI({
                value: P,
                schema: t
              }), u.message.metadata = P;
            }
          }
          switch (a.type) {
            case "text-start": {
              const N = {
                type: "text",
                text: "",
                providerMetadata: a.providerMetadata,
                state: "streaming"
              };
              u.activeTextParts[a.id] = N, u.message.parts.push(N), f();
              break;
            }
            case "text-delta": {
              const N = u.activeTextParts[a.id];
              N.text += a.delta, N.providerMetadata = (h = a.providerMetadata) != null ? h : N.providerMetadata, f();
              break;
            }
            case "text-end": {
              const N = u.activeTextParts[a.id];
              N.state = "done", N.providerMetadata = (m = a.providerMetadata) != null ? m : N.providerMetadata, delete u.activeTextParts[a.id], f();
              break;
            }
            case "reasoning-start": {
              const N = {
                type: "reasoning",
                text: "",
                providerMetadata: a.providerMetadata,
                state: "streaming"
              };
              u.activeReasoningParts[a.id] = N, u.message.parts.push(N), f();
              break;
            }
            case "reasoning-delta": {
              const N = u.activeReasoningParts[a.id];
              N.text += a.delta, N.providerMetadata = (g = a.providerMetadata) != null ? g : N.providerMetadata, f();
              break;
            }
            case "reasoning-end": {
              const N = u.activeReasoningParts[a.id];
              N.providerMetadata = (b = a.providerMetadata) != null ? b : N.providerMetadata, N.state = "done", delete u.activeReasoningParts[a.id], f();
              break;
            }
            case "file": {
              u.message.parts.push({
                type: "file",
                mediaType: a.mediaType,
                url: a.url
              }), f();
              break;
            }
            case "source-url": {
              u.message.parts.push({
                type: "source-url",
                sourceId: a.sourceId,
                url: a.url,
                title: a.title,
                providerMetadata: a.providerMetadata
              }), f();
              break;
            }
            case "source-document": {
              u.message.parts.push({
                type: "source-document",
                sourceId: a.sourceId,
                mediaType: a.mediaType,
                title: a.title,
                filename: a.filename,
                providerMetadata: a.providerMetadata
              }), f();
              break;
            }
            case "tool-input-start": {
              const N = u.message.parts.filter(Fu);
              u.partialToolCalls[a.toolCallId] = {
                text: "",
                toolName: a.toolName,
                index: N.length,
                dynamic: a.dynamic
              }, a.dynamic ? _({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: a.providerExecuted
              }) : S({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: a.providerExecuted
              }), f();
              break;
            }
            case "tool-input-delta": {
              const N = u.partialToolCalls[a.toolCallId];
              N.text += a.inputTextDelta;
              const { value: P } = await TF(
                N.text
              );
              N.dynamic ? _({
                toolCallId: a.toolCallId,
                toolName: N.toolName,
                state: "input-streaming",
                input: P
              }) : S({
                toolCallId: a.toolCallId,
                toolName: N.toolName,
                state: "input-streaming",
                input: P
              }), f();
              break;
            }
            case "tool-input-available": {
              a.dynamic ? _({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "input-available",
                input: a.input,
                providerExecuted: a.providerExecuted,
                providerMetadata: a.providerMetadata
              }) : S({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "input-available",
                input: a.input,
                providerExecuted: a.providerExecuted,
                providerMetadata: a.providerMetadata
              }), f(), o && !a.providerExecuted && await o({
                toolCall: a
              });
              break;
            }
            case "tool-input-error": {
              a.dynamic ? _({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "output-error",
                input: a.input,
                errorText: a.errorText,
                providerExecuted: a.providerExecuted,
                providerMetadata: a.providerMetadata
              }) : S({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "output-error",
                input: void 0,
                rawInput: a.input,
                errorText: a.errorText,
                providerExecuted: a.providerExecuted,
                providerMetadata: a.providerMetadata
              }), f();
              break;
            }
            case "tool-output-available": {
              if (a.dynamic) {
                const N = w(
                  a.toolCallId
                );
                _({
                  toolCallId: a.toolCallId,
                  toolName: N.toolName,
                  state: "output-available",
                  input: N.input,
                  output: a.output,
                  preliminary: a.preliminary
                });
              } else {
                const N = x(a.toolCallId);
                S({
                  toolCallId: a.toolCallId,
                  toolName: lg(N),
                  state: "output-available",
                  input: N.input,
                  output: a.output,
                  providerExecuted: a.providerExecuted,
                  preliminary: a.preliminary
                });
              }
              f();
              break;
            }
            case "tool-output-error": {
              if (a.dynamic) {
                const N = w(
                  a.toolCallId
                );
                _({
                  toolCallId: a.toolCallId,
                  toolName: N.toolName,
                  state: "output-error",
                  input: N.input,
                  errorText: a.errorText,
                  providerExecuted: a.providerExecuted
                });
              } else {
                const N = x(a.toolCallId);
                S({
                  toolCallId: a.toolCallId,
                  toolName: lg(N),
                  state: "output-error",
                  input: N.input,
                  rawInput: N.rawInput,
                  errorText: a.errorText,
                  providerExecuted: a.providerExecuted
                });
              }
              f();
              break;
            }
            case "start-step": {
              u.message.parts.push({ type: "step-start" });
              break;
            }
            case "finish-step": {
              u.activeTextParts = {}, u.activeReasoningParts = {};
              break;
            }
            case "start": {
              a.messageId != null && (u.message.id = a.messageId), await M(a.messageMetadata), (a.messageId != null || a.messageMetadata != null) && f();
              break;
            }
            case "finish": {
              a.finishReason != null && (u.finishReason = a.finishReason), await M(a.messageMetadata), a.messageMetadata != null && f();
              break;
            }
            case "message-metadata": {
              await M(a.messageMetadata), a.messageMetadata != null && f();
              break;
            }
            case "error": {
              i?.(new Error(a.errorText));
              break;
            }
            default:
              if (Bbe(a)) {
                n?.[a.type] != null && await BI({
                  value: a.data,
                  schema: n[a.type]
                });
                const N = a;
                if (N.transient) {
                  s?.(N);
                  break;
                }
                const P = N.id != null ? u.message.parts.find(
                  (I) => N.type === I.type && N.id === I.id
                ) : void 0;
                P != null ? P.data = N.data : u.message.parts.push(N), s?.(N), f();
              }
          }
          c.enqueue(a);
        });
      }
    })
  );
}
async function Hbe({
  stream: e,
  onError: t
}) {
  const n = e.getReader();
  try {
    for (; ; ) {
      const { done: r } = await n.read();
      if (r)
        break;
    }
  } catch (r) {
    t?.(r);
  } finally {
    n.releaseLock();
  }
}
Xg({
  prefix: "aitxt",
  size: 24
});
function Wbe(e, t) {
  const n = [];
  t?.ignoreIncompleteToolCalls && (e = e.map((r) => ({
    ...r,
    parts: r.parts.filter(
      (i) => !ag(i) || i.state !== "input-streaming" && i.state !== "input-available"
    )
  })));
  for (const r of e)
    switch (r.role) {
      case "system": {
        const i = r.parts.filter(
          (s) => s.type === "text"
        ), o = i.reduce((s, a) => a.providerMetadata != null ? { ...s, ...a.providerMetadata } : s, {});
        n.push({
          role: "system",
          content: i.map((s) => s.text).join(""),
          ...Object.keys(o).length > 0 ? { providerOptions: o } : {}
        });
        break;
      }
      case "user": {
        n.push({
          role: "user",
          content: r.parts.map((i) => {
            var o;
            if (lC(i))
              return {
                type: "text",
                text: i.text,
                ...i.providerMetadata != null ? { providerOptions: i.providerMetadata } : {}
              };
            if (cC(i))
              return {
                type: "file",
                mediaType: i.mediaType,
                filename: i.filename,
                data: i.url,
                ...i.providerMetadata != null ? { providerOptions: i.providerMetadata } : {}
              };
            if (aC(i))
              return (o = t?.convertDataPart) == null ? void 0 : o.call(
                t,
                i
              );
          }).filter((i) => i != null)
        });
        break;
      }
      case "assistant": {
        if (r.parts != null) {
          let i = function() {
            var s, a, c;
            if (o.length === 0)
              return;
            const u = [];
            for (const h of o)
              if (lC(h))
                u.push({
                  type: "text",
                  text: h.text,
                  ...h.providerMetadata != null ? { providerOptions: h.providerMetadata } : {}
                });
              else if (cC(h))
                u.push({
                  type: "file",
                  mediaType: h.mediaType,
                  filename: h.filename,
                  data: h.url
                });
              else if (qI(h))
                u.push({
                  type: "reasoning",
                  text: h.text,
                  providerOptions: h.providerMetadata
                });
              else if (NM(h)) {
                const m = h.toolName;
                h.state !== "input-streaming" && u.push({
                  type: "tool-call",
                  toolCallId: h.toolCallId,
                  toolName: m,
                  input: h.input,
                  ...h.callProviderMetadata != null ? { providerOptions: h.callProviderMetadata } : {}
                });
              } else if (Fu(h)) {
                const m = lg(h);
                h.state !== "input-streaming" && (u.push({
                  type: "tool-call",
                  toolCallId: h.toolCallId,
                  toolName: m,
                  input: h.state === "output-error" ? (s = h.input) != null ? s : h.rawInput : h.input,
                  providerExecuted: h.providerExecuted,
                  ...h.callProviderMetadata != null ? { providerOptions: h.callProviderMetadata } : {}
                }), h.providerExecuted === !0 && (h.state === "output-available" || h.state === "output-error") && u.push({
                  type: "tool-result",
                  toolCallId: h.toolCallId,
                  toolName: m,
                  output: HI({
                    output: h.state === "output-error" ? h.errorText : h.output,
                    tool: (a = t?.tools) == null ? void 0 : a[m],
                    errorMode: h.state === "output-error" ? "json" : "none"
                  }),
                  ...h.callProviderMetadata != null ? { providerOptions: h.callProviderMetadata } : {}
                }));
              } else if (aC(h)) {
                const m = (c = t?.convertDataPart) == null ? void 0 : c.call(
                  t,
                  h
                );
                m != null && u.push(m);
              } else {
                const m = h;
                throw new Error(`Unsupported part: ${m}`);
              }
            n.push({
              role: "assistant",
              content: u
            });
            const f = o.filter(
              (h) => Fu(h) && h.providerExecuted !== !0 || h.type === "dynamic-tool"
            );
            f.length > 0 && n.push({
              role: "tool",
              content: f.map((h) => {
                var m;
                switch (h.state) {
                  case "output-error":
                  case "output-available": {
                    const g = Ube(h);
                    return {
                      type: "tool-result",
                      toolCallId: h.toolCallId,
                      toolName: g,
                      output: HI({
                        output: h.state === "output-error" ? h.errorText : h.output,
                        tool: (m = t?.tools) == null ? void 0 : m[g],
                        errorMode: h.state === "output-error" ? "text" : "none"
                      }),
                      ...h.callProviderMetadata != null ? { providerOptions: h.callProviderMetadata } : {}
                    };
                  }
                  default:
                    return null;
                }
              }).filter(
                (h) => h != null
              )
            }), o = [];
          }, o = [];
          for (const s of r.parts)
            lC(s) || qI(s) || cC(s) || ag(s) || aC(s) ? o.push(s) : s.type === "step-start" && i();
          i();
          break;
        }
        break;
      }
      default: {
        const i = r.role;
        throw new Mbe({
          originalMessage: r,
          message: `Unsupported role: ${i}`
        });
      }
    }
  return n;
}
Xg({ prefix: "aiobj", size: 24 });
var qbe = class {
  constructor() {
    this.queue = [], this.isProcessing = !1;
  }
  async processQueue() {
    if (!this.isProcessing) {
      for (this.isProcessing = !0; this.queue.length > 0; )
        await this.queue[0](), this.queue.shift();
      this.isProcessing = !1;
    }
  }
  async run(e) {
    return new Promise((t, n) => {
      this.queue.push(async () => {
        try {
          await e(), t();
        } catch (r) {
          n(r);
        }
      }), this.processQueue();
    });
  }
};
Xg({ prefix: "aiobj", size: 24 });
var Gbe = {};
_be(Gbe, {
  object: () => Zbe,
  text: () => Kbe
});
var Kbe = () => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: e }) {
    return { partial: e };
  },
  async parseOutput({ text: e }) {
    return e;
  }
}), Zbe = ({
  schema: e
}) => {
  const t = Cbe(e);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: t.jsonSchema
    },
    async parsePartial({ text: n }) {
      const r = await TF(n);
      switch (r.state) {
        case "failed-parse":
        case "undefined-input":
          return;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: r.value
          };
        default: {
          const i = r.state;
          throw new Error(`Unsupported parse state: ${i}`);
        }
      }
    },
    async parseOutput({ text: n }, r) {
      const i = await Mb({ text: n });
      if (!i.success)
        throw new FI({
          message: "No object generated: could not parse the response.",
          cause: i.error,
          text: n,
          response: r.response,
          usage: r.usage,
          finishReason: r.finishReason
        });
      const o = await AM({
        value: i.value,
        schema: t
      });
      if (!o.success)
        throw new FI({
          message: "No object generated: response did not match schema.",
          cause: o.error,
          text: n,
          response: r.response,
          usage: r.usage,
          finishReason: r.finishReason
        });
      return o.value;
    }
  };
};
async function Ybe(e) {
  if (e == null)
    return [];
  if (!globalThis.FileList || !(e instanceof globalThis.FileList))
    throw new Error("FileList is not supported in the current environment");
  return Promise.all(
    Array.from(e).map(async (t) => {
      const { name: n, type: r } = t, i = await new Promise((o, s) => {
        const a = new FileReader();
        a.onload = (c) => {
          var u;
          o((u = c.target) == null ? void 0 : u.result);
        }, a.onerror = (c) => s(c), a.readAsDataURL(t);
      });
      return {
        type: "file",
        mediaType: r,
        filename: n,
        url: i
      };
    })
  );
}
var Xbe = class {
  constructor({
    api: e = "/api/chat",
    credentials: t,
    headers: n,
    body: r,
    fetch: i,
    prepareSendMessagesRequest: o,
    prepareReconnectToStreamRequest: s
  }) {
    this.api = e, this.credentials = t, this.headers = n, this.body = r, this.fetch = i, this.prepareSendMessagesRequest = o, this.prepareReconnectToStreamRequest = s;
  }
  async sendMessages({
    abortSignal: e,
    ...t
  }) {
    var n, r, i, o, s;
    const a = await mf(this.body), c = await mf(this.headers), u = await mf(this.credentials), f = {
      ...Mu(c),
      ...Mu(t.headers)
    }, h = await ((n = this.prepareSendMessagesRequest) == null ? void 0 : n.call(this, {
      api: this.api,
      id: t.chatId,
      messages: t.messages,
      body: { ...a, ...t.body },
      headers: f,
      credentials: u,
      requestMetadata: t.metadata,
      trigger: t.trigger,
      messageId: t.messageId
    })), m = (r = h?.api) != null ? r : this.api, g = h?.headers !== void 0 ? Mu(h.headers) : f, b = h?.body !== void 0 ? h.body : {
      ...a,
      ...t.body,
      id: t.chatId,
      messages: t.messages,
      trigger: t.trigger,
      messageId: t.messageId
    }, x = (i = h?.credentials) != null ? i : u, S = await ((o = this.fetch) != null ? o : globalThis.fetch)(m, {
      method: "POST",
      headers: zI(
        {
          "Content-Type": "application/json",
          ...g
        },
        `ai-sdk/${VI}`,
        II()
      ),
      body: JSON.stringify(b),
      credentials: x,
      signal: e
    });
    if (!S.ok)
      throw new Error(
        (s = await S.text()) != null ? s : "Failed to fetch the chat response."
      );
    if (!S.body)
      throw new Error("The response body is empty.");
    return this.processResponseStream(S.body);
  }
  async reconnectToStream(e) {
    var t, n, r, i, o;
    const s = await mf(this.body), a = await mf(this.headers), c = await mf(this.credentials), u = {
      ...Mu(a),
      ...Mu(e.headers)
    }, f = await ((t = this.prepareReconnectToStreamRequest) == null ? void 0 : t.call(this, {
      api: this.api,
      id: e.chatId,
      body: { ...s, ...e.body },
      headers: u,
      credentials: c,
      requestMetadata: e.metadata
    })), h = (n = f?.api) != null ? n : `${this.api}/${e.chatId}/stream`, m = f?.headers !== void 0 ? Mu(f.headers) : u, g = (r = f?.credentials) != null ? r : c, x = await ((i = this.fetch) != null ? i : globalThis.fetch)(h, {
      method: "GET",
      headers: zI(
        m,
        `ai-sdk/${VI}`,
        II()
      ),
      credentials: g
    });
    if (x.status === 204)
      return null;
    if (!x.ok)
      throw new Error(
        (o = await x.text()) != null ? o : "Failed to fetch the chat response."
      );
    if (!x.body)
      throw new Error("The response body is empty.");
    return this.processResponseStream(x.body);
  }
}, AF = class extends Xbe {
  constructor(e = {}) {
    super(e);
  }
  processResponseStream(e) {
    return O0e({
      stream: e,
      schema: Lbe
    }).pipeThrough(
      new TransformStream({
        async transform(t, n) {
          if (!t.success)
            throw t.error;
          n.enqueue(t.value);
        }
      })
    );
  }
}, Jbe = class {
  constructor({
    generateId: e = S0e,
    id: t = e(),
    transport: n = new AF(),
    messageMetadataSchema: r,
    dataPartSchemas: i,
    state: o,
    onError: s,
    onToolCall: a,
    onFinish: c,
    onData: u,
    sendAutomaticallyWhen: f
  }) {
    this.activeResponse = void 0, this.jobExecutor = new qbe(), this.sendMessage = async (h, m) => {
      var g, b, x, w;
      if (h == null) {
        await this.makeRequest({
          trigger: "submit-message",
          messageId: (g = this.lastMessage) == null ? void 0 : g.id,
          ...m
        });
        return;
      }
      let S;
      if ("text" in h || "files" in h ? S = {
        parts: [
          ...Array.isArray(h.files) ? h.files : await Ybe(h.files),
          ..."text" in h && h.text != null ? [{ type: "text", text: h.text }] : []
        ]
      } : S = h, h.messageId != null) {
        const _ = this.state.messages.findIndex(
          (M) => M.id === h.messageId
        );
        if (_ === -1)
          throw new Error(`message with id ${h.messageId} not found`);
        if (this.state.messages[_].role !== "user")
          throw new Error(
            `message with id ${h.messageId} is not a user message`
          );
        this.state.messages = this.state.messages.slice(0, _ + 1), this.state.replaceMessage(_, {
          ...S,
          id: h.messageId,
          role: (b = S.role) != null ? b : "user",
          metadata: h.metadata
        });
      } else
        this.state.pushMessage({
          ...S,
          id: (x = S.id) != null ? x : this.generateId(),
          role: (w = S.role) != null ? w : "user",
          metadata: h.metadata
        });
      await this.makeRequest({
        trigger: "submit-message",
        messageId: h.messageId,
        ...m
      });
    }, this.regenerate = async ({
      messageId: h,
      ...m
    } = {}) => {
      const g = h == null ? this.state.messages.length - 1 : this.state.messages.findIndex((b) => b.id === h);
      if (g === -1)
        throw new Error(`message ${h} not found`);
      this.state.messages = this.state.messages.slice(
        0,
        // if the message is a user message, we need to include it in the request:
        this.messages[g].role === "assistant" ? g : g + 1
      ), await this.makeRequest({
        trigger: "regenerate-message",
        messageId: h,
        ...m
      });
    }, this.resumeStream = async (h = {}) => {
      await this.makeRequest({ trigger: "resume-stream", ...h });
    }, this.clearError = () => {
      this.status === "error" && (this.state.error = void 0, this.setStatus({ status: "ready" }));
    }, this.addToolOutput = async ({
      state: h = "output-available",
      tool: m,
      toolCallId: g,
      output: b,
      errorText: x
    }) => this.jobExecutor.run(async () => {
      var w, S;
      const _ = this.state.messages, M = _[_.length - 1];
      this.state.replaceMessage(_.length - 1, {
        ...M,
        parts: M.parts.map(
          (N) => ag(N) && N.toolCallId === g ? { ...N, state: h, output: b, errorText: x } : N
        )
      }), this.activeResponse && (this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(
        (N) => ag(N) && N.toolCallId === g ? {
          ...N,
          state: h,
          output: b,
          errorText: x
        } : N
      )), this.status !== "streaming" && this.status !== "submitted" && ((w = this.sendAutomaticallyWhen) != null && w.call(this, { messages: this.state.messages })) && this.makeRequest({
        trigger: "submit-message",
        messageId: (S = this.lastMessage) == null ? void 0 : S.id
      });
    }), this.addToolResult = this.addToolOutput, this.stop = async () => {
      var h;
      this.status !== "streaming" && this.status !== "submitted" || (h = this.activeResponse) != null && h.abortController && this.activeResponse.abortController.abort();
    }, this.id = t, this.transport = n, this.generateId = e, this.messageMetadataSchema = r, this.dataPartSchemas = i, this.state = o, this.onError = s, this.onToolCall = a, this.onFinish = c, this.onData = u, this.sendAutomaticallyWhen = f;
  }
  /**
   * Hook status:
   *
   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.
   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.
   * - `ready`: The full response has been received and processed; a new user message can be submitted.
   * - `error`: An error occurred during the API request, preventing successful completion.
   */
  get status() {
    return this.state.status;
  }
  setStatus({
    status: e,
    error: t
  }) {
    this.status !== e && (this.state.status = e, this.state.error = t);
  }
  get error() {
    return this.state.error;
  }
  get messages() {
    return this.state.messages;
  }
  get lastMessage() {
    return this.state.messages[this.state.messages.length - 1];
  }
  set messages(e) {
    this.state.messages = e;
  }
  async makeRequest({
    trigger: e,
    metadata: t,
    headers: n,
    body: r,
    messageId: i
  }) {
    var o, s, a, c;
    this.setStatus({ status: "submitted", error: void 0 });
    const u = this.lastMessage;
    let f = !1, h = !1, m = !1;
    try {
      const g = {
        state: Fbe({
          lastMessage: this.state.snapshot(u),
          messageId: this.generateId()
        }),
        abortController: new AbortController()
      };
      g.abortController.signal.addEventListener("abort", () => {
        f = !0;
      }), this.activeResponse = g;
      let b;
      if (e === "resume-stream") {
        const w = await this.transport.reconnectToStream({
          chatId: this.id,
          metadata: t,
          headers: n,
          body: r
        });
        if (w == null) {
          this.setStatus({ status: "ready" });
          return;
        }
        b = w;
      } else
        b = await this.transport.sendMessages({
          chatId: this.id,
          messages: this.state.messages,
          abortSignal: g.abortController.signal,
          metadata: t,
          headers: n,
          body: r,
          trigger: e,
          messageId: i
        });
      const x = (w) => (
        // serialize the job execution to avoid race conditions:
        this.jobExecutor.run(
          () => w({
            state: g.state,
            write: () => {
              var S;
              this.setStatus({ status: "streaming" }), g.state.message.id === ((S = this.lastMessage) == null ? void 0 : S.id) ? this.state.replaceMessage(
                this.state.messages.length - 1,
                g.state.message
              ) : this.state.pushMessage(g.state.message);
            }
          })
        )
      );
      await Hbe({
        stream: Vbe({
          stream: b,
          onToolCall: this.onToolCall,
          onData: this.onData,
          messageMetadataSchema: this.messageMetadataSchema,
          dataPartSchemas: this.dataPartSchemas,
          runUpdateMessageJob: x,
          onError: (w) => {
            throw w;
          }
        }),
        onError: (w) => {
          throw w;
        }
      }), this.setStatus({ status: "ready" });
    } catch (g) {
      if (f || g.name === "AbortError")
        return f = !0, this.setStatus({ status: "ready" }), null;
      m = !0, g instanceof TypeError && (g.message.toLowerCase().includes("fetch") || g.message.toLowerCase().includes("network")) && (h = !0), this.onError && g instanceof Error && this.onError(g), this.setStatus({ status: "error", error: g });
    } finally {
      try {
        (s = this.onFinish) == null || s.call(this, {
          message: this.activeResponse.state.message,
          messages: this.state.messages,
          isAbort: f,
          isDisconnect: h,
          isError: m,
          finishReason: (o = this.activeResponse) == null ? void 0 : o.state.finishReason
        });
      } catch (g) {
        console.error(g);
      }
      this.activeResponse = void 0;
    }
    (a = this.sendAutomaticallyWhen) != null && a.call(this, { messages: this.state.messages }) && !m && await this.makeRequest({
      trigger: "submit-message",
      messageId: (c = this.lastMessage) == null ? void 0 : c.id,
      metadata: t,
      headers: n,
      body: r
    });
  }
};
function Qbe({
  messages: e
}) {
  const t = e[e.length - 1];
  if (!t || t.role !== "assistant")
    return !1;
  const n = t.parts.reduce((i, o, s) => o.type === "step-start" ? s : i, -1), r = t.parts.slice(n + 1).filter(ag).filter((i) => !i.providerExecuted);
  return r.length > 0 && r.every(
    (i) => i.state === "output-available" || i.state === "output-error"
  );
}
var uC, GI;
function exe() {
  if (GI) return uC;
  GI = 1;
  function e(t, n) {
    if (typeof t != "function")
      throw new TypeError(`Expected the first argument to be a \`function\`, got \`${typeof t}\`.`);
    let r, i = 0;
    return function(...s) {
      clearTimeout(r);
      const a = Date.now(), c = a - i, u = n - c;
      u <= 0 ? (i = a, t.apply(this, s)) : r = setTimeout(() => {
        i = Date.now(), t.apply(this, s);
      }, u);
    };
  }
  return uC = e, uC;
}
var txe = /* @__PURE__ */ exe();
const nxe = /* @__PURE__ */ Pc(txe);
var MF = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, Un = (e, t, n) => (MF(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Ds = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Jl = (e, t, n, r) => (MF(e, t, "write to private field"), t.set(e, n), n);
function rxe(e, t) {
  return t != null ? nxe(e, t) : e;
}
var No, A0, M0, um, dm, fm, Ef, R_, O_, ixe = class {
  constructor(e = []) {
    Ds(this, No, void 0), Ds(this, A0, "ready"), Ds(this, M0, void 0), Ds(this, um, /* @__PURE__ */ new Set()), Ds(this, dm, /* @__PURE__ */ new Set()), Ds(this, fm, /* @__PURE__ */ new Set()), this.pushMessage = (t) => {
      Jl(this, No, Un(this, No).concat(t)), Un(this, Ef).call(this);
    }, this.popMessage = () => {
      Jl(this, No, Un(this, No).slice(0, -1)), Un(this, Ef).call(this);
    }, this.replaceMessage = (t, n) => {
      Jl(this, No, [
        ...Un(this, No).slice(0, t),
        // We deep clone the message here to ensure the new React Compiler (currently in RC) detects deeply nested parts/metadata changes:
        this.snapshot(n),
        ...Un(this, No).slice(t + 1)
      ]), Un(this, Ef).call(this);
    }, this.snapshot = (t) => structuredClone(t), this["~registerMessagesCallback"] = (t, n) => {
      const r = n ? rxe(t, n) : t;
      return Un(this, um).add(r), () => {
        Un(this, um).delete(r);
      };
    }, this["~registerStatusCallback"] = (t) => (Un(this, dm).add(t), () => {
      Un(this, dm).delete(t);
    }), this["~registerErrorCallback"] = (t) => (Un(this, fm).add(t), () => {
      Un(this, fm).delete(t);
    }), Ds(this, Ef, () => {
      Un(this, um).forEach((t) => t());
    }), Ds(this, R_, () => {
      Un(this, dm).forEach((t) => t());
    }), Ds(this, O_, () => {
      Un(this, fm).forEach((t) => t());
    }), Jl(this, No, e);
  }
  get status() {
    return Un(this, A0);
  }
  set status(e) {
    Jl(this, A0, e), Un(this, R_).call(this);
  }
  get error() {
    return Un(this, M0);
  }
  set error(e) {
    Jl(this, M0, e), Un(this, O_).call(this);
  }
  get messages() {
    return Un(this, No);
  }
  set messages(e) {
    Jl(this, No, [...e]), Un(this, Ef).call(this);
  }
};
No = /* @__PURE__ */ new WeakMap();
A0 = /* @__PURE__ */ new WeakMap();
M0 = /* @__PURE__ */ new WeakMap();
um = /* @__PURE__ */ new WeakMap();
dm = /* @__PURE__ */ new WeakMap();
fm = /* @__PURE__ */ new WeakMap();
Ef = /* @__PURE__ */ new WeakMap();
R_ = /* @__PURE__ */ new WeakMap();
O_ = /* @__PURE__ */ new WeakMap();
var _f, KI = class extends Jbe {
  constructor({ messages: e, ...t }) {
    const n = new ixe(e);
    super({ ...t, state: n }), Ds(this, _f, void 0), this["~registerMessagesCallback"] = (r, i) => Un(this, _f)["~registerMessagesCallback"](r, i), this["~registerStatusCallback"] = (r) => Un(this, _f)["~registerStatusCallback"](r), this["~registerErrorCallback"] = (r) => Un(this, _f)["~registerErrorCallback"](r), Jl(this, _f, n);
  }
};
_f = /* @__PURE__ */ new WeakMap();
function oxe({
  experimental_throttle: e,
  resume: t = !1,
  ...n
} = {}) {
  const r = k.useRef(
    "chat" in n ? n.chat : new KI(n)
  );
  ("chat" in n && n.chat !== r.current || "id" in n && r.current.id !== n.id) && (r.current = "chat" in n ? n.chat : new KI(n));
  const o = k.useCallback(
    (f) => r.current["~registerMessagesCallback"](f, e),
    // `chatRef.current.id` is required to trigger re-subscription when the chat ID changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [e, r.current.id]
  ), s = k.useSyncExternalStore(
    o,
    () => r.current.messages,
    () => r.current.messages
  ), a = k.useSyncExternalStore(
    r.current["~registerStatusCallback"],
    () => r.current.status,
    () => r.current.status
  ), c = k.useSyncExternalStore(
    r.current["~registerErrorCallback"],
    () => r.current.error,
    () => r.current.error
  ), u = k.useCallback(
    (f) => {
      typeof f == "function" && (f = f(r.current.messages)), r.current.messages = f;
    },
    [r]
  );
  return k.useEffect(() => {
    t && r.current.resumeStream();
  }, [t, r]), {
    id: r.current.id,
    messages: s,
    setMessages: u,
    sendMessage: r.current.sendMessage,
    regenerate: r.current.regenerate,
    clearError: r.current.clearError,
    stop: r.current.stop,
    error: c,
    resumeStream: r.current.resumeStream,
    status: a,
    /**
     * @deprecated Use `addToolOutput` instead.
     */
    addToolResult: r.current.addToolOutput,
    addToolOutput: r.current.addToolOutput
  };
}
function Mm(e, t) {
  if (e === t) return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (Object.getPrototypeOf(e) !== Object.getPrototypeOf(t)) return !1;
    if (Array.isArray(e)) {
      if (!Array.isArray(t) || e.length !== t.length) return !1;
      for (let i = 0; i < e.length; i++)
        if (!Mm(e[i], t[i])) return !1;
      return !0;
    }
    if (e instanceof Date)
      return t instanceof Date && e.getTime() === t.getTime();
    if (e instanceof RegExp)
      return t instanceof RegExp && e.source === t.source && e.flags === t.flags;
    if (e instanceof Map) {
      if (!(t instanceof Map) || e.size !== t.size) return !1;
      for (const [i, o] of e)
        if (!t.has(i) || !Mm(o, t.get(i))) return !1;
      return !0;
    }
    if (e instanceof Set) {
      if (!(t instanceof Set) || e.size !== t.size) return !1;
      for (const i of e)
        if (!t.has(i)) return !1;
      return !0;
    }
    const n = Object.keys(e), r = Object.keys(t);
    if (n.length !== r.length) return !1;
    for (const i of n)
      if (!Object.prototype.hasOwnProperty.call(t, i) || !Mm(e[i], t[i])) return !1;
    return !0;
  }
  return Number.isNaN(e) && Number.isNaN(t);
}
function NF(e, t) {
  const n = t || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const sxe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, axe = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, lxe = {};
function ZI(e, t) {
  return (lxe.jsx ? axe : sxe).test(e);
}
const cxe = /[ \t\n\f\r]/g;
function _w(e) {
  return typeof e == "object" ? e.type === "text" ? YI(e.value) : !1 : YI(e);
}
function YI(e) {
  return e.replace(cxe, "") === "";
}
let Jg = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
};
Jg.prototype.normal = {};
Jg.prototype.property = {};
Jg.prototype.space = void 0;
function RF(e, t) {
  const n = {}, r = {};
  for (const i of e)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new Jg(n, r, t);
}
function D_(e) {
  return e.toLowerCase();
}
class Yi {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
Yi.prototype.attribute = "";
Yi.prototype.booleanish = !1;
Yi.prototype.boolean = !1;
Yi.prototype.commaOrSpaceSeparated = !1;
Yi.prototype.commaSeparated = !1;
Yi.prototype.defined = !1;
Yi.prototype.mustUseProperty = !1;
Yi.prototype.number = !1;
Yi.prototype.overloadedBoolean = !1;
Yi.prototype.property = "";
Yi.prototype.spaceSeparated = !1;
Yi.prototype.space = void 0;
let uxe = 0;
const Dt = pd(), wr = pd(), P_ = pd(), Fe = pd(), Rn = pd(), Yf = pd(), ao = pd();
function pd() {
  return 2 ** ++uxe;
}
const j_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Dt,
  booleanish: wr,
  commaOrSpaceSeparated: ao,
  commaSeparated: Yf,
  number: Fe,
  overloadedBoolean: P_,
  spaceSeparated: Rn
}, Symbol.toStringTag, { value: "Module" })), dC = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(j_)
);
class RM extends Yi {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, i) {
    let o = -1;
    if (super(t, n), XI(this, "space", i), typeof r == "number")
      for (; ++o < dC.length; ) {
        const s = dC[o];
        XI(this, dC[o], (r & j_[s]) === j_[s]);
      }
  }
}
RM.prototype.defined = !0;
function XI(e, t, n) {
  n && (e[t] = n);
}
function Bh(e) {
  const t = {}, n = {};
  for (const [r, i] of Object.entries(e.properties)) {
    const o = new RM(
      r,
      e.transform(e.attributes || {}, r),
      i,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (o.mustUseProperty = !0), t[r] = o, n[D_(r)] = r, n[D_(o.attribute)] = r;
  }
  return new Jg(t, n, e.space);
}
const OF = Bh({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: wr,
    ariaAutoComplete: null,
    ariaBusy: wr,
    ariaChecked: wr,
    ariaColCount: Fe,
    ariaColIndex: Fe,
    ariaColSpan: Fe,
    ariaControls: Rn,
    ariaCurrent: null,
    ariaDescribedBy: Rn,
    ariaDetails: null,
    ariaDisabled: wr,
    ariaDropEffect: Rn,
    ariaErrorMessage: null,
    ariaExpanded: wr,
    ariaFlowTo: Rn,
    ariaGrabbed: wr,
    ariaHasPopup: null,
    ariaHidden: wr,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Rn,
    ariaLevel: Fe,
    ariaLive: null,
    ariaModal: wr,
    ariaMultiLine: wr,
    ariaMultiSelectable: wr,
    ariaOrientation: null,
    ariaOwns: Rn,
    ariaPlaceholder: null,
    ariaPosInSet: Fe,
    ariaPressed: wr,
    ariaReadOnly: wr,
    ariaRelevant: null,
    ariaRequired: wr,
    ariaRoleDescription: Rn,
    ariaRowCount: Fe,
    ariaRowIndex: Fe,
    ariaRowSpan: Fe,
    ariaSelected: wr,
    ariaSetSize: Fe,
    ariaSort: null,
    ariaValueMax: Fe,
    ariaValueMin: Fe,
    ariaValueNow: Fe,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function DF(e, t) {
  return t in e ? e[t] : t;
}
function PF(e, t) {
  return DF(e, t.toLowerCase());
}
const dxe = Bh({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Yf,
    acceptCharset: Rn,
    accessKey: Rn,
    action: null,
    allow: null,
    allowFullScreen: Dt,
    allowPaymentRequest: Dt,
    allowUserMedia: Dt,
    alt: null,
    as: null,
    async: Dt,
    autoCapitalize: null,
    autoComplete: Rn,
    autoFocus: Dt,
    autoPlay: Dt,
    blocking: Rn,
    capture: null,
    charSet: null,
    checked: Dt,
    cite: null,
    className: Rn,
    cols: Fe,
    colSpan: null,
    content: null,
    contentEditable: wr,
    controls: Dt,
    controlsList: Rn,
    coords: Fe | Yf,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Dt,
    defer: Dt,
    dir: null,
    dirName: null,
    disabled: Dt,
    download: P_,
    draggable: wr,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Dt,
    formTarget: null,
    headers: Rn,
    height: Fe,
    hidden: P_,
    high: Fe,
    href: null,
    hrefLang: null,
    htmlFor: Rn,
    httpEquiv: Rn,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Dt,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Dt,
    itemId: null,
    itemProp: Rn,
    itemRef: Rn,
    itemScope: Dt,
    itemType: Rn,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Dt,
    low: Fe,
    manifest: null,
    max: null,
    maxLength: Fe,
    media: null,
    method: null,
    min: null,
    minLength: Fe,
    multiple: Dt,
    muted: Dt,
    name: null,
    nonce: null,
    noModule: Dt,
    noValidate: Dt,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Dt,
    optimum: Fe,
    pattern: null,
    ping: Rn,
    placeholder: null,
    playsInline: Dt,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Dt,
    referrerPolicy: null,
    rel: Rn,
    required: Dt,
    reversed: Dt,
    rows: Fe,
    rowSpan: Fe,
    sandbox: Rn,
    scope: null,
    scoped: Dt,
    seamless: Dt,
    selected: Dt,
    shadowRootClonable: Dt,
    shadowRootDelegatesFocus: Dt,
    shadowRootMode: null,
    shape: null,
    size: Fe,
    sizes: null,
    slot: null,
    span: Fe,
    spellCheck: wr,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: Fe,
    step: null,
    style: null,
    tabIndex: Fe,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Dt,
    useMap: null,
    value: wr,
    width: Fe,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Rn,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: Fe,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: Fe,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Dt,
    // Lists. Use CSS to reduce space between items instead
    declare: Dt,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: Fe,
    // `<img>` and `<object>`
    leftMargin: Fe,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: Fe,
    // `<body>`
    marginWidth: Fe,
    // `<body>`
    noResize: Dt,
    // `<frame>`
    noHref: Dt,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Dt,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Dt,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: Fe,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: wr,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: Fe,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: Fe,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Dt,
    disableRemotePlayback: Dt,
    prefix: null,
    property: null,
    results: Fe,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: PF
}), fxe = Bh({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: ao,
    accentHeight: Fe,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: Fe,
    amplitude: Fe,
    arabicForm: null,
    ascent: Fe,
    attributeName: null,
    attributeType: null,
    azimuth: Fe,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: Fe,
    by: null,
    calcMode: null,
    capHeight: Fe,
    className: Rn,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: Fe,
    diffuseConstant: Fe,
    direction: null,
    display: null,
    dur: null,
    divisor: Fe,
    dominantBaseline: null,
    download: Dt,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: Fe,
    enableBackground: null,
    end: null,
    event: null,
    exponent: Fe,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: Fe,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Yf,
    g2: Yf,
    glyphName: Yf,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: Fe,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: Fe,
    horizOriginX: Fe,
    horizOriginY: Fe,
    id: null,
    ideographic: Fe,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: Fe,
    k: Fe,
    k1: Fe,
    k2: Fe,
    k3: Fe,
    k4: Fe,
    kernelMatrix: ao,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: Fe,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: Fe,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: Fe,
    overlineThickness: Fe,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: Fe,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Rn,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: Fe,
    pointsAtY: Fe,
    pointsAtZ: Fe,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: ao,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: ao,
    rev: ao,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: ao,
    requiredFeatures: ao,
    requiredFonts: ao,
    requiredFormats: ao,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: Fe,
    specularExponent: Fe,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: Fe,
    strikethroughThickness: Fe,
    string: null,
    stroke: null,
    strokeDashArray: ao,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: Fe,
    strokeOpacity: Fe,
    strokeWidth: null,
    style: null,
    surfaceScale: Fe,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: ao,
    tabIndex: Fe,
    tableValues: null,
    target: null,
    targetX: Fe,
    targetY: Fe,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: ao,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: Fe,
    underlineThickness: Fe,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: Fe,
    values: null,
    vAlphabetic: Fe,
    vMathematical: Fe,
    vectorEffect: null,
    vHanging: Fe,
    vIdeographic: Fe,
    version: null,
    vertAdvY: Fe,
    vertOriginX: Fe,
    vertOriginY: Fe,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: Fe,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: DF
}), jF = Bh({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), IF = Bh({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: PF
}), zF = Bh({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), hxe = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, pxe = /[A-Z]/g, JI = /-[a-z]/g, mxe = /^data[-\w.:]+$/i;
function LF(e, t) {
  const n = D_(t);
  let r = t, i = Yi;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && mxe.test(t)) {
    if (t.charAt(4) === "-") {
      const o = t.slice(5).replace(JI, yxe);
      r = "data" + o.charAt(0).toUpperCase() + o.slice(1);
    } else {
      const o = t.slice(4);
      if (!JI.test(o)) {
        let s = o.replace(pxe, gxe);
        s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s;
      }
    }
    i = RM;
  }
  return new i(r, t);
}
function gxe(e) {
  return "-" + e.toLowerCase();
}
function yxe(e) {
  return e.charAt(1).toUpperCase();
}
const BF = RF([OF, dxe, jF, IF, zF], "html"), Qg = RF([OF, fxe, jF, IF, zF], "svg");
function $F(e) {
  return e.join(" ").trim();
}
var gf = {}, fC, QI;
function vxe() {
  if (QI) return fC;
  QI = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, i = /^:\s*/, o = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, s = /^[;\s]*/, a = /^\s+|\s+$/g, c = `
`, u = "/", f = "*", h = "", m = "comment", g = "declaration";
  function b(w, S) {
    if (typeof w != "string")
      throw new TypeError("First argument must be a string");
    if (!w) return [];
    S = S || {};
    var _ = 1, M = 1;
    function N(ie) {
      var ne = ie.match(t);
      ne && (_ += ne.length);
      var H = ie.lastIndexOf(c);
      M = ~H ? ie.length - H : M + ie.length;
    }
    function P() {
      var ie = { line: _, column: M };
      return function(ne) {
        return ne.position = new I(ie), U(), ne;
      };
    }
    function I(ie) {
      this.start = ie, this.end = { line: _, column: M }, this.source = S.source;
    }
    I.prototype.content = w;
    function O(ie) {
      var ne = new Error(
        S.source + ":" + _ + ":" + M + ": " + ie
      );
      if (ne.reason = ie, ne.filename = S.source, ne.line = _, ne.column = M, ne.source = w, !S.silent) throw ne;
    }
    function L(ie) {
      var ne = ie.exec(w);
      if (ne) {
        var H = ne[0];
        return N(H), w = w.slice(H.length), ne;
      }
    }
    function U() {
      L(n);
    }
    function B(ie) {
      var ne;
      for (ie = ie || []; ne = G(); )
        ne !== !1 && ie.push(ne);
      return ie;
    }
    function G() {
      var ie = P();
      if (!(u != w.charAt(0) || f != w.charAt(1))) {
        for (var ne = 2; h != w.charAt(ne) && (f != w.charAt(ne) || u != w.charAt(ne + 1)); )
          ++ne;
        if (ne += 2, h === w.charAt(ne - 1))
          return O("End of comment missing");
        var H = w.slice(2, ne - 2);
        return M += 2, N(H), w = w.slice(ne), M += 2, ie({
          type: m,
          comment: H
        });
      }
    }
    function Y() {
      var ie = P(), ne = L(r);
      if (ne) {
        if (G(), !L(i)) return O("property missing ':'");
        var H = L(o), Q = ie({
          type: g,
          property: x(ne[0].replace(e, h)),
          value: H ? x(H[0].replace(e, h)) : h
        });
        return L(s), Q;
      }
    }
    function he() {
      var ie = [];
      B(ie);
      for (var ne; ne = Y(); )
        ne !== !1 && (ie.push(ne), B(ie));
      return ie;
    }
    return U(), he();
  }
  function x(w) {
    return w ? w.replace(a, h) : h;
  }
  return fC = b, fC;
}
var ez;
function bxe() {
  if (ez) return gf;
  ez = 1;
  var e = gf && gf.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(gf, "__esModule", { value: !0 }), gf.default = n;
  const t = e(vxe());
  function n(r, i) {
    let o = null;
    if (!r || typeof r != "string")
      return o;
    const s = (0, t.default)(r), a = typeof i == "function";
    return s.forEach((c) => {
      if (c.type !== "declaration")
        return;
      const { property: u, value: f } = c;
      a ? i(u, f, c) : f && (o = o || {}, o[u] = f);
    }), o;
  }
  return gf;
}
var Kp = {}, tz;
function xxe() {
  if (tz) return Kp;
  tz = 1, Object.defineProperty(Kp, "__esModule", { value: !0 }), Kp.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, i = /^-(ms)-/, o = function(u) {
    return !u || n.test(u) || e.test(u);
  }, s = function(u, f) {
    return f.toUpperCase();
  }, a = function(u, f) {
    return "".concat(f, "-");
  }, c = function(u, f) {
    return f === void 0 && (f = {}), o(u) ? u : (u = u.toLowerCase(), f.reactCompat ? u = u.replace(i, a) : u = u.replace(r, a), u.replace(t, s));
  };
  return Kp.camelCase = c, Kp;
}
var Zp, nz;
function wxe() {
  if (nz) return Zp;
  nz = 1;
  var e = Zp && Zp.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  }, t = e(bxe()), n = xxe();
  function r(i, o) {
    var s = {};
    return !i || typeof i != "string" || (0, t.default)(i, function(a, c) {
      a && c && (s[(0, n.camelCase)(a, o)] = c);
    }), s;
  }
  return r.default = r, Zp = r, Zp;
}
var Sxe = wxe();
const kxe = /* @__PURE__ */ Pc(Sxe), UF = FF("end"), OM = FF("start");
function FF(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function Cxe(e) {
  const t = OM(e), n = UF(e);
  if (t && n)
    return { start: t, end: n };
}
function Nm(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? rz(e.position) : "start" in e || "end" in e ? rz(e) : "line" in e || "column" in e ? I_(e) : "";
}
function I_(e) {
  return iz(e && e.line) + ":" + iz(e && e.column);
}
function rz(e) {
  return I_(e && e.start) + "-" + I_(e && e.end);
}
function iz(e) {
  return e && typeof e == "number" ? e : 1;
}
class bi extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", o = {}, s = !1;
    if (n && ("line" in n && "column" in n ? o = { place: n } : "start" in n && "end" in n ? o = { place: n } : "type" in n ? o = {
      ancestors: [n],
      place: n.position
    } : o = { ...n }), typeof t == "string" ? i = t : !o.cause && t && (s = !0, i = t.message, o.cause = t), !o.ruleId && !o.source && typeof r == "string") {
      const c = r.indexOf(":");
      c === -1 ? o.ruleId = r : (o.source = r.slice(0, c), o.ruleId = r.slice(c + 1));
    }
    if (!o.place && o.ancestors && o.ancestors) {
      const c = o.ancestors[o.ancestors.length - 1];
      c && (o.place = c.position);
    }
    const a = o.place && "start" in o.place ? o.place.start : o.place;
    this.ancestors = o.ancestors || void 0, this.cause = o.cause || void 0, this.column = a ? a.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = a ? a.line : void 0, this.name = Nm(o.place) || "1:1", this.place = o.place || void 0, this.reason = this.message, this.ruleId = o.ruleId || void 0, this.source = o.source || void 0, this.stack = s && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
bi.prototype.file = "";
bi.prototype.name = "";
bi.prototype.reason = "";
bi.prototype.message = "";
bi.prototype.stack = "";
bi.prototype.column = void 0;
bi.prototype.line = void 0;
bi.prototype.ancestors = void 0;
bi.prototype.cause = void 0;
bi.prototype.fatal = void 0;
bi.prototype.place = void 0;
bi.prototype.ruleId = void 0;
bi.prototype.source = void 0;
const DM = {}.hasOwnProperty, Exe = /* @__PURE__ */ new Map(), _xe = /[A-Z]/g, Txe = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), Axe = /* @__PURE__ */ new Set(["td", "th"]), VF = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function HF(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = Ixe(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = jxe(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? Qg : BF,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, o = WF(i, e, void 0);
  return o && typeof o != "string" ? o : i.create(
    e,
    i.Fragment,
    { children: o || void 0 },
    void 0
  );
}
function WF(e, t, n) {
  if (t.type === "element")
    return Mxe(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return Nxe(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return Oxe(e, t, n);
  if (t.type === "mdxjsEsm")
    return Rxe(e, t);
  if (t.type === "root")
    return Dxe(e, t, n);
  if (t.type === "text")
    return Pxe(e, t);
}
function Mxe(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = Qg, e.schema = i), e.ancestors.push(t);
  const o = GF(e, t.tagName, !1), s = zxe(e, t);
  let a = jM(e, t);
  return Txe.has(t.tagName) && (a = a.filter(function(c) {
    return typeof c == "string" ? !_w(c) : !0;
  })), qF(e, s, o, t), PM(s, a), e.ancestors.pop(), e.schema = r, e.create(t, o, s, n);
}
function Nxe(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  cg(e, t.position);
}
function Rxe(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  cg(e, t.position);
}
function Oxe(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = Qg, e.schema = i), e.ancestors.push(t);
  const o = t.name === null ? e.Fragment : GF(e, t.name, !0), s = Lxe(e, t), a = jM(e, t);
  return qF(e, s, o, t), PM(s, a), e.ancestors.pop(), e.schema = r, e.create(t, o, s, n);
}
function Dxe(e, t, n) {
  const r = {};
  return PM(r, jM(e, t)), e.create(t, e.Fragment, r, n);
}
function Pxe(e, t) {
  return t.value;
}
function qF(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function PM(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function jxe(e, t, n) {
  return r;
  function r(i, o, s, a) {
    const u = Array.isArray(s.children) ? n : t;
    return a ? u(o, s, a) : u(o, s);
  }
}
function Ixe(e, t) {
  return n;
  function n(r, i, o, s) {
    const a = Array.isArray(o.children), c = OM(r);
    return t(
      i,
      o,
      s,
      a,
      {
        columnNumber: c ? c.column - 1 : void 0,
        fileName: e,
        lineNumber: c ? c.line : void 0
      },
      void 0
    );
  }
}
function zxe(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && DM.call(t.properties, i)) {
      const o = Bxe(e, i, t.properties[i]);
      if (o) {
        const [s, a] = o;
        e.tableCellAlignToStyle && s === "align" && typeof a == "string" && Axe.has(t.tagName) ? r = a : n[s] = a;
      }
    }
  if (r) {
    const o = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    o[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function Lxe(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const o = r.data.estree.body[0];
        o.type;
        const s = o.expression;
        s.type;
        const a = s.properties[0];
        a.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(a.argument)
        );
      } else
        cg(e, t.position);
    else {
      const i = r.name;
      let o;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const a = r.value.data.estree.body[0];
          a.type, o = e.evaluater.evaluateExpression(a.expression);
        } else
          cg(e, t.position);
      else
        o = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      o;
    }
  return n;
}
function jM(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : Exe;
  for (; ++r < t.children.length; ) {
    const o = t.children[r];
    let s;
    if (e.passKeys) {
      const c = o.type === "element" ? o.tagName : o.type === "mdxJsxFlowElement" || o.type === "mdxJsxTextElement" ? o.name : void 0;
      if (c) {
        const u = i.get(c) || 0;
        s = c + "-" + u, i.set(c, u + 1);
      }
    }
    const a = WF(e, o, s);
    a !== void 0 && n.push(a);
  }
  return n;
}
function Bxe(e, t, n) {
  const r = LF(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? NF(n) : $F(n)), r.property === "style") {
      let i = typeof n == "object" ? n : $xe(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = Uxe(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? hxe[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function $xe(e, t) {
  try {
    return kxe(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), i = new bi("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw i.file = e.filePath || void 0, i.url = VF + "#cannot-parse-style-attribute", i;
  }
}
function GF(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let o = -1, s;
    for (; ++o < i.length; ) {
      const a = ZI(i[o]) ? { type: "Identifier", name: i[o] } : { type: "Literal", value: i[o] };
      s = s ? {
        type: "MemberExpression",
        object: s,
        property: a,
        computed: !!(o && a.type === "Literal"),
        optional: !1
      } : a;
    }
    r = s;
  } else
    r = ZI(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {string | number} */
      r.value
    );
    return DM.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  cg(e);
}
function cg(e, t) {
  const n = new bi(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = VF + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function Uxe(e) {
  const t = {};
  let n;
  for (n in e)
    DM.call(e, n) && (t[Fxe(n)] = e[n]);
  return t;
}
function Fxe(e) {
  let t = e.replace(_xe, Vxe);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function Vxe(e) {
  return "-" + e.toLowerCase();
}
const hC = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, Hxe = {};
function IM(e, t) {
  const n = Hxe, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return KF(e, r, i);
}
function KF(e, t, n) {
  if (Wxe(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return oz(e.children, t, n);
  }
  return Array.isArray(e) ? oz(e, t, n) : "";
}
function oz(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = KF(e[i], t, n);
  return r.join("");
}
function Wxe(e) {
  return !!(e && typeof e == "object");
}
const sz = document.createElement("i");
function zM(e) {
  const t = "&" + e + ";";
  sz.innerHTML = t;
  const n = sz.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function po(e, t, n, r) {
  const i = e.length;
  let o = 0, s;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    s = Array.from(r), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); o < r.length; )
      s = r.slice(o, o + 1e4), s.unshift(t, 0), e.splice(...s), o += 1e4, t += 1e4;
}
function Io(e, t) {
  return e.length > 0 ? (po(e, e.length, 0, t), e) : t;
}
const az = {}.hasOwnProperty;
function ZF(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    qxe(t, e[n]);
  return t;
}
function qxe(e, t) {
  let n;
  for (n in t) {
    const i = (az.call(e, n) ? e[n] : void 0) || (e[n] = {}), o = t[n];
    let s;
    if (o)
      for (s in o) {
        az.call(i, s) || (i[s] = []);
        const a = o[s];
        Gxe(
          // @ts-expect-error Looks like a list.
          i[s],
          Array.isArray(a) ? a : a ? [a] : []
        );
      }
  }
}
function Gxe(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  po(e, 0, 0, r);
}
function YF(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function us(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Ai = Fc(/[A-Za-z]/), mi = Fc(/[\dA-Za-z]/), Kxe = Fc(/[#-'*+\--9=?A-Z^-~]/);
function Nb(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const z_ = Fc(/\d/), Zxe = Fc(/[\dA-Fa-f]/), Yxe = Fc(/[!-/:-@[-`{-~]/);
function yt(e) {
  return e !== null && e < -2;
}
function Tn(e) {
  return e !== null && (e < 0 || e === 32);
}
function Gt(e) {
  return e === -2 || e === -1 || e === 32;
}
const Tw = Fc(new RegExp("\\p{P}|\\p{S}", "u")), rd = Fc(/\s/);
function Fc(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function $h(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const o = e.charCodeAt(n);
    let s = "";
    if (o === 37 && mi(e.charCodeAt(n + 1)) && mi(e.charCodeAt(n + 2)))
      i = 2;
    else if (o < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (s = String.fromCharCode(o));
    else if (o > 55295 && o < 57344) {
      const a = e.charCodeAt(n + 1);
      o < 56320 && a > 56319 && a < 57344 ? (s = String.fromCharCode(o, a), i = 1) : s = "";
    } else
      s = String.fromCharCode(o);
    s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + i + 1, s = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function tn(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let o = 0;
  return s;
  function s(c) {
    return Gt(c) ? (e.enter(n), a(c)) : t(c);
  }
  function a(c) {
    return Gt(c) && o++ < i ? (e.consume(c), a) : (e.exit(n), t(c));
  }
}
const Xxe = {
  tokenize: Jxe
};
function Jxe(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return t;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), tn(e, t, "linePrefix");
  }
  function i(a) {
    return e.enter("paragraph"), o(a);
  }
  function o(a) {
    const c = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = c), n = c, s(a);
  }
  function s(a) {
    if (a === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(a);
      return;
    }
    return yt(a) ? (e.consume(a), e.exit("chunkText"), o) : (e.consume(a), s);
  }
}
const Qxe = {
  tokenize: ewe
}, lz = {
  tokenize: twe
};
function ewe(e) {
  const t = this, n = [];
  let r = 0, i, o, s;
  return a;
  function a(M) {
    if (r < n.length) {
      const N = n[r];
      return t.containerState = N[1], e.attempt(N[0].continuation, c, u)(M);
    }
    return u(M);
  }
  function c(M) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && _();
      const N = t.events.length;
      let P = N, I;
      for (; P--; )
        if (t.events[P][0] === "exit" && t.events[P][1].type === "chunkFlow") {
          I = t.events[P][1].end;
          break;
        }
      S(r);
      let O = N;
      for (; O < t.events.length; )
        t.events[O][1].end = {
          ...I
        }, O++;
      return po(t.events, P + 1, 0, t.events.slice(N)), t.events.length = O, u(M);
    }
    return a(M);
  }
  function u(M) {
    if (r === n.length) {
      if (!i)
        return m(M);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return b(M);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(lz, f, h)(M);
  }
  function f(M) {
    return i && _(), S(r), m(M);
  }
  function h(M) {
    return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, b(M);
  }
  function m(M) {
    return t.containerState = {}, e.attempt(lz, g, b)(M);
  }
  function g(M) {
    return r++, n.push([t.currentConstruct, t.containerState]), m(M);
  }
  function b(M) {
    if (M === null) {
      i && _(), S(0), e.consume(M);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: o
    }), x(M);
  }
  function x(M) {
    if (M === null) {
      w(e.exit("chunkFlow"), !0), S(0), e.consume(M);
      return;
    }
    return yt(M) ? (e.consume(M), w(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, a) : (e.consume(M), x);
  }
  function w(M, N) {
    const P = t.sliceStream(M);
    if (N && P.push(null), M.previous = o, o && (o.next = M), o = M, i.defineSkip(M.start), i.write(P), t.parser.lazy[M.start.line]) {
      let I = i.events.length;
      for (; I--; )
        if (
          // The token starts before the line ending
          i.events[I][1].start.offset < s && // and either is not ended yet
          (!i.events[I][1].end || // or ends after it.
          i.events[I][1].end.offset > s)
        )
          return;
      const O = t.events.length;
      let L = O, U, B;
      for (; L--; )
        if (t.events[L][0] === "exit" && t.events[L][1].type === "chunkFlow") {
          if (U) {
            B = t.events[L][1].end;
            break;
          }
          U = !0;
        }
      for (S(r), I = O; I < t.events.length; )
        t.events[I][1].end = {
          ...B
        }, I++;
      po(t.events, L + 1, 0, t.events.slice(O)), t.events.length = I;
    }
  }
  function S(M) {
    let N = n.length;
    for (; N-- > M; ) {
      const P = n[N];
      t.containerState = P[1], P[0].exit.call(t, e);
    }
    n.length = M;
  }
  function _() {
    i.write([null]), o = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function twe(e, t, n) {
  return tn(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function uh(e) {
  if (e === null || Tn(e) || rd(e))
    return 1;
  if (Tw(e))
    return 2;
}
function Aw(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const o = e[i].resolveAll;
    o && !r.includes(o) && (t = o(t, n), r.push(o));
  }
  return t;
}
const L_ = {
  name: "attention",
  resolveAll: nwe,
  tokenize: rwe
};
function nwe(e, t) {
  let n = -1, r, i, o, s, a, c, u, f;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          c = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const h = {
            ...e[r][1].end
          }, m = {
            ...e[n][1].start
          };
          cz(h, -c), cz(m, c), s = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: {
              ...e[r][1].end
            }
          }, a = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: m
          }, o = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, i = {
            type: c > 1 ? "strong" : "emphasis",
            start: {
              ...s.start
            },
            end: {
              ...a.end
            }
          }, e[r][1].end = {
            ...s.start
          }, e[n][1].start = {
            ...a.end
          }, u = [], e[r][1].end.offset - e[r][1].start.offset && (u = Io(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])), u = Io(u, [["enter", i, t], ["enter", s, t], ["exit", s, t], ["enter", o, t]]), u = Io(u, Aw(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), u = Io(u, [["exit", o, t], ["enter", a, t], ["exit", a, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (f = 2, u = Io(u, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : f = 0, po(e, r - 1, n - r + 3, u), n = r + u.length - f - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function rwe(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = uh(r);
  let o;
  return s;
  function s(c) {
    return o = c, e.enter("attentionSequence"), a(c);
  }
  function a(c) {
    if (c === o)
      return e.consume(c), a;
    const u = e.exit("attentionSequence"), f = uh(c), h = !f || f === 2 && i || n.includes(c), m = !i || i === 2 && f || n.includes(r);
    return u._open = !!(o === 42 ? h : h && (i || !m)), u._close = !!(o === 42 ? m : m && (f || !h)), t(c);
  }
}
function cz(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const iwe = {
  name: "autolink",
  tokenize: owe
};
function owe(e, t, n) {
  let r = 0;
  return i;
  function i(g) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), o;
  }
  function o(g) {
    return Ai(g) ? (e.consume(g), s) : g === 64 ? n(g) : u(g);
  }
  function s(g) {
    return g === 43 || g === 45 || g === 46 || mi(g) ? (r = 1, a(g)) : u(g);
  }
  function a(g) {
    return g === 58 ? (e.consume(g), r = 0, c) : (g === 43 || g === 45 || g === 46 || mi(g)) && r++ < 32 ? (e.consume(g), a) : (r = 0, u(g));
  }
  function c(g) {
    return g === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.exit("autolink"), t) : g === null || g === 32 || g === 60 || Nb(g) ? n(g) : (e.consume(g), c);
  }
  function u(g) {
    return g === 64 ? (e.consume(g), f) : Kxe(g) ? (e.consume(g), u) : n(g);
  }
  function f(g) {
    return mi(g) ? h(g) : n(g);
  }
  function h(g) {
    return g === 46 ? (e.consume(g), r = 0, f) : g === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.exit("autolink"), t) : m(g);
  }
  function m(g) {
    if ((g === 45 || mi(g)) && r++ < 63) {
      const b = g === 45 ? m : h;
      return e.consume(g), b;
    }
    return n(g);
  }
}
const ey = {
  partial: !0,
  tokenize: swe
};
function swe(e, t, n) {
  return r;
  function r(o) {
    return Gt(o) ? tn(e, i, "linePrefix")(o) : i(o);
  }
  function i(o) {
    return o === null || yt(o) ? t(o) : n(o);
  }
}
const XF = {
  continuation: {
    tokenize: lwe
  },
  exit: cwe,
  name: "blockQuote",
  tokenize: awe
};
function awe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    if (s === 62) {
      const a = r.containerState;
      return a.open || (e.enter("blockQuote", {
        _container: !0
      }), a.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), o;
    }
    return n(s);
  }
  function o(s) {
    return Gt(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s));
  }
}
function lwe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return Gt(s) ? tn(e, o, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) : o(s);
  }
  function o(s) {
    return e.attempt(XF, t, n)(s);
  }
}
function cwe(e) {
  e.exit("blockQuote");
}
const JF = {
  name: "characterEscape",
  tokenize: uwe
};
function uwe(e, t, n) {
  return r;
  function r(o) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(o), e.exit("escapeMarker"), i;
  }
  function i(o) {
    return Yxe(o) ? (e.enter("characterEscapeValue"), e.consume(o), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(o);
  }
}
const QF = {
  name: "characterReference",
  tokenize: dwe
};
function dwe(e, t, n) {
  const r = this;
  let i = 0, o, s;
  return a;
  function a(h) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), c;
  }
  function c(h) {
    return h === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(h), e.exit("characterReferenceMarkerNumeric"), u) : (e.enter("characterReferenceValue"), o = 31, s = mi, f(h));
  }
  function u(h) {
    return h === 88 || h === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(h), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), o = 6, s = Zxe, f) : (e.enter("characterReferenceValue"), o = 7, s = z_, f(h));
  }
  function f(h) {
    if (h === 59 && i) {
      const m = e.exit("characterReferenceValue");
      return s === mi && !zM(r.sliceSerialize(m)) ? n(h) : (e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return s(h) && i++ < o ? (e.consume(h), f) : n(h);
  }
}
const uz = {
  partial: !0,
  tokenize: hwe
}, dz = {
  concrete: !0,
  name: "codeFenced",
  tokenize: fwe
};
function fwe(e, t, n) {
  const r = this, i = {
    partial: !0,
    tokenize: P
  };
  let o = 0, s = 0, a;
  return c;
  function c(I) {
    return u(I);
  }
  function u(I) {
    const O = r.events[r.events.length - 1];
    return o = O && O[1].type === "linePrefix" ? O[2].sliceSerialize(O[1], !0).length : 0, a = I, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), f(I);
  }
  function f(I) {
    return I === a ? (s++, e.consume(I), f) : s < 3 ? n(I) : (e.exit("codeFencedFenceSequence"), Gt(I) ? tn(e, h, "whitespace")(I) : h(I));
  }
  function h(I) {
    return I === null || yt(I) ? (e.exit("codeFencedFence"), r.interrupt ? t(I) : e.check(uz, x, N)(I)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), m(I));
  }
  function m(I) {
    return I === null || yt(I) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), h(I)) : Gt(I) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), tn(e, g, "whitespace")(I)) : I === 96 && I === a ? n(I) : (e.consume(I), m);
  }
  function g(I) {
    return I === null || yt(I) ? h(I) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), b(I));
  }
  function b(I) {
    return I === null || yt(I) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), h(I)) : I === 96 && I === a ? n(I) : (e.consume(I), b);
  }
  function x(I) {
    return e.attempt(i, N, w)(I);
  }
  function w(I) {
    return e.enter("lineEnding"), e.consume(I), e.exit("lineEnding"), S;
  }
  function S(I) {
    return o > 0 && Gt(I) ? tn(e, _, "linePrefix", o + 1)(I) : _(I);
  }
  function _(I) {
    return I === null || yt(I) ? e.check(uz, x, N)(I) : (e.enter("codeFlowValue"), M(I));
  }
  function M(I) {
    return I === null || yt(I) ? (e.exit("codeFlowValue"), _(I)) : (e.consume(I), M);
  }
  function N(I) {
    return e.exit("codeFenced"), t(I);
  }
  function P(I, O, L) {
    let U = 0;
    return B;
    function B(ne) {
      return I.enter("lineEnding"), I.consume(ne), I.exit("lineEnding"), G;
    }
    function G(ne) {
      return I.enter("codeFencedFence"), Gt(ne) ? tn(I, Y, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(ne) : Y(ne);
    }
    function Y(ne) {
      return ne === a ? (I.enter("codeFencedFenceSequence"), he(ne)) : L(ne);
    }
    function he(ne) {
      return ne === a ? (U++, I.consume(ne), he) : U >= s ? (I.exit("codeFencedFenceSequence"), Gt(ne) ? tn(I, ie, "whitespace")(ne) : ie(ne)) : L(ne);
    }
    function ie(ne) {
      return ne === null || yt(ne) ? (I.exit("codeFencedFence"), O(ne)) : L(ne);
    }
  }
}
function hwe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o);
  }
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const pC = {
  name: "codeIndented",
  tokenize: mwe
}, pwe = {
  partial: !0,
  tokenize: gwe
};
function mwe(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return e.enter("codeIndented"), tn(e, o, "linePrefix", 5)(u);
  }
  function o(u) {
    const f = r.events[r.events.length - 1];
    return f && f[1].type === "linePrefix" && f[2].sliceSerialize(f[1], !0).length >= 4 ? s(u) : n(u);
  }
  function s(u) {
    return u === null ? c(u) : yt(u) ? e.attempt(pwe, s, c)(u) : (e.enter("codeFlowValue"), a(u));
  }
  function a(u) {
    return u === null || yt(u) ? (e.exit("codeFlowValue"), s(u)) : (e.consume(u), a);
  }
  function c(u) {
    return e.exit("codeIndented"), t(u);
  }
}
function gwe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : yt(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i) : tn(e, o, "linePrefix", 5)(s);
  }
  function o(s) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(s) : yt(s) ? i(s) : n(s);
  }
}
const ywe = {
  name: "codeText",
  previous: bwe,
  resolve: vwe,
  tokenize: xwe
};
function vwe(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function bwe(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function xwe(e, t, n) {
  let r = 0, i, o;
  return s;
  function s(h) {
    return e.enter("codeText"), e.enter("codeTextSequence"), a(h);
  }
  function a(h) {
    return h === 96 ? (e.consume(h), r++, a) : (e.exit("codeTextSequence"), c(h));
  }
  function c(h) {
    return h === null ? n(h) : h === 32 ? (e.enter("space"), e.consume(h), e.exit("space"), c) : h === 96 ? (o = e.enter("codeTextSequence"), i = 0, f(h)) : yt(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), c) : (e.enter("codeTextData"), u(h));
  }
  function u(h) {
    return h === null || h === 32 || h === 96 || yt(h) ? (e.exit("codeTextData"), c(h)) : (e.consume(h), u);
  }
  function f(h) {
    return h === 96 ? (e.consume(h), i++, f) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(h)) : (o.type = "codeTextData", u(h));
  }
}
class wwe {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const o = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && Yp(this.left, r), o.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), Yp(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), Yp(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        Yp(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        Yp(this.left, n.reverse());
      }
  }
}
function Yp(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function eV(e) {
  const t = {};
  let n = -1, r, i, o, s, a, c, u;
  const f = new wwe(e);
  for (; ++n < f.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = f.get(n), n && r[1].type === "chunkFlow" && f.get(n - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, o = 0, o < c.length && c[o][1].type === "lineEndingBlank" && (o += 2), o < c.length && c[o][1].type === "content"))
      for (; ++o < c.length && c[o][1].type !== "content"; )
        c[o][1].type === "chunkText" && (c[o][1]._isInFirstContentOfListItem = !0, o++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, Swe(f, n)), n = t[n], u = !0);
    else if (r[1]._container) {
      for (o = n, i = void 0; o--; )
        if (s = f.get(o), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank")
          s[0] === "enter" && (i && (f.get(i)[1].type = "lineEndingBlank"), s[1].type = "lineEnding", i = o);
        else if (!(s[1].type === "linePrefix" || s[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...f.get(i)[1].start
      }, a = f.slice(i, n), a.unshift(r), f.splice(i, n - i + 1, a));
    }
  }
  return po(e, 0, Number.POSITIVE_INFINITY, f.slice(0)), !u;
}
function Swe(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let i = t - 1;
  const o = [];
  let s = n._tokenizer;
  s || (s = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (s._contentTypeTextTrailing = !0));
  const a = s.events, c = [], u = {};
  let f, h, m = -1, g = n, b = 0, x = 0;
  const w = [x];
  for (; g; ) {
    for (; e.get(++i)[1] !== g; )
      ;
    o.push(i), g._tokenizer || (f = r.sliceStream(g), g.next || f.push(null), h && s.defineSkip(g.start), g._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(f), g._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), h = g, g = g.next;
  }
  for (g = n; ++m < a.length; )
    // Find a void token that includes a break.
    a[m][0] === "exit" && a[m - 1][0] === "enter" && a[m][1].type === a[m - 1][1].type && a[m][1].start.line !== a[m][1].end.line && (x = m + 1, w.push(x), g._tokenizer = void 0, g.previous = void 0, g = g.next);
  for (s.events = [], g ? (g._tokenizer = void 0, g.previous = void 0) : w.pop(), m = w.length; m--; ) {
    const S = a.slice(w[m], w[m + 1]), _ = o.pop();
    c.push([_, _ + S.length - 1]), e.splice(_, 2, S);
  }
  for (c.reverse(), m = -1; ++m < c.length; )
    u[b + c[m][0]] = b + c[m][1], b += c[m][1] - c[m][0] - 1;
  return u;
}
const kwe = {
  resolve: Ewe,
  tokenize: _we
}, Cwe = {
  partial: !0,
  tokenize: Twe
};
function Ewe(e) {
  return eV(e), e;
}
function _we(e, t) {
  let n;
  return r;
  function r(a) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(a);
  }
  function i(a) {
    return a === null ? o(a) : yt(a) ? e.check(Cwe, s, o)(a) : (e.consume(a), i);
  }
  function o(a) {
    return e.exit("chunkContent"), e.exit("content"), t(a);
  }
  function s(a) {
    return e.consume(a), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function Twe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), tn(e, o, "linePrefix");
  }
  function o(s) {
    if (s === null || yt(s))
      return n(s);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function tV(e, t, n, r, i, o, s, a, c) {
  const u = c || Number.POSITIVE_INFINITY;
  let f = 0;
  return h;
  function h(S) {
    return S === 60 ? (e.enter(r), e.enter(i), e.enter(o), e.consume(S), e.exit(o), m) : S === null || S === 32 || S === 41 || Nb(S) ? n(S) : (e.enter(r), e.enter(s), e.enter(a), e.enter("chunkString", {
      contentType: "string"
    }), x(S));
  }
  function m(S) {
    return S === 62 ? (e.enter(o), e.consume(S), e.exit(o), e.exit(i), e.exit(r), t) : (e.enter(a), e.enter("chunkString", {
      contentType: "string"
    }), g(S));
  }
  function g(S) {
    return S === 62 ? (e.exit("chunkString"), e.exit(a), m(S)) : S === null || S === 60 || yt(S) ? n(S) : (e.consume(S), S === 92 ? b : g);
  }
  function b(S) {
    return S === 60 || S === 62 || S === 92 ? (e.consume(S), g) : g(S);
  }
  function x(S) {
    return !f && (S === null || S === 41 || Tn(S)) ? (e.exit("chunkString"), e.exit(a), e.exit(s), e.exit(r), t(S)) : f < u && S === 40 ? (e.consume(S), f++, x) : S === 41 ? (e.consume(S), f--, x) : S === null || S === 32 || S === 40 || Nb(S) ? n(S) : (e.consume(S), S === 92 ? w : x);
  }
  function w(S) {
    return S === 40 || S === 41 || S === 92 ? (e.consume(S), x) : x(S);
  }
}
function nV(e, t, n, r, i, o) {
  const s = this;
  let a = 0, c;
  return u;
  function u(g) {
    return e.enter(r), e.enter(i), e.consume(g), e.exit(i), e.enter(o), f;
  }
  function f(g) {
    return a > 999 || g === null || g === 91 || g === 93 && !c || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    g === 94 && !a && "_hiddenFootnoteSupport" in s.parser.constructs ? n(g) : g === 93 ? (e.exit(o), e.enter(i), e.consume(g), e.exit(i), e.exit(r), t) : yt(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), f) : (e.enter("chunkString", {
      contentType: "string"
    }), h(g));
  }
  function h(g) {
    return g === null || g === 91 || g === 93 || yt(g) || a++ > 999 ? (e.exit("chunkString"), f(g)) : (e.consume(g), c || (c = !Gt(g)), g === 92 ? m : h);
  }
  function m(g) {
    return g === 91 || g === 92 || g === 93 ? (e.consume(g), a++, h) : h(g);
  }
}
function rV(e, t, n, r, i, o) {
  let s;
  return a;
  function a(m) {
    return m === 34 || m === 39 || m === 40 ? (e.enter(r), e.enter(i), e.consume(m), e.exit(i), s = m === 40 ? 41 : m, c) : n(m);
  }
  function c(m) {
    return m === s ? (e.enter(i), e.consume(m), e.exit(i), e.exit(r), t) : (e.enter(o), u(m));
  }
  function u(m) {
    return m === s ? (e.exit(o), c(s)) : m === null ? n(m) : yt(m) ? (e.enter("lineEnding"), e.consume(m), e.exit("lineEnding"), tn(e, u, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), f(m));
  }
  function f(m) {
    return m === s || m === null || yt(m) ? (e.exit("chunkString"), u(m)) : (e.consume(m), m === 92 ? h : f);
  }
  function h(m) {
    return m === s || m === 92 ? (e.consume(m), f) : f(m);
  }
}
function Rm(e, t) {
  let n;
  return r;
  function r(i) {
    return yt(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : Gt(i) ? tn(e, r, n ? "linePrefix" : "lineSuffix")(i) : t(i);
  }
}
const Awe = {
  name: "definition",
  tokenize: Nwe
}, Mwe = {
  partial: !0,
  tokenize: Rwe
};
function Nwe(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(g) {
    return e.enter("definition"), s(g);
  }
  function s(g) {
    return nV.call(
      r,
      e,
      a,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(g);
  }
  function a(g) {
    return i = us(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), g === 58 ? (e.enter("definitionMarker"), e.consume(g), e.exit("definitionMarker"), c) : n(g);
  }
  function c(g) {
    return Tn(g) ? Rm(e, u)(g) : u(g);
  }
  function u(g) {
    return tV(
      e,
      f,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(g);
  }
  function f(g) {
    return e.attempt(Mwe, h, h)(g);
  }
  function h(g) {
    return Gt(g) ? tn(e, m, "whitespace")(g) : m(g);
  }
  function m(g) {
    return g === null || yt(g) ? (e.exit("definition"), r.parser.defined.push(i), t(g)) : n(g);
  }
}
function Rwe(e, t, n) {
  return r;
  function r(a) {
    return Tn(a) ? Rm(e, i)(a) : n(a);
  }
  function i(a) {
    return rV(e, o, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(a);
  }
  function o(a) {
    return Gt(a) ? tn(e, s, "whitespace")(a) : s(a);
  }
  function s(a) {
    return a === null || yt(a) ? t(a) : n(a);
  }
}
const Owe = {
  name: "hardBreakEscape",
  tokenize: Dwe
};
function Dwe(e, t, n) {
  return r;
  function r(o) {
    return e.enter("hardBreakEscape"), e.consume(o), i;
  }
  function i(o) {
    return yt(o) ? (e.exit("hardBreakEscape"), t(o)) : n(o);
  }
}
const Pwe = {
  name: "headingAtx",
  resolve: jwe,
  tokenize: Iwe
};
function jwe(e, t) {
  let n = e.length - 2, r = 3, i, o;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, o = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, po(e, r, n - r + 1, [["enter", i, t], ["enter", o, t], ["exit", o, t], ["exit", i, t]])), e;
}
function Iwe(e, t, n) {
  let r = 0;
  return i;
  function i(f) {
    return e.enter("atxHeading"), o(f);
  }
  function o(f) {
    return e.enter("atxHeadingSequence"), s(f);
  }
  function s(f) {
    return f === 35 && r++ < 6 ? (e.consume(f), s) : f === null || Tn(f) ? (e.exit("atxHeadingSequence"), a(f)) : n(f);
  }
  function a(f) {
    return f === 35 ? (e.enter("atxHeadingSequence"), c(f)) : f === null || yt(f) ? (e.exit("atxHeading"), t(f)) : Gt(f) ? tn(e, a, "whitespace")(f) : (e.enter("atxHeadingText"), u(f));
  }
  function c(f) {
    return f === 35 ? (e.consume(f), c) : (e.exit("atxHeadingSequence"), a(f));
  }
  function u(f) {
    return f === null || f === 35 || Tn(f) ? (e.exit("atxHeadingText"), a(f)) : (e.consume(f), u);
  }
}
const zwe = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], fz = ["pre", "script", "style", "textarea"], Lwe = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: Uwe,
  tokenize: Fwe
}, Bwe = {
  partial: !0,
  tokenize: Hwe
}, $we = {
  partial: !0,
  tokenize: Vwe
};
function Uwe(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function Fwe(e, t, n) {
  const r = this;
  let i, o, s, a, c;
  return u;
  function u(F) {
    return f(F);
  }
  function f(F) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(F), h;
  }
  function h(F) {
    return F === 33 ? (e.consume(F), m) : F === 47 ? (e.consume(F), o = !0, x) : F === 63 ? (e.consume(F), i = 3, r.interrupt ? t : W) : Ai(F) ? (e.consume(F), s = String.fromCharCode(F), w) : n(F);
  }
  function m(F) {
    return F === 45 ? (e.consume(F), i = 2, g) : F === 91 ? (e.consume(F), i = 5, a = 0, b) : Ai(F) ? (e.consume(F), i = 4, r.interrupt ? t : W) : n(F);
  }
  function g(F) {
    return F === 45 ? (e.consume(F), r.interrupt ? t : W) : n(F);
  }
  function b(F) {
    const ee = "CDATA[";
    return F === ee.charCodeAt(a++) ? (e.consume(F), a === ee.length ? r.interrupt ? t : Y : b) : n(F);
  }
  function x(F) {
    return Ai(F) ? (e.consume(F), s = String.fromCharCode(F), w) : n(F);
  }
  function w(F) {
    if (F === null || F === 47 || F === 62 || Tn(F)) {
      const ee = F === 47, ge = s.toLowerCase();
      return !ee && !o && fz.includes(ge) ? (i = 1, r.interrupt ? t(F) : Y(F)) : zwe.includes(s.toLowerCase()) ? (i = 6, ee ? (e.consume(F), S) : r.interrupt ? t(F) : Y(F)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(F) : o ? _(F) : M(F));
    }
    return F === 45 || mi(F) ? (e.consume(F), s += String.fromCharCode(F), w) : n(F);
  }
  function S(F) {
    return F === 62 ? (e.consume(F), r.interrupt ? t : Y) : n(F);
  }
  function _(F) {
    return Gt(F) ? (e.consume(F), _) : B(F);
  }
  function M(F) {
    return F === 47 ? (e.consume(F), B) : F === 58 || F === 95 || Ai(F) ? (e.consume(F), N) : Gt(F) ? (e.consume(F), M) : B(F);
  }
  function N(F) {
    return F === 45 || F === 46 || F === 58 || F === 95 || mi(F) ? (e.consume(F), N) : P(F);
  }
  function P(F) {
    return F === 61 ? (e.consume(F), I) : Gt(F) ? (e.consume(F), P) : M(F);
  }
  function I(F) {
    return F === null || F === 60 || F === 61 || F === 62 || F === 96 ? n(F) : F === 34 || F === 39 ? (e.consume(F), c = F, O) : Gt(F) ? (e.consume(F), I) : L(F);
  }
  function O(F) {
    return F === c ? (e.consume(F), c = null, U) : F === null || yt(F) ? n(F) : (e.consume(F), O);
  }
  function L(F) {
    return F === null || F === 34 || F === 39 || F === 47 || F === 60 || F === 61 || F === 62 || F === 96 || Tn(F) ? P(F) : (e.consume(F), L);
  }
  function U(F) {
    return F === 47 || F === 62 || Gt(F) ? M(F) : n(F);
  }
  function B(F) {
    return F === 62 ? (e.consume(F), G) : n(F);
  }
  function G(F) {
    return F === null || yt(F) ? Y(F) : Gt(F) ? (e.consume(F), G) : n(F);
  }
  function Y(F) {
    return F === 45 && i === 2 ? (e.consume(F), H) : F === 60 && i === 1 ? (e.consume(F), Q) : F === 62 && i === 4 ? (e.consume(F), Z) : F === 63 && i === 3 ? (e.consume(F), W) : F === 93 && i === 5 ? (e.consume(F), Se) : yt(F) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(Bwe, pe, he)(F)) : F === null || yt(F) ? (e.exit("htmlFlowData"), he(F)) : (e.consume(F), Y);
  }
  function he(F) {
    return e.check($we, ie, pe)(F);
  }
  function ie(F) {
    return e.enter("lineEnding"), e.consume(F), e.exit("lineEnding"), ne;
  }
  function ne(F) {
    return F === null || yt(F) ? he(F) : (e.enter("htmlFlowData"), Y(F));
  }
  function H(F) {
    return F === 45 ? (e.consume(F), W) : Y(F);
  }
  function Q(F) {
    return F === 47 ? (e.consume(F), s = "", X) : Y(F);
  }
  function X(F) {
    if (F === 62) {
      const ee = s.toLowerCase();
      return fz.includes(ee) ? (e.consume(F), Z) : Y(F);
    }
    return Ai(F) && s.length < 8 ? (e.consume(F), s += String.fromCharCode(F), X) : Y(F);
  }
  function Se(F) {
    return F === 93 ? (e.consume(F), W) : Y(F);
  }
  function W(F) {
    return F === 62 ? (e.consume(F), Z) : F === 45 && i === 2 ? (e.consume(F), W) : Y(F);
  }
  function Z(F) {
    return F === null || yt(F) ? (e.exit("htmlFlowData"), pe(F)) : (e.consume(F), Z);
  }
  function pe(F) {
    return e.exit("htmlFlow"), t(F);
  }
}
function Vwe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return yt(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o) : n(s);
  }
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function Hwe(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(ey, t, n);
  }
}
const Wwe = {
  name: "htmlText",
  tokenize: qwe
};
function qwe(e, t, n) {
  const r = this;
  let i, o, s;
  return a;
  function a(W) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(W), c;
  }
  function c(W) {
    return W === 33 ? (e.consume(W), u) : W === 47 ? (e.consume(W), P) : W === 63 ? (e.consume(W), M) : Ai(W) ? (e.consume(W), L) : n(W);
  }
  function u(W) {
    return W === 45 ? (e.consume(W), f) : W === 91 ? (e.consume(W), o = 0, b) : Ai(W) ? (e.consume(W), _) : n(W);
  }
  function f(W) {
    return W === 45 ? (e.consume(W), g) : n(W);
  }
  function h(W) {
    return W === null ? n(W) : W === 45 ? (e.consume(W), m) : yt(W) ? (s = h, Q(W)) : (e.consume(W), h);
  }
  function m(W) {
    return W === 45 ? (e.consume(W), g) : h(W);
  }
  function g(W) {
    return W === 62 ? H(W) : W === 45 ? m(W) : h(W);
  }
  function b(W) {
    const Z = "CDATA[";
    return W === Z.charCodeAt(o++) ? (e.consume(W), o === Z.length ? x : b) : n(W);
  }
  function x(W) {
    return W === null ? n(W) : W === 93 ? (e.consume(W), w) : yt(W) ? (s = x, Q(W)) : (e.consume(W), x);
  }
  function w(W) {
    return W === 93 ? (e.consume(W), S) : x(W);
  }
  function S(W) {
    return W === 62 ? H(W) : W === 93 ? (e.consume(W), S) : x(W);
  }
  function _(W) {
    return W === null || W === 62 ? H(W) : yt(W) ? (s = _, Q(W)) : (e.consume(W), _);
  }
  function M(W) {
    return W === null ? n(W) : W === 63 ? (e.consume(W), N) : yt(W) ? (s = M, Q(W)) : (e.consume(W), M);
  }
  function N(W) {
    return W === 62 ? H(W) : M(W);
  }
  function P(W) {
    return Ai(W) ? (e.consume(W), I) : n(W);
  }
  function I(W) {
    return W === 45 || mi(W) ? (e.consume(W), I) : O(W);
  }
  function O(W) {
    return yt(W) ? (s = O, Q(W)) : Gt(W) ? (e.consume(W), O) : H(W);
  }
  function L(W) {
    return W === 45 || mi(W) ? (e.consume(W), L) : W === 47 || W === 62 || Tn(W) ? U(W) : n(W);
  }
  function U(W) {
    return W === 47 ? (e.consume(W), H) : W === 58 || W === 95 || Ai(W) ? (e.consume(W), B) : yt(W) ? (s = U, Q(W)) : Gt(W) ? (e.consume(W), U) : H(W);
  }
  function B(W) {
    return W === 45 || W === 46 || W === 58 || W === 95 || mi(W) ? (e.consume(W), B) : G(W);
  }
  function G(W) {
    return W === 61 ? (e.consume(W), Y) : yt(W) ? (s = G, Q(W)) : Gt(W) ? (e.consume(W), G) : U(W);
  }
  function Y(W) {
    return W === null || W === 60 || W === 61 || W === 62 || W === 96 ? n(W) : W === 34 || W === 39 ? (e.consume(W), i = W, he) : yt(W) ? (s = Y, Q(W)) : Gt(W) ? (e.consume(W), Y) : (e.consume(W), ie);
  }
  function he(W) {
    return W === i ? (e.consume(W), i = void 0, ne) : W === null ? n(W) : yt(W) ? (s = he, Q(W)) : (e.consume(W), he);
  }
  function ie(W) {
    return W === null || W === 34 || W === 39 || W === 60 || W === 61 || W === 96 ? n(W) : W === 47 || W === 62 || Tn(W) ? U(W) : (e.consume(W), ie);
  }
  function ne(W) {
    return W === 47 || W === 62 || Tn(W) ? U(W) : n(W);
  }
  function H(W) {
    return W === 62 ? (e.consume(W), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(W);
  }
  function Q(W) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(W), e.exit("lineEnding"), X;
  }
  function X(W) {
    return Gt(W) ? tn(e, Se, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(W) : Se(W);
  }
  function Se(W) {
    return e.enter("htmlTextData"), s(W);
  }
}
const LM = {
  name: "labelEnd",
  resolveAll: Ywe,
  resolveTo: Xwe,
  tokenize: Jwe
}, Gwe = {
  tokenize: Qwe
}, Kwe = {
  tokenize: e1e
}, Zwe = {
  tokenize: t1e
};
function Ywe(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += i;
    }
  }
  return e.length !== n.length && po(e, 0, e.length, n), e;
}
function Xwe(e, t) {
  let n = e.length, r = 0, i, o, s, a;
  for (; n--; )
    if (i = e[n][1], o) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (s) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (o = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (s = n);
  const c = {
    type: e[o][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[o][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, u = {
    type: "label",
    start: {
      ...e[o][1].start
    },
    end: {
      ...e[s][1].end
    }
  }, f = {
    type: "labelText",
    start: {
      ...e[o + r + 2][1].end
    },
    end: {
      ...e[s - 2][1].start
    }
  };
  return a = [["enter", c, t], ["enter", u, t]], a = Io(a, e.slice(o + 1, o + r + 3)), a = Io(a, [["enter", f, t]]), a = Io(a, Aw(t.parser.constructs.insideSpan.null, e.slice(o + r + 4, s - 3), t)), a = Io(a, [["exit", f, t], e[s - 2], e[s - 1], ["exit", u, t]]), a = Io(a, e.slice(s + 1)), a = Io(a, [["exit", c, t]]), po(e, o, e.length, a), e;
}
function Jwe(e, t, n) {
  const r = this;
  let i = r.events.length, o, s;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      o = r.events[i][1];
      break;
    }
  return a;
  function a(m) {
    return o ? o._inactive ? h(m) : (s = r.parser.defined.includes(us(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(m), e.exit("labelMarker"), e.exit("labelEnd"), c) : n(m);
  }
  function c(m) {
    return m === 40 ? e.attempt(Gwe, f, s ? f : h)(m) : m === 91 ? e.attempt(Kwe, f, s ? u : h)(m) : s ? f(m) : h(m);
  }
  function u(m) {
    return e.attempt(Zwe, f, h)(m);
  }
  function f(m) {
    return t(m);
  }
  function h(m) {
    return o._balanced = !0, n(m);
  }
}
function Qwe(e, t, n) {
  return r;
  function r(h) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), i;
  }
  function i(h) {
    return Tn(h) ? Rm(e, o)(h) : o(h);
  }
  function o(h) {
    return h === 41 ? f(h) : tV(e, s, a, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function s(h) {
    return Tn(h) ? Rm(e, c)(h) : f(h);
  }
  function a(h) {
    return n(h);
  }
  function c(h) {
    return h === 34 || h === 39 || h === 40 ? rV(e, u, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : f(h);
  }
  function u(h) {
    return Tn(h) ? Rm(e, f)(h) : f(h);
  }
  function f(h) {
    return h === 41 ? (e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), e.exit("resource"), t) : n(h);
  }
}
function e1e(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return nV.call(r, e, o, s, "reference", "referenceMarker", "referenceString")(a);
  }
  function o(a) {
    return r.parser.defined.includes(us(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(a) : n(a);
  }
  function s(a) {
    return n(a);
  }
}
function t1e(e, t, n) {
  return r;
  function r(o) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), i;
  }
  function i(o) {
    return o === 93 ? (e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), e.exit("reference"), t) : n(o);
  }
}
const n1e = {
  name: "labelStartImage",
  resolveAll: LM.resolveAll,
  tokenize: r1e
};
function r1e(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(a), e.exit("labelImageMarker"), o;
  }
  function o(a) {
    return a === 91 ? (e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelImage"), s) : n(a);
  }
  function s(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a);
  }
}
const i1e = {
  name: "labelStartLink",
  resolveAll: LM.resolveAll,
  tokenize: o1e
};
function o1e(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), o;
  }
  function o(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const mC = {
  name: "lineEnding",
  tokenize: s1e
};
function s1e(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), tn(e, t, "linePrefix");
  }
}
const N0 = {
  name: "thematicBreak",
  tokenize: a1e
};
function a1e(e, t, n) {
  let r = 0, i;
  return o;
  function o(u) {
    return e.enter("thematicBreak"), s(u);
  }
  function s(u) {
    return i = u, a(u);
  }
  function a(u) {
    return u === i ? (e.enter("thematicBreakSequence"), c(u)) : r >= 3 && (u === null || yt(u)) ? (e.exit("thematicBreak"), t(u)) : n(u);
  }
  function c(u) {
    return u === i ? (e.consume(u), r++, c) : (e.exit("thematicBreakSequence"), Gt(u) ? tn(e, a, "whitespace")(u) : a(u));
  }
}
const Hi = {
  continuation: {
    tokenize: d1e
  },
  exit: h1e,
  name: "list",
  tokenize: u1e
}, l1e = {
  partial: !0,
  tokenize: p1e
}, c1e = {
  partial: !0,
  tokenize: f1e
};
function u1e(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, s = 0;
  return a;
  function a(g) {
    const b = r.containerState.type || (g === 42 || g === 43 || g === 45 ? "listUnordered" : "listOrdered");
    if (b === "listUnordered" ? !r.containerState.marker || g === r.containerState.marker : z_(g)) {
      if (r.containerState.type || (r.containerState.type = b, e.enter(b, {
        _container: !0
      })), b === "listUnordered")
        return e.enter("listItemPrefix"), g === 42 || g === 45 ? e.check(N0, n, u)(g) : u(g);
      if (!r.interrupt || g === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), c(g);
    }
    return n(g);
  }
  function c(g) {
    return z_(g) && ++s < 10 ? (e.consume(g), c) : (!r.interrupt || s < 2) && (r.containerState.marker ? g === r.containerState.marker : g === 41 || g === 46) ? (e.exit("listItemValue"), u(g)) : n(g);
  }
  function u(g) {
    return e.enter("listItemMarker"), e.consume(g), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || g, e.check(
      ey,
      // Cant be empty when interrupting.
      r.interrupt ? n : f,
      e.attempt(l1e, m, h)
    );
  }
  function f(g) {
    return r.containerState.initialBlankLine = !0, o++, m(g);
  }
  function h(g) {
    return Gt(g) ? (e.enter("listItemPrefixWhitespace"), e.consume(g), e.exit("listItemPrefixWhitespace"), m) : n(g);
  }
  function m(g) {
    return r.containerState.size = o + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(g);
  }
}
function d1e(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(ey, i, o);
  function i(a) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, tn(e, t, "listItemIndent", r.containerState.size + 1)(a);
  }
  function o(a) {
    return r.containerState.furtherBlankLines || !Gt(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(c1e, t, s)(a));
  }
  function s(a) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, tn(e, e.attempt(Hi, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a);
  }
}
function f1e(e, t, n) {
  const r = this;
  return tn(e, i, "listItemIndent", r.containerState.size + 1);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(o) : n(o);
  }
}
function h1e(e) {
  e.exit(this.containerState.type);
}
function p1e(e, t, n) {
  const r = this;
  return tn(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return !Gt(o) && s && s[1].type === "listItemPrefixWhitespace" ? t(o) : n(o);
  }
}
const hz = {
  name: "setextUnderline",
  resolveTo: m1e,
  tokenize: g1e
};
function m1e(e, t) {
  let n = e.length, r, i, o;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !o && e[n][1].type === "definition" && (o = n);
  const s = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[i][1].type = "setextHeadingText", o ? (e.splice(i, 0, ["enter", s, t]), e.splice(o + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[o][1].end
  }) : e[r][1] = s, e.push(["exit", s, t]), e;
}
function g1e(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(u) {
    let f = r.events.length, h;
    for (; f--; )
      if (r.events[f][1].type !== "lineEnding" && r.events[f][1].type !== "linePrefix" && r.events[f][1].type !== "content") {
        h = r.events[f][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (e.enter("setextHeadingLine"), i = u, s(u)) : n(u);
  }
  function s(u) {
    return e.enter("setextHeadingLineSequence"), a(u);
  }
  function a(u) {
    return u === i ? (e.consume(u), a) : (e.exit("setextHeadingLineSequence"), Gt(u) ? tn(e, c, "lineSuffix")(u) : c(u));
  }
  function c(u) {
    return u === null || yt(u) ? (e.exit("setextHeadingLine"), t(u)) : n(u);
  }
}
const y1e = {
  tokenize: v1e
};
function v1e(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    ey,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, i, tn(e, e.attempt(this.parser.constructs.flow, i, e.attempt(kwe, i)), "linePrefix"))
  );
  return n;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(o), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const b1e = {
  resolveAll: oV()
}, x1e = iV("string"), w1e = iV("text");
function iV(e) {
  return {
    resolveAll: oV(e === "text" ? S1e : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], o = n.attempt(i, s, a);
    return s;
    function s(f) {
      return u(f) ? o(f) : a(f);
    }
    function a(f) {
      if (f === null) {
        n.consume(f);
        return;
      }
      return n.enter("data"), n.consume(f), c;
    }
    function c(f) {
      return u(f) ? (n.exit("data"), o(f)) : (n.consume(f), c);
    }
    function u(f) {
      if (f === null)
        return !0;
      const h = i[f];
      let m = -1;
      if (h)
        for (; ++m < h.length; ) {
          const g = h[m];
          if (!g.previous || g.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function oV(e) {
  return t;
  function t(n, r) {
    let i = -1, o;
    for (; ++i <= n.length; )
      o === void 0 ? n[i] && n[i][1].type === "data" && (o = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== o + 2 && (n[o][1].end = n[i - 1][1].end, n.splice(o + 2, i - o - 2), i = o + 2), o = void 0);
    return e ? e(n, r) : n;
  }
}
function S1e(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let o = i.length, s = -1, a = 0, c;
      for (; o--; ) {
        const u = i[o];
        if (typeof u == "string") {
          for (s = u.length; u.charCodeAt(s - 1) === 32; )
            a++, s--;
          if (s) break;
          s = -1;
        } else if (u === -2)
          c = !0, a++;
        else if (u !== -1) {
          o++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (a = 0), a) {
        const u = {
          type: n === e.length || c || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: o ? s : r.start._bufferIndex + s,
            _index: r.start._index + o,
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...u.start
        }, r.start.offset === r.end.offset ? Object.assign(r, u) : (e.splice(n, 0, ["enter", u, t], ["exit", u, t]), n += 2);
      }
      n++;
    }
  return e;
}
const k1e = {
  42: Hi,
  43: Hi,
  45: Hi,
  48: Hi,
  49: Hi,
  50: Hi,
  51: Hi,
  52: Hi,
  53: Hi,
  54: Hi,
  55: Hi,
  56: Hi,
  57: Hi,
  62: XF
}, C1e = {
  91: Awe
}, E1e = {
  [-2]: pC,
  [-1]: pC,
  32: pC
}, _1e = {
  35: Pwe,
  42: N0,
  45: [hz, N0],
  60: Lwe,
  61: hz,
  95: N0,
  96: dz,
  126: dz
}, T1e = {
  38: QF,
  92: JF
}, A1e = {
  [-5]: mC,
  [-4]: mC,
  [-3]: mC,
  33: n1e,
  38: QF,
  42: L_,
  60: [iwe, Wwe],
  91: i1e,
  92: [Owe, JF],
  93: LM,
  95: L_,
  96: ywe
}, M1e = {
  null: [L_, b1e]
}, N1e = {
  null: [42, 95]
}, R1e = {
  null: []
}, O1e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: N1e,
  contentInitial: C1e,
  disable: R1e,
  document: k1e,
  flow: _1e,
  flowInitial: E1e,
  insideSpan: M1e,
  string: T1e,
  text: A1e
}, Symbol.toStringTag, { value: "Module" }));
function D1e(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const i = {}, o = [];
  let s = [], a = [];
  const c = {
    attempt: O(P),
    check: O(I),
    consume: _,
    enter: M,
    exit: N,
    interrupt: O(I, {
      interrupt: !0
    })
  }, u = {
    code: null,
    containerState: {},
    defineSkip: x,
    events: [],
    now: b,
    parser: e,
    previous: null,
    sliceSerialize: m,
    sliceStream: g,
    write: h
  };
  let f = t.tokenize.call(u, c);
  return t.resolveAll && o.push(t), u;
  function h(G) {
    return s = Io(s, G), w(), s[s.length - 1] !== null ? [] : (L(t, 0), u.events = Aw(o, u.events, u), u.events);
  }
  function m(G, Y) {
    return j1e(g(G), Y);
  }
  function g(G) {
    return P1e(s, G);
  }
  function b() {
    const {
      _bufferIndex: G,
      _index: Y,
      line: he,
      column: ie,
      offset: ne
    } = r;
    return {
      _bufferIndex: G,
      _index: Y,
      line: he,
      column: ie,
      offset: ne
    };
  }
  function x(G) {
    i[G.line] = G.column, B();
  }
  function w() {
    let G;
    for (; r._index < s.length; ) {
      const Y = s[r._index];
      if (typeof Y == "string")
        for (G = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === G && r._bufferIndex < Y.length; )
          S(Y.charCodeAt(r._bufferIndex));
      else
        S(Y);
    }
  }
  function S(G) {
    f = f(G);
  }
  function _(G) {
    yt(G) ? (r.line++, r.column = 1, r.offset += G === -3 ? 2 : 1, B()) : G !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    s[r._index].length && (r._bufferIndex = -1, r._index++)), u.previous = G;
  }
  function M(G, Y) {
    const he = Y || {};
    return he.type = G, he.start = b(), u.events.push(["enter", he, u]), a.push(he), he;
  }
  function N(G) {
    const Y = a.pop();
    return Y.end = b(), u.events.push(["exit", Y, u]), Y;
  }
  function P(G, Y) {
    L(G, Y.from);
  }
  function I(G, Y) {
    Y.restore();
  }
  function O(G, Y) {
    return he;
    function he(ie, ne, H) {
      let Q, X, Se, W;
      return Array.isArray(ie) ? (
        /* c8 ignore next 1 */
        pe(ie)
      ) : "tokenize" in ie ? (
        // Looks like a construct.
        pe([
          /** @type {Construct} */
          ie
        ])
      ) : Z(ie);
      function Z(re) {
        return J;
        function J(xe) {
          const be = xe !== null && re[xe], Ae = xe !== null && re.null, tt = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(be) ? be : be ? [be] : [],
            ...Array.isArray(Ae) ? Ae : Ae ? [Ae] : []
          ];
          return pe(tt)(xe);
        }
      }
      function pe(re) {
        return Q = re, X = 0, re.length === 0 ? H : F(re[X]);
      }
      function F(re) {
        return J;
        function J(xe) {
          return W = U(), Se = re, re.partial || (u.currentConstruct = re), re.name && u.parser.constructs.disable.null.includes(re.name) ? ge() : re.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            Y ? Object.assign(Object.create(u), Y) : u,
            c,
            ee,
            ge
          )(xe);
        }
      }
      function ee(re) {
        return G(Se, W), ne;
      }
      function ge(re) {
        return W.restore(), ++X < Q.length ? F(Q[X]) : H;
      }
    }
  }
  function L(G, Y) {
    G.resolveAll && !o.includes(G) && o.push(G), G.resolve && po(u.events, Y, u.events.length - Y, G.resolve(u.events.slice(Y), u)), G.resolveTo && (u.events = G.resolveTo(u.events, u));
  }
  function U() {
    const G = b(), Y = u.previous, he = u.currentConstruct, ie = u.events.length, ne = Array.from(a);
    return {
      from: ie,
      restore: H
    };
    function H() {
      r = G, u.previous = Y, u.currentConstruct = he, u.events.length = ie, a = ne, B();
    }
  }
  function B() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function P1e(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, o = t.end._bufferIndex;
  let s;
  if (n === i)
    s = [e[n].slice(r, o)];
  else {
    if (s = e.slice(n, i), r > -1) {
      const a = s[0];
      typeof a == "string" ? s[0] = a.slice(r) : s.shift();
    }
    o > 0 && s.push(e[i].slice(0, o));
  }
  return s;
}
function j1e(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const o = e[n];
    let s;
    if (typeof o == "string")
      s = o;
    else switch (o) {
      case -5: {
        s = "\r";
        break;
      }
      case -4: {
        s = `
`;
        break;
      }
      case -3: {
        s = `\r
`;
        break;
      }
      case -2: {
        s = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && i) continue;
        s = " ";
        break;
      }
      default:
        s = String.fromCharCode(o);
    }
    i = o === -2, r.push(s);
  }
  return r.join("");
}
function I1e(e) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      ZF([O1e, ...(e || {}).extensions || []])
    ),
    content: i(Xxe),
    defined: [],
    document: i(Qxe),
    flow: i(y1e),
    lazy: {},
    string: i(x1e),
    text: i(w1e)
  };
  return r;
  function i(o) {
    return s;
    function s(a) {
      return D1e(r, o, a);
    }
  }
}
function z1e(e) {
  for (; !eV(e); )
    ;
  return e;
}
const pz = /[\0\t\n\r]/g;
function L1e() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(o, s, a) {
    const c = [];
    let u, f, h, m, g;
    for (o = t + (typeof o == "string" ? o.toString() : new TextDecoder(s || void 0).decode(o)), h = 0, t = "", n && (o.charCodeAt(0) === 65279 && h++, n = void 0); h < o.length; ) {
      if (pz.lastIndex = h, u = pz.exec(o), m = u && u.index !== void 0 ? u.index : o.length, g = o.charCodeAt(m), !u) {
        t = o.slice(h);
        break;
      }
      if (g === 10 && h === m && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), h < m && (c.push(o.slice(h, m)), e += m - h), g) {
          case 0: {
            c.push(65533), e++;
            break;
          }
          case 9: {
            for (f = Math.ceil(e / 4) * 4, c.push(-2); e++ < f; ) c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      h = m + 1;
    }
    return a && (r && c.push(-5), t && c.push(t), c.push(null)), c;
  }
}
const B1e = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function $1e(e) {
  return e.replace(B1e, U1e);
}
function U1e(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), o = i === 120 || i === 88;
    return YF(n.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return zM(n) || e;
}
const sV = {}.hasOwnProperty;
function F1e(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), V1e(n)(z1e(I1e(n).document().write(L1e()(e, t, !0))));
}
function V1e(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: o(Kt),
      autolinkProtocol: U,
      autolinkEmail: U,
      atxHeading: o(yn),
      blockQuote: o(Ae),
      characterEscape: U,
      characterReference: U,
      codeFenced: o(tt),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: o(tt, s),
      codeText: o(Ge, s),
      codeTextData: U,
      data: U,
      codeFlowValue: U,
      definition: o(nt),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: o(_t),
      hardBreakEscape: o(St),
      hardBreakTrailing: o(St),
      htmlFlow: o(Vt, s),
      htmlFlowData: U,
      htmlText: o(Vt, s),
      htmlTextData: U,
      image: o(xt),
      label: s,
      link: o(Kt),
      listItem: o(Nt),
      listItemValue: m,
      listOrdered: o(An, h),
      listUnordered: o(An),
      paragraph: o(sn),
      reference: F,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: o(yn),
      strong: o(Pn),
      thematicBreak: o(mt)
    },
    exit: {
      atxHeading: c(),
      atxHeadingSequence: P,
      autolink: c(),
      autolinkEmail: be,
      autolinkProtocol: xe,
      blockQuote: c(),
      characterEscapeValue: B,
      characterReferenceMarkerHexadecimal: ge,
      characterReferenceMarkerNumeric: ge,
      characterReferenceValue: re,
      characterReference: J,
      codeFenced: c(w),
      codeFencedFence: x,
      codeFencedFenceInfo: g,
      codeFencedFenceMeta: b,
      codeFlowValue: B,
      codeIndented: c(S),
      codeText: c(ne),
      codeTextData: B,
      data: B,
      definition: c(),
      definitionDestinationString: N,
      definitionLabelString: _,
      definitionTitleString: M,
      emphasis: c(),
      hardBreakEscape: c(Y),
      hardBreakTrailing: c(Y),
      htmlFlow: c(he),
      htmlFlowData: B,
      htmlText: c(ie),
      htmlTextData: B,
      image: c(Q),
      label: Se,
      labelText: X,
      lineEnding: G,
      link: c(H),
      listItem: c(),
      listOrdered: c(),
      listUnordered: c(),
      paragraph: c(),
      referenceString: ee,
      resourceDestinationString: W,
      resourceTitleString: Z,
      resource: pe,
      setextHeading: c(L),
      setextHeadingLineSequence: O,
      setextHeadingText: I,
      strong: c(),
      thematicBreak: c()
    }
  };
  aV(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(ke) {
    let Pe = {
      type: "root",
      children: []
    };
    const He = {
      stack: [Pe],
      tokenStack: [],
      config: t,
      enter: a,
      exit: u,
      buffer: s,
      resume: f,
      data: n
    }, et = [];
    let bt = -1;
    for (; ++bt < ke.length; )
      if (ke[bt][1].type === "listOrdered" || ke[bt][1].type === "listUnordered")
        if (ke[bt][0] === "enter")
          et.push(bt);
        else {
          const Ct = et.pop();
          bt = i(ke, Ct, bt);
        }
    for (bt = -1; ++bt < ke.length; ) {
      const Ct = t[ke[bt][0]];
      sV.call(Ct, ke[bt][1].type) && Ct[ke[bt][1].type].call(Object.assign({
        sliceSerialize: ke[bt][2].sliceSerialize
      }, He), ke[bt][1]);
    }
    if (He.tokenStack.length > 0) {
      const Ct = He.tokenStack[He.tokenStack.length - 1];
      (Ct[1] || mz).call(He, void 0, Ct[0]);
    }
    for (Pe.position = {
      start: Hl(ke.length > 0 ? ke[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Hl(ke.length > 0 ? ke[ke.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, bt = -1; ++bt < t.transforms.length; )
      Pe = t.transforms[bt](Pe) || Pe;
    return Pe;
  }
  function i(ke, Pe, He) {
    let et = Pe - 1, bt = -1, Ct = !1, fn, Lt, nn, jn;
    for (; ++et <= He; ) {
      const Ve = ke[et];
      switch (Ve[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Ve[0] === "enter" ? bt++ : bt--, jn = void 0;
          break;
        }
        case "lineEndingBlank": {
          Ve[0] === "enter" && (fn && !jn && !bt && !nn && (nn = et), jn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          jn = void 0;
      }
      if (!bt && Ve[0] === "enter" && Ve[1].type === "listItemPrefix" || bt === -1 && Ve[0] === "exit" && (Ve[1].type === "listUnordered" || Ve[1].type === "listOrdered")) {
        if (fn) {
          let Ii = et;
          for (Lt = void 0; Ii--; ) {
            const Ar = ke[Ii];
            if (Ar[1].type === "lineEnding" || Ar[1].type === "lineEndingBlank") {
              if (Ar[0] === "exit") continue;
              Lt && (ke[Lt][1].type = "lineEndingBlank", Ct = !0), Ar[1].type = "lineEnding", Lt = Ii;
            } else if (!(Ar[1].type === "linePrefix" || Ar[1].type === "blockQuotePrefix" || Ar[1].type === "blockQuotePrefixWhitespace" || Ar[1].type === "blockQuoteMarker" || Ar[1].type === "listItemIndent")) break;
          }
          nn && (!Lt || nn < Lt) && (fn._spread = !0), fn.end = Object.assign({}, Lt ? ke[Lt][1].start : Ve[1].end), ke.splice(Lt || et, 0, ["exit", fn, Ve[2]]), et++, He++;
        }
        if (Ve[1].type === "listItemPrefix") {
          const Ii = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Ve[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          fn = Ii, ke.splice(et, 0, ["enter", Ii, Ve[2]]), et++, He++, nn = void 0, jn = !0;
        }
      }
    }
    return ke[Pe][1]._spread = Ct, He;
  }
  function o(ke, Pe) {
    return He;
    function He(et) {
      a.call(this, ke(et), et), Pe && Pe.call(this, et);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function a(ke, Pe, He) {
    this.stack[this.stack.length - 1].children.push(ke), this.stack.push(ke), this.tokenStack.push([Pe, He || void 0]), ke.position = {
      start: Hl(Pe.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function c(ke) {
    return Pe;
    function Pe(He) {
      ke && ke.call(this, He), u.call(this, He);
    }
  }
  function u(ke, Pe) {
    const He = this.stack.pop(), et = this.tokenStack.pop();
    if (et)
      et[0].type !== ke.type && (Pe ? Pe.call(this, ke, et[0]) : (et[1] || mz).call(this, ke, et[0]));
    else throw new Error("Cannot close `" + ke.type + "` (" + Nm({
      start: ke.start,
      end: ke.end
    }) + "): its not open");
    He.position.end = Hl(ke.end);
  }
  function f() {
    return IM(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function m(ke) {
    if (this.data.expectingFirstListItemValue) {
      const Pe = this.stack[this.stack.length - 2];
      Pe.start = Number.parseInt(this.sliceSerialize(ke), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function g() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.lang = ke;
  }
  function b() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.meta = ke;
  }
  function x() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function w() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.value = ke.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function S() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.value = ke.replace(/(\r?\n|\r)$/g, "");
  }
  function _(ke) {
    const Pe = this.resume(), He = this.stack[this.stack.length - 1];
    He.label = Pe, He.identifier = us(this.sliceSerialize(ke)).toLowerCase();
  }
  function M() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.title = ke;
  }
  function N() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.url = ke;
  }
  function P(ke) {
    const Pe = this.stack[this.stack.length - 1];
    if (!Pe.depth) {
      const He = this.sliceSerialize(ke).length;
      Pe.depth = He;
    }
  }
  function I() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function O(ke) {
    const Pe = this.stack[this.stack.length - 1];
    Pe.depth = this.sliceSerialize(ke).codePointAt(0) === 61 ? 1 : 2;
  }
  function L() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function U(ke) {
    const He = this.stack[this.stack.length - 1].children;
    let et = He[He.length - 1];
    (!et || et.type !== "text") && (et = Mn(), et.position = {
      start: Hl(ke.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, He.push(et)), this.stack.push(et);
  }
  function B(ke) {
    const Pe = this.stack.pop();
    Pe.value += this.sliceSerialize(ke), Pe.position.end = Hl(ke.end);
  }
  function G(ke) {
    const Pe = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const He = Pe.children[Pe.children.length - 1];
      He.position.end = Hl(ke.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(Pe.type) && (U.call(this, ke), B.call(this, ke));
  }
  function Y() {
    this.data.atHardBreak = !0;
  }
  function he() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.value = ke;
  }
  function ie() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.value = ke;
  }
  function ne() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.value = ke;
  }
  function H() {
    const ke = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Pe = this.data.referenceType || "shortcut";
      ke.type += "Reference", ke.referenceType = Pe, delete ke.url, delete ke.title;
    } else
      delete ke.identifier, delete ke.label;
    this.data.referenceType = void 0;
  }
  function Q() {
    const ke = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Pe = this.data.referenceType || "shortcut";
      ke.type += "Reference", ke.referenceType = Pe, delete ke.url, delete ke.title;
    } else
      delete ke.identifier, delete ke.label;
    this.data.referenceType = void 0;
  }
  function X(ke) {
    const Pe = this.sliceSerialize(ke), He = this.stack[this.stack.length - 2];
    He.label = $1e(Pe), He.identifier = us(Pe).toLowerCase();
  }
  function Se() {
    const ke = this.stack[this.stack.length - 1], Pe = this.resume(), He = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, He.type === "link") {
      const et = ke.children;
      He.children = et;
    } else
      He.alt = Pe;
  }
  function W() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.url = ke;
  }
  function Z() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.title = ke;
  }
  function pe() {
    this.data.inReference = void 0;
  }
  function F() {
    this.data.referenceType = "collapsed";
  }
  function ee(ke) {
    const Pe = this.resume(), He = this.stack[this.stack.length - 1];
    He.label = Pe, He.identifier = us(this.sliceSerialize(ke)).toLowerCase(), this.data.referenceType = "full";
  }
  function ge(ke) {
    this.data.characterReferenceType = ke.type;
  }
  function re(ke) {
    const Pe = this.sliceSerialize(ke), He = this.data.characterReferenceType;
    let et;
    He ? (et = YF(Pe, He === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : et = zM(Pe);
    const bt = this.stack[this.stack.length - 1];
    bt.value += et;
  }
  function J(ke) {
    const Pe = this.stack.pop();
    Pe.position.end = Hl(ke.end);
  }
  function xe(ke) {
    B.call(this, ke);
    const Pe = this.stack[this.stack.length - 1];
    Pe.url = this.sliceSerialize(ke);
  }
  function be(ke) {
    B.call(this, ke);
    const Pe = this.stack[this.stack.length - 1];
    Pe.url = "mailto:" + this.sliceSerialize(ke);
  }
  function Ae() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function tt() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Ge() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function nt() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function _t() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function yn() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function St() {
    return {
      type: "break"
    };
  }
  function Vt() {
    return {
      type: "html",
      value: ""
    };
  }
  function xt() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Kt() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function An(ke) {
    return {
      type: "list",
      ordered: ke.type === "listOrdered",
      start: null,
      spread: ke._spread,
      children: []
    };
  }
  function Nt(ke) {
    return {
      type: "listItem",
      spread: ke._spread,
      checked: null,
      children: []
    };
  }
  function sn() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Pn() {
    return {
      type: "strong",
      children: []
    };
  }
  function Mn() {
    return {
      type: "text",
      value: ""
    };
  }
  function mt() {
    return {
      type: "thematicBreak"
    };
  }
}
function Hl(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function aV(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? aV(e, r) : H1e(e, r);
  }
}
function H1e(e, t) {
  let n;
  for (n in t)
    if (sV.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function mz(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Nm({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Nm({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Nm({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function W1e(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return F1e(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function q1e(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function G1e(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function K1e(e, t) {
  const n = t.value ? t.value + `
` : "", r = {}, i = t.lang ? t.lang.split(/\s+/) : [];
  i.length > 0 && (r.className = ["language-" + i[0]]);
  let o = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (o.data = { meta: t.meta }), e.patch(t, o), o = e.applyData(t, o), o = { type: "element", tagName: "pre", properties: {}, children: [o] }, e.patch(t, o), o;
}
function Z1e(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Y1e(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function X1e(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = $h(r.toLowerCase()), o = e.footnoteOrder.indexOf(r);
  let s, a = e.footnoteCounts.get(r);
  a === void 0 ? (a = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = o + 1, a += 1, e.footnoteCounts.set(r, a);
  const c = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (a > 1 ? "-" + a : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  e.patch(t, c);
  const u = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [c]
  };
  return e.patch(t, u), e.applyData(t, u);
}
function J1e(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Q1e(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function lV(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), o = i[0];
  o && o.type === "text" ? o.value = "[" + o.value : i.unshift({ type: "text", value: "[" });
  const s = i[i.length - 1];
  return s && s.type === "text" ? s.value += r : i.push({ type: "text", value: r }), i;
}
function eSe(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return lV(e, t);
  const i = { src: $h(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const o = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, o), e.applyData(t, o);
}
function tSe(e, t) {
  const n = { src: $h(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function nSe(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function rSe(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return lV(e, t);
  const i = { href: $h(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const o = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function iSe(e, t) {
  const n = { href: $h(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function oSe(e, t, n) {
  const r = e.all(t), i = n ? sSe(n) : cV(t), o = {}, s = [];
  if (typeof t.checked == "boolean") {
    const f = r[0];
    let h;
    f && f.type === "element" && f.tagName === "p" ? h = f : (h = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(h)), h.children.length > 0 && h.children.unshift({ type: "text", value: " " }), h.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), o.className = ["task-list-item"];
  }
  let a = -1;
  for (; ++a < r.length; ) {
    const f = r[a];
    (i || a !== 0 || f.type !== "element" || f.tagName !== "p") && s.push({ type: "text", value: `
` }), f.type === "element" && f.tagName === "p" && !i ? s.push(...f.children) : s.push(f);
  }
  const c = r[r.length - 1];
  c && (i || c.type !== "element" || c.tagName !== "p") && s.push({ type: "text", value: `
` });
  const u = { type: "element", tagName: "li", properties: o, children: s };
  return e.patch(t, u), e.applyData(t, u);
}
function sSe(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = cV(n[r]);
  }
  return t;
}
function cV(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function aSe(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const s = r[i];
    if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const o = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function lSe(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function cSe(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function uSe(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function dSe(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const s = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], s), i.push(s);
  }
  if (n.length > 0) {
    const s = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, a = OM(t.children[1]), c = UF(t.children[t.children.length - 1]);
    a && c && (s.position = { start: a, end: c }), i.push(s);
  }
  const o = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function fSe(e, t, n) {
  const r = n ? n.children : void 0, o = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, a = s ? s.length : t.children.length;
  let c = -1;
  const u = [];
  for (; ++c < a; ) {
    const h = t.children[c], m = {}, g = s ? s[c] : void 0;
    g && (m.align = g);
    let b = { type: "element", tagName: o, properties: m, children: [] };
    h && (b.children = e.all(h), e.patch(h, b), b = e.applyData(h, b)), u.push(b);
  }
  const f = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, f), e.applyData(t, f);
}
function hSe(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const gz = 9, yz = 32;
function pSe(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const o = [];
  for (; r; )
    o.push(
      vz(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return o.push(vz(t.slice(i), i > 0, !1)), o.join("");
}
function vz(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let o = e.codePointAt(r);
    for (; o === gz || o === yz; )
      r++, o = e.codePointAt(r);
  }
  if (n) {
    let o = e.codePointAt(i - 1);
    for (; o === gz || o === yz; )
      i--, o = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function mSe(e, t) {
  const n = { type: "text", value: pSe(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function gSe(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const ySe = {
  blockquote: q1e,
  break: G1e,
  code: K1e,
  delete: Z1e,
  emphasis: Y1e,
  footnoteReference: X1e,
  heading: J1e,
  html: Q1e,
  imageReference: eSe,
  image: tSe,
  inlineCode: nSe,
  linkReference: rSe,
  link: iSe,
  listItem: oSe,
  list: aSe,
  paragraph: lSe,
  // @ts-expect-error: root is different, but hard to type.
  root: cSe,
  strong: uSe,
  table: dSe,
  tableCell: hSe,
  tableRow: fSe,
  text: mSe,
  thematicBreak: gSe,
  toml: $v,
  yaml: $v,
  definition: $v,
  footnoteDefinition: $v
};
function $v() {
}
const uV = -1, Mw = 0, Om = 1, Rb = 2, BM = 3, $M = 4, UM = 5, FM = 6, dV = 7, fV = 8, bz = typeof self == "object" ? self : globalThis, vSe = (e, t) => {
  const n = (i, o) => (e.set(o, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [o, s] = t[i];
    switch (o) {
      case Mw:
      case uV:
        return n(s, i);
      case Om: {
        const a = n([], i);
        for (const c of s)
          a.push(r(c));
        return a;
      }
      case Rb: {
        const a = n({}, i);
        for (const [c, u] of s)
          a[r(c)] = r(u);
        return a;
      }
      case BM:
        return n(new Date(s), i);
      case $M: {
        const { source: a, flags: c } = s;
        return n(new RegExp(a, c), i);
      }
      case UM: {
        const a = n(/* @__PURE__ */ new Map(), i);
        for (const [c, u] of s)
          a.set(r(c), r(u));
        return a;
      }
      case FM: {
        const a = n(/* @__PURE__ */ new Set(), i);
        for (const c of s)
          a.add(r(c));
        return a;
      }
      case dV: {
        const { name: a, message: c } = s;
        return n(new bz[a](c), i);
      }
      case fV:
        return n(BigInt(s), i);
      case "BigInt":
        return n(Object(BigInt(s)), i);
      case "ArrayBuffer":
        return n(new Uint8Array(s).buffer, s);
      case "DataView": {
        const { buffer: a } = new Uint8Array(s);
        return n(new DataView(a), s);
      }
    }
    return n(new bz[o](s), i);
  };
  return r;
}, xz = (e) => vSe(/* @__PURE__ */ new Map(), e)(0), yf = "", { toString: bSe } = {}, { keys: xSe } = Object, Xp = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Mw, t];
  const n = bSe.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Om, yf];
    case "Object":
      return [Rb, yf];
    case "Date":
      return [BM, yf];
    case "RegExp":
      return [$M, yf];
    case "Map":
      return [UM, yf];
    case "Set":
      return [FM, yf];
    case "DataView":
      return [Om, n];
  }
  return n.includes("Array") ? [Om, n] : n.includes("Error") ? [dV, n] : [Rb, n];
}, Uv = ([e, t]) => e === Mw && (t === "function" || t === "symbol"), wSe = (e, t, n, r) => {
  const i = (s, a) => {
    const c = r.push(s) - 1;
    return n.set(a, c), c;
  }, o = (s) => {
    if (n.has(s))
      return n.get(s);
    let [a, c] = Xp(s);
    switch (a) {
      case Mw: {
        let f = s;
        switch (c) {
          case "bigint":
            a = fV, f = s.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + c);
            f = null;
            break;
          case "undefined":
            return i([uV], s);
        }
        return i([a, f], s);
      }
      case Om: {
        if (c) {
          let m = s;
          return c === "DataView" ? m = new Uint8Array(s.buffer) : c === "ArrayBuffer" && (m = new Uint8Array(s)), i([c, [...m]], s);
        }
        const f = [], h = i([a, f], s);
        for (const m of s)
          f.push(o(m));
        return h;
      }
      case Rb: {
        if (c)
          switch (c) {
            case "BigInt":
              return i([c, s.toString()], s);
            case "Boolean":
            case "Number":
            case "String":
              return i([c, s.valueOf()], s);
          }
        if (t && "toJSON" in s)
          return o(s.toJSON());
        const f = [], h = i([a, f], s);
        for (const m of xSe(s))
          (e || !Uv(Xp(s[m]))) && f.push([o(m), o(s[m])]);
        return h;
      }
      case BM:
        return i([a, s.toISOString()], s);
      case $M: {
        const { source: f, flags: h } = s;
        return i([a, { source: f, flags: h }], s);
      }
      case UM: {
        const f = [], h = i([a, f], s);
        for (const [m, g] of s)
          (e || !(Uv(Xp(m)) || Uv(Xp(g)))) && f.push([o(m), o(g)]);
        return h;
      }
      case FM: {
        const f = [], h = i([a, f], s);
        for (const m of s)
          (e || !Uv(Xp(m))) && f.push(o(m));
        return h;
      }
    }
    const { message: u } = s;
    return i([a, { name: c, message: u }], s);
  };
  return o;
}, wz = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return wSe(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Ob = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? xz(wz(e, t)) : structuredClone(e)
) : (e, t) => xz(wz(e, t));
function SSe(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function kSe(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function CSe(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || SSe, r = e.options.footnoteBackLabel || kSe, i = e.options.footnoteLabel || "Footnotes", o = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, a = [];
  let c = -1;
  for (; ++c < e.footnoteOrder.length; ) {
    const u = e.footnoteById.get(
      e.footnoteOrder[c]
    );
    if (!u)
      continue;
    const f = e.all(u), h = String(u.identifier).toUpperCase(), m = $h(h.toLowerCase());
    let g = 0;
    const b = [], x = e.footnoteCounts.get(h);
    for (; x !== void 0 && ++g <= x; ) {
      b.length > 0 && b.push({ type: "text", value: " " });
      let _ = typeof n == "string" ? n : n(c, g);
      typeof _ == "string" && (_ = { type: "text", value: _ }), b.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + m + (g > 1 ? "-" + g : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(c, g),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(_) ? _ : [_]
      });
    }
    const w = f[f.length - 1];
    if (w && w.type === "element" && w.tagName === "p") {
      const _ = w.children[w.children.length - 1];
      _ && _.type === "text" ? _.value += " " : w.children.push({ type: "text", value: " " }), w.children.push(...b);
    } else
      f.push(...b);
    const S = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + m },
      children: e.wrap(f, !0)
    };
    e.patch(u, S), a.push(S);
  }
  if (a.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: o,
          properties: {
            ...Ob(s),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(a, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Nw = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(e) {
    if (e == null)
      return ASe;
    if (typeof e == "function")
      return Rw(e);
    if (typeof e == "object")
      return Array.isArray(e) ? ESe(e) : (
        // Cast because `ReadonlyArray` goes into the above but `isArray`
        // narrows to `Array`.
        _Se(
          /** @type {Props} */
          e
        )
      );
    if (typeof e == "string")
      return TSe(e);
    throw new Error("Expected function, string, or object as test");
  })
);
function ESe(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Nw(e[n]);
  return Rw(r);
  function r(...i) {
    let o = -1;
    for (; ++o < t.length; )
      if (t[o].apply(this, i)) return !0;
    return !1;
  }
}
function _Se(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Rw(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let o;
    for (o in e)
      if (i[o] !== t[o]) return !1;
    return !0;
  }
}
function TSe(e) {
  return Rw(t);
  function t(n) {
    return n && n.type === e;
  }
}
function Rw(e) {
  return t;
  function t(n, r, i) {
    return !!(MSe(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function ASe() {
  return !0;
}
function MSe(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const hV = [], NSe = !0, B_ = !1, RSe = "skip";
function pV(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const o = Nw(i), s = r ? -1 : 1;
  a(e, void 0, [])();
  function a(c, u, f) {
    const h = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof h.type == "string") {
      const g = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(m, "name", {
        value: "node (" + (c.type + (g ? "<" + g + ">" : "")) + ")"
      });
    }
    return m;
    function m() {
      let g = hV, b, x, w;
      if ((!t || o(c, u, f[f.length - 1] || void 0)) && (g = OSe(n(c, f)), g[0] === B_))
        return g;
      if ("children" in c && c.children) {
        const S = (
          /** @type {UnistParent} */
          c
        );
        if (S.children && g[0] !== RSe)
          for (x = (r ? S.children.length : -1) + s, w = f.concat(S); x > -1 && x < S.children.length; ) {
            const _ = S.children[x];
            if (b = a(_, x, w)(), b[0] === B_)
              return b;
            x = typeof b[1] == "number" ? b[1] : x + s;
          }
      }
      return g;
    }
  }
}
function OSe(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [NSe, e] : e == null ? hV : [e];
}
function VM(e, t, n, r) {
  let i, o, s;
  typeof t == "function" && typeof n != "function" ? (o = void 0, s = t, i = n) : (o = t, s = n, i = r), pV(e, o, a, i);
  function a(c, u) {
    const f = u[u.length - 1], h = f ? f.children.indexOf(c) : void 0;
    return s(c, h, f);
  }
}
const $_ = {}.hasOwnProperty, DSe = {};
function PSe(e, t) {
  const n = t || DSe, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), s = { ...ySe, ...n.handlers }, a = {
    all: u,
    applyData: ISe,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: o,
    footnoteOrder: [],
    handlers: s,
    one: c,
    options: n,
    patch: jSe,
    wrap: LSe
  };
  return VM(e, function(f) {
    if (f.type === "definition" || f.type === "footnoteDefinition") {
      const h = f.type === "definition" ? r : i, m = String(f.identifier).toUpperCase();
      h.has(m) || h.set(m, f);
    }
  }), a;
  function c(f, h) {
    const m = f.type, g = a.handlers[m];
    if ($_.call(a.handlers, m) && g)
      return g(a, f, h);
    if (a.options.passThrough && a.options.passThrough.includes(m)) {
      if ("children" in f) {
        const { children: x, ...w } = f, S = Ob(w);
        return S.children = a.all(f), S;
      }
      return Ob(f);
    }
    return (a.options.unknownHandler || zSe)(a, f, h);
  }
  function u(f) {
    const h = [];
    if ("children" in f) {
      const m = f.children;
      let g = -1;
      for (; ++g < m.length; ) {
        const b = a.one(m[g], f);
        if (b) {
          if (g && m[g - 1].type === "break" && (!Array.isArray(b) && b.type === "text" && (b.value = Sz(b.value)), !Array.isArray(b) && b.type === "element")) {
            const x = b.children[0];
            x && x.type === "text" && (x.value = Sz(x.value));
          }
          Array.isArray(b) ? h.push(...b) : h.push(b);
        }
      }
    }
    return h;
  }
}
function jSe(e, t) {
  e.position && (t.position = Cxe(e));
}
function ISe(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, o = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const s = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: s };
      }
    n.type === "element" && o && Object.assign(n.properties, Ob(o)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function zSe(e, t) {
  const n = t.data || {}, r = "value" in t && !($_.call(n, "hProperties") || $_.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function LSe(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Sz(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function kz(e, t) {
  const n = PSe(e, t), r = n.one(e, void 0), i = CSe(n), o = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && o.children.push({ type: "text", value: `
` }, i), o;
}
function BSe(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      kz(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      kz(n, { file: r, ...e || t })
    );
  };
}
function Cz(e) {
  if (e)
    throw e;
}
var gC, Ez;
function $Se() {
  if (Ez) return gC;
  Ez = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = function(u) {
    return typeof Array.isArray == "function" ? Array.isArray(u) : t.call(u) === "[object Array]";
  }, o = function(u) {
    if (!u || t.call(u) !== "[object Object]")
      return !1;
    var f = e.call(u, "constructor"), h = u.constructor && u.constructor.prototype && e.call(u.constructor.prototype, "isPrototypeOf");
    if (u.constructor && !f && !h)
      return !1;
    var m;
    for (m in u)
      ;
    return typeof m > "u" || e.call(u, m);
  }, s = function(u, f) {
    n && f.name === "__proto__" ? n(u, f.name, {
      enumerable: !0,
      configurable: !0,
      value: f.newValue,
      writable: !0
    }) : u[f.name] = f.newValue;
  }, a = function(u, f) {
    if (f === "__proto__")
      if (e.call(u, f)) {
        if (r)
          return r(u, f).value;
      } else return;
    return u[f];
  };
  return gC = function c() {
    var u, f, h, m, g, b, x = arguments[0], w = 1, S = arguments.length, _ = !1;
    for (typeof x == "boolean" && (_ = x, x = arguments[1] || {}, w = 2), (x == null || typeof x != "object" && typeof x != "function") && (x = {}); w < S; ++w)
      if (u = arguments[w], u != null)
        for (f in u)
          h = a(x, f), m = a(u, f), x !== m && (_ && m && (o(m) || (g = i(m))) ? (g ? (g = !1, b = h && i(h) ? h : []) : b = h && o(h) ? h : {}, s(x, { name: f, newValue: c(_, b, m) })) : typeof m < "u" && s(x, { name: f, newValue: m }));
    return x;
  }, gC;
}
var USe = $Se();
const yC = /* @__PURE__ */ Pc(USe);
function U_(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function FSe() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let o = -1;
    const s = i.pop();
    if (typeof s != "function")
      throw new TypeError("Expected function as last argument, not " + s);
    a(null, ...i);
    function a(c, ...u) {
      const f = e[++o];
      let h = -1;
      if (c) {
        s(c);
        return;
      }
      for (; ++h < i.length; )
        (u[h] === null || u[h] === void 0) && (u[h] = i[h]);
      i = u, f ? VSe(f, a)(...u) : s(null, ...u);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function VSe(e, t) {
  let n;
  return r;
  function r(...s) {
    const a = e.length > s.length;
    let c;
    a && s.push(i);
    try {
      c = e.apply(this, s);
    } catch (u) {
      const f = (
        /** @type {Error} */
        u
      );
      if (a && n)
        throw f;
      return i(f);
    }
    a || (c && c.then && typeof c.then == "function" ? c.then(o, i) : c instanceof Error ? i(c) : o(c));
  }
  function i(s, ...a) {
    n || (n = !0, t(s, ...a));
  }
  function o(s) {
    i(null, s);
  }
}
const Is = { basename: HSe, dirname: WSe, extname: qSe, join: GSe, sep: "/" };
function HSe(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  ty(e);
  let n = 0, r = -1, i = e.length, o;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (o) {
          n = i + 1;
          break;
        }
      } else r < 0 && (o = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let s = -1, a = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (o) {
        n = i + 1;
        break;
      }
    } else
      s < 0 && (o = !0, s = i + 1), a > -1 && (e.codePointAt(i) === t.codePointAt(a--) ? a < 0 && (r = i) : (a = -1, r = s));
  return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r);
}
function WSe(e) {
  if (ty(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function qSe(e) {
  ty(e);
  let t = e.length, n = -1, r = 0, i = -1, o = 0, s;
  for (; t--; ) {
    const a = e.codePointAt(t);
    if (a === 47) {
      if (s) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (s = !0, n = t + 1), a === 46 ? i < 0 ? i = t : o !== 1 && (o = 1) : i > -1 && (o = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  o === 0 || // The (right-most) trimmed path component is exactly `..`.
  o === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function GSe(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    ty(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : KSe(n);
}
function KSe(e) {
  ty(e);
  const t = e.codePointAt(0) === 47;
  let n = ZSe(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function ZSe(e, t) {
  let n = "", r = 0, i = -1, o = 0, s = -1, a, c;
  for (; ++s <= e.length; ) {
    if (s < e.length)
      a = e.codePointAt(s);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(i === s - 1 || o === 1)) if (i !== s - 1 && o === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (c = n.lastIndexOf("/"), c !== n.length - 1) {
              c < 0 ? (n = "", r = 0) : (n = n.slice(0, c), r = n.length - 1 - n.lastIndexOf("/")), i = s, o = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = s, o = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(i + 1, s) : n = e.slice(i + 1, s), r = s - i - 1;
      i = s, o = 0;
    } else a === 46 && o > -1 ? o++ : o = -1;
  }
  return n;
}
function ty(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const YSe = { cwd: XSe };
function XSe() {
  return "/";
}
function F_(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function JSe(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!F_(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return QSe(e);
}
function QSe(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const vC = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class mV {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? F_(t) ? n = { path: t } : typeof t == "string" || eke(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : YSe.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < vC.length; ) {
      const o = vC[r];
      o in n && n[o] !== void 0 && n[o] !== null && (this[o] = o === "history" ? [...n[o]] : n[o]);
    }
    let i;
    for (i in n)
      vC.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Is.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    xC(t, "basename"), bC(t, "basename"), this.path = Is.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Is.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    _z(this.basename, "dirname"), this.path = Is.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Is.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (bC(t, "extname"), _z(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Is.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    F_(t) && (t = JSe(t)), xC(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Is.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    xC(t, "stem"), bC(t, "stem"), this.path = Is.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new bi(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function bC(e, t) {
  if (e && e.includes(Is.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Is.sep + "`"
    );
}
function xC(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function _z(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function eke(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const tke = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], o = function() {
      return i.apply(o, arguments);
    };
    return Object.setPrototypeOf(o, r), o;
  })
), nke = {}.hasOwnProperty;
class HM extends tke {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = FSe();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new HM()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(yC(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (kC("data", this.frozen), this.namespace[t] = n, this) : nke.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (kC("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Fv(t), r = this.parser || this.Parser;
    return wC("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), wC("process", this.parser || this.Parser), SC("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(o, s) {
      const a = Fv(t), c = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(a)
      );
      r.run(c, a, function(f, h, m) {
        if (f || !h || !m)
          return u(f);
        const g = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), b = r.stringify(g, m);
        oke(b) ? m.value = b : m.result = b, u(
          f,
          /** @type {VFileWithOutput<CompileResult>} */
          m
        );
      });
      function u(f, h) {
        f || !h ? s(f) : o ? o(h) : n(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), wC("processSync", this.parser || this.Parser), SC("processSync", this.compiler || this.Compiler), this.process(t, i), Az("processSync", "process", n), r;
    function i(o, s) {
      n = !0, Cz(o), r = s;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    Tz(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? o(void 0, r) : new Promise(o);
    function o(s, a) {
      const c = Fv(n);
      i.run(t, c, u);
      function u(f, h, m) {
        const g = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || t
        );
        f ? a(f) : s ? s(g) : r(void 0, g, m);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, o), Az("runSync", "run", r), i;
    function o(s, a) {
      Cz(s), i = a, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Fv(n), i = this.compiler || this.Compiler;
    return SC("stringify", i), Tz(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (kC("use", this.frozen), t != null) if (typeof t == "function")
      c(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? a(t) : s(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function o(u) {
      if (typeof u == "function")
        c(u, []);
      else if (typeof u == "object")
        if (Array.isArray(u)) {
          const [f, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            u
          );
          c(f, h);
        } else
          s(u);
      else
        throw new TypeError("Expected usable value, not `" + u + "`");
    }
    function s(u) {
      if (!("plugins" in u) && !("settings" in u))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      a(u.plugins), u.settings && (i.settings = yC(!0, i.settings, u.settings));
    }
    function a(u) {
      let f = -1;
      if (u != null) if (Array.isArray(u))
        for (; ++f < u.length; ) {
          const h = u[f];
          o(h);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + u + "`");
    }
    function c(u, f) {
      let h = -1, m = -1;
      for (; ++h < r.length; )
        if (r[h][0] === u) {
          m = h;
          break;
        }
      if (m === -1)
        r.push([u, ...f]);
      else if (f.length > 0) {
        let [g, ...b] = f;
        const x = r[m][1];
        U_(x) && U_(g) && (g = yC(!0, x, g)), r[m] = [u, g, ...b];
      }
    }
  }
}
const rke = new HM().freeze();
function wC(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function SC(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function kC(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Tz(e) {
  if (!U_(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function Az(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Fv(e) {
  return ike(e) ? e : new mV(e);
}
function ike(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function oke(e) {
  return typeof e == "string" || ske(e);
}
function ske(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const ake = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", Mz = [], Nz = { allowDangerousHtml: !0 }, lke = /^(https?|ircs?|mailto|xmpp)$/i, cke = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function uke(e) {
  const t = dke(e), n = fke(e);
  return hke(t.runSync(t.parse(n), n), e);
}
function dke(e) {
  const t = e.rehypePlugins || Mz, n = e.remarkPlugins || Mz, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Nz } : Nz;
  return rke().use(W1e).use(n).use(BSe, r).use(t);
}
function fke(e) {
  const t = e.children || "", n = new mV();
  return typeof t == "string" && (n.value = t), n;
}
function hke(e, t) {
  const n = t.allowedElements, r = t.allowElement, i = t.components, o = t.disallowedElements, s = t.skipHtml, a = t.unwrapDisallowed, c = t.urlTransform || pke;
  for (const f of cke)
    Object.hasOwn(t, f.from) && ("" + f.from + (f.to ? "use `" + f.to + "` instead" : "remove it") + ake + f.id, void 0);
  return VM(e, u), HF(e, {
    Fragment: v.Fragment,
    components: i,
    ignoreInvalidStyle: !0,
    jsx: v.jsx,
    jsxs: v.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function u(f, h, m) {
    if (f.type === "raw" && m && typeof h == "number")
      return s ? m.children.splice(h, 1) : m.children[h] = { type: "text", value: f.value }, h;
    if (f.type === "element") {
      let g;
      for (g in hC)
        if (Object.hasOwn(hC, g) && Object.hasOwn(f.properties, g)) {
          const b = f.properties[g], x = hC[g];
          (x === null || x.includes(f.tagName)) && (f.properties[g] = c(String(b || ""), g, f));
        }
    }
    if (f.type === "element") {
      let g = n ? !n.includes(f.tagName) : o ? o.includes(f.tagName) : !1;
      if (!g && r && typeof h == "number" && (g = !r(f, h, m)), g && m && typeof h == "number")
        return a && f.children ? m.children.splice(h, 1, ...f.children) : m.children.splice(h, 1), h;
    }
  }
}
function pke(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    i !== -1 && t > i || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    lke.test(e.slice(0, t)) ? e : ""
  );
}
function Db(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
function mke(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function gke(e, t, n) {
  const i = Nw((n || {}).ignore || []), o = yke(t);
  let s = -1;
  for (; ++s < o.length; )
    pV(e, "text", a);
  function a(u, f) {
    let h = -1, m;
    for (; ++h < f.length; ) {
      const g = f[h], b = m ? m.children : void 0;
      if (i(
        g,
        b ? b.indexOf(g) : void 0,
        m
      ))
        return;
      m = g;
    }
    if (m)
      return c(u, f);
  }
  function c(u, f) {
    const h = f[f.length - 1], m = o[s][0], g = o[s][1];
    let b = 0;
    const w = h.children.indexOf(u);
    let S = !1, _ = [];
    m.lastIndex = 0;
    let M = m.exec(u.value);
    for (; M; ) {
      const N = M.index, P = {
        index: M.index,
        input: M.input,
        stack: [...f, u]
      };
      let I = g(...M, P);
      if (typeof I == "string" && (I = I.length > 0 ? { type: "text", value: I } : void 0), I === !1 ? m.lastIndex = N + 1 : (b !== N && _.push({
        type: "text",
        value: u.value.slice(b, N)
      }), Array.isArray(I) ? _.push(...I) : I && _.push(I), b = N + M[0].length, S = !0), !m.global)
        break;
      M = m.exec(u.value);
    }
    return S ? (b < u.value.length && _.push({ type: "text", value: u.value.slice(b) }), h.children.splice(w, 1, ..._)) : _ = [u], w + _.length;
  }
}
function yke(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([vke(i[0]), bke(i[1])]);
  }
  return t;
}
function vke(e) {
  return typeof e == "string" ? new RegExp(mke(e), "g") : e;
}
function bke(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const CC = "phrasing", EC = ["autolink", "link", "image", "label"];
function xke() {
  return {
    transforms: [Tke],
    enter: {
      literalAutolink: Ske,
      literalAutolinkEmail: _C,
      literalAutolinkHttp: _C,
      literalAutolinkWww: _C
    },
    exit: {
      literalAutolink: _ke,
      literalAutolinkEmail: Eke,
      literalAutolinkHttp: kke,
      literalAutolinkWww: Cke
    }
  };
}
function wke() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: CC,
        notInConstruct: EC
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: CC,
        notInConstruct: EC
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: CC,
        notInConstruct: EC
      }
    ]
  };
}
function Ske(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function _C(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function kke(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function Cke(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function Eke(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function _ke(e) {
  this.exit(e);
}
function Tke(e) {
  gke(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Ake],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), Mke]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function Ake(e, t, n, r, i) {
  let o = "";
  if (!gV(i) || (/^w/i.test(t) && (n = t + n, t = "", o = "http://"), !Nke(n)))
    return !1;
  const s = Rke(n + r);
  if (!s[0]) return !1;
  const a = {
    type: "link",
    title: null,
    url: o + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [a, { type: "text", value: s[1] }] : a;
}
function Mke(e, t, n, r) {
  return (
    // Not an expected previous character.
    !gV(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function Nke(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function Rke(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = Db(e, "(");
  let o = Db(e, ")");
  for (; r !== -1 && i > o; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), o++;
  return [e, n];
}
function gV(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || rd(n) || Tw(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
yV.peek = $ke;
function Oke() {
  this.buffer();
}
function Dke(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function Pke() {
  this.buffer();
}
function jke(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function Ike(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = us(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function zke(e) {
  this.exit(e);
}
function Lke(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = us(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function Bke(e) {
  this.exit(e);
}
function $ke() {
  return "[";
}
function yV(e, t, n, r) {
  const i = n.createTracker(r);
  let o = i.move("[^");
  const s = n.enter("footnoteReference"), a = n.enter("reference");
  return o += i.move(
    n.safe(n.associationId(e), { after: "]", before: o })
  ), a(), s(), o += i.move("]"), o;
}
function Uke() {
  return {
    enter: {
      gfmFootnoteCallString: Oke,
      gfmFootnoteCall: Dke,
      gfmFootnoteDefinitionLabelString: Pke,
      gfmFootnoteDefinition: jke
    },
    exit: {
      gfmFootnoteCallString: Ike,
      gfmFootnoteCall: zke,
      gfmFootnoteDefinitionLabelString: Lke,
      gfmFootnoteDefinition: Bke
    }
  };
}
function Fke(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: yV },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, i, o, s) {
    const a = o.createTracker(s);
    let c = a.move("[^");
    const u = o.enter("footnoteDefinition"), f = o.enter("label");
    return c += a.move(
      o.safe(o.associationId(r), { before: c, after: "]" })
    ), f(), c += a.move("]:"), r.children && r.children.length > 0 && (a.shift(4), c += a.move(
      (t ? `
` : " ") + o.indentLines(
        o.containerFlow(r, a.current()),
        t ? vV : Vke
      )
    )), u(), c;
  }
}
function Vke(e, t, n) {
  return t === 0 ? e : vV(e, t, n);
}
function vV(e, t, n) {
  return (n ? "" : "    ") + e;
}
const Hke = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
bV.peek = Zke;
function Wke() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Gke },
    exit: { strikethrough: Kke }
  };
}
function qke() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Hke
      }
    ],
    handlers: { delete: bV }
  };
}
function Gke(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function Kke(e) {
  this.exit(e);
}
function bV(e, t, n, r) {
  const i = n.createTracker(r), o = n.enter("strikethrough");
  let s = i.move("~~");
  return s += n.containerPhrasing(e, {
    ...i.current(),
    before: s,
    after: "~"
  }), s += i.move("~~"), o(), s;
}
function Zke() {
  return "~";
}
function Yke(e) {
  return e.length;
}
function Xke(e, t) {
  const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || Yke, o = [], s = [], a = [], c = [];
  let u = 0, f = -1;
  for (; ++f < e.length; ) {
    const x = [], w = [];
    let S = -1;
    for (e[f].length > u && (u = e[f].length); ++S < e[f].length; ) {
      const _ = Jke(e[f][S]);
      if (n.alignDelimiters !== !1) {
        const M = i(_);
        w[S] = M, (c[S] === void 0 || M > c[S]) && (c[S] = M);
      }
      x.push(_);
    }
    s[f] = x, a[f] = w;
  }
  let h = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++h < u; )
      o[h] = Rz(r[h]);
  else {
    const x = Rz(r);
    for (; ++h < u; )
      o[h] = x;
  }
  h = -1;
  const m = [], g = [];
  for (; ++h < u; ) {
    const x = o[h];
    let w = "", S = "";
    x === 99 ? (w = ":", S = ":") : x === 108 ? w = ":" : x === 114 && (S = ":");
    let _ = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      c[h] - w.length - S.length
    );
    const M = w + "-".repeat(_) + S;
    n.alignDelimiters !== !1 && (_ = w.length + _ + S.length, _ > c[h] && (c[h] = _), g[h] = _), m[h] = M;
  }
  s.splice(1, 0, m), a.splice(1, 0, g), f = -1;
  const b = [];
  for (; ++f < s.length; ) {
    const x = s[f], w = a[f];
    h = -1;
    const S = [];
    for (; ++h < u; ) {
      const _ = x[h] || "";
      let M = "", N = "";
      if (n.alignDelimiters !== !1) {
        const P = c[h] - (w[h] || 0), I = o[h];
        I === 114 ? M = " ".repeat(P) : I === 99 ? P % 2 ? (M = " ".repeat(P / 2 + 0.5), N = " ".repeat(P / 2 - 0.5)) : (M = " ".repeat(P / 2), N = M) : N = " ".repeat(P);
      }
      n.delimiterStart !== !1 && !h && S.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && _ === "") && (n.delimiterStart !== !1 || h) && S.push(" "), n.alignDelimiters !== !1 && S.push(M), S.push(_), n.alignDelimiters !== !1 && S.push(N), n.padding !== !1 && S.push(" "), (n.delimiterEnd !== !1 || h !== u - 1) && S.push("|");
    }
    b.push(
      n.delimiterEnd === !1 ? S.join("").replace(/ +$/, "") : S.join("")
    );
  }
  return b.join(`
`);
}
function Jke(e) {
  return e == null ? "" : String(e);
}
function Rz(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
const Oz = {}.hasOwnProperty;
function Qke(e, t) {
  const n = t || {};
  function r(i, ...o) {
    let s = r.invalid;
    const a = r.handlers;
    if (i && Oz.call(i, e)) {
      const c = String(i[e]);
      s = Oz.call(a, c) ? a[c] : r.unknown;
    }
    if (s)
      return s.call(this, i, ...o);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
function eCe(e, t, n, r) {
  const i = n.enter("blockquote"), o = n.createTracker(r);
  o.move("> "), o.shift(2);
  const s = n.indentLines(
    n.containerFlow(e, o.current()),
    tCe
  );
  return i(), s;
}
function tCe(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function nCe(e, t) {
  return Dz(e, t.inConstruct, !0) && !Dz(e, t.notInConstruct, !1);
}
function Dz(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function Pz(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && nCe(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function rCe(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, o = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++o > s && (s = o) : o = 1, i = r + t.length, r = n.indexOf(t, i);
  return s;
}
function iCe(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function oCe(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function sCe(e, t, n, r) {
  const i = oCe(n), o = e.value || "", s = i === "`" ? "GraveAccent" : "Tilde";
  if (iCe(e, n)) {
    const h = n.enter("codeIndented"), m = n.indentLines(o, aCe);
    return h(), m;
  }
  const a = n.createTracker(r), c = i.repeat(Math.max(rCe(o, i) + 1, 3)), u = n.enter("codeFenced");
  let f = a.move(c);
  if (e.lang) {
    const h = n.enter(`codeFencedLang${s}`);
    f += a.move(
      n.safe(e.lang, {
        before: f,
        after: " ",
        encode: ["`"],
        ...a.current()
      })
    ), h();
  }
  if (e.lang && e.meta) {
    const h = n.enter(`codeFencedMeta${s}`);
    f += a.move(" "), f += a.move(
      n.safe(e.meta, {
        before: f,
        after: `
`,
        encode: ["`"],
        ...a.current()
      })
    ), h();
  }
  return f += a.move(`
`), o && (f += a.move(o + `
`)), f += a.move(c), u(), f;
}
function aCe(e, t, n) {
  return (n ? "" : "    ") + e;
}
function WM(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function lCe(e, t, n, r) {
  const i = WM(n), o = i === '"' ? "Quote" : "Apostrophe", s = n.enter("definition");
  let a = n.enter("label");
  const c = n.createTracker(r);
  let u = c.move("[");
  return u += c.move(
    n.safe(n.associationId(e), {
      before: u,
      after: "]",
      ...c.current()
    })
  ), u += c.move("]: "), a(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    n.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (a = n.enter("destinationRaw"), u += c.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), a(), e.title && (a = n.enter(`title${o}`), u += c.move(" " + i), u += c.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), a()), s(), u;
}
function cCe(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function ug(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Pb(e, t, n) {
  const r = uh(e), i = uh(t);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
xV.peek = uCe;
function xV(e, t, n, r) {
  const i = cCe(n), o = n.enter("emphasis"), s = n.createTracker(r), a = s.move(i);
  let c = s.move(
    n.containerPhrasing(e, {
      after: i,
      before: a,
      ...s.current()
    })
  );
  const u = c.charCodeAt(0), f = Pb(
    r.before.charCodeAt(r.before.length - 1),
    u,
    i
  );
  f.inside && (c = ug(u) + c.slice(1));
  const h = c.charCodeAt(c.length - 1), m = Pb(r.after.charCodeAt(0), h, i);
  m.inside && (c = c.slice(0, -1) + ug(h));
  const g = s.move(i);
  return o(), n.attentionEncodeSurroundingInfo = {
    after: m.outside,
    before: f.outside
  }, a + c + g;
}
function uCe(e, t, n) {
  return n.options.emphasis || "*";
}
function dCe(e, t) {
  let n = !1;
  return VM(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, B_;
  }), !!((!e.depth || e.depth < 3) && IM(e) && (t.options.setext || n));
}
function fCe(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), o = n.createTracker(r);
  if (dCe(e, n)) {
    const f = n.enter("headingSetext"), h = n.enter("phrasing"), m = n.containerPhrasing(e, {
      ...o.current(),
      before: `
`,
      after: `
`
    });
    return h(), f(), m + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size
      m.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(m.lastIndexOf("\r"), m.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(i), a = n.enter("headingAtx"), c = n.enter("phrasing");
  o.move(s + " ");
  let u = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...o.current()
  });
  return /^[\t ]/.test(u) && (u = ug(u.charCodeAt(0)) + u.slice(1)), u = u ? s + " " + u : s, n.options.closeAtx && (u += " " + s), c(), a(), u;
}
wV.peek = hCe;
function wV(e) {
  return e.value || "";
}
function hCe() {
  return "<";
}
SV.peek = pCe;
function SV(e, t, n, r) {
  const i = WM(n), o = i === '"' ? "Quote" : "Apostrophe", s = n.enter("image");
  let a = n.enter("label");
  const c = n.createTracker(r);
  let u = c.move("![");
  return u += c.move(
    n.safe(e.alt, { before: u, after: "]", ...c.current() })
  ), u += c.move("]("), a(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    n.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (a = n.enter("destinationRaw"), u += c.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), a(), e.title && (a = n.enter(`title${o}`), u += c.move(" " + i), u += c.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), a()), u += c.move(")"), s(), u;
}
function pCe() {
  return "!";
}
kV.peek = mCe;
function kV(e, t, n, r) {
  const i = e.referenceType, o = n.enter("imageReference");
  let s = n.enter("label");
  const a = n.createTracker(r);
  let c = a.move("![");
  const u = n.safe(e.alt, {
    before: c,
    after: "]",
    ...a.current()
  });
  c += a.move(u + "]["), s();
  const f = n.stack;
  n.stack = [], s = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...a.current()
  });
  return s(), n.stack = f, o(), i === "full" || !u || u !== h ? c += a.move(h + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += a.move("]"), c;
}
function mCe() {
  return "!";
}
CV.peek = gCe;
function CV(e, t, n) {
  let r = e.value || "", i = "`", o = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++o < n.unsafe.length; ) {
    const s = n.unsafe[o], a = n.compilePattern(s);
    let c;
    if (s.atBreak)
      for (; c = a.exec(r); ) {
        let u = c.index;
        r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--, r = r.slice(0, u) + " " + r.slice(c.index + 1);
      }
  }
  return i + r + i;
}
function gCe() {
  return "`";
}
function EV(e, t) {
  const n = IM(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
_V.peek = yCe;
function _V(e, t, n, r) {
  const i = WM(n), o = i === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r);
  let a, c;
  if (EV(e, n)) {
    const f = n.stack;
    n.stack = [], a = n.enter("autolink");
    let h = s.move("<");
    return h += s.move(
      n.containerPhrasing(e, {
        before: h,
        after: ">",
        ...s.current()
      })
    ), h += s.move(">"), a(), n.stack = f, h;
  }
  a = n.enter("link"), c = n.enter("label");
  let u = s.move("[");
  return u += s.move(
    n.containerPhrasing(e, {
      before: u,
      after: "](",
      ...s.current()
    })
  ), u += s.move("]("), c(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), u += s.move("<"), u += s.move(
    n.safe(e.url, { before: u, after: ">", ...s.current() })
  ), u += s.move(">")) : (c = n.enter("destinationRaw"), u += s.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), c(), e.title && (c = n.enter(`title${o}`), u += s.move(" " + i), u += s.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...s.current()
    })
  ), u += s.move(i), c()), u += s.move(")"), a(), u;
}
function yCe(e, t, n) {
  return EV(e, n) ? "<" : "[";
}
TV.peek = vCe;
function TV(e, t, n, r) {
  const i = e.referenceType, o = n.enter("linkReference");
  let s = n.enter("label");
  const a = n.createTracker(r);
  let c = a.move("[");
  const u = n.containerPhrasing(e, {
    before: c,
    after: "]",
    ...a.current()
  });
  c += a.move(u + "]["), s();
  const f = n.stack;
  n.stack = [], s = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...a.current()
  });
  return s(), n.stack = f, o(), i === "full" || !u || u !== h ? c += a.move(h + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += a.move("]"), c;
}
function vCe() {
  return "[";
}
function qM(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function bCe(e) {
  const t = qM(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function xCe(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function AV(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function wCe(e, t, n, r) {
  const i = n.enter("list"), o = n.bulletCurrent;
  let s = e.ordered ? xCe(n) : qM(n);
  const a = e.ordered ? s === "." ? ")" : "." : bCe(n);
  let c = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const f = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      f && (!f.children || !f.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (c = !0), AV(n) === s && f
    ) {
      let h = -1;
      for (; ++h < e.children.length; ) {
        const m = e.children[h];
        if (m && m.type === "listItem" && m.children && m.children[0] && m.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (s = a), n.bulletCurrent = s;
  const u = n.containerFlow(e, r);
  return n.bulletLastUsed = s, n.bulletCurrent = o, i(), u;
}
function SCe(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function kCe(e, t, n, r) {
  const i = SCe(n);
  let o = n.bulletCurrent || qM(n);
  t && t.type === "list" && t.ordered && (o = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + o);
  let s = o.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const a = n.createTracker(r);
  a.move(o + " ".repeat(s - o.length)), a.shift(s);
  const c = n.enter("listItem"), u = n.indentLines(
    n.containerFlow(e, a.current()),
    f
  );
  return c(), u;
  function f(h, m, g) {
    return m ? (g ? "" : " ".repeat(s)) + h : (g ? o : o + " ".repeat(s - o.length)) + h;
  }
}
function CCe(e, t, n, r) {
  const i = n.enter("paragraph"), o = n.enter("phrasing"), s = n.containerPhrasing(e, r);
  return o(), i(), s;
}
const ECe = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Nw([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function _Ce(e, t, n, r) {
  return (e.children.some(function(s) {
    return ECe(s);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function TCe(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
MV.peek = ACe;
function MV(e, t, n, r) {
  const i = TCe(n), o = n.enter("strong"), s = n.createTracker(r), a = s.move(i + i);
  let c = s.move(
    n.containerPhrasing(e, {
      after: i,
      before: a,
      ...s.current()
    })
  );
  const u = c.charCodeAt(0), f = Pb(
    r.before.charCodeAt(r.before.length - 1),
    u,
    i
  );
  f.inside && (c = ug(u) + c.slice(1));
  const h = c.charCodeAt(c.length - 1), m = Pb(r.after.charCodeAt(0), h, i);
  m.inside && (c = c.slice(0, -1) + ug(h));
  const g = s.move(i + i);
  return o(), n.attentionEncodeSurroundingInfo = {
    after: m.outside,
    before: f.outside
  }, a + c + g;
}
function ACe(e, t, n) {
  return n.options.strong || "*";
}
function MCe(e, t, n, r) {
  return n.safe(e.value, r);
}
function NCe(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function RCe(e, t, n) {
  const r = (AV(n) + (n.options.ruleSpaces ? " " : "")).repeat(NCe(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const NV = {
  blockquote: eCe,
  break: Pz,
  code: sCe,
  definition: lCe,
  emphasis: xV,
  hardBreak: Pz,
  heading: fCe,
  html: wV,
  image: SV,
  imageReference: kV,
  inlineCode: CV,
  link: _V,
  linkReference: TV,
  list: wCe,
  listItem: kCe,
  paragraph: CCe,
  root: _Ce,
  strong: MV,
  text: MCe,
  thematicBreak: RCe
};
function OCe() {
  return {
    enter: {
      table: DCe,
      tableData: jz,
      tableHeader: jz,
      tableRow: jCe
    },
    exit: {
      codeText: ICe,
      table: PCe,
      tableData: TC,
      tableHeader: TC,
      tableRow: TC
    }
  };
}
function DCe(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function PCe(e) {
  this.exit(e), this.data.inTable = void 0;
}
function jCe(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function TC(e) {
  this.exit(e);
}
function jz(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function ICe(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, zCe));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function zCe(e, t) {
  return t === "|" ? t : e;
}
function LCe(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, o = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: m,
      table: s,
      tableCell: c,
      tableRow: a
    }
  };
  function s(g, b, x, w) {
    return u(f(g, x, w), g.align);
  }
  function a(g, b, x, w) {
    const S = h(g, x, w), _ = u([S]);
    return _.slice(0, _.indexOf(`
`));
  }
  function c(g, b, x, w) {
    const S = x.enter("tableCell"), _ = x.enter("phrasing"), M = x.containerPhrasing(g, {
      ...w,
      before: o,
      after: o
    });
    return _(), S(), M;
  }
  function u(g, b) {
    return Xke(g, {
      align: b,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function f(g, b, x) {
    const w = g.children;
    let S = -1;
    const _ = [], M = b.enter("table");
    for (; ++S < w.length; )
      _[S] = h(w[S], b, x);
    return M(), _;
  }
  function h(g, b, x) {
    const w = g.children;
    let S = -1;
    const _ = [], M = b.enter("tableRow");
    for (; ++S < w.length; )
      _[S] = c(w[S], g, b, x);
    return M(), _;
  }
  function m(g, b, x) {
    let w = NV.inlineCode(g, b, x);
    return x.stack.includes("tableCell") && (w = w.replace(/\|/g, "\\$&")), w;
  }
}
function BCe() {
  return {
    exit: {
      taskListCheckValueChecked: Iz,
      taskListCheckValueUnchecked: Iz,
      paragraph: UCe
    }
  };
}
function $Ce() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: FCe }
  };
}
function Iz(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function UCe(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let o = -1, s;
      for (; ++o < i.length; ) {
        const a = i[o];
        if (a.type === "paragraph") {
          s = a;
          break;
        }
      }
      s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function FCe(e, t, n, r) {
  const i = e.children[0], o = typeof e.checked == "boolean" && i && i.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", a = n.createTracker(r);
  o && a.move(s);
  let c = NV.listItem(e, t, n, {
    ...r,
    ...a.current()
  });
  return o && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), c;
  function u(f) {
    return f + s;
  }
}
function VCe() {
  return [
    xke(),
    Uke(),
    Wke(),
    OCe(),
    BCe()
  ];
}
function HCe(e) {
  return {
    extensions: [
      wke(),
      Fke(e),
      qke(),
      LCe(e),
      $Ce()
    ]
  };
}
const WCe = {
  tokenize: XCe,
  partial: !0
}, RV = {
  tokenize: JCe,
  partial: !0
}, OV = {
  tokenize: QCe,
  partial: !0
}, DV = {
  tokenize: eEe,
  partial: !0
}, qCe = {
  tokenize: tEe,
  partial: !0
}, PV = {
  name: "wwwAutolink",
  tokenize: ZCe,
  previous: IV
}, jV = {
  name: "protocolAutolink",
  tokenize: YCe,
  previous: zV
}, ol = {
  name: "emailAutolink",
  tokenize: KCe,
  previous: LV
}, ia = {};
function GCe() {
  return {
    text: ia
  };
}
let Eu = 48;
for (; Eu < 123; )
  ia[Eu] = ol, Eu++, Eu === 58 ? Eu = 65 : Eu === 91 && (Eu = 97);
ia[43] = ol;
ia[45] = ol;
ia[46] = ol;
ia[95] = ol;
ia[72] = [ol, jV];
ia[104] = [ol, jV];
ia[87] = [ol, PV];
ia[119] = [ol, PV];
function KCe(e, t, n) {
  const r = this;
  let i, o;
  return s;
  function s(h) {
    return !V_(h) || !LV.call(r, r.previous) || GM(r.events) ? n(h) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), a(h));
  }
  function a(h) {
    return V_(h) ? (e.consume(h), a) : h === 64 ? (e.consume(h), c) : n(h);
  }
  function c(h) {
    return h === 46 ? e.check(qCe, f, u)(h) : h === 45 || h === 95 || mi(h) ? (o = !0, e.consume(h), c) : f(h);
  }
  function u(h) {
    return e.consume(h), i = !0, c;
  }
  function f(h) {
    return o && i && Ai(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(h)) : n(h);
  }
}
function ZCe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s !== 87 && s !== 119 || !IV.call(r, r.previous) || GM(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(WCe, e.attempt(RV, e.attempt(OV, o), n), n)(s));
  }
  function o(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function YCe(e, t, n) {
  const r = this;
  let i = "", o = !1;
  return s;
  function s(h) {
    return (h === 72 || h === 104) && zV.call(r, r.previous) && !GM(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(h), e.consume(h), a) : n(h);
  }
  function a(h) {
    if (Ai(h) && i.length < 5)
      return i += String.fromCodePoint(h), e.consume(h), a;
    if (h === 58) {
      const m = i.toLowerCase();
      if (m === "http" || m === "https")
        return e.consume(h), c;
    }
    return n(h);
  }
  function c(h) {
    return h === 47 ? (e.consume(h), o ? u : (o = !0, c)) : n(h);
  }
  function u(h) {
    return h === null || Nb(h) || Tn(h) || rd(h) || Tw(h) ? n(h) : e.attempt(RV, e.attempt(OV, f), n)(h);
  }
  function f(h) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(h);
  }
}
function XCe(e, t, n) {
  let r = 0;
  return i;
  function i(s) {
    return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), i) : s === 46 && r === 3 ? (e.consume(s), o) : n(s);
  }
  function o(s) {
    return s === null ? n(s) : t(s);
  }
}
function JCe(e, t, n) {
  let r, i, o;
  return s;
  function s(u) {
    return u === 46 || u === 95 ? e.check(DV, c, a)(u) : u === null || Tn(u) || rd(u) || u !== 45 && Tw(u) ? c(u) : (o = !0, e.consume(u), s);
  }
  function a(u) {
    return u === 95 ? r = !0 : (i = r, r = void 0), e.consume(u), s;
  }
  function c(u) {
    return i || r || !o ? n(u) : t(u);
  }
}
function QCe(e, t) {
  let n = 0, r = 0;
  return i;
  function i(s) {
    return s === 40 ? (n++, e.consume(s), i) : s === 41 && r < n ? o(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(DV, t, o)(s) : s === null || Tn(s) || rd(s) ? t(s) : (e.consume(s), i);
  }
  function o(s) {
    return s === 41 && r++, e.consume(s), i;
  }
}
function eEe(e, t, n) {
  return r;
  function r(a) {
    return a === 33 || a === 34 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 63 || a === 95 || a === 126 ? (e.consume(a), r) : a === 38 ? (e.consume(a), o) : a === 93 ? (e.consume(a), i) : (
      // `<` is an end.
      a === 60 || // So is whitespace.
      a === null || Tn(a) || rd(a) ? t(a) : n(a)
    );
  }
  function i(a) {
    return a === null || a === 40 || a === 91 || Tn(a) || rd(a) ? t(a) : r(a);
  }
  function o(a) {
    return Ai(a) ? s(a) : n(a);
  }
  function s(a) {
    return a === 59 ? (e.consume(a), r) : Ai(a) ? (e.consume(a), s) : n(a);
  }
}
function tEe(e, t, n) {
  return r;
  function r(o) {
    return e.consume(o), i;
  }
  function i(o) {
    return mi(o) ? n(o) : t(o);
  }
}
function IV(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Tn(e);
}
function zV(e) {
  return !Ai(e);
}
function LV(e) {
  return !(e === 47 || V_(e));
}
function V_(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || mi(e);
}
function GM(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const nEe = {
  tokenize: uEe,
  partial: !0
};
function rEe() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: aEe,
        continuation: {
          tokenize: lEe
        },
        exit: cEe
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: sEe
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: iEe,
        resolveTo: oEe
      }
    }
  };
}
function iEe(e, t, n) {
  const r = this;
  let i = r.events.length;
  const o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s;
  for (; i--; ) {
    const c = r.events[i][1];
    if (c.type === "labelImage") {
      s = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return a;
  function a(c) {
    if (!s || !s._balanced)
      return n(c);
    const u = us(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }));
    return u.codePointAt(0) !== 94 || !o.includes(u.slice(1)) ? n(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function oEe(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const o = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, o.start),
    end: Object.assign({}, o.end)
  }, a = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", o, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", o, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...a), e;
}
function sEe(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o = 0, s;
  return a;
  function a(h) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(h) {
    return h !== 94 ? n(h) : (e.enter("gfmFootnoteCallMarker"), e.consume(h), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
  }
  function u(h) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      h === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || Tn(h)
    )
      return n(h);
    if (h === 93) {
      e.exit("chunkString");
      const m = e.exit("gfmFootnoteCallString");
      return i.includes(us(r.sliceSerialize(m))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(h);
    }
    return Tn(h) || (s = !0), o++, e.consume(h), h === 92 ? f : u;
  }
  function f(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), o++, u) : u(h);
  }
}
function aEe(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o, s = 0, a;
  return c;
  function c(b) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
  }
  function u(b) {
    return b === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", f) : n(b);
  }
  function f(b) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      b === 93 && !a || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      b === null || b === 91 || Tn(b)
    )
      return n(b);
    if (b === 93) {
      e.exit("chunkString");
      const x = e.exit("gfmFootnoteDefinitionLabelString");
      return o = us(r.sliceSerialize(x)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), m;
    }
    return Tn(b) || (a = !0), s++, e.consume(b), b === 92 ? h : f;
  }
  function h(b) {
    return b === 91 || b === 92 || b === 93 ? (e.consume(b), s++, f) : f(b);
  }
  function m(b) {
    return b === 58 ? (e.enter("definitionMarker"), e.consume(b), e.exit("definitionMarker"), i.includes(o) || i.push(o), tn(e, g, "gfmFootnoteDefinitionWhitespace")) : n(b);
  }
  function g(b) {
    return t(b);
  }
}
function lEe(e, t, n) {
  return e.check(ey, t, e.attempt(nEe, t, n));
}
function cEe(e) {
  e.exit("gfmFootnoteDefinition");
}
function uEe(e, t, n) {
  const r = this;
  return tn(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(o) : n(o);
  }
}
function dEe(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: o,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(s, a) {
    let c = -1;
    for (; ++c < s.length; )
      if (s[c][0] === "enter" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._close) {
        let u = c;
        for (; u--; )
          if (s[u][0] === "exit" && s[u][1].type === "strikethroughSequenceTemporary" && s[u][1]._open && // If the sizes are the same:
          s[c][1].end.offset - s[c][1].start.offset === s[u][1].end.offset - s[u][1].start.offset) {
            s[c][1].type = "strikethroughSequence", s[u][1].type = "strikethroughSequence";
            const f = {
              type: "strikethrough",
              start: Object.assign({}, s[u][1].start),
              end: Object.assign({}, s[c][1].end)
            }, h = {
              type: "strikethroughText",
              start: Object.assign({}, s[u][1].end),
              end: Object.assign({}, s[c][1].start)
            }, m = [["enter", f, a], ["enter", s[u][1], a], ["exit", s[u][1], a], ["enter", h, a]], g = a.parser.constructs.insideSpan.null;
            g && po(m, m.length, 0, Aw(g, s.slice(u + 1, c), a)), po(m, m.length, 0, [["exit", h, a], ["enter", s[c][1], a], ["exit", s[c][1], a], ["exit", f, a]]), po(s, u - 1, c - u + 3, m), c = u + m.length - 2;
            break;
          }
      }
    for (c = -1; ++c < s.length; )
      s[c][1].type === "strikethroughSequenceTemporary" && (s[c][1].type = "data");
    return s;
  }
  function o(s, a, c) {
    const u = this.previous, f = this.events;
    let h = 0;
    return m;
    function m(b) {
      return u === 126 && f[f.length - 1][1].type !== "characterEscape" ? c(b) : (s.enter("strikethroughSequenceTemporary"), g(b));
    }
    function g(b) {
      const x = uh(u);
      if (b === 126)
        return h > 1 ? c(b) : (s.consume(b), h++, g);
      if (h < 2 && !n) return c(b);
      const w = s.exit("strikethroughSequenceTemporary"), S = uh(b);
      return w._open = !S || S === 2 && !!x, w._close = !x || x === 2 && !!S, a(b);
    }
  }
}
class fEe {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    hEe(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(o, s) {
      return o[0] - s[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const o of i)
        t.push(o);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function hEe(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function pEe(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const o = r.length - 1;
          r[o] = r[o] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function mEe() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: gEe,
        resolveAll: yEe
      }
    }
  };
}
function gEe(e, t, n) {
  const r = this;
  let i = 0, o = 0, s;
  return a;
  function a(B) {
    let G = r.events.length - 1;
    for (; G > -1; ) {
      const ie = r.events[G][1].type;
      if (ie === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      ie === "linePrefix") G--;
      else break;
    }
    const Y = G > -1 ? r.events[G][1].type : null, he = Y === "tableHead" || Y === "tableRow" ? I : c;
    return he === I && r.parser.lazy[r.now().line] ? n(B) : he(B);
  }
  function c(B) {
    return e.enter("tableHead"), e.enter("tableRow"), u(B);
  }
  function u(B) {
    return B === 124 || (s = !0, o += 1), f(B);
  }
  function f(B) {
    return B === null ? n(B) : yt(B) ? o > 1 ? (o = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(B), e.exit("lineEnding"), g) : n(B) : Gt(B) ? tn(e, f, "whitespace")(B) : (o += 1, s && (s = !1, i += 1), B === 124 ? (e.enter("tableCellDivider"), e.consume(B), e.exit("tableCellDivider"), s = !0, f) : (e.enter("data"), h(B)));
  }
  function h(B) {
    return B === null || B === 124 || Tn(B) ? (e.exit("data"), f(B)) : (e.consume(B), B === 92 ? m : h);
  }
  function m(B) {
    return B === 92 || B === 124 ? (e.consume(B), h) : h(B);
  }
  function g(B) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(B) : (e.enter("tableDelimiterRow"), s = !1, Gt(B) ? tn(e, b, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(B) : b(B));
  }
  function b(B) {
    return B === 45 || B === 58 ? w(B) : B === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(B), e.exit("tableCellDivider"), x) : P(B);
  }
  function x(B) {
    return Gt(B) ? tn(e, w, "whitespace")(B) : w(B);
  }
  function w(B) {
    return B === 58 ? (o += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(B), e.exit("tableDelimiterMarker"), S) : B === 45 ? (o += 1, S(B)) : B === null || yt(B) ? N(B) : P(B);
  }
  function S(B) {
    return B === 45 ? (e.enter("tableDelimiterFiller"), _(B)) : P(B);
  }
  function _(B) {
    return B === 45 ? (e.consume(B), _) : B === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(B), e.exit("tableDelimiterMarker"), M) : (e.exit("tableDelimiterFiller"), M(B));
  }
  function M(B) {
    return Gt(B) ? tn(e, N, "whitespace")(B) : N(B);
  }
  function N(B) {
    return B === 124 ? b(B) : B === null || yt(B) ? !s || i !== o ? P(B) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(B)) : P(B);
  }
  function P(B) {
    return n(B);
  }
  function I(B) {
    return e.enter("tableRow"), O(B);
  }
  function O(B) {
    return B === 124 ? (e.enter("tableCellDivider"), e.consume(B), e.exit("tableCellDivider"), O) : B === null || yt(B) ? (e.exit("tableRow"), t(B)) : Gt(B) ? tn(e, O, "whitespace")(B) : (e.enter("data"), L(B));
  }
  function L(B) {
    return B === null || B === 124 || Tn(B) ? (e.exit("data"), O(B)) : (e.consume(B), B === 92 ? U : L);
  }
  function U(B) {
    return B === 92 || B === 124 ? (e.consume(B), L) : L(B);
  }
}
function yEe(e, t) {
  let n = -1, r = !0, i = 0, o = [0, 0, 0, 0], s = [0, 0, 0, 0], a = !1, c = 0, u, f, h;
  const m = new fEe();
  for (; ++n < e.length; ) {
    const g = e[n], b = g[1];
    g[0] === "enter" ? b.type === "tableHead" ? (a = !1, c !== 0 && (zz(m, t, c, u, f), f = void 0, c = 0), u = {
      type: "table",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, m.add(n, 0, [["enter", u, t]])) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (r = !0, h = void 0, o = [0, 0, 0, 0], s = [0, n + 1, 0, 0], a && (a = !1, f = {
      type: "tableBody",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, m.add(n, 0, [["enter", f, t]])), i = b.type === "tableDelimiterRow" ? 2 : f ? 3 : 1) : i && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (o[1] !== 0 && (s[0] = s[1], h = Vv(m, t, o, i, void 0, h), o = [0, 0, 0, 0]), s[2] = n)) : b.type === "tableCellDivider" && (r ? r = !1 : (o[1] !== 0 && (s[0] = s[1], h = Vv(m, t, o, i, void 0, h)), o = s, s = [o[1], n, 0, 0])) : b.type === "tableHead" ? (a = !0, c = n) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (c = n, o[1] !== 0 ? (s[0] = s[1], h = Vv(m, t, o, i, n, h)) : s[1] !== 0 && (h = Vv(m, t, s, i, n, h)), i = 0) : i && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (c !== 0 && zz(m, t, c, u, f), m.consume(t.events), n = -1; ++n < t.events.length; ) {
    const g = t.events[n];
    g[0] === "enter" && g[1].type === "table" && (g[1]._align = pEe(t.events, n));
  }
  return e;
}
function Vv(e, t, n, r, i, o) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", a = "tableContent";
  n[0] !== 0 && (o.end = Object.assign({}, Tf(t.events, n[0])), e.add(n[0], 0, [["exit", o, t]]));
  const c = Tf(t.events, n[1]);
  if (o = {
    type: s,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(n[1], 0, [["enter", o, t]]), n[2] !== 0) {
    const u = Tf(t.events, n[2]), f = Tf(t.events, n[3]), h = {
      type: a,
      start: Object.assign({}, u),
      end: Object.assign({}, f)
    };
    if (e.add(n[2], 0, [["enter", h, t]]), r !== 2) {
      const m = t.events[n[2]], g = t.events[n[3]];
      if (m[1].end = Object.assign({}, g[1].end), m[1].type = "chunkText", m[1].contentType = "text", n[3] > n[2] + 1) {
        const b = n[2] + 1, x = n[3] - n[2] - 1;
        e.add(b, x, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", h, t]]);
  }
  return i !== void 0 && (o.end = Object.assign({}, Tf(t.events, i)), e.add(i, 0, [["exit", o, t]]), o = void 0), o;
}
function zz(e, t, n, r, i) {
  const o = [], s = Tf(t.events, n);
  i && (i.end = Object.assign({}, s), o.push(["exit", i, t])), r.end = Object.assign({}, s), o.push(["exit", r, t]), e.add(n + 1, 0, o);
}
function Tf(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const vEe = {
  name: "tasklistCheck",
  tokenize: xEe
};
function bEe() {
  return {
    text: {
      91: vEe
    }
  };
}
function xEe(e, t, n) {
  const r = this;
  return i;
  function i(c) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), o)
    );
  }
  function o(c) {
    return Tn(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), s) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), s) : n(c);
  }
  function s(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), a) : n(c);
  }
  function a(c) {
    return yt(c) ? t(c) : Gt(c) ? e.check({
      tokenize: wEe
    }, t, n)(c) : n(c);
  }
}
function wEe(e, t, n) {
  return tn(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function SEe(e) {
  return ZF([
    GCe(),
    rEe(),
    dEe(e),
    mEe(),
    bEe()
  ]);
}
const kEe = {};
function CEe(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || kEe, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), o = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(SEe(n)), o.push(VCe()), s.push(HCe(n));
}
let kr = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
};
function EEe(e) {
  return KM(e);
}
function KM(e) {
  return Array.isArray(e) ? _Ee(e) : e instanceof RegExp ? e : typeof e == "object" ? TEe(e) : e;
}
function _Ee(e) {
  let t = [];
  for (let n = 0, r = e.length; n < r; n++)
    t[n] = KM(e[n]);
  return t;
}
function TEe(e) {
  let t = {};
  for (let n in e)
    t[n] = KM(e[n]);
  return t;
}
function BV(e, ...t) {
  return t.forEach((n) => {
    for (let r in n)
      e[r] = n[r];
  }), e;
}
function $V(e) {
  const t = ~e.lastIndexOf("/") || ~e.lastIndexOf("\\");
  return t === 0 ? e : ~t === e.length - 1 ? $V(e.substring(0, e.length - 1)) : e.substr(~t + 1);
}
var AC = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g, Hv = class {
  static hasCaptures(e) {
    return e === null ? !1 : (AC.lastIndex = 0, AC.test(e));
  }
  static replaceCaptures(e, t, n) {
    return e.replace(AC, (r, i, o, s) => {
      let a = n[parseInt(i || o, 10)];
      if (a) {
        let c = t.substring(a.start, a.end);
        for (; c[0] === "."; )
          c = c.substring(1);
        switch (s) {
          case "downcase":
            return c.toLowerCase();
          case "upcase":
            return c.toUpperCase();
          default:
            return c;
        }
      } else
        return r;
    });
  }
};
function UV(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function FV(e, t) {
  if (e === null && t === null)
    return 0;
  if (!e)
    return -1;
  if (!t)
    return 1;
  let n = e.length, r = t.length;
  if (n === r) {
    for (let i = 0; i < n; i++) {
      let o = UV(e[i], t[i]);
      if (o !== 0)
        return o;
    }
    return 0;
  }
  return n - r;
}
function Lz(e) {
  return !!(/^#[0-9a-f]{6}$/i.test(e) || /^#[0-9a-f]{8}$/i.test(e) || /^#[0-9a-f]{3}$/i.test(e) || /^#[0-9a-f]{4}$/i.test(e));
}
function VV(e) {
  return e.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var HV = class {
  constructor(e) {
    this.fn = e;
  }
  cache = /* @__PURE__ */ new Map();
  get(e) {
    if (this.cache.has(e))
      return this.cache.get(e);
    const t = this.fn(e);
    return this.cache.set(e, t), t;
  }
}, jb = class {
  constructor(e, t, n) {
    this._colorMap = e, this._defaults = t, this._root = n;
  }
  static createFromRawTheme(e, t) {
    return this.createFromParsedTheme(NEe(e), t);
  }
  static createFromParsedTheme(e, t) {
    return OEe(e, t);
  }
  _cachedMatchRoot = new HV(
    (e) => this._root.match(e)
  );
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  getDefaults() {
    return this._defaults;
  }
  match(e) {
    if (e === null)
      return this._defaults;
    const t = e.scopeName, r = this._cachedMatchRoot.get(t).find(
      (i) => AEe(e.parent, i.parentScopes)
    );
    return r ? new WV(
      r.fontStyle,
      r.foreground,
      r.background
    ) : null;
  }
}, MC = class R0 {
  constructor(t, n) {
    this.parent = t, this.scopeName = n;
  }
  static push(t, n) {
    for (const r of n)
      t = new R0(t, r);
    return t;
  }
  static from(...t) {
    let n = null;
    for (let r = 0; r < t.length; r++)
      n = new R0(n, t[r]);
    return n;
  }
  push(t) {
    return new R0(this, t);
  }
  getSegments() {
    let t = this;
    const n = [];
    for (; t; )
      n.push(t.scopeName), t = t.parent;
    return n.reverse(), n;
  }
  toString() {
    return this.getSegments().join(" ");
  }
  extends(t) {
    return this === t ? !0 : this.parent === null ? !1 : this.parent.extends(t);
  }
  getExtensionIfDefined(t) {
    const n = [];
    let r = this;
    for (; r && r !== t; )
      n.push(r.scopeName), r = r.parent;
    return r === t ? n.reverse() : void 0;
  }
};
function AEe(e, t) {
  if (t.length === 0)
    return !0;
  for (let n = 0; n < t.length; n++) {
    let r = t[n], i = !1;
    if (r === ">") {
      if (n === t.length - 1)
        return !1;
      r = t[++n], i = !0;
    }
    for (; e && !MEe(e.scopeName, r); ) {
      if (i)
        return !1;
      e = e.parent;
    }
    if (!e)
      return !1;
    e = e.parent;
  }
  return !0;
}
function MEe(e, t) {
  return t === e || e.startsWith(t) && e[t.length] === ".";
}
var WV = class {
  constructor(e, t, n) {
    this.fontStyle = e, this.foregroundId = t, this.backgroundId = n;
  }
};
function NEe(e) {
  if (!e)
    return [];
  if (!e.settings || !Array.isArray(e.settings))
    return [];
  let t = e.settings, n = [], r = 0;
  for (let i = 0, o = t.length; i < o; i++) {
    let s = t[i];
    if (!s.settings)
      continue;
    let a;
    if (typeof s.scope == "string") {
      let h = s.scope;
      h = h.replace(/^[,]+/, ""), h = h.replace(/[,]+$/, ""), a = h.split(",");
    } else Array.isArray(s.scope) ? a = s.scope : a = [""];
    let c = -1;
    if (typeof s.settings.fontStyle == "string") {
      c = 0;
      let h = s.settings.fontStyle.split(" ");
      for (let m = 0, g = h.length; m < g; m++)
        switch (h[m]) {
          case "italic":
            c = c | 1;
            break;
          case "bold":
            c = c | 2;
            break;
          case "underline":
            c = c | 4;
            break;
          case "strikethrough":
            c = c | 8;
            break;
        }
    }
    let u = null;
    typeof s.settings.foreground == "string" && Lz(s.settings.foreground) && (u = s.settings.foreground);
    let f = null;
    typeof s.settings.background == "string" && Lz(s.settings.background) && (f = s.settings.background);
    for (let h = 0, m = a.length; h < m; h++) {
      let b = a[h].trim().split(" "), x = b[b.length - 1], w = null;
      b.length > 1 && (w = b.slice(0, b.length - 1), w.reverse()), n[r++] = new REe(
        x,
        w,
        i,
        c,
        u,
        f
      );
    }
  }
  return n;
}
var REe = class {
  constructor(e, t, n, r, i, o) {
    this.scope = e, this.parentScopes = t, this.index = n, this.fontStyle = r, this.foreground = i, this.background = o;
  }
}, pi = /* @__PURE__ */ ((e) => (e[e.NotSet = -1] = "NotSet", e[e.None = 0] = "None", e[e.Italic = 1] = "Italic", e[e.Bold = 2] = "Bold", e[e.Underline = 4] = "Underline", e[e.Strikethrough = 8] = "Strikethrough", e))(pi || {});
function OEe(e, t) {
  e.sort((c, u) => {
    let f = UV(c.scope, u.scope);
    return f !== 0 || (f = FV(c.parentScopes, u.parentScopes), f !== 0) ? f : c.index - u.index;
  });
  let n = 0, r = "#000000", i = "#ffffff";
  for (; e.length >= 1 && e[0].scope === ""; ) {
    let c = e.shift();
    c.fontStyle !== -1 && (n = c.fontStyle), c.foreground !== null && (r = c.foreground), c.background !== null && (i = c.background);
  }
  let o = new DEe(t), s = new WV(n, o.getId(r), o.getId(i)), a = new jEe(new H_(0, null, -1, 0, 0), []);
  for (let c = 0, u = e.length; c < u; c++) {
    let f = e[c];
    a.insert(0, f.scope, f.parentScopes, f.fontStyle, o.getId(f.foreground), o.getId(f.background));
  }
  return new jb(o, s, a);
}
var DEe = class {
  _isFrozen;
  _lastColorId;
  _id2color;
  _color2id;
  constructor(e) {
    if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(e)) {
      this._isFrozen = !0;
      for (let t = 0, n = e.length; t < n; t++)
        this._color2id[e[t]] = t, this._id2color[t] = e[t];
    } else
      this._isFrozen = !1;
  }
  getId(e) {
    if (e === null)
      return 0;
    e = e.toUpperCase();
    let t = this._color2id[e];
    if (t)
      return t;
    if (this._isFrozen)
      throw new Error(`Missing color in color map - ${e}`);
    return t = ++this._lastColorId, this._color2id[e] = t, this._id2color[t] = e, t;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}, PEe = Object.freeze([]), H_ = class qV {
  scopeDepth;
  parentScopes;
  fontStyle;
  foreground;
  background;
  constructor(t, n, r, i, o) {
    this.scopeDepth = t, this.parentScopes = n || PEe, this.fontStyle = r, this.foreground = i, this.background = o;
  }
  clone() {
    return new qV(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
  }
  static cloneArr(t) {
    let n = [];
    for (let r = 0, i = t.length; r < i; r++)
      n[r] = t[r].clone();
    return n;
  }
  acceptOverwrite(t, n, r, i) {
    this.scopeDepth > t ? console.log("how did this happen?") : this.scopeDepth = t, n !== -1 && (this.fontStyle = n), r !== 0 && (this.foreground = r), i !== 0 && (this.background = i);
  }
}, jEe = class W_ {
  constructor(t, n = [], r = {}) {
    this._mainRule = t, this._children = r, this._rulesWithParentScopes = n;
  }
  _rulesWithParentScopes;
  static _cmpBySpecificity(t, n) {
    if (t.scopeDepth !== n.scopeDepth)
      return n.scopeDepth - t.scopeDepth;
    let r = 0, i = 0;
    for (; t.parentScopes[r] === ">" && r++, n.parentScopes[i] === ">" && i++, !(r >= t.parentScopes.length || i >= n.parentScopes.length); ) {
      const o = n.parentScopes[i].length - t.parentScopes[r].length;
      if (o !== 0)
        return o;
      r++, i++;
    }
    return n.parentScopes.length - t.parentScopes.length;
  }
  match(t) {
    if (t !== "") {
      let r = t.indexOf("."), i, o;
      if (r === -1 ? (i = t, o = "") : (i = t.substring(0, r), o = t.substring(r + 1)), this._children.hasOwnProperty(i))
        return this._children[i].match(o);
    }
    const n = this._rulesWithParentScopes.concat(this._mainRule);
    return n.sort(W_._cmpBySpecificity), n;
  }
  insert(t, n, r, i, o, s) {
    if (n === "") {
      this._doInsertHere(t, r, i, o, s);
      return;
    }
    let a = n.indexOf("."), c, u;
    a === -1 ? (c = n, u = "") : (c = n.substring(0, a), u = n.substring(a + 1));
    let f;
    this._children.hasOwnProperty(c) ? f = this._children[c] : (f = new W_(this._mainRule.clone(), H_.cloneArr(this._rulesWithParentScopes)), this._children[c] = f), f.insert(t + 1, u, r, i, o, s);
  }
  _doInsertHere(t, n, r, i, o) {
    if (n === null) {
      this._mainRule.acceptOverwrite(t, r, i, o);
      return;
    }
    for (let s = 0, a = this._rulesWithParentScopes.length; s < a; s++) {
      let c = this._rulesWithParentScopes[s];
      if (FV(c.parentScopes, n) === 0) {
        c.acceptOverwrite(t, r, i, o);
        return;
      }
    }
    r === -1 && (r = this._mainRule.fontStyle), i === 0 && (i = this._mainRule.foreground), o === 0 && (o = this._mainRule.background), this._rulesWithParentScopes.push(new H_(t, n, r, i, o));
  }
}, dh = class Ro {
  static toBinaryStr(t) {
    return t.toString(2).padStart(32, "0");
  }
  static print(t) {
    const n = Ro.getLanguageId(t), r = Ro.getTokenType(t), i = Ro.getFontStyle(t), o = Ro.getForeground(t), s = Ro.getBackground(t);
    console.log({
      languageId: n,
      tokenType: r,
      fontStyle: i,
      foreground: o,
      background: s
    });
  }
  static getLanguageId(t) {
    return (t & 255) >>> 0;
  }
  static getTokenType(t) {
    return (t & 768) >>> 8;
  }
  static containsBalancedBrackets(t) {
    return (t & 1024) !== 0;
  }
  static getFontStyle(t) {
    return (t & 30720) >>> 11;
  }
  static getForeground(t) {
    return (t & 16744448) >>> 15;
  }
  static getBackground(t) {
    return (t & 4278190080) >>> 24;
  }
  /**
   * Updates the fields in `metadata`.
   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.
   */
  static set(t, n, r, i, o, s, a) {
    let c = Ro.getLanguageId(t), u = Ro.getTokenType(t), f = Ro.containsBalancedBrackets(t) ? 1 : 0, h = Ro.getFontStyle(t), m = Ro.getForeground(t), g = Ro.getBackground(t);
    return n !== 0 && (c = n), r !== 8 && (u = r), i !== null && (f = i ? 1 : 0), o !== -1 && (h = o), s !== 0 && (m = s), a !== 0 && (g = a), (c << 0 | u << 8 | f << 10 | h << 11 | m << 15 | g << 24) >>> 0;
  }
};
function Ib(e, t) {
  const n = [], r = IEe(e);
  let i = r.next();
  for (; i !== null; ) {
    let c = 0;
    if (i.length === 2 && i.charAt(1) === ":") {
      switch (i.charAt(0)) {
        case "R":
          c = 1;
          break;
        case "L":
          c = -1;
          break;
        default:
          console.log(`Unknown priority ${i} in scope selector`);
      }
      i = r.next();
    }
    let u = s();
    if (n.push({ matcher: u, priority: c }), i !== ",")
      break;
    i = r.next();
  }
  return n;
  function o() {
    if (i === "-") {
      i = r.next();
      const c = o();
      return (u) => !!c && !c(u);
    }
    if (i === "(") {
      i = r.next();
      const c = a();
      return i === ")" && (i = r.next()), c;
    }
    if (Bz(i)) {
      const c = [];
      do
        c.push(i), i = r.next();
      while (Bz(i));
      return (u) => t(c, u);
    }
    return null;
  }
  function s() {
    const c = [];
    let u = o();
    for (; u; )
      c.push(u), u = o();
    return (f) => c.every((h) => h(f));
  }
  function a() {
    const c = [];
    let u = s();
    for (; u && (c.push(u), i === "|" || i === ","); ) {
      do
        i = r.next();
      while (i === "|" || i === ",");
      u = s();
    }
    return (f) => c.some((h) => h(f));
  }
}
function Bz(e) {
  return !!e && !!e.match(/[\w\.:]+/);
}
function IEe(e) {
  let t = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, n = t.exec(e);
  return {
    next: () => {
      if (!n)
        return null;
      const r = n[0];
      return n = t.exec(e), r;
    }
  };
}
function GV(e) {
  typeof e.dispose == "function" && e.dispose();
}
var dg = class {
  constructor(e) {
    this.scopeName = e;
  }
  toKey() {
    return this.scopeName;
  }
}, zEe = class {
  constructor(e, t) {
    this.scopeName = e, this.ruleName = t;
  }
  toKey() {
    return `${this.scopeName}#${this.ruleName}`;
  }
}, LEe = class {
  _references = [];
  _seenReferenceKeys = /* @__PURE__ */ new Set();
  get references() {
    return this._references;
  }
  visitedRule = /* @__PURE__ */ new Set();
  add(e) {
    const t = e.toKey();
    this._seenReferenceKeys.has(t) || (this._seenReferenceKeys.add(t), this._references.push(e));
  }
}, BEe = class {
  constructor(e, t) {
    this.repo = e, this.initialScopeName = t, this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new dg(this.initialScopeName)];
  }
  seenFullScopeRequests = /* @__PURE__ */ new Set();
  seenPartialScopeRequests = /* @__PURE__ */ new Set();
  Q;
  processQueue() {
    const e = this.Q;
    this.Q = [];
    const t = new LEe();
    for (const n of e)
      $Ee(n, this.initialScopeName, this.repo, t);
    for (const n of t.references)
      if (n instanceof dg) {
        if (this.seenFullScopeRequests.has(n.scopeName))
          continue;
        this.seenFullScopeRequests.add(n.scopeName), this.Q.push(n);
      } else {
        if (this.seenFullScopeRequests.has(n.scopeName) || this.seenPartialScopeRequests.has(n.toKey()))
          continue;
        this.seenPartialScopeRequests.add(n.toKey()), this.Q.push(n);
      }
  }
};
function $Ee(e, t, n, r) {
  const i = n.lookup(e.scopeName);
  if (!i) {
    if (e.scopeName === t)
      throw new Error(`No grammar provided for <${t}>`);
    return;
  }
  const o = n.lookup(t);
  e instanceof dg ? O0({ baseGrammar: o, selfGrammar: i }, r) : q_(
    e.ruleName,
    { baseGrammar: o, selfGrammar: i, repository: i.repository },
    r
  );
  const s = n.injections(e.scopeName);
  if (s)
    for (const a of s)
      r.add(new dg(a));
}
function q_(e, t, n) {
  if (t.repository && t.repository[e]) {
    const r = t.repository[e];
    zb([r], t, n);
  }
}
function O0(e, t) {
  e.selfGrammar.patterns && Array.isArray(e.selfGrammar.patterns) && zb(
    e.selfGrammar.patterns,
    { ...e, repository: e.selfGrammar.repository },
    t
  ), e.selfGrammar.injections && zb(
    Object.values(e.selfGrammar.injections),
    { ...e, repository: e.selfGrammar.repository },
    t
  );
}
function zb(e, t, n) {
  for (const r of e) {
    if (n.visitedRule.has(r))
      continue;
    n.visitedRule.add(r);
    const i = r.repository ? BV({}, t.repository, r.repository) : t.repository;
    Array.isArray(r.patterns) && zb(r.patterns, { ...t, repository: i }, n);
    const o = r.include;
    if (!o)
      continue;
    const s = KV(o);
    switch (s.kind) {
      case 0:
        O0({ ...t, selfGrammar: t.baseGrammar }, n);
        break;
      case 1:
        O0(t, n);
        break;
      case 2:
        q_(s.ruleName, { ...t, repository: i }, n);
        break;
      case 3:
      case 4:
        const a = s.scopeName === t.selfGrammar.scopeName ? t.selfGrammar : s.scopeName === t.baseGrammar.scopeName ? t.baseGrammar : void 0;
        if (a) {
          const c = { baseGrammar: t.baseGrammar, selfGrammar: a, repository: i };
          s.kind === 4 ? q_(s.ruleName, c, n) : O0(c, n);
        } else
          s.kind === 4 ? n.add(new zEe(s.scopeName, s.ruleName)) : n.add(new dg(s.scopeName));
        break;
    }
  }
}
var UEe = class {
  kind = 0;
}, FEe = class {
  kind = 1;
}, VEe = class {
  constructor(e) {
    this.ruleName = e;
  }
  kind = 2;
}, HEe = class {
  constructor(e) {
    this.scopeName = e;
  }
  kind = 3;
}, WEe = class {
  constructor(e, t) {
    this.scopeName = e, this.ruleName = t;
  }
  kind = 4;
};
function KV(e) {
  if (e === "$base")
    return new UEe();
  if (e === "$self")
    return new FEe();
  const t = e.indexOf("#");
  if (t === -1)
    return new HEe(e);
  if (t === 0)
    return new VEe(e.substring(1));
  {
    const n = e.substring(0, t), r = e.substring(t + 1);
    return new WEe(n, r);
  }
}
var qEe = /\\(\d+)/, $z = /\\(\d+)/g, GEe = -1, ZV = -2;
var ny = class {
  $location;
  id;
  _nameIsCapturing;
  _name;
  _contentNameIsCapturing;
  _contentName;
  constructor(e, t, n, r) {
    this.$location = e, this.id = t, this._name = n || null, this._nameIsCapturing = Hv.hasCaptures(this._name), this._contentName = r || null, this._contentNameIsCapturing = Hv.hasCaptures(this._contentName);
  }
  get debugName() {
    const e = this.$location ? `${$V(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${e}`;
  }
  getName(e, t) {
    return !this._nameIsCapturing || this._name === null || e === null || t === null ? this._name : Hv.replaceCaptures(this._name, e, t);
  }
  getContentName(e, t) {
    return !this._contentNameIsCapturing || this._contentName === null ? this._contentName : Hv.replaceCaptures(this._contentName, e, t);
  }
}, KEe = class extends ny {
  retokenizeCapturedWithRuleId;
  constructor(e, t, n, r, i) {
    super(e, t, n, r), this.retokenizeCapturedWithRuleId = i;
  }
  dispose() {
  }
  collectPatterns(e, t) {
    throw new Error("Not supported!");
  }
  compile(e, t) {
    throw new Error("Not supported!");
  }
  compileAG(e, t, n, r) {
    throw new Error("Not supported!");
  }
}, ZEe = class extends ny {
  _match;
  captures;
  _cachedCompiledPatterns;
  constructor(e, t, n, r, i) {
    super(e, t, n, null), this._match = new fg(r, this.id), this.captures = i, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugMatchRegExp() {
    return `${this._match.source}`;
  }
  collectPatterns(e, t) {
    t.push(this._match);
  }
  compile(e, t) {
    return this._getCachedCompiledPatterns(e).compile(e);
  }
  compileAG(e, t, n, r) {
    return this._getCachedCompiledPatterns(e).compileAG(e, n, r);
  }
  _getCachedCompiledPatterns(e) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new hg(), this.collectPatterns(e, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, Uz = class extends ny {
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(e, t, n, r, i) {
    super(e, t, n, r), this.patterns = i.patterns, this.hasMissingPatterns = i.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  collectPatterns(e, t) {
    for (const n of this.patterns)
      e.getRule(n).collectPatterns(e, t);
  }
  compile(e, t) {
    return this._getCachedCompiledPatterns(e).compile(e);
  }
  compileAG(e, t, n, r) {
    return this._getCachedCompiledPatterns(e).compileAG(e, n, r);
  }
  _getCachedCompiledPatterns(e) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new hg(), this.collectPatterns(e, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, G_ = class extends ny {
  _begin;
  beginCaptures;
  _end;
  endHasBackReferences;
  endCaptures;
  applyEndPatternLast;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(e, t, n, r, i, o, s, a, c, u) {
    super(e, t, n, r), this._begin = new fg(i, this.id), this.beginCaptures = o, this._end = new fg(s || "", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = a, this.applyEndPatternLast = c || !1, this.patterns = u.patterns, this.hasMissingPatterns = u.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugEndRegExp() {
    return `${this._end.source}`;
  }
  getEndWithResolvedBackReferences(e, t) {
    return this._end.resolveBackReferences(e, t);
  }
  collectPatterns(e, t) {
    t.push(this._begin);
  }
  compile(e, t) {
    return this._getCachedCompiledPatterns(e, t).compile(e);
  }
  compileAG(e, t, n, r) {
    return this._getCachedCompiledPatterns(e, t).compileAG(e, n, r);
  }
  _getCachedCompiledPatterns(e, t) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new hg();
      for (const n of this.patterns)
        e.getRule(n).collectPatterns(e, this._cachedCompiledPatterns);
      this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
    }
    return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, t) : this._cachedCompiledPatterns.setSource(0, t)), this._cachedCompiledPatterns;
  }
}, Lb = class extends ny {
  _begin;
  beginCaptures;
  whileCaptures;
  _while;
  whileHasBackReferences;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  _cachedCompiledWhilePatterns;
  constructor(e, t, n, r, i, o, s, a, c) {
    super(e, t, n, r), this._begin = new fg(i, this.id), this.beginCaptures = o, this.whileCaptures = a, this._while = new fg(s, ZV), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = c.patterns, this.hasMissingPatterns = c.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugWhileRegExp() {
    return `${this._while.source}`;
  }
  getWhileWithResolvedBackReferences(e, t) {
    return this._while.resolveBackReferences(e, t);
  }
  collectPatterns(e, t) {
    t.push(this._begin);
  }
  compile(e, t) {
    return this._getCachedCompiledPatterns(e).compile(e);
  }
  compileAG(e, t, n, r) {
    return this._getCachedCompiledPatterns(e).compileAG(e, n, r);
  }
  _getCachedCompiledPatterns(e) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new hg();
      for (const t of this.patterns)
        e.getRule(t).collectPatterns(e, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
  compileWhile(e, t) {
    return this._getCachedCompiledWhilePatterns(e, t).compile(e);
  }
  compileWhileAG(e, t, n, r) {
    return this._getCachedCompiledWhilePatterns(e, t).compileAG(e, n, r);
  }
  _getCachedCompiledWhilePatterns(e, t) {
    return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new hg(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, t || ""), this._cachedCompiledWhilePatterns;
  }
}, YV = class di {
  static createCaptureRule(t, n, r, i, o) {
    return t.registerRule((s) => new KEe(n, s, r, i, o));
  }
  static getCompiledRuleId(t, n, r) {
    return t.id || n.registerRule((i) => {
      if (t.id = i, t.match)
        return new ZEe(
          t.$vscodeTextmateLocation,
          t.id,
          t.name,
          t.match,
          di._compileCaptures(t.captures, n, r)
        );
      if (typeof t.begin > "u") {
        t.repository && (r = BV({}, r, t.repository));
        let o = t.patterns;
        return typeof o > "u" && t.include && (o = [{ include: t.include }]), new Uz(
          t.$vscodeTextmateLocation,
          t.id,
          t.name,
          t.contentName,
          di._compilePatterns(o, n, r)
        );
      }
      return t.while ? new Lb(
        t.$vscodeTextmateLocation,
        t.id,
        t.name,
        t.contentName,
        t.begin,
        di._compileCaptures(t.beginCaptures || t.captures, n, r),
        t.while,
        di._compileCaptures(t.whileCaptures || t.captures, n, r),
        di._compilePatterns(t.patterns, n, r)
      ) : new G_(
        t.$vscodeTextmateLocation,
        t.id,
        t.name,
        t.contentName,
        t.begin,
        di._compileCaptures(t.beginCaptures || t.captures, n, r),
        t.end,
        di._compileCaptures(t.endCaptures || t.captures, n, r),
        t.applyEndPatternLast,
        di._compilePatterns(t.patterns, n, r)
      );
    }), t.id;
  }
  static _compileCaptures(t, n, r) {
    let i = [];
    if (t) {
      let o = 0;
      for (const s in t) {
        if (s === "$vscodeTextmateLocation")
          continue;
        const a = parseInt(s, 10);
        a > o && (o = a);
      }
      for (let s = 0; s <= o; s++)
        i[s] = null;
      for (const s in t) {
        if (s === "$vscodeTextmateLocation")
          continue;
        const a = parseInt(s, 10);
        let c = 0;
        t[s].patterns && (c = di.getCompiledRuleId(t[s], n, r)), i[a] = di.createCaptureRule(n, t[s].$vscodeTextmateLocation, t[s].name, t[s].contentName, c);
      }
    }
    return i;
  }
  static _compilePatterns(t, n, r) {
    let i = [];
    if (t)
      for (let o = 0, s = t.length; o < s; o++) {
        const a = t[o];
        let c = -1;
        if (a.include) {
          const u = KV(a.include);
          switch (u.kind) {
            case 0:
            case 1:
              c = di.getCompiledRuleId(r[a.include], n, r);
              break;
            case 2:
              let f = r[u.ruleName];
              f && (c = di.getCompiledRuleId(f, n, r));
              break;
            case 3:
            case 4:
              const h = u.scopeName, m = u.kind === 4 ? u.ruleName : null, g = n.getExternalGrammar(h, r);
              if (g)
                if (m) {
                  let b = g.repository[m];
                  b && (c = di.getCompiledRuleId(b, n, g.repository));
                } else
                  c = di.getCompiledRuleId(g.repository.$self, n, g.repository);
              break;
          }
        } else
          c = di.getCompiledRuleId(a, n, r);
        if (c !== -1) {
          const u = n.getRule(c);
          let f = !1;
          if ((u instanceof Uz || u instanceof G_ || u instanceof Lb) && u.hasMissingPatterns && u.patterns.length === 0 && (f = !0), f)
            continue;
          i.push(c);
        }
      }
    return {
      patterns: i,
      hasMissingPatterns: (t ? t.length : 0) !== i.length
    };
  }
}, fg = class XV {
  source;
  ruleId;
  hasAnchor;
  hasBackReferences;
  _anchorCache;
  constructor(t, n) {
    if (t && typeof t == "string") {
      const r = t.length;
      let i = 0, o = [], s = !1;
      for (let a = 0; a < r; a++)
        if (t.charAt(a) === "\\" && a + 1 < r) {
          const u = t.charAt(a + 1);
          u === "z" ? (o.push(t.substring(i, a)), o.push("$(?!\\n)(?<!\\n)"), i = a + 2) : (u === "A" || u === "G") && (s = !0), a++;
        }
      this.hasAnchor = s, i === 0 ? this.source = t : (o.push(t.substring(i, r)), this.source = o.join(""));
    } else
      this.hasAnchor = !1, this.source = t;
    this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = n, typeof this.source == "string" ? this.hasBackReferences = qEe.test(this.source) : this.hasBackReferences = !1;
  }
  clone() {
    return new XV(this.source, this.ruleId);
  }
  setSource(t) {
    this.source !== t && (this.source = t, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
  }
  resolveBackReferences(t, n) {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let r = n.map((i) => t.substring(i.start, i.end));
    return $z.lastIndex = 0, this.source.replace($z, (i, o) => VV(r[parseInt(o, 10)] || ""));
  }
  _buildAnchorCache() {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let t = [], n = [], r = [], i = [], o, s, a, c;
    for (o = 0, s = this.source.length; o < s; o++)
      a = this.source.charAt(o), t[o] = a, n[o] = a, r[o] = a, i[o] = a, a === "\\" && o + 1 < s && (c = this.source.charAt(o + 1), c === "A" ? (t[o + 1] = "", n[o + 1] = "", r[o + 1] = "A", i[o + 1] = "A") : c === "G" ? (t[o + 1] = "", n[o + 1] = "G", r[o + 1] = "", i[o + 1] = "G") : (t[o + 1] = c, n[o + 1] = c, r[o + 1] = c, i[o + 1] = c), o++);
    return {
      A0_G0: t.join(""),
      A0_G1: n.join(""),
      A1_G0: r.join(""),
      A1_G1: i.join("")
    };
  }
  resolveAnchors(t, n) {
    return !this.hasAnchor || !this._anchorCache || typeof this.source != "string" ? this.source : t ? n ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : n ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0;
  }
}, hg = class {
  _items;
  _hasAnchors;
  _cached;
  _anchorCache;
  constructor() {
    this._items = [], this._hasAnchors = !1, this._cached = null, this._anchorCache = {
      A0_G0: null,
      A0_G1: null,
      A1_G0: null,
      A1_G1: null
    };
  }
  dispose() {
    this._disposeCaches();
  }
  _disposeCaches() {
    this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
  }
  push(e) {
    this._items.push(e), this._hasAnchors = this._hasAnchors || e.hasAnchor;
  }
  unshift(e) {
    this._items.unshift(e), this._hasAnchors = this._hasAnchors || e.hasAnchor;
  }
  length() {
    return this._items.length;
  }
  setSource(e, t) {
    this._items[e].source !== t && (this._disposeCaches(), this._items[e].setSource(t));
  }
  compile(e) {
    if (!this._cached) {
      let t = this._items.map((n) => n.source);
      this._cached = new Fz(e, t, this._items.map((n) => n.ruleId));
    }
    return this._cached;
  }
  compileAG(e, t, n) {
    return this._hasAnchors ? t ? n ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(e, t, n)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(e, t, n)), this._anchorCache.A1_G0) : n ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(e, t, n)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(e, t, n)), this._anchorCache.A0_G0) : this.compile(e);
  }
  _resolveAnchors(e, t, n) {
    let r = this._items.map((i) => i.resolveAnchors(t, n));
    return new Fz(e, r, this._items.map((i) => i.ruleId));
  }
}, Fz = class {
  constructor(e, t, n) {
    this.regExps = t, this.rules = n, this.scanner = e.createOnigScanner(t);
  }
  scanner;
  dispose() {
    typeof this.scanner.dispose == "function" && this.scanner.dispose();
  }
  toString() {
    const e = [];
    for (let t = 0, n = this.rules.length; t < n; t++)
      e.push("   - " + this.rules[t] + ": " + this.regExps[t]);
    return e.join(`
`);
  }
  findNextMatchSync(e, t, n) {
    const r = this.scanner.findNextMatchSync(e, t, n);
    return r ? {
      ruleId: this.rules[r.index],
      captureIndices: r.captureIndices
    } : null;
  }
}, NC = class {
  constructor(e, t) {
    this.languageId = e, this.tokenType = t;
  }
}, YEe = class K_ {
  _defaultAttributes;
  _embeddedLanguagesMatcher;
  constructor(t, n) {
    this._defaultAttributes = new NC(
      t,
      8
      /* NotSet */
    ), this._embeddedLanguagesMatcher = new XEe(Object.entries(n || {}));
  }
  getDefaultAttributes() {
    return this._defaultAttributes;
  }
  getBasicScopeAttributes(t) {
    return t === null ? K_._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(t);
  }
  static _NULL_SCOPE_METADATA = new NC(0, 0);
  _getBasicScopeAttributes = new HV((t) => {
    const n = this._scopeToLanguage(t), r = this._toStandardTokenType(t);
    return new NC(n, r);
  });
  /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */
  _scopeToLanguage(t) {
    return this._embeddedLanguagesMatcher.match(t) || 0;
  }
  _toStandardTokenType(t) {
    const n = t.match(K_.STANDARD_TOKEN_TYPE_REGEXP);
    if (!n)
      return 8;
    switch (n[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "meta.embedded":
        return 0;
    }
    throw new Error("Unexpected match for standard token type!");
  }
  static STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/;
}, XEe = class {
  values;
  scopesRegExp;
  constructor(e) {
    if (e.length === 0)
      this.values = null, this.scopesRegExp = null;
    else {
      this.values = new Map(e);
      const t = e.map(
        ([n, r]) => VV(n)
      );
      t.sort(), t.reverse(), this.scopesRegExp = new RegExp(
        `^((${t.join(")|(")}))($|\\.)`,
        ""
      );
    }
  }
  match(e) {
    if (!this.scopesRegExp)
      return;
    const t = e.match(this.scopesRegExp);
    if (t)
      return this.values.get(t[1]);
  }
};
typeof process < "u" && process.env.VSCODE_TEXTMATE_DEBUG;
var Vz = class {
  constructor(e, t) {
    this.stack = e, this.stoppedEarly = t;
  }
};
function JV(e, t, n, r, i, o, s, a) {
  const c = t.content.length;
  let u = !1, f = -1;
  if (s) {
    const g = JEe(
      e,
      t,
      n,
      r,
      i,
      o
    );
    i = g.stack, r = g.linePos, n = g.isFirstLine, f = g.anchorPosition;
  }
  const h = Date.now();
  for (; !u; ) {
    if (a !== 0 && Date.now() - h > a)
      return new Vz(i, !0);
    m();
  }
  return new Vz(i, !1);
  function m() {
    const g = QEe(
      e,
      t,
      n,
      r,
      i,
      f
    );
    if (!g) {
      o.produce(i, c), u = !0;
      return;
    }
    const b = g.captureIndices, x = g.matchedRuleId, w = b && b.length > 0 ? b[0].end > r : !1;
    if (x === GEe) {
      const S = i.getRule(e);
      o.produce(i, b[0].start), i = i.withContentNameScopesList(i.nameScopesList), hm(
        e,
        t,
        n,
        i,
        o,
        S.endCaptures,
        b
      ), o.produce(i, b[0].end);
      const _ = i;
      if (i = i.parent, f = _.getAnchorPos(), !w && _.getEnterPos() === r) {
        i = _, o.produce(i, c), u = !0;
        return;
      }
    } else {
      const S = e.getRule(x);
      o.produce(i, b[0].start);
      const _ = i, M = S.getName(t.content, b), N = i.contentNameScopesList.pushAttributed(
        M,
        e
      );
      if (i = i.push(
        x,
        r,
        f,
        b[0].end === c,
        null,
        N,
        N
      ), S instanceof G_) {
        const P = S;
        hm(
          e,
          t,
          n,
          i,
          o,
          P.beginCaptures,
          b
        ), o.produce(i, b[0].end), f = b[0].end;
        const I = P.getContentName(
          t.content,
          b
        ), O = N.pushAttributed(
          I,
          e
        );
        if (i = i.withContentNameScopesList(O), P.endHasBackReferences && (i = i.withEndRule(
          P.getEndWithResolvedBackReferences(
            t.content,
            b
          )
        )), !w && _.hasSameRuleAs(i)) {
          i = i.pop(), o.produce(i, c), u = !0;
          return;
        }
      } else if (S instanceof Lb) {
        const P = S;
        hm(
          e,
          t,
          n,
          i,
          o,
          P.beginCaptures,
          b
        ), o.produce(i, b[0].end), f = b[0].end;
        const I = P.getContentName(
          t.content,
          b
        ), O = N.pushAttributed(
          I,
          e
        );
        if (i = i.withContentNameScopesList(O), P.whileHasBackReferences && (i = i.withEndRule(
          P.getWhileWithResolvedBackReferences(
            t.content,
            b
          )
        )), !w && _.hasSameRuleAs(i)) {
          i = i.pop(), o.produce(i, c), u = !0;
          return;
        }
      } else if (hm(
        e,
        t,
        n,
        i,
        o,
        S.captures,
        b
      ), o.produce(i, b[0].end), i = i.pop(), !w) {
        i = i.safePop(), o.produce(i, c), u = !0;
        return;
      }
    }
    b[0].end > r && (r = b[0].end, n = !1);
  }
}
function JEe(e, t, n, r, i, o) {
  let s = i.beginRuleCapturedEOL ? 0 : -1;
  const a = [];
  for (let c = i; c; c = c.pop()) {
    const u = c.getRule(e);
    u instanceof Lb && a.push({
      rule: u,
      stack: c
    });
  }
  for (let c = a.pop(); c; c = a.pop()) {
    const { ruleScanner: u, findOptions: f } = n_e(c.rule, e, c.stack.endRule, n, r === s), h = u.findNextMatchSync(t, r, f);
    if (h) {
      if (h.ruleId !== ZV) {
        i = c.stack.pop();
        break;
      }
      h.captureIndices && h.captureIndices.length && (o.produce(c.stack, h.captureIndices[0].start), hm(e, t, n, c.stack, o, c.rule.whileCaptures, h.captureIndices), o.produce(c.stack, h.captureIndices[0].end), s = h.captureIndices[0].end, h.captureIndices[0].end > r && (r = h.captureIndices[0].end, n = !1));
    } else {
      i = c.stack.pop();
      break;
    }
  }
  return { stack: i, linePos: r, anchorPosition: s, isFirstLine: n };
}
function QEe(e, t, n, r, i, o) {
  const s = e_e(e, t, n, r, i, o), a = e.getInjections();
  if (a.length === 0)
    return s;
  const c = t_e(a, e, t, n, r, i, o);
  if (!c)
    return s;
  if (!s)
    return c;
  const u = s.captureIndices[0].start, f = c.captureIndices[0].start;
  return f < u || c.priorityMatch && f === u ? c : s;
}
function e_e(e, t, n, r, i, o) {
  const s = i.getRule(e), { ruleScanner: a, findOptions: c } = QV(s, e, i.endRule, n, r === o), u = a.findNextMatchSync(t, r, c);
  return u ? {
    captureIndices: u.captureIndices,
    matchedRuleId: u.ruleId
  } : null;
}
function t_e(e, t, n, r, i, o, s) {
  let a = Number.MAX_VALUE, c = null, u, f = 0;
  const h = o.contentNameScopesList.getScopeNames();
  for (let m = 0, g = e.length; m < g; m++) {
    const b = e[m];
    if (!b.matcher(h))
      continue;
    const x = t.getRule(b.ruleId), { ruleScanner: w, findOptions: S } = QV(x, t, null, r, i === s), _ = w.findNextMatchSync(n, i, S);
    if (!_)
      continue;
    const M = _.captureIndices[0].start;
    if (!(M >= a) && (a = M, c = _.captureIndices, u = _.ruleId, f = b.priority, a === i))
      break;
  }
  return c ? {
    priorityMatch: f === -1,
    captureIndices: c,
    matchedRuleId: u
  } : null;
}
function QV(e, t, n, r, i) {
  return {
    ruleScanner: e.compileAG(t, n, r, i),
    findOptions: 0
    /* None */
  };
}
function n_e(e, t, n, r, i) {
  return {
    ruleScanner: e.compileWhileAG(t, n, r, i),
    findOptions: 0
    /* None */
  };
}
function hm(e, t, n, r, i, o, s) {
  if (o.length === 0)
    return;
  const a = t.content, c = Math.min(o.length, s.length), u = [], f = s[0].end;
  for (let h = 0; h < c; h++) {
    const m = o[h];
    if (m === null)
      continue;
    const g = s[h];
    if (g.length === 0)
      continue;
    if (g.start > f)
      break;
    for (; u.length > 0 && u[u.length - 1].endPos <= g.start; )
      i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
    if (u.length > 0 ? i.produceFromScopes(u[u.length - 1].scopes, g.start) : i.produce(r, g.start), m.retokenizeCapturedWithRuleId) {
      const x = m.getName(a, s), w = r.contentNameScopesList.pushAttributed(x, e), S = m.getContentName(a, s), _ = w.pushAttributed(S, e), M = r.push(m.retokenizeCapturedWithRuleId, g.start, -1, !1, null, w, _), N = e.createOnigString(a.substring(0, g.end));
      JV(
        e,
        N,
        n && g.start === 0,
        g.start,
        M,
        i,
        !1,
        /* no time limit */
        0
      ), GV(N);
      continue;
    }
    const b = m.getName(a, s);
    if (b !== null) {
      const w = (u.length > 0 ? u[u.length - 1].scopes : r.contentNameScopesList).pushAttributed(b, e);
      u.push(new r_e(w, g.end));
    }
  }
  for (; u.length > 0; )
    i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
}
var r_e = class {
  scopes;
  endPos;
  constructor(e, t) {
    this.scopes = e, this.endPos = t;
  }
};
function i_e(e, t, n, r, i, o, s, a) {
  return new s_e(
    e,
    t,
    n,
    r,
    i,
    o,
    s,
    a
  );
}
function Hz(e, t, n, r, i) {
  const o = Ib(t, Bb), s = YV.getCompiledRuleId(n, r, i.repository);
  for (const a of o)
    e.push({
      debugSelector: t,
      matcher: a.matcher,
      ruleId: s,
      grammar: i,
      priority: a.priority
    });
}
function Bb(e, t) {
  if (t.length < e.length)
    return !1;
  let n = 0;
  return e.every((r) => {
    for (let i = n; i < t.length; i++)
      if (o_e(t[i], r))
        return n = i + 1, !0;
    return !1;
  });
}
function o_e(e, t) {
  if (!e)
    return !1;
  if (e === t)
    return !0;
  const n = t.length;
  return e.length > n && e.substr(0, n) === t && e[n] === ".";
}
var s_e = class {
  constructor(e, t, n, r, i, o, s, a) {
    if (this._rootScopeName = e, this.balancedBracketSelectors = o, this._onigLib = a, this._basicScopeAttributesProvider = new YEe(
      n,
      r
    ), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = s, this._grammar = Wz(t, null), this._injections = null, this._tokenTypeMatchers = [], i)
      for (const c of Object.keys(i)) {
        const u = Ib(c, Bb);
        for (const f of u)
          this._tokenTypeMatchers.push({
            matcher: f.matcher,
            type: i[c]
          });
      }
  }
  _rootId;
  _lastRuleId;
  _ruleId2desc;
  _includedGrammars;
  _grammarRepository;
  _grammar;
  _injections;
  _basicScopeAttributesProvider;
  _tokenTypeMatchers;
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (const e of this._ruleId2desc)
      e && e.dispose();
  }
  createOnigScanner(e) {
    return this._onigLib.createOnigScanner(e);
  }
  createOnigString(e) {
    return this._onigLib.createOnigString(e);
  }
  getMetadataForScope(e) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(e);
  }
  _collectInjections() {
    const e = {
      lookup: (i) => i === this._rootScopeName ? this._grammar : this.getExternalGrammar(i),
      injections: (i) => this._grammarRepository.injections(i)
    }, t = [], n = this._rootScopeName, r = e.lookup(n);
    if (r) {
      const i = r.injections;
      if (i)
        for (let s in i)
          Hz(
            t,
            s,
            i[s],
            this,
            r
          );
      const o = this._grammarRepository.injections(n);
      o && o.forEach((s) => {
        const a = this.getExternalGrammar(s);
        if (a) {
          const c = a.injectionSelector;
          c && Hz(
            t,
            c,
            a,
            this,
            a
          );
        }
      });
    }
    return t.sort((i, o) => i.priority - o.priority), t;
  }
  getInjections() {
    return this._injections === null && (this._injections = this._collectInjections()), this._injections;
  }
  registerRule(e) {
    const t = ++this._lastRuleId, n = e(t);
    return this._ruleId2desc[t] = n, n;
  }
  getRule(e) {
    return this._ruleId2desc[e];
  }
  getExternalGrammar(e, t) {
    if (this._includedGrammars[e])
      return this._includedGrammars[e];
    if (this._grammarRepository) {
      const n = this._grammarRepository.lookup(e);
      if (n)
        return this._includedGrammars[e] = Wz(
          n,
          t && t.$base
        ), this._includedGrammars[e];
    }
  }
  tokenizeLine(e, t, n = 0) {
    const r = this._tokenize(e, t, !1, n);
    return {
      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  tokenizeLine2(e, t, n = 0) {
    const r = this._tokenize(e, t, !0, n);
    return {
      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  _tokenize(e, t, n, r) {
    this._rootId === -1 && (this._rootId = YV.getCompiledRuleId(
      this._grammar.repository.$self,
      this,
      this._grammar.repository
    ), this.getInjections());
    let i;
    if (!t || t === Z_.NULL) {
      i = !0;
      const u = this._basicScopeAttributesProvider.getDefaultAttributes(), f = this.themeProvider.getDefaults(), h = dh.set(
        0,
        u.languageId,
        u.tokenType,
        null,
        f.fontStyle,
        f.foregroundId,
        f.backgroundId
      ), m = this.getRule(this._rootId).getName(
        null,
        null
      );
      let g;
      m ? g = Dm.createRootAndLookUpScopeName(
        m,
        h,
        this
      ) : g = Dm.createRoot(
        "unknown",
        h
      ), t = new Z_(
        null,
        this._rootId,
        -1,
        -1,
        !1,
        null,
        g,
        g
      );
    } else
      i = !1, t.reset();
    e = e + `
`;
    const o = this.createOnigString(e), s = o.content.length, a = new l_e(
      n,
      e,
      this._tokenTypeMatchers,
      this.balancedBracketSelectors
    ), c = JV(
      this,
      o,
      i,
      0,
      t,
      a,
      !0,
      r
    );
    return GV(o), {
      lineLength: s,
      lineTokens: a,
      ruleStack: c.stack,
      stoppedEarly: c.stoppedEarly
    };
  }
};
function Wz(e, t) {
  return e = EEe(e), e.repository = e.repository || {}, e.repository.$self = {
    $vscodeTextmateLocation: e.$vscodeTextmateLocation,
    patterns: e.patterns,
    name: e.scopeName
  }, e.repository.$base = t || e.repository.$self, e;
}
var Dm = class Ps {
  /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(t, n, r) {
    this.parent = t, this.scopePath = n, this.tokenAttributes = r;
  }
  static fromExtension(t, n) {
    let r = t, i = t?.scopePath ?? null;
    for (const o of n)
      i = MC.push(i, o.scopeNames), r = new Ps(r, i, o.encodedTokenAttributes);
    return r;
  }
  static createRoot(t, n) {
    return new Ps(null, new MC(null, t), n);
  }
  static createRootAndLookUpScopeName(t, n, r) {
    const i = r.getMetadataForScope(t), o = new MC(null, t), s = r.themeProvider.themeMatch(o), a = Ps.mergeAttributes(
      n,
      i,
      s
    );
    return new Ps(null, o, a);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(t) {
    return Ps.equals(this, t);
  }
  static equals(t, n) {
    do {
      if (t === n || !t && !n)
        return !0;
      if (!t || !n || t.scopeName !== n.scopeName || t.tokenAttributes !== n.tokenAttributes)
        return !1;
      t = t.parent, n = n.parent;
    } while (!0);
  }
  static mergeAttributes(t, n, r) {
    let i = -1, o = 0, s = 0;
    return r !== null && (i = r.fontStyle, o = r.foregroundId, s = r.backgroundId), dh.set(
      t,
      n.languageId,
      n.tokenType,
      null,
      i,
      o,
      s
    );
  }
  pushAttributed(t, n) {
    if (t === null)
      return this;
    if (t.indexOf(" ") === -1)
      return Ps._pushAttributed(this, t, n);
    const r = t.split(/ /g);
    let i = this;
    for (const o of r)
      i = Ps._pushAttributed(i, o, n);
    return i;
  }
  static _pushAttributed(t, n, r) {
    const i = r.getMetadataForScope(n), o = t.scopePath.push(n), s = r.themeProvider.themeMatch(o), a = Ps.mergeAttributes(
      t.tokenAttributes,
      i,
      s
    );
    return new Ps(t, o, a);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(t) {
    const n = [];
    let r = this;
    for (; r && r !== t; )
      n.push({
        encodedTokenAttributes: r.tokenAttributes,
        scopeNames: r.scopePath.getExtensionIfDefined(r.parent?.scopePath ?? null)
      }), r = r.parent;
    return r === t ? n.reverse() : void 0;
  }
}, Z_ = class Nu {
  /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(t, n, r, i, o, s, a, c) {
    this.parent = t, this.ruleId = n, this.beginRuleCapturedEOL = o, this.endRule = s, this.nameScopesList = a, this.contentNameScopesList = c, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = r, this._anchorPos = i;
  }
  _stackElementBrand = void 0;
  // TODO remove me
  static NULL = new Nu(
    null,
    0,
    0,
    0,
    !1,
    null,
    null,
    null
  );
  /**
   * The position on the current line where this state was pushed.
   * This is relevant only while tokenizing a line, to detect endless loops.
   * Its value is meaningless across lines.
   */
  _enterPos;
  /**
   * The captured anchor position when this stack element was pushed.
   * This is relevant only while tokenizing a line, to restore the anchor position when popping.
   * Its value is meaningless across lines.
   */
  _anchorPos;
  /**
   * The depth of the stack.
   */
  depth;
  equals(t) {
    return t === null ? !1 : Nu._equals(this, t);
  }
  static _equals(t, n) {
    return t === n ? !0 : this._structuralEquals(t, n) ? Dm.equals(t.contentNameScopesList, n.contentNameScopesList) : !1;
  }
  /**
   * A structural equals check. Does not take into account `scopes`.
   */
  static _structuralEquals(t, n) {
    do {
      if (t === n || !t && !n)
        return !0;
      if (!t || !n || t.depth !== n.depth || t.ruleId !== n.ruleId || t.endRule !== n.endRule)
        return !1;
      t = t.parent, n = n.parent;
    } while (!0);
  }
  clone() {
    return this;
  }
  static _reset(t) {
    for (; t; )
      t._enterPos = -1, t._anchorPos = -1, t = t.parent;
  }
  reset() {
    Nu._reset(this);
  }
  pop() {
    return this.parent;
  }
  safePop() {
    return this.parent ? this.parent : this;
  }
  push(t, n, r, i, o, s, a) {
    return new Nu(
      this,
      t,
      n,
      r,
      i,
      o,
      s,
      a
    );
  }
  getEnterPos() {
    return this._enterPos;
  }
  getAnchorPos() {
    return this._anchorPos;
  }
  getRule(t) {
    return t.getRule(this.ruleId);
  }
  toString() {
    const t = [];
    return this._writeString(t, 0), "[" + t.join(",") + "]";
  }
  _writeString(t, n) {
    return this.parent && (n = this.parent._writeString(t, n)), t[n++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`, n;
  }
  withContentNameScopesList(t) {
    return this.contentNameScopesList === t ? this : this.parent.push(
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      this.endRule,
      this.nameScopesList,
      t
    );
  }
  withEndRule(t) {
    return this.endRule === t ? this : new Nu(
      this.parent,
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      t,
      this.nameScopesList,
      this.contentNameScopesList
    );
  }
  // Used to warn of endless loops
  hasSameRuleAs(t) {
    let n = this;
    for (; n && n._enterPos === t._enterPos; ) {
      if (n.ruleId === t.ruleId)
        return !0;
      n = n.parent;
    }
    return !1;
  }
  toStateStackFrame() {
    return {
      ruleId: this.ruleId,
      beginRuleCapturedEOL: this.beginRuleCapturedEOL,
      endRule: this.endRule,
      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],
      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []
    };
  }
  static pushFrame(t, n) {
    const r = Dm.fromExtension(t?.nameScopesList ?? null, n.nameScopesList);
    return new Nu(
      t,
      n.ruleId,
      n.enterPos ?? -1,
      n.anchorPos ?? -1,
      n.beginRuleCapturedEOL,
      n.endRule,
      r,
      Dm.fromExtension(r, n.contentNameScopesList)
    );
  }
}, a_e = class {
  balancedBracketScopes;
  unbalancedBracketScopes;
  allowAny = !1;
  constructor(e, t) {
    this.balancedBracketScopes = e.flatMap(
      (n) => n === "*" ? (this.allowAny = !0, []) : Ib(n, Bb).map((r) => r.matcher)
    ), this.unbalancedBracketScopes = t.flatMap(
      (n) => Ib(n, Bb).map((r) => r.matcher)
    );
  }
  get matchesAlways() {
    return this.allowAny && this.unbalancedBracketScopes.length === 0;
  }
  get matchesNever() {
    return this.balancedBracketScopes.length === 0 && !this.allowAny;
  }
  match(e) {
    for (const t of this.unbalancedBracketScopes)
      if (t(e))
        return !1;
    for (const t of this.balancedBracketScopes)
      if (t(e))
        return !0;
    return this.allowAny;
  }
}, l_e = class {
  constructor(e, t, n, r) {
    this.balancedBracketSelectors = r, this._emitBinaryTokens = e, this._tokenTypeOverrides = n, this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
  }
  _emitBinaryTokens;
  /**
   * defined only if `false`.
   */
  _lineText;
  /**
   * used only if `_emitBinaryTokens` is false.
   */
  _tokens;
  /**
   * used only if `_emitBinaryTokens` is true.
   */
  _binaryTokens;
  _lastTokenEndIndex;
  _tokenTypeOverrides;
  produce(e, t) {
    this.produceFromScopes(e.contentNameScopesList, t);
  }
  produceFromScopes(e, t) {
    if (this._lastTokenEndIndex >= t)
      return;
    if (this._emitBinaryTokens) {
      let r = e?.tokenAttributes ?? 0, i = !1;
      if (this.balancedBracketSelectors?.matchesAlways && (i = !0), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
        const o = e?.getScopeNames() ?? [];
        for (const s of this._tokenTypeOverrides)
          s.matcher(o) && (r = dh.set(
            r,
            0,
            s.type,
            null,
            -1,
            0,
            0
          ));
        this.balancedBracketSelectors && (i = this.balancedBracketSelectors.match(o));
      }
      if (i && (r = dh.set(
        r,
        0,
        8,
        i,
        -1,
        0,
        0
      )), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === r) {
        this._lastTokenEndIndex = t;
        return;
      }
      this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(r), this._lastTokenEndIndex = t;
      return;
    }
    const n = e?.getScopeNames() ?? [];
    this._tokens.push({
      startIndex: this._lastTokenEndIndex,
      endIndex: t,
      // value: lineText.substring(lastTokenEndIndex, endIndex),
      scopes: n
    }), this._lastTokenEndIndex = t;
  }
  getResult(e, t) {
    return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === t - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(e, t), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
  }
  getBinaryResult(e, t) {
    this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === t - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(e, t), this._binaryTokens[this._binaryTokens.length - 2] = 0);
    const n = new Uint32Array(this._binaryTokens.length);
    for (let r = 0, i = this._binaryTokens.length; r < i; r++)
      n[r] = this._binaryTokens[r];
    return n;
  }
}, c_e = class {
  constructor(e, t) {
    this._onigLib = t, this._theme = e;
  }
  _grammars = /* @__PURE__ */ new Map();
  _rawGrammars = /* @__PURE__ */ new Map();
  _injectionGrammars = /* @__PURE__ */ new Map();
  _theme;
  dispose() {
    for (const e of this._grammars.values())
      e.dispose();
  }
  setTheme(e) {
    this._theme = e;
  }
  getColorMap() {
    return this._theme.getColorMap();
  }
  /**
   * Add `grammar` to registry and return a list of referenced scope names
   */
  addGrammar(e, t) {
    this._rawGrammars.set(e.scopeName, e), t && this._injectionGrammars.set(e.scopeName, t);
  }
  /**
   * Lookup a raw grammar.
   */
  lookup(e) {
    return this._rawGrammars.get(e);
  }
  /**
   * Returns the injections for the given grammar
   */
  injections(e) {
    return this._injectionGrammars.get(e);
  }
  /**
   * Get the default theme settings
   */
  getDefaults() {
    return this._theme.getDefaults();
  }
  /**
   * Match a scope in the theme.
   */
  themeMatch(e) {
    return this._theme.match(e);
  }
  /**
   * Lookup a grammar.
   */
  grammarForScopeName(e, t, n, r, i) {
    if (!this._grammars.has(e)) {
      let o = this._rawGrammars.get(e);
      if (!o)
        return null;
      this._grammars.set(e, i_e(
        e,
        o,
        t,
        n,
        r,
        i,
        this,
        this._onigLib
      ));
    }
    return this._grammars.get(e);
  }
}, u_e = class {
  _options;
  _syncRegistry;
  _ensureGrammarCache;
  constructor(t) {
    this._options = t, this._syncRegistry = new c_e(
      jb.createFromRawTheme(t.theme, t.colorMap),
      t.onigLib
    ), this._ensureGrammarCache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._syncRegistry.dispose();
  }
  /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */
  setTheme(t, n) {
    this._syncRegistry.setTheme(jb.createFromRawTheme(t, n));
  }
  /**
   * Returns a lookup array for color ids.
   */
  getColorMap() {
    return this._syncRegistry.getColorMap();
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithEmbeddedLanguages(t, n, r) {
    return this.loadGrammarWithConfiguration(t, n, { embeddedLanguages: r });
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithConfiguration(t, n, r) {
    return this._loadGrammar(
      t,
      n,
      r.embeddedLanguages,
      r.tokenTypes,
      new a_e(
        r.balancedBracketSelectors || [],
        r.unbalancedBracketSelectors || []
      )
    );
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */
  loadGrammar(t) {
    return this._loadGrammar(t, 0, null, null, null);
  }
  _loadGrammar(t, n, r, i, o) {
    const s = new BEe(this._syncRegistry, t);
    for (; s.Q.length > 0; )
      s.Q.map((a) => this._loadSingleGrammar(a.scopeName)), s.processQueue();
    return this._grammarForScopeName(
      t,
      n,
      r,
      i,
      o
    );
  }
  _loadSingleGrammar(t) {
    this._ensureGrammarCache.has(t) || (this._doLoadSingleGrammar(t), this._ensureGrammarCache.set(t, !0));
  }
  _doLoadSingleGrammar(t) {
    const n = this._options.loadGrammar(t);
    if (n) {
      const r = typeof this._options.getInjections == "function" ? this._options.getInjections(t) : void 0;
      this._syncRegistry.addGrammar(n, r);
    }
  }
  /**
   * Adds a rawGrammar.
   */
  addGrammar(t, n = [], r = 0, i = null) {
    return this._syncRegistry.addGrammar(t, n), this._grammarForScopeName(t.scopeName, r, i);
  }
  /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */
  _grammarForScopeName(t, n = 0, r = null, i = null, o = null) {
    return this._syncRegistry.grammarForScopeName(
      t,
      n,
      r,
      i,
      o
    );
  }
}, Y_ = Z_.NULL;
const d_e = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], f_e = /["&'<>`]/g, h_e = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, p_e = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), m_e = /[|\\{}()[\]^$+*?.]/g, qz = /* @__PURE__ */ new WeakMap();
function g_e(e, t) {
  if (e = e.replace(
    t.subset ? y_e(t.subset) : f_e,
    r
  ), t.subset || t.escapeOnly)
    return e;
  return e.replace(h_e, n).replace(p_e, r);
  function n(i, o, s) {
    return t.format(
      (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
      s.charCodeAt(o + 2),
      t
    );
  }
  function r(i, o, s) {
    return t.format(
      i.charCodeAt(0),
      s.charCodeAt(o + 1),
      t
    );
  }
}
function y_e(e) {
  let t = qz.get(e);
  return t || (t = v_e(e), qz.set(e, t)), t;
}
function v_e(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t.push(e[n].replace(m_e, "\\$&"));
  return new RegExp("(?:" + t.join("|") + ")", "g");
}
const b_e = /[\dA-Fa-f]/;
function x_e(e, t, n) {
  const r = "&#x" + e.toString(16).toUpperCase();
  return n && t && !b_e.test(String.fromCharCode(t)) ? r : r + ";";
}
const w_e = /\d/;
function S_e(e, t, n) {
  const r = "&#" + String(e);
  return n && t && !w_e.test(String.fromCharCode(t)) ? r : r + ";";
}
const k_e = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], RC = {
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  fnof: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  bull: "",
  hellip: "",
  prime: "",
  Prime: "",
  oline: "",
  frasl: "",
  weierp: "",
  image: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: "",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  circ: "",
  tilde: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  permil: "",
  lsaquo: "",
  rsaquo: "",
  euro: ""
}, C_e = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], e7 = {}.hasOwnProperty, X_ = {};
let Wv;
for (Wv in RC)
  e7.call(RC, Wv) && (X_[RC[Wv]] = Wv);
const E_e = /[^\dA-Za-z]/;
function __e(e, t, n, r) {
  const i = String.fromCharCode(e);
  if (e7.call(X_, i)) {
    const o = X_[i], s = "&" + o;
    return n && k_e.includes(o) && !C_e.includes(o) && (!r || t && t !== 61 && E_e.test(String.fromCharCode(t))) ? s : s + ";";
  }
  return "";
}
function T_e(e, t, n) {
  let r = x_e(e, t, n.omitOptionalSemicolons), i;
  if ((n.useNamedReferences || n.useShortestReferences) && (i = __e(
    e,
    t,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !i) && n.useShortestReferences) {
    const o = S_e(e, t, n.omitOptionalSemicolons);
    o.length < r.length && (r = o);
  }
  return i && (!n.useShortestReferences || i.length < r.length) ? i : r;
}
function Xf(e, t) {
  return g_e(e, Object.assign({ format: T_e }, t));
}
const A_e = /^>|^->|<!--|-->|--!>|<!-$/g, M_e = [">"], N_e = ["<", ">"];
function R_e(e, t, n, r) {
  return r.settings.bogusComments ? "<?" + Xf(
    e.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: M_e
    })
  ) + ">" : "<!--" + e.value.replace(A_e, i) + "-->";
  function i(o) {
    return Xf(
      o,
      Object.assign({}, r.settings.characterReferences, {
        subset: N_e
      })
    );
  }
}
function O_e(e, t, n, r) {
  return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>";
}
const Pr = n7(1), t7 = n7(-1), D_e = [];
function n7(e) {
  return t;
  function t(n, r, i) {
    const o = n ? n.children : D_e;
    let s = (r || 0) + e, a = o[s];
    if (!i)
      for (; a && _w(a); )
        s += e, a = o[s];
    return a;
  }
}
const P_e = {}.hasOwnProperty;
function r7(e) {
  return t;
  function t(n, r, i) {
    return P_e.call(e, n.tagName) && e[n.tagName](n, r, i);
  }
}
const ZM = r7({
  body: I_e,
  caption: OC,
  colgroup: OC,
  dd: $_e,
  dt: B_e,
  head: OC,
  html: j_e,
  li: L_e,
  optgroup: U_e,
  option: F_e,
  p: z_e,
  rp: Gz,
  rt: Gz,
  tbody: H_e,
  td: Kz,
  tfoot: W_e,
  th: Kz,
  thead: V_e,
  tr: q_e
});
function OC(e, t, n) {
  const r = Pr(n, t, !0);
  return !r || r.type !== "comment" && !(r.type === "text" && _w(r.value.charAt(0)));
}
function j_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type !== "comment";
}
function I_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type !== "comment";
}
function z_e(e, t, n) {
  const r = Pr(n, t);
  return r ? r.type === "element" && (r.tagName === "address" || r.tagName === "article" || r.tagName === "aside" || r.tagName === "blockquote" || r.tagName === "details" || r.tagName === "div" || r.tagName === "dl" || r.tagName === "fieldset" || r.tagName === "figcaption" || r.tagName === "figure" || r.tagName === "footer" || r.tagName === "form" || r.tagName === "h1" || r.tagName === "h2" || r.tagName === "h3" || r.tagName === "h4" || r.tagName === "h5" || r.tagName === "h6" || r.tagName === "header" || r.tagName === "hgroup" || r.tagName === "hr" || r.tagName === "main" || r.tagName === "menu" || r.tagName === "nav" || r.tagName === "ol" || r.tagName === "p" || r.tagName === "pre" || r.tagName === "section" || r.tagName === "table" || r.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function L_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && r.tagName === "li";
}
function B_e(e, t, n) {
  const r = Pr(n, t);
  return !!(r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd"));
}
function $_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function Gz(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && (r.tagName === "rp" || r.tagName === "rt");
}
function U_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && r.tagName === "optgroup";
}
function F_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup");
}
function V_e(e, t, n) {
  const r = Pr(n, t);
  return !!(r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot"));
}
function H_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function W_e(e, t, n) {
  return !Pr(n, t);
}
function q_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && r.tagName === "tr";
}
function Kz(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && (r.tagName === "td" || r.tagName === "th");
}
const G_e = r7({
  body: Y_e,
  colgroup: X_e,
  head: Z_e,
  html: K_e,
  tbody: J_e
});
function K_e(e) {
  const t = Pr(e, -1);
  return !t || t.type !== "comment";
}
function Z_e(e) {
  const t = /* @__PURE__ */ new Set();
  for (const r of e.children)
    if (r.type === "element" && (r.tagName === "base" || r.tagName === "title")) {
      if (t.has(r.tagName)) return !1;
      t.add(r.tagName);
    }
  const n = e.children[0];
  return !n || n.type === "element";
}
function Y_e(e) {
  const t = Pr(e, -1, !0);
  return !t || t.type !== "comment" && !(t.type === "text" && _w(t.value.charAt(0))) && !(t.type === "element" && (t.tagName === "meta" || t.tagName === "link" || t.tagName === "script" || t.tagName === "style" || t.tagName === "template"));
}
function X_e(e, t, n) {
  const r = t7(n, t), i = Pr(e, -1, !0);
  return n && r && r.type === "element" && r.tagName === "colgroup" && ZM(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "col");
}
function J_e(e, t, n) {
  const r = t7(n, t), i = Pr(e, -1);
  return n && r && r.type === "element" && (r.tagName === "thead" || r.tagName === "tbody") && ZM(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "tr");
}
const qv = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function Q_e(e, t, n, r) {
  const i = r.schema, o = i.space === "svg" ? !1 : r.settings.omitOptionalTags;
  let s = i.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(e.tagName.toLowerCase());
  const a = [];
  let c;
  i.space === "html" && e.tagName === "svg" && (r.schema = Qg);
  const u = eTe(r, e.properties), f = r.all(
    i.space === "html" && e.tagName === "template" ? e.content : e
  );
  return r.schema = i, f && (s = !1), (u || !o || !G_e(e, t, n)) && (a.push("<", e.tagName, u ? " " + u : ""), s && (i.space === "svg" || r.settings.closeSelfClosing) && (c = u.charAt(u.length - 1), (!r.settings.tightSelfClosing || c === "/" || c && c !== '"' && c !== "'") && a.push(" "), a.push("/")), a.push(">")), a.push(f), !s && (!o || !ZM(e, t, n)) && a.push("</" + e.tagName + ">"), a.join("");
}
function eTe(e, t) {
  const n = [];
  let r = -1, i;
  if (t) {
    for (i in t)
      if (t[i] !== null && t[i] !== void 0) {
        const o = tTe(e, i, t[i]);
        o && n.push(o);
      }
  }
  for (; ++r < n.length; ) {
    const o = e.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : void 0;
    r !== n.length - 1 && o !== '"' && o !== "'" && (n[r] += " ");
  }
  return n.join("");
}
function tTe(e, t, n) {
  const r = LF(e.schema, t), i = e.settings.allowParseErrors && e.schema.space === "html" ? 0 : 1, o = e.settings.allowDangerousCharacters ? 0 : 1;
  let s = e.quote, a;
  if (r.overloadedBoolean && (n === r.attribute || n === "") ? n = !0 : (r.boolean || r.overloadedBoolean) && (typeof n != "string" || n === r.attribute || n === "") && (n = !!n), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const c = Xf(
    r.attribute,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: qv.name[i][o]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (r.commaSeparated ? NF : $F)(n, {
    padLeft: !e.settings.tightCommaSeparatedLists
  }) : String(n), e.settings.collapseEmptyAttributes && !n) ? c : (e.settings.preferUnquoted && (a = Xf(
    n,
    Object.assign({}, e.settings.characterReferences, {
      attribute: !0,
      subset: qv.unquoted[i][o]
    })
  )), a !== n && (e.settings.quoteSmart && Db(n, s) > Db(n, e.alternative) && (s = e.alternative), a = s + Xf(
    n,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (s === "'" ? qv.single : qv.double)[i][o],
      attribute: !0
    })
  ) + s), c + (a && "=" + a));
}
const nTe = ["<", "&"];
function i7(e, t, n, r) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? e.value : Xf(
    e.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: nTe
    })
  );
}
function rTe(e, t, n, r) {
  return r.settings.allowDangerousHtml ? e.value : i7(e, t, n, r);
}
function iTe(e, t, n, r) {
  return r.all(e);
}
const oTe = Qke("type", {
  invalid: sTe,
  unknown: aTe,
  handlers: { comment: R_e, doctype: O_e, element: Q_e, raw: rTe, root: iTe, text: i7 }
});
function sTe(e) {
  throw new Error("Expected node, not `" + e + "`");
}
function aTe(e) {
  const t = (
    /** @type {Nodes} */
    e
  );
  throw new Error("Cannot compile unknown node `" + t.type + "`");
}
const lTe = {}, cTe = {}, uTe = [];
function dTe(e, t) {
  const n = t || lTe, r = n.quote || '"', i = r === '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
  return {
    one: fTe,
    all: hTe,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || d_e,
      characterReferences: n.characterReferences || cTe,
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? Qg : BF,
    quote: r,
    alternative: i
  }.one(
    Array.isArray(e) ? { type: "root", children: e } : e,
    void 0,
    void 0
  );
}
function fTe(e, t, n) {
  return oTe(e, t, n, this);
}
function hTe(e) {
  const t = [], n = e && e.children || uTe;
  let r = -1;
  for (; ++r < n.length; )
    t[r] = this.one(n[r], r, e);
  return t.join("");
}
function $b(e, t) {
  const n = typeof e == "string" ? {} : { ...e.colorReplacements }, r = typeof e == "string" ? e : e.name;
  for (const [i, o] of Object.entries(t?.colorReplacements || {}))
    typeof o == "string" ? n[i] = o : i === r && Object.assign(n, o);
  return n;
}
function mc(e, t) {
  return e && (t?.[e?.toLowerCase()] || e);
}
function pTe(e) {
  return Array.isArray(e) ? e : [e];
}
async function o7(e) {
  return Promise.resolve(typeof e == "function" ? e() : e).then((t) => t.default || t);
}
function YM(e) {
  return !e || ["plaintext", "txt", "text", "plain"].includes(e);
}
function s7(e) {
  return e === "ansi" || YM(e);
}
function XM(e) {
  return e === "none";
}
function a7(e) {
  return XM(e);
}
function l7(e, t) {
  if (!t)
    return e;
  e.properties ||= {}, e.properties.class ||= [], typeof e.properties.class == "string" && (e.properties.class = e.properties.class.split(/\s+/g)), Array.isArray(e.properties.class) || (e.properties.class = []);
  const n = Array.isArray(t) ? t : t.split(/\s+/g);
  for (const r of n)
    r && !e.properties.class.includes(r) && e.properties.class.push(r);
  return e;
}
function Ow(e, t = !1) {
  if (e.length === 0)
    return [["", 0]];
  const n = e.split(/(\r?\n)/g);
  let r = 0;
  const i = [];
  for (let o = 0; o < n.length; o += 2) {
    const s = t ? n[o] + (n[o + 1] || "") : n[o];
    i.push([s, r]), r += n[o].length, r += n[o + 1]?.length || 0;
  }
  return i;
}
function mTe(e) {
  const t = Ow(e, !0).map(([i]) => i);
  function n(i) {
    if (i === e.length)
      return {
        line: t.length - 1,
        character: t[t.length - 1].length
      };
    let o = i, s = 0;
    for (const a of t) {
      if (o < a.length)
        break;
      o -= a.length, s++;
    }
    return { line: s, character: o };
  }
  function r(i, o) {
    let s = 0;
    for (let a = 0; a < i; a++)
      s += t[a].length;
    return s += o, s;
  }
  return {
    lines: t,
    indexToPos: n,
    posToIndex: r
  };
}
function gTe(e, t, n) {
  const r = /* @__PURE__ */ new Set();
  for (const o of e.matchAll(/:?lang=["']([^"']+)["']/g)) {
    const s = o[1].toLowerCase().trim();
    s && r.add(s);
  }
  for (const o of e.matchAll(/(?:```|~~~)([\w-]+)/g)) {
    const s = o[1].toLowerCase().trim();
    s && r.add(s);
  }
  for (const o of e.matchAll(/\\begin\{([\w-]+)\}/g)) {
    const s = o[1].toLowerCase().trim();
    s && r.add(s);
  }
  for (const o of e.matchAll(/<script\s+(?:type|lang)=["']([^"']+)["']/gi)) {
    const s = o[1].toLowerCase().trim(), a = s.includes("/") ? s.split("/").pop() : s;
    a && r.add(a);
  }
  if (!n)
    return Array.from(r);
  const i = n.getBundledLanguages();
  return Array.from(r).filter((o) => o && i[o]);
}
const JM = "light-dark()", yTe = ["color", "background-color"];
function vTe(e, t) {
  let n = 0;
  const r = [];
  for (const i of t)
    i > n && r.push({
      ...e,
      content: e.content.slice(n, i),
      offset: e.offset + n
    }), n = i;
  return n < e.content.length && r.push({
    ...e,
    content: e.content.slice(n),
    offset: e.offset + n
  }), r;
}
function bTe(e, t) {
  const n = Array.from(t instanceof Set ? t : new Set(t)).sort((r, i) => r - i);
  return n.length ? e.map((r) => r.flatMap((i) => {
    const o = n.filter((s) => i.offset < s && s < i.offset + i.content.length).map((s) => s - i.offset).sort((s, a) => s - a);
    return o.length ? vTe(i, o) : i;
  })) : e;
}
function xTe(e, t, n, r, i = "css-vars") {
  const o = {
    content: e.content,
    explanation: e.explanation,
    offset: e.offset
  }, s = t.map((f) => Ub(e.variants[f])), a = new Set(s.flatMap((f) => Object.keys(f))), c = {}, u = (f, h) => {
    const m = h === "color" ? "" : h === "background-color" ? "-bg" : `-${h}`;
    return n + t[f] + (h === "color" ? "" : m);
  };
  return s.forEach((f, h) => {
    for (const m of a) {
      const g = f[m] || "inherit";
      if (h === 0 && r && yTe.includes(m))
        if (r === JM && s.length > 1) {
          const b = t.findIndex((_) => _ === "light"), x = t.findIndex((_) => _ === "dark");
          if (b === -1 || x === -1)
            throw new kr('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
          const w = s[b][m] || "inherit", S = s[x][m] || "inherit";
          c[m] = `light-dark(${w}, ${S})`, i === "css-vars" && (c[u(h, m)] = g);
        } else
          c[m] = g;
      else
        i === "css-vars" && (c[u(h, m)] = g);
    }
  }), o.htmlStyle = c, o;
}
function Ub(e) {
  const t = {};
  if (e.color && (t.color = e.color), e.bgColor && (t["background-color"] = e.bgColor), e.fontStyle) {
    e.fontStyle & pi.Italic && (t["font-style"] = "italic"), e.fontStyle & pi.Bold && (t["font-weight"] = "bold");
    const n = [];
    e.fontStyle & pi.Underline && n.push("underline"), e.fontStyle & pi.Strikethrough && n.push("line-through"), n.length && (t["text-decoration"] = n.join(" "));
  }
  return t;
}
function J_(e) {
  return typeof e == "string" ? e : Object.entries(e).map(([t, n]) => `${t}:${n}`).join(";");
}
const c7 = /* @__PURE__ */ new WeakMap();
function Dw(e, t) {
  c7.set(e, t);
}
function pg(e) {
  return c7.get(e);
}
class Uh {
  /**
   * Theme to Stack mapping
   */
  _stacks = {};
  lang;
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(t, n) {
    return new Uh(
      Object.fromEntries(pTe(n).map((r) => [r, Y_])),
      t
    );
  }
  constructor(...t) {
    if (t.length === 2) {
      const [n, r] = t;
      this.lang = r, this._stacks = n;
    } else {
      const [n, r, i] = t;
      this.lang = r, this._stacks = { [i]: n };
    }
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(t = this.theme) {
    return this._stacks[t];
  }
  getScopes(t = this.theme) {
    return wTe(this._stacks[t]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.getScopes()
    };
  }
}
function wTe(e) {
  const t = [], n = /* @__PURE__ */ new Set();
  function r(i) {
    if (n.has(i))
      return;
    n.add(i);
    const o = i?.nameScopesList?.scopeName;
    o && t.push(o), i.parent && r(i.parent);
  }
  return r(e), t;
}
function STe(e, t) {
  if (!(e instanceof Uh))
    throw new kr("Invalid grammar state");
  return e.getInternalStack(t);
}
function kTe() {
  const e = /* @__PURE__ */ new WeakMap();
  function t(n) {
    if (!e.has(n.meta)) {
      let r = function(s) {
        if (typeof s == "number") {
          if (s < 0 || s > n.source.length)
            throw new kr(`Invalid decoration offset: ${s}. Code length: ${n.source.length}`);
          return {
            ...i.indexToPos(s),
            offset: s
          };
        } else {
          const a = i.lines[s.line];
          if (a === void 0)
            throw new kr(`Invalid decoration position ${JSON.stringify(s)}. Lines length: ${i.lines.length}`);
          let c = s.character;
          if (c < 0 && (c = a.length + c), c < 0 || c > a.length)
            throw new kr(`Invalid decoration position ${JSON.stringify(s)}. Line ${s.line} length: ${a.length}`);
          return {
            ...s,
            character: c,
            offset: i.posToIndex(s.line, c)
          };
        }
      };
      const i = mTe(n.source), o = (n.options.decorations || []).map((s) => ({
        ...s,
        start: r(s.start),
        end: r(s.end)
      }));
      CTe(o), e.set(n.meta, {
        decorations: o,
        converter: i,
        source: n.source
      });
    }
    return e.get(n.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(n) {
      if (!this.options.decorations?.length)
        return;
      const i = t(this).decorations.flatMap((s) => [s.start.offset, s.end.offset]);
      return bTe(n, i);
    },
    code(n) {
      if (!this.options.decorations?.length)
        return;
      const r = t(this), i = Array.from(n.children).filter((f) => f.type === "element" && f.tagName === "span");
      if (i.length !== r.converter.lines.length)
        throw new kr(`Number of lines in code element (${i.length}) does not match the number of lines in the source (${r.converter.lines.length}). Failed to apply decorations.`);
      function o(f, h, m, g) {
        const b = i[f];
        let x = "", w = -1, S = -1;
        if (h === 0 && (w = 0), m === 0 && (S = 0), m === Number.POSITIVE_INFINITY && (S = b.children.length), w === -1 || S === -1)
          for (let M = 0; M < b.children.length; M++)
            x += u7(b.children[M]), w === -1 && x.length === h && (w = M + 1), S === -1 && x.length === m && (S = M + 1);
        if (w === -1)
          throw new kr(`Failed to find start index for decoration ${JSON.stringify(g.start)}`);
        if (S === -1)
          throw new kr(`Failed to find end index for decoration ${JSON.stringify(g.end)}`);
        const _ = b.children.slice(w, S);
        if (!g.alwaysWrap && _.length === b.children.length)
          a(b, g, "line");
        else if (!g.alwaysWrap && _.length === 1 && _[0].type === "element")
          a(_[0], g, "token");
        else {
          const M = {
            type: "element",
            tagName: "span",
            properties: {},
            children: _
          };
          a(M, g, "wrapper"), b.children.splice(w, _.length, M);
        }
      }
      function s(f, h) {
        i[f] = a(i[f], h, "line");
      }
      function a(f, h, m) {
        const g = h.properties || {}, b = h.transform || ((x) => x);
        return f.tagName = h.tagName || "span", f.properties = {
          ...f.properties,
          ...g,
          class: f.properties.class
        }, h.properties?.class && l7(f, h.properties.class), f = b(f, m) || f, f;
      }
      const c = [], u = r.decorations.sort((f, h) => h.start.offset - f.start.offset || f.end.offset - h.end.offset);
      for (const f of u) {
        const { start: h, end: m } = f;
        if (h.line === m.line)
          o(h.line, h.character, m.character, f);
        else if (h.line < m.line) {
          o(h.line, h.character, Number.POSITIVE_INFINITY, f);
          for (let g = h.line + 1; g < m.line; g++)
            c.unshift(() => s(g, f));
          o(m.line, 0, m.character, f);
        }
      }
      c.forEach((f) => f());
    }
  };
}
function CTe(e) {
  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    if (n.start.offset > n.end.offset)
      throw new kr(`Invalid decoration range: ${JSON.stringify(n.start)} - ${JSON.stringify(n.end)}`);
    for (let r = t + 1; r < e.length; r++) {
      const i = e[r], o = n.start.offset <= i.start.offset && i.start.offset < n.end.offset, s = n.start.offset < i.end.offset && i.end.offset <= n.end.offset, a = i.start.offset <= n.start.offset && n.start.offset < i.end.offset, c = i.start.offset < n.end.offset && n.end.offset <= i.end.offset;
      if (o || s || a || c) {
        if (o && s || a && c || a && n.start.offset === n.end.offset || s && i.start.offset === i.end.offset)
          continue;
        throw new kr(`Decorations ${JSON.stringify(n.start)} and ${JSON.stringify(i.start)} intersect.`);
      }
    }
  }
}
function u7(e) {
  return e.type === "text" ? e.value : e.type === "element" ? e.children.map(u7).join("") : "";
}
const ETe = [
  /* @__PURE__ */ kTe()
];
function Fb(e) {
  const t = _Te(e.transformers || []);
  return [
    ...t.pre,
    ...t.normal,
    ...t.post,
    ...ETe
  ];
}
function _Te(e) {
  const t = [], n = [], r = [];
  for (const i of e)
    switch (i.enforce) {
      case "pre":
        t.push(i);
        break;
      case "post":
        n.push(i);
        break;
      default:
        r.push(i);
    }
  return { pre: t, post: n, normal: r };
}
var ju = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
], DC = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  8: "hidden",
  9: "strikethrough"
};
function TTe(e, t) {
  const n = e.indexOf("\x1B", t);
  if (n !== -1 && e[n + 1] === "[") {
    const r = e.indexOf("m", n);
    if (r !== -1)
      return {
        sequence: e.substring(n + 2, r).split(";"),
        startPosition: n,
        position: r + 1
      };
  }
  return {
    position: e.length
  };
}
function Zz(e) {
  const t = e.shift();
  if (t === "2") {
    const n = e.splice(0, 3).map((r) => Number.parseInt(r));
    return n.length !== 3 || n.some((r) => Number.isNaN(r)) ? void 0 : {
      type: "rgb",
      rgb: n
    };
  } else if (t === "5") {
    const n = e.shift();
    if (n)
      return { type: "table", index: Number(n) };
  }
}
function ATe(e) {
  const t = [];
  for (; e.length > 0; ) {
    const n = e.shift();
    if (!n)
      continue;
    const r = Number.parseInt(n);
    if (!Number.isNaN(r))
      if (r === 0)
        t.push({ type: "resetAll" });
      else if (r <= 9)
        DC[r] && t.push({
          type: "setDecoration",
          value: DC[r]
        });
      else if (r <= 29) {
        const i = DC[r - 20];
        i && (t.push({
          type: "resetDecoration",
          value: i
        }), i === "dim" && t.push({
          type: "resetDecoration",
          value: "bold"
        }));
      } else if (r <= 37)
        t.push({
          type: "setForegroundColor",
          value: { type: "named", name: ju[r - 30] }
        });
      else if (r === 38) {
        const i = Zz(e);
        i && t.push({
          type: "setForegroundColor",
          value: i
        });
      } else if (r === 39)
        t.push({
          type: "resetForegroundColor"
        });
      else if (r <= 47)
        t.push({
          type: "setBackgroundColor",
          value: { type: "named", name: ju[r - 40] }
        });
      else if (r === 48) {
        const i = Zz(e);
        i && t.push({
          type: "setBackgroundColor",
          value: i
        });
      } else r === 49 ? t.push({
        type: "resetBackgroundColor"
      }) : r === 53 ? t.push({
        type: "setDecoration",
        value: "overline"
      }) : r === 55 ? t.push({
        type: "resetDecoration",
        value: "overline"
      }) : r >= 90 && r <= 97 ? t.push({
        type: "setForegroundColor",
        value: { type: "named", name: ju[r - 90 + 8] }
      }) : r >= 100 && r <= 107 && t.push({
        type: "setBackgroundColor",
        value: { type: "named", name: ju[r - 100 + 8] }
      });
  }
  return t;
}
function MTe() {
  let e = null, t = null, n = /* @__PURE__ */ new Set();
  return {
    parse(r) {
      const i = [];
      let o = 0;
      do {
        const s = TTe(r, o), a = s.sequence ? r.substring(o, s.startPosition) : r.substring(o);
        if (a.length > 0 && i.push({
          value: a,
          foreground: e,
          background: t,
          decorations: new Set(n)
        }), s.sequence) {
          const c = ATe(s.sequence);
          for (const u of c)
            u.type === "resetAll" ? (e = null, t = null, n.clear()) : u.type === "resetForegroundColor" ? e = null : u.type === "resetBackgroundColor" ? t = null : u.type === "resetDecoration" && n.delete(u.value);
          for (const u of c)
            u.type === "setForegroundColor" ? e = u.value : u.type === "setBackgroundColor" ? t = u.value : u.type === "setDecoration" && n.add(u.value);
        }
        o = s.position;
      } while (o < r.length);
      return i;
    }
  };
}
var NTe = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function RTe(e = NTe) {
  function t(a) {
    return e[a];
  }
  function n(a) {
    return `#${a.map((c) => Math.max(0, Math.min(c, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let r;
  function i() {
    if (r)
      return r;
    r = [];
    for (let u = 0; u < ju.length; u++)
      r.push(t(ju[u]));
    let a = [0, 95, 135, 175, 215, 255];
    for (let u = 0; u < 6; u++)
      for (let f = 0; f < 6; f++)
        for (let h = 0; h < 6; h++)
          r.push(n([a[u], a[f], a[h]]));
    let c = 8;
    for (let u = 0; u < 24; u++, c += 10)
      r.push(n([c, c, c]));
    return r;
  }
  function o(a) {
    return i()[a];
  }
  function s(a) {
    switch (a.type) {
      case "named":
        return t(a.name);
      case "rgb":
        return n(a.rgb);
      case "table":
        return o(a.index);
    }
  }
  return {
    value: s
  };
}
const OTe = {
  black: "#000000",
  red: "#cd3131",
  green: "#0DBC79",
  yellow: "#E5E510",
  blue: "#2472C8",
  magenta: "#BC3FBC",
  cyan: "#11A8CD",
  white: "#E5E5E5",
  brightBlack: "#666666",
  brightRed: "#F14C4C",
  brightGreen: "#23D18B",
  brightYellow: "#F5F543",
  brightBlue: "#3B8EEA",
  brightMagenta: "#D670D6",
  brightCyan: "#29B8DB",
  brightWhite: "#FFFFFF"
};
function DTe(e, t, n) {
  const r = $b(e, n), i = Ow(t), o = Object.fromEntries(
    ju.map((c) => {
      const u = `terminal.ansi${c[0].toUpperCase()}${c.substring(1)}`, f = e.colors?.[u];
      return [c, f || OTe[c]];
    })
  ), s = RTe(o), a = MTe();
  return i.map(
    (c) => a.parse(c[0]).map((u) => {
      let f, h;
      u.decorations.has("reverse") ? (f = u.background ? s.value(u.background) : e.bg, h = u.foreground ? s.value(u.foreground) : e.fg) : (f = u.foreground ? s.value(u.foreground) : e.fg, h = u.background ? s.value(u.background) : void 0), f = mc(f, r), h = mc(h, r), u.decorations.has("dim") && (f = PTe(f));
      let m = pi.None;
      return u.decorations.has("bold") && (m |= pi.Bold), u.decorations.has("italic") && (m |= pi.Italic), u.decorations.has("underline") && (m |= pi.Underline), u.decorations.has("strikethrough") && (m |= pi.Strikethrough), {
        content: u.value,
        offset: c[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color: f,
        bgColor: h,
        fontStyle: m
      };
    })
  );
}
function PTe(e) {
  const t = e.match(/#([0-9a-f]{3,8})/i);
  if (t) {
    const r = t[1];
    if (r.length === 8) {
      const i = Math.round(Number.parseInt(r.slice(6, 8), 16) / 2).toString(16).padStart(2, "0");
      return `#${r.slice(0, 6)}${i}`;
    } else {
      if (r.length === 6)
        return `#${r}80`;
      if (r.length === 4) {
        const i = r[0], o = r[1], s = r[2], a = r[3], c = Math.round(Number.parseInt(`${a}${a}`, 16) / 2).toString(16).padStart(2, "0");
        return `#${i}${i}${o}${o}${s}${s}${c}`;
      } else if (r.length === 3) {
        const i = r[0], o = r[1], s = r[2];
        return `#${i}${i}${o}${o}${s}${s}80`;
      }
    }
  }
  const n = e.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  return n ? `var(${n[1]}-dim)` : e;
}
function QM(e, t, n = {}) {
  const {
    theme: r = e.getLoadedThemes()[0]
  } = n, i = e.resolveLangAlias(n.lang || "text");
  if (YM(i) || XM(r))
    return Ow(t).map((c) => [{ content: c[0], offset: c[1] }]);
  const { theme: o, colorMap: s } = e.setTheme(r);
  if (i === "ansi")
    return DTe(o, t, n);
  const a = e.getLanguage(n.lang || "text");
  if (n.grammarState) {
    if (n.grammarState.lang !== a.name)
      throw new kr(`Grammar state language "${n.grammarState.lang}" does not match highlight language "${a.name}"`);
    if (!n.grammarState.themes.includes(o.name))
      throw new kr(`Grammar state themes "${n.grammarState.themes}" do not contain highlight theme "${o.name}"`);
  }
  return ITe(t, a, o, s, n);
}
function jTe(...e) {
  if (e.length === 2)
    return pg(e[1]);
  const [t, n, r = {}] = e, {
    lang: i = "text",
    theme: o = t.getLoadedThemes()[0]
  } = r;
  if (YM(i) || XM(o))
    throw new kr("Plain language does not have grammar state");
  if (i === "ansi")
    throw new kr("ANSI language does not have grammar state");
  const { theme: s, colorMap: a } = t.setTheme(o), c = t.getLanguage(i);
  return new Uh(
    eN(n, c, s, a, r).stateStack,
    c.name,
    s.name
  );
}
function ITe(e, t, n, r, i) {
  const o = eN(e, t, n, r, i), s = new Uh(
    o.stateStack,
    t.name,
    n.name
  );
  return Dw(o.tokens, s), o.tokens;
}
function eN(e, t, n, r, i) {
  const o = $b(n, i), {
    tokenizeMaxLineLength: s = 0,
    tokenizeTimeLimit: a = 500
  } = i, c = Ow(e);
  let u = i.grammarState ? STe(i.grammarState, n.name) ?? Y_ : i.grammarContextCode != null ? eN(
    i.grammarContextCode,
    t,
    n,
    r,
    {
      ...i,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : Y_, f = [];
  const h = [];
  for (let m = 0, g = c.length; m < g; m++) {
    const [b, x] = c[m];
    if (b === "") {
      f = [], h.push([]);
      continue;
    }
    if (s > 0 && b.length >= s) {
      f = [], h.push([{
        content: b,
        offset: x,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let w, S, _;
    i.includeExplanation && (w = t.tokenizeLine(b, u, a), S = w.tokens, _ = 0);
    const M = t.tokenizeLine2(b, u, a), N = M.tokens.length / 2;
    for (let P = 0; P < N; P++) {
      const I = M.tokens[2 * P], O = P + 1 < N ? M.tokens[2 * P + 2] : b.length;
      if (I === O)
        continue;
      const L = M.tokens[2 * P + 1], U = mc(
        r[dh.getForeground(L)],
        o
      ), B = dh.getFontStyle(L), G = {
        content: b.substring(I, O),
        offset: x + I,
        color: U,
        fontStyle: B
      };
      if (i.includeExplanation) {
        const Y = [];
        if (i.includeExplanation !== "scopeName")
          for (const ie of n.settings) {
            let ne;
            switch (typeof ie.scope) {
              case "string":
                ne = ie.scope.split(/,/).map((H) => H.trim());
                break;
              case "object":
                ne = ie.scope;
                break;
              default:
                continue;
            }
            Y.push({
              settings: ie,
              selectors: ne.map((H) => H.split(/ /))
            });
          }
        G.explanation = [];
        let he = 0;
        for (; I + he < O; ) {
          const ie = S[_], ne = b.substring(
            ie.startIndex,
            ie.endIndex
          );
          he += ne.length, G.explanation.push({
            content: ne,
            scopes: i.includeExplanation === "scopeName" ? zTe(
              ie.scopes
            ) : LTe(
              Y,
              ie.scopes
            )
          }), _ += 1;
        }
      }
      f.push(G);
    }
    h.push(f), f = [], u = M.ruleStack;
  }
  return {
    tokens: h,
    stateStack: u
  };
}
function zTe(e) {
  return e.map((t) => ({ scopeName: t }));
}
function LTe(e, t) {
  const n = [];
  for (let r = 0, i = t.length; r < i; r++) {
    const o = t[r];
    n[r] = {
      scopeName: o,
      themeMatches: $Te(e, o, t.slice(0, r))
    };
  }
  return n;
}
function Yz(e, t) {
  return e === t || t.substring(0, e.length) === e && t[e.length] === ".";
}
function BTe(e, t, n) {
  if (!Yz(e[e.length - 1], t))
    return !1;
  let r = e.length - 2, i = n.length - 1;
  for (; r >= 0 && i >= 0; )
    Yz(e[r], n[i]) && (r -= 1), i -= 1;
  return r === -1;
}
function $Te(e, t, n) {
  const r = [];
  for (const { selectors: i, settings: o } of e)
    for (const s of i)
      if (BTe(s, t, n)) {
        r.push(o);
        break;
      }
  return r;
}
function d7(e, t, n) {
  const r = Object.entries(n.themes).filter((c) => c[1]).map((c) => ({ color: c[0], theme: c[1] })), i = r.map((c) => {
    const u = QM(e, t, {
      ...n,
      theme: c.theme
    }), f = pg(u), h = typeof c.theme == "string" ? c.theme : c.theme.name;
    return {
      tokens: u,
      state: f,
      theme: h
    };
  }), o = UTe(
    ...i.map((c) => c.tokens)
  ), s = o[0].map(
    (c, u) => c.map((f, h) => {
      const m = {
        content: f.content,
        variants: {},
        offset: f.offset
      };
      return "includeExplanation" in n && n.includeExplanation && (m.explanation = f.explanation), o.forEach((g, b) => {
        const {
          content: x,
          explanation: w,
          offset: S,
          ..._
        } = g[u][h];
        m.variants[r[b].color] = _;
      }), m;
    })
  ), a = i[0].state ? new Uh(
    Object.fromEntries(i.map((c) => [c.theme, c.state?.getInternalStack(c.theme)])),
    i[0].state.lang
  ) : void 0;
  return a && Dw(s, a), s;
}
function UTe(...e) {
  const t = e.map(() => []), n = e.length;
  for (let r = 0; r < e[0].length; r++) {
    const i = e.map((c) => c[r]), o = t.map(() => []);
    t.forEach((c, u) => c.push(o[u]));
    const s = i.map(() => 0), a = i.map((c) => c[0]);
    for (; a.every((c) => c); ) {
      const c = Math.min(...a.map((u) => u.content.length));
      for (let u = 0; u < n; u++) {
        const f = a[u];
        f.content.length === c ? (o[u].push(f), s[u] += 1, a[u] = i[u][s[u]]) : (o[u].push({
          ...f,
          content: f.content.slice(0, c)
        }), a[u] = {
          ...f,
          content: f.content.slice(c),
          offset: f.offset + c
        });
      }
    }
  }
  return t;
}
function Vb(e, t, n) {
  let r, i, o, s, a, c;
  if ("themes" in n) {
    const {
      defaultColor: u = "light",
      cssVariablePrefix: f = "--shiki-",
      colorsRendering: h = "css-vars"
    } = n, m = Object.entries(n.themes).filter((S) => S[1]).map((S) => ({ color: S[0], theme: S[1] })).sort((S, _) => S.color === u ? -1 : _.color === u ? 1 : 0);
    if (m.length === 0)
      throw new kr("`themes` option must not be empty");
    const g = d7(
      e,
      t,
      n
    );
    if (c = pg(g), u && JM !== u && !m.find((S) => S.color === u))
      throw new kr(`\`themes\` option must contain the defaultColor key \`${u}\``);
    const b = m.map((S) => e.getTheme(S.theme)), x = m.map((S) => S.color);
    o = g.map((S) => S.map((_) => xTe(_, x, f, u, h))), c && Dw(o, c);
    const w = m.map((S) => $b(S.theme, n));
    i = Xz(m, b, w, f, u, "fg", h), r = Xz(m, b, w, f, u, "bg", h), s = `shiki-themes ${b.map((S) => S.name).join(" ")}`, a = u ? void 0 : [i, r].join(";");
  } else if ("theme" in n) {
    const u = $b(n.theme, n);
    o = QM(
      e,
      t,
      n
    );
    const f = e.getTheme(n.theme);
    r = mc(f.bg, u), i = mc(f.fg, u), s = f.name, c = pg(o);
  } else
    throw new kr("Invalid options, either `theme` or `themes` must be provided");
  return {
    tokens: o,
    fg: i,
    bg: r,
    themeName: s,
    rootStyle: a,
    grammarState: c
  };
}
function Xz(e, t, n, r, i, o, s) {
  return e.map((a, c) => {
    const u = mc(t[c][o], n[c]) || "inherit", f = `${r + a.color}${o === "bg" ? "-bg" : ""}:${u}`;
    if (c === 0 && i) {
      if (i === JM && e.length > 1) {
        const h = e.findIndex((x) => x.color === "light"), m = e.findIndex((x) => x.color === "dark");
        if (h === -1 || m === -1)
          throw new kr('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
        const g = mc(t[h][o], n[h]) || "inherit", b = mc(t[m][o], n[m]) || "inherit";
        return `light-dark(${g}, ${b});${f}`;
      }
      return u;
    }
    return s === "css-vars" ? f : null;
  }).filter((a) => !!a).join(";");
}
function Hb(e, t, n, r = {
  meta: {},
  options: n,
  codeToHast: (i, o) => Hb(e, i, o),
  codeToTokens: (i, o) => Vb(e, i, o)
}) {
  let i = t;
  for (const b of Fb(n))
    i = b.preprocess?.call(r, i, n) || i;
  let {
    tokens: o,
    fg: s,
    bg: a,
    themeName: c,
    rootStyle: u,
    grammarState: f
  } = Vb(e, i, n);
  const {
    mergeWhitespaces: h = !0,
    mergeSameStyleTokens: m = !1
  } = n;
  h === !0 ? o = VTe(o) : h === "never" && (o = HTe(o)), m && (o = WTe(o));
  const g = {
    ...r,
    get source() {
      return i;
    }
  };
  for (const b of Fb(n))
    o = b.tokens?.call(g, o) || o;
  return FTe(
    o,
    {
      ...n,
      fg: s,
      bg: a,
      themeName: c,
      rootStyle: n.rootStyle === !1 ? !1 : n.rootStyle ?? u
    },
    g,
    f
  );
}
function FTe(e, t, n, r = pg(e)) {
  const i = Fb(t), o = [], s = {
    type: "root",
    children: []
  }, {
    structure: a = "classic",
    tabindex: c = "0"
  } = t, u = {
    class: `shiki ${t.themeName || ""}`
  };
  t.rootStyle !== !1 && (t.rootStyle != null ? u.style = t.rootStyle : u.style = `background-color:${t.bg};color:${t.fg}`), c !== !1 && c != null && (u.tabindex = c.toString());
  for (const [x, w] of Object.entries(t.meta || {}))
    x.startsWith("_") || (u[x] = w);
  let f = {
    type: "element",
    tagName: "pre",
    properties: u,
    children: [],
    data: t.data
  }, h = {
    type: "element",
    tagName: "code",
    properties: {},
    children: o
  };
  const m = [], g = {
    ...n,
    structure: a,
    addClassToHast: l7,
    get source() {
      return n.source;
    },
    get tokens() {
      return e;
    },
    get options() {
      return t;
    },
    get root() {
      return s;
    },
    get pre() {
      return f;
    },
    get code() {
      return h;
    },
    get lines() {
      return m;
    }
  };
  if (e.forEach((x, w) => {
    w && (a === "inline" ? s.children.push({ type: "element", tagName: "br", properties: {}, children: [] }) : a === "classic" && o.push({ type: "text", value: `
` }));
    let S = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    }, _ = 0;
    for (const M of x) {
      let N = {
        type: "element",
        tagName: "span",
        properties: {
          ...M.htmlAttrs
        },
        children: [{ type: "text", value: M.content }]
      };
      const P = J_(M.htmlStyle || Ub(M));
      P && (N.properties.style = P);
      for (const I of i)
        N = I?.span?.call(g, N, w + 1, _, S, M) || N;
      a === "inline" ? s.children.push(N) : a === "classic" && S.children.push(N), _ += M.content.length;
    }
    if (a === "classic") {
      for (const M of i)
        S = M?.line?.call(g, S, w + 1) || S;
      m.push(S), o.push(S);
    } else a === "inline" && m.push(S);
  }), a === "classic") {
    for (const x of i)
      h = x?.code?.call(g, h) || h;
    f.children.push(h);
    for (const x of i)
      f = x?.pre?.call(g, f) || f;
    s.children.push(f);
  } else if (a === "inline") {
    const x = [];
    let w = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    };
    for (const M of s.children)
      M.type === "element" && M.tagName === "br" ? (x.push(w), w = {
        type: "element",
        tagName: "span",
        properties: { class: "line" },
        children: []
      }) : (M.type === "element" || M.type === "text") && w.children.push(M);
    x.push(w);
    let _ = {
      type: "element",
      tagName: "code",
      properties: {},
      children: x
    };
    for (const M of i)
      _ = M?.code?.call(g, _) || _;
    s.children = [];
    for (let M = 0; M < _.children.length; M++) {
      M > 0 && s.children.push({ type: "element", tagName: "br", properties: {}, children: [] });
      const N = _.children[M];
      N.type === "element" && s.children.push(...N.children);
    }
  }
  let b = s;
  for (const x of i)
    b = x?.root?.call(g, b) || b;
  return r && Dw(b, r), b;
}
function VTe(e) {
  return e.map((t) => {
    const n = [];
    let r = "", i;
    return t.forEach((o, s) => {
      const c = !(o.fontStyle && (o.fontStyle & pi.Underline || o.fontStyle & pi.Strikethrough));
      c && o.content.match(/^\s+$/) && t[s + 1] ? (i === void 0 && (i = o.offset), r += o.content) : r ? (c ? n.push({
        ...o,
        offset: i,
        content: r + o.content
      }) : n.push(
        {
          content: r,
          offset: i
        },
        o
      ), i = void 0, r = "") : n.push(o);
    }), n;
  });
}
function HTe(e) {
  return e.map((t) => t.flatMap((n) => {
    if (n.content.match(/^\s+$/))
      return n;
    const r = n.content.match(/^(\s*)(.*?)(\s*)$/);
    if (!r)
      return n;
    const [, i, o, s] = r;
    if (!i && !s)
      return n;
    const a = [{
      ...n,
      offset: n.offset + i.length,
      content: o
    }];
    return i && a.unshift({
      content: i,
      offset: n.offset
    }), s && a.push({
      content: s,
      offset: n.offset + i.length + o.length
    }), a;
  }));
}
function WTe(e) {
  return e.map((t) => {
    const n = [];
    for (const r of t) {
      if (n.length === 0) {
        n.push({ ...r });
        continue;
      }
      const i = n[n.length - 1], o = J_(i.htmlStyle || Ub(i)), s = J_(r.htmlStyle || Ub(r)), a = i.fontStyle && (i.fontStyle & pi.Underline || i.fontStyle & pi.Strikethrough), c = r.fontStyle && (r.fontStyle & pi.Underline || r.fontStyle & pi.Strikethrough);
      !a && !c && o === s ? i.content += r.content : n.push({ ...r });
    }
    return n;
  });
}
const qTe = dTe;
function GTe(e, t, n) {
  const r = {
    meta: {},
    options: n,
    codeToHast: (o, s) => Hb(e, o, s),
    codeToTokens: (o, s) => Vb(e, o, s)
  };
  let i = qTe(Hb(e, t, n, r));
  for (const o of Fb(n))
    i = o.postprocess?.call(r, i, n) || i;
  return i;
}
const Jz = { light: "#333333", dark: "#bbbbbb" }, Qz = { light: "#fffffe", dark: "#1e1e1e" }, eL = "__shiki_resolved";
function tN(e) {
  if (e?.[eL])
    return e;
  const t = {
    ...e
  };
  t.tokenColors && !t.settings && (t.settings = t.tokenColors, delete t.tokenColors), t.type ||= "dark", t.colorReplacements = { ...t.colorReplacements }, t.settings ||= [];
  let { bg: n, fg: r } = t;
  if (!n || !r) {
    const a = t.settings ? t.settings.find((c) => !c.name && !c.scope) : void 0;
    a?.settings?.foreground && (r = a.settings.foreground), a?.settings?.background && (n = a.settings.background), !r && t?.colors?.["editor.foreground"] && (r = t.colors["editor.foreground"]), !n && t?.colors?.["editor.background"] && (n = t.colors["editor.background"]), r || (r = t.type === "light" ? Jz.light : Jz.dark), n || (n = t.type === "light" ? Qz.light : Qz.dark), t.fg = r, t.bg = n;
  }
  t.settings[0] && t.settings[0].settings && !t.settings[0].scope || t.settings.unshift({
    settings: {
      foreground: t.fg,
      background: t.bg
    }
  });
  let i = 0;
  const o = /* @__PURE__ */ new Map();
  function s(a) {
    if (o.has(a))
      return o.get(a);
    i += 1;
    const c = `#${i.toString(16).padStart(8, "0").toLowerCase()}`;
    return t.colorReplacements?.[`#${c}`] ? s(a) : (o.set(a, c), c);
  }
  t.settings = t.settings.map((a) => {
    const c = a.settings?.foreground && !a.settings.foreground.startsWith("#"), u = a.settings?.background && !a.settings.background.startsWith("#");
    if (!c && !u)
      return a;
    const f = {
      ...a,
      settings: {
        ...a.settings
      }
    };
    if (c) {
      const h = s(a.settings.foreground);
      t.colorReplacements[h] = a.settings.foreground, f.settings.foreground = h;
    }
    if (u) {
      const h = s(a.settings.background);
      t.colorReplacements[h] = a.settings.background, f.settings.background = h;
    }
    return f;
  });
  for (const a of Object.keys(t.colors || {}))
    if ((a === "editor.foreground" || a === "editor.background" || a.startsWith("terminal.ansi")) && !t.colors[a]?.startsWith("#")) {
      const c = s(t.colors[a]);
      t.colorReplacements[c] = t.colors[a], t.colors[a] = c;
    }
  return Object.defineProperty(t, eL, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), t;
}
async function f7(e) {
  return Array.from(new Set((await Promise.all(
    e.filter((t) => !s7(t)).map(async (t) => await o7(t).then((n) => Array.isArray(n) ? n : [n]))
  )).flat()));
}
async function h7(e) {
  return (await Promise.all(
    e.map(
      async (n) => a7(n) ? null : tN(await o7(n))
    )
  )).filter((n) => !!n);
}
let KTe = 3;
function ZTe(e, t = 3) {
  t > KTe || console.trace(`[SHIKI DEPRECATE]: ${e}`);
}
let Lf = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
};
function p7(e, t) {
  if (!t)
    return e;
  if (t[e]) {
    const n = /* @__PURE__ */ new Set([e]);
    for (; t[e]; ) {
      if (e = t[e], n.has(e))
        throw new Lf(`Circular alias \`${Array.from(n).join(" -> ")} -> ${e}\``);
      n.add(e);
    }
  }
  return e;
}
class YTe extends u_e {
  constructor(t, n, r, i = {}) {
    super(t), this._resolver = t, this._themes = n, this._langs = r, this._alias = i, this._themes.map((o) => this.loadTheme(o)), this.loadLanguages(this._langs);
  }
  _resolvedThemes = /* @__PURE__ */ new Map();
  _resolvedGrammars = /* @__PURE__ */ new Map();
  _langMap = /* @__PURE__ */ new Map();
  _langGraph = /* @__PURE__ */ new Map();
  _textmateThemeCache = /* @__PURE__ */ new WeakMap();
  _loadedThemesCache = null;
  _loadedLanguagesCache = null;
  getTheme(t) {
    return typeof t == "string" ? this._resolvedThemes.get(t) : this.loadTheme(t);
  }
  loadTheme(t) {
    const n = tN(t);
    return n.name && (this._resolvedThemes.set(n.name, n), this._loadedThemesCache = null), n;
  }
  getLoadedThemes() {
    return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]), this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(t) {
    let n = this._textmateThemeCache.get(t);
    n || (n = jb.createFromRawTheme(t), this._textmateThemeCache.set(t, n)), this._syncRegistry.setTheme(n);
  }
  getGrammar(t) {
    return t = p7(t, this._alias), this._resolvedGrammars.get(t);
  }
  loadLanguage(t) {
    if (this.getGrammar(t.name))
      return;
    const n = new Set(
      [...this._langMap.values()].filter((o) => o.embeddedLangsLazy?.includes(t.name))
    );
    this._resolver.addLanguage(t);
    const r = {
      balancedBracketSelectors: t.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: t.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(t.scopeName, t);
    const i = this.loadGrammarWithConfiguration(t.scopeName, 1, r);
    if (i.name = t.name, this._resolvedGrammars.set(t.name, i), t.aliases && t.aliases.forEach((o) => {
      this._alias[o] = t.name;
    }), this._loadedLanguagesCache = null, n.size)
      for (const o of n)
        this._resolvedGrammars.delete(o.name), this._loadedLanguagesCache = null, this._syncRegistry?._injectionGrammars?.delete(o.scopeName), this._syncRegistry?._grammars?.delete(o.scopeName), this.loadLanguage(this._langMap.get(o.name));
  }
  dispose() {
    super.dispose(), this._resolvedThemes.clear(), this._resolvedGrammars.clear(), this._langMap.clear(), this._langGraph.clear(), this._loadedThemesCache = null;
  }
  loadLanguages(t) {
    for (const i of t)
      this.resolveEmbeddedLanguages(i);
    const n = Array.from(this._langGraph.entries()), r = n.filter(([i, o]) => !o);
    if (r.length) {
      const i = n.filter(([o, s]) => s ? (s.embeddedLanguages || s.embeddedLangs)?.some((c) => r.map(([u]) => u).includes(c)) : !1).filter((o) => !r.includes(o));
      throw new Lf(`Missing languages ${r.map(([o]) => `\`${o}\``).join(", ")}, required by ${i.map(([o]) => `\`${o}\``).join(", ")}`);
    }
    for (const [i, o] of n)
      this._resolver.addLanguage(o);
    for (const [i, o] of n)
      this.loadLanguage(o);
  }
  getLoadedLanguages() {
    return this._loadedLanguagesCache || (this._loadedLanguagesCache = [
      .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
    ]), this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(t) {
    this._langMap.set(t.name, t), this._langGraph.set(t.name, t);
    const n = t.embeddedLanguages ?? t.embeddedLangs;
    if (n)
      for (const r of n)
        this._langGraph.set(r, this._langMap.get(r));
  }
}
class XTe {
  _langs = /* @__PURE__ */ new Map();
  _scopeToLang = /* @__PURE__ */ new Map();
  _injections = /* @__PURE__ */ new Map();
  _onigLib;
  constructor(t, n) {
    this._onigLib = {
      createOnigScanner: (r) => t.createScanner(r),
      createOnigString: (r) => t.createString(r)
    }, n.forEach((r) => this.addLanguage(r));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(t) {
    return this._langs.get(t);
  }
  loadGrammar(t) {
    return this._scopeToLang.get(t);
  }
  addLanguage(t) {
    this._langs.set(t.name, t), t.aliases && t.aliases.forEach((n) => {
      this._langs.set(n, t);
    }), this._scopeToLang.set(t.scopeName, t), t.injectTo && t.injectTo.forEach((n) => {
      this._injections.get(n) || this._injections.set(n, []), this._injections.get(n).push(t.scopeName);
    });
  }
  getInjections(t) {
    const n = t.split(".");
    let r = [];
    for (let i = 1; i <= n.length; i++) {
      const o = n.slice(0, i).join(".");
      r = [...r, ...this._injections.get(o) || []];
    }
    return r;
  }
}
let Jp = 0;
function JTe(e) {
  Jp += 1, e.warnings !== !1 && Jp >= 10 && Jp % 10 === 0 && console.warn(`[Shiki] ${Jp} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let t = !1;
  if (!e.engine)
    throw new Lf("`engine` option is required for synchronous mode");
  const n = (e.langs || []).flat(1), r = (e.themes || []).flat(1).map(tN), i = new XTe(e.engine, n), o = new YTe(i, r, n, e.langAlias);
  let s;
  function a(M) {
    return p7(M, e.langAlias);
  }
  function c(M) {
    S();
    const N = o.getGrammar(typeof M == "string" ? M : M.name);
    if (!N)
      throw new Lf(`Language \`${M}\` not found, you may need to load it first`);
    return N;
  }
  function u(M) {
    if (M === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    S();
    const N = o.getTheme(M);
    if (!N)
      throw new Lf(`Theme \`${M}\` not found, you may need to load it first`);
    return N;
  }
  function f(M) {
    S();
    const N = u(M);
    s !== M && (o.setTheme(N), s = M);
    const P = o.getColorMap();
    return {
      theme: N,
      colorMap: P
    };
  }
  function h() {
    return S(), o.getLoadedThemes();
  }
  function m() {
    return S(), o.getLoadedLanguages();
  }
  function g(...M) {
    S(), o.loadLanguages(M.flat(1));
  }
  async function b(...M) {
    return g(await f7(M));
  }
  function x(...M) {
    S();
    for (const N of M.flat(1))
      o.loadTheme(N);
  }
  async function w(...M) {
    return S(), x(await h7(M));
  }
  function S() {
    if (t)
      throw new Lf("Shiki instance has been disposed");
  }
  function _() {
    t || (t = !0, o.dispose(), Jp -= 1);
  }
  return {
    setTheme: f,
    getTheme: u,
    getLanguage: c,
    getLoadedThemes: h,
    getLoadedLanguages: m,
    resolveLangAlias: a,
    loadLanguage: b,
    loadLanguageSync: g,
    loadTheme: w,
    loadThemeSync: x,
    dispose: _,
    [Symbol.dispose]: _
  };
}
async function QTe(e) {
  e.engine || ZTe("`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.");
  const [
    t,
    n,
    r
  ] = await Promise.all([
    h7(e.themes || []),
    f7(e.langs || []),
    e.engine
  ]);
  return JTe({
    ...e,
    themes: t,
    langs: n,
    engine: r
  });
}
async function eAe(e) {
  const t = await QTe(e);
  return {
    getLastGrammarState: (...n) => jTe(t, ...n),
    codeToTokensBase: (n, r) => QM(t, n, r),
    codeToTokensWithThemes: (n, r) => d7(t, n, r),
    codeToTokens: (n, r) => Vb(t, n, r),
    codeToHast: (n, r) => Hb(t, n, r),
    codeToHtml: (n, r) => GTe(t, n, r),
    getBundledLanguages: () => ({}),
    getBundledThemes: () => ({}),
    ...t,
    getInternalContext: () => t
  };
}
function tAe(e) {
  const t = e.langs, n = e.themes, r = e.engine;
  async function i(o) {
    function s(h) {
      if (typeof h == "string") {
        if (h = o.langAlias?.[h] || h, s7(h))
          return [];
        const m = t[h];
        if (!m)
          throw new kr(`Language \`${h}\` is not included in this bundle. You may want to load it from external source.`);
        return m;
      }
      return h;
    }
    function a(h) {
      if (a7(h))
        return "none";
      if (typeof h == "string") {
        const m = n[h];
        if (!m)
          throw new kr(`Theme \`${h}\` is not included in this bundle. You may want to load it from external source.`);
        return m;
      }
      return h;
    }
    const c = (o.themes ?? []).map((h) => a(h)), u = (o.langs ?? []).map((h) => s(h)), f = await eAe({
      engine: o.engine ?? r(),
      ...o,
      themes: c,
      langs: u
    });
    return {
      ...f,
      loadLanguage(...h) {
        return f.loadLanguage(...h.map(s));
      },
      loadTheme(...h) {
        return f.loadTheme(...h.map(a));
      },
      getBundledLanguages() {
        return t;
      },
      getBundledThemes() {
        return n;
      }
    };
  }
  return i;
}
function nAe(e) {
  let t;
  async function n(r = {}) {
    if (t) {
      const i = await t;
      return await Promise.all([
        i.loadTheme(...r.themes || []),
        i.loadLanguage(...r.langs || [])
      ]), i;
    } else {
      t = e({
        ...r,
        themes: [],
        langs: []
      });
      const i = await t;
      return await Promise.all([
        i.loadTheme(...r.themes || []),
        i.loadLanguage(...r.langs || [])
      ]), i;
    }
  }
  return n;
}
function rAe(e, t) {
  const n = nAe(e);
  async function r(i, o) {
    const s = await n({
      langs: [o.lang],
      themes: "theme" in o ? [o.theme] : Object.values(o.themes)
    }), a = await t?.guessEmbeddedLanguages?.(i, o.lang, s);
    return a && await s.loadLanguage(...a), s;
  }
  return {
    getSingletonHighlighter(i) {
      return n(i);
    },
    async codeToHtml(i, o) {
      return (await r(i, o)).codeToHtml(i, o);
    },
    async codeToHast(i, o) {
      return (await r(i, o)).codeToHast(i, o);
    },
    async codeToTokens(i, o) {
      return (await r(i, o)).codeToTokens(i, o);
    },
    async codeToTokensBase(i, o) {
      return (await r(i, o)).codeToTokensBase(i, o);
    },
    async codeToTokensWithThemes(i, o) {
      return (await r(i, o)).codeToTokensWithThemes(i, o);
    },
    async getLastGrammarState(i, o) {
      return (await n({
        langs: [o.lang],
        themes: [o.theme]
      })).getLastGrammarState(i, o);
    }
  };
}
const iAe = [
  {
    id: "andromeeda",
    displayName: "Andromeeda",
    type: "dark",
    import: (() => import("./andromeeda-BbmzSJq1.js"))
  },
  {
    id: "aurora-x",
    displayName: "Aurora X",
    type: "dark",
    import: (() => import("./aurora-x-BwoVEUWZ.js"))
  },
  {
    id: "ayu-dark",
    displayName: "Ayu Dark",
    type: "dark",
    import: (() => import("./ayu-dark-Dsjk_2Jx.js"))
  },
  {
    id: "ayu-light",
    displayName: "Ayu Light",
    type: "light",
    import: (() => import("./ayu-light-R7pgdmWq.js"))
  },
  {
    id: "ayu-mirage",
    displayName: "Ayu Mirage",
    type: "dark",
    import: (() => import("./ayu-mirage-DraY-SDX.js"))
  },
  {
    id: "catppuccin-frappe",
    displayName: "Catppuccin Frapp",
    type: "dark",
    import: (() => import("./catppuccin-frappe-D3cH2rXe.js"))
  },
  {
    id: "catppuccin-latte",
    displayName: "Catppuccin Latte",
    type: "light",
    import: (() => import("./catppuccin-latte-C0LRGUW4.js"))
  },
  {
    id: "catppuccin-macchiato",
    displayName: "Catppuccin Macchiato",
    type: "dark",
    import: (() => import("./catppuccin-macchiato-c5wQ11TT.js"))
  },
  {
    id: "catppuccin-mocha",
    displayName: "Catppuccin Mocha",
    type: "dark",
    import: (() => import("./catppuccin-mocha-WMD6Qvya.js"))
  },
  {
    id: "dark-plus",
    displayName: "Dark Plus",
    type: "dark",
    import: (() => import("./dark-plus-pUHDTVV0.js"))
  },
  {
    id: "dracula",
    displayName: "Dracula Theme",
    type: "dark",
    import: (() => import("./dracula-BtZx2Kac.js"))
  },
  {
    id: "dracula-soft",
    displayName: "Dracula Theme Soft",
    type: "dark",
    import: (() => import("./dracula-soft-BKa-aqBv.js"))
  },
  {
    id: "everforest-dark",
    displayName: "Everforest Dark",
    type: "dark",
    import: (() => import("./everforest-dark-DMCBqXCK.js"))
  },
  {
    id: "everforest-light",
    displayName: "Everforest Light",
    type: "light",
    import: (() => import("./everforest-light-BbXl82Em.js"))
  },
  {
    id: "github-dark",
    displayName: "GitHub Dark",
    type: "dark",
    import: (() => import("./github-dark-DenFmJkN.js"))
  },
  {
    id: "github-dark-default",
    displayName: "GitHub Dark Default",
    type: "dark",
    import: (() => import("./github-dark-default-BJPUVz4H.js"))
  },
  {
    id: "github-dark-dimmed",
    displayName: "GitHub Dark Dimmed",
    type: "dark",
    import: (() => import("./github-dark-dimmed-DUshB20C.js"))
  },
  {
    id: "github-dark-high-contrast",
    displayName: "GitHub Dark High Contrast",
    type: "dark",
    import: (() => import("./github-dark-high-contrast-D3aGCnF8.js"))
  },
  {
    id: "github-light",
    displayName: "GitHub Light",
    type: "light",
    import: (() => import("./github-light-JYsPkUQd.js"))
  },
  {
    id: "github-light-default",
    displayName: "GitHub Light Default",
    type: "light",
    import: (() => import("./github-light-default-D99KPAby.js"))
  },
  {
    id: "github-light-high-contrast",
    displayName: "GitHub Light High Contrast",
    type: "light",
    import: (() => import("./github-light-high-contrast-BbmZE-Mp.js"))
  },
  {
    id: "gruvbox-dark-hard",
    displayName: "Gruvbox Dark Hard",
    type: "dark",
    import: (() => import("./gruvbox-dark-hard-C5HOtKIh.js"))
  },
  {
    id: "gruvbox-dark-medium",
    displayName: "Gruvbox Dark Medium",
    type: "dark",
    import: (() => import("./gruvbox-dark-medium-FVgwJHuz.js"))
  },
  {
    id: "gruvbox-dark-soft",
    displayName: "Gruvbox Dark Soft",
    type: "dark",
    import: (() => import("./gruvbox-dark-soft-B46F314v.js"))
  },
  {
    id: "gruvbox-light-hard",
    displayName: "Gruvbox Light Hard",
    type: "light",
    import: (() => import("./gruvbox-light-hard-CJD38wDZ.js"))
  },
  {
    id: "gruvbox-light-medium",
    displayName: "Gruvbox Light Medium",
    type: "light",
    import: (() => import("./gruvbox-light-medium-BlIhMYTA.js"))
  },
  {
    id: "gruvbox-light-soft",
    displayName: "Gruvbox Light Soft",
    type: "light",
    import: (() => import("./gruvbox-light-soft-DoPHyLVZ.js"))
  },
  {
    id: "horizon",
    displayName: "Horizon",
    type: "dark",
    import: (() => import("./horizon-CJQ10nlf.js"))
  },
  {
    id: "houston",
    displayName: "Houston",
    type: "dark",
    import: (() => import("./houston-BDYrDoDW.js"))
  },
  {
    id: "kanagawa-dragon",
    displayName: "Kanagawa Dragon",
    type: "dark",
    import: (() => import("./kanagawa-dragon-CiKur4Hl.js"))
  },
  {
    id: "kanagawa-lotus",
    displayName: "Kanagawa Lotus",
    type: "light",
    import: (() => import("./kanagawa-lotus-BKu-smKu.js"))
  },
  {
    id: "kanagawa-wave",
    displayName: "Kanagawa Wave",
    type: "dark",
    import: (() => import("./kanagawa-wave-CQwozSzG.js"))
  },
  {
    id: "laserwave",
    displayName: "LaserWave",
    type: "dark",
    import: (() => import("./laserwave-6a00oqik.js"))
  },
  {
    id: "light-plus",
    displayName: "Light Plus",
    type: "light",
    import: (() => import("./light-plus-CZuVqSLX.js"))
  },
  {
    id: "material-theme",
    displayName: "Material Theme",
    type: "dark",
    import: (() => import("./material-theme-D6KBX41T.js"))
  },
  {
    id: "material-theme-darker",
    displayName: "Material Theme Darker",
    type: "dark",
    import: (() => import("./material-theme-darker-CkRroheE.js"))
  },
  {
    id: "material-theme-lighter",
    displayName: "Material Theme Lighter",
    type: "light",
    import: (() => import("./material-theme-lighter-BUBw43Yz.js"))
  },
  {
    id: "material-theme-ocean",
    displayName: "Material Theme Ocean",
    type: "dark",
    import: (() => import("./material-theme-ocean-ClGX14Ja.js"))
  },
  {
    id: "material-theme-palenight",
    displayName: "Material Theme Palenight",
    type: "dark",
    import: (() => import("./material-theme-palenight-C1RVm8K1.js"))
  },
  {
    id: "min-dark",
    displayName: "Min Dark",
    type: "dark",
    import: (() => import("./min-dark-C7ak0t6c.js"))
  },
  {
    id: "min-light",
    displayName: "Min Light",
    type: "light",
    import: (() => import("./min-light-CKFxVcPp.js"))
  },
  {
    id: "monokai",
    displayName: "Monokai",
    type: "dark",
    import: (() => import("./monokai-C1KBYcO0.js"))
  },
  {
    id: "night-owl",
    displayName: "Night Owl",
    type: "dark",
    import: (() => import("./night-owl-Bm2rzalh.js"))
  },
  {
    id: "night-owl-light",
    displayName: "Night Owl Light",
    type: "light",
    import: (() => import("./night-owl-light-CBI5u5kw.js"))
  },
  {
    id: "nord",
    displayName: "Nord",
    type: "dark",
    import: (() => import("./nord-CC5OiUXg.js"))
  },
  {
    id: "one-dark-pro",
    displayName: "One Dark Pro",
    type: "dark",
    import: (() => import("./one-dark-pro-DTA3VF0_.js"))
  },
  {
    id: "one-light",
    displayName: "One Light",
    type: "light",
    import: (() => import("./one-light-LkMrt1Cf.js"))
  },
  {
    id: "plastic",
    displayName: "Plastic",
    type: "dark",
    import: (() => import("./plastic-CSTz3KZp.js"))
  },
  {
    id: "poimandres",
    displayName: "Poimandres",
    type: "dark",
    import: (() => import("./poimandres-C-VADXHD.js"))
  },
  {
    id: "red",
    displayName: "Red",
    type: "dark",
    import: (() => import("./red-7y8PH7HH.js"))
  },
  {
    id: "rose-pine",
    displayName: "Ros Pine",
    type: "dark",
    import: (() => import("./rose-pine-BKc3yVeu.js"))
  },
  {
    id: "rose-pine-dawn",
    displayName: "Ros Pine Dawn",
    type: "light",
    import: (() => import("./rose-pine-dawn-BulJcPZT.js"))
  },
  {
    id: "rose-pine-moon",
    displayName: "Ros Pine Moon",
    type: "dark",
    import: (() => import("./rose-pine-moon-j6jiXKV8.js"))
  },
  {
    id: "slack-dark",
    displayName: "Slack Dark",
    type: "dark",
    import: (() => import("./slack-dark-i7wN4OET.js"))
  },
  {
    id: "slack-ochin",
    displayName: "Slack Ochin",
    type: "light",
    import: (() => import("./slack-ochin-ndHf0LoP.js"))
  },
  {
    id: "snazzy-light",
    displayName: "Snazzy Light",
    type: "light",
    import: (() => import("./snazzy-light-BlSJXAu4.js"))
  },
  {
    id: "solarized-dark",
    displayName: "Solarized Dark",
    type: "dark",
    import: (() => import("./solarized-dark-UTmkh7lw.js"))
  },
  {
    id: "solarized-light",
    displayName: "Solarized Light",
    type: "light",
    import: (() => import("./solarized-light-BheCkDPT.js"))
  },
  {
    id: "synthwave-84",
    displayName: "Synthwave '84",
    type: "dark",
    import: (() => import("./synthwave-84-NU3C_KFZ.js"))
  },
  {
    id: "tokyo-night",
    displayName: "Tokyo Night",
    type: "dark",
    import: (() => import("./tokyo-night-DP4TmcQl.js"))
  },
  {
    id: "vesper",
    displayName: "Vesper",
    type: "dark",
    import: (() => import("./vesper-BckBta1U.js"))
  },
  {
    id: "vitesse-black",
    displayName: "Vitesse Black",
    type: "dark",
    import: (() => import("./vitesse-black-BoGvW84i.js"))
  },
  {
    id: "vitesse-dark",
    displayName: "Vitesse Dark",
    type: "dark",
    import: (() => import("./vitesse-dark-Cym-eLtO.js"))
  },
  {
    id: "vitesse-light",
    displayName: "Vitesse Light",
    type: "light",
    import: (() => import("./vitesse-light-CcmG315c.js"))
  }
], oAe = Object.fromEntries(iAe.map((e) => [e.id, e.import]));
class nN extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
}
function sAe() {
  return 2147483648;
}
function aAe() {
  return typeof performance < "u" ? performance.now() : Date.now();
}
const lAe = (e, t) => e + (t - e % t) % t;
async function cAe(e) {
  let t, n;
  const r = {};
  function i(g) {
    n = g, r.HEAPU8 = new Uint8Array(g), r.HEAPU32 = new Uint32Array(g);
  }
  function o(g, b, x) {
    r.HEAPU8.copyWithin(g, b, b + x);
  }
  function s(g) {
    try {
      return t.grow(g - n.byteLength + 65535 >>> 16), i(t.buffer), 1;
    } catch {
    }
  }
  function a(g) {
    const b = r.HEAPU8.length;
    g = g >>> 0;
    const x = sAe();
    if (g > x)
      return !1;
    for (let w = 1; w <= 4; w *= 2) {
      let S = b * (1 + 0.2 / w);
      S = Math.min(S, g + 100663296);
      const _ = Math.min(x, lAe(Math.max(g, S), 65536));
      if (s(_))
        return !0;
    }
    return !1;
  }
  const c = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
  function u(g, b, x = 1024) {
    const w = b + x;
    let S = b;
    for (; g[S] && !(S >= w); ) ++S;
    if (S - b > 16 && g.buffer && c)
      return c.decode(g.subarray(b, S));
    let _ = "";
    for (; b < S; ) {
      let M = g[b++];
      if (!(M & 128)) {
        _ += String.fromCharCode(M);
        continue;
      }
      const N = g[b++] & 63;
      if ((M & 224) === 192) {
        _ += String.fromCharCode((M & 31) << 6 | N);
        continue;
      }
      const P = g[b++] & 63;
      if ((M & 240) === 224 ? M = (M & 15) << 12 | N << 6 | P : M = (M & 7) << 18 | N << 12 | P << 6 | g[b++] & 63, M < 65536)
        _ += String.fromCharCode(M);
      else {
        const I = M - 65536;
        _ += String.fromCharCode(55296 | I >> 10, 56320 | I & 1023);
      }
    }
    return _;
  }
  function f(g, b) {
    return g ? u(r.HEAPU8, g, b) : "";
  }
  const h = {
    emscripten_get_now: aAe,
    emscripten_memcpy_big: o,
    emscripten_resize_heap: a,
    fd_write: () => 0
  };
  async function m() {
    const b = await e({
      env: h,
      wasi_snapshot_preview1: h
    });
    t = b.memory, i(t.buffer), Object.assign(r, b), r.UTF8ToString = f;
  }
  return await m(), r;
}
var uAe = Object.defineProperty, dAe = (e, t, n) => t in e ? uAe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Or = (e, t, n) => dAe(e, typeof t != "symbol" ? t + "" : t, n);
let $r = null;
function fAe(e) {
  throw new nN(e.UTF8ToString(e.getLastOnigError()));
}
class Pw {
  constructor(t) {
    Or(this, "utf16Length"), Or(this, "utf8Length"), Or(this, "utf16Value"), Or(this, "utf8Value"), Or(this, "utf16OffsetToUtf8"), Or(this, "utf8OffsetToUtf16");
    const n = t.length, r = Pw._utf8ByteLength(t), i = r !== n, o = i ? new Uint32Array(n + 1) : null;
    i && (o[n] = r);
    const s = i ? new Uint32Array(r + 1) : null;
    i && (s[r] = n);
    const a = new Uint8Array(r);
    let c = 0;
    for (let u = 0; u < n; u++) {
      const f = t.charCodeAt(u);
      let h = f, m = !1;
      if (f >= 55296 && f <= 56319 && u + 1 < n) {
        const g = t.charCodeAt(u + 1);
        g >= 56320 && g <= 57343 && (h = (f - 55296 << 10) + 65536 | g - 56320, m = !0);
      }
      i && (o[u] = c, m && (o[u + 1] = c), h <= 127 ? s[c + 0] = u : h <= 2047 ? (s[c + 0] = u, s[c + 1] = u) : h <= 65535 ? (s[c + 0] = u, s[c + 1] = u, s[c + 2] = u) : (s[c + 0] = u, s[c + 1] = u, s[c + 2] = u, s[c + 3] = u)), h <= 127 ? a[c++] = h : h <= 2047 ? (a[c++] = 192 | (h & 1984) >>> 6, a[c++] = 128 | (h & 63) >>> 0) : h <= 65535 ? (a[c++] = 224 | (h & 61440) >>> 12, a[c++] = 128 | (h & 4032) >>> 6, a[c++] = 128 | (h & 63) >>> 0) : (a[c++] = 240 | (h & 1835008) >>> 18, a[c++] = 128 | (h & 258048) >>> 12, a[c++] = 128 | (h & 4032) >>> 6, a[c++] = 128 | (h & 63) >>> 0), m && u++;
    }
    this.utf16Length = n, this.utf8Length = r, this.utf16Value = t, this.utf8Value = a, this.utf16OffsetToUtf8 = o, this.utf8OffsetToUtf16 = s;
  }
  static _utf8ByteLength(t) {
    let n = 0;
    for (let r = 0, i = t.length; r < i; r++) {
      const o = t.charCodeAt(r);
      let s = o, a = !1;
      if (o >= 55296 && o <= 56319 && r + 1 < i) {
        const c = t.charCodeAt(r + 1);
        c >= 56320 && c <= 57343 && (s = (o - 55296 << 10) + 65536 | c - 56320, a = !0);
      }
      s <= 127 ? n += 1 : s <= 2047 ? n += 2 : s <= 65535 ? n += 3 : n += 4, a && r++;
    }
    return n;
  }
  createString(t) {
    const n = t.omalloc(this.utf8Length);
    return t.HEAPU8.set(this.utf8Value, n), n;
  }
}
const jw = class js {
  constructor(t) {
    if (Or(this, "id", ++js.LAST_ID), Or(this, "_onigBinding"), Or(this, "content"), Or(this, "utf16Length"), Or(this, "utf8Length"), Or(this, "utf16OffsetToUtf8"), Or(this, "utf8OffsetToUtf16"), Or(this, "ptr"), !$r)
      throw new nN("Must invoke loadWasm first.");
    this._onigBinding = $r, this.content = t;
    const n = new Pw(t);
    this.utf16Length = n.utf16Length, this.utf8Length = n.utf8Length, this.utf16OffsetToUtf8 = n.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = n.utf8OffsetToUtf16, this.utf8Length < 1e4 && !js._sharedPtrInUse ? (js._sharedPtr || (js._sharedPtr = $r.omalloc(1e4)), js._sharedPtrInUse = !0, $r.HEAPU8.set(n.utf8Value, js._sharedPtr), this.ptr = js._sharedPtr) : this.ptr = n.createString($r);
  }
  convertUtf8OffsetToUtf16(t) {
    return this.utf8OffsetToUtf16 ? t < 0 ? 0 : t > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[t] : t;
  }
  convertUtf16OffsetToUtf8(t) {
    return this.utf16OffsetToUtf8 ? t < 0 ? 0 : t > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[t] : t;
  }
  dispose() {
    this.ptr === js._sharedPtr ? js._sharedPtrInUse = !1 : this._onigBinding.ofree(this.ptr);
  }
};
Or(jw, "LAST_ID", 0);
Or(jw, "_sharedPtr", 0);
Or(jw, "_sharedPtrInUse", !1);
let m7 = jw;
class hAe {
  constructor(t) {
    if (Or(this, "_onigBinding"), Or(this, "_ptr"), !$r)
      throw new nN("Must invoke loadWasm first.");
    const n = [], r = [];
    for (let a = 0, c = t.length; a < c; a++) {
      const u = new Pw(t[a]);
      n[a] = u.createString($r), r[a] = u.utf8Length;
    }
    const i = $r.omalloc(4 * t.length);
    $r.HEAPU32.set(n, i / 4);
    const o = $r.omalloc(4 * t.length);
    $r.HEAPU32.set(r, o / 4);
    const s = $r.createOnigScanner(i, o, t.length);
    for (let a = 0, c = t.length; a < c; a++)
      $r.ofree(n[a]);
    $r.ofree(o), $r.ofree(i), s === 0 && fAe($r), this._onigBinding = $r, this._ptr = s;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(t, n, r) {
    let i = 0;
    if (typeof r == "number" && (i = r), typeof t == "string") {
      t = new m7(t);
      const o = this._findNextMatchSync(t, n, !1, i);
      return t.dispose(), o;
    }
    return this._findNextMatchSync(t, n, !1, i);
  }
  _findNextMatchSync(t, n, r, i) {
    const o = this._onigBinding, s = o.findNextOnigScannerMatch(this._ptr, t.id, t.ptr, t.utf8Length, t.convertUtf16OffsetToUtf8(n), i);
    if (s === 0)
      return null;
    const a = o.HEAPU32;
    let c = s / 4;
    const u = a[c++], f = a[c++], h = [];
    for (let m = 0; m < f; m++) {
      const g = t.convertUtf8OffsetToUtf16(a[c++]), b = t.convertUtf8OffsetToUtf16(a[c++]);
      h[m] = {
        start: g,
        end: b,
        length: b - g
      };
    }
    return {
      index: u,
      captureIndices: h
    };
  }
}
function pAe(e) {
  return typeof e.instantiator == "function";
}
function mAe(e) {
  return typeof e.default == "function";
}
function gAe(e) {
  return typeof e.data < "u";
}
function yAe(e) {
  return typeof Response < "u" && e instanceof Response;
}
function vAe(e) {
  return typeof ArrayBuffer < "u" && (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) || typeof Buffer < "u" && Buffer.isBuffer?.(e) || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer || typeof Uint32Array < "u" && e instanceof Uint32Array;
}
let Gv;
function bAe(e) {
  if (Gv)
    return Gv;
  async function t() {
    $r = await cAe(async (n) => {
      let r = e;
      return r = await r, typeof r == "function" && (r = await r(n)), typeof r == "function" && (r = await r(n)), pAe(r) ? r = await r.instantiator(n) : mAe(r) ? r = await r.default(n) : (gAe(r) && (r = r.data), yAe(r) ? typeof WebAssembly.instantiateStreaming == "function" ? r = await xAe(r)(n) : r = await wAe(r)(n) : vAe(r) ? r = await PC(r)(n) : r instanceof WebAssembly.Module ? r = await PC(r)(n) : "default" in r && r.default instanceof WebAssembly.Module && (r = await PC(r.default)(n))), "instance" in r && (r = r.instance), "exports" in r && (r = r.exports), r;
    });
  }
  return Gv = t(), Gv;
}
function PC(e) {
  return (t) => WebAssembly.instantiate(e, t);
}
function xAe(e) {
  return (t) => WebAssembly.instantiateStreaming(e, t);
}
function wAe(e) {
  return async (t) => {
    const n = await e.arrayBuffer();
    return WebAssembly.instantiate(n, t);
  };
}
async function SAe(e) {
  return e && await bAe(e), {
    createScanner(t) {
      return new hAe(t.map((n) => typeof n == "string" ? n : n.source));
    },
    createString(t) {
      return new m7(t);
    }
  };
}
const g7 = [
  {
    id: "angular-html",
    name: "Angular HTML",
    import: (() => import("./angular-html-DPB4Rf0C.js").then((e) => e.f))
  },
  {
    id: "angular-ts",
    name: "Angular TypeScript",
    import: (() => import("./angular-ts-CTOR2ofC.js"))
  },
  {
    id: "astro",
    name: "Astro",
    import: (() => import("./astro-CFFExE8Q.js"))
  },
  {
    id: "blade",
    name: "Blade",
    import: (() => import("./blade-D0HyNvCw.js"))
  },
  {
    id: "c",
    name: "C",
    import: (() => import("./c-eeMepfLm.js"))
  },
  {
    id: "coffee",
    name: "CoffeeScript",
    aliases: [
      "coffeescript"
    ],
    import: (() => import("./coffee-DGBR_nr_.js"))
  },
  {
    id: "cpp",
    name: "C++",
    aliases: [
      "c++"
    ],
    import: (() => import("./cpp-Cj177cuW.js"))
  },
  {
    id: "css",
    name: "CSS",
    import: (() => import("./css-CECN5uSL.js"))
  },
  {
    id: "csv",
    name: "CSV",
    import: (() => import("./csv-CmYOceLb.js"))
  },
  {
    id: "glsl",
    name: "GLSL",
    import: (() => import("./glsl-CkUcVZNK.js"))
  },
  {
    id: "graphql",
    name: "GraphQL",
    aliases: [
      "gql"
    ],
    import: (() => import("./graphql-CBu2ehBn.js"))
  },
  {
    id: "haml",
    name: "Ruby Haml",
    import: (() => import("./haml-NZLVzu_R.js"))
  },
  {
    id: "handlebars",
    name: "Handlebars",
    aliases: [
      "hbs"
    ],
    import: (() => import("./handlebars-mxStpSE7.js"))
  },
  {
    id: "html",
    name: "HTML",
    import: (() => import("./html-B50bmoVb.js"))
  },
  {
    id: "html-derivative",
    name: "HTML (Derivative)",
    import: (() => import("./html-derivative-C6bxFbFW.js"))
  },
  {
    id: "http",
    name: "HTTP",
    import: (() => import("./http-DLvAkeD-.js"))
  },
  {
    id: "hurl",
    name: "Hurl",
    import: (() => import("./hurl-CgkFN90t.js"))
  },
  {
    id: "imba",
    name: "Imba",
    import: (() => import("./imba-CimUv-Uh.js"))
  },
  {
    id: "java",
    name: "Java",
    import: (() => import("./java-DY6VlHhP.js"))
  },
  {
    id: "javascript",
    name: "JavaScript",
    aliases: [
      "js",
      "cjs",
      "mjs"
    ],
    import: (() => import("./javascript-C25yR2R2.js"))
  },
  {
    id: "jinja",
    name: "Jinja",
    import: (() => import("./jinja-CFW5uAwY.js"))
  },
  {
    id: "jison",
    name: "Jison",
    import: (() => import("./jison-DdreslRX.js"))
  },
  {
    id: "json",
    name: "JSON",
    import: (() => import("./json-DxJze_jm.js"))
  },
  {
    id: "json5",
    name: "JSON5",
    import: (() => import("./json5-BT4Fjg39.js"))
  },
  {
    id: "jsonc",
    name: "JSON with Comments",
    import: (() => import("./jsonc-CHjZD8gR.js"))
  },
  {
    id: "jsonl",
    name: "JSON Lines",
    import: (() => import("./jsonl-BGuvDmy9.js"))
  },
  {
    id: "jsx",
    name: "JSX",
    import: (() => import("./jsx-BtKADgXT.js"))
  },
  {
    id: "julia",
    name: "Julia",
    aliases: [
      "jl"
    ],
    import: (() => import("./julia-CZiKXNNP.js"))
  },
  {
    id: "less",
    name: "Less",
    import: (() => import("./less-B1GLI2Di.js"))
  },
  {
    id: "markdown",
    name: "Markdown",
    aliases: [
      "md"
    ],
    import: (() => import("./markdown-CrScaQ96.js"))
  },
  {
    id: "marko",
    name: "Marko",
    import: (() => import("./marko-Ns9BYtDO.js"))
  },
  {
    id: "mdc",
    name: "MDC",
    import: (() => import("./mdc-uaivvctV.js"))
  },
  {
    id: "mdx",
    name: "MDX",
    import: (() => import("./mdx-BOhZZUJ8.js"))
  },
  {
    id: "php",
    name: "PHP",
    import: (() => import("./php-BIzsF_5x.js"))
  },
  {
    id: "postcss",
    name: "PostCSS",
    import: (() => import("./postcss-05aHdL-n.js"))
  },
  {
    id: "pug",
    name: "Pug",
    aliases: [
      "jade"
    ],
    import: (() => import("./pug-XOw9Q1Ho.js"))
  },
  {
    id: "python",
    name: "Python",
    aliases: [
      "py"
    ],
    import: (() => import("./python-BFNSHbwJ.js"))
  },
  {
    id: "r",
    name: "R",
    import: (() => import("./r-CSmzDPi7.js"))
  },
  {
    id: "regexp",
    name: "RegExp",
    aliases: [
      "regex"
    ],
    import: (() => import("./regexp-BazyLpPg.js"))
  },
  {
    id: "sass",
    name: "Sass",
    import: (() => import("./sass-DxHp5rTx.js"))
  },
  {
    id: "scss",
    name: "SCSS",
    import: (() => import("./scss-B1FaCqwR.js"))
  },
  {
    id: "shellscript",
    name: "Shell",
    aliases: [
      "bash",
      "sh",
      "shell",
      "zsh"
    ],
    import: (() => import("./shellscript-InADTalH.js"))
  },
  {
    id: "sql",
    name: "SQL",
    import: (() => import("./sql-Cn_v3PB0.js"))
  },
  {
    id: "stylus",
    name: "Stylus",
    aliases: [
      "styl"
    ],
    import: (() => import("./stylus-CyKEU1Ej.js"))
  },
  {
    id: "svelte",
    name: "Svelte",
    import: (() => import("./svelte-CYf4HR3U.js"))
  },
  {
    id: "ts-tags",
    name: "TypeScript with Tags",
    aliases: [
      "lit"
    ],
    import: (() => import("./ts-tags-ioVe2PKw.js"))
  },
  {
    id: "tsx",
    name: "TSX",
    import: (() => import("./tsx-B8rCNbgL.js"))
  },
  {
    id: "typescript",
    name: "TypeScript",
    aliases: [
      "ts",
      "cts",
      "mts"
    ],
    import: (() => import("./typescript-RycA9KXf.js"))
  },
  {
    id: "vue",
    name: "Vue",
    import: (() => import("./vue-DXEmyXn9.js"))
  },
  {
    id: "vue-html",
    name: "Vue HTML",
    import: (() => import("./vue-html-j9xNEdu3.js"))
  },
  {
    id: "vue-vine",
    name: "Vue Vine",
    import: (() => import("./vue-vine-D41-N99t.js"))
  },
  {
    id: "wasm",
    name: "WebAssembly",
    import: (() => import("./wasm-BBXxrAl7.js"))
  },
  {
    id: "wgsl",
    name: "WGSL",
    import: (() => import("./wgsl-DY4iK1q1.js"))
  },
  {
    id: "wit",
    name: "WebAssembly Interface Types",
    import: (() => import("./wit-CQMQOlTg.js"))
  },
  {
    id: "xml",
    name: "XML",
    import: (() => import("./xml-C2J0sS9M.js"))
  },
  {
    id: "yaml",
    name: "YAML",
    aliases: [
      "yml"
    ],
    import: (() => import("./yaml-DaO7k5B1.js"))
  }
], kAe = Object.fromEntries(g7.map((e) => [e.id, e.import])), CAe = Object.fromEntries(g7.flatMap((e) => e.aliases?.map((t) => [t, e.import]) || [])), y7 = {
  ...kAe,
  ...CAe
}, EAe = /* @__PURE__ */ tAe({
  langs: y7,
  themes: oAe,
  engine: () => SAe(import("./wasm-DQxwEHae.js"))
}), {
  codeToHast: _Ae
} = /* @__PURE__ */ rAe(
  EAe,
  { guessEmbeddedLanguages: gTe }
);
var v7 = (e) => typeof e == "function", Bf = (e) => v7(e?.then), TAe = (e) => {
  try {
    return e instanceof Error ? e : typeof e == "string" ? new Error(e) : new Error(JSON.stringify(e));
  } catch (t) {
    return t;
  }
}, D0 = (e) => ({ isOk: !0, error: void 0, value: e }), P0 = (e) => ({ isOk: !1, error: TAe(e), value: void 0 }), AAe = (e, t) => {
  if (Bf(e)) return e.then(t).then(D0, P0);
  try {
    let n = t(e);
    return Bf(n) ? n.then((r) => Promise.resolve(D0(r)), (r) => Promise.resolve(P0(r))) : D0(n);
  } catch (n) {
    return P0(n);
  }
}, Iw = { ok: D0, fail: P0, update: AAe }, zw = (e) => {
  let t = (n) => zw(Iw.update(e, n));
  return { map(n) {
    return t((r) => {
      if (r.isOk) return n(r.value);
      throw r.error;
    });
  }, flatMap(n) {
    return t((r) => {
      if (r.isOk) return n(r.value).unwrap();
      throw r.error;
    });
  }, effect(n) {
    return t((r) => {
      if (!r.isOk) throw r.error;
      let i = n(r.value);
      return Bf(i) ? i.then(() => r.value) : r.value;
    });
  }, ifOk(n) {
    return t((r) => {
      if (!r.isOk) throw r.error;
      let i = n(r.value);
      return Bf(i) ? i.then(() => r.value) : r.value;
    });
  }, watch(n) {
    return t((r) => {
      try {
        n({ ...r });
      } catch {
      }
      if (r.isOk) return r.value;
      throw r.error;
    });
  }, catch(n) {
    return t((r) => r.isOk ? r.value : n(r.error));
  }, ifFail(n) {
    return t((r) => r.isOk ? r.value : n(r.error));
  }, unwrap() {
    if (Bf(e)) return e.then((n) => {
      if (n.isOk) return n.value;
      throw n.error;
    });
    if (e.isOk) return e.value;
    throw e.error;
  }, isOk: Bf(e) ? e.then((n) => Promise.resolve(n.isOk)) : e.isOk, orElse(n) {
    return t((r) => r.isOk ? r.value : n).unwrap();
  } };
};
function b7(e) {
  let t = zw(Iw.ok(void 0));
  try {
    return t.map(() => e);
  } catch (n) {
    return t.map(() => {
      throw n;
    });
  }
}
function MAe(e) {
  let t = zw(Iw.ok(void 0));
  try {
    return t.map(() => e());
  } catch (n) {
    return t.map(() => {
      throw n;
    });
  }
}
function NAe() {
  return zw(Iw.ok(void 0));
}
function RAe(...e) {
  return (t) => {
    let n = b7(t);
    return e.reduce((r, i) => r.map(i), n);
  };
}
function rN(e) {
  return e === void 0 ? NAe() : v7(e) ? MAe(e) : b7(e);
}
rN.pipe = RAe;
const iN = (e = 2e3) => {
  const [t, n] = k.useState(!1);
  return { copied: t, copy: (i) => {
    navigator.clipboard.writeText(i), n(!0), setTimeout(() => {
      n(!1);
    }, e);
  } };
};
function oN(...e) {
  return e.filter(Boolean).join(" ");
}
function OAe() {
  const [e, t] = k.useState(
    () => typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
  );
  return k.useEffect(() => {
    if (typeof window > "u" || !window.matchMedia) return;
    const n = window.matchMedia("(prefers-color-scheme: dark)"), r = () => t(n.matches ? "dark" : "light");
    return n.addEventListener?.("change", r), () => n.removeEventListener?.("change", r);
  }, []), e;
}
const DAe = Ne.lazy(async () => ({ default: (await import("./mermaid-diagram-Dl9aCRAC.js")).MermaidDiagram })), PAe = () => /* @__PURE__ */ v.jsxs("div", { className: "text-sm flex bg-accent/30 flex-col rounded-2xl relative my-4 overflow-hidden border", children: [
  /* @__PURE__ */ v.jsx("div", { className: "w-full flex z-20 py-2 px-4 items-center", children: /* @__PURE__ */ v.jsx("span", { className: "text-sm text-muted-foreground", children: "mermaid" }) }),
  /* @__PURE__ */ v.jsx("div", { className: "relative overflow-x-auto px-6 pb-6", children: /* @__PURE__ */ v.jsx("div", { className: "h-20 w-full flex items-center justify-center", children: /* @__PURE__ */ v.jsx("span", { className: "text-muted-foreground", children: "Loading Mermaid renderer" }) }) })
] }), jAe = k.memo(function(t) {
  const { className: n, active: r, ...i } = t;
  return /* @__PURE__ */ v.jsx(
    "button",
    {
      ...i,
      className: oN(
        "inline-flex items-center justify-center rounded-sm",
        "transition-colors focus:outline-none",
        r ? "bg-secondary text-foreground" : "hover:bg-muted text-muted-foreground",
        "h-7 w-7",
        n
      )
    }
  );
});
function j0({
  lang: e,
  code: t,
  children: n,
  className: r
}) {
  const { copied: i, copy: o } = iN();
  return /* @__PURE__ */ v.jsxs("pre", { className: oN("relative", r), children: [
    /* @__PURE__ */ v.jsx("div", { className: "p-1.5 border-b mb-4 z-20 bg-secondary", children: /* @__PURE__ */ v.jsxs("div", { className: "w-full flex z-20 py-0.5 px-4 items-center gap-2", children: [
      /* @__PURE__ */ v.jsx("span", { className: "text-xs uppercase tracking-wide text-muted-foreground", children: e }),
      /* @__PURE__ */ v.jsx(
        jAe,
        {
          onClick: () => o(t),
          title: "Copy code",
          "aria-label": "Copy",
          active: i,
          className: "ml-auto",
          children: i ? /* @__PURE__ */ v.jsx(Sc, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(kc, { className: "h-4 w-4" })
        }
      )
    ] }) }),
    /* @__PURE__ */ v.jsx("div", { className: "relative overflow-x-auto px-6 pb-6", children: n })
  ] });
}
async function IAe(e, t, n) {
  const r = typeof t == "string" && t in y7 ? t : "md";
  if (t === "json")
    return /* @__PURE__ */ v.jsx(j0, { code: e, lang: "json", children: /* @__PURE__ */ v.jsx(Qu, { data: e, initialExpandDepth: 3 }) });
  if (t === "mermaid")
    return /* @__PURE__ */ v.jsx(j0, { code: e, lang: "mermaid", children: /* @__PURE__ */ v.jsx(k.Suspense, { fallback: /* @__PURE__ */ v.jsx(PAe, {}), children: /* @__PURE__ */ v.jsx(DAe, { chart: e }) }) });
  const i = await _Ae(e, { lang: r, theme: n });
  return HF(i, {
    Fragment: k.Fragment,
    jsx: v.jsx,
    jsxs: v.jsxs,
    components: {
      pre: (o) => /* @__PURE__ */ v.jsx(j0, { ...o, code: e, lang: String(t) })
    }
  });
}
function zAe({ children: e }) {
  const t = e?.props?.children ?? "", n = e?.props?.className?.split("-")?.[1] || "bash", i = OAe() === "dark" ? "dark-plus" : "github-light", [o, s] = k.useState(!0), [a, c] = k.useState(
    /* @__PURE__ */ v.jsx(j0, { className: "animate-pulse", code: t, lang: n, children: e })
  );
  return k.useLayoutEffect(() => {
    rN().map(() => IAe(t, n, i)).ifOk(c).watch(() => s(!1));
  }, [i, n, t]), /* @__PURE__ */ v.jsx(
    "div",
    {
      className: oN(
        o && "animate-pulse",
        "text-sm flex bg-secondary/40 shadow border flex-col rounded relative my-4 overflow-hidden"
      ),
      children: a
    }
  );
}
function x7({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "table-container",
      className: "relative w-full overflow-x-auto",
      children: /* @__PURE__ */ v.jsx(
        "table",
        {
          "data-slot": "table",
          className: at("w-full caption-bottom text-sm", e),
          ...t
        }
      )
    }
  );
}
function w7({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "thead",
    {
      "data-slot": "table-header",
      className: at("[&_tr]:border-b", e),
      ...t
    }
  );
}
function S7({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "tbody",
    {
      "data-slot": "table-body",
      className: at("[&_tr:last-child]:border-0", e),
      ...t
    }
  );
}
function I0({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "tr",
    {
      "data-slot": "table-row",
      className: at(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        e
      ),
      ...t
    }
  );
}
function k7({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "th",
    {
      "data-slot": "table-head",
      className: at(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        e
      ),
      ...t
    }
  );
}
function Q_({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "td",
    {
      "data-slot": "table-cell",
      className: at(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        e
      ),
      ...t
    }
  );
}
const C7 = k.memo(({ children: e }) => /* @__PURE__ */ v.jsxs("span", { className: "fade-in animate-in duration-1000", children: [
  e,
  " "
] }));
C7.displayName = "FadeIn";
const LAe = k.memo(({ children: e }) => ah(e) ? /* @__PURE__ */ v.jsx(ng, { text: e }) : /* @__PURE__ */ v.jsx(v.Fragment, { children: e }));
LAe.displayName = "EntityText";
const Br = k.memo(({ children: e }) => {
  if (ah(e))
    return /* @__PURE__ */ v.jsx("span", { className: "fade-in animate-in duration-1000", children: /* @__PURE__ */ v.jsx(ng, { text: e }) });
  const t = [e].flat();
  return /* @__PURE__ */ v.jsx(v.Fragment, { children: t.map(
    (n, r) => ah(n) ? /* @__PURE__ */ v.jsx(C7, { children: /* @__PURE__ */ v.jsx(ng, { text: n }) }, r) : n
  ) });
});
Br.displayName = "WordByWordFadeIn";
const BAe = {
  table: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("div", { className: "my-1", children: /* @__PURE__ */ v.jsx(x7, { ...n, children: t }) }),
  thead: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(w7, { ...n, children: t }),
  tbody: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(S7, { ...n, children: t }),
  tr: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(I0, { ...n, children: t }),
  th: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(k7, { ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  td: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(Q_, { ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  code: ({ children: e }) => /* @__PURE__ */ v.jsx("code", { className: "text-sm rounded-md bg-accent text-primary py-1 px-2 mx-0.5", children: /* @__PURE__ */ v.jsx(Br, { children: e }) }),
  blockquote: ({ children: e }) => /* @__PURE__ */ v.jsx("div", { className: "px-4", children: /* @__PURE__ */ v.jsx("blockquote", { className: "relative bg-accent/30 p-6 rounded-2xl my-2 overflow-hidden border", children: /* @__PURE__ */ v.jsx(Br, { children: e }) }) }),
  p: ({ children: e }) => /* @__PURE__ */ v.jsx("p", { className: "leading-6 my-1 break-words", children: /* @__PURE__ */ v.jsx(Br, { children: e }) }),
  pre: ({ children: e }) => /* @__PURE__ */ v.jsx("div", { className: "px-4 py-2", children: /* @__PURE__ */ v.jsx(zAe, { children: e }) }),
  ol: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("ol", { className: "px-4 list-decimal list-outside ol-context", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  ul: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("ul", { className: "px-4 list-none ul-context", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  li: ({ node: e, children: t, ...n }) => {
    const r = k.useRef(null), [i, o] = k.useState(!1);
    return k.useEffect(() => {
      r.current?.parentElement?.tagName === "UL" && o(!0);
    }, []), /* @__PURE__ */ v.jsx("li", { ref: r, className: "py-1 break-words", ...n, children: i ? /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
      /* @__PURE__ */ v.jsx("span", { className: "text-green-500 mt-0.5", children: "" }),
      /* @__PURE__ */ v.jsx("div", { className: "flex-1", children: /* @__PURE__ */ v.jsx(Br, { children: t }) })
    ] }) : /* @__PURE__ */ v.jsx(Br, { children: t }) });
  },
  strong: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("span", { className: "font-semibold", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  a: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsxs(
    "a",
    {
      className: "text-primary hover:underline flex gap-1.5 items-center",
      target: "_blank",
      rel: "noreferrer",
      ...n,
      children: [
        /* @__PURE__ */ v.jsx(ZZ, { className: "size-3.5" }),
        /* @__PURE__ */ v.jsx(Br, { children: t })
      ]
    }
  ),
  h1: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h1", { className: "text-3xl font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  h2: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h2", { className: "text-2xl font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  h3: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h3", { className: "text-xl font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  h4: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h4", { className: "text-lg font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  h5: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h5", { className: "text-base font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  h6: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h6", { className: "text-sm font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  img: ({ node: e, children: t, ...n }) => {
    const { src: r, alt: i, ...o } = n;
    return r ? (
      // eslint-disable-next-line @next/next/no-img-element
      /* @__PURE__ */ v.jsx("img", { className: "mx-auto rounded-lg", src: r, alt: i, ...o })
    ) : null;
  }
}, $Ae = ({ children: e }) => /* @__PURE__ */ v.jsx("article", { className: "w-full h-full relative", children: yle(e) ? /* @__PURE__ */ v.jsx(Qu, { data: e }) : /* @__PURE__ */ v.jsx(uke, { components: BAe, remarkPlugins: [CEe], children: e }) }), E7 = k.memo(
  $Ae,
  (e, t) => e.children === t.children
), UAe = ({
  reasoningText: e,
  isThinking: t
}) => {
  const [n, r] = k.useState(!!t), [i, o] = k.useState(!!t);
  return k.useEffect(() => {
    t && !i ? (r(!0), o(!0)) : !t && i && (r(!1), o(!1));
  }, [t, i]), !e && !t ? null : /* @__PURE__ */ v.jsx("div", { className: "text-xs", children: n && /* @__PURE__ */ v.jsx("div", { className: "mt-2 pl-4 text-muted-foreground bg-muted/20 p-2 rounded-md", children: /* @__PURE__ */ v.jsx(E7, { children: e || (t ? "Reasoning..." : "No reasoning content available") }) }) });
}, FAe = k.memo(UAe), _7 = ({
  text: e,
  onReuseMessage: t,
  onRegenerate: n,
  className: r = ""
}) => {
  const [i, o] = k.useState(!1), [s, a] = k.useState(!1), [c, u] = k.useState(!1), f = async (g) => {
    g.preventDefault(), g.stopPropagation();
    try {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(e ?? ""), o(!0), cn.success("Message copied to clipboard", { duration: 2e3 }), setTimeout(() => o(!1), 3e3);
        return;
      }
      if (navigator.clipboard)
        try {
          await navigator.clipboard.writeText(e ?? ""), o(!0), setTimeout(() => o(!1), 3e3);
          return;
        } catch (x) {
          console.warn("Clipboard API failed, trying selection fallback:", x);
        }
      const b = document.createElement("textarea");
      b.value = e ?? "", b.style.position = "fixed", b.style.left = "-9999px", b.style.top = "-9999px", b.style.opacity = "0", b.setAttribute("readonly", ""), document.body.appendChild(b);
      try {
        b.select(), b.setSelectionRange(0, b.value.length);
        const x = window.getSelection();
        if (x) {
          x.removeAllRanges();
          const w = document.createRange();
          w.selectNodeContents(b), x.addRange(w), o(!0), setTimeout(() => o(!1), 3e3);
        } else
          throw new Error("Selection API not supported");
      } finally {
        document.body.removeChild(b);
      }
    } catch (b) {
      console.warn("All copy methods failed:", b), alert("Unable to copy automatically. Please select and copy the text manually.");
    }
  }, h = async (g) => {
    if (g.preventDefault(), g.stopPropagation(), t && e && !s)
      try {
        a(!0), await new Promise((b) => setTimeout(b, 300)), t(e);
      } finally {
        a(!1);
      }
  }, m = async (g) => {
    if (g.preventDefault(), g.stopPropagation(), n && !c)
      try {
        u(!0), await n(), cn.success("Regenerating response...", { duration: 2e3 });
      } catch {
        cn.error("Failed to regenerate", { duration: 2e3 });
      } finally {
        u(!1);
      }
  };
  return /* @__PURE__ */ v.jsxs("div", { className: `flex gap-1 ${r}`, "data-testid": "message-action-buttons", children: [
    n && /* @__PURE__ */ v.jsx(
      "button",
      {
        "aria-label": c ? "Regenerating..." : "Regenerate response",
        title: c ? "Regenerating..." : "Regenerate response",
        onClick: (g) => m(g),
        disabled: c,
        className: `p-1 rounded-lg transition-all cursor-pointer ${c ? "opacity-100 bg-purple-100 dark:bg-purple-900/30" : "hover:bg-muted/20 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 md:opacity-0 md:group-hover:opacity-100"}`,
        children: c ? /* @__PURE__ */ v.jsx(Zs, { className: "h-4 w-4 text-purple-500 animate-spin" }) : /* @__PURE__ */ v.jsx(gY, { className: "h-4 w-4 text-muted-foreground" })
      }
    ),
    /* @__PURE__ */ v.jsx(
      "button",
      {
        "aria-label": s ? "Loading..." : "Reuse this message",
        title: s ? "Loading..." : "Reuse this message",
        onClick: (g) => h(g),
        disabled: s,
        className: `p-1 rounded-lg transition-all cursor-pointer ${s ? "opacity-100 bg-blue-100 dark:bg-blue-900/30" : "hover:bg-muted/20 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 md:opacity-0 md:group-hover:opacity-100"}`,
        children: s ? /* @__PURE__ */ v.jsx(Zs, { className: "h-4 w-4 text-blue-500 animate-spin" }) : /* @__PURE__ */ v.jsx(UT, { className: "h-4 w-4 text-muted-foreground" })
      }
    ),
    /* @__PURE__ */ v.jsx(
      "button",
      {
        "aria-label": "Copy message",
        title: "Copy message",
        onClick: (g) => f(g),
        className: `p-1 rounded-lg transition-all cursor-pointer ${i ? "opacity-100 bg-green-100 dark:bg-green-900/30" : "hover:bg-muted/20 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 md:opacity-0 md:group-hover:opacity-100"}`,
        children: i ? /* @__PURE__ */ v.jsx(Sc, { className: "h-4 w-4 text-green-500" }) : /* @__PURE__ */ v.jsx(kc, { className: "h-4 w-4 text-muted-foreground" })
      }
    )
  ] });
};
async function VAe(e) {
  const t = await Lc(), n = new FormData();
  n.append("file", e);
  const r = await fetch(`${Wa}/files/upload`, { method: "POST", headers: t, body: n });
  if (!r.ok) throw new Error(`Upload failed (${r.status})`);
  return r.json().catch(() => null);
}
async function HAe(e, t) {
  const n = await Lc(), r = await fetch(`${Wa}/files/${encodeURIComponent(e)}`, { headers: n });
  if (!r.ok) throw new Error(`Download failed (${r.status})`);
  const i = await r.blob(), o = URL.createObjectURL(i);
  {
    const s = document.createElement("a");
    s.href = o, s.download = e, document.body.appendChild(s), s.click(), s.remove(), setTimeout(() => URL.revokeObjectURL(o), 1e3);
  }
}
const WAe = ({ files: e, className: t = "" }) => {
  const n = (s) => s.startsWith("image/") ? /* @__PURE__ */ v.jsx(WZ, { className: "h-4 w-4" }) : s === "application/pdf" ? /* @__PURE__ */ v.jsx(zZ, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(BZ, { className: "h-4 w-4" }), r = (s) => s.startsWith("image/"), i = async (s) => {
    try {
      if (s.s3Key) {
        HAe(s.s3Key, { forceDownload: !0 }), cn.success("Download started");
        return;
      }
      if (s.s3Url) {
        const a = document.createElement("a");
        a.href = s.s3Url, a.rel = "noopener", a.target = "_blank", a.download = s.fileName, document.body.appendChild(a), a.click(), a.remove(), cn.success("Download started");
        return;
      }
      cn.error("File not available");
    } catch (a) {
      console.error(a), cn.error("Download failed");
    }
  }, o = (s) => s < 1024 ? `${s} B` : s < 1048576 ? `${(s / 1024).toFixed(1)} KB` : `${(s / 1048576).toFixed(1)} MB`;
  return /* @__PURE__ */ v.jsx("div", { className: `flex flex-row justify-end flex-wrap gap-3 ${t} relative`, children: e.map((s, a) => {
    const c = s.status === "uploading";
    return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 items-end", children: [
      /* @__PURE__ */ v.jsxs(
        Rh,
        {
          variant: "outline",
          className: `flex items-center gap-2 w-fit px-3 py-2 rounded-lg shadow-sm transition-all duration-200 border-1 border-gray-300 dark:border-gray-600 ${c ? "opacity-80 cursor-default" : "cursor-pointer hover:bg-primary/10 hover:shadow-lg hover:border-primary/60 focus-visible:ring-2 focus-visible:ring-primary/40"}`,
          onClick: c ? void 0 : () => i(s),
          style: { userSelect: "text" },
          children: [
            n(s.mimeType),
            /* @__PURE__ */ v.jsx("span", { className: "text-sm font-medium truncate max-w-[180px]", children: s.fileName }),
            /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground ml-2", children: o(s.fileSize) }),
            c ? /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-1 ml-1 text-xs text-muted-foreground", children: [
              /* @__PURE__ */ v.jsx(Zs, { className: "h-3 w-3 animate-spin" }),
              /* @__PURE__ */ v.jsx("span", { children: "Uploading" })
            ] }) : /* @__PURE__ */ v.jsx(kE, { className: "h-3 w-3 ml-1 opacity-70 group-hover:opacity-100 transition" })
          ]
        }
      ),
      r(s.mimeType) && s.s3Url && /* @__PURE__ */ v.jsx(
        "img",
        {
          src: s.s3Url,
          alt: s.fileName,
          className: "max-w-xs max-h-64 rounded-xl border-2 border-gray-300 dark:border-gray-600 mt-1 shadow-md transition-all duration-200 hover:shadow-xl hover:border-primary/60 cursor-pointer",
          style: { objectFit: "cover" },
          onClick: () => i(s),
          title: "Click  ti nh"
        }
      )
    ] }, a);
  }) });
};
function qAe(e) {
  if (!e?.attachments || !Array.isArray(e.attachments)) return [];
  const t = [];
  for (const n of e.attachments) {
    if (!n) continue;
    const r = n.results;
    if (Array.isArray(r) && r.length > 0) {
      for (const o of r)
        o && t.push({
          fileName: o.fileName ?? o.file_name ?? o.name,
          fileSize: o.fileSize ?? o.size ?? 0,
          mimeType: o.mimeType ?? o.type ?? "application/octet-stream",
          s3Key: o.s3Key ?? o.key ?? o.keyName ?? void 0,
          s3Url: o.s3Url ?? o.url ?? o.location ?? void 0,
          status: o.status,
          ...o
        });
      continue;
    }
    const i = n;
    (i.fileName || i.mimeType || i.s3Key) && t.push({
      fileName: i.fileName ?? i.name,
      fileSize: i.fileSize ?? i.size ?? 0,
      mimeType: i.mimeType ?? i.type ?? "application/octet-stream",
      s3Key: i.s3Key ?? i.key ?? void 0,
      s3Url: i.s3Url ?? i.url ?? i.location ?? void 0,
      status: i.status,
      ...i
    });
  }
  return t;
}
const GAe = ({ mentions: e, className: t = "" }) => {
  if (!e || e.length === 0) return null;
  const n = (i) => {
    switch (i) {
      case "mcpTool":
        return /* @__PURE__ */ v.jsx(q0, { className: "h-3 w-3" });
      case "defaultTool":
        return /* @__PURE__ */ v.jsx(q0, { className: "h-3 w-3" });
      case "mcpServer":
        return /* @__PURE__ */ v.jsx(bD, { className: "h-3 w-3" });
      case "workflow":
        return /* @__PURE__ */ v.jsx(VY, { className: "h-3 w-3" });
      case "agent":
        return /* @__PURE__ */ v.jsx(cZ, { className: "h-3 w-3" });
      default:
        return /* @__PURE__ */ v.jsx(I3, { className: "h-3 w-3" });
    }
  }, r = (i) => i.label || i.name;
  return /* @__PURE__ */ v.jsx(Nh, { children: /* @__PURE__ */ v.jsx("div", { className: `flex flex-wrap gap-1 ${t}`, children: e.map((i, o) => /* @__PURE__ */ v.jsxs(Gi, { delayDuration: 200, children: [
    /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
      Rh,
      {
        variant: "outline",
        className: "flex items-center gap-1 text-xs px-2  bg-blue-50 dark:bg-blue-950 border-blue-200 dark:border-blue-800 text-blue-700 dark:text-blue-300",
        children: [
          n(i.type),
          /* @__PURE__ */ v.jsx("span", { className: "font-mono", children: r(i) })
        ]
      }
    ) }),
    /* @__PURE__ */ v.jsx(Bo, { className: "text-xs bg-card border border-border max-w-xs", children: /* @__PURE__ */ v.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
        n(i.type),
        /* @__PURE__ */ v.jsx("span", { className: "font-mono font-semibold", children: r(i) })
      ] }),
      /* @__PURE__ */ v.jsx("hr", { className: "border-border" }),
      /* @__PURE__ */ v.jsxs("div", { children: [
        /* @__PURE__ */ v.jsx("strong", { children: "Description:" }),
        " ",
        i.description || "No description"
      ] }),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-1", children: [
        /* @__PURE__ */ v.jsx(bD, { className: "h-3 w-3" }),
        /* @__PURE__ */ v.jsx("strong", { children: "Server:" }),
        " ",
        i.serverName || "Unknown"
      ] })
    ] }) })
  ] }, o)) }) });
};
function KAe(e, t = []) {
  let n = [];
  function r(o, s) {
    const a = k.createContext(s);
    a.displayName = o + "Context";
    const c = n.length;
    n = [...n, s];
    const u = (h) => {
      const { scope: m, children: g, ...b } = h, x = m?.[e]?.[c] || a, w = k.useMemo(() => b, Object.values(b));
      return /* @__PURE__ */ v.jsx(x.Provider, { value: w, children: g });
    };
    u.displayName = o + "Provider";
    function f(h, m) {
      const g = m?.[e]?.[c] || a, b = k.useContext(g);
      if (b) return b;
      if (s !== void 0) return s;
      throw new Error(`\`${h}\` must be used within \`${o}\``);
    }
    return [u, f];
  }
  const i = () => {
    const o = n.map((s) => k.createContext(s));
    return function(a) {
      const c = a?.[e] || o;
      return k.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: c } }),
        [a, c]
      );
    };
  };
  return i.scopeName = e, [r, ZAe(i, ...t)];
}
function ZAe(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(o) {
      const s = r.reduce((a, { useScope: c, scopeName: u }) => {
        const h = c(o)[`__scope${u}`];
        return { ...a, ...h };
      }, {});
      return k.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var YAe = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], sN = YAe.reduce((e, t) => {
  const n = /* @__PURE__ */ qx(`Primitive.${t}`), r = k.forwardRef((i, o) => {
    const { asChild: s, ...a } = i, c = s ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ v.jsx(c, { ...a, ref: o });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function XAe() {
  return th.useSyncExternalStore(
    JAe,
    () => !0,
    () => !1
  );
}
function JAe() {
  return () => {
  };
}
var aN = "Avatar", [QAe] = KAe(aN), [eMe, T7] = QAe(aN), A7 = k.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, ...r } = e, [i, o] = k.useState("idle");
    return /* @__PURE__ */ v.jsx(
      eMe,
      {
        scope: n,
        imageLoadingStatus: i,
        onImageLoadingStatusChange: o,
        children: /* @__PURE__ */ v.jsx(sN.span, { ...r, ref: t })
      }
    );
  }
);
A7.displayName = aN;
var M7 = "AvatarImage", tMe = k.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, src: r, onLoadingStatusChange: i = () => {
    }, ...o } = e, s = T7(M7, n), a = nMe(r, o), c = Dr((u) => {
      i(u), s.onImageLoadingStatusChange(u);
    });
    return Er(() => {
      a !== "idle" && c(a);
    }, [a, c]), a === "loaded" ? /* @__PURE__ */ v.jsx(sN.img, { ...o, ref: t, src: r }) : null;
  }
);
tMe.displayName = M7;
var N7 = "AvatarFallback", R7 = k.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, delayMs: r, ...i } = e, o = T7(N7, n), [s, a] = k.useState(r === void 0);
    return k.useEffect(() => {
      if (r !== void 0) {
        const c = window.setTimeout(() => a(!0), r);
        return () => window.clearTimeout(c);
      }
    }, [r]), s && o.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ v.jsx(sN.span, { ...i, ref: t }) : null;
  }
);
R7.displayName = N7;
function tL(e, t) {
  return e ? t ? (e.src !== t && (e.src = t), e.complete && e.naturalWidth > 0 ? "loaded" : "loading") : "error" : "idle";
}
function nMe(e, { referrerPolicy: t, crossOrigin: n }) {
  const r = XAe(), i = k.useRef(null), o = r ? (i.current || (i.current = new window.Image()), i.current) : null, [s, a] = k.useState(
    () => tL(o, e)
  );
  return Er(() => {
    a(tL(o, e));
  }, [o, e]), Er(() => {
    const c = (h) => () => {
      a(h);
    };
    if (!o) return;
    const u = c("loaded"), f = c("error");
    return o.addEventListener("load", u), o.addEventListener("error", f), t && (o.referrerPolicy = t), typeof n == "string" && (o.crossOrigin = n), () => {
      o.removeEventListener("load", u), o.removeEventListener("error", f);
    };
  }, [o, n, t]), s;
}
var rMe = A7, iMe = R7;
function nL({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    rMe,
    {
      "data-slot": "avatar",
      className: at("relative flex size-8 shrink-0 overflow-hidden rounded-full", e),
      ...t
    }
  );
}
function rL({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    iMe,
    {
      "data-slot": "avatar-fallback",
      className: at("bg-muted flex size-full items-center justify-center rounded-full", e),
      ...t
    }
  );
}
function oMe(e) {
  let t = 0;
  for (let r = 0; r < e.length; r++)
    t = e.charCodeAt(r) + ((t << 5) - t);
  return `hsl(${Math.abs(t) % 360}, 70%, 45%)`;
}
const sMe = ({
  part: e,
  isLast: t,
  message: n,
  onReuseMessage: r
}) => {
  const i = k.useRef(null), [o, s] = k.useState(!1), [a, c] = k.useState([]), { user: u } = DU();
  if (!n.parts) return null;
  const f = (() => {
    const m = n.metadata;
    if (!m?.attachments || !Array.isArray(m.attachments))
      return 0;
    let g = 0;
    for (const b of m.attachments)
      b && (Array.isArray(b.results) ? g += b.results.length : g += 1);
    return g;
  })();
  k.useEffect(() => {
    const m = n.metadata, g = qAe(m);
    c(g);
  }, [n.id, f, n.metadata?.attachments]), k.useEffect(() => {
    t && !o && (s(!0), i.current?.scrollIntoView({ behavior: "smooth" }));
  }, [t, o]);
  const h = n.metadata?.mentions;
  return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-1 w-full", ref: i, children: [
    /* @__PURE__ */ v.jsx("div", { className: "flex justify-end my-2 ", children: /* @__PURE__ */ v.jsxs("div", { className: "group flex items-start gap-2", children: [
      /* @__PURE__ */ v.jsx("div", { className: "relative flex flex-col gap-2 items-end", children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ v.jsx(
          _7,
          {
            text: e.text ?? "",
            onReuseMessage: r,
            className: "ml-2"
          }
        ),
        /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2", children: [
          /* @__PURE__ */ v.jsx("div", { className: "bg-neutral-200 dark:bg-neutral-700 px-3 py-2 rounded-md text-sm text-foreground", children: /* @__PURE__ */ v.jsx(ng, { text: e.text ?? "" }) }),
          h && h.length > 0 && /* @__PURE__ */ v.jsx(GAe, { mentions: h, className: "justify-end" })
        ] })
      ] }) }),
      /* @__PURE__ */ v.jsx("span", { className: "shrink-0 mt-1", children: u != null ? /* @__PURE__ */ v.jsx(nL, { children: /* @__PURE__ */ v.jsx(
        rL,
        {
          className: "text-xs text-primary-foreground items-center",
          title: u.emailAddresses[0]?.emailAddress ?? "",
          style: {
            backgroundColor: oMe(u.id)
          },
          children: u.emailAddresses[0]?.emailAddress.slice(0, 2).toUpperCase() ?? ""
        }
      ) }) : /* @__PURE__ */ v.jsx(nL, { children: /* @__PURE__ */ v.jsx(rL, { children: "No Avatar" }) }) })
    ] }) }),
    /* @__PURE__ */ v.jsx("div", { className: "px-10", children: a.length > 0 && /* @__PURE__ */ v.jsx(WAe, { files: a, className: "mt-1" }) })
  ] });
}, aMe = ({
  steps: e,
  defaultExpanded: t = !1
}) => {
  const [n, r] = k.useState(t), i = e.filter(
    (a) => a.type === "tool_call" || a.type === "complete" || a.type === "error" || a.type === "planning"
  );
  if (i.length === 0) return null;
  const o = i.filter((a) => a.type === "complete").length, s = i.filter((a) => a.type === "error").length;
  return /* @__PURE__ */ v.jsxs("div", { className: "mt-2 text-xs", children: [
    /* @__PURE__ */ v.jsxs(
      "button",
      {
        onClick: () => r(!n),
        className: "flex items-center gap-1.5 text-gray-500 dark:text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 transition-colors",
        children: [
          n ? /* @__PURE__ */ v.jsx(Ag, { className: "w-3.5 h-3.5" }) : /* @__PURE__ */ v.jsx(Mg, { className: "w-3.5 h-3.5" }),
          /* @__PURE__ */ v.jsxs("span", { className: "text-xs", children: [
            o > 0 && `${o} step${o > 1 ? "s" : ""}`,
            s > 0 && `  ${s} error${s > 1 ? "s" : ""}`
          ] })
        ]
      }
    ),
    /* @__PURE__ */ v.jsx(CA, { children: n && /* @__PURE__ */ v.jsx(
      Wf.div,
      {
        initial: { opacity: 0, height: 0 },
        animate: { opacity: 1, height: "auto" },
        exit: { opacity: 0, height: 0 },
        transition: { duration: 0.2 },
        className: "mt-2 pl-5 space-y-1.5 overflow-hidden",
        children: i.map((a) => /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
          /* @__PURE__ */ v.jsx("div", { className: "mt-0.5 shrink-0", children: a.type === "complete" ? /* @__PURE__ */ v.jsx("div", { className: "w-3.5 h-3.5 rounded-full bg-green-500 flex items-center justify-center", children: /* @__PURE__ */ v.jsx(Sc, { className: "w-2.5 h-2.5 text-white", strokeWidth: 3 }) }) : a.type === "error" ? /* @__PURE__ */ v.jsx("div", { className: "w-3.5 h-3.5 rounded-full bg-red-500 flex items-center justify-center", children: /* @__PURE__ */ v.jsx(Ng, { className: "w-2.5 h-2.5 text-white", strokeWidth: 3 }) }) : /* @__PURE__ */ v.jsx("div", { className: "w-3.5 h-3.5 rounded-full bg-blue-500" }) }),
          /* @__PURE__ */ v.jsxs("div", { className: "flex-1 min-w-0", children: [
            /* @__PURE__ */ v.jsx(
              "div",
              {
                className: at(
                  "text-xs",
                  a.type === "complete" && "text-gray-600 dark:text-gray-400",
                  a.type === "error" && "text-red-600 dark:text-red-400",
                  a.type !== "complete" && a.type !== "error" && "text-gray-700 dark:text-gray-300"
                ),
                children: a.message
              }
            ),
            a.details && /* @__PURE__ */ v.jsx("div", { className: "text-[10px] text-gray-400 dark:text-gray-600 mt-0.5 truncate", children: a.details })
          ] })
        ] }, a.id))
      }
    ) })
  ] });
}, lMe = ({
  part: e,
  message: t,
  // showActions,
  // isLoading,
  showAvatar: n,
  regenerate: r,
  onReuseMessage: i
}) => {
  const o = La.getMessageSteps(t.id);
  return /* @__PURE__ */ v.jsx(v.Fragment, { children: /* @__PURE__ */ v.jsxs("div", { className: "group flex items-start gap-2", children: [
    n && /* @__PURE__ */ v.jsx("span", { className: "shrink-0 mt-1", children: /* @__PURE__ */ v.jsx(LT, { className: "h-5 w-5 text-blue-400" }) }),
    /* @__PURE__ */ v.jsxs("div", { className: "relative flex flex-col w-full", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ v.jsx("div", { className: "text-foreground text-sm max-w-[70vw] wrap-break-word", children: /* @__PURE__ */ v.jsx("div", { className: "prose prose-sm dark:prose-invert prose-p:my-0 prose-ul:my-1 prose-ol:my-1 prose-pre:my-1", children: /* @__PURE__ */ v.jsx(E7, { children: e.text }) }) }),
        /* @__PURE__ */ v.jsx(
          _7,
          {
            text: e.text ?? "",
            onReuseMessage: i,
            onRegenerate: r ? () => r({ messageId: t.id }) : void 0,
            className: "ml-2"
          }
        )
      ] }),
      o && o.length > 0 && /* @__PURE__ */ v.jsx(
        aMe,
        {
          steps: o,
          messageId: t.id,
          defaultExpanded: !1
        }
      )
    ] })
  ] }) });
}, cMe = k.memo(lMe, (e, t) => !(e.isLoading !== t.isLoading || e.showActions !== t.showActions || e.part.text !== t.part.text));
function O7({
  data: e,
  className: t = "",
  defaultExpandAll: n = !0
}) {
  const { copied: r, copy: i } = iN(), [o, s] = k.useState(n), [a, c] = k.useState(!1);
  return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
    /* @__PURE__ */ v.jsxs("div", { className: `w-full flex flex-col ${t}`, children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex gap-2 ml-auto mb-2", children: [
        /* @__PURE__ */ v.jsx(
          Ht,
          {
            variant: "ghost",
            size: "icon",
            className: "size-3! p-4! cursor-pointer",
            onClick: () => s(!o),
            title: o ? "Collapse All" : "Expand All",
            children: o ? /* @__PURE__ */ v.jsx(vD, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(gD, { className: "h-4 w-4" })
          }
        ),
        /* @__PURE__ */ v.jsx(
          Ht,
          {
            variant: "ghost",
            size: "icon",
            className: "size-3! p-4! cursor-pointer",
            onClick: () => i(ah(e) ? e : JSON.stringify(e)),
            title: "Copy JSON",
            children: r ? /* @__PURE__ */ v.jsx(Sc, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(kc, { className: "h-4 w-4" })
          }
        ),
        /* @__PURE__ */ v.jsx(
          Ht,
          {
            variant: "ghost",
            size: "icon",
            className: "size-3! p-4! cursor-pointer",
            onClick: () => c(!0),
            title: "Open in Popup",
            children: /* @__PURE__ */ v.jsx(NZ, { className: "h-4 w-4" })
          }
        )
      ] }),
      /* @__PURE__ */ v.jsx(Qu, { data: e, expandAll: o })
    ] }),
    /* @__PURE__ */ v.jsx(Oh, { open: a, onOpenChange: c, children: /* @__PURE__ */ v.jsxs(Dh, { className: "max-w-4xl max-h-[80vh] flex flex-col", children: [
      /* @__PURE__ */ v.jsx(Ug, { children: /* @__PURE__ */ v.jsxs(Ph, { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ v.jsx("span", { children: "JSON Data Viewer" }),
        /* @__PURE__ */ v.jsxs("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "ghost",
              size: "icon",
              className: "size-8! cursor-pointer",
              onClick: () => s(!o),
              title: o ? "Collapse All" : "Expand All",
              children: o ? /* @__PURE__ */ v.jsx(vD, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(gD, { className: "h-4 w-4" })
            }
          ),
          /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "ghost",
              size: "icon",
              className: "size-8! cursor-pointer",
              onClick: () => i(ah(e) ? e : JSON.stringify(e)),
              title: "Copy JSON",
              children: r ? /* @__PURE__ */ v.jsx(Sc, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(kc, { className: "h-4 w-4" })
            }
          )
        ] })
      ] }) }),
      /* @__PURE__ */ v.jsx("div", { className: "flex-1 overflow-auto p-4 bg-muted/20 rounded-md", children: /* @__PURE__ */ v.jsx(Qu, { data: e, expandAll: o }) })
    ] }) })
  ] });
}
function uMe({
  data: e,
  open: t,
  onOpenChange: n,
  children: r
}) {
  return /* @__PURE__ */ v.jsxs(Oh, { open: t, onOpenChange: n, children: [
    /* @__PURE__ */ v.jsx(f$, { asChild: !0, children: r || /* @__PURE__ */ v.jsx(
      Ht,
      {
        variant: "ghost",
        size: "sm",
        className: "text-muted-foreground text-xs",
        children: "JSON"
      }
    ) }),
    /* @__PURE__ */ v.jsxs(Dh, { className: "max-w-[70vw] min-w-[40vw]", children: [
      /* @__PURE__ */ v.jsx(Ug, { children: /* @__PURE__ */ v.jsx(Ph, { className: "cursor-pointer", children: "JSON" }) }),
      /* @__PURE__ */ v.jsx("div", { className: "max-h-[70vh] w-full overflow-y-auto p-6 pt-0", children: /* @__PURE__ */ v.jsx(O7, { data: e }) })
    ] })
  ] });
}
var Lw = "Checkbox", [dMe] = ps(Lw), [fMe, lN] = dMe(Lw);
function hMe(e) {
  const {
    __scopeCheckbox: t,
    checked: n,
    children: r,
    defaultChecked: i,
    disabled: o,
    form: s,
    name: a,
    onCheckedChange: c,
    required: u,
    value: f = "on",
    // @ts-expect-error
    internal_do_not_use_render: h
  } = e, [m, g] = Qa({
    prop: n,
    defaultProp: i ?? !1,
    onChange: c,
    caller: Lw
  }), [b, x] = k.useState(null), [w, S] = k.useState(null), _ = k.useRef(!1), M = b ? !!s || !!b.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    !0
  ), N = {
    checked: m,
    disabled: o,
    setChecked: g,
    control: b,
    setControl: x,
    name: a,
    form: s,
    value: f,
    hasConsumerStoppedPropagationRef: _,
    required: u,
    defaultChecked: gc(i) ? !1 : i,
    isFormControl: M,
    bubbleInput: w,
    setBubbleInput: S
  };
  return /* @__PURE__ */ v.jsx(
    fMe,
    {
      scope: t,
      ...N,
      children: pMe(h) ? h(N) : r
    }
  );
}
var D7 = "CheckboxTrigger", P7 = k.forwardRef(
  ({ __scopeCheckbox: e, onKeyDown: t, onClick: n, ...r }, i) => {
    const {
      control: o,
      value: s,
      disabled: a,
      checked: c,
      required: u,
      setControl: f,
      setChecked: h,
      hasConsumerStoppedPropagationRef: m,
      isFormControl: g,
      bubbleInput: b
    } = lN(D7, e), x = Ft(i, f), w = k.useRef(c);
    return k.useEffect(() => {
      const S = o?.form;
      if (S) {
        const _ = () => h(w.current);
        return S.addEventListener("reset", _), () => S.removeEventListener("reset", _);
      }
    }, [o, h]), /* @__PURE__ */ v.jsx(
      Et.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": gc(c) ? "mixed" : c,
        "aria-required": u,
        "data-state": $7(c),
        "data-disabled": a ? "" : void 0,
        disabled: a,
        value: s,
        ...r,
        ref: x,
        onKeyDown: Ye(t, (S) => {
          S.key === "Enter" && S.preventDefault();
        }),
        onClick: Ye(n, (S) => {
          h((_) => gc(_) ? !0 : !_), b && g && (m.current = S.isPropagationStopped(), m.current || S.stopPropagation());
        })
      }
    );
  }
);
P7.displayName = D7;
var j7 = k.forwardRef(
  (e, t) => {
    const {
      __scopeCheckbox: n,
      name: r,
      checked: i,
      defaultChecked: o,
      required: s,
      disabled: a,
      value: c,
      onCheckedChange: u,
      form: f,
      ...h
    } = e;
    return /* @__PURE__ */ v.jsx(
      hMe,
      {
        __scopeCheckbox: n,
        checked: i,
        defaultChecked: o,
        disabled: a,
        required: s,
        onCheckedChange: u,
        name: r,
        form: f,
        value: c,
        internal_do_not_use_render: ({ isFormControl: m }) => /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
          /* @__PURE__ */ v.jsx(
            P7,
            {
              ...h,
              ref: t,
              __scopeCheckbox: n
            }
          ),
          m && /* @__PURE__ */ v.jsx(
            B7,
            {
              __scopeCheckbox: n
            }
          )
        ] })
      }
    );
  }
);
j7.displayName = Lw;
var I7 = "CheckboxIndicator", z7 = k.forwardRef(
  (e, t) => {
    const { __scopeCheckbox: n, forceMount: r, ...i } = e, o = lN(I7, n);
    return /* @__PURE__ */ v.jsx(
      Di,
      {
        present: r || gc(o.checked) || o.checked === !0,
        children: /* @__PURE__ */ v.jsx(
          Et.span,
          {
            "data-state": $7(o.checked),
            "data-disabled": o.disabled ? "" : void 0,
            ...i,
            ref: t,
            style: { pointerEvents: "none", ...e.style }
          }
        )
      }
    );
  }
);
z7.displayName = I7;
var L7 = "CheckboxBubbleInput", B7 = k.forwardRef(
  ({ __scopeCheckbox: e, ...t }, n) => {
    const {
      control: r,
      hasConsumerStoppedPropagationRef: i,
      checked: o,
      defaultChecked: s,
      required: a,
      disabled: c,
      name: u,
      value: f,
      form: h,
      bubbleInput: m,
      setBubbleInput: g
    } = lN(L7, e), b = Ft(n, g), x = YA(o), w = jA(r);
    k.useEffect(() => {
      const _ = m;
      if (!_) return;
      const M = window.HTMLInputElement.prototype, P = Object.getOwnPropertyDescriptor(
        M,
        "checked"
      ).set, I = !i.current;
      if (x !== o && P) {
        const O = new Event("click", { bubbles: I });
        _.indeterminate = gc(o), P.call(_, gc(o) ? !1 : o), _.dispatchEvent(O);
      }
    }, [m, x, o, i]);
    const S = k.useRef(gc(o) ? !1 : o);
    return /* @__PURE__ */ v.jsx(
      Et.input,
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: s ?? S.current,
        required: a,
        disabled: c,
        name: u,
        value: f,
        form: h,
        ...t,
        tabIndex: -1,
        ref: b,
        style: {
          ...t.style,
          ...w,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
B7.displayName = L7;
function pMe(e) {
  return typeof e == "function";
}
function gc(e) {
  return e === "indeterminate";
}
function $7(e) {
  return gc(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function U7({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    j7,
    {
      "data-slot": "checkbox",
      className: at(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        e
      ),
      ...t,
      children: /* @__PURE__ */ v.jsx(
        z7,
        {
          "data-slot": "checkbox-indicator",
          className: "flex items-center justify-center text-current transition-none",
          children: /* @__PURE__ */ v.jsx(Sc, { className: "size-3.5" })
        }
      )
    }
  );
}
const mMe = async () => {
  if (typeof window > "u")
    throw new Error("XLSX can only be loaded in browser environment");
  return window.XLSX ? window.XLSX : new Promise((e, t) => {
    const n = document.createElement("script");
    n.src = "https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js", n.onload = () => {
      window.XLSX ? e(window.XLSX) : t(new Error("Failed to load XLSX library"));
    }, n.onerror = () => t(new Error("Failed to load XLSX script")), document.head.appendChild(n);
  });
};
function gMe(e) {
  const { title: t, data: n, columns: r, description: i } = e, o = 20, s = !0, [a, c] = k.useState(""), [u, f] = k.useState(null), [h, m] = k.useState(null), [g, b] = k.useState(1), [x, w] = k.useState(
    new Set(r.map((B) => B.key))
  ), S = (B, G = "string") => {
    if (B == null) return "";
    switch (G) {
      case "number":
        return typeof B == "number" ? B.toLocaleString() : B;
      case "boolean":
        return B ? "Yes" : "No";
      case "date":
        try {
          return new Date(B).toLocaleDateString();
        } catch {
          return B;
        }
      default:
        return String(B);
    }
  }, _ = (B, G) => {
    if (!G || !B) return B;
    const Y = new RegExp(`(${G})`, "gi");
    return String(B).split(Y).map(
      (ie, ne) => Y.test(ie) ? /* @__PURE__ */ v.jsx("mark", { className: "bg-yellow-200 dark:bg-yellow-800", children: ie }, ne) : ie
    );
  }, M = k.useMemo(() => {
    let B = [...n];
    return a && s && (B = B.filter(
      (G) => Object.values(G).some(
        (Y) => String(Y).toLowerCase().includes(a.toLowerCase())
      )
    )), u && h && B.sort((G, Y) => {
      const he = G[u], ie = Y[u], H = r.find((X) => X.key === u)?.type || "string";
      let Q = 0;
      switch (H) {
        case "number":
          Q = Number(he || 0) - Number(ie || 0);
          break;
        case "date":
          Q = new Date(he || 0).getTime() - new Date(ie || 0).getTime();
          break;
        case "boolean":
          Q = (he ? 1 : 0) - (ie ? 1 : 0);
          break;
        default:
          Q = String(he || "").localeCompare(
            String(ie || "")
          );
      }
      return h === "asc" ? Q : -Q;
    }), B;
  }, [n, a, u, h]), N = Math.ceil(M.length / o), P = M.slice(
    (g - 1) * o,
    g * o
  ), I = (B) => {
    u === B ? (m(
      h === "asc" ? "desc" : h === "desc" ? null : "asc"
    ), h === "desc" && f(null)) : (f(B), m("asc"));
  }, O = () => {
    const B = r.filter((ne) => x.has(ne.key)), G = [
      // Header
      B.map((ne) => ne.label).join(","),
      // Data rows
      ...M.map(
        (ne) => B.map((H) => `"${S(ne[H.key], H.type)}"`).join(",")
      )
    ].join(`
`), Y = new Blob([G], { type: "text/csv" }), he = URL.createObjectURL(Y), ie = document.createElement("a");
    ie.href = he, ie.download = `${t.replace(/\s+/g, "_")}.csv`, ie.click(), URL.revokeObjectURL(he);
  }, L = async () => {
    try {
      const B = await mMe(), G = r.filter((H) => x.has(H.key)), Y = [
        // Header row
        G.map((H) => H.label),
        // Data rows
        ...M.map(
          (H) => G.map((Q) => {
            const X = H[Q.key];
            switch (Q.type) {
              case "number":
                return typeof X == "number" ? X : Number(X) || X;
              case "date":
                return X instanceof Date ? X : new Date(X);
              case "boolean":
                return X;
              default:
                return X;
            }
          })
        )
      ], he = B.utils.book_new(), ie = B.utils.aoa_to_sheet(Y), ne = G.map((H) => {
        const Q = Math.max(
          H.label.length,
          ...M.map(
            (X) => String(S(X[H.key], H.type) || "").length
          )
        );
        return { wch: Math.min(Math.max(Q + 2, 10), 50) };
      });
      ie["!cols"] = ne, B.utils.book_append_sheet(he, ie, "Data"), B.writeFile(he, `${t.replace(/\s+/g, "_")}.xlsx`);
    } catch (B) {
      console.error("Failed to export Excel:", B), O();
    }
  }, U = r.filter(
    (B) => x.has(B.key)
  );
  return /* @__PURE__ */ v.jsx("div", { className: "px-6", children: /* @__PURE__ */ v.jsxs(i9, { className: "w-full px-0", children: [
    /* @__PURE__ */ v.jsxs(o9, { children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
        /* @__PURE__ */ v.jsxs(Yle, { className: "w-full flex items-center gap-2 justify-between", children: [
          "Interactive Table - ",
          t,
          /* @__PURE__ */ v.jsx(uMe, { data: e })
        ] }),
        i && /* @__PURE__ */ v.jsx(Xle, { className: "mt-2 ", children: i })
      ] }),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 mt-4", children: [
        /* @__PURE__ */ v.jsx("div", { className: "flex-1", children: /* @__PURE__ */ v.jsx(
          eM,
          {
            placeholder: "Search across all columns...",
            value: a,
            onChange: (B) => {
              c(B.target.value), b(1);
            },
            className: "hover:bg-input bg-secondary/40 transition-colors border-transparent border-none! focus-visible:bg-input! ring-0!"
          }
        ) }),
        /* @__PURE__ */ v.jsxs(ed, { children: [
          /* @__PURE__ */ v.jsx(td, { asChild: !0, children: /* @__PURE__ */ v.jsxs(Ht, { variant: "ghost", className: "data-[state=open]:bg-accent", children: [
            /* @__PURE__ */ v.jsx(BT, { className: "size-3.5" }),
            "Columns"
          ] }) }),
          /* @__PURE__ */ v.jsx(nd, { children: r.map((B) => /* @__PURE__ */ v.jsx(
            _fe,
            {
              checked: x.has(B.key),
              onClick: (G) => {
                G.stopPropagation(), G.preventDefault();
                const Y = new Set(x);
                !Y.has(B.key) ? Y.add(B.key) : Y.delete(B.key), w(Y);
              },
              children: B.label
            },
            B.key
          )) })
        ] }),
        /* @__PURE__ */ v.jsxs(ed, { children: [
          /* @__PURE__ */ v.jsx(td, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
            Ht,
            {
              variant: "ghost",
              className: "data-[state=open]:bg-accent",
              children: [
                /* @__PURE__ */ v.jsx(kE, { className: "size-3.5" }),
                "Export"
              ]
            }
          ) }),
          /* @__PURE__ */ v.jsxs(nd, { children: [
            /* @__PURE__ */ v.jsxs(ls, { onClick: O, children: [
              /* @__PURE__ */ v.jsx(kE, { className: "h-4 w-4 mr-2" }),
              "CSV"
            ] }),
            /* @__PURE__ */ v.jsxs(ls, { onClick: L, children: [
              /* @__PURE__ */ v.jsx(jZ, { className: "h-4 w-4 mr-2" }),
              "Excel"
            ] })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ v.jsxs(s9, { className: "px-0 relative", children: [
      /* @__PURE__ */ v.jsxs(x7, { children: [
        /* @__PURE__ */ v.jsx(w7, { className: "bg-secondary border-t", children: /* @__PURE__ */ v.jsx(I0, { children: U.map((B, G) => /* @__PURE__ */ v.jsx(
          k7,
          {
            className: `relative select-none ${G === 0 ? "pl-6" : G === U.length - 1 ? "pr-6" : ""} ${B.type === "number" || B.type === "date" || B.type === "boolean" ? "text-center" : ""}`,
            children: /* @__PURE__ */ v.jsxs(
              "div",
              {
                className: `flex items-center gap-2 cursor-pointer ${B.type === "number" || B.type === "date" ? "justify-center" : ""}`,
                onClick: () => I(B.key),
                children: [
                  /* @__PURE__ */ v.jsx("span", { className: "hover:text-primary", children: B.label }),
                  /* @__PURE__ */ v.jsx(
                    eZ,
                    {
                      className: `h-3 w-3 ${u === B.key ? "" : "text-muted-foreground/30"}`
                    }
                  )
                ]
              }
            )
          },
          B.key
        )) }) }),
        /* @__PURE__ */ v.jsx(S7, { className: "min-h-[24rem]", children: P.length === 0 ? /* @__PURE__ */ v.jsx(I0, { children: /* @__PURE__ */ v.jsx(
          Q_,
          {
            colSpan: U.length,
            className: "text-center h-48",
            children: "No data found"
          }
        ) }) : P.map((B, G) => /* @__PURE__ */ v.jsx(I0, { className: "border-b!", children: U.map((Y, he) => /* @__PURE__ */ v.jsx(
          Q_,
          {
            className: `py-3 ${he === 0 ? "pl-6" : he === U.length - 1 ? "pr-6" : ""} ${Y.type === "number" || Y.type === "date" ? "text-center" : Y.type == "boolean" ? "flex items-center justify-center" : ""}`,
            children: Y.type == "boolean" ? /* @__PURE__ */ v.jsx(v.Fragment, { children: /* @__PURE__ */ v.jsx(U7, { checked: B[Y.key] }) }) : a && s ? _(
              S(B[Y.key], Y.type),
              a
            ) : S(B[Y.key], Y.type)
          },
          Y.key
        )) }, G)) })
      ] }),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between pt-4 px-6", children: [
        /* @__PURE__ */ v.jsxs("div", { className: "text-xs text-muted-foreground", children: [
          "Total rows: ",
          n.length
        ] }),
        N > 1 && /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ v.jsxs(
            Ht,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => b((B) => Math.max(1, B - 1)),
              disabled: g === 1,
              children: [
                /* @__PURE__ */ v.jsx(mZ, { className: "h-4 w-4" }),
                "Previous"
              ]
            }
          ),
          /* @__PURE__ */ v.jsxs("span", { className: "text-sm px-2", children: [
            "Page ",
            g,
            " of ",
            N
          ] }),
          /* @__PURE__ */ v.jsxs(
            Ht,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => b((B) => Math.min(N, B + 1)),
              disabled: g === N,
              children: [
                "Next",
                /* @__PURE__ */ v.jsx(Mg, { className: "h-4 w-4" })
              ]
            }
          )
        ] })
      ] })
    ] })
  ] }) });
}
function iL(e, t) {
  const n = (o) => o && (o.data || o.columns || o.rows || o.points || o.content || o.results), r = t?.content;
  if (n(r)) return r;
  if (n(t)) return t;
  const i = e?.content;
  return n(i) ? i : e ?? {};
}
function F7(e, t) {
  const {
    chatbotStore: { isStopStream: n }
  } = ra(), r = n.value;
  return k.useMemo(() => e === "output-error" ? {
    label: "Tool error",
    icon: /* @__PURE__ */ v.jsx(DZ, { className: "h-4 w-4 text-yellow-700" }),
    detail: t ?? "An error occurred while calling the tool."
  } : e.startsWith("output") ? {
    label: "Called tool",
    icon: /* @__PURE__ */ v.jsx(xZ, { className: "h-4 w-4 text-emerald-400" })
  } : e === "input-available" ? {
    label: "Calling tool",
    icon: /* @__PURE__ */ v.jsx(Zs, { className: "h-4 w-4 animate-spin text-muted-foreground" })
  } : r && e === "input-streaming" ? {
    label: "Tool call stopped",
    icon: /* @__PURE__ */ v.jsx(SZ, { className: "h-4 w-4 text-red-700" }),
    detail: "The tool call was stopped by the user."
  } : {
    label: "Connecting to app",
    icon: /* @__PURE__ */ v.jsx(Zs, { className: "h-4 w-4 animate-spin text-muted-foreground" })
  }, [e, t, r]);
}
const yMe = ({ toolName: e, state: t }) => {
  const n = F7(t), [r, i] = k.useState(!0);
  return /* @__PURE__ */ v.jsxs("div", { className: "", children: [
    /* @__PURE__ */ v.jsxs(
      Ht,
      {
        type: "button",
        variant: "ghost",
        size: "sm",
        onClick: () => i((o) => !o),
        className: "flex items-center gap-2 cursor-pointer px-3 py-2",
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-sm", children: [
            n.icon,
            /* @__PURE__ */ v.jsx("span", { className: "text-sm text-muted-foreground", children: n.label })
          ] }),
          /* @__PURE__ */ v.jsx(
            Ag,
            {
              className: `h-4 w-4 text-muted-foreground transition ${r ? "rotate-180" : ""}`
            }
          )
        ]
      }
    ),
    r && /* @__PURE__ */ v.jsxs(
      "div",
      {
        title: "AI Tool - Automated Data Processing",
        className: "flex items-center gap-2 border border-accent-background p-2",
        children: [
          /* @__PURE__ */ v.jsx("span", { className: "relative flex items-center", children: /* @__PURE__ */ v.jsx(IY, { className: "w-5 h-5 opacity-90" }) }),
          /* @__PURE__ */ v.jsx("div", { className: " py-0.5 rounded bg-muted text-foreground", children: e }),
          /* @__PURE__ */ v.jsx(CU, { className: "h-4 w-px bg-border" }),
          /* @__PURE__ */ v.jsx("div", { className: "text-muted-foreground", children: t })
        ]
      }
    )
  ] });
}, oL = k.memo(yMe), nr = {
  // General tools
  MODAL: "modal",
  CONTROL_BY_NAME: "controlbyname",
  PARSE_COORDINATES_SEARCH: "parsecoordinatesfromsearch",
  PARSE_COORDINATES: "parsecoordinates",
  PYTHON_EXECUTION: "python-execution",
  JAVASCRIPT_EXECUTION: "javascript-execution",
  CREATE_MODEL: "createmodel",
  HIDDEN: "hidden",
  PREPARE_ENTITY_UPDATE: "prepareentityupdate",
  // 24KTwin-Editor-MCP-Remote tools
  ENTITY_CONNECTION: "connect_entities",
  OPEN_CREATE_MANY_RELATIONSHIPS_UI: "open_create_many_relationships_ui",
  MOVE_ENTITIES: "move_entities",
  DELETE_ENTITIES: "delete_entities",
  CREATE_ENTITIES: "create_entities",
  ABC_TOOL: "abc",
  // Example: New ABC tool
  FALLBACK: "fallback"
};
function vMe(e) {
  const t = e.match(/^_([^_]+?)(?:-(?:\d+|latest))?_(.+)$/);
  return t ? {
    serverName: t[1],
    toolName: t[2]
  } : null;
}
const bMe = {
  [nr.MODAL]: /^(tool-?open-?modal|openModal|tool_open_modal|open-modal)$/i,
  [nr.CONTROL_BY_NAME]: /^contro(lbyname|lbyName|lbyNames|Names)$/i,
  [nr.PARSE_COORDINATES_SEARCH]: /^parsecoordinatesfromsearch$/i,
  [nr.PARSE_COORDINATES]: /^parsecoordinates$/i,
  [nr.PYTHON_EXECUTION]: /^python-execution$/i,
  [nr.JAVASCRIPT_EXECUTION]: /^javascript-execution$/i,
  [nr.CREATE_MODEL]: /^(createmodel|create-?model|createModel)$/i,
  [nr.PREPARE_ENTITY_UPDATE]: /^\s*(?:tool-)?prepareentityupdate/i
}, sL = {
  // 24KTwin-Editor-MCP-Remote tools
  "24KTwin-Editor-MCP-Remote.abc": nr.ABC_TOOL,
  //  New ABC tool added here 
  "24KTwin-Editor-MCP-Remote.connect_entities": nr.ENTITY_CONNECTION,
  "24KTwin-Editor-MCP-Remote.open_create_many_relationships_ui": nr.OPEN_CREATE_MANY_RELATIONSHIPS_UI,
  "24KTwin-Editor-MCP-Remote.move_entities": nr.MOVE_ENTITIES,
  "24KTwin-Editor-MCP-Remote.delete_entities": nr.DELETE_ENTITIES,
  "24KTwin-Editor-MCP-Remote.create_entities": nr.CREATE_ENTITIES
  // Add other MCP servers here
  // 'OtherServer.same_tool_name': TOOL_CATEGORIES.OTHER_CATEGORY,
}, aL = {
  connect_entities: nr.ENTITY_CONNECTION,
  open_create_many_relationships_ui: nr.OPEN_CREATE_MANY_RELATIONSHIPS_UI,
  move_entities: nr.MOVE_ENTITIES,
  delete_entities: nr.DELETE_ENTITIES,
  create_entities: nr.CREATE_ENTITIES
}, xMe = ["webSearch", "web-search", "search", "websearch"], vf = /* @__PURE__ */ new Map();
function wMe(e) {
  const t = vf.get(e);
  if (t) return t;
  let n;
  if (xMe.includes(e))
    return n = nr.HIDDEN, vf.set(e, n), n;
  const r = vMe(e);
  if (r) {
    const i = `${r.serverName}.${r.toolName}`;
    if (sL[i])
      return n = sL[i], vf.set(e, n), n;
    if (aL[r.toolName])
      return n = aL[r.toolName], vf.set(e, n), n;
  }
  for (const [i, o] of Object.entries(bMe))
    if (o.test(e))
      return n = i, vf.set(e, n), n;
  return n = nr.FALLBACK, vf.set(e, n), n;
}
const SMe = ({
  toolName: e,
  state: t,
  parts: n,
  errorText: r
}) => {
  const [i, o] = k.useState(!1), s = F7(t, r), a = k.useMemo(() => {
    if (n == null) return "No payload available.";
    try {
      return JSON.stringify(n, null, 2);
    } catch {
      return String(n);
    }
  }, [n]), c = k.useMemo(() => {
    if (!n && !n.input) return null;
    try {
      return JSON.stringify(n.input, null, 2);
    } catch {
      return String(n);
    }
  }, [n]), u = k.useMemo(() => {
    if (!n) return null;
    try {
      return JSON.stringify(n, null, 2);
    } catch {
      return String(n);
    }
  }, [n]), { copy: f, copied: h } = iN(), m = !c && !u, g = (b, x) => /* @__PURE__ */ v.jsxs("div", { className: "rounded-xl border border-border bg-card/20 p-3 text-xs text-foreground", children: [
    /* @__PURE__ */ v.jsx("div", { className: "flex items-center justify-between gap-2 text-[10px] uppercase tracking-[0.3em] text-muted-foreground", children: /* @__PURE__ */ v.jsx("span", { children: b }) }),
    /* @__PURE__ */ v.jsx("div", { className: "mt-2 max-h-full w-full overflow-auto whitespace-pre-wrap wrap-break-word text-sm text-foreground", children: /* @__PURE__ */ v.jsx(O7, { data: x }) })
  ] });
  return /* @__PURE__ */ v.jsxs("div", { className: "space-y-2 text-xs py-2", children: [
    /* @__PURE__ */ v.jsxs(
      Ht,
      {
        type: "button",
        variant: "ghost",
        size: "sm",
        onClick: () => o((b) => !b),
        className: "flex items-center gap-2 cursor-pointer px-3 py-2",
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-sm text-muted-foreground", children: [
            s.icon,
            /* @__PURE__ */ v.jsx("span", { className: "text-sm", children: s.label })
          ] }),
          /* @__PURE__ */ v.jsx(
            Ag,
            {
              className: `h-4 w-4 text-muted-foreground transition ${i ? "rotate-180" : ""}`
            }
          )
        ]
      }
    ),
    i && /* @__PURE__ */ v.jsxs("div", { className: "space-y-4 rounded-md border border-border p-4 dark:bg-zinc-950 shadow-lg shadow-black/40", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3 text-xs font-semibold text-muted-foreground", children: [
          /* @__PURE__ */ v.jsx("div", { className: "flex h-10 w-10 items-center justify-center rounded-2xl bg-muted text-sm font-semibold uppercase text-foreground", children: e?.[0] ?? "T" }),
          /* @__PURE__ */ v.jsxs("div", { children: [
            /* @__PURE__ */ v.jsx("p", { className: "text-sm font-semibold text-foreground", children: e }),
            /* @__PURE__ */ v.jsx("p", { className: "text-[11px] text-muted-foreground", children: t })
          ] })
        ] }),
        /* @__PURE__ */ v.jsx("p", { className: "text-[11px] text-muted-foreground", children: s.detail ?? "The agent is currently handling a tool request; expand to view the payload." })
      ] }),
      m ? /* @__PURE__ */ v.jsxs("div", { className: "rounded-md border border-border bg-card/20 p-3 text-xs text-foreground", children: [
        /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-2 text-[10px] uppercase tracking-[0.3em] text-muted-foreground", children: [
          /* @__PURE__ */ v.jsx("span", { children: "Tool payload (raw)" }),
          /* @__PURE__ */ v.jsxs(
            "button",
            {
              type: "button",
              onClick: () => f(a),
              className: "flex items-center gap-1 rounded-full border border-border px-3 py-1 text-[10px] font-semibold text-muted-foreground transition hover:border-foreground hover:text-foreground",
              children: [
                /* @__PURE__ */ v.jsx(kc, { className: "h-3 w-3" }),
                h ? "Copied" : "Copy"
              ]
            }
          )
        ] }),
        /* @__PURE__ */ v.jsx("div", { className: "mt-2 max-h-52 overflow-auto whitespace-pre-wrap break-words text-[12px] text-foreground", children: a })
      ] }) : /* @__PURE__ */ v.jsxs("div", { className: `grid gap-3 ${c && u ? "sm:grid-cols-2" : ""}`, children: [
        c && g("Request", c),
        u && g("Response", u)
      ] })
    ] })
  ] });
}, kMe = k.memo(SMe), CMe = k.lazy(
  () => import("./pie-chart-DwYDoyYu.js").then((e) => ({ default: e.PieChart }))
), EMe = k.lazy(
  () => import("./bar-chart-C--Zx00D.js").then((e) => ({ default: e.BarChart }))
), _Me = k.lazy(
  () => import("./line-chart-CYyRLRw9.js").then((e) => ({ default: e.LineChart }))
), TMe = ({
  part: e,
  addToolResult: t
}) => {
  const { input: n, output: r, state: i, errorText: o, toolCallId: s } = e, a = k.useMemo(() => lg(e), [e.type]), c = i.startsWith("output");
  k.useCallback(
    (m) => {
      t?.({
        tool: a,
        toolCallId: s,
        output: m
      }), console.log("Result", m);
    },
    [t, s, a]
  );
  const u = k.useMemo(() => {
    if (!(a === "createTable" || a === "CreateTable" || /table$/i.test(a))) return null;
    const g = iL(n, r), b = Array.isArray(g?.columns) ? g.columns : [], x = Array.isArray(g?.data) ? g.data : [], w = g?.title ?? "Table", S = g?.description;
    return !b.length || !x.length ? null : /* @__PURE__ */ v.jsx(
      gMe,
      {
        title: w,
        columns: b,
        data: x,
        description: S
      }
    );
  }, [a, n, r, c]), f = k.useMemo(() => {
    const m = /^(create)?bar(chart)?$/i.test(a), g = /^(create)?line(chart)?$/i.test(a), b = /^(create)?pie(chart)?$/i.test(a);
    if (!m && !g && !b) return null;
    const x = iL(n, r), w = x?.data ?? x?.rows ?? x?.points ?? [];
    if (!Array.isArray(w) || w.length === 0) return null;
    const S = x?.title ?? (m ? "Bar Chart" : g ? "Line Chart" : "Pie Chart"), _ = x?.description ?? void 0, M = x?.yAxisLabel ?? void 0;
    if (b) {
      const P = w.map((I) => ({
        label: I.label ?? I.xAxisLabel ?? "",
        value: I.value ?? 0
      }));
      return /* @__PURE__ */ v.jsx(CMe, { title: S, data: P, description: _ });
    }
    const N = "series" in w[0] ? w : w.map((P) => ({
      xAxisLabel: P.xAxisLabel,
      series: [{ seriesName: "Value", value: P.value }]
    }));
    return m ? /* @__PURE__ */ v.jsx(
      EMe,
      {
        title: S,
        data: N,
        description: _,
        yAxisLabel: M
      }
    ) : /* @__PURE__ */ v.jsx(
      _Me,
      {
        title: S,
        data: N,
        description: _,
        yAxisLabel: M
      }
    );
  }, [a, n, r, i]);
  switch (u ? "table" : f ? "chart" : wMe(a)) {
    case "table":
      return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 text-xs", children: [
        /* @__PURE__ */ v.jsx(oL, { toolName: a, state: i }),
        u
      ] });
    case "chart":
      return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 text-xs", children: [
        /* @__PURE__ */ v.jsx(oL, { toolName: a, state: i }),
        /* @__PURE__ */ v.jsx("div", { className: "rounded border bg-card p-3", children: /* @__PURE__ */ v.jsx(
          k.Suspense,
          {
            fallback: /* @__PURE__ */ v.jsx("div", { className: "h-44 w-full rounded-md opacity-50" }),
            children: f
          }
        ) })
      ] });
    // case TOOL_CATEGORIES.MODAL:
    //   return (
    //     <ModalOutput
    //       input={input}
    //       output={output}
    //       state={state}
    //       toolName={toolName}
    //     />
    //   );
    // case TOOL_CATEGORIES.CONTROL_BY_NAME:
    //   const controlData = getPayload(input, output);
    //   const items = Array.isArray(controlData && controlData.data && controlData.data.items)
    //   ? controlData.data.items
    //   : Array.isArray(controlData)
    //   ? controlData
    //   : [];
    //   return (
    //     items.length > 0 && (
    //       <div className="flex flex-col gap-2 text-xs">
    //         <RenderToolHeader toolName={toolName} state={state} />
    //         <div className="rounded border bg-card p-4">
    //           <ControlByNameHandler
    //             controlData={controlData}
    //             items={items}
    //           />
    //         </div>
    //       </div>
    //     )
    //   );
    // case TOOL_CATEGORIES.PARSE_COORDINATES_SEARCH:
    // case TOOL_CATEGORIES.PARSE_COORDINATES:
    //   return <GISModelCreator2
    //     input={input}
    //     output={output}
    //     toolName={toolName}
    //     state={state}
    //     isCompleted={isCompleted}
    //   />
    // case TOOL_CATEGORIES.JAVASCRIPT_EXECUTION:
    //   console.log("Rendering JavascriptExecution for toolName:", toolName);
    //   return (
    //     <CodeExecutor
    //       part={part}
    //       key={part.toolCallId}
    //       onResult={onToolCallDirect}
    //       type="javascript"
    //     />
    //   );
    // case TOOL_CATEGORIES.PYTHON_EXECUTION:
    //   console.log("Rendering PythonExecution for toolName:", toolName);
    //   return (
    //     <CodeExecutor
    //       part={part}
    //       key={part.toolCallId}
    //       onResult={onToolCallDirect}
    //       type="python"
    //     />
    //   );
    // case TOOL_CATEGORIES.CREATE_MODEL:  
    //   if (!isCompleted) return null;
    //   return <BrickModelCreators
    //     output={output}
    //     toolName={toolName}
    //     state={state}
    //     isCompleted={isCompleted}
    //   />;
    // case TOOL_CATEGORIES.ENTITY_CONNECTION: {
    //   const relationshipData = getPayload(input, output);
    //   if (!isCompleted) return null;
    //   if (!relationshipData || relationshipData.isError) return null;
    //   const connections = relationshipData.content[0].text.connections;
    //   return (
    //     <div className="flex flex-col gap-2 text-xs">
    //       <RenderToolHeader toolName={toolName} state={state} />
    //       <SetRelationshipOutput data={connections} />
    //     </div>
    //   );
    // }
    // case TOOL_CATEGORIES.OPEN_CREATE_MANY_RELATIONSHIPS_UI:
    //   const data = getPayload(input, output);
    //   if (!isCompleted) return null;
    //   if (!data) return null;
    //   const content = data.content[0].text;
    //   return (
    //     null
    //     // <ItemModals values={content} />
    //   );
    // case TOOL_CATEGORIES.PREPARE_ENTITY_UPDATE:
    //   const updateData = getPayload(input, output);
    //   if (!isCompleted) return null;
    //   if (!updateData) return null;
    //   return (
    //     <>
    //       <ToolMessageFallback  
    //       parts={part}
    //       toolName={toolName}
    //       state={state}
    //       errorText={errorText}
    //       />
    //       <EntityEditors data={output}  />
    //     </>
    //   );
    //   case TOOL_CATEGORIES.MOVE_ENTITIES:
    //     const moveData = getPayload(input, output);
    //     console.log(output);
    //     if (!isCompleted) return null;
    //     if (!moveData) return null;
    //     return (
    //       <>
    //         <ToolMessageFallback  
    //       parts={part}
    //       toolName={toolName}
    //       state={state}
    //       errorText={errorText}
    //       />
    //         <MoveEntitiesOutput data={output} />
    //       </>
    //     );
    //   case TOOL_CATEGORIES.DELETE_ENTITIES:
    //     const deleteData = getPayload(input, output);
    //     if (!isCompleted) return null;
    //     if (!deleteData) return null;
    //     return (
    //       <>
    //         <ToolMessageFallback  
    //       parts={part}
    //       toolName={toolName}
    //       state={state}
    //       errorText={errorText}
    //       />
    //         <DeleteEntitiesOutput data={output} />
    //       </>
    //     );
    //   case TOOL_CATEGORIES.CREATE_ENTITIES:
    //     const createData = getPayload(input, output);
    //     if (!isCompleted) return null;
    //     if (!createData) return null;
    //     return (
    //       <>
    //         <ToolMessageFallback  
    //       parts={part}
    //       toolName={toolName}
    //       state={state}
    //       errorText={errorText}
    //       />
    //         <CreateEntitiesOutput data={output} />
    //       </>
    //     );
    // case TOOL_CATEGORIES.HIDDEN:
    //   // Hide tools that should not be shown to end users
    //   return null;
    case nr.FALLBACK:
    default:
      return /* @__PURE__ */ v.jsx(
        kMe,
        {
          parts: e,
          toolName: a,
          state: i,
          errorText: o
        }
      );
  }
}, AMe = k.memo(TMe), MMe = ({
  message: e,
  prevMessage: t,
  threadId: n,
  isLoading: r,
  isLastMessage: i,
  status: o,
  className: s,
  setMessages: a,
  regenerate: c,
  addToolResult: u,
  messageIndex: f,
  sendMessage: h,
  onReuseMessage: m
}) => {
  const g = k.useMemo(() => e.role === "user", [e.role]);
  if (e.role === "system" || !e.parts.length) return null;
  let b = !1;
  return /* @__PURE__ */ v.jsx("div", { className: "w-full mx-auto max-w-3xl px-4 ", "data-role": e.role, children: /* @__PURE__ */ v.jsx("div", { className: s, children: /* @__PURE__ */ v.jsx("div", { className: "flex flex-col w-full", children: e.parts.map((x, w) => {
    const S = `message-${f}-part-${x.type}-${w}`, _ = w === e.parts.length - 1, N = e.role === "assistant" && x.type === "text" && !b;
    if (N && (b = !0), x.type === "reasoning")
      return /* @__PURE__ */ v.jsx(
        FAe,
        {
          reasoningText: x.text,
          isThinking: _ && i && r
        },
        S
      );
    if (g && x.type === "text" && x.text)
      return t ? /* @__PURE__ */ v.jsxs(k.Fragment, { children: [
        f !== 0 && /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-muted-foreground px-2", children: [
          /* @__PURE__ */ v.jsx(z3, { className: "w-4 h-4 opacity-50", "aria-hidden": !0 }),
          /* @__PURE__ */ v.jsx("div", { className: "flex-1 h-px border-t border-dashed border-muted-foreground/40" })
        ] }),
        /* @__PURE__ */ v.jsx(
          sMe,
          {
            status: o,
            part: x,
            isLast: _,
            message: e,
            setMessages: a,
            sendMessage: h,
            onReuseMessage: m
          },
          S
        )
      ] }, S) : null;
    if (Fu(x)) {
      const P = e.metadata?.toolChoice === "manual" && i && _ && x.state === "input-available" && r;
      return /* @__PURE__ */ v.jsx(
        AMe,
        {
          part: x,
          messageId: e.id,
          isLast: i && _,
          isManualToolInvocation: P,
          showActions: i ? _ && !r : _,
          addToolResult: u
        },
        S
      );
    }
    return x.type === "text" && !g ? /* @__PURE__ */ v.jsx(
      cMe,
      {
        part: x,
        isLast: i && _,
        isLoading: r,
        message: e,
        prevMessage: t,
        showActions: i ? _ && !r : _,
        setMessages: a,
        sendMessage: h,
        regenerate: c,
        threadId: n,
        showAvatar: N,
        onReuseMessage: m
      },
      S
    ) : x.type === "step-start" ? null : /* @__PURE__ */ v.jsxs("div", { children: [
      " unknown part ",
      x.type
    ] }, S);
  }) }) }) });
}, NMe = k.memo(MMe, (e, t) => !(e.message.id !== t.message.id || e.isLoading !== t.isLoading || e.isLastMessage !== t.isLastMessage || e.className !== t.className || t.isLoading && t.isLastMessage || !Mm(e.message.metadata, t.message.metadata) || e.message.parts.length !== t.message.parts.length || !Mm(e.message.parts, t.message.parts)));
function RMe() {
  const [e, t] = k.useState(!1);
  return k.useEffect(() => {
    t(!0);
  }, []), e;
}
const OMe = ({
  words: e,
  duration: t = 3e3,
  className: n
}) => {
  const [r, i] = k.useState(e[0]), [o, s] = k.useState(!1), a = RMe(), c = k.useCallback(() => {
    const u = e[e.indexOf(r) + 1] || e[0];
    i(u), s(!0);
  }, [r, e]);
  return k.useEffect(() => {
    o || setTimeout(() => {
      c();
    }, t);
  }, [o, t, c]), a ? /* @__PURE__ */ v.jsx(
    CA,
    {
      onExitComplete: () => {
        s(!1);
      },
      children: /* @__PURE__ */ v.jsx(
        Wf.div,
        {
          initial: {
            opacity: 0,
            y: 10
          },
          animate: {
            opacity: 1,
            y: 0
          },
          transition: {
            type: "spring",
            stiffness: 100,
            damping: 10
          },
          exit: {
            opacity: 0,
            y: -40,
            x: 40,
            filter: "blur(8px)",
            scale: 2,
            position: "absolute"
          },
          className: at(
            "z-10 inline-block relative text-left text-foreground px-2",
            n
          ),
          children: r.split(" ").map((u, f) => /* @__PURE__ */ v.jsxs(
            Wf.span,
            {
              initial: { opacity: 0, y: 10, filter: "blur(4px)" },
              animate: { opacity: 1, y: 0, filter: "blur(0px)" },
              transition: {
                delay: f * 0.01,
                duration: 0.03
              },
              className: "inline-block whitespace-nowrap",
              children: [
                u.split("").map((h, m) => /* @__PURE__ */ v.jsx(
                  Wf.span,
                  {
                    initial: { opacity: 0, y: 10, filter: "blur(4px)" },
                    animate: { opacity: 1, y: 0, filter: "blur(0px)" },
                    transition: {
                      delay: f * 0.2 + m * 0.08,
                      duration: 0.2
                    },
                    className: "inline-block",
                    children: h
                  },
                  u + m
                )),
                /* @__PURE__ */ v.jsx("span", { className: "inline-block", children: "" })
              ]
            },
            u + f
          ))
        },
        r
      )
    }
  ) : null;
};
function DMe() {
  const e = (/* @__PURE__ */ new Date()).getHours();
  return e < 12 ? "goodMorning" : e < 18 ? "goodAfternoon" : "goodEvening";
}
const PMe = () => {
  const e = { name: "User" }, t = k.useMemo(() => {
    if (!e) return "";
    const n = [
      `Good ${DMe().replace("good", "")}, ${e.name}!`,
      `Nice to see you again, ${e.name}.`,
      `What are you working on today, ${e.name}?`,
      "Let me know when you're ready to begin.",
      "What are your thoughts today?",
      "Where would you like to start?",
      `What are you thinking, ${e.name}?`
    ];
    return n[Math.floor(Math.random() * n.length)];
  }, [e.name]);
  return /* @__PURE__ */ v.jsx(
    Wf.div,
    {
      className: "max-w-3xl mx-auto my-1",
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      transition: { delay: 0.3 },
      children: /* @__PURE__ */ v.jsx("div", { className: "rounded-xl p-2 flex flex-col gap-2 leading-relaxed text-center", children: /* @__PURE__ */ v.jsx("h1", { className: "text-sm md:text-base text-blue-700 dark:text-[#1abcfe] drop-shadow-sm font-sans", children: t ? /* @__PURE__ */ v.jsx(OMe, { words: [t], className: "" }) : "" }) })
    },
    "welcome"
  );
};
var Bw = "Switch", [jMe] = ps(Bw), [IMe, zMe] = jMe(Bw), V7 = k.forwardRef(
  (e, t) => {
    const {
      __scopeSwitch: n,
      name: r,
      checked: i,
      defaultChecked: o,
      required: s,
      disabled: a,
      value: c = "on",
      onCheckedChange: u,
      form: f,
      ...h
    } = e, [m, g] = k.useState(null), b = Ft(t, (M) => g(M)), x = k.useRef(!1), w = m ? f || !!m.closest("form") : !0, [S, _] = Qa({
      prop: i,
      defaultProp: o ?? !1,
      onChange: u,
      caller: Bw
    });
    return /* @__PURE__ */ v.jsxs(IMe, { scope: n, checked: S, disabled: a, children: [
      /* @__PURE__ */ v.jsx(
        Et.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": S,
          "aria-required": s,
          "data-state": G7(S),
          "data-disabled": a ? "" : void 0,
          disabled: a,
          value: c,
          ...h,
          ref: b,
          onClick: Ye(e.onClick, (M) => {
            _((N) => !N), w && (x.current = M.isPropagationStopped(), x.current || M.stopPropagation());
          })
        }
      ),
      w && /* @__PURE__ */ v.jsx(
        q7,
        {
          control: m,
          bubbles: !x.current,
          name: r,
          value: c,
          checked: S,
          required: s,
          disabled: a,
          form: f,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
V7.displayName = Bw;
var H7 = "SwitchThumb", W7 = k.forwardRef(
  (e, t) => {
    const { __scopeSwitch: n, ...r } = e, i = zMe(H7, n);
    return /* @__PURE__ */ v.jsx(
      Et.span,
      {
        "data-state": G7(i.checked),
        "data-disabled": i.disabled ? "" : void 0,
        ...r,
        ref: t
      }
    );
  }
);
W7.displayName = H7;
var LMe = "SwitchBubbleInput", q7 = k.forwardRef(
  ({
    __scopeSwitch: e,
    control: t,
    checked: n,
    bubbles: r = !0,
    ...i
  }, o) => {
    const s = k.useRef(null), a = Ft(s, o), c = YA(n), u = jA(t);
    return k.useEffect(() => {
      const f = s.current;
      if (!f) return;
      const h = window.HTMLInputElement.prototype, g = Object.getOwnPropertyDescriptor(
        h,
        "checked"
      ).set;
      if (c !== n && g) {
        const b = new Event("click", { bubbles: r });
        g.call(f, n), f.dispatchEvent(b);
      }
    }, [c, n, r]), /* @__PURE__ */ v.jsx(
      "input",
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: n,
        ...i,
        tabIndex: -1,
        ref: a,
        style: {
          ...i.style,
          ...u,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
q7.displayName = LMe;
function G7(e) {
  return e ? "checked" : "unchecked";
}
var BMe = V7, $Me = W7;
function K7({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    BMe,
    {
      "data-slot": "switch",
      className: at(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        e
      ),
      ...t,
      children: /* @__PURE__ */ v.jsx(
        $Me,
        {
          "data-slot": "switch-thumb",
          className: at(
            "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
          )
        }
      )
    }
  );
}
const UMe = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Z7 = UMe ? k.useLayoutEffect : k.useEffect;
function Y7(e) {
  const t = k.useRef(e);
  return Z7(() => {
    t.current = e;
  }), k.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
      r[i] = arguments[i];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
function lL(e, t) {
  t === void 0 && (t = [e]);
  const n = k.useRef(e);
  return Z7(() => {
    n.current !== e && (n.current = e);
  }, t), n;
}
function FMe(e) {
  const t = Y7(e), n = k.useRef(null), r = k.useCallback(
    (i) => {
      i !== n.current && t?.(i, n.current), n.current = i;
    },
    //eslint-disable-next-line
    []
  );
  return [n, r];
}
let jC = {};
function VMe(e, t) {
  return k.useMemo(() => {
    const n = jC[e] == null ? 0 : jC[e] + 1;
    return jC[e] = n, e + "-" + n;
  }, [e, t]);
}
var Pm;
(function(e) {
  e.DragStart = "dragStart", e.DragMove = "dragMove", e.DragEnd = "dragEnd", e.DragCancel = "dragCancel", e.DragOver = "dragOver", e.RegisterDroppable = "registerDroppable", e.SetDroppableDisabled = "setDroppableDisabled", e.UnregisterDroppable = "unregisterDroppable";
})(Pm || (Pm = {}));
function cL() {
}
const HMe = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
var $f;
(function(e) {
  e[e.Forward = 1] = "Forward", e[e.Backward = -1] = "Backward";
})($f || ($f = {}));
var uL;
(function(e) {
  e.Click = "click", e.DragStart = "dragstart", e.Keydown = "keydown", e.ContextMenu = "contextmenu", e.Resize = "resize", e.SelectionChange = "selectionchange", e.VisibilityChange = "visibilitychange";
})(uL || (uL = {}));
var tc;
(function(e) {
  e.Space = "Space", e.Down = "ArrowDown", e.Right = "ArrowRight", e.Left = "ArrowLeft", e.Up = "ArrowUp", e.Esc = "Escape", e.Enter = "Enter", e.Tab = "Tab";
})(tc || (tc = {}));
tc.Space, tc.Enter, tc.Esc, tc.Space, tc.Enter, tc.Tab;
var dL;
(function(e) {
  e[e.RightClick = 2] = "RightClick";
})(dL || (dL = {}));
var fL;
(function(e) {
  e[e.Pointer = 0] = "Pointer", e[e.DraggableRect = 1] = "DraggableRect";
})(fL || (fL = {}));
var hL;
(function(e) {
  e[e.TreeOrder = 0] = "TreeOrder", e[e.ReversedTreeOrder = 1] = "ReversedTreeOrder";
})(hL || (hL = {}));
$f.Backward + "", $f.Forward + "", $f.Backward + "", $f.Forward + "";
var eT;
(function(e) {
  e[e.Always = 0] = "Always", e[e.BeforeDragging = 1] = "BeforeDragging", e[e.WhileDragging = 2] = "WhileDragging";
})(eT || (eT = {}));
var tT;
(function(e) {
  e.Optimized = "optimized";
})(tT || (tT = {}));
function WMe(e) {
  let {
    callback: t,
    disabled: n
  } = e;
  const r = Y7(t), i = k.useMemo(
    () => {
      if (n || typeof window > "u" || typeof window.ResizeObserver > "u")
        return;
      const {
        ResizeObserver: o
      } = window;
      return new o(r);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [n]
  );
  return k.useEffect(() => () => i?.disconnect(), [i]), i;
}
eT.WhileDragging, tT.Optimized;
const qMe = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: cL,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: cL
}, GMe = /* @__PURE__ */ k.createContext(qMe);
({
  ...HMe
});
var pL;
(function(e) {
  e[e.Uninitialized = 0] = "Uninitialized", e[e.Initializing = 1] = "Initializing", e[e.Initialized = 2] = "Initialized";
})(pL || (pL = {}));
const KMe = "Droppable", ZMe = {
  timeout: 25
};
function YMe(e) {
  let {
    data: t,
    disabled: n = !1,
    id: r,
    resizeObserverConfig: i
  } = e;
  const o = VMe(KMe), {
    active: s,
    dispatch: a,
    over: c,
    measureDroppableContainers: u
  } = k.useContext(GMe), f = k.useRef({
    disabled: n
  }), h = k.useRef(!1), m = k.useRef(null), g = k.useRef(null), {
    disabled: b,
    updateMeasurementsFor: x,
    timeout: w
  } = {
    ...ZMe,
    ...i
  }, S = lL(x ?? r), _ = k.useCallback(
    () => {
      if (!h.current) {
        h.current = !0;
        return;
      }
      g.current != null && clearTimeout(g.current), g.current = setTimeout(() => {
        u(Array.isArray(S.current) ? S.current : [S.current]), g.current = null;
      }, w);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [w]
  ), M = WMe({
    callback: _,
    disabled: b || !s
  }), N = k.useCallback((L, U) => {
    M && (U && (M.unobserve(U), h.current = !1), L && M.observe(L));
  }, [M]), [P, I] = FMe(N), O = lL(t);
  return k.useEffect(() => {
    !M || !P.current || (M.disconnect(), h.current = !1, M.observe(P.current));
  }, [P, M]), k.useEffect(
    () => (a({
      type: Pm.RegisterDroppable,
      element: {
        id: r,
        key: o,
        disabled: n,
        node: P,
        rect: m,
        data: O
      }
    }), () => a({
      type: Pm.UnregisterDroppable,
      key: o,
      id: r
    })),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [r]
  ), k.useEffect(() => {
    n !== f.current.disabled && (a({
      type: Pm.SetDroppableDisabled,
      id: r,
      key: o,
      disabled: n
    }), f.current.disabled = n);
  }, [r, o, n, a]), {
    active: s,
    rect: m,
    isOver: c?.id === r,
    node: P,
    over: c,
    setNodeRef: I
  };
}
function XMe(e) {
  return {
    name: e.name,
    size: e.size,
    type: e.type,
    uploadedAt: /* @__PURE__ */ new Date()
  };
}
const JMe = ({ onFilesChange: e, files: t, isAIThinking: n }) => {
  const r = k.useRef(null), [i, o] = k.useState([]), [s, a] = k.useState(!1);
  Ne.useEffect(() => {
    o(t || []);
  }, [t]);
  const c = (x) => {
    o(x), e && e(x);
  }, u = () => {
    const x = document.createElement("input");
    x.type = "file", x.accept = ".json,.xlsx,.xls,.geojson,.ifc", x.multiple = !0, x.click(), x.onchange = async (w) => {
      const S = w.target.files;
      o([...S ? Array.from(S) : []]), f(S), x.remove();
    };
  }, f = (x) => {
    if (!x) return;
    const w = Array.from(x);
    w.forEach((_) => XMe(_));
    const S = [...i, ...w];
    c(S);
  }, h = (x) => {
    f(x.target.files), x.target && (x.target.value = "");
  }, m = (x) => {
    x.preventDefault(), a(!1), f(x.dataTransfer.files);
  }, g = (x) => {
    x.preventDefault(), a(!0);
  }, b = () => a(!1);
  return /* @__PURE__ */ v.jsx("div", { className: "flex flex-col items-end", children: /* @__PURE__ */ v.jsxs(
    "div",
    {
      onDrop: m,
      onDragOver: g,
      onDragLeave: b,
      className: `flex items-center gap-2 rounded-md ${s ? "bg-neutral-100 dark:bg-neutral-800" : ""}`,
      style: { minWidth: 40 },
      children: [
        /* @__PURE__ */ v.jsx(
          "input",
          {
            ref: r,
            type: "file",
            multiple: !0,
            onChange: h,
            className: "hidden",
            disabled: n
          }
        ),
        /* @__PURE__ */ v.jsx(
          Ht,
          {
            disabled: n,
            size: "icon",
            variant: "ghost",
            onClick: u,
            title: "Upload files",
            className: "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
            children: /* @__PURE__ */ v.jsx(CZ, { className: "h-5 w-5" })
          }
        )
      ]
    }
  ) });
};
function Jr(e) {
  this.content = e;
}
Jr.prototype = {
  constructor: Jr,
  find: function(e) {
    for (var t = 0; t < this.content.length; t += 2)
      if (this.content[t] === e) return t;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(e) {
    var t = this.find(e);
    return t == -1 ? void 0 : this.content[t + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(e, t, n) {
    var r = n && n != e ? this.remove(n) : this, i = r.find(e), o = r.content.slice();
    return i == -1 ? o.push(n || e, t) : (o[i + 1] = t, n && (o[i] = n)), new Jr(o);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(e) {
    var t = this.find(e);
    if (t == -1) return this;
    var n = this.content.slice();
    return n.splice(t, 2), new Jr(n);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(e, t) {
    return new Jr([e, t].concat(this.remove(e).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(e, t) {
    var n = this.remove(e).content.slice();
    return n.push(e, t), new Jr(n);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(e, t, n) {
    var r = this.remove(t), i = r.content.slice(), o = r.find(e);
    return i.splice(o == -1 ? i.length : o, 0, t, n), new Jr(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(e) {
    for (var t = 0; t < this.content.length; t += 2)
      e(this.content[t], this.content[t + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(e) {
    return e = Jr.from(e), e.size ? new Jr(e.content.concat(this.subtract(e).content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(e) {
    return e = Jr.from(e), e.size ? new Jr(this.subtract(e).content.concat(e.content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(e) {
    var t = this;
    e = Jr.from(e);
    for (var n = 0; n < e.content.length; n += 2)
      t = t.remove(e.content[n]);
    return t;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var e = {};
    return this.forEach(function(t, n) {
      e[t] = n;
    }), e;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Jr.from = function(e) {
  if (e instanceof Jr) return e;
  var t = [];
  if (e) for (var n in e) t.push(n, e[n]);
  return new Jr(t);
};
function X7(e, t, n) {
  for (let r = 0; ; r++) {
    if (r == e.childCount || r == t.childCount)
      return e.childCount == t.childCount ? null : n;
    let i = e.child(r), o = t.child(r);
    if (i == o) {
      n += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(o))
      return n;
    if (i.isText && i.text != o.text) {
      for (let s = 0; i.text[s] == o.text[s]; s++)
        n++;
      return n;
    }
    if (i.content.size || o.content.size) {
      let s = X7(i.content, o.content, n + 1);
      if (s != null)
        return s;
    }
    n += i.nodeSize;
  }
}
function J7(e, t, n, r) {
  for (let i = e.childCount, o = t.childCount; ; ) {
    if (i == 0 || o == 0)
      return i == o ? null : { a: n, b: r };
    let s = e.child(--i), a = t.child(--o), c = s.nodeSize;
    if (s == a) {
      n -= c, r -= c;
      continue;
    }
    if (!s.sameMarkup(a))
      return { a: n, b: r };
    if (s.isText && s.text != a.text) {
      let u = 0, f = Math.min(s.text.length, a.text.length);
      for (; u < f && s.text[s.text.length - u - 1] == a.text[a.text.length - u - 1]; )
        u++, n--, r--;
      return { a: n, b: r };
    }
    if (s.content.size || a.content.size) {
      let u = J7(s.content, a.content, n - 1, r - 1);
      if (u)
        return u;
    }
    n -= c, r -= c;
  }
}
class $e {
  /**
  @internal
  */
  constructor(t, n) {
    if (this.content = t, this.size = n || 0, n == null)
      for (let r = 0; r < t.length; r++)
        this.size += t[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(t, n, r, i = 0, o) {
    for (let s = 0, a = 0; a < n; s++) {
      let c = this.content[s], u = a + c.nodeSize;
      if (u > t && r(c, i + a, o || null, s) !== !1 && c.content.size) {
        let f = a + 1;
        c.nodesBetween(Math.max(0, t - f), Math.min(c.content.size, n - f), r, i + f);
      }
      a = u;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(t) {
    this.nodesBetween(0, this.size, t);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(t, n, r, i) {
    let o = "", s = !0;
    return this.nodesBetween(t, n, (a, c) => {
      let u = a.isText ? a.text.slice(Math.max(t, c) - c, n - c) : a.isLeaf ? i ? typeof i == "function" ? i(a) : i : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && u || a.isTextblock) && r && (s ? s = !1 : o += r), o += u;
    }, 0), o;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(t) {
    if (!t.size)
      return this;
    if (!this.size)
      return t;
    let n = this.lastChild, r = t.firstChild, i = this.content.slice(), o = 0;
    for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), o = 1); o < t.content.length; o++)
      i.push(t.content[o]);
    return new $e(i, this.size + t.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(t, n = this.size) {
    if (t == 0 && n == this.size)
      return this;
    let r = [], i = 0;
    if (n > t)
      for (let o = 0, s = 0; s < n; o++) {
        let a = this.content[o], c = s + a.nodeSize;
        c > t && ((s < t || c > n) && (a.isText ? a = a.cut(Math.max(0, t - s), Math.min(a.text.length, n - s)) : a = a.cut(Math.max(0, t - s - 1), Math.min(a.content.size, n - s - 1))), r.push(a), i += a.nodeSize), s = c;
      }
    return new $e(r, i);
  }
  /**
  @internal
  */
  cutByIndex(t, n) {
    return t == n ? $e.empty : t == 0 && n == this.content.length ? this : new $e(this.content.slice(t, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(t, n) {
    let r = this.content[t];
    if (r == n)
      return this;
    let i = this.content.slice(), o = this.size + n.nodeSize - r.nodeSize;
    return i[t] = n, new $e(i, o);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(t) {
    return new $e([t].concat(this.content), this.size + t.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(t) {
    return new $e(this.content.concat(t), this.size + t.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(t) {
    if (this.content.length != t.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(t.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(t) {
    let n = this.content[t];
    if (!n)
      throw new RangeError("Index " + t + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(t) {
    return this.content[t] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(t) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n];
      t(i, r, n), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(t, n = 0) {
    return X7(this, t, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(t, n = this.size, r = t.size) {
    return J7(this, t, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(t) {
    if (t == 0)
      return Kv(0, t);
    if (t == this.size)
      return Kv(this.content.length, t);
    if (t > this.size || t < 0)
      throw new RangeError(`Position ${t} outside of fragment (${this})`);
    for (let n = 0, r = 0; ; n++) {
      let i = this.child(n), o = r + i.nodeSize;
      if (o >= t)
        return o == t ? Kv(n + 1, o) : Kv(n, r);
      r = o;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((t) => t.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(t, n) {
    if (!n)
      return $e.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new $e(n.map(t.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(t) {
    if (!t.length)
      return $e.empty;
    let n, r = 0;
    for (let i = 0; i < t.length; i++) {
      let o = t[i];
      r += o.nodeSize, i && o.isText && t[i - 1].sameMarkup(o) ? (n || (n = t.slice(0, i)), n[n.length - 1] = o.withText(n[n.length - 1].text + o.text)) : n && n.push(o);
    }
    return new $e(n || t, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(t) {
    if (!t)
      return $e.empty;
    if (t instanceof $e)
      return t;
    if (Array.isArray(t))
      return this.fromArray(t);
    if (t.attrs)
      return new $e([t], t.nodeSize);
    throw new RangeError("Can not convert " + t + " to a Fragment" + (t.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
$e.empty = new $e([], 0);
const IC = { index: 0, offset: 0 };
function Kv(e, t) {
  return IC.index = e, IC.offset = t, IC;
}
function Wb(e, t) {
  if (e === t)
    return !0;
  if (!(e && typeof e == "object") || !(t && typeof t == "object"))
    return !1;
  let n = Array.isArray(e);
  if (Array.isArray(t) != n)
    return !1;
  if (n) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!Wb(e[r], t[r]))
        return !1;
  } else {
    for (let r in e)
      if (!(r in t) || !Wb(e[r], t[r]))
        return !1;
    for (let r in t)
      if (!(r in e))
        return !1;
  }
  return !0;
}
let En = class nT {
  /**
  @internal
  */
  constructor(t, n) {
    this.type = t, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(t) {
    let n, r = !1;
    for (let i = 0; i < t.length; i++) {
      let o = t[i];
      if (this.eq(o))
        return t;
      if (this.type.excludes(o.type))
        n || (n = t.slice(0, i));
      else {
        if (o.type.excludes(this.type))
          return t;
        !r && o.type.rank > this.type.rank && (n || (n = t.slice(0, i)), n.push(this), r = !0), n && n.push(o);
      }
    }
    return n || (n = t.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(t) {
    for (let n = 0; n < t.length; n++)
      if (this.eq(t[n]))
        return t.slice(0, n).concat(t.slice(n + 1));
    return t;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(t) {
    for (let n = 0; n < t.length; n++)
      if (this.eq(t[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(t) {
    return this == t || this.type == t.type && Wb(this.attrs, t.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let t = { type: this.type.name };
    for (let n in this.attrs) {
      t.attrs = this.attrs;
      break;
    }
    return t;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(t, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = t.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let i = r.create(n.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(t, n) {
    if (t == n)
      return !0;
    if (t.length != n.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!t[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(t) {
    if (!t || Array.isArray(t) && t.length == 0)
      return nT.none;
    if (t instanceof nT)
      return [t];
    let n = t.slice();
    return n.sort((r, i) => r.type.rank - i.type.rank), n;
  }
};
En.none = [];
class qb extends Error {
}
class Qe {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(t, n, r) {
    this.content = t, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(t, n) {
    let r = eH(this.content, t + this.openStart, n);
    return r && new Qe(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(t, n) {
    return new Qe(Q7(this.content, t + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(t) {
    return this.content.eq(t.content) && this.openStart == t.openStart && this.openEnd == t.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let t = { content: this.content.toJSON() };
    return this.openStart > 0 && (t.openStart = this.openStart), this.openEnd > 0 && (t.openEnd = this.openEnd), t;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(t, n) {
    if (!n)
      return Qe.empty;
    let r = n.openStart || 0, i = n.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Qe($e.fromJSON(t, n.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(t, n = !0) {
    let r = 0, i = 0;
    for (let o = t.firstChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.firstChild)
      r++;
    for (let o = t.lastChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.lastChild)
      i++;
    return new Qe(t, r, i);
  }
}
Qe.empty = new Qe($e.empty, 0, 0);
function Q7(e, t, n) {
  let { index: r, offset: i } = e.findIndex(t), o = e.maybeChild(r), { index: s, offset: a } = e.findIndex(n);
  if (i == t || o.isText) {
    if (a != n && !e.child(s).isText)
      throw new RangeError("Removing non-flat range");
    return e.cut(0, t).append(e.cut(n));
  }
  if (r != s)
    throw new RangeError("Removing non-flat range");
  return e.replaceChild(r, o.copy(Q7(o.content, t - i - 1, n - i - 1)));
}
function eH(e, t, n, r) {
  let { index: i, offset: o } = e.findIndex(t), s = e.maybeChild(i);
  if (o == t || s.isText)
    return r && !r.canReplace(i, i, n) ? null : e.cut(0, t).append(n).append(e.cut(t));
  let a = eH(s.content, t - o - 1, n, s);
  return a && e.replaceChild(i, s.copy(a));
}
function QMe(e, t, n) {
  if (n.openStart > e.depth)
    throw new qb("Inserted content deeper than insertion position");
  if (e.depth - n.openStart != t.depth - n.openEnd)
    throw new qb("Inconsistent open depths");
  return tH(e, t, n, 0);
}
function tH(e, t, n, r) {
  let i = e.index(r), o = e.node(r);
  if (i == t.index(r) && r < e.depth - n.openStart) {
    let s = tH(e, t, n, r + 1);
    return o.copy(o.content.replaceChild(i, s));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && e.depth == r && t.depth == r) {
      let s = e.parent, a = s.content;
      return Hu(s, a.cut(0, e.parentOffset).append(n.content).append(a.cut(t.parentOffset)));
    } else {
      let { start: s, end: a } = eNe(n, e);
      return Hu(o, rH(e, s, a, t, r));
    }
  else return Hu(o, Gb(e, t, r));
}
function nH(e, t) {
  if (!t.type.compatibleContent(e.type))
    throw new qb("Cannot join " + t.type.name + " onto " + e.type.name);
}
function rT(e, t, n) {
  let r = e.node(n);
  return nH(r, t.node(n)), r;
}
function Vu(e, t) {
  let n = t.length - 1;
  n >= 0 && e.isText && e.sameMarkup(t[n]) ? t[n] = e.withText(t[n].text + e.text) : t.push(e);
}
function jm(e, t, n, r) {
  let i = (t || e).node(n), o = 0, s = t ? t.index(n) : i.childCount;
  e && (o = e.index(n), e.depth > n ? o++ : e.textOffset && (Vu(e.nodeAfter, r), o++));
  for (let a = o; a < s; a++)
    Vu(i.child(a), r);
  t && t.depth == n && t.textOffset && Vu(t.nodeBefore, r);
}
function Hu(e, t) {
  return e.type.checkContent(t), e.copy(t);
}
function rH(e, t, n, r, i) {
  let o = e.depth > i && rT(e, t, i + 1), s = r.depth > i && rT(n, r, i + 1), a = [];
  return jm(null, e, i, a), o && s && t.index(i) == n.index(i) ? (nH(o, s), Vu(Hu(o, rH(e, t, n, r, i + 1)), a)) : (o && Vu(Hu(o, Gb(e, t, i + 1)), a), jm(t, n, i, a), s && Vu(Hu(s, Gb(n, r, i + 1)), a)), jm(r, null, i, a), new $e(a);
}
function Gb(e, t, n) {
  let r = [];
  if (jm(null, e, n, r), e.depth > n) {
    let i = rT(e, t, n + 1);
    Vu(Hu(i, Gb(e, t, n + 1)), r);
  }
  return jm(t, null, n, r), new $e(r);
}
function eNe(e, t) {
  let n = t.depth - e.openStart, i = t.node(n).copy(e.content);
  for (let o = n - 1; o >= 0; o--)
    i = t.node(o).copy($e.from(i));
  return {
    start: i.resolveNoCache(e.openStart + n),
    end: i.resolveNoCache(i.content.size - e.openEnd - n)
  };
}
class mg {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.pos = t, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(t) {
    return t == null ? this.depth : t < 0 ? this.depth + t : t;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(t) {
    return this.path[this.resolveDepth(t) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(t) {
    return this.path[this.resolveDepth(t) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(t) {
    return t = this.resolveDepth(t), this.index(t) + (t == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(t) {
    return t = this.resolveDepth(t), t == 0 ? 0 : this.path[t * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(t) {
    return t = this.resolveDepth(t), this.start(t) + this.node(t).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(t) {
    if (t = this.resolveDepth(t), !t)
      throw new RangeError("There is no position before the top-level node");
    return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(t) {
    if (t = this.resolveDepth(t), !t)
      throw new RangeError("There is no position after the top-level node");
    return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1] + this.path[t * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let t = this.parent, n = this.index(this.depth);
    if (n == t.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = t.child(n);
    return r ? t.child(n).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let t = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(t).cut(0, n) : t == 0 ? null : this.parent.child(t - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(t, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let o = 0; o < t; o++)
      i += r.child(o).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let t = this.parent, n = this.index();
    if (t.content.size == 0)
      return En.none;
    if (this.textOffset)
      return t.child(n).marks;
    let r = t.maybeChild(n - 1), i = t.maybeChild(n);
    if (!r) {
      let a = r;
      r = i, i = a;
    }
    let o = r.marks;
    for (var s = 0; s < o.length; s++)
      o[s].type.spec.inclusive === !1 && (!i || !o[s].isInSet(i.marks)) && (o = o[s--].removeFromSet(o));
    return o;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(t) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, i = t.parent.maybeChild(t.index());
    for (var o = 0; o < r.length; o++)
      r[o].type.spec.inclusive === !1 && (!i || !r[o].isInSet(i.marks)) && (r = r[o--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(t) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= t && this.end(n) >= t)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(t = this, n) {
    if (t.pos < this.pos)
      return t.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == t.pos ? 1 : 0); r >= 0; r--)
      if (t.pos <= this.end(r) && (!n || n(this.node(r))))
        return new Kb(this, t, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(t) {
    return this.pos - this.parentOffset == t.pos - t.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(t) {
    return t.pos > this.pos ? t : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(t) {
    return t.pos < this.pos ? t : this;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let n = 1; n <= this.depth; n++)
      t += (t ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return t + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(t, n) {
    if (!(n >= 0 && n <= t.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], i = 0, o = n;
    for (let s = t; ; ) {
      let { index: a, offset: c } = s.content.findIndex(o), u = o - c;
      if (r.push(s, a, i + c), !u || (s = s.child(a), s.isText))
        break;
      o = u - 1, i += c + 1;
    }
    return new mg(n, r, o);
  }
  /**
  @internal
  */
  static resolveCached(t, n) {
    let r = mL.get(t);
    if (r)
      for (let o = 0; o < r.elts.length; o++) {
        let s = r.elts[o];
        if (s.pos == n)
          return s;
      }
    else
      mL.set(t, r = new tNe());
    let i = r.elts[r.i] = mg.resolve(t, n);
    return r.i = (r.i + 1) % nNe, i;
  }
}
class tNe {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const nNe = 12, mL = /* @__PURE__ */ new WeakMap();
class Kb {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(t, n, r) {
    this.$from = t, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const rNe = /* @__PURE__ */ Object.create(null);
let yc = class iT {
  /**
  @internal
  */
  constructor(t, n, r, i = En.none) {
    this.type = t, this.attrs = n, this.marks = i, this.content = r || $e.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(t) {
    return this.content.child(t);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(t) {
    return this.content.maybeChild(t);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(t) {
    this.content.forEach(t);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(t, n, r, i = 0) {
    this.content.nodesBetween(t, n, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(t) {
    this.nodesBetween(0, this.content.size, t);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(t, n, r, i) {
    return this.content.textBetween(t, n, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(t) {
    return this == t || this.sameMarkup(t) && this.content.eq(t.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(t) {
    return this.hasMarkup(t.type, t.attrs, t.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(t, n, r) {
    return this.type == t && Wb(this.attrs, n || t.defaultAttrs || rNe) && En.sameSet(this.marks, r || En.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(t = null) {
    return t == this.content ? this : new iT(this.type, this.attrs, t, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(t) {
    return t == this.marks ? this : new iT(this.type, this.attrs, this.content, t);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(t, n = this.content.size) {
    return t == 0 && n == this.content.size ? this : this.copy(this.content.cut(t, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(t, n = this.content.size, r = !1) {
    if (t == n)
      return Qe.empty;
    let i = this.resolve(t), o = this.resolve(n), s = r ? 0 : i.sharedDepth(n), a = i.start(s), u = i.node(s).content.cut(i.pos - a, o.pos - a);
    return new Qe(u, i.depth - s, o.depth - s);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(t, n, r) {
    return QMe(this.resolve(t), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(t) {
    for (let n = this; ; ) {
      let { index: r, offset: i } = n.content.findIndex(t);
      if (n = n.maybeChild(r), !n)
        return null;
      if (i == t || n.isText)
        return n;
      t -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(t) {
    let { index: n, offset: r } = this.content.findIndex(t);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(t) {
    if (t == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(t);
    if (r < t)
      return { node: this.content.child(n), index: n, offset: r };
    let i = this.content.child(n - 1);
    return { node: i, index: n - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(t) {
    return mg.resolveCached(this, t);
  }
  /**
  @internal
  */
  resolveNoCache(t) {
    return mg.resolve(this, t);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(t, n, r) {
    let i = !1;
    return n > t && this.nodesBetween(t, n, (o) => (r.isInSet(o.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let t = this.type.name;
    return this.content.size && (t += "(" + this.content.toStringInner() + ")"), iH(this.marks, t);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(t) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, t);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(t, n, r = $e.empty, i = 0, o = r.childCount) {
    let s = this.contentMatchAt(t).matchFragment(r, i, o), a = s && s.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let c = i; c < o; c++)
      if (!this.type.allowsMarks(r.child(c).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(t, n, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let o = this.contentMatchAt(t).matchType(r), s = o && o.matchFragment(this.content, n);
    return s ? s.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(t) {
    return t.content.size ? this.canReplace(this.childCount, this.childCount, t.content) : this.type.compatibleContent(t.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let t = En.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), t = r.addToSet(t);
    }
    if (!En.sameSet(t, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let t = { type: this.type.name };
    for (let n in this.attrs) {
      t.attrs = this.attrs;
      break;
    }
    return this.content.size && (t.content = this.content.toJSON()), this.marks.length && (t.marks = this.marks.map((n) => n.toJSON())), t;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(t, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(t.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return t.text(n.text, r);
    }
    let i = $e.fromJSON(t, n.content), o = t.nodeType(n.type).create(n.attrs, i, r);
    return o.type.checkAttrs(o.attrs), o;
  }
};
yc.prototype.text = void 0;
class Zb extends yc {
  /**
  @internal
  */
  constructor(t, n, r, i) {
    if (super(t, n, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : iH(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(t, n) {
    return this.text.slice(t, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(t) {
    return t == this.marks ? this : new Zb(this.type, this.attrs, this.text, t);
  }
  withText(t) {
    return t == this.text ? this : new Zb(this.type, this.attrs, t, this.marks);
  }
  cut(t = 0, n = this.text.length) {
    return t == 0 && n == this.text.length ? this : this.withText(this.text.slice(t, n));
  }
  eq(t) {
    return this.sameMarkup(t) && this.text == t.text;
  }
  toJSON() {
    let t = super.toJSON();
    return t.text = this.text, t;
  }
}
function iH(e, t) {
  for (let n = e.length - 1; n >= 0; n--)
    t = e[n].type.name + "(" + t + ")";
  return t;
}
class id {
  /**
  @internal
  */
  constructor(t) {
    this.validEnd = t, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(t, n) {
    let r = new iNe(t, n);
    if (r.next == null)
      return id.empty;
    let i = oH(r);
    r.next && r.err("Unexpected trailing text");
    let o = dNe(uNe(i));
    return fNe(o, r), o;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(t) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == t)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(t, n = 0, r = t.childCount) {
    let i = this;
    for (let o = n; i && o < r; o++)
      i = i.matchType(t.child(o).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let t = 0; t < this.next.length; t++) {
      let { type: n } = this.next[t];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(t) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < t.next.length; r++)
        if (this.next[n].type == t.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(t, n = !1, r = 0) {
    let i = [this];
    function o(s, a) {
      let c = s.matchFragment(t, r);
      if (c && (!n || c.validEnd))
        return $e.from(a.map((u) => u.createAndFill()));
      for (let u = 0; u < s.next.length; u++) {
        let { type: f, next: h } = s.next[u];
        if (!(f.isText || f.hasRequiredAttrs()) && i.indexOf(h) == -1) {
          i.push(h);
          let m = o(h, a.concat(f));
          if (m)
            return m;
        }
      }
      return null;
    }
    return o(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(t) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == t)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(t);
    return this.wrapCache.push(t, n), n;
  }
  /**
  @internal
  */
  computeWrapping(t) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), o = i.match;
      if (o.matchType(t)) {
        let s = [];
        for (let a = i; a.type; a = a.via)
          s.push(a.type);
        return s.reverse();
      }
      for (let s = 0; s < o.next.length; s++) {
        let { type: a, next: c } = o.next[s];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!i.type || c.validEnd) && (r.push({ match: a.contentMatch, type: a, via: i }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(t) {
    if (t >= this.next.length)
      throw new RangeError(`There's no ${t}th edge in this content match`);
    return this.next[t];
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    function n(r) {
      t.push(r);
      for (let i = 0; i < r.next.length; i++)
        t.indexOf(r.next[i].next) == -1 && n(r.next[i].next);
    }
    return n(this), t.map((r, i) => {
      let o = i + (r.validEnd ? "*" : " ") + " ";
      for (let s = 0; s < r.next.length; s++)
        o += (s ? ", " : "") + r.next[s].type.name + "->" + t.indexOf(r.next[s].next);
      return o;
    }).join(`
`);
  }
}
id.empty = new id(!0);
class iNe {
  constructor(t, n) {
    this.string = t, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = t.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(t) {
    return this.next == t && (this.pos++ || !0);
  }
  err(t) {
    throw new SyntaxError(t + " (in content expression '" + this.string + "')");
  }
}
function oH(e) {
  let t = [];
  do
    t.push(oNe(e));
  while (e.eat("|"));
  return t.length == 1 ? t[0] : { type: "choice", exprs: t };
}
function oNe(e) {
  let t = [];
  do
    t.push(sNe(e));
  while (e.next && e.next != ")" && e.next != "|");
  return t.length == 1 ? t[0] : { type: "seq", exprs: t };
}
function sNe(e) {
  let t = cNe(e);
  for (; ; )
    if (e.eat("+"))
      t = { type: "plus", expr: t };
    else if (e.eat("*"))
      t = { type: "star", expr: t };
    else if (e.eat("?"))
      t = { type: "opt", expr: t };
    else if (e.eat("{"))
      t = aNe(e, t);
    else
      break;
  return t;
}
function gL(e) {
  /\D/.test(e.next) && e.err("Expected number, got '" + e.next + "'");
  let t = Number(e.next);
  return e.pos++, t;
}
function aNe(e, t) {
  let n = gL(e), r = n;
  return e.eat(",") && (e.next != "}" ? r = gL(e) : r = -1), e.eat("}") || e.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: t };
}
function lNe(e, t) {
  let n = e.nodeTypes, r = n[t];
  if (r)
    return [r];
  let i = [];
  for (let o in n) {
    let s = n[o];
    s.isInGroup(t) && i.push(s);
  }
  return i.length == 0 && e.err("No node type or group '" + t + "' found"), i;
}
function cNe(e) {
  if (e.eat("(")) {
    let t = oH(e);
    return e.eat(")") || e.err("Missing closing paren"), t;
  } else if (/\W/.test(e.next))
    e.err("Unexpected token '" + e.next + "'");
  else {
    let t = lNe(e, e.next).map((n) => (e.inline == null ? e.inline = n.isInline : e.inline != n.isInline && e.err("Mixing inline and block content"), { type: "name", value: n }));
    return e.pos++, t.length == 1 ? t[0] : { type: "choice", exprs: t };
  }
}
function uNe(e) {
  let t = [[]];
  return i(o(e, 0), n()), t;
  function n() {
    return t.push([]) - 1;
  }
  function r(s, a, c) {
    let u = { term: c, to: a };
    return t[s].push(u), u;
  }
  function i(s, a) {
    s.forEach((c) => c.to = a);
  }
  function o(s, a) {
    if (s.type == "choice")
      return s.exprs.reduce((c, u) => c.concat(o(u, a)), []);
    if (s.type == "seq")
      for (let c = 0; ; c++) {
        let u = o(s.exprs[c], a);
        if (c == s.exprs.length - 1)
          return u;
        i(u, a = n());
      }
    else if (s.type == "star") {
      let c = n();
      return r(a, c), i(o(s.expr, c), c), [r(c)];
    } else if (s.type == "plus") {
      let c = n();
      return i(o(s.expr, a), c), i(o(s.expr, c), c), [r(c)];
    } else {
      if (s.type == "opt")
        return [r(a)].concat(o(s.expr, a));
      if (s.type == "range") {
        let c = a;
        for (let u = 0; u < s.min; u++) {
          let f = n();
          i(o(s.expr, c), f), c = f;
        }
        if (s.max == -1)
          i(o(s.expr, c), c);
        else
          for (let u = s.min; u < s.max; u++) {
            let f = n();
            r(c, f), i(o(s.expr, c), f), c = f;
          }
        return [r(c)];
      } else {
        if (s.type == "name")
          return [r(a, void 0, s.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function sH(e, t) {
  return t - e;
}
function yL(e, t) {
  let n = [];
  return r(t), n.sort(sH);
  function r(i) {
    let o = e[i];
    if (o.length == 1 && !o[0].term)
      return r(o[0].to);
    n.push(i);
    for (let s = 0; s < o.length; s++) {
      let { term: a, to: c } = o[s];
      !a && n.indexOf(c) == -1 && r(c);
    }
  }
}
function dNe(e) {
  let t = /* @__PURE__ */ Object.create(null);
  return n(yL(e, 0));
  function n(r) {
    let i = [];
    r.forEach((s) => {
      e[s].forEach(({ term: a, to: c }) => {
        if (!a)
          return;
        let u;
        for (let f = 0; f < i.length; f++)
          i[f][0] == a && (u = i[f][1]);
        yL(e, c).forEach((f) => {
          u || i.push([a, u = []]), u.indexOf(f) == -1 && u.push(f);
        });
      });
    });
    let o = t[r.join(",")] = new id(r.indexOf(e.length - 1) > -1);
    for (let s = 0; s < i.length; s++) {
      let a = i[s][1].sort(sH);
      o.next.push({ type: i[s][0], next: t[a.join(",")] || n(a) });
    }
    return o;
  }
}
function fNe(e, t) {
  for (let n = 0, r = [e]; n < r.length; n++) {
    let i = r[n], o = !i.validEnd, s = [];
    for (let a = 0; a < i.next.length; a++) {
      let { type: c, next: u } = i.next[a];
      s.push(c.name), o && !(c.isText || c.hasRequiredAttrs()) && (o = !1), r.indexOf(u) == -1 && r.push(u);
    }
    o && t.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function aH(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in e) {
    let r = e[n];
    if (!r.hasDefault)
      return null;
    t[n] = r.default;
  }
  return t;
}
function lH(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in e) {
    let i = t && t[r];
    if (i === void 0) {
      let o = e[r];
      if (o.hasDefault)
        i = o.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = i;
  }
  return n;
}
function cH(e, t, n, r) {
  for (let i in t)
    if (!(i in e))
      throw new RangeError(`Unsupported attribute ${i} for ${n} of type ${i}`);
  for (let i in e) {
    let o = e[i];
    o.validate && o.validate(t[i]);
  }
}
function uH(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  if (t)
    for (let r in t)
      n[r] = new pNe(e, r, t[r]);
  return n;
}
let vL = class dH {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.name = t, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = uH(t, r.attrs), this.defaultAttrs = aH(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || t == "text"), this.isText = t == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == id.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(t) {
    return this.groups.indexOf(t) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let t in this.attrs)
      if (this.attrs[t].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(t) {
    return this == t || this.contentMatch.compatible(t.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(t) {
    return !t && this.defaultAttrs ? this.defaultAttrs : lH(this.attrs, t);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(t = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new yc(this, this.computeAttrs(t), $e.from(n), En.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(t = null, n, r) {
    return n = $e.from(n), this.checkContent(n), new yc(this, this.computeAttrs(t), n, En.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(t = null, n, r) {
    if (t = this.computeAttrs(t), n = $e.from(n), n.size) {
      let s = this.contentMatch.fillBefore(n);
      if (!s)
        return null;
      n = s.append(n);
    }
    let i = this.contentMatch.matchFragment(n), o = i && i.fillBefore($e.empty, !0);
    return o ? new yc(this, t, n.append(o), En.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(t) {
    let n = this.contentMatch.matchFragment(t);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < t.childCount; r++)
      if (!this.allowsMarks(t.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(t) {
    if (!this.validContent(t))
      throw new RangeError(`Invalid content for node ${this.name}: ${t.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(t) {
    cH(this.attrs, t, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(t) {
    return this.markSet == null || this.markSet.indexOf(t) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(t) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < t.length; n++)
      if (!this.allowsMarkType(t[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(t) {
    if (this.markSet == null)
      return t;
    let n;
    for (let r = 0; r < t.length; r++)
      this.allowsMarkType(t[r].type) ? n && n.push(t[r]) : n || (n = t.slice(0, r));
    return n ? n.length ? n : En.none : t;
  }
  /**
  @internal
  */
  static compile(t, n) {
    let r = /* @__PURE__ */ Object.create(null);
    t.forEach((o, s) => r[o] = new dH(o, n, s));
    let i = n.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let o in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function hNe(e, t, n) {
  let r = n.split("|");
  return (i) => {
    let o = i === null ? "null" : typeof i;
    if (r.indexOf(o) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${t} on type ${e}, got ${o}`);
  };
}
class pNe {
  constructor(t, n, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? hNe(t, n, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class $w {
  /**
  @internal
  */
  constructor(t, n, r, i) {
    this.name = t, this.rank = n, this.schema = r, this.spec = i, this.attrs = uH(t, i.attrs), this.excluded = null;
    let o = aH(this.attrs);
    this.instance = o ? new En(this, o) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(t = null) {
    return !t && this.instance ? this.instance : new En(this, lH(this.attrs, t));
  }
  /**
  @internal
  */
  static compile(t, n) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return t.forEach((o, s) => r[o] = new $w(o, i++, n, s)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(t) {
    for (var n = 0; n < t.length; n++)
      t[n].type == this && (t = t.slice(0, n).concat(t.slice(n + 1)), n--);
    return t;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(t) {
    for (let n = 0; n < t.length; n++)
      if (t[n].type == this)
        return t[n];
  }
  /**
  @internal
  */
  checkAttrs(t) {
    cH(this.attrs, t, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(t) {
    return this.excluded.indexOf(t) > -1;
  }
}
class fH {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(t) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let i in t)
      n[i] = t[i];
    n.nodes = Jr.from(t.nodes), n.marks = Jr.from(t.marks || {}), this.nodes = vL.compile(this.spec.nodes, this), this.marks = $w.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let o = this.nodes[i], s = o.spec.content || "", a = o.spec.marks;
      if (o.contentMatch = r[s] || (r[s] = id.parse(s, this.nodes)), o.inlineContent = o.contentMatch.inlineContent, o.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!o.isInline || !o.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = o;
      }
      o.markSet = a == "_" ? null : a ? bL(this, a.split(" ")) : a == "" || !o.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let o = this.marks[i], s = o.spec.excludes;
      o.excluded = s == null ? [o] : s == "" ? [] : bL(this, s.split(" "));
    }
    this.nodeFromJSON = (i) => yc.fromJSON(this, i), this.markFromJSON = (i) => En.fromJSON(this, i), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(t, n = null, r, i) {
    if (typeof t == "string")
      t = this.nodeType(t);
    else if (t instanceof vL) {
      if (t.schema != this)
        throw new RangeError("Node type from different schema used (" + t.name + ")");
    } else throw new RangeError("Invalid node type: " + t);
    return t.createChecked(n, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(t, n) {
    let r = this.nodes.text;
    return new Zb(r, r.defaultAttrs, t, En.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(t, n) {
    return typeof t == "string" && (t = this.marks[t]), t.create(n);
  }
  /**
  @internal
  */
  nodeType(t) {
    let n = this.nodes[t];
    if (!n)
      throw new RangeError("Unknown node type: " + t);
    return n;
  }
}
function bL(e, t) {
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r], o = e.marks[i], s = o;
    if (o)
      n.push(o);
    else
      for (let a in e.marks) {
        let c = e.marks[a];
        (i == "_" || c.spec.group && c.spec.group.split(" ").indexOf(i) > -1) && n.push(s = c);
      }
    if (!s)
      throw new SyntaxError("Unknown mark type: '" + t[r] + "'");
  }
  return n;
}
function mNe(e) {
  return e.tag != null;
}
function gNe(e) {
  return e.style != null;
}
class vc {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(t, n) {
    this.schema = t, this.rules = n, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    n.forEach((i) => {
      if (mNe(i))
        this.tags.push(i);
      else if (gNe(i)) {
        let o = /[^=]*/.exec(i.style)[0];
        r.indexOf(o) < 0 && r.push(o), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let o = t.nodes[i.node];
      return o.contentMatch.matchType(o);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(t, n = {}) {
    let r = new wL(this, n, !1);
    return r.addAll(t, En.none, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(t, n = {}) {
    let r = new wL(this, n, !0);
    return r.addAll(t, En.none, n.from, n.to), Qe.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(t, n, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let o = this.tags[i];
      if (bNe(t, o.tag) && (o.namespace === void 0 || t.namespaceURI == o.namespace) && (!o.context || n.matchesContext(o.context))) {
        if (o.getAttrs) {
          let s = o.getAttrs(t);
          if (s === !1)
            continue;
          o.attrs = s || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(t, n, r, i) {
    for (let o = i ? this.styles.indexOf(i) + 1 : 0; o < this.styles.length; o++) {
      let s = this.styles[o], a = s.style;
      if (!(a.indexOf(t) != 0 || s.context && !r.matchesContext(s.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > t.length && (a.charCodeAt(t.length) != 61 || a.slice(t.length + 1) != n))) {
        if (s.getAttrs) {
          let c = s.getAttrs(n);
          if (c === !1)
            continue;
          s.attrs = c || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(t) {
    let n = [];
    function r(i) {
      let o = i.priority == null ? 50 : i.priority, s = 0;
      for (; s < n.length; s++) {
        let a = n[s];
        if ((a.priority == null ? 50 : a.priority) < o)
          break;
      }
      n.splice(s, 0, i);
    }
    for (let i in t.marks) {
      let o = t.marks[i].spec.parseDOM;
      o && o.forEach((s) => {
        r(s = SL(s)), s.mark || s.ignore || s.clearMark || (s.mark = i);
      });
    }
    for (let i in t.nodes) {
      let o = t.nodes[i].spec.parseDOM;
      o && o.forEach((s) => {
        r(s = SL(s)), s.node || s.ignore || s.mark || (s.node = i);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(t) {
    return t.cached.domParser || (t.cached.domParser = new vc(t, vc.schemaRules(t)));
  }
}
const hH = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, yNe = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, pH = { ol: !0, ul: !0 }, gg = 1, oT = 2, Im = 4;
function xL(e, t, n) {
  return t != null ? (t ? gg : 0) | (t === "full" ? oT : 0) : e && e.whitespace == "pre" ? gg | oT : n & ~Im;
}
class Zv {
  constructor(t, n, r, i, o, s) {
    this.type = t, this.attrs = n, this.marks = r, this.solid = i, this.options = s, this.content = [], this.activeMarks = En.none, this.match = o || (s & Im ? null : t.contentMatch);
  }
  findWrapping(t) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore($e.from(t));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(t.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(t.type);
  }
  finish(t) {
    if (!(this.options & gg)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let o = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = o.withText(o.text.slice(0, o.text.length - i[0].length));
      }
    }
    let n = $e.from(this.content);
    return !t && this.match && (n = n.append(this.match.fillBefore($e.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(t) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : t.parentNode && !hH.hasOwnProperty(t.parentNode.nodeName.toLowerCase());
  }
}
class wL {
  constructor(t, n, r) {
    this.parser = t, this.options = n, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let i = n.topNode, o, s = xL(null, n.preserveWhitespace, 0) | (r ? Im : 0);
    i ? o = new Zv(i.type, i.attrs, En.none, !0, n.topMatch || i.type.contentMatch, s) : r ? o = new Zv(null, null, En.none, !0, null, s) : o = new Zv(t.schema.topNodeType, null, En.none, !0, null, s), this.nodes = [o], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(t, n) {
    t.nodeType == 3 ? this.addTextNode(t, n) : t.nodeType == 1 && this.addElement(t, n);
  }
  addTextNode(t, n) {
    let r = t.nodeValue, i = this.top, o = i.options & oT ? "full" : this.localPreserveWS || (i.options & gg) > 0, { schema: s } = this.parser;
    if (o === "full" || i.inlineContext(t) || /[^ \t\r\n\u000c]/.test(r)) {
      if (o)
        if (o === "full")
          r = r.replace(/\r\n?/g, `
`);
        else if (s.linebreakReplacement && /[\r\n]/.test(r) && this.top.findWrapping(s.linebreakReplacement.create())) {
          let a = r.split(/\r?\n|\r/);
          for (let c = 0; c < a.length; c++)
            c && this.insertNode(s.linebreakReplacement.create(), n, !0), a[c] && this.insertNode(s.text(a[c]), n, !/\S/.test(a[c]));
          r = "";
        } else
          r = r.replace(/\r?\n|\r/g, " ");
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let a = i.content[i.content.length - 1], c = t.previousSibling;
        (!a || c && c.nodeName == "BR" || a.isText && /[ \t\r\n\u000c]$/.test(a.text)) && (r = r.slice(1));
      }
      r && this.insertNode(s.text(r), n, !/\S/.test(r)), this.findInText(t);
    } else
      this.findInside(t);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(t, n, r) {
    let i = this.localPreserveWS, o = this.top;
    (t.tagName == "PRE" || /pre/.test(t.style && t.style.whiteSpace)) && (this.localPreserveWS = !0);
    let s = t.nodeName.toLowerCase(), a;
    pH.hasOwnProperty(s) && this.parser.normalizeLists && vNe(t);
    let c = this.options.ruleFromNode && this.options.ruleFromNode(t) || (a = this.parser.matchTag(t, this, r));
    e: if (c ? c.ignore : yNe.hasOwnProperty(s))
      this.findInside(t), this.ignoreFallback(t, n);
    else if (!c || c.skip || c.closeParent) {
      c && c.closeParent ? this.open = Math.max(0, this.open - 1) : c && c.skip.nodeType && (t = c.skip);
      let u, f = this.needsBlock;
      if (hH.hasOwnProperty(s))
        o.content.length && o.content[0].isInline && this.open && (this.open--, o = this.top), u = !0, o.type || (this.needsBlock = !0);
      else if (!t.firstChild) {
        this.leafFallback(t, n);
        break e;
      }
      let h = c && c.skip ? n : this.readStyles(t, n);
      h && this.addAll(t, h), u && this.sync(o), this.needsBlock = f;
    } else {
      let u = this.readStyles(t, n);
      u && this.addElementByRule(t, c, u, c.consuming === !1 ? a : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(t, n) {
    t.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(t.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(t, n) {
    t.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(t, n) {
    let r = t.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let o = this.parser.matchedStyles[i], s = r.getPropertyValue(o);
        if (s)
          for (let a = void 0; ; ) {
            let c = this.parser.matchStyle(o, s, this, a);
            if (!c)
              break;
            if (c.ignore)
              return null;
            if (c.clearMark ? n = n.filter((u) => !c.clearMark(u)) : n = n.concat(this.parser.schema.marks[c.mark].create(c.attrs)), c.consuming === !1)
              a = c;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(t, n, r, i) {
    let o, s;
    if (n.node)
      if (s = this.parser.schema.nodes[n.node], s.isLeaf)
        this.insertNode(s.create(n.attrs), r, t.nodeName == "BR") || this.leafFallback(t, r);
      else {
        let c = this.enter(s, n.attrs || null, r, n.preserveWhitespace);
        c && (o = !0, r = c);
      }
    else {
      let c = this.parser.schema.marks[n.mark];
      r = r.concat(c.create(n.attrs));
    }
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(t);
    else if (i)
      this.addElement(t, r, i);
    else if (n.getContent)
      this.findInside(t), n.getContent(t, this.parser.schema).forEach((c) => this.insertNode(c, r, !1));
    else {
      let c = t;
      typeof n.contentElement == "string" ? c = t.querySelector(n.contentElement) : typeof n.contentElement == "function" ? c = n.contentElement(t) : n.contentElement && (c = n.contentElement), this.findAround(t, c, !0), this.addAll(c, r), this.findAround(t, c, !1);
    }
    o && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(t, n, r, i) {
    let o = r || 0;
    for (let s = r ? t.childNodes[r] : t.firstChild, a = i == null ? null : t.childNodes[i]; s != a; s = s.nextSibling, ++o)
      this.findAtPoint(t, o), this.addDOM(s, n);
    this.findAtPoint(t, o);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(t, n, r) {
    let i, o;
    for (let s = this.open, a = 0; s >= 0; s--) {
      let c = this.nodes[s], u = c.findWrapping(t);
      if (u && (!i || i.length > u.length + a) && (i = u, o = c, !u.length))
        break;
      if (c.solid) {
        if (r)
          break;
        a += 2;
      }
    }
    if (!i)
      return null;
    this.sync(o);
    for (let s = 0; s < i.length; s++)
      n = this.enterInner(i[s], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(t, n, r) {
    if (t.isInline && this.needsBlock && !this.top.type) {
      let o = this.textblockFromContext();
      o && (n = this.enterInner(o, null, n));
    }
    let i = this.findPlace(t, n, r);
    if (i) {
      this.closeExtra();
      let o = this.top;
      o.match && (o.match = o.match.matchType(t.type));
      let s = En.none;
      for (let a of i.concat(t.marks))
        (o.type ? o.type.allowsMarkType(a.type) : kL(a.type, t.type)) && (s = a.addToSet(s));
      return o.content.push(t.mark(s)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(t, n, r, i) {
    let o = this.findPlace(t.create(n), r, !1);
    return o && (o = this.enterInner(t, n, r, !0, i)), o;
  }
  // Open a node of the given type
  enterInner(t, n, r, i = !1, o) {
    this.closeExtra();
    let s = this.top;
    s.match = s.match && s.match.matchType(t);
    let a = xL(t, o, s.options);
    s.options & Im && s.content.length == 0 && (a |= Im);
    let c = En.none;
    return r = r.filter((u) => (s.type ? s.type.allowsMarkType(u.type) : kL(u.type, t)) ? (c = u.addToSet(c), !1) : !0), this.nodes.push(new Zv(t, n, c, i, null, a)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(t = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(t));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(t) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == t)
        return this.open = n, !0;
      this.localPreserveWS && (this.nodes[n].options |= gg);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let t = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let i = r.length - 1; i >= 0; i--)
        t += r[i].nodeSize;
      n && t++;
    }
    return t;
  }
  findAtPoint(t, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == t && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(t) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && t.nodeType == 1 && t.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(t, n, r) {
    if (t != n && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && t.nodeType == 1 && t.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(t) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == t && (this.find[n].pos = this.currentPos - (t.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(t) {
    if (t.indexOf("|") > -1)
      return t.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = t.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), o = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), s = (a, c) => {
      for (; a >= 0; a--) {
        let u = n[a];
        if (u == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; c >= o; c--)
            if (s(a - 1, c))
              return !0;
          return !1;
        } else {
          let f = c > 0 || c == 0 && i ? this.nodes[c].type : r && c >= o ? r.node(c - o).type : null;
          if (!f || f.name != u && !f.isInGroup(u))
            return !1;
          c--;
        }
      }
      return !0;
    };
    return s(n.length - 1, this.open);
  }
  textblockFromContext() {
    let t = this.options.context;
    if (t)
      for (let n = t.depth; n >= 0; n--) {
        let r = t.node(n).contentMatchAt(t.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function vNe(e) {
  for (let t = e.firstChild, n = null; t; t = t.nextSibling) {
    let r = t.nodeType == 1 ? t.nodeName.toLowerCase() : null;
    r && pH.hasOwnProperty(r) && n ? (n.appendChild(t), t = n) : r == "li" ? n = t : r && (n = null);
  }
}
function bNe(e, t) {
  return (e.matches || e.msMatchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector).call(e, t);
}
function SL(e) {
  let t = {};
  for (let n in e)
    t[n] = e[n];
  return t;
}
function kL(e, t) {
  let n = t.schema.nodes;
  for (let r in n) {
    let i = n[r];
    if (!i.allowsMarkType(e))
      continue;
    let o = [], s = (a) => {
      o.push(a);
      for (let c = 0; c < a.edgeCount; c++) {
        let { type: u, next: f } = a.edge(c);
        if (u == t || o.indexOf(f) < 0 && s(f))
          return !0;
      }
    };
    if (s(i.contentMatch))
      return !0;
  }
}
class md {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(t, n) {
    this.nodes = t, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(t, n = {}, r) {
    r || (r = zC(n).createDocumentFragment());
    let i = r, o = [];
    return t.forEach((s) => {
      if (o.length || s.marks.length) {
        let a = 0, c = 0;
        for (; a < o.length && c < s.marks.length; ) {
          let u = s.marks[c];
          if (!this.marks[u.type.name]) {
            c++;
            continue;
          }
          if (!u.eq(o[a][0]) || u.type.spec.spanning === !1)
            break;
          a++, c++;
        }
        for (; a < o.length; )
          i = o.pop()[1];
        for (; c < s.marks.length; ) {
          let u = s.marks[c++], f = this.serializeMark(u, s.isInline, n);
          f && (o.push([u, i]), i.appendChild(f.dom), i = f.contentDOM || f.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(s, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(t, n) {
    let { dom: r, contentDOM: i } = z0(zC(n), this.nodes[t.type.name](t), null, t.attrs);
    if (i) {
      if (t.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(t.content, n, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(t, n = {}) {
    let r = this.serializeNodeInner(t, n);
    for (let i = t.marks.length - 1; i >= 0; i--) {
      let o = this.serializeMark(t.marks[i], t.isInline, n);
      o && ((o.contentDOM || o.dom).appendChild(r), r = o.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(t, n, r = {}) {
    let i = this.marks[t.type.name];
    return i && z0(zC(r), i(t, n), null, t.attrs);
  }
  static renderSpec(t, n, r = null, i) {
    return z0(t, n, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(t) {
    return t.cached.domSerializer || (t.cached.domSerializer = new md(this.nodesFromSchema(t), this.marksFromSchema(t)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(t) {
    let n = CL(t.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(t) {
    return CL(t.marks);
  }
}
function CL(e) {
  let t = {};
  for (let n in e) {
    let r = e[n].spec.toDOM;
    r && (t[n] = r);
  }
  return t;
}
function zC(e) {
  return e.document || window.document;
}
const EL = /* @__PURE__ */ new WeakMap();
function xNe(e) {
  let t = EL.get(e);
  return t === void 0 && EL.set(e, t = wNe(e)), t;
}
function wNe(e) {
  let t = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          t || (t = []), t.push(r);
        else
          for (let i = 0; i < r.length; i++)
            n(r[i]);
      else
        for (let i in r)
          n(r[i]);
  }
  return n(e), t;
}
function z0(e, t, n, r) {
  if (typeof t == "string")
    return { dom: e.createTextNode(t) };
  if (t.nodeType != null)
    return { dom: t };
  if (t.dom && t.dom.nodeType != null)
    return t;
  let i = t[0], o;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (o = xNe(r)) && o.indexOf(t) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let s = i.indexOf(" ");
  s > 0 && (n = i.slice(0, s), i = i.slice(s + 1));
  let a, c = n ? e.createElementNS(n, i) : e.createElement(i), u = t[1], f = 1;
  if (u && typeof u == "object" && u.nodeType == null && !Array.isArray(u)) {
    f = 2;
    for (let h in u)
      if (u[h] != null) {
        let m = h.indexOf(" ");
        m > 0 ? c.setAttributeNS(h.slice(0, m), h.slice(m + 1), u[h]) : h == "style" && c.style ? c.style.cssText = u[h] : c.setAttribute(h, u[h]);
      }
  }
  for (let h = f; h < t.length; h++) {
    let m = t[h];
    if (m === 0) {
      if (h < t.length - 1 || h > f)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: c, contentDOM: c };
    } else {
      let { dom: g, contentDOM: b } = z0(e, m, n, r);
      if (c.appendChild(g), b) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = b;
      }
    }
  }
  return { dom: c, contentDOM: a };
}
const mH = 65535, gH = Math.pow(2, 16);
function SNe(e, t) {
  return e + t * gH;
}
function _L(e) {
  return e & mH;
}
function kNe(e) {
  return (e - (e & mH)) / gH;
}
const yH = 1, vH = 2, L0 = 4, bH = 8;
class sT {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.pos = t, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & bH) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (yH | L0)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (vH | L0)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & L0) > 0;
  }
}
class uo {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(t, n = !1) {
    if (this.ranges = t, this.inverted = n, !t.length && uo.empty)
      return uo.empty;
  }
  /**
  @internal
  */
  recover(t) {
    let n = 0, r = _L(t);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + n + kNe(t);
  }
  mapResult(t, n = 1) {
    return this._map(t, n, !1);
  }
  map(t, n = 1) {
    return this._map(t, n, !0);
  }
  /**
  @internal
  */
  _map(t, n, r) {
    let i = 0, o = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let c = this.ranges[a] - (this.inverted ? i : 0);
      if (c > t)
        break;
      let u = this.ranges[a + o], f = this.ranges[a + s], h = c + u;
      if (t <= h) {
        let m = u ? t == c ? -1 : t == h ? 1 : n : n, g = c + i + (m < 0 ? 0 : f);
        if (r)
          return g;
        let b = t == (n < 0 ? c : h) ? null : SNe(a / 3, t - c), x = t == c ? vH : t == h ? yH : L0;
        return (n < 0 ? t != c : t != h) && (x |= bH), new sT(g, x, b);
      }
      i += f - u;
    }
    return r ? t + i : new sT(t + i, 0, null);
  }
  /**
  @internal
  */
  touches(t, n) {
    let r = 0, i = _L(n), o = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let c = this.ranges[a] - (this.inverted ? r : 0);
      if (c > t)
        break;
      let u = this.ranges[a + o], f = c + u;
      if (t <= f && a == i * 3)
        return !0;
      r += this.ranges[a + s] - u;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(t) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, o = 0; i < this.ranges.length; i += 3) {
      let s = this.ranges[i], a = s - (this.inverted ? o : 0), c = s + (this.inverted ? 0 : o), u = this.ranges[i + n], f = this.ranges[i + r];
      t(a, a + u, c, c + f), o += f - u;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new uo(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(t) {
    return t == 0 ? uo.empty : new uo(t < 0 ? [0, -t, 0] : [0, 0, t]);
  }
}
uo.empty = new uo([]);
class yg {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(t, n, r = 0, i = t ? t.length : 0) {
    this.mirror = n, this.from = r, this.to = i, this._maps = t || [], this.ownData = !(t || n);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(t = 0, n = this.maps.length) {
    return new yg(this._maps, this.mirror, t, n);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(t, n) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(t), n != null && this.setMirror(this._maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(t) {
    for (let n = 0, r = this._maps.length; n < t._maps.length; n++) {
      let i = t.getMirror(n);
      this.appendMap(t._maps[n], i != null && i < n ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(t) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == t)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(t, n) {
    this.mirror || (this.mirror = []), this.mirror.push(t, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(t) {
    for (let n = t.maps.length - 1, r = this._maps.length + t._maps.length; n >= 0; n--) {
      let i = t.getMirror(n);
      this.appendMap(t._maps[n].invert(), i != null && i > n ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let t = new yg();
    return t.appendMappingInverted(this), t;
  }
  /**
  Map a position through this mapping.
  */
  map(t, n = 1) {
    if (this.mirror)
      return this._map(t, n, !0);
    for (let r = this.from; r < this.to; r++)
      t = this._maps[r].map(t, n);
    return t;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(t, n = 1) {
    return this._map(t, n, !1);
  }
  /**
  @internal
  */
  _map(t, n, r) {
    let i = 0;
    for (let o = this.from; o < this.to; o++) {
      let s = this._maps[o], a = s.mapResult(t, n);
      if (a.recover != null) {
        let c = this.getMirror(o);
        if (c != null && c > o && c < this.to) {
          o = c, t = this._maps[c].recover(a.recover);
          continue;
        }
      }
      i |= a.delInfo, t = a.pos;
    }
    return r ? t : new sT(t, i, null);
  }
}
const LC = /* @__PURE__ */ Object.create(null);
class xi {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return uo.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(t) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(t, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = LC[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(t, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(t, n) {
    if (t in LC)
      throw new RangeError("Duplicate use of step JSON ID " + t);
    return LC[t] = n, n.prototype.jsonID = t, n;
  }
}
class Cr {
  /**
  @internal
  */
  constructor(t, n) {
    this.doc = t, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(t) {
    return new Cr(t, null);
  }
  /**
  Create a failed step result.
  */
  static fail(t) {
    return new Cr(null, t);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(t, n, r, i) {
    try {
      return Cr.ok(t.replace(n, r, i));
    } catch (o) {
      if (o instanceof qb)
        return Cr.fail(o.message);
      throw o;
    }
  }
}
function cN(e, t, n) {
  let r = [];
  for (let i = 0; i < e.childCount; i++) {
    let o = e.child(i);
    o.content.size && (o = o.copy(cN(o.content, t, o))), o.isInline && (o = t(o, n, i)), r.push(o);
  }
  return $e.fromArray(r);
}
class dc extends xi {
  /**
  Create a mark step.
  */
  constructor(t, n, r) {
    super(), this.from = t, this.to = n, this.mark = r;
  }
  apply(t) {
    let n = t.slice(this.from, this.to), r = t.resolve(this.from), i = r.node(r.sharedDepth(this.to)), o = new Qe(cN(n.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), i), n.openStart, n.openEnd);
    return Cr.fromReplace(t, this.from, this.to, o);
  }
  invert() {
    return new cs(this.from, this.to, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new dc(n.pos, r.pos, this.mark);
  }
  merge(t) {
    return t instanceof dc && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from ? new dc(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new dc(n.from, n.to, t.markFromJSON(n.mark));
  }
}
xi.jsonID("addMark", dc);
class cs extends xi {
  /**
  Create a mark-removing step.
  */
  constructor(t, n, r) {
    super(), this.from = t, this.to = n, this.mark = r;
  }
  apply(t) {
    let n = t.slice(this.from, this.to), r = new Qe(cN(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), t), n.openStart, n.openEnd);
    return Cr.fromReplace(t, this.from, this.to, r);
  }
  invert() {
    return new dc(this.from, this.to, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new cs(n.pos, r.pos, this.mark);
  }
  merge(t) {
    return t instanceof cs && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from ? new cs(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new cs(n.from, n.to, t.markFromJSON(n.mark));
  }
}
xi.jsonID("removeMark", cs);
class fc extends xi {
  /**
  Create a node mark step.
  */
  constructor(t, n) {
    super(), this.pos = t, this.mark = n;
  }
  apply(t) {
    let n = t.nodeAt(this.pos);
    if (!n)
      return Cr.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return Cr.fromReplace(t, this.pos, this.pos + 1, new Qe($e.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(t) {
    let n = t.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r))
            return new fc(this.pos, n.marks[i]);
        return new fc(this.pos, this.mark);
      }
    }
    return new od(this.pos, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new fc(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new fc(n.pos, t.markFromJSON(n.mark));
  }
}
xi.jsonID("addNodeMark", fc);
class od extends xi {
  /**
  Create a mark-removing step.
  */
  constructor(t, n) {
    super(), this.pos = t, this.mark = n;
  }
  apply(t) {
    let n = t.nodeAt(this.pos);
    if (!n)
      return Cr.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return Cr.fromReplace(t, this.pos, this.pos + 1, new Qe($e.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(t) {
    let n = t.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new fc(this.pos, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new od(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new od(n.pos, t.markFromJSON(n.mark));
  }
}
xi.jsonID("removeNodeMark", od);
class Ur extends xi {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(t, n, r, i = !1) {
    super(), this.from = t, this.to = n, this.slice = r, this.structure = i;
  }
  apply(t) {
    return this.structure && aT(t, this.from, this.to) ? Cr.fail("Structure replace would overwrite content") : Cr.fromReplace(t, this.from, this.to, this.slice);
  }
  getMap() {
    return new uo([this.from, this.to - this.from, this.slice.size]);
  }
  invert(t) {
    return new Ur(this.from, this.from + this.slice.size, t.slice(this.from, this.to));
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new Ur(n.pos, Math.max(n.pos, r.pos), this.slice, this.structure);
  }
  merge(t) {
    if (!(t instanceof Ur) || t.structure || this.structure)
      return null;
    if (this.from + this.slice.size == t.from && !this.slice.openEnd && !t.slice.openStart) {
      let n = this.slice.size + t.slice.size == 0 ? Qe.empty : new Qe(this.slice.content.append(t.slice.content), this.slice.openStart, t.slice.openEnd);
      return new Ur(this.from, this.to + (t.to - t.from), n, this.structure);
    } else if (t.to == this.from && !this.slice.openStart && !t.slice.openEnd) {
      let n = this.slice.size + t.slice.size == 0 ? Qe.empty : new Qe(t.slice.content.append(this.slice.content), t.slice.openStart, this.slice.openEnd);
      return new Ur(t.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let t = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (t.slice = this.slice.toJSON()), this.structure && (t.structure = !0), t;
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new Ur(n.from, n.to, Qe.fromJSON(t, n.slice), !!n.structure);
  }
}
xi.jsonID("replace", Ur);
class Hr extends xi {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(t, n, r, i, o, s, a = !1) {
    super(), this.from = t, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = o, this.insert = s, this.structure = a;
  }
  apply(t) {
    if (this.structure && (aT(t, this.from, this.gapFrom) || aT(t, this.gapTo, this.to)))
      return Cr.fail("Structure gap-replace would overwrite content");
    let n = t.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return Cr.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? Cr.fromReplace(t, this.from, this.to, r) : Cr.fail("Content does not fit in gap");
  }
  getMap() {
    return new uo([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(t) {
    let n = this.gapTo - this.gapFrom;
    return new Hr(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, t.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1), i = this.from == this.gapFrom ? n.pos : t.map(this.gapFrom, -1), o = this.to == this.gapTo ? r.pos : t.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || i < n.pos || o > r.pos ? null : new Hr(n.pos, r.pos, i, o, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let t = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (t.slice = this.slice.toJSON()), this.structure && (t.structure = !0), t;
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Hr(n.from, n.to, n.gapFrom, n.gapTo, Qe.fromJSON(t, n.slice), n.insert, !!n.structure);
  }
}
xi.jsonID("replaceAround", Hr);
function aT(e, t, n) {
  let r = e.resolve(t), i = n - t, o = r.depth;
  for (; i > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount; )
    o--, i--;
  if (i > 0) {
    let s = r.node(o).maybeChild(r.indexAfter(o));
    for (; i > 0; ) {
      if (!s || s.isLeaf)
        return !0;
      s = s.firstChild, i--;
    }
  }
  return !1;
}
function CNe(e, t, n, r) {
  let i = [], o = [], s, a;
  e.doc.nodesBetween(t, n, (c, u, f) => {
    if (!c.isInline)
      return;
    let h = c.marks;
    if (!r.isInSet(h) && f.type.allowsMarkType(r.type)) {
      let m = Math.max(u, t), g = Math.min(u + c.nodeSize, n), b = r.addToSet(h);
      for (let x = 0; x < h.length; x++)
        h[x].isInSet(b) || (s && s.to == m && s.mark.eq(h[x]) ? s.to = g : i.push(s = new cs(m, g, h[x])));
      a && a.to == m ? a.to = g : o.push(a = new dc(m, g, r));
    }
  }), i.forEach((c) => e.step(c)), o.forEach((c) => e.step(c));
}
function ENe(e, t, n, r) {
  let i = [], o = 0;
  e.doc.nodesBetween(t, n, (s, a) => {
    if (!s.isInline)
      return;
    o++;
    let c = null;
    if (r instanceof $w) {
      let u = s.marks, f;
      for (; f = r.isInSet(u); )
        (c || (c = [])).push(f), u = f.removeFromSet(u);
    } else r ? r.isInSet(s.marks) && (c = [r]) : c = s.marks;
    if (c && c.length) {
      let u = Math.min(a + s.nodeSize, n);
      for (let f = 0; f < c.length; f++) {
        let h = c[f], m;
        for (let g = 0; g < i.length; g++) {
          let b = i[g];
          b.step == o - 1 && h.eq(i[g].style) && (m = b);
        }
        m ? (m.to = u, m.step = o) : i.push({ style: h, from: Math.max(a, t), to: u, step: o });
      }
    }
  }), i.forEach((s) => e.step(new cs(s.from, s.to, s.style)));
}
function uN(e, t, n, r = n.contentMatch, i = !0) {
  let o = e.doc.nodeAt(t), s = [], a = t + 1;
  for (let c = 0; c < o.childCount; c++) {
    let u = o.child(c), f = a + u.nodeSize, h = r.matchType(u.type);
    if (!h)
      s.push(new Ur(a, f, Qe.empty));
    else {
      r = h;
      for (let m = 0; m < u.marks.length; m++)
        n.allowsMarkType(u.marks[m].type) || e.step(new cs(a, f, u.marks[m]));
      if (i && u.isText && n.whitespace != "pre") {
        let m, g = /\r?\n|\r/g, b;
        for (; m = g.exec(u.text); )
          b || (b = new Qe($e.from(n.schema.text(" ", n.allowedMarks(u.marks))), 0, 0)), s.push(new Ur(a + m.index, a + m.index + m[0].length, b));
      }
    }
    a = f;
  }
  if (!r.validEnd) {
    let c = r.fillBefore($e.empty, !0);
    e.replace(a, a, new Qe(c, 0, 0));
  }
  for (let c = s.length - 1; c >= 0; c--)
    e.step(s[c]);
}
function _Ne(e, t, n) {
  return (t == 0 || e.canReplace(t, e.childCount)) && (n == e.childCount || e.canReplace(0, n));
}
function Fh(e) {
  let n = e.parent.content.cutByIndex(e.startIndex, e.endIndex);
  for (let r = e.depth, i = 0, o = 0; ; --r) {
    let s = e.$from.node(r), a = e.$from.index(r) + i, c = e.$to.indexAfter(r) - o;
    if (r < e.depth && s.canReplace(a, c, n))
      return r;
    if (r == 0 || s.type.spec.isolating || !_Ne(s, a, c))
      break;
    a && (i = 1), c < s.childCount && (o = 1);
  }
  return null;
}
function TNe(e, t, n) {
  let { $from: r, $to: i, depth: o } = t, s = r.before(o + 1), a = i.after(o + 1), c = s, u = a, f = $e.empty, h = 0;
  for (let b = o, x = !1; b > n; b--)
    x || r.index(b) > 0 ? (x = !0, f = $e.from(r.node(b).copy(f)), h++) : c--;
  let m = $e.empty, g = 0;
  for (let b = o, x = !1; b > n; b--)
    x || i.after(b + 1) < i.end(b) ? (x = !0, m = $e.from(i.node(b).copy(m)), g++) : u++;
  e.step(new Hr(c, u, s, a, new Qe(f.append(m), h, g), f.size - h, !0));
}
function dN(e, t, n = null, r = e) {
  let i = ANe(e, t), o = i && MNe(r, t);
  return o ? i.map(TL).concat({ type: t, attrs: n }).concat(o.map(TL)) : null;
}
function TL(e) {
  return { type: e, attrs: null };
}
function ANe(e, t) {
  let { parent: n, startIndex: r, endIndex: i } = e, o = n.contentMatchAt(r).findWrapping(t);
  if (!o)
    return null;
  let s = o.length ? o[0] : t;
  return n.canReplaceWith(r, i, s) ? o : null;
}
function MNe(e, t) {
  let { parent: n, startIndex: r, endIndex: i } = e, o = n.child(r), s = t.contentMatch.findWrapping(o.type);
  if (!s)
    return null;
  let c = (s.length ? s[s.length - 1] : t).contentMatch;
  for (let u = r; c && u < i; u++)
    c = c.matchType(n.child(u).type);
  return !c || !c.validEnd ? null : s;
}
function NNe(e, t, n) {
  let r = $e.empty;
  for (let s = n.length - 1; s >= 0; s--) {
    if (r.size) {
      let a = n[s].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = $e.from(n[s].type.create(n[s].attrs, r));
  }
  let i = t.start, o = t.end;
  e.step(new Hr(i, o, i, o, new Qe(r, 0, 0), n.length, !0));
}
function RNe(e, t, n, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let o = e.steps.length;
  e.doc.nodesBetween(t, n, (s, a) => {
    let c = typeof i == "function" ? i(s) : i;
    if (s.isTextblock && !s.hasMarkup(r, c) && ONe(e.doc, e.mapping.slice(o).map(a), r)) {
      let u = null;
      if (r.schema.linebreakReplacement) {
        let g = r.whitespace == "pre", b = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        g && !b ? u = !1 : !g && b && (u = !0);
      }
      u === !1 && wH(e, s, a, o), uN(e, e.mapping.slice(o).map(a, 1), r, void 0, u === null);
      let f = e.mapping.slice(o), h = f.map(a, 1), m = f.map(a + s.nodeSize, 1);
      return e.step(new Hr(h, m, h + 1, m - 1, new Qe($e.from(r.create(c, null, s.marks)), 0, 0), 1, !0)), u === !0 && xH(e, s, a, o), !1;
    }
  });
}
function xH(e, t, n, r) {
  t.forEach((i, o) => {
    if (i.isText) {
      let s, a = /\r?\n|\r/g;
      for (; s = a.exec(i.text); ) {
        let c = e.mapping.slice(r).map(n + 1 + o + s.index);
        e.replaceWith(c, c + 1, t.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function wH(e, t, n, r) {
  t.forEach((i, o) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let s = e.mapping.slice(r).map(n + 1 + o);
      e.replaceWith(s, s + 1, t.type.schema.text(`
`));
    }
  });
}
function ONe(e, t, n) {
  let r = e.resolve(t), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, n);
}
function DNe(e, t, n, r, i) {
  let o = e.doc.nodeAt(t);
  if (!o)
    throw new RangeError("No node at given position");
  n || (n = o.type);
  let s = n.create(r, null, i || o.marks);
  if (o.isLeaf)
    return e.replaceWith(t, t + o.nodeSize, s);
  if (!n.validContent(o.content))
    throw new RangeError("Invalid content for node type " + n.name);
  e.step(new Hr(t, t + o.nodeSize, t + 1, t + o.nodeSize - 1, new Qe($e.from(s), 0, 0), 1, !0));
}
function Ga(e, t, n = 1, r) {
  let i = e.resolve(t), o = i.depth - n, s = r && r[r.length - 1] || i.parent;
  if (o < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !s.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let u = i.depth - 1, f = n - 2; u > o; u--, f--) {
    let h = i.node(u), m = i.index(u);
    if (h.type.spec.isolating)
      return !1;
    let g = h.content.cutByIndex(m, h.childCount), b = r && r[f + 1];
    b && (g = g.replaceChild(0, b.type.create(b.attrs)));
    let x = r && r[f] || h;
    if (!h.canReplace(m + 1, h.childCount) || !x.type.validContent(g))
      return !1;
  }
  let a = i.indexAfter(o), c = r && r[0];
  return i.node(o).canReplaceWith(a, a, c ? c.type : i.node(o + 1).type);
}
function PNe(e, t, n = 1, r) {
  let i = e.doc.resolve(t), o = $e.empty, s = $e.empty;
  for (let a = i.depth, c = i.depth - n, u = n - 1; a > c; a--, u--) {
    o = $e.from(i.node(a).copy(o));
    let f = r && r[u];
    s = $e.from(f ? f.type.create(f.attrs, s) : i.node(a).copy(s));
  }
  e.step(new Ur(t, t, new Qe(o.append(s), n, n), !0));
}
function Vc(e, t) {
  let n = e.resolve(t), r = n.index();
  return SH(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function jNe(e, t) {
  t.content.size || e.type.compatibleContent(t.type);
  let n = e.contentMatchAt(e.childCount), { linebreakReplacement: r } = e.type.schema;
  for (let i = 0; i < t.childCount; i++) {
    let o = t.child(i), s = o.type == r ? e.type.schema.nodes.text : o.type;
    if (n = n.matchType(s), !n || !e.type.allowsMarks(o.marks))
      return !1;
  }
  return n.validEnd;
}
function SH(e, t) {
  return !!(e && t && !e.isLeaf && jNe(e, t));
}
function Uw(e, t, n = -1) {
  let r = e.resolve(t);
  for (let i = r.depth; ; i--) {
    let o, s, a = r.index(i);
    if (i == r.depth ? (o = r.nodeBefore, s = r.nodeAfter) : n > 0 ? (o = r.node(i + 1), a++, s = r.node(i).maybeChild(a)) : (o = r.node(i).maybeChild(a - 1), s = r.node(i + 1)), o && !o.isTextblock && SH(o, s) && r.node(i).canReplace(a, a + 1))
      return t;
    if (i == 0)
      break;
    t = n < 0 ? r.before(i) : r.after(i);
  }
}
function INe(e, t, n) {
  let r = null, { linebreakReplacement: i } = e.doc.type.schema, o = e.doc.resolve(t - n), s = o.node().type;
  if (i && s.inlineContent) {
    let f = s.whitespace == "pre", h = !!s.contentMatch.matchType(i);
    f && !h ? r = !1 : !f && h && (r = !0);
  }
  let a = e.steps.length;
  if (r === !1) {
    let f = e.doc.resolve(t + n);
    wH(e, f.node(), f.before(), a);
  }
  s.inlineContent && uN(e, t + n - 1, s, o.node().contentMatchAt(o.index()), r == null);
  let c = e.mapping.slice(a), u = c.map(t - n);
  if (e.step(new Ur(u, c.map(t + n, -1), Qe.empty, !0)), r === !0) {
    let f = e.doc.resolve(u);
    xH(e, f.node(), f.before(), e.steps.length);
  }
  return e;
}
function zNe(e, t, n) {
  let r = e.resolve(t);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return t;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.index(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.before(i + 1);
      if (o > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.indexAfter(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.after(i + 1);
      if (o < r.node(i).childCount)
        return null;
    }
  return null;
}
function kH(e, t, n) {
  let r = e.resolve(t);
  if (!n.content.size)
    return t;
  let i = n.content;
  for (let o = 0; o < n.openStart; o++)
    i = i.firstChild.content;
  for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++)
    for (let s = r.depth; s >= 0; s--) {
      let a = s == r.depth ? 0 : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2 ? -1 : 1, c = r.index(s) + (a > 0 ? 1 : 0), u = r.node(s), f = !1;
      if (o == 1)
        f = u.canReplace(c, c, i);
      else {
        let h = u.contentMatchAt(c).findWrapping(i.firstChild.type);
        f = h && u.canReplaceWith(c, c, h[0]);
      }
      if (f)
        return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1);
    }
  return null;
}
function Fw(e, t, n = t, r = Qe.empty) {
  if (t == n && !r.size)
    return null;
  let i = e.resolve(t), o = e.resolve(n);
  return CH(i, o, r) ? new Ur(t, n, r) : new LNe(i, o, r).fit();
}
function CH(e, t, n) {
  return !n.openStart && !n.openEnd && e.start() == t.start() && e.parent.canReplace(e.index(), t.index(), n.content);
}
class LNe {
  constructor(t, n, r) {
    this.$from = t, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = $e.empty;
    for (let i = 0; i <= t.depth; i++) {
      let o = t.node(i);
      this.frontier.push({
        type: o.type,
        match: o.contentMatchAt(t.indexAfter(i))
      });
    }
    for (let i = t.depth; i > 0; i--)
      this.placed = $e.from(t.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let u = this.findFittable();
      u ? this.placeNodes(u) : this.openMore() || this.dropNode();
    }
    let t = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(t < 0 ? this.$to : r.doc.resolve(t));
    if (!i)
      return null;
    let o = this.placed, s = r.depth, a = i.depth;
    for (; s && a && o.childCount == 1; )
      o = o.firstChild.content, s--, a--;
    let c = new Qe(o, s, a);
    return t > -1 ? new Hr(r.pos, t, this.$to.pos, this.$to.end(), c, n) : c.size || r.pos != this.$to.pos ? new Ur(r.pos, i.pos, c) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let t = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < t; r++) {
      let o = n.firstChild;
      if (n.childCount > 1 && (i = 0), o.type.spec.isolating && i <= r) {
        t = r;
        break;
      }
      n = o.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? t : this.unplaced.openStart; r >= 0; r--) {
        let i, o = null;
        r ? (o = BC(this.unplaced.content, r - 1).firstChild, i = o.content) : i = this.unplaced.content;
        let s = i.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: c, match: u } = this.frontier[a], f, h = null;
          if (n == 1 && (s ? u.matchType(s.type) || (h = u.fillBefore($e.from(s), !1)) : o && c.compatibleContent(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: o, inject: h };
          if (n == 2 && s && (f = u.findWrapping(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: o, wrap: f };
          if (o && u.matchType(o.type))
            break;
        }
      }
  }
  openMore() {
    let { content: t, openStart: n, openEnd: r } = this.unplaced, i = BC(t, n);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new Qe(t, n + 1, Math.max(r, i.size + n >= t.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: t, openStart: n, openEnd: r } = this.unplaced, i = BC(t, n);
    if (i.childCount <= 1 && n > 0) {
      let o = t.size - n <= n + i.size;
      this.unplaced = new Qe(pm(t, n - 1, 1), n - 1, o ? n - 1 : r);
    } else
      this.unplaced = new Qe(pm(t, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: t, frontierDepth: n, parent: r, inject: i, wrap: o }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (o)
      for (let x = 0; x < o.length; x++)
        this.openFrontierNode(o[x]);
    let s = this.unplaced, a = r ? r.content : s.content, c = s.openStart - t, u = 0, f = [], { match: h, type: m } = this.frontier[n];
    if (i) {
      for (let x = 0; x < i.childCount; x++)
        f.push(i.child(x));
      h = h.matchFragment(i);
    }
    let g = a.size + t - (s.content.size - s.openEnd);
    for (; u < a.childCount; ) {
      let x = a.child(u), w = h.matchType(x.type);
      if (!w)
        break;
      u++, (u > 1 || c == 0 || x.content.size) && (h = w, f.push(EH(x.mark(m.allowedMarks(x.marks)), u == 1 ? c : 0, u == a.childCount ? g : -1)));
    }
    let b = u == a.childCount;
    b || (g = -1), this.placed = mm(this.placed, n, $e.from(f)), this.frontier[n].match = h, b && g < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let x = 0, w = a; x < g; x++) {
      let S = w.lastChild;
      this.frontier.push({ type: S.type, match: S.contentMatchAt(S.childCount) }), w = S.content;
    }
    this.unplaced = b ? t == 0 ? Qe.empty : new Qe(pm(s.content, t - 1, 1), t - 1, g < 0 ? s.openEnd : t - 1) : new Qe(pm(s.content, t, u), s.openStart, s.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let t = this.frontier[this.depth], n;
    if (!t.type.isTextblock || !$C(this.$to, this.$to.depth, t.type, t.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(t) {
    e: for (let n = Math.min(this.depth, t.depth); n >= 0; n--) {
      let { match: r, type: i } = this.frontier[n], o = n < t.depth && t.end(n + 1) == t.pos + (t.depth - (n + 1)), s = $C(t, n, i, r, o);
      if (s) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: c, type: u } = this.frontier[a], f = $C(t, a, u, c, !0);
          if (!f || f.childCount)
            continue e;
        }
        return { depth: n, fit: s, move: o ? t.doc.resolve(t.after(n + 1)) : t };
      }
    }
  }
  close(t) {
    let n = this.findCloseLevel(t);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = mm(this.placed, n.depth, n.fit)), t = n.move;
    for (let r = n.depth + 1; r <= t.depth; r++) {
      let i = t.node(r), o = i.type.contentMatch.fillBefore(i.content, !0, t.index(r));
      this.openFrontierNode(i.type, i.attrs, o);
    }
    return t;
  }
  openFrontierNode(t, n = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(t), this.placed = mm(this.placed, this.depth, $e.from(t.create(n, r))), this.frontier.push({ type: t, match: t.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore($e.empty, !0);
    n.childCount && (this.placed = mm(this.placed, this.frontier.length, n));
  }
}
function pm(e, t, n) {
  return t == 0 ? e.cutByIndex(n, e.childCount) : e.replaceChild(0, e.firstChild.copy(pm(e.firstChild.content, t - 1, n)));
}
function mm(e, t, n) {
  return t == 0 ? e.append(n) : e.replaceChild(e.childCount - 1, e.lastChild.copy(mm(e.lastChild.content, t - 1, n)));
}
function BC(e, t) {
  for (let n = 0; n < t; n++)
    e = e.firstChild.content;
  return e;
}
function EH(e, t, n) {
  if (t <= 0)
    return e;
  let r = e.content;
  return t > 1 && (r = r.replaceChild(0, EH(r.firstChild, t - 1, r.childCount == 1 ? n - 1 : 0))), t > 0 && (r = e.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(e.type.contentMatch.matchFragment(r).fillBefore($e.empty, !0)))), e.copy(r);
}
function $C(e, t, n, r, i) {
  let o = e.node(t), s = i ? e.indexAfter(t) : e.index(t);
  if (s == o.childCount && !n.compatibleContent(o.type))
    return null;
  let a = r.fillBefore(o.content, !0, s);
  return a && !BNe(n, o.content, s) ? a : null;
}
function BNe(e, t, n) {
  for (let r = n; r < t.childCount; r++)
    if (!e.allowsMarks(t.child(r).marks))
      return !0;
  return !1;
}
function $Ne(e) {
  return e.spec.defining || e.spec.definingForContent;
}
function UNe(e, t, n, r) {
  if (!r.size)
    return e.deleteRange(t, n);
  let i = e.doc.resolve(t), o = e.doc.resolve(n);
  if (CH(i, o, r))
    return e.step(new Ur(t, n, r));
  let s = TH(i, o);
  s[s.length - 1] == 0 && s.pop();
  let a = -(i.depth + 1);
  s.unshift(a);
  for (let m = i.depth, g = i.pos - 1; m > 0; m--, g--) {
    let b = i.node(m).type.spec;
    if (b.defining || b.definingAsContext || b.isolating)
      break;
    s.indexOf(m) > -1 ? a = m : i.before(m) == g && s.splice(1, 0, -m);
  }
  let c = s.indexOf(a), u = [], f = r.openStart;
  for (let m = r.content, g = 0; ; g++) {
    let b = m.firstChild;
    if (u.push(b), g == r.openStart)
      break;
    m = b.content;
  }
  for (let m = f - 1; m >= 0; m--) {
    let g = u[m], b = $Ne(g.type);
    if (b && !g.sameMarkup(i.node(Math.abs(a) - 1)))
      f = m;
    else if (b || !g.type.isTextblock)
      break;
  }
  for (let m = r.openStart; m >= 0; m--) {
    let g = (m + f + 1) % (r.openStart + 1), b = u[g];
    if (b)
      for (let x = 0; x < s.length; x++) {
        let w = s[(x + c) % s.length], S = !0;
        w < 0 && (S = !1, w = -w);
        let _ = i.node(w - 1), M = i.index(w - 1);
        if (_.canReplaceWith(M, M, b.type, b.marks))
          return e.replace(i.before(w), S ? o.after(w) : n, new Qe(_H(r.content, 0, r.openStart, g), g, r.openEnd));
      }
  }
  let h = e.steps.length;
  for (let m = s.length - 1; m >= 0 && (e.replace(t, n, r), !(e.steps.length > h)); m--) {
    let g = s[m];
    g < 0 || (t = i.before(g), n = o.after(g));
  }
}
function _H(e, t, n, r, i) {
  if (t < n) {
    let o = e.firstChild;
    e = e.replaceChild(0, o.copy(_H(o.content, t + 1, n, r, o)));
  }
  if (t > r) {
    let o = i.contentMatchAt(0), s = o.fillBefore(e).append(e);
    e = s.append(o.matchFragment(s).fillBefore($e.empty, !0));
  }
  return e;
}
function FNe(e, t, n, r) {
  if (!r.isInline && t == n && e.doc.resolve(t).parent.content.size) {
    let i = zNe(e.doc, t, r.type);
    i != null && (t = n = i);
  }
  e.replaceRange(t, n, new Qe($e.from(r), 0, 0));
}
function VNe(e, t, n) {
  let r = e.doc.resolve(t), i = e.doc.resolve(n), o = TH(r, i);
  for (let s = 0; s < o.length; s++) {
    let a = o[s], c = s == o.length - 1;
    if (c && a == 0 || r.node(a).type.contentMatch.validEnd)
      return e.delete(r.start(a), i.end(a));
    if (a > 0 && (c || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
      return e.delete(r.before(a), i.after(a));
  }
  for (let s = 1; s <= r.depth && s <= i.depth; s++)
    if (t - r.start(s) == r.depth - s && n > r.end(s) && i.end(s) - n != i.depth - s && r.start(s - 1) == i.start(s - 1) && r.node(s - 1).canReplace(r.index(s - 1), i.index(s - 1)))
      return e.delete(r.before(s), n);
  e.delete(t, n);
}
function TH(e, t) {
  let n = [], r = Math.min(e.depth, t.depth);
  for (let i = r; i >= 0; i--) {
    let o = e.start(i);
    if (o < e.pos - (e.depth - i) || t.end(i) > t.pos + (t.depth - i) || e.node(i).type.spec.isolating || t.node(i).type.spec.isolating)
      break;
    (o == t.start(i) || i == e.depth && i == t.depth && e.parent.inlineContent && t.parent.inlineContent && i && t.start(i - 1) == o - 1) && n.push(i);
  }
  return n;
}
class Jf extends xi {
  /**
  Construct an attribute step.
  */
  constructor(t, n, r) {
    super(), this.pos = t, this.attr = n, this.value = r;
  }
  apply(t) {
    let n = t.nodeAt(this.pos);
    if (!n)
      return Cr.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in n.attrs)
      r[o] = n.attrs[o];
    r[this.attr] = this.value;
    let i = n.type.create(r, null, n.marks);
    return Cr.fromReplace(t, this.pos, this.pos + 1, new Qe($e.from(i), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return uo.empty;
  }
  invert(t) {
    return new Jf(this.pos, this.attr, t.nodeAt(this.pos).attrs[this.attr]);
  }
  map(t) {
    let n = t.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Jf(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(t, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new Jf(n.pos, n.attr, n.value);
  }
}
xi.jsonID("attr", Jf);
class vg extends xi {
  /**
  Construct an attribute step.
  */
  constructor(t, n) {
    super(), this.attr = t, this.value = n;
  }
  apply(t) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in t.attrs)
      n[i] = t.attrs[i];
    n[this.attr] = this.value;
    let r = t.type.create(n, t.content, t.marks);
    return Cr.ok(r);
  }
  getMap() {
    return uo.empty;
  }
  invert(t) {
    return new vg(this.attr, t.attrs[this.attr]);
  }
  map(t) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(t, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new vg(n.attr, n.value);
  }
}
xi.jsonID("docAttr", vg);
let fh = class extends Error {
};
fh = function e(t) {
  let n = Error.call(this, t);
  return n.__proto__ = e.prototype, n;
};
fh.prototype = Object.create(Error.prototype);
fh.prototype.constructor = fh;
fh.prototype.name = "TransformError";
class AH {
  /**
  Create a transform that starts with the given document.
  */
  constructor(t) {
    this.doc = t, this.steps = [], this.docs = [], this.mapping = new yg();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(t) {
    let n = this.maybeStep(t);
    if (n.failed)
      throw new fh(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(t) {
    let n = t.apply(this.doc);
    return n.failed || this.addStep(t, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  Return a single range, in post-transform document positions,
  that covers all content changed by this transform. Returns null
  if no replacements are made. Note that this will ignore changes
  that add/remove marks without replacing the underlying content.
  */
  changedRange() {
    let t = 1e9, n = -1e9;
    for (let r = 0; r < this.mapping.maps.length; r++) {
      let i = this.mapping.maps[r];
      r && (t = i.map(t, 1), n = i.map(n, -1)), i.forEach((o, s, a, c) => {
        t = Math.min(t, a), n = Math.max(n, c);
      });
    }
    return t == 1e9 ? null : { from: t, to: n };
  }
  /**
  @internal
  */
  addStep(t, n) {
    this.docs.push(this.doc), this.steps.push(t), this.mapping.appendMap(t.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(t, n = t, r = Qe.empty) {
    let i = Fw(this.doc, t, n, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(t, n, r) {
    return this.replace(t, n, new Qe($e.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(t, n) {
    return this.replace(t, n, Qe.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(t, n) {
    return this.replaceWith(t, t, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(t, n, r) {
    return UNe(this, t, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(t, n, r) {
    return FNe(this, t, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(t, n) {
    return VNe(this, t, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(t, n) {
    return TNe(this, t, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(t, n = 1) {
    return INe(this, t, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(t, n) {
    return NNe(this, t, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(t, n = t, r, i = null) {
    return RNe(this, t, n, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(t, n, r = null, i) {
    return DNe(this, t, n, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(t, n, r) {
    return this.step(new Jf(t, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(t, n) {
    return this.step(new vg(t, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(t, n) {
    return this.step(new fc(t, n)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(t, n) {
    let r = this.doc.nodeAt(t);
    if (!r)
      throw new RangeError("No node at position " + t);
    if (n instanceof En)
      n.isInSet(r.marks) && this.step(new od(t, n));
    else {
      let i = r.marks, o, s = [];
      for (; o = n.isInSet(i); )
        s.push(new od(t, o)), i = o.removeFromSet(i);
      for (let a = s.length - 1; a >= 0; a--)
        this.step(s[a]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(t, n = 1, r) {
    return PNe(this, t, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(t, n, r) {
    return CNe(this, t, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(t, n, r) {
    return ENe(this, t, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(t, n, r) {
    return uN(this, t, n, r), this;
  }
}
const UC = /* @__PURE__ */ Object.create(null);
class zt {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(t, n, r) {
    this.$anchor = t, this.$head = n, this.ranges = r || [new HNe(t.min(n), t.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let t = this.ranges;
    for (let n = 0; n < t.length; n++)
      if (t[n].$from.pos != t[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(t, n = Qe.empty) {
    let r = n.content.lastChild, i = null;
    for (let a = 0; a < n.openEnd; a++)
      i = r, r = r.lastChild;
    let o = t.steps.length, s = this.ranges;
    for (let a = 0; a < s.length; a++) {
      let { $from: c, $to: u } = s[a], f = t.mapping.slice(o);
      t.replaceRange(f.map(c.pos), f.map(u.pos), a ? Qe.empty : n), a == 0 && NL(t, o, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(t, n) {
    let r = t.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      let { $from: s, $to: a } = i[o], c = t.mapping.slice(r), u = c.map(s.pos), f = c.map(a.pos);
      o ? t.deleteRange(u, f) : (t.replaceRangeWith(u, f, n), NL(t, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(t, n, r = !1) {
    let i = t.parent.inlineContent ? new kt(t) : Af(t.node(0), t.parent, t.pos, t.index(), n, r);
    if (i)
      return i;
    for (let o = t.depth - 1; o >= 0; o--) {
      let s = n < 0 ? Af(t.node(0), t.node(o), t.before(o + 1), t.index(o), n, r) : Af(t.node(0), t.node(o), t.after(o + 1), t.index(o) + 1, n, r);
      if (s)
        return s;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(t, n = 1) {
    return this.findFrom(t, n) || this.findFrom(t, -n) || new mo(t.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(t) {
    return Af(t, t, 0, 0, 1) || new mo(t);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(t) {
    return Af(t, t, t.content.size, t.childCount, -1) || new mo(t);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(t, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = UC[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(t, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(t, n) {
    if (t in UC)
      throw new RangeError("Duplicate use of selection JSON ID " + t);
    return UC[t] = n, n.prototype.jsonID = t, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return kt.between(this.$anchor, this.$head).getBookmark();
  }
}
zt.prototype.visible = !0;
class HNe {
  /**
  Create a range.
  */
  constructor(t, n) {
    this.$from = t, this.$to = n;
  }
}
let AL = !1;
function ML(e) {
  !AL && !e.parent.inlineContent && (AL = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + e.parent.type.name + ")"));
}
class kt extends zt {
  /**
  Construct a text selection between the given points.
  */
  constructor(t, n = t) {
    ML(t), ML(n), super(t, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(t, n) {
    let r = t.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return zt.near(r);
    let i = t.resolve(n.map(this.anchor));
    return new kt(i.parent.inlineContent ? i : r, r);
  }
  replace(t, n = Qe.empty) {
    if (super.replace(t, n), n == Qe.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && t.ensureMarks(r);
    }
  }
  eq(t) {
    return t instanceof kt && t.anchor == this.anchor && t.head == this.head;
  }
  getBookmark() {
    return new Vw(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new kt(t.resolve(n.anchor), t.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(t, n, r = n) {
    let i = t.resolve(n);
    return new this(i, r == n ? i : t.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(t, n, r) {
    let i = t.pos - n.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let o = zt.findFrom(n, r, !0) || zt.findFrom(n, -r, !0);
      if (o)
        n = o.$head;
      else
        return zt.near(n, r);
    }
    return t.parent.inlineContent || (i == 0 ? t = n : (t = (zt.findFrom(t, -r, !0) || zt.findFrom(t, r, !0)).$anchor, t.pos < n.pos != i < 0 && (t = n))), new kt(t, n);
  }
}
zt.jsonID("text", kt);
class Vw {
  constructor(t, n) {
    this.anchor = t, this.head = n;
  }
  map(t) {
    return new Vw(t.map(this.anchor), t.map(this.head));
  }
  resolve(t) {
    return kt.between(t.resolve(this.anchor), t.resolve(this.head));
  }
}
class ht extends zt {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(t) {
    let n = t.nodeAfter, r = t.node(0).resolve(t.pos + n.nodeSize);
    super(t, r), this.node = n;
  }
  map(t, n) {
    let { deleted: r, pos: i } = n.mapResult(this.anchor), o = t.resolve(i);
    return r ? zt.near(o) : new ht(o);
  }
  content() {
    return new Qe($e.from(this.node), 0, 0);
  }
  eq(t) {
    return t instanceof ht && t.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new fN(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ht(t.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(t, n) {
    return new ht(t.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(t) {
    return !t.isText && t.type.spec.selectable !== !1;
  }
}
ht.prototype.visible = !1;
zt.jsonID("node", ht);
class fN {
  constructor(t) {
    this.anchor = t;
  }
  map(t) {
    let { deleted: n, pos: r } = t.mapResult(this.anchor);
    return n ? new Vw(r, r) : new fN(r);
  }
  resolve(t) {
    let n = t.resolve(this.anchor), r = n.nodeAfter;
    return r && ht.isSelectable(r) ? new ht(n) : zt.near(n);
  }
}
class mo extends zt {
  /**
  Create an all-selection over the given document.
  */
  constructor(t) {
    super(t.resolve(0), t.resolve(t.content.size));
  }
  replace(t, n = Qe.empty) {
    if (n == Qe.empty) {
      t.delete(0, t.doc.content.size);
      let r = zt.atStart(t.doc);
      r.eq(t.selection) || t.setSelection(r);
    } else
      super.replace(t, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(t) {
    return new mo(t);
  }
  map(t) {
    return new mo(t);
  }
  eq(t) {
    return t instanceof mo;
  }
  getBookmark() {
    return WNe;
  }
}
zt.jsonID("all", mo);
const WNe = {
  map() {
    return this;
  },
  resolve(e) {
    return new mo(e);
  }
};
function Af(e, t, n, r, i, o = !1) {
  if (t.inlineContent)
    return kt.create(e, n);
  for (let s = r - (i > 0 ? 0 : 1); i > 0 ? s < t.childCount : s >= 0; s += i) {
    let a = t.child(s);
    if (a.isAtom) {
      if (!o && ht.isSelectable(a))
        return ht.create(e, n - (i < 0 ? a.nodeSize : 0));
    } else {
      let c = Af(e, a, n + i, i < 0 ? a.childCount : 0, i, o);
      if (c)
        return c;
    }
    n += a.nodeSize * i;
  }
  return null;
}
function NL(e, t, n) {
  let r = e.steps.length - 1;
  if (r < t)
    return;
  let i = e.steps[r];
  if (!(i instanceof Ur || i instanceof Hr))
    return;
  let o = e.mapping.maps[r], s;
  o.forEach((a, c, u, f) => {
    s == null && (s = f);
  }), e.setSelection(zt.near(e.doc.resolve(s), n));
}
const RL = 1, Yv = 2, OL = 4;
class qNe extends AH {
  /**
  @internal
  */
  constructor(t) {
    super(t.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = t.selection, this.storedMarks = t.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(t) {
    if (t.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = t, this.curSelectionFor = this.steps.length, this.updated = (this.updated | RL) & ~Yv, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & RL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(t) {
    return this.storedMarks = t, this.updated |= Yv, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(t) {
    return En.sameSet(this.storedMarks || this.selection.$from.marks(), t) || this.setStoredMarks(t), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(t) {
    return this.ensureMarks(t.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(t) {
    return this.ensureMarks(t.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Yv) > 0;
  }
  /**
  @internal
  */
  addStep(t, n) {
    super.addStep(t, n), this.updated = this.updated & ~Yv, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(t) {
    return this.time = t, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(t) {
    return this.selection.replace(this, t), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(t, n = !0) {
    let r = this.selection;
    return n && (t = t.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || En.none))), r.replaceWith(this, t), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(t, n, r) {
    let i = this.doc.type.schema;
    if (n == null)
      return t ? this.replaceSelectionWith(i.text(t), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), !t)
        return this.deleteRange(n, r);
      let o = this.storedMarks;
      if (!o) {
        let s = this.doc.resolve(n);
        o = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, i.text(t, o)), !this.selection.empty && this.selection.to == n + t.length && this.setSelection(zt.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(t, n) {
    return this.meta[typeof t == "string" ? t : t.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(t) {
    return this.meta[typeof t == "string" ? t : t.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let t in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= OL, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & OL) > 0;
  }
}
function DL(e, t) {
  return !t || !e ? e : e.bind(t);
}
class gm {
  constructor(t, n, r) {
    this.name = t, this.init = DL(n.init, r), this.apply = DL(n.apply, r);
  }
}
const GNe = [
  new gm("doc", {
    init(e) {
      return e.doc || e.schema.topNodeType.createAndFill();
    },
    apply(e) {
      return e.doc;
    }
  }),
  new gm("selection", {
    init(e, t) {
      return e.selection || zt.atStart(t.doc);
    },
    apply(e) {
      return e.selection;
    }
  }),
  new gm("storedMarks", {
    init(e) {
      return e.storedMarks || null;
    },
    apply(e, t, n, r) {
      return r.selection.$cursor ? e.storedMarks : null;
    }
  }),
  new gm("scrollToSelection", {
    init() {
      return 0;
    },
    apply(e, t) {
      return e.scrolledIntoView ? t + 1 : t;
    }
  })
];
class FC {
  constructor(t, n) {
    this.schema = t, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = GNe.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new gm(r.key, r.spec.state, r));
    });
  }
}
class Uf {
  /**
  @internal
  */
  constructor(t) {
    this.config = t;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(t) {
    return this.applyTransaction(t).state;
  }
  /**
  @internal
  */
  filterTransaction(t, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, t, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(t) {
    if (!this.filterTransaction(t))
      return { state: this, transactions: [] };
    let n = [t], r = this.applyInner(t), i = null;
    for (; ; ) {
      let o = !1;
      for (let s = 0; s < this.config.plugins.length; s++) {
        let a = this.config.plugins[s];
        if (a.spec.appendTransaction) {
          let c = i ? i[s].n : 0, u = i ? i[s].state : this, f = c < n.length && a.spec.appendTransaction.call(a, c ? n.slice(c) : n, u, r);
          if (f && r.filterTransaction(f, s)) {
            if (f.setMeta("appendedTransaction", t), !i) {
              i = [];
              for (let h = 0; h < this.config.plugins.length; h++)
                i.push(h < s ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(f), r = r.applyInner(f), o = !0;
          }
          i && (i[s] = { state: r, n: n.length });
        }
      }
      if (!o)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(t) {
    if (!t.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Uf(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let o = r[i];
      n[o.name] = o.apply(t, this[o.name], this, n);
    }
    return n;
  }
  /**
  Accessor that constructs and returns a new [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new qNe(this);
  }
  /**
  Create a new state.
  */
  static create(t) {
    let n = new FC(t.doc ? t.doc.type.schema : t.schema, t.plugins), r = new Uf(n);
    for (let i = 0; i < n.fields.length; i++)
      r[n.fields[i].name] = n.fields[i].init(t, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(t) {
    let n = new FC(this.schema, t.plugins), r = n.fields, i = new Uf(n);
    for (let o = 0; o < r.length; o++) {
      let s = r[o].name;
      i[s] = this.hasOwnProperty(s) ? this[s] : r[o].init(t, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(t) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), t && typeof t == "object")
      for (let r in t) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = t[r], o = i.spec.state;
        o && o.toJSON && (n[r] = o.toJSON.call(i, this[i.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(t, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!t.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new FC(t.schema, t.plugins), o = new Uf(i);
    return i.fields.forEach((s) => {
      if (s.name == "doc")
        o.doc = yc.fromJSON(t.schema, n.doc);
      else if (s.name == "selection")
        o.selection = zt.fromJSON(o.doc, n.selection);
      else if (s.name == "storedMarks")
        n.storedMarks && (o.storedMarks = n.storedMarks.map(t.schema.markFromJSON));
      else {
        if (r)
          for (let a in r) {
            let c = r[a], u = c.spec.state;
            if (c.key == s.name && u && u.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              o[s.name] = u.fromJSON.call(c, t, n[a], o);
              return;
            }
          }
        o[s.name] = s.init(t, o);
      }
    }), o;
  }
}
function MH(e, t, n) {
  for (let r in e) {
    let i = e[r];
    i instanceof Function ? i = i.bind(t) : r == "handleDOMEvents" && (i = MH(i, t, {})), n[r] = i;
  }
  return n;
}
class Zn {
  /**
  Create a plugin.
  */
  constructor(t) {
    this.spec = t, this.props = {}, t.props && MH(t.props, this, this.props), this.key = t.key ? t.key.key : NH("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(t) {
    return t[this.key];
  }
}
const VC = /* @__PURE__ */ Object.create(null);
function NH(e) {
  return e in VC ? e + "$" + ++VC[e] : (VC[e] = 0, e + "$");
}
class Tr {
  /**
  Create a plugin key.
  */
  constructor(t = "key") {
    this.key = NH(t);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(t) {
    return t.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(t) {
    return t[this.key];
  }
}
const hN = (e, t) => e.selection.empty ? !1 : (t && t(e.tr.deleteSelection().scrollIntoView()), !0);
function RH(e, t) {
  let { $cursor: n } = e.selection;
  return !n || (t ? !t.endOfTextblock("backward", e) : n.parentOffset > 0) ? null : n;
}
const OH = (e, t, n) => {
  let r = RH(e, n);
  if (!r)
    return !1;
  let i = pN(r);
  if (!i) {
    let s = r.blockRange(), a = s && Fh(s);
    return a == null ? !1 : (t && t(e.tr.lift(s, a).scrollIntoView()), !0);
  }
  let o = i.nodeBefore;
  if (UH(e, i, t, -1))
    return !0;
  if (r.parent.content.size == 0 && (hh(o, "end") || ht.isSelectable(o)))
    for (let s = r.depth; ; s--) {
      let a = Fw(e.doc, r.before(s), r.after(s), Qe.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (t) {
          let c = e.tr.step(a);
          c.setSelection(hh(o, "end") ? zt.findFrom(c.doc.resolve(c.mapping.map(i.pos, -1)), -1) : ht.create(c.doc, i.pos - o.nodeSize)), t(c.scrollIntoView());
        }
        return !0;
      }
      if (s == 1 || r.node(s - 1).childCount > 1)
        break;
    }
  return o.isAtom && i.depth == r.depth - 1 ? (t && t(e.tr.delete(i.pos - o.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, KNe = (e, t, n) => {
  let r = RH(e, n);
  if (!r)
    return !1;
  let i = pN(r);
  return i ? DH(e, i, t) : !1;
}, ZNe = (e, t, n) => {
  let r = jH(e, n);
  if (!r)
    return !1;
  let i = mN(r);
  return i ? DH(e, i, t) : !1;
};
function DH(e, t, n) {
  let r = t.nodeBefore, i = r, o = t.pos - 1;
  for (; !i.isTextblock; o--) {
    if (i.type.spec.isolating)
      return !1;
    let f = i.lastChild;
    if (!f)
      return !1;
    i = f;
  }
  let s = t.nodeAfter, a = s, c = t.pos + 1;
  for (; !a.isTextblock; c++) {
    if (a.type.spec.isolating)
      return !1;
    let f = a.firstChild;
    if (!f)
      return !1;
    a = f;
  }
  let u = Fw(e.doc, o, c, Qe.empty);
  if (!u || u.from != o || u instanceof Ur && u.slice.size >= c - o)
    return !1;
  if (n) {
    let f = e.tr.step(u);
    f.setSelection(kt.create(f.doc, o)), n(f.scrollIntoView());
  }
  return !0;
}
function hh(e, t, n = !1) {
  for (let r = e; r; r = t == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const PH = (e, t, n) => {
  let { $head: r, empty: i } = e.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0)
      return !1;
    o = pN(r);
  }
  let s = o && o.nodeBefore;
  return !s || !ht.isSelectable(s) ? !1 : (t && t(e.tr.setSelection(ht.create(e.doc, o.pos - s.nodeSize)).scrollIntoView()), !0);
};
function pN(e) {
  if (!e.parent.type.spec.isolating)
    for (let t = e.depth - 1; t >= 0; t--) {
      if (e.index(t) > 0)
        return e.doc.resolve(e.before(t + 1));
      if (e.node(t).type.spec.isolating)
        break;
    }
  return null;
}
function jH(e, t) {
  let { $cursor: n } = e.selection;
  return !n || (t ? !t.endOfTextblock("forward", e) : n.parentOffset < n.parent.content.size) ? null : n;
}
const IH = (e, t, n) => {
  let r = jH(e, n);
  if (!r)
    return !1;
  let i = mN(r);
  if (!i)
    return !1;
  let o = i.nodeAfter;
  if (UH(e, i, t, 1))
    return !0;
  if (r.parent.content.size == 0 && (hh(o, "start") || ht.isSelectable(o))) {
    let s = Fw(e.doc, r.before(), r.after(), Qe.empty);
    if (s && s.slice.size < s.to - s.from) {
      if (t) {
        let a = e.tr.step(s);
        a.setSelection(hh(o, "start") ? zt.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1) : ht.create(a.doc, a.mapping.map(i.pos))), t(a.scrollIntoView());
      }
      return !0;
    }
  }
  return o.isAtom && i.depth == r.depth - 1 ? (t && t(e.tr.delete(i.pos, i.pos + o.nodeSize).scrollIntoView()), !0) : !1;
}, zH = (e, t, n) => {
  let { $head: r, empty: i } = e.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size)
      return !1;
    o = mN(r);
  }
  let s = o && o.nodeAfter;
  return !s || !ht.isSelectable(s) ? !1 : (t && t(e.tr.setSelection(ht.create(e.doc, o.pos)).scrollIntoView()), !0);
};
function mN(e) {
  if (!e.parent.type.spec.isolating)
    for (let t = e.depth - 1; t >= 0; t--) {
      let n = e.node(t);
      if (e.index(t) + 1 < n.childCount)
        return e.doc.resolve(e.after(t + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const YNe = (e, t) => {
  let n = e.selection, r = n instanceof ht, i;
  if (r) {
    if (n.node.isTextblock || !Vc(e.doc, n.from))
      return !1;
    i = n.from;
  } else if (i = Uw(e.doc, n.from, -1), i == null)
    return !1;
  if (t) {
    let o = e.tr.join(i);
    r && o.setSelection(ht.create(o.doc, i - e.doc.resolve(i).nodeBefore.nodeSize)), t(o.scrollIntoView());
  }
  return !0;
}, XNe = (e, t) => {
  let n = e.selection, r;
  if (n instanceof ht) {
    if (n.node.isTextblock || !Vc(e.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = Uw(e.doc, n.to, 1), r == null)
    return !1;
  return t && t(e.tr.join(r).scrollIntoView()), !0;
}, JNe = (e, t) => {
  let { $from: n, $to: r } = e.selection, i = n.blockRange(r), o = i && Fh(i);
  return o == null ? !1 : (t && t(e.tr.lift(i, o).scrollIntoView()), !0);
}, LH = (e, t) => {
  let { $head: n, $anchor: r } = e.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (t && t(e.tr.insertText(`
`).scrollIntoView()), !0);
};
function gN(e) {
  for (let t = 0; t < e.edgeCount; t++) {
    let { type: n } = e.edge(t);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const QNe = (e, t) => {
  let { $head: n, $anchor: r } = e.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let i = n.node(-1), o = n.indexAfter(-1), s = gN(i.contentMatchAt(o));
  if (!s || !i.canReplaceWith(o, o, s))
    return !1;
  if (t) {
    let a = n.after(), c = e.tr.replaceWith(a, a, s.createAndFill());
    c.setSelection(zt.near(c.doc.resolve(a), 1)), t(c.scrollIntoView());
  }
  return !0;
}, BH = (e, t) => {
  let n = e.selection, { $from: r, $to: i } = n;
  if (n instanceof mo || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let o = gN(i.parent.contentMatchAt(i.indexAfter()));
  if (!o || !o.isTextblock)
    return !1;
  if (t) {
    let s = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, a = e.tr.insert(s, o.createAndFill());
    a.setSelection(kt.create(a.doc, s + 1)), t(a.scrollIntoView());
  }
  return !0;
}, $H = (e, t) => {
  let { $cursor: n } = e.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let o = n.before();
    if (Ga(e.doc, o))
      return t && t(e.tr.split(o).scrollIntoView()), !0;
  }
  let r = n.blockRange(), i = r && Fh(r);
  return i == null ? !1 : (t && t(e.tr.lift(r, i).scrollIntoView()), !0);
};
function eRe(e) {
  return (t, n) => {
    let { $from: r, $to: i } = t.selection;
    if (t.selection instanceof ht && t.selection.node.isBlock)
      return !r.parentOffset || !Ga(t.doc, r.pos) ? !1 : (n && n(t.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let o = [], s, a, c = !1, u = !1;
    for (let g = r.depth; ; g--)
      if (r.node(g).isBlock) {
        c = r.end(g) == r.pos + (r.depth - g), u = r.start(g) == r.pos - (r.depth - g), a = gN(r.node(g - 1).contentMatchAt(r.indexAfter(g - 1))), o.unshift(c && a ? { type: a } : null), s = g;
        break;
      } else {
        if (g == 1)
          return !1;
        o.unshift(null);
      }
    let f = t.tr;
    (t.selection instanceof kt || t.selection instanceof mo) && f.deleteSelection();
    let h = f.mapping.map(r.pos), m = Ga(f.doc, h, o.length, o);
    if (m || (o[0] = a ? { type: a } : null, m = Ga(f.doc, h, o.length, o)), !m)
      return !1;
    if (f.split(h, o.length, o), !c && u && r.node(s).type != a) {
      let g = f.mapping.map(r.before(s)), b = f.doc.resolve(g);
      a && r.node(s - 1).canReplaceWith(b.index(), b.index() + 1, a) && f.setNodeMarkup(f.mapping.map(r.before(s)), a);
    }
    return n && n(f.scrollIntoView()), !0;
  };
}
const tRe = eRe(), nRe = (e, t) => {
  let { $from: n, to: r } = e.selection, i, o = n.sharedDepth(r);
  return o == 0 ? !1 : (i = n.before(o), t && t(e.tr.setSelection(ht.create(e.doc, i))), !0);
};
function rRe(e, t, n) {
  let r = t.nodeBefore, i = t.nodeAfter, o = t.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && t.parent.canReplace(o - 1, o) ? (n && n(e.tr.delete(t.pos - r.nodeSize, t.pos).scrollIntoView()), !0) : !t.parent.canReplace(o, o + 1) || !(i.isTextblock || Vc(e.doc, t.pos)) ? !1 : (n && n(e.tr.join(t.pos).scrollIntoView()), !0);
}
function UH(e, t, n, r) {
  let i = t.nodeBefore, o = t.nodeAfter, s, a, c = i.type.spec.isolating || o.type.spec.isolating;
  if (!c && rRe(e, t, n))
    return !0;
  let u = !c && t.parent.canReplace(t.index(), t.index() + 1);
  if (u && (s = (a = i.contentMatchAt(i.childCount)).findWrapping(o.type)) && a.matchType(s[0] || o.type).validEnd) {
    if (n) {
      let g = t.pos + o.nodeSize, b = $e.empty;
      for (let S = s.length - 1; S >= 0; S--)
        b = $e.from(s[S].create(null, b));
      b = $e.from(i.copy(b));
      let x = e.tr.step(new Hr(t.pos - 1, g, t.pos, g, new Qe(b, 1, 0), s.length, !0)), w = x.doc.resolve(g + 2 * s.length);
      w.nodeAfter && w.nodeAfter.type == i.type && Vc(x.doc, w.pos) && x.join(w.pos), n(x.scrollIntoView());
    }
    return !0;
  }
  let f = o.type.spec.isolating || r > 0 && c ? null : zt.findFrom(t, 1), h = f && f.$from.blockRange(f.$to), m = h && Fh(h);
  if (m != null && m >= t.depth)
    return n && n(e.tr.lift(h, m).scrollIntoView()), !0;
  if (u && hh(o, "start", !0) && hh(i, "end")) {
    let g = i, b = [];
    for (; b.push(g), !g.isTextblock; )
      g = g.lastChild;
    let x = o, w = 1;
    for (; !x.isTextblock; x = x.firstChild)
      w++;
    if (g.canReplace(g.childCount, g.childCount, x.content)) {
      if (n) {
        let S = $e.empty;
        for (let M = b.length - 1; M >= 0; M--)
          S = $e.from(b[M].copy(S));
        let _ = e.tr.step(new Hr(t.pos - b.length, t.pos + o.nodeSize, t.pos + w, t.pos + o.nodeSize - w, new Qe(S, b.length, 0), 0, !0));
        n(_.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function FH(e) {
  return function(t, n) {
    let r = t.selection, i = e < 0 ? r.$from : r.$to, o = i.depth;
    for (; i.node(o).isInline; ) {
      if (!o)
        return !1;
      o--;
    }
    return i.node(o).isTextblock ? (n && n(t.tr.setSelection(kt.create(t.doc, e < 0 ? i.start(o) : i.end(o)))), !0) : !1;
  };
}
const iRe = FH(-1), oRe = FH(1);
function sRe(e, t = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, s = i.blockRange(o), a = s && dN(s, e, t);
    return a ? (r && r(n.tr.wrap(s, a).scrollIntoView()), !0) : !1;
  };
}
function PL(e, t = null) {
  return function(n, r) {
    let i = !1;
    for (let o = 0; o < n.selection.ranges.length && !i; o++) {
      let { $from: { pos: s }, $to: { pos: a } } = n.selection.ranges[o];
      n.doc.nodesBetween(s, a, (c, u) => {
        if (i)
          return !1;
        if (!(!c.isTextblock || c.hasMarkup(e, t)))
          if (c.type == e)
            i = !0;
          else {
            let f = n.doc.resolve(u), h = f.index();
            i = f.parent.canReplaceWith(h, h + 1, e);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let o = n.tr;
      for (let s = 0; s < n.selection.ranges.length; s++) {
        let { $from: { pos: a }, $to: { pos: c } } = n.selection.ranges[s];
        o.setBlockType(a, c, e, t);
      }
      r(o.scrollIntoView());
    }
    return !0;
  };
}
function yN(...e) {
  return function(t, n, r) {
    for (let i = 0; i < e.length; i++)
      if (e[i](t, n, r))
        return !0;
    return !1;
  };
}
yN(hN, OH, PH);
yN(hN, IH, zH);
yN(LH, BH, $H, tRe);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function aRe(e, t = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, s = i.blockRange(o);
    if (!s)
      return !1;
    let a = r ? n.tr : null;
    return lRe(a, s, e, t) ? (r && r(a.scrollIntoView()), !0) : !1;
  };
}
function lRe(e, t, n, r = null) {
  let i = !1, o = t, s = t.$from.doc;
  if (t.depth >= 2 && t.$from.node(t.depth - 1).type.compatibleContent(n) && t.startIndex == 0) {
    if (t.$from.index(t.depth - 1) == 0)
      return !1;
    let c = s.resolve(t.start - 2);
    o = new Kb(c, c, t.depth), t.endIndex < t.parent.childCount && (t = new Kb(t.$from, s.resolve(t.$to.end(t.depth)), t.depth)), i = !0;
  }
  let a = dN(o, n, r, t);
  return a ? (e && cRe(e, t, a, i, n), !0) : !1;
}
function cRe(e, t, n, r, i) {
  let o = $e.empty;
  for (let f = n.length - 1; f >= 0; f--)
    o = $e.from(n[f].type.create(n[f].attrs, o));
  e.step(new Hr(t.start - (r ? 2 : 0), t.end, t.start, t.end, new Qe(o, 0, 0), n.length, !0));
  let s = 0;
  for (let f = 0; f < n.length; f++)
    n[f].type == i && (s = f + 1);
  let a = n.length - s, c = t.start + n.length - (r ? 2 : 0), u = t.parent;
  for (let f = t.startIndex, h = t.endIndex, m = !0; f < h; f++, m = !1)
    !m && Ga(e.doc, c, a) && (e.split(c, a), c += 2 * a), c += u.child(f).nodeSize;
  return e;
}
function uRe(e) {
  return function(t, n) {
    let { $from: r, $to: i } = t.selection, o = r.blockRange(i, (s) => s.childCount > 0 && s.firstChild.type == e);
    return o ? n ? r.node(o.depth - 1).type == e ? dRe(t, n, e, o) : fRe(t, n, o) : !0 : !1;
  };
}
function dRe(e, t, n, r) {
  let i = e.tr, o = r.end, s = r.$to.end(r.depth);
  o < s && (i.step(new Hr(o - 1, s, o, s, new Qe($e.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new Kb(i.doc.resolve(r.$from.pos), i.doc.resolve(s), r.depth));
  const a = Fh(r);
  if (a == null)
    return !1;
  i.lift(r, a);
  let c = i.doc.resolve(i.mapping.map(o, -1) - 1);
  return Vc(i.doc, c.pos) && c.nodeBefore.type == c.nodeAfter.type && i.join(c.pos), t(i.scrollIntoView()), !0;
}
function fRe(e, t, n) {
  let r = e.tr, i = n.parent;
  for (let g = n.end, b = n.endIndex - 1, x = n.startIndex; b > x; b--)
    g -= i.child(b).nodeSize, r.delete(g - 1, g + 1);
  let o = r.doc.resolve(n.start), s = o.nodeAfter;
  if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, c = n.endIndex == i.childCount, u = o.node(-1), f = o.index(-1);
  if (!u.canReplace(f + (a ? 0 : 1), f + 1, s.content.append(c ? $e.empty : $e.from(i))))
    return !1;
  let h = o.pos, m = h + s.nodeSize;
  return r.step(new Hr(h - (a ? 1 : 0), m + (c ? 1 : 0), h + 1, m - 1, new Qe((a ? $e.empty : $e.from(i.copy($e.empty))).append(c ? $e.empty : $e.from(i.copy($e.empty))), a ? 0 : 1, c ? 0 : 1), a ? 0 : 1)), t(r.scrollIntoView()), !0;
}
function hRe(e) {
  return function(t, n) {
    let { $from: r, $to: i } = t.selection, o = r.blockRange(i, (u) => u.childCount > 0 && u.firstChild.type == e);
    if (!o)
      return !1;
    let s = o.startIndex;
    if (s == 0)
      return !1;
    let a = o.parent, c = a.child(s - 1);
    if (c.type != e)
      return !1;
    if (n) {
      let u = c.lastChild && c.lastChild.type == a.type, f = $e.from(u ? e.create() : null), h = new Qe($e.from(e.create(null, $e.from(a.type.create(null, f)))), u ? 3 : 1, 0), m = o.start, g = o.end;
      n(t.tr.step(new Hr(m - (u ? 3 : 1), g, m, g, h, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
const ti = function(e) {
  for (var t = 0; ; t++)
    if (e = e.previousSibling, !e)
      return t;
}, ph = function(e) {
  let t = e.assignedSlot || e.parentNode;
  return t && t.nodeType == 11 ? t.host : t;
};
let lT = null;
const $a = function(e, t, n) {
  let r = lT || (lT = document.createRange());
  return r.setEnd(e, n ?? e.nodeValue.length), r.setStart(e, t || 0), r;
}, pRe = function() {
  lT = null;
}, sd = function(e, t, n, r) {
  return n && (jL(e, t, n, r, -1) || jL(e, t, n, r, 1));
}, mRe = /^(img|br|input|textarea|hr)$/i;
function jL(e, t, n, r, i) {
  for (var o; ; ) {
    if (e == n && t == r)
      return !0;
    if (t == (i < 0 ? 0 : zo(e))) {
      let s = e.parentNode;
      if (!s || s.nodeType != 1 || ry(e) || mRe.test(e.nodeName) || e.contentEditable == "false")
        return !1;
      t = ti(e) + (i < 0 ? 0 : 1), e = s;
    } else if (e.nodeType == 1) {
      let s = e.childNodes[t + (i < 0 ? -1 : 0)];
      if (s.nodeType == 1 && s.contentEditable == "false")
        if (!((o = s.pmViewDesc) === null || o === void 0) && o.ignoreForSelection)
          t += i;
        else
          return !1;
      else
        e = s, t = i < 0 ? zo(e) : 0;
    } else
      return !1;
  }
}
function zo(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length;
}
function gRe(e, t) {
  for (; ; ) {
    if (e.nodeType == 3 && t)
      return e;
    if (e.nodeType == 1 && t > 0) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[t - 1], t = zo(e);
    } else if (e.parentNode && !ry(e))
      t = ti(e), e = e.parentNode;
    else
      return null;
  }
}
function yRe(e, t) {
  for (; ; ) {
    if (e.nodeType == 3 && t < e.nodeValue.length)
      return e;
    if (e.nodeType == 1 && t < e.childNodes.length) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[t], t = 0;
    } else if (e.parentNode && !ry(e))
      t = ti(e) + 1, e = e.parentNode;
    else
      return null;
  }
}
function vRe(e, t, n) {
  for (let r = t == 0, i = t == zo(e); r || i; ) {
    if (e == n)
      return !0;
    let o = ti(e);
    if (e = e.parentNode, !e)
      return !1;
    r = r && o == 0, i = i && o == zo(e);
  }
}
function ry(e) {
  let t;
  for (let n = e; n && !(t = n.pmViewDesc); n = n.parentNode)
    ;
  return t && t.node && t.node.isBlock && (t.dom == e || t.contentDOM == e);
}
const Hw = function(e) {
  return e.focusNode && sd(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset);
};
function Ru(e, t) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = e, n.key = n.code = t, n;
}
function bRe(e) {
  let t = e.activeElement;
  for (; t && t.shadowRoot; )
    t = t.shadowRoot.activeElement;
  return t;
}
function xRe(e, t, n) {
  if (e.caretPositionFromPoint)
    try {
      let r = e.caretPositionFromPoint(t, n);
      if (r)
        return { node: r.offsetNode, offset: Math.min(zo(r.offsetNode), r.offset) };
    } catch {
    }
  if (e.caretRangeFromPoint) {
    let r = e.caretRangeFromPoint(t, n);
    if (r)
      return { node: r.startContainer, offset: Math.min(zo(r.startContainer), r.startOffset) };
  }
}
const Qs = typeof navigator < "u" ? navigator : null, IL = typeof document < "u" ? document : null, Hc = Qs && Qs.userAgent || "", cT = /Edge\/(\d+)/.exec(Hc), VH = /MSIE \d/.exec(Hc), uT = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Hc), Ki = !!(VH || uT || cT), bc = VH ? document.documentMode : uT ? +uT[1] : cT ? +cT[1] : 0, Vo = !Ki && /gecko\/(\d+)/i.test(Hc);
Vo && +(/Firefox\/(\d+)/.exec(Hc) || [0, 0])[1];
const dT = !Ki && /Chrome\/(\d+)/.exec(Hc), Vr = !!dT, HH = dT ? +dT[1] : 0, ii = !Ki && !!Qs && /Apple Computer/.test(Qs.vendor), mh = ii && (/Mobile\/\w+/.test(Hc) || !!Qs && Qs.maxTouchPoints > 2), jo = mh || (Qs ? /Mac/.test(Qs.platform) : !1), WH = Qs ? /Win/.test(Qs.platform) : !1, Ha = /Android \d/.test(Hc), iy = !!IL && "webkitFontSmoothing" in IL.documentElement.style, wRe = iy ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function SRe(e) {
  let t = e.defaultView && e.defaultView.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: e.documentElement.clientWidth,
    top: 0,
    bottom: e.documentElement.clientHeight
  };
}
function Pa(e, t) {
  return typeof e == "number" ? e : e[t];
}
function kRe(e) {
  let t = e.getBoundingClientRect(), n = t.width / e.offsetWidth || 1, r = t.height / e.offsetHeight || 1;
  return {
    left: t.left,
    right: t.left + e.clientWidth * n,
    top: t.top,
    bottom: t.top + e.clientHeight * r
  };
}
function zL(e, t, n) {
  let r = e.someProp("scrollThreshold") || 0, i = e.someProp("scrollMargin") || 5, o = e.dom.ownerDocument;
  for (let s = n || e.dom; s; ) {
    if (s.nodeType != 1) {
      s = ph(s);
      continue;
    }
    let a = s, c = a == o.body, u = c ? SRe(o) : kRe(a), f = 0, h = 0;
    if (t.top < u.top + Pa(r, "top") ? h = -(u.top - t.top + Pa(i, "top")) : t.bottom > u.bottom - Pa(r, "bottom") && (h = t.bottom - t.top > u.bottom - u.top ? t.top + Pa(i, "top") - u.top : t.bottom - u.bottom + Pa(i, "bottom")), t.left < u.left + Pa(r, "left") ? f = -(u.left - t.left + Pa(i, "left")) : t.right > u.right - Pa(r, "right") && (f = t.right - u.right + Pa(i, "right")), f || h)
      if (c)
        o.defaultView.scrollBy(f, h);
      else {
        let g = a.scrollLeft, b = a.scrollTop;
        h && (a.scrollTop += h), f && (a.scrollLeft += f);
        let x = a.scrollLeft - g, w = a.scrollTop - b;
        t = { left: t.left - x, top: t.top - w, right: t.right - x, bottom: t.bottom - w };
      }
    let m = c ? "fixed" : getComputedStyle(s).position;
    if (/^(fixed|sticky)$/.test(m))
      break;
    s = m == "absolute" ? s.offsetParent : ph(s);
  }
}
function CRe(e) {
  let t = e.dom.getBoundingClientRect(), n = Math.max(0, t.top), r, i;
  for (let o = (t.left + t.right) / 2, s = n + 1; s < Math.min(innerHeight, t.bottom); s += 5) {
    let a = e.root.elementFromPoint(o, s);
    if (!a || a == e.dom || !e.dom.contains(a))
      continue;
    let c = a.getBoundingClientRect();
    if (c.top >= n - 20) {
      r = a, i = c.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: qH(e.dom) };
}
function qH(e) {
  let t = [], n = e.ownerDocument;
  for (let r = e; r && (t.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), e != n); r = ph(r))
    ;
  return t;
}
function ERe({ refDOM: e, refTop: t, stack: n }) {
  let r = e ? e.getBoundingClientRect().top : 0;
  GH(n, r == 0 ? 0 : r - t);
}
function GH(e, t) {
  for (let n = 0; n < e.length; n++) {
    let { dom: r, top: i, left: o } = e[n];
    r.scrollTop != i + t && (r.scrollTop = i + t), r.scrollLeft != o && (r.scrollLeft = o);
  }
}
let bf = null;
function _Re(e) {
  if (e.setActive)
    return e.setActive();
  if (bf)
    return e.focus(bf);
  let t = qH(e);
  e.focus(bf == null ? {
    get preventScroll() {
      return bf = { preventScroll: !0 }, !0;
    }
  } : void 0), bf || (bf = !1, GH(t, 0));
}
function KH(e, t) {
  let n, r = 2e8, i, o = 0, s = t.top, a = t.top, c, u;
  for (let f = e.firstChild, h = 0; f; f = f.nextSibling, h++) {
    let m;
    if (f.nodeType == 1)
      m = f.getClientRects();
    else if (f.nodeType == 3)
      m = $a(f).getClientRects();
    else
      continue;
    for (let g = 0; g < m.length; g++) {
      let b = m[g];
      if (b.top <= s && b.bottom >= a) {
        s = Math.max(b.bottom, s), a = Math.min(b.top, a);
        let x = b.left > t.left ? b.left - t.left : b.right < t.left ? t.left - b.right : 0;
        if (x < r) {
          n = f, r = x, i = x && n.nodeType == 3 ? {
            left: b.right < t.left ? b.right : b.left,
            top: t.top
          } : t, f.nodeType == 1 && x && (o = h + (t.left >= (b.left + b.right) / 2 ? 1 : 0));
          continue;
        }
      } else b.top > t.top && !c && b.left <= t.left && b.right >= t.left && (c = f, u = { left: Math.max(b.left, Math.min(b.right, t.left)), top: b.top });
      !n && (t.left >= b.right && t.top >= b.top || t.left >= b.left && t.top >= b.bottom) && (o = h + 1);
    }
  }
  return !n && c && (n = c, i = u, r = 0), n && n.nodeType == 3 ? TRe(n, i) : !n || r && n.nodeType == 1 ? { node: e, offset: o } : KH(n, i);
}
function TRe(e, t) {
  let n = e.nodeValue.length, r = document.createRange(), i;
  for (let o = 0; o < n; o++) {
    r.setEnd(e, o + 1), r.setStart(e, o);
    let s = Ql(r, 1);
    if (s.top != s.bottom && vN(t, s)) {
      i = { node: e, offset: o + (t.left >= (s.left + s.right) / 2 ? 1 : 0) };
      break;
    }
  }
  return r.detach(), i || { node: e, offset: 0 };
}
function vN(e, t) {
  return e.left >= t.left - 1 && e.left <= t.right + 1 && e.top >= t.top - 1 && e.top <= t.bottom + 1;
}
function ARe(e, t) {
  let n = e.parentNode;
  return n && /^li$/i.test(n.nodeName) && t.left < e.getBoundingClientRect().left ? n : e;
}
function MRe(e, t, n) {
  let { node: r, offset: i } = KH(t, n), o = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let s = r.getBoundingClientRect();
    o = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
  }
  return e.docView.posFromDOM(r, i, o);
}
function NRe(e, t, n, r) {
  let i = -1;
  for (let o = t, s = !1; o != e.dom; ) {
    let a = e.docView.nearestDesc(o, !0), c;
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((c = a.dom.getBoundingClientRect()).width || c.height) && (a.node.isBlock && a.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(a.dom.nodeName) && (!s && c.left > r.left || c.top > r.top ? i = a.posBefore : (!s && c.right < r.left || c.bottom < r.top) && (i = a.posAfter), s = !0), !a.contentDOM && i < 0 && !a.node.isText))
      return (a.node.isBlock ? r.top < (c.top + c.bottom) / 2 : r.left < (c.left + c.right) / 2) ? a.posBefore : a.posAfter;
    o = a.dom.parentNode;
  }
  return i > -1 ? i : e.docView.posFromDOM(t, n, -1);
}
function ZH(e, t, n) {
  let r = e.childNodes.length;
  if (r && n.top < n.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (t.top - n.top) / (n.bottom - n.top)) - 2)), o = i; ; ) {
      let s = e.childNodes[o];
      if (s.nodeType == 1) {
        let a = s.getClientRects();
        for (let c = 0; c < a.length; c++) {
          let u = a[c];
          if (vN(t, u))
            return ZH(s, t, u);
        }
      }
      if ((o = (o + 1) % r) == i)
        break;
    }
  return e;
}
function RRe(e, t) {
  let n = e.dom.ownerDocument, r, i = 0, o = xRe(n, t.left, t.top);
  o && ({ node: r, offset: i } = o);
  let s = (e.root.elementFromPoint ? e.root : n).elementFromPoint(t.left, t.top), a;
  if (!s || !e.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let u = e.dom.getBoundingClientRect();
    if (!vN(t, u) || (s = ZH(e.dom, t, u), !s))
      return null;
  }
  if (ii)
    for (let u = s; r && u; u = ph(u))
      u.draggable && (r = void 0);
  if (s = ARe(s, t), r) {
    if (Vo && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let f = r.childNodes[i], h;
      f.nodeName == "IMG" && (h = f.getBoundingClientRect()).right <= t.left && h.bottom > t.top && i++;
    }
    let u;
    iy && i && r.nodeType == 1 && (u = r.childNodes[i - 1]).nodeType == 1 && u.contentEditable == "false" && u.getBoundingClientRect().top >= t.top && i--, r == e.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && t.top > r.lastChild.getBoundingClientRect().bottom ? a = e.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (a = NRe(e, r, i, t));
  }
  a == null && (a = MRe(e, s, t));
  let c = e.docView.nearestDesc(s, !0);
  return { pos: a, inside: c ? c.posAtStart - c.border : -1 };
}
function LL(e) {
  return e.top < e.bottom || e.left < e.right;
}
function Ql(e, t) {
  let n = e.getClientRects();
  if (n.length) {
    let r = n[t < 0 ? 0 : n.length - 1];
    if (LL(r))
      return r;
  }
  return Array.prototype.find.call(n, LL) || e.getBoundingClientRect();
}
const ORe = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function YH(e, t, n) {
  let { node: r, offset: i, atom: o } = e.docView.domFromPos(t, n < 0 ? -1 : 1), s = iy || Vo;
  if (r.nodeType == 3)
    if (s && (ORe.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
      let c = Ql($a(r, i, i), n);
      if (Vo && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let u = Ql($a(r, i - 1, i - 1), -1);
        if (u.top == c.top) {
          let f = Ql($a(r, i, i + 1), -1);
          if (f.top != c.top)
            return Qp(f, f.left < u.left);
        }
      }
      return c;
    } else {
      let c = i, u = i, f = n < 0 ? 1 : -1;
      return n < 0 && !i ? (u++, f = -1) : n >= 0 && i == r.nodeValue.length ? (c--, f = 1) : n < 0 ? c-- : u++, Qp(Ql($a(r, c, u), f), f < 0);
    }
  if (!e.state.doc.resolve(t - (o || 0)).parent.inlineContent) {
    if (o == null && i && (n < 0 || i == zo(r))) {
      let c = r.childNodes[i - 1];
      if (c.nodeType == 1)
        return HC(c.getBoundingClientRect(), !1);
    }
    if (o == null && i < zo(r)) {
      let c = r.childNodes[i];
      if (c.nodeType == 1)
        return HC(c.getBoundingClientRect(), !0);
    }
    return HC(r.getBoundingClientRect(), n >= 0);
  }
  if (o == null && i && (n < 0 || i == zo(r))) {
    let c = r.childNodes[i - 1], u = c.nodeType == 3 ? $a(c, zo(c) - (s ? 0 : 1)) : c.nodeType == 1 && (c.nodeName != "BR" || !c.nextSibling) ? c : null;
    if (u)
      return Qp(Ql(u, 1), !1);
  }
  if (o == null && i < zo(r)) {
    let c = r.childNodes[i];
    for (; c.pmViewDesc && c.pmViewDesc.ignoreForCoords; )
      c = c.nextSibling;
    let u = c ? c.nodeType == 3 ? $a(c, 0, s ? 0 : 1) : c.nodeType == 1 ? c : null : null;
    if (u)
      return Qp(Ql(u, -1), !0);
  }
  return Qp(Ql(r.nodeType == 3 ? $a(r) : r, -n), n >= 0);
}
function Qp(e, t) {
  if (e.width == 0)
    return e;
  let n = t ? e.left : e.right;
  return { top: e.top, bottom: e.bottom, left: n, right: n };
}
function HC(e, t) {
  if (e.height == 0)
    return e;
  let n = t ? e.top : e.bottom;
  return { top: n, bottom: n, left: e.left, right: e.right };
}
function XH(e, t, n) {
  let r = e.state, i = e.root.activeElement;
  r != t && e.updateState(t), i != e.dom && e.focus();
  try {
    return n();
  } finally {
    r != t && e.updateState(r), i != e.dom && i && i.focus();
  }
}
function DRe(e, t, n) {
  let r = t.selection, i = n == "up" ? r.$from : r.$to;
  return XH(e, t, () => {
    let { node: o } = e.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = e.docView.nearestDesc(o, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        o = a.contentDOM || a.dom;
        break;
      }
      o = a.dom.parentNode;
    }
    let s = YH(e, i.pos, 1);
    for (let a = o.firstChild; a; a = a.nextSibling) {
      let c;
      if (a.nodeType == 1)
        c = a.getClientRects();
      else if (a.nodeType == 3)
        c = $a(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let u = 0; u < c.length; u++) {
        let f = c[u];
        if (f.bottom > f.top + 1 && (n == "up" ? s.top - f.top > (f.bottom - s.top) * 2 : f.bottom - s.bottom > (s.bottom - f.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const PRe = /[\u0590-\u08ac]/;
function jRe(e, t, n) {
  let { $head: r } = t.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, o = !i, s = i == r.parent.content.size, a = e.domSelection();
  return a ? !PRe.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? o : s : XH(e, t, () => {
    let { focusNode: c, focusOffset: u, anchorNode: f, anchorOffset: h } = e.domSelectionRange(), m = a.caretBidiLevel;
    a.modify("move", n, "character");
    let g = r.depth ? e.docView.domAfterPos(r.before()) : e.dom, { focusNode: b, focusOffset: x } = e.domSelectionRange(), w = b && !g.contains(b.nodeType == 1 ? b : b.parentNode) || c == b && u == x;
    try {
      a.collapse(f, h), c && (c != f || u != h) && a.extend && a.extend(c, u);
    } catch {
    }
    return m != null && (a.caretBidiLevel = m), w;
  }) : r.pos == r.start() || r.pos == r.end();
}
let BL = null, $L = null, UL = !1;
function IRe(e, t, n) {
  return BL == t && $L == n ? UL : (BL = t, $L = n, UL = n == "up" || n == "down" ? DRe(e, t, n) : jRe(e, t, n));
}
const Ho = 0, FL = 1, Iu = 2, ea = 3;
class oy {
  constructor(t, n, r, i) {
    this.parent = t, this.children = n, this.dom = r, this.contentDOM = i, this.dirty = Ho, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(t) {
    return !1;
  }
  matchesMark(t) {
    return !1;
  }
  matchesNode(t, n, r) {
    return !1;
  }
  matchesHack(t) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(t) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let t = 0;
    for (let n = 0; n < this.children.length; n++)
      t += this.children[n].size;
    return t;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let t = 0; t < this.children.length; t++)
      this.children[t].destroy();
  }
  posBeforeChild(t) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let i = this.children[n];
      if (i == t)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(t, n, r) {
    if (this.contentDOM && this.contentDOM.contains(t.nodeType == 1 ? t : t.parentNode))
      if (r < 0) {
        let o, s;
        if (t == this.contentDOM)
          o = t.childNodes[n - 1];
        else {
          for (; t.parentNode != this.contentDOM; )
            t = t.parentNode;
          o = t.previousSibling;
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this); )
          o = o.previousSibling;
        return o ? this.posBeforeChild(s) + s.size : this.posAtStart;
      } else {
        let o, s;
        if (t == this.contentDOM)
          o = t.childNodes[n];
        else {
          for (; t.parentNode != this.contentDOM; )
            t = t.parentNode;
          o = t.nextSibling;
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this); )
          o = o.nextSibling;
        return o ? this.posBeforeChild(s) : this.posAtEnd;
      }
    let i;
    if (t == this.dom && this.contentDOM)
      i = n > ti(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = t.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let o = t; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !1;
            break;
          }
          if (o.previousSibling)
            break;
        }
      if (i == null && n == t.childNodes.length)
        for (let o = t; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !0;
            break;
          }
          if (o.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(t, n = !1) {
    for (let r = !0, i = t; i; i = i.parentNode) {
      let o = this.getDesc(i), s;
      if (o && (!n || o.node))
        if (r && (s = o.nodeDOM) && !(s.nodeType == 1 ? s.contains(t.nodeType == 1 ? t : t.parentNode) : s == t))
          r = !1;
        else
          return o;
    }
  }
  getDesc(t) {
    let n = t.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(t, n, r) {
    for (let i = t; i; i = i.parentNode) {
      let o = this.getDesc(i);
      if (o)
        return o.localPosFromDOM(t, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(t) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let i = this.children[n], o = r + i.size;
      if (r == t && o != r) {
        for (; !i.border && i.children.length; )
          for (let s = 0; s < i.children.length; s++) {
            let a = i.children[s];
            if (a.size) {
              i = a;
              break;
            }
          }
        return i;
      }
      if (t < o)
        return i.descAt(t - r - i.border);
      r = o;
    }
  }
  domFromPos(t, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: t + 1 };
    let r = 0, i = 0;
    for (let o = 0; r < this.children.length; r++) {
      let s = this.children[r], a = o + s.size;
      if (a > t || s instanceof QH) {
        i = t - o;
        break;
      }
      o = a;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, n);
    for (let o; r && !(o = this.children[r - 1]).size && o instanceof JH && o.side >= 0; r--)
      ;
    if (n <= 0) {
      let o, s = !0;
      for (; o = r ? this.children[r - 1] : null, !(!o || o.dom.parentNode == this.contentDOM); r--, s = !1)
        ;
      return o && n && s && !o.border && !o.domAtom ? o.domFromPos(o.size, n) : { node: this.contentDOM, offset: o ? ti(o.dom) + 1 : 0 };
    } else {
      let o, s = !0;
      for (; o = r < this.children.length ? this.children[r] : null, !(!o || o.dom.parentNode == this.contentDOM); r++, s = !1)
        ;
      return o && s && !o.border && !o.domAtom ? o.domFromPos(0, n) : { node: this.contentDOM, offset: o ? ti(o.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(t, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: t, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, o = -1;
    for (let s = r, a = 0; ; a++) {
      let c = this.children[a], u = s + c.size;
      if (i == -1 && t <= u) {
        let f = s + c.border;
        if (t >= f && n <= u - c.border && c.node && c.contentDOM && this.contentDOM.contains(c.contentDOM))
          return c.parseRange(t, n, f);
        t = s;
        for (let h = a; h > 0; h--) {
          let m = this.children[h - 1];
          if (m.size && m.dom.parentNode == this.contentDOM && !m.emptyChildAt(1)) {
            i = ti(m.dom) + 1;
            break;
          }
          t -= m.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (u > n || a == this.children.length - 1)) {
        n = u;
        for (let f = a + 1; f < this.children.length; f++) {
          let h = this.children[f];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
            o = ti(h.dom);
            break;
          }
          n += h.size;
        }
        o == -1 && (o = this.contentDOM.childNodes.length);
        break;
      }
      s = u;
    }
    return { node: this.contentDOM, from: t, to: n, fromOffset: i, toOffset: o };
  }
  emptyChildAt(t) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[t < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(t);
  }
  domAfterPos(t) {
    let { node: n, offset: r } = this.domFromPos(t, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + t);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(t, n, r, i = !1) {
    let o = Math.min(t, n), s = Math.max(t, n);
    for (let g = 0, b = 0; g < this.children.length; g++) {
      let x = this.children[g], w = b + x.size;
      if (o > b && s < w)
        return x.setSelection(t - b - x.border, n - b - x.border, r, i);
      b = w;
    }
    let a = this.domFromPos(t, t ? -1 : 1), c = n == t ? a : this.domFromPos(n, n ? -1 : 1), u = r.root.getSelection(), f = r.domSelectionRange(), h = !1;
    if ((Vo || ii) && t == n) {
      let { node: g, offset: b } = a;
      if (g.nodeType == 3) {
        if (h = !!(b && g.nodeValue[b - 1] == `
`), h && b == g.nodeValue.length)
          for (let x = g, w; x; x = x.parentNode) {
            if (w = x.nextSibling) {
              w.nodeName == "BR" && (a = c = { node: w.parentNode, offset: ti(w) + 1 });
              break;
            }
            let S = x.pmViewDesc;
            if (S && S.node && S.node.isBlock)
              break;
          }
      } else {
        let x = g.childNodes[b - 1];
        h = x && (x.nodeName == "BR" || x.contentEditable == "false");
      }
    }
    if (Vo && f.focusNode && f.focusNode != c.node && f.focusNode.nodeType == 1) {
      let g = f.focusNode.childNodes[f.focusOffset];
      g && g.contentEditable == "false" && (i = !0);
    }
    if (!(i || h && ii) && sd(a.node, a.offset, f.anchorNode, f.anchorOffset) && sd(c.node, c.offset, f.focusNode, f.focusOffset))
      return;
    let m = !1;
    if ((u.extend || t == n) && !(h && Vo)) {
      u.collapse(a.node, a.offset);
      try {
        t != n && u.extend(c.node, c.offset), m = !0;
      } catch {
      }
    }
    if (!m) {
      if (t > n) {
        let b = a;
        a = c, c = b;
      }
      let g = document.createRange();
      g.setEnd(c.node, c.offset), g.setStart(a.node, a.offset), u.removeAllRanges(), u.addRange(g);
    }
  }
  ignoreMutation(t) {
    return !this.contentDOM && t.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(t, n) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let o = this.children[i], s = r + o.size;
      if (r == s ? t <= s && n >= r : t < s && n > r) {
        let a = r + o.border, c = s - o.border;
        if (t >= a && n <= c) {
          this.dirty = t == r || n == s ? Iu : FL, t == a && n == c && (o.contentLost || o.dom.parentNode != this.contentDOM) ? o.dirty = ea : o.markDirty(t - a, n - a);
          return;
        } else
          o.dirty = o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length ? Iu : ea;
      }
      r = s;
    }
    this.dirty = Iu;
  }
  markParentsDirty() {
    let t = 1;
    for (let n = this.parent; n; n = n.parent, t++) {
      let r = t == 1 ? Iu : FL;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(t) {
    return !1;
  }
}
class JH extends oy {
  constructor(t, n, r, i) {
    let o, s = n.type.toDOM;
    if (typeof s == "function" && (s = s(r, () => {
      if (!o)
        return i;
      if (o.parent)
        return o.parent.posBeforeChild(o);
    })), !n.type.spec.raw) {
      if (s.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(s), s = a;
      }
      s.contentEditable = "false", s.classList.add("ProseMirror-widget");
    }
    super(t, [], s, null), this.widget = n, this.widget = n, o = this;
  }
  matchesWidget(t) {
    return this.dirty == Ho && t.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(t) {
    let n = this.widget.spec.stopEvent;
    return n ? n(t) : !1;
  }
  ignoreMutation(t) {
    return t.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class zRe extends oy {
  constructor(t, n, r, i) {
    super(t, [], n, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(t, n) {
    return t != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(t) {
    return { node: this.textDOM, offset: t };
  }
  ignoreMutation(t) {
    return t.type === "characterData" && t.target.nodeValue == t.oldValue;
  }
}
class ad extends oy {
  constructor(t, n, r, i, o) {
    super(t, [], r, i), this.mark = n, this.spec = o;
  }
  static create(t, n, r, i) {
    let o = i.nodeViews[n.type.name], s = o && o(n, i, r);
    return (!s || !s.dom) && (s = md.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new ad(t, n, s.dom, s.contentDOM || s.dom, s);
  }
  parseRule() {
    return this.dirty & ea || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(t) {
    return this.dirty != ea && this.mark.eq(t);
  }
  markDirty(t, n) {
    if (super.markDirty(t, n), this.dirty != Ho) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Ho;
    }
  }
  slice(t, n, r) {
    let i = ad.create(this.parent, this.mark, !0, r), o = this.children, s = this.size;
    n < s && (o = hT(o, n, s, r)), t > 0 && (o = hT(o, 0, t, r));
    for (let a = 0; a < o.length; a++)
      o[a].parent = i;
    return i.children = o, i;
  }
  ignoreMutation(t) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(t) : super.ignoreMutation(t);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class xc extends oy {
  constructor(t, n, r, i, o, s, a, c, u) {
    super(t, [], o, s), this.node = n, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(t, n, r, i, o, s) {
    let a = o.nodeViews[n.type.name], c, u = a && a(n, o, () => {
      if (!c)
        return s;
      if (c.parent)
        return c.parent.posBeforeChild(c);
    }, r, i), f = u && u.dom, h = u && u.contentDOM;
    if (n.isText) {
      if (!f)
        f = document.createTextNode(n.text);
      else if (f.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else f || ({ dom: f, contentDOM: h } = md.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !h && !n.isText && f.nodeName != "BR" && (f.hasAttribute("contenteditable") || (f.contentEditable = "false"), n.type.spec.draggable && (f.draggable = !0));
    let m = f;
    return f = nW(f, r, n), u ? c = new LRe(t, n, r, i, f, h || null, m, u, o, s + 1) : n.isText ? new Ww(t, n, r, i, f, m, o) : new xc(t, n, r, i, f, h || null, m, o, s + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let t = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (t.preserveWhitespace = "full"), !this.contentDOM)
      t.getContent = () => this.node.content;
    else if (!this.contentLost)
      t.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          t.contentElement = r.dom.parentNode;
          break;
        }
      }
      t.contentElement || (t.getContent = () => $e.empty);
    }
    return t;
  }
  matchesNode(t, n, r) {
    return this.dirty == Ho && t.eq(this.node) && Yb(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(t, n) {
    let r = this.node.inlineContent, i = n, o = t.composing ? this.localCompositionInfo(t, n) : null, s = o && o.pos > -1 ? o : null, a = o && o.pos < 0, c = new $Re(this, s && s.node, t);
    VRe(this.node, this.innerDeco, (u, f, h) => {
      u.spec.marks ? c.syncToMarks(u.spec.marks, r, t, f) : u.type.side >= 0 && !h && c.syncToMarks(f == this.node.childCount ? En.none : this.node.child(f).marks, r, t, f), c.placeWidget(u, t, i);
    }, (u, f, h, m) => {
      c.syncToMarks(u.marks, r, t, m);
      let g;
      c.findNodeMatch(u, f, h, m) || a && t.state.selection.from > i && t.state.selection.to < i + u.nodeSize && (g = c.findIndexWithChild(o.node)) > -1 && c.updateNodeAt(u, f, h, g, t) || c.updateNextNode(u, f, h, t, m, i) || c.addNode(u, f, h, t, i), i += u.nodeSize;
    }), c.syncToMarks([], r, t, 0), this.node.isTextblock && c.addTextblockHacks(), c.destroyRest(), (c.changed || this.dirty == Iu) && (s && this.protectLocalComposition(t, s), eW(this.contentDOM, this.children, t), mh && HRe(this.dom));
  }
  localCompositionInfo(t, n) {
    let { from: r, to: i } = t.state.selection;
    if (!(t.state.selection instanceof kt) || r < n || i > n + this.node.content.size)
      return null;
    let o = t.input.compositionNode;
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let s = o.nodeValue, a = WRe(this.node.content, s, r - n, i - n);
      return a < 0 ? null : { node: o, pos: a, text: s };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(t, { node: n, pos: r, text: i }) {
    if (this.getDesc(n))
      return;
    let o = n;
    for (; o.parentNode != this.contentDOM; o = o.parentNode) {
      for (; o.previousSibling; )
        o.parentNode.removeChild(o.previousSibling);
      for (; o.nextSibling; )
        o.parentNode.removeChild(o.nextSibling);
      o.pmViewDesc && (o.pmViewDesc = void 0);
    }
    let s = new zRe(this, o, n, i);
    t.input.compositionNodes.push(s), this.children = hT(this.children, r, r + i.length, t, s);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(t, n, r, i) {
    return this.dirty == ea || !t.sameMarkup(this.node) ? !1 : (this.updateInner(t, n, r, i), !0);
  }
  updateInner(t, n, r, i) {
    this.updateOuterDeco(n), this.node = t, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Ho;
  }
  updateOuterDeco(t) {
    if (Yb(t, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = tW(this.dom, this.nodeDOM, fT(this.outerDeco, this.node, n), fT(t, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = t;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.nodeDOM.draggable = !0));
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.nodeDOM.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function VL(e, t, n, r, i) {
  nW(r, t, e);
  let o = new xc(void 0, e, t, n, r, r, r, i, 0);
  return o.contentDOM && o.updateChildren(i, 0), o;
}
class Ww extends xc {
  constructor(t, n, r, i, o, s, a) {
    super(t, n, r, i, o, null, s, a, 0);
  }
  parseRule() {
    let t = this.nodeDOM.parentNode;
    for (; t && t != this.dom && !t.pmIsDeco; )
      t = t.parentNode;
    return { skip: t || !0 };
  }
  update(t, n, r, i) {
    return this.dirty == ea || this.dirty != Ho && !this.inParent() || !t.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != Ho || t.text != this.node.text) && t.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = t.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = t, this.dirty = Ho, !0);
  }
  inParent() {
    let t = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == t)
        return !0;
    return !1;
  }
  domFromPos(t) {
    return { node: this.nodeDOM, offset: t };
  }
  localPosFromDOM(t, n, r) {
    return t == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(t, n, r);
  }
  ignoreMutation(t) {
    return t.type != "characterData" && t.type != "selection";
  }
  slice(t, n, r) {
    let i = this.node.cut(t, n), o = document.createTextNode(i.text);
    return new Ww(this.parent, i, this.outerDeco, this.innerDeco, o, o, r);
  }
  markDirty(t, n) {
    super.markDirty(t, n), this.dom != this.nodeDOM && (t == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = ea);
  }
  get domAtom() {
    return !1;
  }
  isText(t) {
    return this.node.text == t;
  }
}
class QH extends oy {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(t) {
    return this.dirty == Ho && this.dom.nodeName == t;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class LRe extends xc {
  constructor(t, n, r, i, o, s, a, c, u, f) {
    super(t, n, r, i, o, s, a, u, f), this.spec = c;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(t, n, r, i) {
    if (this.dirty == ea)
      return !1;
    if (this.spec.update && (this.node.type == t.type || this.spec.multiType)) {
      let o = this.spec.update(t, n, r);
      return o && this.updateInner(t, n, r, i), o;
    } else return !this.contentDOM && !t.isLeaf ? !1 : super.update(t, n, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(t, n, r, i) {
    this.spec.setSelection ? this.spec.setSelection(t, n, r.root) : super.setSelection(t, n, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(t) {
    return this.spec.stopEvent ? this.spec.stopEvent(t) : !1;
  }
  ignoreMutation(t) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(t) : super.ignoreMutation(t);
  }
}
function eW(e, t, n) {
  let r = e.firstChild, i = !1;
  for (let o = 0; o < t.length; o++) {
    let s = t[o], a = s.dom;
    if (a.parentNode == e) {
      for (; a != r; )
        r = HL(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, e.insertBefore(a, r);
    if (s instanceof ad) {
      let c = r ? r.previousSibling : e.lastChild;
      eW(s.contentDOM, s.children, n), r = c ? c.nextSibling : e.firstChild;
    }
  }
  for (; r; )
    r = HL(r), i = !0;
  i && n.trackWrites == e && (n.trackWrites = null);
}
const zm = function(e) {
  e && (this.nodeName = e);
};
zm.prototype = /* @__PURE__ */ Object.create(null);
const zu = [new zm()];
function fT(e, t, n) {
  if (e.length == 0)
    return zu;
  let r = n ? zu[0] : new zm(), i = [r];
  for (let o = 0; o < e.length; o++) {
    let s = e[o].type.attrs;
    if (s) {
      s.nodeName && i.push(r = new zm(s.nodeName));
      for (let a in s) {
        let c = s[a];
        c != null && (n && i.length == 1 && i.push(r = new zm(t.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + c : a == "style" ? r.style = (r.style ? r.style + ";" : "") + c : a != "nodeName" && (r[a] = c));
      }
    }
  }
  return i;
}
function tW(e, t, n, r) {
  if (n == zu && r == zu)
    return t;
  let i = t;
  for (let o = 0; o < r.length; o++) {
    let s = r[o], a = n[o];
    if (o) {
      let c;
      a && a.nodeName == s.nodeName && i != e && (c = i.parentNode) && c.nodeName.toLowerCase() == s.nodeName || (c = document.createElement(s.nodeName), c.pmIsDeco = !0, c.appendChild(i), a = zu[0]), i = c;
    }
    BRe(i, a || zu[0], s);
  }
  return i;
}
function BRe(e, t, n) {
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && e.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != t[r] && e.setAttribute(r, n[r]);
  if (t.class != n.class) {
    let r = t.class ? t.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let o = 0; o < r.length; o++)
      i.indexOf(r[o]) == -1 && e.classList.remove(r[o]);
    for (let o = 0; o < i.length; o++)
      r.indexOf(i[o]) == -1 && e.classList.add(i[o]);
    e.classList.length == 0 && e.removeAttribute("class");
  }
  if (t.style != n.style) {
    if (t.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(t.style); )
        e.style.removeProperty(i[1]);
    }
    n.style && (e.style.cssText += n.style);
  }
}
function nW(e, t, n) {
  return tW(e, e, zu, fT(t, n, e.nodeType != 1));
}
function Yb(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!e[n].type.eq(t[n].type))
      return !1;
  return !0;
}
function HL(e) {
  let t = e.nextSibling;
  return e.parentNode.removeChild(e), t;
}
class $Re {
  constructor(t, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = t, this.preMatch = URe(t.node.content, t);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(t, n) {
    if (t != n) {
      for (let r = t; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(t, n - t), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(t, n, r, i) {
    let o = 0, s = this.stack.length >> 1, a = Math.min(s, t.length);
    for (; o < a && (o == s - 1 ? this.top : this.stack[o + 1 << 1]).matchesMark(t[o]) && t[o].type.spec.spanning !== !1; )
      o++;
    for (; o < s; )
      this.destroyRest(), this.top.dirty = Ho, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < t.length; ) {
      this.stack.push(this.top, this.index + 1);
      let c = -1, u = this.top.children.length;
      i < this.preMatch.index && (u = Math.min(this.index + 3, u));
      for (let f = this.index; f < u; f++) {
        let h = this.top.children[f];
        if (h.matchesMark(t[s]) && !this.isLocked(h.dom)) {
          c = f;
          break;
        }
      }
      if (c > -1)
        c > this.index && (this.changed = !0, this.destroyBetween(this.index, c)), this.top = this.top.children[this.index];
      else {
        let f = ad.create(this.top, t[s], n, r);
        this.top.children.splice(this.index, 0, f), this.top = f, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(t, n, r, i) {
    let o = -1, s;
    if (i >= this.preMatch.index && (s = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && s.matchesNode(t, n, r))
      o = this.top.children.indexOf(s, this.index);
    else
      for (let a = this.index, c = Math.min(this.top.children.length, a + 5); a < c; a++) {
        let u = this.top.children[a];
        if (u.matchesNode(t, n, r) && !this.preMatch.matched.has(u)) {
          o = a;
          break;
        }
      }
    return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
  }
  updateNodeAt(t, n, r, i, o) {
    let s = this.top.children[i];
    return s.dirty == ea && s.dom == s.contentDOM && (s.dirty = Iu), s.update(t, n, r, o) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(t) {
    for (; ; ) {
      let n = t.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = t.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      t = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(t, n, r, i, o, s) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let c = this.top.children[a];
      if (c instanceof xc) {
        let u = this.preMatch.matched.get(c);
        if (u != null && u != o)
          return !1;
        let f = c.dom, h, m = this.isLocked(f) && !(t.isText && c.node && c.node.isText && c.nodeDOM.nodeValue == t.text && c.dirty != ea && Yb(n, c.outerDeco));
        if (!m && c.update(t, n, r, i))
          return this.destroyBetween(this.index, a), c.dom != f && (this.changed = !0), this.index++, !0;
        if (!m && (h = this.recreateWrapper(c, t, n, r, i, s)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = h, h.contentDOM && (h.dirty = Iu, h.updateChildren(i, s + 1), h.dirty = Ho), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(t, n, r, i, o, s) {
    if (t.dirty || n.isAtom || !t.children.length || !t.node.content.eq(n.content) || !Yb(r, t.outerDeco) || !i.eq(t.innerDeco))
      return null;
    let a = xc.create(this.top, n, r, i, o, s);
    if (a.contentDOM) {
      a.children = t.children, t.children = [];
      for (let c of a.children)
        c.parent = a;
    }
    return t.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(t, n, r, i, o) {
    let s = xc.create(this.top, t, n, r, i, o);
    s.contentDOM && s.updateChildren(i, o + 1), this.top.children.splice(this.index++, 0, s), this.changed = !0;
  }
  placeWidget(t, n, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(t) && (t == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let o = new JH(this.top, t, n, r);
      this.top.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let t = this.top.children[this.index - 1], n = this.top;
    for (; t instanceof ad; )
      n = t, t = n.children[n.children.length - 1];
    (!t || // Empty textblock
    !(t instanceof Ww) || /\n$/.test(t.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(t.node.text)) && ((ii || Vr) && t && t.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(t, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(t))
      this.index++;
    else {
      let r = document.createElement(t);
      t == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), t == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new QH(this.top, [], r, null);
      n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(t) {
    return this.lock && (t == this.lock || t.nodeType == 1 && t.contains(this.lock.parentNode));
  }
}
function URe(e, t) {
  let n = t, r = n.children.length, i = e.childCount, o = /* @__PURE__ */ new Map(), s = [];
  e: for (; i > 0; ) {
    let a;
    for (; ; )
      if (r) {
        let u = n.children[r - 1];
        if (u instanceof ad)
          n = u, r = u.children.length;
        else {
          a = u, r--;
          break;
        }
      } else {
        if (n == t)
          break e;
        r = n.parent.children.indexOf(n), n = n.parent;
      }
    let c = a.node;
    if (c) {
      if (c != e.child(i - 1))
        break;
      --i, o.set(a, i), s.push(a);
    }
  }
  return { index: i, matched: o, matches: s.reverse() };
}
function FRe(e, t) {
  return e.type.side - t.type.side;
}
function VRe(e, t, n, r) {
  let i = t.locals(e), o = 0;
  if (i.length == 0) {
    for (let u = 0; u < e.childCount; u++) {
      let f = e.child(u);
      r(f, i, t.forChild(o, f), u), o += f.nodeSize;
    }
    return;
  }
  let s = 0, a = [], c = null;
  for (let u = 0; ; ) {
    let f, h;
    for (; s < i.length && i[s].to == o; ) {
      let w = i[s++];
      w.widget && (f ? (h || (h = [f])).push(w) : f = w);
    }
    if (f)
      if (h) {
        h.sort(FRe);
        for (let w = 0; w < h.length; w++)
          n(h[w], u, !!c);
      } else
        n(f, u, !!c);
    let m, g;
    if (c)
      g = -1, m = c, c = null;
    else if (u < e.childCount)
      g = u, m = e.child(u++);
    else
      break;
    for (let w = 0; w < a.length; w++)
      a[w].to <= o && a.splice(w--, 1);
    for (; s < i.length && i[s].from <= o && i[s].to > o; )
      a.push(i[s++]);
    let b = o + m.nodeSize;
    if (m.isText) {
      let w = b;
      s < i.length && i[s].from < w && (w = i[s].from);
      for (let S = 0; S < a.length; S++)
        a[S].to < w && (w = a[S].to);
      w < b && (c = m.cut(w - o), m = m.cut(0, w - o), b = w, g = -1);
    } else
      for (; s < i.length && i[s].to < b; )
        s++;
    let x = m.isInline && !m.isLeaf ? a.filter((w) => !w.inline) : a.slice();
    r(m, x, t.forChild(o, m), g), o = b;
  }
}
function HRe(e) {
  if (e.nodeName == "UL" || e.nodeName == "OL") {
    let t = e.style.cssText;
    e.style.cssText = t + "; list-style: square !important", window.getComputedStyle(e).listStyle, e.style.cssText = t;
  }
}
function WRe(e, t, n, r) {
  for (let i = 0, o = 0; i < e.childCount && o <= r; ) {
    let s = e.child(i++), a = o;
    if (o += s.nodeSize, !s.isText)
      continue;
    let c = s.text;
    for (; i < e.childCount; ) {
      let u = e.child(i++);
      if (o += u.nodeSize, !u.isText)
        break;
      c += u.text;
    }
    if (o >= n) {
      if (o >= r && c.slice(r - t.length - a, r - a) == t)
        return r - t.length;
      let u = a < r ? c.lastIndexOf(t, r - a - 1) : -1;
      if (u >= 0 && u + t.length + a >= n)
        return a + u;
      if (n == r && c.length >= r + t.length - a && c.slice(r - a, r - a + t.length) == t)
        return r;
    }
  }
  return -1;
}
function hT(e, t, n, r, i) {
  let o = [];
  for (let s = 0, a = 0; s < e.length; s++) {
    let c = e[s], u = a, f = a += c.size;
    u >= n || f <= t ? o.push(c) : (u < t && o.push(c.slice(0, t - u, r)), i && (o.push(i), i = void 0), f > n && o.push(c.slice(n - u, c.size, r)));
  }
  return o;
}
function bN(e, t = null) {
  let n = e.domSelectionRange(), r = e.state.doc;
  if (!n.focusNode)
    return null;
  let i = e.docView.nearestDesc(n.focusNode), o = i && i.size == 0, s = e.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (s < 0)
    return null;
  let a = r.resolve(s), c, u;
  if (Hw(n)) {
    for (c = s; i && !i.node; )
      i = i.parent;
    let h = i.node;
    if (i && h.isAtom && ht.isSelectable(h) && i.parent && !(h.isInline && vRe(n.focusNode, n.focusOffset, i.dom))) {
      let m = i.posBefore;
      u = new ht(s == m ? a : r.resolve(m));
    }
  } else {
    if (n instanceof e.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let h = s, m = s;
      for (let g = 0; g < n.rangeCount; g++) {
        let b = n.getRangeAt(g);
        h = Math.min(h, e.docView.posFromDOM(b.startContainer, b.startOffset, 1)), m = Math.max(m, e.docView.posFromDOM(b.endContainer, b.endOffset, -1));
      }
      if (h < 0)
        return null;
      [c, s] = m == e.state.selection.anchor ? [m, h] : [h, m], a = r.resolve(s);
    } else
      c = e.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (c < 0)
      return null;
  }
  let f = r.resolve(c);
  if (!u) {
    let h = t == "pointer" || e.state.selection.head < a.pos && !o ? 1 : -1;
    u = xN(e, f, a, h);
  }
  return u;
}
function rW(e) {
  return e.editable ? e.hasFocus() : oW(e) && document.activeElement && document.activeElement.contains(e.dom);
}
function Ka(e, t = !1) {
  let n = e.state.selection;
  if (iW(e, n), !!rW(e)) {
    if (!t && e.input.mouseDown && e.input.mouseDown.allowDefault && Vr) {
      let r = e.domSelectionRange(), i = e.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && sd(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        e.input.mouseDown.delayedSelectionSync = !0, e.domObserver.setCurSelection();
        return;
      }
    }
    if (e.domObserver.disconnectSelection(), e.cursorWrapper)
      GRe(e);
    else {
      let { anchor: r, head: i } = n, o, s;
      WL && !(n instanceof kt) && (n.$from.parent.inlineContent || (o = qL(e, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = qL(e, n.to))), e.docView.setSelection(r, i, e, t), WL && (o && GL(o), s && GL(s)), n.visible ? e.dom.classList.remove("ProseMirror-hideselection") : (e.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && qRe(e));
    }
    e.domObserver.setCurSelection(), e.domObserver.connectSelection();
  }
}
const WL = ii || Vr && HH < 63;
function qL(e, t) {
  let { node: n, offset: r } = e.docView.domFromPos(t, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, o = r ? n.childNodes[r - 1] : null;
  if (ii && i && i.contentEditable == "false")
    return WC(i);
  if ((!i || i.contentEditable == "false") && (!o || o.contentEditable == "false")) {
    if (i)
      return WC(i);
    if (o)
      return WC(o);
  }
}
function WC(e) {
  return e.contentEditable = "true", ii && e.draggable && (e.draggable = !1, e.wasDraggable = !0), e;
}
function GL(e) {
  e.contentEditable = "false", e.wasDraggable && (e.draggable = !0, e.wasDraggable = null);
}
function qRe(e) {
  let t = e.dom.ownerDocument;
  t.removeEventListener("selectionchange", e.input.hideSelectionGuard);
  let n = e.domSelectionRange(), r = n.anchorNode, i = n.anchorOffset;
  t.addEventListener("selectionchange", e.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != i) && (t.removeEventListener("selectionchange", e.input.hideSelectionGuard), setTimeout(() => {
      (!rW(e) || e.state.selection.visible) && e.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function GRe(e) {
  let t = e.domSelection();
  if (!t)
    return;
  let n = e.cursorWrapper.dom, r = n.nodeName == "IMG";
  r ? t.collapse(n.parentNode, ti(n) + 1) : t.collapse(n, 0), !r && !e.state.selection.visible && Ki && bc <= 11 && (n.disabled = !0, n.disabled = !1);
}
function iW(e, t) {
  if (t instanceof ht) {
    let n = e.docView.descAt(t.from);
    n != e.lastSelectedViewDesc && (KL(e), n && n.selectNode(), e.lastSelectedViewDesc = n);
  } else
    KL(e);
}
function KL(e) {
  e.lastSelectedViewDesc && (e.lastSelectedViewDesc.parent && e.lastSelectedViewDesc.deselectNode(), e.lastSelectedViewDesc = void 0);
}
function xN(e, t, n, r) {
  return e.someProp("createSelectionBetween", (i) => i(e, t, n)) || kt.between(t, n, r);
}
function ZL(e) {
  return e.editable && !e.hasFocus() ? !1 : oW(e);
}
function oW(e) {
  let t = e.domSelectionRange();
  if (!t.anchorNode)
    return !1;
  try {
    return e.dom.contains(t.anchorNode.nodeType == 3 ? t.anchorNode.parentNode : t.anchorNode) && (e.editable || e.dom.contains(t.focusNode.nodeType == 3 ? t.focusNode.parentNode : t.focusNode));
  } catch {
    return !1;
  }
}
function KRe(e) {
  let t = e.docView.domFromPos(e.state.selection.anchor, 0), n = e.domSelectionRange();
  return sd(t.node, t.offset, n.anchorNode, n.anchorOffset);
}
function pT(e, t) {
  let { $anchor: n, $head: r } = e.selection, i = t > 0 ? n.max(r) : n.min(r), o = i.parent.inlineContent ? i.depth ? e.doc.resolve(t > 0 ? i.after() : i.before()) : null : i;
  return o && zt.findFrom(o, t);
}
function nc(e, t) {
  return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()), !0;
}
function YL(e, t, n) {
  let r = e.state.selection;
  if (r instanceof kt)
    if (n.indexOf("s") > -1) {
      let { $head: i } = r, o = i.textOffset ? null : t < 0 ? i.nodeBefore : i.nodeAfter;
      if (!o || o.isText || !o.isLeaf)
        return !1;
      let s = e.state.doc.resolve(i.pos + o.nodeSize * (t < 0 ? -1 : 1));
      return nc(e, new kt(r.$anchor, s));
    } else if (r.empty) {
      if (e.endOfTextblock(t > 0 ? "forward" : "backward")) {
        let i = pT(e.state, t);
        return i && i instanceof ht ? nc(e, i) : !1;
      } else if (!(jo && n.indexOf("m") > -1)) {
        let i = r.$head, o = i.textOffset ? null : t < 0 ? i.nodeBefore : i.nodeAfter, s;
        if (!o || o.isText)
          return !1;
        let a = t < 0 ? i.pos - o.nodeSize : i.pos;
        return o.isAtom || (s = e.docView.descAt(a)) && !s.contentDOM ? ht.isSelectable(o) ? nc(e, new ht(t < 0 ? e.state.doc.resolve(i.pos - o.nodeSize) : i)) : iy ? nc(e, new kt(e.state.doc.resolve(t < 0 ? a : a + o.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof ht && r.node.isInline)
      return nc(e, new kt(t > 0 ? r.$to : r.$from));
    {
      let i = pT(e.state, t);
      return i ? nc(e, i) : !1;
    }
  }
}
function Xb(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length;
}
function Lm(e, t) {
  let n = e.pmViewDesc;
  return n && n.size == 0 && (t < 0 || e.nextSibling || e.nodeName != "BR");
}
function xf(e, t) {
  return t < 0 ? ZRe(e) : YRe(e);
}
function ZRe(e) {
  let t = e.domSelectionRange(), n = t.focusNode, r = t.focusOffset;
  if (!n)
    return;
  let i, o, s = !1;
  for (Vo && n.nodeType == 1 && r < Xb(n) && Lm(n.childNodes[r], -1) && (s = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[r - 1];
        if (Lm(a, -1))
          i = n, o = --r;
        else if (a.nodeType == 3)
          n = a, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (sW(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && Lm(a, -1); )
          i = n.parentNode, o = ti(a), a = a.previousSibling;
        if (a)
          n = a, r = Xb(n);
        else {
          if (n = n.parentNode, n == e.dom)
            break;
          r = 0;
        }
      }
    }
  s ? mT(e, n, r) : i && mT(e, i, o);
}
function YRe(e) {
  let t = e.domSelectionRange(), n = t.focusNode, r = t.focusOffset;
  if (!n)
    return;
  let i = Xb(n), o, s;
  for (; ; )
    if (r < i) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[r];
      if (Lm(a, 1))
        o = n, s = ++r;
      else
        break;
    } else {
      if (sW(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && Lm(a, 1); )
          o = a.parentNode, s = ti(a) + 1, a = a.nextSibling;
        if (a)
          n = a, r = 0, i = Xb(n);
        else {
          if (n = n.parentNode, n == e.dom)
            break;
          r = i = 0;
        }
      }
    }
  o && mT(e, o, s);
}
function sW(e) {
  let t = e.pmViewDesc;
  return t && t.node && t.node.isBlock;
}
function XRe(e, t) {
  for (; e && t == e.childNodes.length && !ry(e); )
    t = ti(e) + 1, e = e.parentNode;
  for (; e && t < e.childNodes.length; ) {
    let n = e.childNodes[t];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    e = n, t = 0;
  }
}
function JRe(e, t) {
  for (; e && !t && !ry(e); )
    t = ti(e), e = e.parentNode;
  for (; e && t; ) {
    let n = e.childNodes[t - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    e = n, t = e.childNodes.length;
  }
}
function mT(e, t, n) {
  if (t.nodeType != 3) {
    let o, s;
    (s = XRe(t, n)) ? (t = s, n = 0) : (o = JRe(t, n)) && (t = o, n = o.nodeValue.length);
  }
  let r = e.domSelection();
  if (!r)
    return;
  if (Hw(r)) {
    let o = document.createRange();
    o.setEnd(t, n), o.setStart(t, n), r.removeAllRanges(), r.addRange(o);
  } else r.extend && r.extend(t, n);
  e.domObserver.setCurSelection();
  let { state: i } = e;
  setTimeout(() => {
    e.state == i && Ka(e);
  }, 50);
}
function XL(e, t) {
  let n = e.state.doc.resolve(t);
  if (!(Vr || WH) && n.parent.inlineContent) {
    let i = e.coordsAtPos(t);
    if (t > n.start()) {
      let o = e.coordsAtPos(t - 1), s = (o.top + o.bottom) / 2;
      if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left < i.left ? "ltr" : "rtl";
    }
    if (t < n.end()) {
      let o = e.coordsAtPos(t + 1), s = (o.top + o.bottom) / 2;
      if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(e.dom).direction == "rtl" ? "rtl" : "ltr";
}
function JL(e, t, n) {
  let r = e.state.selection;
  if (r instanceof kt && !r.empty || n.indexOf("s") > -1 || jo && n.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: o } = r;
  if (!i.parent.inlineContent || e.endOfTextblock(t < 0 ? "up" : "down")) {
    let s = pT(e.state, t);
    if (s && s instanceof ht)
      return nc(e, s);
  }
  if (!i.parent.inlineContent) {
    let s = t < 0 ? i : o, a = r instanceof mo ? zt.near(s, t) : zt.findFrom(s, t);
    return a ? nc(e, a) : !1;
  }
  return !1;
}
function QL(e, t) {
  if (!(e.state.selection instanceof kt))
    return !0;
  let { $head: n, $anchor: r, empty: i } = e.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (e.endOfTextblock(t > 0 ? "forward" : "backward"))
    return !0;
  let o = !n.textOffset && (t < 0 ? n.nodeBefore : n.nodeAfter);
  if (o && !o.isText) {
    let s = e.state.tr;
    return t < 0 ? s.delete(n.pos - o.nodeSize, n.pos) : s.delete(n.pos, n.pos + o.nodeSize), e.dispatch(s), !0;
  }
  return !1;
}
function e5(e, t, n) {
  e.domObserver.stop(), t.contentEditable = n, e.domObserver.start();
}
function QRe(e) {
  if (!ii || e.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: t, focusOffset: n } = e.domSelectionRange();
  if (t && t.nodeType == 1 && n == 0 && t.firstChild && t.firstChild.contentEditable == "false") {
    let r = t.firstChild;
    e5(e, r, "true"), setTimeout(() => e5(e, r, "false"), 20);
  }
  return !1;
}
function e2e(e) {
  let t = "";
  return e.ctrlKey && (t += "c"), e.metaKey && (t += "m"), e.altKey && (t += "a"), e.shiftKey && (t += "s"), t;
}
function t2e(e, t) {
  let n = t.keyCode, r = e2e(t);
  if (n == 8 || jo && n == 72 && r == "c")
    return QL(e, -1) || xf(e, -1);
  if (n == 46 && !t.shiftKey || jo && n == 68 && r == "c")
    return QL(e, 1) || xf(e, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || jo && n == 66 && r == "c") {
    let i = n == 37 ? XL(e, e.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return YL(e, i, r) || xf(e, i);
  } else if (n == 39 || jo && n == 70 && r == "c") {
    let i = n == 39 ? XL(e, e.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return YL(e, i, r) || xf(e, i);
  } else {
    if (n == 38 || jo && n == 80 && r == "c")
      return JL(e, -1, r) || xf(e, -1);
    if (n == 40 || jo && n == 78 && r == "c")
      return QRe(e) || JL(e, 1, r) || xf(e, 1);
    if (r == (jo ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function wN(e, t) {
  e.someProp("transformCopied", (g) => {
    t = g(t, e);
  });
  let n = [], { content: r, openStart: i, openEnd: o } = t;
  for (; i > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, o--;
    let g = r.firstChild;
    n.push(g.type.name, g.attrs != g.type.defaultAttrs ? g.attrs : null), r = g.content;
  }
  let s = e.someProp("clipboardSerializer") || md.fromSchema(e.state.schema), a = fW(), c = a.createElement("div");
  c.appendChild(s.serializeFragment(r, { document: a }));
  let u = c.firstChild, f, h = 0;
  for (; u && u.nodeType == 1 && (f = dW[u.nodeName.toLowerCase()]); ) {
    for (let g = f.length - 1; g >= 0; g--) {
      let b = a.createElement(f[g]);
      for (; c.firstChild; )
        b.appendChild(c.firstChild);
      c.appendChild(b), h++;
    }
    u = c.firstChild;
  }
  u && u.nodeType == 1 && u.setAttribute("data-pm-slice", `${i} ${o}${h ? ` -${h}` : ""} ${JSON.stringify(n)}`);
  let m = e.someProp("clipboardTextSerializer", (g) => g(t, e)) || t.content.textBetween(0, t.content.size, `

`);
  return { dom: c, text: m, slice: t };
}
function aW(e, t, n, r, i) {
  let o = i.parent.type.spec.code, s, a;
  if (!n && !t)
    return null;
  let c = !!t && (r || o || !n);
  if (c) {
    if (e.someProp("transformPastedText", (m) => {
      t = m(t, o || r, e);
    }), o)
      return a = new Qe($e.from(e.state.schema.text(t.replace(/\r\n?/g, `
`))), 0, 0), e.someProp("transformPasted", (m) => {
        a = m(a, e, !0);
      }), a;
    let h = e.someProp("clipboardTextParser", (m) => m(t, i, r, e));
    if (h)
      a = h;
    else {
      let m = i.marks(), { schema: g } = e.state, b = md.fromSchema(g);
      s = document.createElement("div"), t.split(/(?:\r\n?|\n)+/).forEach((x) => {
        let w = s.appendChild(document.createElement("p"));
        x && w.appendChild(b.serializeNode(g.text(x, m)));
      });
    }
  } else
    e.someProp("transformPastedHTML", (h) => {
      n = h(n, e);
    }), s = o2e(n), iy && s2e(s);
  let u = s && s.querySelector("[data-pm-slice]"), f = u && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(u.getAttribute("data-pm-slice") || "");
  if (f && f[3])
    for (let h = +f[3]; h > 0; h--) {
      let m = s.firstChild;
      for (; m && m.nodeType != 1; )
        m = m.nextSibling;
      if (!m)
        break;
      s = m;
    }
  if (a || (a = (e.someProp("clipboardParser") || e.someProp("domParser") || vc.fromSchema(e.state.schema)).parseSlice(s, {
    preserveWhitespace: !!(c || f),
    context: i,
    ruleFromNode(m) {
      return m.nodeName == "BR" && !m.nextSibling && m.parentNode && !n2e.test(m.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), f)
    a = a2e(t5(a, +f[1], +f[2]), f[4]);
  else if (a = Qe.maxOpen(r2e(a.content, i), !0), a.openStart || a.openEnd) {
    let h = 0, m = 0;
    for (let g = a.content.firstChild; h < a.openStart && !g.type.spec.isolating; h++, g = g.firstChild)
      ;
    for (let g = a.content.lastChild; m < a.openEnd && !g.type.spec.isolating; m++, g = g.lastChild)
      ;
    a = t5(a, h, m);
  }
  return e.someProp("transformPasted", (h) => {
    a = h(a, e, c);
  }), a;
}
const n2e = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function r2e(e, t) {
  if (e.childCount < 2)
    return e;
  for (let n = t.depth; n >= 0; n--) {
    let i = t.node(n).contentMatchAt(t.index(n)), o, s = [];
    if (e.forEach((a) => {
      if (!s)
        return;
      let c = i.findWrapping(a.type), u;
      if (!c)
        return s = null;
      if (u = s.length && o.length && cW(c, o, a, s[s.length - 1], 0))
        s[s.length - 1] = u;
      else {
        s.length && (s[s.length - 1] = uW(s[s.length - 1], o.length));
        let f = lW(a, c);
        s.push(f), i = i.matchType(f.type), o = c;
      }
    }), s)
      return $e.from(s);
  }
  return e;
}
function lW(e, t, n = 0) {
  for (let r = t.length - 1; r >= n; r--)
    e = t[r].create(null, $e.from(e));
  return e;
}
function cW(e, t, n, r, i) {
  if (i < e.length && i < t.length && e[i] == t[i]) {
    let o = cW(e, t, n, r.lastChild, i + 1);
    if (o)
      return r.copy(r.content.replaceChild(r.childCount - 1, o));
    if (r.contentMatchAt(r.childCount).matchType(i == e.length - 1 ? n.type : e[i + 1]))
      return r.copy(r.content.append($e.from(lW(n, e, i + 1))));
  }
}
function uW(e, t) {
  if (t == 0)
    return e;
  let n = e.content.replaceChild(e.childCount - 1, uW(e.lastChild, t - 1)), r = e.contentMatchAt(e.childCount).fillBefore($e.empty, !0);
  return e.copy(n.append(r));
}
function gT(e, t, n, r, i, o) {
  let s = t < 0 ? e.firstChild : e.lastChild, a = s.content;
  return e.childCount > 1 && (o = 0), i < r - 1 && (a = gT(a, t, n, r, i + 1, o)), i >= n && (a = t < 0 ? s.contentMatchAt(0).fillBefore(a, o <= i).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore($e.empty, !0))), e.replaceChild(t < 0 ? 0 : e.childCount - 1, s.copy(a));
}
function t5(e, t, n) {
  return t < e.openStart && (e = new Qe(gT(e.content, -1, t, e.openStart, 0, e.openEnd), t, e.openEnd)), n < e.openEnd && (e = new Qe(gT(e.content, 1, n, e.openEnd, 0, 0), e.openStart, n)), e;
}
const dW = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let n5 = null;
function fW() {
  return n5 || (n5 = document.implementation.createHTMLDocument("title"));
}
let qC = null;
function i2e(e) {
  let t = window.trustedTypes;
  return t ? (qC || (qC = t.defaultPolicy || t.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), qC.createHTML(e)) : e;
}
function o2e(e) {
  let t = /^(\s*<meta [^>]*>)*/.exec(e);
  t && (e = e.slice(t[0].length));
  let n = fW().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(e), i;
  if ((i = r && dW[r[1].toLowerCase()]) && (e = i.map((o) => "<" + o + ">").join("") + e + i.map((o) => "</" + o + ">").reverse().join("")), n.innerHTML = i2e(e), i)
    for (let o = 0; o < i.length; o++)
      n = n.querySelector(i[o]) || n;
  return n;
}
function s2e(e) {
  let t = e.querySelectorAll(Vr ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < t.length; n++) {
    let r = t[n];
    r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "), r);
  }
}
function a2e(e, t) {
  if (!e.size)
    return e;
  let n = e.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(t);
  } catch {
    return e;
  }
  let { content: i, openStart: o, openEnd: s } = e;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let c = n.nodes[r[a]];
    if (!c || c.hasRequiredAttrs())
      break;
    i = $e.from(c.create(r[a + 1], i)), o++, s++;
  }
  return new Qe(i, o, s);
}
const Ri = {}, Oi = {}, l2e = { touchstart: !0, touchmove: !0 };
class c2e {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.badSafariComposition = !1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function u2e(e) {
  for (let t in Ri) {
    let n = Ri[t];
    e.dom.addEventListener(t, e.input.eventHandlers[t] = (r) => {
      f2e(e, r) && !SN(e, r) && (e.editable || !(r.type in Oi)) && n(e, r);
    }, l2e[t] ? { passive: !0 } : void 0);
  }
  ii && e.dom.addEventListener("input", () => null), yT(e);
}
function hc(e, t) {
  e.input.lastSelectionOrigin = t, e.input.lastSelectionTime = Date.now();
}
function d2e(e) {
  e.domObserver.stop();
  for (let t in e.input.eventHandlers)
    e.dom.removeEventListener(t, e.input.eventHandlers[t]);
  clearTimeout(e.input.composingTimeout), clearTimeout(e.input.lastIOSEnterFallbackTimeout);
}
function yT(e) {
  e.someProp("handleDOMEvents", (t) => {
    for (let n in t)
      e.input.eventHandlers[n] || e.dom.addEventListener(n, e.input.eventHandlers[n] = (r) => SN(e, r));
  });
}
function SN(e, t) {
  return e.someProp("handleDOMEvents", (n) => {
    let r = n[t.type];
    return r ? r(e, t) || t.defaultPrevented : !1;
  });
}
function f2e(e, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let n = t.target; n != e.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(t))
      return !1;
  return !0;
}
function h2e(e, t) {
  !SN(e, t) && Ri[t.type] && (e.editable || !(t.type in Oi)) && Ri[t.type](e, t);
}
Oi.keydown = (e, t) => {
  let n = t;
  if (e.input.shiftKey = n.keyCode == 16 || n.shiftKey, !pW(e, n) && (e.input.lastKeyCode = n.keyCode, e.input.lastKeyCodeTime = Date.now(), !(Ha && Vr && n.keyCode == 13)))
    if (n.keyCode != 229 && e.domObserver.forceFlush(), mh && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      e.input.lastIOSEnter = r, e.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        e.input.lastIOSEnter == r && (e.someProp("handleKeyDown", (i) => i(e, Ru(13, "Enter"))), e.input.lastIOSEnter = 0);
      }, 200);
    } else e.someProp("handleKeyDown", (r) => r(e, n)) || t2e(e, n) ? n.preventDefault() : hc(e, "key");
};
Oi.keyup = (e, t) => {
  t.keyCode == 16 && (e.input.shiftKey = !1);
};
Oi.keypress = (e, t) => {
  let n = t;
  if (pW(e, n) || !n.charCode || n.ctrlKey && !n.altKey || jo && n.metaKey)
    return;
  if (e.someProp("handleKeyPress", (i) => i(e, n))) {
    n.preventDefault();
    return;
  }
  let r = e.state.selection;
  if (!(r instanceof kt) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(n.charCode), o = () => e.state.tr.insertText(i).scrollIntoView();
    !/[\r\n]/.test(i) && !e.someProp("handleTextInput", (s) => s(e, r.$from.pos, r.$to.pos, i, o)) && e.dispatch(o()), n.preventDefault();
  }
};
function qw(e) {
  return { left: e.clientX, top: e.clientY };
}
function p2e(e, t) {
  let n = t.x - e.clientX, r = t.y - e.clientY;
  return n * n + r * r < 100;
}
function kN(e, t, n, r, i) {
  if (r == -1)
    return !1;
  let o = e.state.doc.resolve(r);
  for (let s = o.depth + 1; s > 0; s--)
    if (e.someProp(t, (a) => s > o.depth ? a(e, n, o.nodeAfter, o.before(s), i, !0) : a(e, n, o.node(s), o.before(s), i, !1)))
      return !0;
  return !1;
}
function Qf(e, t, n) {
  if (e.focused || e.focus(), e.state.selection.eq(t))
    return;
  let r = e.state.tr.setSelection(t);
  r.setMeta("pointer", !0), e.dispatch(r);
}
function m2e(e, t) {
  if (t == -1)
    return !1;
  let n = e.state.doc.resolve(t), r = n.nodeAfter;
  return r && r.isAtom && ht.isSelectable(r) ? (Qf(e, new ht(n)), !0) : !1;
}
function g2e(e, t) {
  if (t == -1)
    return !1;
  let n = e.state.selection, r, i;
  n instanceof ht && (r = n.node);
  let o = e.state.doc.resolve(t);
  for (let s = o.depth + 1; s > 0; s--) {
    let a = s > o.depth ? o.nodeAfter : o.node(s);
    if (ht.isSelectable(a)) {
      r && n.$from.depth > 0 && s >= n.$from.depth && o.before(n.$from.depth + 1) == n.$from.pos ? i = o.before(n.$from.depth) : i = o.before(s);
      break;
    }
  }
  return i != null ? (Qf(e, ht.create(e.state.doc, i)), !0) : !1;
}
function y2e(e, t, n, r, i) {
  return kN(e, "handleClickOn", t, n, r) || e.someProp("handleClick", (o) => o(e, t, r)) || (i ? g2e(e, n) : m2e(e, n));
}
function v2e(e, t, n, r) {
  return kN(e, "handleDoubleClickOn", t, n, r) || e.someProp("handleDoubleClick", (i) => i(e, t, r));
}
function b2e(e, t, n, r) {
  return kN(e, "handleTripleClickOn", t, n, r) || e.someProp("handleTripleClick", (i) => i(e, t, r)) || x2e(e, n, r);
}
function x2e(e, t, n) {
  if (n.button != 0)
    return !1;
  let r = e.state.doc;
  if (t == -1)
    return r.inlineContent ? (Qf(e, kt.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(t);
  for (let o = i.depth + 1; o > 0; o--) {
    let s = o > i.depth ? i.nodeAfter : i.node(o), a = i.before(o);
    if (s.inlineContent)
      Qf(e, kt.create(r, a + 1, a + 1 + s.content.size));
    else if (ht.isSelectable(s))
      Qf(e, ht.create(r, a));
    else
      continue;
    return !0;
  }
}
function CN(e) {
  return Jb(e);
}
const hW = jo ? "metaKey" : "ctrlKey";
Ri.mousedown = (e, t) => {
  let n = t;
  e.input.shiftKey = n.shiftKey;
  let r = CN(e), i = Date.now(), o = "singleClick";
  i - e.input.lastClick.time < 500 && p2e(n, e.input.lastClick) && !n[hW] && e.input.lastClick.button == n.button && (e.input.lastClick.type == "singleClick" ? o = "doubleClick" : e.input.lastClick.type == "doubleClick" && (o = "tripleClick")), e.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: o, button: n.button };
  let s = e.posAtCoords(qw(n));
  s && (o == "singleClick" ? (e.input.mouseDown && e.input.mouseDown.done(), e.input.mouseDown = new w2e(e, s, n, !!r)) : (o == "doubleClick" ? v2e : b2e)(e, s.pos, s.inside, n) ? n.preventDefault() : hc(e, "pointer"));
};
class w2e {
  constructor(t, n, r, i) {
    this.view = t, this.pos = n, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = t.state.doc, this.selectNode = !!r[hW], this.allowDefault = r.shiftKey;
    let o, s;
    if (n.inside > -1)
      o = t.state.doc.nodeAt(n.inside), s = n.inside;
    else {
      let f = t.state.doc.resolve(n.pos);
      o = f.parent, s = f.depth ? f.before() : 0;
    }
    const a = i ? null : r.target, c = a ? t.docView.nearestDesc(a, !0) : null;
    this.target = c && c.nodeDOM.nodeType == 1 ? c.nodeDOM : null;
    let { selection: u } = t.state;
    (r.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1 || u instanceof ht && u.from <= s && u.to > s) && (this.mightDrag = {
      node: o,
      pos: s,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Vo && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), t.root.addEventListener("mouseup", this.up = this.up.bind(this)), t.root.addEventListener("mousemove", this.move = this.move.bind(this)), hc(t, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Ka(this.view)), this.view.input.mouseDown = null;
  }
  up(t) {
    if (this.done(), !this.view.dom.contains(t.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(qw(t))), this.updateAllowDefault(t), this.allowDefault || !n ? hc(this.view, "pointer") : y2e(this.view, n.pos, n.inside, t, this.selectNode) ? t.preventDefault() : t.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    ii && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Vr && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Qf(this.view, zt.near(this.view.state.doc.resolve(n.pos))), t.preventDefault()) : hc(this.view, "pointer");
  }
  move(t) {
    this.updateAllowDefault(t), hc(this.view, "pointer"), t.buttons == 0 && this.done();
  }
  updateAllowDefault(t) {
    !this.allowDefault && (Math.abs(this.event.x - t.clientX) > 4 || Math.abs(this.event.y - t.clientY) > 4) && (this.allowDefault = !0);
  }
}
Ri.touchstart = (e) => {
  e.input.lastTouch = Date.now(), CN(e), hc(e, "pointer");
};
Ri.touchmove = (e) => {
  e.input.lastTouch = Date.now(), hc(e, "pointer");
};
Ri.contextmenu = (e) => CN(e);
function pW(e, t) {
  return e.composing ? !0 : ii && Math.abs(t.timeStamp - e.input.compositionEndedAt) < 500 ? (e.input.compositionEndedAt = -2e8, !0) : !1;
}
const S2e = Ha ? 5e3 : -1;
Oi.compositionstart = Oi.compositionupdate = (e) => {
  if (!e.composing) {
    e.domObserver.flush();
    let { state: t } = e, n = t.selection.$to;
    if (t.selection instanceof kt && (t.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1) || Vr && WH && k2e(e)))
      e.markCursor = e.state.storedMarks || n.marks(), Jb(e, !0), e.markCursor = null;
    else if (Jb(e, !t.selection.empty), Vo && t.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = e.domSelectionRange();
      for (let i = r.focusNode, o = r.focusOffset; i && i.nodeType == 1 && o != 0; ) {
        let s = o < 0 ? i.lastChild : i.childNodes[o - 1];
        if (!s)
          break;
        if (s.nodeType == 3) {
          let a = e.domSelection();
          a && a.collapse(s, s.nodeValue.length);
          break;
        } else
          i = s, o = -1;
      }
    }
    e.input.composing = !0;
  }
  mW(e, S2e);
};
function k2e(e) {
  let { focusNode: t, focusOffset: n } = e.domSelectionRange();
  if (!t || t.nodeType != 1 || n >= t.childNodes.length)
    return !1;
  let r = t.childNodes[n];
  return r.nodeType == 1 && r.contentEditable == "false";
}
Oi.compositionend = (e, t) => {
  e.composing && (e.input.composing = !1, e.input.compositionEndedAt = t.timeStamp, e.input.compositionPendingChanges = e.domObserver.pendingRecords().length ? e.input.compositionID : 0, e.input.compositionNode = null, e.input.badSafariComposition ? e.domObserver.forceFlush() : e.input.compositionPendingChanges && Promise.resolve().then(() => e.domObserver.flush()), e.input.compositionID++, mW(e, 20));
};
function mW(e, t) {
  clearTimeout(e.input.composingTimeout), t > -1 && (e.input.composingTimeout = setTimeout(() => Jb(e), t));
}
function gW(e) {
  for (e.composing && (e.input.composing = !1, e.input.compositionEndedAt = E2e()); e.input.compositionNodes.length > 0; )
    e.input.compositionNodes.pop().markParentsDirty();
}
function C2e(e) {
  let t = e.domSelectionRange();
  if (!t.focusNode)
    return null;
  let n = gRe(t.focusNode, t.focusOffset), r = yRe(t.focusNode, t.focusOffset);
  if (n && r && n != r) {
    let i = r.pmViewDesc, o = e.domObserver.lastChangedTextNode;
    if (n == o || r == o)
      return o;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (e.input.compositionNode == r) {
      let s = n.pmViewDesc;
      if (!(!s || !s.isText(n.nodeValue)))
        return r;
    }
  }
  return n || r;
}
function E2e() {
  let e = document.createEvent("Event");
  return e.initEvent("event", !0, !0), e.timeStamp;
}
function Jb(e, t = !1) {
  if (!(Ha && e.domObserver.flushingSoon >= 0)) {
    if (e.domObserver.forceFlush(), gW(e), t || e.docView && e.docView.dirty) {
      let n = bN(e), r = e.state.selection;
      return n && !n.eq(r) ? e.dispatch(e.state.tr.setSelection(n)) : (e.markCursor || t) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? e.dispatch(e.state.tr.deleteSelection()) : e.updateState(e.state), !0;
    }
    return !1;
  }
}
function _2e(e, t) {
  if (!e.dom.parentNode)
    return;
  let n = e.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(t), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(t), e.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), e.focus();
  }, 50);
}
const bg = Ki && bc < 15 || mh && wRe < 604;
Ri.copy = Oi.cut = (e, t) => {
  let n = t, r = e.state.selection, i = n.type == "cut";
  if (r.empty)
    return;
  let o = bg ? null : n.clipboardData, s = r.content(), { dom: a, text: c } = wN(e, s);
  o ? (n.preventDefault(), o.clearData(), o.setData("text/html", a.innerHTML), o.setData("text/plain", c)) : _2e(e, a), i && e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function T2e(e) {
  return e.openStart == 0 && e.openEnd == 0 && e.content.childCount == 1 ? e.content.firstChild : null;
}
function A2e(e, t) {
  if (!e.dom.parentNode)
    return;
  let n = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code, r = e.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = e.input.shiftKey && e.input.lastKeyCode != 45;
  setTimeout(() => {
    e.focus(), r.parentNode && r.parentNode.removeChild(r), n ? xg(e, r.value, null, i, t) : xg(e, r.textContent, r.innerHTML, i, t);
  }, 50);
}
function xg(e, t, n, r, i) {
  let o = aW(e, t, n, r, e.state.selection.$from);
  if (e.someProp("handlePaste", (c) => c(e, i, o || Qe.empty)))
    return !0;
  if (!o)
    return !1;
  let s = T2e(o), a = s ? e.state.tr.replaceSelectionWith(s, r) : e.state.tr.replaceSelection(o);
  return e.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function yW(e) {
  let t = e.getData("text/plain") || e.getData("Text");
  if (t)
    return t;
  let n = e.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
Oi.paste = (e, t) => {
  let n = t;
  if (e.composing && !Ha)
    return;
  let r = bg ? null : n.clipboardData, i = e.input.shiftKey && e.input.lastKeyCode != 45;
  r && xg(e, yW(r), r.getData("text/html"), i, n) ? n.preventDefault() : A2e(e, n);
};
class vW {
  constructor(t, n, r) {
    this.slice = t, this.move = n, this.node = r;
  }
}
const M2e = jo ? "altKey" : "ctrlKey";
function bW(e, t) {
  let n = e.someProp("dragCopies", (r) => !r(t));
  return n ?? !t[M2e];
}
Ri.dragstart = (e, t) => {
  let n = t, r = e.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let i = e.state.selection, o = i.empty ? null : e.posAtCoords(qw(n)), s;
  if (!(o && o.pos >= i.from && o.pos <= (i instanceof ht ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      s = ht.create(e.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let h = e.docView.nearestDesc(n.target, !0);
      h && h.node.type.spec.draggable && h != e.docView && (s = ht.create(e.state.doc, h.posBefore));
    }
  }
  let a = (s || e.state.selection).content(), { dom: c, text: u, slice: f } = wN(e, a);
  (!n.dataTransfer.files.length || !Vr || HH > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(bg ? "Text" : "text/html", c.innerHTML), n.dataTransfer.effectAllowed = "copyMove", bg || n.dataTransfer.setData("text/plain", u), e.dragging = new vW(f, bW(e, n), s);
};
Ri.dragend = (e) => {
  let t = e.dragging;
  window.setTimeout(() => {
    e.dragging == t && (e.dragging = null);
  }, 50);
};
Oi.dragover = Oi.dragenter = (e, t) => t.preventDefault();
Oi.drop = (e, t) => {
  try {
    N2e(e, t, e.dragging);
  } finally {
    e.dragging = null;
  }
};
function N2e(e, t, n) {
  if (!t.dataTransfer)
    return;
  let r = e.posAtCoords(qw(t));
  if (!r)
    return;
  let i = e.state.doc.resolve(r.pos), o = n && n.slice;
  o ? e.someProp("transformPasted", (g) => {
    o = g(o, e, !1);
  }) : o = aW(e, yW(t.dataTransfer), bg ? null : t.dataTransfer.getData("text/html"), !1, i);
  let s = !!(n && bW(e, t));
  if (e.someProp("handleDrop", (g) => g(e, t, o || Qe.empty, s))) {
    t.preventDefault();
    return;
  }
  if (!o)
    return;
  t.preventDefault();
  let a = o ? kH(e.state.doc, i.pos, o) : i.pos;
  a == null && (a = i.pos);
  let c = e.state.tr;
  if (s) {
    let { node: g } = n;
    g ? g.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(a), f = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, h = c.doc;
  if (f ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(h))
    return;
  let m = c.doc.resolve(u);
  if (f && ht.isSelectable(o.content.firstChild) && m.nodeAfter && m.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new ht(m));
  else {
    let g = c.mapping.map(a);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((b, x, w, S) => g = S), c.setSelection(xN(e, m, c.doc.resolve(g)));
  }
  e.focus(), e.dispatch(c.setMeta("uiEvent", "drop"));
}
Ri.focus = (e) => {
  e.input.lastFocus = Date.now(), e.focused || (e.domObserver.stop(), e.dom.classList.add("ProseMirror-focused"), e.domObserver.start(), e.focused = !0, setTimeout(() => {
    e.docView && e.hasFocus() && !e.domObserver.currentSelection.eq(e.domSelectionRange()) && Ka(e);
  }, 20));
};
Ri.blur = (e, t) => {
  let n = t;
  e.focused && (e.domObserver.stop(), e.dom.classList.remove("ProseMirror-focused"), e.domObserver.start(), n.relatedTarget && e.dom.contains(n.relatedTarget) && e.domObserver.currentSelection.clear(), e.focused = !1);
};
Ri.beforeinput = (e, t) => {
  if (Vr && Ha && t.inputType == "deleteContentBackward") {
    e.domObserver.flushSoon();
    let { domChangeCount: r } = e.input;
    setTimeout(() => {
      if (e.input.domChangeCount != r || (e.dom.blur(), e.focus(), e.someProp("handleKeyDown", (o) => o(e, Ru(8, "Backspace")))))
        return;
      let { $cursor: i } = e.state.selection;
      i && i.pos > 0 && e.dispatch(e.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let e in Oi)
  Ri[e] = Oi[e];
function wg(e, t) {
  if (e == t)
    return !0;
  for (let n in e)
    if (e[n] !== t[n])
      return !1;
  for (let n in t)
    if (!(n in e))
      return !1;
  return !0;
}
class Qb {
  constructor(t, n) {
    this.toDOM = t, this.spec = n || Wu, this.side = this.spec.side || 0;
  }
  map(t, n, r, i) {
    let { pos: o, deleted: s } = t.mapResult(n.from + i, this.side < 0 ? -1 : 1);
    return s ? null : new gi(o - r, o - r, this);
  }
  valid() {
    return !0;
  }
  eq(t) {
    return this == t || t instanceof Qb && (this.spec.key && this.spec.key == t.spec.key || this.toDOM == t.toDOM && wg(this.spec, t.spec));
  }
  destroy(t) {
    this.spec.destroy && this.spec.destroy(t);
  }
}
class wc {
  constructor(t, n) {
    this.attrs = t, this.spec = n || Wu;
  }
  map(t, n, r, i) {
    let o = t.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r, s = t.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return o >= s ? null : new gi(o, s, this);
  }
  valid(t, n) {
    return n.from < n.to;
  }
  eq(t) {
    return this == t || t instanceof wc && wg(this.attrs, t.attrs) && wg(this.spec, t.spec);
  }
  static is(t) {
    return t.type instanceof wc;
  }
  destroy() {
  }
}
class EN {
  constructor(t, n) {
    this.attrs = t, this.spec = n || Wu;
  }
  map(t, n, r, i) {
    let o = t.mapResult(n.from + i, 1);
    if (o.deleted)
      return null;
    let s = t.mapResult(n.to + i, -1);
    return s.deleted || s.pos <= o.pos ? null : new gi(o.pos - r, s.pos - r, this);
  }
  valid(t, n) {
    let { index: r, offset: i } = t.content.findIndex(n.from), o;
    return i == n.from && !(o = t.child(r)).isText && i + o.nodeSize == n.to;
  }
  eq(t) {
    return this == t || t instanceof EN && wg(this.attrs, t.attrs) && wg(this.spec, t.spec);
  }
  destroy() {
  }
}
class gi {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.from = t, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(t, n) {
    return new gi(t, n, this.type);
  }
  /**
  @internal
  */
  eq(t, n = 0) {
    return this.type.eq(t.type) && this.from + n == t.from && this.to + n == t.to;
  }
  /**
  @internal
  */
  map(t, n, r) {
    return this.type.map(t, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(t, n, r) {
    return new gi(t, t, new Qb(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(t, n, r, i) {
    return new gi(t, n, new wc(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(t, n, r, i) {
    return new gi(t, n, new EN(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof wc;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Qb;
  }
}
const Mf = [], Wu = {};
class qn {
  /**
  @internal
  */
  constructor(t, n) {
    this.local = t.length ? t : Mf, this.children = n.length ? n : Mf;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(t, n) {
    return n.length ? ex(n, t, 0, Wu) : fi;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(t, n, r) {
    let i = [];
    return this.findInner(t ?? 0, n ?? 1e9, i, 0, r), i;
  }
  findInner(t, n, r, i, o) {
    for (let s = 0; s < this.local.length; s++) {
      let a = this.local[s];
      a.from <= n && a.to >= t && (!o || o(a.spec)) && r.push(a.copy(a.from + i, a.to + i));
    }
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] < n && this.children[s + 1] > t) {
        let a = this.children[s] + 1;
        this.children[s + 2].findInner(t - a, n - a, r, i + a, o);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(t, n, r) {
    return this == fi || t.maps.length == 0 ? this : this.mapInner(t, n, 0, 0, r || Wu);
  }
  /**
  @internal
  */
  mapInner(t, n, r, i, o) {
    let s;
    for (let a = 0; a < this.local.length; a++) {
      let c = this.local[a].map(t, r, i);
      c && c.type.valid(n, c) ? (s || (s = [])).push(c) : o.onRemove && o.onRemove(this.local[a].spec);
    }
    return this.children.length ? R2e(this.children, s || [], t, n, r, i, o) : s ? new qn(s.sort(qu), Mf) : fi;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(t, n) {
    return n.length ? this == fi ? qn.create(t, n) : this.addInner(t, n, 0) : this;
  }
  addInner(t, n, r) {
    let i, o = 0;
    t.forEach((a, c) => {
      let u = c + r, f;
      if (f = wW(n, a, u)) {
        for (i || (i = this.children.slice()); o < i.length && i[o] < c; )
          o += 3;
        i[o] == c ? i[o + 2] = i[o + 2].addInner(a, f, u + 1) : i.splice(o, 0, c, c + a.nodeSize, ex(f, a, u + 1, Wu)), o += 3;
      }
    });
    let s = xW(o ? SW(n) : n, -r);
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(t, s[a]) || s.splice(a--, 1);
    return new qn(s.length ? this.local.concat(s).sort(qu) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(t) {
    return t.length == 0 || this == fi ? this : this.removeInner(t, 0);
  }
  removeInner(t, n) {
    let r = this.children, i = this.local;
    for (let o = 0; o < r.length; o += 3) {
      let s, a = r[o] + n, c = r[o + 1] + n;
      for (let f = 0, h; f < t.length; f++)
        (h = t[f]) && h.from > a && h.to < c && (t[f] = null, (s || (s = [])).push(h));
      if (!s)
        continue;
      r == this.children && (r = this.children.slice());
      let u = r[o + 2].removeInner(s, a + 1);
      u != fi ? r[o + 2] = u : (r.splice(o, 3), o -= 3);
    }
    if (i.length) {
      for (let o = 0, s; o < t.length; o++)
        if (s = t[o])
          for (let a = 0; a < i.length; a++)
            i[a].eq(s, n) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new qn(i, r) : fi;
  }
  forChild(t, n) {
    if (this == fi)
      return this;
    if (n.isLeaf)
      return qn.empty;
    let r, i;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= t) {
        this.children[a] == t && (r = this.children[a + 2]);
        break;
      }
    let o = t + 1, s = o + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let c = this.local[a];
      if (c.from < s && c.to > o && c.type instanceof wc) {
        let u = Math.max(o, c.from) - o, f = Math.min(s, c.to) - o;
        u < f && (i || (i = [])).push(c.copy(u, f));
      }
    }
    if (i) {
      let a = new qn(i.sort(qu), Mf);
      return r ? new oc([a, r]) : a;
    }
    return r || fi;
  }
  /**
  @internal
  */
  eq(t) {
    if (this == t)
      return !0;
    if (!(t instanceof qn) || this.local.length != t.local.length || this.children.length != t.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(t.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != t.children[n] || this.children[n + 1] != t.children[n + 1] || !this.children[n + 2].eq(t.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(t) {
    return _N(this.localsInner(t));
  }
  /**
  @internal
  */
  localsInner(t) {
    if (this == fi)
      return Mf;
    if (t.inlineContent || !this.local.some(wc.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof wc || n.push(this.local[r]);
    return n;
  }
  forEachSet(t) {
    t(this);
  }
}
qn.empty = new qn([], []);
qn.removeOverlap = _N;
const fi = qn.empty;
class oc {
  constructor(t) {
    this.members = t;
  }
  map(t, n) {
    const r = this.members.map((i) => i.map(t, n, Wu));
    return oc.from(r);
  }
  forChild(t, n) {
    if (n.isLeaf)
      return qn.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].forChild(t, n);
      o != fi && (o instanceof oc ? r = r.concat(o.members) : r.push(o));
    }
    return oc.from(r);
  }
  eq(t) {
    if (!(t instanceof oc) || t.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(t.members[n]))
        return !1;
    return !0;
  }
  locals(t) {
    let n, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].localsInner(t);
      if (o.length)
        if (!n)
          n = o;
        else {
          r && (n = n.slice(), r = !1);
          for (let s = 0; s < o.length; s++)
            n.push(o[s]);
        }
    }
    return n ? _N(r ? n : n.sort(qu)) : Mf;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(t) {
    switch (t.length) {
      case 0:
        return fi;
      case 1:
        return t[0];
      default:
        return new oc(t.every((n) => n instanceof qn) ? t : t.reduce((n, r) => n.concat(r instanceof qn ? r : r.members), []));
    }
  }
  forEachSet(t) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(t);
  }
}
function R2e(e, t, n, r, i, o, s) {
  let a = e.slice();
  for (let u = 0, f = o; u < n.maps.length; u++) {
    let h = 0;
    n.maps[u].forEach((m, g, b, x) => {
      let w = x - b - (g - m);
      for (let S = 0; S < a.length; S += 3) {
        let _ = a[S + 1];
        if (_ < 0 || m > _ + f - h)
          continue;
        let M = a[S] + f - h;
        g >= M ? a[S + 1] = m <= M ? -2 : -1 : m >= f && w && (a[S] += w, a[S + 1] += w);
      }
      h += w;
    }), f = n.maps[u].map(f, -1);
  }
  let c = !1;
  for (let u = 0; u < a.length; u += 3)
    if (a[u + 1] < 0) {
      if (a[u + 1] == -2) {
        c = !0, a[u + 1] = -1;
        continue;
      }
      let f = n.map(e[u] + o), h = f - i;
      if (h < 0 || h >= r.content.size) {
        c = !0;
        continue;
      }
      let m = n.map(e[u + 1] + o, -1), g = m - i, { index: b, offset: x } = r.content.findIndex(h), w = r.maybeChild(b);
      if (w && x == h && x + w.nodeSize == g) {
        let S = a[u + 2].mapInner(n, w, f + 1, e[u] + o + 1, s);
        S != fi ? (a[u] = h, a[u + 1] = g, a[u + 2] = S) : (a[u + 1] = -2, c = !0);
      } else
        c = !0;
    }
  if (c) {
    let u = O2e(a, e, t, n, i, o, s), f = ex(u, r, 0, s);
    t = f.local;
    for (let h = 0; h < a.length; h += 3)
      a[h + 1] < 0 && (a.splice(h, 3), h -= 3);
    for (let h = 0, m = 0; h < f.children.length; h += 3) {
      let g = f.children[h];
      for (; m < a.length && a[m] < g; )
        m += 3;
      a.splice(m, 0, f.children[h], f.children[h + 1], f.children[h + 2]);
    }
  }
  return new qn(t.sort(qu), a);
}
function xW(e, t) {
  if (!t || !e.length)
    return e;
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    n.push(new gi(i.from + t, i.to + t, i.type));
  }
  return n;
}
function O2e(e, t, n, r, i, o, s) {
  function a(c, u) {
    for (let f = 0; f < c.local.length; f++) {
      let h = c.local[f].map(r, i, u);
      h ? n.push(h) : s.onRemove && s.onRemove(c.local[f].spec);
    }
    for (let f = 0; f < c.children.length; f += 3)
      a(c.children[f + 2], c.children[f] + u + 1);
  }
  for (let c = 0; c < e.length; c += 3)
    e[c + 1] == -1 && a(e[c + 2], t[c] + o + 1);
  return n;
}
function wW(e, t, n) {
  if (t.isLeaf)
    return null;
  let r = n + t.nodeSize, i = null;
  for (let o = 0, s; o < e.length; o++)
    (s = e[o]) && s.from > n && s.to < r && ((i || (i = [])).push(s), e[o] = null);
  return i;
}
function SW(e) {
  let t = [];
  for (let n = 0; n < e.length; n++)
    e[n] != null && t.push(e[n]);
  return t;
}
function ex(e, t, n, r) {
  let i = [], o = !1;
  t.forEach((a, c) => {
    let u = wW(e, a, c + n);
    if (u) {
      o = !0;
      let f = ex(u, a, n + c + 1, r);
      f != fi && i.push(c, c + a.nodeSize, f);
    }
  });
  let s = xW(o ? SW(e) : e, -n).sort(qu);
  for (let a = 0; a < s.length; a++)
    s[a].type.valid(t, s[a]) || (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
  return s.length || i.length ? new qn(s, i) : fi;
}
function qu(e, t) {
  return e.from - t.from || e.to - t.to;
}
function _N(e) {
  let t = e;
  for (let n = 0; n < t.length - 1; n++) {
    let r = t[n];
    if (r.from != r.to)
      for (let i = n + 1; i < t.length; i++) {
        let o = t[i];
        if (o.from == r.from) {
          o.to != r.to && (t == e && (t = e.slice()), t[i] = o.copy(o.from, r.to), r5(t, i + 1, o.copy(r.to, o.to)));
          continue;
        } else {
          o.from < r.to && (t == e && (t = e.slice()), t[n] = r.copy(r.from, o.from), r5(t, i, r.copy(o.from, r.to)));
          break;
        }
      }
  }
  return t;
}
function r5(e, t, n) {
  for (; t < e.length && qu(n, e[t]) > 0; )
    t++;
  e.splice(t, 0, n);
}
function GC(e) {
  let t = [];
  return e.someProp("decorations", (n) => {
    let r = n(e.state);
    r && r != fi && t.push(r);
  }), e.cursorWrapper && t.push(qn.create(e.state.doc, [e.cursorWrapper.deco])), oc.from(t);
}
const D2e = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, P2e = Ki && bc <= 11;
class j2e {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(t) {
    this.anchorNode = t.anchorNode, this.anchorOffset = t.anchorOffset, this.focusNode = t.focusNode, this.focusOffset = t.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(t) {
    return t.anchorNode == this.anchorNode && t.anchorOffset == this.anchorOffset && t.focusNode == this.focusNode && t.focusOffset == this.focusOffset;
  }
}
class I2e {
  constructor(t, n) {
    this.view = t, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new j2e(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      Ki && bc <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : ii && t.composing && r.some((i) => i.type == "childList" && i.target.nodeName == "TR") ? (t.input.badSafariComposition = !0, this.flushSoon()) : this.flush();
    }), P2e && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, D2e)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let t = this.observer.takeRecords();
      if (t.length) {
        for (let n = 0; n < t.length; n++)
          this.queue.push(t[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (ZL(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Ka(this.view);
      if (Ki && bc <= 11 && !this.view.state.selection.empty) {
        let t = this.view.domSelectionRange();
        if (t.focusNode && sd(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(t) {
    if (!t.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let o = t.focusNode; o; o = ph(o))
      n.add(o);
    for (let o = t.anchorNode; o; o = ph(o))
      if (n.has(o)) {
        r = o;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let t of this.observer.takeRecords())
        this.queue.push(t);
    return this.queue;
  }
  flush() {
    let { view: t } = this;
    if (!t.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = t.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && ZL(t) && !this.ignoreSelectionChange(r), o = -1, s = -1, a = !1, c = [];
    if (t.editable)
      for (let f = 0; f < n.length; f++) {
        let h = this.registerMutation(n[f], c);
        h && (o = o < 0 ? h.from : Math.min(h.from, o), s = s < 0 ? h.to : Math.max(h.to, s), h.typeOver && (a = !0));
      }
    if (Vo && c.length) {
      let f = c.filter((h) => h.nodeName == "BR");
      if (f.length == 2) {
        let [h, m] = f;
        h.parentNode && h.parentNode.parentNode == m.parentNode ? m.remove() : h.remove();
      } else {
        let { focusNode: h } = this.currentSelection;
        for (let m of f) {
          let g = m.parentNode;
          g && g.nodeName == "LI" && (!h || B2e(t, h) != g) && m.remove();
        }
      }
    } else if ((Vr || ii) && c.some((f) => f.nodeName == "BR") && (t.input.lastKeyCode == 8 || t.input.lastKeyCode == 46)) {
      for (let f of c)
        if (f.nodeName == "BR" && f.parentNode) {
          let h = f.nextSibling;
          h && h.nodeType == 1 && h.contentEditable == "false" && f.parentNode.removeChild(f);
        }
    }
    let u = null;
    o < 0 && i && t.input.lastFocus > Date.now() - 200 && Math.max(t.input.lastTouch, t.input.lastClick.time) < Date.now() - 300 && Hw(r) && (u = bN(t)) && u.eq(zt.near(t.state.doc.resolve(0), 1)) ? (t.input.lastFocus = 0, Ka(t), this.currentSelection.set(r), t.scrollToSelection()) : (o > -1 || i) && (o > -1 && (t.docView.markDirty(o, s), z2e(t)), t.input.badSafariComposition && (t.input.badSafariComposition = !1, $2e(t, c)), this.handleDOMChange(o, s, a, c), t.docView && t.docView.dirty ? t.updateState(t.state) : this.currentSelection.eq(r) || Ka(t), this.currentSelection.set(r));
  }
  registerMutation(t, n) {
    if (n.indexOf(t.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(t.target);
    if (t.type == "attributes" && (r == this.view.docView || t.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    t.attributeName == "style" && !t.oldValue && !t.target.getAttribute("style")) || !r || r.ignoreMutation(t))
      return null;
    if (t.type == "childList") {
      for (let f = 0; f < t.addedNodes.length; f++) {
        let h = t.addedNodes[f];
        n.push(h), h.nodeType == 3 && (this.lastChangedTextNode = h);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(t.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = t.previousSibling, o = t.nextSibling;
      if (Ki && bc <= 11 && t.addedNodes.length)
        for (let f = 0; f < t.addedNodes.length; f++) {
          let { previousSibling: h, nextSibling: m } = t.addedNodes[f];
          (!h || Array.prototype.indexOf.call(t.addedNodes, h) < 0) && (i = h), (!m || Array.prototype.indexOf.call(t.addedNodes, m) < 0) && (o = m);
        }
      let s = i && i.parentNode == t.target ? ti(i) + 1 : 0, a = r.localPosFromDOM(t.target, s, -1), c = o && o.parentNode == t.target ? ti(o) : t.target.childNodes.length, u = r.localPosFromDOM(t.target, c, 1);
      return { from: a, to: u };
    } else return t.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = t.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: t.target.nodeValue == t.oldValue
    });
  }
}
let i5 = /* @__PURE__ */ new WeakMap(), o5 = !1;
function z2e(e) {
  if (!i5.has(e) && (i5.set(e, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(e.dom).whiteSpace) !== -1)) {
    if (e.requiresGeckoHackNode = Vo, o5)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), o5 = !0;
  }
}
function s5(e, t) {
  let n = t.startContainer, r = t.startOffset, i = t.endContainer, o = t.endOffset, s = e.domAtPos(e.state.selection.anchor);
  return sd(s.node, s.offset, i, o) && ([n, r, i, o] = [i, o, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o };
}
function L2e(e, t) {
  if (t.getComposedRanges) {
    let i = t.getComposedRanges(e.root)[0];
    if (i)
      return s5(e, i);
  }
  let n;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return e.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), e.dom.removeEventListener("beforeinput", r, !0), n ? s5(e, n) : null;
}
function B2e(e, t) {
  for (let n = t.parentNode; n && n != e.dom; n = n.parentNode) {
    let r = e.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock)
      return n;
  }
  return null;
}
function $2e(e, t) {
  var n;
  let { focusNode: r, focusOffset: i } = e.domSelectionRange();
  for (let o of t)
    if (((n = o.parentNode) === null || n === void 0 ? void 0 : n.nodeName) == "TR") {
      let s = o.nextSibling;
      for (; s && s.nodeName != "TD" && s.nodeName != "TH"; )
        s = s.nextSibling;
      if (s) {
        let a = s;
        for (; ; ) {
          let c = a.firstChild;
          if (!c || c.nodeType != 1 || c.contentEditable == "false" || /^(BR|IMG)$/.test(c.nodeName))
            break;
          a = c;
        }
        a.insertBefore(o, a.firstChild), r == o && e.domSelection().collapse(o, i);
      } else
        o.parentNode.removeChild(o);
    }
}
function U2e(e, t, n) {
  let { node: r, fromOffset: i, toOffset: o, from: s, to: a } = e.docView.parseRange(t, n), c = e.domSelectionRange(), u, f = c.anchorNode;
  if (f && e.dom.contains(f.nodeType == 1 ? f : f.parentNode) && (u = [{ node: f, offset: c.anchorOffset }], Hw(c) || u.push({ node: c.focusNode, offset: c.focusOffset })), Vr && e.input.lastKeyCode === 8)
    for (let w = o; w > i; w--) {
      let S = r.childNodes[w - 1], _ = S.pmViewDesc;
      if (S.nodeName == "BR" && !_) {
        o = w;
        break;
      }
      if (!_ || _.size)
        break;
    }
  let h = e.state.doc, m = e.someProp("domParser") || vc.fromSchema(e.state.schema), g = h.resolve(s), b = null, x = m.parse(r, {
    topNode: g.parent,
    topMatch: g.parent.contentMatchAt(g.index()),
    topOpen: !0,
    from: i,
    to: o,
    preserveWhitespace: g.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: u,
    ruleFromNode: F2e,
    context: g
  });
  if (u && u[0].pos != null) {
    let w = u[0].pos, S = u[1] && u[1].pos;
    S == null && (S = w), b = { anchor: w + s, head: S + s };
  }
  return { doc: x, sel: b, from: s, to: a };
}
function F2e(e) {
  let t = e.pmViewDesc;
  if (t)
    return t.parseRule();
  if (e.nodeName == "BR" && e.parentNode) {
    if (ii && /^(ul|ol)$/i.test(e.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (e.parentNode.lastChild == e || ii && /^(tr|table)$/i.test(e.parentNode.nodeName))
      return { ignore: !0 };
  } else if (e.nodeName == "IMG" && e.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const V2e = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function H2e(e, t, n, r, i) {
  let o = e.input.compositionPendingChanges || (e.composing ? e.input.compositionID : 0);
  if (e.input.compositionPendingChanges = 0, t < 0) {
    let O = e.input.lastSelectionTime > Date.now() - 50 ? e.input.lastSelectionOrigin : null, L = bN(e, O);
    if (L && !e.state.selection.eq(L)) {
      if (Vr && Ha && e.input.lastKeyCode === 13 && Date.now() - 100 < e.input.lastKeyCodeTime && e.someProp("handleKeyDown", (B) => B(e, Ru(13, "Enter"))))
        return;
      let U = e.state.tr.setSelection(L);
      O == "pointer" ? U.setMeta("pointer", !0) : O == "key" && U.scrollIntoView(), o && U.setMeta("composition", o), e.dispatch(U);
    }
    return;
  }
  let s = e.state.doc.resolve(t), a = s.sharedDepth(n);
  t = s.before(a + 1), n = e.state.doc.resolve(n).after(a + 1);
  let c = e.state.selection, u = U2e(e, t, n), f = e.state.doc, h = f.slice(u.from, u.to), m, g;
  e.input.lastKeyCode === 8 && Date.now() - 100 < e.input.lastKeyCodeTime ? (m = e.state.selection.to, g = "end") : (m = e.state.selection.from, g = "start"), e.input.lastKeyCode = null;
  let b = G2e(h.content, u.doc.content, u.from, m, g);
  if (b && e.input.domChangeCount++, (mh && e.input.lastIOSEnter > Date.now() - 225 || Ha) && i.some((O) => O.nodeType == 1 && !V2e.test(O.nodeName)) && (!b || b.endA >= b.endB) && e.someProp("handleKeyDown", (O) => O(e, Ru(13, "Enter")))) {
    e.input.lastIOSEnter = 0;
    return;
  }
  if (!b)
    if (r && c instanceof kt && !c.empty && c.$head.sameParent(c.$anchor) && !e.composing && !(u.sel && u.sel.anchor != u.sel.head))
      b = { start: c.from, endA: c.to, endB: c.to };
    else {
      if (u.sel) {
        let O = a5(e, e.state.doc, u.sel);
        if (O && !O.eq(e.state.selection)) {
          let L = e.state.tr.setSelection(O);
          o && L.setMeta("composition", o), e.dispatch(L);
        }
      }
      return;
    }
  e.state.selection.from < e.state.selection.to && b.start == b.endB && e.state.selection instanceof kt && (b.start > e.state.selection.from && b.start <= e.state.selection.from + 2 && e.state.selection.from >= u.from ? b.start = e.state.selection.from : b.endA < e.state.selection.to && b.endA >= e.state.selection.to - 2 && e.state.selection.to <= u.to && (b.endB += e.state.selection.to - b.endA, b.endA = e.state.selection.to)), Ki && bc <= 11 && b.endB == b.start + 1 && b.endA == b.start && b.start > u.from && u.doc.textBetween(b.start - u.from - 1, b.start - u.from + 1) == " " && (b.start--, b.endA--, b.endB--);
  let x = u.doc.resolveNoCache(b.start - u.from), w = u.doc.resolveNoCache(b.endB - u.from), S = f.resolve(b.start), _ = x.sameParent(w) && x.parent.inlineContent && S.end() >= b.endA;
  if ((mh && e.input.lastIOSEnter > Date.now() - 225 && (!_ || i.some((O) => O.nodeName == "DIV" || O.nodeName == "P")) || !_ && x.pos < u.doc.content.size && (!x.sameParent(w) || !x.parent.inlineContent) && x.pos < w.pos && !/\S/.test(u.doc.textBetween(x.pos, w.pos, "", ""))) && e.someProp("handleKeyDown", (O) => O(e, Ru(13, "Enter")))) {
    e.input.lastIOSEnter = 0;
    return;
  }
  if (e.state.selection.anchor > b.start && q2e(f, b.start, b.endA, x, w) && e.someProp("handleKeyDown", (O) => O(e, Ru(8, "Backspace")))) {
    Ha && Vr && e.domObserver.suppressSelectionUpdates();
    return;
  }
  Vr && b.endB == b.start && (e.input.lastChromeDelete = Date.now()), Ha && !_ && x.start() != w.start() && w.parentOffset == 0 && x.depth == w.depth && u.sel && u.sel.anchor == u.sel.head && u.sel.head == b.endA && (b.endB -= 2, w = u.doc.resolveNoCache(b.endB - u.from), setTimeout(() => {
    e.someProp("handleKeyDown", function(O) {
      return O(e, Ru(13, "Enter"));
    });
  }, 20));
  let M = b.start, N = b.endA, P = (O) => {
    let L = O || e.state.tr.replace(M, N, u.doc.slice(b.start - u.from, b.endB - u.from));
    if (u.sel) {
      let U = a5(e, L.doc, u.sel);
      U && !(Vr && e.composing && U.empty && (b.start != b.endB || e.input.lastChromeDelete < Date.now() - 100) && (U.head == M || U.head == L.mapping.map(N) - 1) || Ki && U.empty && U.head == M) && L.setSelection(U);
    }
    return o && L.setMeta("composition", o), L.scrollIntoView();
  }, I;
  if (_)
    if (x.pos == w.pos) {
      Ki && bc <= 11 && x.parentOffset == 0 && (e.domObserver.suppressSelectionUpdates(), setTimeout(() => Ka(e), 20));
      let O = P(e.state.tr.delete(M, N)), L = f.resolve(b.start).marksAcross(f.resolve(b.endA));
      L && O.ensureMarks(L), e.dispatch(O);
    } else if (
      // Adding or removing a mark
      b.endA == b.endB && (I = W2e(x.parent.content.cut(x.parentOffset, w.parentOffset), S.parent.content.cut(S.parentOffset, b.endA - S.start())))
    ) {
      let O = P(e.state.tr);
      I.type == "add" ? O.addMark(M, N, I.mark) : O.removeMark(M, N, I.mark), e.dispatch(O);
    } else if (x.parent.child(x.index()).isText && x.index() == w.index() - (w.textOffset ? 0 : 1)) {
      let O = x.parent.textBetween(x.parentOffset, w.parentOffset), L = () => P(e.state.tr.insertText(O, M, N));
      e.someProp("handleTextInput", (U) => U(e, M, N, O, L)) || e.dispatch(L());
    } else
      e.dispatch(P());
  else
    e.dispatch(P());
}
function a5(e, t, n) {
  return Math.max(n.anchor, n.head) > t.content.size ? null : xN(e, t.resolve(n.anchor), t.resolve(n.head));
}
function W2e(e, t) {
  let n = e.firstChild.marks, r = t.firstChild.marks, i = n, o = r, s, a, c;
  for (let f = 0; f < r.length; f++)
    i = r[f].removeFromSet(i);
  for (let f = 0; f < n.length; f++)
    o = n[f].removeFromSet(o);
  if (i.length == 1 && o.length == 0)
    a = i[0], s = "add", c = (f) => f.mark(a.addToSet(f.marks));
  else if (i.length == 0 && o.length == 1)
    a = o[0], s = "remove", c = (f) => f.mark(a.removeFromSet(f.marks));
  else
    return null;
  let u = [];
  for (let f = 0; f < t.childCount; f++)
    u.push(c(t.child(f)));
  if ($e.from(u).eq(e))
    return { mark: a, type: s };
}
function q2e(e, t, n, r, i) {
  if (
    // The content must have shrunk
    n - t <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    KC(r, !0, !1) < i.pos
  )
    return !1;
  let o = e.resolve(t);
  if (!r.parent.isTextblock) {
    let a = o.nodeAfter;
    return a != null && n == t + a.nodeSize;
  }
  if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
    return !1;
  let s = e.resolve(KC(o, !0, !0));
  return !s.parent.isTextblock || s.pos > n || KC(s, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
}
function KC(e, t, n) {
  let r = e.depth, i = t ? e.end() : e.pos;
  for (; r > 0 && (t || e.indexAfter(r) == e.node(r).childCount); )
    r--, i++, t = !1;
  if (n) {
    let o = e.node(r).maybeChild(e.indexAfter(r));
    for (; o && !o.isLeaf; )
      o = o.firstChild, i++;
  }
  return i;
}
function G2e(e, t, n, r, i) {
  let o = e.findDiffStart(t, n);
  if (o == null)
    return null;
  let { a: s, b: a } = e.findDiffEnd(t, n + e.size, n + t.size);
  if (i == "end") {
    let c = Math.max(0, o - Math.min(s, a));
    r -= s + c - o;
  }
  if (s < o && e.size < t.size) {
    let c = r <= o && r >= s ? o - r : 0;
    o -= c, o && o < t.size && l5(t.textBetween(o - 1, o + 1)) && (o += c ? 1 : -1), a = o + (a - s), s = o;
  } else if (a < o) {
    let c = r <= o && r >= a ? o - r : 0;
    o -= c, o && o < e.size && l5(e.textBetween(o - 1, o + 1)) && (o += c ? 1 : -1), s = o + (s - a), a = o;
  }
  return { start: o, endA: s, endB: a };
}
function l5(e) {
  if (e.length != 2)
    return !1;
  let t = e.charCodeAt(0), n = e.charCodeAt(1);
  return t >= 56320 && t <= 57343 && n >= 55296 && n <= 56319;
}
class kW {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(t, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new c2e(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(h5), this.dispatch = this.dispatch.bind(this), this.dom = t && t.mount || document.createElement("div"), t && (t.appendChild ? t.appendChild(this.dom) : typeof t == "function" ? t(this.dom) : t.mount && (this.mounted = !0)), this.editable = d5(this), u5(this), this.nodeViews = f5(this), this.docView = VL(this.state.doc, c5(this), GC(this), this.dom, this), this.domObserver = new I2e(this, (r, i, o, s) => H2e(this, r, i, o, s)), this.domObserver.start(), u2e(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let t = this._props;
      this._props = {};
      for (let n in t)
        this._props[n] = t[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(t) {
    t.handleDOMEvents != this._props.handleDOMEvents && yT(this);
    let n = this._props;
    this._props = t, t.plugins && (t.plugins.forEach(h5), this.directPlugins = t.plugins), this.updateStateInner(t.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(t) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in t)
      n[r] = t[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(t) {
    this.updateStateInner(t, this._props);
  }
  updateStateInner(t, n) {
    var r;
    let i = this.state, o = !1, s = !1;
    t.storedMarks && this.composing && (gW(this), s = !0), this.state = t;
    let a = i.plugins != t.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let g = f5(this);
      Z2e(g, this.nodeViews) && (this.nodeViews = g, o = !0);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && yT(this), this.editable = d5(this), u5(this);
    let c = GC(this), u = c5(this), f = i.plugins != t.plugins && !i.doc.eq(t.doc) ? "reset" : t.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", h = o || !this.docView.matchesNode(t.doc, u, c);
    (h || !t.selection.eq(i.selection)) && (s = !0);
    let m = f == "preserve" && s && this.dom.style.overflowAnchor == null && CRe(this);
    if (s) {
      this.domObserver.stop();
      let g = h && (Ki || Vr) && !this.composing && !i.selection.empty && !t.selection.empty && K2e(i.selection, t.selection);
      if (h) {
        let b = Vr ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = C2e(this)), (o || !this.docView.update(t.doc, u, c, this)) && (this.docView.updateOuterDeco(u), this.docView.destroy(), this.docView = VL(t.doc, u, c, this.dom, this)), b && (!this.trackWrites || !this.dom.contains(this.trackWrites)) && (g = !0);
      }
      g || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && KRe(this)) ? Ka(this, g) : (iW(this, t.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(t.doc) && this.updateDraggedNode(this.dragging, i), f == "reset" ? this.dom.scrollTop = 0 : f == "to selection" ? this.scrollToSelection() : m && ERe(m);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let t = this.domSelectionRange().focusNode;
    if (!(!t || !this.dom.contains(t.nodeType == 1 ? t : t.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof ht) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && zL(this, n.getBoundingClientRect(), t);
      } else
        zL(this, this.coordsAtPos(this.state.selection.head, 1), t);
    }
  }
  destroyPluginViews() {
    let t;
    for (; t = this.pluginViews.pop(); )
      t.destroy && t.destroy();
  }
  updatePluginViews(t) {
    if (!t || t.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, t);
      }
  }
  updateDraggedNode(t, n) {
    let r = t.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let o = r.from + (this.state.doc.content.size - n.doc.content.size);
      (o > 0 && this.state.doc.nodeAt(o)) == r.node && (i = o);
    }
    this.dragging = new vW(t.slice, t.move, i < 0 ? void 0 : ht.create(this.state.doc, i));
  }
  someProp(t, n) {
    let r = this._props && this._props[t], i;
    if (r != null && (i = n ? n(r) : r))
      return i;
    for (let s = 0; s < this.directPlugins.length; s++) {
      let a = this.directPlugins[s].props[t];
      if (a != null && (i = n ? n(a) : a))
        return i;
    }
    let o = this.state.plugins;
    if (o)
      for (let s = 0; s < o.length; s++) {
        let a = o[s].props[t];
        if (a != null && (i = n ? n(a) : a))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Ki) {
      let t = this.root.activeElement;
      if (t == this.dom)
        return !0;
      if (!t || !this.dom.contains(t))
        return !1;
      for (; t && this.dom != t && this.dom.contains(t); ) {
        if (t.contentEditable == "false")
          return !1;
        t = t.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && _Re(this.dom), Ka(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let t = this._root;
    if (t == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return t || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(t) {
    return RRe(this, t);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(t, n = 1) {
    return YH(this, t, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(t, n = 0) {
    return this.docView.domFromPos(t, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(t) {
    let n = this.docView.descAt(t);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(t, n, r = -1) {
    let i = this.docView.posFromDOM(t, n, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(t, n) {
    return IRe(this, n || this.state, t);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(t, n) {
    return xg(this, "", t, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(t, n) {
    return xg(this, t, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(t) {
    return wN(this, t);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (d2e(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], GC(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, pRe());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(t) {
    return h2e(this, t);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let t = this.domSelection();
    return t ? ii && this.root.nodeType === 11 && bRe(this.dom.ownerDocument) == this.dom && L2e(this, t) || t : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
kW.prototype.dispatch = function(e) {
  let t = this._props.dispatchTransaction;
  t ? t.call(this, e) : this.updateState(this.state.apply(e));
};
function c5(e) {
  let t = /* @__PURE__ */ Object.create(null);
  return t.class = "ProseMirror", t.contenteditable = String(e.editable), e.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(e.state)), n)
      for (let r in n)
        r == "class" ? t.class += " " + n[r] : r == "style" ? t.style = (t.style ? t.style + ";" : "") + n[r] : !t[r] && r != "contenteditable" && r != "nodeName" && (t[r] = String(n[r]));
  }), t.translate || (t.translate = "no"), [gi.node(0, e.state.doc.content.size, t)];
}
function u5(e) {
  if (e.markCursor) {
    let t = document.createElement("img");
    t.className = "ProseMirror-separator", t.setAttribute("mark-placeholder", "true"), t.setAttribute("alt", ""), e.cursorWrapper = { dom: t, deco: gi.widget(e.state.selection.from, t, { raw: !0, marks: e.markCursor }) };
  } else
    e.cursorWrapper = null;
}
function d5(e) {
  return !e.someProp("editable", (t) => t(e.state) === !1);
}
function K2e(e, t) {
  let n = Math.min(e.$anchor.sharedDepth(e.head), t.$anchor.sharedDepth(t.head));
  return e.$anchor.start(n) != t.$anchor.start(n);
}
function f5(e) {
  let t = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(t, i) || (t[i] = r[i]);
  }
  return e.someProp("nodeViews", n), e.someProp("markViews", n), t;
}
function Z2e(e, t) {
  let n = 0, r = 0;
  for (let i in e) {
    if (e[i] != t[i])
      return !0;
    n++;
  }
  for (let i in t)
    r++;
  return n != r;
}
function h5(e) {
  if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Oc = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, tx = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, Y2e = typeof navigator < "u" && /Mac/.test(navigator.platform), X2e = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var ni = 0; ni < 10; ni++) Oc[48 + ni] = Oc[96 + ni] = String(ni);
for (var ni = 1; ni <= 24; ni++) Oc[ni + 111] = "F" + ni;
for (var ni = 65; ni <= 90; ni++)
  Oc[ni] = String.fromCharCode(ni + 32), tx[ni] = String.fromCharCode(ni);
for (var ZC in Oc) tx.hasOwnProperty(ZC) || (tx[ZC] = Oc[ZC]);
function J2e(e) {
  var t = Y2e && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || X2e && e.shiftKey && e.key && e.key.length == 1 || e.key == "Unidentified", n = !t && e.key || (e.shiftKey ? tx : Oc)[e.keyCode] || e.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const Q2e = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), eOe = typeof navigator < "u" && /Win/.test(navigator.platform);
function tOe(e) {
  let t = e.split(/-(?!$)/), n = t[t.length - 1];
  n == "Space" && (n = " ");
  let r, i, o, s;
  for (let a = 0; a < t.length - 1; a++) {
    let c = t[a];
    if (/^(cmd|meta|m)$/i.test(c))
      s = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      i = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      Q2e ? s = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return r && (n = "Alt-" + n), i && (n = "Ctrl-" + n), s && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function nOe(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in e)
    t[tOe(n)] = e[n];
  return t;
}
function YC(e, t, n = !0) {
  return t.altKey && (e = "Alt-" + e), t.ctrlKey && (e = "Ctrl-" + e), t.metaKey && (e = "Meta-" + e), n && t.shiftKey && (e = "Shift-" + e), e;
}
function rOe(e) {
  return new Zn({ props: { handleKeyDown: CW(e) } });
}
function CW(e) {
  let t = nOe(e);
  return function(n, r) {
    let i = J2e(r), o, s = t[YC(i, r)];
    if (s && s(n.state, n.dispatch, n))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let a = t[YC(i, r, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(eOe && r.ctrlKey && r.altKey) && (o = Oc[r.keyCode]) && o != i) {
        let a = t[YC(o, r)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
var iOe = Object.defineProperty, TN = (e, t) => {
  for (var n in t)
    iOe(e, n, { get: t[n], enumerable: !0 });
};
function Gw(e) {
  const { state: t, transaction: n } = e;
  let { selection: r } = n, { doc: i } = n, { storedMarks: o } = n;
  return {
    ...t,
    apply: t.apply.bind(t),
    applyTransaction: t.applyTransaction.bind(t),
    plugins: t.plugins,
    schema: t.schema,
    reconfigure: t.reconfigure.bind(t),
    toJSON: t.toJSON.bind(t),
    get storedMarks() {
      return o;
    },
    get selection() {
      return r;
    },
    get doc() {
      return i;
    },
    get tr() {
      return r = n.selection, i = n.doc, o = n.storedMarks, n;
    }
  };
}
var Kw = class {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: t, state: n } = this, { view: r } = t, { tr: i } = n, o = this.buildProps(i);
    return Object.fromEntries(
      Object.entries(e).map(([s, a]) => [s, (...u) => {
        const f = a(...u)(o);
        return !i.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(i), f;
      }])
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, t = !0) {
    const { rawCommands: n, editor: r, state: i } = this, { view: o } = r, s = [], a = !!e, c = e || i.tr, u = () => (!a && t && !c.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(c), s.every((h) => h === !0)), f = {
      ...Object.fromEntries(
        Object.entries(n).map(([h, m]) => [h, (...b) => {
          const x = this.buildProps(c, t), w = m(...b)(x);
          return s.push(w), f;
        }])
      ),
      run: u
    };
    return f;
  }
  createCan(e) {
    const { rawCommands: t, state: n } = this, r = !1, i = e || n.tr, o = this.buildProps(i, r);
    return {
      ...Object.fromEntries(
        Object.entries(t).map(([a, c]) => [a, (...u) => c(...u)({ ...o, dispatch: void 0 })])
      ),
      chain: () => this.createChain(i, r)
    };
  }
  buildProps(e, t = !0) {
    const { rawCommands: n, editor: r, state: i } = this, { view: o } = r, s = {
      tr: e,
      editor: r,
      view: o,
      state: Gw({
        state: i,
        transaction: e
      }),
      dispatch: t ? () => {
      } : void 0,
      chain: () => this.createChain(e, t),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(
          Object.entries(n).map(([a, c]) => [a, (...u) => c(...u)(s)])
        );
      }
    };
    return s;
  }
}, EW = {};
TN(EW, {
  blur: () => oOe,
  clearContent: () => sOe,
  clearNodes: () => aOe,
  command: () => lOe,
  createParagraphNear: () => cOe,
  cut: () => uOe,
  deleteCurrentNode: () => dOe,
  deleteNode: () => fOe,
  deleteRange: () => hOe,
  deleteSelection: () => pOe,
  enter: () => mOe,
  exitCode: () => gOe,
  extendMarkRange: () => yOe,
  first: () => vOe,
  focus: () => xOe,
  forEach: () => wOe,
  insertContent: () => SOe,
  insertContentAt: () => EOe,
  joinBackward: () => AOe,
  joinDown: () => TOe,
  joinForward: () => MOe,
  joinItemBackward: () => NOe,
  joinItemForward: () => ROe,
  joinTextblockBackward: () => OOe,
  joinTextblockForward: () => DOe,
  joinUp: () => _Oe,
  keyboardShortcut: () => jOe,
  lift: () => IOe,
  liftEmptyBlock: () => zOe,
  liftListItem: () => LOe,
  newlineInCode: () => BOe,
  resetAttributes: () => $Oe,
  scrollIntoView: () => UOe,
  selectAll: () => FOe,
  selectNodeBackward: () => VOe,
  selectNodeForward: () => HOe,
  selectParentNode: () => WOe,
  selectTextblockEnd: () => qOe,
  selectTextblockStart: () => GOe,
  setContent: () => KOe,
  setMark: () => pDe,
  setMeta: () => mDe,
  setNode: () => gDe,
  setNodeSelection: () => yDe,
  setTextDirection: () => vDe,
  setTextSelection: () => bDe,
  sinkListItem: () => xDe,
  splitBlock: () => wDe,
  splitListItem: () => SDe,
  toggleList: () => kDe,
  toggleMark: () => CDe,
  toggleNode: () => EDe,
  toggleWrap: () => _De,
  undoInputRule: () => TDe,
  unsetAllMarks: () => ADe,
  unsetMark: () => MDe,
  unsetTextDirection: () => NDe,
  updateAttributes: () => RDe,
  wrapIn: () => ODe,
  wrapInList: () => DDe
});
var oOe = () => ({ editor: e, view: t }) => (requestAnimationFrame(() => {
  var n;
  e.isDestroyed || (t.dom.blur(), (n = window?.getSelection()) == null || n.removeAllRanges());
}), !0), sOe = (e = !0) => ({ commands: t }) => t.setContent("", { emitUpdate: e }), aOe = () => ({ state: e, tr: t, dispatch: n }) => {
  const { selection: r } = t, { ranges: i } = r;
  return n && i.forEach(({ $from: o, $to: s }) => {
    e.doc.nodesBetween(o.pos, s.pos, (a, c) => {
      if (a.type.isText)
        return;
      const { doc: u, mapping: f } = t, h = u.resolve(f.map(c)), m = u.resolve(f.map(c + a.nodeSize)), g = h.blockRange(m);
      if (!g)
        return;
      const b = Fh(g);
      if (a.type.isTextblock) {
        const { defaultType: x } = h.parent.contentMatchAt(h.index());
        t.setNodeMarkup(g.start, x);
      }
      (b || b === 0) && t.lift(g, b);
    });
  }), !0;
}, lOe = (e) => (t) => e(t), cOe = () => ({ state: e, dispatch: t }) => BH(e, t), uOe = (e, t) => ({ editor: n, tr: r }) => {
  const { state: i } = n, o = i.doc.slice(e.from, e.to);
  r.deleteRange(e.from, e.to);
  const s = r.mapping.map(t);
  return r.insert(s, o.content), r.setSelection(new kt(r.doc.resolve(Math.max(s - 1, 0)))), !0;
}, dOe = () => ({ tr: e, dispatch: t }) => {
  const { selection: n } = e, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const i = e.selection.$anchor;
  for (let o = i.depth; o > 0; o -= 1)
    if (i.node(o).type === r.type) {
      if (t) {
        const a = i.before(o), c = i.after(o);
        e.delete(a, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
};
function _r(e, t) {
  if (typeof e == "string") {
    if (!t.nodes[e])
      throw Error(`There is no node type named '${e}'. Maybe you forgot to add the extension?`);
    return t.nodes[e];
  }
  return e;
}
var fOe = (e) => ({ tr: t, state: n, dispatch: r }) => {
  const i = _r(e, n.schema), o = t.selection.$anchor;
  for (let s = o.depth; s > 0; s -= 1)
    if (o.node(s).type === i) {
      if (r) {
        const c = o.before(s), u = o.after(s);
        t.delete(c, u).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, hOe = (e) => ({ tr: t, dispatch: n }) => {
  const { from: r, to: i } = e;
  return n && t.delete(r, i), !0;
}, pOe = () => ({ state: e, dispatch: t }) => hN(e, t), mOe = () => ({ commands: e }) => e.keyboardShortcut("Enter"), gOe = () => ({ state: e, dispatch: t }) => QNe(e, t);
function AN(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
function nx(e, t, n = { strict: !0 }) {
  const r = Object.keys(t);
  return r.length ? r.every((i) => n.strict ? t[i] === e[i] : AN(t[i]) ? t[i].test(e[i]) : t[i] === e[i]) : !0;
}
function _W(e, t, n = {}) {
  return e.find((r) => r.type === t && nx(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((i) => [i, r.attrs[i]])),
    n
  ));
}
function p5(e, t, n = {}) {
  return !!_W(e, t, n);
}
function MN(e, t, n) {
  var r;
  if (!e || !t)
    return;
  let i = e.parent.childAfter(e.parentOffset);
  if ((!i.node || !i.node.marks.some((f) => f.type === t)) && (i = e.parent.childBefore(e.parentOffset)), !i.node || !i.node.marks.some((f) => f.type === t) || (n = n || ((r = i.node.marks[0]) == null ? void 0 : r.attrs), !_W([...i.node.marks], t, n)))
    return;
  let s = i.index, a = e.start() + i.offset, c = s + 1, u = a + i.node.nodeSize;
  for (; s > 0 && p5([...e.parent.child(s - 1).marks], t, n); )
    s -= 1, a -= e.parent.child(s).nodeSize;
  for (; c < e.parent.childCount && p5([...e.parent.child(c).marks], t, n); )
    u += e.parent.child(c).nodeSize, c += 1;
  return {
    from: a,
    to: u
  };
}
function sl(e, t) {
  if (typeof e == "string") {
    if (!t.marks[e])
      throw Error(`There is no mark type named '${e}'. Maybe you forgot to add the extension?`);
    return t.marks[e];
  }
  return e;
}
var yOe = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const o = sl(e, r.schema), { doc: s, selection: a } = n, { $from: c, from: u, to: f } = a;
  if (i) {
    const h = MN(c, o, t);
    if (h && h.from <= u && h.to >= f) {
      const m = kt.create(s, h.from, h.to);
      n.setSelection(m);
    }
  }
  return !0;
}, vOe = (e) => (t) => {
  const n = typeof e == "function" ? e(t) : e;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](t))
      return !0;
  return !1;
};
function TW(e) {
  return e instanceof kt;
}
function Lu(e = 0, t = 0, n = 0) {
  return Math.min(Math.max(e, t), n);
}
function AW(e, t = null) {
  if (!t)
    return null;
  const n = zt.atStart(e), r = zt.atEnd(e);
  if (t === "start" || t === !0)
    return n;
  if (t === "end")
    return r;
  const i = n.from, o = r.to;
  return t === "all" ? kt.create(e, Lu(0, i, o), Lu(e.content.size, i, o)) : kt.create(e, Lu(t, i, o), Lu(t, i, o));
}
function vT() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function Sg() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function bOe() {
  return typeof navigator < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1;
}
var xOe = (e = null, t = {}) => ({ editor: n, view: r, tr: i, dispatch: o }) => {
  t = {
    scrollIntoView: !0,
    ...t
  };
  const s = () => {
    (Sg() || vT()) && r.dom.focus(), bOe() && !Sg() && !vT() && r.dom.focus({ preventScroll: !0 }), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), t?.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  try {
    if (r.hasFocus() && e === null || e === !1)
      return !0;
  } catch {
    return !1;
  }
  if (o && e === null && !TW(n.state.selection))
    return s(), !0;
  const a = AW(i.doc, e) || n.state.selection, c = n.state.selection.eq(a);
  return o && (c || i.setSelection(a), c && i.storedMarks && i.setStoredMarks(i.storedMarks), s()), !0;
}, wOe = (e, t) => (n) => e.every((r, i) => t(r, { ...n, index: i })), SOe = (e, t) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, e, t), MW = (e) => {
  const t = e.childNodes;
  for (let n = t.length - 1; n >= 0; n -= 1) {
    const r = t[n];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? e.removeChild(r) : r.nodeType === 1 && MW(r);
  }
  return e;
};
function Xv(e) {
  if (typeof window > "u")
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  const t = `<body>${e}</body>`, n = new window.DOMParser().parseFromString(t, "text/html").body;
  return MW(n);
}
function kg(e, t, n) {
  if (e instanceof yc || e instanceof $e)
    return e;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const r = typeof e == "object" && e !== null, i = typeof e == "string";
  if (r)
    try {
      if (Array.isArray(e) && e.length > 0)
        return $e.fromArray(e.map((a) => t.nodeFromJSON(a)));
      const s = t.nodeFromJSON(e);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (o) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: o });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", e, "Error:", o), kg("", t, n);
    }
  if (i) {
    if (n.errorOnInvalidContent) {
      let s = !1, a = "";
      const c = new fH({
        topNode: t.spec.topNode,
        marks: t.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: t.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (u) => (s = !0, a = typeof u == "string" ? u : u.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? vc.fromSchema(c).parseSlice(Xv(e), n.parseOptions) : vc.fromSchema(c).parse(Xv(e), n.parseOptions), n.errorOnInvalidContent && s)
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${a}`)
        });
    }
    const o = vc.fromSchema(t);
    return n.slice ? o.parseSlice(Xv(e), n.parseOptions).content : o.parse(Xv(e), n.parseOptions);
  }
  return kg("", t, n);
}
function kOe(e, t, n) {
  const r = e.steps.length - 1;
  if (r < t)
    return;
  const i = e.steps[r];
  if (!(i instanceof Ur || i instanceof Hr))
    return;
  const o = e.mapping.maps[r];
  let s = 0;
  o.forEach((a, c, u, f) => {
    s === 0 && (s = f);
  }), e.setSelection(zt.near(e.doc.resolve(s), n));
}
var COe = (e) => !("type" in e), EOe = (e, t, n) => ({ tr: r, dispatch: i, editor: o }) => {
  var s;
  if (i) {
    n = {
      parseOptions: o.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    const c = (w) => {
      o.emit("contentError", {
        editor: o,
        error: w,
        disableCollaboration: () => {
          "collaboration" in o.storage && typeof o.storage.collaboration == "object" && o.storage.collaboration && (o.storage.collaboration.isDisabled = !0);
        }
      });
    }, u = {
      preserveWhitespace: "full",
      ...n.parseOptions
    };
    if (!n.errorOnInvalidContent && !o.options.enableContentCheck && o.options.emitContentError)
      try {
        kg(t, o.schema, {
          parseOptions: u,
          errorOnInvalidContent: !0
        });
      } catch (w) {
        c(w);
      }
    try {
      a = kg(t, o.schema, {
        parseOptions: u,
        errorOnInvalidContent: (s = n.errorOnInvalidContent) != null ? s : o.options.enableContentCheck
      });
    } catch (w) {
      return c(w), !1;
    }
    let { from: f, to: h } = typeof e == "number" ? { from: e, to: e } : { from: e.from, to: e.to }, m = !0, g = !0;
    if ((COe(a) ? a : [a]).forEach((w) => {
      w.check(), m = m ? w.isText && w.marks.length === 0 : !1, g = g ? w.isBlock : !1;
    }), f === h && g) {
      const { parent: w } = r.doc.resolve(f);
      w.isTextblock && !w.type.spec.code && !w.childCount && (f -= 1, h += 1);
    }
    let x;
    if (m) {
      if (Array.isArray(t))
        x = t.map((w) => w.text || "").join("");
      else if (t instanceof $e) {
        let w = "";
        t.forEach((S) => {
          S.text && (w += S.text);
        }), x = w;
      } else typeof t == "object" && t && t.text ? x = t.text : x = t;
      r.insertText(x, f, h);
    } else {
      x = a;
      const w = r.doc.resolve(f), S = w.node(), _ = w.parentOffset === 0, M = S.isText || S.isTextblock, N = S.content.size > 0;
      _ && M && N && (f = Math.max(0, f - 1)), r.replaceWith(f, h, x);
    }
    n.updateSelection && kOe(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: f, text: x }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: f, text: x });
  }
  return !0;
}, _Oe = () => ({ state: e, dispatch: t }) => YNe(e, t), TOe = () => ({ state: e, dispatch: t }) => XNe(e, t), AOe = () => ({ state: e, dispatch: t }) => OH(e, t), MOe = () => ({ state: e, dispatch: t }) => IH(e, t), NOe = () => ({ state: e, dispatch: t, tr: n }) => {
  try {
    const r = Uw(e.doc, e.selection.$from.pos, -1);
    return r == null ? !1 : (n.join(r, 2), t && t(n), !0);
  } catch {
    return !1;
  }
}, ROe = () => ({ state: e, dispatch: t, tr: n }) => {
  try {
    const r = Uw(e.doc, e.selection.$from.pos, 1);
    return r == null ? !1 : (n.join(r, 2), t && t(n), !0);
  } catch {
    return !1;
  }
}, OOe = () => ({ state: e, dispatch: t }) => KNe(e, t), DOe = () => ({ state: e, dispatch: t }) => ZNe(e, t);
function NW() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function POe(e) {
  const t = e.split(/-(?!$)/);
  let n = t[t.length - 1];
  n === "Space" && (n = " ");
  let r, i, o, s;
  for (let a = 0; a < t.length - 1; a += 1) {
    const c = t[a];
    if (/^(cmd|meta|m)$/i.test(c))
      s = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      i = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      Sg() || NW() ? s = !0 : i = !0;
    else
      throw new Error(`Unrecognized modifier name: ${c}`);
  }
  return r && (n = `Alt-${n}`), i && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), o && (n = `Shift-${n}`), n;
}
var jOe = (e) => ({ editor: t, view: n, tr: r, dispatch: i }) => {
  const o = POe(e).split(/-(?!$)/), s = o.find((u) => !["Alt", "Ctrl", "Meta", "Shift"].includes(u)), a = new KeyboardEvent("keydown", {
    key: s === "Space" ? " " : s,
    altKey: o.includes("Alt"),
    ctrlKey: o.includes("Ctrl"),
    metaKey: o.includes("Meta"),
    shiftKey: o.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), c = t.captureTransaction(() => {
    n.someProp("handleKeyDown", (u) => u(n, a));
  });
  return c?.steps.forEach((u) => {
    const f = u.map(r.mapping);
    f && i && r.maybeStep(f);
  }), !0;
};
function Dc(e, t, n = {}) {
  const { from: r, to: i, empty: o } = e.selection, s = t ? _r(t, e.schema) : null, a = [];
  e.doc.nodesBetween(r, i, (h, m) => {
    if (h.isText)
      return;
    const g = Math.max(r, m), b = Math.min(i, m + h.nodeSize);
    a.push({
      node: h,
      from: g,
      to: b
    });
  });
  const c = i - r, u = a.filter((h) => s ? s.name === h.node.type.name : !0).filter((h) => nx(h.node.attrs, n, { strict: !1 }));
  return o ? !!u.length : u.reduce((h, m) => h + m.to - m.from, 0) >= c;
}
var IOe = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const i = _r(e, n.schema);
  return Dc(n, i, t) ? JNe(n, r) : !1;
}, zOe = () => ({ state: e, dispatch: t }) => $H(e, t), LOe = (e) => ({ state: t, dispatch: n }) => {
  const r = _r(e, t.schema);
  return uRe(r)(t, n);
}, BOe = () => ({ state: e, dispatch: t }) => LH(e, t);
function Zw(e, t) {
  return t.nodes[e] ? "node" : t.marks[e] ? "mark" : null;
}
function m5(e, t) {
  const n = typeof t == "string" ? [t] : t;
  return Object.keys(e).reduce((r, i) => (n.includes(i) || (r[i] = e[i]), r), {});
}
var $Oe = (e, t) => ({ tr: n, state: r, dispatch: i }) => {
  let o = null, s = null;
  const a = Zw(
    typeof e == "string" ? e : e.name,
    r.schema
  );
  if (!a)
    return !1;
  a === "node" && (o = _r(e, r.schema)), a === "mark" && (s = sl(e, r.schema));
  let c = !1;
  return n.selection.ranges.forEach((u) => {
    r.doc.nodesBetween(u.$from.pos, u.$to.pos, (f, h) => {
      o && o === f.type && (c = !0, i && n.setNodeMarkup(h, void 0, m5(f.attrs, t))), s && f.marks.length && f.marks.forEach((m) => {
        s === m.type && (c = !0, i && n.addMark(h, h + f.nodeSize, s.create(m5(m.attrs, t))));
      });
    });
  }), c;
}, UOe = () => ({ tr: e, dispatch: t }) => (t && e.scrollIntoView(), !0), FOe = () => ({ tr: e, dispatch: t }) => {
  if (t) {
    const n = new mo(e.doc);
    e.setSelection(n);
  }
  return !0;
}, VOe = () => ({ state: e, dispatch: t }) => PH(e, t), HOe = () => ({ state: e, dispatch: t }) => zH(e, t), WOe = () => ({ state: e, dispatch: t }) => nRe(e, t), qOe = () => ({ state: e, dispatch: t }) => oRe(e, t), GOe = () => ({ state: e, dispatch: t }) => iRe(e, t);
function bT(e, t, n = {}, r = {}) {
  return kg(e, t, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
var KOe = (e, { errorOnInvalidContent: t, emitUpdate: n = !0, parseOptions: r = {} } = {}) => ({ editor: i, tr: o, dispatch: s, commands: a }) => {
  const { doc: c } = o;
  if (r.preserveWhitespace !== "full") {
    const u = bT(e, i.schema, r, {
      errorOnInvalidContent: t ?? i.options.enableContentCheck
    });
    return s && o.replaceWith(0, c.content.size, u).setMeta("preventUpdate", !n), !0;
  }
  return s && o.setMeta("preventUpdate", !n), a.insertContentAt({ from: 0, to: c.content.size }, e, {
    parseOptions: r,
    errorOnInvalidContent: t ?? i.options.enableContentCheck
  });
};
function RW(e, t) {
  const n = sl(t, e.schema), { from: r, to: i, empty: o } = e.selection, s = [];
  o ? (e.storedMarks && s.push(...e.storedMarks), s.push(...e.selection.$head.marks())) : e.doc.nodesBetween(r, i, (c) => {
    s.push(...c.marks);
  });
  const a = s.find((c) => c.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function OW(e, t) {
  const n = new AH(e);
  return t.forEach((r) => {
    r.steps.forEach((i) => {
      n.step(i);
    });
  }), n;
}
function ZOe(e) {
  for (let t = 0; t < e.edgeCount; t += 1) {
    const { type: n } = e.edge(t);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function YOe(e, t, n) {
  const r = [];
  return e.nodesBetween(t.from, t.to, (i, o) => {
    n(i) && r.push({
      node: i,
      pos: o
    });
  }), r;
}
function XOe(e, t) {
  for (let n = e.depth; n > 0; n -= 1) {
    const r = e.node(n);
    if (t(r))
      return {
        pos: n > 0 ? e.before(n) : 0,
        start: e.start(n),
        depth: n,
        node: r
      };
  }
}
function Yw(e) {
  return (t) => XOe(t.$from, e);
}
function ft(e, t, n) {
  return e.config[t] === void 0 && e.parent ? ft(e.parent, t, n) : typeof e.config[t] == "function" ? e.config[t].bind({
    ...n,
    parent: e.parent ? ft(e.parent, t, n) : null
  }) : e.config[t];
}
function NN(e) {
  return e.map((t) => {
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    }, r = ft(t, "addExtensions", n);
    return r ? [t, ...NN(r())] : t;
  }).flat(10);
}
function RN(e, t) {
  const n = md.fromSchema(t).serializeFragment(e), i = document.implementation.createHTMLDocument().createElement("div");
  return i.appendChild(n), i.innerHTML;
}
function DW(e) {
  return typeof e == "function";
}
function mn(e, t = void 0, ...n) {
  return DW(e) ? t ? e.bind(t)(...n) : e(...n) : e;
}
function JOe(e = {}) {
  return Object.keys(e).length === 0 && e.constructor === Object;
}
function gh(e) {
  const t = e.filter((i) => i.type === "extension"), n = e.filter((i) => i.type === "node"), r = e.filter((i) => i.type === "mark");
  return {
    baseExtensions: t,
    nodeExtensions: n,
    markExtensions: r
  };
}
function PW(e) {
  const t = [], { nodeExtensions: n, markExtensions: r } = gh(e), i = [...n, ...r], o = {
    default: null,
    validate: void 0,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return e.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage,
      extensions: i
    }, c = ft(
      s,
      "addGlobalAttributes",
      a
    );
    if (!c)
      return;
    c().forEach((f) => {
      f.types.forEach((h) => {
        Object.entries(f.attributes).forEach(([m, g]) => {
          t.push({
            type: h,
            name: m,
            attribute: {
              ...o,
              ...g
            }
          });
        });
      });
    });
  }), i.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage
    }, c = ft(
      s,
      "addAttributes",
      a
    );
    if (!c)
      return;
    const u = c();
    Object.entries(u).forEach(([f, h]) => {
      const m = {
        ...o,
        ...h
      };
      typeof m?.default == "function" && (m.default = m.default()), m?.isRequired && m?.default === void 0 && delete m.default, t.push({
        type: s.name,
        name: f,
        attribute: m
      });
    });
  }), t;
}
function or(...e) {
  return e.filter((t) => !!t).reduce((t, n) => {
    const r = { ...t };
    return Object.entries(n).forEach(([i, o]) => {
      if (!r[i]) {
        r[i] = o;
        return;
      }
      if (i === "class") {
        const a = o ? String(o).split(" ") : [], c = r[i] ? r[i].split(" ") : [], u = a.filter((f) => !c.includes(f));
        r[i] = [...c, ...u].join(" ");
      } else if (i === "style") {
        const a = o ? o.split(";").map((f) => f.trim()).filter(Boolean) : [], c = r[i] ? r[i].split(";").map((f) => f.trim()).filter(Boolean) : [], u = /* @__PURE__ */ new Map();
        c.forEach((f) => {
          const [h, m] = f.split(":").map((g) => g.trim());
          u.set(h, m);
        }), a.forEach((f) => {
          const [h, m] = f.split(":").map((g) => g.trim());
          u.set(h, m);
        }), r[i] = Array.from(u.entries()).map(([f, h]) => `${f}: ${h}`).join("; ");
      } else
        r[i] = o;
    }), r;
  }, {});
}
function yh(e, t) {
  return t.filter((n) => n.type === e.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(e.attrs) || {} : {
    [n.name]: e.attrs[n.name]
  }).reduce((n, r) => or(n, r), {});
}
function QOe(e) {
  return typeof e != "string" ? e : e.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(e) : e === "true" ? !0 : e === "false" ? !1 : e;
}
function g5(e, t) {
  return "style" in e ? e : {
    ...e,
    getAttrs: (n) => {
      const r = e.getAttrs ? e.getAttrs(n) : e.attrs;
      if (r === !1)
        return !1;
      const i = t.reduce((o, s) => {
        const a = s.attribute.parseHTML ? s.attribute.parseHTML(n) : QOe(n.getAttribute(s.name));
        return a == null ? o : {
          ...o,
          [s.name]: a
        };
      }, {});
      return { ...r, ...i };
    }
  };
}
function y5(e) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(e).filter(([t, n]) => t === "attrs" && JOe(n) ? !1 : n != null)
  );
}
function v5(e) {
  var t, n;
  const r = {};
  return !((t = e?.attribute) != null && t.isRequired) && "default" in (e?.attribute || {}) && (r.default = e.attribute.default), ((n = e?.attribute) == null ? void 0 : n.validate) !== void 0 && (r.validate = e.attribute.validate), [e.name, r];
}
function eDe(e, t) {
  var n;
  const r = PW(e), { nodeExtensions: i, markExtensions: o } = gh(e), s = (n = i.find((u) => ft(u, "topNode"))) == null ? void 0 : n.name, a = Object.fromEntries(
    i.map((u) => {
      const f = r.filter((S) => S.type === u.name), h = {
        name: u.name,
        options: u.options,
        storage: u.storage,
        editor: t
      }, m = e.reduce((S, _) => {
        const M = ft(_, "extendNodeSchema", h);
        return {
          ...S,
          ...M ? M(u) : {}
        };
      }, {}), g = y5({
        ...m,
        content: mn(ft(u, "content", h)),
        marks: mn(ft(u, "marks", h)),
        group: mn(ft(u, "group", h)),
        inline: mn(ft(u, "inline", h)),
        atom: mn(ft(u, "atom", h)),
        selectable: mn(ft(u, "selectable", h)),
        draggable: mn(ft(u, "draggable", h)),
        code: mn(ft(u, "code", h)),
        whitespace: mn(ft(u, "whitespace", h)),
        linebreakReplacement: mn(
          ft(u, "linebreakReplacement", h)
        ),
        defining: mn(ft(u, "defining", h)),
        isolating: mn(ft(u, "isolating", h)),
        attrs: Object.fromEntries(f.map(v5))
      }), b = mn(ft(u, "parseHTML", h));
      b && (g.parseDOM = b.map(
        (S) => g5(S, f)
      ));
      const x = ft(u, "renderHTML", h);
      x && (g.toDOM = (S) => x({
        node: S,
        HTMLAttributes: yh(S, f)
      }));
      const w = ft(u, "renderText", h);
      return w && (g.toText = w), [u.name, g];
    })
  ), c = Object.fromEntries(
    o.map((u) => {
      const f = r.filter((w) => w.type === u.name), h = {
        name: u.name,
        options: u.options,
        storage: u.storage,
        editor: t
      }, m = e.reduce((w, S) => {
        const _ = ft(S, "extendMarkSchema", h);
        return {
          ...w,
          ..._ ? _(u) : {}
        };
      }, {}), g = y5({
        ...m,
        inclusive: mn(ft(u, "inclusive", h)),
        excludes: mn(ft(u, "excludes", h)),
        group: mn(ft(u, "group", h)),
        spanning: mn(ft(u, "spanning", h)),
        code: mn(ft(u, "code", h)),
        attrs: Object.fromEntries(f.map(v5))
      }), b = mn(ft(u, "parseHTML", h));
      b && (g.parseDOM = b.map(
        (w) => g5(w, f)
      ));
      const x = ft(u, "renderHTML", h);
      return x && (g.toDOM = (w) => x({
        mark: w,
        HTMLAttributes: yh(w, f)
      })), [u.name, g];
    })
  );
  return new fH({
    topNode: s,
    nodes: a,
    marks: c
  });
}
function tDe(e) {
  const t = e.filter((n, r) => e.indexOf(n) !== r);
  return Array.from(new Set(t));
}
function rx(e) {
  return e.sort((n, r) => {
    const i = ft(n, "priority") || 100, o = ft(r, "priority") || 100;
    return i > o ? -1 : i < o ? 1 : 0;
  });
}
function jW(e) {
  const t = rx(NN(e)), n = tDe(t.map((r) => r.name));
  return n.length && console.warn(
    `[tiptap warn]: Duplicate extension names found: [${n.map((r) => `'${r}'`).join(", ")}]. This can lead to issues.`
  ), t;
}
function IW(e, t, n) {
  const { from: r, to: i } = t, { blockSeparator: o = `

`, textSerializers: s = {} } = n || {};
  let a = "";
  return e.nodesBetween(r, i, (c, u, f, h) => {
    var m;
    c.isBlock && u > r && (a += o);
    const g = s?.[c.type.name];
    if (g)
      return f && (a += g({
        node: c,
        pos: u,
        parent: f,
        index: h,
        range: t
      })), !1;
    c.isText && (a += (m = c?.text) == null ? void 0 : m.slice(Math.max(r, u) - u, i - u));
  }), a;
}
function nDe(e, t) {
  const n = {
    from: 0,
    to: e.content.size
  };
  return IW(e, n, t);
}
function zW(e) {
  return Object.fromEntries(
    Object.entries(e.nodes).filter(([, t]) => t.spec.toText).map(([t, n]) => [t, n.spec.toText])
  );
}
function rDe(e, t) {
  const n = _r(t, e.schema), { from: r, to: i } = e.selection, o = [];
  e.doc.nodesBetween(r, i, (a) => {
    o.push(a);
  });
  const s = o.reverse().find((a) => a.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function LW(e, t) {
  const n = Zw(
    typeof t == "string" ? t : t.name,
    e.schema
  );
  return n === "node" ? rDe(e, t) : n === "mark" ? RW(e, t) : {};
}
function iDe(e, t = JSON.stringify) {
  const n = {};
  return e.filter((r) => {
    const i = t(r);
    return Object.prototype.hasOwnProperty.call(n, i) ? !1 : n[i] = !0;
  });
}
function oDe(e) {
  const t = iDe(e);
  return t.length === 1 ? t : t.filter((n, r) => !t.filter((o, s) => s !== r).some((o) => n.oldRange.from >= o.oldRange.from && n.oldRange.to <= o.oldRange.to && n.newRange.from >= o.newRange.from && n.newRange.to <= o.newRange.to));
}
function BW(e) {
  const { mapping: t, steps: n } = e, r = [];
  return t.maps.forEach((i, o) => {
    const s = [];
    if (i.ranges.length)
      i.forEach((a, c) => {
        s.push({ from: a, to: c });
      });
    else {
      const { from: a, to: c } = n[o];
      if (a === void 0 || c === void 0)
        return;
      s.push({ from: a, to: c });
    }
    s.forEach(({ from: a, to: c }) => {
      const u = t.slice(o).map(a, -1), f = t.slice(o).map(c), h = t.invert().map(u, -1), m = t.invert().map(f);
      r.push({
        oldRange: {
          from: h,
          to: m
        },
        newRange: {
          from: u,
          to: f
        }
      });
    });
  }), oDe(r);
}
function ON(e, t, n) {
  const r = [];
  return e === t ? n.resolve(e).marks().forEach((i) => {
    const o = n.resolve(e), s = MN(o, i.type);
    s && r.push({
      mark: i,
      ...s
    });
  }) : n.nodesBetween(e, t, (i, o) => {
    !i || i?.nodeSize === void 0 || r.push(
      ...i.marks.map((s) => ({
        from: o,
        to: o + i.nodeSize,
        mark: s
      }))
    );
  }), r;
}
var sDe = (e, t, n, r = 20) => {
  const i = e.doc.resolve(n);
  let o = r, s = null;
  for (; o > 0 && s === null; ) {
    const a = i.node(o);
    a?.type.name === t ? s = a : o -= 1;
  }
  return [s, o];
};
function Jv(e, t) {
  return t.nodes[e] || t.marks[e] || null;
}
function B0(e, t, n) {
  return Object.fromEntries(
    Object.entries(n).filter(([r]) => {
      const i = e.find((o) => o.type === t && o.name === r);
      return i ? i.attribute.keepOnSplit : !1;
    })
  );
}
var aDe = (e, t = 500) => {
  let n = "";
  const r = e.parentOffset;
  return e.parent.nodesBetween(Math.max(0, r - t), r, (i, o, s, a) => {
    var c, u;
    const f = ((u = (c = i.type.spec).toText) == null ? void 0 : u.call(c, {
      node: i,
      pos: o,
      parent: s,
      index: a
    })) || i.textContent || "%leaf%";
    n += i.isAtom && !i.isText ? f : f.slice(0, Math.max(0, r - o));
  }), n;
};
function xT(e, t, n = {}) {
  const { empty: r, ranges: i } = e.selection, o = t ? sl(t, e.schema) : null;
  if (r)
    return !!(e.storedMarks || e.selection.$from.marks()).filter((h) => o ? o.name === h.type.name : !0).find((h) => nx(h.attrs, n, { strict: !1 }));
  let s = 0;
  const a = [];
  if (i.forEach(({ $from: h, $to: m }) => {
    const g = h.pos, b = m.pos;
    e.doc.nodesBetween(g, b, (x, w) => {
      if (!x.isText && !x.marks.length)
        return;
      const S = Math.max(g, w), _ = Math.min(b, w + x.nodeSize), M = _ - S;
      s += M, a.push(
        ...x.marks.map((N) => ({
          mark: N,
          from: S,
          to: _
        }))
      );
    });
  }), s === 0)
    return !1;
  const c = a.filter((h) => o ? o.name === h.mark.type.name : !0).filter((h) => nx(h.mark.attrs, n, { strict: !1 })).reduce((h, m) => h + m.to - m.from, 0), u = a.filter((h) => o ? h.mark.type !== o && h.mark.type.excludes(o) : !0).reduce((h, m) => h + m.to - m.from, 0);
  return (c > 0 ? c + u : c) >= s;
}
function lDe(e, t, n = {}) {
  if (!t)
    return Dc(e, null, n) || xT(e, null, n);
  const r = Zw(t, e.schema);
  return r === "node" ? Dc(e, t, n) : r === "mark" ? xT(e, t, n) : !1;
}
var cDe = (e, t) => {
  const { $from: n, $to: r, $anchor: i } = e.selection;
  if (t) {
    const o = Yw((a) => a.type.name === t)(e.selection);
    if (!o)
      return !1;
    const s = e.doc.resolve(o.pos + 1);
    return i.pos + 1 === s.end();
  }
  return !(r.parentOffset < r.parent.nodeSize - 2 || n.pos !== r.pos);
}, uDe = (e) => {
  const { $from: t, $to: n } = e.selection;
  return !(t.parentOffset > 0 || t.pos !== n.pos);
};
function b5(e, t) {
  return Array.isArray(t) ? t.some((n) => (typeof n == "string" ? n : n.name) === e.name) : t;
}
function x5(e, t) {
  const { nodeExtensions: n } = gh(t), r = n.find((s) => s.name === e);
  if (!r)
    return !1;
  const i = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, o = mn(ft(r, "group", i));
  return typeof o != "string" ? !1 : o.split(" ").includes("list");
}
function Xw(e, {
  checkChildren: t = !0,
  ignoreWhitespace: n = !1
} = {}) {
  var r;
  if (n) {
    if (e.type.name === "hardBreak")
      return !0;
    if (e.isText)
      return /^\s*$/m.test((r = e.text) != null ? r : "");
  }
  if (e.isText)
    return !e.text;
  if (e.isAtom || e.isLeaf)
    return !1;
  if (e.content.childCount === 0)
    return !0;
  if (t) {
    let i = !0;
    return e.content.forEach((o) => {
      i !== !1 && (Xw(o, { ignoreWhitespace: n, checkChildren: t }) || (i = !1));
    }), i;
  }
  return !1;
}
function $W(e) {
  return e instanceof ht;
}
var UW = class FW {
  constructor(t) {
    this.position = t;
  }
  /**
   * Creates a MappablePosition from a JSON object.
   */
  static fromJSON(t) {
    return new FW(t.position);
  }
  /**
   * Converts the MappablePosition to a JSON object.
   */
  toJSON() {
    return {
      position: this.position
    };
  }
};
function dDe(e, t) {
  const n = t.mapping.mapResult(e.position);
  return {
    position: new UW(n.pos),
    mapResult: n
  };
}
function fDe(e) {
  return new UW(e);
}
function hDe(e, t, n) {
  var r;
  const { selection: i } = t;
  let o = null;
  if (TW(i) && (o = i.$cursor), o) {
    const a = (r = e.storedMarks) != null ? r : o.marks();
    return o.parent.type.allowsMarkType(n) && (!!n.isInSet(a) || !a.some((u) => u.type.excludes(n)));
  }
  const { ranges: s } = i;
  return s.some(({ $from: a, $to: c }) => {
    let u = a.depth === 0 ? e.doc.inlineContent && e.doc.type.allowsMarkType(n) : !1;
    return e.doc.nodesBetween(a.pos, c.pos, (f, h, m) => {
      if (u)
        return !1;
      if (f.isInline) {
        const g = !m || m.type.allowsMarkType(n), b = !!n.isInSet(f.marks) || !f.marks.some((x) => x.type.excludes(n));
        u = g && b;
      }
      return !u;
    }), u;
  });
}
var pDe = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const { selection: o } = n, { empty: s, ranges: a } = o, c = sl(e, r.schema);
  if (i)
    if (s) {
      const u = RW(r, c);
      n.addStoredMark(
        c.create({
          ...u,
          ...t
        })
      );
    } else
      a.forEach((u) => {
        const f = u.$from.pos, h = u.$to.pos;
        r.doc.nodesBetween(f, h, (m, g) => {
          const b = Math.max(g, f), x = Math.min(g + m.nodeSize, h);
          m.marks.find((S) => S.type === c) ? m.marks.forEach((S) => {
            c === S.type && n.addMark(
              b,
              x,
              c.create({
                ...S.attrs,
                ...t
              })
            );
          }) : n.addMark(b, x, c.create(t));
        });
      });
  return hDe(r, n, c);
}, mDe = (e, t) => ({ tr: n }) => (n.setMeta(e, t), !0), gDe = (e, t = {}) => ({ state: n, dispatch: r, chain: i }) => {
  const o = _r(e, n.schema);
  let s;
  return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), o.isTextblock ? i().command(({ commands: a }) => PL(o, { ...s, ...t })(n) ? !0 : a.clearNodes()).command(({ state: a }) => PL(o, { ...s, ...t })(a, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, yDe = (e) => ({ tr: t, dispatch: n }) => {
  if (n) {
    const { doc: r } = t, i = Lu(e, 0, r.content.size), o = ht.create(r, i);
    t.setSelection(o);
  }
  return !0;
}, vDe = (e, t) => ({ tr: n, state: r, dispatch: i }) => {
  const { selection: o } = r;
  let s, a;
  return typeof t == "number" ? (s = t, a = t) : t && "from" in t && "to" in t ? (s = t.from, a = t.to) : (s = o.from, a = o.to), i && n.doc.nodesBetween(s, a, (c, u) => {
    c.isText || n.setNodeMarkup(u, void 0, {
      ...c.attrs,
      dir: e
    });
  }), !0;
}, bDe = (e) => ({ tr: t, dispatch: n }) => {
  if (n) {
    const { doc: r } = t, { from: i, to: o } = typeof e == "number" ? { from: e, to: e } : e, s = kt.atStart(r).from, a = kt.atEnd(r).to, c = Lu(i, s, a), u = Lu(o, s, a), f = kt.create(r, c, u);
    t.setSelection(f);
  }
  return !0;
}, xDe = (e) => ({ state: t, dispatch: n }) => {
  const r = _r(e, t.schema);
  return hRe(r)(t, n);
};
function w5(e, t) {
  const n = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks();
  if (n) {
    const r = n.filter((i) => t?.includes(i.type.name));
    e.tr.ensureMarks(r);
  }
}
var wDe = ({ keepMarks: e = !0 } = {}) => ({ tr: t, state: n, dispatch: r, editor: i }) => {
  const { selection: o, doc: s } = t, { $from: a, $to: c } = o, u = i.extensionManager.attributes, f = B0(u, a.node().type.name, a.node().attrs);
  if (o instanceof ht && o.node.isBlock)
    return !a.parentOffset || !Ga(s, a.pos) ? !1 : (r && (e && w5(n, i.extensionManager.splittableMarks), t.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const h = c.parentOffset === c.parent.content.size, m = a.depth === 0 ? void 0 : ZOe(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let g = h && m ? [
    {
      type: m,
      attrs: f
    }
  ] : void 0, b = Ga(t.doc, t.mapping.map(a.pos), 1, g);
  if (!g && !b && Ga(t.doc, t.mapping.map(a.pos), 1, m ? [{ type: m }] : void 0) && (b = !0, g = m ? [
    {
      type: m,
      attrs: f
    }
  ] : void 0), r) {
    if (b && (o instanceof kt && t.deleteSelection(), t.split(t.mapping.map(a.pos), 1, g), m && !h && !a.parentOffset && a.parent.type !== m)) {
      const x = t.mapping.map(a.before()), w = t.doc.resolve(x);
      a.node(-1).canReplaceWith(w.index(), w.index() + 1, m) && t.setNodeMarkup(t.mapping.map(a.before()), m);
    }
    e && w5(n, i.extensionManager.splittableMarks), t.scrollIntoView();
  }
  return b;
}, SDe = (e, t = {}) => ({ tr: n, state: r, dispatch: i, editor: o }) => {
  var s;
  const a = _r(e, r.schema), { $from: c, $to: u } = r.selection, f = r.selection.node;
  if (f && f.isBlock || c.depth < 2 || !c.sameParent(u))
    return !1;
  const h = c.node(-1);
  if (h.type !== a)
    return !1;
  const m = o.extensionManager.attributes;
  if (c.parent.content.size === 0 && c.node(-1).childCount === c.indexAfter(-1)) {
    if (c.depth === 2 || c.node(-3).type !== a || c.index(-2) !== c.node(-2).childCount - 1)
      return !1;
    if (i) {
      let S = $e.empty;
      const _ = c.index(-1) ? 1 : c.index(-2) ? 2 : 3;
      for (let L = c.depth - _; L >= c.depth - 3; L -= 1)
        S = $e.from(c.node(L).copy(S));
      const M = (
        // eslint-disable-next-line no-nested-ternary
        c.indexAfter(-1) < c.node(-2).childCount ? 1 : c.indexAfter(-2) < c.node(-3).childCount ? 2 : 3
      ), N = {
        ...B0(m, c.node().type.name, c.node().attrs),
        ...t
      }, P = ((s = a.contentMatch.defaultType) == null ? void 0 : s.createAndFill(N)) || void 0;
      S = S.append($e.from(a.createAndFill(null, P) || void 0));
      const I = c.before(c.depth - (_ - 1));
      n.replace(I, c.after(-M), new Qe(S, 4 - _, 0));
      let O = -1;
      n.doc.nodesBetween(I, n.doc.content.size, (L, U) => {
        if (O > -1)
          return !1;
        L.isTextblock && L.content.size === 0 && (O = U + 1);
      }), O > -1 && n.setSelection(kt.near(n.doc.resolve(O))), n.scrollIntoView();
    }
    return !0;
  }
  const g = u.pos === c.end() ? h.contentMatchAt(0).defaultType : null, b = {
    ...B0(m, h.type.name, h.attrs),
    ...t
  }, x = {
    ...B0(m, c.node().type.name, c.node().attrs),
    ...t
  };
  n.delete(c.pos, u.pos);
  const w = g ? [
    { type: a, attrs: b },
    { type: g, attrs: x }
  ] : [{ type: a, attrs: b }];
  if (!Ga(n.doc, c.pos, 2))
    return !1;
  if (i) {
    const { selection: S, storedMarks: _ } = r, { splittableMarks: M } = o.extensionManager, N = _ || S.$to.parentOffset && S.$from.marks();
    if (n.split(c.pos, 2, w).scrollIntoView(), !N || !i)
      return !0;
    const P = N.filter((I) => M.includes(I.type.name));
    n.ensureMarks(P);
  }
  return !0;
}, XC = (e, t) => {
  const n = Yw((s) => s.type === t)(e.selection);
  if (!n)
    return !0;
  const r = e.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const i = e.doc.nodeAt(r);
  return n.node.type === i?.type && Vc(e.doc, n.pos) && e.join(n.pos), !0;
}, JC = (e, t) => {
  const n = Yw((s) => s.type === t)(e.selection);
  if (!n)
    return !0;
  const r = e.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const i = e.doc.nodeAt(r);
  return n.node.type === i?.type && Vc(e.doc, r) && e.join(r), !0;
}, kDe = (e, t, n, r = {}) => ({ editor: i, tr: o, state: s, dispatch: a, chain: c, commands: u, can: f }) => {
  const { extensions: h, splittableMarks: m } = i.extensionManager, g = _r(e, s.schema), b = _r(t, s.schema), { selection: x, storedMarks: w } = s, { $from: S, $to: _ } = x, M = S.blockRange(_), N = w || x.$to.parentOffset && x.$from.marks();
  if (!M)
    return !1;
  const P = Yw((I) => x5(I.type.name, h))(x);
  if (M.depth >= 1 && P && M.depth - P.depth <= 1) {
    if (P.node.type === g)
      return u.liftListItem(b);
    if (x5(P.node.type.name, h) && g.validContent(P.node.content) && a)
      return c().command(() => (o.setNodeMarkup(P.pos, g), !0)).command(() => XC(o, g)).command(() => JC(o, g)).run();
  }
  return !n || !N || !a ? c().command(() => f().wrapInList(g, r) ? !0 : u.clearNodes()).wrapInList(g, r).command(() => XC(o, g)).command(() => JC(o, g)).run() : c().command(() => {
    const I = f().wrapInList(g, r), O = N.filter((L) => m.includes(L.type.name));
    return o.ensureMarks(O), I ? !0 : u.clearNodes();
  }).wrapInList(g, r).command(() => XC(o, g)).command(() => JC(o, g)).run();
}, CDe = (e, t = {}, n = {}) => ({ state: r, commands: i }) => {
  const { extendEmptyMarkRange: o = !1 } = n, s = sl(e, r.schema);
  return xT(r, s, t) ? i.unsetMark(s, { extendEmptyMarkRange: o }) : i.setMark(s, t);
}, EDe = (e, t, n = {}) => ({ state: r, commands: i }) => {
  const o = _r(e, r.schema), s = _r(t, r.schema), a = Dc(r, o, n);
  let c;
  return r.selection.$anchor.sameParent(r.selection.$head) && (c = r.selection.$anchor.parent.attrs), a ? i.setNode(s, c) : i.setNode(o, { ...c, ...n });
}, _De = (e, t = {}) => ({ state: n, commands: r }) => {
  const i = _r(e, n.schema);
  return Dc(n, i, t) ? r.lift(i) : r.wrapIn(i, t);
}, TDe = () => ({ state: e, dispatch: t }) => {
  const n = e.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const i = n[r];
    let o;
    if (i.spec.isInputRules && (o = i.getState(e))) {
      if (t) {
        const s = e.tr, a = o.transform;
        for (let c = a.steps.length - 1; c >= 0; c -= 1)
          s.step(a.steps[c].invert(a.docs[c]));
        if (o.text) {
          const c = s.doc.resolve(o.from).marks();
          s.replaceWith(o.from, o.to, e.schema.text(o.text, c));
        } else
          s.delete(o.from, o.to);
      }
      return !0;
    }
  }
  return !1;
}, ADe = () => ({ tr: e, dispatch: t }) => {
  const { selection: n } = e, { empty: r, ranges: i } = n;
  return r || t && i.forEach((o) => {
    e.removeMark(o.$from.pos, o.$to.pos);
  }), !0;
}, MDe = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  var o;
  const { extendEmptyMarkRange: s = !1 } = t, { selection: a } = n, c = sl(e, r.schema), { $from: u, empty: f, ranges: h } = a;
  if (!i)
    return !0;
  if (f && s) {
    let { from: m, to: g } = a;
    const b = (o = u.marks().find((w) => w.type === c)) == null ? void 0 : o.attrs, x = MN(u, c, b);
    x && (m = x.from, g = x.to), n.removeMark(m, g, c);
  } else
    h.forEach((m) => {
      n.removeMark(m.$from.pos, m.$to.pos, c);
    });
  return n.removeStoredMark(c), !0;
}, NDe = (e) => ({ tr: t, state: n, dispatch: r }) => {
  const { selection: i } = n;
  let o, s;
  return typeof e == "number" ? (o = e, s = e) : e && "from" in e && "to" in e ? (o = e.from, s = e.to) : (o = i.from, s = i.to), r && t.doc.nodesBetween(o, s, (a, c) => {
    if (a.isText)
      return;
    const u = { ...a.attrs };
    delete u.dir, t.setNodeMarkup(c, void 0, u);
  }), !0;
}, RDe = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  let o = null, s = null;
  const a = Zw(
    typeof e == "string" ? e : e.name,
    r.schema
  );
  if (!a)
    return !1;
  a === "node" && (o = _r(e, r.schema)), a === "mark" && (s = sl(e, r.schema));
  let c = !1;
  return n.selection.ranges.forEach((u) => {
    const f = u.$from.pos, h = u.$to.pos;
    let m, g, b, x;
    n.selection.empty ? r.doc.nodesBetween(f, h, (w, S) => {
      o && o === w.type && (c = !0, b = Math.max(S, f), x = Math.min(S + w.nodeSize, h), m = S, g = w);
    }) : r.doc.nodesBetween(f, h, (w, S) => {
      S < f && o && o === w.type && (c = !0, b = Math.max(S, f), x = Math.min(S + w.nodeSize, h), m = S, g = w), S >= f && S <= h && (o && o === w.type && (c = !0, i && n.setNodeMarkup(S, void 0, {
        ...w.attrs,
        ...t
      })), s && w.marks.length && w.marks.forEach((_) => {
        if (s === _.type && (c = !0, i)) {
          const M = Math.max(S, f), N = Math.min(S + w.nodeSize, h);
          n.addMark(
            M,
            N,
            s.create({
              ..._.attrs,
              ...t
            })
          );
        }
      }));
    }), g && (m !== void 0 && i && n.setNodeMarkup(m, void 0, {
      ...g.attrs,
      ...t
    }), s && g.marks.length && g.marks.forEach((w) => {
      s === w.type && i && n.addMark(
        b,
        x,
        s.create({
          ...w.attrs,
          ...t
        })
      );
    }));
  }), c;
}, ODe = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const i = _r(e, n.schema);
  return sRe(i, t)(n, r);
}, DDe = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const i = _r(e, n.schema);
  return aRe(i, t)(n, r);
}, PDe = class {
  constructor() {
    this.callbacks = {};
  }
  on(e, t) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
  }
  emit(e, ...t) {
    const n = this.callbacks[e];
    return n && n.forEach((r) => r.apply(this, t)), this;
  }
  off(e, t) {
    const n = this.callbacks[e];
    return n && (t ? this.callbacks[e] = n.filter((r) => r !== t) : delete this.callbacks[e]), this;
  }
  once(e, t) {
    const n = (...r) => {
      this.off(e, n), t.apply(this, r);
    };
    return this.on(e, n);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}, Jw = class {
  constructor(e) {
    var t;
    this.find = e.find, this.handler = e.handler, this.undoable = (t = e.undoable) != null ? t : !0;
  }
}, jDe = (e, t) => {
  if (AN(t))
    return t.exec(e);
  const n = t(e);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = e, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function Qv(e) {
  var t;
  const { editor: n, from: r, to: i, text: o, rules: s, plugin: a } = e, { view: c } = n;
  if (c.composing)
    return !1;
  const u = c.state.doc.resolve(r);
  if (
    // check for code node
    u.parent.type.spec.code || (t = u.nodeBefore || u.nodeAfter) != null && t.marks.find((m) => m.type.spec.code)
  )
    return !1;
  let f = !1;
  const h = aDe(u) + o;
  return s.forEach((m) => {
    if (f)
      return;
    const g = jDe(h, m.find);
    if (!g)
      return;
    const b = c.state.tr, x = Gw({
      state: c.state,
      transaction: b
    }), w = {
      from: r - (g[0].length - o.length),
      to: i
    }, { commands: S, chain: _, can: M } = new Kw({
      editor: n,
      state: x
    });
    m.handler({
      state: x,
      range: w,
      match: g,
      commands: S,
      chain: _,
      can: M
    }) === null || !b.steps.length || (m.undoable && b.setMeta(a, {
      transform: b,
      from: r,
      to: i,
      text: o
    }), c.dispatch(b), f = !0);
  }), f;
}
function IDe(e) {
  const { editor: t, rules: n } = e, r = new Zn({
    state: {
      init() {
        return null;
      },
      apply(i, o, s) {
        const a = i.getMeta(r);
        if (a)
          return a;
        const c = i.getMeta("applyInputRules");
        return c && setTimeout(() => {
          let { text: f } = c;
          typeof f == "string" ? f = f : f = RN($e.from(f), s.schema);
          const { from: h } = c, m = h + f.length;
          Qv({
            editor: t,
            from: h,
            to: m,
            text: f,
            rules: n,
            plugin: r
          });
        }), i.selectionSet || i.docChanged ? null : o;
      }
    },
    props: {
      handleTextInput(i, o, s, a) {
        return Qv({
          editor: t,
          from: o,
          to: s,
          text: a,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (i) => (setTimeout(() => {
          const { $cursor: o } = i.state.selection;
          o && Qv({
            editor: t,
            from: o.pos,
            to: o.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(i, o) {
        if (o.key !== "Enter")
          return !1;
        const { $cursor: s } = i.state.selection;
        return s ? Qv({
          editor: t,
          from: s.pos,
          to: s.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function zDe(e) {
  return Object.prototype.toString.call(e).slice(8, -1);
}
function e0(e) {
  return zDe(e) !== "Object" ? !1 : e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype;
}
function VW(e, t) {
  const n = { ...e };
  return e0(e) && e0(t) && Object.keys(t).forEach((r) => {
    e0(t[r]) && e0(e[r]) ? n[r] = VW(e[r], t[r]) : n[r] = t[r];
  }), n;
}
var DN = class {
  constructor(e = {}) {
    this.type = "extendable", this.parent = null, this.child = null, this.name = "", this.config = {
      name: this.name
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name;
  }
  get options() {
    return {
      ...mn(
        ft(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...mn(
        ft(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => VW(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new this.constructor({ ...this.config, ...e });
    return t.parent = this, this.child = t, t.name = "name" in e ? e.name : t.parent.name, t;
  }
}, gd = class HW extends DN {
  constructor() {
    super(...arguments), this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new HW(n);
  }
  static handleExit({ editor: t, mark: n }) {
    const { tr: r } = t.state, i = t.state.selection.$from;
    if (i.pos === i.end()) {
      const s = i.marks();
      if (!!!s.find((u) => u?.type.name === n.name))
        return !1;
      const c = s.find((u) => u?.type.name === n.name);
      return c && r.removeStoredMark(c), r.insertText(" ", i.pos), t.view.dispatch(r), !0;
    }
    return !1;
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
};
function LDe(e) {
  return typeof e == "number";
}
var BDe = class {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}, $De = (e, t, n) => {
  if (AN(t))
    return [...e.matchAll(t)];
  const r = t(e, n);
  return r ? r.map((i) => {
    const o = [i.text];
    return o.index = i.index, o.input = e, o.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), o.push(i.replaceWith)), o;
  }) : [];
};
function UDe(e) {
  const { editor: t, state: n, from: r, to: i, rule: o, pasteEvent: s, dropEvent: a } = e, { commands: c, chain: u, can: f } = new Kw({
    editor: t,
    state: n
  }), h = [];
  return n.doc.nodesBetween(r, i, (g, b) => {
    var x, w, S, _, M;
    if ((w = (x = g.type) == null ? void 0 : x.spec) != null && w.code || !(g.isText || g.isTextblock || g.isInline))
      return;
    const N = (M = (_ = (S = g.content) == null ? void 0 : S.size) != null ? _ : g.nodeSize) != null ? M : 0, P = Math.max(r, b), I = Math.min(i, b + N);
    if (P >= I)
      return;
    const O = g.isText ? g.text || "" : g.textBetween(P - b, I - b, void 0, "");
    $De(O, o.find, s).forEach((U) => {
      if (U.index === void 0)
        return;
      const B = P + U.index + 1, G = B + U[0].length, Y = {
        from: n.tr.mapping.map(B),
        to: n.tr.mapping.map(G)
      }, he = o.handler({
        state: n,
        range: Y,
        match: U,
        commands: c,
        chain: u,
        can: f,
        pasteEvent: s,
        dropEvent: a
      });
      h.push(he);
    });
  }), h.every((g) => g !== null);
}
var t0 = null, FDe = (e) => {
  var t;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (t = n.clipboardData) == null || t.setData("text/html", e), n;
};
function VDe(e) {
  const { editor: t, rules: n } = e;
  let r = null, i = !1, o = !1, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const c = ({
    state: f,
    from: h,
    to: m,
    rule: g,
    pasteEvt: b
  }) => {
    const x = f.tr, w = Gw({
      state: f,
      transaction: x
    });
    if (!(!UDe({
      editor: t,
      state: w,
      from: Math.max(h - 1, 0),
      to: m.b - 1,
      rule: g,
      pasteEvent: b,
      dropEvent: a
    }) || !x.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, x;
    }
  };
  return n.map((f) => new Zn({
    // we register a global drag handler to track the current drag source element
    view(h) {
      const m = (b) => {
        var x;
        r = (x = h.dom.parentElement) != null && x.contains(b.target) ? h.dom.parentElement : null, r && (t0 = t);
      }, g = () => {
        t0 && (t0 = null);
      };
      return window.addEventListener("dragstart", m), window.addEventListener("dragend", g), {
        destroy() {
          window.removeEventListener("dragstart", m), window.removeEventListener("dragend", g);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (h, m) => {
          if (o = r === h.dom.parentElement, a = m, !o) {
            const g = t0;
            g?.isEditable && setTimeout(() => {
              const b = g.state.selection;
              b && g.commands.deleteRange({ from: b.from, to: b.to });
            }, 10);
          }
          return !1;
        },
        paste: (h, m) => {
          var g;
          const b = (g = m.clipboardData) == null ? void 0 : g.getData("text/html");
          return s = m, i = !!b?.includes("data-pm-slice"), !1;
        }
      }
    },
    appendTransaction: (h, m, g) => {
      const b = h[0], x = b.getMeta("uiEvent") === "paste" && !i, w = b.getMeta("uiEvent") === "drop" && !o, S = b.getMeta("applyPasteRules"), _ = !!S;
      if (!x && !w && !_)
        return;
      if (_) {
        let { text: P } = S;
        typeof P == "string" ? P = P : P = RN($e.from(P), g.schema);
        const { from: I } = S, O = I + P.length, L = FDe(P);
        return c({
          rule: f,
          state: g,
          from: I,
          to: { b: O },
          pasteEvt: L
        });
      }
      const M = m.doc.content.findDiffStart(g.doc.content), N = m.doc.content.findDiffEnd(g.doc.content);
      if (!(!LDe(M) || !N || M === N.b))
        return c({
          rule: f,
          state: g,
          from: M,
          to: N,
          pasteEvt: s
        });
    }
  }));
}
var Qw = class {
  constructor(e, t) {
    this.splittableMarks = [], this.editor = t, this.baseExtensions = e, this.extensions = jW(e), this.schema = eDe(this.extensions, t), this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, t) => {
      const n = {
        name: t.name,
        options: t.options,
        storage: this.editor.extensionStorage[t.name],
        editor: this.editor,
        type: Jv(t.name, this.schema)
      }, r = ft(t, "addCommands", n);
      return r ? {
        ...e,
        ...r()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this;
    return rx([...this.extensions].reverse()).flatMap((r) => {
      const i = {
        name: r.name,
        options: r.options,
        storage: this.editor.extensionStorage[r.name],
        editor: e,
        type: Jv(r.name, this.schema)
      }, o = [], s = ft(
        r,
        "addKeyboardShortcuts",
        i
      );
      let a = {};
      if (r.type === "mark" && ft(r, "exitable", i) && (a.ArrowRight = () => gd.handleExit({ editor: e, mark: r })), s) {
        const m = Object.fromEntries(
          Object.entries(s()).map(([g, b]) => [g, () => b({ editor: e })])
        );
        a = { ...a, ...m };
      }
      const c = rOe(a);
      o.push(c);
      const u = ft(r, "addInputRules", i);
      if (b5(r, e.options.enableInputRules) && u) {
        const m = u();
        if (m && m.length) {
          const g = IDe({
            editor: e,
            rules: m
          }), b = Array.isArray(g) ? g : [g];
          o.push(...b);
        }
      }
      const f = ft(r, "addPasteRules", i);
      if (b5(r, e.options.enablePasteRules) && f) {
        const m = f();
        if (m && m.length) {
          const g = VDe({ editor: e, rules: m });
          o.push(...g);
        }
      }
      const h = ft(
        r,
        "addProseMirrorPlugins",
        i
      );
      if (h) {
        const m = h();
        o.push(...m);
      }
      return o;
    });
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return PW(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: t } = gh(this.extensions);
    return Object.fromEntries(
      t.filter((n) => !!ft(n, "addNodeView")).map((n) => {
        const r = this.attributes.filter((c) => c.type === n.name), i = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: e,
          type: _r(n.name, this.schema)
        }, o = ft(n, "addNodeView", i);
        if (!o)
          return [];
        const s = o();
        if (!s)
          return [];
        const a = (c, u, f, h, m) => {
          const g = yh(c, r);
          return s({
            // pass-through
            node: c,
            view: u,
            getPos: f,
            decorations: h,
            innerDecorations: m,
            // tiptap-specific
            editor: e,
            extension: n,
            HTMLAttributes: g
          });
        };
        return [n.name, a];
      })
    );
  }
  /**
   * Get the composed dispatchTransaction function from all extensions.
   * @param baseDispatch The base dispatch function (e.g. from the editor or user props)
   * @returns A composed dispatch function
   */
  dispatchTransaction(e) {
    const { editor: t } = this;
    return rx([...this.extensions].reverse()).reduceRight((r, i) => {
      const o = {
        name: i.name,
        options: i.options,
        storage: this.editor.extensionStorage[i.name],
        editor: t,
        type: Jv(i.name, this.schema)
      }, s = ft(
        i,
        "dispatchTransaction",
        o
      );
      return s ? (a) => {
        s.call(o, { transaction: a, next: r });
      } : r;
    }, e);
  }
  get markViews() {
    const { editor: e } = this, { markExtensions: t } = gh(this.extensions);
    return Object.fromEntries(
      t.filter((n) => !!ft(n, "addMarkView")).map((n) => {
        const r = this.attributes.filter((a) => a.type === n.name), i = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: e,
          type: sl(n.name, this.schema)
        }, o = ft(n, "addMarkView", i);
        if (!o)
          return [];
        const s = (a, c, u) => {
          const f = yh(a, r);
          return o()({
            // pass-through
            mark: a,
            view: c,
            inline: u,
            // tiptap-specific
            editor: e,
            extension: n,
            HTMLAttributes: f,
            updateAttributes: (h) => {
              iPe(a, e, h);
            }
          });
        };
        return [n.name, s];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const e = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      e.map((t) => [t.name, t.storage])
    ), e.forEach((t) => {
      var n;
      const r = {
        name: t.name,
        options: t.options,
        storage: this.editor.extensionStorage[t.name],
        editor: this.editor,
        type: Jv(t.name, this.schema)
      };
      t.type === "mark" && ((n = mn(ft(t, "keepOnSplit", r))) == null || n) && this.splittableMarks.push(t.name);
      const i = ft(t, "onBeforeCreate", r), o = ft(t, "onCreate", r), s = ft(t, "onUpdate", r), a = ft(
        t,
        "onSelectionUpdate",
        r
      ), c = ft(t, "onTransaction", r), u = ft(t, "onFocus", r), f = ft(t, "onBlur", r), h = ft(t, "onDestroy", r);
      i && this.editor.on("beforeCreate", i), o && this.editor.on("create", o), s && this.editor.on("update", s), a && this.editor.on("selectionUpdate", a), c && this.editor.on("transaction", c), u && this.editor.on("focus", u), f && this.editor.on("blur", f), h && this.editor.on("destroy", h);
    });
  }
};
Qw.resolve = jW;
Qw.sort = rx;
Qw.flatten = NN;
var HDe = {};
TN(HDe, {
  ClipboardTextSerializer: () => qW,
  Commands: () => GW,
  Delete: () => KW,
  Drop: () => ZW,
  Editable: () => YW,
  FocusEvents: () => JW,
  Keymap: () => QW,
  Paste: () => eq,
  Tabindex: () => tq,
  TextDirection: () => nq,
  focusEventsPluginKey: () => XW
});
var hr = class WW extends DN {
  constructor() {
    super(...arguments), this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new WW(n);
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
}, qW = hr.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: e } = this, { state: t, schema: n } = e, { doc: r, selection: i } = t, { ranges: o } = i, s = Math.min(...o.map((f) => f.$from.pos)), a = Math.max(...o.map((f) => f.$to.pos)), c = zW(n);
            return IW(r, { from: s, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: c
            });
          }
        }
      })
    ];
  }
}), GW = hr.create({
  name: "commands",
  addCommands() {
    return {
      ...EW
    };
  }
}), KW = hr.create({
  name: "delete",
  onUpdate({ transaction: e, appendedTransactions: t }) {
    var n, r, i;
    const o = () => {
      var s, a, c, u;
      if ((u = (c = (a = (s = this.editor.options.coreExtensionOptions) == null ? void 0 : s.delete) == null ? void 0 : a.filterTransaction) == null ? void 0 : c.call(a, e)) != null ? u : e.getMeta("y-sync$"))
        return;
      const f = OW(e.before, [e, ...t]);
      BW(f).forEach((g) => {
        f.mapping.mapResult(g.oldRange.from).deletedAfter && f.mapping.mapResult(g.oldRange.to).deletedBefore && f.before.nodesBetween(g.oldRange.from, g.oldRange.to, (b, x) => {
          const w = x + b.nodeSize - 2, S = g.oldRange.from <= x && w <= g.oldRange.to;
          this.editor.emit("delete", {
            type: "node",
            node: b,
            from: x,
            to: w,
            newFrom: f.mapping.map(x),
            newTo: f.mapping.map(w),
            deletedRange: g.oldRange,
            newRange: g.newRange,
            partial: !S,
            editor: this.editor,
            transaction: e,
            combinedTransform: f
          });
        });
      });
      const m = f.mapping;
      f.steps.forEach((g, b) => {
        var x, w;
        if (g instanceof cs) {
          const S = m.slice(b).map(g.from, -1), _ = m.slice(b).map(g.to), M = m.invert().map(S, -1), N = m.invert().map(_), P = (x = f.doc.nodeAt(S - 1)) == null ? void 0 : x.marks.some((O) => O.eq(g.mark)), I = (w = f.doc.nodeAt(_)) == null ? void 0 : w.marks.some((O) => O.eq(g.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: g.mark,
            from: g.from,
            to: g.to,
            deletedRange: {
              from: M,
              to: N
            },
            newRange: {
              from: S,
              to: _
            },
            partial: !!(I || P),
            editor: this.editor,
            transaction: e,
            combinedTransform: f
          });
        }
      });
    };
    (i = (r = (n = this.editor.options.coreExtensionOptions) == null ? void 0 : n.delete) == null ? void 0 : r.async) == null || i ? setTimeout(o, 0) : o();
  }
}), ZW = hr.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("tiptapDrop"),
        props: {
          handleDrop: (e, t, n, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: t,
              slice: n,
              moved: r
            });
          }
        }
      })
    ];
  }
}), YW = hr.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), XW = new Tr("focusEvents"), JW = hr.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: e } = this;
    return [
      new Zn({
        key: XW,
        props: {
          handleDOMEvents: {
            focus: (t, n) => {
              e.isFocused = !0;
              const r = e.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return t.dispatch(r), !1;
            },
            blur: (t, n) => {
              e.isFocused = !1;
              const r = e.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return t.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), QW = hr.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const e = () => this.editor.commands.first(({ commands: s }) => [
      () => s.undoInputRule(),
      // maybe convert first text block node to default node
      () => s.command(({ tr: a }) => {
        const { selection: c, doc: u } = a, { empty: f, $anchor: h } = c, { pos: m, parent: g } = h, b = h.parent.isTextblock && m > 0 ? a.doc.resolve(m - 1) : h, x = b.parent.type.spec.isolating, w = h.pos - h.parentOffset, S = x && b.parent.childCount === 1 ? w === h.pos : zt.atStart(u).from === m;
        return !f || !g.type.isTextblock || g.textContent.length || !S || S && h.parent.type.name === "paragraph" ? !1 : s.clearNodes();
      }),
      () => s.deleteSelection(),
      () => s.joinBackward(),
      () => s.selectNodeBackward()
    ]), t = () => this.editor.commands.first(({ commands: s }) => [
      () => s.deleteSelection(),
      () => s.deleteCurrentNode(),
      () => s.joinForward(),
      () => s.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: s }) => [
        () => s.newlineInCode(),
        () => s.createParagraphNear(),
        () => s.liftEmptyBlock(),
        () => s.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: e,
      "Mod-Backspace": e,
      "Shift-Backspace": e,
      Delete: t,
      "Mod-Delete": t,
      "Mod-a": () => this.editor.commands.selectAll()
    }, i = {
      ...r
    }, o = {
      ...r,
      "Ctrl-h": e,
      "Alt-Backspace": e,
      "Ctrl-d": t,
      "Ctrl-Alt-Backspace": t,
      "Alt-Delete": t,
      "Alt-d": t,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return Sg() || NW() ? o : i;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new Zn({
        key: new Tr("clearDocument"),
        appendTransaction: (e, t, n) => {
          if (e.some((x) => x.getMeta("composition")))
            return;
          const r = e.some((x) => x.docChanged) && !t.doc.eq(n.doc), i = e.some((x) => x.getMeta("preventClearDocument"));
          if (!r || i)
            return;
          const { empty: o, from: s, to: a } = t.selection, c = zt.atStart(t.doc).from, u = zt.atEnd(t.doc).to;
          if (o || !(s === c && a === u) || !Xw(n.doc))
            return;
          const m = n.tr, g = Gw({
            state: n,
            transaction: m
          }), { commands: b } = new Kw({
            editor: this.editor,
            state: g
          });
          if (b.clearNodes(), !!m.steps.length)
            return m;
        }
      })
    ];
  }
}), eq = hr.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("tiptapPaste"),
        props: {
          handlePaste: (e, t, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: t,
              slice: n
            });
          }
        }
      })
    ];
  }
}), tq = hr.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
}), nq = hr.create({
  name: "textDirection",
  addOptions() {
    return {
      direction: void 0
    };
  },
  addGlobalAttributes() {
    if (!this.options.direction)
      return [];
    const { nodeExtensions: e } = gh(this.extensions);
    return [
      {
        types: e.filter((t) => t.name !== "text").map((t) => t.name),
        attributes: {
          dir: {
            default: this.options.direction,
            parseHTML: (t) => {
              const n = t.getAttribute("dir");
              return n && (n === "ltr" || n === "rtl" || n === "auto") ? n : this.options.direction;
            },
            renderHTML: (t) => t.dir ? {
              dir: t.dir
            } : {}
          }
        }
      }
    ];
  },
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("textDirection"),
        props: {
          attributes: () => {
            const e = this.options.direction;
            return e ? {
              dir: e
            } : {};
          }
        }
      })
    ];
  }
}), WDe = class ym {
  constructor(t, n, r = !1, i = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = t, this.editor = n, this.currentNode = i;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var t;
    return (t = this.actualDepth) != null ? t : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(t) {
    let n = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, t);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const t = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(t);
    return new ym(n, this.editor);
  }
  get before() {
    let t = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return t.depth !== this.depth && (t = this.resolvedPos.doc.resolve(this.from - 3)), new ym(t, this.editor);
  }
  get after() {
    let t = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return t.depth !== this.depth && (t = this.resolvedPos.doc.resolve(this.to + 3)), new ym(t, this.editor);
  }
  get children() {
    const t = [];
    return this.node.content.forEach((n, r) => {
      const i = n.isBlock && !n.isTextblock, o = n.isAtom && !n.isText, s = n.isInline, a = this.pos + r + (o ? 0 : 1);
      if (a < 0 || a > this.resolvedPos.doc.nodeSize - 2)
        return;
      const c = this.resolvedPos.doc.resolve(a);
      if (!i && !s && c.depth <= this.depth)
        return;
      const u = new ym(c, this.editor, i, i || s ? n : null);
      i && (u.actualDepth = this.depth + 1), t.push(u);
    }), t;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const t = this.children;
    return t[t.length - 1] || null;
  }
  closest(t, n = {}) {
    let r = null, i = this.parent;
    for (; i && !r; ) {
      if (i.node.type.name === t)
        if (Object.keys(n).length > 0) {
          const o = i.node.attrs, s = Object.keys(n);
          for (let a = 0; a < s.length; a += 1) {
            const c = s[a];
            if (o[c] !== n[c])
              break;
          }
        } else
          r = i;
      i = i.parent;
    }
    return r;
  }
  querySelector(t, n = {}) {
    return this.querySelectorAll(t, n, !0)[0] || null;
  }
  querySelectorAll(t, n = {}, r = !1) {
    let i = [];
    if (!this.children || this.children.length === 0)
      return i;
    const o = Object.keys(n);
    return this.children.forEach((s) => {
      r && i.length > 0 || (s.node.type.name === t && o.every((c) => n[c] === s.node.attrs[c]) && i.push(s), !(r && i.length > 0) && (i = i.concat(s.querySelectorAll(t, n, r))));
    }), i;
  }
  setAttribute(t) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...t
    }), this.editor.view.dispatch(n);
  }
}, qDe = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function GDe(e, t, n) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null)
    return r;
  const i = document.createElement("style");
  return t && i.setAttribute("nonce", t), i.setAttribute("data-tiptap-style", ""), i.innerHTML = e, document.getElementsByTagName("head")[0].appendChild(i), i;
}
var KDe = class extends PDe {
  constructor(e = {}) {
    super(), this.css = null, this.className = "tiptap", this.editorView = null, this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.instanceId = Math.random().toString(36).slice(2, 9), this.options = {
      element: typeof document < "u" ? document.createElement("div") : null,
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      textDirection: void 0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      emitContentError: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onMount: () => null,
      onUnmount: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: r }) => {
        throw r;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null,
      enableExtensionDispatchTransaction: !0
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.utils = {
      getUpdatedPosition: dDe,
      createMappablePosition: fDe
    }, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("mount", this.options.onMount), this.on("unmount", this.options.onUnmount), this.on("contentError", this.options.onContentError), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: r, slice: i, moved: o }) => this.options.onDrop(r, i, o)), this.on("paste", ({ event: r, slice: i }) => this.options.onPaste(r, i)), this.on("delete", this.options.onDelete);
    const t = this.createDoc(), n = AW(t, this.options.autofocus);
    this.editorState = Uf.create({
      doc: t,
      schema: this.schema,
      selection: n || void 0
    }), this.options.element && this.mount(this.options.element);
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(e) {
    if (typeof document > "u")
      throw new Error(
        "[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment."
      );
    this.createView(e), this.emit("mount", { editor: this }), this.css && !document.head.contains(this.css) && document.head.appendChild(this.css), window.setTimeout(() => {
      this.isDestroyed || (this.options.autofocus !== !1 && this.options.autofocus !== null && this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    if (this.editorView) {
      const e = this.editorView.dom;
      e?.editor && delete e.editor, this.editorView.destroy();
    }
    if (this.editorView = null, this.isInitialized = !1, this.css && !document.querySelectorAll(`.${this.className}`).length)
      try {
        typeof this.css.remove == "function" ? this.css.remove() : this.css.parentNode && this.css.parentNode.removeChild(this.css);
      } catch (e) {
        console.warn("Failed to remove CSS element:", e);
      }
    this.css = null, this.emit("unmount", { editor: this });
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && typeof document < "u" && (this.css = GDe(qDe, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.editorView || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, t = !0) {
    this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    return this.editorView ? this.editorView : new Proxy(
      {
        state: this.editorState,
        updateState: (e) => {
          this.editorState = e;
        },
        dispatch: (e) => {
          this.dispatchTransaction(e);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: !1,
        dragging: null,
        editable: !0,
        isDestroyed: !1
      },
      {
        get: (e, t) => {
          if (this.editorView)
            return this.editorView[t];
          if (t === "state")
            return this.editorState;
          if (t in e)
            return Reflect.get(e, t);
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${t}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.editorView && (this.editorState = this.view.state), this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, t) {
    const n = DW(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], r = this.state.reconfigure({ plugins: n });
    return this.view.updateState(r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const t = this.state.plugins;
    let n = t;
    if ([].concat(e).forEach((i) => {
      const o = typeof i == "string" ? `${i}$` : i.key;
      n = n.filter((s) => !s.key.startsWith(o));
    }), t.length === n.length)
      return;
    const r = this.state.reconfigure({
      plugins: n
    });
    return this.view.updateState(r), r;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, t;
    const r = [...this.options.enableCoreExtensions ? [
      YW,
      qW.configure({
        blockSeparator: (t = (e = this.options.coreExtensionOptions) == null ? void 0 : e.clipboardTextSerializer) == null ? void 0 : t.blockSeparator
      }),
      GW,
      JW,
      QW,
      tq,
      ZW,
      eq,
      KW,
      nq.configure({
        direction: this.options.textDirection
      })
    ].filter((i) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[i.name] !== !1 : !0) : [], ...this.options.extensions].filter((i) => ["extension", "node", "mark"].includes(i?.type));
    this.extensionManager = new Qw(r, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new Kw({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let e;
    try {
      e = bT(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (t) {
      if (!(t instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(t.message))
        throw t;
      this.emit("contentError", {
        editor: this,
        error: t,
        disableCollaboration: () => {
          "collaboration" in this.storage && typeof this.storage.collaboration == "object" && this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((n) => n.name !== "collaboration"), this.createExtensionManager();
        }
      }), e = bT(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: !1
      });
    }
    return e;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(e) {
    const { editorProps: t, enableExtensionDispatchTransaction: n } = this.options, r = t.dispatchTransaction || this.dispatchTransaction.bind(this), i = n ? this.extensionManager.dispatchTransaction(r) : r;
    this.editorView = new kW(e, {
      ...t,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...t?.attributes
      },
      dispatchTransaction: i,
      state: this.editorState,
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
    const o = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(o), this.prependClass(), this.injectCSS();
    const s = this.view.dom;
    s.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `${this.className} ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const t = this.capturedTransaction;
    return this.capturedTransaction = null, t;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((u) => {
        var f;
        return (f = this.capturedTransaction) == null ? void 0 : f.step(u);
      });
      return;
    }
    const { state: t, transactions: n } = this.state.applyTransaction(e), r = !this.state.selection.eq(t.selection), i = n.includes(e), o = this.state;
    if (this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: t
    }), !i)
      return;
    this.view.updateState(t), this.emit("transaction", {
      editor: this,
      transaction: e,
      appendedTransactions: n.slice(1)
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const s = n.findLast((u) => u.getMeta("focus") || u.getMeta("blur")), a = s?.getMeta("focus"), c = s?.getMeta("blur");
    a && this.emit("focus", {
      editor: this,
      event: a.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: s
    }), c && this.emit("blur", {
      editor: this,
      event: c.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: s
    }), !(e.getMeta("preventUpdate") || !n.some((u) => u.docChanged) || o.doc.eq(t.doc)) && this.emit("update", {
      editor: this,
      transaction: e,
      appendedTransactions: n.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return LW(this.state, e);
  }
  isActive(e, t) {
    const n = typeof e == "string" ? e : null, r = typeof e == "string" ? t : e;
    return lDe(this.state, n, r);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return RN(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: t = `

`, textSerializers: n = {} } = e || {};
    return nDe(this.state.doc, {
      blockSeparator: t,
      textSerializers: {
        ...zW(this.schema),
        ...n
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return Xw(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy"), this.unmount(), this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e, t;
    return (t = (e = this.editorView) == null ? void 0 : e.isDestroyed) != null ? t : !0;
  }
  $node(e, t) {
    var n;
    return ((n = this.$doc) == null ? void 0 : n.querySelector(e, t)) || null;
  }
  $nodes(e, t) {
    var n;
    return ((n = this.$doc) == null ? void 0 : n.querySelectorAll(e, t)) || null;
  }
  $pos(e) {
    const t = this.state.doc.resolve(e);
    return new WDe(t, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function vh(e) {
  return new Jw({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const i = mn(e.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: o } = t, s = r[r.length - 1], a = r[0];
      if (s) {
        const c = a.search(/\S/), u = n.from + a.indexOf(s), f = u + s.length;
        if (ON(n.from, n.to, t.doc).filter((g) => g.mark.type.excluded.find((x) => x === e.type && x !== g.mark.type)).filter((g) => g.to > u).length)
          return null;
        f < n.to && o.delete(f, n.to), u > n.from && o.delete(n.from + c, u);
        const m = n.from + c + s.length;
        o.addMark(n.from + c, m, e.type.create(i || {})), o.removeStoredMark(e.type);
      }
    },
    undoable: e.undoable
  });
}
function ZDe(e) {
  return new Jw({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const i = mn(e.getAttributes, void 0, r) || {}, { tr: o } = t, s = n.from;
      let a = n.to;
      const c = e.type.create(i);
      if (r[1]) {
        const u = r[0].lastIndexOf(r[1]);
        let f = s + u;
        f > a ? f = a : a = f + r[1].length;
        const h = r[0][r[0].length - 1];
        o.insertText(h, s + r[0].length - 1), o.replaceWith(f, a, c);
      } else if (r[0]) {
        const u = e.type.isInline ? s : s - 1;
        o.insert(u, e.type.create(i)).delete(o.mapping.map(s), o.mapping.map(a));
      }
      o.scrollIntoView();
    },
    undoable: e.undoable
  });
}
function wT(e) {
  return new Jw({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const i = t.doc.resolve(n.from), o = mn(e.getAttributes, void 0, r) || {};
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), e.type))
        return null;
      t.tr.delete(n.from, n.to).setBlockType(n.from, n.from, e.type, o);
    },
    undoable: e.undoable
  });
}
function bh(e) {
  return new Jw({
    find: e.find,
    handler: ({ state: t, range: n, match: r, chain: i }) => {
      const o = mn(e.getAttributes, void 0, r) || {}, s = t.tr.delete(n.from, n.to), c = s.doc.resolve(n.from).blockRange(), u = c && dN(c, e.type, o);
      if (!u)
        return null;
      if (s.wrap(c, u), e.keepMarks && e.editor) {
        const { selection: h, storedMarks: m } = t, { splittableMarks: g } = e.editor.extensionManager, b = m || h.$to.parentOffset && h.$from.marks();
        if (b) {
          const x = b.filter((w) => g.includes(w.type.name));
          s.ensureMarks(x);
        }
      }
      if (e.keepAttributes) {
        const h = e.type.name === "bulletList" || e.type.name === "orderedList" ? "listItem" : "taskList";
        i().updateAttributes(h, o).run();
      }
      const f = s.doc.resolve(n.from - 1).nodeBefore;
      f && f.type === e.type && Vc(s.doc, n.from - 1) && (!e.joinPredicate || e.joinPredicate(r, f)) && s.join(n.from - 1);
    },
    undoable: e.undoable
  });
}
function YDe(e, t) {
  const { selection: n } = e, { $from: r } = n;
  if (n instanceof ht) {
    const o = r.index();
    return r.parent.canReplaceWith(o, o + 1, t);
  }
  let i = r.depth;
  for (; i >= 0; ) {
    const o = r.index(i);
    if (r.node(i).contentMatchAt(o).matchType(t))
      return !0;
    i -= 1;
  }
  return !1;
}
function XDe(e) {
  return e.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var JDe = {};
TN(JDe, {
  createAtomBlockMarkdownSpec: () => QDe,
  createBlockMarkdownSpec: () => ePe,
  createInlineMarkdownSpec: () => rPe,
  parseAttributes: () => PN,
  parseIndentedBlocks: () => ST,
  renderNestedMarkdownContent: () => IN,
  serializeAttributes: () => jN
});
function PN(e) {
  if (!e?.trim())
    return {};
  const t = {}, n = [], r = e.replace(/["']([^"']*)["']/g, (u) => (n.push(u), `__QUOTED_${n.length - 1}__`)), i = r.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);
  if (i) {
    const u = i.map((f) => f.trim().slice(1));
    t.class = u.join(" ");
  }
  const o = r.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);
  o && (t.id = o[1]);
  const s = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;
  Array.from(r.matchAll(s)).forEach(([, u, f]) => {
    var h;
    const m = parseInt(((h = f.match(/__QUOTED_(\d+)__/)) == null ? void 0 : h[1]) || "0", 10), g = n[m];
    g && (t[u] = g.slice(1, -1));
  });
  const c = r.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, "").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, "").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, "").trim();
  return c && c.split(/\s+/).filter(Boolean).forEach((f) => {
    f.match(/^[a-zA-Z][\w-]*$/) && (t[f] = !0);
  }), t;
}
function jN(e) {
  if (!e || Object.keys(e).length === 0)
    return "";
  const t = [];
  return e.class && String(e.class).split(/\s+/).filter(Boolean).forEach((r) => t.push(`.${r}`)), e.id && t.push(`#${e.id}`), Object.entries(e).forEach(([n, r]) => {
    n === "class" || n === "id" || (r === !0 ? t.push(n) : r !== !1 && r != null && t.push(`${n}="${String(r)}"`));
  }), t.join(" ");
}
function QDe(e) {
  const {
    nodeName: t,
    name: n,
    parseAttributes: r = PN,
    serializeAttributes: i = jN,
    defaultAttributes: o = {},
    requiredAttributes: s = [],
    allowedAttributes: a
  } = e, c = n || t, u = (f) => {
    if (!a)
      return f;
    const h = {};
    return a.forEach((m) => {
      m in f && (h[m] = f[m]);
    }), h;
  };
  return {
    parseMarkdown: (f, h) => {
      const m = { ...o, ...f.attributes };
      return h.createNode(t, m, []);
    },
    markdownTokenizer: {
      name: t,
      level: "block",
      start(f) {
        var h;
        const m = new RegExp(`^:::${c}(?:\\s|$)`, "m"), g = (h = f.match(m)) == null ? void 0 : h.index;
        return g !== void 0 ? g : -1;
      },
      tokenize(f, h, m) {
        const g = new RegExp(`^:::${c}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`), b = f.match(g);
        if (!b)
          return;
        const x = b[1] || "", w = r(x);
        if (!s.find((_) => !(_ in w)))
          return {
            type: t,
            raw: b[0],
            attributes: w
          };
      }
    },
    renderMarkdown: (f) => {
      const h = u(f.attrs || {}), m = i(h), g = m ? ` {${m}}` : "";
      return `:::${c}${g} :::`;
    }
  };
}
function ePe(e) {
  const {
    nodeName: t,
    name: n,
    getContent: r,
    parseAttributes: i = PN,
    serializeAttributes: o = jN,
    defaultAttributes: s = {},
    content: a = "block",
    allowedAttributes: c
  } = e, u = n || t, f = (h) => {
    if (!c)
      return h;
    const m = {};
    return c.forEach((g) => {
      g in h && (m[g] = h[g]);
    }), m;
  };
  return {
    parseMarkdown: (h, m) => {
      let g;
      if (r) {
        const x = r(h);
        g = typeof x == "string" ? [{ type: "text", text: x }] : x;
      } else a === "block" ? g = m.parseChildren(h.tokens || []) : g = m.parseInline(h.tokens || []);
      const b = { ...s, ...h.attributes };
      return m.createNode(t, b, g);
    },
    markdownTokenizer: {
      name: t,
      level: "block",
      start(h) {
        var m;
        const g = new RegExp(`^:::${u}`, "m"), b = (m = h.match(g)) == null ? void 0 : m.index;
        return b !== void 0 ? b : -1;
      },
      tokenize(h, m, g) {
        var b;
        const x = new RegExp(`^:::${u}(?:\\s+\\{([^}]*)\\})?\\s*\\n`), w = h.match(x);
        if (!w)
          return;
        const [S, _ = ""] = w, M = i(_);
        let N = 1;
        const P = S.length;
        let I = "";
        const O = /^:::([\w-]*)(\s.*)?/gm, L = h.slice(P);
        for (O.lastIndex = 0; ; ) {
          const U = O.exec(L);
          if (U === null)
            break;
          const B = U.index, G = U[1];
          if (!((b = U[2]) != null && b.endsWith(":::"))) {
            if (G)
              N += 1;
            else if (N -= 1, N === 0) {
              const Y = L.slice(0, B);
              I = Y.trim();
              const he = h.slice(0, P + B + U[0].length);
              let ie = [];
              if (I)
                if (a === "block")
                  for (ie = g.blockTokens(Y), ie.forEach((ne) => {
                    ne.text && (!ne.tokens || ne.tokens.length === 0) && (ne.tokens = g.inlineTokens(ne.text));
                  }); ie.length > 0; ) {
                    const ne = ie[ie.length - 1];
                    if (ne.type === "paragraph" && (!ne.text || ne.text.trim() === ""))
                      ie.pop();
                    else
                      break;
                  }
                else
                  ie = g.inlineTokens(I);
              return {
                type: t,
                raw: he,
                attributes: M,
                content: I,
                tokens: ie
              };
            }
          }
        }
      }
    },
    renderMarkdown: (h, m) => {
      const g = f(h.attrs || {}), b = o(g), x = b ? ` {${b}}` : "", w = m.renderChildren(h.content || [], `

`);
      return `:::${u}${x}

${w}

:::`;
    }
  };
}
function tPe(e) {
  if (!e.trim())
    return {};
  const t = {}, n = /(\w+)=(?:"([^"]*)"|'([^']*)')/g;
  let r = n.exec(e);
  for (; r !== null; ) {
    const [, i, o, s] = r;
    t[i] = o || s, r = n.exec(e);
  }
  return t;
}
function nPe(e) {
  return Object.entries(e).filter(([, t]) => t != null).map(([t, n]) => `${t}="${n}"`).join(" ");
}
function rPe(e) {
  const {
    nodeName: t,
    name: n,
    getContent: r,
    parseAttributes: i = tPe,
    serializeAttributes: o = nPe,
    defaultAttributes: s = {},
    selfClosing: a = !1,
    allowedAttributes: c
  } = e, u = n || t, f = (m) => {
    if (!c)
      return m;
    const g = {};
    return c.forEach((b) => {
      const x = typeof b == "string" ? b : b.name, w = typeof b == "string" ? void 0 : b.skipIfDefault;
      if (x in m) {
        const S = m[x];
        if (w !== void 0 && S === w)
          return;
        g[x] = S;
      }
    }), g;
  }, h = u.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  return {
    parseMarkdown: (m, g) => {
      const b = { ...s, ...m.attributes };
      if (a)
        return g.createNode(t, b);
      const x = r ? r(m) : m.content || "";
      return x ? g.createNode(t, b, [g.createTextNode(x)]) : g.createNode(t, b, []);
    },
    markdownTokenizer: {
      name: t,
      level: "inline",
      start(m) {
        const g = a ? new RegExp(`\\[${h}\\s*[^\\]]*\\]`) : new RegExp(`\\[${h}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${h}\\]`), b = m.match(g), x = b?.index;
        return x !== void 0 ? x : -1;
      },
      tokenize(m, g, b) {
        const x = a ? new RegExp(`^\\[${h}\\s*([^\\]]*)\\]`) : new RegExp(`^\\[${h}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${h}\\]`), w = m.match(x);
        if (!w)
          return;
        let S = "", _ = "";
        if (a) {
          const [, N] = w;
          _ = N;
        } else {
          const [, N, P] = w;
          _ = N, S = P || "";
        }
        const M = i(_.trim());
        return {
          type: t,
          raw: w[0],
          content: S.trim(),
          attributes: M
        };
      }
    },
    renderMarkdown: (m) => {
      let g = "";
      r ? g = r(m) : m.content && m.content.length > 0 && (g = m.content.filter((S) => S.type === "text").map((S) => S.text).join(""));
      const b = f(m.attrs || {}), x = o(b), w = x ? ` ${x}` : "";
      return a ? `[${u}${w}]` : `[${u}${w}]${g}[/${u}]`;
    }
  };
}
function ST(e, t, n) {
  var r, i, o, s;
  const a = e.split(`
`), c = [];
  let u = "", f = 0;
  const h = t.baseIndentSize || 2;
  for (; f < a.length; ) {
    const m = a[f], g = m.match(t.itemPattern);
    if (!g) {
      if (c.length > 0)
        break;
      if (m.trim() === "") {
        f += 1, u = `${u}${m}
`;
        continue;
      } else
        return;
    }
    const b = t.extractItemData(g), { indentLevel: x, mainContent: w } = b;
    u = `${u}${m}
`;
    const S = [w];
    for (f += 1; f < a.length; ) {
      const P = a[f];
      if (P.trim() === "") {
        const O = a.slice(f + 1).findIndex((B) => B.trim() !== "");
        if (O === -1)
          break;
        if ((((i = (r = a[f + 1 + O].match(/^(\s*)/)) == null ? void 0 : r[1]) == null ? void 0 : i.length) || 0) > x) {
          S.push(P), u = `${u}${P}
`, f += 1;
          continue;
        } else
          break;
      }
      if ((((s = (o = P.match(/^(\s*)/)) == null ? void 0 : o[1]) == null ? void 0 : s.length) || 0) > x)
        S.push(P), u = `${u}${P}
`, f += 1;
      else
        break;
    }
    let _;
    const M = S.slice(1);
    if (M.length > 0) {
      const P = M.map((I) => I.slice(x + h)).join(`
`);
      P.trim() && (t.customNestedParser ? _ = t.customNestedParser(P) : _ = n.blockTokens(P));
    }
    const N = t.createToken(b, _);
    c.push(N);
  }
  if (c.length !== 0)
    return {
      items: c,
      raw: u
    };
}
function IN(e, t, n, r) {
  if (!e || !Array.isArray(e.content))
    return "";
  const i = typeof n == "function" ? n(r) : n, [o, ...s] = e.content, a = t.renderChildren([o]), c = [`${i}${a}`];
  return s && s.length > 0 && s.forEach((u) => {
    const f = t.renderChildren([u]);
    if (f) {
      const h = f.split(`
`).map((m) => m ? t.indent(m) : "").join(`
`);
      c.push(h);
    }
  }), c.join(`
`);
}
function iPe(e, t, n = {}) {
  const { state: r } = t, { doc: i, tr: o } = r, s = e;
  i.descendants((a, c) => {
    const u = o.mapping.map(c), f = o.mapping.map(c) + a.nodeSize;
    let h = null;
    if (a.marks.forEach((g) => {
      if (g !== s)
        return !1;
      h = g;
    }), !h)
      return;
    let m = !1;
    if (Object.keys(n).forEach((g) => {
      n[g] !== h.attrs[g] && (m = !0);
    }), m) {
      const g = e.type.create({
        ...e.attrs,
        ...n
      });
      o.removeMark(u, f, e.type), o.addMark(u, f, g);
    }
  }), o.docChanged && t.view.dispatch(o);
}
var ji = class rq extends DN {
  constructor() {
    super(...arguments), this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new rq(n);
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
}, oPe = class {
  constructor(e, t, n) {
    this.isDragging = !1, this.component = e, this.editor = t.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...n
    }, this.extension = t.extension, this.node = t.node, this.decorations = t.decorations, this.innerDecorations = t.innerDecorations, this.view = t.view, this.HTMLAttributes = t.HTMLAttributes, this.getPos = t.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(e) {
    var t, n, r, i, o, s, a;
    const { view: c } = this.editor, u = e.target, f = u.nodeType === 3 ? (t = u.parentElement) == null ? void 0 : t.closest("[data-drag-handle]") : u.closest("[data-drag-handle]");
    if (!this.dom || (n = this.contentDOM) != null && n.contains(u) || !f)
      return;
    let h = 0, m = 0;
    if (this.dom !== f) {
      const _ = this.dom.getBoundingClientRect(), M = f.getBoundingClientRect(), N = (i = e.offsetX) != null ? i : (r = e.nativeEvent) == null ? void 0 : r.offsetX, P = (s = e.offsetY) != null ? s : (o = e.nativeEvent) == null ? void 0 : o.offsetY;
      h = M.x - _.x + N, m = M.y - _.y + P;
    }
    const g = this.dom.cloneNode(!0);
    try {
      const _ = this.dom.getBoundingClientRect();
      g.style.width = `${Math.round(_.width)}px`, g.style.height = `${Math.round(_.height)}px`, g.style.boxSizing = "border-box", g.style.pointerEvents = "none";
    } catch {
    }
    let b = null;
    try {
      b = document.createElement("div"), b.style.position = "absolute", b.style.top = "-9999px", b.style.left = "-9999px", b.style.pointerEvents = "none", b.appendChild(g), document.body.appendChild(b), (a = e.dataTransfer) == null || a.setDragImage(g, h, m);
    } finally {
      b && setTimeout(() => {
        try {
          b?.remove();
        } catch {
        }
      }, 0);
    }
    const x = this.getPos();
    if (typeof x != "number")
      return;
    const w = ht.create(c.state.doc, x), S = c.state.tr.setSelection(w);
    c.dispatch(S);
  }
  stopEvent(e) {
    var t;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: e });
    const n = e.target;
    if (!(this.dom.contains(n) && !((t = this.contentDOM) != null && t.contains(n))))
      return !1;
    const i = e.type.startsWith("drag"), o = e.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(n.tagName) || n.isContentEditable) && !o && !i)
      return !0;
    const { isEditable: a } = this.editor, { isDragging: c } = this, u = !!this.node.type.spec.draggable, f = ht.isSelectable(this.node), h = e.type === "copy", m = e.type === "paste", g = e.type === "cut", b = e.type === "mousedown";
    if (!u && f && i && e.target === this.dom && e.preventDefault(), u && i && !c && e.target === this.dom)
      return e.preventDefault(), !1;
    if (u && a && !c && b) {
      const x = n.closest("[data-drag-handle]");
      x && (this.dom === x || this.dom.contains(x)) && (this.isDragging = !0, document.addEventListener(
        "dragend",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ), document.addEventListener(
        "drop",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ), document.addEventListener(
        "mouseup",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ));
    }
    return !(c || o || h || m || g || b && f);
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? !0 : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (Sg() || vT()) && this.editor.isFocused && [...Array.from(e.addedNodes), ...Array.from(e.removedNodes)].every((n) => n.isContentEditable) ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(e) {
    this.editor.commands.command(({ tr: t }) => {
      const n = this.getPos();
      return typeof n != "number" ? !1 : (t.setNodeMarkup(n, void 0, {
        ...this.node.attrs,
        ...e
      }), !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const e = this.getPos();
    if (typeof e != "number")
      return;
    const t = e + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: e, to: t });
  }
};
function ld(e) {
  return new BDe({
    find: e.find,
    handler: ({ state: t, range: n, match: r, pasteEvent: i }) => {
      const o = mn(e.getAttributes, void 0, r, i);
      if (o === !1 || o === null)
        return null;
      const { tr: s } = t, a = r[r.length - 1], c = r[0];
      let u = n.to;
      if (a) {
        const f = c.search(/\S/), h = n.from + c.indexOf(a), m = h + a.length;
        if (ON(n.from, n.to, t.doc).filter((b) => b.mark.type.excluded.find((w) => w === e.type && w !== b.mark.type)).filter((b) => b.to > h).length)
          return null;
        m < n.to && s.delete(m, n.to), h > n.from && s.delete(n.from + f, h), u = n.from + f + a.length, s.addMark(n.from + f, u, e.type.create(o || {})), s.removeStoredMark(e.type);
      }
    }
  });
}
const { getOwnPropertyNames: sPe, getOwnPropertySymbols: aPe } = Object, { hasOwnProperty: lPe } = Object.prototype;
function QC(e, t) {
  return function(r, i, o) {
    return e(r, i, o) && t(r, i, o);
  };
}
function n0(e) {
  return function(n, r, i) {
    if (!n || !r || typeof n != "object" || typeof r != "object")
      return e(n, r, i);
    const { cache: o } = i, s = o.get(n), a = o.get(r);
    if (s && a)
      return s === r && a === n;
    o.set(n, r), o.set(r, n);
    const c = e(n, r, i);
    return o.delete(n), o.delete(r), c;
  };
}
function cPe(e) {
  return e?.[Symbol.toStringTag];
}
function S5(e) {
  return sPe(e).concat(aPe(e));
}
const uPe = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  Object.hasOwn || ((e, t) => lPe.call(e, t))
);
function yd(e, t) {
  return e === t || !e && !t && e !== e && t !== t;
}
const dPe = "__v", fPe = "__o", hPe = "_owner", { getOwnPropertyDescriptor: k5, keys: C5 } = Object;
function pPe(e, t) {
  return e.byteLength === t.byteLength && ix(new Uint8Array(e), new Uint8Array(t));
}
function mPe(e, t, n) {
  let r = e.length;
  if (t.length !== r)
    return !1;
  for (; r-- > 0; )
    if (!n.equals(e[r], t[r], r, r, e, t, n))
      return !1;
  return !0;
}
function gPe(e, t) {
  return e.byteLength === t.byteLength && ix(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), new Uint8Array(t.buffer, t.byteOffset, t.byteLength));
}
function yPe(e, t) {
  return yd(e.getTime(), t.getTime());
}
function vPe(e, t) {
  return e.name === t.name && e.message === t.message && e.cause === t.cause && e.stack === t.stack;
}
function bPe(e, t) {
  return e === t;
}
function E5(e, t, n) {
  const r = e.size;
  if (r !== t.size)
    return !1;
  if (!r)
    return !0;
  const i = new Array(r), o = e.entries();
  let s, a, c = 0;
  for (; (s = o.next()) && !s.done; ) {
    const u = t.entries();
    let f = !1, h = 0;
    for (; (a = u.next()) && !a.done; ) {
      if (i[h]) {
        h++;
        continue;
      }
      const m = s.value, g = a.value;
      if (n.equals(m[0], g[0], c, h, e, t, n) && n.equals(m[1], g[1], m[0], g[0], e, t, n)) {
        f = i[h] = !0;
        break;
      }
      h++;
    }
    if (!f)
      return !1;
    c++;
  }
  return !0;
}
const xPe = yd;
function wPe(e, t, n) {
  const r = C5(e);
  let i = r.length;
  if (C5(t).length !== i)
    return !1;
  for (; i-- > 0; )
    if (!iq(e, t, n, r[i]))
      return !1;
  return !0;
}
function em(e, t, n) {
  const r = S5(e);
  let i = r.length;
  if (S5(t).length !== i)
    return !1;
  let o, s, a;
  for (; i-- > 0; )
    if (o = r[i], !iq(e, t, n, o) || (s = k5(e, o), a = k5(t, o), (s || a) && (!s || !a || s.configurable !== a.configurable || s.enumerable !== a.enumerable || s.writable !== a.writable)))
      return !1;
  return !0;
}
function SPe(e, t) {
  return yd(e.valueOf(), t.valueOf());
}
function kPe(e, t) {
  return e.source === t.source && e.flags === t.flags;
}
function _5(e, t, n) {
  const r = e.size;
  if (r !== t.size)
    return !1;
  if (!r)
    return !0;
  const i = new Array(r), o = e.values();
  let s, a;
  for (; (s = o.next()) && !s.done; ) {
    const c = t.values();
    let u = !1, f = 0;
    for (; (a = c.next()) && !a.done; ) {
      if (!i[f] && n.equals(s.value, a.value, s.value, a.value, e, t, n)) {
        u = i[f] = !0;
        break;
      }
      f++;
    }
    if (!u)
      return !1;
  }
  return !0;
}
function ix(e, t) {
  let n = e.byteLength;
  if (t.byteLength !== n || e.byteOffset !== t.byteOffset)
    return !1;
  for (; n-- > 0; )
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function CPe(e, t) {
  return e.hostname === t.hostname && e.pathname === t.pathname && e.protocol === t.protocol && e.port === t.port && e.hash === t.hash && e.username === t.username && e.password === t.password;
}
function iq(e, t, n, r) {
  return (r === hPe || r === fPe || r === dPe) && (e.$$typeof || t.$$typeof) ? !0 : uPe(t, r) && n.equals(e[r], t[r], r, r, e, t, n);
}
const EPe = "[object ArrayBuffer]", _Pe = "[object Arguments]", TPe = "[object Boolean]", APe = "[object DataView]", MPe = "[object Date]", NPe = "[object Error]", RPe = "[object Map]", OPe = "[object Number]", DPe = "[object Object]", PPe = "[object RegExp]", jPe = "[object Set]", IPe = "[object String]", zPe = {
  "[object Int8Array]": !0,
  "[object Uint8Array]": !0,
  "[object Uint8ClampedArray]": !0,
  "[object Int16Array]": !0,
  "[object Uint16Array]": !0,
  "[object Int32Array]": !0,
  "[object Uint32Array]": !0,
  "[object Float16Array]": !0,
  "[object Float32Array]": !0,
  "[object Float64Array]": !0,
  "[object BigInt64Array]": !0,
  "[object BigUint64Array]": !0
}, LPe = "[object URL]", BPe = Object.prototype.toString;
function $Pe({ areArrayBuffersEqual: e, areArraysEqual: t, areDataViewsEqual: n, areDatesEqual: r, areErrorsEqual: i, areFunctionsEqual: o, areMapsEqual: s, areNumbersEqual: a, areObjectsEqual: c, arePrimitiveWrappersEqual: u, areRegExpsEqual: f, areSetsEqual: h, areTypedArraysEqual: m, areUrlsEqual: g, unknownTagComparators: b }) {
  return function(w, S, _) {
    if (w === S)
      return !0;
    if (w == null || S == null)
      return !1;
    const M = typeof w;
    if (M !== typeof S)
      return !1;
    if (M !== "object")
      return M === "number" ? a(w, S, _) : M === "function" ? o(w, S, _) : !1;
    const N = w.constructor;
    if (N !== S.constructor)
      return !1;
    if (N === Object)
      return c(w, S, _);
    if (Array.isArray(w))
      return t(w, S, _);
    if (N === Date)
      return r(w, S, _);
    if (N === RegExp)
      return f(w, S, _);
    if (N === Map)
      return s(w, S, _);
    if (N === Set)
      return h(w, S, _);
    const P = BPe.call(w);
    if (P === MPe)
      return r(w, S, _);
    if (P === PPe)
      return f(w, S, _);
    if (P === RPe)
      return s(w, S, _);
    if (P === jPe)
      return h(w, S, _);
    if (P === DPe)
      return typeof w.then != "function" && typeof S.then != "function" && c(w, S, _);
    if (P === LPe)
      return g(w, S, _);
    if (P === NPe)
      return i(w, S, _);
    if (P === _Pe)
      return c(w, S, _);
    if (zPe[P])
      return m(w, S, _);
    if (P === EPe)
      return e(w, S, _);
    if (P === APe)
      return n(w, S, _);
    if (P === TPe || P === OPe || P === IPe)
      return u(w, S, _);
    if (b) {
      let I = b[P];
      if (!I) {
        const O = cPe(w);
        O && (I = b[O]);
      }
      if (I)
        return I(w, S, _);
    }
    return !1;
  };
}
function UPe({ circular: e, createCustomConfig: t, strict: n }) {
  let r = {
    areArrayBuffersEqual: pPe,
    areArraysEqual: n ? em : mPe,
    areDataViewsEqual: gPe,
    areDatesEqual: yPe,
    areErrorsEqual: vPe,
    areFunctionsEqual: bPe,
    areMapsEqual: n ? QC(E5, em) : E5,
    areNumbersEqual: xPe,
    areObjectsEqual: n ? em : wPe,
    arePrimitiveWrappersEqual: SPe,
    areRegExpsEqual: kPe,
    areSetsEqual: n ? QC(_5, em) : _5,
    areTypedArraysEqual: n ? QC(ix, em) : ix,
    areUrlsEqual: CPe,
    unknownTagComparators: void 0
  };
  if (t && (r = Object.assign({}, r, t(r))), e) {
    const i = n0(r.areArraysEqual), o = n0(r.areMapsEqual), s = n0(r.areObjectsEqual), a = n0(r.areSetsEqual);
    r = Object.assign({}, r, {
      areArraysEqual: i,
      areMapsEqual: o,
      areObjectsEqual: s,
      areSetsEqual: a
    });
  }
  return r;
}
function FPe(e) {
  return function(t, n, r, i, o, s, a) {
    return e(t, n, a);
  };
}
function VPe({ circular: e, comparator: t, createState: n, equals: r, strict: i }) {
  if (n)
    return function(a, c) {
      const { cache: u = e ? /* @__PURE__ */ new WeakMap() : void 0, meta: f } = n();
      return t(a, c, {
        cache: u,
        equals: r,
        meta: f,
        strict: i
      });
    };
  if (e)
    return function(a, c) {
      return t(a, c, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: r,
        meta: void 0,
        strict: i
      });
    };
  const o = {
    cache: void 0,
    equals: r,
    meta: void 0,
    strict: i
  };
  return function(a, c) {
    return t(a, c, o);
  };
}
const HPe = Wc();
Wc({ strict: !0 });
Wc({ circular: !0 });
Wc({
  circular: !0,
  strict: !0
});
Wc({
  createInternalComparator: () => yd
});
Wc({
  strict: !0,
  createInternalComparator: () => yd
});
Wc({
  circular: !0,
  createInternalComparator: () => yd
});
Wc({
  circular: !0,
  createInternalComparator: () => yd,
  strict: !0
});
function Wc(e = {}) {
  const { circular: t = !1, createInternalComparator: n, createState: r, strict: i = !1 } = e, o = UPe(e), s = $Pe(o), a = n ? n(s) : FPe(s);
  return VPe({ circular: t, comparator: s, createState: r, equals: a, strict: i });
}
var eE = { exports: {} }, tE = {};
var T5;
function WPe() {
  if (T5) return tE;
  T5 = 1;
  var e = ud(), t = N3();
  function n(u, f) {
    return u === f && (u !== 0 || 1 / u === 1 / f) || u !== u && f !== f;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, a = e.useMemo, c = e.useDebugValue;
  return tE.useSyncExternalStoreWithSelector = function(u, f, h, m, g) {
    var b = o(null);
    if (b.current === null) {
      var x = { hasValue: !1, value: null };
      b.current = x;
    } else x = b.current;
    b = a(
      function() {
        function S(I) {
          if (!_) {
            if (_ = !0, M = I, I = m(I), g !== void 0 && x.hasValue) {
              var O = x.value;
              if (g(O, I))
                return N = O;
            }
            return N = I;
          }
          if (O = N, r(M, I)) return O;
          var L = m(I);
          return g !== void 0 && g(O, L) ? (M = I, O) : (M = I, N = L);
        }
        var _ = !1, M, N, P = h === void 0 ? null : h;
        return [
          function() {
            return S(f());
          },
          P === null ? void 0 : function() {
            return S(P());
          }
        ];
      },
      [f, h, m, g]
    );
    var w = i(u, b[0], b[1]);
    return s(
      function() {
        x.hasValue = !0, x.value = w;
      },
      [w]
    ), c(w), w;
  }, tE;
}
var A5;
function qPe() {
  return A5 || (A5 = 1, eE.exports = WPe()), eE.exports;
}
var GPe = qPe(), KPe = (...e) => (t) => {
  e.forEach((n) => {
    typeof n == "function" ? n(t) : n && (n.current = t);
  });
}, ZPe = ({ contentComponent: e }) => {
  const t = th.useSyncExternalStore(
    e.subscribe,
    e.getSnapshot,
    e.getServerSnapshot
  );
  return /* @__PURE__ */ v.jsx(v.Fragment, { children: Object.values(t) });
};
function YPe() {
  const e = /* @__PURE__ */ new Set();
  let t = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(n) {
      return e.add(n), () => {
        e.delete(n);
      };
    },
    getSnapshot() {
      return t;
    },
    getServerSnapshot() {
      return t;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(n, r) {
      t = {
        ...t,
        [n]: $3.createPortal(r.reactElement, r.element, n)
      }, e.forEach((i) => i());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(n) {
      const r = { ...t };
      delete r[n], t = r, e.forEach((i) => i());
    }
  };
}
var XPe = class extends Ne.Component {
  constructor(e) {
    var t;
    super(e), this.editorContentRef = Ne.createRef(), this.initialized = !1, this.state = {
      hasContentComponentInitialized: !!((t = e.editor) != null && t.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    var e;
    const t = this.props.editor;
    if (t && !t.isDestroyed && ((e = t.view.dom) != null && e.parentNode)) {
      if (t.contentComponent)
        return;
      const n = this.editorContentRef.current;
      n.append(...t.view.dom.parentNode.childNodes), t.setOptions({
        element: n
      }), t.contentComponent = YPe(), this.state.hasContentComponentInitialized || (this.unsubscribeToContentComponent = t.contentComponent.subscribe(() => {
        this.setState((r) => r.hasContentComponentInitialized ? r : {
          hasContentComponentInitialized: !0
        }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent();
      })), t.createNodeViews(), this.initialized = !0;
    }
  }
  componentWillUnmount() {
    var e;
    const t = this.props.editor;
    if (t) {
      this.initialized = !1, t.isDestroyed || t.view.setProps({
        nodeViews: {}
      }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent(), t.contentComponent = null;
      try {
        if (!((e = t.view.dom) != null && e.parentNode))
          return;
        const n = document.createElement("div");
        n.append(...t.view.dom.parentNode.childNodes), t.setOptions({
          element: n
        });
      } catch {
      }
    }
  }
  render() {
    const { editor: e, innerRef: t, ...n } = this.props;
    return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx("div", { ref: KPe(t, this.editorContentRef), ...n }),
      e?.contentComponent && /* @__PURE__ */ v.jsx(ZPe, { contentComponent: e.contentComponent })
    ] });
  }
}, JPe = k.forwardRef(
  (e, t) => {
    const n = Ne.useMemo(() => Math.floor(Math.random() * 4294967295).toString(), [e.editor]);
    return Ne.createElement(XPe, {
      key: n,
      innerRef: t,
      ...e
    });
  }
), oq = Ne.memo(JPe), QPe = typeof window < "u" ? k.useLayoutEffect : k.useEffect, eje = class {
  constructor(e) {
    this.transactionNumber = 0, this.lastTransactionNumber = 0, this.subscribers = /* @__PURE__ */ new Set(), this.editor = e, this.lastSnapshot = { editor: e, transactionNumber: 0 }, this.getSnapshot = this.getSnapshot.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.watch = this.watch.bind(this), this.subscribe = this.subscribe.bind(this);
  }
  /**
   * Get the current editor instance.
   */
  getSnapshot() {
    return this.transactionNumber === this.lastTransactionNumber ? this.lastSnapshot : (this.lastTransactionNumber = this.transactionNumber, this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber }, this.lastSnapshot);
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return { editor: null, transactionNumber: 0 };
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(e) {
    return this.subscribers.add(e), () => {
      this.subscribers.delete(e);
    };
  }
  /**
   * Watch the editor instance for changes.
   */
  watch(e) {
    if (this.editor = e, this.editor) {
      const t = () => {
        this.transactionNumber += 1, this.subscribers.forEach((r) => r());
      }, n = this.editor;
      return n.on("transaction", t), () => {
        n.off("transaction", t);
      };
    }
  }
};
function tje(e) {
  var t;
  const [n] = k.useState(() => new eje(e.editor)), r = GPe.useSyncExternalStoreWithSelector(
    n.subscribe,
    n.getSnapshot,
    n.getServerSnapshot,
    e.selector,
    (t = e.equalityFn) != null ? t : HPe
  );
  return QPe(() => n.watch(e.editor), [e.editor, n]), k.useDebugValue(r), r;
}
var nje = !1, kT = typeof window > "u", rje = kT || !!(typeof window < "u" && window.next), ije = class sq {
  constructor(t) {
    this.editor = null, this.subscriptions = /* @__PURE__ */ new Set(), this.isComponentMounted = !1, this.previousDeps = null, this.instanceId = "", this.options = t, this.subscriptions = /* @__PURE__ */ new Set(), this.setEditor(this.getInitialEditor()), this.scheduleDestroy(), this.getEditor = this.getEditor.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.subscribe = this.subscribe.bind(this), this.refreshEditorInstance = this.refreshEditorInstance.bind(this), this.scheduleDestroy = this.scheduleDestroy.bind(this), this.onRender = this.onRender.bind(this), this.createEditor = this.createEditor.bind(this);
  }
  setEditor(t) {
    this.editor = t, this.instanceId = Math.random().toString(36).slice(2, 9), this.subscriptions.forEach((n) => n());
  }
  getInitialEditor() {
    return this.options.current.immediatelyRender === void 0 ? kT || rje ? null : this.createEditor() : (this.options.current.immediatelyRender, this.options.current.immediatelyRender ? this.createEditor() : null);
  }
  /**
   * Create a new editor instance. And attach event listeners.
   */
  createEditor() {
    const t = {
      ...this.options.current,
      // Always call the most recent version of the callback function by default
      onBeforeCreate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onBeforeCreate) == null ? void 0 : o.call(i, ...r);
      },
      onBlur: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onBlur) == null ? void 0 : o.call(i, ...r);
      },
      onCreate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onCreate) == null ? void 0 : o.call(i, ...r);
      },
      onDestroy: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onDestroy) == null ? void 0 : o.call(i, ...r);
      },
      onFocus: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onFocus) == null ? void 0 : o.call(i, ...r);
      },
      onSelectionUpdate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onSelectionUpdate) == null ? void 0 : o.call(i, ...r);
      },
      onTransaction: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onTransaction) == null ? void 0 : o.call(i, ...r);
      },
      onUpdate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onUpdate) == null ? void 0 : o.call(i, ...r);
      },
      onContentError: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onContentError) == null ? void 0 : o.call(i, ...r);
      },
      onDrop: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onDrop) == null ? void 0 : o.call(i, ...r);
      },
      onPaste: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onPaste) == null ? void 0 : o.call(i, ...r);
      },
      onDelete: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onDelete) == null ? void 0 : o.call(i, ...r);
      }
    };
    return new KDe(t);
  }
  /**
   * Get the current editor instance.
   */
  getEditor() {
    return this.editor;
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return null;
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(t) {
    return this.subscriptions.add(t), () => {
      this.subscriptions.delete(t);
    };
  }
  static compareOptions(t, n) {
    return Object.keys(t).every((r) => [
      "onCreate",
      "onBeforeCreate",
      "onDestroy",
      "onUpdate",
      "onTransaction",
      "onFocus",
      "onBlur",
      "onSelectionUpdate",
      "onContentError",
      "onDrop",
      "onPaste"
    ].includes(r) ? !0 : r === "extensions" && t.extensions && n.extensions ? t.extensions.length !== n.extensions.length ? !1 : t.extensions.every((i, o) => {
      var s;
      return i === ((s = n.extensions) == null ? void 0 : s[o]);
    }) : t[r] === n[r]);
  }
  /**
   * On each render, we will create, update, or destroy the editor instance.
   * @param deps The dependencies to watch for changes
   * @returns A cleanup function
   */
  onRender(t) {
    return () => (this.isComponentMounted = !0, clearTimeout(this.scheduledDestructionTimeout), this.editor && !this.editor.isDestroyed && t.length === 0 ? sq.compareOptions(this.options.current, this.editor.options) || this.editor.setOptions({
      ...this.options.current,
      editable: this.editor.isEditable
    }) : this.refreshEditorInstance(t), () => {
      this.isComponentMounted = !1, this.scheduleDestroy();
    });
  }
  /**
   * Recreate the editor instance if the dependencies have changed.
   */
  refreshEditorInstance(t) {
    if (this.editor && !this.editor.isDestroyed) {
      if (this.previousDeps === null) {
        this.previousDeps = t;
        return;
      }
      if (this.previousDeps.length === t.length && this.previousDeps.every((r, i) => r === t[i]))
        return;
    }
    this.editor && !this.editor.isDestroyed && this.editor.destroy(), this.setEditor(this.createEditor()), this.previousDeps = t;
  }
  /**
   * Schedule the destruction of the editor instance.
   * This will only destroy the editor if it was not mounted on the next tick.
   * This is to avoid destroying the editor instance when it's actually still mounted.
   */
  scheduleDestroy() {
    const t = this.instanceId, n = this.editor;
    this.scheduledDestructionTimeout = setTimeout(() => {
      if (this.isComponentMounted && this.instanceId === t) {
        n && n.setOptions(this.options.current);
        return;
      }
      n && !n.isDestroyed && (n.destroy(), this.instanceId === t && this.setEditor(null));
    }, 1);
  }
};
function oje(e = {}, t = []) {
  const n = k.useRef(e);
  n.current = e;
  const [r] = k.useState(() => new ije(n)), i = th.useSyncExternalStore(
    r.subscribe,
    r.getEditor,
    r.getServerSnapshot
  );
  return k.useDebugValue(i), k.useEffect(r.onRender(t)), tje({
    editor: i,
    selector: ({ transactionNumber: o }) => e.shouldRerenderOnTransaction === !1 || e.shouldRerenderOnTransaction === void 0 ? null : e.immediatelyRender && o === 0 ? 0 : o + 1
  }), i;
}
var aq = k.createContext({
  editor: null
});
aq.Consumer;
var lq = k.createContext({
  onDragStart: () => {
  },
  nodeViewContentChildren: void 0,
  nodeViewContentRef: () => {
  }
}), sje = () => k.useContext(lq), aje = Ne.forwardRef((e, t) => {
  const { onDragStart: n } = sje(), r = e.as || "div";
  return (
    // @ts-ignore
    /* @__PURE__ */ v.jsx(
      r,
      {
        ...e,
        ref: t,
        "data-node-view-wrapper": "",
        onDragStart: n,
        style: {
          whiteSpace: "normal",
          ...e.style
        }
      }
    )
  );
});
function M5(e) {
  return !!(typeof e == "function" && e.prototype && e.prototype.isReactComponent);
}
function N5(e) {
  return !!(typeof e == "object" && e.$$typeof && (e.$$typeof.toString() === "Symbol(react.forward_ref)" || e.$$typeof.description === "react.forward_ref"));
}
function lje(e) {
  return !!(typeof e == "object" && e.$$typeof && (e.$$typeof.toString() === "Symbol(react.memo)" || e.$$typeof.description === "react.memo"));
}
function cje(e) {
  if (M5(e) || N5(e))
    return !0;
  if (lje(e)) {
    const t = e.type;
    if (t)
      return M5(t) || N5(t);
  }
  return !1;
}
function uje() {
  try {
    if (k.version)
      return parseInt(k.version.split(".")[0], 10) >= 19;
  } catch {
  }
  return !1;
}
var dje = class {
  /**
   * Immediately creates element and renders the provided React component.
   */
  constructor(e, { editor: t, props: n = {}, as: r = "div", className: i = "" }) {
    this.ref = null, this.destroyed = !1, this.id = Math.floor(Math.random() * 4294967295).toString(), this.component = e, this.editor = t, this.props = n, this.element = document.createElement(r), this.element.classList.add("react-renderer"), i && this.element.classList.add(...i.split(" ")), this.editor.isInitialized ? tl.flushSync(() => {
      this.render();
    }) : queueMicrotask(() => {
      this.destroyed || this.render();
    });
  }
  /**
   * Render the React component.
   */
  render() {
    var e;
    if (this.destroyed)
      return;
    const t = this.component, n = this.props, r = this.editor, i = uje(), o = cje(t), s = { ...n };
    s.ref && !(i || o) && delete s.ref, !s.ref && (i || o) && (s.ref = (a) => {
      this.ref = a;
    }), this.reactElement = /* @__PURE__ */ v.jsx(t, { ...s }), (e = r?.contentComponent) == null || e.setRenderer(this.id, this);
  }
  /**
   * Re-renders the React component with new props.
   */
  updateProps(e = {}) {
    this.destroyed || (this.props = {
      ...this.props,
      ...e
    }, this.render());
  }
  /**
   * Destroy the React component.
   */
  destroy() {
    var e;
    this.destroyed = !0;
    const t = this.editor;
    (e = t?.contentComponent) == null || e.removeRenderer(this.id);
    try {
      this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element);
    } catch {
    }
  }
  /**
   * Update the attributes of the element that holds the React component.
   */
  updateAttributes(e) {
    Object.keys(e).forEach((t) => {
      this.element.setAttribute(t, e[t]);
    });
  }
};
Ne.createContext({
  markViewContentRef: () => {
  }
});
var fje = class extends oPe {
  constructor(e, t, n) {
    if (super(e, t, n), this.selectionRafId = null, this.cachedExtensionWithSyncedStorage = null, !this.node.isLeaf) {
      this.options.contentDOMElementTag ? this.contentDOMElement = document.createElement(this.options.contentDOMElementTag) : this.contentDOMElement = document.createElement(this.node.isInline ? "span" : "div"), this.contentDOMElement.dataset.nodeViewContentReact = "", this.contentDOMElement.dataset.nodeViewWrapper = "", this.contentDOMElement.style.whiteSpace = "inherit";
      const r = this.dom.querySelector("[data-node-view-content]");
      if (!r)
        return;
      r.appendChild(this.contentDOMElement);
    }
  }
  /**
   * Returns a proxy of the extension that redirects storage access to the editor's mutable storage.
   * This preserves the original prototype chain (instanceof checks, methods like configure/extend work).
   * Cached to avoid proxy creation on every update.
   */
  get extensionWithSyncedStorage() {
    if (!this.cachedExtensionWithSyncedStorage) {
      const e = this.editor, t = this.extension;
      this.cachedExtensionWithSyncedStorage = new Proxy(t, {
        get(n, r, i) {
          var o;
          return r === "storage" ? (o = e.storage[t.name]) != null ? o : {} : Reflect.get(n, r, i);
        }
      });
    }
    return this.cachedExtensionWithSyncedStorage;
  }
  /**
   * Setup the React component.
   * Called on initialization.
   */
  mount() {
    const e = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: !1,
      extension: this.extensionWithSyncedStorage,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (c = {}) => this.updateAttributes(c),
      deleteNode: () => this.deleteNode(),
      ref: k.createRef()
    };
    if (!this.component.displayName) {
      const c = (u) => u.charAt(0).toUpperCase() + u.substring(1);
      this.component.displayName = c(this.extension.name);
    }
    const r = { onDragStart: this.onDragStart.bind(this), nodeViewContentRef: (c) => {
      c && this.contentDOMElement && c.firstChild !== this.contentDOMElement && (c.hasAttribute("data-node-view-wrapper") && c.removeAttribute("data-node-view-wrapper"), c.appendChild(this.contentDOMElement));
    } }, i = this.component, o = k.memo((c) => /* @__PURE__ */ v.jsx(lq.Provider, { value: r, children: k.createElement(i, c) }));
    o.displayName = "ReactNodeView";
    let s = this.node.isInline ? "span" : "div";
    this.options.as && (s = this.options.as);
    const { className: a = "" } = this.options;
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.renderer = new dje(o, {
      editor: this.editor,
      props: e,
      as: s,
      className: `node-${this.node.type.name} ${a}`.trim()
    }), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.updateElementAttributes();
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    var e;
    if (this.renderer.element.firstElementChild && !((e = this.renderer.element.firstElementChild) != null && e.hasAttribute("data-node-view-wrapper")))
      throw Error("Please use the NodeViewWrapper component for your node view.");
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    return this.node.isLeaf ? null : this.contentDOMElement;
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    this.selectionRafId && (cancelAnimationFrame(this.selectionRafId), this.selectionRafId = null), this.selectionRafId = requestAnimationFrame(() => {
      this.selectionRafId = null;
      const { from: e, to: t } = this.editor.state.selection, n = this.getPos();
      if (typeof n == "number")
        if (e <= n && t >= n + this.node.nodeSize) {
          if (this.renderer.props.selected)
            return;
          this.selectNode();
        } else {
          if (!this.renderer.props.selected)
            return;
          this.deselectNode();
        }
    });
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(e, t, n) {
    const r = (i) => {
      this.renderer.updateProps(i), typeof this.options.attrs == "function" && this.updateElementAttributes();
    };
    if (e.type !== this.node.type)
      return !1;
    if (typeof this.options.update == "function") {
      const i = this.node, o = this.decorations, s = this.innerDecorations;
      return this.node = e, this.decorations = t, this.innerDecorations = n, this.options.update({
        oldNode: i,
        oldDecorations: o,
        newNode: e,
        newDecorations: t,
        oldInnerDecorations: s,
        innerDecorations: n,
        updateProps: () => r({ node: e, decorations: t, innerDecorations: n, extension: this.extensionWithSyncedStorage })
      });
    }
    return e === this.node && this.decorations === t && this.innerDecorations === n || (this.node = e, this.decorations = t, this.innerDecorations = n, r({ node: e, decorations: t, innerDecorations: n, extension: this.extensionWithSyncedStorage })), !0;
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: !0
    }), this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: !1
    }), this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  /**
   * Destroy the React component instance.
   */
  destroy() {
    this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate), this.contentDOMElement = null, this.selectionRafId && (cancelAnimationFrame(this.selectionRafId), this.selectionRafId = null);
  }
  /**
   * Update the attributes of the top-level element that holds the React component.
   * Applying the attributes defined in the `attrs` option.
   */
  updateElementAttributes() {
    if (this.options.attrs) {
      let e = {};
      if (typeof this.options.attrs == "function") {
        const t = this.editor.extensionManager.attributes, n = yh(this.node, t);
        e = this.options.attrs({ node: this.node, HTMLAttributes: n });
      } else
        e = this.options.attrs;
      this.renderer.updateAttributes(e);
    }
  }
};
function hje(e, t) {
  return (n) => n.editor.contentComponent ? new fje(e, n, t) : {};
}
var zN = k.createContext({
  get editor() {
    throw new Error("useTiptap must be used within a <Tiptap> provider");
  }
});
zN.displayName = "TiptapContext";
var pje = () => k.useContext(zN);
function cq({ editor: e, instance: t, children: n }) {
  const r = e ?? t;
  if (!r)
    throw new Error("Tiptap: An editor instance is required. Pass a non-null `editor` prop.");
  const i = k.useMemo(() => ({ editor: r }), [r]), o = k.useMemo(() => ({ editor: r }), [r]);
  return /* @__PURE__ */ v.jsx(aq.Provider, { value: o, children: /* @__PURE__ */ v.jsx(zN.Provider, { value: i, children: n }) });
}
cq.displayName = "Tiptap";
function uq({ ...e }) {
  const { editor: t } = pje();
  return /* @__PURE__ */ v.jsx(oq, { editor: t, ...e });
}
uq.displayName = "Tiptap.Content";
Object.assign(cq, {
  /**
   * The Tiptap Content component that renders the EditorContent with the editor instance from the context.
   * @see TiptapContent
   */
  Content: uq
});
var ox = (e, t) => {
  if (e === "slot")
    return 0;
  if (e instanceof Function)
    return e(t);
  const { children: n, ...r } = t ?? {};
  if (e === "svg")
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  return [e, r, n];
}, mje = /^\s*>\s$/, gje = ji.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [{ tag: "blockquote" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return /* @__PURE__ */ ox("blockquote", { ...or(this.options.HTMLAttributes, e), children: /* @__PURE__ */ ox("slot", {}) });
  },
  parseMarkdown: (e, t) => t.createNode("blockquote", void 0, t.parseChildren(e.tokens || [])),
  renderMarkdown: (e, t) => {
    if (!e.content)
      return "";
    const n = ">", r = [];
    return e.content.forEach((i) => {
      const a = t.renderChildren([i]).split(`
`).map((c) => c.trim() === "" ? n : `${n} ${c}`);
      r.push(a.join(`
`));
    }), r.join(`
${n}
`);
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: e }) => e.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: e }) => e.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: e }) => e.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      bh({
        find: mje,
        type: this.type
      })
    ];
  }
}), yje = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, vje = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, bje = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, xje = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, wje = gd.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (e) => e.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (e) => e.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return /* @__PURE__ */ ox("strong", { ...or(this.options.HTMLAttributes, e), children: /* @__PURE__ */ ox("slot", {}) });
  },
  markdownTokenName: "strong",
  parseMarkdown: (e, t) => t.applyMark("bold", t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => `**${t.renderChildren(e)}**`,
  addCommands() {
    return {
      setBold: () => ({ commands: e }) => e.setMark(this.name),
      toggleBold: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetBold: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      vh({
        find: yje,
        type: this.type
      }),
      vh({
        find: bje,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ld({
        find: vje,
        type: this.type
      }),
      ld({
        find: xje,
        type: this.type
      })
    ];
  }
}), Sje = /(^|[^`])`([^`]+)`(?!`)$/, kje = /(^|[^`])`([^`]+)`(?!`)/g, Cje = gd.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [{ tag: "code" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["code", or(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "codespan",
  parseMarkdown: (e, t) => t.applyMark("code", [{ type: "text", text: e.text || "" }]),
  renderMarkdown: (e, t) => e.content ? `\`${t.renderChildren(e.content)}\`` : "",
  addCommands() {
    return {
      setCode: () => ({ commands: e }) => e.setMark(this.name),
      toggleCode: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetCode: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      vh({
        find: Sje,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ld({
        find: kje,
        type: this.type
      })
    ];
  }
}), nE = 4, Eje = /^```([a-z]+)?[\s\n]$/, _je = /^~~~([a-z]+)?[\s\n]$/, Tje = ji.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      enableTabIndentation: !1,
      tabSize: nE,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (e) => {
          var t;
          const { languageClassPrefix: n } = this.options;
          if (!n)
            return null;
          const o = [...((t = e.firstElementChild) == null ? void 0 : t.classList) || []].filter((s) => s.startsWith(n)).map((s) => s.replace(n, ""))[0];
          return o || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "pre",
      or(this.options.HTMLAttributes, t),
      [
        "code",
        {
          class: e.attrs.language ? this.options.languageClassPrefix + e.attrs.language : null
        },
        0
      ]
    ];
  },
  markdownTokenName: "code",
  parseMarkdown: (e, t) => {
    var n;
    return ((n = e.raw) == null ? void 0 : n.startsWith("```")) === !1 && e.codeBlockStyle !== "indented" ? [] : t.createNode(
      "codeBlock",
      { language: e.lang || null },
      e.text ? [t.createTextNode(e.text)] : []
    );
  },
  renderMarkdown: (e, t) => {
    var n;
    let r = "";
    const i = ((n = e.attrs) == null ? void 0 : n.language) || "";
    return e.content ? r = [`\`\`\`${i}`, t.renderChildren(e.content), "```"].join(`
`) : r = `\`\`\`${i}

\`\`\``, r;
  },
  addCommands() {
    return {
      setCodeBlock: (e) => ({ commands: t }) => t.setNode(this.name, e),
      toggleCodeBlock: (e) => ({ commands: t }) => t.toggleNode(this.name, "paragraph", e)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: e, $anchor: t } = this.editor.state.selection, n = t.pos === 1;
        return !e || t.parent.type.name !== this.name ? !1 : n || !t.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // handle tab indentation
      Tab: ({ editor: e }) => {
        var t;
        if (!this.options.enableTabIndentation)
          return !1;
        const n = (t = this.options.tabSize) != null ? t : nE, { state: r } = e, { selection: i } = r, { $from: o, empty: s } = i;
        if (o.parent.type !== this.type)
          return !1;
        const a = " ".repeat(n);
        return s ? e.commands.insertContent(a) : e.commands.command(({ tr: c }) => {
          const { from: u, to: f } = i, g = r.doc.textBetween(u, f, `
`, `
`).split(`
`).map((b) => a + b).join(`
`);
          return c.replaceWith(u, f, r.schema.text(g)), !0;
        });
      },
      // handle shift+tab reverse indentation
      "Shift-Tab": ({ editor: e }) => {
        var t;
        if (!this.options.enableTabIndentation)
          return !1;
        const n = (t = this.options.tabSize) != null ? t : nE, { state: r } = e, { selection: i } = r, { $from: o, empty: s } = i;
        return o.parent.type !== this.type ? !1 : s ? e.commands.command(({ tr: a }) => {
          var c;
          const { pos: u } = o, f = o.start(), h = o.end(), g = r.doc.textBetween(f, h, `
`, `
`).split(`
`);
          let b = 0, x = 0;
          const w = u - f;
          for (let I = 0; I < g.length; I += 1) {
            if (x + g[I].length >= w) {
              b = I;
              break;
            }
            x += g[I].length + 1;
          }
          const _ = ((c = g[b].match(/^ */)) == null ? void 0 : c[0]) || "", M = Math.min(_.length, n);
          if (M === 0)
            return !0;
          let N = f;
          for (let I = 0; I < b; I += 1)
            N += g[I].length + 1;
          return a.delete(N, N + M), u - N <= M && a.setSelection(kt.create(a.doc, N)), !0;
        }) : e.commands.command(({ tr: a }) => {
          const { from: c, to: u } = i, m = r.doc.textBetween(c, u, `
`, `
`).split(`
`).map((g) => {
            var b;
            const x = ((b = g.match(/^ */)) == null ? void 0 : b[0]) || "", w = Math.min(x.length, n);
            return g.slice(w);
          }).join(`
`);
          return a.replaceWith(c, u, r.schema.text(m)), !0;
        });
      },
      // exit node on triple enter
      Enter: ({ editor: e }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: t } = e, { selection: n } = t, { $from: r, empty: i } = n;
        if (!i || r.parent.type !== this.type)
          return !1;
        const o = r.parentOffset === r.parent.nodeSize - 2, s = r.parent.textContent.endsWith(`

`);
        return !o || !s ? !1 : e.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: e }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: t } = e, { selection: n, doc: r } = t, { $from: i, empty: o } = n;
        if (!o || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
          return !1;
        const a = i.after();
        return a === void 0 ? !1 : r.nodeAt(a) ? e.commands.command(({ tr: u }) => (u.setSelection(zt.near(r.resolve(a))), !0)) : e.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      wT({
        find: Eje,
        type: this.type,
        getAttributes: (e) => ({
          language: e[1]
        })
      }),
      wT({
        find: _je,
        type: this.type,
        getAttributes: (e) => ({
          language: e[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Zn({
        key: new Tr("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (e, t) => {
            if (!t.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = t.clipboardData.getData("text/plain"), r = t.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, o = i?.mode;
            if (!n || !o)
              return !1;
            const { tr: s, schema: a } = e.state, c = a.text(n.replace(/\r\n?/g, `
`));
            return s.replaceSelectionWith(this.type.create({ language: o }, c)), s.selection.$from.parent.type !== this.type && s.setSelection(kt.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.setMeta("paste", !0), e.dispatch(s), !0;
          }
        }
      })
    ];
  }
}), Aje = ji.create({
  name: "doc",
  topNode: !0,
  content: "block+",
  renderMarkdown: (e, t) => e.content ? t.renderChildren(e.content, `

`) : ""
}), Mje = ji.create({
  name: "hardBreak",
  markdownTokenName: "br",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["br", or(this.options.HTMLAttributes, e)];
  },
  renderText() {
    return `
`;
  },
  renderMarkdown: () => `  
`,
  parseMarkdown: () => ({
    type: "hardBreak"
  }),
  addCommands() {
    return {
      setHardBreak: () => ({ commands: e, chain: t, state: n, editor: r }) => e.first([
        () => e.exitCode(),
        () => e.command(() => {
          const { selection: i, storedMarks: o } = n;
          if (i.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: s } = this.options, { splittableMarks: a } = r.extensionManager, c = o || i.$to.parentOffset && i.$from.marks();
          return t().insertContent({ type: this.name }).command(({ tr: u, dispatch: f }) => {
            if (f && c && s) {
              const h = c.filter((m) => a.includes(m.type.name));
              u.ensureMarks(h);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), Nje = ji.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((e) => ({
      tag: `h${e}`,
      attrs: { level: e }
    }));
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [`h${this.options.levels.includes(e.attrs.level) ? e.attrs.level : this.options.levels[0]}`, or(this.options.HTMLAttributes, t), 0];
  },
  parseMarkdown: (e, t) => t.createNode("heading", { level: e.depth || 1 }, t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => {
    var n;
    const r = (n = e.attrs) != null && n.level ? parseInt(e.attrs.level, 10) : 1, i = "#".repeat(r);
    return e.content ? `${i} ${t.renderChildren(e.content)}` : "";
  },
  addCommands() {
    return {
      setHeading: (e) => ({ commands: t }) => this.options.levels.includes(e.level) ? t.setNode(this.name, e) : !1,
      toggleHeading: (e) => ({ commands: t }) => this.options.levels.includes(e.level) ? t.toggleNode(this.name, "paragraph", e) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce(
      (e, t) => ({
        ...e,
        [`Mod-Alt-${t}`]: () => this.editor.commands.toggleHeading({ level: t })
      }),
      {}
    );
  },
  addInputRules() {
    return this.options.levels.map((e) => wT({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${e}})\\s$`),
      type: this.type,
      getAttributes: {
        level: e
      }
    }));
  }
}), Rje = ji.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {},
      nextNodeType: "paragraph"
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["hr", or(this.options.HTMLAttributes, e)];
  },
  markdownTokenName: "hr",
  parseMarkdown: (e, t) => t.createNode("horizontalRule"),
  renderMarkdown: () => "---",
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: e, state: t }) => {
        if (!YDe(t, t.schema.nodes[this.name]))
          return !1;
        const { selection: n } = t, { $to: r } = n, i = e();
        return $W(n) ? i.insertContentAt(r.pos, {
          type: this.name
        }) : i.insertContent({ type: this.name }), i.command(({ state: o, tr: s, dispatch: a }) => {
          if (a) {
            const { $to: c } = s.selection, u = c.end();
            if (c.nodeAfter)
              c.nodeAfter.isTextblock ? s.setSelection(kt.create(s.doc, c.pos + 1)) : c.nodeAfter.isBlock ? s.setSelection(ht.create(s.doc, c.pos)) : s.setSelection(kt.create(s.doc, c.pos));
            else {
              const f = o.schema.nodes[this.options.nextNodeType] || c.parent.type.contentMatch.defaultType, h = f?.create();
              h && (s.insert(u, h), s.setSelection(kt.create(s.doc, u + 1)));
            }
            s.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      ZDe({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), Oje = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, Dje = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, Pje = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, jje = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, Ije = gd.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (e) => e.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (e) => e.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["em", or(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: e }) => e.setMark(this.name),
      toggleItalic: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetItalic: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  markdownTokenName: "em",
  parseMarkdown: (e, t) => t.applyMark("italic", t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => `*${t.renderChildren(e)}*`,
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      vh({
        find: Oje,
        type: this.type
      }),
      vh({
        find: Pje,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ld({
        find: Dje,
        type: this.type
      }),
      ld({
        find: jje,
        type: this.type
      })
    ];
  }
});
const zje = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", Lje = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", CT = "numeric", ET = "ascii", _T = "alpha", Bm = "asciinumeric", vm = "alphanumeric", TT = "domain", dq = "emoji", Bje = "scheme", $je = "slashscheme", rE = "whitespace";
function Uje(e, t) {
  return e in t || (t[e] = []), t[e];
}
function Bu(e, t, n) {
  t[CT] && (t[Bm] = !0, t[vm] = !0), t[ET] && (t[Bm] = !0, t[_T] = !0), t[Bm] && (t[vm] = !0), t[_T] && (t[vm] = !0), t[vm] && (t[TT] = !0), t[dq] && (t[TT] = !0);
  for (const r in t) {
    const i = Uje(r, n);
    i.indexOf(e) < 0 && i.push(e);
  }
}
function Fje(e, t) {
  const n = {};
  for (const r in t)
    t[r].indexOf(e) >= 0 && (n[r] = !0);
  return n;
}
function qi(e = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = e;
}
qi.groups = {};
qi.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(e) {
    const t = this, n = t.j[e];
    if (n)
      return n;
    for (let r = 0; r < t.jr.length; r++) {
      const i = t.jr[r][0], o = t.jr[r][1];
      if (o && i.test(e))
        return o;
    }
    return t.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(e, t = !1) {
    return t ? e in this.j : !!this.go(e);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(e, t, n, r) {
    for (let i = 0; i < e.length; i++)
      this.tt(e[i], t, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(e, t, n, r) {
    r = r || qi.groups;
    let i;
    return t && t.j ? i = t : (i = new qi(t), n && r && Bu(t, n, r)), this.jr.push([e, i]), i;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(e, t, n, r) {
    let i = this;
    const o = e.length;
    if (!o)
      return i;
    for (let s = 0; s < o - 1; s++)
      i = i.tt(e[s]);
    return i.tt(e[o - 1], t, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(e, t, n, r) {
    r = r || qi.groups;
    const i = this;
    if (t && t.j)
      return i.j[e] = t, t;
    const o = t;
    let s, a = i.go(e);
    if (a ? (s = new qi(), Object.assign(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new qi(), o) {
      if (r)
        if (s.t && typeof s.t == "string") {
          const c = Object.assign(Fje(s.t, r), n);
          Bu(o, c, r);
        } else n && Bu(o, n, r);
      s.t = o;
    }
    return i.j[e] = s, s;
  }
};
const jt = (e, t, n, r, i) => e.ta(t, n, r, i), er = (e, t, n, r, i) => e.tr(t, n, r, i), R5 = (e, t, n, r, i) => e.ts(t, n, r, i), Ue = (e, t, n, r, i) => e.tt(t, n, r, i), Ba = "WORD", AT = "UWORD", fq = "ASCIINUMERICAL", hq = "ALPHANUMERICAL", Cg = "LOCALHOST", MT = "TLD", NT = "UTLD", $0 = "SCHEME", Nf = "SLASH_SCHEME", LN = "NUM", RT = "WS", BN = "NL", $m = "OPENBRACE", Um = "CLOSEBRACE", sx = "OPENBRACKET", ax = "CLOSEBRACKET", lx = "OPENPAREN", cx = "CLOSEPAREN", ux = "OPENANGLEBRACKET", dx = "CLOSEANGLEBRACKET", fx = "FULLWIDTHLEFTPAREN", hx = "FULLWIDTHRIGHTPAREN", px = "LEFTCORNERBRACKET", mx = "RIGHTCORNERBRACKET", gx = "LEFTWHITECORNERBRACKET", yx = "RIGHTWHITECORNERBRACKET", vx = "FULLWIDTHLESSTHAN", bx = "FULLWIDTHGREATERTHAN", xx = "AMPERSAND", wx = "APOSTROPHE", Sx = "ASTERISK", rc = "AT", kx = "BACKSLASH", Cx = "BACKTICK", Ex = "CARET", sc = "COLON", $N = "COMMA", _x = "DOLLAR", zs = "DOT", Tx = "EQUALS", UN = "EXCLAMATION", Do = "HYPHEN", Fm = "PERCENT", Ax = "PIPE", Mx = "PLUS", Nx = "POUND", Vm = "QUERY", FN = "QUOTE", pq = "FULLWIDTHMIDDLEDOT", VN = "SEMI", Ls = "SLASH", Hm = "TILDE", Rx = "UNDERSCORE", mq = "EMOJI", Ox = "SYM";
var gq = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: hq,
  AMPERSAND: xx,
  APOSTROPHE: wx,
  ASCIINUMERICAL: fq,
  ASTERISK: Sx,
  AT: rc,
  BACKSLASH: kx,
  BACKTICK: Cx,
  CARET: Ex,
  CLOSEANGLEBRACKET: dx,
  CLOSEBRACE: Um,
  CLOSEBRACKET: ax,
  CLOSEPAREN: cx,
  COLON: sc,
  COMMA: $N,
  DOLLAR: _x,
  DOT: zs,
  EMOJI: mq,
  EQUALS: Tx,
  EXCLAMATION: UN,
  FULLWIDTHGREATERTHAN: bx,
  FULLWIDTHLEFTPAREN: fx,
  FULLWIDTHLESSTHAN: vx,
  FULLWIDTHMIDDLEDOT: pq,
  FULLWIDTHRIGHTPAREN: hx,
  HYPHEN: Do,
  LEFTCORNERBRACKET: px,
  LEFTWHITECORNERBRACKET: gx,
  LOCALHOST: Cg,
  NL: BN,
  NUM: LN,
  OPENANGLEBRACKET: ux,
  OPENBRACE: $m,
  OPENBRACKET: sx,
  OPENPAREN: lx,
  PERCENT: Fm,
  PIPE: Ax,
  PLUS: Mx,
  POUND: Nx,
  QUERY: Vm,
  QUOTE: FN,
  RIGHTCORNERBRACKET: mx,
  RIGHTWHITECORNERBRACKET: yx,
  SCHEME: $0,
  SEMI: VN,
  SLASH: Ls,
  SLASH_SCHEME: Nf,
  SYM: Ox,
  TILDE: Hm,
  TLD: MT,
  UNDERSCORE: Rx,
  UTLD: NT,
  UWORD: AT,
  WORD: Ba,
  WS: RT
});
const ja = /[a-z]/, tm = new RegExp("\\p{L}", "u"), iE = new RegExp("\\p{Emoji}", "u"), Ia = /\d/, oE = /\s/, O5 = "\r", sE = `
`, Vje = "", Hje = "", aE = "";
let r0 = null, i0 = null;
function Wje(e = []) {
  const t = {};
  qi.groups = t;
  const n = new qi();
  r0 == null && (r0 = D5(zje)), i0 == null && (i0 = D5(Lje)), Ue(n, "'", wx), Ue(n, "{", $m), Ue(n, "}", Um), Ue(n, "[", sx), Ue(n, "]", ax), Ue(n, "(", lx), Ue(n, ")", cx), Ue(n, "<", ux), Ue(n, ">", dx), Ue(n, "", fx), Ue(n, "", hx), Ue(n, "", px), Ue(n, "", mx), Ue(n, "", gx), Ue(n, "", yx), Ue(n, "", vx), Ue(n, "", bx), Ue(n, "&", xx), Ue(n, "*", Sx), Ue(n, "@", rc), Ue(n, "`", Cx), Ue(n, "^", Ex), Ue(n, ":", sc), Ue(n, ",", $N), Ue(n, "$", _x), Ue(n, ".", zs), Ue(n, "=", Tx), Ue(n, "!", UN), Ue(n, "-", Do), Ue(n, "%", Fm), Ue(n, "|", Ax), Ue(n, "+", Mx), Ue(n, "#", Nx), Ue(n, "?", Vm), Ue(n, '"', FN), Ue(n, "/", Ls), Ue(n, ";", VN), Ue(n, "~", Hm), Ue(n, "_", Rx), Ue(n, "\\", kx), Ue(n, "", pq);
  const r = er(n, Ia, LN, {
    [CT]: !0
  });
  er(r, Ia, r);
  const i = er(r, ja, fq, {
    [Bm]: !0
  }), o = er(r, tm, hq, {
    [vm]: !0
  }), s = er(n, ja, Ba, {
    [ET]: !0
  });
  er(s, Ia, i), er(s, ja, s), er(i, Ia, i), er(i, ja, i);
  const a = er(n, tm, AT, {
    [_T]: !0
  });
  er(a, ja), er(a, Ia, o), er(a, tm, a), er(o, Ia, o), er(o, ja), er(o, tm, o);
  const c = Ue(n, sE, BN, {
    [rE]: !0
  }), u = Ue(n, O5, RT, {
    [rE]: !0
  }), f = er(n, oE, RT, {
    [rE]: !0
  });
  Ue(n, aE, f), Ue(u, sE, c), Ue(u, aE, f), er(u, oE, f), Ue(f, O5), Ue(f, sE), er(f, oE, f), Ue(f, aE, f);
  const h = er(n, iE, mq, {
    [dq]: !0
  });
  Ue(h, "#"), er(h, iE, h), Ue(h, Vje, h);
  const m = Ue(h, Hje);
  Ue(m, "#"), er(m, iE, h);
  const g = [[ja, s], [Ia, i]], b = [[ja, null], [tm, a], [Ia, o]];
  for (let x = 0; x < r0.length; x++)
    Wl(n, r0[x], MT, Ba, g);
  for (let x = 0; x < i0.length; x++)
    Wl(n, i0[x], NT, AT, b);
  Bu(MT, {
    tld: !0,
    ascii: !0
  }, t), Bu(NT, {
    utld: !0,
    alpha: !0
  }, t), Wl(n, "file", $0, Ba, g), Wl(n, "mailto", $0, Ba, g), Wl(n, "http", Nf, Ba, g), Wl(n, "https", Nf, Ba, g), Wl(n, "ftp", Nf, Ba, g), Wl(n, "ftps", Nf, Ba, g), Bu($0, {
    scheme: !0,
    ascii: !0
  }, t), Bu(Nf, {
    slashscheme: !0,
    ascii: !0
  }, t), e = e.sort((x, w) => x[0] > w[0] ? 1 : -1);
  for (let x = 0; x < e.length; x++) {
    const w = e[x][0], _ = e[x][1] ? {
      [Bje]: !0
    } : {
      [$je]: !0
    };
    w.indexOf("-") >= 0 ? _[TT] = !0 : ja.test(w) ? Ia.test(w) ? _[Bm] = !0 : _[ET] = !0 : _[CT] = !0, R5(n, w, w, _);
  }
  return R5(n, "localhost", Cg, {
    ascii: !0
  }), n.jd = new qi(Ox), {
    start: n,
    tokens: Object.assign({
      groups: t
    }, gq)
  };
}
function yq(e, t) {
  const n = qje(t.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = n.length, i = [];
  let o = 0, s = 0;
  for (; s < r; ) {
    let a = e, c = null, u = 0, f = null, h = -1, m = -1;
    for (; s < r && (c = a.go(n[s])); )
      a = c, a.accepts() ? (h = 0, m = 0, f = a) : h >= 0 && (h += n[s].length, m++), u += n[s].length, o += n[s].length, s++;
    o -= h, s -= m, u -= h, i.push({
      t: f.t,
      // token type/name
      v: t.slice(o - u, o),
      // string value
      s: o - u,
      // start index
      e: o
      // end index (excluding)
    });
  }
  return i;
}
function qje(e) {
  const t = [], n = e.length;
  let r = 0;
  for (; r < n; ) {
    let i = e.charCodeAt(r), o, s = i < 55296 || i > 56319 || r + 1 === n || (o = e.charCodeAt(r + 1)) < 56320 || o > 57343 ? e[r] : e.slice(r, r + 2);
    t.push(s), r += s.length;
  }
  return t;
}
function Wl(e, t, n, r, i) {
  let o;
  const s = t.length;
  for (let a = 0; a < s - 1; a++) {
    const c = t[a];
    e.j[c] ? o = e.j[c] : (o = new qi(r), o.jr = i.slice(), e.j[c] = o), e = o;
  }
  return o = new qi(n), o.jr = i.slice(), e.j[t[s - 1]] = o, o;
}
function D5(e) {
  const t = [], n = [];
  let r = 0, i = "0123456789";
  for (; r < e.length; ) {
    let o = 0;
    for (; i.indexOf(e[r + o]) >= 0; )
      o++;
    if (o > 0) {
      t.push(n.join(""));
      for (let s = parseInt(e.substring(r, r + o), 10); s > 0; s--)
        n.pop();
      r += o;
    } else
      n.push(e[r]), r++;
  }
  return t;
}
const Eg = {
  defaultProtocol: "http",
  events: null,
  format: P5,
  formatHref: P5,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function HN(e, t = null) {
  let n = Object.assign({}, Eg);
  e && (n = Object.assign(n, e instanceof HN ? e.o : e));
  const r = n.ignoreTags, i = [];
  for (let o = 0; o < r.length; o++)
    i.push(r[o].toUpperCase());
  this.o = n, t && (this.defaultRender = t), this.ignoreTags = i;
}
HN.prototype = {
  o: Eg,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(e) {
    return e;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(e) {
    return this.get("validate", e.toString(), e);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(e, t, n) {
    const r = t != null;
    let i = this.o[e];
    return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : Eg[e], typeof i == "function" && r && (i = i(t, n))) : typeof i == "function" && r && (i = i(t, n.t, n)), i);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(e, t, n) {
    let r = this.o[e];
    return typeof r == "function" && t != null && (r = r(t, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(e) {
    const t = e.render(this);
    return (this.get("render", null, e) || this.defaultRender)(t, e.t, e);
  }
};
function P5(e) {
  return e;
}
function vq(e, t) {
  this.t = "token", this.v = e, this.tk = t;
}
vq.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(e) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(e) {
    const t = this.toString(), n = e.get("truncate", t, this), r = e.get("format", t, this);
    return n && r.length > n ? r.substring(0, n) + "" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(e) {
    return e.get("formatHref", this.toHref(e.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(e = Eg.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(e),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(e) {
    return {
      type: this.t,
      value: this.toFormattedString(e),
      isLink: this.isLink,
      href: this.toFormattedHref(e),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(e) {
    return e.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(e) {
    const t = this, n = this.toHref(e.get("defaultProtocol")), r = e.get("formatHref", n, this), i = e.get("tagName", n, t), o = this.toFormattedString(e), s = {}, a = e.get("className", n, t), c = e.get("target", n, t), u = e.get("rel", n, t), f = e.getObj("attributes", n, t), h = e.getObj("events", n, t);
    return s.href = r, a && (s.class = a), c && (s.target = c), u && (s.rel = u), f && Object.assign(s, f), {
      tagName: i,
      attributes: s,
      content: o,
      eventListeners: h
    };
  }
};
function e1(e, t) {
  class n extends vq {
    constructor(i, o) {
      super(i, o), this.t = e;
    }
  }
  for (const r in t)
    n.prototype[r] = t[r];
  return n.t = e, n;
}
const j5 = e1("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), I5 = e1("text"), Gje = e1("nl"), o0 = e1("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(e = Eg.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${e}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const e = this.tk;
    return e.length >= 2 && e[0].t !== Cg && e[1].t === sc;
  }
}), Mo = (e) => new qi(e);
function Kje({
  groups: e
}) {
  const t = e.domain.concat([xx, Sx, rc, kx, Cx, Ex, _x, Tx, Do, LN, Fm, Ax, Mx, Nx, Ls, Ox, Hm, Rx]), n = [wx, sc, $N, zs, UN, Fm, Vm, FN, VN, ux, dx, $m, Um, ax, sx, lx, cx, fx, hx, px, mx, gx, yx, vx, bx], r = [xx, wx, Sx, kx, Cx, Ex, _x, Tx, Do, $m, Um, Fm, Ax, Mx, Nx, Vm, Ls, Ox, Hm, Rx], i = Mo(), o = Ue(i, Hm);
  jt(o, r, o), jt(o, e.domain, o);
  const s = Mo(), a = Mo(), c = Mo();
  jt(i, e.domain, s), jt(i, e.scheme, a), jt(i, e.slashscheme, c), jt(s, r, o), jt(s, e.domain, s);
  const u = Ue(s, rc);
  Ue(o, rc, u), Ue(a, rc, u), Ue(c, rc, u);
  const f = Ue(o, zs);
  jt(f, r, o), jt(f, e.domain, o);
  const h = Mo();
  jt(u, e.domain, h), jt(h, e.domain, h);
  const m = Ue(h, zs);
  jt(m, e.domain, h);
  const g = Mo(j5);
  jt(m, e.tld, g), jt(m, e.utld, g), Ue(u, Cg, g);
  const b = Ue(h, Do);
  Ue(b, Do, b), jt(b, e.domain, h), jt(g, e.domain, h), Ue(g, zs, m), Ue(g, Do, b);
  const x = Ue(g, sc);
  jt(x, e.numeric, j5);
  const w = Ue(s, Do), S = Ue(s, zs);
  Ue(w, Do, w), jt(w, e.domain, s), jt(S, r, o), jt(S, e.domain, s);
  const _ = Mo(o0);
  jt(S, e.tld, _), jt(S, e.utld, _), jt(_, e.domain, s), jt(_, r, o), Ue(_, zs, S), Ue(_, Do, w), Ue(_, rc, u);
  const M = Ue(_, sc), N = Mo(o0);
  jt(M, e.numeric, N);
  const P = Mo(o0), I = Mo();
  jt(P, t, P), jt(P, n, I), jt(I, t, P), jt(I, n, I), Ue(_, Ls, P), Ue(N, Ls, P);
  const O = Ue(a, sc), L = Ue(c, sc), U = Ue(L, Ls), B = Ue(U, Ls);
  jt(a, e.domain, s), Ue(a, zs, S), Ue(a, Do, w), jt(c, e.domain, s), Ue(c, zs, S), Ue(c, Do, w), jt(O, e.domain, P), Ue(O, Ls, P), Ue(O, Vm, P), jt(B, e.domain, P), jt(B, t, P), Ue(B, Ls, P);
  const G = [
    [$m, Um],
    // {}
    [sx, ax],
    // []
    [lx, cx],
    // ()
    [ux, dx],
    // <>
    [fx, hx],
    // 
    [px, mx],
    // 
    [gx, yx],
    // 
    [vx, bx]
    // 
  ];
  for (let Y = 0; Y < G.length; Y++) {
    const [he, ie] = G[Y], ne = Ue(P, he);
    Ue(I, he, ne), Ue(ne, ie, P);
    const H = Mo(o0);
    jt(ne, t, H);
    const Q = Mo();
    jt(ne, n), jt(H, t, H), jt(H, n, Q), jt(Q, t, H), jt(Q, n, Q), Ue(H, ie, P), Ue(Q, ie, P);
  }
  return Ue(i, Cg, _), Ue(i, BN, Gje), {
    start: i,
    tokens: gq
  };
}
function Zje(e, t, n) {
  let r = n.length, i = 0, o = [], s = [];
  for (; i < r; ) {
    let a = e, c = null, u = null, f = 0, h = null, m = -1;
    for (; i < r && !(c = a.go(n[i].t)); )
      s.push(n[i++]);
    for (; i < r && (u = c || a.go(n[i].t)); )
      c = null, a = u, a.accepts() ? (m = 0, h = a) : m >= 0 && m++, i++, f++;
    if (m < 0)
      i -= f, i < r && (s.push(n[i]), i++);
    else {
      s.length > 0 && (o.push(lE(I5, t, s)), s = []), i -= m, f -= m;
      const g = h.t, b = n.slice(i - f, i);
      o.push(lE(g, t, b));
    }
  }
  return s.length > 0 && o.push(lE(I5, t, s)), o;
}
function lE(e, t, n) {
  const r = n[0].s, i = n[n.length - 1].e, o = t.slice(r, i);
  return new e(o, n);
}
const Yje = typeof console < "u" && console && console.warn || (() => {
}), Xje = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", Fn = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function Jje() {
  return qi.groups = {}, Fn.scanner = null, Fn.parser = null, Fn.tokenQueue = [], Fn.pluginQueue = [], Fn.customSchemes = [], Fn.initialized = !1, Fn;
}
function z5(e, t = !1) {
  if (Fn.initialized && Yje(`linkifyjs: already initialized - will not register custom scheme "${e}" ${Xje}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(e))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  Fn.customSchemes.push([e, t]);
}
function Qje() {
  Fn.scanner = Wje(Fn.customSchemes);
  for (let e = 0; e < Fn.tokenQueue.length; e++)
    Fn.tokenQueue[e][1]({
      scanner: Fn.scanner
    });
  Fn.parser = Kje(Fn.scanner.tokens);
  for (let e = 0; e < Fn.pluginQueue.length; e++)
    Fn.pluginQueue[e][1]({
      scanner: Fn.scanner,
      parser: Fn.parser
    });
  return Fn.initialized = !0, Fn;
}
function WN(e) {
  return Fn.initialized || Qje(), Zje(Fn.parser.start, e, yq(Fn.scanner.start, e));
}
WN.scan = yq;
function bq(e, t = null, n = null) {
  if (t && typeof t == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${t}; must be a string`);
    n = t, t = null;
  }
  const r = new HN(n), i = WN(e), o = [];
  for (let s = 0; s < i.length; s++) {
    const a = i[s];
    a.isLink && (!t || a.t === t) && r.check(a) && o.push(a.toFormattedObject(r));
  }
  return o;
}
var qN = "[\0- -\u2029]", eIe = new RegExp(qN), tIe = new RegExp(`${qN}$`), nIe = new RegExp(qN, "g");
function rIe(e) {
  return e.length === 1 ? e[0].isLink : e.length === 3 && e[1].isLink ? ["()", "[]"].includes(e[0].value + e[2].value) : !1;
}
function iIe(e) {
  return new Zn({
    key: new Tr("autolink"),
    appendTransaction: (t, n, r) => {
      const i = t.some((u) => u.docChanged) && !n.doc.eq(r.doc), o = t.some((u) => u.getMeta("preventAutolink"));
      if (!i || o)
        return;
      const { tr: s } = r, a = OW(n.doc, [...t]);
      if (BW(a).forEach(({ newRange: u }) => {
        const f = YOe(r.doc, u, (g) => g.isTextblock);
        let h, m;
        if (f.length > 1)
          h = f[0], m = r.doc.textBetween(
            h.pos,
            h.pos + h.node.nodeSize,
            void 0,
            " "
          );
        else if (f.length) {
          const g = r.doc.textBetween(u.from, u.to, " ", " ");
          if (!tIe.test(g))
            return;
          h = f[0], m = r.doc.textBetween(h.pos, u.to, void 0, " ");
        }
        if (h && m) {
          const g = m.split(eIe).filter(Boolean);
          if (g.length <= 0)
            return !1;
          const b = g[g.length - 1], x = h.pos + m.lastIndexOf(b);
          if (!b)
            return !1;
          const w = WN(b).map((S) => S.toObject(e.defaultProtocol));
          if (!rIe(w))
            return !1;
          w.filter((S) => S.isLink).map((S) => ({
            ...S,
            from: x + S.start + 1,
            to: x + S.end + 1
          })).filter((S) => r.schema.marks.code ? !r.doc.rangeHasMark(S.from, S.to, r.schema.marks.code) : !0).filter((S) => e.validate(S.value)).filter((S) => e.shouldAutoLink(S.value)).forEach((S) => {
            ON(S.from, S.to, r.doc).some((_) => _.mark.type === e.type) || s.addMark(
              S.from,
              S.to,
              e.type.create({
                href: S.href
              })
            );
          });
        }
      }), !!s.steps.length)
        return s;
    }
  });
}
function oIe(e) {
  return new Zn({
    key: new Tr("handleClickLink"),
    props: {
      handleClick: (t, n, r) => {
        var i, o;
        if (r.button !== 0 || !t.editable)
          return !1;
        let s = null;
        if (r.target instanceof HTMLAnchorElement)
          s = r.target;
        else {
          const c = r.target;
          if (!c)
            return !1;
          const u = e.editor.view.dom;
          s = c.closest("a"), s && !u.contains(s) && (s = null);
        }
        if (!s)
          return !1;
        let a = !1;
        if (e.enableClickSelection && (a = e.editor.commands.extendMarkRange(e.type.name)), e.openOnClick) {
          const c = LW(t.state, e.type.name), u = (i = s.href) != null ? i : c.href, f = (o = s.target) != null ? o : c.target;
          u && (window.open(u, f), a = !0);
        }
        return a;
      }
    }
  });
}
function sIe(e) {
  return new Zn({
    key: new Tr("handlePasteLink"),
    props: {
      handlePaste: (t, n, r) => {
        const { shouldAutoLink: i } = e, { state: o } = t, { selection: s } = o, { empty: a } = s;
        if (a)
          return !1;
        let c = "";
        r.content.forEach((f) => {
          c += f.textContent;
        });
        const u = bq(c, { defaultProtocol: e.defaultProtocol }).find(
          (f) => f.isLink && f.value === c
        );
        return !c || !u || i !== void 0 && !i(u.value) ? !1 : e.editor.commands.setMark(e.type, {
          href: u.href
        });
      }
    }
  });
}
function _u(e, t) {
  const n = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return t && t.forEach((r) => {
    const i = typeof r == "string" ? r : r.scheme;
    i && n.push(i);
  }), !e || e.replace(nIe, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var aIe = gd.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((e) => {
      if (typeof e == "string") {
        z5(e);
        return;
      }
      z5(e.scheme, e.optionalSlashes);
    });
  },
  onDestroy() {
    Jje();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      enableClickSelection: !1,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (e, t) => !!_u(e, t.protocols),
      validate: (e) => !!e,
      shouldAutoLink: (e) => {
        const t = /^[a-z][a-z0-9+.-]*:\/\//i.test(e), n = /^[a-z][a-z0-9+.-]*:/i.test(e);
        if (t || n && !e.includes("@"))
          return !0;
        const i = (e.includes("@") ? e.split("@").pop() : e).split(/[/?#:]/)[0];
        return !(/^\d{1,3}(\.\d{1,3}){3}$/.test(i) || !/\./.test(i));
      }
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(e) {
          return e.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (e) => {
          const t = e.getAttribute("href");
          return !t || !this.options.isAllowedUri(t, {
            defaultValidate: (n) => !!_u(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return this.options.isAllowedUri(e.href, {
      defaultValidate: (t) => !!_u(t, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", or(this.options.HTMLAttributes, e), 0] : ["a", or(this.options.HTMLAttributes, { ...e, href: "" }), 0];
  },
  markdownTokenName: "link",
  parseMarkdown: (e, t) => t.applyMark("link", t.parseInline(e.tokens || []), {
    href: e.href,
    title: e.title || null
  }),
  renderMarkdown: (e, t) => {
    var n, r, i, o;
    const s = (r = (n = e.attrs) == null ? void 0 : n.href) != null ? r : "", a = (o = (i = e.attrs) == null ? void 0 : i.title) != null ? o : "", c = t.renderChildren(e);
    return a ? `[${c}](${s} "${a}")` : `[${c}](${s})`;
  },
  addCommands() {
    return {
      setLink: (e) => ({ chain: t }) => {
        const { href: n } = e;
        return this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!_u(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? t().setMark(this.name, e).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (e) => ({ chain: t }) => {
        const { href: n } = e || {};
        return n && !this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!_u(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? !1 : t().toggleMark(this.name, e, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run();
      },
      unsetLink: () => ({ chain: e }) => e().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      ld({
        find: (e) => {
          const t = [];
          if (e) {
            const { protocols: n, defaultProtocol: r } = this.options, i = bq(e).filter(
              (o) => o.isLink && this.options.isAllowedUri(o.value, {
                defaultValidate: (s) => !!_u(s, n),
                protocols: n,
                defaultProtocol: r
              })
            );
            i.length && i.forEach((o) => {
              this.options.shouldAutoLink(o.value) && t.push({
                text: o.value,
                data: {
                  href: o.href
                },
                index: o.start
              });
            });
          }
          return t;
        },
        type: this.type,
        getAttributes: (e) => {
          var t;
          return {
            href: (t = e.data) == null ? void 0 : t.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const e = [], { protocols: t, defaultProtocol: n } = this.options;
    return this.options.autolink && e.push(
      iIe({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (r) => this.options.isAllowedUri(r, {
          defaultValidate: (i) => !!_u(i, t),
          protocols: t,
          defaultProtocol: n
        }),
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), e.push(
      oIe({
        type: this.type,
        editor: this.editor,
        openOnClick: this.options.openOnClick === "whenNotEditable" ? !0 : this.options.openOnClick,
        enableClickSelection: this.options.enableClickSelection
      })
    ), this.options.linkOnPaste && e.push(
      sIe({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type,
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), e;
  }
}), lIe = Object.defineProperty, cIe = (e, t) => {
  for (var n in t)
    lIe(e, n, { get: t[n], enumerable: !0 });
}, uIe = "listItem", L5 = "textStyle", B5 = /^\s*([-+*])\s$/, xq = ji.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [{ tag: "ul" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["ul", or(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (e, t) => e.type !== "list" || e.ordered ? [] : {
    type: "bulletList",
    content: e.items ? t.parseChildren(e.items) : []
  },
  renderMarkdown: (e, t) => e.content ? t.renderChildren(e.content, `
`) : "",
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: e, chain: t }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(uIe, this.editor.getAttributes(L5)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let e = bh({
      find: B5,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (e = bh({
      find: B5,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(L5),
      editor: this.editor
    })), [e];
  }
}), wq = ji.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["li", or(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "list_item",
  parseMarkdown: (e, t) => {
    if (e.type !== "list_item")
      return [];
    let n = [];
    if (e.tokens && e.tokens.length > 0)
      if (e.tokens.some((i) => i.type === "paragraph"))
        n = t.parseChildren(e.tokens);
      else {
        const i = e.tokens[0];
        if (i && i.type === "text" && i.tokens && i.tokens.length > 0) {
          if (n = [
            {
              type: "paragraph",
              content: t.parseInline(i.tokens)
            }
          ], e.tokens.length > 1) {
            const s = e.tokens.slice(1), a = t.parseChildren(s);
            n.push(...a);
          }
        } else
          n = t.parseChildren(e.tokens);
      }
    return n.length === 0 && (n = [
      {
        type: "paragraph",
        content: []
      }
    ]), {
      type: "listItem",
      content: n
    };
  },
  renderMarkdown: (e, t, n) => IN(
    e,
    t,
    (r) => {
      var i, o;
      return r.parentType === "bulletList" ? "- " : r.parentType === "orderedList" ? `${(((o = (i = r.meta) == null ? void 0 : i.parentAttrs) == null ? void 0 : o.start) || 1) + r.index}. ` : "- ";
    },
    n
  ),
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), dIe = {};
cIe(dIe, {
  findListItemPos: () => sy,
  getNextListDepth: () => GN,
  handleBackspace: () => OT,
  handleDelete: () => DT,
  hasListBefore: () => Sq,
  hasListItemAfter: () => fIe,
  hasListItemBefore: () => kq,
  listItemHasSubList: () => Cq,
  nextListIsDeeper: () => Eq,
  nextListIsHigher: () => _q
});
var sy = (e, t) => {
  const { $from: n } = t.selection, r = _r(e, t.schema);
  let i = null, o = n.depth, s = n.pos, a = null;
  for (; o > 0 && a === null; )
    i = n.node(o), i.type === r ? a = o : (o -= 1, s -= 1);
  return a === null ? null : { $pos: t.doc.resolve(s), depth: a };
}, GN = (e, t) => {
  const n = sy(e, t);
  if (!n)
    return !1;
  const [, r] = sDe(t, e, n.$pos.pos + 4);
  return r;
}, Sq = (e, t, n) => {
  const { $anchor: r } = e.selection, i = Math.max(0, r.pos - 2), o = e.doc.resolve(i).node();
  return !(!o || !n.includes(o.type.name));
}, kq = (e, t) => {
  var n;
  const { $anchor: r } = t.selection, i = t.doc.resolve(r.pos - 2);
  return !(i.index() === 0 || ((n = i.nodeBefore) == null ? void 0 : n.type.name) !== e);
}, Cq = (e, t, n) => {
  if (!n)
    return !1;
  const r = _r(e, t.schema);
  let i = !1;
  return n.descendants((o) => {
    o.type === r && (i = !0);
  }), i;
}, OT = (e, t, n) => {
  if (e.commands.undoInputRule())
    return !0;
  if (e.state.selection.from !== e.state.selection.to)
    return !1;
  if (!Dc(e.state, t) && Sq(e.state, t, n)) {
    const { $anchor: a } = e.state.selection, c = e.state.doc.resolve(a.before() - 1), u = [];
    c.node().descendants((m, g) => {
      m.type.name === t && u.push({ node: m, pos: g });
    });
    const f = u.at(-1);
    if (!f)
      return !1;
    const h = e.state.doc.resolve(c.start() + f.pos + 1);
    return e.chain().cut({ from: a.start() - 1, to: a.end() + 1 }, h.end()).joinForward().run();
  }
  if (!Dc(e.state, t) || !uDe(e.state))
    return !1;
  const r = sy(t, e.state);
  if (!r)
    return !1;
  const o = e.state.doc.resolve(r.$pos.pos - 2).node(r.depth), s = Cq(t, e.state, o);
  return kq(t, e.state) && !s ? e.commands.joinItemBackward() : e.chain().liftListItem(t).run();
}, Eq = (e, t) => {
  const n = GN(e, t), r = sy(e, t);
  return !r || !n ? !1 : n > r.depth;
}, _q = (e, t) => {
  const n = GN(e, t), r = sy(e, t);
  return !r || !n ? !1 : n < r.depth;
}, DT = (e, t) => {
  if (!Dc(e.state, t) || !cDe(e.state, t))
    return !1;
  const { selection: n } = e.state, { $from: r, $to: i } = n;
  return !n.empty && r.sameParent(i) ? !1 : Eq(t, e.state) ? e.chain().focus(e.state.selection.from + 4).lift(t).joinBackward().run() : _q(t, e.state) ? e.chain().joinForward().joinBackward().run() : e.commands.joinItemForward();
}, fIe = (e, t) => {
  var n;
  const { $anchor: r } = t.selection, i = t.doc.resolve(r.pos - r.parentOffset - 2);
  return !(i.index() === i.parent.childCount - 1 || ((n = i.nodeAfter) == null ? void 0 : n.type.name) !== e);
}, Tq = hr.create({
  name: "listKeymap",
  addOptions() {
    return {
      listTypes: [
        {
          itemName: "listItem",
          wrapperNames: ["bulletList", "orderedList"]
        },
        {
          itemName: "taskItem",
          wrapperNames: ["taskList"]
        }
      ]
    };
  },
  addKeyboardShortcuts() {
    return {
      Delete: ({ editor: e }) => {
        let t = !1;
        return this.options.listTypes.forEach(({ itemName: n }) => {
          e.state.schema.nodes[n] !== void 0 && DT(e, n) && (t = !0);
        }), t;
      },
      "Mod-Delete": ({ editor: e }) => {
        let t = !1;
        return this.options.listTypes.forEach(({ itemName: n }) => {
          e.state.schema.nodes[n] !== void 0 && DT(e, n) && (t = !0);
        }), t;
      },
      Backspace: ({ editor: e }) => {
        let t = !1;
        return this.options.listTypes.forEach(({ itemName: n, wrapperNames: r }) => {
          e.state.schema.nodes[n] !== void 0 && OT(e, n, r) && (t = !0);
        }), t;
      },
      "Mod-Backspace": ({ editor: e }) => {
        let t = !1;
        return this.options.listTypes.forEach(({ itemName: n, wrapperNames: r }) => {
          e.state.schema.nodes[n] !== void 0 && OT(e, n, r) && (t = !0);
        }), t;
      }
    };
  }
}), $5 = /^(\s*)(\d+)\.\s+(.*)$/, hIe = /^\s/;
function pIe(e) {
  const t = [];
  let n = 0, r = 0;
  for (; n < e.length; ) {
    const i = e[n], o = i.match($5);
    if (!o)
      break;
    const [, s, a, c] = o, u = s.length;
    let f = c, h = n + 1;
    const m = [i];
    for (; h < e.length; ) {
      const g = e[h];
      if (g.match($5))
        break;
      if (g.trim() === "")
        m.push(g), f += `
`, h += 1;
      else if (g.match(hIe))
        m.push(g), f += `
${g.slice(u + 2)}`, h += 1;
      else
        break;
    }
    t.push({
      indent: u,
      number: parseInt(a, 10),
      content: f.trim(),
      raw: m.join(`
`)
    }), r = h, n = h;
  }
  return [t, r];
}
function Aq(e, t, n) {
  var r;
  const i = [];
  let o = 0;
  for (; o < e.length; ) {
    const s = e[o];
    if (s.indent === t) {
      const a = s.content.split(`
`), c = ((r = a[0]) == null ? void 0 : r.trim()) || "", u = [];
      c && u.push({
        type: "paragraph",
        raw: c,
        tokens: n.inlineTokens(c)
      });
      const f = a.slice(1).join(`
`).trim();
      if (f) {
        const g = n.blockTokens(f);
        u.push(...g);
      }
      let h = o + 1;
      const m = [];
      for (; h < e.length && e[h].indent > t; )
        m.push(e[h]), h += 1;
      if (m.length > 0) {
        const g = Math.min(...m.map((x) => x.indent)), b = Aq(m, g, n);
        u.push({
          type: "list",
          ordered: !0,
          start: m[0].number,
          items: b,
          raw: m.map((x) => x.raw).join(`
`)
        });
      }
      i.push({
        type: "list_item",
        raw: s.raw,
        tokens: u
      }), o = h;
    } else
      o += 1;
  }
  return i;
}
function mIe(e, t) {
  return e.map((n) => {
    if (n.type !== "list_item")
      return t.parseChildren([n])[0];
    const r = [];
    return n.tokens && n.tokens.length > 0 && n.tokens.forEach((i) => {
      if (i.type === "paragraph" || i.type === "list" || i.type === "blockquote" || i.type === "code")
        r.push(...t.parseChildren([i]));
      else if (i.type === "text" && i.tokens) {
        const o = t.parseChildren([i]);
        r.push({
          type: "paragraph",
          content: o
        });
      } else {
        const o = t.parseChildren([i]);
        o.length > 0 && r.push(...o);
      }
    }), {
      type: "listItem",
      content: r
    };
  });
}
var gIe = "listItem", U5 = "textStyle", F5 = /^(\d+)\.\s$/, Mq = ji.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (e) => e.hasAttribute("start") ? parseInt(e.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: null,
        parseHTML: (e) => e.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    const { start: t, ...n } = e;
    return t === 1 ? ["ol", or(this.options.HTMLAttributes, n), 0] : ["ol", or(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (e, t) => {
    if (e.type !== "list" || !e.ordered)
      return [];
    const n = e.start || 1, r = e.items ? mIe(e.items, t) : [];
    return n !== 1 ? {
      type: "orderedList",
      attrs: { start: n },
      content: r
    } : {
      type: "orderedList",
      content: r
    };
  },
  renderMarkdown: (e, t) => e.content ? t.renderChildren(e.content, `
`) : "",
  markdownTokenizer: {
    name: "orderedList",
    level: "block",
    start: (e) => {
      const t = e.match(/^(\s*)(\d+)\.\s+/), n = t?.index;
      return n !== void 0 ? n : -1;
    },
    tokenize: (e, t, n) => {
      var r;
      const i = e.split(`
`), [o, s] = pIe(i);
      if (o.length === 0)
        return;
      const a = Aq(o, 0, n);
      return a.length === 0 ? void 0 : {
        type: "list",
        ordered: !0,
        start: ((r = o[0]) == null ? void 0 : r.number) || 1,
        items: a,
        raw: i.slice(0, s).join(`
`)
      };
    }
  },
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: e, chain: t }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(gIe, this.editor.getAttributes(U5)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let e = bh({
      find: F5,
      type: this.type,
      getAttributes: (t) => ({ start: +t[1] }),
      joinPredicate: (t, n) => n.childCount + n.attrs.start === +t[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (e = bh({
      find: F5,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (t) => ({ start: +t[1], ...this.editor.getAttributes(U5) }),
      joinPredicate: (t, n) => n.childCount + n.attrs.start === +t[1],
      editor: this.editor
    })), [e];
  }
}), yIe = /^\s*(\[([( |x])?\])\s$/, vIe = ji.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList",
      a11y: void 0
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (e) => {
          const t = e.getAttribute("data-checked");
          return t === "" || t === "true";
        },
        renderHTML: (e) => ({
          "data-checked": e.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "li",
      or(this.options.HTMLAttributes, t, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: e.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  parseMarkdown: (e, t) => {
    const n = [];
    if (e.tokens && e.tokens.length > 0 ? n.push(t.createNode("paragraph", {}, t.parseInline(e.tokens))) : e.text ? n.push(t.createNode("paragraph", {}, [t.createNode("text", { text: e.text })])) : n.push(t.createNode("paragraph", {}, [])), e.nestedTokens && e.nestedTokens.length > 0) {
      const r = t.parseChildren(e.nestedTokens);
      n.push(...r);
    }
    return t.createNode("taskItem", { checked: e.checked || !1 }, n);
  },
  renderMarkdown: (e, t) => {
    var n;
    const i = `- [${(n = e.attrs) != null && n.checked ? "x" : " "}] `;
    return IN(e, t, i);
  },
  addKeyboardShortcuts() {
    const e = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...e,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : e;
  },
  addNodeView() {
    return ({ node: e, HTMLAttributes: t, getPos: n, editor: r }) => {
      const i = document.createElement("li"), o = document.createElement("label"), s = document.createElement("span"), a = document.createElement("input"), c = document.createElement("div"), u = (h) => {
        var m, g;
        a.ariaLabel = ((g = (m = this.options.a11y) == null ? void 0 : m.checkboxLabel) == null ? void 0 : g.call(m, h, a.checked)) || `Task item checkbox for ${h.textContent || "empty task item"}`;
      };
      u(e), o.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (h) => h.preventDefault()), a.addEventListener("change", (h) => {
        if (!r.isEditable && !this.options.onReadOnlyChecked) {
          a.checked = !a.checked;
          return;
        }
        const { checked: m } = h.target;
        r.isEditable && typeof n == "function" && r.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: g }) => {
          const b = n();
          if (typeof b != "number")
            return !1;
          const x = g.doc.nodeAt(b);
          return g.setNodeMarkup(b, void 0, {
            ...x?.attrs,
            checked: m
          }), !0;
        }).run(), !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(e, m) || (a.checked = !a.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([h, m]) => {
        i.setAttribute(h, m);
      }), i.dataset.checked = e.attrs.checked, a.checked = e.attrs.checked, o.append(a, s), i.append(o, c), Object.entries(t).forEach(([h, m]) => {
        i.setAttribute(h, m);
      });
      let f = new Set(Object.keys(t));
      return {
        dom: i,
        contentDOM: c,
        update: (h) => {
          if (h.type !== this.type)
            return !1;
          i.dataset.checked = h.attrs.checked, a.checked = h.attrs.checked, u(h);
          const m = r.extensionManager.attributes, g = yh(h, m), b = new Set(Object.keys(g)), x = this.options.HTMLAttributes;
          return f.forEach((w) => {
            b.has(w) || (w in x ? i.setAttribute(w, x[w]) : i.removeAttribute(w));
          }), Object.entries(g).forEach(([w, S]) => {
            S == null ? w in x ? i.setAttribute(w, x[w]) : i.removeAttribute(w) : i.setAttribute(w, S);
          }), f = b, !0;
        }
      };
    };
  },
  addInputRules() {
    return [
      bh({
        find: yIe,
        type: this.type,
        getAttributes: (e) => ({
          checked: e[e.length - 1] === "x"
        })
      })
    ];
  }
}), bIe = ji.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["ul", or(this.options.HTMLAttributes, e, { "data-type": this.name }), 0];
  },
  parseMarkdown: (e, t) => t.createNode("taskList", {}, t.parseChildren(e.items || [])),
  renderMarkdown: (e, t) => e.content ? t.renderChildren(e.content, `
`) : "",
  markdownTokenizer: {
    name: "taskList",
    level: "block",
    start(e) {
      var t;
      const n = (t = e.match(/^\s*[-+*]\s+\[([ xX])\]\s+/)) == null ? void 0 : t.index;
      return n !== void 0 ? n : -1;
    },
    tokenize(e, t, n) {
      const r = (o) => {
        const s = ST(
          o,
          {
            itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
            extractItemData: (a) => ({
              indentLevel: a[1].length,
              mainContent: a[4],
              checked: a[3].toLowerCase() === "x"
            }),
            createToken: (a, c) => ({
              type: "taskItem",
              raw: "",
              mainContent: a.mainContent,
              indentLevel: a.indentLevel,
              checked: a.checked,
              text: a.mainContent,
              tokens: n.inlineTokens(a.mainContent),
              nestedTokens: c
            }),
            // Allow recursive nesting
            customNestedParser: r
          },
          n
        );
        return s ? [
          {
            type: "taskList",
            raw: s.raw,
            items: s.items
          }
        ] : n.blockTokens(o);
      }, i = ST(
        e,
        {
          itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
          extractItemData: (o) => ({
            indentLevel: o[1].length,
            mainContent: o[4],
            checked: o[3].toLowerCase() === "x"
          }),
          createToken: (o, s) => ({
            type: "taskItem",
            raw: "",
            mainContent: o.mainContent,
            indentLevel: o.indentLevel,
            checked: o.checked,
            text: o.mainContent,
            tokens: n.inlineTokens(o.mainContent),
            nestedTokens: s
          }),
          // Use the recursive parser for nested content
          customNestedParser: r
        },
        n
      );
      if (i)
        return {
          type: "taskList",
          raw: i.raw,
          items: i.items
        };
    }
  },
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: e }) => e.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
hr.create({
  name: "listKit",
  addExtensions() {
    const e = [];
    return this.options.bulletList !== !1 && e.push(xq.configure(this.options.bulletList)), this.options.listItem !== !1 && e.push(wq.configure(this.options.listItem)), this.options.listKeymap !== !1 && e.push(Tq.configure(this.options.listKeymap)), this.options.orderedList !== !1 && e.push(Mq.configure(this.options.orderedList)), this.options.taskItem !== !1 && e.push(vIe.configure(this.options.taskItem)), this.options.taskList !== !1 && e.push(bIe.configure(this.options.taskList)), e;
  }
});
var V5 = "&nbsp;", xIe = "", wIe = ji.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["p", or(this.options.HTMLAttributes, e), 0];
  },
  parseMarkdown: (e, t) => {
    const n = e.tokens || [];
    if (n.length === 1 && n[0].type === "image")
      return t.parseChildren([n[0]]);
    const r = t.parseInline(n);
    return r.length === 1 && r[0].type === "text" && (r[0].text === V5 || r[0].text === xIe) ? t.createNode("paragraph", void 0, []) : t.createNode("paragraph", void 0, r);
  },
  renderMarkdown: (e, t) => {
    if (!e)
      return "";
    const n = Array.isArray(e.content) ? e.content : [];
    return n.length === 0 ? V5 : t.renderChildren(n);
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: e }) => e.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), SIe = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, kIe = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, CIe = gd.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (e) => e.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["s", or(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "del",
  parseMarkdown: (e, t) => t.applyMark("strike", t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => `~~${t.renderChildren(e)}~~`,
  addCommands() {
    return {
      setStrike: () => ({ commands: e }) => e.setMark(this.name),
      toggleStrike: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetStrike: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      vh({
        find: SIe,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ld({
        find: kIe,
        type: this.type
      })
    ];
  }
}), EIe = ji.create({
  name: "text",
  group: "inline",
  parseMarkdown: (e) => ({
    type: "text",
    text: e.text || ""
  }),
  renderMarkdown: (e) => e.text || ""
}), _Ie = gd.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (e) => e.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["u", or(this.options.HTMLAttributes, e), 0];
  },
  parseMarkdown(e, t) {
    return t.applyMark(this.name || "underline", t.parseInline(e.tokens || []));
  },
  renderMarkdown(e, t) {
    return `++${t.renderChildren(e)}++`;
  },
  markdownTokenizer: {
    name: "underline",
    level: "inline",
    start(e) {
      return e.indexOf("++");
    },
    tokenize(e, t, n) {
      const i = /^(\+\+)([\s\S]+?)(\+\+)/.exec(e);
      if (!i)
        return;
      const o = i[2].trim();
      return {
        type: "underline",
        raw: i[0],
        text: o,
        tokens: n.inlineTokens(o)
      };
    }
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: e }) => e.setMark(this.name),
      toggleUnderline: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetUnderline: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
function TIe(e = {}) {
  return new Zn({
    view(t) {
      return new AIe(t, e);
    }
  });
}
class AIe {
  constructor(t, n) {
    var r;
    this.editorView = t, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let o = (s) => {
        this[i](s);
      };
      return t.dom.addEventListener(i, o), { name: i, handler: o };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: t, handler: n }) => this.editorView.dom.removeEventListener(t, n));
  }
  update(t, n) {
    this.cursorPos != null && n.doc != t.state.doc && (this.cursorPos > t.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(t) {
    t != this.cursorPos && (this.cursorPos = t, t == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let t = this.editorView.state.doc.resolve(this.cursorPos), n = !t.parent.inlineContent, r, i = this.editorView.dom, o = i.getBoundingClientRect(), s = o.width / i.offsetWidth, a = o.height / i.offsetHeight;
    if (n) {
      let h = t.nodeBefore, m = t.nodeAfter;
      if (h || m) {
        let g = this.editorView.nodeDOM(this.cursorPos - (h ? h.nodeSize : 0));
        if (g) {
          let b = g.getBoundingClientRect(), x = h ? b.bottom : b.top;
          h && m && (x = (x + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let w = this.width / 2 * a;
          r = { left: b.left, right: b.right, top: x - w, bottom: x + w };
        }
      }
    }
    if (!r) {
      let h = this.editorView.coordsAtPos(this.cursorPos), m = this.width / 2 * s;
      r = { left: h.left - m, right: h.left + m, top: h.top, bottom: h.bottom };
    }
    let c = this.editorView.dom.offsetParent;
    this.element || (this.element = c.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let u, f;
    if (!c || c == document.body && getComputedStyle(c).position == "static")
      u = -pageXOffset, f = -pageYOffset;
    else {
      let h = c.getBoundingClientRect(), m = h.width / c.offsetWidth, g = h.height / c.offsetHeight;
      u = h.left - c.scrollLeft * m, f = h.top - c.scrollTop * g;
    }
    this.element.style.left = (r.left - u) / s + "px", this.element.style.top = (r.top - f) / a + "px", this.element.style.width = (r.right - r.left) / s + "px", this.element.style.height = (r.bottom - r.top) / a + "px";
  }
  scheduleRemoval(t) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), t);
  }
  dragover(t) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: t.clientX, top: t.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), i = r && r.type.spec.disableDropCursor, o = typeof i == "function" ? i(this.editorView, n, t) : i;
    if (n && !o) {
      let s = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = kH(this.editorView.state.doc, s, this.editorView.dragging.slice);
        a != null && (s = a);
      }
      this.setCursor(s), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(t) {
    this.editorView.dom.contains(t.relatedTarget) || this.setCursor(null);
  }
}
class rr extends zt {
  /**
  Create a gap cursor.
  */
  constructor(t) {
    super(t, t);
  }
  map(t, n) {
    let r = t.resolve(n.map(this.head));
    return rr.valid(r) ? new rr(r) : zt.near(r);
  }
  content() {
    return Qe.empty;
  }
  eq(t) {
    return t instanceof rr && t.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new rr(t.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new KN(this.anchor);
  }
  /**
  @internal
  */
  static valid(t) {
    let n = t.parent;
    if (n.isTextblock || !MIe(t) || !NIe(t))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = n.contentMatchAt(t.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(t, n, r = !1) {
    e: for (; ; ) {
      if (!r && rr.valid(t))
        return t;
      let i = t.pos, o = null;
      for (let s = t.depth; ; s--) {
        let a = t.node(s);
        if (n > 0 ? t.indexAfter(s) < a.childCount : t.index(s) > 0) {
          o = a.child(n > 0 ? t.indexAfter(s) : t.index(s) - 1);
          break;
        } else if (s == 0)
          return null;
        i += n;
        let c = t.doc.resolve(i);
        if (rr.valid(c))
          return c;
      }
      for (; ; ) {
        let s = n > 0 ? o.firstChild : o.lastChild;
        if (!s) {
          if (o.isAtom && !o.isText && !ht.isSelectable(o)) {
            t = t.doc.resolve(i + o.nodeSize * n), r = !1;
            continue e;
          }
          break;
        }
        o = s, i += n;
        let a = t.doc.resolve(i);
        if (rr.valid(a))
          return a;
      }
      return null;
    }
  }
}
rr.prototype.visible = !1;
rr.findFrom = rr.findGapCursorFrom;
zt.jsonID("gapcursor", rr);
class KN {
  constructor(t) {
    this.pos = t;
  }
  map(t) {
    return new KN(t.map(this.pos));
  }
  resolve(t) {
    let n = t.resolve(this.pos);
    return rr.valid(n) ? new rr(n) : zt.near(n);
  }
}
function Nq(e) {
  return e.isAtom || e.spec.isolating || e.spec.createGapCursor;
}
function MIe(e) {
  for (let t = e.depth; t >= 0; t--) {
    let n = e.index(t), r = e.node(t);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || Nq(i.type))
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function NIe(e) {
  for (let t = e.depth; t >= 0; t--) {
    let n = e.indexAfter(t), r = e.node(t);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || Nq(i.type))
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function RIe() {
  return new Zn({
    props: {
      decorations: jIe,
      createSelectionBetween(e, t, n) {
        return t.pos == n.pos && rr.valid(n) ? new rr(n) : null;
      },
      handleClick: DIe,
      handleKeyDown: OIe,
      handleDOMEvents: { beforeinput: PIe }
    }
  });
}
const OIe = CW({
  ArrowLeft: s0("horiz", -1),
  ArrowRight: s0("horiz", 1),
  ArrowUp: s0("vert", -1),
  ArrowDown: s0("vert", 1)
});
function s0(e, t) {
  const n = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
  return function(r, i, o) {
    let s = r.selection, a = t > 0 ? s.$to : s.$from, c = s.empty;
    if (s instanceof kt) {
      if (!o.endOfTextblock(n) || a.depth == 0)
        return !1;
      c = !1, a = r.doc.resolve(t > 0 ? a.after() : a.before());
    }
    let u = rr.findGapCursorFrom(a, t, c);
    return u ? (i && i(r.tr.setSelection(new rr(u))), !0) : !1;
  };
}
function DIe(e, t, n) {
  if (!e || !e.editable)
    return !1;
  let r = e.state.doc.resolve(t);
  if (!rr.valid(r))
    return !1;
  let i = e.posAtCoords({ left: n.clientX, top: n.clientY });
  return i && i.inside > -1 && ht.isSelectable(e.state.doc.nodeAt(i.inside)) ? !1 : (e.dispatch(e.state.tr.setSelection(new rr(r))), !0);
}
function PIe(e, t) {
  if (t.inputType != "insertCompositionText" || !(e.state.selection instanceof rr))
    return !1;
  let { $from: n } = e.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(e.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = $e.empty;
  for (let s = r.length - 1; s >= 0; s--)
    i = $e.from(r[s].createAndFill(null, i));
  let o = e.state.tr.replace(n.pos, n.pos, new Qe(i, 0, 0));
  return o.setSelection(kt.near(o.doc.resolve(n.pos + 1))), e.dispatch(o), !1;
}
function jIe(e) {
  if (!(e.selection instanceof rr))
    return null;
  let t = document.createElement("div");
  return t.className = "ProseMirror-gapcursor", qn.create(e.doc, [gi.widget(e.selection.head, t, { key: "gapcursor" })]);
}
var Dx = 200, Wr = function() {
};
Wr.prototype.append = function(t) {
  return t.length ? (t = Wr.from(t), !this.length && t || t.length < Dx && this.leafAppend(t) || this.length < Dx && t.leafPrepend(this) || this.appendInner(t)) : this;
};
Wr.prototype.prepend = function(t) {
  return t.length ? Wr.from(t).append(this) : this;
};
Wr.prototype.appendInner = function(t) {
  return new IIe(this, t);
};
Wr.prototype.slice = function(t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = this.length), t >= n ? Wr.empty : this.sliceInner(Math.max(0, t), Math.min(this.length, n));
};
Wr.prototype.get = function(t) {
  if (!(t < 0 || t >= this.length))
    return this.getInner(t);
};
Wr.prototype.forEach = function(t, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(t, n, r, 0) : this.forEachInvertedInner(t, n, r, 0);
};
Wr.prototype.map = function(t, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(o, s) {
    return i.push(t(o, s));
  }, n, r), i;
};
Wr.from = function(t) {
  return t instanceof Wr ? t : t && t.length ? new Rq(t) : Wr.empty;
};
var Rq = /* @__PURE__ */ (function(e) {
  function t(r) {
    e.call(this), this.values = r;
  }
  e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return t.prototype.flatten = function() {
    return this.values;
  }, t.prototype.sliceInner = function(i, o) {
    return i == 0 && o == this.length ? this : new t(this.values.slice(i, o));
  }, t.prototype.getInner = function(i) {
    return this.values[i];
  }, t.prototype.forEachInner = function(i, o, s, a) {
    for (var c = o; c < s; c++)
      if (i(this.values[c], a + c) === !1)
        return !1;
  }, t.prototype.forEachInvertedInner = function(i, o, s, a) {
    for (var c = o - 1; c >= s; c--)
      if (i(this.values[c], a + c) === !1)
        return !1;
  }, t.prototype.leafAppend = function(i) {
    if (this.length + i.length <= Dx)
      return new t(this.values.concat(i.flatten()));
  }, t.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= Dx)
      return new t(i.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(t.prototype, n), t;
})(Wr);
Wr.empty = new Rq([]);
var IIe = /* @__PURE__ */ (function(e) {
  function t(n, r) {
    e.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, t.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, t.prototype.forEachInner = function(r, i, o, s) {
    var a = this.left.length;
    if (i < a && this.left.forEachInner(r, i, Math.min(o, a), s) === !1 || o > a && this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, o) - a, s + a) === !1)
      return !1;
  }, t.prototype.forEachInvertedInner = function(r, i, o, s) {
    var a = this.left.length;
    if (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(o, a) - a, s + a) === !1 || o < a && this.left.forEachInvertedInner(r, Math.min(i, a), o, s) === !1)
      return !1;
  }, t.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var o = this.left.length;
    return i <= o ? this.left.slice(r, i) : r >= o ? this.right.slice(r - o, i - o) : this.left.slice(r, o).append(this.right.slice(0, i - o));
  }, t.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new t(this.left, i);
  }, t.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new t(i, this.right);
  }, t.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new t(this.left, new t(this.right, r)) : new t(this, r);
  }, t;
})(Wr);
const zIe = 500;
class as {
  constructor(t, n) {
    this.items = t, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(t, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, o;
    n && (i = this.remapping(r, this.items.length), o = i.maps.length);
    let s = t.tr, a, c, u = [], f = [];
    return this.items.forEach((h, m) => {
      if (!h.step) {
        i || (i = this.remapping(r, m + 1), o = i.maps.length), o--, f.push(h);
        return;
      }
      if (i) {
        f.push(new Bs(h.map));
        let g = h.step.map(i.slice(o)), b;
        g && s.maybeStep(g).doc && (b = s.mapping.maps[s.mapping.maps.length - 1], u.push(new Bs(b, void 0, void 0, u.length + f.length))), o--, b && i.appendMap(b, o);
      } else
        s.maybeStep(h.step);
      if (h.selection)
        return a = i ? h.selection.map(i.slice(o)) : h.selection, c = new as(this.items.slice(0, r).append(f.reverse().concat(u)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: c, transform: s, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(t, n, r, i) {
    let o = [], s = this.eventCount, a = this.items, c = !i && a.length ? a.get(a.length - 1) : null;
    for (let f = 0; f < t.steps.length; f++) {
      let h = t.steps[f].invert(t.docs[f]), m = new Bs(t.mapping.maps[f], h, n), g;
      (g = c && c.merge(m)) && (m = g, f ? o.pop() : a = a.slice(0, a.length - 1)), o.push(m), n && (s++, n = void 0), i || (c = m);
    }
    let u = s - r.depth;
    return u > BIe && (a = LIe(a, u), s -= u), new as(a.append(o), s);
  }
  remapping(t, n) {
    let r = new yg();
    return this.items.forEach((i, o) => {
      let s = i.mirrorOffset != null && o - i.mirrorOffset >= t ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, s);
    }, t, n), r;
  }
  addMaps(t) {
    return this.eventCount == 0 ? this : new as(this.items.append(t.map((n) => new Bs(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(t, n) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - n), o = t.mapping, s = t.steps.length, a = this.eventCount;
    this.items.forEach((m) => {
      m.selection && a--;
    }, i);
    let c = n;
    this.items.forEach((m) => {
      let g = o.getMirror(--c);
      if (g == null)
        return;
      s = Math.min(s, g);
      let b = o.maps[g];
      if (m.step) {
        let x = t.steps[g].invert(t.docs[g]), w = m.selection && m.selection.map(o.slice(c + 1, g));
        w && a++, r.push(new Bs(b, x, w));
      } else
        r.push(new Bs(b));
    }, i);
    let u = [];
    for (let m = n; m < s; m++)
      u.push(new Bs(o.maps[m]));
    let f = this.items.slice(0, i).append(u).append(r), h = new as(f, a);
    return h.emptyItemCount() > zIe && (h = h.compress(this.items.length - r.length)), h;
  }
  emptyItemCount() {
    let t = 0;
    return this.items.forEach((n) => {
      n.step || t++;
    }), t;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(t = this.items.length) {
    let n = this.remapping(0, t), r = n.maps.length, i = [], o = 0;
    return this.items.forEach((s, a) => {
      if (a >= t)
        i.push(s), s.selection && o++;
      else if (s.step) {
        let c = s.step.map(n.slice(r)), u = c && c.getMap();
        if (r--, u && n.appendMap(u, r), c) {
          let f = s.selection && s.selection.map(n.slice(r));
          f && o++;
          let h = new Bs(u.invert(), c, f), m, g = i.length - 1;
          (m = i.length && i[g].merge(h)) ? i[g] = m : i.push(h);
        }
      } else s.map && r--;
    }, this.items.length, 0), new as(Wr.from(i.reverse()), o);
  }
}
as.empty = new as(Wr.empty, 0);
function LIe(e, t) {
  let n;
  return e.forEach((r, i) => {
    if (r.selection && t-- == 0)
      return n = i, !1;
  }), e.slice(n);
}
class Bs {
  constructor(t, n, r, i) {
    this.map = t, this.step = n, this.selection = r, this.mirrorOffset = i;
  }
  merge(t) {
    if (this.step && t.step && !t.selection) {
      let n = t.step.merge(this.step);
      if (n)
        return new Bs(n.getMap().invert(), n, this.selection);
    }
  }
}
class ic {
  constructor(t, n, r, i, o) {
    this.done = t, this.undone = n, this.prevRanges = r, this.prevTime = i, this.prevComposition = o;
  }
}
const BIe = 20;
function $Ie(e, t, n, r) {
  let i = n.getMeta(Gu), o;
  if (i)
    return i.historyState;
  n.getMeta(VIe) && (e = new ic(e.done, e.undone, null, 0, -1));
  let s = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return e;
  if (s && s.getMeta(Gu))
    return s.getMeta(Gu).redo ? new ic(e.done.addTransform(n, void 0, r, U0(t)), e.undone, H5(n.mapping.maps), e.prevTime, e.prevComposition) : new ic(e.done, e.undone.addTransform(n, void 0, r, U0(t)), null, e.prevTime, e.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(s && s.getMeta("addToHistory") === !1)) {
    let a = n.getMeta("composition"), c = e.prevTime == 0 || !s && e.prevComposition != a && (e.prevTime < (n.time || 0) - r.newGroupDelay || !UIe(n, e.prevRanges)), u = s ? cE(e.prevRanges, n.mapping) : H5(n.mapping.maps);
    return new ic(e.done.addTransform(n, c ? t.selection.getBookmark() : void 0, r, U0(t)), as.empty, u, n.time, a ?? e.prevComposition);
  } else return (o = n.getMeta("rebased")) ? new ic(e.done.rebased(n, o), e.undone.rebased(n, o), cE(e.prevRanges, n.mapping), e.prevTime, e.prevComposition) : new ic(e.done.addMaps(n.mapping.maps), e.undone.addMaps(n.mapping.maps), cE(e.prevRanges, n.mapping), e.prevTime, e.prevComposition);
}
function UIe(e, t) {
  if (!t)
    return !1;
  if (!e.docChanged)
    return !0;
  let n = !1;
  return e.mapping.maps[0].forEach((r, i) => {
    for (let o = 0; o < t.length; o += 2)
      r <= t[o + 1] && i >= t[o] && (n = !0);
  }), n;
}
function H5(e) {
  let t = [];
  for (let n = e.length - 1; n >= 0 && t.length == 0; n--)
    e[n].forEach((r, i, o, s) => t.push(o, s));
  return t;
}
function cE(e, t) {
  if (!e)
    return null;
  let n = [];
  for (let r = 0; r < e.length; r += 2) {
    let i = t.map(e[r], 1), o = t.map(e[r + 1], -1);
    i <= o && n.push(i, o);
  }
  return n;
}
function FIe(e, t, n) {
  let r = U0(t), i = Gu.get(t).spec.config, o = (n ? e.undone : e.done).popEvent(t, r);
  if (!o)
    return null;
  let s = o.selection.resolve(o.transform.doc), a = (n ? e.done : e.undone).addTransform(o.transform, t.selection.getBookmark(), i, r), c = new ic(n ? a : o.remaining, n ? o.remaining : a, null, 0, -1);
  return o.transform.setSelection(s).setMeta(Gu, { redo: n, historyState: c });
}
let uE = !1, W5 = null;
function U0(e) {
  let t = e.plugins;
  if (W5 != t) {
    uE = !1, W5 = t;
    for (let n = 0; n < t.length; n++)
      if (t[n].spec.historyPreserveItems) {
        uE = !0;
        break;
      }
  }
  return uE;
}
const Gu = new Tr("history"), VIe = new Tr("closeHistory");
function HIe(e = {}) {
  return e = {
    depth: e.depth || 100,
    newGroupDelay: e.newGroupDelay || 500
  }, new Zn({
    key: Gu,
    state: {
      init() {
        return new ic(as.empty, as.empty, null, 0, -1);
      },
      apply(t, n, r) {
        return $Ie(n, r, t, e);
      }
    },
    config: e,
    props: {
      handleDOMEvents: {
        beforeinput(t, n) {
          let r = n.inputType, i = r == "historyUndo" ? Dq : r == "historyRedo" ? Pq : null;
          return !i || !t.editable ? !1 : (n.preventDefault(), i(t.state, t.dispatch));
        }
      }
    }
  });
}
function Oq(e, t) {
  return (n, r) => {
    let i = Gu.getState(n);
    if (!i || (e ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let o = FIe(i, n, e);
      o && r(t ? o.scrollIntoView() : o);
    }
    return !0;
  };
}
const Dq = Oq(!1, !0), Pq = Oq(!0, !0);
hr.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (e) => e.length,
      wordCounter: (e) => e.split(" ").filter((t) => t !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (e) => {
      const t = e?.node || this.editor.state.doc;
      if ((e?.mode || this.options.mode) === "textSize") {
        const r = t.textBetween(0, t.content.size, void 0, " ");
        return this.options.textCounter(r);
      }
      return t.nodeSize;
    }, this.storage.words = (e) => {
      const t = e?.node || this.editor.state.doc, n = t.textBetween(0, t.content.size, " ", " ");
      return this.options.wordCounter(n);
    };
  },
  addProseMirrorPlugins() {
    let e = !1;
    return [
      new Zn({
        key: new Tr("characterCount"),
        appendTransaction: (t, n, r) => {
          if (e)
            return;
          const i = this.options.limit;
          if (i == null || i === 0) {
            e = !0;
            return;
          }
          const o = this.storage.characters({ node: r.doc });
          if (o > i) {
            const s = o - i, a = 0, c = s;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${i} characters. Content was automatically trimmed.`
            );
            const u = r.tr.deleteRange(a, c);
            return e = !0, u;
          }
          e = !0;
        },
        filterTransaction: (t, n) => {
          const r = this.options.limit;
          if (!t.docChanged || r === 0 || r === null || r === void 0)
            return !0;
          const i = this.storage.characters({ node: n.doc }), o = this.storage.characters({ node: t.doc });
          if (o <= r || i > r && o > r && o <= i)
            return !0;
          if (i > r && o > r && o > i || !t.getMeta("paste"))
            return !1;
          const a = t.selection.$head.pos, c = o - r, u = a - c, f = a;
          return t.deleteRange(u, f), !(this.storage.characters({ node: t.doc }) > r);
        }
      })
    ];
  }
});
var WIe = hr.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [TIe(this.options)];
  }
});
hr.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("focus"),
        props: {
          decorations: ({ doc: e, selection: t }) => {
            const { isEditable: n, isFocused: r } = this.editor, { anchor: i } = t, o = [];
            if (!n || !r)
              return qn.create(e, []);
            let s = 0;
            this.options.mode === "deepest" && e.descendants((c, u) => {
              if (c.isText)
                return;
              if (!(i >= u && i <= u + c.nodeSize - 1))
                return !1;
              s += 1;
            });
            let a = 0;
            return e.descendants((c, u) => {
              if (c.isText || !(i >= u && i <= u + c.nodeSize - 1))
                return !1;
              if (a += 1, this.options.mode === "deepest" && s - a > 0 || this.options.mode === "shallowest" && a > 1)
                return this.options.mode === "deepest";
              o.push(
                gi.node(u, u + c.nodeSize, {
                  class: this.options.className
                })
              );
            }), qn.create(e, o);
          }
        }
      })
    ];
  }
});
var qIe = hr.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [RIe()];
  },
  extendNodeSchema(e) {
    var t;
    const n = {
      name: e.name,
      options: e.options,
      storage: e.storage
    };
    return {
      allowGapCursor: (t = mn(ft(e, "allowGapCursor", n))) != null ? t : null
    };
  }
}), q5 = "placeholder";
function GIe(e) {
  return e.replace(/\s+/g, "-").replace(/[^a-zA-Z0-9-]/g, "").replace(/^[0-9-]+/, "").replace(/^-+/, "").toLowerCase();
}
var KIe = hr.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      dataAttribute: q5,
      placeholder: "Write something ",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    const e = this.options.dataAttribute ? `data-${GIe(this.options.dataAttribute)}` : `data-${q5}`;
    return [
      new Zn({
        key: new Tr("placeholder"),
        props: {
          decorations: ({ doc: t, selection: n }) => {
            const r = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: i } = n, o = [];
            if (!r)
              return null;
            const s = this.editor.isEmpty;
            return t.descendants((a, c) => {
              const u = i >= c && i <= c + a.nodeSize, f = !a.isLeaf && Xw(a);
              if ((u || !this.options.showOnlyCurrent) && f) {
                const h = [this.options.emptyNodeClass];
                s && h.push(this.options.emptyEditorClass);
                const m = gi.node(c, c + a.nodeSize, {
                  class: h.join(" "),
                  [e]: typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: a,
                    pos: c,
                    hasAnchor: u
                  }) : this.options.placeholder
                });
                o.push(m);
              }
              return this.options.includeChildren;
            }), qn.create(t, o);
          }
        }
      })
    ];
  }
});
hr.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor: e, options: t } = this;
    return [
      new Zn({
        key: new Tr("selection"),
        props: {
          decorations(n) {
            return n.selection.empty || e.isFocused || !e.isEditable || $W(n.selection) || e.view.dragging ? null : qn.create(n.doc, [
              gi.inline(n.selection.from, n.selection.to, {
                class: t.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function G5({ types: e, node: t }) {
  return t && Array.isArray(e) && e.includes(t.type) || t?.type === e;
}
var ZIe = hr.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: void 0,
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    var e;
    const t = new Tr(this.name), n = this.options.node || ((e = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : e.name) || "paragraph", r = Object.entries(this.editor.schema.nodes).map(([, i]) => i).filter((i) => (this.options.notAfter || []).concat(n).includes(i.name));
    return [
      new Zn({
        key: t,
        appendTransaction: (i, o, s) => {
          const { doc: a, tr: c, schema: u } = s, f = t.getState(s), h = a.content.size, m = u.nodes[n];
          if (f)
            return c.insert(h, m.create());
        },
        state: {
          init: (i, o) => {
            const s = o.tr.doc.lastChild;
            return !G5({ node: s, types: r });
          },
          apply: (i, o) => {
            if (!i.docChanged || i.getMeta("__uniqueIDTransaction"))
              return o;
            const s = i.doc.lastChild;
            return !G5({ node: s, types: r });
          }
        }
      })
    ];
  }
}), YIe = hr.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: e, dispatch: t }) => Dq(e, t),
      redo: () => ({ state: e, dispatch: t }) => Pq(e, t)
    };
  },
  addProseMirrorPlugins() {
    return [HIe(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
}), XIe = hr.create({
  name: "starterKit",
  addExtensions() {
    var e, t, n, r;
    const i = [];
    return this.options.bold !== !1 && i.push(wje.configure(this.options.bold)), this.options.blockquote !== !1 && i.push(gje.configure(this.options.blockquote)), this.options.bulletList !== !1 && i.push(xq.configure(this.options.bulletList)), this.options.code !== !1 && i.push(Cje.configure(this.options.code)), this.options.codeBlock !== !1 && i.push(Tje.configure(this.options.codeBlock)), this.options.document !== !1 && i.push(Aje.configure(this.options.document)), this.options.dropcursor !== !1 && i.push(WIe.configure(this.options.dropcursor)), this.options.gapcursor !== !1 && i.push(qIe.configure(this.options.gapcursor)), this.options.hardBreak !== !1 && i.push(Mje.configure(this.options.hardBreak)), this.options.heading !== !1 && i.push(Nje.configure(this.options.heading)), this.options.undoRedo !== !1 && i.push(YIe.configure(this.options.undoRedo)), this.options.horizontalRule !== !1 && i.push(Rje.configure(this.options.horizontalRule)), this.options.italic !== !1 && i.push(Ije.configure(this.options.italic)), this.options.listItem !== !1 && i.push(wq.configure(this.options.listItem)), this.options.listKeymap !== !1 && i.push(Tq.configure((e = this.options) == null ? void 0 : e.listKeymap)), this.options.link !== !1 && i.push(aIe.configure((t = this.options) == null ? void 0 : t.link)), this.options.orderedList !== !1 && i.push(Mq.configure(this.options.orderedList)), this.options.paragraph !== !1 && i.push(wIe.configure(this.options.paragraph)), this.options.strike !== !1 && i.push(CIe.configure(this.options.strike)), this.options.text !== !1 && i.push(EIe.configure(this.options.text)), this.options.underline !== !1 && i.push(_Ie.configure((n = this.options) == null ? void 0 : n.underline)), this.options.trailingNode !== !1 && i.push(ZIe.configure((r = this.options) == null ? void 0 : r.trailingNode)), i;
  }
}), JIe = XIe, QIe = KIe;
function eze(e) {
  var t;
  const { char: n, allowSpaces: r, allowToIncludeChar: i, allowedPrefixes: o, startOfLine: s, $position: a } = e, c = r && !i, u = XDe(n), f = new RegExp(`\\s${u}$`), h = s ? "^" : "", m = i ? "" : u, g = c ? new RegExp(`${h}${u}.*?(?=\\s${m}|$)`, "gm") : new RegExp(`${h}(?:^)?${u}[^\\s${m}]*`, "gm"), b = ((t = a.nodeBefore) == null ? void 0 : t.isText) && a.nodeBefore.text;
  if (!b)
    return null;
  const x = a.pos - b.length, w = Array.from(b.matchAll(g)).pop();
  if (!w || w.input === void 0 || w.index === void 0)
    return null;
  const S = w.input.slice(Math.max(0, w.index - 1), w.index), _ = new RegExp(`^[${o?.join("")}\0]?$`).test(S);
  if (o !== null && !_)
    return null;
  const M = x + w.index;
  let N = M + w[0].length;
  return c && f.test(b.slice(N - 1, N + 1)) && (w[0] += " ", N += 1), M < a.pos && N >= a.pos ? {
    range: {
      from: M,
      to: N
    },
    query: w[0].slice(n.length),
    text: w[0]
  } : null;
}
var tze = new Tr("suggestion");
function nze({
  pluginKey: e = tze,
  editor: t,
  char: n = "@",
  allowSpaces: r = !1,
  allowToIncludeChar: i = !1,
  allowedPrefixes: o = [" "],
  startOfLine: s = !1,
  decorationTag: a = "span",
  decorationClass: c = "suggestion",
  decorationContent: u = "",
  decorationEmptyClass: f = "is-empty",
  command: h = () => null,
  items: m = () => [],
  render: g = () => ({}),
  allow: b = () => !0,
  findSuggestionMatch: x = eze,
  shouldShow: w
}) {
  let S;
  const _ = g?.(), M = () => {
    const O = t.state.selection.$anchor.pos, L = t.view.coordsAtPos(O), { top: U, right: B, bottom: G, left: Y } = L;
    try {
      return new DOMRect(Y, U, B - Y, G - U);
    } catch {
      return null;
    }
  }, N = (O, L) => L ? () => {
    const U = e.getState(t.state), B = U?.decorationId, G = O.dom.querySelector(`[data-decoration-id="${B}"]`);
    return G?.getBoundingClientRect() || null;
  } : M;
  function P(O, L) {
    var U;
    try {
      const G = e.getState(O.state), Y = G?.decorationId ? O.dom.querySelector(`[data-decoration-id="${G.decorationId}"]`) : null, he = {
        // @ts-ignore editor is available in closure
        editor: t,
        range: G?.range || { from: 0, to: 0 },
        query: G?.query || null,
        text: G?.text || null,
        items: [],
        command: (ie) => h({ editor: t, range: G?.range || { from: 0, to: 0 }, props: ie }),
        decorationNode: Y,
        clientRect: N(O, Y)
      };
      (U = _?.onExit) == null || U.call(_, he);
    } catch {
    }
    const B = O.state.tr.setMeta(L, { exit: !0 });
    O.dispatch(B);
  }
  const I = new Zn({
    key: e,
    view() {
      return {
        update: async (O, L) => {
          var U, B, G, Y, he, ie, ne;
          const H = (U = this.key) == null ? void 0 : U.getState(L), Q = (B = this.key) == null ? void 0 : B.getState(O.state), X = H.active && Q.active && H.range.from !== Q.range.from, Se = !H.active && Q.active, W = H.active && !Q.active, Z = !Se && !W && H.query !== Q.query, pe = Se || X && Z, F = Z || X, ee = W || X && Z;
          if (!pe && !F && !ee)
            return;
          const ge = ee && !pe ? H : Q, re = O.dom.querySelector(`[data-decoration-id="${ge.decorationId}"]`);
          S = {
            editor: t,
            range: ge.range,
            query: ge.query,
            text: ge.text,
            items: [],
            command: (J) => h({
              editor: t,
              range: ge.range,
              props: J
            }),
            decorationNode: re,
            clientRect: N(O, re)
          }, pe && ((G = _?.onBeforeStart) == null || G.call(_, S)), F && ((Y = _?.onBeforeUpdate) == null || Y.call(_, S)), (F || pe) && (S.items = await m({
            editor: t,
            query: ge.query
          })), ee && ((he = _?.onExit) == null || he.call(_, S)), F && ((ie = _?.onUpdate) == null || ie.call(_, S)), pe && ((ne = _?.onStart) == null || ne.call(_, S));
        },
        destroy: () => {
          var O;
          S && ((O = _?.onExit) == null || O.call(_, S));
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        return {
          active: !1,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: !1
        };
      },
      // Apply changes to the plugin state from a view transaction.
      apply(O, L, U, B) {
        const { isEditable: G } = t, { composing: Y } = t.view, { selection: he } = O, { empty: ie, from: ne } = he, H = { ...L }, Q = O.getMeta(e);
        if (Q && Q.exit)
          return H.active = !1, H.decorationId = null, H.range = { from: 0, to: 0 }, H.query = null, H.text = null, H;
        if (H.composing = Y, G && (ie || t.view.composing)) {
          (ne < L.range.from || ne > L.range.to) && !Y && !L.composing && (H.active = !1);
          const X = x({
            char: n,
            allowSpaces: r,
            allowToIncludeChar: i,
            allowedPrefixes: o,
            startOfLine: s,
            $position: he.$from
          }), Se = `id_${Math.floor(Math.random() * 4294967295)}`;
          X && b({
            editor: t,
            state: B,
            range: X.range,
            isActive: L.active
          }) && (!w || w({
            editor: t,
            range: X.range,
            query: X.query,
            text: X.text,
            transaction: O
          })) ? (H.active = !0, H.decorationId = L.decorationId ? L.decorationId : Se, H.range = X.range, H.query = X.query, H.text = X.text) : H.active = !1;
        } else
          H.active = !1;
        return H.active || (H.decorationId = null, H.range = { from: 0, to: 0 }, H.query = null, H.text = null), H;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(O, L) {
        var U, B, G, Y;
        const { active: he, range: ie } = I.getState(O.state);
        if (!he)
          return !1;
        if (L.key === "Escape" || L.key === "Esc") {
          const H = I.getState(O.state), Q = (U = S?.decorationNode) != null ? U : null, X = Q ?? (H?.decorationId ? O.dom.querySelector(`[data-decoration-id="${H.decorationId}"]`) : null);
          if (((B = _?.onKeyDown) == null ? void 0 : B.call(_, { view: O, event: L, range: H.range })) || !1)
            return !0;
          const W = {
            editor: t,
            range: H.range,
            query: H.query,
            text: H.text,
            items: [],
            command: (Z) => h({ editor: t, range: H.range, props: Z }),
            decorationNode: X,
            // If we have a cached decoration node, use it for the clientRect
            // to avoid another DOM lookup. If not, leave clientRect null and
            // let consumer decide if they want to query.
            clientRect: X ? () => X.getBoundingClientRect() || null : null
          };
          return (G = _?.onExit) == null || G.call(_, W), P(O, e), !0;
        }
        return ((Y = _?.onKeyDown) == null ? void 0 : Y.call(_, { view: O, event: L, range: ie })) || !1;
      },
      // Setup decorator on the currently active suggestion.
      decorations(O) {
        const { active: L, range: U, decorationId: B, query: G } = I.getState(O);
        if (!L)
          return null;
        const Y = !G?.length, he = [c];
        return Y && he.push(f), qn.create(O.doc, [
          gi.inline(U.from, U.to, {
            nodeName: a,
            class: he.join(" "),
            "data-decoration-id": B,
            "data-decoration-content": u
          })
        ]);
      }
    }
  });
  return I;
}
var rze = nze;
function ize() {
  return /* @__PURE__ */ v.jsxs("svg", { className: "animate-spin h-4 w-4 text-muted-foreground", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ v.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4", fill: "none" }),
    /* @__PURE__ */ v.jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" })
  ] });
}
function a0({
  items: e,
  selectedIndex: t,
  onSelect: n,
  onHover: r,
  loading: i = !1
}) {
  const [o, s] = k.useState(""), a = k.useMemo(() => {
    const u = (Array.isArray(e) ? e : Object.values(e)).flatMap(
      (h) => Object.values(h)
    );
    if (!o.trim()) return u;
    const f = o.trim().toLowerCase();
    return u.filter(
      (h) => h.name.toLowerCase().includes(f) || h.description?.toLowerCase().includes(f) || h.serverName.toLowerCase().includes(f)
    );
  }, [e, o]);
  return /* @__PURE__ */ v.jsxs("div", { className: "bg-popover rounded-lg shadow-lg divide-y max-h-96 overflow-auto w-96 mb-2 border focus:border-accent", children: [
    /* @__PURE__ */ v.jsx("div", { className: "px-4 py-2 sticky top-0 bg-popover z-10 border-b", children: /* @__PURE__ */ v.jsx(
      "input",
      {
        type: "text",
        className: "w-full px-2 py-1 rounded border text-sm bg-background outline-none focus:ring-2 focus:ring-accent focus:border-accent",
        placeholder: "Search tools... (name / description / mcp)",
        value: o,
        onChange: (c) => s(c.target.value)
      }
    ) }),
    i ? /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 px-4 py-3", children: [
      /* @__PURE__ */ v.jsx(ize, {}),
      /* @__PURE__ */ v.jsx("div", { className: "text-sm text-muted-foreground", children: "Loading tools..." })
    ] }) : a.length === 0 ? /* @__PURE__ */ v.jsx("div", { className: "px-4 py-3 text-sm text-muted-foreground", children: "No results" }) : a.map((c, u) => /* @__PURE__ */ v.jsxs(
      "div",
      {
        role: "option",
        "aria-selected": u === t,
        onMouseDown: (f) => {
          f.preventDefault(), n(c);
        },
        onMouseEnter: () => r(u),
        className: `flex items-center gap-3 px-4 py-3 cursor-pointer transition-colors select-none ${u === t ? "bg-accent/15 text-accent-foreground" : "hover:bg-accent/50"}`,
        children: [
          /* @__PURE__ */ v.jsx("div", { className: "shrink-0 w-8 h-8 rounded-full bg-slate-100 dark:bg-neutral-800 flex items-center justify-center text-sm font-semibold text-slate-700", children: c.name ? c.name.charAt(0).toUpperCase() : "?" }),
          /* @__PURE__ */ v.jsxs("div", { className: "min-w-0 flex-1", children: [
            /* @__PURE__ */ v.jsxs(Gi, { children: [
              /* @__PURE__ */ v.jsx(FA, { asChild: !0, children: /* @__PURE__ */ v.jsx("span", { className: "font-medium text-sm truncate hover:underline decoration-dotted cursor-help", children: c.name }) }),
              /* @__PURE__ */ v.jsxs(ew, { side: "right", align: "start", className: "z-1000 bg-white/95 backdrop-blur text-neutral-900 max-w-xs text-xs shadow-2xl border border-neutral-200 rounded-xl px-5 py-4", children: [
                /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3 mb-2", children: [
                  /* @__PURE__ */ v.jsx("div", { className: "w-9 h-9 rounded-full bg-linear-to-tr from-accent to-muted flex items-center justify-center text-lg font-bold text-white shadow", children: c.name ? c.name.charAt(0).toUpperCase() : "?" }),
                  /* @__PURE__ */ v.jsxs("div", { children: [
                    /* @__PURE__ */ v.jsx("div", { className: "font-semibold text-base text-neutral-800", children: c.name }),
                    /* @__PURE__ */ v.jsxs("div", { className: "text-[11px] text-neutral-500 mt-0.5", children: [
                      "MCP: ",
                      /* @__PURE__ */ v.jsx("span", { className: "font-medium text-neutral-700", children: c.serverName })
                    ] })
                  ] })
                ] }),
                c.description && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
                  /* @__PURE__ */ v.jsx("div", { className: "border-t border-neutral-200 my-2" }),
                  /* @__PURE__ */ v.jsx("div", { className: "text-sm text-neutral-700 leading-relaxed", children: c.description })
                ] })
              ] })
            ] }),
            c.description && /* @__PURE__ */ v.jsx("div", { className: "text-xs text-muted-foreground truncate mt-0.5", children: c.description }),
            /* @__PURE__ */ v.jsxs("div", { className: "text-[11px] text-muted-foreground truncate mt-0.5", children: [
              "MCP: ",
              /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: c.serverName })
            ] })
          ] }),
          /* @__PURE__ */ v.jsxs("div", { className: "ml-auto flex items-center gap-2", children: [
            /* @__PURE__ */ v.jsx("span", { className: "text-[11px] px-2 py-0.5 rounded bg-muted text-muted-foreground", children: c.serverName }),
            /* @__PURE__ */ v.jsx("div", { className: "text-xs text-neutral-400", children: "Select" })
          ] })
        ]
      },
      `${c.serverId}-${c.id || c.name}-${u}`
    ))
  ] });
}
function oze(e) {
  return {
    items: async ({ query: t }) => {
      try {
        const n = e?.mcpServerList?.value || [], r = e?.allowedMcpServers?.value || {}, i = n.reduce((a, c) => {
          const u = c.name, f = c.id, h = r[f]?.tools || [];
          a[u] || (a[u] = []);
          const m = c.toolInfo.filter((g) => h.includes(g.name)).map((g) => ({
            ...g,
            serverId: c.id,
            serverName: c.name
          }));
          return m.length > 0 && a[u].push(...m), a;
        }, {});
        if (!t) return i;
        const o = String(t).toLowerCase();
        return Object.fromEntries(
          Object.entries(i).map(([a, c]) => [
            a,
            c.filter((u) => u.name.toLowerCase().includes(o))
          ]).filter(([, a]) => a.length > 0)
        );
      } catch {
        return [];
      }
    },
    render: () => {
      let t = null, n = null, r = {}, i = 0, o = null;
      const s = () => Object.values(r).flat();
      return {
        onStart: (a) => {
          o = a.command, r = a.items || {}, i = 0, t = document.createElement("div"), t.style.position = "absolute", t.style.zIndex = "9999", t.style.left = "0px", t.style.top = "0px", document.body.appendChild(t);
          const c = () => {
            if (!t || !a.clientRect) return;
            const u = a.clientRect();
            if (u) {
              t.style.left = `${u.left + window.scrollX}px`;
              const f = t.offsetHeight || 40;
              t.style.top = `${u.top + window.scrollY - f}px`, t.style.width = `${u.width}px`;
            }
          };
          n = S3.createRoot(t), n.render(
            /* @__PURE__ */ v.jsx(
              a0,
              {
                items: a.items,
                selectedIndex: 0,
                onSelect: (u) => {
                  console.log("Selected mention item:", u), a.command(u);
                },
                onHover: (u) => {
                  i = u;
                }
              }
            )
          ), requestAnimationFrame(c);
        },
        onUpdate: (a) => {
          o = a.command, r = a.items || {};
          const c = s();
          i = Math.min(i, Math.max(c.length - 1, 0)), n && n.render(
            /* @__PURE__ */ v.jsx(
              a0,
              {
                items: r,
                selectedIndex: i,
                onSelect: (u) => a.command(u),
                onHover: (u) => {
                  i = u;
                }
              }
            )
          ), t && a.clientRect && requestAnimationFrame(() => {
            if (!t) return;
            const f = a.clientRect();
            if (f) {
              const h = t.offsetHeight || 40;
              t.style.left = `${f.left + window.scrollX}px`, t.style.top = `${f.top + window.scrollY - h}px`, t.style.width = `${f.width}px`;
            }
          });
        },
        onKeyDown: (a) => {
          const c = a.event;
          if (c.key === "ArrowDown") {
            c.preventDefault(), c.stopPropagation();
            const u = s();
            return i = Math.min(i + 1, Math.max(u.length - 1, 0)), n && n.render(
              /* @__PURE__ */ v.jsx(
                a0,
                {
                  items: r,
                  selectedIndex: i,
                  onSelect: (f) => {
                    o && o(f);
                  },
                  onHover: (f) => {
                    i = f;
                  }
                }
              )
            ), !0;
          }
          if (c.key === "ArrowUp")
            return c.preventDefault(), c.stopPropagation(), i = Math.max(i - 1, 0), n && n.render(
              /* @__PURE__ */ v.jsx(
                a0,
                {
                  items: r,
                  selectedIndex: i,
                  onSelect: (u) => {
                    o && o(u);
                  },
                  onHover: (u) => {
                    i = u;
                  }
                }
              )
            ), !0;
          if (c.key === "Enter" || c.key === "Tab") {
            const u = s()[i];
            if (u && o)
              return c.preventDefault(), c.stopPropagation(), o(u), !0;
          }
          return !1;
        },
        onExit: () => {
          if (n && t) {
            n.unmount();
            try {
              t.remove();
            } catch {
            }
            n = null, t = null;
          }
          if (t) {
            try {
              t.remove();
            } catch {
            }
            t = null;
          }
        }
      };
    }
  };
}
const sze = ji.create({
  name: "mention",
  inline: !0,
  group: "inline",
  atom: !0,
  addOptions() {
    return {
      chatbotServerStore: void 0
    };
  },
  addAttributes() {
    return {
      id: { default: null },
      label: { default: null },
      description: { default: null },
      serverId: { default: null },
      serverName: { default: null }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span[data-mention]"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "span",
      or(t, { "data-mention": "", "data-id": e.attrs.id, class: "mention-node" }),
      `@${e.attrs.label}`
    ];
  },
  addCommands() {
    return {
      insertMention: (e) => ({ chain: t }) => {
        try {
          return t().focus().insertContent({ type: this.name, attrs: e }).run();
        } catch {
          return !1;
        }
      }
    };
  },
  addProseMirrorPlugins() {
    const e = this.editor, t = oze(this.options.chatbotServerStore), n = Object.assign({ editor: e, char: "@", startOfLine: !1 }, t);
    return n.command = ({ editor: r, range: i, props: o }) => {
      try {
        const s = o.label || o.name || o.id || "unknown";
        setTimeout(() => {
          r.chain().focus().setTextSelection(i.from).deleteRange(i).insertContent([{
            type: "mention",
            attrs: {
              id: o.id || o.name,
              label: s,
              description: o.description,
              serverId: o.serverId,
              serverName: o.serverName
            }
          }, { type: "text", text: " " }]).run();
        }, 0);
        const a = new CustomEvent("tiptap-mention-inserted", { detail: { ...o, label: s } });
        window.dispatchEvent(a);
      } catch (s) {
        console.error("Error inserting mention:", s);
      }
    }, [rze(n)];
  }
}), aze = (e) => {
  const { node: t, deleteNode: n, editor: r } = e, { id: i, name: o, classUri: s, versionId: a } = t.attrs, [c, u] = k.useState(!1), f = (S) => {
    S.preventDefault(), S.stopPropagation(), n(), setTimeout(() => {
      try {
        r?.commands?.focus();
      } catch {
      }
    }, 0);
  }, h = (S) => {
    S.preventDefault(), S.stopPropagation();
    const _ = new CustomEvent("entity-isolate", {
      detail: { id: i, name: o, classUri: s, versionId: a }
    });
    window.dispatchEvent(_), cn.success(`Isolated ${o}`);
  }, m = (S) => {
    S.preventDefault(), S.stopPropagation();
    const _ = new CustomEvent("entity-reset-visibility", {
      detail: { id: i, name: o }
    });
    window.dispatchEvent(_), cn.success("Reset visibility");
  }, g = (S) => {
    S.preventDefault(), S.stopPropagation();
    const _ = [
      `Name: ${o}`,
      i ? `Element ID: ${i}` : null,
      a ? `Version ID: ${a}` : null,
      s ? `Class: ${s}` : null
    ].filter(Boolean).join(`
`);
    navigator.clipboard.writeText(_).then(() => {
      cn.success("Copied entity info");
    }).catch(() => {
      cn.error("Failed to copy");
    });
  }, b = (S) => {
    S.preventDefault(), S.stopPropagation();
    const _ = new CustomEvent("entity-zoom-select", {
      detail: { id: i, name: o, classUri: s, versionId: a }
    });
    window.dispatchEvent(_);
  }, x = () => {
    u(!0);
    const S = new CustomEvent("entity-hover", {
      detail: { id: i, name: o, classUri: s, versionId: a, hover: !0 }
    });
    window.dispatchEvent(S);
  }, w = () => {
    u(!1);
    const S = new CustomEvent("entity-hover", {
      detail: { id: i, name: o, classUri: s, versionId: a, hover: !1 }
    });
    window.dispatchEvent(S);
  };
  return /* @__PURE__ */ v.jsx(aje, { className: "inline select-none", contentEditable: !1, children: /* @__PURE__ */ v.jsxs(
    "span",
    {
      className: "mt-1 inline-flex items-center gap-1 mx-0.5 px-2 py-0.5 rounded-md bg-emerald-600/20 border border-emerald-600/30 cursor-default transition-colors hover:bg-emerald-600/30",
      onMouseEnter: x,
      onMouseLeave: w,
      onDoubleClick: b,
      children: [
        /* @__PURE__ */ v.jsx("span", { className: "select-none", children: o || "Entity" }),
        /* @__PURE__ */ v.jsxs("div", { className: "inline-flex items-center gap-0.5", children: [
          c && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
            /* @__PURE__ */ v.jsx(
              "button",
              {
                className: "inline-flex items-center justify-center bg-transparent border-none cursor-pointer p-0.5 m-0 text-emerald-600/80 transition-all rounded-sm hover:bg-emerald-600/20 hover:text-emerald-600",
                onClick: h,
                onMouseDown: (S) => S.preventDefault(),
                title: "Isolate",
                children: /* @__PURE__ */ v.jsx(BT, { className: "h-3 w-3" })
              }
            ),
            /* @__PURE__ */ v.jsx(
              "button",
              {
                className: "inline-flex items-center justify-center bg-transparent border-none cursor-pointer p-0.5 m-0 text-emerald-600/80 transition-all rounded-sm hover:bg-emerald-600/20 hover:text-emerald-600",
                onClick: m,
                onMouseDown: (S) => S.preventDefault(),
                title: "Reset visibility",
                children: /* @__PURE__ */ v.jsx(UT, { className: "h-3 w-3" })
              }
            ),
            /* @__PURE__ */ v.jsx(
              "button",
              {
                className: "inline-flex items-center justify-center bg-transparent border-none cursor-pointer p-0.5 m-0 text-emerald-600/80 transition-all rounded-sm hover:bg-emerald-600/20 hover:text-emerald-600",
                onClick: g,
                onMouseDown: (S) => S.preventDefault(),
                title: "Copy info",
                children: /* @__PURE__ */ v.jsx(kc, { className: "h-3 w-3" })
              }
            )
          ] }),
          /* @__PURE__ */ v.jsx(
            "button",
            {
              className: "inline-flex items-center justify-center bg-transparent border-none cursor-pointer p-0.5 m-0 text-emerald-600/60 transition-all rounded-sm hover:bg-red-500/10 hover:text-red-500",
              onClick: f,
              onMouseDown: (S) => S.preventDefault(),
              title: "Remove entity",
              children: /* @__PURE__ */ v.jsx(Ng, { className: "h-3 w-3" })
            }
          )
        ] })
      ]
    }
  ) });
}, lze = ji.create({
  name: "entity",
  inline: !0,
  group: "inline",
  atom: !0,
  draggable: !1,
  addAttributes() {
    return {
      id: { default: null },
      name: { default: null },
      classUri: { default: null },
      versionId: { default: null }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span[data-entity]"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "span",
      or(t, {
        "data-entity": "",
        "data-id": e.attrs.id,
        "data-class-uri": e.attrs.classUri,
        "data-version-id": e.attrs.versionId,
        class: "entity-node"
      }),
      e.attrs.name ? String(e.attrs.name) : "Entity"
    ];
  },
  addNodeView() {
    return hje(aze);
  },
  renderText({ node: e }) {
    const t = e?.attrs?.name ? String(e.attrs.name) : "Entity", n = e?.attrs?.id ? String(e.attrs.id) : "", r = e?.attrs?.versionId ? String(e.attrs.versionId) : "";
    return n && r ? `[Name: ${t}, Element Id: ${n}: VersionId: ${r}]` : n ? `[${t}:${n}]` : r ? `[Name: ${t}, VersionId:${r}]` : `[${t}]`;
  }
});
async function cze() {
  const e = await Lc(), t = await fetch(`${Wa}/chat/tools`, { headers: e });
  if (!t.ok) return { ok: !1, tools: [] };
  const n = await t.json().catch(() => null);
  return Array.isArray(n) ? { ok: !0, tools: n } : n && Array.isArray(n?.tools) ? {
    ok: !!(n?.ok ?? !0),
    tools: n.tools
  } : { ok: !1, tools: [] };
}
function uze(e) {
  const {
    localValue: t,
    history: n,
    historyIndex: r,
    setHistoryIndex: i,
    setLocalValue: o,
    onChange: s,
    doSendAndClear: a,
    mention: c
  } = e;
  return (u) => {
    if ((u.ctrlKey || u.metaKey) && (u.key === "c" || u.key === "v" || u.key === "x" || u.key === "a")) {
      u.stopPropagation();
      return;
    }
    if ((u.ctrlKey || u.metaKey) && u.key === "End") {
      u.preventDefault(), a();
      return;
    }
    if (u.ctrlKey && u.key === "Enter" && (u.preventDefault(), a()), u.key === "ArrowUp") {
      if (t.trim() === "" && n.length === 0) return;
      if (t.trim() === "" || r !== null) {
        u.preventDefault();
        const h = r === null ? n.length - 1 : Math.max(0, r - 1);
        i(h);
        const m = n[h];
        m !== void 0 && (o(m), s && s(m));
      }
      return;
    }
    try {
      if (c.handleKeyDown(u), u.defaultPrevented) return;
    } catch {
    }
    if (u.key === "ArrowDown") {
      if (r === null) return;
      u.preventDefault();
      const h = r + 1;
      if (h >= n.length)
        i(null), o(""), s && s("");
      else {
        i(h);
        const m = n[h];
        m !== void 0 && (o(m), s && s(m));
      }
      return;
    }
  };
}
function dze(e) {
  if (!isFinite(e) || e <= 0) return "0 B";
  const t = ["B", "KB", "MB", "GB", "TB"], n = Math.min(t.length - 1, Math.floor(Math.log(e) / Math.log(1024))), r = e / Math.pow(1024, n);
  return `${n === 0 ? Math.round(r) : r.toFixed(2)} ${t[n]}`;
}
async function fze(e) {
  if (!e) throw new Error("No file provided");
  try {
    const t = await VAe(e);
    if (!t) throw new Error("No metadata returned from S3 upload");
    return {
      fileName: e.name,
      mimeType: e.type || t.mimeType || "application/octet-stream",
      s3Key: t.s3Key || t.key || t.keyName || "",
      size: e.size,
      url: t.url || t.s3Url || t.location || void 0,
      status: "uploaded",
      ...t
    };
  } catch (t) {
    return console.error("S3 upload failed:", t), {
      fileName: e.name,
      mimeType: e.type || "application/octet-stream",
      s3Key: "",
      size: e.size,
      status: "error",
      error: t?.message || String(t)
    };
  }
}
function hze({
  number: e,
  className: t
}) {
  const n = r6(0), r = Une(n, Math.round);
  return k.useEffect(() => ore(n, e, { duration: 1 }).stop, [e]), /* @__PURE__ */ v.jsx(Wf.span, { className: at(t), children: r });
}
const pze = 2500, mze = (e) => {
  const {
    tools: t,
    onClickAllChecked: n,
    isAuthorizing: r,
    authorizationUrl: i,
    error: o,
    checked: s,
    onToolClick: a
  } = e, [c, u] = k.useState(!1), [f, h] = k.useState(""), [m, g] = k.useState(!1), b = k.useRef(null), x = !!i, w = k.useMemo(() => t.filter(
    (N) => N.name.toLowerCase().includes(f.toLowerCase())
  ), [t, f]), S = k.useCallback(() => {
    b.current !== null && (window.clearInterval(b.current), b.current = null), g(!1);
  }, []), _ = k.useCallback(() => {
    b.current === null && (b.current = window.setInterval(() => {
      g_(`${Ws}/list`);
    }, pze), g(!0));
  }, []);
  k.useEffect(() => {
    (!r || o) && S();
  }, [o, r, S]), k.useEffect(() => S, [S]);
  const M = k.useCallback(
    () => rN(() => u(!0)).ifOk(() => (x && (window.open(i, "_blank", "noopener,noreferrer"), _()), g_(`${Ws}/list`))).ifFail(ub).watch(() => u(!1)),
    [i, x, _]
  );
  return r ? /* @__PURE__ */ v.jsxs(
    a9,
    {
      className: "transition-colors border-none",
      children: [
        c ? /* @__PURE__ */ v.jsx($T, { className: "animate-spin" }) : /* @__PURE__ */ v.jsx(W0, {}),
        /* @__PURE__ */ v.jsx(l9, { children: "Authorization Required" }),
        /* @__PURE__ */ v.jsx(c9, { children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2", children: [
          /* @__PURE__ */ v.jsx("span", { children: m ? "Waiting for authorization to complete." : "Pending authorization to access this MCP server." }),
          /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "outline",
              size: "sm",
              onClick: M,
              disabled: !x || c,
              className: "cursor-pointer",
              children: "Authorize"
            }
          )
        ] }) })
      ]
    }
  ) : /* @__PURE__ */ v.jsxs("div", { children: [
    /* @__PURE__ */ v.jsxs(
      Tfe,
      {
        className: "text-muted-foreground flex items-center gap-2",
        onClick: (N) => {
          N.preventDefault(), n(!s);
        },
        children: [
          /* @__PURE__ */ v.jsx(
            "input",
            {
              autoFocus: !0,
              placeholder: "Search tools...",
              value: f,
              onKeyDown: (N) => {
                N.stopPropagation();
              },
              onChange: (N) => h(N.target.value),
              onClick: (N) => {
                N.stopPropagation();
              },
              className: "placeholder:text-muted-foreground flex w-full text-xs   outline-hidden disabled:cursor-not-allowed disabled:opacity-50"
            }
          ),
          /* @__PURE__ */ v.jsx("div", { className: "flex-1" }),
          /* @__PURE__ */ v.jsx(K7, { checked: s })
        ]
      }
    ),
    /* @__PURE__ */ v.jsx(gb, {}),
    /* @__PURE__ */ v.jsx("div", { className: "max-h-96 overflow-y-auto", children: w.length === 0 ? /* @__PURE__ */ v.jsx("div", { className: "text-sm text-muted-foreground w-full h-full flex items-center justify-center py-6", children: "No results found" }) : w.map((N) => /* @__PURE__ */ v.jsxs(
      ls,
      {
        className: "flex items-center gap-2 cursor-pointer mb-1",
        onClick: (P) => {
          P.preventDefault(), a(N.name, !N.checked);
        },
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "mx-1 flex-1 min-w-0", children: [
            /* @__PURE__ */ v.jsx("p", { className: "font-medium text-xs mb-1 truncate", children: N.name }),
            /* @__PURE__ */ v.jsx("p", { className: "text-xs text-muted-foreground truncate", children: N.description })
          ] }),
          /* @__PURE__ */ v.jsx(U7, { checked: N.checked, className: "ml-auto" })
        ]
      },
      N.name
    )) })
  ] });
}, gze = () => {
  const {
    chatbotServerStore: { allowedMcpServers: e, mcpServerList: t }
  } = ra(), n = k.useMemo(() => t.value.length === 0 ? [] : [...t.value].sort(
    (i, o) => (i.status === "connected" ? -1 : 1) - (o.status === "connected" ? -1 : 1)
  ).map((i) => {
    const o = e.value?.[i.id]?.tools ?? [];
    return {
      id: i.id,
      serverName: i.name,
      checked: o.length > 0,
      tools: (i.toolInfo || []).map((s) => ({
        name: s.name,
        checked: o.includes(s.name),
        description: s.description
      })),
      error: i.error,
      status: i.status,
      authorizationUrl: i.authorizationUrl
    };
  }), [t.value, e.value]), r = k.useCallback(
    (i, o) => {
      const a = {
        ...e.value || {},
        [i]: {
          tools: o
        }
      };
      e.value = a, localStorage.setItem(cb.ALLOWED_MCP_SERVERS, JSON.stringify(a));
    },
    [e]
  );
  return /* @__PURE__ */ v.jsxs(Efe, { className: "max-h-96 overflow-y-auto", children: [
    n.map((i) => /* @__PURE__ */ v.jsxs(Afe, { children: [
      /* @__PURE__ */ v.jsxs(
        Mfe,
        {
          className: "flex items-center gap-2 font-semibold cursor-pointer",
          onClick: (o) => {
            o.preventDefault(), r(
              i.id,
              i.checked ? [] : i.tools.map((s) => s.name)
            );
          },
          children: [
            /* @__PURE__ */ v.jsx("div", { className: "flex items-center justify-center p-1 rounded bg-input/40 border", children: /* @__PURE__ */ v.jsx(sh, { className: "fill-foreground size-2.5" }) }),
            /* @__PURE__ */ v.jsx("span", { className: at("truncate", !i.checked && "opacity-30"), children: i.serverName }),
            i.error ? /* @__PURE__ */ v.jsx(
              "span",
              {
                className: at("text-xs text-destructive ml-1 p-1 rounded"),
                children: "error"
              }
            ) : null,
            /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-2 ml-auto", children: i.status === "authorizing" ? /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-1", children: /* @__PURE__ */ v.jsx(W0, { className: "size-3 text-muted-foreground" }) }) : /* @__PURE__ */ v.jsx(v.Fragment, { children: i.tools.filter((o) => o.checked).length > 0 ? /* @__PURE__ */ v.jsx("span", { className: "w-5 h-5 items-center justify-start flex text-[8px] text-muted-foreground font-semibold ", children: /* @__PURE__ */ v.jsx(
              Rh,
              {
                variant: "outline",
                className: "h-5 min-w-5 rounded-full px-1 font-mono tabular-nums",
                children: i.tools.filter((o) => o.checked).length
              }
            ) }) : null }) })
          ]
        }
      ),
      /* @__PURE__ */ v.jsx(Cfe, { children: /* @__PURE__ */ v.jsx(Nfe, { className: "w-80 relative", children: /* @__PURE__ */ v.jsx(
        mze,
        {
          tools: i.tools,
          isAuthorizing: i.status === "authorizing",
          authorizationUrl: i.authorizationUrl,
          error: i.error,
          checked: i.checked,
          serverId: i.id,
          onClickAllChecked: (o) => {
            r(
              i.id,
              o ? i.tools.map((s) => s.name) : []
            );
          },
          onToolClick: (o, s) => {
            const a = i.tools.filter((c) => c.checked).map((c) => c.name);
            r(
              i.id,
              s ? a.concat(o) : a.filter((c) => c !== o)
            );
          }
        }
      ) }) })
    ] }, i.id)),
    t.value.length !== 0 && /* @__PURE__ */ v.jsx("div", { className: "py-1 w-full", children: /* @__PURE__ */ v.jsx(gb, {}) }),
    /* @__PURE__ */ v.jsxs("div", { className: "text-sm text-muted-foreground w-full h-full flex flex-col items-center justify-center py-6", children: [
      t.value.length !== 0 ? /* @__PURE__ */ v.jsx("div", { children: "Welcome to additional MCP servers!" }) : /* @__PURE__ */ v.jsx("div", { children: "No MCP servers detected." }),
      /* @__PURE__ */ v.jsx(dw, { to: "/chat-bot/mcp/create", children: /* @__PURE__ */ v.jsxs(
        Ht,
        {
          variant: "ghost",
          className: "mt-2 text-primary flex items-center gap-1",
          children: [
            "Add a server ",
            /* @__PURE__ */ v.jsx(Mg, { className: "size-4" })
          ]
        }
      ) })
    ] })
  ] });
};
function yze({
  align: e,
  side: t,
  mentions: n,
  className: r
}) {
  const [i, o] = k.useState(!1), { data: s, isLoading: a } = r9(), {
    chatbotServerStore: { allowedMcpServers: c, mcpServerList: u }
  } = ra(), f = k.useMemo(() => n?.find((g) => g.type === "agent"), [n]);
  let h = k.useMemo(() => {
    if (n?.length)
      return n.map((x) => x.name);
    const g = u.value.map((x) => x.id);
    return [...Object.values(
      G$(c?.value ?? {}).filter(
        (x, w) => g.includes(String(w))
      )
    ).map((x) => x.tools ?? []).flat()];
  }, [
    n,
    u.value,
    c.value,
    s
  ]);
  const m = k.useMemo(() => /* @__PURE__ */ v.jsxs(
    Ht,
    {
      variant: "ghost",
      size: "sm",
      className: at(
        "gap-0.5 bg-background/50 border rounded-full data-[state=open]:bg-input! hover:bg-input! cursor-pointer",
        !h.length && !a && "text-muted-foreground bg-transparent border-transparent",
        a && "bg-input/60",
        i && "bg-input!",
        r
      ),
      children: [
        /* @__PURE__ */ v.jsx("span", { className: h ? "" : "text-muted-foreground", children: f ? "Agent" : n?.length ?? !1 ? "Mention" : "Tools" }),
        (!f && h.length > 0 || a) && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
          /* @__PURE__ */ v.jsx("div", { className: "h-4 hidden sm:block mx-1", children: /* @__PURE__ */ v.jsx(db, { orientation: "vertical" }) }),
          /* @__PURE__ */ v.jsx("div", { className: "min-w-5 flex justify-center", children: a ? /* @__PURE__ */ v.jsx($T, { className: "animate-spin size-3.5" }) : (n?.length ?? 0) > 0 ? /* @__PURE__ */ v.jsx(I3, { className: "size-3.5" }) : /* @__PURE__ */ v.jsx(
            hze,
            {
              number: h.length,
              className: "text-xs"
            }
          ) })
        ] })
      ]
    }
  ), [
    h.length,
    a,
    i,
    r,
    f,
    n?.length
  ]);
  return /* @__PURE__ */ v.jsxs(ed, { open: i, onOpenChange: o, children: [
    /* @__PURE__ */ v.jsx(td, { asChild: !0, children: /* @__PURE__ */ v.jsx("div", { children: /* @__PURE__ */ v.jsxs(Gi, { children: [
      /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: m }),
      /* @__PURE__ */ v.jsxs(
        Bo,
        {
          align: e,
          side: t,
          className: "p-4 text-xs bg-card border border-border",
          children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ v.jsx(q0, { className: "size-3.5" }),
              /* @__PURE__ */ v.jsx("span", { className: "text-sm", children: "Tools Setup" })
            ] }),
            /* @__PURE__ */ v.jsx("p", { className: "text-muted-foreground mt-4 whitespace-pre-wrap", children: `"Select tools that the chatbot can use.
The chatbot will use selected tools based on its own judgment.

You can also force the use of specific tools through @mention.",` })
          ]
        }
      )
    ] }) }) }),
    /* @__PURE__ */ v.jsx(nd, { className: "md:w-72", align: e, side: t, children: /* @__PURE__ */ v.jsxs("div", { className: "py-2", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "py-1", children: [
        /* @__PURE__ */ v.jsx("span", { className: "px-3 text-sm font-medium", children: "MCP Servers" }),
        /* @__PURE__ */ v.jsx(gb, {})
      ] }),
      /* @__PURE__ */ v.jsx(gze, {}),
      /* @__PURE__ */ v.jsx(gb, {})
    ] }) })
  ] });
}
const jq = window.SpeechRecognition || window.webkitSpeechRecognition, Iq = !!jq, vze = (e) => () => {
  const { isListening: t, recognitionRef: n, setIsListening: r, onTranscript: i, language: o = "en-US" } = e;
  if (!Iq) {
    alert("Speech recognition is not supported. Please use Chrome or Edge.");
    return;
  }
  if (t) {
    n.current && (n.current.stop(), n.current = null), r(!1);
    return;
  }
  let s = "";
  const a = new jq();
  a.continuous = !0, a.interimResults = !0, a.lang = o, a.onresult = (c) => {
    s = "";
    for (let u = 0; u < c.results.length; u++) {
      const f = c.results[u][0].transcript;
      c.results[u].isFinal && (s += f + " ");
    }
    s && i && (i(s), s = "");
  }, a.onend = () => {
    r(!1), n.current = null;
  }, a.onerror = (c) => {
    c.error === "not-allowed" || c.error === "permission-denied" ? alert("Please allow microphone access in your browser.") : c.error !== "aborted" && console.error("Speech recognition error:", c.error), r(!1);
  };
  try {
    a.start(), n.current = a, r(!0);
  } catch (c) {
    console.error("Failed to start speech recognition", c), r(!1);
  }
}, bze = (e) => async () => {
  const {
    localValue: t,
    isAIThinking: n,
    isListening: r,
    recognitionRef: i,
    editor: o,
    setHistory: s,
    setHistoryIndex: a,
    setLocalValue: c,
    setIsListening: u,
    setFiles: f,
    startedTypingRef: h,
    onChange: m,
    onSend: g
  } = e, b = (t || "").trim();
  if (n || !b) return;
  if (r && i.current)
    try {
      i.current.stop(), i.current = null, u(!1);
    } catch (w) {
      console.error("Error stopping speech recognition:", w);
    }
  const x = [];
  if (o && o.state && o.state.doc)
    try {
      o.state.doc.descendants((w) => (w && w.type && w.type.name === "mention" && w.attrs && x.push({
        type: "mcpTool",
        name: w.attrs.id ?? w.attrs.label ?? "",
        label: w.attrs.label ?? w.attrs.id ?? "",
        description: w.attrs.description ?? "",
        serverId: w.attrs.serverId ?? "",
        serverName: w.attrs.serverName ?? ""
      }), !0));
    } catch (w) {
      console.error("Error collecting mentions:", w);
    }
  try {
    if (b && s((w) => w[w.length - 1] === b ? w : [...w, b].slice(-10)), a(null), c(""), m && m(""), f([]), o && o.view)
      try {
        o.commands.setContent(""), setTimeout(() => {
          if (o && o.view)
            try {
              o.commands.focus();
            } catch {
            }
        }, 100);
      } catch (w) {
        console.error("Error clearing editor:", w);
      }
    h.current = !1, await g(b, x);
  } catch (w) {
    throw console.error("PromptInput: send error", w), w;
  }
};
var F0 = /* @__PURE__ */ ((e) => (e.Hierarchy = "Hierarchy", e.System = "System", e.GraphRelationship = "GraphRelationship", e.GraphComputation = "GraphComputation", e.MakeAsRootProject = "MakeAsRootProject", e.HandleRelationship = "HandleRelationship", e.HandleComposite = "HandleComposite", e.InspectionRelationship = "InspectionRelationship", e.PropertyReferenceEntity = "PropertyReferenceEntity", e.ImportedModelBachedGroup = "ImportedModelBachedGroup", e.ImportedModelFloorPlan = "ImportedModelFloorPlan", e.ImportedModelPdfViewer = "ImportedModelPdfViewer", e.ImportedModel3D = "ImportedModel3D", e.MakeAsRootBachedGroup = "MakeAsRootBachedGroup", e.HandlePromptUserInputChatbot = "HandlePromptUserInputChatbot", e.HandleRelationshipCreationSource = "HandleRelationshipCreationSource", e.HandleRelationshipCreationTarget = "HandleRelationshipCreationTarget", e))(F0 || {});
function K5(e) {
  const {
    value: t = "",
    onChange: n,
    onSend: r,
    opStop: i,
    onFilesChange: o,
    files: s,
    onStartTyping: a,
    onUseNextSuggestionChange: c
  } = e, u = k.useRef(n), f = k.useRef(null), h = k.useRef("");
  k.useEffect(() => {
    u.current = n;
  }, [n]), k.useEffect(() => () => {
    f.current && (window.clearTimeout(f.current), f.current = null);
  }, []), P3();
  const {
    chatbotStore: { isAIThinking: m },
    chatbotThreadStore: { addThreadMention: g, removeThreadMention: b },
    chatbotServerStore: x
  } = ra(), { setNodeRef: w, isOver: S } = YMe({
    id: F0.HandlePromptUserInputChatbot
  }), _ = oje({
    extensions: [
      JIe,
      QIe.configure({
        placeholder: "Ask any thing"
      }),
      sze.configure({ chatbotServerStore: x }),
      lze
    ],
    content: t ?? "",
    editable: !m.value,
    editorProps: {
      attributes: {
        class: "min-h-16 max-h-40 overflow-y-auto dark:bg-neutral-700 bg-neutral-200 resize-none border-0 focus-visible:ring-0 px-3 text-neutral-800 placeholder:text-neutral-600 dark:text-white dark:placeholder:text-gray-400"
      }
    },
    // Auto-focus on creation
    autofocus: "end"
  }), M = k.useRef(null), [N, P] = k.useState(!1), [I, O] = k.useState([]), [L, U] = k.useState(null), [B, G] = k.useState(s ?? []), [Y, he] = k.useState(t), ie = k.useRef(!1), ne = k.useRef(!1), [H, Q] = k.useState(() => {
    try {
      const ee = localStorage.getItem(cb.AI_USE_NEXT_SUGGESTION);
      return ee ? JSON.parse(ee) : !1;
    } catch {
      return !1;
    }
  }), X = k.useRef({});
  k.useEffect(() => {
    try {
      localStorage.setItem(
        "useNextSuggestion",
        JSON.stringify(H)
      );
    } catch {
    }
    c && c(H);
  }, [H, c]), k.useEffect(() => {
    const ee = (ge) => {
      const re = ge?.detail;
      if (re)
        try {
          g({
            type: "mcpTool",
            name: re.name,
            label: re.label ? re.label : re.name,
            description: re.description,
            serverId: re.serverId,
            serverName: re.serverName
          });
        } catch {
        }
    };
    return window.addEventListener(
      "tiptap-mention-inserted",
      ee
    ), () => window.removeEventListener(
      "tiptap-mention-inserted",
      ee
    );
  }, [g]), k.useEffect(() => {
    if (Array.isArray(s))
      try {
        const ee = JSON.stringify(B || []), ge = JSON.stringify(s || []);
        ee !== ge && G(s || []);
      } catch {
        G(s || []);
      }
  }, [s]), k.useEffect(() => {
    he(t ?? "");
  }, [t]), k.useEffect(() => {
    if (_)
      try {
        const ee = _.getText(), ge = t ?? "";
        if (ee !== ge) {
          if (ne.current && Math.abs(ee.length - ge.length) < 5)
            return;
          ne.current = !1, _.commands.setContent(ge), _.commands.focus("end");
        }
      } catch {
      }
  }, [_, t]);
  const Se = (ee) => {
    G(ee), o && o(ee);
  };
  k.useEffect(() => {
    if (_ && _.view)
      try {
        _.commands.focus();
      } catch {
      }
  }, [_]), k.useEffect(() => {
    if (!_) return;
    const ee = _.view?.dom ?? null;
    if (!ee) return;
    const ge = 240;
    let re = null;
    const J = () => {
      try {
        ee.style.height = "auto";
        const be = ee.scrollHeight || ee.offsetHeight;
        be > ge ? (ee.style.height = `${ge}px`, ee.style.overflowY = "auto") : (ee.style.height = `${Math.max(48, be)}px`, ee.style.overflowY = "hidden");
      } catch {
      }
    }, xe = () => {
      try {
        re && window.cancelAnimationFrame(re), re = window.requestAnimationFrame(() => {
          re = null, J();
        });
      } catch {
        J();
      }
    };
    return _.on("update", xe), xe(), () => {
      try {
        _.off("update", xe);
      } catch {
      }
      try {
        re && window.cancelAnimationFrame(re);
      } catch {
      }
      try {
        ee && (ee.style.overflowY = "", ee.style.height = "");
      } catch {
      }
    };
  }, [_]), k.useEffect(() => {
    if (!m.value && _ && _.view)
      try {
        _.commands.focus();
      } catch {
      }
  }, [m.value, _]), k.useEffect(() => {
    if (_)
      try {
        _.setEditable(!m.value);
      } catch {
      }
  }, [_, m.value]);
  const W = {
    handleKeyDown: (ee) => {
    }
  };
  k.useEffect(() => {
    if (!_) return;
    const ee = () => {
      ne.current = !0;
      const ge = _.getText();
      he(ge), h.current = ge, u.current && (f.current && window.clearTimeout(f.current), f.current = window.setTimeout(() => {
        try {
          u.current?.(h.current);
        } catch {
        }
      }, 400)), !ie.current && ge.trim().length > 0 && (ie.current = !0, a && a());
      const re = [];
      _.state.doc.descendants((Ae) => (Ae.type && Ae.type.name === "mention" && re.push(Ae.attrs.label ?? Ae.attrs.id ?? ""), !0));
      const J = X.current || {}, xe = new Set(re);
      Object.values(J).forEach((Ae) => {
        if (!xe.has(Ae)) {
          try {
            b(Ae);
          } catch {
          }
          (async () => {
            try {
              const tt = await cze(), Ge = new CustomEvent("mention-tools-fetched", {
                detail: tt
              });
              window.dispatchEvent(Ge);
            } catch {
            }
          })();
        }
      });
      const be = {};
      re.forEach((Ae, tt) => {
        be[String(tt)] = Ae;
      }), X.current = be;
    };
    return _.on("update", ee), () => {
      _.off("update", ee);
    };
  }, [_, n, a, b]);
  const Z = async () => {
    ne.current = !1, await bze({
      localValue: Y,
      isAIThinking: m.value,
      isListening: N,
      recognitionRef: M,
      editor: _,
      setHistory: O,
      setHistoryIndex: U,
      setLocalValue: he,
      setIsListening: P,
      setFiles: G,
      startedTypingRef: ie,
      onChange: n,
      onSend: r
    })();
  }, pe = vze({
    isListening: N,
    recognitionRef: M,
    setIsListening: P,
    onTranscript: (ee) => {
      if (_ && _.commands)
        try {
          _.commands.focus(), _.commands.insertContent(ee);
        } catch (ge) {
          console.error("Error inserting speech text:", ge);
        }
      he((ge) => {
        const re = ge + ee;
        return h.current = re, u.current && (f.current && window.clearTimeout(f.current), f.current = window.setTimeout(() => {
          try {
            u.current?.(h.current);
          } catch {
          }
        }, 400)), re;
      });
    },
    language: "en-US"
    // change to "vi-VN" if you want Vietnamese
  }), F = (ee) => {
    const ge = B.filter((re, J) => J !== ee);
    G(ge);
  };
  return k.useEffect(() => {
    const ee = document.createElement("style");
    return ee.innerHTML = `
      .ProseMirror, .ProseMirror * {
        user-select: text !important;
        -webkit-user-select: text !important;
      }
      .ProseMirror p.is-editor-empty:first-child::before {
        content: attr(data-placeholder);
        float: left;
        color: #6b7280;
        pointer-events: none;
        height: 0;
      }
    `, document.head.appendChild(ee), () => {
      document.head.removeChild(ee);
    };
  }, []), k.useEffect(() => {
    if (!_) return;
    const ee = _.view?.dom;
    if (!ee) return;
    const ge = (re) => {
    };
    return ee.addEventListener("paste", ge), () => {
      ee.removeEventListener("paste", ge);
    };
  }, [_]), k.useEffect(() => {
    if (!_) return;
    const ee = (ge) => {
      const re = ge?.detail;
      if (re && _.isEditable)
        try {
          const J = (() => {
            try {
              return new URLSearchParams(window.location.search).get("version_id");
            } catch {
              return null;
            }
          })(), xe = re.position, be = _.view, Ae = xe && be?.posAtCoords ? be.posAtCoords({ left: xe.x, top: xe.y }) : null, tt = Ae && typeof Ae.pos == "number" ? Ae.pos : _.state.selection.from, Ge = re.entities || (re.id && re.name ? [{ id: re.id, name: re.name, classUri: re.classUri, versionId: re.versionId }] : []);
          if (Ge.length === 0) return;
          const nt = [];
          Ge.forEach((_t, yn) => {
            nt.push({
              type: "entity",
              attrs: {
                id: _t.id,
                name: _t.name,
                classUri: _t.classUri ?? null,
                versionId: _t.versionId ?? J ?? null
              }
            }), nt.push({ type: "text", text: " " });
          }), _.chain().focus().insertContentAt(tt, nt).run();
        } catch {
        }
    };
    return window.addEventListener(F0.HandlePromptUserInputChatbot, ee), () => window.removeEventListener(F0.HandlePromptUserInputChatbot, ee);
  }, [_]), /* @__PURE__ */ v.jsxs(
    "div",
    {
      ref: w,
      className: `w-full border-t dark:bg-neutral-700 bg-neutral-200 backdrop-blur-md shadow-xl dark:border-0 p-2 flex flex-col gap-2 transition-all ${S ? "ring-4 ring-blue-500 ring-inset bg-blue-50 dark:bg-blue-950/30" : ""}`,
      children: [
        /* @__PURE__ */ v.jsxs("div", { className: "flex-1 flex flex-col", children: [
          B.length > 0 && /* @__PURE__ */ v.jsx("div", { className: "flex mt-1 w-full flex-wrap gap-2 max-h-32 overflow-y-auto wrap-break-word p-2", children: B.map((ee, ge) => /* @__PURE__ */ v.jsxs(
            Rh,
            {
              variant: "outline",
              className: "flex items-center justify-between gap-2 text-sm py-1 bg-background/50 dark:bg-neutral-800 rounded-md px-2 border",
              children: [
                /* @__PURE__ */ v.jsxs("div", { className: "truncate flex items-baseline gap-2", children: [
                  /* @__PURE__ */ v.jsx("div", { className: "font-medium", children: ee.name }),
                  ee.size && /* @__PURE__ */ v.jsx("div", { className: "text-xs text-neutral-500", children: dze(ee.size) })
                ] }),
                /* @__PURE__ */ v.jsx(
                  "button",
                  {
                    onClick: () => F(ge),
                    title: "Remove",
                    className: "cursor-pointer text-neutral-400 hover:text-red-500 p-1",
                    children: /* @__PURE__ */ v.jsx(Ng, { className: "h-4 w-4" })
                  }
                )
              ]
            },
            ge
          )) }),
          /* @__PURE__ */ v.jsx("div", { className: "relative", children: ((ge) => !!ge && typeof ge.state == "object" && typeof ge.commands == "object")(_) ? /* @__PURE__ */ v.jsx(
            oq,
            {
              editor: _,
              tabIndex: 0,
              onCopy: (ge) => {
                ge.stopPropagation();
              },
              onCut: (ge) => {
                ge.stopPropagation();
              },
              onPaste: (ge) => {
                ge.stopPropagation();
              },
              onKeyDown: (ge) => {
                const re = ge.key?.toLowerCase();
                if ((ge.ctrlKey || ge.metaKey) && (re === "c" || re === "x" || re === "v" || re === "a")) {
                  ge.stopPropagation();
                  return;
                }
                try {
                  W.handleKeyDown(ge);
                } catch {
                }
                const xe = uze({
                  localValue: Y,
                  history: I,
                  historyIndex: L,
                  setHistoryIndex: U,
                  setLocalValue: he,
                  onChange: n,
                  doSendAndClear: Z,
                  mention: { handleKeyDown: W.handleKeyDown }
                });
                try {
                  xe(ge);
                } catch {
                }
              },
              "data-chatbot-text": "chatbot-input"
            }
          ) : null })
        ] }),
        /* @__PURE__ */ v.jsxs("div", { className: "flex flex-row items-center gap-2", children: [
          /* @__PURE__ */ v.jsx(
            yze,
            {
              className: "mx-1",
              align: "start",
              side: "top",
              mentions: []
            }
          ),
          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-row items-center gap-2 ml-auto", children: [
            /* @__PURE__ */ v.jsx(
              JMe,
              {
                files: B,
                onFilesChange: Se,
                isAIThinking: m.value
              }
            ),
            /* @__PURE__ */ v.jsx(
              Ht,
              {
                size: "icon",
                variant: "ghost",
                onClick: pe,
                type: "button",
                disabled: !Iq || m.value,
                "aria-pressed": N,
                title: N ? "Stop voice" : "Start voice",
                className: N ? "cursor-pointer  bg-neutral-200 dark:bg-neutral-800 text-red-500 dark:text-red-400" : "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
                children: N ? /* @__PURE__ */ v.jsx(aY, { className: "h-5 w-5" }) : /* @__PURE__ */ v.jsx(cY, { className: "h-5 w-5" })
              }
            ),
            /* @__PURE__ */ v.jsxs(ed, { children: [
              /* @__PURE__ */ v.jsx(td, { asChild: !0, children: /* @__PURE__ */ v.jsx(
                Ht,
                {
                  size: "icon",
                  variant: "ghost",
                  disabled: m.value,
                  title: "Using next suggestion",
                  className: "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
                  children: /* @__PURE__ */ v.jsx(nY, { className: "h-5 w-5" })
                }
              ) }),
              /* @__PURE__ */ v.jsx(nd, { align: "end", side: "top", className: "w-72", children: /* @__PURE__ */ v.jsxs(
                ls,
                {
                  onSelect: (ee) => ee.preventDefault(),
                  className: "flex items-center justify-between gap-3 cursor-pointer px-3 py-2",
                  children: [
                    /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
                      /* @__PURE__ */ v.jsx(GZ, { className: "h-4 w-4 text-amber-500 shrink-0" }),
                      /* @__PURE__ */ v.jsx("span", { className: "text-sm font-medium whitespace-nowrap", children: "Using next suggestion" })
                    ] }),
                    /* @__PURE__ */ v.jsx(
                      K7,
                      {
                        checked: H,
                        onCheckedChange: (ee) => Q(ee),
                        className: "shrink-0"
                      }
                    )
                  ]
                }
              ) })
            ] }),
            m.value ? /* @__PURE__ */ v.jsx(
              Ht,
              {
                size: "icon",
                className: "cursor-pointer rounded-full bg-red-900 text-white hover:bg-blue-600 transition-colors shadow-md dark:bg-red-900 dark:hover:bg-neutral-800",
                onClick: i,
                disabled: !m.value,
                title: "Stop thinking",
                children: /* @__PURE__ */ v.jsx(fY, { className: "h-5 w-5" })
              }
            ) : /* @__PURE__ */ v.jsx(
              Ht,
              {
                size: "icon",
                className: "cursor-pointer rounded-full bg-blue-500 text-white hover:bg-blue-600 transition-colors shadow-md dark:bg-green-500 dark:hover:bg-neutral-800",
                onClick: Z,
                disabled: m.value || !(Y || "").trim(),
                title: "Send (Ctrl+End)",
                children: /* @__PURE__ */ v.jsx(kY, { className: "h-5 w-5" })
              }
            )
          ] })
        ] })
      ]
    }
  );
}
function Z5() {
  return /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-muted-foreground text-xs px-6 py-2 mt-1", children: [
    /* @__PURE__ */ v.jsx(LT, { className: "h-4 w-4 text-blue-400 dark:text-[#1abcfe] animate-pulse" }),
    /* @__PURE__ */ v.jsx("span", { className: "animate-pulse", children: "Thinking" })
  ] });
}
const xze = ({
  error: e
}) => {
  const [t, n] = k.useState(!1), r = e?.message ?? "Unknown error", i = r.length > 200 ? r.slice(0, 200) + "" : r;
  return /* @__PURE__ */ v.jsx("div", { className: "w-full mx-auto max-w-2xl px-4 mt-6", children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-3 bg-stone-50 dark:bg-stone-800/30 border border-stone-200 dark:border-stone-700 rounded-xl p-4 shadow-sm", children: [
    /* @__PURE__ */ v.jsx("div", { className: "flex-shrink-0 mt-1", children: /* @__PURE__ */ v.jsx(BY, { className: "h-6 w-6 text-amber-500" }) }),
    /* @__PURE__ */ v.jsxs("div", { className: "flex-1 min-w-0", children: [
      /* @__PURE__ */ v.jsx("div", { className: "font-semibold text-stone-800 dark:text-stone-200 mb-1", children: "Oops! Something went wrong" }),
      /* @__PURE__ */ v.jsx("div", { className: "whitespace-pre-wrap break-words text-stone-700 dark:text-stone-300 text-sm leading-relaxed", children: t ? r : i }),
      r.length > 200 && /* @__PURE__ */ v.jsx(
        "button",
        {
          className: "mt-2 text-xs text-blue-600 dark:text-blue-400 underline hover:opacity-80",
          onClick: () => n((o) => !o),
          children: t ? "Show less" : "Show more"
        }
      ),
      /* @__PURE__ */ v.jsx("div", { className: "mt-3 text-xs text-stone-500 dark:text-stone-400", children: "Try refreshing the page or checking your connection. If the problem keeps happening, please contact support." })
    ] })
  ] }) });
}, wze = (e, t) => {
  t(e ?? ""), setTimeout(() => {
    const n = document.querySelector(
      'div[data-chatbot-text="chatbot-input"]'
    );
    if (n && n.focus)
      try {
        n.focus();
      } catch {
      }
  }, 100);
}, t1 = k.createContext(null);
t1.displayName = "PanelGroupContext";
const ir = {
  group: "data-panel-group",
  groupDirection: "data-panel-group-direction",
  groupId: "data-panel-group-id",
  panel: "data-panel",
  panelCollapsible: "data-panel-collapsible",
  panelId: "data-panel-id",
  panelSize: "data-panel-size",
  resizeHandle: "data-resize-handle",
  resizeHandleActive: "data-resize-handle-active",
  resizeHandleEnabled: "data-panel-resize-handle-enabled",
  resizeHandleId: "data-panel-resize-handle-id",
  resizeHandleState: "data-resize-handle-state"
}, ZN = 10, Ku = k.useLayoutEffect, Y5 = Ix.useId, Sze = typeof Y5 == "function" ? Y5 : () => null;
let kze = 0;
function YN(e = null) {
  const t = Sze(), n = k.useRef(e || t || null);
  return n.current === null && (n.current = "" + kze++), e ?? n.current;
}
function zq({
  children: e,
  className: t = "",
  collapsedSize: n,
  collapsible: r,
  defaultSize: i,
  forwardedRef: o,
  id: s,
  maxSize: a,
  minSize: c,
  onCollapse: u,
  onExpand: f,
  onResize: h,
  order: m,
  style: g,
  tagName: b = "div",
  ...x
}) {
  const w = k.useContext(t1);
  if (w === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    collapsePanel: S,
    expandPanel: _,
    getPanelSize: M,
    getPanelStyle: N,
    groupId: P,
    isPanelCollapsed: I,
    reevaluatePanelConstraints: O,
    registerPanel: L,
    resizePanel: U,
    unregisterPanel: B
  } = w, G = YN(s), Y = k.useRef({
    callbacks: {
      onCollapse: u,
      onExpand: f,
      onResize: h
    },
    constraints: {
      collapsedSize: n,
      collapsible: r,
      defaultSize: i,
      maxSize: a,
      minSize: c
    },
    id: G,
    idIsFromProps: s !== void 0,
    order: m
  });
  k.useRef({
    didLogMissingDefaultSizeWarning: !1
  }), Ku(() => {
    const {
      callbacks: ie,
      constraints: ne
    } = Y.current, H = {
      ...ne
    };
    Y.current.id = G, Y.current.idIsFromProps = s !== void 0, Y.current.order = m, ie.onCollapse = u, ie.onExpand = f, ie.onResize = h, ne.collapsedSize = n, ne.collapsible = r, ne.defaultSize = i, ne.maxSize = a, ne.minSize = c, (H.collapsedSize !== ne.collapsedSize || H.collapsible !== ne.collapsible || H.maxSize !== ne.maxSize || H.minSize !== ne.minSize) && O(Y.current, H);
  }), Ku(() => {
    const ie = Y.current;
    return L(ie), () => {
      B(ie);
    };
  }, [m, G, L, B]), k.useImperativeHandle(o, () => ({
    collapse: () => {
      S(Y.current);
    },
    expand: (ie) => {
      _(Y.current, ie);
    },
    getId() {
      return G;
    },
    getSize() {
      return M(Y.current);
    },
    isCollapsed() {
      return I(Y.current);
    },
    isExpanded() {
      return !I(Y.current);
    },
    resize: (ie) => {
      U(Y.current, ie);
    }
  }), [S, _, M, I, G, U]);
  const he = N(Y.current, i);
  return k.createElement(b, {
    ...x,
    children: e,
    className: t,
    id: G,
    style: {
      ...he,
      ...g
    },
    // CSS selectors
    [ir.groupId]: P,
    [ir.panel]: "",
    [ir.panelCollapsible]: r || void 0,
    [ir.panelId]: G,
    [ir.panelSize]: parseFloat("" + he.flexGrow).toFixed(1)
  });
}
const Lq = k.forwardRef((e, t) => k.createElement(zq, {
  ...e,
  forwardedRef: t
}));
zq.displayName = "Panel";
Lq.displayName = "forwardRef(Panel)";
let PT = null, V0 = -1, ac = null;
function Cze(e, t, n) {
  const r = (t & Vq) !== 0, i = (t & Hq) !== 0, o = (t & Wq) !== 0, s = (t & qq) !== 0;
  if (t) {
    if (r)
      return o ? "se-resize" : s ? "ne-resize" : "e-resize";
    if (i)
      return o ? "sw-resize" : s ? "nw-resize" : "w-resize";
    if (o)
      return "s-resize";
    if (s)
      return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function Eze() {
  ac !== null && (document.head.removeChild(ac), PT = null, ac = null, V0 = -1);
}
function dE(e, t, n) {
  var r, i;
  const o = Cze(e, t);
  if (PT !== o) {
    if (PT = o, ac === null && (ac = document.createElement("style"), document.head.appendChild(ac)), V0 >= 0) {
      var s;
      (s = ac.sheet) === null || s === void 0 || s.removeRule(V0);
    }
    V0 = (r = (i = ac.sheet) === null || i === void 0 ? void 0 : i.insertRule(`*{cursor: ${o} !important;}`)) !== null && r !== void 0 ? r : -1;
  }
}
function Bq(e) {
  return e.type === "keydown";
}
function $q(e) {
  return e.type.startsWith("pointer");
}
function Uq(e) {
  return e.type.startsWith("mouse");
}
function n1(e) {
  if ($q(e)) {
    if (e.isPrimary)
      return {
        x: e.clientX,
        y: e.clientY
      };
  } else if (Uq(e))
    return {
      x: e.clientX,
      y: e.clientY
    };
  return {
    x: 1 / 0,
    y: 1 / 0
  };
}
function _ze() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
function Tze(e, t, n) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function Aze(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: Q5(e),
    b: Q5(t)
  };
  let r;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), r = e;
  It(r, "Stacking order can only be calculated for elements with a common ancestor");
  const i = {
    a: J5(X5(n.a)),
    b: J5(X5(n.b))
  };
  if (i.a === i.b) {
    const o = r.childNodes, s = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let a = o.length;
    for (; a--; ) {
      const c = o[a];
      if (c === s.a) return 1;
      if (c === s.b) return -1;
    }
  }
  return Math.sign(i.a - i.b);
}
const Mze = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function Nze(e) {
  var t;
  const n = getComputedStyle((t = Fq(e)) !== null && t !== void 0 ? t : e).display;
  return n === "flex" || n === "inline-flex";
}
function Rze(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || Nze(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || Mze.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function X5(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (It(n, "Missing node"), Rze(n)) return n;
  }
  return null;
}
function J5(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function Q5(e) {
  const t = [];
  for (; e; )
    t.push(e), e = Fq(e);
  return t;
}
function Fq(e) {
  const {
    parentNode: t
  } = e;
  return t && t instanceof ShadowRoot ? t.host : t;
}
const Vq = 1, Hq = 2, Wq = 4, qq = 8, Oze = _ze() === "coarse";
let ds = [], eh = !1, lc = /* @__PURE__ */ new Map(), r1 = /* @__PURE__ */ new Map();
const _g = /* @__PURE__ */ new Set();
function Dze(e, t, n, r, i) {
  var o;
  const {
    ownerDocument: s
  } = t, a = {
    direction: n,
    element: t,
    hitAreaMargins: r,
    setResizeHandlerState: i
  }, c = (o = lc.get(s)) !== null && o !== void 0 ? o : 0;
  return lc.set(s, c + 1), _g.add(a), Px(), function() {
    var f;
    r1.delete(e), _g.delete(a);
    const h = (f = lc.get(s)) !== null && f !== void 0 ? f : 1;
    if (lc.set(s, h - 1), Px(), h === 1 && lc.delete(s), ds.includes(a)) {
      const m = ds.indexOf(a);
      m >= 0 && ds.splice(m, 1), i1(), i("up", !0, null);
    }
  };
}
function Pze(e) {
  const {
    target: t
  } = e, {
    x: n,
    y: r
  } = n1(e);
  eh = !0, XN({
    target: t,
    x: n,
    y: r
  }), Px(), ds.length > 0 && (jx("down", e), i1(), e.preventDefault(), Gq(t) || e.stopImmediatePropagation());
}
function fE(e) {
  const {
    x: t,
    y: n
  } = n1(e);
  if (eh && // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
  e.type !== "pointerleave" && e.buttons === 0 && (eh = !1, jx("up", e)), !eh) {
    const {
      target: r
    } = e;
    XN({
      target: r,
      x: t,
      y: n
    });
  }
  jx("move", e), i1(), ds.length > 0 && e.preventDefault();
}
function hE(e) {
  const {
    target: t
  } = e, {
    x: n,
    y: r
  } = n1(e);
  r1.clear(), eh = !1, ds.length > 0 && (e.preventDefault(), Gq(t) || e.stopImmediatePropagation()), jx("up", e), XN({
    target: t,
    x: n,
    y: r
  }), i1(), Px();
}
function Gq(e) {
  let t = e;
  for (; t; ) {
    if (t.hasAttribute(ir.resizeHandle))
      return !0;
    t = t.parentElement;
  }
  return !1;
}
function XN({
  target: e,
  x: t,
  y: n
}) {
  ds.splice(0);
  let r = null;
  (e instanceof HTMLElement || e instanceof SVGElement) && (r = e), _g.forEach((i) => {
    const {
      element: o,
      hitAreaMargins: s
    } = i, a = o.getBoundingClientRect(), {
      bottom: c,
      left: u,
      right: f,
      top: h
    } = a, m = Oze ? s.coarse : s.fine;
    if (t >= u - m && t <= f + m && n >= h - m && n <= c + m) {
      if (r !== null && document.contains(r) && o !== r && !o.contains(r) && !r.contains(o) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      Aze(r, o) > 0) {
        let b = r, x = !1;
        for (; b && !b.contains(o); ) {
          if (Tze(b.getBoundingClientRect(), a)) {
            x = !0;
            break;
          }
          b = b.parentElement;
        }
        if (x)
          return;
      }
      ds.push(i);
    }
  });
}
function pE(e, t) {
  r1.set(e, t);
}
function i1() {
  let e = !1, t = !1;
  ds.forEach((r) => {
    const {
      direction: i
    } = r;
    i === "horizontal" ? e = !0 : t = !0;
  });
  let n = 0;
  r1.forEach((r) => {
    n |= r;
  }), e && t ? dE("intersection", n) : e ? dE("horizontal", n) : t ? dE("vertical", n) : Eze();
}
let mE;
function Px() {
  var e;
  (e = mE) === null || e === void 0 || e.abort(), mE = new AbortController();
  const t = {
    capture: !0,
    signal: mE.signal
  };
  _g.size && (eh ? (ds.length > 0 && lc.forEach((n, r) => {
    const {
      body: i
    } = r;
    n > 0 && (i.addEventListener("contextmenu", hE, t), i.addEventListener("pointerleave", fE, t), i.addEventListener("pointermove", fE, t));
  }), lc.forEach((n, r) => {
    const {
      body: i
    } = r;
    i.addEventListener("pointerup", hE, t), i.addEventListener("pointercancel", hE, t);
  })) : lc.forEach((n, r) => {
    const {
      body: i
    } = r;
    n > 0 && (i.addEventListener("pointerdown", Pze, t), i.addEventListener("pointermove", fE, t));
  }));
}
function jx(e, t) {
  _g.forEach((n) => {
    const {
      setResizeHandlerState: r
    } = n, i = ds.includes(n);
    r(e, i, t);
  });
}
function jze() {
  const [e, t] = k.useState(0);
  return k.useCallback(() => t((n) => n + 1), []);
}
function It(e, t) {
  if (!e)
    throw console.error(t), Error(t);
}
function cd(e, t, n = ZN) {
  return e.toFixed(n) === t.toFixed(n) ? 0 : e > t ? 1 : -1;
}
function Fa(e, t, n = ZN) {
  return cd(e, t, n) === 0;
}
function lo(e, t, n) {
  return cd(e, t, n) === 0;
}
function Ize(e, t, n) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++) {
    const i = e[r], o = t[r];
    if (!lo(i, o, n))
      return !1;
  }
  return !0;
}
function Ff({
  panelConstraints: e,
  panelIndex: t,
  size: n
}) {
  const r = e[t];
  It(r != null, `Panel constraints not found for index ${t}`);
  let {
    collapsedSize: i = 0,
    collapsible: o,
    maxSize: s = 100,
    minSize: a = 0
  } = r;
  if (cd(n, a) < 0)
    if (o) {
      const c = (i + a) / 2;
      cd(n, c) < 0 ? n = i : n = a;
    } else
      n = a;
  return n = Math.min(s, n), n = parseFloat(n.toFixed(ZN)), n;
}
function bm({
  delta: e,
  initialLayout: t,
  panelConstraints: n,
  pivotIndices: r,
  prevLayout: i,
  trigger: o
}) {
  if (lo(e, 0))
    return t;
  const s = [...t], [a, c] = r;
  It(a != null, "Invalid first pivot index"), It(c != null, "Invalid second pivot index");
  let u = 0;
  if (o === "keyboard") {
    {
      const h = e < 0 ? c : a, m = n[h];
      It(m, `Panel constraints not found for index ${h}`);
      const {
        collapsedSize: g = 0,
        collapsible: b,
        minSize: x = 0
      } = m;
      if (b) {
        const w = t[h];
        if (It(w != null, `Previous layout not found for panel index ${h}`), lo(w, g)) {
          const S = x - w;
          cd(S, Math.abs(e)) > 0 && (e = e < 0 ? 0 - S : S);
        }
      }
    }
    {
      const h = e < 0 ? a : c, m = n[h];
      It(m, `No panel constraints found for index ${h}`);
      const {
        collapsedSize: g = 0,
        collapsible: b,
        minSize: x = 0
      } = m;
      if (b) {
        const w = t[h];
        if (It(w != null, `Previous layout not found for panel index ${h}`), lo(w, x)) {
          const S = w - g;
          cd(S, Math.abs(e)) > 0 && (e = e < 0 ? 0 - S : S);
        }
      }
    }
  }
  {
    const h = e < 0 ? 1 : -1;
    let m = e < 0 ? c : a, g = 0;
    for (; ; ) {
      const x = t[m];
      It(x != null, `Previous layout not found for panel index ${m}`);
      const S = Ff({
        panelConstraints: n,
        panelIndex: m,
        size: 100
      }) - x;
      if (g += S, m += h, m < 0 || m >= n.length)
        break;
    }
    const b = Math.min(Math.abs(e), Math.abs(g));
    e = e < 0 ? 0 - b : b;
  }
  {
    let m = e < 0 ? a : c;
    for (; m >= 0 && m < n.length; ) {
      const g = Math.abs(e) - Math.abs(u), b = t[m];
      It(b != null, `Previous layout not found for panel index ${m}`);
      const x = b - g, w = Ff({
        panelConstraints: n,
        panelIndex: m,
        size: x
      });
      if (!lo(b, w) && (u += b - w, s[m] = w, u.toFixed(3).localeCompare(Math.abs(e).toFixed(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? m-- : m++;
    }
  }
  if (Ize(i, s))
    return i;
  {
    const h = e < 0 ? c : a, m = t[h];
    It(m != null, `Previous layout not found for panel index ${h}`);
    const g = m + u, b = Ff({
      panelConstraints: n,
      panelIndex: h,
      size: g
    });
    if (s[h] = b, !lo(b, g)) {
      let x = g - b, S = e < 0 ? c : a;
      for (; S >= 0 && S < n.length; ) {
        const _ = s[S];
        It(_ != null, `Previous layout not found for panel index ${S}`);
        const M = _ + x, N = Ff({
          panelConstraints: n,
          panelIndex: S,
          size: M
        });
        if (lo(_, N) || (x -= N - _, s[S] = N), lo(x, 0))
          break;
        e > 0 ? S-- : S++;
      }
    }
  }
  const f = s.reduce((h, m) => m + h, 0);
  return lo(f, 100) ? s : i;
}
function zze({
  layout: e,
  panelsArray: t,
  pivotIndices: n
}) {
  let r = 0, i = 100, o = 0, s = 0;
  const a = n[0];
  It(a != null, "No pivot index found"), t.forEach((h, m) => {
    const {
      constraints: g
    } = h, {
      maxSize: b = 100,
      minSize: x = 0
    } = g;
    m === a ? (r = x, i = b) : (o += x, s += b);
  });
  const c = Math.min(i, 100 - o), u = Math.max(r, 100 - s), f = e[a];
  return {
    valueMax: c,
    valueMin: u,
    valueNow: f
  };
}
function Tg(e, t = document) {
  return Array.from(t.querySelectorAll(`[${ir.resizeHandleId}][data-panel-group-id="${e}"]`));
}
function Kq(e, t, n = document) {
  const i = Tg(e, n).findIndex((o) => o.getAttribute(ir.resizeHandleId) === t);
  return i ?? null;
}
function Zq(e, t, n) {
  const r = Kq(e, t, n);
  return r != null ? [r, r + 1] : [-1, -1];
}
function Lze(e) {
  return e instanceof HTMLElement ? !0 : typeof e == "object" && e !== null && "tagName" in e && "getAttribute" in e;
}
function Yq(e, t = document) {
  if (Lze(t) && t.dataset.panelGroupId == e)
    return t;
  const n = t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return n || null;
}
function o1(e, t = document) {
  const n = t.querySelector(`[${ir.resizeHandleId}="${e}"]`);
  return n || null;
}
function Bze(e, t, n, r = document) {
  var i, o, s, a;
  const c = o1(t, r), u = Tg(e, r), f = c ? u.indexOf(c) : -1, h = (i = (o = n[f]) === null || o === void 0 ? void 0 : o.id) !== null && i !== void 0 ? i : null, m = (s = (a = n[f + 1]) === null || a === void 0 ? void 0 : a.id) !== null && s !== void 0 ? s : null;
  return [h, m];
}
function $ze({
  committedValuesRef: e,
  eagerValuesRef: t,
  groupId: n,
  layout: r,
  panelDataArray: i,
  panelGroupElement: o,
  setLayout: s
}) {
  k.useRef({
    didWarnAboutMissingResizeHandle: !1
  }), Ku(() => {
    if (!o)
      return;
    const a = Tg(n, o);
    for (let c = 0; c < i.length - 1; c++) {
      const {
        valueMax: u,
        valueMin: f,
        valueNow: h
      } = zze({
        layout: r,
        panelsArray: i,
        pivotIndices: [c, c + 1]
      }), m = a[c];
      if (m != null) {
        const g = i[c];
        It(g, `No panel data found for index "${c}"`), m.setAttribute("aria-controls", g.id), m.setAttribute("aria-valuemax", "" + Math.round(u)), m.setAttribute("aria-valuemin", "" + Math.round(f)), m.setAttribute("aria-valuenow", h != null ? "" + Math.round(h) : "");
      }
    }
    return () => {
      a.forEach((c, u) => {
        c.removeAttribute("aria-controls"), c.removeAttribute("aria-valuemax"), c.removeAttribute("aria-valuemin"), c.removeAttribute("aria-valuenow");
      });
    };
  }, [n, r, i, o]), k.useEffect(() => {
    if (!o)
      return;
    const a = t.current;
    It(a, "Eager values not found");
    const {
      panelDataArray: c
    } = a, u = Yq(n, o);
    It(u != null, `No group found for id "${n}"`);
    const f = Tg(n, o);
    It(f, `No resize handles found for group id "${n}"`);
    const h = f.map((m) => {
      const g = m.getAttribute(ir.resizeHandleId);
      It(g, "Resize handle element has no handle id attribute");
      const [b, x] = Bze(n, g, c, o);
      if (b == null || x == null)
        return () => {
        };
      const w = (S) => {
        if (!S.defaultPrevented)
          switch (S.key) {
            case "Enter": {
              S.preventDefault();
              const _ = c.findIndex((M) => M.id === b);
              if (_ >= 0) {
                const M = c[_];
                It(M, `No panel data found for index ${_}`);
                const N = r[_], {
                  collapsedSize: P = 0,
                  collapsible: I,
                  minSize: O = 0
                } = M.constraints;
                if (N != null && I) {
                  const L = bm({
                    delta: lo(N, P) ? O - P : P - N,
                    initialLayout: r,
                    panelConstraints: c.map((U) => U.constraints),
                    pivotIndices: Zq(n, g, o),
                    prevLayout: r,
                    trigger: "keyboard"
                  });
                  r !== L && s(L);
                }
              }
              break;
            }
          }
      };
      return m.addEventListener("keydown", w), () => {
        m.removeEventListener("keydown", w);
      };
    });
    return () => {
      h.forEach((m) => m());
    };
  }, [o, e, t, n, r, i, s]);
}
function e3(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function Xq(e, t) {
  const n = e === "horizontal", {
    x: r,
    y: i
  } = n1(t);
  return n ? r : i;
}
function Uze(e, t, n, r, i) {
  const o = n === "horizontal", s = o1(t, i);
  It(s, `No resize handle element found for id "${t}"`);
  const a = s.getAttribute(ir.groupId);
  It(a, "Resize handle element has no group id attribute");
  let {
    initialCursorPosition: c
  } = r;
  const u = Xq(n, e), f = Yq(a, i);
  It(f, `No group element found for id "${a}"`);
  const h = f.getBoundingClientRect(), m = o ? h.width : h.height;
  return (u - c) / m * 100;
}
function Fze(e, t, n, r, i, o) {
  if (Bq(e)) {
    const s = n === "horizontal";
    let a = 0;
    e.shiftKey ? a = 100 : i != null ? a = i : a = 10;
    let c = 0;
    switch (e.key) {
      case "ArrowDown":
        c = s ? 0 : a;
        break;
      case "ArrowLeft":
        c = s ? -a : 0;
        break;
      case "ArrowRight":
        c = s ? a : 0;
        break;
      case "ArrowUp":
        c = s ? 0 : -a;
        break;
      case "End":
        c = 100;
        break;
      case "Home":
        c = -100;
        break;
    }
    return c;
  } else
    return r == null ? 0 : Uze(e, t, n, r, o);
}
function Vze({
  panelDataArray: e
}) {
  const t = Array(e.length), n = e.map((o) => o.constraints);
  let r = 0, i = 100;
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    It(s, `Panel constraints not found for index ${o}`);
    const {
      defaultSize: a
    } = s;
    a != null && (r++, t[o] = a, i -= a);
  }
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    It(s, `Panel constraints not found for index ${o}`);
    const {
      defaultSize: a
    } = s;
    if (a != null)
      continue;
    const c = e.length - r, u = i / c;
    r++, t[o] = u, i -= u;
  }
  return t;
}
function wf(e, t, n) {
  t.forEach((r, i) => {
    const o = e[i];
    It(o, `Panel data not found for index ${i}`);
    const {
      callbacks: s,
      constraints: a,
      id: c
    } = o, {
      collapsedSize: u = 0,
      collapsible: f
    } = a, h = n[c];
    if (h == null || r !== h) {
      n[c] = r;
      const {
        onCollapse: m,
        onExpand: g,
        onResize: b
      } = s;
      b && b(r, h), f && (m || g) && (g && (h == null || Fa(h, u)) && !Fa(r, u) && g(), m && (h == null || !Fa(h, u)) && Fa(r, u) && m());
    }
  });
}
function l0(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n])
      return !1;
  return !0;
}
function Hze({
  defaultSize: e,
  dragState: t,
  layout: n,
  panelData: r,
  panelIndex: i,
  precision: o = 3
}) {
  const s = n[i];
  let a;
  return s == null ? a = e != null ? e.toFixed(o) : "1" : r.length === 1 ? a = "1" : a = s.toFixed(o), {
    flexBasis: 0,
    flexGrow: a,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: t !== null ? "none" : void 0
  };
}
function Wze(e, t = 10) {
  let n = null;
  return (...i) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...i);
    }, t);
  };
}
function t3(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, n) => {
        localStorage.setItem(t, n);
      };
    else
      throw new Error("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function Jq(e) {
  return `react-resizable-panels:${e}`;
}
function Qq(e) {
  return e.map((t) => {
    const {
      constraints: n,
      id: r,
      idIsFromProps: i,
      order: o
    } = t;
    return i ? r : o ? `${o}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((t, n) => t.localeCompare(n)).join(",");
}
function eG(e, t) {
  try {
    const n = Jq(e), r = t.getItem(n);
    if (r) {
      const i = JSON.parse(r);
      if (typeof i == "object" && i != null)
        return i;
    }
  } catch {
  }
  return null;
}
function qze(e, t, n) {
  var r, i;
  const o = (r = eG(e, n)) !== null && r !== void 0 ? r : {}, s = Qq(t);
  return (i = o[s]) !== null && i !== void 0 ? i : null;
}
function Gze(e, t, n, r, i) {
  var o;
  const s = Jq(e), a = Qq(t), c = (o = eG(e, i)) !== null && o !== void 0 ? o : {};
  c[a] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: r
  };
  try {
    i.setItem(s, JSON.stringify(c));
  } catch (u) {
    console.error(u);
  }
}
function n3({
  layout: e,
  panelConstraints: t
}) {
  const n = [...e], r = n.reduce((o, s) => o + s, 0);
  if (n.length !== t.length)
    throw Error(`Invalid ${t.length} panel layout: ${n.map((o) => `${o}%`).join(", ")}`);
  if (!lo(r, 100) && n.length > 0)
    for (let o = 0; o < t.length; o++) {
      const s = n[o];
      It(s != null, `No layout data found for index ${o}`);
      const a = 100 / r * s;
      n[o] = a;
    }
  let i = 0;
  for (let o = 0; o < t.length; o++) {
    const s = n[o];
    It(s != null, `No layout data found for index ${o}`);
    const a = Ff({
      panelConstraints: t,
      panelIndex: o,
      size: s
    });
    s != a && (i += s - a, n[o] = a);
  }
  if (!lo(i, 0))
    for (let o = 0; o < t.length; o++) {
      const s = n[o];
      It(s != null, `No layout data found for index ${o}`);
      const a = s + i, c = Ff({
        panelConstraints: t,
        panelIndex: o,
        size: a
      });
      if (s !== c && (i -= c - s, n[o] = c, lo(i, 0)))
        break;
    }
  return n;
}
const Kze = 100, xm = {
  getItem: (e) => (t3(xm), xm.getItem(e)),
  setItem: (e, t) => {
    t3(xm), xm.setItem(e, t);
  }
}, r3 = {};
function tG({
  autoSaveId: e = null,
  children: t,
  className: n = "",
  direction: r,
  forwardedRef: i,
  id: o = null,
  onLayout: s = null,
  keyboardResizeBy: a = null,
  storage: c = xm,
  style: u,
  tagName: f = "div",
  ...h
}) {
  const m = YN(o), g = k.useRef(null), [b, x] = k.useState(null), [w, S] = k.useState([]), _ = jze(), M = k.useRef({}), N = k.useRef(/* @__PURE__ */ new Map()), P = k.useRef(0), I = k.useRef({
    autoSaveId: e,
    direction: r,
    dragState: b,
    id: m,
    keyboardResizeBy: a,
    onLayout: s,
    storage: c
  }), O = k.useRef({
    layout: w,
    panelDataArray: [],
    panelDataArrayChanged: !1
  });
  k.useRef({
    didLogIdAndOrderWarning: !1,
    didLogPanelConstraintsWarning: !1,
    prevPanelIds: []
  }), k.useImperativeHandle(i, () => ({
    getId: () => I.current.id,
    getLayout: () => {
      const {
        layout: F
      } = O.current;
      return F;
    },
    setLayout: (F) => {
      const {
        onLayout: ee
      } = I.current, {
        layout: ge,
        panelDataArray: re
      } = O.current, J = n3({
        layout: F,
        panelConstraints: re.map((xe) => xe.constraints)
      });
      e3(ge, J) || (S(J), O.current.layout = J, ee && ee(J), wf(re, J, M.current));
    }
  }), []), Ku(() => {
    I.current.autoSaveId = e, I.current.direction = r, I.current.dragState = b, I.current.id = m, I.current.onLayout = s, I.current.storage = c;
  }), $ze({
    committedValuesRef: I,
    eagerValuesRef: O,
    groupId: m,
    layout: w,
    panelDataArray: O.current.panelDataArray,
    setLayout: S,
    panelGroupElement: g.current
  }), k.useEffect(() => {
    const {
      panelDataArray: F
    } = O.current;
    if (e) {
      if (w.length === 0 || w.length !== F.length)
        return;
      let ee = r3[e];
      ee == null && (ee = Wze(Gze, Kze), r3[e] = ee);
      const ge = [...F], re = new Map(N.current);
      ee(e, ge, re, w, c);
    }
  }, [e, w, c]), k.useEffect(() => {
  });
  const L = k.useCallback((F) => {
    const {
      onLayout: ee
    } = I.current, {
      layout: ge,
      panelDataArray: re
    } = O.current;
    if (F.constraints.collapsible) {
      const J = re.map((tt) => tt.constraints), {
        collapsedSize: xe = 0,
        panelSize: be,
        pivotIndices: Ae
      } = Tu(re, F, ge);
      if (It(be != null, `Panel size not found for panel "${F.id}"`), !Fa(be, xe)) {
        N.current.set(F.id, be);
        const Ge = Rf(re, F) === re.length - 1 ? be - xe : xe - be, nt = bm({
          delta: Ge,
          initialLayout: ge,
          panelConstraints: J,
          pivotIndices: Ae,
          prevLayout: ge,
          trigger: "imperative-api"
        });
        l0(ge, nt) || (S(nt), O.current.layout = nt, ee && ee(nt), wf(re, nt, M.current));
      }
    }
  }, []), U = k.useCallback((F, ee) => {
    const {
      onLayout: ge
    } = I.current, {
      layout: re,
      panelDataArray: J
    } = O.current;
    if (F.constraints.collapsible) {
      const xe = J.map((_t) => _t.constraints), {
        collapsedSize: be = 0,
        panelSize: Ae = 0,
        minSize: tt = 0,
        pivotIndices: Ge
      } = Tu(J, F, re), nt = ee ?? tt;
      if (Fa(Ae, be)) {
        const _t = N.current.get(F.id), yn = _t != null && _t >= nt ? _t : nt, Vt = Rf(J, F) === J.length - 1 ? Ae - yn : yn - Ae, xt = bm({
          delta: Vt,
          initialLayout: re,
          panelConstraints: xe,
          pivotIndices: Ge,
          prevLayout: re,
          trigger: "imperative-api"
        });
        l0(re, xt) || (S(xt), O.current.layout = xt, ge && ge(xt), wf(J, xt, M.current));
      }
    }
  }, []), B = k.useCallback((F) => {
    const {
      layout: ee,
      panelDataArray: ge
    } = O.current, {
      panelSize: re
    } = Tu(ge, F, ee);
    return It(re != null, `Panel size not found for panel "${F.id}"`), re;
  }, []), G = k.useCallback((F, ee) => {
    const {
      panelDataArray: ge
    } = O.current, re = Rf(ge, F);
    return Hze({
      defaultSize: ee,
      dragState: b,
      layout: w,
      panelData: ge,
      panelIndex: re
    });
  }, [b, w]), Y = k.useCallback((F) => {
    const {
      layout: ee,
      panelDataArray: ge
    } = O.current, {
      collapsedSize: re = 0,
      collapsible: J,
      panelSize: xe
    } = Tu(ge, F, ee);
    return It(xe != null, `Panel size not found for panel "${F.id}"`), J === !0 && Fa(xe, re);
  }, []), he = k.useCallback((F) => {
    const {
      layout: ee,
      panelDataArray: ge
    } = O.current, {
      collapsedSize: re = 0,
      collapsible: J,
      panelSize: xe
    } = Tu(ge, F, ee);
    return It(xe != null, `Panel size not found for panel "${F.id}"`), !J || cd(xe, re) > 0;
  }, []), ie = k.useCallback((F) => {
    const {
      panelDataArray: ee
    } = O.current;
    ee.push(F), ee.sort((ge, re) => {
      const J = ge.order, xe = re.order;
      return J == null && xe == null ? 0 : J == null ? -1 : xe == null ? 1 : J - xe;
    }), O.current.panelDataArrayChanged = !0, _();
  }, [_]);
  Ku(() => {
    if (O.current.panelDataArrayChanged) {
      O.current.panelDataArrayChanged = !1;
      const {
        autoSaveId: F,
        onLayout: ee,
        storage: ge
      } = I.current, {
        layout: re,
        panelDataArray: J
      } = O.current;
      let xe = null;
      if (F) {
        const Ae = qze(F, J, ge);
        Ae && (N.current = new Map(Object.entries(Ae.expandToSizes)), xe = Ae.layout);
      }
      xe == null && (xe = Vze({
        panelDataArray: J
      }));
      const be = n3({
        layout: xe,
        panelConstraints: J.map((Ae) => Ae.constraints)
      });
      e3(re, be) || (S(be), O.current.layout = be, ee && ee(be), wf(J, be, M.current));
    }
  }), Ku(() => {
    const F = O.current;
    return () => {
      F.layout = [];
    };
  }, []);
  const ne = k.useCallback((F) => {
    let ee = !1;
    const ge = g.current;
    return ge && window.getComputedStyle(ge, null).getPropertyValue("direction") === "rtl" && (ee = !0), function(J) {
      J.preventDefault();
      const xe = g.current;
      if (!xe)
        return () => null;
      const {
        direction: be,
        dragState: Ae,
        id: tt,
        keyboardResizeBy: Ge,
        onLayout: nt
      } = I.current, {
        layout: _t,
        panelDataArray: yn
      } = O.current, {
        initialLayout: St
      } = Ae ?? {}, Vt = Zq(tt, F, xe);
      let xt = Fze(J, F, be, Ae, Ge, xe);
      const Kt = be === "horizontal";
      Kt && ee && (xt = -xt);
      const An = yn.map((Pn) => Pn.constraints), Nt = bm({
        delta: xt,
        initialLayout: St ?? _t,
        panelConstraints: An,
        pivotIndices: Vt,
        prevLayout: _t,
        trigger: Bq(J) ? "keyboard" : "mouse-or-touch"
      }), sn = !l0(_t, Nt);
      ($q(J) || Uq(J)) && P.current != xt && (P.current = xt, !sn && xt !== 0 ? Kt ? pE(F, xt < 0 ? Vq : Hq) : pE(F, xt < 0 ? Wq : qq) : pE(F, 0)), sn && (S(Nt), O.current.layout = Nt, nt && nt(Nt), wf(yn, Nt, M.current));
    };
  }, []), H = k.useCallback((F, ee) => {
    const {
      onLayout: ge
    } = I.current, {
      layout: re,
      panelDataArray: J
    } = O.current, xe = J.map((_t) => _t.constraints), {
      panelSize: be,
      pivotIndices: Ae
    } = Tu(J, F, re);
    It(be != null, `Panel size not found for panel "${F.id}"`);
    const Ge = Rf(J, F) === J.length - 1 ? be - ee : ee - be, nt = bm({
      delta: Ge,
      initialLayout: re,
      panelConstraints: xe,
      pivotIndices: Ae,
      prevLayout: re,
      trigger: "imperative-api"
    });
    l0(re, nt) || (S(nt), O.current.layout = nt, ge && ge(nt), wf(J, nt, M.current));
  }, []), Q = k.useCallback((F, ee) => {
    const {
      layout: ge,
      panelDataArray: re
    } = O.current, {
      collapsedSize: J = 0,
      collapsible: xe
    } = ee, {
      collapsedSize: be = 0,
      collapsible: Ae,
      maxSize: tt = 100,
      minSize: Ge = 0
    } = F.constraints, {
      panelSize: nt
    } = Tu(re, F, ge);
    nt != null && (xe && Ae && Fa(nt, J) ? Fa(J, be) || H(F, be) : nt < Ge ? H(F, Ge) : nt > tt && H(F, tt));
  }, [H]), X = k.useCallback((F, ee) => {
    const {
      direction: ge
    } = I.current, {
      layout: re
    } = O.current;
    if (!g.current)
      return;
    const J = o1(F, g.current);
    It(J, `Drag handle element not found for id "${F}"`);
    const xe = Xq(ge, ee);
    x({
      dragHandleId: F,
      dragHandleRect: J.getBoundingClientRect(),
      initialCursorPosition: xe,
      initialLayout: re
    });
  }, []), Se = k.useCallback(() => {
    x(null);
  }, []), W = k.useCallback((F) => {
    const {
      panelDataArray: ee
    } = O.current, ge = Rf(ee, F);
    ge >= 0 && (ee.splice(ge, 1), delete M.current[F.id], O.current.panelDataArrayChanged = !0, _());
  }, [_]), Z = k.useMemo(() => ({
    collapsePanel: L,
    direction: r,
    dragState: b,
    expandPanel: U,
    getPanelSize: B,
    getPanelStyle: G,
    groupId: m,
    isPanelCollapsed: Y,
    isPanelExpanded: he,
    reevaluatePanelConstraints: Q,
    registerPanel: ie,
    registerResizeHandle: ne,
    resizePanel: H,
    startDragging: X,
    stopDragging: Se,
    unregisterPanel: W,
    panelGroupElement: g.current
  }), [L, b, r, U, B, G, m, Y, he, Q, ie, ne, H, X, Se, W]), pe = {
    display: "flex",
    flexDirection: r === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return k.createElement(t1.Provider, {
    value: Z
  }, k.createElement(f, {
    ...h,
    children: t,
    className: n,
    id: o,
    ref: g,
    style: {
      ...pe,
      ...u
    },
    // CSS selectors
    [ir.group]: "",
    [ir.groupDirection]: r,
    [ir.groupId]: m
  }));
}
const nG = k.forwardRef((e, t) => k.createElement(tG, {
  ...e,
  forwardedRef: t
}));
tG.displayName = "PanelGroup";
nG.displayName = "forwardRef(PanelGroup)";
function Rf(e, t) {
  return e.findIndex((n) => n === t || n.id === t.id);
}
function Tu(e, t, n) {
  const r = Rf(e, t), o = r === e.length - 1 ? [r - 1, r] : [r, r + 1], s = n[r];
  return {
    ...t.constraints,
    panelSize: s,
    pivotIndices: o
  };
}
function Zze({
  disabled: e,
  handleId: t,
  resizeHandler: n,
  panelGroupElement: r
}) {
  k.useEffect(() => {
    if (e || n == null || r == null)
      return;
    const i = o1(t, r);
    if (i == null)
      return;
    const o = (s) => {
      if (!s.defaultPrevented)
        switch (s.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            s.preventDefault(), n(s);
            break;
          }
          case "F6": {
            s.preventDefault();
            const a = i.getAttribute(ir.groupId);
            It(a, `No group element found for id "${a}"`);
            const c = Tg(a, r), u = Kq(a, t, r);
            It(u !== null, `No resize element found for id "${t}"`);
            const f = s.shiftKey ? u > 0 ? u - 1 : c.length - 1 : u + 1 < c.length ? u + 1 : 0;
            c[f].focus();
            break;
          }
        }
    };
    return i.addEventListener("keydown", o), () => {
      i.removeEventListener("keydown", o);
    };
  }, [r, e, t, n]);
}
function rG({
  children: e = null,
  className: t = "",
  disabled: n = !1,
  hitAreaMargins: r,
  id: i,
  onBlur: o,
  onClick: s,
  onDragging: a,
  onFocus: c,
  onPointerDown: u,
  onPointerUp: f,
  style: h = {},
  tabIndex: m = 0,
  tagName: g = "div",
  ...b
}) {
  var x, w;
  const S = k.useRef(null), _ = k.useRef({
    onClick: s,
    onDragging: a,
    onPointerDown: u,
    onPointerUp: f
  });
  k.useEffect(() => {
    _.current.onClick = s, _.current.onDragging = a, _.current.onPointerDown = u, _.current.onPointerUp = f;
  });
  const M = k.useContext(t1);
  if (M === null)
    throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
  const {
    direction: N,
    groupId: P,
    registerResizeHandle: I,
    startDragging: O,
    stopDragging: L,
    panelGroupElement: U
  } = M, B = YN(i), [G, Y] = k.useState("inactive"), [he, ie] = k.useState(!1), [ne, H] = k.useState(null), Q = k.useRef({
    state: G
  });
  Ku(() => {
    Q.current.state = G;
  }), k.useEffect(() => {
    if (n)
      H(null);
    else {
      const Z = I(B);
      H(() => Z);
    }
  }, [n, B, I]);
  const X = (x = r?.coarse) !== null && x !== void 0 ? x : 15, Se = (w = r?.fine) !== null && w !== void 0 ? w : 5;
  k.useEffect(() => {
    if (n || ne == null)
      return;
    const Z = S.current;
    It(Z, "Element ref not attached");
    let pe = !1;
    return Dze(B, Z, N, {
      coarse: X,
      fine: Se
    }, (ee, ge, re) => {
      if (!ge) {
        Y("inactive");
        return;
      }
      switch (ee) {
        case "down": {
          Y("drag"), pe = !1, It(re, 'Expected event to be defined for "down" action'), O(B, re);
          const {
            onDragging: J,
            onPointerDown: xe
          } = _.current;
          J?.(!0), xe?.();
          break;
        }
        case "move": {
          const {
            state: J
          } = Q.current;
          pe = !0, J !== "drag" && Y("hover"), It(re, 'Expected event to be defined for "move" action'), ne(re);
          break;
        }
        case "up": {
          Y("hover"), L();
          const {
            onClick: J,
            onDragging: xe,
            onPointerUp: be
          } = _.current;
          xe?.(!1), be?.(), pe || J?.();
          break;
        }
      }
    });
  }, [X, N, n, Se, I, B, ne, O, L]), Zze({
    disabled: n,
    handleId: B,
    resizeHandler: ne,
    panelGroupElement: U
  });
  const W = {
    touchAction: "none",
    userSelect: "none"
  };
  return k.createElement(g, {
    ...b,
    children: e,
    className: t,
    id: i,
    onBlur: () => {
      ie(!1), o?.();
    },
    onFocus: () => {
      ie(!0), c?.();
    },
    ref: S,
    role: "separator",
    style: {
      ...W,
      ...h
    },
    tabIndex: m,
    // CSS selectors
    [ir.groupDirection]: N,
    [ir.groupId]: P,
    [ir.resizeHandle]: "",
    [ir.resizeHandleActive]: G === "drag" ? "pointer" : he ? "keyboard" : void 0,
    [ir.resizeHandleEnabled]: !n,
    [ir.resizeHandleId]: B,
    [ir.resizeHandleState]: G
  });
}
rG.displayName = "PanelResizeHandle";
function Yze({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    nG,
    {
      "data-slot": "resizable-panel-group",
      className: at(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        e
      ),
      ...t
    }
  );
}
function i3({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Lq, { "data-slot": "resizable-panel", ...e });
}
function Xze({
  withHandle: e,
  className: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsx(
    rG,
    {
      "data-slot": "resizable-handle",
      className: at(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:translate-x-0 data-[panel-group-direction=vertical]:after:-translate-y-1/2 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        t
      ),
      ...n,
      children: e && /* @__PURE__ */ v.jsx("div", { className: "bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border", children: /* @__PURE__ */ v.jsx(UZ, { className: "size-2.5" }) })
    }
  );
}
async function Jze(e) {
  const { filesToSend: t, parts: n, messages: r, setMessages: i, sendMessage: o, metadata: s } = e;
  if (!t || t.length === 0) return;
  const a = t.map((b) => ({
    fileName: b.name,
    mimeType: b.type || "application/octet-stream",
    size: b.size,
    s3Key: "",
    url: void 0,
    status: "uploading"
  })), c = `temp-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`, u = {
    id: c,
    role: "user",
    parts: n,
    metadata: { ...s || {}, attachments: a }
  };
  let f = Array.isArray(r) ? [...r] : [];
  f.push(u);
  try {
    i(f);
  } catch {
  }
  const h = t.map(async (b, x) => {
    const w = await fze(b);
    f = (f || []).map((S) => {
      if (S.id !== c) return S;
      const _ = Array.isArray(S.metadata?.attachments) ? [...S.metadata.attachments] : [];
      return _[x] = w, { ...S, metadata: { ...S.metadata, attachments: _ } };
    });
    try {
      i(f);
    } catch {
    }
    return w;
  }), m = await Promise.all(h), g = (f || []).filter((b) => b.id !== c);
  try {
    i(g);
  } catch {
  }
  try {
    await o({
      role: "user",
      parts: n,
      metadata: { ...s || {}, attachments: m }
    });
  } catch (b) {
    const x = {
      id: u.id,
      role: u.role,
      parts: u.parts,
      metadata: { ...u.metadata, attachments: m }
    };
    try {
      i([...g || [], x]);
    } catch {
    }
    console.error("sendMessage failed:", b);
  }
}
const Qze = ({
  onClose: e,
  threadId: t
}) => {
  const {
    chatbotStore: {
      allowedAppDefaultToolkit: n,
      toolChoice: r,
      isNewThread: i,
      currentThreadId: o,
      threadMessages: s,
      isLoadingThread: a,
      isAIThinking: c,
      storeThreads: u,
      useNextSuggestion: f,
      isStopStream: h
    },
    chatbotStore: m,
    chatbotServerStore: { allowedMcpServers: g },
    chatbotThreadStore: { threadMentions: b }
  } = ra(), [x, w] = k.useState(""), [S, _] = k.useState([]), [M, N] = k.useState(!1), [P, I] = k.useState(!0), O = new URLSearchParams(window.location.search), L = O.get("project_id") || "unknown", U = O.get("version_id") || "unknown", B = async (mt) => {
    try {
      localStorage.setItem("ai-name", mt);
    } catch {
    }
  }, G = o.value || t, Y = !i.value && !tg(G), he = 10, {
    messages: ie,
    pagination: ne,
    loadMore: H
  } = Ape(G, 50, Y), Q = k.useMemo(() => {
    const mt = s.value[G] || [];
    return mt.length > 0 ? mt : Y && ie.length > 0 ? ie : [];
  }, [s.value, G, Y, ie]), X = k.useMemo(
    () => Spe(G),
    [G]
  );
  Mpe(f);
  const {
    saveMessages: Se
  } = Npe({
    threadId: G,
    enabled: !0,
    maxInMemory: he
  }), {
    messages: W,
    status: Z,
    sendMessage: pe,
    setMessages: F,
    stop: ee,
    error: ge,
    regenerate: re,
    addToolOutput: J
    //IMPORTANT for manual tool approvals
  } = oxe({
    id: G,
    sendAutomaticallyWhen: Qbe,
    transport: new AF({
      api: `${Wa}/ai-chat`,
      fetch: async (mt, ke) => {
        const Pe = await Lc();
        return fetch(mt, {
          ...ke,
          headers: {
            ...Pe,
            ...ke?.headers
          }
        });
      },
      prepareSendMessagesRequest: ({
        messages: mt,
        body: ke,
        id: Pe,
        trigger: He,
        messageId: et
      }) => {
        const bt = Wbe(mt), Ct = Array.isArray(mt) && mt.length ? mt[mt.length - 1] : void 0;
        if (!Ct)
          return { body: ke ?? {} };
        const fn = localStorage.getItem("ai-name") || W$, Lt = {
          provider: fn.startsWith("gpt") ? "openai" : "azure",
          model: fn
        };
        return { body: {
          id: o.value || Pe,
          chatModel: Lt,
          toolChoice: r.value || "auto",
          allowedAppDefaultToolkit: n.value,
          allowedMcpServers: g.value,
          mentions: b.value[G] || [],
          message: Ct,
          // server expects single message
          messages: bt,
          // Add converted ModelMessages for backend
          trigger: He,
          // 'submit-message' | 'regenerate-message'
          messageId: et,
          // ID of message to regenerate (for regenerate-message trigger)
          projectId: L,
          versionId: U,
          usingNextSuggestion: f.value
        } };
      }
    }),
    messages: Q,
    generateId: vle,
    experimental_throttle: 100,
    onFinish: (mt) => {
    },
    onToolCall: (mt) => {
    },
    onData: (mt) => {
    },
    onError: (mt) => {
      console.log(" onError:", mt), X.onError(mt);
    }
  }), xe = k.useCallback(
    async (mt) => {
      await J(mt);
    },
    [J]
  ), be = W, Ae = F, tt = k.useRef(G), Ge = k.useRef(be), nt = Z === "streaming" || Z === "submitted";
  c.value = nt;
  const _t = k.useCallback(
    () => {
      ee(), h.value = !0;
    },
    [ee, be, Ae]
  );
  k.useEffect(() => {
    Q.length > 0 && be.length === 0 && Ae(Q);
  }, [G, Q, be.length, Ae]);
  const { scrollAreaRef: yn, containerRef: St, topSentinelRef: Vt, scrollToBottom: xt } = kpe(
    be.length > 0 ? be : Q,
    a.value,
    Y ? H : void 0,
    Y ? ne.hasMore : !1
  ), Kt = () => {
    if (tg(G)) {
      const mt = gpe(G);
      o.value = mt, i.value = !0;
    }
  }, An = k.useCallback(
    async (mt, ke) => {
      const Pe = (mt ?? x ?? "").trim();
      if (!(!Pe || nt))
        try {
          c.value = !0, ke && ke.length > 0 && (b.value = {
            ...b.value,
            [G]: ke
          });
          const He = [...S];
          _([]), w(""), N(!1);
          const et = Pe ? [{ type: "text", text: Pe }] : [{ type: "text", text: "" }];
          if (He.length > 0 ? await Jze({
            filesToSend: He,
            parts: et,
            messages: be,
            setMessages: Ae,
            sendMessage: pe
          }) : await pe({
            role: "user",
            parts: et,
            metadata: {
              mentions: ke
            }
          }), i.value && !nt) {
            const bt = await XU();
            try {
              bt.ok && (u.value = [...bt.threads]);
            } catch (Ct) {
              console.error("Error fetching threads:", Ct);
            }
          }
          nt || (c.value = !1), i.value = !1, setTimeout(() => xt(!0), 100);
        } catch (He) {
          c.value = !1, console.error("sendMessage error:", He);
        }
    },
    [
      x,
      S,
      nt,
      pe,
      xt,
      _,
      N,
      X
    ]
  ), Nt = k.useMemo(() => {
    const mt = (He) => He.filter((et) => et.role !== "system"), ke = mt(be), Pe = mt(Q || []);
    return ke.length > 0 ? ke : Pe;
  }, [be, Q]);
  k.useEffect(() => {
    const mt = he * 2, ke = (Pe, He) => {
      if (Pe.length <= He) return Pe;
      let et = Pe.slice(-He);
      const bt = et[0];
      if (bt && bt.role === "user" && bt.parts?.some((Lt) => Lt.type === "tool-result"))
        for (let Lt = Pe.length - He - 1; Lt >= 0; Lt--) {
          const nn = Pe[Lt];
          if (nn && nn.role === "assistant" && nn.parts?.some((Ve) => Ve.type === "tool-call")) {
            et = Pe.slice(Lt);
            break;
          }
        }
      const Ct = et[et.length - 1];
      if (Ct && Ct.role === "assistant") {
        const fn = Ct.parts?.filter(
          (Lt) => Lt.type === "tool-call" && !Lt.result
        );
        if (fn && fn.length > 0)
          return Pe;
      }
      return et;
    };
    if (be.length > mt) {
      const Pe = ke(be, he);
      Pe.length !== be.length && Ae(Pe);
    } else if (Z !== "streaming" && Z !== "submitted" && be.length > he) {
      const Pe = ke(be, he);
      Pe.length !== be.length && Ae(Pe);
    }
  }, [be, Z, Ae, he]), k.useEffect(() => {
    be !== Ge.current && (Ge.current = be, tt.current = G);
  }, [be, G]), k.useEffect(() => {
    if (tt.current === G && be.length > 0 && G) {
      const ke = s.value[G] || [], Pe = new Map(
        ke.map((Ct) => [Ct.id, Ct.createdAt])
      );
      let He = be;
      if (be.length > 10) {
        He = be.slice(-10);
        const Ct = He[0];
        if (Ct && Ct.role === "user" && Ct.parts?.some((Lt) => Lt.type === "tool-result"))
          for (let Lt = be.indexOf(Ct) - 1; Lt >= 0; Lt--) {
            const nn = be[Lt];
            if (nn && nn.role === "assistant" && nn.parts?.some((Ve) => Ve.type === "tool-call")) {
              He = be.slice(Lt);
              break;
            }
          }
      }
      const et = He.map((Ct) => ({
        id: Ct.id,
        threadId: G,
        role: Ct.role,
        parts: Ct.parts,
        metadata: Ct.metadata,
        createdAt: Pe.get(Ct.id) || /* @__PURE__ */ new Date()
      })), bt = s.value;
      JSON.stringify(bt[G]) !== JSON.stringify(et) && (s.value = {
        ...bt,
        [G]: et
      }), Z !== "streaming" && Se(be).catch((Ct) => {
        console.error("Failed to save messages to IndexedDB:", Ct);
      });
    }
  }, [be, G, Z, s, Se]), k.useEffect(() => {
    be.length > 0 && xt(!0);
  }, [be.length, xt]), k.useEffect(() => () => {
    m.cleanup(), Ae([]), _([]), w("");
  }, [m]);
  const sn = () => {
    I(!P);
  }, { handleThreadSelect: Pn, handleNewThread: Mn } = xpe({
    threadId: t,
    setMessages: Ae,
    stop: _t,
    setHideError: N
  });
  return /* @__PURE__ */ v.jsxs("div", { className: "relative h-full w-full flex flex-col overflow-hidden", children: [
    /* @__PURE__ */ v.jsx(
      ape,
      {
        onClose: e,
        setApiKeyByName: B,
        onToggleSidebar: sn,
        isSidebarOpen: P
      }
    ),
    /* @__PURE__ */ v.jsxs(Yze, { direction: "horizontal", className: "flex-1 min-h-0", children: [
      /* @__PURE__ */ v.jsx(
        i3,
        {
          defaultSize: 25,
          minSize: 21,
          maxSize: 26,
          collapsible: !0,
          collapsedSize: 0,
          className: P ? "z-1000 overflow-auto-y" : "hidden",
          children: /* @__PURE__ */ v.jsx(
            bpe,
            {
              isOpen: P,
              onThreadSelect: Pn,
              onNewThread: Mn
            }
          )
        }
      ),
      P && /* @__PURE__ */ v.jsx(Xze, { withHandle: !0 }),
      /* @__PURE__ */ v.jsx(i3, { defaultSize: 80, minSize: 50, children: /* @__PURE__ */ v.jsxs("div", { className: "h-full flex flex-col gap-2 overflow-y-auto overflow-hidden", children: [
        a.value ? /* @__PURE__ */ v.jsx(QU, { message: "Loading thread..." }) : /* @__PURE__ */ v.jsxs(k.Fragment, { children: [
          /* @__PURE__ */ v.jsx(
            "div",
            {
              ref: St,
              className: "flex-1 overflow-hidden",
              "data-chatbot-text": "data-chatbot",
              tabIndex: 0,
              children: /* @__PURE__ */ v.jsx(
                qT,
                {
                  ref: yn,
                  className: "h-full pr-2 chat-scroll-area",
                  children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-3 py-2 min-h-full justify-end overflow-x-auto wrap-break-word", children: [
                    Y && ne.hasMore && /* @__PURE__ */ v.jsx(
                      "div",
                      {
                        ref: Vt,
                        className: "h-4 flex items-center justify-center",
                        children: ne.isLoadingMore && /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Loading..." })
                      }
                    ),
                    /* @__PURE__ */ v.jsx(CA, { initial: !1, children: Nt.map((mt, ke) => {
                      const Pe = Nt[ke - 1] ?? mt;
                      return /* @__PURE__ */ v.jsx(
                        NMe,
                        {
                          threadId: t,
                          messageIndex: ke,
                          message: mt,
                          prevMessage: Pe,
                          isLoading: nt,
                          isLastMessage: ke === Nt.length - 1,
                          status: Z,
                          setMessages: Ae,
                          sendMessage: pe,
                          regenerate: re,
                          addToolResult: xe,
                          onReuseMessage: (He) => wze(He, w)
                        },
                        mt.id
                      );
                    }) }),
                    Nt.length > 0 && (Z === "streaming" || Z === "submitted") && /* @__PURE__ */ v.jsx(Z5, {}),
                    !M && ge && /* @__PURE__ */ v.jsx(xze, { error: ge }),
                    /* @__PURE__ */ v.jsx("div", { className: "min-w-0 min-h-52" })
                  ] })
                }
              )
            }
          ),
          Nt.length !== 0 && /* @__PURE__ */ v.jsx(
            K5,
            {
              value: x,
              onChange: w,
              onSend: An,
              onFilesChange: _,
              files: S,
              mcpServers: [],
              opStop: _t,
              onToggleMcpServer: () => {
              },
              onStartTyping: Kt,
              onUseNextSuggestionChange: (mt) => {
                f.value = mt;
              }
            }
          )
        ] }),
        Nt.length === 0 && /* @__PURE__ */ v.jsxs(k.Fragment, { children: [
          /* @__PURE__ */ v.jsx(PMe, {}),
          (Z === "streaming" || Z === "submitted") && /* @__PURE__ */ v.jsx("div", { className: "flex justify-center py-4", children: /* @__PURE__ */ v.jsx(Z5, {}) }),
          /* @__PURE__ */ v.jsx(
            K5,
            {
              value: x,
              onChange: w,
              onSend: An,
              onFilesChange: _,
              files: S,
              mcpServers: [],
              onToggleMcpServer: () => {
              },
              opStop: _t,
              onStartTyping: Kt,
              onUseNextSuggestionChange: (mt) => {
                f.value = mt;
              }
            }
          )
        ] })
      ] }) })
    ] })
  ] });
};
var nm = { exports: {} }, gE = {}, yE = { exports: {} }, vE, o3;
function eLe() {
  if (o3) return vE;
  o3 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return vE = e, vE;
}
var bE, s3;
function tLe() {
  if (s3) return bE;
  s3 = 1;
  var e = /* @__PURE__ */ eLe();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, bE = function() {
    function r(s, a, c, u, f, h) {
      if (h !== e) {
        var m = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw m.name = "Invariant Violation", m;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var o = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, bE;
}
var a3;
function iG() {
  return a3 || (a3 = 1, yE.exports = /* @__PURE__ */ tLe()()), yE.exports;
}
function oG(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (n = oG(e[t])) && (r && (r += " "), r += n);
  else for (t in e) e[t] && (r && (r += " "), r += t);
  return r;
}
function l3() {
  for (var e, t, n = 0, r = ""; n < arguments.length; ) (e = arguments[n++]) && (t = oG(e)) && (r && (r += " "), r += t);
  return r;
}
const nLe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: l3,
  default: l3
}, Symbol.toStringTag, { value: "Module" })), rLe = /* @__PURE__ */ TK(nLe);
var dr = {}, ql = {}, c3;
function s1() {
  if (c3) return ql;
  c3 = 1, Object.defineProperty(ql, "__esModule", {
    value: !0
  }), ql.dontSetMe = i, ql.findInArray = e, ql.int = r, ql.isFunction = t, ql.isNum = n;
  function e(o, s) {
    for (let a = 0, c = o.length; a < c; a++)
      if (s.apply(s, [o[a], a, o])) return o[a];
  }
  function t(o) {
    return typeof o == "function" || Object.prototype.toString.call(o) === "[object Function]";
  }
  function n(o) {
    return typeof o == "number" && !isNaN(o);
  }
  function r(o) {
    return parseInt(o, 10);
  }
  function i(o, s, a) {
    if (o[s])
      return new Error("Invalid prop ".concat(s, " passed to ").concat(a, " - do not set this, set it on the child."));
  }
  return ql;
}
var Gl = {}, u3;
function iLe() {
  if (u3) return Gl;
  u3 = 1, Object.defineProperty(Gl, "__esModule", {
    value: !0
  }), Gl.browserPrefixToKey = n, Gl.browserPrefixToStyle = r, Gl.default = void 0, Gl.getPrefix = t;
  const e = ["Moz", "Webkit", "O", "ms"];
  function t() {
    var o;
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
    if (typeof window > "u") return "";
    const a = (o = window.document) === null || o === void 0 || (o = o.documentElement) === null || o === void 0 ? void 0 : o.style;
    if (!a || s in a) return "";
    for (let c = 0; c < e.length; c++)
      if (n(s, e[c]) in a) return e[c];
    return "";
  }
  function n(o, s) {
    return s ? "".concat(s).concat(i(o)) : o;
  }
  function r(o, s) {
    return s ? "-".concat(s.toLowerCase(), "-").concat(o) : o;
  }
  function i(o) {
    let s = "", a = !0;
    for (let c = 0; c < o.length; c++)
      a ? (s += o[c].toUpperCase(), a = !1) : o[c] === "-" ? a = !0 : s += o[c];
    return s;
  }
  return Gl.default = t(), Gl;
}
var d3;
function JN() {
  if (d3) return dr;
  d3 = 1, Object.defineProperty(dr, "__esModule", {
    value: !0
  }), dr.addClassName = P, dr.addEvent = a, dr.addUserSelectStyles = M, dr.createCSSTransform = b, dr.createSVGTransform = x, dr.getTouch = S, dr.getTouchIdentifier = _, dr.getTranslation = w, dr.innerHeight = h, dr.innerWidth = m, dr.matchesSelector = o, dr.matchesSelectorAndParentsTo = s, dr.offsetXYFromParent = g, dr.outerHeight = u, dr.outerWidth = f, dr.removeClassName = I, dr.removeEvent = c, dr.removeUserSelectStyles = N;
  var e = s1(), t = r(iLe());
  function n(O) {
    if (typeof WeakMap != "function") return null;
    var L = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap();
    return (n = function(B) {
      return B ? U : L;
    })(O);
  }
  function r(O, L) {
    if (O && O.__esModule)
      return O;
    if (O === null || typeof O != "object" && typeof O != "function")
      return { default: O };
    var U = n(L);
    if (U && U.has(O))
      return U.get(O);
    var B = {}, G = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var Y in O)
      if (Y !== "default" && Object.prototype.hasOwnProperty.call(O, Y)) {
        var he = G ? Object.getOwnPropertyDescriptor(O, Y) : null;
        he && (he.get || he.set) ? Object.defineProperty(B, Y, he) : B[Y] = O[Y];
      }
    return B.default = O, U && U.set(O, B), B;
  }
  let i = "";
  function o(O, L) {
    return i || (i = (0, e.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(U) {
      return (0, e.isFunction)(O[U]);
    })), (0, e.isFunction)(O[i]) ? O[i](L) : !1;
  }
  function s(O, L, U) {
    let B = O;
    do {
      if (o(B, L)) return !0;
      if (B === U) return !1;
      B = B.parentNode;
    } while (B);
    return !1;
  }
  function a(O, L, U, B) {
    if (!O) return;
    const G = {
      capture: !0,
      ...B
    };
    O.addEventListener ? O.addEventListener(L, U, G) : O.attachEvent ? O.attachEvent("on" + L, U) : O["on" + L] = U;
  }
  function c(O, L, U, B) {
    if (!O) return;
    const G = {
      capture: !0,
      ...B
    };
    O.removeEventListener ? O.removeEventListener(L, U, G) : O.detachEvent ? O.detachEvent("on" + L, U) : O["on" + L] = null;
  }
  function u(O) {
    let L = O.clientHeight;
    const U = O.ownerDocument.defaultView.getComputedStyle(O);
    return L += (0, e.int)(U.borderTopWidth), L += (0, e.int)(U.borderBottomWidth), L;
  }
  function f(O) {
    let L = O.clientWidth;
    const U = O.ownerDocument.defaultView.getComputedStyle(O);
    return L += (0, e.int)(U.borderLeftWidth), L += (0, e.int)(U.borderRightWidth), L;
  }
  function h(O) {
    let L = O.clientHeight;
    const U = O.ownerDocument.defaultView.getComputedStyle(O);
    return L -= (0, e.int)(U.paddingTop), L -= (0, e.int)(U.paddingBottom), L;
  }
  function m(O) {
    let L = O.clientWidth;
    const U = O.ownerDocument.defaultView.getComputedStyle(O);
    return L -= (0, e.int)(U.paddingLeft), L -= (0, e.int)(U.paddingRight), L;
  }
  function g(O, L, U) {
    const G = L === L.ownerDocument.body ? {
      left: 0,
      top: 0
    } : L.getBoundingClientRect(), Y = (O.clientX + L.scrollLeft - G.left) / U, he = (O.clientY + L.scrollTop - G.top) / U;
    return {
      x: Y,
      y: he
    };
  }
  function b(O, L) {
    const U = w(O, L, "px");
    return {
      [(0, t.browserPrefixToKey)("transform", t.default)]: U
    };
  }
  function x(O, L) {
    return w(O, L, "");
  }
  function w(O, L, U) {
    let {
      x: B,
      y: G
    } = O, Y = "translate(".concat(B).concat(U, ",").concat(G).concat(U, ")");
    if (L) {
      const he = "".concat(typeof L.x == "string" ? L.x : L.x + U), ie = "".concat(typeof L.y == "string" ? L.y : L.y + U);
      Y = "translate(".concat(he, ", ").concat(ie, ")") + Y;
    }
    return Y;
  }
  function S(O, L) {
    return O.targetTouches && (0, e.findInArray)(O.targetTouches, (U) => L === U.identifier) || O.changedTouches && (0, e.findInArray)(O.changedTouches, (U) => L === U.identifier);
  }
  function _(O) {
    if (O.targetTouches && O.targetTouches[0]) return O.targetTouches[0].identifier;
    if (O.changedTouches && O.changedTouches[0]) return O.changedTouches[0].identifier;
  }
  function M(O) {
    if (!O) return;
    let L = O.getElementById("react-draggable-style-el");
    L || (L = O.createElement("style"), L.type = "text/css", L.id = "react-draggable-style-el", L.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, L.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, O.getElementsByTagName("head")[0].appendChild(L)), O.body && P(O.body, "react-draggable-transparent-selection");
  }
  function N(O) {
    if (O)
      try {
        if (O.body && I(O.body, "react-draggable-transparent-selection"), O.selection)
          O.selection.empty();
        else {
          const L = (O.defaultView || window).getSelection();
          L && L.type !== "Caret" && L.removeAllRanges();
        }
      } catch {
      }
  }
  function P(O, L) {
    O.classList ? O.classList.add(L) : O.className.match(new RegExp("(?:^|\\s)".concat(L, "(?!\\S)"))) || (O.className += " ".concat(L));
  }
  function I(O, L) {
    O.classList ? O.classList.remove(L) : O.className = O.className.replace(new RegExp("(?:^|\\s)".concat(L, "(?!\\S)"), "g"), "");
  }
  return dr;
}
var Rs = {}, f3;
function sG() {
  if (f3) return Rs;
  f3 = 1, Object.defineProperty(Rs, "__esModule", {
    value: !0
  }), Rs.canDragX = i, Rs.canDragY = o, Rs.createCoreData = a, Rs.createDraggableData = c, Rs.getBoundPosition = n, Rs.getControlPosition = s, Rs.snapToGrid = r;
  var e = s1(), t = JN();
  function n(h, m, g) {
    if (!h.props.bounds) return [m, g];
    let {
      bounds: b
    } = h.props;
    b = typeof b == "string" ? b : u(b);
    const x = f(h);
    if (typeof b == "string") {
      const {
        ownerDocument: w
      } = x, S = w.defaultView;
      let _;
      if (b === "parent" ? _ = x.parentNode : _ = w.querySelector(b), !(_ instanceof S.HTMLElement))
        throw new Error('Bounds selector "' + b + '" could not find an element.');
      const M = _, N = S.getComputedStyle(x), P = S.getComputedStyle(M);
      b = {
        left: -x.offsetLeft + (0, e.int)(P.paddingLeft) + (0, e.int)(N.marginLeft),
        top: -x.offsetTop + (0, e.int)(P.paddingTop) + (0, e.int)(N.marginTop),
        right: (0, t.innerWidth)(M) - (0, t.outerWidth)(x) - x.offsetLeft + (0, e.int)(P.paddingRight) - (0, e.int)(N.marginRight),
        bottom: (0, t.innerHeight)(M) - (0, t.outerHeight)(x) - x.offsetTop + (0, e.int)(P.paddingBottom) - (0, e.int)(N.marginBottom)
      };
    }
    return (0, e.isNum)(b.right) && (m = Math.min(m, b.right)), (0, e.isNum)(b.bottom) && (g = Math.min(g, b.bottom)), (0, e.isNum)(b.left) && (m = Math.max(m, b.left)), (0, e.isNum)(b.top) && (g = Math.max(g, b.top)), [m, g];
  }
  function r(h, m, g) {
    const b = Math.round(m / h[0]) * h[0], x = Math.round(g / h[1]) * h[1];
    return [b, x];
  }
  function i(h) {
    return h.props.axis === "both" || h.props.axis === "x";
  }
  function o(h) {
    return h.props.axis === "both" || h.props.axis === "y";
  }
  function s(h, m, g) {
    const b = typeof m == "number" ? (0, t.getTouch)(h, m) : null;
    if (typeof m == "number" && !b) return null;
    const x = f(g), w = g.props.offsetParent || x.offsetParent || x.ownerDocument.body;
    return (0, t.offsetXYFromParent)(b || h, w, g.props.scale);
  }
  function a(h, m, g) {
    const b = !(0, e.isNum)(h.lastX), x = f(h);
    return b ? {
      node: x,
      deltaX: 0,
      deltaY: 0,
      lastX: m,
      lastY: g,
      x: m,
      y: g
    } : {
      node: x,
      deltaX: m - h.lastX,
      deltaY: g - h.lastY,
      lastX: h.lastX,
      lastY: h.lastY,
      x: m,
      y: g
    };
  }
  function c(h, m) {
    const g = h.props.scale;
    return {
      node: m.node,
      x: h.state.x + m.deltaX / g,
      y: h.state.y + m.deltaY / g,
      deltaX: m.deltaX / g,
      deltaY: m.deltaY / g,
      lastX: h.state.x,
      lastY: h.state.y
    };
  }
  function u(h) {
    return {
      left: h.left,
      top: h.top,
      right: h.right,
      bottom: h.bottom
    };
  }
  function f(h) {
    const m = h.findDOMNode();
    if (!m)
      throw new Error("<DraggableCore>: Unmounted during event!");
    return m;
  }
  return Rs;
}
var rm = {}, c0 = {}, h3;
function aG() {
  if (h3) return c0;
  h3 = 1, Object.defineProperty(c0, "__esModule", {
    value: !0
  }), c0.default = e;
  function e() {
  }
  return c0;
}
var p3;
function oLe() {
  if (p3) return rm;
  p3 = 1, Object.defineProperty(rm, "__esModule", {
    value: !0
  }), rm.default = void 0;
  var e = u(ud()), t = a(/* @__PURE__ */ iG()), n = a(zx()), r = JN(), i = sG(), o = s1(), s = a(aG());
  function a(w) {
    return w && w.__esModule ? w : { default: w };
  }
  function c(w) {
    if (typeof WeakMap != "function") return null;
    var S = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap();
    return (c = function(M) {
      return M ? _ : S;
    })(w);
  }
  function u(w, S) {
    if (w && w.__esModule)
      return w;
    if (w === null || typeof w != "object" && typeof w != "function")
      return { default: w };
    var _ = c(S);
    if (_ && _.has(w))
      return _.get(w);
    var M = {}, N = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var P in w)
      if (P !== "default" && Object.prototype.hasOwnProperty.call(w, P)) {
        var I = N ? Object.getOwnPropertyDescriptor(w, P) : null;
        I && (I.get || I.set) ? Object.defineProperty(M, P, I) : M[P] = w[P];
      }
    return M.default = w, _ && _.set(w, M), M;
  }
  function f(w, S, _) {
    return S = h(S), S in w ? Object.defineProperty(w, S, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : w[S] = _, w;
  }
  function h(w) {
    var S = m(w, "string");
    return typeof S == "symbol" ? S : String(S);
  }
  function m(w, S) {
    if (typeof w != "object" || w === null) return w;
    var _ = w[Symbol.toPrimitive];
    if (_ !== void 0) {
      var M = _.call(w, S);
      if (typeof M != "object") return M;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (S === "string" ? String : Number)(w);
  }
  const g = {
    touch: {
      start: "touchstart",
      move: "touchmove",
      stop: "touchend"
    },
    mouse: {
      start: "mousedown",
      move: "mousemove",
      stop: "mouseup"
    }
  };
  let b = g.mouse, x = class extends e.Component {
    constructor() {
      super(...arguments), f(this, "dragging", !1), f(this, "lastX", NaN), f(this, "lastY", NaN), f(this, "touchIdentifier", null), f(this, "mounted", !1), f(this, "handleDragStart", (S) => {
        if (this.props.onMouseDown(S), !this.props.allowAnyClick && typeof S.button == "number" && S.button !== 0) return !1;
        const _ = this.findDOMNode();
        if (!_ || !_.ownerDocument || !_.ownerDocument.body)
          throw new Error("<DraggableCore> not mounted on DragStart!");
        const {
          ownerDocument: M
        } = _;
        if (this.props.disabled || !(S.target instanceof M.defaultView.Node) || this.props.handle && !(0, r.matchesSelectorAndParentsTo)(S.target, this.props.handle, _) || this.props.cancel && (0, r.matchesSelectorAndParentsTo)(S.target, this.props.cancel, _))
          return;
        S.type === "touchstart" && S.preventDefault();
        const N = (0, r.getTouchIdentifier)(S);
        this.touchIdentifier = N;
        const P = (0, i.getControlPosition)(S, N, this);
        if (P == null) return;
        const {
          x: I,
          y: O
        } = P, L = (0, i.createCoreData)(this, I, O);
        (0, s.default)("DraggableCore: handleDragStart: %j", L), (0, s.default)("calling", this.props.onStart), !(this.props.onStart(S, L) === !1 || this.mounted === !1) && (this.props.enableUserSelectHack && (0, r.addUserSelectStyles)(M), this.dragging = !0, this.lastX = I, this.lastY = O, (0, r.addEvent)(M, b.move, this.handleDrag), (0, r.addEvent)(M, b.stop, this.handleDragStop));
      }), f(this, "handleDrag", (S) => {
        const _ = (0, i.getControlPosition)(S, this.touchIdentifier, this);
        if (_ == null) return;
        let {
          x: M,
          y: N
        } = _;
        if (Array.isArray(this.props.grid)) {
          let O = M - this.lastX, L = N - this.lastY;
          if ([O, L] = (0, i.snapToGrid)(this.props.grid, O, L), !O && !L) return;
          M = this.lastX + O, N = this.lastY + L;
        }
        const P = (0, i.createCoreData)(this, M, N);
        if ((0, s.default)("DraggableCore: handleDrag: %j", P), this.props.onDrag(S, P) === !1 || this.mounted === !1) {
          try {
            this.handleDragStop(new MouseEvent("mouseup"));
          } catch {
            const L = document.createEvent("MouseEvents");
            L.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), this.handleDragStop(L);
          }
          return;
        }
        this.lastX = M, this.lastY = N;
      }), f(this, "handleDragStop", (S) => {
        if (!this.dragging) return;
        const _ = (0, i.getControlPosition)(S, this.touchIdentifier, this);
        if (_ == null) return;
        let {
          x: M,
          y: N
        } = _;
        if (Array.isArray(this.props.grid)) {
          let L = M - this.lastX || 0, U = N - this.lastY || 0;
          [L, U] = (0, i.snapToGrid)(this.props.grid, L, U), M = this.lastX + L, N = this.lastY + U;
        }
        const P = (0, i.createCoreData)(this, M, N);
        if (this.props.onStop(S, P) === !1 || this.mounted === !1) return !1;
        const O = this.findDOMNode();
        O && this.props.enableUserSelectHack && (0, r.removeUserSelectStyles)(O.ownerDocument), (0, s.default)("DraggableCore: handleDragStop: %j", P), this.dragging = !1, this.lastX = NaN, this.lastY = NaN, O && ((0, s.default)("DraggableCore: Removing handlers"), (0, r.removeEvent)(O.ownerDocument, b.move, this.handleDrag), (0, r.removeEvent)(O.ownerDocument, b.stop, this.handleDragStop));
      }), f(this, "onMouseDown", (S) => (b = g.mouse, this.handleDragStart(S))), f(this, "onMouseUp", (S) => (b = g.mouse, this.handleDragStop(S))), f(this, "onTouchStart", (S) => (b = g.touch, this.handleDragStart(S))), f(this, "onTouchEnd", (S) => (b = g.touch, this.handleDragStop(S)));
    }
    componentDidMount() {
      this.mounted = !0;
      const S = this.findDOMNode();
      S && (0, r.addEvent)(S, g.touch.start, this.onTouchStart, {
        passive: !1
      });
    }
    componentWillUnmount() {
      this.mounted = !1;
      const S = this.findDOMNode();
      if (S) {
        const {
          ownerDocument: _
        } = S;
        (0, r.removeEvent)(_, g.mouse.move, this.handleDrag), (0, r.removeEvent)(_, g.touch.move, this.handleDrag), (0, r.removeEvent)(_, g.mouse.stop, this.handleDragStop), (0, r.removeEvent)(_, g.touch.stop, this.handleDragStop), (0, r.removeEvent)(S, g.touch.start, this.onTouchStart, {
          passive: !1
        }), this.props.enableUserSelectHack && (0, r.removeUserSelectStyles)(_);
      }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() {
      var S, _;
      return (S = this.props) !== null && S !== void 0 && S.nodeRef ? (_ = this.props) === null || _ === void 0 || (_ = _.nodeRef) === null || _ === void 0 ? void 0 : _.current : n.default.findDOMNode(this);
    }
    render() {
      return /* @__PURE__ */ e.cloneElement(e.Children.only(this.props.children), {
        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        // onTouchStart is added on `componentDidMount` so they can be added with
        // {passive: false}, which allows it to cancel. See
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        onTouchEnd: this.onTouchEnd
      });
    }
  };
  return rm.default = x, f(x, "displayName", "DraggableCore"), f(x, "propTypes", {
    /**
     * `allowAnyClick` allows dragging using any mouse button.
     * By default, we only accept the left button.
     *
     * Defaults to `false`.
     */
    allowAnyClick: t.default.bool,
    children: t.default.node.isRequired,
    /**
     * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
     * with the exception of `onMouseDown`, will not fire.
     */
    disabled: t.default.bool,
    /**
     * By default, we add 'user-select:none' attributes to the document body
     * to prevent ugly text selection during drag. If this is causing problems
     * for your app, set this to `false`.
     */
    enableUserSelectHack: t.default.bool,
    /**
     * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
     * instead of using the parent node.
     */
    offsetParent: function(w, S) {
      if (w[S] && w[S].nodeType !== 1)
        throw new Error("Draggable's offsetParent must be a DOM Node.");
    },
    /**
     * `grid` specifies the x and y that dragging should snap to.
     */
    grid: t.default.arrayOf(t.default.number),
    /**
     * `handle` specifies a selector to be used as the handle that initiates drag.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable handle=".handle">
     *              <div>
     *                  <div className="handle">Click me to drag</div>
     *                  <div>This is some other content</div>
     *              </div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    handle: t.default.string,
    /**
     * `cancel` specifies a selector to be used to prevent drag initialization.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *           return(
     *               <Draggable cancel=".cancel">
     *                   <div>
     *                     <div className="cancel">You can't drag from here</div>
     *                     <div>Dragging here works fine</div>
     *                   </div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    cancel: t.default.string,
    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
     * Unfortunately, in order for <Draggable> to work properly, we need raw access
     * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
     * as in this example:
     *
     * function MyComponent() {
     *   const nodeRef = React.useRef(null);
     *   return (
     *     <Draggable nodeRef={nodeRef}>
     *       <div ref={nodeRef}>Example Target</div>
     *     </Draggable>
     *   );
     * }
     *
     * This can be used for arbitrarily nested components, so long as the ref ends up
     * pointing to the actual child DOM node and not a custom component.
     */
    nodeRef: t.default.object,
    /**
     * Called when dragging starts.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onStart: t.default.func,
    /**
     * Called while dragging.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onDrag: t.default.func,
    /**
     * Called when dragging stops.
     * If this function returns the boolean false, the drag will remain active.
     */
    onStop: t.default.func,
    /**
     * A workaround option which can be passed if onMouseDown needs to be accessed,
     * since it'll always be blocked (as there is internal use of onMouseDown)
     */
    onMouseDown: t.default.func,
    /**
     * `scale`, if set, applies scaling while dragging an element
     */
    scale: t.default.number,
    /**
     * These properties should be defined on the child, not here.
     */
    className: o.dontSetMe,
    style: o.dontSetMe,
    transform: o.dontSetMe
  }), f(x, "defaultProps", {
    allowAnyClick: !1,
    // by default only accept left click
    disabled: !1,
    enableUserSelectHack: !0,
    onStart: function() {
    },
    onDrag: function() {
    },
    onStop: function() {
    },
    onMouseDown: function() {
    },
    scale: 1
  }), rm;
}
var m3;
function sLe() {
  return m3 || (m3 = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "DraggableCore", {
      enumerable: !0,
      get: function() {
        return c.default;
      }
    }), e.default = void 0;
    var t = m(ud()), n = f(/* @__PURE__ */ iG()), r = f(zx()), i = f(rLe), o = JN(), s = sG(), a = s1(), c = f(oLe()), u = f(aG());
    function f(_) {
      return _ && _.__esModule ? _ : { default: _ };
    }
    function h(_) {
      if (typeof WeakMap != "function") return null;
      var M = /* @__PURE__ */ new WeakMap(), N = /* @__PURE__ */ new WeakMap();
      return (h = function(P) {
        return P ? N : M;
      })(_);
    }
    function m(_, M) {
      if (_ && _.__esModule)
        return _;
      if (_ === null || typeof _ != "object" && typeof _ != "function")
        return { default: _ };
      var N = h(M);
      if (N && N.has(_))
        return N.get(_);
      var P = {}, I = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var O in _)
        if (O !== "default" && Object.prototype.hasOwnProperty.call(_, O)) {
          var L = I ? Object.getOwnPropertyDescriptor(_, O) : null;
          L && (L.get || L.set) ? Object.defineProperty(P, O, L) : P[O] = _[O];
        }
      return P.default = _, N && N.set(_, P), P;
    }
    function g() {
      return g = Object.assign ? Object.assign.bind() : function(_) {
        for (var M = 1; M < arguments.length; M++) {
          var N = arguments[M];
          for (var P in N)
            Object.prototype.hasOwnProperty.call(N, P) && (_[P] = N[P]);
        }
        return _;
      }, g.apply(this, arguments);
    }
    function b(_, M, N) {
      return M = x(M), M in _ ? Object.defineProperty(_, M, { value: N, enumerable: !0, configurable: !0, writable: !0 }) : _[M] = N, _;
    }
    function x(_) {
      var M = w(_, "string");
      return typeof M == "symbol" ? M : String(M);
    }
    function w(_, M) {
      if (typeof _ != "object" || _ === null) return _;
      var N = _[Symbol.toPrimitive];
      if (N !== void 0) {
        var P = N.call(_, M);
        if (typeof P != "object") return P;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (M === "string" ? String : Number)(_);
    }
    class S extends t.Component {
      // React 16.3+
      // Arity (props, state)
      static getDerivedStateFromProps(M, N) {
        let {
          position: P
        } = M, {
          prevPropsPosition: I
        } = N;
        return P && (!I || P.x !== I.x || P.y !== I.y) ? ((0, u.default)("Draggable: getDerivedStateFromProps %j", {
          position: P,
          prevPropsPosition: I
        }), {
          x: P.x,
          y: P.y,
          prevPropsPosition: {
            ...P
          }
        }) : null;
      }
      constructor(M) {
        super(M), b(this, "onDragStart", (N, P) => {
          if ((0, u.default)("Draggable: onDragStart: %j", P), this.props.onStart(N, (0, s.createDraggableData)(this, P)) === !1) return !1;
          this.setState({
            dragging: !0,
            dragged: !0
          });
        }), b(this, "onDrag", (N, P) => {
          if (!this.state.dragging) return !1;
          (0, u.default)("Draggable: onDrag: %j", P);
          const I = (0, s.createDraggableData)(this, P), O = {
            x: I.x,
            y: I.y,
            slackX: 0,
            slackY: 0
          };
          if (this.props.bounds) {
            const {
              x: U,
              y: B
            } = O;
            O.x += this.state.slackX, O.y += this.state.slackY;
            const [G, Y] = (0, s.getBoundPosition)(this, O.x, O.y);
            O.x = G, O.y = Y, O.slackX = this.state.slackX + (U - O.x), O.slackY = this.state.slackY + (B - O.y), I.x = O.x, I.y = O.y, I.deltaX = O.x - this.state.x, I.deltaY = O.y - this.state.y;
          }
          if (this.props.onDrag(N, I) === !1) return !1;
          this.setState(O);
        }), b(this, "onDragStop", (N, P) => {
          if (!this.state.dragging || this.props.onStop(N, (0, s.createDraggableData)(this, P)) === !1) return !1;
          (0, u.default)("Draggable: onDragStop: %j", P);
          const O = {
            dragging: !1,
            slackX: 0,
            slackY: 0
          };
          if (!!this.props.position) {
            const {
              x: U,
              y: B
            } = this.props.position;
            O.x = U, O.y = B;
          }
          this.setState(O);
        }), this.state = {
          // Whether or not we are currently dragging.
          dragging: !1,
          // Whether or not we have been dragged before.
          dragged: !1,
          // Current transform x and y.
          x: M.position ? M.position.x : M.defaultPosition.x,
          y: M.position ? M.position.y : M.defaultPosition.y,
          prevPropsPosition: {
            ...M.position
          },
          // Used for compensating for out-of-bounds drags
          slackX: 0,
          slackY: 0,
          // Can only determine if SVG after mounting
          isElementSVG: !1
        }, M.position && !(M.onDrag || M.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
      }
      componentDidMount() {
        typeof window.SVGElement < "u" && this.findDOMNode() instanceof window.SVGElement && this.setState({
          isElementSVG: !0
        });
      }
      componentWillUnmount() {
        this.setState({
          dragging: !1
        });
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        var M, N;
        return (M = (N = this.props) === null || N === void 0 || (N = N.nodeRef) === null || N === void 0 ? void 0 : N.current) !== null && M !== void 0 ? M : r.default.findDOMNode(this);
      }
      render() {
        const {
          axis: M,
          bounds: N,
          children: P,
          defaultPosition: I,
          defaultClassName: O,
          defaultClassNameDragging: L,
          defaultClassNameDragged: U,
          position: B,
          positionOffset: G,
          scale: Y,
          ...he
        } = this.props;
        let ie = {}, ne = null;
        const Q = !!!B || this.state.dragging, X = B || I, Se = {
          // Set left if horizontal drag is enabled
          x: (0, s.canDragX)(this) && Q ? this.state.x : X.x,
          // Set top if vertical drag is enabled
          y: (0, s.canDragY)(this) && Q ? this.state.y : X.y
        };
        this.state.isElementSVG ? ne = (0, o.createSVGTransform)(Se, G) : ie = (0, o.createCSSTransform)(Se, G);
        const W = (0, i.default)(P.props.className || "", O, {
          [L]: this.state.dragging,
          [U]: this.state.dragged
        });
        return /* @__PURE__ */ t.createElement(c.default, g({}, he, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), /* @__PURE__ */ t.cloneElement(t.Children.only(P), {
          className: W,
          style: {
            ...P.props.style,
            ...ie
          },
          transform: ne
        }));
      }
    }
    e.default = S, b(S, "displayName", "Draggable"), b(S, "propTypes", {
      // Accepts all props <DraggableCore> accepts.
      ...c.default.propTypes,
      /**
       * `axis` determines which axis the draggable can move.
       *
       *  Note that all callbacks will still return data as normal. This only
       *  controls flushing to the DOM.
       *
       * 'both' allows movement horizontally and vertically.
       * 'x' limits movement to horizontal axis.
       * 'y' limits movement to vertical axis.
       * 'none' limits all movement.
       *
       * Defaults to 'both'.
       */
      axis: n.default.oneOf(["both", "x", "y", "none"]),
      /**
       * `bounds` determines the range of movement available to the element.
       * Available values are:
       *
       * 'parent' restricts movement within the Draggable's parent node.
       *
       * Alternatively, pass an object with the following properties, all of which are optional:
       *
       * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
       *
       * All values are in px.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable bounds={{right: 300, bottom: 300}}>
       *              <div>Content</div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      bounds: n.default.oneOfType([n.default.shape({
        left: n.default.number,
        right: n.default.number,
        top: n.default.number,
        bottom: n.default.number
      }), n.default.string, n.default.oneOf([!1])]),
      defaultClassName: n.default.string,
      defaultClassNameDragging: n.default.string,
      defaultClassNameDragged: n.default.string,
      /**
       * `defaultPosition` specifies the x and y that the dragged item should start at
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable defaultPosition={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      defaultPosition: n.default.shape({
        x: n.default.number,
        y: n.default.number
      }),
      positionOffset: n.default.shape({
        x: n.default.oneOfType([n.default.number, n.default.string]),
        y: n.default.oneOfType([n.default.number, n.default.string])
      }),
      /**
       * `position`, if present, defines the current position of the element.
       *
       *  This is similar to how form elements in React work - if no `position` is supplied, the component
       *  is uncontrolled.
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable position={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      position: n.default.shape({
        x: n.default.number,
        y: n.default.number
      }),
      /**
       * These properties should be defined on the child, not here.
       */
      className: a.dontSetMe,
      style: a.dontSetMe,
      transform: a.dontSetMe
    }), b(S, "defaultProps", {
      ...c.default.defaultProps,
      axis: "both",
      bounds: !1,
      defaultClassName: "react-draggable",
      defaultClassNameDragging: "react-draggable-dragging",
      defaultClassNameDragged: "react-draggable-dragged",
      defaultPosition: {
        x: 0,
        y: 0
      },
      scale: 1
    });
  })(gE)), gE;
}
var g3;
function aLe() {
  if (g3) return nm.exports;
  g3 = 1;
  const {
    default: e,
    DraggableCore: t
  } = sLe();
  return nm.exports = e, nm.exports.default = e, nm.exports.DraggableCore = t, nm.exports;
}
var lLe = aLe();
const cLe = /* @__PURE__ */ Pc(lLe);
var br = function() {
  return br = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, br.apply(this, arguments);
}, y3 = {
  width: "100%",
  height: "10px",
  top: "0px",
  left: "0px",
  cursor: "row-resize"
}, v3 = {
  width: "10px",
  height: "100%",
  top: "0px",
  left: "0px",
  cursor: "col-resize"
}, u0 = {
  width: "20px",
  height: "20px",
  position: "absolute",
  zIndex: 1
}, uLe = {
  top: br(br({}, y3), { top: "-5px" }),
  right: br(br({}, v3), { left: void 0, right: "-5px" }),
  bottom: br(br({}, y3), { top: void 0, bottom: "-5px" }),
  left: br(br({}, v3), { left: "-5px" }),
  topRight: br(br({}, u0), { right: "-10px", top: "-10px", cursor: "ne-resize" }),
  bottomRight: br(br({}, u0), { right: "-10px", bottom: "-10px", cursor: "se-resize" }),
  bottomLeft: br(br({}, u0), { left: "-10px", bottom: "-10px", cursor: "sw-resize" }),
  topLeft: br(br({}, u0), { left: "-10px", top: "-10px", cursor: "nw-resize" })
}, dLe = k.memo(function(e) {
  var t = e.onResizeStart, n = e.direction, r = e.children, i = e.replaceStyles, o = e.className, s = k.useCallback(function(u) {
    t(u, n);
  }, [t, n]), a = k.useCallback(function(u) {
    t(u, n);
  }, [t, n]), c = k.useMemo(function() {
    return br(br({ position: "absolute", userSelect: "none" }, uLe[n]), i ?? {});
  }, [i, n]);
  return v.jsx("div", { className: o || void 0, style: c, onMouseDown: s, onTouchStart: a, children: r });
}), fLe = /* @__PURE__ */ (function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
})(), $s = function() {
  return $s = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, $s.apply(this, arguments);
}, hLe = {
  width: "auto",
  height: "auto"
}, d0 = function(e, t, n) {
  return Math.max(Math.min(e, n), t);
}, b3 = function(e, t, n) {
  var r = Math.round(e / t);
  return r * t + n * (r - 1);
}, Sf = function(e, t) {
  return new RegExp(e, "i").test(t);
}, f0 = function(e) {
  return !!(e.touches && e.touches.length);
}, pLe = function(e) {
  return !!((e.clientX || e.clientX === 0) && (e.clientY || e.clientY === 0));
}, x3 = function(e, t, n) {
  n === void 0 && (n = 0);
  var r = t.reduce(function(o, s, a) {
    return Math.abs(s - e) < Math.abs(t[o] - e) ? a : o;
  }, 0), i = Math.abs(t[r] - e);
  return n === 0 || i < n ? t[r] : e;
}, xE = function(e) {
  return e = e.toString(), e === "auto" || e.endsWith("px") || e.endsWith("%") || e.endsWith("vh") || e.endsWith("vw") || e.endsWith("vmax") || e.endsWith("vmin") ? e : "".concat(e, "px");
}, h0 = function(e, t, n, r) {
  if (e && typeof e == "string") {
    if (e.endsWith("px"))
      return Number(e.replace("px", ""));
    if (e.endsWith("%")) {
      var i = Number(e.replace("%", "")) / 100;
      return t * i;
    }
    if (e.endsWith("vw")) {
      var i = Number(e.replace("vw", "")) / 100;
      return n * i;
    }
    if (e.endsWith("vh")) {
      var i = Number(e.replace("vh", "")) / 100;
      return r * i;
    }
  }
  return e;
}, mLe = function(e, t, n, r, i, o, s) {
  return r = h0(r, e.width, t, n), i = h0(i, e.height, t, n), o = h0(o, e.width, t, n), s = h0(s, e.height, t, n), {
    maxWidth: typeof r > "u" ? void 0 : Number(r),
    maxHeight: typeof i > "u" ? void 0 : Number(i),
    minWidth: typeof o > "u" ? void 0 : Number(o),
    minHeight: typeof s > "u" ? void 0 : Number(s)
  };
}, gLe = function(e) {
  return Array.isArray(e) ? e : [e, e];
}, yLe = [
  "as",
  "ref",
  "style",
  "className",
  "grid",
  "gridGap",
  "snap",
  "bounds",
  "boundsByDirection",
  "size",
  "defaultSize",
  "minWidth",
  "minHeight",
  "maxWidth",
  "maxHeight",
  "lockAspectRatio",
  "lockAspectRatioExtraWidth",
  "lockAspectRatioExtraHeight",
  "enable",
  "handleStyles",
  "handleClasses",
  "handleWrapperStyle",
  "handleWrapperClass",
  "children",
  "onResizeStart",
  "onResize",
  "onResizeStop",
  "handleComponent",
  "scale",
  "resizeRatio",
  "snapGap"
], w3 = "__resizable_base__", vLe = (
  /** @class */
  (function(e) {
    fLe(t, e);
    function t(n) {
      var r, i, o, s, a = e.call(this, n) || this;
      return a.ratio = 1, a.resizable = null, a.parentLeft = 0, a.parentTop = 0, a.resizableLeft = 0, a.resizableRight = 0, a.resizableTop = 0, a.resizableBottom = 0, a.targetLeft = 0, a.targetTop = 0, a.delta = {
        width: 0,
        height: 0
      }, a.appendBase = function() {
        if (!a.resizable || !a.window)
          return null;
        var c = a.parentNode;
        if (!c)
          return null;
        var u = a.window.document.createElement("div");
        return u.style.width = "100%", u.style.height = "100%", u.style.position = "absolute", u.style.transform = "scale(0, 0)", u.style.left = "0", u.style.flex = "0 0 100%", u.classList ? u.classList.add(w3) : u.className += w3, c.appendChild(u), u;
      }, a.removeBase = function(c) {
        var u = a.parentNode;
        u && u.removeChild(c);
      }, a.state = {
        isResizing: !1,
        width: (i = (r = a.propsSize) === null || r === void 0 ? void 0 : r.width) !== null && i !== void 0 ? i : "auto",
        height: (s = (o = a.propsSize) === null || o === void 0 ? void 0 : o.height) !== null && s !== void 0 ? s : "auto",
        direction: "right",
        original: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        backgroundStyle: {
          height: "100%",
          width: "100%",
          backgroundColor: "rgba(0,0,0,0)",
          cursor: "auto",
          opacity: 0,
          position: "fixed",
          zIndex: 9999,
          top: "0",
          left: "0",
          bottom: "0",
          right: "0"
        },
        flexBasis: void 0
      }, a.onResizeStart = a.onResizeStart.bind(a), a.onMouseMove = a.onMouseMove.bind(a), a.onMouseUp = a.onMouseUp.bind(a), a;
    }
    return Object.defineProperty(t.prototype, "parentNode", {
      get: function() {
        return this.resizable ? this.resizable.parentNode : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "window", {
      get: function() {
        return !this.resizable || !this.resizable.ownerDocument ? null : this.resizable.ownerDocument.defaultView;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "propsSize", {
      get: function() {
        return this.props.size || this.props.defaultSize || hLe;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "size", {
      get: function() {
        var n = 0, r = 0;
        if (this.resizable && this.window) {
          var i = this.resizable.offsetWidth, o = this.resizable.offsetHeight, s = this.resizable.style.position;
          s !== "relative" && (this.resizable.style.position = "relative"), n = this.resizable.style.width !== "auto" ? this.resizable.offsetWidth : i, r = this.resizable.style.height !== "auto" ? this.resizable.offsetHeight : o, this.resizable.style.position = s;
        }
        return { width: n, height: r };
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "sizeStyle", {
      get: function() {
        var n = this, r = this.props.size, i = function(a) {
          var c;
          if (typeof n.state[a] > "u" || n.state[a] === "auto")
            return "auto";
          if (n.propsSize && n.propsSize[a] && (!((c = n.propsSize[a]) === null || c === void 0) && c.toString().endsWith("%"))) {
            if (n.state[a].toString().endsWith("%"))
              return n.state[a].toString();
            var u = n.getParentSize(), f = Number(n.state[a].toString().replace("px", "")), h = f / u[a] * 100;
            return "".concat(h, "%");
          }
          return xE(n.state[a]);
        }, o = r && typeof r.width < "u" && !this.state.isResizing ? xE(r.width) : i("width"), s = r && typeof r.height < "u" && !this.state.isResizing ? xE(r.height) : i("height");
        return { width: o, height: s };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.getParentSize = function() {
      if (!this.parentNode)
        return this.window ? { width: this.window.innerWidth, height: this.window.innerHeight } : { width: 0, height: 0 };
      var n = this.appendBase();
      if (!n)
        return { width: 0, height: 0 };
      var r = !1, i = this.parentNode.style.flexWrap;
      i !== "wrap" && (r = !0, this.parentNode.style.flexWrap = "wrap"), n.style.position = "relative", n.style.minWidth = "100%", n.style.minHeight = "100%";
      var o = {
        width: n.offsetWidth,
        height: n.offsetHeight
      };
      return r && (this.parentNode.style.flexWrap = i), this.removeBase(n), o;
    }, t.prototype.bindEvents = function() {
      this.window && (this.window.addEventListener("mouseup", this.onMouseUp), this.window.addEventListener("mousemove", this.onMouseMove), this.window.addEventListener("mouseleave", this.onMouseUp), this.window.addEventListener("touchmove", this.onMouseMove, {
        capture: !0,
        passive: !1
      }), this.window.addEventListener("touchend", this.onMouseUp));
    }, t.prototype.unbindEvents = function() {
      this.window && (this.window.removeEventListener("mouseup", this.onMouseUp), this.window.removeEventListener("mousemove", this.onMouseMove), this.window.removeEventListener("mouseleave", this.onMouseUp), this.window.removeEventListener("touchmove", this.onMouseMove, !0), this.window.removeEventListener("touchend", this.onMouseUp));
    }, t.prototype.componentDidMount = function() {
      if (!(!this.resizable || !this.window)) {
        var n = this.window.getComputedStyle(this.resizable);
        this.setState({
          width: this.state.width || this.size.width,
          height: this.state.height || this.size.height,
          flexBasis: n.flexBasis !== "auto" ? n.flexBasis : void 0
        });
      }
    }, t.prototype.componentWillUnmount = function() {
      this.window && this.unbindEvents();
    }, t.prototype.createSizeForCssProperty = function(n, r) {
      var i = this.propsSize && this.propsSize[r];
      return this.state[r] === "auto" && this.state.original[r] === n && (typeof i > "u" || i === "auto") ? "auto" : n;
    }, t.prototype.calculateNewMaxFromBoundary = function(n, r) {
      var i = this.props.boundsByDirection, o = this.state.direction, s = i && Sf("left", o), a = i && Sf("top", o), c, u;
      if (this.props.bounds === "parent") {
        var f = this.parentNode;
        f && (c = s ? this.resizableRight - this.parentLeft : f.offsetWidth + (this.parentLeft - this.resizableLeft), u = a ? this.resizableBottom - this.parentTop : f.offsetHeight + (this.parentTop - this.resizableTop));
      } else this.props.bounds === "window" ? this.window && (c = s ? this.resizableRight : this.window.innerWidth - this.resizableLeft, u = a ? this.resizableBottom : this.window.innerHeight - this.resizableTop) : this.props.bounds && (c = s ? this.resizableRight - this.targetLeft : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft), u = a ? this.resizableBottom - this.targetTop : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop));
      return c && Number.isFinite(c) && (n = n && n < c ? n : c), u && Number.isFinite(u) && (r = r && r < u ? r : u), { maxWidth: n, maxHeight: r };
    }, t.prototype.calculateNewSizeFromDirection = function(n, r) {
      var i = this.props.scale || 1, o = gLe(this.props.resizeRatio || 1), s = o[0], a = o[1], c = this.state, u = c.direction, f = c.original, h = this.props, m = h.lockAspectRatio, g = h.lockAspectRatioExtraHeight, b = h.lockAspectRatioExtraWidth, x = f.width, w = f.height, S = g || 0, _ = b || 0;
      return Sf("right", u) && (x = f.width + (n - f.x) * s / i, m && (w = (x - _) / this.ratio + S)), Sf("left", u) && (x = f.width - (n - f.x) * s / i, m && (w = (x - _) / this.ratio + S)), Sf("bottom", u) && (w = f.height + (r - f.y) * a / i, m && (x = (w - S) * this.ratio + _)), Sf("top", u) && (w = f.height - (r - f.y) * a / i, m && (x = (w - S) * this.ratio + _)), { newWidth: x, newHeight: w };
    }, t.prototype.calculateNewSizeFromAspectRatio = function(n, r, i, o) {
      var s = this.props, a = s.lockAspectRatio, c = s.lockAspectRatioExtraHeight, u = s.lockAspectRatioExtraWidth, f = typeof o.width > "u" ? 10 : o.width, h = typeof i.width > "u" || i.width < 0 ? n : i.width, m = typeof o.height > "u" ? 10 : o.height, g = typeof i.height > "u" || i.height < 0 ? r : i.height, b = c || 0, x = u || 0;
      if (a) {
        var w = (m - b) * this.ratio + x, S = (g - b) * this.ratio + x, _ = (f - x) / this.ratio + b, M = (h - x) / this.ratio + b, N = Math.max(f, w), P = Math.min(h, S), I = Math.max(m, _), O = Math.min(g, M);
        n = d0(n, N, P), r = d0(r, I, O);
      } else
        n = d0(n, f, h), r = d0(r, m, g);
      return { newWidth: n, newHeight: r };
    }, t.prototype.setBoundingClientRect = function() {
      var n = 1 / (this.props.scale || 1);
      if (this.props.bounds === "parent") {
        var r = this.parentNode;
        if (r) {
          var i = r.getBoundingClientRect();
          this.parentLeft = i.left * n, this.parentTop = i.top * n;
        }
      }
      if (this.props.bounds && typeof this.props.bounds != "string") {
        var o = this.props.bounds.getBoundingClientRect();
        this.targetLeft = o.left * n, this.targetTop = o.top * n;
      }
      if (this.resizable) {
        var s = this.resizable.getBoundingClientRect(), a = s.left, c = s.top, u = s.right, f = s.bottom;
        this.resizableLeft = a * n, this.resizableRight = u * n, this.resizableTop = c * n, this.resizableBottom = f * n;
      }
    }, t.prototype.onResizeStart = function(n, r) {
      if (!(!this.resizable || !this.window)) {
        var i = 0, o = 0;
        if (n.nativeEvent && pLe(n.nativeEvent) ? (i = n.nativeEvent.clientX, o = n.nativeEvent.clientY) : n.nativeEvent && f0(n.nativeEvent) && (i = n.nativeEvent.touches[0].clientX, o = n.nativeEvent.touches[0].clientY), this.props.onResizeStart && this.resizable) {
          var s = this.props.onResizeStart(n, r, this.resizable);
          if (s === !1)
            return;
        }
        this.props.size && (typeof this.props.size.height < "u" && this.props.size.height !== this.state.height && this.setState({ height: this.props.size.height }), typeof this.props.size.width < "u" && this.props.size.width !== this.state.width && this.setState({ width: this.props.size.width })), this.ratio = typeof this.props.lockAspectRatio == "number" ? this.props.lockAspectRatio : this.size.width / this.size.height;
        var a, c = this.window.getComputedStyle(this.resizable);
        if (c.flexBasis !== "auto") {
          var u = this.parentNode;
          if (u) {
            var f = this.window.getComputedStyle(u).flexDirection;
            this.flexDir = f.startsWith("row") ? "row" : "column", a = c.flexBasis;
          }
        }
        this.setBoundingClientRect(), this.bindEvents();
        var h = {
          original: {
            x: i,
            y: o,
            width: this.size.width,
            height: this.size.height
          },
          isResizing: !0,
          backgroundStyle: $s($s({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(n.target).cursor || "auto" }),
          direction: r,
          flexBasis: a
        };
        this.setState(h);
      }
    }, t.prototype.onMouseMove = function(n) {
      var r = this;
      if (!(!this.state.isResizing || !this.resizable || !this.window)) {
        if (this.window.TouchEvent && f0(n))
          try {
            n.preventDefault(), n.stopPropagation();
          } catch {
          }
        var i = this.props, o = i.maxWidth, s = i.maxHeight, a = i.minWidth, c = i.minHeight, u = f0(n) ? n.touches[0].clientX : n.clientX, f = f0(n) ? n.touches[0].clientY : n.clientY, h = this.state, m = h.direction, g = h.original, b = h.width, x = h.height, w = this.getParentSize(), S = mLe(w, this.window.innerWidth, this.window.innerHeight, o, s, a, c);
        o = S.maxWidth, s = S.maxHeight, a = S.minWidth, c = S.minHeight;
        var _ = this.calculateNewSizeFromDirection(u, f), M = _.newHeight, N = _.newWidth, P = this.calculateNewMaxFromBoundary(o, s);
        this.props.snap && this.props.snap.x && (N = x3(N, this.props.snap.x, this.props.snapGap)), this.props.snap && this.props.snap.y && (M = x3(M, this.props.snap.y, this.props.snapGap));
        var I = this.calculateNewSizeFromAspectRatio(N, M, { width: P.maxWidth, height: P.maxHeight }, { width: a, height: c });
        if (N = I.newWidth, M = I.newHeight, this.props.grid) {
          var O = b3(N, this.props.grid[0], this.props.gridGap ? this.props.gridGap[0] : 0), L = b3(M, this.props.grid[1], this.props.gridGap ? this.props.gridGap[1] : 0), U = this.props.snapGap || 0, B = U === 0 || Math.abs(O - N) <= U ? O : N, G = U === 0 || Math.abs(L - M) <= U ? L : M;
          N = B, M = G;
        }
        var Y = {
          width: N - g.width,
          height: M - g.height
        };
        if (this.delta = Y, b && typeof b == "string") {
          if (b.endsWith("%")) {
            var he = N / w.width * 100;
            N = "".concat(he, "%");
          } else if (b.endsWith("vw")) {
            var ie = N / this.window.innerWidth * 100;
            N = "".concat(ie, "vw");
          } else if (b.endsWith("vh")) {
            var ne = N / this.window.innerHeight * 100;
            N = "".concat(ne, "vh");
          }
        }
        if (x && typeof x == "string") {
          if (x.endsWith("%")) {
            var he = M / w.height * 100;
            M = "".concat(he, "%");
          } else if (x.endsWith("vw")) {
            var ie = M / this.window.innerWidth * 100;
            M = "".concat(ie, "vw");
          } else if (x.endsWith("vh")) {
            var ne = M / this.window.innerHeight * 100;
            M = "".concat(ne, "vh");
          }
        }
        var H = {
          width: this.createSizeForCssProperty(N, "width"),
          height: this.createSizeForCssProperty(M, "height")
        };
        this.flexDir === "row" ? H.flexBasis = H.width : this.flexDir === "column" && (H.flexBasis = H.height);
        var Q = this.state.width !== H.width, X = this.state.height !== H.height, Se = this.state.flexBasis !== H.flexBasis, W = Q || X || Se;
        W && tl.flushSync(function() {
          r.setState(H);
        }), this.props.onResize && W && this.props.onResize(n, m, this.resizable, Y);
      }
    }, t.prototype.onMouseUp = function(n) {
      var r, i, o = this.state, s = o.isResizing, a = o.direction;
      o.original, !(!s || !this.resizable) && (this.props.onResizeStop && this.props.onResizeStop(n, a, this.resizable, this.delta), this.props.size && this.setState({ width: (r = this.props.size.width) !== null && r !== void 0 ? r : "auto", height: (i = this.props.size.height) !== null && i !== void 0 ? i : "auto" }), this.unbindEvents(), this.setState({
        isResizing: !1,
        backgroundStyle: $s($s({}, this.state.backgroundStyle), { cursor: "auto" })
      }));
    }, t.prototype.updateSize = function(n) {
      var r, i;
      this.setState({ width: (r = n.width) !== null && r !== void 0 ? r : "auto", height: (i = n.height) !== null && i !== void 0 ? i : "auto" });
    }, t.prototype.renderResizer = function() {
      var n = this, r = this.props, i = r.enable, o = r.handleStyles, s = r.handleClasses, a = r.handleWrapperStyle, c = r.handleWrapperClass, u = r.handleComponent;
      if (!i)
        return null;
      var f = Object.keys(i).map(function(h) {
        return i[h] !== !1 ? v.jsx(dLe, { direction: h, onResizeStart: n.onResizeStart, replaceStyles: o && o[h], className: s && s[h], children: u && u[h] ? u[h] : null }, h) : null;
      });
      return v.jsx("div", { className: c, style: a, children: f });
    }, t.prototype.render = function() {
      var n = this, r = Object.keys(this.props).reduce(function(s, a) {
        return yLe.indexOf(a) !== -1 || (s[a] = n.props[a]), s;
      }, {}), i = $s($s($s({ position: "relative", userSelect: this.state.isResizing ? "none" : "auto" }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: "border-box", flexShrink: 0 });
      this.state.flexBasis && (i.flexBasis = this.state.flexBasis);
      var o = this.props.as || "div";
      return v.jsxs(o, $s({ style: i, className: this.props.className }, r, {
        // `ref` is after `extendsProps` to ensure this one wins over a version
        // passed in
        ref: function(s) {
          s && (n.resizable = s);
        },
        children: [this.state.isResizing && v.jsx("div", { style: this.state.backgroundStyle }), this.props.children, this.renderResizer()]
      }));
    }, t.defaultProps = {
      as: "div",
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      enable: {
        top: !0,
        right: !0,
        bottom: !0,
        left: !0,
        topRight: !0,
        bottomRight: !0,
        bottomLeft: !0,
        topLeft: !0
      },
      style: {},
      grid: [1, 1],
      gridGap: [0, 0],
      lockAspectRatio: !1,
      lockAspectRatioExtraWidth: 0,
      lockAspectRatioExtraHeight: 0,
      scale: 1,
      resizeRatio: 1,
      snapGap: 0
    }, t;
  })(k.PureComponent)
);
var jT = function(e, t) {
  return jT = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r) r.hasOwnProperty(i) && (n[i] = r[i]);
  }, jT(e, t);
};
function bLe(e, t) {
  jT(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Rr = function() {
  return Rr = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, Rr.apply(this, arguments);
};
function xLe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
var wLe = {
  width: "auto",
  height: "auto",
  display: "inline-block",
  position: "absolute",
  top: 0,
  left: 0
}, SLe = function(e) {
  return {
    bottom: e,
    bottomLeft: e,
    bottomRight: e,
    left: e,
    right: e,
    top: e,
    topLeft: e,
    topRight: e
  };
}, kLe = (
  /** @class */
  (function(e) {
    bLe(t, e);
    function t(n) {
      var r = e.call(this, n) || this;
      return r.resizingPosition = { x: 0, y: 0 }, r.offsetFromParent = { left: 0, top: 0 }, r.resizableElement = { current: null }, r.originalPosition = { x: 0, y: 0 }, r.state = {
        resizing: !1,
        bounds: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        },
        maxWidth: n.maxWidth,
        maxHeight: n.maxHeight
      }, r.onResizeStart = r.onResizeStart.bind(r), r.onResize = r.onResize.bind(r), r.onResizeStop = r.onResizeStop.bind(r), r.onDragStart = r.onDragStart.bind(r), r.onDrag = r.onDrag.bind(r), r.onDragStop = r.onDragStop.bind(r), r.getMaxSizesFromProps = r.getMaxSizesFromProps.bind(r), r;
    }
    return t.prototype.componentDidMount = function() {
      this.updateOffsetFromParent();
      var n = this.offsetFromParent, r = n.left, i = n.top, o = this.getDraggablePosition(), s = o.x, a = o.y;
      this.draggable.setState({
        x: s - r,
        y: a - i
      }), this.forceUpdate();
    }, t.prototype.getDraggablePosition = function() {
      var n = this.draggable.state, r = n.x, i = n.y;
      return { x: r, y: i };
    }, t.prototype.getParent = function() {
      return this.resizable && this.resizable.parentNode;
    }, t.prototype.getParentSize = function() {
      return this.resizable.getParentSize();
    }, t.prototype.getMaxSizesFromProps = function() {
      var n = typeof this.props.maxWidth > "u" ? Number.MAX_SAFE_INTEGER : this.props.maxWidth, r = typeof this.props.maxHeight > "u" ? Number.MAX_SAFE_INTEGER : this.props.maxHeight;
      return { maxWidth: n, maxHeight: r };
    }, t.prototype.getSelfElement = function() {
      return this.resizable && this.resizable.resizable;
    }, t.prototype.getOffsetHeight = function(n) {
      var r = this.props.scale;
      switch (this.props.bounds) {
        case "window":
          return window.innerHeight / r;
        case "body":
          return document.body.offsetHeight / r;
        default:
          return n.offsetHeight;
      }
    }, t.prototype.getOffsetWidth = function(n) {
      var r = this.props.scale;
      switch (this.props.bounds) {
        case "window":
          return window.innerWidth / r;
        case "body":
          return document.body.offsetWidth / r;
        default:
          return n.offsetWidth;
      }
    }, t.prototype.onDragStart = function(n, r) {
      this.props.onDragStart && this.props.onDragStart(n, r);
      var i = this.getDraggablePosition();
      if (this.originalPosition = i, !!this.props.bounds) {
        var o = this.getParent(), s = this.props.scale, a;
        if (this.props.bounds === "parent")
          a = o;
        else if (this.props.bounds === "body") {
          var c = o.getBoundingClientRect(), u = c.left, f = c.top, h = document.body.getBoundingClientRect(), m = -(u - o.offsetLeft * s - h.left) / s, g = -(f - o.offsetTop * s - h.top) / s, b = (document.body.offsetWidth - this.resizable.size.width * s) / s + m, x = (document.body.offsetHeight - this.resizable.size.height * s) / s + g;
          return this.setState({ bounds: { top: g, right: b, bottom: x, left: m } });
        } else if (this.props.bounds === "window") {
          if (!this.resizable)
            return;
          var w = o.getBoundingClientRect(), S = w.left, _ = w.top, M = -(S - o.offsetLeft * s) / s, N = -(_ - o.offsetTop * s) / s, b = (window.innerWidth - this.resizable.size.width * s) / s + M, x = (window.innerHeight - this.resizable.size.height * s) / s + N;
          return this.setState({ bounds: { top: N, right: b, bottom: x, left: M } });
        } else typeof this.props.bounds == "string" ? a = document.querySelector(this.props.bounds) : this.props.bounds instanceof HTMLElement && (a = this.props.bounds);
        if (!(!(a instanceof HTMLElement) || !(o instanceof HTMLElement))) {
          var P = a.getBoundingClientRect(), I = P.left, O = P.top, L = o.getBoundingClientRect(), U = L.left, B = L.top, G = (I - U) / s, Y = O - B;
          if (this.resizable) {
            this.updateOffsetFromParent();
            var he = this.offsetFromParent;
            this.setState({
              bounds: {
                top: Y - he.top,
                right: G + (a.offsetWidth - this.resizable.size.width) - he.left / s,
                bottom: Y + (a.offsetHeight - this.resizable.size.height) - he.top,
                left: G - he.left / s
              }
            });
          }
        }
      }
    }, t.prototype.onDrag = function(n, r) {
      if (this.props.onDrag) {
        var i = this.offsetFromParent, o = i.left, s = i.top;
        if (!this.props.dragAxis || this.props.dragAxis === "both")
          return this.props.onDrag(n, Rr(Rr({}, r), { x: r.x + o, y: r.y + s }));
        if (this.props.dragAxis === "x")
          return this.props.onDrag(n, Rr(Rr({}, r), { x: r.x + o, y: this.originalPosition.y + s, deltaY: 0 }));
        if (this.props.dragAxis === "y")
          return this.props.onDrag(n, Rr(Rr({}, r), { x: this.originalPosition.x + o, y: r.y + s, deltaX: 0 }));
      }
    }, t.prototype.onDragStop = function(n, r) {
      if (this.props.onDragStop) {
        var i = this.offsetFromParent, o = i.left, s = i.top;
        if (!this.props.dragAxis || this.props.dragAxis === "both")
          return this.props.onDragStop(n, Rr(Rr({}, r), { x: r.x + o, y: r.y + s }));
        if (this.props.dragAxis === "x")
          return this.props.onDragStop(n, Rr(Rr({}, r), { x: r.x + o, y: this.originalPosition.y + s, deltaY: 0 }));
        if (this.props.dragAxis === "y")
          return this.props.onDragStop(n, Rr(Rr({}, r), { x: this.originalPosition.x + o, y: r.y + s, deltaX: 0 }));
      }
    }, t.prototype.onResizeStart = function(n, r, i) {
      n.stopPropagation(), this.setState({
        resizing: !0
      });
      var o = this.props.scale, s = this.offsetFromParent, a = this.getDraggablePosition();
      if (this.resizingPosition = { x: a.x + s.left, y: a.y + s.top }, this.originalPosition = a, this.props.bounds) {
        var c = this.getParent(), u = void 0;
        this.props.bounds === "parent" ? u = c : this.props.bounds === "body" ? u = document.body : this.props.bounds === "window" ? u = window : typeof this.props.bounds == "string" ? u = document.querySelector(this.props.bounds) : this.props.bounds instanceof HTMLElement && (u = this.props.bounds);
        var f = this.getSelfElement();
        if (f instanceof Element && (u instanceof HTMLElement || u === window) && c instanceof HTMLElement) {
          var h = this.getMaxSizesFromProps(), m = h.maxWidth, g = h.maxHeight, b = this.getParentSize();
          if (m && typeof m == "string")
            if (m.endsWith("%")) {
              var x = Number(m.replace("%", "")) / 100;
              m = b.width * x;
            } else m.endsWith("px") && (m = Number(m.replace("px", "")));
          if (g && typeof g == "string")
            if (g.endsWith("%")) {
              var x = Number(g.replace("%", "")) / 100;
              g = b.height * x;
            } else g.endsWith("px") && (g = Number(g.replace("px", "")));
          var w = f.getBoundingClientRect(), S = w.left, _ = w.top, M = this.props.bounds === "window" ? { left: 0, top: 0 } : u.getBoundingClientRect(), N = M.left, P = M.top, I = this.getOffsetWidth(u), O = this.getOffsetHeight(u), L = r.toLowerCase().endsWith("left"), U = r.toLowerCase().endsWith("right"), B = r.startsWith("top"), G = r.startsWith("bottom");
          if ((L || B) && this.resizable) {
            var Y = (S - N) / o + this.resizable.size.width;
            this.setState({ maxWidth: Y > Number(m) ? m : Y });
          }
          if (U || this.props.lockAspectRatio && !L && !B) {
            var Y = I + (N - S) / o;
            this.setState({ maxWidth: Y > Number(m) ? m : Y });
          }
          if ((B || L) && this.resizable) {
            var Y = (_ - P) / o + this.resizable.size.height;
            this.setState({
              maxHeight: Y > Number(g) ? g : Y
            });
          }
          if (G || this.props.lockAspectRatio && !B && !L) {
            var Y = O + (P - _) / o;
            this.setState({
              maxHeight: Y > Number(g) ? g : Y
            });
          }
        }
      } else
        this.setState({
          maxWidth: this.props.maxWidth,
          maxHeight: this.props.maxHeight
        });
      this.props.onResizeStart && this.props.onResizeStart(n, r, i);
    }, t.prototype.onResize = function(n, r, i, o) {
      var s = this, a = { x: this.originalPosition.x, y: this.originalPosition.y }, c = -o.width, u = -o.height, f = ["top", "left", "topLeft", "bottomLeft", "topRight"];
      f.includes(r) && (r === "bottomLeft" ? a.x += c : (r === "topRight" || (a.x += c), a.y += u));
      var h = this.draggable.state;
      (a.x !== h.x || a.y !== h.y) && tl.flushSync(function() {
        s.draggable.setState(a);
      }), this.updateOffsetFromParent();
      var m = this.offsetFromParent, g = this.getDraggablePosition().x + m.left, b = this.getDraggablePosition().y + m.top;
      this.resizingPosition = { x: g, y: b }, this.props.onResize && this.props.onResize(n, r, i, o, {
        x: g,
        y: b
      });
    }, t.prototype.onResizeStop = function(n, r, i, o) {
      this.setState({
        resizing: !1
      });
      var s = this.getMaxSizesFromProps(), a = s.maxWidth, c = s.maxHeight;
      this.setState({ maxWidth: a, maxHeight: c }), this.props.onResizeStop && this.props.onResizeStop(n, r, i, o, this.resizingPosition);
    }, t.prototype.updateSize = function(n) {
      this.resizable && this.resizable.updateSize({ width: n.width, height: n.height });
    }, t.prototype.updatePosition = function(n) {
      this.draggable.setState(n);
    }, t.prototype.updateOffsetFromParent = function() {
      var n = this.props.scale, r = this.getParent(), i = this.getSelfElement();
      if (!r || i === null)
        return {
          top: 0,
          left: 0
        };
      var o = r.getBoundingClientRect(), s = o.left, a = o.top, c = i.getBoundingClientRect(), u = this.getDraggablePosition(), f = r.scrollLeft, h = r.scrollTop;
      this.offsetFromParent = {
        left: c.left - s + f - u.x * n,
        top: c.top - a + h - u.y * n
      };
    }, t.prototype.render = function() {
      var n = this, r = this.props, i = r.disableDragging, o = r.style, s = r.dragHandleClassName, a = r.position, c = r.onMouseDown, u = r.onMouseUp, f = r.dragAxis, h = r.dragGrid, m = r.bounds, g = r.enableUserSelectHack, b = r.cancel, x = r.children;
      r.onResizeStart, r.onResize, r.onResizeStop, r.onDragStart, r.onDrag, r.onDragStop;
      var w = r.resizeHandleStyles, S = r.resizeHandleClasses, _ = r.resizeHandleComponent, M = r.enableResizing, N = r.resizeGrid, P = r.resizeHandleWrapperClass, I = r.resizeHandleWrapperStyle, O = r.scale, L = r.allowAnyClick, U = r.dragPositionOffset, B = xLe(r, ["disableDragging", "style", "dragHandleClassName", "position", "onMouseDown", "onMouseUp", "dragAxis", "dragGrid", "bounds", "enableUserSelectHack", "cancel", "children", "onResizeStart", "onResize", "onResizeStop", "onDragStart", "onDrag", "onDragStop", "resizeHandleStyles", "resizeHandleClasses", "resizeHandleComponent", "enableResizing", "resizeGrid", "resizeHandleWrapperClass", "resizeHandleWrapperStyle", "scale", "allowAnyClick", "dragPositionOffset"]), G = this.props.default ? Rr({}, this.props.default) : void 0;
      delete B.default;
      var Y = i || s ? { cursor: "auto" } : { cursor: "move" }, he = Rr(Rr(Rr({}, wLe), Y), o), ie = this.offsetFromParent, ne = ie.left, H = ie.top, Q;
      a && (Q = {
        x: a.x - ne,
        y: a.y - H
      });
      var X = this.state.resizing ? void 0 : Q, Se = this.state.resizing ? "both" : f;
      return k.createElement(
        cLe,
        {
          ref: function(W) {
            W && (n.draggable = W);
          },
          handle: s ? ".".concat(s) : void 0,
          defaultPosition: G,
          onMouseDown: c,
          // @ts-expect-error
          onMouseUp: u,
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop,
          axis: Se,
          disabled: i,
          grid: h,
          bounds: m ? this.state.bounds : void 0,
          position: X,
          enableUserSelectHack: g,
          cancel: b,
          scale: O,
          allowAnyClick: L,
          nodeRef: this.resizableElement,
          positionOffset: U
        },
        k.createElement(vLe, Rr({}, B, { ref: function(W) {
          W && (n.resizable = W, n.resizableElement.current = W.resizable);
        }, defaultSize: G, size: this.props.size, enable: typeof M == "boolean" ? SLe(M) : M, onResizeStart: this.onResizeStart, onResize: this.onResize, onResizeStop: this.onResizeStop, style: he, minWidth: this.props.minWidth, minHeight: this.props.minHeight, maxWidth: this.state.resizing ? this.state.maxWidth : this.props.maxWidth, maxHeight: this.state.resizing ? this.state.maxHeight : this.props.maxHeight, grid: N, handleWrapperClass: P, handleWrapperStyle: I, lockAspectRatio: this.props.lockAspectRatio, lockAspectRatioExtraWidth: this.props.lockAspectRatioExtraWidth, lockAspectRatioExtraHeight: this.props.lockAspectRatioExtraHeight, handleStyles: w, handleClasses: S, handleComponent: _, scale: this.props.scale }), x)
      );
    }, t.defaultProps = {
      maxWidth: Number.MAX_SAFE_INTEGER,
      maxHeight: Number.MAX_SAFE_INTEGER,
      scale: 1,
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      onDragStart: function() {
      },
      onDrag: function() {
      },
      onDragStop: function() {
      }
    }, t;
  })(k.PureComponent)
);
function CLe() {
  return `temp-${JU()}`;
}
const ELe = () => {
  P3();
  const [e, t] = k.useState(!1), [n, r] = k.useState(!1), {
    chatbotStore: { chatbotReady: i, ChatbotConfig: o, ChatbotThreadConfig: s, isLoadingThread: a },
    chatbotStore: c,
    chatbotThreadStore: { threadMentions: u }
  } = ra();
  if (!c.currentThreadId.value) {
    const f = CLe();
    c.currentThreadId.value = f;
  }
  return k.useEffect(() => {
    o();
  }, []), k.useEffect(() => {
    let f = !1;
    return e && i.value && !n && (a.value = !0, s().then(() => {
      f || r(!0);
    }).catch((h) => {
      f || console.error("Failed to configure thread:", h);
    }).finally(() => {
      f || (a.value = !1);
    })), () => {
      f = !0;
    };
  }, [e, i.value, n, s]), i.value ? /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
    /* @__PURE__ */ v.jsx(
      kLe,
      {
        default: {
          x: window.innerWidth - 850,
          y: 120,
          width: 800,
          height: window.innerHeight - 150
        },
        minWidth: 500,
        minHeight: 400,
        maxWidth: window.innerWidth - 100,
        maxHeight: window.innerHeight - 100,
        bounds: "window",
        dragHandleClassName: "chatbot-drag-handle",
        className: "z-50",
        style: {
          position: "fixed",
          opacity: e ? 1 : 0,
          visibility: e ? "visible" : "hidden",
          pointerEvents: e ? "auto" : "none"
        },
        children: /* @__PURE__ */ v.jsx("div", { className: "w-full h-full rounded-2xl shadow-xl border backdrop-blur-md flex flex-col bg-background overflow-hidden z-[1000]", children: /* @__PURE__ */ v.jsx(
          Qze,
          {
            onClose: () => {
              t(!1), u.value = {};
            },
            threadId: c.currentThreadId.value || ""
          }
        ) })
      }
    ),
    !e && /* @__PURE__ */ v.jsx(
      "button",
      {
        onClick: () => t(!0),
        className: "fixed bottom-4 right-4 z-50 cursor-pointer p-3 rounded-full border-2 shadow-sm bg-background hover:bg-core-navy-60 hover:shadow-2xl transition-all",
        children: /* @__PURE__ */ v.jsx(LT, { className: "h-6 w-6" })
      }
    )
  ] }) : null;
}, _Le = k.memo(ELe);
let za = null;
const TLe = {
  init(e) {
    if (!e.apiHost) {
      console.error("ChatbotEmbed: apiHost is required");
      return;
    }
    const t = e.containerId || "chatbot-root";
    let n = document.getElementById(t);
    return n || (n = document.createElement("div"), n.id = t, document.body.appendChild(n)), window.__CHATBOT_CONFIG__ = e, sle(e.apiHost), za || (za = PK.createRoot(n)), za.render(
      Ne.createElement(
        Ne.StrictMode,
        null,
        Ne.createElement(_Le)
      )
    ), {
      destroy: () => {
        za && (za.unmount(), za = null), n && n.parentNode && n.parentNode.removeChild(n);
      }
    };
  },
  destroy() {
    za && (za.unmount(), za = null);
  }
};
typeof window < "u" && (window.ChatbotEmbed = TLe);
export {
  i9 as C,
  uMe as J,
  $T as L,
  Ne as R,
  o9 as a,
  Yle as b,
  Xle as c,
  s9 as d,
  NLe as e,
  pc as f,
  RLe as g,
  Pc as h,
  _K as i,
  v as j,
  iG as k,
  HPe as l,
  at as m,
  TLe as n,
  k as r
};
