function bZ(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in e)) {
          const o = Object.getOwnPropertyDescriptor(r, i);
          o && Object.defineProperty(e, i, o.get ? o : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var xZ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Bc(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function wZ(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      var i = !1;
      try {
        i = this instanceof r;
      } catch {
      }
      return i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var xk = { exports: {} }, Mt = {};
var EP;
function SZ() {
  if (EP) return Mt;
  EP = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), i = /* @__PURE__ */ Symbol.for("react.profiler"), o = /* @__PURE__ */ Symbol.for("react.consumer"), s = /* @__PURE__ */ Symbol.for("react.context"), a = /* @__PURE__ */ Symbol.for("react.forward_ref"), c = /* @__PURE__ */ Symbol.for("react.suspense"), u = /* @__PURE__ */ Symbol.for("react.memo"), f = /* @__PURE__ */ Symbol.for("react.lazy"), h = /* @__PURE__ */ Symbol.for("react.activity"), m = Symbol.iterator;
  function g(Z) {
    return Z === null || typeof Z != "object" ? null : (Z = m && Z[m] || Z["@@iterator"], typeof Z == "function" ? Z : null);
  }
  var b = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, x = Object.assign, w = {};
  function S(Z, pe, F) {
    this.props = Z, this.context = pe, this.refs = w, this.updater = F || b;
  }
  S.prototype.isReactComponent = {}, S.prototype.setState = function(Z, pe) {
    if (typeof Z != "object" && typeof Z != "function" && Z != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, Z, pe, "setState");
  }, S.prototype.forceUpdate = function(Z) {
    this.updater.enqueueForceUpdate(this, Z, "forceUpdate");
  };
  function _() {
  }
  _.prototype = S.prototype;
  function M(Z, pe, F) {
    this.props = Z, this.context = pe, this.refs = w, this.updater = F || b;
  }
  var N = M.prototype = new _();
  N.constructor = M, x(N, S.prototype), N.isPureReactComponent = !0;
  var D = Array.isArray;
  function j() {
  }
  var O = { H: null, A: null, T: null, S: null }, L = Object.prototype.hasOwnProperty;
  function U(Z, pe, F) {
    var ee = F.ref;
    return {
      $$typeof: e,
      type: Z,
      key: pe,
      ref: ee !== void 0 ? ee : null,
      props: F
    };
  }
  function B(Z, pe) {
    return U(Z.type, pe, Z.props);
  }
  function G(Z) {
    return typeof Z == "object" && Z !== null && Z.$$typeof === e;
  }
  function Y(Z) {
    var pe = { "=": "=0", ":": "=2" };
    return "$" + Z.replace(/[=:]/g, function(F) {
      return pe[F];
    });
  }
  var he = /\/+/g;
  function ie(Z, pe) {
    return typeof Z == "object" && Z !== null && Z.key != null ? Y("" + Z.key) : pe.toString(36);
  }
  function ne(Z) {
    switch (Z.status) {
      case "fulfilled":
        return Z.value;
      case "rejected":
        throw Z.reason;
      default:
        switch (typeof Z.status == "string" ? Z.then(j, j) : (Z.status = "pending", Z.then(
          function(pe) {
            Z.status === "pending" && (Z.status = "fulfilled", Z.value = pe);
          },
          function(pe) {
            Z.status === "pending" && (Z.status = "rejected", Z.reason = pe);
          }
        )), Z.status) {
          case "fulfilled":
            return Z.value;
          case "rejected":
            throw Z.reason;
        }
    }
    throw Z;
  }
  function H(Z, pe, F, ee, ge) {
    var re = typeof Z;
    (re === "undefined" || re === "boolean") && (Z = null);
    var J = !1;
    if (Z === null) J = !0;
    else
      switch (re) {
        case "bigint":
        case "string":
        case "number":
          J = !0;
          break;
        case "object":
          switch (Z.$$typeof) {
            case e:
            case t:
              J = !0;
              break;
            case f:
              return J = Z._init, H(
                J(Z._payload),
                pe,
                F,
                ee,
                ge
              );
          }
      }
    if (J)
      return ge = ge(Z), J = ee === "" ? "." + ie(Z, 0) : ee, D(ge) ? (F = "", J != null && (F = J.replace(he, "$&/") + "/"), H(ge, pe, F, "", function(Ae) {
        return Ae;
      })) : ge != null && (G(ge) && (ge = B(
        ge,
        F + (ge.key == null || Z && Z.key === ge.key ? "" : ("" + ge.key).replace(
          he,
          "$&/"
        ) + "/") + J
      )), pe.push(ge)), 1;
    J = 0;
    var xe = ee === "" ? "." : ee + ":";
    if (D(Z))
      for (var be = 0; be < Z.length; be++)
        ee = Z[be], re = xe + ie(ee, be), J += H(
          ee,
          pe,
          F,
          re,
          ge
        );
    else if (be = g(Z), typeof be == "function")
      for (Z = be.call(Z), be = 0; !(ee = Z.next()).done; )
        ee = ee.value, re = xe + ie(ee, be++), J += H(
          ee,
          pe,
          F,
          re,
          ge
        );
    else if (re === "object") {
      if (typeof Z.then == "function")
        return H(
          ne(Z),
          pe,
          F,
          ee,
          ge
        );
      throw pe = String(Z), Error(
        "Objects are not valid as a React child (found: " + (pe === "[object Object]" ? "object with keys {" + Object.keys(Z).join(", ") + "}" : pe) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return J;
  }
  function Q(Z, pe, F) {
    if (Z == null) return Z;
    var ee = [], ge = 0;
    return H(Z, ee, "", "", function(re) {
      return pe.call(F, re, ge++);
    }), ee;
  }
  function X(Z) {
    if (Z._status === -1) {
      var pe = Z._result;
      pe = pe(), pe.then(
        function(F) {
          (Z._status === 0 || Z._status === -1) && (Z._status = 1, Z._result = F);
        },
        function(F) {
          (Z._status === 0 || Z._status === -1) && (Z._status = 2, Z._result = F);
        }
      ), Z._status === -1 && (Z._status = 0, Z._result = pe);
    }
    if (Z._status === 1) return Z._result.default;
    throw Z._result;
  }
  var Se = typeof reportError == "function" ? reportError : function(Z) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var pe = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof Z == "object" && Z !== null && typeof Z.message == "string" ? String(Z.message) : String(Z),
        error: Z
      });
      if (!window.dispatchEvent(pe)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", Z);
      return;
    }
    console.error(Z);
  }, W = {
    map: Q,
    forEach: function(Z, pe, F) {
      Q(
        Z,
        function() {
          pe.apply(this, arguments);
        },
        F
      );
    },
    count: function(Z) {
      var pe = 0;
      return Q(Z, function() {
        pe++;
      }), pe;
    },
    toArray: function(Z) {
      return Q(Z, function(pe) {
        return pe;
      }) || [];
    },
    only: function(Z) {
      if (!G(Z))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return Z;
    }
  };
  return Mt.Activity = h, Mt.Children = W, Mt.Component = S, Mt.Fragment = n, Mt.Profiler = i, Mt.PureComponent = M, Mt.StrictMode = r, Mt.Suspense = c, Mt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = O, Mt.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(Z) {
      return O.H.useMemoCache(Z);
    }
  }, Mt.cache = function(Z) {
    return function() {
      return Z.apply(null, arguments);
    };
  }, Mt.cacheSignal = function() {
    return null;
  }, Mt.cloneElement = function(Z, pe, F) {
    if (Z == null)
      throw Error(
        "The argument must be a React element, but you passed " + Z + "."
      );
    var ee = x({}, Z.props), ge = Z.key;
    if (pe != null)
      for (re in pe.key !== void 0 && (ge = "" + pe.key), pe)
        !L.call(pe, re) || re === "key" || re === "__self" || re === "__source" || re === "ref" && pe.ref === void 0 || (ee[re] = pe[re]);
    var re = arguments.length - 2;
    if (re === 1) ee.children = F;
    else if (1 < re) {
      for (var J = Array(re), xe = 0; xe < re; xe++)
        J[xe] = arguments[xe + 2];
      ee.children = J;
    }
    return U(Z.type, ge, ee);
  }, Mt.createContext = function(Z) {
    return Z = {
      $$typeof: s,
      _currentValue: Z,
      _currentValue2: Z,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, Z.Provider = Z, Z.Consumer = {
      $$typeof: o,
      _context: Z
    }, Z;
  }, Mt.createElement = function(Z, pe, F) {
    var ee, ge = {}, re = null;
    if (pe != null)
      for (ee in pe.key !== void 0 && (re = "" + pe.key), pe)
        L.call(pe, ee) && ee !== "key" && ee !== "__self" && ee !== "__source" && (ge[ee] = pe[ee]);
    var J = arguments.length - 2;
    if (J === 1) ge.children = F;
    else if (1 < J) {
      for (var xe = Array(J), be = 0; be < J; be++)
        xe[be] = arguments[be + 2];
      ge.children = xe;
    }
    if (Z && Z.defaultProps)
      for (ee in J = Z.defaultProps, J)
        ge[ee] === void 0 && (ge[ee] = J[ee]);
    return U(Z, re, ge);
  }, Mt.createRef = function() {
    return { current: null };
  }, Mt.forwardRef = function(Z) {
    return { $$typeof: a, render: Z };
  }, Mt.isValidElement = G, Mt.lazy = function(Z) {
    return {
      $$typeof: f,
      _payload: { _status: -1, _result: Z },
      _init: X
    };
  }, Mt.memo = function(Z, pe) {
    return {
      $$typeof: u,
      type: Z,
      compare: pe === void 0 ? null : pe
    };
  }, Mt.startTransition = function(Z) {
    var pe = O.T, F = {};
    O.T = F;
    try {
      var ee = Z(), ge = O.S;
      ge !== null && ge(F, ee), typeof ee == "object" && ee !== null && typeof ee.then == "function" && ee.then(j, Se);
    } catch (re) {
      Se(re);
    } finally {
      pe !== null && F.types !== null && (pe.types = F.types), O.T = pe;
    }
  }, Mt.unstable_useCacheRefresh = function() {
    return O.H.useCacheRefresh();
  }, Mt.use = function(Z) {
    return O.H.use(Z);
  }, Mt.useActionState = function(Z, pe, F) {
    return O.H.useActionState(Z, pe, F);
  }, Mt.useCallback = function(Z, pe) {
    return O.H.useCallback(Z, pe);
  }, Mt.useContext = function(Z) {
    return O.H.useContext(Z);
  }, Mt.useDebugValue = function() {
  }, Mt.useDeferredValue = function(Z, pe) {
    return O.H.useDeferredValue(Z, pe);
  }, Mt.useEffect = function(Z, pe) {
    return O.H.useEffect(Z, pe);
  }, Mt.useEffectEvent = function(Z) {
    return O.H.useEffectEvent(Z);
  }, Mt.useId = function() {
    return O.H.useId();
  }, Mt.useImperativeHandle = function(Z, pe, F) {
    return O.H.useImperativeHandle(Z, pe, F);
  }, Mt.useInsertionEffect = function(Z, pe) {
    return O.H.useInsertionEffect(Z, pe);
  }, Mt.useLayoutEffect = function(Z, pe) {
    return O.H.useLayoutEffect(Z, pe);
  }, Mt.useMemo = function(Z, pe) {
    return O.H.useMemo(Z, pe);
  }, Mt.useOptimistic = function(Z, pe) {
    return O.H.useOptimistic(Z, pe);
  }, Mt.useReducer = function(Z, pe, F) {
    return O.H.useReducer(Z, pe, F);
  }, Mt.useRef = function(Z) {
    return O.H.useRef(Z);
  }, Mt.useState = function(Z) {
    return O.H.useState(Z);
  }, Mt.useSyncExternalStore = function(Z, pe, F) {
    return O.H.useSyncExternalStore(
      Z,
      pe,
      F
    );
  }, Mt.useTransition = function() {
    return O.H.useTransition();
  }, Mt.version = "19.2.4", Mt;
}
var _P;
function gd() {
  return _P || (_P = 1, xk.exports = SZ()), xk.exports;
}
var C = gd();
const Ne = /* @__PURE__ */ Bc(C), nw = /* @__PURE__ */ bZ({
  __proto__: null,
  default: Ne
}, [C]);
var wk = { exports: {} }, rm = {}, Sk = { exports: {} }, kk = {};
var TP;
function kZ() {
  return TP || (TP = 1, (function(e) {
    function t(H, Q) {
      var X = H.length;
      H.push(Q);
      e: for (; 0 < X; ) {
        var Se = X - 1 >>> 1, W = H[Se];
        if (0 < i(W, Q))
          H[Se] = Q, H[X] = W, X = Se;
        else break e;
      }
    }
    function n(H) {
      return H.length === 0 ? null : H[0];
    }
    function r(H) {
      if (H.length === 0) return null;
      var Q = H[0], X = H.pop();
      if (X !== Q) {
        H[0] = X;
        e: for (var Se = 0, W = H.length, Z = W >>> 1; Se < Z; ) {
          var pe = 2 * (Se + 1) - 1, F = H[pe], ee = pe + 1, ge = H[ee];
          if (0 > i(F, X))
            ee < W && 0 > i(ge, F) ? (H[Se] = ge, H[ee] = X, Se = ee) : (H[Se] = F, H[pe] = X, Se = pe);
          else if (ee < W && 0 > i(ge, X))
            H[Se] = ge, H[ee] = X, Se = ee;
          else break e;
        }
      }
      return Q;
    }
    function i(H, Q) {
      var X = H.sortIndex - Q.sortIndex;
      return X !== 0 ? X : H.id - Q.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      e.unstable_now = function() {
        return o.now();
      };
    } else {
      var s = Date, a = s.now();
      e.unstable_now = function() {
        return s.now() - a;
      };
    }
    var c = [], u = [], f = 1, h = null, m = 3, g = !1, b = !1, x = !1, w = !1, S = typeof setTimeout == "function" ? setTimeout : null, _ = typeof clearTimeout == "function" ? clearTimeout : null, M = typeof setImmediate < "u" ? setImmediate : null;
    function N(H) {
      for (var Q = n(u); Q !== null; ) {
        if (Q.callback === null) r(u);
        else if (Q.startTime <= H)
          r(u), Q.sortIndex = Q.expirationTime, t(c, Q);
        else break;
        Q = n(u);
      }
    }
    function D(H) {
      if (x = !1, N(H), !b)
        if (n(c) !== null)
          b = !0, j || (j = !0, Y());
        else {
          var Q = n(u);
          Q !== null && ne(D, Q.startTime - H);
        }
    }
    var j = !1, O = -1, L = 5, U = -1;
    function B() {
      return w ? !0 : !(e.unstable_now() - U < L);
    }
    function G() {
      if (w = !1, j) {
        var H = e.unstable_now();
        U = H;
        var Q = !0;
        try {
          e: {
            b = !1, x && (x = !1, _(O), O = -1), g = !0;
            var X = m;
            try {
              t: {
                for (N(H), h = n(c); h !== null && !(h.expirationTime > H && B()); ) {
                  var Se = h.callback;
                  if (typeof Se == "function") {
                    h.callback = null, m = h.priorityLevel;
                    var W = Se(
                      h.expirationTime <= H
                    );
                    if (H = e.unstable_now(), typeof W == "function") {
                      h.callback = W, N(H), Q = !0;
                      break t;
                    }
                    h === n(c) && r(c), N(H);
                  } else r(c);
                  h = n(c);
                }
                if (h !== null) Q = !0;
                else {
                  var Z = n(u);
                  Z !== null && ne(
                    D,
                    Z.startTime - H
                  ), Q = !1;
                }
              }
              break e;
            } finally {
              h = null, m = X, g = !1;
            }
            Q = void 0;
          }
        } finally {
          Q ? Y() : j = !1;
        }
      }
    }
    var Y;
    if (typeof M == "function")
      Y = function() {
        M(G);
      };
    else if (typeof MessageChannel < "u") {
      var he = new MessageChannel(), ie = he.port2;
      he.port1.onmessage = G, Y = function() {
        ie.postMessage(null);
      };
    } else
      Y = function() {
        S(G, 0);
      };
    function ne(H, Q) {
      O = S(function() {
        H(e.unstable_now());
      }, Q);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(H) {
      H.callback = null;
    }, e.unstable_forceFrameRate = function(H) {
      0 > H || 125 < H ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : L = 0 < H ? Math.floor(1e3 / H) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return m;
    }, e.unstable_next = function(H) {
      switch (m) {
        case 1:
        case 2:
        case 3:
          var Q = 3;
          break;
        default:
          Q = m;
      }
      var X = m;
      m = Q;
      try {
        return H();
      } finally {
        m = X;
      }
    }, e.unstable_requestPaint = function() {
      w = !0;
    }, e.unstable_runWithPriority = function(H, Q) {
      switch (H) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          H = 3;
      }
      var X = m;
      m = H;
      try {
        return Q();
      } finally {
        m = X;
      }
    }, e.unstable_scheduleCallback = function(H, Q, X) {
      var Se = e.unstable_now();
      switch (typeof X == "object" && X !== null ? (X = X.delay, X = typeof X == "number" && 0 < X ? Se + X : Se) : X = Se, H) {
        case 1:
          var W = -1;
          break;
        case 2:
          W = 250;
          break;
        case 5:
          W = 1073741823;
          break;
        case 4:
          W = 1e4;
          break;
        default:
          W = 5e3;
      }
      return W = X + W, H = {
        id: f++,
        callback: Q,
        priorityLevel: H,
        startTime: X,
        expirationTime: W,
        sortIndex: -1
      }, X > Se ? (H.sortIndex = X, t(u, H), n(c) === null && H === n(u) && (x ? (_(O), O = -1) : x = !0, ne(D, X - Se))) : (H.sortIndex = W, t(c, H), b || g || (b = !0, j || (j = !0, Y()))), H;
    }, e.unstable_shouldYield = B, e.unstable_wrapCallback = function(H) {
      var Q = m;
      return function() {
        var X = m;
        m = Q;
        try {
          return H.apply(this, arguments);
        } finally {
          m = X;
        }
      };
    };
  })(kk)), kk;
}
var AP;
function CZ() {
  return AP || (AP = 1, Sk.exports = kZ()), Sk.exports;
}
var Ck = { exports: {} }, pi = {};
var MP;
function EZ() {
  if (MP) return pi;
  MP = 1;
  var e = gd();
  function t(c) {
    var u = "https://react.dev/errors/" + c;
    if (1 < arguments.length) {
      u += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var f = 2; f < arguments.length; f++)
        u += "&args[]=" + encodeURIComponent(arguments[f]);
    }
    return "Minified React error #" + c + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var r = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, i = /* @__PURE__ */ Symbol.for("react.portal");
  function o(c, u, f) {
    var h = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: i,
      key: h == null ? null : "" + h,
      children: c,
      containerInfo: u,
      implementation: f
    };
  }
  var s = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function a(c, u) {
    if (c === "font") return "";
    if (typeof u == "string")
      return u === "use-credentials" ? u : "";
  }
  return pi.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, pi.createPortal = function(c, u) {
    var f = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11)
      throw Error(t(299));
    return o(c, u, null, f);
  }, pi.flushSync = function(c) {
    var u = s.T, f = r.p;
    try {
      if (s.T = null, r.p = 2, c) return c();
    } finally {
      s.T = u, r.p = f, r.d.f();
    }
  }, pi.preconnect = function(c, u) {
    typeof c == "string" && (u ? (u = u.crossOrigin, u = typeof u == "string" ? u === "use-credentials" ? u : "" : void 0) : u = null, r.d.C(c, u));
  }, pi.prefetchDNS = function(c) {
    typeof c == "string" && r.d.D(c);
  }, pi.preinit = function(c, u) {
    if (typeof c == "string" && u && typeof u.as == "string") {
      var f = u.as, h = a(f, u.crossOrigin), m = typeof u.integrity == "string" ? u.integrity : void 0, g = typeof u.fetchPriority == "string" ? u.fetchPriority : void 0;
      f === "style" ? r.d.S(
        c,
        typeof u.precedence == "string" ? u.precedence : void 0,
        {
          crossOrigin: h,
          integrity: m,
          fetchPriority: g
        }
      ) : f === "script" && r.d.X(c, {
        crossOrigin: h,
        integrity: m,
        fetchPriority: g,
        nonce: typeof u.nonce == "string" ? u.nonce : void 0
      });
    }
  }, pi.preinitModule = function(c, u) {
    if (typeof c == "string")
      if (typeof u == "object" && u !== null) {
        if (u.as == null || u.as === "script") {
          var f = a(
            u.as,
            u.crossOrigin
          );
          r.d.M(c, {
            crossOrigin: f,
            integrity: typeof u.integrity == "string" ? u.integrity : void 0,
            nonce: typeof u.nonce == "string" ? u.nonce : void 0
          });
        }
      } else u == null && r.d.M(c);
  }, pi.preload = function(c, u) {
    if (typeof c == "string" && typeof u == "object" && u !== null && typeof u.as == "string") {
      var f = u.as, h = a(f, u.crossOrigin);
      r.d.L(c, f, {
        crossOrigin: h,
        integrity: typeof u.integrity == "string" ? u.integrity : void 0,
        nonce: typeof u.nonce == "string" ? u.nonce : void 0,
        type: typeof u.type == "string" ? u.type : void 0,
        fetchPriority: typeof u.fetchPriority == "string" ? u.fetchPriority : void 0,
        referrerPolicy: typeof u.referrerPolicy == "string" ? u.referrerPolicy : void 0,
        imageSrcSet: typeof u.imageSrcSet == "string" ? u.imageSrcSet : void 0,
        imageSizes: typeof u.imageSizes == "string" ? u.imageSizes : void 0,
        media: typeof u.media == "string" ? u.media : void 0
      });
    }
  }, pi.preloadModule = function(c, u) {
    if (typeof c == "string")
      if (u) {
        var f = a(u.as, u.crossOrigin);
        r.d.m(c, {
          as: typeof u.as == "string" && u.as !== "script" ? u.as : void 0,
          crossOrigin: f,
          integrity: typeof u.integrity == "string" ? u.integrity : void 0
        });
      } else r.d.m(c);
  }, pi.requestFormReset = function(c) {
    r.d.r(c);
  }, pi.unstable_batchedUpdates = function(c, u) {
    return c(u);
  }, pi.useFormState = function(c, u, f) {
    return s.H.useFormState(c, u, f);
  }, pi.useFormStatus = function() {
    return s.H.useHostTransitionStatus();
  }, pi.version = "19.2.4", pi;
}
var NP;
function rw() {
  if (NP) return Ck.exports;
  NP = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Ck.exports = EZ(), Ck.exports;
}
var RP;
function _Z() {
  if (RP) return rm;
  RP = 1;
  var e = CZ(), t = gd(), n = rw();
  function r(l) {
    var d = "https://react.dev/errors/" + l;
    if (1 < arguments.length) {
      d += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var p = 2; p < arguments.length; p++)
        d += "&args[]=" + encodeURIComponent(arguments[p]);
    }
    return "Minified React error #" + l + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function i(l) {
    return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11);
  }
  function o(l) {
    var d = l, p = l;
    if (l.alternate) for (; d.return; ) d = d.return;
    else {
      l = d;
      do
        d = l, (d.flags & 4098) !== 0 && (p = d.return), l = d.return;
      while (l);
    }
    return d.tag === 3 ? p : null;
  }
  function s(l) {
    if (l.tag === 13) {
      var d = l.memoizedState;
      if (d === null && (l = l.alternate, l !== null && (d = l.memoizedState)), d !== null) return d.dehydrated;
    }
    return null;
  }
  function a(l) {
    if (l.tag === 31) {
      var d = l.memoizedState;
      if (d === null && (l = l.alternate, l !== null && (d = l.memoizedState)), d !== null) return d.dehydrated;
    }
    return null;
  }
  function c(l) {
    if (o(l) !== l)
      throw Error(r(188));
  }
  function u(l) {
    var d = l.alternate;
    if (!d) {
      if (d = o(l), d === null) throw Error(r(188));
      return d !== l ? null : l;
    }
    for (var p = l, y = d; ; ) {
      var E = p.return;
      if (E === null) break;
      var T = E.alternate;
      if (T === null) {
        if (y = E.return, y !== null) {
          p = y;
          continue;
        }
        break;
      }
      if (E.child === T.child) {
        for (T = E.child; T; ) {
          if (T === p) return c(E), l;
          if (T === y) return c(E), d;
          T = T.sibling;
        }
        throw Error(r(188));
      }
      if (p.return !== y.return) p = E, y = T;
      else {
        for (var I = !1, V = E.child; V; ) {
          if (V === p) {
            I = !0, p = E, y = T;
            break;
          }
          if (V === y) {
            I = !0, y = E, p = T;
            break;
          }
          V = V.sibling;
        }
        if (!I) {
          for (V = T.child; V; ) {
            if (V === p) {
              I = !0, p = T, y = E;
              break;
            }
            if (V === y) {
              I = !0, y = T, p = E;
              break;
            }
            V = V.sibling;
          }
          if (!I) throw Error(r(189));
        }
      }
      if (p.alternate !== y) throw Error(r(190));
    }
    if (p.tag !== 3) throw Error(r(188));
    return p.stateNode.current === p ? l : d;
  }
  function f(l) {
    var d = l.tag;
    if (d === 5 || d === 26 || d === 27 || d === 6) return l;
    for (l = l.child; l !== null; ) {
      if (d = f(l), d !== null) return d;
      l = l.sibling;
    }
    return null;
  }
  var h = Object.assign, m = /* @__PURE__ */ Symbol.for("react.element"), g = /* @__PURE__ */ Symbol.for("react.transitional.element"), b = /* @__PURE__ */ Symbol.for("react.portal"), x = /* @__PURE__ */ Symbol.for("react.fragment"), w = /* @__PURE__ */ Symbol.for("react.strict_mode"), S = /* @__PURE__ */ Symbol.for("react.profiler"), _ = /* @__PURE__ */ Symbol.for("react.consumer"), M = /* @__PURE__ */ Symbol.for("react.context"), N = /* @__PURE__ */ Symbol.for("react.forward_ref"), D = /* @__PURE__ */ Symbol.for("react.suspense"), j = /* @__PURE__ */ Symbol.for("react.suspense_list"), O = /* @__PURE__ */ Symbol.for("react.memo"), L = /* @__PURE__ */ Symbol.for("react.lazy"), U = /* @__PURE__ */ Symbol.for("react.activity"), B = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel"), G = Symbol.iterator;
  function Y(l) {
    return l === null || typeof l != "object" ? null : (l = G && l[G] || l["@@iterator"], typeof l == "function" ? l : null);
  }
  var he = /* @__PURE__ */ Symbol.for("react.client.reference");
  function ie(l) {
    if (l == null) return null;
    if (typeof l == "function")
      return l.$$typeof === he ? null : l.displayName || l.name || null;
    if (typeof l == "string") return l;
    switch (l) {
      case x:
        return "Fragment";
      case S:
        return "Profiler";
      case w:
        return "StrictMode";
      case D:
        return "Suspense";
      case j:
        return "SuspenseList";
      case U:
        return "Activity";
    }
    if (typeof l == "object")
      switch (l.$$typeof) {
        case b:
          return "Portal";
        case M:
          return l.displayName || "Context";
        case _:
          return (l._context.displayName || "Context") + ".Consumer";
        case N:
          var d = l.render;
          return l = l.displayName, l || (l = d.displayName || d.name || "", l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"), l;
        case O:
          return d = l.displayName || null, d !== null ? d : ie(l.type) || "Memo";
        case L:
          d = l._payload, l = l._init;
          try {
            return ie(l(d));
          } catch {
          }
      }
    return null;
  }
  var ne = Array.isArray, H = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Q = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, X = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Se = [], W = -1;
  function Z(l) {
    return { current: l };
  }
  function pe(l) {
    0 > W || (l.current = Se[W], Se[W] = null, W--);
  }
  function F(l, d) {
    W++, Se[W] = l.current, l.current = d;
  }
  var ee = Z(null), ge = Z(null), re = Z(null), J = Z(null);
  function xe(l, d) {
    switch (F(re, d), F(ge, l), F(ee, null), d.nodeType) {
      case 9:
      case 11:
        l = (l = d.documentElement) && (l = l.namespaceURI) ? KO(l) : 0;
        break;
      default:
        if (l = d.tagName, d = d.namespaceURI)
          d = KO(d), l = ZO(d, l);
        else
          switch (l) {
            case "svg":
              l = 1;
              break;
            case "math":
              l = 2;
              break;
            default:
              l = 0;
          }
    }
    pe(ee), F(ee, l);
  }
  function be() {
    pe(ee), pe(ge), pe(re);
  }
  function Ae(l) {
    l.memoizedState !== null && F(J, l);
    var d = ee.current, p = ZO(d, l.type);
    d !== p && (F(ge, l), F(ee, p));
  }
  function nt(l) {
    ge.current === l && (pe(ee), pe(ge)), J.current === l && (pe(J), Qp._currentValue = X);
  }
  var Ge, rt;
  function Tt(l) {
    if (Ge === void 0)
      try {
        throw Error();
      } catch (p) {
        var d = p.stack.trim().match(/\n( *(at )?)/);
        Ge = d && d[1] || "", rt = -1 < p.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < p.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + Ge + l + rt;
  }
  var vn = !1;
  function kt(l, d) {
    if (!l || vn) return "";
    vn = !0;
    var p = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var y = {
        DetermineComponentFrameRoot: function() {
          try {
            if (d) {
              var je = function() {
                throw Error();
              };
              if (Object.defineProperty(je.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(je, []);
                } catch (Me) {
                  var Te = Me;
                }
                Reflect.construct(l, [], je);
              } else {
                try {
                  je.call();
                } catch (Me) {
                  Te = Me;
                }
                l.call(je.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (Me) {
                Te = Me;
              }
              (je = l()) && typeof je.catch == "function" && je.catch(function() {
              });
            }
          } catch (Me) {
            if (Me && Te && typeof Me.stack == "string")
              return [Me.stack, Te.stack];
          }
          return [null, null];
        }
      };
      y.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var E = Object.getOwnPropertyDescriptor(
        y.DetermineComponentFrameRoot,
        "name"
      );
      E && E.configurable && Object.defineProperty(
        y.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var T = y.DetermineComponentFrameRoot(), I = T[0], V = T[1];
      if (I && V) {
        var te = I.split(`
`), Ee = V.split(`
`);
        for (E = y = 0; y < te.length && !te[y].includes("DetermineComponentFrameRoot"); )
          y++;
        for (; E < Ee.length && !Ee[E].includes(
          "DetermineComponentFrameRoot"
        ); )
          E++;
        if (y === te.length || E === Ee.length)
          for (y = te.length - 1, E = Ee.length - 1; 1 <= y && 0 <= E && te[y] !== Ee[E]; )
            E--;
        for (; 1 <= y && 0 <= E; y--, E--)
          if (te[y] !== Ee[E]) {
            if (y !== 1 || E !== 1)
              do
                if (y--, E--, 0 > E || te[y] !== Ee[E]) {
                  var Oe = `
` + te[y].replace(" at new ", " at ");
                  return l.displayName && Oe.includes("<anonymous>") && (Oe = Oe.replace("<anonymous>", l.displayName)), Oe;
                }
              while (1 <= y && 0 <= E);
            break;
          }
      }
    } finally {
      vn = !1, Error.prepareStackTrace = p;
    }
    return (p = l ? l.displayName || l.name : "") ? Tt(p) : "";
  }
  function Wt(l, d) {
    switch (l.tag) {
      case 26:
      case 27:
      case 5:
        return Tt(l.type);
      case 16:
        return Tt("Lazy");
      case 13:
        return l.child !== d && d !== null ? Tt("Suspense Fallback") : Tt("Suspense");
      case 19:
        return Tt("SuspenseList");
      case 0:
      case 15:
        return kt(l.type, !1);
      case 11:
        return kt(l.type.render, !1);
      case 1:
        return kt(l.type, !0);
      case 31:
        return Tt("Activity");
      default:
        return "";
    }
  }
  function wt(l) {
    try {
      var d = "", p = null;
      do
        d += Wt(l, p), p = l, l = l.return;
      while (l);
      return d;
    } catch (y) {
      return `
Error generating stack: ` + y.message + `
` + y.stack;
    }
  }
  var Yt = Object.prototype.hasOwnProperty, Mn = e.unstable_scheduleCallback, Rt = e.unstable_cancelCallback, ln = e.unstable_shouldYield, In = e.unstable_requestPaint, Nn = e.unstable_now, gt = e.unstable_getCurrentPriorityLevel, ke = e.unstable_ImmediatePriority, De = e.unstable_UserBlockingPriority, He = e.unstable_NormalPriority, tt = e.unstable_LowPriority, xt = e.unstable_IdlePriority, Et = e.log, hn = e.unstable_setDisableYieldValue, Bt = null, on = null;
  function jn(l) {
    if (typeof Et == "function" && hn(l), on && typeof on.setStrictMode == "function")
      try {
        on.setStrictMode(Bt, l);
      } catch {
      }
  }
  var Ve = Math.clz32 ? Math.clz32 : Td, Bi = Math.log, Mr = Math.LN2;
  function Td(l) {
    return l >>>= 0, l === 0 ? 32 : 31 - (Bi(l) / Mr | 0) | 0;
  }
  var Ke = 256, dl = 262144, Xc = 4194304;
  function Jo(l) {
    var d = l & 42;
    if (d !== 0) return d;
    switch (l & -l) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return l & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return l & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return l;
    }
  }
  function Jc(l, d, p) {
    var y = l.pendingLanes;
    if (y === 0) return 0;
    var E = 0, T = l.suspendedLanes, I = l.pingedLanes;
    l = l.warmLanes;
    var V = y & 134217727;
    return V !== 0 ? (y = V & ~T, y !== 0 ? E = Jo(y) : (I &= V, I !== 0 ? E = Jo(I) : p || (p = V & ~l, p !== 0 && (E = Jo(p))))) : (V = y & ~T, V !== 0 ? E = Jo(V) : I !== 0 ? E = Jo(I) : p || (p = y & ~l, p !== 0 && (E = Jo(p)))), E === 0 ? 0 : d !== 0 && d !== E && (d & T) === 0 && (T = E & -E, p = d & -d, T >= p || T === 32 && (p & 4194048) !== 0) ? d : E;
  }
  function ua(l, d) {
    return (l.pendingLanes & ~(l.suspendedLanes & ~l.pingedLanes) & d) === 0;
  }
  function T1(l, d) {
    switch (l) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return d + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return d + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Sy() {
    var l = Xc;
    return Xc <<= 1, (Xc & 62914560) === 0 && (Xc = 4194304), l;
  }
  function Ss(l) {
    for (var d = [], p = 0; 31 > p; p++) d.push(l);
    return d;
  }
  function wo(l, d) {
    l.pendingLanes |= d, d !== 268435456 && (l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0);
  }
  function rp(l, d, p, y, E, T) {
    var I = l.pendingLanes;
    l.pendingLanes = p, l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0, l.expiredLanes &= p, l.entangledLanes &= p, l.errorRecoveryDisabledLanes &= p, l.shellSuspendCounter = 0;
    var V = l.entanglements, te = l.expirationTimes, Ee = l.hiddenUpdates;
    for (p = I & ~p; 0 < p; ) {
      var Oe = 31 - Ve(p), je = 1 << Oe;
      V[Oe] = 0, te[Oe] = -1;
      var Te = Ee[Oe];
      if (Te !== null)
        for (Ee[Oe] = null, Oe = 0; Oe < Te.length; Oe++) {
          var Me = Te[Oe];
          Me !== null && (Me.lane &= -536870913);
        }
      p &= ~je;
    }
    y !== 0 && Qc(l, y, 0), T !== 0 && E === 0 && l.tag !== 0 && (l.suspendedLanes |= T & ~(I & ~d));
  }
  function Qc(l, d, p) {
    l.pendingLanes |= d, l.suspendedLanes &= ~d;
    var y = 31 - Ve(d);
    l.entangledLanes |= d, l.entanglements[y] = l.entanglements[y] | 1073741824 | p & 261930;
  }
  function Cn(l, d) {
    var p = l.entangledLanes |= d;
    for (l = l.entanglements; p; ) {
      var y = 31 - Ve(p), E = 1 << y;
      E & d | l[y] & d && (l[y] |= d), p &= ~E;
    }
  }
  function ar(l, d) {
    var p = d & -d;
    return p = (p & 42) !== 0 ? 1 : ip(p), (p & (l.suspendedLanes | d)) !== 0 ? 0 : p;
  }
  function ip(l) {
    switch (l) {
      case 2:
        l = 1;
        break;
      case 8:
        l = 4;
        break;
      case 32:
        l = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        l = 128;
        break;
      case 268435456:
        l = 134217728;
        break;
      default:
        l = 0;
    }
    return l;
  }
  function fl(l) {
    return l &= -l, 2 < l ? 8 < l ? (l & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function eu() {
    var l = Q.p;
    return l !== 0 ? l : (l = window.event, l === void 0 ? 32 : vP(l.type));
  }
  function tu(l, d) {
    var p = Q.p;
    try {
      return Q.p = l, d();
    } finally {
      Q.p = p;
    }
  }
  var ks = Math.random().toString(36).slice(2), Rn = "__reactFiber$" + ks, lr = "__reactProps$" + ks, Ci = "__reactContainer$" + ks, hl = "__reactEvents$" + ks, A1 = "__reactListeners$" + ks, Cs = "__reactHandles$" + ks, op = "__reactResources$" + ks, eo = "__reactMarker$" + ks;
  function Ad(l) {
    delete l[Rn], delete l[lr], delete l[hl], delete l[A1], delete l[Cs];
  }
  function Es(l) {
    var d = l[Rn];
    if (d) return d;
    for (var p = l.parentNode; p; ) {
      if (d = p[Ci] || p[Rn]) {
        if (p = d.alternate, d.child !== null || p !== null && p.child !== null)
          for (l = nP(l); l !== null; ) {
            if (p = l[Rn]) return p;
            l = nP(l);
          }
        return d;
      }
      l = p, p = l.parentNode;
    }
    return null;
  }
  function bn(l) {
    if (l = l[Rn] || l[Ci]) {
      var d = l.tag;
      if (d === 5 || d === 6 || d === 13 || d === 31 || d === 26 || d === 27 || d === 3)
        return l;
    }
    return null;
  }
  function to(l) {
    var d = l.tag;
    if (d === 5 || d === 26 || d === 27 || d === 6) return l.stateNode;
    throw Error(r(33));
  }
  function ui(l) {
    var d = l[op];
    return d || (d = l[op] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), d;
  }
  function cr(l) {
    l[eo] = !0;
  }
  var da = /* @__PURE__ */ new Set(), nu = {};
  function Qo(l, d) {
    _s(l, d), _s(l + "Capture", d);
  }
  function _s(l, d) {
    for (nu[l] = d, l = 0; l < d.length; l++)
      da.add(d[l]);
  }
  var fa = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), sp = {}, ru = {};
  function ky(l) {
    return Yt.call(ru, l) ? !0 : Yt.call(sp, l) ? !1 : fa.test(l) ? ru[l] = !0 : (sp[l] = !0, !1);
  }
  function It(l, d, p) {
    if (ky(d))
      if (p === null) l.removeAttribute(d);
      else {
        switch (typeof p) {
          case "undefined":
          case "function":
          case "symbol":
            l.removeAttribute(d);
            return;
          case "boolean":
            var y = d.toLowerCase().slice(0, 5);
            if (y !== "data-" && y !== "aria-") {
              l.removeAttribute(d);
              return;
            }
        }
        l.setAttribute(d, "" + p);
      }
  }
  function iu(l, d, p) {
    if (p === null) l.removeAttribute(d);
    else {
      switch (typeof p) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          l.removeAttribute(d);
          return;
      }
      l.setAttribute(d, "" + p);
    }
  }
  function So(l, d, p, y) {
    if (y === null) l.removeAttribute(p);
    else {
      switch (typeof y) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          l.removeAttribute(p);
          return;
      }
      l.setAttributeNS(d, p, "" + y);
    }
  }
  function Zr(l) {
    switch (typeof l) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return l;
      case "object":
        return l;
      default:
        return "";
    }
  }
  function pl(l) {
    var d = l.type;
    return (l = l.nodeName) && l.toLowerCase() === "input" && (d === "checkbox" || d === "radio");
  }
  function Cy(l, d, p) {
    var y = Object.getOwnPropertyDescriptor(
      l.constructor.prototype,
      d
    );
    if (!l.hasOwnProperty(d) && typeof y < "u" && typeof y.get == "function" && typeof y.set == "function") {
      var E = y.get, T = y.set;
      return Object.defineProperty(l, d, {
        configurable: !0,
        get: function() {
          return E.call(this);
        },
        set: function(I) {
          p = "" + I, T.call(this, I);
        }
      }), Object.defineProperty(l, d, {
        enumerable: y.enumerable
      }), {
        getValue: function() {
          return p;
        },
        setValue: function(I) {
          p = "" + I;
        },
        stopTracking: function() {
          l._valueTracker = null, delete l[d];
        }
      };
    }
  }
  function Md(l) {
    if (!l._valueTracker) {
      var d = pl(l) ? "checked" : "value";
      l._valueTracker = Cy(
        l,
        d,
        "" + l[d]
      );
    }
  }
  function ap(l) {
    if (!l) return !1;
    var d = l._valueTracker;
    if (!d) return !0;
    var p = d.getValue(), y = "";
    return l && (y = pl(l) ? l.checked ? "true" : "false" : l.value), l = y, l !== p ? (d.setValue(l), !0) : !1;
  }
  function cn(l) {
    if (l = l || (typeof document < "u" ? document : void 0), typeof l > "u") return null;
    try {
      return l.activeElement || l.body;
    } catch {
      return l.body;
    }
  }
  var ou = /[\n"\\]/g;
  function zr(l) {
    return l.replace(
      ou,
      function(d) {
        return "\\" + d.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Ts(l, d, p, y, E, T, I, V) {
    l.name = "", I != null && typeof I != "function" && typeof I != "symbol" && typeof I != "boolean" ? l.type = I : l.removeAttribute("type"), d != null ? I === "number" ? (d === 0 && l.value === "" || l.value != d) && (l.value = "" + Zr(d)) : l.value !== "" + Zr(d) && (l.value = "" + Zr(d)) : I !== "submit" && I !== "reset" || l.removeAttribute("value"), d != null ? su(l, I, Zr(d)) : p != null ? su(l, I, Zr(p)) : y != null && l.removeAttribute("value"), E == null && T != null && (l.defaultChecked = !!T), E != null && (l.checked = E && typeof E != "function" && typeof E != "symbol"), V != null && typeof V != "function" && typeof V != "symbol" && typeof V != "boolean" ? l.name = "" + Zr(V) : l.removeAttribute("name");
  }
  function Nd(l, d, p, y, E, T, I, V) {
    if (T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" && (l.type = T), d != null || p != null) {
      if (!(T !== "submit" && T !== "reset" || d != null)) {
        Md(l);
        return;
      }
      p = p != null ? "" + Zr(p) : "", d = d != null ? "" + Zr(d) : p, V || d === l.value || (l.value = d), l.defaultValue = d;
    }
    y = y ?? E, y = typeof y != "function" && typeof y != "symbol" && !!y, l.checked = V ? l.checked : !!y, l.defaultChecked = !!y, I != null && typeof I != "function" && typeof I != "symbol" && typeof I != "boolean" && (l.name = I), Md(l);
  }
  function su(l, d, p) {
    d === "number" && cn(l.ownerDocument) === l || l.defaultValue === "" + p || (l.defaultValue = "" + p);
  }
  function es(l, d, p, y) {
    if (l = l.options, d) {
      d = {};
      for (var E = 0; E < p.length; E++)
        d["$" + p[E]] = !0;
      for (p = 0; p < l.length; p++)
        E = d.hasOwnProperty("$" + l[p].value), l[p].selected !== E && (l[p].selected = E), E && y && (l[p].defaultSelected = !0);
    } else {
      for (p = "" + Zr(p), d = null, E = 0; E < l.length; E++) {
        if (l[E].value === p) {
          l[E].selected = !0, y && (l[E].defaultSelected = !0);
          return;
        }
        d !== null || l[E].disabled || (d = l[E]);
      }
      d !== null && (d.selected = !0);
    }
  }
  function lp(l, d, p) {
    if (d != null && (d = "" + Zr(d), d !== l.value && (l.value = d), p == null)) {
      l.defaultValue !== d && (l.defaultValue = d);
      return;
    }
    l.defaultValue = p != null ? "" + Zr(p) : "";
  }
  function au(l, d, p, y) {
    if (d == null) {
      if (y != null) {
        if (p != null) throw Error(r(92));
        if (ne(y)) {
          if (1 < y.length) throw Error(r(93));
          y = y[0];
        }
        p = y;
      }
      p == null && (p = ""), d = p;
    }
    p = Zr(d), l.defaultValue = p, y = l.textContent, y === p && y !== "" && y !== null && (l.value = y), Md(l);
  }
  function ha(l, d) {
    if (d) {
      var p = l.firstChild;
      if (p && p === l.lastChild && p.nodeType === 3) {
        p.nodeValue = d;
        return;
      }
    }
    l.textContent = d;
  }
  var M1 = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function en(l, d, p) {
    var y = d.indexOf("--") === 0;
    p == null || typeof p == "boolean" || p === "" ? y ? l.setProperty(d, "") : d === "float" ? l.cssFloat = "" : l[d] = "" : y ? l.setProperty(d, p) : typeof p != "number" || p === 0 || M1.has(d) ? d === "float" ? l.cssFloat = p : l[d] = ("" + p).trim() : l[d] = p + "px";
  }
  function cp(l, d, p) {
    if (d != null && typeof d != "object")
      throw Error(r(62));
    if (l = l.style, p != null) {
      for (var y in p)
        !p.hasOwnProperty(y) || d != null && d.hasOwnProperty(y) || (y.indexOf("--") === 0 ? l.setProperty(y, "") : y === "float" ? l.cssFloat = "" : l[y] = "");
      for (var E in d)
        y = d[E], d.hasOwnProperty(E) && p[E] !== y && en(l, E, y);
    } else
      for (var T in d)
        d.hasOwnProperty(T) && en(l, T, d[T]);
  }
  function up(l) {
    if (l.indexOf("-") === -1) return !1;
    switch (l) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var N1 = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), Ei = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function ts(l) {
    return Ei.test("" + l) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : l;
  }
  function $i() {
  }
  var ko = null;
  function Rd(l) {
    return l = l.target || l.srcElement || window, l.correspondingUseElement && (l = l.correspondingUseElement), l.nodeType === 3 ? l.parentNode : l;
  }
  var pa = null, zn = null;
  function no(l) {
    var d = bn(l);
    if (d && (l = d.stateNode)) {
      var p = l[lr] || null;
      e: switch (l = d.stateNode, d.type) {
        case "input":
          if (Ts(
            l,
            p.value,
            p.defaultValue,
            p.defaultValue,
            p.checked,
            p.defaultChecked,
            p.type,
            p.name
          ), d = p.name, p.type === "radio" && d != null) {
            for (p = l; p.parentNode; ) p = p.parentNode;
            for (p = p.querySelectorAll(
              'input[name="' + zr(
                "" + d
              ) + '"][type="radio"]'
            ), d = 0; d < p.length; d++) {
              var y = p[d];
              if (y !== l && y.form === l.form) {
                var E = y[lr] || null;
                if (!E) throw Error(r(90));
                Ts(
                  y,
                  E.value,
                  E.defaultValue,
                  E.defaultValue,
                  E.checked,
                  E.defaultChecked,
                  E.type,
                  E.name
                );
              }
            }
            for (d = 0; d < p.length; d++)
              y = p[d], y.form === l.form && ap(y);
          }
          break e;
        case "textarea":
          lp(l, p.value, p.defaultValue);
          break e;
        case "select":
          d = p.value, d != null && es(l, !!p.multiple, d, !1);
      }
    }
  }
  var ma = !1;
  function ml(l, d, p) {
    if (ma) return l(d, p);
    ma = !0;
    try {
      var y = l(d);
      return y;
    } finally {
      if (ma = !1, (pa !== null || zn !== null) && (hv(), pa && (d = pa, l = zn, zn = pa = null, no(d), l)))
        for (d = 0; d < l.length; d++) no(l[d]);
    }
  }
  function ga(l, d) {
    var p = l.stateNode;
    if (p === null) return null;
    var y = p[lr] || null;
    if (y === null) return null;
    p = y[d];
    e: switch (d) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (y = !y.disabled) || (l = l.type, y = !(l === "button" || l === "input" || l === "select" || l === "textarea")), l = !y;
        break e;
      default:
        l = !1;
    }
    if (l) return null;
    if (p && typeof p != "function")
      throw Error(
        r(231, d, typeof p)
      );
    return p;
  }
  var Lr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), dp = !1;
  if (Lr)
    try {
      var di = {};
      Object.defineProperty(di, "passive", {
        get: function() {
          dp = !0;
        }
      }), window.addEventListener("test", di, di), window.removeEventListener("test", di, di);
    } catch {
      dp = !1;
    }
  var Co = null, Od = null, gl = null;
  function yl() {
    if (gl) return gl;
    var l, d = Od, p = d.length, y, E = "value" in Co ? Co.value : Co.textContent, T = E.length;
    for (l = 0; l < p && d[l] === E[l]; l++) ;
    var I = p - l;
    for (y = 1; y <= I && d[p - y] === E[T - y]; y++) ;
    return gl = E.slice(l, 1 < y ? 1 - y : void 0);
  }
  function vl(l) {
    var d = l.keyCode;
    return "charCode" in l ? (l = l.charCode, l === 0 && d === 13 && (l = 13)) : l = d, l === 10 && (l = 13), 32 <= l || l === 13 ? l : 0;
  }
  function lu() {
    return !0;
  }
  function Ey() {
    return !1;
  }
  function mr(l) {
    function d(p, y, E, T, I) {
      this._reactName = p, this._targetInst = E, this.type = y, this.nativeEvent = T, this.target = I, this.currentTarget = null;
      for (var V in l)
        l.hasOwnProperty(V) && (p = l[V], this[V] = p ? p(T) : T[V]);
      return this.isDefaultPrevented = (T.defaultPrevented != null ? T.defaultPrevented : T.returnValue === !1) ? lu : Ey, this.isPropagationStopped = Ey, this;
    }
    return h(d.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var p = this.nativeEvent;
        p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1), this.isDefaultPrevented = lu);
      },
      stopPropagation: function() {
        var p = this.nativeEvent;
        p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0), this.isPropagationStopped = lu);
      },
      persist: function() {
      },
      isPersistent: lu
    }), d;
  }
  var ya = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(l) {
      return l.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Pd = mr(ya), As = h({}, ya, { view: 0, detail: 0 }), Dd = mr(As), cu, fp, uu, Id = h({}, As, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: va,
    button: 0,
    buttons: 0,
    relatedTarget: function(l) {
      return l.relatedTarget === void 0 ? l.fromElement === l.srcElement ? l.toElement : l.fromElement : l.relatedTarget;
    },
    movementX: function(l) {
      return "movementX" in l ? l.movementX : (l !== uu && (uu && l.type === "mousemove" ? (cu = l.screenX - uu.screenX, fp = l.screenY - uu.screenY) : fp = cu = 0, uu = l), cu);
    },
    movementY: function(l) {
      return "movementY" in l ? l.movementY : fp;
    }
  }), jd = mr(Id), hp = h({}, Id, { dataTransfer: 0 }), _y = mr(hp), zd = h({}, As, { relatedTarget: 0 }), bl = mr(zd), Ld = h({}, ya, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Ty = mr(Ld), R1 = h({}, ya, {
    clipboardData: function(l) {
      return "clipboardData" in l ? l.clipboardData : window.clipboardData;
    }
  }), xl = mr(R1), pp = h({}, ya, { data: 0 }), Bd = mr(pp), mp = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, gp = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Br = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function du(l) {
    var d = this.nativeEvent;
    return d.getModifierState ? d.getModifierState(l) : (l = Br[l]) ? !!d[l] : !1;
  }
  function va() {
    return du;
  }
  var Ay = h({}, As, {
    key: function(l) {
      if (l.key) {
        var d = mp[l.key] || l.key;
        if (d !== "Unidentified") return d;
      }
      return l.type === "keypress" ? (l = vl(l), l === 13 ? "Enter" : String.fromCharCode(l)) : l.type === "keydown" || l.type === "keyup" ? gp[l.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: va,
    charCode: function(l) {
      return l.type === "keypress" ? vl(l) : 0;
    },
    keyCode: function(l) {
      return l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
    },
    which: function(l) {
      return l.type === "keypress" ? vl(l) : l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
    }
  }), $d = mr(Ay), My = h({}, Id, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), yp = mr(My), Ud = h({}, As, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: va
  }), vp = mr(Ud), ba = h({}, ya, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), bp = mr(ba), xp = h({}, Id, {
    deltaX: function(l) {
      return "deltaX" in l ? l.deltaX : "wheelDeltaX" in l ? -l.wheelDeltaX : 0;
    },
    deltaY: function(l) {
      return "deltaY" in l ? l.deltaY : "wheelDeltaY" in l ? -l.wheelDeltaY : "wheelDelta" in l ? -l.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Fd = mr(xp), wp = h({}, ya, {
    newState: 0,
    oldState: 0
  }), Ny = mr(wp), O1 = [9, 13, 27, 32], fu = Lr && "CompositionEvent" in window, Ms = null;
  Lr && "documentMode" in document && (Ms = document.documentMode);
  var P1 = Lr && "TextEvent" in window && !Ms, Vd = Lr && (!fu || Ms && 8 < Ms && 11 >= Ms), Hd = " ", Ry = !1;
  function Sp(l, d) {
    switch (l) {
      case "keyup":
        return O1.indexOf(d.keyCode) !== -1;
      case "keydown":
        return d.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Oy(l) {
    return l = l.detail, typeof l == "object" && "data" in l ? l.data : null;
  }
  var xa = !1;
  function Py(l, d) {
    switch (l) {
      case "compositionend":
        return Oy(d);
      case "keypress":
        return d.which !== 32 ? null : (Ry = !0, Hd);
      case "textInput":
        return l = d.data, l === Hd && Ry ? null : l;
      default:
        return null;
    }
  }
  function D1(l, d) {
    if (xa)
      return l === "compositionend" || !fu && Sp(l, d) ? (l = yl(), gl = Od = Co = null, xa = !1, l) : null;
    switch (l) {
      case "paste":
        return null;
      case "keypress":
        if (!(d.ctrlKey || d.altKey || d.metaKey) || d.ctrlKey && d.altKey) {
          if (d.char && 1 < d.char.length)
            return d.char;
          if (d.which) return String.fromCharCode(d.which);
        }
        return null;
      case "compositionend":
        return Vd && d.locale !== "ko" ? null : d.data;
      default:
        return null;
    }
  }
  var Dy = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Wd(l) {
    var d = l && l.nodeName && l.nodeName.toLowerCase();
    return d === "input" ? !!Dy[l.type] : d === "textarea";
  }
  function kp(l, d, p, y) {
    pa ? zn ? zn.push(y) : zn = [y] : pa = y, d = xv(d, "onChange"), 0 < d.length && (p = new Pd(
      "onChange",
      "change",
      null,
      p,
      y
    ), l.push({ event: p, listeners: d }));
  }
  var wl = null, hu = null;
  function I1(l) {
    FO(l, 0);
  }
  function qd(l) {
    var d = to(l);
    if (ap(d)) return l;
  }
  function pu(l, d) {
    if (l === "change") return d;
  }
  var Eo = !1;
  if (Lr) {
    var Ln;
    if (Lr) {
      var Sl = "oninput" in document;
      if (!Sl) {
        var wa = document.createElement("div");
        wa.setAttribute("oninput", "return;"), Sl = typeof wa.oninput == "function";
      }
      Ln = Sl;
    } else Ln = !1;
    Eo = Ln && (!document.documentMode || 9 < document.documentMode);
  }
  function Iy() {
    wl && (wl.detachEvent("onpropertychange", Gd), hu = wl = null);
  }
  function Gd(l) {
    if (l.propertyName === "value" && qd(hu)) {
      var d = [];
      kp(
        d,
        hu,
        l,
        Rd(l)
      ), ml(I1, d);
    }
  }
  function jy(l, d, p) {
    l === "focusin" ? (Iy(), wl = d, hu = p, wl.attachEvent("onpropertychange", Gd)) : l === "focusout" && Iy();
  }
  function Sa(l) {
    if (l === "selectionchange" || l === "keyup" || l === "keydown")
      return qd(hu);
  }
  function Cp(l, d) {
    if (l === "click") return qd(d);
  }
  function kl(l, d) {
    if (l === "input" || l === "change")
      return qd(d);
  }
  function Ns(l, d) {
    return l === d && (l !== 0 || 1 / l === 1 / d) || l !== l && d !== d;
  }
  var fi = typeof Object.is == "function" ? Object.is : Ns;
  function k(l, d) {
    if (fi(l, d)) return !0;
    if (typeof l != "object" || l === null || typeof d != "object" || d === null)
      return !1;
    var p = Object.keys(l), y = Object.keys(d);
    if (p.length !== y.length) return !1;
    for (y = 0; y < p.length; y++) {
      var E = p[y];
      if (!Yt.call(d, E) || !fi(l[E], d[E]))
        return !1;
    }
    return !0;
  }
  function A(l) {
    for (; l && l.firstChild; ) l = l.firstChild;
    return l;
  }
  function R(l, d) {
    var p = A(l);
    l = 0;
    for (var y; p; ) {
      if (p.nodeType === 3) {
        if (y = l + p.textContent.length, l <= d && y >= d)
          return { node: p, offset: d - l };
        l = y;
      }
      e: {
        for (; p; ) {
          if (p.nextSibling) {
            p = p.nextSibling;
            break e;
          }
          p = p.parentNode;
        }
        p = void 0;
      }
      p = A(p);
    }
  }
  function P(l, d) {
    return l && d ? l === d ? !0 : l && l.nodeType === 3 ? !1 : d && d.nodeType === 3 ? P(l, d.parentNode) : "contains" in l ? l.contains(d) : l.compareDocumentPosition ? !!(l.compareDocumentPosition(d) & 16) : !1 : !1;
  }
  function z(l) {
    l = l != null && l.ownerDocument != null && l.ownerDocument.defaultView != null ? l.ownerDocument.defaultView : window;
    for (var d = cn(l.document); d instanceof l.HTMLIFrameElement; ) {
      try {
        var p = typeof d.contentWindow.location.href == "string";
      } catch {
        p = !1;
      }
      if (p) l = d.contentWindow;
      else break;
      d = cn(l.document);
    }
    return d;
  }
  function $(l) {
    var d = l && l.nodeName && l.nodeName.toLowerCase();
    return d && (d === "input" && (l.type === "text" || l.type === "search" || l.type === "tel" || l.type === "url" || l.type === "password") || d === "textarea" || l.contentEditable === "true");
  }
  var q = Lr && "documentMode" in document && 11 >= document.documentMode, K = null, se = null, ye = null, ae = !1;
  function oe(l, d, p) {
    var y = p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
    ae || K == null || K !== cn(y) || (y = K, "selectionStart" in y && $(y) ? y = { start: y.selectionStart, end: y.selectionEnd } : (y = (y.ownerDocument && y.ownerDocument.defaultView || window).getSelection(), y = {
      anchorNode: y.anchorNode,
      anchorOffset: y.anchorOffset,
      focusNode: y.focusNode,
      focusOffset: y.focusOffset
    }), ye && k(ye, y) || (ye = y, y = xv(se, "onSelect"), 0 < y.length && (d = new Pd(
      "onSelect",
      "select",
      null,
      d,
      p
    ), l.push({ event: d, listeners: y }), d.target = K)));
  }
  function ue(l, d) {
    var p = {};
    return p[l.toLowerCase()] = d.toLowerCase(), p["Webkit" + l] = "webkit" + d, p["Moz" + l] = "moz" + d, p;
  }
  var fe = {
    animationend: ue("Animation", "AnimationEnd"),
    animationiteration: ue("Animation", "AnimationIteration"),
    animationstart: ue("Animation", "AnimationStart"),
    transitionrun: ue("Transition", "TransitionRun"),
    transitionstart: ue("Transition", "TransitionStart"),
    transitioncancel: ue("Transition", "TransitionCancel"),
    transitionend: ue("Transition", "TransitionEnd")
  }, le = {}, ce = {};
  Lr && (ce = document.createElement("div").style, "AnimationEvent" in window || (delete fe.animationend.animation, delete fe.animationiteration.animation, delete fe.animationstart.animation), "TransitionEvent" in window || delete fe.transitionend.transition);
  function we(l) {
    if (le[l]) return le[l];
    if (!fe[l]) return l;
    var d = fe[l], p;
    for (p in d)
      if (d.hasOwnProperty(p) && p in ce)
        return le[l] = d[p];
    return l;
  }
  var _e = we("animationend"), ve = we("animationiteration"), Re = we("animationstart"), ze = we("transitionrun"), We = we("transitionstart"), qe = we("transitioncancel"), Le = we("transitionend"), Xe = /* @__PURE__ */ new Map(), Ze = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Ze.push("scrollEnd");
  function Be(l, d) {
    Xe.set(l, d), Qo(d, [l]);
  }
  var Je = typeof reportError == "function" ? reportError : function(l) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var d = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof l == "object" && l !== null && typeof l.message == "string" ? String(l.message) : String(l),
        error: l
      });
      if (!window.dispatchEvent(d)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", l);
      return;
    }
    console.error(l);
  }, St = [], $t = 0, ft = 0;
  function At() {
    for (var l = $t, d = ft = $t = 0; d < l; ) {
      var p = St[d];
      St[d++] = null;
      var y = St[d];
      St[d++] = null;
      var E = St[d];
      St[d++] = null;
      var T = St[d];
      if (St[d++] = null, y !== null && E !== null) {
        var I = y.pending;
        I === null ? E.next = E : (E.next = I.next, I.next = E), y.pending = E;
      }
      T !== 0 && Rs(p, E, T);
    }
  }
  function xn(l, d, p, y) {
    St[$t++] = l, St[$t++] = d, St[$t++] = p, St[$t++] = y, ft |= y, l.lanes |= y, l = l.alternate, l !== null && (l.lanes |= y);
  }
  function hi(l, d, p, y) {
    return xn(l, d, p, y), Cl(l);
  }
  function dn(l, d) {
    return xn(l, null, null, d), Cl(l);
  }
  function Rs(l, d, p) {
    l.lanes |= p;
    var y = l.alternate;
    y !== null && (y.lanes |= p);
    for (var E = !1, T = l.return; T !== null; )
      T.childLanes |= p, y = T.alternate, y !== null && (y.childLanes |= p), T.tag === 22 && (l = T.stateNode, l === null || l._visibility & 1 || (E = !0)), l = T, T = T.return;
    return l.tag === 3 ? (T = l.stateNode, E && d !== null && (E = 31 - Ve(p), l = T.hiddenUpdates, y = l[E], y === null ? l[E] = [d] : y.push(d), d.lane = p | 536870912), T) : null;
  }
  function Cl(l) {
    if (50 < qp)
      throw qp = 0, HS = null, Error(r(185));
    for (var d = l.return; d !== null; )
      l = d, d = l.return;
    return l.tag === 3 ? l.stateNode : null;
  }
  var Kd = {};
  function nK(l, d, p, y) {
    this.tag = l, this.key = p, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = d, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = y, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function ro(l, d, p, y) {
    return new nK(l, d, p, y);
  }
  function j1(l) {
    return l = l.prototype, !(!l || !l.isReactComponent);
  }
  function ka(l, d) {
    var p = l.alternate;
    return p === null ? (p = ro(
      l.tag,
      d,
      l.key,
      l.mode
    ), p.elementType = l.elementType, p.type = l.type, p.stateNode = l.stateNode, p.alternate = l, l.alternate = p) : (p.pendingProps = d, p.type = l.type, p.flags = 0, p.subtreeFlags = 0, p.deletions = null), p.flags = l.flags & 65011712, p.childLanes = l.childLanes, p.lanes = l.lanes, p.child = l.child, p.memoizedProps = l.memoizedProps, p.memoizedState = l.memoizedState, p.updateQueue = l.updateQueue, d = l.dependencies, p.dependencies = d === null ? null : { lanes: d.lanes, firstContext: d.firstContext }, p.sibling = l.sibling, p.index = l.index, p.ref = l.ref, p.refCleanup = l.refCleanup, p;
  }
  function CR(l, d) {
    l.flags &= 65011714;
    var p = l.alternate;
    return p === null ? (l.childLanes = 0, l.lanes = d, l.child = null, l.subtreeFlags = 0, l.memoizedProps = null, l.memoizedState = null, l.updateQueue = null, l.dependencies = null, l.stateNode = null) : (l.childLanes = p.childLanes, l.lanes = p.lanes, l.child = p.child, l.subtreeFlags = 0, l.deletions = null, l.memoizedProps = p.memoizedProps, l.memoizedState = p.memoizedState, l.updateQueue = p.updateQueue, l.type = p.type, d = p.dependencies, l.dependencies = d === null ? null : {
      lanes: d.lanes,
      firstContext: d.firstContext
    }), l;
  }
  function zy(l, d, p, y, E, T) {
    var I = 0;
    if (y = l, typeof l == "function") j1(l) && (I = 1);
    else if (typeof l == "string")
      I = aZ(
        l,
        p,
        ee.current
      ) ? 26 : l === "html" || l === "head" || l === "body" ? 27 : 5;
    else
      e: switch (l) {
        case U:
          return l = ro(31, p, d, E), l.elementType = U, l.lanes = T, l;
        case x:
          return mu(p.children, E, T, d);
        case w:
          I = 8, E |= 24;
          break;
        case S:
          return l = ro(12, p, d, E | 2), l.elementType = S, l.lanes = T, l;
        case D:
          return l = ro(13, p, d, E), l.elementType = D, l.lanes = T, l;
        case j:
          return l = ro(19, p, d, E), l.elementType = j, l.lanes = T, l;
        default:
          if (typeof l == "object" && l !== null)
            switch (l.$$typeof) {
              case M:
                I = 10;
                break e;
              case _:
                I = 9;
                break e;
              case N:
                I = 11;
                break e;
              case O:
                I = 14;
                break e;
              case L:
                I = 16, y = null;
                break e;
            }
          I = 29, p = Error(
            r(130, l === null ? "null" : typeof l, "")
          ), y = null;
      }
    return d = ro(I, p, d, E), d.elementType = l, d.type = y, d.lanes = T, d;
  }
  function mu(l, d, p, y) {
    return l = ro(7, l, y, d), l.lanes = p, l;
  }
  function z1(l, d, p) {
    return l = ro(6, l, null, d), l.lanes = p, l;
  }
  function ER(l) {
    var d = ro(18, null, null, 0);
    return d.stateNode = l, d;
  }
  function L1(l, d, p) {
    return d = ro(
      4,
      l.children !== null ? l.children : [],
      l.key,
      d
    ), d.lanes = p, d.stateNode = {
      containerInfo: l.containerInfo,
      pendingChildren: null,
      implementation: l.implementation
    }, d;
  }
  var _R = /* @__PURE__ */ new WeakMap();
  function _o(l, d) {
    if (typeof l == "object" && l !== null) {
      var p = _R.get(l);
      return p !== void 0 ? p : (d = {
        value: l,
        source: d,
        stack: wt(d)
      }, _R.set(l, d), d);
    }
    return {
      value: l,
      source: d,
      stack: wt(d)
    };
  }
  var Zd = [], Yd = 0, Ly = null, Ep = 0, To = [], Ao = 0, El = null, Os = 1, Ps = "";
  function Ca(l, d) {
    Zd[Yd++] = Ep, Zd[Yd++] = Ly, Ly = l, Ep = d;
  }
  function TR(l, d, p) {
    To[Ao++] = Os, To[Ao++] = Ps, To[Ao++] = El, El = l;
    var y = Os;
    l = Ps;
    var E = 32 - Ve(y) - 1;
    y &= ~(1 << E), p += 1;
    var T = 32 - Ve(d) + E;
    if (30 < T) {
      var I = E - E % 5;
      T = (y & (1 << I) - 1).toString(32), y >>= I, E -= I, Os = 1 << 32 - Ve(d) + E | p << E | y, Ps = T + l;
    } else
      Os = 1 << T | p << E | y, Ps = l;
  }
  function B1(l) {
    l.return !== null && (Ca(l, 1), TR(l, 1, 0));
  }
  function $1(l) {
    for (; l === Ly; )
      Ly = Zd[--Yd], Zd[Yd] = null, Ep = Zd[--Yd], Zd[Yd] = null;
    for (; l === El; )
      El = To[--Ao], To[Ao] = null, Ps = To[--Ao], To[Ao] = null, Os = To[--Ao], To[Ao] = null;
  }
  function AR(l, d) {
    To[Ao++] = Os, To[Ao++] = Ps, To[Ao++] = El, Os = d.id, Ps = d.overflow, El = l;
  }
  var Yr = null, Bn = null, tn = !1, _l = null, Mo = !1, U1 = Error(r(519));
  function Tl(l) {
    var d = Error(
      r(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    throw _p(_o(d, l)), U1;
  }
  function MR(l) {
    var d = l.stateNode, p = l.type, y = l.memoizedProps;
    switch (d[Rn] = l, d[lr] = y, p) {
      case "dialog":
        Kt("cancel", d), Kt("close", d);
        break;
      case "iframe":
      case "object":
      case "embed":
        Kt("load", d);
        break;
      case "video":
      case "audio":
        for (p = 0; p < Kp.length; p++)
          Kt(Kp[p], d);
        break;
      case "source":
        Kt("error", d);
        break;
      case "img":
      case "image":
      case "link":
        Kt("error", d), Kt("load", d);
        break;
      case "details":
        Kt("toggle", d);
        break;
      case "input":
        Kt("invalid", d), Nd(
          d,
          y.value,
          y.defaultValue,
          y.checked,
          y.defaultChecked,
          y.type,
          y.name,
          !0
        );
        break;
      case "select":
        Kt("invalid", d);
        break;
      case "textarea":
        Kt("invalid", d), au(d, y.value, y.defaultValue, y.children);
    }
    p = y.children, typeof p != "string" && typeof p != "number" && typeof p != "bigint" || d.textContent === "" + p || y.suppressHydrationWarning === !0 || qO(d.textContent, p) ? (y.popover != null && (Kt("beforetoggle", d), Kt("toggle", d)), y.onScroll != null && Kt("scroll", d), y.onScrollEnd != null && Kt("scrollend", d), y.onClick != null && (d.onclick = $i), d = !0) : d = !1, d || Tl(l, !0);
  }
  function NR(l) {
    for (Yr = l.return; Yr; )
      switch (Yr.tag) {
        case 5:
        case 31:
        case 13:
          Mo = !1;
          return;
        case 27:
        case 3:
          Mo = !0;
          return;
        default:
          Yr = Yr.return;
      }
  }
  function Xd(l) {
    if (l !== Yr) return !1;
    if (!tn) return NR(l), tn = !0, !1;
    var d = l.tag, p;
    if ((p = d !== 3 && d !== 27) && ((p = d === 5) && (p = l.type, p = !(p !== "form" && p !== "button") || ok(l.type, l.memoizedProps)), p = !p), p && Bn && Tl(l), NR(l), d === 13) {
      if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(317));
      Bn = tP(l);
    } else if (d === 31) {
      if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(317));
      Bn = tP(l);
    } else
      d === 27 ? (d = Bn, Ul(l.type) ? (l = uk, uk = null, Bn = l) : Bn = d) : Bn = Yr ? Ro(l.stateNode.nextSibling) : null;
    return !0;
  }
  function gu() {
    Bn = Yr = null, tn = !1;
  }
  function F1() {
    var l = _l;
    return l !== null && (Hi === null ? Hi = l : Hi.push.apply(
      Hi,
      l
    ), _l = null), l;
  }
  function _p(l) {
    _l === null ? _l = [l] : _l.push(l);
  }
  var V1 = Z(null), yu = null, Ea = null;
  function Al(l, d, p) {
    F(V1, d._currentValue), d._currentValue = p;
  }
  function _a(l) {
    l._currentValue = V1.current, pe(V1);
  }
  function H1(l, d, p) {
    for (; l !== null; ) {
      var y = l.alternate;
      if ((l.childLanes & d) !== d ? (l.childLanes |= d, y !== null && (y.childLanes |= d)) : y !== null && (y.childLanes & d) !== d && (y.childLanes |= d), l === p) break;
      l = l.return;
    }
  }
  function W1(l, d, p, y) {
    var E = l.child;
    for (E !== null && (E.return = l); E !== null; ) {
      var T = E.dependencies;
      if (T !== null) {
        var I = E.child;
        T = T.firstContext;
        e: for (; T !== null; ) {
          var V = T;
          T = E;
          for (var te = 0; te < d.length; te++)
            if (V.context === d[te]) {
              T.lanes |= p, V = T.alternate, V !== null && (V.lanes |= p), H1(
                T.return,
                p,
                l
              ), y || (I = null);
              break e;
            }
          T = V.next;
        }
      } else if (E.tag === 18) {
        if (I = E.return, I === null) throw Error(r(341));
        I.lanes |= p, T = I.alternate, T !== null && (T.lanes |= p), H1(I, p, l), I = null;
      } else I = E.child;
      if (I !== null) I.return = E;
      else
        for (I = E; I !== null; ) {
          if (I === l) {
            I = null;
            break;
          }
          if (E = I.sibling, E !== null) {
            E.return = I.return, I = E;
            break;
          }
          I = I.return;
        }
      E = I;
    }
  }
  function Jd(l, d, p, y) {
    l = null;
    for (var E = d, T = !1; E !== null; ) {
      if (!T) {
        if ((E.flags & 524288) !== 0) T = !0;
        else if ((E.flags & 262144) !== 0) break;
      }
      if (E.tag === 10) {
        var I = E.alternate;
        if (I === null) throw Error(r(387));
        if (I = I.memoizedProps, I !== null) {
          var V = E.type;
          fi(E.pendingProps.value, I.value) || (l !== null ? l.push(V) : l = [V]);
        }
      } else if (E === J.current) {
        if (I = E.alternate, I === null) throw Error(r(387));
        I.memoizedState.memoizedState !== E.memoizedState.memoizedState && (l !== null ? l.push(Qp) : l = [Qp]);
      }
      E = E.return;
    }
    l !== null && W1(
      d,
      l,
      p,
      y
    ), d.flags |= 262144;
  }
  function By(l) {
    for (l = l.firstContext; l !== null; ) {
      if (!fi(
        l.context._currentValue,
        l.memoizedValue
      ))
        return !0;
      l = l.next;
    }
    return !1;
  }
  function vu(l) {
    yu = l, Ea = null, l = l.dependencies, l !== null && (l.firstContext = null);
  }
  function Xr(l) {
    return RR(yu, l);
  }
  function $y(l, d) {
    return yu === null && vu(l), RR(l, d);
  }
  function RR(l, d) {
    var p = d._currentValue;
    if (d = { context: d, memoizedValue: p, next: null }, Ea === null) {
      if (l === null) throw Error(r(308));
      Ea = d, l.dependencies = { lanes: 0, firstContext: d }, l.flags |= 524288;
    } else Ea = Ea.next = d;
    return p;
  }
  var rK = typeof AbortController < "u" ? AbortController : function() {
    var l = [], d = this.signal = {
      aborted: !1,
      addEventListener: function(p, y) {
        l.push(y);
      }
    };
    this.abort = function() {
      d.aborted = !0, l.forEach(function(p) {
        return p();
      });
    };
  }, iK = e.unstable_scheduleCallback, oK = e.unstable_NormalPriority, gr = {
    $$typeof: M,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function q1() {
    return {
      controller: new rK(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function Tp(l) {
    l.refCount--, l.refCount === 0 && iK(oK, function() {
      l.controller.abort();
    });
  }
  var Ap = null, G1 = 0, Qd = 0, ef = null;
  function sK(l, d) {
    if (Ap === null) {
      var p = Ap = [];
      G1 = 0, Qd = YS(), ef = {
        status: "pending",
        value: void 0,
        then: function(y) {
          p.push(y);
        }
      };
    }
    return G1++, d.then(OR, OR), d;
  }
  function OR() {
    if (--G1 === 0 && Ap !== null) {
      ef !== null && (ef.status = "fulfilled");
      var l = Ap;
      Ap = null, Qd = 0, ef = null;
      for (var d = 0; d < l.length; d++) (0, l[d])();
    }
  }
  function aK(l, d) {
    var p = [], y = {
      status: "pending",
      value: null,
      reason: null,
      then: function(E) {
        p.push(E);
      }
    };
    return l.then(
      function() {
        y.status = "fulfilled", y.value = d;
        for (var E = 0; E < p.length; E++) (0, p[E])(d);
      },
      function(E) {
        for (y.status = "rejected", y.reason = E, E = 0; E < p.length; E++)
          (0, p[E])(void 0);
      }
    ), y;
  }
  var PR = H.S;
  H.S = function(l, d) {
    gO = Nn(), typeof d == "object" && d !== null && typeof d.then == "function" && sK(l, d), PR !== null && PR(l, d);
  };
  var bu = Z(null);
  function K1() {
    var l = bu.current;
    return l !== null ? l : En.pooledCache;
  }
  function Uy(l, d) {
    d === null ? F(bu, bu.current) : F(bu, d.pool);
  }
  function DR() {
    var l = K1();
    return l === null ? null : { parent: gr._currentValue, pool: l };
  }
  var tf = Error(r(460)), Z1 = Error(r(474)), Fy = Error(r(542)), Vy = { then: function() {
  } };
  function IR(l) {
    return l = l.status, l === "fulfilled" || l === "rejected";
  }
  function jR(l, d, p) {
    switch (p = l[p], p === void 0 ? l.push(d) : p !== d && (d.then($i, $i), d = p), d.status) {
      case "fulfilled":
        return d.value;
      case "rejected":
        throw l = d.reason, LR(l), l;
      default:
        if (typeof d.status == "string") d.then($i, $i);
        else {
          if (l = En, l !== null && 100 < l.shellSuspendCounter)
            throw Error(r(482));
          l = d, l.status = "pending", l.then(
            function(y) {
              if (d.status === "pending") {
                var E = d;
                E.status = "fulfilled", E.value = y;
              }
            },
            function(y) {
              if (d.status === "pending") {
                var E = d;
                E.status = "rejected", E.reason = y;
              }
            }
          );
        }
        switch (d.status) {
          case "fulfilled":
            return d.value;
          case "rejected":
            throw l = d.reason, LR(l), l;
        }
        throw wu = d, tf;
    }
  }
  function xu(l) {
    try {
      var d = l._init;
      return d(l._payload);
    } catch (p) {
      throw p !== null && typeof p == "object" && typeof p.then == "function" ? (wu = p, tf) : p;
    }
  }
  var wu = null;
  function zR() {
    if (wu === null) throw Error(r(459));
    var l = wu;
    return wu = null, l;
  }
  function LR(l) {
    if (l === tf || l === Fy)
      throw Error(r(483));
  }
  var nf = null, Mp = 0;
  function Hy(l) {
    var d = Mp;
    return Mp += 1, nf === null && (nf = []), jR(nf, l, d);
  }
  function Np(l, d) {
    d = d.props.ref, l.ref = d !== void 0 ? d : null;
  }
  function Wy(l, d) {
    throw d.$$typeof === m ? Error(r(525)) : (l = Object.prototype.toString.call(d), Error(
      r(
        31,
        l === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : l
      )
    ));
  }
  function BR(l) {
    function d(me, de) {
      if (l) {
        var Ce = me.deletions;
        Ce === null ? (me.deletions = [de], me.flags |= 16) : Ce.push(de);
      }
    }
    function p(me, de) {
      if (!l) return null;
      for (; de !== null; )
        d(me, de), de = de.sibling;
      return null;
    }
    function y(me) {
      for (var de = /* @__PURE__ */ new Map(); me !== null; )
        me.key !== null ? de.set(me.key, me) : de.set(me.index, me), me = me.sibling;
      return de;
    }
    function E(me, de) {
      return me = ka(me, de), me.index = 0, me.sibling = null, me;
    }
    function T(me, de, Ce) {
      return me.index = Ce, l ? (Ce = me.alternate, Ce !== null ? (Ce = Ce.index, Ce < de ? (me.flags |= 67108866, de) : Ce) : (me.flags |= 67108866, de)) : (me.flags |= 1048576, de);
    }
    function I(me) {
      return l && me.alternate === null && (me.flags |= 67108866), me;
    }
    function V(me, de, Ce, Ie) {
      return de === null || de.tag !== 6 ? (de = z1(Ce, me.mode, Ie), de.return = me, de) : (de = E(de, Ce), de.return = me, de);
    }
    function te(me, de, Ce, Ie) {
      var mt = Ce.type;
      return mt === x ? Oe(
        me,
        de,
        Ce.props.children,
        Ie,
        Ce.key
      ) : de !== null && (de.elementType === mt || typeof mt == "object" && mt !== null && mt.$$typeof === L && xu(mt) === de.type) ? (de = E(de, Ce.props), Np(de, Ce), de.return = me, de) : (de = zy(
        Ce.type,
        Ce.key,
        Ce.props,
        null,
        me.mode,
        Ie
      ), Np(de, Ce), de.return = me, de);
    }
    function Ee(me, de, Ce, Ie) {
      return de === null || de.tag !== 4 || de.stateNode.containerInfo !== Ce.containerInfo || de.stateNode.implementation !== Ce.implementation ? (de = L1(Ce, me.mode, Ie), de.return = me, de) : (de = E(de, Ce.children || []), de.return = me, de);
    }
    function Oe(me, de, Ce, Ie, mt) {
      return de === null || de.tag !== 7 ? (de = mu(
        Ce,
        me.mode,
        Ie,
        mt
      ), de.return = me, de) : (de = E(de, Ce), de.return = me, de);
    }
    function je(me, de, Ce) {
      if (typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint")
        return de = z1(
          "" + de,
          me.mode,
          Ce
        ), de.return = me, de;
      if (typeof de == "object" && de !== null) {
        switch (de.$$typeof) {
          case g:
            return Ce = zy(
              de.type,
              de.key,
              de.props,
              null,
              me.mode,
              Ce
            ), Np(Ce, de), Ce.return = me, Ce;
          case b:
            return de = L1(
              de,
              me.mode,
              Ce
            ), de.return = me, de;
          case L:
            return de = xu(de), je(me, de, Ce);
        }
        if (ne(de) || Y(de))
          return de = mu(
            de,
            me.mode,
            Ce,
            null
          ), de.return = me, de;
        if (typeof de.then == "function")
          return je(me, Hy(de), Ce);
        if (de.$$typeof === M)
          return je(
            me,
            $y(me, de),
            Ce
          );
        Wy(me, de);
      }
      return null;
    }
    function Te(me, de, Ce, Ie) {
      var mt = de !== null ? de.key : null;
      if (typeof Ce == "string" && Ce !== "" || typeof Ce == "number" || typeof Ce == "bigint")
        return mt !== null ? null : V(me, de, "" + Ce, Ie);
      if (typeof Ce == "object" && Ce !== null) {
        switch (Ce.$$typeof) {
          case g:
            return Ce.key === mt ? te(me, de, Ce, Ie) : null;
          case b:
            return Ce.key === mt ? Ee(me, de, Ce, Ie) : null;
          case L:
            return Ce = xu(Ce), Te(me, de, Ce, Ie);
        }
        if (ne(Ce) || Y(Ce))
          return mt !== null ? null : Oe(me, de, Ce, Ie, null);
        if (typeof Ce.then == "function")
          return Te(
            me,
            de,
            Hy(Ce),
            Ie
          );
        if (Ce.$$typeof === M)
          return Te(
            me,
            de,
            $y(me, Ce),
            Ie
          );
        Wy(me, Ce);
      }
      return null;
    }
    function Me(me, de, Ce, Ie, mt) {
      if (typeof Ie == "string" && Ie !== "" || typeof Ie == "number" || typeof Ie == "bigint")
        return me = me.get(Ce) || null, V(de, me, "" + Ie, mt);
      if (typeof Ie == "object" && Ie !== null) {
        switch (Ie.$$typeof) {
          case g:
            return me = me.get(
              Ie.key === null ? Ce : Ie.key
            ) || null, te(de, me, Ie, mt);
          case b:
            return me = me.get(
              Ie.key === null ? Ce : Ie.key
            ) || null, Ee(de, me, Ie, mt);
          case L:
            return Ie = xu(Ie), Me(
              me,
              de,
              Ce,
              Ie,
              mt
            );
        }
        if (ne(Ie) || Y(Ie))
          return me = me.get(Ce) || null, Oe(de, me, Ie, mt, null);
        if (typeof Ie.then == "function")
          return Me(
            me,
            de,
            Ce,
            Hy(Ie),
            mt
          );
        if (Ie.$$typeof === M)
          return Me(
            me,
            de,
            Ce,
            $y(de, Ie),
            mt
          );
        Wy(de, Ie);
      }
      return null;
    }
    function it(me, de, Ce, Ie) {
      for (var mt = null, sn = null, ct = de, Pt = de = 0, Jt = null; ct !== null && Pt < Ce.length; Pt++) {
        ct.index > Pt ? (Jt = ct, ct = null) : Jt = ct.sibling;
        var an = Te(
          me,
          ct,
          Ce[Pt],
          Ie
        );
        if (an === null) {
          ct === null && (ct = Jt);
          break;
        }
        l && ct && an.alternate === null && d(me, ct), de = T(an, de, Pt), sn === null ? mt = an : sn.sibling = an, sn = an, ct = Jt;
      }
      if (Pt === Ce.length)
        return p(me, ct), tn && Ca(me, Pt), mt;
      if (ct === null) {
        for (; Pt < Ce.length; Pt++)
          ct = je(me, Ce[Pt], Ie), ct !== null && (de = T(
            ct,
            de,
            Pt
          ), sn === null ? mt = ct : sn.sibling = ct, sn = ct);
        return tn && Ca(me, Pt), mt;
      }
      for (ct = y(ct); Pt < Ce.length; Pt++)
        Jt = Me(
          ct,
          me,
          Pt,
          Ce[Pt],
          Ie
        ), Jt !== null && (l && Jt.alternate !== null && ct.delete(
          Jt.key === null ? Pt : Jt.key
        ), de = T(
          Jt,
          de,
          Pt
        ), sn === null ? mt = Jt : sn.sibling = Jt, sn = Jt);
      return l && ct.forEach(function(ql) {
        return d(me, ql);
      }), tn && Ca(me, Pt), mt;
    }
    function bt(me, de, Ce, Ie) {
      if (Ce == null) throw Error(r(151));
      for (var mt = null, sn = null, ct = de, Pt = de = 0, Jt = null, an = Ce.next(); ct !== null && !an.done; Pt++, an = Ce.next()) {
        ct.index > Pt ? (Jt = ct, ct = null) : Jt = ct.sibling;
        var ql = Te(me, ct, an.value, Ie);
        if (ql === null) {
          ct === null && (ct = Jt);
          break;
        }
        l && ct && ql.alternate === null && d(me, ct), de = T(ql, de, Pt), sn === null ? mt = ql : sn.sibling = ql, sn = ql, ct = Jt;
      }
      if (an.done)
        return p(me, ct), tn && Ca(me, Pt), mt;
      if (ct === null) {
        for (; !an.done; Pt++, an = Ce.next())
          an = je(me, an.value, Ie), an !== null && (de = T(an, de, Pt), sn === null ? mt = an : sn.sibling = an, sn = an);
        return tn && Ca(me, Pt), mt;
      }
      for (ct = y(ct); !an.done; Pt++, an = Ce.next())
        an = Me(ct, me, Pt, an.value, Ie), an !== null && (l && an.alternate !== null && ct.delete(an.key === null ? Pt : an.key), de = T(an, de, Pt), sn === null ? mt = an : sn.sibling = an, sn = an);
      return l && ct.forEach(function(vZ) {
        return d(me, vZ);
      }), tn && Ca(me, Pt), mt;
    }
    function kn(me, de, Ce, Ie) {
      if (typeof Ce == "object" && Ce !== null && Ce.type === x && Ce.key === null && (Ce = Ce.props.children), typeof Ce == "object" && Ce !== null) {
        switch (Ce.$$typeof) {
          case g:
            e: {
              for (var mt = Ce.key; de !== null; ) {
                if (de.key === mt) {
                  if (mt = Ce.type, mt === x) {
                    if (de.tag === 7) {
                      p(
                        me,
                        de.sibling
                      ), Ie = E(
                        de,
                        Ce.props.children
                      ), Ie.return = me, me = Ie;
                      break e;
                    }
                  } else if (de.elementType === mt || typeof mt == "object" && mt !== null && mt.$$typeof === L && xu(mt) === de.type) {
                    p(
                      me,
                      de.sibling
                    ), Ie = E(de, Ce.props), Np(Ie, Ce), Ie.return = me, me = Ie;
                    break e;
                  }
                  p(me, de);
                  break;
                } else d(me, de);
                de = de.sibling;
              }
              Ce.type === x ? (Ie = mu(
                Ce.props.children,
                me.mode,
                Ie,
                Ce.key
              ), Ie.return = me, me = Ie) : (Ie = zy(
                Ce.type,
                Ce.key,
                Ce.props,
                null,
                me.mode,
                Ie
              ), Np(Ie, Ce), Ie.return = me, me = Ie);
            }
            return I(me);
          case b:
            e: {
              for (mt = Ce.key; de !== null; ) {
                if (de.key === mt)
                  if (de.tag === 4 && de.stateNode.containerInfo === Ce.containerInfo && de.stateNode.implementation === Ce.implementation) {
                    p(
                      me,
                      de.sibling
                    ), Ie = E(de, Ce.children || []), Ie.return = me, me = Ie;
                    break e;
                  } else {
                    p(me, de);
                    break;
                  }
                else d(me, de);
                de = de.sibling;
              }
              Ie = L1(Ce, me.mode, Ie), Ie.return = me, me = Ie;
            }
            return I(me);
          case L:
            return Ce = xu(Ce), kn(
              me,
              de,
              Ce,
              Ie
            );
        }
        if (ne(Ce))
          return it(
            me,
            de,
            Ce,
            Ie
          );
        if (Y(Ce)) {
          if (mt = Y(Ce), typeof mt != "function") throw Error(r(150));
          return Ce = mt.call(Ce), bt(
            me,
            de,
            Ce,
            Ie
          );
        }
        if (typeof Ce.then == "function")
          return kn(
            me,
            de,
            Hy(Ce),
            Ie
          );
        if (Ce.$$typeof === M)
          return kn(
            me,
            de,
            $y(me, Ce),
            Ie
          );
        Wy(me, Ce);
      }
      return typeof Ce == "string" && Ce !== "" || typeof Ce == "number" || typeof Ce == "bigint" ? (Ce = "" + Ce, de !== null && de.tag === 6 ? (p(me, de.sibling), Ie = E(de, Ce), Ie.return = me, me = Ie) : (p(me, de), Ie = z1(Ce, me.mode, Ie), Ie.return = me, me = Ie), I(me)) : p(me, de);
    }
    return function(me, de, Ce, Ie) {
      try {
        Mp = 0;
        var mt = kn(
          me,
          de,
          Ce,
          Ie
        );
        return nf = null, mt;
      } catch (ct) {
        if (ct === tf || ct === Fy) throw ct;
        var sn = ro(29, ct, null, me.mode);
        return sn.lanes = Ie, sn.return = me, sn;
      }
    };
  }
  var Su = BR(!0), $R = BR(!1), Ml = !1;
  function Y1(l) {
    l.updateQueue = {
      baseState: l.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function X1(l, d) {
    l = l.updateQueue, d.updateQueue === l && (d.updateQueue = {
      baseState: l.baseState,
      firstBaseUpdate: l.firstBaseUpdate,
      lastBaseUpdate: l.lastBaseUpdate,
      shared: l.shared,
      callbacks: null
    });
  }
  function Nl(l) {
    return { lane: l, tag: 0, payload: null, callback: null, next: null };
  }
  function Rl(l, d, p) {
    var y = l.updateQueue;
    if (y === null) return null;
    if (y = y.shared, (un & 2) !== 0) {
      var E = y.pending;
      return E === null ? d.next = d : (d.next = E.next, E.next = d), y.pending = d, d = Cl(l), Rs(l, null, p), d;
    }
    return xn(l, y, d, p), Cl(l);
  }
  function Rp(l, d, p) {
    if (d = d.updateQueue, d !== null && (d = d.shared, (p & 4194048) !== 0)) {
      var y = d.lanes;
      y &= l.pendingLanes, p |= y, d.lanes = p, Cn(l, p);
    }
  }
  function J1(l, d) {
    var p = l.updateQueue, y = l.alternate;
    if (y !== null && (y = y.updateQueue, p === y)) {
      var E = null, T = null;
      if (p = p.firstBaseUpdate, p !== null) {
        do {
          var I = {
            lane: p.lane,
            tag: p.tag,
            payload: p.payload,
            callback: null,
            next: null
          };
          T === null ? E = T = I : T = T.next = I, p = p.next;
        } while (p !== null);
        T === null ? E = T = d : T = T.next = d;
      } else E = T = d;
      p = {
        baseState: y.baseState,
        firstBaseUpdate: E,
        lastBaseUpdate: T,
        shared: y.shared,
        callbacks: y.callbacks
      }, l.updateQueue = p;
      return;
    }
    l = p.lastBaseUpdate, l === null ? p.firstBaseUpdate = d : l.next = d, p.lastBaseUpdate = d;
  }
  var Q1 = !1;
  function Op() {
    if (Q1) {
      var l = ef;
      if (l !== null) throw l;
    }
  }
  function Pp(l, d, p, y) {
    Q1 = !1;
    var E = l.updateQueue;
    Ml = !1;
    var T = E.firstBaseUpdate, I = E.lastBaseUpdate, V = E.shared.pending;
    if (V !== null) {
      E.shared.pending = null;
      var te = V, Ee = te.next;
      te.next = null, I === null ? T = Ee : I.next = Ee, I = te;
      var Oe = l.alternate;
      Oe !== null && (Oe = Oe.updateQueue, V = Oe.lastBaseUpdate, V !== I && (V === null ? Oe.firstBaseUpdate = Ee : V.next = Ee, Oe.lastBaseUpdate = te));
    }
    if (T !== null) {
      var je = E.baseState;
      I = 0, Oe = Ee = te = null, V = T;
      do {
        var Te = V.lane & -536870913, Me = Te !== V.lane;
        if (Me ? (Xt & Te) === Te : (y & Te) === Te) {
          Te !== 0 && Te === Qd && (Q1 = !0), Oe !== null && (Oe = Oe.next = {
            lane: 0,
            tag: V.tag,
            payload: V.payload,
            callback: null,
            next: null
          });
          e: {
            var it = l, bt = V;
            Te = d;
            var kn = p;
            switch (bt.tag) {
              case 1:
                if (it = bt.payload, typeof it == "function") {
                  je = it.call(kn, je, Te);
                  break e;
                }
                je = it;
                break e;
              case 3:
                it.flags = it.flags & -65537 | 128;
              case 0:
                if (it = bt.payload, Te = typeof it == "function" ? it.call(kn, je, Te) : it, Te == null) break e;
                je = h({}, je, Te);
                break e;
              case 2:
                Ml = !0;
            }
          }
          Te = V.callback, Te !== null && (l.flags |= 64, Me && (l.flags |= 8192), Me = E.callbacks, Me === null ? E.callbacks = [Te] : Me.push(Te));
        } else
          Me = {
            lane: Te,
            tag: V.tag,
            payload: V.payload,
            callback: V.callback,
            next: null
          }, Oe === null ? (Ee = Oe = Me, te = je) : Oe = Oe.next = Me, I |= Te;
        if (V = V.next, V === null) {
          if (V = E.shared.pending, V === null)
            break;
          Me = V, V = Me.next, Me.next = null, E.lastBaseUpdate = Me, E.shared.pending = null;
        }
      } while (!0);
      Oe === null && (te = je), E.baseState = te, E.firstBaseUpdate = Ee, E.lastBaseUpdate = Oe, T === null && (E.shared.lanes = 0), jl |= I, l.lanes = I, l.memoizedState = je;
    }
  }
  function UR(l, d) {
    if (typeof l != "function")
      throw Error(r(191, l));
    l.call(d);
  }
  function FR(l, d) {
    var p = l.callbacks;
    if (p !== null)
      for (l.callbacks = null, l = 0; l < p.length; l++)
        UR(p[l], d);
  }
  var rf = Z(null), qy = Z(0);
  function VR(l, d) {
    l = Ia, F(qy, l), F(rf, d), Ia = l | d.baseLanes;
  }
  function eS() {
    F(qy, Ia), F(rf, rf.current);
  }
  function tS() {
    Ia = qy.current, pe(rf), pe(qy);
  }
  var io = Z(null), No = null;
  function Ol(l) {
    var d = l.alternate;
    F(ur, ur.current & 1), F(io, l), No === null && (d === null || rf.current !== null || d.memoizedState !== null) && (No = l);
  }
  function nS(l) {
    F(ur, ur.current), F(io, l), No === null && (No = l);
  }
  function HR(l) {
    l.tag === 22 ? (F(ur, ur.current), F(io, l), No === null && (No = l)) : Pl();
  }
  function Pl() {
    F(ur, ur.current), F(io, io.current);
  }
  function oo(l) {
    pe(io), No === l && (No = null), pe(ur);
  }
  var ur = Z(0);
  function Gy(l) {
    for (var d = l; d !== null; ) {
      if (d.tag === 13) {
        var p = d.memoizedState;
        if (p !== null && (p = p.dehydrated, p === null || lk(p) || ck(p)))
          return d;
      } else if (d.tag === 19 && (d.memoizedProps.revealOrder === "forwards" || d.memoizedProps.revealOrder === "backwards" || d.memoizedProps.revealOrder === "unstable_legacy-backwards" || d.memoizedProps.revealOrder === "together")) {
        if ((d.flags & 128) !== 0) return d;
      } else if (d.child !== null) {
        d.child.return = d, d = d.child;
        continue;
      }
      if (d === l) break;
      for (; d.sibling === null; ) {
        if (d.return === null || d.return === l) return null;
        d = d.return;
      }
      d.sibling.return = d.return, d = d.sibling;
    }
    return null;
  }
  var Ta = 0, Ot = null, wn = null, yr = null, Ky = !1, of = !1, ku = !1, Zy = 0, Dp = 0, sf = null, lK = 0;
  function Qn() {
    throw Error(r(321));
  }
  function rS(l, d) {
    if (d === null) return !1;
    for (var p = 0; p < d.length && p < l.length; p++)
      if (!fi(l[p], d[p])) return !1;
    return !0;
  }
  function iS(l, d, p, y, E, T) {
    return Ta = T, Ot = d, d.memoizedState = null, d.updateQueue = null, d.lanes = 0, H.H = l === null || l.memoizedState === null ? T2 : bS, ku = !1, T = p(y, E), ku = !1, of && (T = qR(
      d,
      p,
      y,
      E
    )), WR(l), T;
  }
  function WR(l) {
    H.H = zp;
    var d = wn !== null && wn.next !== null;
    if (Ta = 0, yr = wn = Ot = null, Ky = !1, Dp = 0, sf = null, d) throw Error(r(300));
    l === null || vr || (l = l.dependencies, l !== null && By(l) && (vr = !0));
  }
  function qR(l, d, p, y) {
    Ot = l;
    var E = 0;
    do {
      if (of && (sf = null), Dp = 0, of = !1, 25 <= E) throw Error(r(301));
      if (E += 1, yr = wn = null, l.updateQueue != null) {
        var T = l.updateQueue;
        T.lastEffect = null, T.events = null, T.stores = null, T.memoCache != null && (T.memoCache.index = 0);
      }
      H.H = A2, T = d(p, y);
    } while (of);
    return T;
  }
  function cK() {
    var l = H.H, d = l.useState()[0];
    return d = typeof d.then == "function" ? Ip(d) : d, l = l.useState()[0], (wn !== null ? wn.memoizedState : null) !== l && (Ot.flags |= 1024), d;
  }
  function oS() {
    var l = Zy !== 0;
    return Zy = 0, l;
  }
  function sS(l, d, p) {
    d.updateQueue = l.updateQueue, d.flags &= -2053, l.lanes &= ~p;
  }
  function aS(l) {
    if (Ky) {
      for (l = l.memoizedState; l !== null; ) {
        var d = l.queue;
        d !== null && (d.pending = null), l = l.next;
      }
      Ky = !1;
    }
    Ta = 0, yr = wn = Ot = null, of = !1, Dp = Zy = 0, sf = null;
  }
  function _i() {
    var l = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return yr === null ? Ot.memoizedState = yr = l : yr = yr.next = l, yr;
  }
  function dr() {
    if (wn === null) {
      var l = Ot.alternate;
      l = l !== null ? l.memoizedState : null;
    } else l = wn.next;
    var d = yr === null ? Ot.memoizedState : yr.next;
    if (d !== null)
      yr = d, wn = l;
    else {
      if (l === null)
        throw Ot.alternate === null ? Error(r(467)) : Error(r(310));
      wn = l, l = {
        memoizedState: wn.memoizedState,
        baseState: wn.baseState,
        baseQueue: wn.baseQueue,
        queue: wn.queue,
        next: null
      }, yr === null ? Ot.memoizedState = yr = l : yr = yr.next = l;
    }
    return yr;
  }
  function Yy() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function Ip(l) {
    var d = Dp;
    return Dp += 1, sf === null && (sf = []), l = jR(sf, l, d), d = Ot, (yr === null ? d.memoizedState : yr.next) === null && (d = d.alternate, H.H = d === null || d.memoizedState === null ? T2 : bS), l;
  }
  function Xy(l) {
    if (l !== null && typeof l == "object") {
      if (typeof l.then == "function") return Ip(l);
      if (l.$$typeof === M) return Xr(l);
    }
    throw Error(r(438, String(l)));
  }
  function lS(l) {
    var d = null, p = Ot.updateQueue;
    if (p !== null && (d = p.memoCache), d == null) {
      var y = Ot.alternate;
      y !== null && (y = y.updateQueue, y !== null && (y = y.memoCache, y != null && (d = {
        data: y.data.map(function(E) {
          return E.slice();
        }),
        index: 0
      })));
    }
    if (d == null && (d = { data: [], index: 0 }), p === null && (p = Yy(), Ot.updateQueue = p), p.memoCache = d, p = d.data[d.index], p === void 0)
      for (p = d.data[d.index] = Array(l), y = 0; y < l; y++)
        p[y] = B;
    return d.index++, p;
  }
  function Aa(l, d) {
    return typeof d == "function" ? d(l) : d;
  }
  function Jy(l) {
    var d = dr();
    return cS(d, wn, l);
  }
  function cS(l, d, p) {
    var y = l.queue;
    if (y === null) throw Error(r(311));
    y.lastRenderedReducer = p;
    var E = l.baseQueue, T = y.pending;
    if (T !== null) {
      if (E !== null) {
        var I = E.next;
        E.next = T.next, T.next = I;
      }
      d.baseQueue = E = T, y.pending = null;
    }
    if (T = l.baseState, E === null) l.memoizedState = T;
    else {
      d = E.next;
      var V = I = null, te = null, Ee = d, Oe = !1;
      do {
        var je = Ee.lane & -536870913;
        if (je !== Ee.lane ? (Xt & je) === je : (Ta & je) === je) {
          var Te = Ee.revertLane;
          if (Te === 0)
            te !== null && (te = te.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: Ee.action,
              hasEagerState: Ee.hasEagerState,
              eagerState: Ee.eagerState,
              next: null
            }), je === Qd && (Oe = !0);
          else if ((Ta & Te) === Te) {
            Ee = Ee.next, Te === Qd && (Oe = !0);
            continue;
          } else
            je = {
              lane: 0,
              revertLane: Ee.revertLane,
              gesture: null,
              action: Ee.action,
              hasEagerState: Ee.hasEagerState,
              eagerState: Ee.eagerState,
              next: null
            }, te === null ? (V = te = je, I = T) : te = te.next = je, Ot.lanes |= Te, jl |= Te;
          je = Ee.action, ku && p(T, je), T = Ee.hasEagerState ? Ee.eagerState : p(T, je);
        } else
          Te = {
            lane: je,
            revertLane: Ee.revertLane,
            gesture: Ee.gesture,
            action: Ee.action,
            hasEagerState: Ee.hasEagerState,
            eagerState: Ee.eagerState,
            next: null
          }, te === null ? (V = te = Te, I = T) : te = te.next = Te, Ot.lanes |= je, jl |= je;
        Ee = Ee.next;
      } while (Ee !== null && Ee !== d);
      if (te === null ? I = T : te.next = V, !fi(T, l.memoizedState) && (vr = !0, Oe && (p = ef, p !== null)))
        throw p;
      l.memoizedState = T, l.baseState = I, l.baseQueue = te, y.lastRenderedState = T;
    }
    return E === null && (y.lanes = 0), [l.memoizedState, y.dispatch];
  }
  function uS(l) {
    var d = dr(), p = d.queue;
    if (p === null) throw Error(r(311));
    p.lastRenderedReducer = l;
    var y = p.dispatch, E = p.pending, T = d.memoizedState;
    if (E !== null) {
      p.pending = null;
      var I = E = E.next;
      do
        T = l(T, I.action), I = I.next;
      while (I !== E);
      fi(T, d.memoizedState) || (vr = !0), d.memoizedState = T, d.baseQueue === null && (d.baseState = T), p.lastRenderedState = T;
    }
    return [T, y];
  }
  function GR(l, d, p) {
    var y = Ot, E = dr(), T = tn;
    if (T) {
      if (p === void 0) throw Error(r(407));
      p = p();
    } else p = d();
    var I = !fi(
      (wn || E).memoizedState,
      p
    );
    if (I && (E.memoizedState = p, vr = !0), E = E.queue, hS(YR.bind(null, y, E, l), [
      l
    ]), E.getSnapshot !== d || I || yr !== null && yr.memoizedState.tag & 1) {
      if (y.flags |= 2048, af(
        9,
        { destroy: void 0 },
        ZR.bind(
          null,
          y,
          E,
          p,
          d
        ),
        null
      ), En === null) throw Error(r(349));
      T || (Ta & 127) !== 0 || KR(y, d, p);
    }
    return p;
  }
  function KR(l, d, p) {
    l.flags |= 16384, l = { getSnapshot: d, value: p }, d = Ot.updateQueue, d === null ? (d = Yy(), Ot.updateQueue = d, d.stores = [l]) : (p = d.stores, p === null ? d.stores = [l] : p.push(l));
  }
  function ZR(l, d, p, y) {
    d.value = p, d.getSnapshot = y, XR(d) && JR(l);
  }
  function YR(l, d, p) {
    return p(function() {
      XR(d) && JR(l);
    });
  }
  function XR(l) {
    var d = l.getSnapshot;
    l = l.value;
    try {
      var p = d();
      return !fi(l, p);
    } catch {
      return !0;
    }
  }
  function JR(l) {
    var d = dn(l, 2);
    d !== null && Wi(d, l, 2);
  }
  function dS(l) {
    var d = _i();
    if (typeof l == "function") {
      var p = l;
      if (l = p(), ku) {
        jn(!0);
        try {
          p();
        } finally {
          jn(!1);
        }
      }
    }
    return d.memoizedState = d.baseState = l, d.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Aa,
      lastRenderedState: l
    }, d;
  }
  function QR(l, d, p, y) {
    return l.baseState = p, cS(
      l,
      wn,
      typeof y == "function" ? y : Aa
    );
  }
  function uK(l, d, p, y, E) {
    if (tv(l)) throw Error(r(485));
    if (l = d.action, l !== null) {
      var T = {
        payload: E,
        action: l,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(I) {
          T.listeners.push(I);
        }
      };
      H.T !== null ? p(!0) : T.isTransition = !1, y(T), p = d.pending, p === null ? (T.next = d.pending = T, e2(d, T)) : (T.next = p.next, d.pending = p.next = T);
    }
  }
  function e2(l, d) {
    var p = d.action, y = d.payload, E = l.state;
    if (d.isTransition) {
      var T = H.T, I = {};
      H.T = I;
      try {
        var V = p(E, y), te = H.S;
        te !== null && te(I, V), t2(l, d, V);
      } catch (Ee) {
        fS(l, d, Ee);
      } finally {
        T !== null && I.types !== null && (T.types = I.types), H.T = T;
      }
    } else
      try {
        T = p(E, y), t2(l, d, T);
      } catch (Ee) {
        fS(l, d, Ee);
      }
  }
  function t2(l, d, p) {
    p !== null && typeof p == "object" && typeof p.then == "function" ? p.then(
      function(y) {
        n2(l, d, y);
      },
      function(y) {
        return fS(l, d, y);
      }
    ) : n2(l, d, p);
  }
  function n2(l, d, p) {
    d.status = "fulfilled", d.value = p, r2(d), l.state = p, d = l.pending, d !== null && (p = d.next, p === d ? l.pending = null : (p = p.next, d.next = p, e2(l, p)));
  }
  function fS(l, d, p) {
    var y = l.pending;
    if (l.pending = null, y !== null) {
      y = y.next;
      do
        d.status = "rejected", d.reason = p, r2(d), d = d.next;
      while (d !== y);
    }
    l.action = null;
  }
  function r2(l) {
    l = l.listeners;
    for (var d = 0; d < l.length; d++) (0, l[d])();
  }
  function i2(l, d) {
    return d;
  }
  function o2(l, d) {
    if (tn) {
      var p = En.formState;
      if (p !== null) {
        e: {
          var y = Ot;
          if (tn) {
            if (Bn) {
              t: {
                for (var E = Bn, T = Mo; E.nodeType !== 8; ) {
                  if (!T) {
                    E = null;
                    break t;
                  }
                  if (E = Ro(
                    E.nextSibling
                  ), E === null) {
                    E = null;
                    break t;
                  }
                }
                T = E.data, E = T === "F!" || T === "F" ? E : null;
              }
              if (E) {
                Bn = Ro(
                  E.nextSibling
                ), y = E.data === "F!";
                break e;
              }
            }
            Tl(y);
          }
          y = !1;
        }
        y && (d = p[0]);
      }
    }
    return p = _i(), p.memoizedState = p.baseState = d, y = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: i2,
      lastRenderedState: d
    }, p.queue = y, p = C2.bind(
      null,
      Ot,
      y
    ), y.dispatch = p, y = dS(!1), T = vS.bind(
      null,
      Ot,
      !1,
      y.queue
    ), y = _i(), E = {
      state: d,
      dispatch: null,
      action: l,
      pending: null
    }, y.queue = E, p = uK.bind(
      null,
      Ot,
      E,
      T,
      p
    ), E.dispatch = p, y.memoizedState = l, [d, p, !1];
  }
  function s2(l) {
    var d = dr();
    return a2(d, wn, l);
  }
  function a2(l, d, p) {
    if (d = cS(
      l,
      d,
      i2
    )[0], l = Jy(Aa)[0], typeof d == "object" && d !== null && typeof d.then == "function")
      try {
        var y = Ip(d);
      } catch (I) {
        throw I === tf ? Fy : I;
      }
    else y = d;
    d = dr();
    var E = d.queue, T = E.dispatch;
    return p !== d.memoizedState && (Ot.flags |= 2048, af(
      9,
      { destroy: void 0 },
      dK.bind(null, E, p),
      null
    )), [y, T, l];
  }
  function dK(l, d) {
    l.action = d;
  }
  function l2(l) {
    var d = dr(), p = wn;
    if (p !== null)
      return a2(d, p, l);
    dr(), d = d.memoizedState, p = dr();
    var y = p.queue.dispatch;
    return p.memoizedState = l, [d, y, !1];
  }
  function af(l, d, p, y) {
    return l = { tag: l, create: p, deps: y, inst: d, next: null }, d = Ot.updateQueue, d === null && (d = Yy(), Ot.updateQueue = d), p = d.lastEffect, p === null ? d.lastEffect = l.next = l : (y = p.next, p.next = l, l.next = y, d.lastEffect = l), l;
  }
  function c2() {
    return dr().memoizedState;
  }
  function Qy(l, d, p, y) {
    var E = _i();
    Ot.flags |= l, E.memoizedState = af(
      1 | d,
      { destroy: void 0 },
      p,
      y === void 0 ? null : y
    );
  }
  function ev(l, d, p, y) {
    var E = dr();
    y = y === void 0 ? null : y;
    var T = E.memoizedState.inst;
    wn !== null && y !== null && rS(y, wn.memoizedState.deps) ? E.memoizedState = af(d, T, p, y) : (Ot.flags |= l, E.memoizedState = af(
      1 | d,
      T,
      p,
      y
    ));
  }
  function u2(l, d) {
    Qy(8390656, 8, l, d);
  }
  function hS(l, d) {
    ev(2048, 8, l, d);
  }
  function fK(l) {
    Ot.flags |= 4;
    var d = Ot.updateQueue;
    if (d === null)
      d = Yy(), Ot.updateQueue = d, d.events = [l];
    else {
      var p = d.events;
      p === null ? d.events = [l] : p.push(l);
    }
  }
  function d2(l) {
    var d = dr().memoizedState;
    return fK({ ref: d, nextImpl: l }), function() {
      if ((un & 2) !== 0) throw Error(r(440));
      return d.impl.apply(void 0, arguments);
    };
  }
  function f2(l, d) {
    return ev(4, 2, l, d);
  }
  function h2(l, d) {
    return ev(4, 4, l, d);
  }
  function p2(l, d) {
    if (typeof d == "function") {
      l = l();
      var p = d(l);
      return function() {
        typeof p == "function" ? p() : d(null);
      };
    }
    if (d != null)
      return l = l(), d.current = l, function() {
        d.current = null;
      };
  }
  function m2(l, d, p) {
    p = p != null ? p.concat([l]) : null, ev(4, 4, p2.bind(null, d, l), p);
  }
  function pS() {
  }
  function g2(l, d) {
    var p = dr();
    d = d === void 0 ? null : d;
    var y = p.memoizedState;
    return d !== null && rS(d, y[1]) ? y[0] : (p.memoizedState = [l, d], l);
  }
  function y2(l, d) {
    var p = dr();
    d = d === void 0 ? null : d;
    var y = p.memoizedState;
    if (d !== null && rS(d, y[1]))
      return y[0];
    if (y = l(), ku) {
      jn(!0);
      try {
        l();
      } finally {
        jn(!1);
      }
    }
    return p.memoizedState = [y, d], y;
  }
  function mS(l, d, p) {
    return p === void 0 || (Ta & 1073741824) !== 0 && (Xt & 261930) === 0 ? l.memoizedState = d : (l.memoizedState = p, l = vO(), Ot.lanes |= l, jl |= l, p);
  }
  function v2(l, d, p, y) {
    return fi(p, d) ? p : rf.current !== null ? (l = mS(l, p, y), fi(l, d) || (vr = !0), l) : (Ta & 42) === 0 || (Ta & 1073741824) !== 0 && (Xt & 261930) === 0 ? (vr = !0, l.memoizedState = p) : (l = vO(), Ot.lanes |= l, jl |= l, d);
  }
  function b2(l, d, p, y, E) {
    var T = Q.p;
    Q.p = T !== 0 && 8 > T ? T : 8;
    var I = H.T, V = {};
    H.T = V, vS(l, !1, d, p);
    try {
      var te = E(), Ee = H.S;
      if (Ee !== null && Ee(V, te), te !== null && typeof te == "object" && typeof te.then == "function") {
        var Oe = aK(
          te,
          y
        );
        jp(
          l,
          d,
          Oe,
          lo(l)
        );
      } else
        jp(
          l,
          d,
          y,
          lo(l)
        );
    } catch (je) {
      jp(
        l,
        d,
        { then: function() {
        }, status: "rejected", reason: je },
        lo()
      );
    } finally {
      Q.p = T, I !== null && V.types !== null && (I.types = V.types), H.T = I;
    }
  }
  function hK() {
  }
  function gS(l, d, p, y) {
    if (l.tag !== 5) throw Error(r(476));
    var E = x2(l).queue;
    b2(
      l,
      E,
      d,
      X,
      p === null ? hK : function() {
        return w2(l), p(y);
      }
    );
  }
  function x2(l) {
    var d = l.memoizedState;
    if (d !== null) return d;
    d = {
      memoizedState: X,
      baseState: X,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Aa,
        lastRenderedState: X
      },
      next: null
    };
    var p = {};
    return d.next = {
      memoizedState: p,
      baseState: p,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Aa,
        lastRenderedState: p
      },
      next: null
    }, l.memoizedState = d, l = l.alternate, l !== null && (l.memoizedState = d), d;
  }
  function w2(l) {
    var d = x2(l);
    d.next === null && (d = l.alternate.memoizedState), jp(
      l,
      d.next.queue,
      {},
      lo()
    );
  }
  function yS() {
    return Xr(Qp);
  }
  function S2() {
    return dr().memoizedState;
  }
  function k2() {
    return dr().memoizedState;
  }
  function pK(l) {
    for (var d = l.return; d !== null; ) {
      switch (d.tag) {
        case 24:
        case 3:
          var p = lo();
          l = Nl(p);
          var y = Rl(d, l, p);
          y !== null && (Wi(y, d, p), Rp(y, d, p)), d = { cache: q1() }, l.payload = d;
          return;
      }
      d = d.return;
    }
  }
  function mK(l, d, p) {
    var y = lo();
    p = {
      lane: y,
      revertLane: 0,
      gesture: null,
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, tv(l) ? E2(d, p) : (p = hi(l, d, p, y), p !== null && (Wi(p, l, y), _2(p, d, y)));
  }
  function C2(l, d, p) {
    var y = lo();
    jp(l, d, p, y);
  }
  function jp(l, d, p, y) {
    var E = {
      lane: y,
      revertLane: 0,
      gesture: null,
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (tv(l)) E2(d, E);
    else {
      var T = l.alternate;
      if (l.lanes === 0 && (T === null || T.lanes === 0) && (T = d.lastRenderedReducer, T !== null))
        try {
          var I = d.lastRenderedState, V = T(I, p);
          if (E.hasEagerState = !0, E.eagerState = V, fi(V, I))
            return xn(l, d, E, 0), En === null && At(), !1;
        } catch {
        }
      if (p = hi(l, d, E, y), p !== null)
        return Wi(p, l, y), _2(p, d, y), !0;
    }
    return !1;
  }
  function vS(l, d, p, y) {
    if (y = {
      lane: 2,
      revertLane: YS(),
      gesture: null,
      action: y,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, tv(l)) {
      if (d) throw Error(r(479));
    } else
      d = hi(
        l,
        p,
        y,
        2
      ), d !== null && Wi(d, l, 2);
  }
  function tv(l) {
    var d = l.alternate;
    return l === Ot || d !== null && d === Ot;
  }
  function E2(l, d) {
    of = Ky = !0;
    var p = l.pending;
    p === null ? d.next = d : (d.next = p.next, p.next = d), l.pending = d;
  }
  function _2(l, d, p) {
    if ((p & 4194048) !== 0) {
      var y = d.lanes;
      y &= l.pendingLanes, p |= y, d.lanes = p, Cn(l, p);
    }
  }
  var zp = {
    readContext: Xr,
    use: Xy,
    useCallback: Qn,
    useContext: Qn,
    useEffect: Qn,
    useImperativeHandle: Qn,
    useLayoutEffect: Qn,
    useInsertionEffect: Qn,
    useMemo: Qn,
    useReducer: Qn,
    useRef: Qn,
    useState: Qn,
    useDebugValue: Qn,
    useDeferredValue: Qn,
    useTransition: Qn,
    useSyncExternalStore: Qn,
    useId: Qn,
    useHostTransitionStatus: Qn,
    useFormState: Qn,
    useActionState: Qn,
    useOptimistic: Qn,
    useMemoCache: Qn,
    useCacheRefresh: Qn
  };
  zp.useEffectEvent = Qn;
  var T2 = {
    readContext: Xr,
    use: Xy,
    useCallback: function(l, d) {
      return _i().memoizedState = [
        l,
        d === void 0 ? null : d
      ], l;
    },
    useContext: Xr,
    useEffect: u2,
    useImperativeHandle: function(l, d, p) {
      p = p != null ? p.concat([l]) : null, Qy(
        4194308,
        4,
        p2.bind(null, d, l),
        p
      );
    },
    useLayoutEffect: function(l, d) {
      return Qy(4194308, 4, l, d);
    },
    useInsertionEffect: function(l, d) {
      Qy(4, 2, l, d);
    },
    useMemo: function(l, d) {
      var p = _i();
      d = d === void 0 ? null : d;
      var y = l();
      if (ku) {
        jn(!0);
        try {
          l();
        } finally {
          jn(!1);
        }
      }
      return p.memoizedState = [y, d], y;
    },
    useReducer: function(l, d, p) {
      var y = _i();
      if (p !== void 0) {
        var E = p(d);
        if (ku) {
          jn(!0);
          try {
            p(d);
          } finally {
            jn(!1);
          }
        }
      } else E = d;
      return y.memoizedState = y.baseState = E, l = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: l,
        lastRenderedState: E
      }, y.queue = l, l = l.dispatch = mK.bind(
        null,
        Ot,
        l
      ), [y.memoizedState, l];
    },
    useRef: function(l) {
      var d = _i();
      return l = { current: l }, d.memoizedState = l;
    },
    useState: function(l) {
      l = dS(l);
      var d = l.queue, p = C2.bind(null, Ot, d);
      return d.dispatch = p, [l.memoizedState, p];
    },
    useDebugValue: pS,
    useDeferredValue: function(l, d) {
      var p = _i();
      return mS(p, l, d);
    },
    useTransition: function() {
      var l = dS(!1);
      return l = b2.bind(
        null,
        Ot,
        l.queue,
        !0,
        !1
      ), _i().memoizedState = l, [!1, l];
    },
    useSyncExternalStore: function(l, d, p) {
      var y = Ot, E = _i();
      if (tn) {
        if (p === void 0)
          throw Error(r(407));
        p = p();
      } else {
        if (p = d(), En === null)
          throw Error(r(349));
        (Xt & 127) !== 0 || KR(y, d, p);
      }
      E.memoizedState = p;
      var T = { value: p, getSnapshot: d };
      return E.queue = T, u2(YR.bind(null, y, T, l), [
        l
      ]), y.flags |= 2048, af(
        9,
        { destroy: void 0 },
        ZR.bind(
          null,
          y,
          T,
          p,
          d
        ),
        null
      ), p;
    },
    useId: function() {
      var l = _i(), d = En.identifierPrefix;
      if (tn) {
        var p = Ps, y = Os;
        p = (y & ~(1 << 32 - Ve(y) - 1)).toString(32) + p, d = "_" + d + "R_" + p, p = Zy++, 0 < p && (d += "H" + p.toString(32)), d += "_";
      } else
        p = lK++, d = "_" + d + "r_" + p.toString(32) + "_";
      return l.memoizedState = d;
    },
    useHostTransitionStatus: yS,
    useFormState: o2,
    useActionState: o2,
    useOptimistic: function(l) {
      var d = _i();
      d.memoizedState = d.baseState = l;
      var p = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return d.queue = p, d = vS.bind(
        null,
        Ot,
        !0,
        p
      ), p.dispatch = d, [l, d];
    },
    useMemoCache: lS,
    useCacheRefresh: function() {
      return _i().memoizedState = pK.bind(
        null,
        Ot
      );
    },
    useEffectEvent: function(l) {
      var d = _i(), p = { impl: l };
      return d.memoizedState = p, function() {
        if ((un & 2) !== 0)
          throw Error(r(440));
        return p.impl.apply(void 0, arguments);
      };
    }
  }, bS = {
    readContext: Xr,
    use: Xy,
    useCallback: g2,
    useContext: Xr,
    useEffect: hS,
    useImperativeHandle: m2,
    useInsertionEffect: f2,
    useLayoutEffect: h2,
    useMemo: y2,
    useReducer: Jy,
    useRef: c2,
    useState: function() {
      return Jy(Aa);
    },
    useDebugValue: pS,
    useDeferredValue: function(l, d) {
      var p = dr();
      return v2(
        p,
        wn.memoizedState,
        l,
        d
      );
    },
    useTransition: function() {
      var l = Jy(Aa)[0], d = dr().memoizedState;
      return [
        typeof l == "boolean" ? l : Ip(l),
        d
      ];
    },
    useSyncExternalStore: GR,
    useId: S2,
    useHostTransitionStatus: yS,
    useFormState: s2,
    useActionState: s2,
    useOptimistic: function(l, d) {
      var p = dr();
      return QR(p, wn, l, d);
    },
    useMemoCache: lS,
    useCacheRefresh: k2
  };
  bS.useEffectEvent = d2;
  var A2 = {
    readContext: Xr,
    use: Xy,
    useCallback: g2,
    useContext: Xr,
    useEffect: hS,
    useImperativeHandle: m2,
    useInsertionEffect: f2,
    useLayoutEffect: h2,
    useMemo: y2,
    useReducer: uS,
    useRef: c2,
    useState: function() {
      return uS(Aa);
    },
    useDebugValue: pS,
    useDeferredValue: function(l, d) {
      var p = dr();
      return wn === null ? mS(p, l, d) : v2(
        p,
        wn.memoizedState,
        l,
        d
      );
    },
    useTransition: function() {
      var l = uS(Aa)[0], d = dr().memoizedState;
      return [
        typeof l == "boolean" ? l : Ip(l),
        d
      ];
    },
    useSyncExternalStore: GR,
    useId: S2,
    useHostTransitionStatus: yS,
    useFormState: l2,
    useActionState: l2,
    useOptimistic: function(l, d) {
      var p = dr();
      return wn !== null ? QR(p, wn, l, d) : (p.baseState = l, [l, p.queue.dispatch]);
    },
    useMemoCache: lS,
    useCacheRefresh: k2
  };
  A2.useEffectEvent = d2;
  function xS(l, d, p, y) {
    d = l.memoizedState, p = p(y, d), p = p == null ? d : h({}, d, p), l.memoizedState = p, l.lanes === 0 && (l.updateQueue.baseState = p);
  }
  var wS = {
    enqueueSetState: function(l, d, p) {
      l = l._reactInternals;
      var y = lo(), E = Nl(y);
      E.payload = d, p != null && (E.callback = p), d = Rl(l, E, y), d !== null && (Wi(d, l, y), Rp(d, l, y));
    },
    enqueueReplaceState: function(l, d, p) {
      l = l._reactInternals;
      var y = lo(), E = Nl(y);
      E.tag = 1, E.payload = d, p != null && (E.callback = p), d = Rl(l, E, y), d !== null && (Wi(d, l, y), Rp(d, l, y));
    },
    enqueueForceUpdate: function(l, d) {
      l = l._reactInternals;
      var p = lo(), y = Nl(p);
      y.tag = 2, d != null && (y.callback = d), d = Rl(l, y, p), d !== null && (Wi(d, l, p), Rp(d, l, p));
    }
  };
  function M2(l, d, p, y, E, T, I) {
    return l = l.stateNode, typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(y, T, I) : d.prototype && d.prototype.isPureReactComponent ? !k(p, y) || !k(E, T) : !0;
  }
  function N2(l, d, p, y) {
    l = d.state, typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(p, y), typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(p, y), d.state !== l && wS.enqueueReplaceState(d, d.state, null);
  }
  function Cu(l, d) {
    var p = d;
    if ("ref" in d) {
      p = {};
      for (var y in d)
        y !== "ref" && (p[y] = d[y]);
    }
    if (l = l.defaultProps) {
      p === d && (p = h({}, p));
      for (var E in l)
        p[E] === void 0 && (p[E] = l[E]);
    }
    return p;
  }
  function R2(l) {
    Je(l);
  }
  function O2(l) {
    console.error(l);
  }
  function P2(l) {
    Je(l);
  }
  function nv(l, d) {
    try {
      var p = l.onUncaughtError;
      p(d.value, { componentStack: d.stack });
    } catch (y) {
      setTimeout(function() {
        throw y;
      });
    }
  }
  function D2(l, d, p) {
    try {
      var y = l.onCaughtError;
      y(p.value, {
        componentStack: p.stack,
        errorBoundary: d.tag === 1 ? d.stateNode : null
      });
    } catch (E) {
      setTimeout(function() {
        throw E;
      });
    }
  }
  function SS(l, d, p) {
    return p = Nl(p), p.tag = 3, p.payload = { element: null }, p.callback = function() {
      nv(l, d);
    }, p;
  }
  function I2(l) {
    return l = Nl(l), l.tag = 3, l;
  }
  function j2(l, d, p, y) {
    var E = p.type.getDerivedStateFromError;
    if (typeof E == "function") {
      var T = y.value;
      l.payload = function() {
        return E(T);
      }, l.callback = function() {
        D2(d, p, y);
      };
    }
    var I = p.stateNode;
    I !== null && typeof I.componentDidCatch == "function" && (l.callback = function() {
      D2(d, p, y), typeof E != "function" && (zl === null ? zl = /* @__PURE__ */ new Set([this]) : zl.add(this));
      var V = y.stack;
      this.componentDidCatch(y.value, {
        componentStack: V !== null ? V : ""
      });
    });
  }
  function gK(l, d, p, y, E) {
    if (p.flags |= 32768, y !== null && typeof y == "object" && typeof y.then == "function") {
      if (d = p.alternate, d !== null && Jd(
        d,
        p,
        E,
        !0
      ), p = io.current, p !== null) {
        switch (p.tag) {
          case 31:
          case 13:
            return No === null ? pv() : p.alternate === null && er === 0 && (er = 3), p.flags &= -257, p.flags |= 65536, p.lanes = E, y === Vy ? p.flags |= 16384 : (d = p.updateQueue, d === null ? p.updateQueue = /* @__PURE__ */ new Set([y]) : d.add(y), GS(l, y, E)), !1;
          case 22:
            return p.flags |= 65536, y === Vy ? p.flags |= 16384 : (d = p.updateQueue, d === null ? (d = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([y])
            }, p.updateQueue = d) : (p = d.retryQueue, p === null ? d.retryQueue = /* @__PURE__ */ new Set([y]) : p.add(y)), GS(l, y, E)), !1;
        }
        throw Error(r(435, p.tag));
      }
      return GS(l, y, E), pv(), !1;
    }
    if (tn)
      return d = io.current, d !== null ? ((d.flags & 65536) === 0 && (d.flags |= 256), d.flags |= 65536, d.lanes = E, y !== U1 && (l = Error(r(422), { cause: y }), _p(_o(l, p)))) : (y !== U1 && (d = Error(r(423), {
        cause: y
      }), _p(
        _o(d, p)
      )), l = l.current.alternate, l.flags |= 65536, E &= -E, l.lanes |= E, y = _o(y, p), E = SS(
        l.stateNode,
        y,
        E
      ), J1(l, E), er !== 4 && (er = 2)), !1;
    var T = Error(r(520), { cause: y });
    if (T = _o(T, p), Wp === null ? Wp = [T] : Wp.push(T), er !== 4 && (er = 2), d === null) return !0;
    y = _o(y, p), p = d;
    do {
      switch (p.tag) {
        case 3:
          return p.flags |= 65536, l = E & -E, p.lanes |= l, l = SS(p.stateNode, y, l), J1(p, l), !1;
        case 1:
          if (d = p.type, T = p.stateNode, (p.flags & 128) === 0 && (typeof d.getDerivedStateFromError == "function" || T !== null && typeof T.componentDidCatch == "function" && (zl === null || !zl.has(T))))
            return p.flags |= 65536, E &= -E, p.lanes |= E, E = I2(E), j2(
              E,
              l,
              p,
              y
            ), J1(p, E), !1;
      }
      p = p.return;
    } while (p !== null);
    return !1;
  }
  var kS = Error(r(461)), vr = !1;
  function Jr(l, d, p, y) {
    d.child = l === null ? $R(d, null, p, y) : Su(
      d,
      l.child,
      p,
      y
    );
  }
  function z2(l, d, p, y, E) {
    p = p.render;
    var T = d.ref;
    if ("ref" in y) {
      var I = {};
      for (var V in y)
        V !== "ref" && (I[V] = y[V]);
    } else I = y;
    return vu(d), y = iS(
      l,
      d,
      p,
      I,
      T,
      E
    ), V = oS(), l !== null && !vr ? (sS(l, d, E), Ma(l, d, E)) : (tn && V && B1(d), d.flags |= 1, Jr(l, d, y, E), d.child);
  }
  function L2(l, d, p, y, E) {
    if (l === null) {
      var T = p.type;
      return typeof T == "function" && !j1(T) && T.defaultProps === void 0 && p.compare === null ? (d.tag = 15, d.type = T, B2(
        l,
        d,
        T,
        y,
        E
      )) : (l = zy(
        p.type,
        null,
        y,
        d,
        d.mode,
        E
      ), l.ref = d.ref, l.return = d, d.child = l);
    }
    if (T = l.child, !RS(l, E)) {
      var I = T.memoizedProps;
      if (p = p.compare, p = p !== null ? p : k, p(I, y) && l.ref === d.ref)
        return Ma(l, d, E);
    }
    return d.flags |= 1, l = ka(T, y), l.ref = d.ref, l.return = d, d.child = l;
  }
  function B2(l, d, p, y, E) {
    if (l !== null) {
      var T = l.memoizedProps;
      if (k(T, y) && l.ref === d.ref)
        if (vr = !1, d.pendingProps = y = T, RS(l, E))
          (l.flags & 131072) !== 0 && (vr = !0);
        else
          return d.lanes = l.lanes, Ma(l, d, E);
    }
    return CS(
      l,
      d,
      p,
      y,
      E
    );
  }
  function $2(l, d, p, y) {
    var E = y.children, T = l !== null ? l.memoizedState : null;
    if (l === null && d.stateNode === null && (d.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), y.mode === "hidden") {
      if ((d.flags & 128) !== 0) {
        if (T = T !== null ? T.baseLanes | p : p, l !== null) {
          for (y = d.child = l.child, E = 0; y !== null; )
            E = E | y.lanes | y.childLanes, y = y.sibling;
          y = E & ~T;
        } else y = 0, d.child = null;
        return U2(
          l,
          d,
          T,
          p,
          y
        );
      }
      if ((p & 536870912) !== 0)
        d.memoizedState = { baseLanes: 0, cachePool: null }, l !== null && Uy(
          d,
          T !== null ? T.cachePool : null
        ), T !== null ? VR(d, T) : eS(), HR(d);
      else
        return y = d.lanes = 536870912, U2(
          l,
          d,
          T !== null ? T.baseLanes | p : p,
          p,
          y
        );
    } else
      T !== null ? (Uy(d, T.cachePool), VR(d, T), Pl(), d.memoizedState = null) : (l !== null && Uy(d, null), eS(), Pl());
    return Jr(l, d, E, p), d.child;
  }
  function Lp(l, d) {
    return l !== null && l.tag === 22 || d.stateNode !== null || (d.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), d.sibling;
  }
  function U2(l, d, p, y, E) {
    var T = K1();
    return T = T === null ? null : { parent: gr._currentValue, pool: T }, d.memoizedState = {
      baseLanes: p,
      cachePool: T
    }, l !== null && Uy(d, null), eS(), HR(d), l !== null && Jd(l, d, y, !0), d.childLanes = E, null;
  }
  function rv(l, d) {
    return d = ov(
      { mode: d.mode, children: d.children },
      l.mode
    ), d.ref = l.ref, l.child = d, d.return = l, d;
  }
  function F2(l, d, p) {
    return Su(d, l.child, null, p), l = rv(d, d.pendingProps), l.flags |= 2, oo(d), d.memoizedState = null, l;
  }
  function yK(l, d, p) {
    var y = d.pendingProps, E = (d.flags & 128) !== 0;
    if (d.flags &= -129, l === null) {
      if (tn) {
        if (y.mode === "hidden")
          return l = rv(d, y), d.lanes = 536870912, Lp(null, l);
        if (nS(d), (l = Bn) ? (l = eP(
          l,
          Mo
        ), l = l !== null && l.data === "&" ? l : null, l !== null && (d.memoizedState = {
          dehydrated: l,
          treeContext: El !== null ? { id: Os, overflow: Ps } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, p = ER(l), p.return = d, d.child = p, Yr = d, Bn = null)) : l = null, l === null) throw Tl(d);
        return d.lanes = 536870912, null;
      }
      return rv(d, y);
    }
    var T = l.memoizedState;
    if (T !== null) {
      var I = T.dehydrated;
      if (nS(d), E)
        if (d.flags & 256)
          d.flags &= -257, d = F2(
            l,
            d,
            p
          );
        else if (d.memoizedState !== null)
          d.child = l.child, d.flags |= 128, d = null;
        else throw Error(r(558));
      else if (vr || Jd(l, d, p, !1), E = (p & l.childLanes) !== 0, vr || E) {
        if (y = En, y !== null && (I = ar(y, p), I !== 0 && I !== T.retryLane))
          throw T.retryLane = I, dn(l, I), Wi(y, l, I), kS;
        pv(), d = F2(
          l,
          d,
          p
        );
      } else
        l = T.treeContext, Bn = Ro(I.nextSibling), Yr = d, tn = !0, _l = null, Mo = !1, l !== null && AR(d, l), d = rv(d, y), d.flags |= 4096;
      return d;
    }
    return l = ka(l.child, {
      mode: y.mode,
      children: y.children
    }), l.ref = d.ref, d.child = l, l.return = d, l;
  }
  function iv(l, d) {
    var p = d.ref;
    if (p === null)
      l !== null && l.ref !== null && (d.flags |= 4194816);
    else {
      if (typeof p != "function" && typeof p != "object")
        throw Error(r(284));
      (l === null || l.ref !== p) && (d.flags |= 4194816);
    }
  }
  function CS(l, d, p, y, E) {
    return vu(d), p = iS(
      l,
      d,
      p,
      y,
      void 0,
      E
    ), y = oS(), l !== null && !vr ? (sS(l, d, E), Ma(l, d, E)) : (tn && y && B1(d), d.flags |= 1, Jr(l, d, p, E), d.child);
  }
  function V2(l, d, p, y, E, T) {
    return vu(d), d.updateQueue = null, p = qR(
      d,
      y,
      p,
      E
    ), WR(l), y = oS(), l !== null && !vr ? (sS(l, d, T), Ma(l, d, T)) : (tn && y && B1(d), d.flags |= 1, Jr(l, d, p, T), d.child);
  }
  function H2(l, d, p, y, E) {
    if (vu(d), d.stateNode === null) {
      var T = Kd, I = p.contextType;
      typeof I == "object" && I !== null && (T = Xr(I)), T = new p(y, T), d.memoizedState = T.state !== null && T.state !== void 0 ? T.state : null, T.updater = wS, d.stateNode = T, T._reactInternals = d, T = d.stateNode, T.props = y, T.state = d.memoizedState, T.refs = {}, Y1(d), I = p.contextType, T.context = typeof I == "object" && I !== null ? Xr(I) : Kd, T.state = d.memoizedState, I = p.getDerivedStateFromProps, typeof I == "function" && (xS(
        d,
        p,
        I,
        y
      ), T.state = d.memoizedState), typeof p.getDerivedStateFromProps == "function" || typeof T.getSnapshotBeforeUpdate == "function" || typeof T.UNSAFE_componentWillMount != "function" && typeof T.componentWillMount != "function" || (I = T.state, typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount(), I !== T.state && wS.enqueueReplaceState(T, T.state, null), Pp(d, y, T, E), Op(), T.state = d.memoizedState), typeof T.componentDidMount == "function" && (d.flags |= 4194308), y = !0;
    } else if (l === null) {
      T = d.stateNode;
      var V = d.memoizedProps, te = Cu(p, V);
      T.props = te;
      var Ee = T.context, Oe = p.contextType;
      I = Kd, typeof Oe == "object" && Oe !== null && (I = Xr(Oe));
      var je = p.getDerivedStateFromProps;
      Oe = typeof je == "function" || typeof T.getSnapshotBeforeUpdate == "function", V = d.pendingProps !== V, Oe || typeof T.UNSAFE_componentWillReceiveProps != "function" && typeof T.componentWillReceiveProps != "function" || (V || Ee !== I) && N2(
        d,
        T,
        y,
        I
      ), Ml = !1;
      var Te = d.memoizedState;
      T.state = Te, Pp(d, y, T, E), Op(), Ee = d.memoizedState, V || Te !== Ee || Ml ? (typeof je == "function" && (xS(
        d,
        p,
        je,
        y
      ), Ee = d.memoizedState), (te = Ml || M2(
        d,
        p,
        te,
        y,
        Te,
        Ee,
        I
      )) ? (Oe || typeof T.UNSAFE_componentWillMount != "function" && typeof T.componentWillMount != "function" || (typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount()), typeof T.componentDidMount == "function" && (d.flags |= 4194308)) : (typeof T.componentDidMount == "function" && (d.flags |= 4194308), d.memoizedProps = y, d.memoizedState = Ee), T.props = y, T.state = Ee, T.context = I, y = te) : (typeof T.componentDidMount == "function" && (d.flags |= 4194308), y = !1);
    } else {
      T = d.stateNode, X1(l, d), I = d.memoizedProps, Oe = Cu(p, I), T.props = Oe, je = d.pendingProps, Te = T.context, Ee = p.contextType, te = Kd, typeof Ee == "object" && Ee !== null && (te = Xr(Ee)), V = p.getDerivedStateFromProps, (Ee = typeof V == "function" || typeof T.getSnapshotBeforeUpdate == "function") || typeof T.UNSAFE_componentWillReceiveProps != "function" && typeof T.componentWillReceiveProps != "function" || (I !== je || Te !== te) && N2(
        d,
        T,
        y,
        te
      ), Ml = !1, Te = d.memoizedState, T.state = Te, Pp(d, y, T, E), Op();
      var Me = d.memoizedState;
      I !== je || Te !== Me || Ml || l !== null && l.dependencies !== null && By(l.dependencies) ? (typeof V == "function" && (xS(
        d,
        p,
        V,
        y
      ), Me = d.memoizedState), (Oe = Ml || M2(
        d,
        p,
        Oe,
        y,
        Te,
        Me,
        te
      ) || l !== null && l.dependencies !== null && By(l.dependencies)) ? (Ee || typeof T.UNSAFE_componentWillUpdate != "function" && typeof T.componentWillUpdate != "function" || (typeof T.componentWillUpdate == "function" && T.componentWillUpdate(y, Me, te), typeof T.UNSAFE_componentWillUpdate == "function" && T.UNSAFE_componentWillUpdate(
        y,
        Me,
        te
      )), typeof T.componentDidUpdate == "function" && (d.flags |= 4), typeof T.getSnapshotBeforeUpdate == "function" && (d.flags |= 1024)) : (typeof T.componentDidUpdate != "function" || I === l.memoizedProps && Te === l.memoizedState || (d.flags |= 4), typeof T.getSnapshotBeforeUpdate != "function" || I === l.memoizedProps && Te === l.memoizedState || (d.flags |= 1024), d.memoizedProps = y, d.memoizedState = Me), T.props = y, T.state = Me, T.context = te, y = Oe) : (typeof T.componentDidUpdate != "function" || I === l.memoizedProps && Te === l.memoizedState || (d.flags |= 4), typeof T.getSnapshotBeforeUpdate != "function" || I === l.memoizedProps && Te === l.memoizedState || (d.flags |= 1024), y = !1);
    }
    return T = y, iv(l, d), y = (d.flags & 128) !== 0, T || y ? (T = d.stateNode, p = y && typeof p.getDerivedStateFromError != "function" ? null : T.render(), d.flags |= 1, l !== null && y ? (d.child = Su(
      d,
      l.child,
      null,
      E
    ), d.child = Su(
      d,
      null,
      p,
      E
    )) : Jr(l, d, p, E), d.memoizedState = T.state, l = d.child) : l = Ma(
      l,
      d,
      E
    ), l;
  }
  function W2(l, d, p, y) {
    return gu(), d.flags |= 256, Jr(l, d, p, y), d.child;
  }
  var ES = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function _S(l) {
    return { baseLanes: l, cachePool: DR() };
  }
  function TS(l, d, p) {
    return l = l !== null ? l.childLanes & ~p : 0, d && (l |= ao), l;
  }
  function q2(l, d, p) {
    var y = d.pendingProps, E = !1, T = (d.flags & 128) !== 0, I;
    if ((I = T) || (I = l !== null && l.memoizedState === null ? !1 : (ur.current & 2) !== 0), I && (E = !0, d.flags &= -129), I = (d.flags & 32) !== 0, d.flags &= -33, l === null) {
      if (tn) {
        if (E ? Ol(d) : Pl(), (l = Bn) ? (l = eP(
          l,
          Mo
        ), l = l !== null && l.data !== "&" ? l : null, l !== null && (d.memoizedState = {
          dehydrated: l,
          treeContext: El !== null ? { id: Os, overflow: Ps } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, p = ER(l), p.return = d, d.child = p, Yr = d, Bn = null)) : l = null, l === null) throw Tl(d);
        return ck(l) ? d.lanes = 32 : d.lanes = 536870912, null;
      }
      var V = y.children;
      return y = y.fallback, E ? (Pl(), E = d.mode, V = ov(
        { mode: "hidden", children: V },
        E
      ), y = mu(
        y,
        E,
        p,
        null
      ), V.return = d, y.return = d, V.sibling = y, d.child = V, y = d.child, y.memoizedState = _S(p), y.childLanes = TS(
        l,
        I,
        p
      ), d.memoizedState = ES, Lp(null, y)) : (Ol(d), AS(d, V));
    }
    var te = l.memoizedState;
    if (te !== null && (V = te.dehydrated, V !== null)) {
      if (T)
        d.flags & 256 ? (Ol(d), d.flags &= -257, d = MS(
          l,
          d,
          p
        )) : d.memoizedState !== null ? (Pl(), d.child = l.child, d.flags |= 128, d = null) : (Pl(), V = y.fallback, E = d.mode, y = ov(
          { mode: "visible", children: y.children },
          E
        ), V = mu(
          V,
          E,
          p,
          null
        ), V.flags |= 2, y.return = d, V.return = d, y.sibling = V, d.child = y, Su(
          d,
          l.child,
          null,
          p
        ), y = d.child, y.memoizedState = _S(p), y.childLanes = TS(
          l,
          I,
          p
        ), d.memoizedState = ES, d = Lp(null, y));
      else if (Ol(d), ck(V)) {
        if (I = V.nextSibling && V.nextSibling.dataset, I) var Ee = I.dgst;
        I = Ee, y = Error(r(419)), y.stack = "", y.digest = I, _p({ value: y, source: null, stack: null }), d = MS(
          l,
          d,
          p
        );
      } else if (vr || Jd(l, d, p, !1), I = (p & l.childLanes) !== 0, vr || I) {
        if (I = En, I !== null && (y = ar(I, p), y !== 0 && y !== te.retryLane))
          throw te.retryLane = y, dn(l, y), Wi(I, l, y), kS;
        lk(V) || pv(), d = MS(
          l,
          d,
          p
        );
      } else
        lk(V) ? (d.flags |= 192, d.child = l.child, d = null) : (l = te.treeContext, Bn = Ro(
          V.nextSibling
        ), Yr = d, tn = !0, _l = null, Mo = !1, l !== null && AR(d, l), d = AS(
          d,
          y.children
        ), d.flags |= 4096);
      return d;
    }
    return E ? (Pl(), V = y.fallback, E = d.mode, te = l.child, Ee = te.sibling, y = ka(te, {
      mode: "hidden",
      children: y.children
    }), y.subtreeFlags = te.subtreeFlags & 65011712, Ee !== null ? V = ka(
      Ee,
      V
    ) : (V = mu(
      V,
      E,
      p,
      null
    ), V.flags |= 2), V.return = d, y.return = d, y.sibling = V, d.child = y, Lp(null, y), y = d.child, V = l.child.memoizedState, V === null ? V = _S(p) : (E = V.cachePool, E !== null ? (te = gr._currentValue, E = E.parent !== te ? { parent: te, pool: te } : E) : E = DR(), V = {
      baseLanes: V.baseLanes | p,
      cachePool: E
    }), y.memoizedState = V, y.childLanes = TS(
      l,
      I,
      p
    ), d.memoizedState = ES, Lp(l.child, y)) : (Ol(d), p = l.child, l = p.sibling, p = ka(p, {
      mode: "visible",
      children: y.children
    }), p.return = d, p.sibling = null, l !== null && (I = d.deletions, I === null ? (d.deletions = [l], d.flags |= 16) : I.push(l)), d.child = p, d.memoizedState = null, p);
  }
  function AS(l, d) {
    return d = ov(
      { mode: "visible", children: d },
      l.mode
    ), d.return = l, l.child = d;
  }
  function ov(l, d) {
    return l = ro(22, l, null, d), l.lanes = 0, l;
  }
  function MS(l, d, p) {
    return Su(d, l.child, null, p), l = AS(
      d,
      d.pendingProps.children
    ), l.flags |= 2, d.memoizedState = null, l;
  }
  function G2(l, d, p) {
    l.lanes |= d;
    var y = l.alternate;
    y !== null && (y.lanes |= d), H1(l.return, d, p);
  }
  function NS(l, d, p, y, E, T) {
    var I = l.memoizedState;
    I === null ? l.memoizedState = {
      isBackwards: d,
      rendering: null,
      renderingStartTime: 0,
      last: y,
      tail: p,
      tailMode: E,
      treeForkCount: T
    } : (I.isBackwards = d, I.rendering = null, I.renderingStartTime = 0, I.last = y, I.tail = p, I.tailMode = E, I.treeForkCount = T);
  }
  function K2(l, d, p) {
    var y = d.pendingProps, E = y.revealOrder, T = y.tail;
    y = y.children;
    var I = ur.current, V = (I & 2) !== 0;
    if (V ? (I = I & 1 | 2, d.flags |= 128) : I &= 1, F(ur, I), Jr(l, d, y, p), y = tn ? Ep : 0, !V && l !== null && (l.flags & 128) !== 0)
      e: for (l = d.child; l !== null; ) {
        if (l.tag === 13)
          l.memoizedState !== null && G2(l, p, d);
        else if (l.tag === 19)
          G2(l, p, d);
        else if (l.child !== null) {
          l.child.return = l, l = l.child;
          continue;
        }
        if (l === d) break e;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === d)
            break e;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    switch (E) {
      case "forwards":
        for (p = d.child, E = null; p !== null; )
          l = p.alternate, l !== null && Gy(l) === null && (E = p), p = p.sibling;
        p = E, p === null ? (E = d.child, d.child = null) : (E = p.sibling, p.sibling = null), NS(
          d,
          !1,
          E,
          p,
          T,
          y
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (p = null, E = d.child, d.child = null; E !== null; ) {
          if (l = E.alternate, l !== null && Gy(l) === null) {
            d.child = E;
            break;
          }
          l = E.sibling, E.sibling = p, p = E, E = l;
        }
        NS(
          d,
          !0,
          p,
          null,
          T,
          y
        );
        break;
      case "together":
        NS(
          d,
          !1,
          null,
          null,
          void 0,
          y
        );
        break;
      default:
        d.memoizedState = null;
    }
    return d.child;
  }
  function Ma(l, d, p) {
    if (l !== null && (d.dependencies = l.dependencies), jl |= d.lanes, (p & d.childLanes) === 0)
      if (l !== null) {
        if (Jd(
          l,
          d,
          p,
          !1
        ), (p & d.childLanes) === 0)
          return null;
      } else return null;
    if (l !== null && d.child !== l.child)
      throw Error(r(153));
    if (d.child !== null) {
      for (l = d.child, p = ka(l, l.pendingProps), d.child = p, p.return = d; l.sibling !== null; )
        l = l.sibling, p = p.sibling = ka(l, l.pendingProps), p.return = d;
      p.sibling = null;
    }
    return d.child;
  }
  function RS(l, d) {
    return (l.lanes & d) !== 0 ? !0 : (l = l.dependencies, !!(l !== null && By(l)));
  }
  function vK(l, d, p) {
    switch (d.tag) {
      case 3:
        xe(d, d.stateNode.containerInfo), Al(d, gr, l.memoizedState.cache), gu();
        break;
      case 27:
      case 5:
        Ae(d);
        break;
      case 4:
        xe(d, d.stateNode.containerInfo);
        break;
      case 10:
        Al(
          d,
          d.type,
          d.memoizedProps.value
        );
        break;
      case 31:
        if (d.memoizedState !== null)
          return d.flags |= 128, nS(d), null;
        break;
      case 13:
        var y = d.memoizedState;
        if (y !== null)
          return y.dehydrated !== null ? (Ol(d), d.flags |= 128, null) : (p & d.child.childLanes) !== 0 ? q2(l, d, p) : (Ol(d), l = Ma(
            l,
            d,
            p
          ), l !== null ? l.sibling : null);
        Ol(d);
        break;
      case 19:
        var E = (l.flags & 128) !== 0;
        if (y = (p & d.childLanes) !== 0, y || (Jd(
          l,
          d,
          p,
          !1
        ), y = (p & d.childLanes) !== 0), E) {
          if (y)
            return K2(
              l,
              d,
              p
            );
          d.flags |= 128;
        }
        if (E = d.memoizedState, E !== null && (E.rendering = null, E.tail = null, E.lastEffect = null), F(ur, ur.current), y) break;
        return null;
      case 22:
        return d.lanes = 0, $2(
          l,
          d,
          p,
          d.pendingProps
        );
      case 24:
        Al(d, gr, l.memoizedState.cache);
    }
    return Ma(l, d, p);
  }
  function Z2(l, d, p) {
    if (l !== null)
      if (l.memoizedProps !== d.pendingProps)
        vr = !0;
      else {
        if (!RS(l, p) && (d.flags & 128) === 0)
          return vr = !1, vK(
            l,
            d,
            p
          );
        vr = (l.flags & 131072) !== 0;
      }
    else
      vr = !1, tn && (d.flags & 1048576) !== 0 && TR(d, Ep, d.index);
    switch (d.lanes = 0, d.tag) {
      case 16:
        e: {
          var y = d.pendingProps;
          if (l = xu(d.elementType), d.type = l, typeof l == "function")
            j1(l) ? (y = Cu(l, y), d.tag = 1, d = H2(
              null,
              d,
              l,
              y,
              p
            )) : (d.tag = 0, d = CS(
              null,
              d,
              l,
              y,
              p
            ));
          else {
            if (l != null) {
              var E = l.$$typeof;
              if (E === N) {
                d.tag = 11, d = z2(
                  null,
                  d,
                  l,
                  y,
                  p
                );
                break e;
              } else if (E === O) {
                d.tag = 14, d = L2(
                  null,
                  d,
                  l,
                  y,
                  p
                );
                break e;
              }
            }
            throw d = ie(l) || l, Error(r(306, d, ""));
          }
        }
        return d;
      case 0:
        return CS(
          l,
          d,
          d.type,
          d.pendingProps,
          p
        );
      case 1:
        return y = d.type, E = Cu(
          y,
          d.pendingProps
        ), H2(
          l,
          d,
          y,
          E,
          p
        );
      case 3:
        e: {
          if (xe(
            d,
            d.stateNode.containerInfo
          ), l === null) throw Error(r(387));
          y = d.pendingProps;
          var T = d.memoizedState;
          E = T.element, X1(l, d), Pp(d, y, null, p);
          var I = d.memoizedState;
          if (y = I.cache, Al(d, gr, y), y !== T.cache && W1(
            d,
            [gr],
            p,
            !0
          ), Op(), y = I.element, T.isDehydrated)
            if (T = {
              element: y,
              isDehydrated: !1,
              cache: I.cache
            }, d.updateQueue.baseState = T, d.memoizedState = T, d.flags & 256) {
              d = W2(
                l,
                d,
                y,
                p
              );
              break e;
            } else if (y !== E) {
              E = _o(
                Error(r(424)),
                d
              ), _p(E), d = W2(
                l,
                d,
                y,
                p
              );
              break e;
            } else
              for (l = d.stateNode.containerInfo, l.nodeType === 9 ? l = l.body : l = l.nodeName === "HTML" ? l.ownerDocument.body : l, Bn = Ro(l.firstChild), Yr = d, tn = !0, _l = null, Mo = !0, p = $R(
                d,
                null,
                y,
                p
              ), d.child = p; p; )
                p.flags = p.flags & -3 | 4096, p = p.sibling;
          else {
            if (gu(), y === E) {
              d = Ma(
                l,
                d,
                p
              );
              break e;
            }
            Jr(l, d, y, p);
          }
          d = d.child;
        }
        return d;
      case 26:
        return iv(l, d), l === null ? (p = sP(
          d.type,
          null,
          d.pendingProps,
          null
        )) ? d.memoizedState = p : tn || (p = d.type, l = d.pendingProps, y = wv(
          re.current
        ).createElement(p), y[Rn] = d, y[lr] = l, Qr(y, p, l), cr(y), d.stateNode = y) : d.memoizedState = sP(
          d.type,
          l.memoizedProps,
          d.pendingProps,
          l.memoizedState
        ), null;
      case 27:
        return Ae(d), l === null && tn && (y = d.stateNode = rP(
          d.type,
          d.pendingProps,
          re.current
        ), Yr = d, Mo = !0, E = Bn, Ul(d.type) ? (uk = E, Bn = Ro(y.firstChild)) : Bn = E), Jr(
          l,
          d,
          d.pendingProps.children,
          p
        ), iv(l, d), l === null && (d.flags |= 4194304), d.child;
      case 5:
        return l === null && tn && ((E = y = Bn) && (y = KK(
          y,
          d.type,
          d.pendingProps,
          Mo
        ), y !== null ? (d.stateNode = y, Yr = d, Bn = Ro(y.firstChild), Mo = !1, E = !0) : E = !1), E || Tl(d)), Ae(d), E = d.type, T = d.pendingProps, I = l !== null ? l.memoizedProps : null, y = T.children, ok(E, T) ? y = null : I !== null && ok(E, I) && (d.flags |= 32), d.memoizedState !== null && (E = iS(
          l,
          d,
          cK,
          null,
          null,
          p
        ), Qp._currentValue = E), iv(l, d), Jr(l, d, y, p), d.child;
      case 6:
        return l === null && tn && ((l = p = Bn) && (p = ZK(
          p,
          d.pendingProps,
          Mo
        ), p !== null ? (d.stateNode = p, Yr = d, Bn = null, l = !0) : l = !1), l || Tl(d)), null;
      case 13:
        return q2(l, d, p);
      case 4:
        return xe(
          d,
          d.stateNode.containerInfo
        ), y = d.pendingProps, l === null ? d.child = Su(
          d,
          null,
          y,
          p
        ) : Jr(l, d, y, p), d.child;
      case 11:
        return z2(
          l,
          d,
          d.type,
          d.pendingProps,
          p
        );
      case 7:
        return Jr(
          l,
          d,
          d.pendingProps,
          p
        ), d.child;
      case 8:
        return Jr(
          l,
          d,
          d.pendingProps.children,
          p
        ), d.child;
      case 12:
        return Jr(
          l,
          d,
          d.pendingProps.children,
          p
        ), d.child;
      case 10:
        return y = d.pendingProps, Al(d, d.type, y.value), Jr(l, d, y.children, p), d.child;
      case 9:
        return E = d.type._context, y = d.pendingProps.children, vu(d), E = Xr(E), y = y(E), d.flags |= 1, Jr(l, d, y, p), d.child;
      case 14:
        return L2(
          l,
          d,
          d.type,
          d.pendingProps,
          p
        );
      case 15:
        return B2(
          l,
          d,
          d.type,
          d.pendingProps,
          p
        );
      case 19:
        return K2(l, d, p);
      case 31:
        return yK(l, d, p);
      case 22:
        return $2(
          l,
          d,
          p,
          d.pendingProps
        );
      case 24:
        return vu(d), y = Xr(gr), l === null ? (E = K1(), E === null && (E = En, T = q1(), E.pooledCache = T, T.refCount++, T !== null && (E.pooledCacheLanes |= p), E = T), d.memoizedState = { parent: y, cache: E }, Y1(d), Al(d, gr, E)) : ((l.lanes & p) !== 0 && (X1(l, d), Pp(d, null, null, p), Op()), E = l.memoizedState, T = d.memoizedState, E.parent !== y ? (E = { parent: y, cache: y }, d.memoizedState = E, d.lanes === 0 && (d.memoizedState = d.updateQueue.baseState = E), Al(d, gr, y)) : (y = T.cache, Al(d, gr, y), y !== E.cache && W1(
          d,
          [gr],
          p,
          !0
        ))), Jr(
          l,
          d,
          d.pendingProps.children,
          p
        ), d.child;
      case 29:
        throw d.pendingProps;
    }
    throw Error(r(156, d.tag));
  }
  function Na(l) {
    l.flags |= 4;
  }
  function OS(l, d, p, y, E) {
    if ((d = (l.mode & 32) !== 0) && (d = !1), d) {
      if (l.flags |= 16777216, (E & 335544128) === E)
        if (l.stateNode.complete) l.flags |= 8192;
        else if (SO()) l.flags |= 8192;
        else
          throw wu = Vy, Z1;
    } else l.flags &= -16777217;
  }
  function Y2(l, d) {
    if (d.type !== "stylesheet" || (d.state.loading & 4) !== 0)
      l.flags &= -16777217;
    else if (l.flags |= 16777216, !dP(d))
      if (SO()) l.flags |= 8192;
      else
        throw wu = Vy, Z1;
  }
  function sv(l, d) {
    d !== null && (l.flags |= 4), l.flags & 16384 && (d = l.tag !== 22 ? Sy() : 536870912, l.lanes |= d, df |= d);
  }
  function Bp(l, d) {
    if (!tn)
      switch (l.tailMode) {
        case "hidden":
          d = l.tail;
          for (var p = null; d !== null; )
            d.alternate !== null && (p = d), d = d.sibling;
          p === null ? l.tail = null : p.sibling = null;
          break;
        case "collapsed":
          p = l.tail;
          for (var y = null; p !== null; )
            p.alternate !== null && (y = p), p = p.sibling;
          y === null ? d || l.tail === null ? l.tail = null : l.tail.sibling = null : y.sibling = null;
      }
  }
  function $n(l) {
    var d = l.alternate !== null && l.alternate.child === l.child, p = 0, y = 0;
    if (d)
      for (var E = l.child; E !== null; )
        p |= E.lanes | E.childLanes, y |= E.subtreeFlags & 65011712, y |= E.flags & 65011712, E.return = l, E = E.sibling;
    else
      for (E = l.child; E !== null; )
        p |= E.lanes | E.childLanes, y |= E.subtreeFlags, y |= E.flags, E.return = l, E = E.sibling;
    return l.subtreeFlags |= y, l.childLanes = p, d;
  }
  function bK(l, d, p) {
    var y = d.pendingProps;
    switch ($1(d), d.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return $n(d), null;
      case 1:
        return $n(d), null;
      case 3:
        return p = d.stateNode, y = null, l !== null && (y = l.memoizedState.cache), d.memoizedState.cache !== y && (d.flags |= 2048), _a(gr), be(), p.pendingContext && (p.context = p.pendingContext, p.pendingContext = null), (l === null || l.child === null) && (Xd(d) ? Na(d) : l === null || l.memoizedState.isDehydrated && (d.flags & 256) === 0 || (d.flags |= 1024, F1())), $n(d), null;
      case 26:
        var E = d.type, T = d.memoizedState;
        return l === null ? (Na(d), T !== null ? ($n(d), Y2(d, T)) : ($n(d), OS(
          d,
          E,
          null,
          y,
          p
        ))) : T ? T !== l.memoizedState ? (Na(d), $n(d), Y2(d, T)) : ($n(d), d.flags &= -16777217) : (l = l.memoizedProps, l !== y && Na(d), $n(d), OS(
          d,
          E,
          l,
          y,
          p
        )), null;
      case 27:
        if (nt(d), p = re.current, E = d.type, l !== null && d.stateNode != null)
          l.memoizedProps !== y && Na(d);
        else {
          if (!y) {
            if (d.stateNode === null)
              throw Error(r(166));
            return $n(d), null;
          }
          l = ee.current, Xd(d) ? MR(d) : (l = rP(E, y, p), d.stateNode = l, Na(d));
        }
        return $n(d), null;
      case 5:
        if (nt(d), E = d.type, l !== null && d.stateNode != null)
          l.memoizedProps !== y && Na(d);
        else {
          if (!y) {
            if (d.stateNode === null)
              throw Error(r(166));
            return $n(d), null;
          }
          if (T = ee.current, Xd(d))
            MR(d);
          else {
            var I = wv(
              re.current
            );
            switch (T) {
              case 1:
                T = I.createElementNS(
                  "http://www.w3.org/2000/svg",
                  E
                );
                break;
              case 2:
                T = I.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  E
                );
                break;
              default:
                switch (E) {
                  case "svg":
                    T = I.createElementNS(
                      "http://www.w3.org/2000/svg",
                      E
                    );
                    break;
                  case "math":
                    T = I.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      E
                    );
                    break;
                  case "script":
                    T = I.createElement("div"), T.innerHTML = "<script><\/script>", T = T.removeChild(
                      T.firstChild
                    );
                    break;
                  case "select":
                    T = typeof y.is == "string" ? I.createElement("select", {
                      is: y.is
                    }) : I.createElement("select"), y.multiple ? T.multiple = !0 : y.size && (T.size = y.size);
                    break;
                  default:
                    T = typeof y.is == "string" ? I.createElement(E, { is: y.is }) : I.createElement(E);
                }
            }
            T[Rn] = d, T[lr] = y;
            e: for (I = d.child; I !== null; ) {
              if (I.tag === 5 || I.tag === 6)
                T.appendChild(I.stateNode);
              else if (I.tag !== 4 && I.tag !== 27 && I.child !== null) {
                I.child.return = I, I = I.child;
                continue;
              }
              if (I === d) break e;
              for (; I.sibling === null; ) {
                if (I.return === null || I.return === d)
                  break e;
                I = I.return;
              }
              I.sibling.return = I.return, I = I.sibling;
            }
            d.stateNode = T;
            e: switch (Qr(T, E, y), E) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                y = !!y.autoFocus;
                break e;
              case "img":
                y = !0;
                break e;
              default:
                y = !1;
            }
            y && Na(d);
          }
        }
        return $n(d), OS(
          d,
          d.type,
          l === null ? null : l.memoizedProps,
          d.pendingProps,
          p
        ), null;
      case 6:
        if (l && d.stateNode != null)
          l.memoizedProps !== y && Na(d);
        else {
          if (typeof y != "string" && d.stateNode === null)
            throw Error(r(166));
          if (l = re.current, Xd(d)) {
            if (l = d.stateNode, p = d.memoizedProps, y = null, E = Yr, E !== null)
              switch (E.tag) {
                case 27:
                case 5:
                  y = E.memoizedProps;
              }
            l[Rn] = d, l = !!(l.nodeValue === p || y !== null && y.suppressHydrationWarning === !0 || qO(l.nodeValue, p)), l || Tl(d, !0);
          } else
            l = wv(l).createTextNode(
              y
            ), l[Rn] = d, d.stateNode = l;
        }
        return $n(d), null;
      case 31:
        if (p = d.memoizedState, l === null || l.memoizedState !== null) {
          if (y = Xd(d), p !== null) {
            if (l === null) {
              if (!y) throw Error(r(318));
              if (l = d.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(557));
              l[Rn] = d;
            } else
              gu(), (d.flags & 128) === 0 && (d.memoizedState = null), d.flags |= 4;
            $n(d), l = !1;
          } else
            p = F1(), l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = p), l = !0;
          if (!l)
            return d.flags & 256 ? (oo(d), d) : (oo(d), null);
          if ((d.flags & 128) !== 0)
            throw Error(r(558));
        }
        return $n(d), null;
      case 13:
        if (y = d.memoizedState, l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) {
          if (E = Xd(d), y !== null && y.dehydrated !== null) {
            if (l === null) {
              if (!E) throw Error(r(318));
              if (E = d.memoizedState, E = E !== null ? E.dehydrated : null, !E) throw Error(r(317));
              E[Rn] = d;
            } else
              gu(), (d.flags & 128) === 0 && (d.memoizedState = null), d.flags |= 4;
            $n(d), E = !1;
          } else
            E = F1(), l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = E), E = !0;
          if (!E)
            return d.flags & 256 ? (oo(d), d) : (oo(d), null);
        }
        return oo(d), (d.flags & 128) !== 0 ? (d.lanes = p, d) : (p = y !== null, l = l !== null && l.memoizedState !== null, p && (y = d.child, E = null, y.alternate !== null && y.alternate.memoizedState !== null && y.alternate.memoizedState.cachePool !== null && (E = y.alternate.memoizedState.cachePool.pool), T = null, y.memoizedState !== null && y.memoizedState.cachePool !== null && (T = y.memoizedState.cachePool.pool), T !== E && (y.flags |= 2048)), p !== l && p && (d.child.flags |= 8192), sv(d, d.updateQueue), $n(d), null);
      case 4:
        return be(), l === null && ek(d.stateNode.containerInfo), $n(d), null;
      case 10:
        return _a(d.type), $n(d), null;
      case 19:
        if (pe(ur), y = d.memoizedState, y === null) return $n(d), null;
        if (E = (d.flags & 128) !== 0, T = y.rendering, T === null)
          if (E) Bp(y, !1);
          else {
            if (er !== 0 || l !== null && (l.flags & 128) !== 0)
              for (l = d.child; l !== null; ) {
                if (T = Gy(l), T !== null) {
                  for (d.flags |= 128, Bp(y, !1), l = T.updateQueue, d.updateQueue = l, sv(d, l), d.subtreeFlags = 0, l = p, p = d.child; p !== null; )
                    CR(p, l), p = p.sibling;
                  return F(
                    ur,
                    ur.current & 1 | 2
                  ), tn && Ca(d, y.treeForkCount), d.child;
                }
                l = l.sibling;
              }
            y.tail !== null && Nn() > dv && (d.flags |= 128, E = !0, Bp(y, !1), d.lanes = 4194304);
          }
        else {
          if (!E)
            if (l = Gy(T), l !== null) {
              if (d.flags |= 128, E = !0, l = l.updateQueue, d.updateQueue = l, sv(d, l), Bp(y, !0), y.tail === null && y.tailMode === "hidden" && !T.alternate && !tn)
                return $n(d), null;
            } else
              2 * Nn() - y.renderingStartTime > dv && p !== 536870912 && (d.flags |= 128, E = !0, Bp(y, !1), d.lanes = 4194304);
          y.isBackwards ? (T.sibling = d.child, d.child = T) : (l = y.last, l !== null ? l.sibling = T : d.child = T, y.last = T);
        }
        return y.tail !== null ? (l = y.tail, y.rendering = l, y.tail = l.sibling, y.renderingStartTime = Nn(), l.sibling = null, p = ur.current, F(
          ur,
          E ? p & 1 | 2 : p & 1
        ), tn && Ca(d, y.treeForkCount), l) : ($n(d), null);
      case 22:
      case 23:
        return oo(d), tS(), y = d.memoizedState !== null, l !== null ? l.memoizedState !== null !== y && (d.flags |= 8192) : y && (d.flags |= 8192), y ? (p & 536870912) !== 0 && (d.flags & 128) === 0 && ($n(d), d.subtreeFlags & 6 && (d.flags |= 8192)) : $n(d), p = d.updateQueue, p !== null && sv(d, p.retryQueue), p = null, l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (p = l.memoizedState.cachePool.pool), y = null, d.memoizedState !== null && d.memoizedState.cachePool !== null && (y = d.memoizedState.cachePool.pool), y !== p && (d.flags |= 2048), l !== null && pe(bu), null;
      case 24:
        return p = null, l !== null && (p = l.memoizedState.cache), d.memoizedState.cache !== p && (d.flags |= 2048), _a(gr), $n(d), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(r(156, d.tag));
  }
  function xK(l, d) {
    switch ($1(d), d.tag) {
      case 1:
        return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
      case 3:
        return _a(gr), be(), l = d.flags, (l & 65536) !== 0 && (l & 128) === 0 ? (d.flags = l & -65537 | 128, d) : null;
      case 26:
      case 27:
      case 5:
        return nt(d), null;
      case 31:
        if (d.memoizedState !== null) {
          if (oo(d), d.alternate === null)
            throw Error(r(340));
          gu();
        }
        return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
      case 13:
        if (oo(d), l = d.memoizedState, l !== null && l.dehydrated !== null) {
          if (d.alternate === null)
            throw Error(r(340));
          gu();
        }
        return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
      case 19:
        return pe(ur), null;
      case 4:
        return be(), null;
      case 10:
        return _a(d.type), null;
      case 22:
      case 23:
        return oo(d), tS(), l !== null && pe(bu), l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
      case 24:
        return _a(gr), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function X2(l, d) {
    switch ($1(d), d.tag) {
      case 3:
        _a(gr), be();
        break;
      case 26:
      case 27:
      case 5:
        nt(d);
        break;
      case 4:
        be();
        break;
      case 31:
        d.memoizedState !== null && oo(d);
        break;
      case 13:
        oo(d);
        break;
      case 19:
        pe(ur);
        break;
      case 10:
        _a(d.type);
        break;
      case 22:
      case 23:
        oo(d), tS(), l !== null && pe(bu);
        break;
      case 24:
        _a(gr);
    }
  }
  function $p(l, d) {
    try {
      var p = d.updateQueue, y = p !== null ? p.lastEffect : null;
      if (y !== null) {
        var E = y.next;
        p = E;
        do {
          if ((p.tag & l) === l) {
            y = void 0;
            var T = p.create, I = p.inst;
            y = T(), I.destroy = y;
          }
          p = p.next;
        } while (p !== E);
      }
    } catch (V) {
      mn(d, d.return, V);
    }
  }
  function Dl(l, d, p) {
    try {
      var y = d.updateQueue, E = y !== null ? y.lastEffect : null;
      if (E !== null) {
        var T = E.next;
        y = T;
        do {
          if ((y.tag & l) === l) {
            var I = y.inst, V = I.destroy;
            if (V !== void 0) {
              I.destroy = void 0, E = d;
              var te = p, Ee = V;
              try {
                Ee();
              } catch (Oe) {
                mn(
                  E,
                  te,
                  Oe
                );
              }
            }
          }
          y = y.next;
        } while (y !== T);
      }
    } catch (Oe) {
      mn(d, d.return, Oe);
    }
  }
  function J2(l) {
    var d = l.updateQueue;
    if (d !== null) {
      var p = l.stateNode;
      try {
        FR(d, p);
      } catch (y) {
        mn(l, l.return, y);
      }
    }
  }
  function Q2(l, d, p) {
    p.props = Cu(
      l.type,
      l.memoizedProps
    ), p.state = l.memoizedState;
    try {
      p.componentWillUnmount();
    } catch (y) {
      mn(l, d, y);
    }
  }
  function Up(l, d) {
    try {
      var p = l.ref;
      if (p !== null) {
        switch (l.tag) {
          case 26:
          case 27:
          case 5:
            var y = l.stateNode;
            break;
          case 30:
            y = l.stateNode;
            break;
          default:
            y = l.stateNode;
        }
        typeof p == "function" ? l.refCleanup = p(y) : p.current = y;
      }
    } catch (E) {
      mn(l, d, E);
    }
  }
  function Ds(l, d) {
    var p = l.ref, y = l.refCleanup;
    if (p !== null)
      if (typeof y == "function")
        try {
          y();
        } catch (E) {
          mn(l, d, E);
        } finally {
          l.refCleanup = null, l = l.alternate, l != null && (l.refCleanup = null);
        }
      else if (typeof p == "function")
        try {
          p(null);
        } catch (E) {
          mn(l, d, E);
        }
      else p.current = null;
  }
  function eO(l) {
    var d = l.type, p = l.memoizedProps, y = l.stateNode;
    try {
      e: switch (d) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          p.autoFocus && y.focus();
          break e;
        case "img":
          p.src ? y.src = p.src : p.srcSet && (y.srcset = p.srcSet);
      }
    } catch (E) {
      mn(l, l.return, E);
    }
  }
  function PS(l, d, p) {
    try {
      var y = l.stateNode;
      FK(y, l.type, p, d), y[lr] = d;
    } catch (E) {
      mn(l, l.return, E);
    }
  }
  function tO(l) {
    return l.tag === 5 || l.tag === 3 || l.tag === 26 || l.tag === 27 && Ul(l.type) || l.tag === 4;
  }
  function DS(l) {
    e: for (; ; ) {
      for (; l.sibling === null; ) {
        if (l.return === null || tO(l.return)) return null;
        l = l.return;
      }
      for (l.sibling.return = l.return, l = l.sibling; l.tag !== 5 && l.tag !== 6 && l.tag !== 18; ) {
        if (l.tag === 27 && Ul(l.type) || l.flags & 2 || l.child === null || l.tag === 4) continue e;
        l.child.return = l, l = l.child;
      }
      if (!(l.flags & 2)) return l.stateNode;
    }
  }
  function IS(l, d, p) {
    var y = l.tag;
    if (y === 5 || y === 6)
      l = l.stateNode, d ? (p.nodeType === 9 ? p.body : p.nodeName === "HTML" ? p.ownerDocument.body : p).insertBefore(l, d) : (d = p.nodeType === 9 ? p.body : p.nodeName === "HTML" ? p.ownerDocument.body : p, d.appendChild(l), p = p._reactRootContainer, p != null || d.onclick !== null || (d.onclick = $i));
    else if (y !== 4 && (y === 27 && Ul(l.type) && (p = l.stateNode, d = null), l = l.child, l !== null))
      for (IS(l, d, p), l = l.sibling; l !== null; )
        IS(l, d, p), l = l.sibling;
  }
  function av(l, d, p) {
    var y = l.tag;
    if (y === 5 || y === 6)
      l = l.stateNode, d ? p.insertBefore(l, d) : p.appendChild(l);
    else if (y !== 4 && (y === 27 && Ul(l.type) && (p = l.stateNode), l = l.child, l !== null))
      for (av(l, d, p), l = l.sibling; l !== null; )
        av(l, d, p), l = l.sibling;
  }
  function nO(l) {
    var d = l.stateNode, p = l.memoizedProps;
    try {
      for (var y = l.type, E = d.attributes; E.length; )
        d.removeAttributeNode(E[0]);
      Qr(d, y, p), d[Rn] = l, d[lr] = p;
    } catch (T) {
      mn(l, l.return, T);
    }
  }
  var Ra = !1, br = !1, jS = !1, rO = typeof WeakSet == "function" ? WeakSet : Set, $r = null;
  function wK(l, d) {
    if (l = l.containerInfo, rk = Av, l = z(l), $(l)) {
      if ("selectionStart" in l)
        var p = {
          start: l.selectionStart,
          end: l.selectionEnd
        };
      else
        e: {
          p = (p = l.ownerDocument) && p.defaultView || window;
          var y = p.getSelection && p.getSelection();
          if (y && y.rangeCount !== 0) {
            p = y.anchorNode;
            var E = y.anchorOffset, T = y.focusNode;
            y = y.focusOffset;
            try {
              p.nodeType, T.nodeType;
            } catch {
              p = null;
              break e;
            }
            var I = 0, V = -1, te = -1, Ee = 0, Oe = 0, je = l, Te = null;
            t: for (; ; ) {
              for (var Me; je !== p || E !== 0 && je.nodeType !== 3 || (V = I + E), je !== T || y !== 0 && je.nodeType !== 3 || (te = I + y), je.nodeType === 3 && (I += je.nodeValue.length), (Me = je.firstChild) !== null; )
                Te = je, je = Me;
              for (; ; ) {
                if (je === l) break t;
                if (Te === p && ++Ee === E && (V = I), Te === T && ++Oe === y && (te = I), (Me = je.nextSibling) !== null) break;
                je = Te, Te = je.parentNode;
              }
              je = Me;
            }
            p = V === -1 || te === -1 ? null : { start: V, end: te };
          } else p = null;
        }
      p = p || { start: 0, end: 0 };
    } else p = null;
    for (ik = { focusedElem: l, selectionRange: p }, Av = !1, $r = d; $r !== null; )
      if (d = $r, l = d.child, (d.subtreeFlags & 1028) !== 0 && l !== null)
        l.return = d, $r = l;
      else
        for (; $r !== null; ) {
          switch (d = $r, T = d.alternate, l = d.flags, d.tag) {
            case 0:
              if ((l & 4) !== 0 && (l = d.updateQueue, l = l !== null ? l.events : null, l !== null))
                for (p = 0; p < l.length; p++)
                  E = l[p], E.ref.impl = E.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((l & 1024) !== 0 && T !== null) {
                l = void 0, p = d, E = T.memoizedProps, T = T.memoizedState, y = p.stateNode;
                try {
                  var it = Cu(
                    p.type,
                    E
                  );
                  l = y.getSnapshotBeforeUpdate(
                    it,
                    T
                  ), y.__reactInternalSnapshotBeforeUpdate = l;
                } catch (bt) {
                  mn(
                    p,
                    p.return,
                    bt
                  );
                }
              }
              break;
            case 3:
              if ((l & 1024) !== 0) {
                if (l = d.stateNode.containerInfo, p = l.nodeType, p === 9)
                  ak(l);
                else if (p === 1)
                  switch (l.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      ak(l);
                      break;
                    default:
                      l.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((l & 1024) !== 0) throw Error(r(163));
          }
          if (l = d.sibling, l !== null) {
            l.return = d.return, $r = l;
            break;
          }
          $r = d.return;
        }
  }
  function iO(l, d, p) {
    var y = p.flags;
    switch (p.tag) {
      case 0:
      case 11:
      case 15:
        Pa(l, p), y & 4 && $p(5, p);
        break;
      case 1:
        if (Pa(l, p), y & 4)
          if (l = p.stateNode, d === null)
            try {
              l.componentDidMount();
            } catch (I) {
              mn(p, p.return, I);
            }
          else {
            var E = Cu(
              p.type,
              d.memoizedProps
            );
            d = d.memoizedState;
            try {
              l.componentDidUpdate(
                E,
                d,
                l.__reactInternalSnapshotBeforeUpdate
              );
            } catch (I) {
              mn(
                p,
                p.return,
                I
              );
            }
          }
        y & 64 && J2(p), y & 512 && Up(p, p.return);
        break;
      case 3:
        if (Pa(l, p), y & 64 && (l = p.updateQueue, l !== null)) {
          if (d = null, p.child !== null)
            switch (p.child.tag) {
              case 27:
              case 5:
                d = p.child.stateNode;
                break;
              case 1:
                d = p.child.stateNode;
            }
          try {
            FR(l, d);
          } catch (I) {
            mn(p, p.return, I);
          }
        }
        break;
      case 27:
        d === null && y & 4 && nO(p);
      case 26:
      case 5:
        Pa(l, p), d === null && y & 4 && eO(p), y & 512 && Up(p, p.return);
        break;
      case 12:
        Pa(l, p);
        break;
      case 31:
        Pa(l, p), y & 4 && aO(l, p);
        break;
      case 13:
        Pa(l, p), y & 4 && lO(l, p), y & 64 && (l = p.memoizedState, l !== null && (l = l.dehydrated, l !== null && (p = NK.bind(
          null,
          p
        ), YK(l, p))));
        break;
      case 22:
        if (y = p.memoizedState !== null || Ra, !y) {
          d = d !== null && d.memoizedState !== null || br, E = Ra;
          var T = br;
          Ra = y, (br = d) && !T ? Da(
            l,
            p,
            (p.subtreeFlags & 8772) !== 0
          ) : Pa(l, p), Ra = E, br = T;
        }
        break;
      case 30:
        break;
      default:
        Pa(l, p);
    }
  }
  function oO(l) {
    var d = l.alternate;
    d !== null && (l.alternate = null, oO(d)), l.child = null, l.deletions = null, l.sibling = null, l.tag === 5 && (d = l.stateNode, d !== null && Ad(d)), l.stateNode = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
  }
  var qn = null, Ui = !1;
  function Oa(l, d, p) {
    for (p = p.child; p !== null; )
      sO(l, d, p), p = p.sibling;
  }
  function sO(l, d, p) {
    if (on && typeof on.onCommitFiberUnmount == "function")
      try {
        on.onCommitFiberUnmount(Bt, p);
      } catch {
      }
    switch (p.tag) {
      case 26:
        br || Ds(p, d), Oa(
          l,
          d,
          p
        ), p.memoizedState ? p.memoizedState.count-- : p.stateNode && (p = p.stateNode, p.parentNode.removeChild(p));
        break;
      case 27:
        br || Ds(p, d);
        var y = qn, E = Ui;
        Ul(p.type) && (qn = p.stateNode, Ui = !1), Oa(
          l,
          d,
          p
        ), Yp(p.stateNode), qn = y, Ui = E;
        break;
      case 5:
        br || Ds(p, d);
      case 6:
        if (y = qn, E = Ui, qn = null, Oa(
          l,
          d,
          p
        ), qn = y, Ui = E, qn !== null)
          if (Ui)
            try {
              (qn.nodeType === 9 ? qn.body : qn.nodeName === "HTML" ? qn.ownerDocument.body : qn).removeChild(p.stateNode);
            } catch (T) {
              mn(
                p,
                d,
                T
              );
            }
          else
            try {
              qn.removeChild(p.stateNode);
            } catch (T) {
              mn(
                p,
                d,
                T
              );
            }
        break;
      case 18:
        qn !== null && (Ui ? (l = qn, JO(
          l.nodeType === 9 ? l.body : l.nodeName === "HTML" ? l.ownerDocument.body : l,
          p.stateNode
        ), bf(l)) : JO(qn, p.stateNode));
        break;
      case 4:
        y = qn, E = Ui, qn = p.stateNode.containerInfo, Ui = !0, Oa(
          l,
          d,
          p
        ), qn = y, Ui = E;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Dl(2, p, d), br || Dl(4, p, d), Oa(
          l,
          d,
          p
        );
        break;
      case 1:
        br || (Ds(p, d), y = p.stateNode, typeof y.componentWillUnmount == "function" && Q2(
          p,
          d,
          y
        )), Oa(
          l,
          d,
          p
        );
        break;
      case 21:
        Oa(
          l,
          d,
          p
        );
        break;
      case 22:
        br = (y = br) || p.memoizedState !== null, Oa(
          l,
          d,
          p
        ), br = y;
        break;
      default:
        Oa(
          l,
          d,
          p
        );
    }
  }
  function aO(l, d) {
    if (d.memoizedState === null && (l = d.alternate, l !== null && (l = l.memoizedState, l !== null))) {
      l = l.dehydrated;
      try {
        bf(l);
      } catch (p) {
        mn(d, d.return, p);
      }
    }
  }
  function lO(l, d) {
    if (d.memoizedState === null && (l = d.alternate, l !== null && (l = l.memoizedState, l !== null && (l = l.dehydrated, l !== null))))
      try {
        bf(l);
      } catch (p) {
        mn(d, d.return, p);
      }
  }
  function SK(l) {
    switch (l.tag) {
      case 31:
      case 13:
      case 19:
        var d = l.stateNode;
        return d === null && (d = l.stateNode = new rO()), d;
      case 22:
        return l = l.stateNode, d = l._retryCache, d === null && (d = l._retryCache = new rO()), d;
      default:
        throw Error(r(435, l.tag));
    }
  }
  function lv(l, d) {
    var p = SK(l);
    d.forEach(function(y) {
      if (!p.has(y)) {
        p.add(y);
        var E = RK.bind(null, l, y);
        y.then(E, E);
      }
    });
  }
  function Fi(l, d) {
    var p = d.deletions;
    if (p !== null)
      for (var y = 0; y < p.length; y++) {
        var E = p[y], T = l, I = d, V = I;
        e: for (; V !== null; ) {
          switch (V.tag) {
            case 27:
              if (Ul(V.type)) {
                qn = V.stateNode, Ui = !1;
                break e;
              }
              break;
            case 5:
              qn = V.stateNode, Ui = !1;
              break e;
            case 3:
            case 4:
              qn = V.stateNode.containerInfo, Ui = !0;
              break e;
          }
          V = V.return;
        }
        if (qn === null) throw Error(r(160));
        sO(T, I, E), qn = null, Ui = !1, T = E.alternate, T !== null && (T.return = null), E.return = null;
      }
    if (d.subtreeFlags & 13886)
      for (d = d.child; d !== null; )
        cO(d, l), d = d.sibling;
  }
  var ns = null;
  function cO(l, d) {
    var p = l.alternate, y = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Fi(d, l), Vi(l), y & 4 && (Dl(3, l, l.return), $p(3, l), Dl(5, l, l.return));
        break;
      case 1:
        Fi(d, l), Vi(l), y & 512 && (br || p === null || Ds(p, p.return)), y & 64 && Ra && (l = l.updateQueue, l !== null && (y = l.callbacks, y !== null && (p = l.shared.hiddenCallbacks, l.shared.hiddenCallbacks = p === null ? y : p.concat(y))));
        break;
      case 26:
        var E = ns;
        if (Fi(d, l), Vi(l), y & 512 && (br || p === null || Ds(p, p.return)), y & 4) {
          var T = p !== null ? p.memoizedState : null;
          if (y = l.memoizedState, p === null)
            if (y === null)
              if (l.stateNode === null) {
                e: {
                  y = l.type, p = l.memoizedProps, E = E.ownerDocument || E;
                  t: switch (y) {
                    case "title":
                      T = E.getElementsByTagName("title")[0], (!T || T[eo] || T[Rn] || T.namespaceURI === "http://www.w3.org/2000/svg" || T.hasAttribute("itemprop")) && (T = E.createElement(y), E.head.insertBefore(
                        T,
                        E.querySelector("head > title")
                      )), Qr(T, y, p), T[Rn] = l, cr(T), y = T;
                      break e;
                    case "link":
                      var I = cP(
                        "link",
                        "href",
                        E
                      ).get(y + (p.href || ""));
                      if (I) {
                        for (var V = 0; V < I.length; V++)
                          if (T = I[V], T.getAttribute("href") === (p.href == null || p.href === "" ? null : p.href) && T.getAttribute("rel") === (p.rel == null ? null : p.rel) && T.getAttribute("title") === (p.title == null ? null : p.title) && T.getAttribute("crossorigin") === (p.crossOrigin == null ? null : p.crossOrigin)) {
                            I.splice(V, 1);
                            break t;
                          }
                      }
                      T = E.createElement(y), Qr(T, y, p), E.head.appendChild(T);
                      break;
                    case "meta":
                      if (I = cP(
                        "meta",
                        "content",
                        E
                      ).get(y + (p.content || ""))) {
                        for (V = 0; V < I.length; V++)
                          if (T = I[V], T.getAttribute("content") === (p.content == null ? null : "" + p.content) && T.getAttribute("name") === (p.name == null ? null : p.name) && T.getAttribute("property") === (p.property == null ? null : p.property) && T.getAttribute("http-equiv") === (p.httpEquiv == null ? null : p.httpEquiv) && T.getAttribute("charset") === (p.charSet == null ? null : p.charSet)) {
                            I.splice(V, 1);
                            break t;
                          }
                      }
                      T = E.createElement(y), Qr(T, y, p), E.head.appendChild(T);
                      break;
                    default:
                      throw Error(r(468, y));
                  }
                  T[Rn] = l, cr(T), y = T;
                }
                l.stateNode = y;
              } else
                uP(
                  E,
                  l.type,
                  l.stateNode
                );
            else
              l.stateNode = lP(
                E,
                y,
                l.memoizedProps
              );
          else
            T !== y ? (T === null ? p.stateNode !== null && (p = p.stateNode, p.parentNode.removeChild(p)) : T.count--, y === null ? uP(
              E,
              l.type,
              l.stateNode
            ) : lP(
              E,
              y,
              l.memoizedProps
            )) : y === null && l.stateNode !== null && PS(
              l,
              l.memoizedProps,
              p.memoizedProps
            );
        }
        break;
      case 27:
        Fi(d, l), Vi(l), y & 512 && (br || p === null || Ds(p, p.return)), p !== null && y & 4 && PS(
          l,
          l.memoizedProps,
          p.memoizedProps
        );
        break;
      case 5:
        if (Fi(d, l), Vi(l), y & 512 && (br || p === null || Ds(p, p.return)), l.flags & 32) {
          E = l.stateNode;
          try {
            ha(E, "");
          } catch (it) {
            mn(l, l.return, it);
          }
        }
        y & 4 && l.stateNode != null && (E = l.memoizedProps, PS(
          l,
          E,
          p !== null ? p.memoizedProps : E
        )), y & 1024 && (jS = !0);
        break;
      case 6:
        if (Fi(d, l), Vi(l), y & 4) {
          if (l.stateNode === null)
            throw Error(r(162));
          y = l.memoizedProps, p = l.stateNode;
          try {
            p.nodeValue = y;
          } catch (it) {
            mn(l, l.return, it);
          }
        }
        break;
      case 3:
        if (Cv = null, E = ns, ns = Sv(d.containerInfo), Fi(d, l), ns = E, Vi(l), y & 4 && p !== null && p.memoizedState.isDehydrated)
          try {
            bf(d.containerInfo);
          } catch (it) {
            mn(l, l.return, it);
          }
        jS && (jS = !1, uO(l));
        break;
      case 4:
        y = ns, ns = Sv(
          l.stateNode.containerInfo
        ), Fi(d, l), Vi(l), ns = y;
        break;
      case 12:
        Fi(d, l), Vi(l);
        break;
      case 31:
        Fi(d, l), Vi(l), y & 4 && (y = l.updateQueue, y !== null && (l.updateQueue = null, lv(l, y)));
        break;
      case 13:
        Fi(d, l), Vi(l), l.child.flags & 8192 && l.memoizedState !== null != (p !== null && p.memoizedState !== null) && (uv = Nn()), y & 4 && (y = l.updateQueue, y !== null && (l.updateQueue = null, lv(l, y)));
        break;
      case 22:
        E = l.memoizedState !== null;
        var te = p !== null && p.memoizedState !== null, Ee = Ra, Oe = br;
        if (Ra = Ee || E, br = Oe || te, Fi(d, l), br = Oe, Ra = Ee, Vi(l), y & 8192)
          e: for (d = l.stateNode, d._visibility = E ? d._visibility & -2 : d._visibility | 1, E && (p === null || te || Ra || br || Eu(l)), p = null, d = l; ; ) {
            if (d.tag === 5 || d.tag === 26) {
              if (p === null) {
                te = p = d;
                try {
                  if (T = te.stateNode, E)
                    I = T.style, typeof I.setProperty == "function" ? I.setProperty("display", "none", "important") : I.display = "none";
                  else {
                    V = te.stateNode;
                    var je = te.memoizedProps.style, Te = je != null && je.hasOwnProperty("display") ? je.display : null;
                    V.style.display = Te == null || typeof Te == "boolean" ? "" : ("" + Te).trim();
                  }
                } catch (it) {
                  mn(te, te.return, it);
                }
              }
            } else if (d.tag === 6) {
              if (p === null) {
                te = d;
                try {
                  te.stateNode.nodeValue = E ? "" : te.memoizedProps;
                } catch (it) {
                  mn(te, te.return, it);
                }
              }
            } else if (d.tag === 18) {
              if (p === null) {
                te = d;
                try {
                  var Me = te.stateNode;
                  E ? QO(Me, !0) : QO(te.stateNode, !1);
                } catch (it) {
                  mn(te, te.return, it);
                }
              }
            } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === l) && d.child !== null) {
              d.child.return = d, d = d.child;
              continue;
            }
            if (d === l) break e;
            for (; d.sibling === null; ) {
              if (d.return === null || d.return === l) break e;
              p === d && (p = null), d = d.return;
            }
            p === d && (p = null), d.sibling.return = d.return, d = d.sibling;
          }
        y & 4 && (y = l.updateQueue, y !== null && (p = y.retryQueue, p !== null && (y.retryQueue = null, lv(l, p))));
        break;
      case 19:
        Fi(d, l), Vi(l), y & 4 && (y = l.updateQueue, y !== null && (l.updateQueue = null, lv(l, y)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Fi(d, l), Vi(l);
    }
  }
  function Vi(l) {
    var d = l.flags;
    if (d & 2) {
      try {
        for (var p, y = l.return; y !== null; ) {
          if (tO(y)) {
            p = y;
            break;
          }
          y = y.return;
        }
        if (p == null) throw Error(r(160));
        switch (p.tag) {
          case 27:
            var E = p.stateNode, T = DS(l);
            av(l, T, E);
            break;
          case 5:
            var I = p.stateNode;
            p.flags & 32 && (ha(I, ""), p.flags &= -33);
            var V = DS(l);
            av(l, V, I);
            break;
          case 3:
          case 4:
            var te = p.stateNode.containerInfo, Ee = DS(l);
            IS(
              l,
              Ee,
              te
            );
            break;
          default:
            throw Error(r(161));
        }
      } catch (Oe) {
        mn(l, l.return, Oe);
      }
      l.flags &= -3;
    }
    d & 4096 && (l.flags &= -4097);
  }
  function uO(l) {
    if (l.subtreeFlags & 1024)
      for (l = l.child; l !== null; ) {
        var d = l;
        uO(d), d.tag === 5 && d.flags & 1024 && d.stateNode.reset(), l = l.sibling;
      }
  }
  function Pa(l, d) {
    if (d.subtreeFlags & 8772)
      for (d = d.child; d !== null; )
        iO(l, d.alternate, d), d = d.sibling;
  }
  function Eu(l) {
    for (l = l.child; l !== null; ) {
      var d = l;
      switch (d.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Dl(4, d, d.return), Eu(d);
          break;
        case 1:
          Ds(d, d.return);
          var p = d.stateNode;
          typeof p.componentWillUnmount == "function" && Q2(
            d,
            d.return,
            p
          ), Eu(d);
          break;
        case 27:
          Yp(d.stateNode);
        case 26:
        case 5:
          Ds(d, d.return), Eu(d);
          break;
        case 22:
          d.memoizedState === null && Eu(d);
          break;
        case 30:
          Eu(d);
          break;
        default:
          Eu(d);
      }
      l = l.sibling;
    }
  }
  function Da(l, d, p) {
    for (p = p && (d.subtreeFlags & 8772) !== 0, d = d.child; d !== null; ) {
      var y = d.alternate, E = l, T = d, I = T.flags;
      switch (T.tag) {
        case 0:
        case 11:
        case 15:
          Da(
            E,
            T,
            p
          ), $p(4, T);
          break;
        case 1:
          if (Da(
            E,
            T,
            p
          ), y = T, E = y.stateNode, typeof E.componentDidMount == "function")
            try {
              E.componentDidMount();
            } catch (Ee) {
              mn(y, y.return, Ee);
            }
          if (y = T, E = y.updateQueue, E !== null) {
            var V = y.stateNode;
            try {
              var te = E.shared.hiddenCallbacks;
              if (te !== null)
                for (E.shared.hiddenCallbacks = null, E = 0; E < te.length; E++)
                  UR(te[E], V);
            } catch (Ee) {
              mn(y, y.return, Ee);
            }
          }
          p && I & 64 && J2(T), Up(T, T.return);
          break;
        case 27:
          nO(T);
        case 26:
        case 5:
          Da(
            E,
            T,
            p
          ), p && y === null && I & 4 && eO(T), Up(T, T.return);
          break;
        case 12:
          Da(
            E,
            T,
            p
          );
          break;
        case 31:
          Da(
            E,
            T,
            p
          ), p && I & 4 && aO(E, T);
          break;
        case 13:
          Da(
            E,
            T,
            p
          ), p && I & 4 && lO(E, T);
          break;
        case 22:
          T.memoizedState === null && Da(
            E,
            T,
            p
          ), Up(T, T.return);
          break;
        case 30:
          break;
        default:
          Da(
            E,
            T,
            p
          );
      }
      d = d.sibling;
    }
  }
  function zS(l, d) {
    var p = null;
    l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (p = l.memoizedState.cachePool.pool), l = null, d.memoizedState !== null && d.memoizedState.cachePool !== null && (l = d.memoizedState.cachePool.pool), l !== p && (l != null && l.refCount++, p != null && Tp(p));
  }
  function LS(l, d) {
    l = null, d.alternate !== null && (l = d.alternate.memoizedState.cache), d = d.memoizedState.cache, d !== l && (d.refCount++, l != null && Tp(l));
  }
  function rs(l, d, p, y) {
    if (d.subtreeFlags & 10256)
      for (d = d.child; d !== null; )
        dO(
          l,
          d,
          p,
          y
        ), d = d.sibling;
  }
  function dO(l, d, p, y) {
    var E = d.flags;
    switch (d.tag) {
      case 0:
      case 11:
      case 15:
        rs(
          l,
          d,
          p,
          y
        ), E & 2048 && $p(9, d);
        break;
      case 1:
        rs(
          l,
          d,
          p,
          y
        );
        break;
      case 3:
        rs(
          l,
          d,
          p,
          y
        ), E & 2048 && (l = null, d.alternate !== null && (l = d.alternate.memoizedState.cache), d = d.memoizedState.cache, d !== l && (d.refCount++, l != null && Tp(l)));
        break;
      case 12:
        if (E & 2048) {
          rs(
            l,
            d,
            p,
            y
          ), l = d.stateNode;
          try {
            var T = d.memoizedProps, I = T.id, V = T.onPostCommit;
            typeof V == "function" && V(
              I,
              d.alternate === null ? "mount" : "update",
              l.passiveEffectDuration,
              -0
            );
          } catch (te) {
            mn(d, d.return, te);
          }
        } else
          rs(
            l,
            d,
            p,
            y
          );
        break;
      case 31:
        rs(
          l,
          d,
          p,
          y
        );
        break;
      case 13:
        rs(
          l,
          d,
          p,
          y
        );
        break;
      case 23:
        break;
      case 22:
        T = d.stateNode, I = d.alternate, d.memoizedState !== null ? T._visibility & 2 ? rs(
          l,
          d,
          p,
          y
        ) : Fp(l, d) : T._visibility & 2 ? rs(
          l,
          d,
          p,
          y
        ) : (T._visibility |= 2, lf(
          l,
          d,
          p,
          y,
          (d.subtreeFlags & 10256) !== 0 || !1
        )), E & 2048 && zS(I, d);
        break;
      case 24:
        rs(
          l,
          d,
          p,
          y
        ), E & 2048 && LS(d.alternate, d);
        break;
      default:
        rs(
          l,
          d,
          p,
          y
        );
    }
  }
  function lf(l, d, p, y, E) {
    for (E = E && ((d.subtreeFlags & 10256) !== 0 || !1), d = d.child; d !== null; ) {
      var T = l, I = d, V = p, te = y, Ee = I.flags;
      switch (I.tag) {
        case 0:
        case 11:
        case 15:
          lf(
            T,
            I,
            V,
            te,
            E
          ), $p(8, I);
          break;
        case 23:
          break;
        case 22:
          var Oe = I.stateNode;
          I.memoizedState !== null ? Oe._visibility & 2 ? lf(
            T,
            I,
            V,
            te,
            E
          ) : Fp(
            T,
            I
          ) : (Oe._visibility |= 2, lf(
            T,
            I,
            V,
            te,
            E
          )), E && Ee & 2048 && zS(
            I.alternate,
            I
          );
          break;
        case 24:
          lf(
            T,
            I,
            V,
            te,
            E
          ), E && Ee & 2048 && LS(I.alternate, I);
          break;
        default:
          lf(
            T,
            I,
            V,
            te,
            E
          );
      }
      d = d.sibling;
    }
  }
  function Fp(l, d) {
    if (d.subtreeFlags & 10256)
      for (d = d.child; d !== null; ) {
        var p = l, y = d, E = y.flags;
        switch (y.tag) {
          case 22:
            Fp(p, y), E & 2048 && zS(
              y.alternate,
              y
            );
            break;
          case 24:
            Fp(p, y), E & 2048 && LS(y.alternate, y);
            break;
          default:
            Fp(p, y);
        }
        d = d.sibling;
      }
  }
  var Vp = 8192;
  function cf(l, d, p) {
    if (l.subtreeFlags & Vp)
      for (l = l.child; l !== null; )
        fO(
          l,
          d,
          p
        ), l = l.sibling;
  }
  function fO(l, d, p) {
    switch (l.tag) {
      case 26:
        cf(
          l,
          d,
          p
        ), l.flags & Vp && l.memoizedState !== null && lZ(
          p,
          ns,
          l.memoizedState,
          l.memoizedProps
        );
        break;
      case 5:
        cf(
          l,
          d,
          p
        );
        break;
      case 3:
      case 4:
        var y = ns;
        ns = Sv(l.stateNode.containerInfo), cf(
          l,
          d,
          p
        ), ns = y;
        break;
      case 22:
        l.memoizedState === null && (y = l.alternate, y !== null && y.memoizedState !== null ? (y = Vp, Vp = 16777216, cf(
          l,
          d,
          p
        ), Vp = y) : cf(
          l,
          d,
          p
        ));
        break;
      default:
        cf(
          l,
          d,
          p
        );
    }
  }
  function hO(l) {
    var d = l.alternate;
    if (d !== null && (l = d.child, l !== null)) {
      d.child = null;
      do
        d = l.sibling, l.sibling = null, l = d;
      while (l !== null);
    }
  }
  function Hp(l) {
    var d = l.deletions;
    if ((l.flags & 16) !== 0) {
      if (d !== null)
        for (var p = 0; p < d.length; p++) {
          var y = d[p];
          $r = y, mO(
            y,
            l
          );
        }
      hO(l);
    }
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; )
        pO(l), l = l.sibling;
  }
  function pO(l) {
    switch (l.tag) {
      case 0:
      case 11:
      case 15:
        Hp(l), l.flags & 2048 && Dl(9, l, l.return);
        break;
      case 3:
        Hp(l);
        break;
      case 12:
        Hp(l);
        break;
      case 22:
        var d = l.stateNode;
        l.memoizedState !== null && d._visibility & 2 && (l.return === null || l.return.tag !== 13) ? (d._visibility &= -3, cv(l)) : Hp(l);
        break;
      default:
        Hp(l);
    }
  }
  function cv(l) {
    var d = l.deletions;
    if ((l.flags & 16) !== 0) {
      if (d !== null)
        for (var p = 0; p < d.length; p++) {
          var y = d[p];
          $r = y, mO(
            y,
            l
          );
        }
      hO(l);
    }
    for (l = l.child; l !== null; ) {
      switch (d = l, d.tag) {
        case 0:
        case 11:
        case 15:
          Dl(8, d, d.return), cv(d);
          break;
        case 22:
          p = d.stateNode, p._visibility & 2 && (p._visibility &= -3, cv(d));
          break;
        default:
          cv(d);
      }
      l = l.sibling;
    }
  }
  function mO(l, d) {
    for (; $r !== null; ) {
      var p = $r;
      switch (p.tag) {
        case 0:
        case 11:
        case 15:
          Dl(8, p, d);
          break;
        case 23:
        case 22:
          if (p.memoizedState !== null && p.memoizedState.cachePool !== null) {
            var y = p.memoizedState.cachePool.pool;
            y != null && y.refCount++;
          }
          break;
        case 24:
          Tp(p.memoizedState.cache);
      }
      if (y = p.child, y !== null) y.return = p, $r = y;
      else
        e: for (p = l; $r !== null; ) {
          y = $r;
          var E = y.sibling, T = y.return;
          if (oO(y), y === p) {
            $r = null;
            break e;
          }
          if (E !== null) {
            E.return = T, $r = E;
            break e;
          }
          $r = T;
        }
    }
  }
  var kK = {
    getCacheForType: function(l) {
      var d = Xr(gr), p = d.data.get(l);
      return p === void 0 && (p = l(), d.data.set(l, p)), p;
    },
    cacheSignal: function() {
      return Xr(gr).controller.signal;
    }
  }, CK = typeof WeakMap == "function" ? WeakMap : Map, un = 0, En = null, Gt = null, Xt = 0, pn = 0, so = null, Il = !1, uf = !1, BS = !1, Ia = 0, er = 0, jl = 0, _u = 0, $S = 0, ao = 0, df = 0, Wp = null, Hi = null, US = !1, uv = 0, gO = 0, dv = 1 / 0, fv = null, zl = null, Nr = 0, Ll = null, ff = null, ja = 0, FS = 0, VS = null, yO = null, qp = 0, HS = null;
  function lo() {
    return (un & 2) !== 0 && Xt !== 0 ? Xt & -Xt : H.T !== null ? YS() : eu();
  }
  function vO() {
    if (ao === 0)
      if ((Xt & 536870912) === 0 || tn) {
        var l = dl;
        dl <<= 1, (dl & 3932160) === 0 && (dl = 262144), ao = l;
      } else ao = 536870912;
    return l = io.current, l !== null && (l.flags |= 32), ao;
  }
  function Wi(l, d, p) {
    (l === En && (pn === 2 || pn === 9) || l.cancelPendingCommit !== null) && (hf(l, 0), Bl(
      l,
      Xt,
      ao,
      !1
    )), wo(l, p), ((un & 2) === 0 || l !== En) && (l === En && ((un & 2) === 0 && (_u |= p), er === 4 && Bl(
      l,
      Xt,
      ao,
      !1
    )), Is(l));
  }
  function bO(l, d, p) {
    if ((un & 6) !== 0) throw Error(r(327));
    var y = !p && (d & 127) === 0 && (d & l.expiredLanes) === 0 || ua(l, d), E = y ? TK(l, d) : qS(l, d, !0), T = y;
    do {
      if (E === 0) {
        uf && !y && Bl(l, d, 0, !1);
        break;
      } else {
        if (p = l.current.alternate, T && !EK(p)) {
          E = qS(l, d, !1), T = !1;
          continue;
        }
        if (E === 2) {
          if (T = d, l.errorRecoveryDisabledLanes & T)
            var I = 0;
          else
            I = l.pendingLanes & -536870913, I = I !== 0 ? I : I & 536870912 ? 536870912 : 0;
          if (I !== 0) {
            d = I;
            e: {
              var V = l;
              E = Wp;
              var te = V.current.memoizedState.isDehydrated;
              if (te && (hf(V, I).flags |= 256), I = qS(
                V,
                I,
                !1
              ), I !== 2) {
                if (BS && !te) {
                  V.errorRecoveryDisabledLanes |= T, _u |= T, E = 4;
                  break e;
                }
                T = Hi, Hi = E, T !== null && (Hi === null ? Hi = T : Hi.push.apply(
                  Hi,
                  T
                ));
              }
              E = I;
            }
            if (T = !1, E !== 2) continue;
          }
        }
        if (E === 1) {
          hf(l, 0), Bl(l, d, 0, !0);
          break;
        }
        e: {
          switch (y = l, T = E, T) {
            case 0:
            case 1:
              throw Error(r(345));
            case 4:
              if ((d & 4194048) !== d) break;
            case 6:
              Bl(
                y,
                d,
                ao,
                !Il
              );
              break e;
            case 2:
              Hi = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r(329));
          }
          if ((d & 62914560) === d && (E = uv + 300 - Nn(), 10 < E)) {
            if (Bl(
              y,
              d,
              ao,
              !Il
            ), Jc(y, 0, !0) !== 0) break e;
            ja = d, y.timeoutHandle = YO(
              xO.bind(
                null,
                y,
                p,
                Hi,
                fv,
                US,
                d,
                ao,
                _u,
                df,
                Il,
                T,
                "Throttled",
                -0,
                0
              ),
              E
            );
            break e;
          }
          xO(
            y,
            p,
            Hi,
            fv,
            US,
            d,
            ao,
            _u,
            df,
            Il,
            T,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Is(l);
  }
  function xO(l, d, p, y, E, T, I, V, te, Ee, Oe, je, Te, Me) {
    if (l.timeoutHandle = -1, je = d.subtreeFlags, je & 8192 || (je & 16785408) === 16785408) {
      je = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: $i
      }, fO(
        d,
        T,
        je
      );
      var it = (T & 62914560) === T ? uv - Nn() : (T & 4194048) === T ? gO - Nn() : 0;
      if (it = cZ(
        je,
        it
      ), it !== null) {
        ja = T, l.cancelPendingCommit = it(
          AO.bind(
            null,
            l,
            d,
            T,
            p,
            y,
            E,
            I,
            V,
            te,
            Oe,
            je,
            null,
            Te,
            Me
          )
        ), Bl(l, T, I, !Ee);
        return;
      }
    }
    AO(
      l,
      d,
      T,
      p,
      y,
      E,
      I,
      V,
      te
    );
  }
  function EK(l) {
    for (var d = l; ; ) {
      var p = d.tag;
      if ((p === 0 || p === 11 || p === 15) && d.flags & 16384 && (p = d.updateQueue, p !== null && (p = p.stores, p !== null)))
        for (var y = 0; y < p.length; y++) {
          var E = p[y], T = E.getSnapshot;
          E = E.value;
          try {
            if (!fi(T(), E)) return !1;
          } catch {
            return !1;
          }
        }
      if (p = d.child, d.subtreeFlags & 16384 && p !== null)
        p.return = d, d = p;
      else {
        if (d === l) break;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === l) return !0;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
    }
    return !0;
  }
  function Bl(l, d, p, y) {
    d &= ~$S, d &= ~_u, l.suspendedLanes |= d, l.pingedLanes &= ~d, y && (l.warmLanes |= d), y = l.expirationTimes;
    for (var E = d; 0 < E; ) {
      var T = 31 - Ve(E), I = 1 << T;
      y[T] = -1, E &= ~I;
    }
    p !== 0 && Qc(l, p, d);
  }
  function hv() {
    return (un & 6) === 0 ? (Gp(0), !1) : !0;
  }
  function WS() {
    if (Gt !== null) {
      if (pn === 0)
        var l = Gt.return;
      else
        l = Gt, Ea = yu = null, aS(l), nf = null, Mp = 0, l = Gt;
      for (; l !== null; )
        X2(l.alternate, l), l = l.return;
      Gt = null;
    }
  }
  function hf(l, d) {
    var p = l.timeoutHandle;
    p !== -1 && (l.timeoutHandle = -1, WK(p)), p = l.cancelPendingCommit, p !== null && (l.cancelPendingCommit = null, p()), ja = 0, WS(), En = l, Gt = p = ka(l.current, null), Xt = d, pn = 0, so = null, Il = !1, uf = ua(l, d), BS = !1, df = ao = $S = _u = jl = er = 0, Hi = Wp = null, US = !1, (d & 8) !== 0 && (d |= d & 32);
    var y = l.entangledLanes;
    if (y !== 0)
      for (l = l.entanglements, y &= d; 0 < y; ) {
        var E = 31 - Ve(y), T = 1 << E;
        d |= l[E], y &= ~T;
      }
    return Ia = d, At(), p;
  }
  function wO(l, d) {
    Ot = null, H.H = zp, d === tf || d === Fy ? (d = zR(), pn = 3) : d === Z1 ? (d = zR(), pn = 4) : pn = d === kS ? 8 : d !== null && typeof d == "object" && typeof d.then == "function" ? 6 : 1, so = d, Gt === null && (er = 1, nv(
      l,
      _o(d, l.current)
    ));
  }
  function SO() {
    var l = io.current;
    return l === null ? !0 : (Xt & 4194048) === Xt ? No === null : (Xt & 62914560) === Xt || (Xt & 536870912) !== 0 ? l === No : !1;
  }
  function kO() {
    var l = H.H;
    return H.H = zp, l === null ? zp : l;
  }
  function CO() {
    var l = H.A;
    return H.A = kK, l;
  }
  function pv() {
    er = 4, Il || (Xt & 4194048) !== Xt && io.current !== null || (uf = !0), (jl & 134217727) === 0 && (_u & 134217727) === 0 || En === null || Bl(
      En,
      Xt,
      ao,
      !1
    );
  }
  function qS(l, d, p) {
    var y = un;
    un |= 2;
    var E = kO(), T = CO();
    (En !== l || Xt !== d) && (fv = null, hf(l, d)), d = !1;
    var I = er;
    e: do
      try {
        if (pn !== 0 && Gt !== null) {
          var V = Gt, te = so;
          switch (pn) {
            case 8:
              WS(), I = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              io.current === null && (d = !0);
              var Ee = pn;
              if (pn = 0, so = null, pf(l, V, te, Ee), p && uf) {
                I = 0;
                break e;
              }
              break;
            default:
              Ee = pn, pn = 0, so = null, pf(l, V, te, Ee);
          }
        }
        _K(), I = er;
        break;
      } catch (Oe) {
        wO(l, Oe);
      }
    while (!0);
    return d && l.shellSuspendCounter++, Ea = yu = null, un = y, H.H = E, H.A = T, Gt === null && (En = null, Xt = 0, At()), I;
  }
  function _K() {
    for (; Gt !== null; ) EO(Gt);
  }
  function TK(l, d) {
    var p = un;
    un |= 2;
    var y = kO(), E = CO();
    En !== l || Xt !== d ? (fv = null, dv = Nn() + 500, hf(l, d)) : uf = ua(
      l,
      d
    );
    e: do
      try {
        if (pn !== 0 && Gt !== null) {
          d = Gt;
          var T = so;
          t: switch (pn) {
            case 1:
              pn = 0, so = null, pf(l, d, T, 1);
              break;
            case 2:
            case 9:
              if (IR(T)) {
                pn = 0, so = null, _O(d);
                break;
              }
              d = function() {
                pn !== 2 && pn !== 9 || En !== l || (pn = 7), Is(l);
              }, T.then(d, d);
              break e;
            case 3:
              pn = 7;
              break e;
            case 4:
              pn = 5;
              break e;
            case 7:
              IR(T) ? (pn = 0, so = null, _O(d)) : (pn = 0, so = null, pf(l, d, T, 7));
              break;
            case 5:
              var I = null;
              switch (Gt.tag) {
                case 26:
                  I = Gt.memoizedState;
                case 5:
                case 27:
                  var V = Gt;
                  if (I ? dP(I) : V.stateNode.complete) {
                    pn = 0, so = null;
                    var te = V.sibling;
                    if (te !== null) Gt = te;
                    else {
                      var Ee = V.return;
                      Ee !== null ? (Gt = Ee, mv(Ee)) : Gt = null;
                    }
                    break t;
                  }
              }
              pn = 0, so = null, pf(l, d, T, 5);
              break;
            case 6:
              pn = 0, so = null, pf(l, d, T, 6);
              break;
            case 8:
              WS(), er = 6;
              break e;
            default:
              throw Error(r(462));
          }
        }
        AK();
        break;
      } catch (Oe) {
        wO(l, Oe);
      }
    while (!0);
    return Ea = yu = null, H.H = y, H.A = E, un = p, Gt !== null ? 0 : (En = null, Xt = 0, At(), er);
  }
  function AK() {
    for (; Gt !== null && !ln(); )
      EO(Gt);
  }
  function EO(l) {
    var d = Z2(l.alternate, l, Ia);
    l.memoizedProps = l.pendingProps, d === null ? mv(l) : Gt = d;
  }
  function _O(l) {
    var d = l, p = d.alternate;
    switch (d.tag) {
      case 15:
      case 0:
        d = V2(
          p,
          d,
          d.pendingProps,
          d.type,
          void 0,
          Xt
        );
        break;
      case 11:
        d = V2(
          p,
          d,
          d.pendingProps,
          d.type.render,
          d.ref,
          Xt
        );
        break;
      case 5:
        aS(d);
      default:
        X2(p, d), d = Gt = CR(d, Ia), d = Z2(p, d, Ia);
    }
    l.memoizedProps = l.pendingProps, d === null ? mv(l) : Gt = d;
  }
  function pf(l, d, p, y) {
    Ea = yu = null, aS(d), nf = null, Mp = 0;
    var E = d.return;
    try {
      if (gK(
        l,
        E,
        d,
        p,
        Xt
      )) {
        er = 1, nv(
          l,
          _o(p, l.current)
        ), Gt = null;
        return;
      }
    } catch (T) {
      if (E !== null) throw Gt = E, T;
      er = 1, nv(
        l,
        _o(p, l.current)
      ), Gt = null;
      return;
    }
    d.flags & 32768 ? (tn || y === 1 ? l = !0 : uf || (Xt & 536870912) !== 0 ? l = !1 : (Il = l = !0, (y === 2 || y === 9 || y === 3 || y === 6) && (y = io.current, y !== null && y.tag === 13 && (y.flags |= 16384))), TO(d, l)) : mv(d);
  }
  function mv(l) {
    var d = l;
    do {
      if ((d.flags & 32768) !== 0) {
        TO(
          d,
          Il
        );
        return;
      }
      l = d.return;
      var p = bK(
        d.alternate,
        d,
        Ia
      );
      if (p !== null) {
        Gt = p;
        return;
      }
      if (d = d.sibling, d !== null) {
        Gt = d;
        return;
      }
      Gt = d = l;
    } while (d !== null);
    er === 0 && (er = 5);
  }
  function TO(l, d) {
    do {
      var p = xK(l.alternate, l);
      if (p !== null) {
        p.flags &= 32767, Gt = p;
        return;
      }
      if (p = l.return, p !== null && (p.flags |= 32768, p.subtreeFlags = 0, p.deletions = null), !d && (l = l.sibling, l !== null)) {
        Gt = l;
        return;
      }
      Gt = l = p;
    } while (l !== null);
    er = 6, Gt = null;
  }
  function AO(l, d, p, y, E, T, I, V, te) {
    l.cancelPendingCommit = null;
    do
      gv();
    while (Nr !== 0);
    if ((un & 6) !== 0) throw Error(r(327));
    if (d !== null) {
      if (d === l.current) throw Error(r(177));
      if (T = d.lanes | d.childLanes, T |= ft, rp(
        l,
        p,
        T,
        I,
        V,
        te
      ), l === En && (Gt = En = null, Xt = 0), ff = d, Ll = l, ja = p, FS = T, VS = E, yO = y, (d.subtreeFlags & 10256) !== 0 || (d.flags & 10256) !== 0 ? (l.callbackNode = null, l.callbackPriority = 0, OK(He, function() {
        return PO(), null;
      })) : (l.callbackNode = null, l.callbackPriority = 0), y = (d.flags & 13878) !== 0, (d.subtreeFlags & 13878) !== 0 || y) {
        y = H.T, H.T = null, E = Q.p, Q.p = 2, I = un, un |= 4;
        try {
          wK(l, d, p);
        } finally {
          un = I, Q.p = E, H.T = y;
        }
      }
      Nr = 1, MO(), NO(), RO();
    }
  }
  function MO() {
    if (Nr === 1) {
      Nr = 0;
      var l = Ll, d = ff, p = (d.flags & 13878) !== 0;
      if ((d.subtreeFlags & 13878) !== 0 || p) {
        p = H.T, H.T = null;
        var y = Q.p;
        Q.p = 2;
        var E = un;
        un |= 4;
        try {
          cO(d, l);
          var T = ik, I = z(l.containerInfo), V = T.focusedElem, te = T.selectionRange;
          if (I !== V && V && V.ownerDocument && P(
            V.ownerDocument.documentElement,
            V
          )) {
            if (te !== null && $(V)) {
              var Ee = te.start, Oe = te.end;
              if (Oe === void 0 && (Oe = Ee), "selectionStart" in V)
                V.selectionStart = Ee, V.selectionEnd = Math.min(
                  Oe,
                  V.value.length
                );
              else {
                var je = V.ownerDocument || document, Te = je && je.defaultView || window;
                if (Te.getSelection) {
                  var Me = Te.getSelection(), it = V.textContent.length, bt = Math.min(te.start, it), kn = te.end === void 0 ? bt : Math.min(te.end, it);
                  !Me.extend && bt > kn && (I = kn, kn = bt, bt = I);
                  var me = R(
                    V,
                    bt
                  ), de = R(
                    V,
                    kn
                  );
                  if (me && de && (Me.rangeCount !== 1 || Me.anchorNode !== me.node || Me.anchorOffset !== me.offset || Me.focusNode !== de.node || Me.focusOffset !== de.offset)) {
                    var Ce = je.createRange();
                    Ce.setStart(me.node, me.offset), Me.removeAllRanges(), bt > kn ? (Me.addRange(Ce), Me.extend(de.node, de.offset)) : (Ce.setEnd(de.node, de.offset), Me.addRange(Ce));
                  }
                }
              }
            }
            for (je = [], Me = V; Me = Me.parentNode; )
              Me.nodeType === 1 && je.push({
                element: Me,
                left: Me.scrollLeft,
                top: Me.scrollTop
              });
            for (typeof V.focus == "function" && V.focus(), V = 0; V < je.length; V++) {
              var Ie = je[V];
              Ie.element.scrollLeft = Ie.left, Ie.element.scrollTop = Ie.top;
            }
          }
          Av = !!rk, ik = rk = null;
        } finally {
          un = E, Q.p = y, H.T = p;
        }
      }
      l.current = d, Nr = 2;
    }
  }
  function NO() {
    if (Nr === 2) {
      Nr = 0;
      var l = Ll, d = ff, p = (d.flags & 8772) !== 0;
      if ((d.subtreeFlags & 8772) !== 0 || p) {
        p = H.T, H.T = null;
        var y = Q.p;
        Q.p = 2;
        var E = un;
        un |= 4;
        try {
          iO(l, d.alternate, d);
        } finally {
          un = E, Q.p = y, H.T = p;
        }
      }
      Nr = 3;
    }
  }
  function RO() {
    if (Nr === 4 || Nr === 3) {
      Nr = 0, In();
      var l = Ll, d = ff, p = ja, y = yO;
      (d.subtreeFlags & 10256) !== 0 || (d.flags & 10256) !== 0 ? Nr = 5 : (Nr = 0, ff = Ll = null, OO(l, l.pendingLanes));
      var E = l.pendingLanes;
      if (E === 0 && (zl = null), fl(p), d = d.stateNode, on && typeof on.onCommitFiberRoot == "function")
        try {
          on.onCommitFiberRoot(
            Bt,
            d,
            void 0,
            (d.current.flags & 128) === 128
          );
        } catch {
        }
      if (y !== null) {
        d = H.T, E = Q.p, Q.p = 2, H.T = null;
        try {
          for (var T = l.onRecoverableError, I = 0; I < y.length; I++) {
            var V = y[I];
            T(V.value, {
              componentStack: V.stack
            });
          }
        } finally {
          H.T = d, Q.p = E;
        }
      }
      (ja & 3) !== 0 && gv(), Is(l), E = l.pendingLanes, (p & 261930) !== 0 && (E & 42) !== 0 ? l === HS ? qp++ : (qp = 0, HS = l) : qp = 0, Gp(0);
    }
  }
  function OO(l, d) {
    (l.pooledCacheLanes &= d) === 0 && (d = l.pooledCache, d != null && (l.pooledCache = null, Tp(d)));
  }
  function gv() {
    return MO(), NO(), RO(), PO();
  }
  function PO() {
    if (Nr !== 5) return !1;
    var l = Ll, d = FS;
    FS = 0;
    var p = fl(ja), y = H.T, E = Q.p;
    try {
      Q.p = 32 > p ? 32 : p, H.T = null, p = VS, VS = null;
      var T = Ll, I = ja;
      if (Nr = 0, ff = Ll = null, ja = 0, (un & 6) !== 0) throw Error(r(331));
      var V = un;
      if (un |= 4, pO(T.current), dO(
        T,
        T.current,
        I,
        p
      ), un = V, Gp(0, !1), on && typeof on.onPostCommitFiberRoot == "function")
        try {
          on.onPostCommitFiberRoot(Bt, T);
        } catch {
        }
      return !0;
    } finally {
      Q.p = E, H.T = y, OO(l, d);
    }
  }
  function DO(l, d, p) {
    d = _o(p, d), d = SS(l.stateNode, d, 2), l = Rl(l, d, 2), l !== null && (wo(l, 2), Is(l));
  }
  function mn(l, d, p) {
    if (l.tag === 3)
      DO(l, l, p);
    else
      for (; d !== null; ) {
        if (d.tag === 3) {
          DO(
            d,
            l,
            p
          );
          break;
        } else if (d.tag === 1) {
          var y = d.stateNode;
          if (typeof d.type.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && (zl === null || !zl.has(y))) {
            l = _o(p, l), p = I2(2), y = Rl(d, p, 2), y !== null && (j2(
              p,
              y,
              d,
              l
            ), wo(y, 2), Is(y));
            break;
          }
        }
        d = d.return;
      }
  }
  function GS(l, d, p) {
    var y = l.pingCache;
    if (y === null) {
      y = l.pingCache = new CK();
      var E = /* @__PURE__ */ new Set();
      y.set(d, E);
    } else
      E = y.get(d), E === void 0 && (E = /* @__PURE__ */ new Set(), y.set(d, E));
    E.has(p) || (BS = !0, E.add(p), l = MK.bind(null, l, d, p), d.then(l, l));
  }
  function MK(l, d, p) {
    var y = l.pingCache;
    y !== null && y.delete(d), l.pingedLanes |= l.suspendedLanes & p, l.warmLanes &= ~p, En === l && (Xt & p) === p && (er === 4 || er === 3 && (Xt & 62914560) === Xt && 300 > Nn() - uv ? (un & 2) === 0 && hf(l, 0) : $S |= p, df === Xt && (df = 0)), Is(l);
  }
  function IO(l, d) {
    d === 0 && (d = Sy()), l = dn(l, d), l !== null && (wo(l, d), Is(l));
  }
  function NK(l) {
    var d = l.memoizedState, p = 0;
    d !== null && (p = d.retryLane), IO(l, p);
  }
  function RK(l, d) {
    var p = 0;
    switch (l.tag) {
      case 31:
      case 13:
        var y = l.stateNode, E = l.memoizedState;
        E !== null && (p = E.retryLane);
        break;
      case 19:
        y = l.stateNode;
        break;
      case 22:
        y = l.stateNode._retryCache;
        break;
      default:
        throw Error(r(314));
    }
    y !== null && y.delete(d), IO(l, p);
  }
  function OK(l, d) {
    return Mn(l, d);
  }
  var yv = null, mf = null, KS = !1, vv = !1, ZS = !1, $l = 0;
  function Is(l) {
    l !== mf && l.next === null && (mf === null ? yv = mf = l : mf = mf.next = l), vv = !0, KS || (KS = !0, DK());
  }
  function Gp(l, d) {
    if (!ZS && vv) {
      ZS = !0;
      do
        for (var p = !1, y = yv; y !== null; ) {
          if (l !== 0) {
            var E = y.pendingLanes;
            if (E === 0) var T = 0;
            else {
              var I = y.suspendedLanes, V = y.pingedLanes;
              T = (1 << 31 - Ve(42 | l) + 1) - 1, T &= E & ~(I & ~V), T = T & 201326741 ? T & 201326741 | 1 : T ? T | 2 : 0;
            }
            T !== 0 && (p = !0, BO(y, T));
          } else
            T = Xt, T = Jc(
              y,
              y === En ? T : 0,
              y.cancelPendingCommit !== null || y.timeoutHandle !== -1
            ), (T & 3) === 0 || ua(y, T) || (p = !0, BO(y, T));
          y = y.next;
        }
      while (p);
      ZS = !1;
    }
  }
  function PK() {
    jO();
  }
  function jO() {
    vv = KS = !1;
    var l = 0;
    $l !== 0 && HK() && (l = $l);
    for (var d = Nn(), p = null, y = yv; y !== null; ) {
      var E = y.next, T = zO(y, d);
      T === 0 ? (y.next = null, p === null ? yv = E : p.next = E, E === null && (mf = p)) : (p = y, (l !== 0 || (T & 3) !== 0) && (vv = !0)), y = E;
    }
    Nr !== 0 && Nr !== 5 || Gp(l), $l !== 0 && ($l = 0);
  }
  function zO(l, d) {
    for (var p = l.suspendedLanes, y = l.pingedLanes, E = l.expirationTimes, T = l.pendingLanes & -62914561; 0 < T; ) {
      var I = 31 - Ve(T), V = 1 << I, te = E[I];
      te === -1 ? ((V & p) === 0 || (V & y) !== 0) && (E[I] = T1(V, d)) : te <= d && (l.expiredLanes |= V), T &= ~V;
    }
    if (d = En, p = Xt, p = Jc(
      l,
      l === d ? p : 0,
      l.cancelPendingCommit !== null || l.timeoutHandle !== -1
    ), y = l.callbackNode, p === 0 || l === d && (pn === 2 || pn === 9) || l.cancelPendingCommit !== null)
      return y !== null && y !== null && Rt(y), l.callbackNode = null, l.callbackPriority = 0;
    if ((p & 3) === 0 || ua(l, p)) {
      if (d = p & -p, d === l.callbackPriority) return d;
      switch (y !== null && Rt(y), fl(p)) {
        case 2:
        case 8:
          p = De;
          break;
        case 32:
          p = He;
          break;
        case 268435456:
          p = xt;
          break;
        default:
          p = He;
      }
      return y = LO.bind(null, l), p = Mn(p, y), l.callbackPriority = d, l.callbackNode = p, d;
    }
    return y !== null && y !== null && Rt(y), l.callbackPriority = 2, l.callbackNode = null, 2;
  }
  function LO(l, d) {
    if (Nr !== 0 && Nr !== 5)
      return l.callbackNode = null, l.callbackPriority = 0, null;
    var p = l.callbackNode;
    if (gv() && l.callbackNode !== p)
      return null;
    var y = Xt;
    return y = Jc(
      l,
      l === En ? y : 0,
      l.cancelPendingCommit !== null || l.timeoutHandle !== -1
    ), y === 0 ? null : (bO(l, y, d), zO(l, Nn()), l.callbackNode != null && l.callbackNode === p ? LO.bind(null, l) : null);
  }
  function BO(l, d) {
    if (gv()) return null;
    bO(l, d, !0);
  }
  function DK() {
    qK(function() {
      (un & 6) !== 0 ? Mn(
        ke,
        PK
      ) : jO();
    });
  }
  function YS() {
    if ($l === 0) {
      var l = Qd;
      l === 0 && (l = Ke, Ke <<= 1, (Ke & 261888) === 0 && (Ke = 256)), $l = l;
    }
    return $l;
  }
  function $O(l) {
    return l == null || typeof l == "symbol" || typeof l == "boolean" ? null : typeof l == "function" ? l : ts("" + l);
  }
  function UO(l, d) {
    var p = d.ownerDocument.createElement("input");
    return p.name = d.name, p.value = d.value, l.id && p.setAttribute("form", l.id), d.parentNode.insertBefore(p, d), l = new FormData(l), p.parentNode.removeChild(p), l;
  }
  function IK(l, d, p, y, E) {
    if (d === "submit" && p && p.stateNode === E) {
      var T = $O(
        (E[lr] || null).action
      ), I = y.submitter;
      I && (d = (d = I[lr] || null) ? $O(d.formAction) : I.getAttribute("formAction"), d !== null && (T = d, I = null));
      var V = new Pd(
        "action",
        "action",
        null,
        y,
        E
      );
      l.push({
        event: V,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (y.defaultPrevented) {
                if ($l !== 0) {
                  var te = I ? UO(E, I) : new FormData(E);
                  gS(
                    p,
                    {
                      pending: !0,
                      data: te,
                      method: E.method,
                      action: T
                    },
                    null,
                    te
                  );
                }
              } else
                typeof T == "function" && (V.preventDefault(), te = I ? UO(E, I) : new FormData(E), gS(
                  p,
                  {
                    pending: !0,
                    data: te,
                    method: E.method,
                    action: T
                  },
                  T,
                  te
                ));
            },
            currentTarget: E
          }
        ]
      });
    }
  }
  for (var XS = 0; XS < Ze.length; XS++) {
    var JS = Ze[XS], jK = JS.toLowerCase(), zK = JS[0].toUpperCase() + JS.slice(1);
    Be(
      jK,
      "on" + zK
    );
  }
  Be(_e, "onAnimationEnd"), Be(ve, "onAnimationIteration"), Be(Re, "onAnimationStart"), Be("dblclick", "onDoubleClick"), Be("focusin", "onFocus"), Be("focusout", "onBlur"), Be(ze, "onTransitionRun"), Be(We, "onTransitionStart"), Be(qe, "onTransitionCancel"), Be(Le, "onTransitionEnd"), _s("onMouseEnter", ["mouseout", "mouseover"]), _s("onMouseLeave", ["mouseout", "mouseover"]), _s("onPointerEnter", ["pointerout", "pointerover"]), _s("onPointerLeave", ["pointerout", "pointerover"]), Qo(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Qo(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Qo("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Qo(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Qo(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Qo(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Kp = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), LK = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Kp)
  );
  function FO(l, d) {
    d = (d & 4) !== 0;
    for (var p = 0; p < l.length; p++) {
      var y = l[p], E = y.event;
      y = y.listeners;
      e: {
        var T = void 0;
        if (d)
          for (var I = y.length - 1; 0 <= I; I--) {
            var V = y[I], te = V.instance, Ee = V.currentTarget;
            if (V = V.listener, te !== T && E.isPropagationStopped())
              break e;
            T = V, E.currentTarget = Ee;
            try {
              T(E);
            } catch (Oe) {
              Je(Oe);
            }
            E.currentTarget = null, T = te;
          }
        else
          for (I = 0; I < y.length; I++) {
            if (V = y[I], te = V.instance, Ee = V.currentTarget, V = V.listener, te !== T && E.isPropagationStopped())
              break e;
            T = V, E.currentTarget = Ee;
            try {
              T(E);
            } catch (Oe) {
              Je(Oe);
            }
            E.currentTarget = null, T = te;
          }
      }
    }
  }
  function Kt(l, d) {
    var p = d[hl];
    p === void 0 && (p = d[hl] = /* @__PURE__ */ new Set());
    var y = l + "__bubble";
    p.has(y) || (VO(d, l, 2, !1), p.add(y));
  }
  function QS(l, d, p) {
    var y = 0;
    d && (y |= 4), VO(
      p,
      l,
      y,
      d
    );
  }
  var bv = "_reactListening" + Math.random().toString(36).slice(2);
  function ek(l) {
    if (!l[bv]) {
      l[bv] = !0, da.forEach(function(p) {
        p !== "selectionchange" && (LK.has(p) || QS(p, !1, l), QS(p, !0, l));
      });
      var d = l.nodeType === 9 ? l : l.ownerDocument;
      d === null || d[bv] || (d[bv] = !0, QS("selectionchange", !1, d));
    }
  }
  function VO(l, d, p, y) {
    switch (vP(d)) {
      case 2:
        var E = fZ;
        break;
      case 8:
        E = hZ;
        break;
      default:
        E = mk;
    }
    p = E.bind(
      null,
      d,
      p,
      l
    ), E = void 0, !dp || d !== "touchstart" && d !== "touchmove" && d !== "wheel" || (E = !0), y ? E !== void 0 ? l.addEventListener(d, p, {
      capture: !0,
      passive: E
    }) : l.addEventListener(d, p, !0) : E !== void 0 ? l.addEventListener(d, p, {
      passive: E
    }) : l.addEventListener(d, p, !1);
  }
  function tk(l, d, p, y, E) {
    var T = y;
    if ((d & 1) === 0 && (d & 2) === 0 && y !== null)
      e: for (; ; ) {
        if (y === null) return;
        var I = y.tag;
        if (I === 3 || I === 4) {
          var V = y.stateNode.containerInfo;
          if (V === E) break;
          if (I === 4)
            for (I = y.return; I !== null; ) {
              var te = I.tag;
              if ((te === 3 || te === 4) && I.stateNode.containerInfo === E)
                return;
              I = I.return;
            }
          for (; V !== null; ) {
            if (I = Es(V), I === null) return;
            if (te = I.tag, te === 5 || te === 6 || te === 26 || te === 27) {
              y = T = I;
              continue e;
            }
            V = V.parentNode;
          }
        }
        y = y.return;
      }
    ml(function() {
      var Ee = T, Oe = Rd(p), je = [];
      e: {
        var Te = Xe.get(l);
        if (Te !== void 0) {
          var Me = Pd, it = l;
          switch (l) {
            case "keypress":
              if (vl(p) === 0) break e;
            case "keydown":
            case "keyup":
              Me = $d;
              break;
            case "focusin":
              it = "focus", Me = bl;
              break;
            case "focusout":
              it = "blur", Me = bl;
              break;
            case "beforeblur":
            case "afterblur":
              Me = bl;
              break;
            case "click":
              if (p.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Me = jd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Me = _y;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Me = vp;
              break;
            case _e:
            case ve:
            case Re:
              Me = Ty;
              break;
            case Le:
              Me = bp;
              break;
            case "scroll":
            case "scrollend":
              Me = Dd;
              break;
            case "wheel":
              Me = Fd;
              break;
            case "copy":
            case "cut":
            case "paste":
              Me = xl;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Me = yp;
              break;
            case "toggle":
            case "beforetoggle":
              Me = Ny;
          }
          var bt = (d & 4) !== 0, kn = !bt && (l === "scroll" || l === "scrollend"), me = bt ? Te !== null ? Te + "Capture" : null : Te;
          bt = [];
          for (var de = Ee, Ce; de !== null; ) {
            var Ie = de;
            if (Ce = Ie.stateNode, Ie = Ie.tag, Ie !== 5 && Ie !== 26 && Ie !== 27 || Ce === null || me === null || (Ie = ga(de, me), Ie != null && bt.push(
              Zp(de, Ie, Ce)
            )), kn) break;
            de = de.return;
          }
          0 < bt.length && (Te = new Me(
            Te,
            it,
            null,
            p,
            Oe
          ), je.push({ event: Te, listeners: bt }));
        }
      }
      if ((d & 7) === 0) {
        e: {
          if (Te = l === "mouseover" || l === "pointerover", Me = l === "mouseout" || l === "pointerout", Te && p !== ko && (it = p.relatedTarget || p.fromElement) && (Es(it) || it[Ci]))
            break e;
          if ((Me || Te) && (Te = Oe.window === Oe ? Oe : (Te = Oe.ownerDocument) ? Te.defaultView || Te.parentWindow : window, Me ? (it = p.relatedTarget || p.toElement, Me = Ee, it = it ? Es(it) : null, it !== null && (kn = o(it), bt = it.tag, it !== kn || bt !== 5 && bt !== 27 && bt !== 6) && (it = null)) : (Me = null, it = Ee), Me !== it)) {
            if (bt = jd, Ie = "onMouseLeave", me = "onMouseEnter", de = "mouse", (l === "pointerout" || l === "pointerover") && (bt = yp, Ie = "onPointerLeave", me = "onPointerEnter", de = "pointer"), kn = Me == null ? Te : to(Me), Ce = it == null ? Te : to(it), Te = new bt(
              Ie,
              de + "leave",
              Me,
              p,
              Oe
            ), Te.target = kn, Te.relatedTarget = Ce, Ie = null, Es(Oe) === Ee && (bt = new bt(
              me,
              de + "enter",
              it,
              p,
              Oe
            ), bt.target = Ce, bt.relatedTarget = kn, Ie = bt), kn = Ie, Me && it)
              t: {
                for (bt = BK, me = Me, de = it, Ce = 0, Ie = me; Ie; Ie = bt(Ie))
                  Ce++;
                Ie = 0;
                for (var mt = de; mt; mt = bt(mt))
                  Ie++;
                for (; 0 < Ce - Ie; )
                  me = bt(me), Ce--;
                for (; 0 < Ie - Ce; )
                  de = bt(de), Ie--;
                for (; Ce--; ) {
                  if (me === de || de !== null && me === de.alternate) {
                    bt = me;
                    break t;
                  }
                  me = bt(me), de = bt(de);
                }
                bt = null;
              }
            else bt = null;
            Me !== null && HO(
              je,
              Te,
              Me,
              bt,
              !1
            ), it !== null && kn !== null && HO(
              je,
              kn,
              it,
              bt,
              !0
            );
          }
        }
        e: {
          if (Te = Ee ? to(Ee) : window, Me = Te.nodeName && Te.nodeName.toLowerCase(), Me === "select" || Me === "input" && Te.type === "file")
            var sn = pu;
          else if (Wd(Te))
            if (Eo)
              sn = kl;
            else {
              sn = Sa;
              var ct = jy;
            }
          else
            Me = Te.nodeName, !Me || Me.toLowerCase() !== "input" || Te.type !== "checkbox" && Te.type !== "radio" ? Ee && up(Ee.elementType) && (sn = pu) : sn = Cp;
          if (sn && (sn = sn(l, Ee))) {
            kp(
              je,
              sn,
              p,
              Oe
            );
            break e;
          }
          ct && ct(l, Te, Ee), l === "focusout" && Ee && Te.type === "number" && Ee.memoizedProps.value != null && su(Te, "number", Te.value);
        }
        switch (ct = Ee ? to(Ee) : window, l) {
          case "focusin":
            (Wd(ct) || ct.contentEditable === "true") && (K = ct, se = Ee, ye = null);
            break;
          case "focusout":
            ye = se = K = null;
            break;
          case "mousedown":
            ae = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            ae = !1, oe(je, p, Oe);
            break;
          case "selectionchange":
            if (q) break;
          case "keydown":
          case "keyup":
            oe(je, p, Oe);
        }
        var Pt;
        if (fu)
          e: {
            switch (l) {
              case "compositionstart":
                var Jt = "onCompositionStart";
                break e;
              case "compositionend":
                Jt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Jt = "onCompositionUpdate";
                break e;
            }
            Jt = void 0;
          }
        else
          xa ? Sp(l, p) && (Jt = "onCompositionEnd") : l === "keydown" && p.keyCode === 229 && (Jt = "onCompositionStart");
        Jt && (Vd && p.locale !== "ko" && (xa || Jt !== "onCompositionStart" ? Jt === "onCompositionEnd" && xa && (Pt = yl()) : (Co = Oe, Od = "value" in Co ? Co.value : Co.textContent, xa = !0)), ct = xv(Ee, Jt), 0 < ct.length && (Jt = new Bd(
          Jt,
          l,
          null,
          p,
          Oe
        ), je.push({ event: Jt, listeners: ct }), Pt ? Jt.data = Pt : (Pt = Oy(p), Pt !== null && (Jt.data = Pt)))), (Pt = P1 ? Py(l, p) : D1(l, p)) && (Jt = xv(Ee, "onBeforeInput"), 0 < Jt.length && (ct = new Bd(
          "onBeforeInput",
          "beforeinput",
          null,
          p,
          Oe
        ), je.push({
          event: ct,
          listeners: Jt
        }), ct.data = Pt)), IK(
          je,
          l,
          Ee,
          p,
          Oe
        );
      }
      FO(je, d);
    });
  }
  function Zp(l, d, p) {
    return {
      instance: l,
      listener: d,
      currentTarget: p
    };
  }
  function xv(l, d) {
    for (var p = d + "Capture", y = []; l !== null; ) {
      var E = l, T = E.stateNode;
      if (E = E.tag, E !== 5 && E !== 26 && E !== 27 || T === null || (E = ga(l, p), E != null && y.unshift(
        Zp(l, E, T)
      ), E = ga(l, d), E != null && y.push(
        Zp(l, E, T)
      )), l.tag === 3) return y;
      l = l.return;
    }
    return [];
  }
  function BK(l) {
    if (l === null) return null;
    do
      l = l.return;
    while (l && l.tag !== 5 && l.tag !== 27);
    return l || null;
  }
  function HO(l, d, p, y, E) {
    for (var T = d._reactName, I = []; p !== null && p !== y; ) {
      var V = p, te = V.alternate, Ee = V.stateNode;
      if (V = V.tag, te !== null && te === y) break;
      V !== 5 && V !== 26 && V !== 27 || Ee === null || (te = Ee, E ? (Ee = ga(p, T), Ee != null && I.unshift(
        Zp(p, Ee, te)
      )) : E || (Ee = ga(p, T), Ee != null && I.push(
        Zp(p, Ee, te)
      ))), p = p.return;
    }
    I.length !== 0 && l.push({ event: d, listeners: I });
  }
  var $K = /\r\n?/g, UK = /\u0000|\uFFFD/g;
  function WO(l) {
    return (typeof l == "string" ? l : "" + l).replace($K, `
`).replace(UK, "");
  }
  function qO(l, d) {
    return d = WO(d), WO(l) === d;
  }
  function Sn(l, d, p, y, E, T) {
    switch (p) {
      case "children":
        typeof y == "string" ? d === "body" || d === "textarea" && y === "" || ha(l, y) : (typeof y == "number" || typeof y == "bigint") && d !== "body" && ha(l, "" + y);
        break;
      case "className":
        iu(l, "class", y);
        break;
      case "tabIndex":
        iu(l, "tabindex", y);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        iu(l, p, y);
        break;
      case "style":
        cp(l, y, T);
        break;
      case "data":
        if (d !== "object") {
          iu(l, "data", y);
          break;
        }
      case "src":
      case "href":
        if (y === "" && (d !== "a" || p !== "href")) {
          l.removeAttribute(p);
          break;
        }
        if (y == null || typeof y == "function" || typeof y == "symbol" || typeof y == "boolean") {
          l.removeAttribute(p);
          break;
        }
        y = ts("" + y), l.setAttribute(p, y);
        break;
      case "action":
      case "formAction":
        if (typeof y == "function") {
          l.setAttribute(
            p,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof T == "function" && (p === "formAction" ? (d !== "input" && Sn(l, d, "name", E.name, E, null), Sn(
            l,
            d,
            "formEncType",
            E.formEncType,
            E,
            null
          ), Sn(
            l,
            d,
            "formMethod",
            E.formMethod,
            E,
            null
          ), Sn(
            l,
            d,
            "formTarget",
            E.formTarget,
            E,
            null
          )) : (Sn(l, d, "encType", E.encType, E, null), Sn(l, d, "method", E.method, E, null), Sn(l, d, "target", E.target, E, null)));
        if (y == null || typeof y == "symbol" || typeof y == "boolean") {
          l.removeAttribute(p);
          break;
        }
        y = ts("" + y), l.setAttribute(p, y);
        break;
      case "onClick":
        y != null && (l.onclick = $i);
        break;
      case "onScroll":
        y != null && Kt("scroll", l);
        break;
      case "onScrollEnd":
        y != null && Kt("scrollend", l);
        break;
      case "dangerouslySetInnerHTML":
        if (y != null) {
          if (typeof y != "object" || !("__html" in y))
            throw Error(r(61));
          if (p = y.__html, p != null) {
            if (E.children != null) throw Error(r(60));
            l.innerHTML = p;
          }
        }
        break;
      case "multiple":
        l.multiple = y && typeof y != "function" && typeof y != "symbol";
        break;
      case "muted":
        l.muted = y && typeof y != "function" && typeof y != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (y == null || typeof y == "function" || typeof y == "boolean" || typeof y == "symbol") {
          l.removeAttribute("xlink:href");
          break;
        }
        p = ts("" + y), l.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          p
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        y != null && typeof y != "function" && typeof y != "symbol" ? l.setAttribute(p, "" + y) : l.removeAttribute(p);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        y && typeof y != "function" && typeof y != "symbol" ? l.setAttribute(p, "") : l.removeAttribute(p);
        break;
      case "capture":
      case "download":
        y === !0 ? l.setAttribute(p, "") : y !== !1 && y != null && typeof y != "function" && typeof y != "symbol" ? l.setAttribute(p, y) : l.removeAttribute(p);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        y != null && typeof y != "function" && typeof y != "symbol" && !isNaN(y) && 1 <= y ? l.setAttribute(p, y) : l.removeAttribute(p);
        break;
      case "rowSpan":
      case "start":
        y == null || typeof y == "function" || typeof y == "symbol" || isNaN(y) ? l.removeAttribute(p) : l.setAttribute(p, y);
        break;
      case "popover":
        Kt("beforetoggle", l), Kt("toggle", l), It(l, "popover", y);
        break;
      case "xlinkActuate":
        So(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          y
        );
        break;
      case "xlinkArcrole":
        So(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          y
        );
        break;
      case "xlinkRole":
        So(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          y
        );
        break;
      case "xlinkShow":
        So(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          y
        );
        break;
      case "xlinkTitle":
        So(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          y
        );
        break;
      case "xlinkType":
        So(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          y
        );
        break;
      case "xmlBase":
        So(
          l,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          y
        );
        break;
      case "xmlLang":
        So(
          l,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          y
        );
        break;
      case "xmlSpace":
        So(
          l,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          y
        );
        break;
      case "is":
        It(l, "is", y);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < p.length) || p[0] !== "o" && p[0] !== "O" || p[1] !== "n" && p[1] !== "N") && (p = N1.get(p) || p, It(l, p, y));
    }
  }
  function nk(l, d, p, y, E, T) {
    switch (p) {
      case "style":
        cp(l, y, T);
        break;
      case "dangerouslySetInnerHTML":
        if (y != null) {
          if (typeof y != "object" || !("__html" in y))
            throw Error(r(61));
          if (p = y.__html, p != null) {
            if (E.children != null) throw Error(r(60));
            l.innerHTML = p;
          }
        }
        break;
      case "children":
        typeof y == "string" ? ha(l, y) : (typeof y == "number" || typeof y == "bigint") && ha(l, "" + y);
        break;
      case "onScroll":
        y != null && Kt("scroll", l);
        break;
      case "onScrollEnd":
        y != null && Kt("scrollend", l);
        break;
      case "onClick":
        y != null && (l.onclick = $i);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!nu.hasOwnProperty(p))
          e: {
            if (p[0] === "o" && p[1] === "n" && (E = p.endsWith("Capture"), d = p.slice(2, E ? p.length - 7 : void 0), T = l[lr] || null, T = T != null ? T[p] : null, typeof T == "function" && l.removeEventListener(d, T, E), typeof y == "function")) {
              typeof T != "function" && T !== null && (p in l ? l[p] = null : l.hasAttribute(p) && l.removeAttribute(p)), l.addEventListener(d, y, E);
              break e;
            }
            p in l ? l[p] = y : y === !0 ? l.setAttribute(p, "") : It(l, p, y);
          }
    }
  }
  function Qr(l, d, p) {
    switch (d) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Kt("error", l), Kt("load", l);
        var y = !1, E = !1, T;
        for (T in p)
          if (p.hasOwnProperty(T)) {
            var I = p[T];
            if (I != null)
              switch (T) {
                case "src":
                  y = !0;
                  break;
                case "srcSet":
                  E = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, d));
                default:
                  Sn(l, d, T, I, p, null);
              }
          }
        E && Sn(l, d, "srcSet", p.srcSet, p, null), y && Sn(l, d, "src", p.src, p, null);
        return;
      case "input":
        Kt("invalid", l);
        var V = T = I = E = null, te = null, Ee = null;
        for (y in p)
          if (p.hasOwnProperty(y)) {
            var Oe = p[y];
            if (Oe != null)
              switch (y) {
                case "name":
                  E = Oe;
                  break;
                case "type":
                  I = Oe;
                  break;
                case "checked":
                  te = Oe;
                  break;
                case "defaultChecked":
                  Ee = Oe;
                  break;
                case "value":
                  T = Oe;
                  break;
                case "defaultValue":
                  V = Oe;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Oe != null)
                    throw Error(r(137, d));
                  break;
                default:
                  Sn(l, d, y, Oe, p, null);
              }
          }
        Nd(
          l,
          T,
          V,
          te,
          Ee,
          I,
          E,
          !1
        );
        return;
      case "select":
        Kt("invalid", l), y = I = T = null;
        for (E in p)
          if (p.hasOwnProperty(E) && (V = p[E], V != null))
            switch (E) {
              case "value":
                T = V;
                break;
              case "defaultValue":
                I = V;
                break;
              case "multiple":
                y = V;
              default:
                Sn(l, d, E, V, p, null);
            }
        d = T, p = I, l.multiple = !!y, d != null ? es(l, !!y, d, !1) : p != null && es(l, !!y, p, !0);
        return;
      case "textarea":
        Kt("invalid", l), T = E = y = null;
        for (I in p)
          if (p.hasOwnProperty(I) && (V = p[I], V != null))
            switch (I) {
              case "value":
                y = V;
                break;
              case "defaultValue":
                E = V;
                break;
              case "children":
                T = V;
                break;
              case "dangerouslySetInnerHTML":
                if (V != null) throw Error(r(91));
                break;
              default:
                Sn(l, d, I, V, p, null);
            }
        au(l, y, E, T);
        return;
      case "option":
        for (te in p)
          p.hasOwnProperty(te) && (y = p[te], y != null) && (te === "selected" ? l.selected = y && typeof y != "function" && typeof y != "symbol" : Sn(l, d, te, y, p, null));
        return;
      case "dialog":
        Kt("beforetoggle", l), Kt("toggle", l), Kt("cancel", l), Kt("close", l);
        break;
      case "iframe":
      case "object":
        Kt("load", l);
        break;
      case "video":
      case "audio":
        for (y = 0; y < Kp.length; y++)
          Kt(Kp[y], l);
        break;
      case "image":
        Kt("error", l), Kt("load", l);
        break;
      case "details":
        Kt("toggle", l);
        break;
      case "embed":
      case "source":
      case "link":
        Kt("error", l), Kt("load", l);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (Ee in p)
          if (p.hasOwnProperty(Ee) && (y = p[Ee], y != null))
            switch (Ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, d));
              default:
                Sn(l, d, Ee, y, p, null);
            }
        return;
      default:
        if (up(d)) {
          for (Oe in p)
            p.hasOwnProperty(Oe) && (y = p[Oe], y !== void 0 && nk(
              l,
              d,
              Oe,
              y,
              p,
              void 0
            ));
          return;
        }
    }
    for (V in p)
      p.hasOwnProperty(V) && (y = p[V], y != null && Sn(l, d, V, y, p, null));
  }
  function FK(l, d, p, y) {
    switch (d) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var E = null, T = null, I = null, V = null, te = null, Ee = null, Oe = null;
        for (Me in p) {
          var je = p[Me];
          if (p.hasOwnProperty(Me) && je != null)
            switch (Me) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                te = je;
              default:
                y.hasOwnProperty(Me) || Sn(l, d, Me, null, y, je);
            }
        }
        for (var Te in y) {
          var Me = y[Te];
          if (je = p[Te], y.hasOwnProperty(Te) && (Me != null || je != null))
            switch (Te) {
              case "type":
                T = Me;
                break;
              case "name":
                E = Me;
                break;
              case "checked":
                Ee = Me;
                break;
              case "defaultChecked":
                Oe = Me;
                break;
              case "value":
                I = Me;
                break;
              case "defaultValue":
                V = Me;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (Me != null)
                  throw Error(r(137, d));
                break;
              default:
                Me !== je && Sn(
                  l,
                  d,
                  Te,
                  Me,
                  y,
                  je
                );
            }
        }
        Ts(
          l,
          I,
          V,
          te,
          Ee,
          Oe,
          T,
          E
        );
        return;
      case "select":
        Me = I = V = Te = null;
        for (T in p)
          if (te = p[T], p.hasOwnProperty(T) && te != null)
            switch (T) {
              case "value":
                break;
              case "multiple":
                Me = te;
              default:
                y.hasOwnProperty(T) || Sn(
                  l,
                  d,
                  T,
                  null,
                  y,
                  te
                );
            }
        for (E in y)
          if (T = y[E], te = p[E], y.hasOwnProperty(E) && (T != null || te != null))
            switch (E) {
              case "value":
                Te = T;
                break;
              case "defaultValue":
                V = T;
                break;
              case "multiple":
                I = T;
              default:
                T !== te && Sn(
                  l,
                  d,
                  E,
                  T,
                  y,
                  te
                );
            }
        d = V, p = I, y = Me, Te != null ? es(l, !!p, Te, !1) : !!y != !!p && (d != null ? es(l, !!p, d, !0) : es(l, !!p, p ? [] : "", !1));
        return;
      case "textarea":
        Me = Te = null;
        for (V in p)
          if (E = p[V], p.hasOwnProperty(V) && E != null && !y.hasOwnProperty(V))
            switch (V) {
              case "value":
                break;
              case "children":
                break;
              default:
                Sn(l, d, V, null, y, E);
            }
        for (I in y)
          if (E = y[I], T = p[I], y.hasOwnProperty(I) && (E != null || T != null))
            switch (I) {
              case "value":
                Te = E;
                break;
              case "defaultValue":
                Me = E;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (E != null) throw Error(r(91));
                break;
              default:
                E !== T && Sn(l, d, I, E, y, T);
            }
        lp(l, Te, Me);
        return;
      case "option":
        for (var it in p)
          Te = p[it], p.hasOwnProperty(it) && Te != null && !y.hasOwnProperty(it) && (it === "selected" ? l.selected = !1 : Sn(
            l,
            d,
            it,
            null,
            y,
            Te
          ));
        for (te in y)
          Te = y[te], Me = p[te], y.hasOwnProperty(te) && Te !== Me && (Te != null || Me != null) && (te === "selected" ? l.selected = Te && typeof Te != "function" && typeof Te != "symbol" : Sn(
            l,
            d,
            te,
            Te,
            y,
            Me
          ));
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var bt in p)
          Te = p[bt], p.hasOwnProperty(bt) && Te != null && !y.hasOwnProperty(bt) && Sn(l, d, bt, null, y, Te);
        for (Ee in y)
          if (Te = y[Ee], Me = p[Ee], y.hasOwnProperty(Ee) && Te !== Me && (Te != null || Me != null))
            switch (Ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (Te != null)
                  throw Error(r(137, d));
                break;
              default:
                Sn(
                  l,
                  d,
                  Ee,
                  Te,
                  y,
                  Me
                );
            }
        return;
      default:
        if (up(d)) {
          for (var kn in p)
            Te = p[kn], p.hasOwnProperty(kn) && Te !== void 0 && !y.hasOwnProperty(kn) && nk(
              l,
              d,
              kn,
              void 0,
              y,
              Te
            );
          for (Oe in y)
            Te = y[Oe], Me = p[Oe], !y.hasOwnProperty(Oe) || Te === Me || Te === void 0 && Me === void 0 || nk(
              l,
              d,
              Oe,
              Te,
              y,
              Me
            );
          return;
        }
    }
    for (var me in p)
      Te = p[me], p.hasOwnProperty(me) && Te != null && !y.hasOwnProperty(me) && Sn(l, d, me, null, y, Te);
    for (je in y)
      Te = y[je], Me = p[je], !y.hasOwnProperty(je) || Te === Me || Te == null && Me == null || Sn(l, d, je, Te, y, Me);
  }
  function GO(l) {
    switch (l) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function VK() {
    if (typeof performance.getEntriesByType == "function") {
      for (var l = 0, d = 0, p = performance.getEntriesByType("resource"), y = 0; y < p.length; y++) {
        var E = p[y], T = E.transferSize, I = E.initiatorType, V = E.duration;
        if (T && V && GO(I)) {
          for (I = 0, V = E.responseEnd, y += 1; y < p.length; y++) {
            var te = p[y], Ee = te.startTime;
            if (Ee > V) break;
            var Oe = te.transferSize, je = te.initiatorType;
            Oe && GO(je) && (te = te.responseEnd, I += Oe * (te < V ? 1 : (V - Ee) / (te - Ee)));
          }
          if (--y, d += 8 * (T + I) / (E.duration / 1e3), l++, 10 < l) break;
        }
      }
      if (0 < l) return d / l / 1e6;
    }
    return navigator.connection && (l = navigator.connection.downlink, typeof l == "number") ? l : 5;
  }
  var rk = null, ik = null;
  function wv(l) {
    return l.nodeType === 9 ? l : l.ownerDocument;
  }
  function KO(l) {
    switch (l) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function ZO(l, d) {
    if (l === 0)
      switch (d) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return l === 1 && d === "foreignObject" ? 0 : l;
  }
  function ok(l, d) {
    return l === "textarea" || l === "noscript" || typeof d.children == "string" || typeof d.children == "number" || typeof d.children == "bigint" || typeof d.dangerouslySetInnerHTML == "object" && d.dangerouslySetInnerHTML !== null && d.dangerouslySetInnerHTML.__html != null;
  }
  var sk = null;
  function HK() {
    var l = window.event;
    return l && l.type === "popstate" ? l === sk ? !1 : (sk = l, !0) : (sk = null, !1);
  }
  var YO = typeof setTimeout == "function" ? setTimeout : void 0, WK = typeof clearTimeout == "function" ? clearTimeout : void 0, XO = typeof Promise == "function" ? Promise : void 0, qK = typeof queueMicrotask == "function" ? queueMicrotask : typeof XO < "u" ? function(l) {
    return XO.resolve(null).then(l).catch(GK);
  } : YO;
  function GK(l) {
    setTimeout(function() {
      throw l;
    });
  }
  function Ul(l) {
    return l === "head";
  }
  function JO(l, d) {
    var p = d, y = 0;
    do {
      var E = p.nextSibling;
      if (l.removeChild(p), E && E.nodeType === 8)
        if (p = E.data, p === "/$" || p === "/&") {
          if (y === 0) {
            l.removeChild(E), bf(d);
            return;
          }
          y--;
        } else if (p === "$" || p === "$?" || p === "$~" || p === "$!" || p === "&")
          y++;
        else if (p === "html")
          Yp(l.ownerDocument.documentElement);
        else if (p === "head") {
          p = l.ownerDocument.head, Yp(p);
          for (var T = p.firstChild; T; ) {
            var I = T.nextSibling, V = T.nodeName;
            T[eo] || V === "SCRIPT" || V === "STYLE" || V === "LINK" && T.rel.toLowerCase() === "stylesheet" || p.removeChild(T), T = I;
          }
        } else
          p === "body" && Yp(l.ownerDocument.body);
      p = E;
    } while (p);
    bf(d);
  }
  function QO(l, d) {
    var p = l;
    l = 0;
    do {
      var y = p.nextSibling;
      if (p.nodeType === 1 ? d ? (p._stashedDisplay = p.style.display, p.style.display = "none") : (p.style.display = p._stashedDisplay || "", p.getAttribute("style") === "" && p.removeAttribute("style")) : p.nodeType === 3 && (d ? (p._stashedText = p.nodeValue, p.nodeValue = "") : p.nodeValue = p._stashedText || ""), y && y.nodeType === 8)
        if (p = y.data, p === "/$") {
          if (l === 0) break;
          l--;
        } else
          p !== "$" && p !== "$?" && p !== "$~" && p !== "$!" || l++;
      p = y;
    } while (p);
  }
  function ak(l) {
    var d = l.firstChild;
    for (d && d.nodeType === 10 && (d = d.nextSibling); d; ) {
      var p = d;
      switch (d = d.nextSibling, p.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          ak(p), Ad(p);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (p.rel.toLowerCase() === "stylesheet") continue;
      }
      l.removeChild(p);
    }
  }
  function KK(l, d, p, y) {
    for (; l.nodeType === 1; ) {
      var E = p;
      if (l.nodeName.toLowerCase() !== d.toLowerCase()) {
        if (!y && (l.nodeName !== "INPUT" || l.type !== "hidden"))
          break;
      } else if (y) {
        if (!l[eo])
          switch (d) {
            case "meta":
              if (!l.hasAttribute("itemprop")) break;
              return l;
            case "link":
              if (T = l.getAttribute("rel"), T === "stylesheet" && l.hasAttribute("data-precedence"))
                break;
              if (T !== E.rel || l.getAttribute("href") !== (E.href == null || E.href === "" ? null : E.href) || l.getAttribute("crossorigin") !== (E.crossOrigin == null ? null : E.crossOrigin) || l.getAttribute("title") !== (E.title == null ? null : E.title))
                break;
              return l;
            case "style":
              if (l.hasAttribute("data-precedence")) break;
              return l;
            case "script":
              if (T = l.getAttribute("src"), (T !== (E.src == null ? null : E.src) || l.getAttribute("type") !== (E.type == null ? null : E.type) || l.getAttribute("crossorigin") !== (E.crossOrigin == null ? null : E.crossOrigin)) && T && l.hasAttribute("async") && !l.hasAttribute("itemprop"))
                break;
              return l;
            default:
              return l;
          }
      } else if (d === "input" && l.type === "hidden") {
        var T = E.name == null ? null : "" + E.name;
        if (E.type === "hidden" && l.getAttribute("name") === T)
          return l;
      } else return l;
      if (l = Ro(l.nextSibling), l === null) break;
    }
    return null;
  }
  function ZK(l, d, p) {
    if (d === "") return null;
    for (; l.nodeType !== 3; )
      if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !p || (l = Ro(l.nextSibling), l === null)) return null;
    return l;
  }
  function eP(l, d) {
    for (; l.nodeType !== 8; )
      if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !d || (l = Ro(l.nextSibling), l === null)) return null;
    return l;
  }
  function lk(l) {
    return l.data === "$?" || l.data === "$~";
  }
  function ck(l) {
    return l.data === "$!" || l.data === "$?" && l.ownerDocument.readyState !== "loading";
  }
  function YK(l, d) {
    var p = l.ownerDocument;
    if (l.data === "$~") l._reactRetry = d;
    else if (l.data !== "$?" || p.readyState !== "loading")
      d();
    else {
      var y = function() {
        d(), p.removeEventListener("DOMContentLoaded", y);
      };
      p.addEventListener("DOMContentLoaded", y), l._reactRetry = y;
    }
  }
  function Ro(l) {
    for (; l != null; l = l.nextSibling) {
      var d = l.nodeType;
      if (d === 1 || d === 3) break;
      if (d === 8) {
        if (d = l.data, d === "$" || d === "$!" || d === "$?" || d === "$~" || d === "&" || d === "F!" || d === "F")
          break;
        if (d === "/$" || d === "/&") return null;
      }
    }
    return l;
  }
  var uk = null;
  function tP(l) {
    l = l.nextSibling;
    for (var d = 0; l; ) {
      if (l.nodeType === 8) {
        var p = l.data;
        if (p === "/$" || p === "/&") {
          if (d === 0)
            return Ro(l.nextSibling);
          d--;
        } else
          p !== "$" && p !== "$!" && p !== "$?" && p !== "$~" && p !== "&" || d++;
      }
      l = l.nextSibling;
    }
    return null;
  }
  function nP(l) {
    l = l.previousSibling;
    for (var d = 0; l; ) {
      if (l.nodeType === 8) {
        var p = l.data;
        if (p === "$" || p === "$!" || p === "$?" || p === "$~" || p === "&") {
          if (d === 0) return l;
          d--;
        } else p !== "/$" && p !== "/&" || d++;
      }
      l = l.previousSibling;
    }
    return null;
  }
  function rP(l, d, p) {
    switch (d = wv(p), l) {
      case "html":
        if (l = d.documentElement, !l) throw Error(r(452));
        return l;
      case "head":
        if (l = d.head, !l) throw Error(r(453));
        return l;
      case "body":
        if (l = d.body, !l) throw Error(r(454));
        return l;
      default:
        throw Error(r(451));
    }
  }
  function Yp(l) {
    for (var d = l.attributes; d.length; )
      l.removeAttributeNode(d[0]);
    Ad(l);
  }
  var Oo = /* @__PURE__ */ new Map(), iP = /* @__PURE__ */ new Set();
  function Sv(l) {
    return typeof l.getRootNode == "function" ? l.getRootNode() : l.nodeType === 9 ? l : l.ownerDocument;
  }
  var za = Q.d;
  Q.d = {
    f: XK,
    r: JK,
    D: QK,
    C: eZ,
    L: tZ,
    m: nZ,
    X: iZ,
    S: rZ,
    M: oZ
  };
  function XK() {
    var l = za.f(), d = hv();
    return l || d;
  }
  function JK(l) {
    var d = bn(l);
    d !== null && d.tag === 5 && d.type === "form" ? w2(d) : za.r(l);
  }
  var gf = typeof document > "u" ? null : document;
  function oP(l, d, p) {
    var y = gf;
    if (y && typeof d == "string" && d) {
      var E = zr(d);
      E = 'link[rel="' + l + '"][href="' + E + '"]', typeof p == "string" && (E += '[crossorigin="' + p + '"]'), iP.has(E) || (iP.add(E), l = { rel: l, crossOrigin: p, href: d }, y.querySelector(E) === null && (d = y.createElement("link"), Qr(d, "link", l), cr(d), y.head.appendChild(d)));
    }
  }
  function QK(l) {
    za.D(l), oP("dns-prefetch", l, null);
  }
  function eZ(l, d) {
    za.C(l, d), oP("preconnect", l, d);
  }
  function tZ(l, d, p) {
    za.L(l, d, p);
    var y = gf;
    if (y && l && d) {
      var E = 'link[rel="preload"][as="' + zr(d) + '"]';
      d === "image" && p && p.imageSrcSet ? (E += '[imagesrcset="' + zr(
        p.imageSrcSet
      ) + '"]', typeof p.imageSizes == "string" && (E += '[imagesizes="' + zr(
        p.imageSizes
      ) + '"]')) : E += '[href="' + zr(l) + '"]';
      var T = E;
      switch (d) {
        case "style":
          T = yf(l);
          break;
        case "script":
          T = vf(l);
      }
      Oo.has(T) || (l = h(
        {
          rel: "preload",
          href: d === "image" && p && p.imageSrcSet ? void 0 : l,
          as: d
        },
        p
      ), Oo.set(T, l), y.querySelector(E) !== null || d === "style" && y.querySelector(Xp(T)) || d === "script" && y.querySelector(Jp(T)) || (d = y.createElement("link"), Qr(d, "link", l), cr(d), y.head.appendChild(d)));
    }
  }
  function nZ(l, d) {
    za.m(l, d);
    var p = gf;
    if (p && l) {
      var y = d && typeof d.as == "string" ? d.as : "script", E = 'link[rel="modulepreload"][as="' + zr(y) + '"][href="' + zr(l) + '"]', T = E;
      switch (y) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          T = vf(l);
      }
      if (!Oo.has(T) && (l = h({ rel: "modulepreload", href: l }, d), Oo.set(T, l), p.querySelector(E) === null)) {
        switch (y) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (p.querySelector(Jp(T)))
              return;
        }
        y = p.createElement("link"), Qr(y, "link", l), cr(y), p.head.appendChild(y);
      }
    }
  }
  function rZ(l, d, p) {
    za.S(l, d, p);
    var y = gf;
    if (y && l) {
      var E = ui(y).hoistableStyles, T = yf(l);
      d = d || "default";
      var I = E.get(T);
      if (!I) {
        var V = { loading: 0, preload: null };
        if (I = y.querySelector(
          Xp(T)
        ))
          V.loading = 5;
        else {
          l = h(
            { rel: "stylesheet", href: l, "data-precedence": d },
            p
          ), (p = Oo.get(T)) && dk(l, p);
          var te = I = y.createElement("link");
          cr(te), Qr(te, "link", l), te._p = new Promise(function(Ee, Oe) {
            te.onload = Ee, te.onerror = Oe;
          }), te.addEventListener("load", function() {
            V.loading |= 1;
          }), te.addEventListener("error", function() {
            V.loading |= 2;
          }), V.loading |= 4, kv(I, d, y);
        }
        I = {
          type: "stylesheet",
          instance: I,
          count: 1,
          state: V
        }, E.set(T, I);
      }
    }
  }
  function iZ(l, d) {
    za.X(l, d);
    var p = gf;
    if (p && l) {
      var y = ui(p).hoistableScripts, E = vf(l), T = y.get(E);
      T || (T = p.querySelector(Jp(E)), T || (l = h({ src: l, async: !0 }, d), (d = Oo.get(E)) && fk(l, d), T = p.createElement("script"), cr(T), Qr(T, "link", l), p.head.appendChild(T)), T = {
        type: "script",
        instance: T,
        count: 1,
        state: null
      }, y.set(E, T));
    }
  }
  function oZ(l, d) {
    za.M(l, d);
    var p = gf;
    if (p && l) {
      var y = ui(p).hoistableScripts, E = vf(l), T = y.get(E);
      T || (T = p.querySelector(Jp(E)), T || (l = h({ src: l, async: !0, type: "module" }, d), (d = Oo.get(E)) && fk(l, d), T = p.createElement("script"), cr(T), Qr(T, "link", l), p.head.appendChild(T)), T = {
        type: "script",
        instance: T,
        count: 1,
        state: null
      }, y.set(E, T));
    }
  }
  function sP(l, d, p, y) {
    var E = (E = re.current) ? Sv(E) : null;
    if (!E) throw Error(r(446));
    switch (l) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof p.precedence == "string" && typeof p.href == "string" ? (d = yf(p.href), p = ui(
          E
        ).hoistableStyles, y = p.get(d), y || (y = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, p.set(d, y)), y) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (p.rel === "stylesheet" && typeof p.href == "string" && typeof p.precedence == "string") {
          l = yf(p.href);
          var T = ui(
            E
          ).hoistableStyles, I = T.get(l);
          if (I || (E = E.ownerDocument || E, I = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, T.set(l, I), (T = E.querySelector(
            Xp(l)
          )) && !T._p && (I.instance = T, I.state.loading = 5), Oo.has(l) || (p = {
            rel: "preload",
            as: "style",
            href: p.href,
            crossOrigin: p.crossOrigin,
            integrity: p.integrity,
            media: p.media,
            hrefLang: p.hrefLang,
            referrerPolicy: p.referrerPolicy
          }, Oo.set(l, p), T || sZ(
            E,
            l,
            p,
            I.state
          ))), d && y === null)
            throw Error(r(528, ""));
          return I;
        }
        if (d && y !== null)
          throw Error(r(529, ""));
        return null;
      case "script":
        return d = p.async, p = p.src, typeof p == "string" && d && typeof d != "function" && typeof d != "symbol" ? (d = vf(p), p = ui(
          E
        ).hoistableScripts, y = p.get(d), y || (y = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, p.set(d, y)), y) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(r(444, l));
    }
  }
  function yf(l) {
    return 'href="' + zr(l) + '"';
  }
  function Xp(l) {
    return 'link[rel="stylesheet"][' + l + "]";
  }
  function aP(l) {
    return h({}, l, {
      "data-precedence": l.precedence,
      precedence: null
    });
  }
  function sZ(l, d, p, y) {
    l.querySelector('link[rel="preload"][as="style"][' + d + "]") ? y.loading = 1 : (d = l.createElement("link"), y.preload = d, d.addEventListener("load", function() {
      return y.loading |= 1;
    }), d.addEventListener("error", function() {
      return y.loading |= 2;
    }), Qr(d, "link", p), cr(d), l.head.appendChild(d));
  }
  function vf(l) {
    return '[src="' + zr(l) + '"]';
  }
  function Jp(l) {
    return "script[async]" + l;
  }
  function lP(l, d, p) {
    if (d.count++, d.instance === null)
      switch (d.type) {
        case "style":
          var y = l.querySelector(
            'style[data-href~="' + zr(p.href) + '"]'
          );
          if (y)
            return d.instance = y, cr(y), y;
          var E = h({}, p, {
            "data-href": p.href,
            "data-precedence": p.precedence,
            href: null,
            precedence: null
          });
          return y = (l.ownerDocument || l).createElement(
            "style"
          ), cr(y), Qr(y, "style", E), kv(y, p.precedence, l), d.instance = y;
        case "stylesheet":
          E = yf(p.href);
          var T = l.querySelector(
            Xp(E)
          );
          if (T)
            return d.state.loading |= 4, d.instance = T, cr(T), T;
          y = aP(p), (E = Oo.get(E)) && dk(y, E), T = (l.ownerDocument || l).createElement("link"), cr(T);
          var I = T;
          return I._p = new Promise(function(V, te) {
            I.onload = V, I.onerror = te;
          }), Qr(T, "link", y), d.state.loading |= 4, kv(T, p.precedence, l), d.instance = T;
        case "script":
          return T = vf(p.src), (E = l.querySelector(
            Jp(T)
          )) ? (d.instance = E, cr(E), E) : (y = p, (E = Oo.get(T)) && (y = h({}, p), fk(y, E)), l = l.ownerDocument || l, E = l.createElement("script"), cr(E), Qr(E, "link", y), l.head.appendChild(E), d.instance = E);
        case "void":
          return null;
        default:
          throw Error(r(443, d.type));
      }
    else
      d.type === "stylesheet" && (d.state.loading & 4) === 0 && (y = d.instance, d.state.loading |= 4, kv(y, p.precedence, l));
    return d.instance;
  }
  function kv(l, d, p) {
    for (var y = p.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), E = y.length ? y[y.length - 1] : null, T = E, I = 0; I < y.length; I++) {
      var V = y[I];
      if (V.dataset.precedence === d) T = V;
      else if (T !== E) break;
    }
    T ? T.parentNode.insertBefore(l, T.nextSibling) : (d = p.nodeType === 9 ? p.head : p, d.insertBefore(l, d.firstChild));
  }
  function dk(l, d) {
    l.crossOrigin == null && (l.crossOrigin = d.crossOrigin), l.referrerPolicy == null && (l.referrerPolicy = d.referrerPolicy), l.title == null && (l.title = d.title);
  }
  function fk(l, d) {
    l.crossOrigin == null && (l.crossOrigin = d.crossOrigin), l.referrerPolicy == null && (l.referrerPolicy = d.referrerPolicy), l.integrity == null && (l.integrity = d.integrity);
  }
  var Cv = null;
  function cP(l, d, p) {
    if (Cv === null) {
      var y = /* @__PURE__ */ new Map(), E = Cv = /* @__PURE__ */ new Map();
      E.set(p, y);
    } else
      E = Cv, y = E.get(p), y || (y = /* @__PURE__ */ new Map(), E.set(p, y));
    if (y.has(l)) return y;
    for (y.set(l, null), p = p.getElementsByTagName(l), E = 0; E < p.length; E++) {
      var T = p[E];
      if (!(T[eo] || T[Rn] || l === "link" && T.getAttribute("rel") === "stylesheet") && T.namespaceURI !== "http://www.w3.org/2000/svg") {
        var I = T.getAttribute(d) || "";
        I = l + I;
        var V = y.get(I);
        V ? V.push(T) : y.set(I, [T]);
      }
    }
    return y;
  }
  function uP(l, d, p) {
    l = l.ownerDocument || l, l.head.insertBefore(
      p,
      d === "title" ? l.querySelector("head > title") : null
    );
  }
  function aZ(l, d, p) {
    if (p === 1 || d.itemProp != null) return !1;
    switch (l) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof d.precedence != "string" || typeof d.href != "string" || d.href === "")
          break;
        return !0;
      case "link":
        if (typeof d.rel != "string" || typeof d.href != "string" || d.href === "" || d.onLoad || d.onError)
          break;
        return d.rel === "stylesheet" ? (l = d.disabled, typeof d.precedence == "string" && l == null) : !0;
      case "script":
        if (d.async && typeof d.async != "function" && typeof d.async != "symbol" && !d.onLoad && !d.onError && d.src && typeof d.src == "string")
          return !0;
    }
    return !1;
  }
  function dP(l) {
    return !(l.type === "stylesheet" && (l.state.loading & 3) === 0);
  }
  function lZ(l, d, p, y) {
    if (p.type === "stylesheet" && (typeof y.media != "string" || matchMedia(y.media).matches !== !1) && (p.state.loading & 4) === 0) {
      if (p.instance === null) {
        var E = yf(y.href), T = d.querySelector(
          Xp(E)
        );
        if (T) {
          d = T._p, d !== null && typeof d == "object" && typeof d.then == "function" && (l.count++, l = Ev.bind(l), d.then(l, l)), p.state.loading |= 4, p.instance = T, cr(T);
          return;
        }
        T = d.ownerDocument || d, y = aP(y), (E = Oo.get(E)) && dk(y, E), T = T.createElement("link"), cr(T);
        var I = T;
        I._p = new Promise(function(V, te) {
          I.onload = V, I.onerror = te;
        }), Qr(T, "link", y), p.instance = T;
      }
      l.stylesheets === null && (l.stylesheets = /* @__PURE__ */ new Map()), l.stylesheets.set(p, d), (d = p.state.preload) && (p.state.loading & 3) === 0 && (l.count++, p = Ev.bind(l), d.addEventListener("load", p), d.addEventListener("error", p));
    }
  }
  var hk = 0;
  function cZ(l, d) {
    return l.stylesheets && l.count === 0 && Tv(l, l.stylesheets), 0 < l.count || 0 < l.imgCount ? function(p) {
      var y = setTimeout(function() {
        if (l.stylesheets && Tv(l, l.stylesheets), l.unsuspend) {
          var T = l.unsuspend;
          l.unsuspend = null, T();
        }
      }, 6e4 + d);
      0 < l.imgBytes && hk === 0 && (hk = 62500 * VK());
      var E = setTimeout(
        function() {
          if (l.waitingForImages = !1, l.count === 0 && (l.stylesheets && Tv(l, l.stylesheets), l.unsuspend)) {
            var T = l.unsuspend;
            l.unsuspend = null, T();
          }
        },
        (l.imgBytes > hk ? 50 : 800) + d
      );
      return l.unsuspend = p, function() {
        l.unsuspend = null, clearTimeout(y), clearTimeout(E);
      };
    } : null;
  }
  function Ev() {
    if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
      if (this.stylesheets) Tv(this, this.stylesheets);
      else if (this.unsuspend) {
        var l = this.unsuspend;
        this.unsuspend = null, l();
      }
    }
  }
  var _v = null;
  function Tv(l, d) {
    l.stylesheets = null, l.unsuspend !== null && (l.count++, _v = /* @__PURE__ */ new Map(), d.forEach(uZ, l), _v = null, Ev.call(l));
  }
  function uZ(l, d) {
    if (!(d.state.loading & 4)) {
      var p = _v.get(l);
      if (p) var y = p.get(null);
      else {
        p = /* @__PURE__ */ new Map(), _v.set(l, p);
        for (var E = l.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), T = 0; T < E.length; T++) {
          var I = E[T];
          (I.nodeName === "LINK" || I.getAttribute("media") !== "not all") && (p.set(I.dataset.precedence, I), y = I);
        }
        y && p.set(null, y);
      }
      E = d.instance, I = E.getAttribute("data-precedence"), T = p.get(I) || y, T === y && p.set(null, E), p.set(I, E), this.count++, y = Ev.bind(this), E.addEventListener("load", y), E.addEventListener("error", y), T ? T.parentNode.insertBefore(E, T.nextSibling) : (l = l.nodeType === 9 ? l.head : l, l.insertBefore(E, l.firstChild)), d.state.loading |= 4;
    }
  }
  var Qp = {
    $$typeof: M,
    Provider: null,
    Consumer: null,
    _currentValue: X,
    _currentValue2: X,
    _threadCount: 0
  };
  function dZ(l, d, p, y, E, T, I, V, te) {
    this.tag = 1, this.containerInfo = l, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Ss(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ss(0), this.hiddenUpdates = Ss(null), this.identifierPrefix = y, this.onUncaughtError = E, this.onCaughtError = T, this.onRecoverableError = I, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = te, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function fP(l, d, p, y, E, T, I, V, te, Ee, Oe, je) {
    return l = new dZ(
      l,
      d,
      p,
      I,
      te,
      Ee,
      Oe,
      je,
      V
    ), d = 1, T === !0 && (d |= 24), T = ro(3, null, null, d), l.current = T, T.stateNode = l, d = q1(), d.refCount++, l.pooledCache = d, d.refCount++, T.memoizedState = {
      element: y,
      isDehydrated: p,
      cache: d
    }, Y1(T), l;
  }
  function hP(l) {
    return l ? (l = Kd, l) : Kd;
  }
  function pP(l, d, p, y, E, T) {
    E = hP(E), y.context === null ? y.context = E : y.pendingContext = E, y = Nl(d), y.payload = { element: p }, T = T === void 0 ? null : T, T !== null && (y.callback = T), p = Rl(l, y, d), p !== null && (Wi(p, l, d), Rp(p, l, d));
  }
  function mP(l, d) {
    if (l = l.memoizedState, l !== null && l.dehydrated !== null) {
      var p = l.retryLane;
      l.retryLane = p !== 0 && p < d ? p : d;
    }
  }
  function pk(l, d) {
    mP(l, d), (l = l.alternate) && mP(l, d);
  }
  function gP(l) {
    if (l.tag === 13 || l.tag === 31) {
      var d = dn(l, 67108864);
      d !== null && Wi(d, l, 67108864), pk(l, 67108864);
    }
  }
  function yP(l) {
    if (l.tag === 13 || l.tag === 31) {
      var d = lo();
      d = ip(d);
      var p = dn(l, d);
      p !== null && Wi(p, l, d), pk(l, d);
    }
  }
  var Av = !0;
  function fZ(l, d, p, y) {
    var E = H.T;
    H.T = null;
    var T = Q.p;
    try {
      Q.p = 2, mk(l, d, p, y);
    } finally {
      Q.p = T, H.T = E;
    }
  }
  function hZ(l, d, p, y) {
    var E = H.T;
    H.T = null;
    var T = Q.p;
    try {
      Q.p = 8, mk(l, d, p, y);
    } finally {
      Q.p = T, H.T = E;
    }
  }
  function mk(l, d, p, y) {
    if (Av) {
      var E = gk(y);
      if (E === null)
        tk(
          l,
          d,
          y,
          Mv,
          p
        ), bP(l, y);
      else if (mZ(
        E,
        l,
        d,
        p,
        y
      ))
        y.stopPropagation();
      else if (bP(l, y), d & 4 && -1 < pZ.indexOf(l)) {
        for (; E !== null; ) {
          var T = bn(E);
          if (T !== null)
            switch (T.tag) {
              case 3:
                if (T = T.stateNode, T.current.memoizedState.isDehydrated) {
                  var I = Jo(T.pendingLanes);
                  if (I !== 0) {
                    var V = T;
                    for (V.pendingLanes |= 2, V.entangledLanes |= 2; I; ) {
                      var te = 1 << 31 - Ve(I);
                      V.entanglements[1] |= te, I &= ~te;
                    }
                    Is(T), (un & 6) === 0 && (dv = Nn() + 500, Gp(0));
                  }
                }
                break;
              case 31:
              case 13:
                V = dn(T, 2), V !== null && Wi(V, T, 2), hv(), pk(T, 2);
            }
          if (T = gk(y), T === null && tk(
            l,
            d,
            y,
            Mv,
            p
          ), T === E) break;
          E = T;
        }
        E !== null && y.stopPropagation();
      } else
        tk(
          l,
          d,
          y,
          null,
          p
        );
    }
  }
  function gk(l) {
    return l = Rd(l), yk(l);
  }
  var Mv = null;
  function yk(l) {
    if (Mv = null, l = Es(l), l !== null) {
      var d = o(l);
      if (d === null) l = null;
      else {
        var p = d.tag;
        if (p === 13) {
          if (l = s(d), l !== null) return l;
          l = null;
        } else if (p === 31) {
          if (l = a(d), l !== null) return l;
          l = null;
        } else if (p === 3) {
          if (d.stateNode.current.memoizedState.isDehydrated)
            return d.tag === 3 ? d.stateNode.containerInfo : null;
          l = null;
        } else d !== l && (l = null);
      }
    }
    return Mv = l, null;
  }
  function vP(l) {
    switch (l) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (gt()) {
          case ke:
            return 2;
          case De:
            return 8;
          case He:
          case tt:
            return 32;
          case xt:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var vk = !1, Fl = null, Vl = null, Hl = null, em = /* @__PURE__ */ new Map(), tm = /* @__PURE__ */ new Map(), Wl = [], pZ = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function bP(l, d) {
    switch (l) {
      case "focusin":
      case "focusout":
        Fl = null;
        break;
      case "dragenter":
      case "dragleave":
        Vl = null;
        break;
      case "mouseover":
      case "mouseout":
        Hl = null;
        break;
      case "pointerover":
      case "pointerout":
        em.delete(d.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        tm.delete(d.pointerId);
    }
  }
  function nm(l, d, p, y, E, T) {
    return l === null || l.nativeEvent !== T ? (l = {
      blockedOn: d,
      domEventName: p,
      eventSystemFlags: y,
      nativeEvent: T,
      targetContainers: [E]
    }, d !== null && (d = bn(d), d !== null && gP(d)), l) : (l.eventSystemFlags |= y, d = l.targetContainers, E !== null && d.indexOf(E) === -1 && d.push(E), l);
  }
  function mZ(l, d, p, y, E) {
    switch (d) {
      case "focusin":
        return Fl = nm(
          Fl,
          l,
          d,
          p,
          y,
          E
        ), !0;
      case "dragenter":
        return Vl = nm(
          Vl,
          l,
          d,
          p,
          y,
          E
        ), !0;
      case "mouseover":
        return Hl = nm(
          Hl,
          l,
          d,
          p,
          y,
          E
        ), !0;
      case "pointerover":
        var T = E.pointerId;
        return em.set(
          T,
          nm(
            em.get(T) || null,
            l,
            d,
            p,
            y,
            E
          )
        ), !0;
      case "gotpointercapture":
        return T = E.pointerId, tm.set(
          T,
          nm(
            tm.get(T) || null,
            l,
            d,
            p,
            y,
            E
          )
        ), !0;
    }
    return !1;
  }
  function xP(l) {
    var d = Es(l.target);
    if (d !== null) {
      var p = o(d);
      if (p !== null) {
        if (d = p.tag, d === 13) {
          if (d = s(p), d !== null) {
            l.blockedOn = d, tu(l.priority, function() {
              yP(p);
            });
            return;
          }
        } else if (d === 31) {
          if (d = a(p), d !== null) {
            l.blockedOn = d, tu(l.priority, function() {
              yP(p);
            });
            return;
          }
        } else if (d === 3 && p.stateNode.current.memoizedState.isDehydrated) {
          l.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
          return;
        }
      }
    }
    l.blockedOn = null;
  }
  function Nv(l) {
    if (l.blockedOn !== null) return !1;
    for (var d = l.targetContainers; 0 < d.length; ) {
      var p = gk(l.nativeEvent);
      if (p === null) {
        p = l.nativeEvent;
        var y = new p.constructor(
          p.type,
          p
        );
        ko = y, p.target.dispatchEvent(y), ko = null;
      } else
        return d = bn(p), d !== null && gP(d), l.blockedOn = p, !1;
      d.shift();
    }
    return !0;
  }
  function wP(l, d, p) {
    Nv(l) && p.delete(d);
  }
  function gZ() {
    vk = !1, Fl !== null && Nv(Fl) && (Fl = null), Vl !== null && Nv(Vl) && (Vl = null), Hl !== null && Nv(Hl) && (Hl = null), em.forEach(wP), tm.forEach(wP);
  }
  function Rv(l, d) {
    l.blockedOn === d && (l.blockedOn = null, vk || (vk = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      gZ
    )));
  }
  var Ov = null;
  function SP(l) {
    Ov !== l && (Ov = l, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        Ov === l && (Ov = null);
        for (var d = 0; d < l.length; d += 3) {
          var p = l[d], y = l[d + 1], E = l[d + 2];
          if (typeof y != "function") {
            if (yk(y || p) === null)
              continue;
            break;
          }
          var T = bn(p);
          T !== null && (l.splice(d, 3), d -= 3, gS(
            T,
            {
              pending: !0,
              data: E,
              method: p.method,
              action: y
            },
            y,
            E
          ));
        }
      }
    ));
  }
  function bf(l) {
    function d(te) {
      return Rv(te, l);
    }
    Fl !== null && Rv(Fl, l), Vl !== null && Rv(Vl, l), Hl !== null && Rv(Hl, l), em.forEach(d), tm.forEach(d);
    for (var p = 0; p < Wl.length; p++) {
      var y = Wl[p];
      y.blockedOn === l && (y.blockedOn = null);
    }
    for (; 0 < Wl.length && (p = Wl[0], p.blockedOn === null); )
      xP(p), p.blockedOn === null && Wl.shift();
    if (p = (l.ownerDocument || l).$$reactFormReplay, p != null)
      for (y = 0; y < p.length; y += 3) {
        var E = p[y], T = p[y + 1], I = E[lr] || null;
        if (typeof T == "function")
          I || SP(p);
        else if (I) {
          var V = null;
          if (T && T.hasAttribute("formAction")) {
            if (E = T, I = T[lr] || null)
              V = I.formAction;
            else if (yk(E) !== null) continue;
          } else V = I.action;
          typeof V == "function" ? p[y + 1] = V : (p.splice(y, 3), y -= 3), SP(p);
        }
      }
  }
  function kP() {
    function l(T) {
      T.canIntercept && T.info === "react-transition" && T.intercept({
        handler: function() {
          return new Promise(function(I) {
            return E = I;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function d() {
      E !== null && (E(), E = null), y || setTimeout(p, 20);
    }
    function p() {
      if (!y && !navigation.transition) {
        var T = navigation.currentEntry;
        T && T.url != null && navigation.navigate(T.url, {
          state: T.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if (typeof navigation == "object") {
      var y = !1, E = null;
      return navigation.addEventListener("navigate", l), navigation.addEventListener("navigatesuccess", d), navigation.addEventListener("navigateerror", d), setTimeout(p, 100), function() {
        y = !0, navigation.removeEventListener("navigate", l), navigation.removeEventListener("navigatesuccess", d), navigation.removeEventListener("navigateerror", d), E !== null && (E(), E = null);
      };
    }
  }
  function bk(l) {
    this._internalRoot = l;
  }
  Pv.prototype.render = bk.prototype.render = function(l) {
    var d = this._internalRoot;
    if (d === null) throw Error(r(409));
    var p = d.current, y = lo();
    pP(p, y, l, d, null, null);
  }, Pv.prototype.unmount = bk.prototype.unmount = function() {
    var l = this._internalRoot;
    if (l !== null) {
      this._internalRoot = null;
      var d = l.containerInfo;
      pP(l.current, 2, null, l, null, null), hv(), d[Ci] = null;
    }
  };
  function Pv(l) {
    this._internalRoot = l;
  }
  Pv.prototype.unstable_scheduleHydration = function(l) {
    if (l) {
      var d = eu();
      l = { blockedOn: null, target: l, priority: d };
      for (var p = 0; p < Wl.length && d !== 0 && d < Wl[p].priority; p++) ;
      Wl.splice(p, 0, l), p === 0 && xP(l);
    }
  };
  var CP = t.version;
  if (CP !== "19.2.4")
    throw Error(
      r(
        527,
        CP,
        "19.2.4"
      )
    );
  Q.findDOMNode = function(l) {
    var d = l._reactInternals;
    if (d === void 0)
      throw typeof l.render == "function" ? Error(r(188)) : (l = Object.keys(l).join(","), Error(r(268, l)));
    return l = u(d), l = l !== null ? f(l) : null, l = l === null ? null : l.stateNode, l;
  };
  var yZ = {
    bundleType: 0,
    version: "19.2.4",
    rendererPackageName: "react-dom",
    currentDispatcherRef: H,
    reconcilerVersion: "19.2.4"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Dv = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Dv.isDisabled && Dv.supportsFiber)
      try {
        Bt = Dv.inject(
          yZ
        ), on = Dv;
      } catch {
      }
  }
  return rm.createRoot = function(l, d) {
    if (!i(l)) throw Error(r(299));
    var p = !1, y = "", E = R2, T = O2, I = P2;
    return d != null && (d.unstable_strictMode === !0 && (p = !0), d.identifierPrefix !== void 0 && (y = d.identifierPrefix), d.onUncaughtError !== void 0 && (E = d.onUncaughtError), d.onCaughtError !== void 0 && (T = d.onCaughtError), d.onRecoverableError !== void 0 && (I = d.onRecoverableError)), d = fP(
      l,
      1,
      !1,
      null,
      null,
      p,
      y,
      null,
      E,
      T,
      I,
      kP
    ), l[Ci] = d.current, ek(l), new bk(d);
  }, rm.hydrateRoot = function(l, d, p) {
    if (!i(l)) throw Error(r(299));
    var y = !1, E = "", T = R2, I = O2, V = P2, te = null;
    return p != null && (p.unstable_strictMode === !0 && (y = !0), p.identifierPrefix !== void 0 && (E = p.identifierPrefix), p.onUncaughtError !== void 0 && (T = p.onUncaughtError), p.onCaughtError !== void 0 && (I = p.onCaughtError), p.onRecoverableError !== void 0 && (V = p.onRecoverableError), p.formState !== void 0 && (te = p.formState)), d = fP(
      l,
      1,
      !0,
      d,
      p ?? null,
      y,
      E,
      te,
      T,
      I,
      V,
      kP
    ), d.context = hP(null), p = d.current, y = lo(), y = ip(y), E = Nl(y), E.callback = null, Rl(p, E, y), p = y, d.current.lanes = p, wo(d, p), Is(d), l[Ci] = d.current, ek(l), new Pv(d);
  }, rm.version = "19.2.4", rm;
}
var OP;
function TZ() {
  if (OP) return wk.exports;
  OP = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), wk.exports = _Z(), wk.exports;
}
var a4 = TZ();
const AZ = /* @__PURE__ */ Bc(a4);
var Ek = { exports: {} }, im = {};
var PP;
function MZ() {
  if (PP) return im;
  PP = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.fragment");
  function n(r, i, o) {
    var s = null;
    if (o !== void 0 && (s = "" + o), i.key !== void 0 && (s = "" + i.key), "key" in i) {
      o = {};
      for (var a in i)
        a !== "key" && (o[a] = i[a]);
    } else o = i;
    return i = o.ref, {
      $$typeof: e,
      type: r,
      key: s,
      ref: i !== void 0 ? i : null,
      props: o
    };
  }
  return im.Fragment = t, im.jsx = n, im.jsxs = n, im;
}
var DP;
function NZ() {
  return DP || (DP = 1, Ek.exports = MZ()), Ek.exports;
}
var v = NZ(), RZ = /* @__PURE__ */ Symbol.for("preact-signals");
function iw() {
  if (vc > 1)
    vc--;
  else {
    for (var e, t = !1; Dm !== void 0; ) {
      var n = Dm;
      for (Dm = void 0, HE++; n !== void 0; ) {
        var r = n.o;
        if (n.o = void 0, n.f &= -3, !(8 & n.f) && u4(n)) try {
          n.c();
        } catch (i) {
          t || (e = i, t = !0);
        }
        n = r;
      }
    }
    if (HE = 0, vc--, t) throw e;
  }
}
function OZ(e) {
  if (vc > 0) return e();
  vc++;
  try {
    return e();
  } finally {
    iw();
  }
}
var fn = void 0;
function l4(e) {
  var t = fn;
  fn = void 0;
  try {
    return e();
  } finally {
    fn = t;
  }
}
var Dm = void 0, vc = 0, HE = 0, cb = 0;
function c4(e) {
  if (fn !== void 0) {
    var t = e.n;
    if (t === void 0 || t.t !== fn)
      return t = { i: 0, S: e, p: fn.s, n: void 0, t: fn, e: void 0, x: void 0, r: t }, fn.s !== void 0 && (fn.s.n = t), fn.s = t, e.n = t, 32 & fn.f && e.S(t), t;
    if (t.i === -1)
      return t.i = 0, t.n !== void 0 && (t.n.p = t.p, t.p !== void 0 && (t.p.n = t.n), t.p = fn.s, t.n = void 0, fn.s.n = t, fn.s = t), t;
  }
}
function Kr(e, t) {
  this.v = e, this.i = 0, this.n = void 0, this.t = void 0, this.W = t?.watched, this.Z = t?.unwatched, this.name = t?.name;
}
Kr.prototype.brand = RZ;
Kr.prototype.h = function() {
  return !0;
};
Kr.prototype.S = function(e) {
  var t = this, n = this.t;
  n !== e && e.e === void 0 && (e.x = n, this.t = e, n !== void 0 ? n.e = e : l4(function() {
    var r;
    (r = t.W) == null || r.call(t);
  }));
};
Kr.prototype.U = function(e) {
  var t = this;
  if (this.t !== void 0) {
    var n = e.e, r = e.x;
    n !== void 0 && (n.x = r, e.e = void 0), r !== void 0 && (r.e = n, e.x = void 0), e === this.t && (this.t = r, r === void 0 && l4(function() {
      var i;
      (i = t.Z) == null || i.call(t);
    }));
  }
};
Kr.prototype.subscribe = function(e) {
  var t = this;
  return vd(function() {
    var n = t.value, r = fn;
    fn = void 0;
    try {
      e(n);
    } finally {
      fn = r;
    }
  }, { name: "sub" });
};
Kr.prototype.valueOf = function() {
  return this.value;
};
Kr.prototype.toString = function() {
  return this.value + "";
};
Kr.prototype.toJSON = function() {
  return this.value;
};
Kr.prototype.peek = function() {
  var e = fn;
  fn = void 0;
  try {
    return this.value;
  } finally {
    fn = e;
  }
};
Object.defineProperty(Kr.prototype, "value", { get: function() {
  var e = c4(this);
  return e !== void 0 && (e.i = this.i), this.v;
}, set: function(e) {
  if (e !== this.v) {
    if (HE > 100) throw new Error("Cycle detected");
    this.v = e, this.i++, cb++, vc++;
    try {
      for (var t = this.t; t !== void 0; t = t.x) t.t.N();
    } finally {
      iw();
    }
  }
} });
function Qe(e, t) {
  return new Kr(e, t);
}
function u4(e) {
  for (var t = e.s; t !== void 0; t = t.n) if (t.S.i !== t.i || !t.S.h() || t.S.i !== t.i) return !0;
  return !1;
}
function d4(e) {
  for (var t = e.s; t !== void 0; t = t.n) {
    var n = t.S.n;
    if (n !== void 0 && (t.r = n), t.S.n = t, t.i = -1, t.n === void 0) {
      e.s = t;
      break;
    }
  }
}
function f4(e) {
  for (var t = e.s, n = void 0; t !== void 0; ) {
    var r = t.p;
    t.i === -1 ? (t.S.U(t), r !== void 0 && (r.n = t.n), t.n !== void 0 && (t.n.p = r)) : n = t, t.S.n = t.r, t.r !== void 0 && (t.r = void 0), t = r;
  }
  e.s = n;
}
function yd(e, t) {
  Kr.call(this, void 0), this.x = e, this.s = void 0, this.g = cb - 1, this.f = 4, this.W = t?.watched, this.Z = t?.unwatched, this.name = t?.name;
}
yd.prototype = new Kr();
yd.prototype.h = function() {
  if (this.f &= -3, 1 & this.f) return !1;
  if ((36 & this.f) == 32 || (this.f &= -5, this.g === cb)) return !0;
  if (this.g = cb, this.f |= 1, this.i > 0 && !u4(this))
    return this.f &= -2, !0;
  var e = fn;
  try {
    d4(this), fn = this;
    var t = this.x();
    (16 & this.f || this.v !== t || this.i === 0) && (this.v = t, this.f &= -17, this.i++);
  } catch (n) {
    this.v = n, this.f |= 16, this.i++;
  }
  return fn = e, f4(this), this.f &= -2, !0;
};
yd.prototype.S = function(e) {
  if (this.t === void 0) {
    this.f |= 36;
    for (var t = this.s; t !== void 0; t = t.n) t.S.S(t);
  }
  Kr.prototype.S.call(this, e);
};
yd.prototype.U = function(e) {
  if (this.t !== void 0 && (Kr.prototype.U.call(this, e), this.t === void 0)) {
    this.f &= -33;
    for (var t = this.s; t !== void 0; t = t.n) t.S.U(t);
  }
};
yd.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var e = this.t; e !== void 0; e = e.x) e.t.N();
  }
};
Object.defineProperty(yd.prototype, "value", { get: function() {
  if (1 & this.f) throw new Error("Cycle detected");
  var e = c4(this);
  if (this.h(), e !== void 0 && (e.i = this.i), 16 & this.f) throw this.v;
  return this.v;
} });
function IP(e, t) {
  return new yd(e, t);
}
function h4(e) {
  var t = e.u;
  if (e.u = void 0, typeof t == "function") {
    vc++;
    var n = fn;
    fn = void 0;
    try {
      t();
    } catch (r) {
      throw e.f &= -2, e.f |= 8, lA(e), r;
    } finally {
      fn = n, iw();
    }
  }
}
function lA(e) {
  for (var t = e.s; t !== void 0; t = t.n) t.S.U(t);
  e.x = void 0, e.s = void 0, h4(e);
}
function PZ(e) {
  if (fn !== this) throw new Error("Out-of-order effect");
  f4(this), fn = e, this.f &= -2, 8 & this.f && lA(this), iw();
}
function Ph(e, t) {
  this.x = e, this.u = void 0, this.s = void 0, this.o = void 0, this.f = 32, this.name = t?.name;
}
Ph.prototype.c = function() {
  var e = this.S();
  try {
    if (8 & this.f || this.x === void 0) return;
    var t = this.x();
    typeof t == "function" && (this.u = t);
  } finally {
    e();
  }
};
Ph.prototype.S = function() {
  if (1 & this.f) throw new Error("Cycle detected");
  this.f |= 1, this.f &= -9, h4(this), d4(this), vc++;
  var e = fn;
  return fn = this, PZ.bind(this, e);
};
Ph.prototype.N = function() {
  2 & this.f || (this.f |= 2, this.o = Dm, Dm = this);
};
Ph.prototype.d = function() {
  this.f |= 8, 1 & this.f || lA(this);
};
Ph.prototype.dispose = function() {
  this.d();
};
function vd(e, t) {
  var n = new Ph(e, t);
  try {
    n.c();
  } catch (i) {
    throw n.d(), i;
  }
  var r = n.d.bind(n);
  return r[Symbol.dispose] = r, r;
}
var _k = { exports: {} }, Tk = {};
var jP;
function DZ() {
  if (jP) return Tk;
  jP = 1;
  var e = gd();
  function t(h, m) {
    return h === m && (h !== 0 || 1 / h === 1 / m) || h !== h && m !== m;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, s = e.useDebugValue;
  function a(h, m) {
    var g = m(), b = r({ inst: { value: g, getSnapshot: m } }), x = b[0].inst, w = b[1];
    return o(
      function() {
        x.value = g, x.getSnapshot = m, c(x) && w({ inst: x });
      },
      [h, g, m]
    ), i(
      function() {
        return c(x) && w({ inst: x }), h(function() {
          c(x) && w({ inst: x });
        });
      },
      [h]
    ), s(g), g;
  }
  function c(h) {
    var m = h.getSnapshot;
    h = h.value;
    try {
      var g = m();
      return !n(h, g);
    } catch {
      return !0;
    }
  }
  function u(h, m) {
    return m();
  }
  var f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? u : a;
  return Tk.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : f, Tk;
}
var zP;
function p4() {
  return zP || (zP = 1, _k.exports = DZ()), _k.exports;
}
var fh = p4(), IZ = C.version.split(".").map(Number)[0], jZ = /* @__PURE__ */ Symbol.for(IZ >= 19 ? "react.transitional.element" : "react.element"), zZ = typeof window < "u" && !!window.__PREACT_SIGNALS_DEVTOOLS__, zu, m4 = Symbol.dispose || /* @__PURE__ */ Symbol.for("Symbol.dispose");
function Ak(e, t) {
  var n = t.effect.S();
  return zu = t, LZ.bind(t, e, n);
}
function LZ(e, t) {
  t(), zu = e;
}
var LP, WE, BP = function() {
}, BZ = ((LP = { o: 0, effect: { s: void 0, c: function() {
}, S: function() {
  return BP;
}, d: function() {
} }, subscribe: function() {
  return BP;
}, getSnapshot: function() {
  return 0;
}, S: function() {
}, f: function() {
} })[m4] = function() {
}, LP), $Z = Promise.prototype.then.bind(Promise.resolve());
function UZ() {
  WE || (WE = $Z(g4));
}
function g4() {
  var e;
  WE = void 0, (e = zu) == null || e.f();
}
var FZ = typeof window < "u" ? C.useLayoutEffect : C.useEffect;
function y4(e, t) {
  e === void 0 && (e = 0), UZ();
  var n = C.useRef();
  n.current == null && (typeof window > "u" ? n.current = BZ : n.current = (function(i, o) {
    var s, a, c, u, f = 0, h = vd(function() {
      a = this;
    }, { name: "Component" });
    return a.c = function() {
      if (f = f + 1 | 0, zZ) {
        var m;
        (m = a.y) == null || m.call(a);
      }
      u && u();
    }, (s = { o: i, effect: a, subscribe: function(m) {
      return u = m, function() {
        f = f + 1 | 0, u = void 0, h();
      };
    }, getSnapshot: function() {
      return f;
    }, S: function() {
      if (zu != null) {
        var m = zu.o, g = this.o;
        m == 0 && g == 0 || m == 0 && g == 1 ? (zu.f(), c = Ak(void 0, this)) : m == 1 && g == 0 || m == 2 && g == 0 || (c = Ak(zu, this));
      } else c = Ak(void 0, this);
    }, f: function() {
      var m = c;
      c = void 0, m?.();
    } })[m4] = function() {
      this.f();
    }, s;
  })(e));
  var r = n.current;
  return fh.useSyncExternalStore(r.subscribe, r.getSnapshot, r.getSnapshot), r.S(), e === 0 && FZ(g4), r;
}
Object.defineProperties(Kr.prototype, { $$typeof: { configurable: !0, value: jZ }, type: { configurable: !0, value: function(e) {
  var t = e.data, n = y4(1);
  try {
    return t.value;
  } finally {
    n.f();
  }
} }, props: { configurable: !0, get: function() {
  return { data: this };
} }, ref: { configurable: !0, value: null } });
function v4(e, t) {
  return y4(e);
}
const b4 = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim();
const VZ = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const HZ = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, r) => r ? r.toUpperCase() : n.toLowerCase()
);
const $P = (e) => {
  const t = HZ(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
};
var WZ = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
const qZ = (e) => {
  for (const t in e)
    if (t.startsWith("aria-") || t === "role" || t === "title")
      return !0;
  return !1;
};
const GZ = C.forwardRef(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: i = "",
    children: o,
    iconNode: s,
    ...a
  }, c) => C.createElement(
    "svg",
    {
      ref: c,
      ...WZ,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: r ? Number(n) * 24 / Number(t) : n,
      className: b4("lucide", i),
      ...!o && !qZ(a) && { "aria-hidden": "true" },
      ...a
    },
    [
      ...s.map(([u, f]) => C.createElement(u, f)),
      ...Array.isArray(o) ? o : [o]
    ]
  )
);
const dt = (e, t) => {
  const n = C.forwardRef(
    ({ className: r, ...i }, o) => C.createElement(GZ, {
      ref: o,
      iconNode: t,
      className: b4(
        `lucide-${VZ($P(e))}`,
        `lucide-${e}`,
        r
      ),
      ...i
    })
  );
  return n.displayName = $P(e), n;
};
const KZ = [
  ["path", { d: "m3 16 4 4 4-4", key: "1co6wj" }],
  ["path", { d: "M7 20V4", key: "1yoxec" }],
  ["path", { d: "m21 8-4-4-4 4", key: "1c9v7m" }],
  ["path", { d: "M17 4v16", key: "7dpous" }]
], ZZ = dt("arrow-down-up", KZ);
const YZ = [
  ["path", { d: "M7 7h10v10", key: "1tivn9" }],
  ["path", { d: "M7 17 17 7", key: "1vkiza" }]
], XZ = dt("arrow-up-right", YZ);
const JZ = [
  ["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }],
  ["path", { d: "M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8", key: "7n84p3" }]
], x4 = dt("at-sign", JZ);
const QZ = [
  [
    "path",
    {
      d: "M17 3a2 2 0 0 1 2 2v15a1 1 0 0 1-1.496.868l-4.512-2.578a2 2 0 0 0-1.984 0l-4.512 2.578A1 1 0 0 1 5 20V5a2 2 0 0 1 2-2z",
      key: "oz39mx"
    }
  ],
  ["path", { d: "m9 10 2 2 4-4", key: "1gnqz4" }]
], eY = dt("bookmark-check", QZ);
const tY = [
  [
    "path",
    {
      d: "M17 3a2 2 0 0 1 2 2v15a1 1 0 0 1-1.496.868l-4.512-2.578a2 2 0 0 0-1.984 0l-4.512 2.578A1 1 0 0 1 5 20V5a2 2 0 0 1 2-2z",
      key: "oz39mx"
    }
  ]
], w4 = dt("bookmark", tY);
const nY = [
  ["path", { d: "M12 6V2H8", key: "1155em" }],
  ["path", { d: "M15 11v2", key: "i11awn" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "M20 12h2", key: "1q8mjw" }],
  [
    "path",
    {
      d: "M20 16a2 2 0 0 1-2 2H8.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 4 20.286V8a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2z",
      key: "11gyqh"
    }
  ],
  ["path", { d: "M9 11v2", key: "1ueba0" }]
], cA = dt("bot-message-square", nY);
const rY = [
  ["path", { d: "M12 8V4H8", key: "hb8ula" }],
  ["rect", { width: "16", height: "12", x: "4", y: "8", rx: "2", key: "enze0r" }],
  ["path", { d: "M2 14h2", key: "vft8re" }],
  ["path", { d: "M20 14h2", key: "4cs60a" }],
  ["path", { d: "M15 13v2", key: "1xurst" }],
  ["path", { d: "M9 13v2", key: "rq6x2g" }]
], iY = dt("bot", rY);
const oY = [
  [
    "path",
    {
      d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",
      key: "hh9hay"
    }
  ],
  ["path", { d: "m3.3 7 8.7 5 8.7-5", key: "g66t2b" }],
  ["path", { d: "M12 22V12", key: "d0xqtd" }]
], sY = dt("box", oY);
const aY = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], Tc = dt("check", aY);
const lY = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], Fg = dt("chevron-down", lY);
const cY = [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]], uY = dt("chevron-left", cY);
const dY = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]], Vg = dt("chevron-right", dY);
const fY = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], hY = dt("chevron-up", fY);
const pY = [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
], mY = dt("circle-check-big", pY);
const gY = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "10", x2: "10", y1: "15", y2: "9", key: "c1nkhi" }],
  ["line", { x1: "14", x2: "14", y1: "15", y2: "9", key: "h65svq" }]
], yY = dt("circle-pause", gY);
const vY = [
  ["path", { d: "M12 13v8", key: "1l5pq0" }],
  ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242", key: "1pljnt" }],
  ["path", { d: "m8 17 4-4 4 4", key: "1quai1" }]
], bY = dt("cloud-upload", vY);
const xY = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
], Ac = dt("copy", xY);
const wY = [
  ["path", { d: "M12 15V3", key: "m9g1x1" }],
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["path", { d: "m7 10 5 5 5-5", key: "brsn70" }]
], qE = dt("download", wY);
const SY = [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }],
  ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }]
], kY = dt("ellipsis-vertical", SY);
const CY = [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
], EY = dt("external-link", CY);
const _Y = [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], uA = dt("eye", _Y);
const TY = [
  [
    "path",
    { d: "M12 6a2 2 0 0 1 3.414-1.414l6 6a2 2 0 0 1 0 2.828l-6 6A2 2 0 0 1 12 18z", key: "b19h5q" }
  ],
  [
    "path",
    { d: "M2 6a2 2 0 0 1 3.414-1.414l6 6a2 2 0 0 1 0 2.828l-6 6A2 2 0 0 1 2 18z", key: "h7h5ge" }
  ]
], AY = dt("fast-forward", TY);
const MY = [
  [
    "path",
    {
      d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",
      key: "1oefj6"
    }
  ],
  ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }],
  ["path", { d: "M8 13h2", key: "yr2amv" }],
  ["path", { d: "M14 13h2", key: "un5t4a" }],
  ["path", { d: "M8 17h2", key: "2yhykz" }],
  ["path", { d: "M14 17h2", key: "10kma7" }]
], NY = dt("file-spreadsheet", MY);
const RY = [
  [
    "path",
    {
      d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",
      key: "1oefj6"
    }
  ],
  ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
], OY = dt("file-text", RY);
const PY = [
  [
    "path",
    {
      d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",
      key: "1oefj6"
    }
  ],
  ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }]
], DY = dt("file", PY);
const IY = [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
], jY = dt("grip-vertical", IY);
const zY = [
  ["line", { x1: "4", x2: "20", y1: "9", y2: "9", key: "4lhtct" }],
  ["line", { x1: "4", x2: "20", y1: "15", y2: "15", key: "vyu0kd" }],
  ["line", { x1: "10", x2: "8", y1: "3", y2: "21", key: "1ggp8o" }],
  ["line", { x1: "16", x2: "14", y1: "3", y2: "21", key: "weycgp" }]
], LY = dt("hash", zY);
const BY = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
], $Y = dt("image", BY);
const UY = [
  [
    "path",
    {
      d: "M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5",
      key: "1gvzjb"
    }
  ],
  ["path", { d: "M9 18h6", key: "x1upvd" }],
  ["path", { d: "M10 22h4", key: "ceow96" }]
], FY = dt("lightbulb", UY);
const VY = [
  ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }],
  ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]
], HY = dt("link", VY);
const WY = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]], ea = dt("loader-circle", WY);
const qY = [
  ["path", { d: "M12 2v4", key: "3427ic" }],
  ["path", { d: "m16.2 7.8 2.9-2.9", key: "r700ao" }],
  ["path", { d: "M18 12h4", key: "wj9ykh" }],
  ["path", { d: "m16.2 16.2 2.9 2.9", key: "1bxg5t" }],
  ["path", { d: "M12 18v4", key: "jadmvz" }],
  ["path", { d: "m4.9 19.1 2.9-2.9", key: "bwix9q" }],
  ["path", { d: "M2 12h4", key: "j09sii" }],
  ["path", { d: "m4.9 4.9 2.9 2.9", key: "giyufr" }]
], dA = dt("loader", qY);
const GY = [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "m21 3-7 7", key: "1l2asr" }],
  ["path", { d: "m3 21 7-7", key: "tjx5ai" }],
  ["path", { d: "M9 21H3v-6", key: "wtvkvv" }]
], UP = dt("maximize-2", GY);
const KY = [
  ["path", { d: "M4 5h16", key: "1tepv9" }],
  ["path", { d: "M4 12h16", key: "1lakjw" }],
  ["path", { d: "M4 19h16", key: "1djgab" }]
], ZY = dt("menu", KY);
const YY = [
  [
    "path",
    {
      d: "M2.992 16.342a2 2 0 0 1 .094 1.167l-1.065 3.29a1 1 0 0 0 1.236 1.168l3.413-.998a2 2 0 0 1 1.099.092 10 10 0 1 0-4.777-4.719",
      key: "1sd12s"
    }
  ]
], XY = dt("message-circle", YY);
const JY = [
  [
    "path",
    {
      d: "M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z",
      key: "18887p"
    }
  ],
  ["path", { d: "M7 11h10", key: "1twpyw" }],
  ["path", { d: "M7 15h6", key: "d9of3u" }],
  ["path", { d: "M7 7h8", key: "af5zfr" }]
], QY = dt("message-square-text", JY);
const eX = [
  [
    "path",
    {
      d: "M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z",
      key: "18887p"
    }
  ]
], FP = dt("message-square", eX);
const tX = [
  ["path", { d: "M12 19v3", key: "npa21l" }],
  ["path", { d: "M15 9.34V5a3 3 0 0 0-5.68-1.33", key: "1gzdoj" }],
  ["path", { d: "M16.95 16.95A7 7 0 0 1 5 12v-2", key: "cqa7eg" }],
  ["path", { d: "M18.89 13.23A7 7 0 0 0 19 12v-2", key: "16hl24" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }],
  ["path", { d: "M9 9v3a3 3 0 0 0 5.12 2.12", key: "r2i35w" }]
], nX = dt("mic-off", tX);
const rX = [
  ["path", { d: "M12 19v3", key: "npa21l" }],
  ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
  ["rect", { x: "9", y: "2", width: "6", height: "13", rx: "3", key: "s6n7sd" }]
], iX = dt("mic", rX);
const oX = [
  ["path", { d: "m14 10 7-7", key: "oa77jy" }],
  ["path", { d: "M20 10h-6V4", key: "mjg0md" }],
  ["path", { d: "m3 21 7-7", key: "tjx5ai" }],
  ["path", { d: "M4 14h6v6", key: "rmj7iw" }]
], VP = dt("minimize-2", oX);
const sX = [
  ["rect", { x: "14", y: "3", width: "5", height: "18", rx: "1", key: "kaeet6" }],
  ["rect", { x: "5", y: "3", width: "5", height: "18", rx: "1", key: "1wsw3u" }]
], aX = dt("pause", sX);
const lX = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
], cX = dt("plus", lX);
const uX = [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
], dX = dt("refresh-cw", uX);
const fX = [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
], fA = dt("rotate-ccw", fX);
const hX = [
  ["path", { d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8", key: "1p45f6" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }]
], pX = dt("rotate-cw", hX);
const mX = [
  ["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }],
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]
], gX = dt("search", mX);
const yX = [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
], vX = dt("send", yX);
const bX = [
  ["rect", { width: "20", height: "8", x: "2", y: "2", rx: "2", ry: "2", key: "ngkwjq" }],
  ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2", ry: "2", key: "iecqi9" }],
  ["line", { x1: "6", x2: "6.01", y1: "6", y2: "6", key: "16zg32" }],
  ["line", { x1: "6", x2: "6.01", y1: "18", y2: "18", key: "nzw8ys" }]
], HP = dt("server", bX);
const xX = [
  [
    "path",
    {
      d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
      key: "1i5ecw"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], S4 = dt("settings", xX);
const wX = [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ],
  ["path", { d: "M12 8v4", key: "1got3b" }],
  ["path", { d: "M12 16h.01", key: "1drbdi" }]
], ub = dt("shield-alert", wX);
const SX = [
  ["circle", { cx: "8", cy: "21", r: "1", key: "jimo8o" }],
  ["circle", { cx: "19", cy: "21", r: "1", key: "13723u" }],
  [
    "path",
    {
      d: "M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",
      key: "9zh506"
    }
  ]
], kX = dt("shopping-cart", SX);
const CX = [
  [
    "path",
    {
      d: "M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z",
      key: "1s2grr"
    }
  ],
  ["path", { d: "M20 2v4", key: "1rf3ol" }],
  ["path", { d: "M22 4h-4", key: "gwowj6" }],
  ["circle", { cx: "4", cy: "20", r: "2", key: "6kqj1y" }]
], EX = dt("sparkles", CX);
const _X = [
  ["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }],
  [
    "path",
    {
      d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
      key: "ohrbg2"
    }
  ]
], TX = dt("square-pen", _X);
const AX = [
  ["path", { d: "M15 21v-5a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v5", key: "slp6dd" }],
  [
    "path",
    {
      d: "M17.774 10.31a1.12 1.12 0 0 0-1.549 0 2.5 2.5 0 0 1-3.451 0 1.12 1.12 0 0 0-1.548 0 2.5 2.5 0 0 1-3.452 0 1.12 1.12 0 0 0-1.549 0 2.5 2.5 0 0 1-3.77-3.248l2.889-4.184A2 2 0 0 1 7 2h10a2 2 0 0 1 1.653.873l2.895 4.192a2.5 2.5 0 0 1-3.774 3.244",
      key: "o0xfot"
    }
  ],
  ["path", { d: "M4 10.95V19a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8.05", key: "wn3emo" }]
], MX = dt("store", AX);
const NX = [
  ["polyline", { points: "14.5 17.5 3 6 3 3 6 3 17.5 14.5", key: "1hfsw2" }],
  ["line", { x1: "13", x2: "19", y1: "19", y2: "13", key: "1vrmhu" }],
  ["line", { x1: "16", x2: "20", y1: "16", y2: "20", key: "1bron3" }],
  ["line", { x1: "19", x2: "21", y1: "21", y2: "19", key: "13pww6" }],
  ["polyline", { points: "14.5 6.5 18 3 21 3 21 6 17.5 9.5", key: "hbey2j" }],
  ["line", { x1: "5", x2: "9", y1: "14", y2: "18", key: "1hf58s" }],
  ["line", { x1: "7", x2: "4", y1: "17", y2: "20", key: "pidxm4" }],
  ["line", { x1: "3", x2: "5", y1: "19", y2: "21", key: "1pehsh" }]
], RX = dt("swords", NX);
const OX = [
  ["path", { d: "M10 11v6", key: "nco0om" }],
  ["path", { d: "M14 11v6", key: "outv1u" }],
  ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6", key: "miytrc" }],
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2", key: "e791ji" }]
], k4 = dt("trash-2", OX);
const PX = [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
], DX = dt("triangle-alert", PX);
const IX = [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["path", { d: "M16 3.128a4 4 0 0 1 0 7.744", key: "16gr8j" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
], jX = dt("users", IX);
const zX = [
  ["rect", { width: "8", height: "8", x: "3", y: "3", rx: "2", key: "by2w9f" }],
  ["path", { d: "M7 11v4a2 2 0 0 0 2 2h4", key: "xkn7yn" }],
  ["rect", { width: "8", height: "8", x: "13", y: "13", rx: "2", key: "1cgmvn" }]
], LX = dt("workflow", zX);
const BX = [
  [
    "path",
    {
      d: "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.106-3.105c.32-.322.863-.22.983.218a6 6 0 0 1-8.259 7.057l-7.91 7.91a1 1 0 0 1-2.999-3l7.91-7.91a6 6 0 0 1 7.057-8.259c.438.12.54.662.219.984z",
      key: "1ngwbx"
    }
  ]
], db = dt("wrench", BX);
const $X = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
], Hg = dt("x", $X);
var sl = rw();
const C4 = /* @__PURE__ */ Bc(sl);
function WP(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function Wg(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const o = WP(i, t);
      return !n && typeof o == "function" && (n = !0), o;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const o = r[i];
          typeof o == "function" ? o() : WP(e[i], null);
        }
      };
  };
}
function Ht(...e) {
  return C.useCallback(Wg(...e), e);
}
// @__NO_SIDE_EFFECTS__
function hh(e) {
  const t = /* @__PURE__ */ UX(e), n = C.forwardRef((r, i) => {
    const { children: o, ...s } = r, a = C.Children.toArray(o), c = a.find(VX);
    if (c) {
      const u = c.props.children, f = a.map((h) => h === c ? C.Children.count(u) > 1 ? C.Children.only(null) : C.isValidElement(u) ? u.props.children : null : h);
      return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: C.isValidElement(u) ? C.cloneElement(u, void 0, f) : null });
    }
    return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: o });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function UX(e) {
  const t = C.forwardRef((n, r) => {
    const { children: i, ...o } = n;
    if (C.isValidElement(i)) {
      const s = WX(i), a = HX(o, i.props);
      return i.type !== C.Fragment && (a.ref = r ? Wg(r, s) : s), C.cloneElement(i, a);
    }
    return C.Children.count(i) > 1 ? C.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var E4 = /* @__PURE__ */ Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function FX(e) {
  const t = ({ children: n }) => /* @__PURE__ */ v.jsx(v.Fragment, { children: n });
  return t.displayName = `${e}.Slottable`, t.__radixId = E4, t;
}
function VX(e) {
  return C.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === E4;
}
function HX(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...a) => {
      const c = o(...a);
      return i(...a), c;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function WX(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var qX = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], _t = qX.reduce((e, t) => {
  const n = /* @__PURE__ */ hh(`Primitive.${t}`), r = C.forwardRef((i, o) => {
    const { asChild: s, ...a } = i, c = s ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ v.jsx(c, { ...a, ref: o });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function _4(e, t) {
  e && sl.flushSync(() => e.dispatchEvent(t));
}
var _r = globalThis?.document ? C.useLayoutEffect : () => {
};
function GX(e, t) {
  return C.useReducer((n, r) => t[n][r] ?? n, e);
}
var ji = (e) => {
  const { present: t, children: n } = e, r = KX(t), i = typeof n == "function" ? n({ present: r.isPresent }) : C.Children.only(n), o = Ht(r.ref, ZX(i));
  return typeof n == "function" || r.isPresent ? C.cloneElement(i, { ref: o }) : null;
};
ji.displayName = "Presence";
function KX(e) {
  const [t, n] = C.useState(), r = C.useRef(null), i = C.useRef(e), o = C.useRef("none"), s = e ? "mounted" : "unmounted", [a, c] = GX(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return C.useEffect(() => {
    const u = Iv(r.current);
    o.current = a === "mounted" ? u : "none";
  }, [a]), _r(() => {
    const u = r.current, f = i.current;
    if (f !== e) {
      const m = o.current, g = Iv(u);
      e ? c("MOUNT") : g === "none" || u?.display === "none" ? c("UNMOUNT") : c(f && m !== g ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, c]), _r(() => {
    if (t) {
      let u;
      const f = t.ownerDocument.defaultView ?? window, h = (g) => {
        const x = Iv(r.current).includes(CSS.escape(g.animationName));
        if (g.target === t && x && (c("ANIMATION_END"), !i.current)) {
          const w = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", u = f.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = w);
          });
        }
      }, m = (g) => {
        g.target === t && (o.current = Iv(r.current));
      };
      return t.addEventListener("animationstart", m), t.addEventListener("animationcancel", h), t.addEventListener("animationend", h), () => {
        f.clearTimeout(u), t.removeEventListener("animationstart", m), t.removeEventListener("animationcancel", h), t.removeEventListener("animationend", h);
      };
    } else
      c("ANIMATION_END");
  }, [t, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: C.useCallback((u) => {
      r.current = u ? getComputedStyle(u) : null, n(u);
    }, [])
  };
}
function Iv(e) {
  return e?.animationName || "none";
}
function ZX(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function YX(e, t) {
  const n = C.createContext(t), r = (o) => {
    const { children: s, ...a } = o, c = C.useMemo(() => a, Object.values(a));
    return /* @__PURE__ */ v.jsx(n.Provider, { value: c, children: s });
  };
  r.displayName = e + "Provider";
  function i(o) {
    const s = C.useContext(n);
    if (s) return s;
    if (t !== void 0) return t;
    throw new Error(`\`${o}\` must be used within \`${e}\``);
  }
  return [r, i];
}
function bs(e, t = []) {
  let n = [];
  function r(o, s) {
    const a = C.createContext(s), c = n.length;
    n = [...n, s];
    const u = (h) => {
      const { scope: m, children: g, ...b } = h, x = m?.[e]?.[c] || a, w = C.useMemo(() => b, Object.values(b));
      return /* @__PURE__ */ v.jsx(x.Provider, { value: w, children: g });
    };
    u.displayName = o + "Provider";
    function f(h, m) {
      const g = m?.[e]?.[c] || a, b = C.useContext(g);
      if (b) return b;
      if (s !== void 0) return s;
      throw new Error(`\`${h}\` must be used within \`${o}\``);
    }
    return [u, f];
  }
  const i = () => {
    const o = n.map((s) => C.createContext(s));
    return function(a) {
      const c = a?.[e] || o;
      return C.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: c } }),
        [a, c]
      );
    };
  };
  return i.scopeName = e, [r, XX(i, ...t)];
}
function XX(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(o) {
      const s = r.reduce((a, { useScope: c, scopeName: u }) => {
        const h = c(o)[`__scope${u}`];
        return { ...a, ...h };
      }, {});
      return C.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Ir(e) {
  const t = C.useRef(e);
  return C.useEffect(() => {
    t.current = e;
  }), C.useMemo(() => (...n) => t.current?.(...n), []);
}
var JX = C.createContext(void 0);
function ow(e) {
  const t = C.useContext(JX);
  return e || t || "ltr";
}
function GE(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function Ye(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e?.(i), n === !1 || !i.defaultPrevented)
      return t?.(i);
  };
}
function QX(e, t) {
  return C.useReducer((n, r) => t[n][r] ?? n, e);
}
var hA = "ScrollArea", [T4] = bs(hA), [eJ, Yo] = T4(hA), A4 = C.forwardRef(
  (e, t) => {
    const {
      __scopeScrollArea: n,
      type: r = "hover",
      dir: i,
      scrollHideDelay: o = 600,
      ...s
    } = e, [a, c] = C.useState(null), [u, f] = C.useState(null), [h, m] = C.useState(null), [g, b] = C.useState(null), [x, w] = C.useState(null), [S, _] = C.useState(0), [M, N] = C.useState(0), [D, j] = C.useState(!1), [O, L] = C.useState(!1), U = Ht(t, (G) => c(G)), B = ow(i);
    return /* @__PURE__ */ v.jsx(
      eJ,
      {
        scope: n,
        type: r,
        dir: B,
        scrollHideDelay: o,
        scrollArea: a,
        viewport: u,
        onViewportChange: f,
        content: h,
        onContentChange: m,
        scrollbarX: g,
        onScrollbarXChange: b,
        scrollbarXEnabled: D,
        onScrollbarXEnabledChange: j,
        scrollbarY: x,
        onScrollbarYChange: w,
        scrollbarYEnabled: O,
        onScrollbarYEnabledChange: L,
        onCornerWidthChange: _,
        onCornerHeightChange: N,
        children: /* @__PURE__ */ v.jsx(
          _t.div,
          {
            dir: B,
            ...s,
            ref: U,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": S + "px",
              "--radix-scroll-area-corner-height": M + "px",
              ...e.style
            }
          }
        )
      }
    );
  }
);
A4.displayName = hA;
var M4 = "ScrollAreaViewport", N4 = C.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, children: r, nonce: i, ...o } = e, s = Yo(M4, n), a = C.useRef(null), c = Ht(t, a, s.onViewportChange);
    return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: i
        }
      ),
      /* @__PURE__ */ v.jsx(
        _t.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...o,
          ref: c,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: s.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: s.scrollbarYEnabled ? "scroll" : "hidden",
            ...e.style
          },
          children: /* @__PURE__ */ v.jsx("div", { ref: s.onContentChange, style: { minWidth: "100%", display: "table" }, children: r })
        }
      )
    ] });
  }
);
N4.displayName = M4;
var sa = "ScrollAreaScrollbar", R4 = C.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, i = Yo(sa, e.__scopeScrollArea), { onScrollbarXEnabledChange: o, onScrollbarYEnabledChange: s } = i, a = e.orientation === "horizontal";
    return C.useEffect(() => (a ? o(!0) : s(!0), () => {
      a ? o(!1) : s(!1);
    }), [a, o, s]), i.type === "hover" ? /* @__PURE__ */ v.jsx(tJ, { ...r, ref: t, forceMount: n }) : i.type === "scroll" ? /* @__PURE__ */ v.jsx(nJ, { ...r, ref: t, forceMount: n }) : i.type === "auto" ? /* @__PURE__ */ v.jsx(O4, { ...r, ref: t, forceMount: n }) : i.type === "always" ? /* @__PURE__ */ v.jsx(pA, { ...r, ref: t }) : null;
  }
);
R4.displayName = sa;
var tJ = C.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, i = Yo(sa, e.__scopeScrollArea), [o, s] = C.useState(!1);
  return C.useEffect(() => {
    const a = i.scrollArea;
    let c = 0;
    if (a) {
      const u = () => {
        window.clearTimeout(c), s(!0);
      }, f = () => {
        c = window.setTimeout(() => s(!1), i.scrollHideDelay);
      };
      return a.addEventListener("pointerenter", u), a.addEventListener("pointerleave", f), () => {
        window.clearTimeout(c), a.removeEventListener("pointerenter", u), a.removeEventListener("pointerleave", f);
      };
    }
  }, [i.scrollArea, i.scrollHideDelay]), /* @__PURE__ */ v.jsx(ji, { present: n || o, children: /* @__PURE__ */ v.jsx(
    O4,
    {
      "data-state": o ? "visible" : "hidden",
      ...r,
      ref: t
    }
  ) });
}), nJ = C.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, i = Yo(sa, e.__scopeScrollArea), o = e.orientation === "horizontal", s = aw(() => c("SCROLL_END"), 100), [a, c] = QX("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return C.useEffect(() => {
    if (a === "idle") {
      const u = window.setTimeout(() => c("HIDE"), i.scrollHideDelay);
      return () => window.clearTimeout(u);
    }
  }, [a, i.scrollHideDelay, c]), C.useEffect(() => {
    const u = i.viewport, f = o ? "scrollLeft" : "scrollTop";
    if (u) {
      let h = u[f];
      const m = () => {
        const g = u[f];
        h !== g && (c("SCROLL"), s()), h = g;
      };
      return u.addEventListener("scroll", m), () => u.removeEventListener("scroll", m);
    }
  }, [i.viewport, o, c, s]), /* @__PURE__ */ v.jsx(ji, { present: n || a !== "hidden", children: /* @__PURE__ */ v.jsx(
    pA,
    {
      "data-state": a === "hidden" ? "hidden" : "visible",
      ...r,
      ref: t,
      onPointerEnter: Ye(e.onPointerEnter, () => c("POINTER_ENTER")),
      onPointerLeave: Ye(e.onPointerLeave, () => c("POINTER_LEAVE"))
    }
  ) });
}), O4 = C.forwardRef((e, t) => {
  const n = Yo(sa, e.__scopeScrollArea), { forceMount: r, ...i } = e, [o, s] = C.useState(!1), a = e.orientation === "horizontal", c = aw(() => {
    if (n.viewport) {
      const u = n.viewport.offsetWidth < n.viewport.scrollWidth, f = n.viewport.offsetHeight < n.viewport.scrollHeight;
      s(a ? u : f);
    }
  }, 10);
  return ph(n.viewport, c), ph(n.content, c), /* @__PURE__ */ v.jsx(ji, { present: r || o, children: /* @__PURE__ */ v.jsx(
    pA,
    {
      "data-state": o ? "visible" : "hidden",
      ...i,
      ref: t
    }
  ) });
}), pA = C.forwardRef((e, t) => {
  const { orientation: n = "vertical", ...r } = e, i = Yo(sa, e.__scopeScrollArea), o = C.useRef(null), s = C.useRef(0), [a, c] = C.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), u = z4(a.viewport, a.content), f = {
    ...r,
    sizes: a,
    onSizesChange: c,
    hasThumb: u > 0 && u < 1,
    onThumbChange: (m) => o.current = m,
    onThumbPointerUp: () => s.current = 0,
    onThumbPointerDown: (m) => s.current = m
  };
  function h(m, g) {
    return lJ(m, s.current, a, g);
  }
  return n === "horizontal" ? /* @__PURE__ */ v.jsx(
    rJ,
    {
      ...f,
      ref: t,
      onThumbPositionChange: () => {
        if (i.viewport && o.current) {
          const m = i.viewport.scrollLeft, g = qP(m, a, i.dir);
          o.current.style.transform = `translate3d(${g}px, 0, 0)`;
        }
      },
      onWheelScroll: (m) => {
        i.viewport && (i.viewport.scrollLeft = m);
      },
      onDragScroll: (m) => {
        i.viewport && (i.viewport.scrollLeft = h(m, i.dir));
      }
    }
  ) : n === "vertical" ? /* @__PURE__ */ v.jsx(
    iJ,
    {
      ...f,
      ref: t,
      onThumbPositionChange: () => {
        if (i.viewport && o.current) {
          const m = i.viewport.scrollTop, g = qP(m, a);
          o.current.style.transform = `translate3d(0, ${g}px, 0)`;
        }
      },
      onWheelScroll: (m) => {
        i.viewport && (i.viewport.scrollTop = m);
      },
      onDragScroll: (m) => {
        i.viewport && (i.viewport.scrollTop = h(m));
      }
    }
  ) : null;
}), rJ = C.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: r, ...i } = e, o = Yo(sa, e.__scopeScrollArea), [s, a] = C.useState(), c = C.useRef(null), u = Ht(t, c, o.onScrollbarXChange);
  return C.useEffect(() => {
    c.current && a(getComputedStyle(c.current));
  }, [c]), /* @__PURE__ */ v.jsx(
    D4,
    {
      "data-orientation": "horizontal",
      ...i,
      ref: u,
      sizes: n,
      style: {
        bottom: 0,
        left: o.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: o.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": sw(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (f) => e.onThumbPointerDown(f.x),
      onDragScroll: (f) => e.onDragScroll(f.x),
      onWheelScroll: (f, h) => {
        if (o.viewport) {
          const m = o.viewport.scrollLeft + f.deltaX;
          e.onWheelScroll(m), B4(m, h) && f.preventDefault();
        }
      },
      onResize: () => {
        c.current && o.viewport && s && r({
          content: o.viewport.scrollWidth,
          viewport: o.viewport.offsetWidth,
          scrollbar: {
            size: c.current.clientWidth,
            paddingStart: hb(s.paddingLeft),
            paddingEnd: hb(s.paddingRight)
          }
        });
      }
    }
  );
}), iJ = C.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: r, ...i } = e, o = Yo(sa, e.__scopeScrollArea), [s, a] = C.useState(), c = C.useRef(null), u = Ht(t, c, o.onScrollbarYChange);
  return C.useEffect(() => {
    c.current && a(getComputedStyle(c.current));
  }, [c]), /* @__PURE__ */ v.jsx(
    D4,
    {
      "data-orientation": "vertical",
      ...i,
      ref: u,
      sizes: n,
      style: {
        top: 0,
        right: o.dir === "ltr" ? 0 : void 0,
        left: o.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": sw(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (f) => e.onThumbPointerDown(f.y),
      onDragScroll: (f) => e.onDragScroll(f.y),
      onWheelScroll: (f, h) => {
        if (o.viewport) {
          const m = o.viewport.scrollTop + f.deltaY;
          e.onWheelScroll(m), B4(m, h) && f.preventDefault();
        }
      },
      onResize: () => {
        c.current && o.viewport && s && r({
          content: o.viewport.scrollHeight,
          viewport: o.viewport.offsetHeight,
          scrollbar: {
            size: c.current.clientHeight,
            paddingStart: hb(s.paddingTop),
            paddingEnd: hb(s.paddingBottom)
          }
        });
      }
    }
  );
}), [oJ, P4] = T4(sa), D4 = C.forwardRef((e, t) => {
  const {
    __scopeScrollArea: n,
    sizes: r,
    hasThumb: i,
    onThumbChange: o,
    onThumbPointerUp: s,
    onThumbPointerDown: a,
    onThumbPositionChange: c,
    onDragScroll: u,
    onWheelScroll: f,
    onResize: h,
    ...m
  } = e, g = Yo(sa, n), [b, x] = C.useState(null), w = Ht(t, (U) => x(U)), S = C.useRef(null), _ = C.useRef(""), M = g.viewport, N = r.content - r.viewport, D = Ir(f), j = Ir(c), O = aw(h, 10);
  function L(U) {
    if (S.current) {
      const B = U.clientX - S.current.left, G = U.clientY - S.current.top;
      u({ x: B, y: G });
    }
  }
  return C.useEffect(() => {
    const U = (B) => {
      const G = B.target;
      b?.contains(G) && D(B, N);
    };
    return document.addEventListener("wheel", U, { passive: !1 }), () => document.removeEventListener("wheel", U, { passive: !1 });
  }, [M, b, N, D]), C.useEffect(j, [r, j]), ph(b, O), ph(g.content, O), /* @__PURE__ */ v.jsx(
    oJ,
    {
      scope: n,
      scrollbar: b,
      hasThumb: i,
      onThumbChange: Ir(o),
      onThumbPointerUp: Ir(s),
      onThumbPositionChange: j,
      onThumbPointerDown: Ir(a),
      children: /* @__PURE__ */ v.jsx(
        _t.div,
        {
          ...m,
          ref: w,
          style: { position: "absolute", ...m.style },
          onPointerDown: Ye(e.onPointerDown, (U) => {
            U.button === 0 && (U.target.setPointerCapture(U.pointerId), S.current = b.getBoundingClientRect(), _.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", g.viewport && (g.viewport.style.scrollBehavior = "auto"), L(U));
          }),
          onPointerMove: Ye(e.onPointerMove, L),
          onPointerUp: Ye(e.onPointerUp, (U) => {
            const B = U.target;
            B.hasPointerCapture(U.pointerId) && B.releasePointerCapture(U.pointerId), document.body.style.webkitUserSelect = _.current, g.viewport && (g.viewport.style.scrollBehavior = ""), S.current = null;
          })
        }
      )
    }
  );
}), fb = "ScrollAreaThumb", I4 = C.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, i = P4(fb, e.__scopeScrollArea);
    return /* @__PURE__ */ v.jsx(ji, { present: n || i.hasThumb, children: /* @__PURE__ */ v.jsx(sJ, { ref: t, ...r }) });
  }
), sJ = C.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, style: r, ...i } = e, o = Yo(fb, n), s = P4(fb, n), { onThumbPositionChange: a } = s, c = Ht(
      t,
      (h) => s.onThumbChange(h)
    ), u = C.useRef(void 0), f = aw(() => {
      u.current && (u.current(), u.current = void 0);
    }, 100);
    return C.useEffect(() => {
      const h = o.viewport;
      if (h) {
        const m = () => {
          if (f(), !u.current) {
            const g = cJ(h, a);
            u.current = g, a();
          }
        };
        return a(), h.addEventListener("scroll", m), () => h.removeEventListener("scroll", m);
      }
    }, [o.viewport, f, a]), /* @__PURE__ */ v.jsx(
      _t.div,
      {
        "data-state": s.hasThumb ? "visible" : "hidden",
        ...i,
        ref: c,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...r
        },
        onPointerDownCapture: Ye(e.onPointerDownCapture, (h) => {
          const g = h.target.getBoundingClientRect(), b = h.clientX - g.left, x = h.clientY - g.top;
          s.onThumbPointerDown({ x: b, y: x });
        }),
        onPointerUp: Ye(e.onPointerUp, s.onThumbPointerUp)
      }
    );
  }
);
I4.displayName = fb;
var mA = "ScrollAreaCorner", j4 = C.forwardRef(
  (e, t) => {
    const n = Yo(mA, e.__scopeScrollArea), r = !!(n.scrollbarX && n.scrollbarY);
    return n.type !== "scroll" && r ? /* @__PURE__ */ v.jsx(aJ, { ...e, ref: t }) : null;
  }
);
j4.displayName = mA;
var aJ = C.forwardRef((e, t) => {
  const { __scopeScrollArea: n, ...r } = e, i = Yo(mA, n), [o, s] = C.useState(0), [a, c] = C.useState(0), u = !!(o && a);
  return ph(i.scrollbarX, () => {
    const f = i.scrollbarX?.offsetHeight || 0;
    i.onCornerHeightChange(f), c(f);
  }), ph(i.scrollbarY, () => {
    const f = i.scrollbarY?.offsetWidth || 0;
    i.onCornerWidthChange(f), s(f);
  }), u ? /* @__PURE__ */ v.jsx(
    _t.div,
    {
      ...r,
      ref: t,
      style: {
        width: o,
        height: a,
        position: "absolute",
        right: i.dir === "ltr" ? 0 : void 0,
        left: i.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...e.style
      }
    }
  ) : null;
});
function hb(e) {
  return e ? parseInt(e, 10) : 0;
}
function z4(e, t) {
  const n = e / t;
  return isNaN(n) ? 0 : n;
}
function sw(e) {
  const t = z4(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, r = (e.scrollbar.size - n) * t;
  return Math.max(r, 18);
}
function lJ(e, t, n, r = "ltr") {
  const i = sw(n), o = i / 2, s = t || o, a = i - s, c = n.scrollbar.paddingStart + s, u = n.scrollbar.size - n.scrollbar.paddingEnd - a, f = n.content - n.viewport, h = r === "ltr" ? [0, f] : [f * -1, 0];
  return L4([c, u], h)(e);
}
function qP(e, t, n = "ltr") {
  const r = sw(t), i = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, o = t.scrollbar.size - i, s = t.content - t.viewport, a = o - r, c = n === "ltr" ? [0, s] : [s * -1, 0], u = GE(e, c);
  return L4([0, s], [0, a])(u);
}
function L4(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function B4(e, t) {
  return e > 0 && e < t;
}
var cJ = (e, t = () => {
}) => {
  let n = { left: e.scrollLeft, top: e.scrollTop }, r = 0;
  return (function i() {
    const o = { left: e.scrollLeft, top: e.scrollTop }, s = n.left !== o.left, a = n.top !== o.top;
    (s || a) && t(), n = o, r = window.requestAnimationFrame(i);
  })(), () => window.cancelAnimationFrame(r);
};
function aw(e, t) {
  const n = Ir(e), r = C.useRef(0);
  return C.useEffect(() => () => window.clearTimeout(r.current), []), C.useCallback(() => {
    window.clearTimeout(r.current), r.current = window.setTimeout(n, t);
  }, [n, t]);
}
function ph(e, t) {
  const n = Ir(t);
  _r(() => {
    let r = 0;
    if (e) {
      const i = new ResizeObserver(() => {
        cancelAnimationFrame(r), r = window.requestAnimationFrame(n);
      });
      return i.observe(e), () => {
        window.cancelAnimationFrame(r), i.unobserve(e);
      };
    }
  }, [e, n]);
}
var uJ = A4, dJ = N4, fJ = j4;
function $4(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = $4(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function bc() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = $4(e)) && (r && (r += " "), r += t);
  return r;
}
const hJ = (e, t) => {
  const n = new Array(e.length + t.length);
  for (let r = 0; r < e.length; r++)
    n[r] = e[r];
  for (let r = 0; r < t.length; r++)
    n[e.length + r] = t[r];
  return n;
}, pJ = (e, t) => ({
  classGroupId: e,
  validator: t
}), U4 = (e = /* @__PURE__ */ new Map(), t = null, n) => ({
  nextPart: e,
  validators: t,
  classGroupId: n
}), pb = "-", GP = [], mJ = "arbitrary..", gJ = (e) => {
  const t = vJ(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: r
  } = e;
  return {
    getClassGroupId: (s) => {
      if (s.startsWith("[") && s.endsWith("]"))
        return yJ(s);
      const a = s.split(pb), c = a[0] === "" && a.length > 1 ? 1 : 0;
      return F4(a, c, t);
    },
    getConflictingClassGroupIds: (s, a) => {
      if (a) {
        const c = r[s], u = n[s];
        return c ? u ? hJ(u, c) : c : u || GP;
      }
      return n[s] || GP;
    }
  };
}, F4 = (e, t, n) => {
  if (e.length - t === 0)
    return n.classGroupId;
  const i = e[t], o = n.nextPart.get(i);
  if (o) {
    const u = F4(e, t + 1, o);
    if (u) return u;
  }
  const s = n.validators;
  if (s === null)
    return;
  const a = t === 0 ? e.join(pb) : e.slice(t).join(pb), c = s.length;
  for (let u = 0; u < c; u++) {
    const f = s[u];
    if (f.validator(a))
      return f.classGroupId;
  }
}, yJ = (e) => e.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const t = e.slice(1, -1), n = t.indexOf(":"), r = t.slice(0, n);
  return r ? mJ + r : void 0;
})(), vJ = (e) => {
  const {
    theme: t,
    classGroups: n
  } = e;
  return bJ(n, t);
}, bJ = (e, t) => {
  const n = U4();
  for (const r in e) {
    const i = e[r];
    gA(i, n, r, t);
  }
  return n;
}, gA = (e, t, n, r) => {
  const i = e.length;
  for (let o = 0; o < i; o++) {
    const s = e[o];
    xJ(s, t, n, r);
  }
}, xJ = (e, t, n, r) => {
  if (typeof e == "string") {
    wJ(e, t, n);
    return;
  }
  if (typeof e == "function") {
    SJ(e, t, n, r);
    return;
  }
  kJ(e, t, n, r);
}, wJ = (e, t, n) => {
  const r = e === "" ? t : V4(t, e);
  r.classGroupId = n;
}, SJ = (e, t, n, r) => {
  if (CJ(e)) {
    gA(e(r), t, n, r);
    return;
  }
  t.validators === null && (t.validators = []), t.validators.push(pJ(n, e));
}, kJ = (e, t, n, r) => {
  const i = Object.entries(e), o = i.length;
  for (let s = 0; s < o; s++) {
    const [a, c] = i[s];
    gA(c, V4(t, a), n, r);
  }
}, V4 = (e, t) => {
  let n = e;
  const r = t.split(pb), i = r.length;
  for (let o = 0; o < i; o++) {
    const s = r[o];
    let a = n.nextPart.get(s);
    a || (a = U4(), n.nextPart.set(s, a)), n = a;
  }
  return n;
}, CJ = (e) => "isThemeGetter" in e && e.isThemeGetter === !0, EJ = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  const i = (o, s) => {
    n[o] = s, t++, t > e && (t = 0, r = n, n = /* @__PURE__ */ Object.create(null));
  };
  return {
    get(o) {
      let s = n[o];
      if (s !== void 0)
        return s;
      if ((s = r[o]) !== void 0)
        return i(o, s), s;
    },
    set(o, s) {
      o in n ? n[o] = s : i(o, s);
    }
  };
}, KE = "!", KP = ":", _J = [], ZP = (e, t, n, r, i) => ({
  modifiers: e,
  hasImportantModifier: t,
  baseClassName: n,
  maybePostfixModifierPosition: r,
  isExternal: i
}), TJ = (e) => {
  const {
    prefix: t,
    experimentalParseClassName: n
  } = e;
  let r = (i) => {
    const o = [];
    let s = 0, a = 0, c = 0, u;
    const f = i.length;
    for (let x = 0; x < f; x++) {
      const w = i[x];
      if (s === 0 && a === 0) {
        if (w === KP) {
          o.push(i.slice(c, x)), c = x + 1;
          continue;
        }
        if (w === "/") {
          u = x;
          continue;
        }
      }
      w === "[" ? s++ : w === "]" ? s-- : w === "(" ? a++ : w === ")" && a--;
    }
    const h = o.length === 0 ? i : i.slice(c);
    let m = h, g = !1;
    h.endsWith(KE) ? (m = h.slice(0, -1), g = !0) : (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      h.startsWith(KE) && (m = h.slice(1), g = !0)
    );
    const b = u && u > c ? u - c : void 0;
    return ZP(o, g, m, b);
  };
  if (t) {
    const i = t + KP, o = r;
    r = (s) => s.startsWith(i) ? o(s.slice(i.length)) : ZP(_J, !1, s, void 0, !0);
  }
  if (n) {
    const i = r;
    r = (o) => n({
      className: o,
      parseClassName: i
    });
  }
  return r;
}, AJ = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.orderSensitiveModifiers.forEach((n, r) => {
    t.set(n, 1e6 + r);
  }), (n) => {
    const r = [];
    let i = [];
    for (let o = 0; o < n.length; o++) {
      const s = n[o], a = s[0] === "[", c = t.has(s);
      a || c ? (i.length > 0 && (i.sort(), r.push(...i), i = []), r.push(s)) : i.push(s);
    }
    return i.length > 0 && (i.sort(), r.push(...i)), r;
  };
}, MJ = (e) => ({
  cache: EJ(e.cacheSize),
  parseClassName: TJ(e),
  sortModifiers: AJ(e),
  ...gJ(e)
}), NJ = /\s+/, RJ = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: r,
    getConflictingClassGroupIds: i,
    sortModifiers: o
  } = t, s = [], a = e.trim().split(NJ);
  let c = "";
  for (let u = a.length - 1; u >= 0; u -= 1) {
    const f = a[u], {
      isExternal: h,
      modifiers: m,
      hasImportantModifier: g,
      baseClassName: b,
      maybePostfixModifierPosition: x
    } = n(f);
    if (h) {
      c = f + (c.length > 0 ? " " + c : c);
      continue;
    }
    let w = !!x, S = r(w ? b.substring(0, x) : b);
    if (!S) {
      if (!w) {
        c = f + (c.length > 0 ? " " + c : c);
        continue;
      }
      if (S = r(b), !S) {
        c = f + (c.length > 0 ? " " + c : c);
        continue;
      }
      w = !1;
    }
    const _ = m.length === 0 ? "" : m.length === 1 ? m[0] : o(m).join(":"), M = g ? _ + KE : _, N = M + S;
    if (s.indexOf(N) > -1)
      continue;
    s.push(N);
    const D = i(S, w);
    for (let j = 0; j < D.length; ++j) {
      const O = D[j];
      s.push(M + O);
    }
    c = f + (c.length > 0 ? " " + c : c);
  }
  return c;
}, OJ = (...e) => {
  let t = 0, n, r, i = "";
  for (; t < e.length; )
    (n = e[t++]) && (r = H4(n)) && (i && (i += " "), i += r);
  return i;
}, H4 = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let r = 0; r < e.length; r++)
    e[r] && (t = H4(e[r])) && (n && (n += " "), n += t);
  return n;
}, PJ = (e, ...t) => {
  let n, r, i, o;
  const s = (c) => {
    const u = t.reduce((f, h) => h(f), e());
    return n = MJ(u), r = n.cache.get, i = n.cache.set, o = a, a(c);
  }, a = (c) => {
    const u = r(c);
    if (u)
      return u;
    const f = RJ(c, n);
    return i(c, f), f;
  };
  return o = s, (...c) => o(OJ(...c));
}, DJ = [], Rr = (e) => {
  const t = (n) => n[e] || DJ;
  return t.isThemeGetter = !0, t;
}, W4 = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, q4 = /^\((?:(\w[\w-]*):)?(.+)\)$/i, IJ = /^\d+\/\d+$/, jJ = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, zJ = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, LJ = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, BJ = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, $J = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, xf = (e) => IJ.test(e), Ut = (e) => !!e && !Number.isNaN(Number(e)), Gl = (e) => !!e && Number.isInteger(Number(e)), Mk = (e) => e.endsWith("%") && Ut(e.slice(0, -1)), La = (e) => jJ.test(e), UJ = () => !0, FJ = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  zJ.test(e) && !LJ.test(e)
), G4 = () => !1, VJ = (e) => BJ.test(e), HJ = (e) => $J.test(e), WJ = (e) => !ot(e) && !st(e), qJ = (e) => Dh(e, Y4, G4), ot = (e) => W4.test(e), Tu = (e) => Dh(e, X4, FJ), Nk = (e) => Dh(e, XJ, Ut), YP = (e) => Dh(e, K4, G4), GJ = (e) => Dh(e, Z4, HJ), jv = (e) => Dh(e, J4, VJ), st = (e) => q4.test(e), om = (e) => Ih(e, X4), KJ = (e) => Ih(e, JJ), XP = (e) => Ih(e, K4), ZJ = (e) => Ih(e, Y4), YJ = (e) => Ih(e, Z4), zv = (e) => Ih(e, J4, !0), Dh = (e, t, n) => {
  const r = W4.exec(e);
  return r ? r[1] ? t(r[1]) : n(r[2]) : !1;
}, Ih = (e, t, n = !1) => {
  const r = q4.exec(e);
  return r ? r[1] ? t(r[1]) : n : !1;
}, K4 = (e) => e === "position" || e === "percentage", Z4 = (e) => e === "image" || e === "url", Y4 = (e) => e === "length" || e === "size" || e === "bg-size", X4 = (e) => e === "length", XJ = (e) => e === "number", JJ = (e) => e === "family-name", J4 = (e) => e === "shadow", QJ = () => {
  const e = Rr("color"), t = Rr("font"), n = Rr("text"), r = Rr("font-weight"), i = Rr("tracking"), o = Rr("leading"), s = Rr("breakpoint"), a = Rr("container"), c = Rr("spacing"), u = Rr("radius"), f = Rr("shadow"), h = Rr("inset-shadow"), m = Rr("text-shadow"), g = Rr("drop-shadow"), b = Rr("blur"), x = Rr("perspective"), w = Rr("aspect"), S = Rr("ease"), _ = Rr("animate"), M = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], N = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], D = () => [...N(), st, ot], j = () => ["auto", "hidden", "clip", "visible", "scroll"], O = () => ["auto", "contain", "none"], L = () => [st, ot, c], U = () => [xf, "full", "auto", ...L()], B = () => [Gl, "none", "subgrid", st, ot], G = () => ["auto", {
    span: ["full", Gl, st, ot]
  }, Gl, st, ot], Y = () => [Gl, "auto", st, ot], he = () => ["auto", "min", "max", "fr", st, ot], ie = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], ne = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], H = () => ["auto", ...L()], Q = () => [xf, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...L()], X = () => [e, st, ot], Se = () => [...N(), XP, YP, {
    position: [st, ot]
  }], W = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], Z = () => ["auto", "cover", "contain", ZJ, qJ, {
    size: [st, ot]
  }], pe = () => [Mk, om, Tu], F = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    u,
    st,
    ot
  ], ee = () => ["", Ut, om, Tu], ge = () => ["solid", "dashed", "dotted", "double"], re = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], J = () => [Ut, Mk, XP, YP], xe = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    b,
    st,
    ot
  ], be = () => ["none", Ut, st, ot], Ae = () => ["none", Ut, st, ot], nt = () => [Ut, st, ot], Ge = () => [xf, "full", ...L()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [La],
      breakpoint: [La],
      color: [UJ],
      container: [La],
      "drop-shadow": [La],
      ease: ["in", "out", "in-out"],
      font: [WJ],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [La],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [La],
      shadow: [La],
      spacing: ["px", Ut],
      text: [La],
      "text-shadow": [La],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", xf, ot, st, w]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Ut, ot, st, a]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": M()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": M()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: D()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: j()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": j()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": j()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: O()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": O()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": O()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: U()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": U()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": U()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: U()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: U()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: U()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: U()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: U()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: U()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [Gl, "auto", st, ot]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [xf, "full", "auto", a, ...L()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [Ut, xf, "auto", "initial", "none", ot]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", Ut, st, ot]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", Ut, st, ot]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [Gl, "first", "last", "none", st, ot]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": B()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: G()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": Y()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": Y()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": B()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: G()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": Y()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": Y()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": he()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": he()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: L()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": L()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": L()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...ie(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...ne(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...ne()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ie()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...ne(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...ne(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": ie()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...ne(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...ne()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: L()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: L()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: L()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: L()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: L()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: L()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: L()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: L()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: L()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: H()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: H()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: H()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: H()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: H()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: H()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: H()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: H()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: H()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": L()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": L()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: Q()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [a, "screen", ...Q()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          a,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...Q()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          a,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [s]
          },
          ...Q()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...Q()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...Q()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...Q()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", n, om, Tu]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [r, st, Nk]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", Mk, ot]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [KJ, ot, t]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [i, st, ot]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [Ut, "none", st, Nk]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          o,
          ...L()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", st, ot]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", st, ot]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: X()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: X()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...ge(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [Ut, "from-font", "auto", st, Tu]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: X()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [Ut, "auto", st, ot]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: L()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", st, ot]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", st, ot]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: Se()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: W()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: Z()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, Gl, st, ot],
          radial: ["", st, ot],
          conic: [Gl, st, ot]
        }, YJ, GJ]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: X()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: pe()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: pe()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: pe()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: X()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: X()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: X()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: F()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": F()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": F()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": F()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": F()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": F()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": F()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": F()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": F()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": F()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": F()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": F()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": F()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": F()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": F()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: ee()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": ee()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": ee()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": ee()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": ee()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": ee()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": ee()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": ee()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": ee()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": ee()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": ee()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...ge(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...ge(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: X()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": X()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": X()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": X()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": X()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": X()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": X()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": X()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": X()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: X()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...ge(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Ut, st, ot]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", Ut, om, Tu]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: X()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          f,
          zv,
          jv
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: X()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", h, zv, jv]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": X()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: ee()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: X()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [Ut, Tu]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": X()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": ee()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": X()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", m, zv, jv]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": X()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [Ut, st, ot]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...re(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": re()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [Ut]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": J()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": J()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": X()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": X()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": J()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": J()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": X()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": X()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": J()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": J()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": X()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": X()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": J()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": J()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": X()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": X()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": J()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": J()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": X()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": X()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": J()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": J()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": X()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": X()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": J()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": J()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": X()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": X()
      }],
      "mask-image-radial": [{
        "mask-radial": [st, ot]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": J()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": J()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": X()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": X()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": N()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [Ut]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": J()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": J()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": X()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": X()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: Se()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: W()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: Z()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", st, ot]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          st,
          ot
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: xe()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [Ut, st, ot]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [Ut, st, ot]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          g,
          zv,
          jv
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": X()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", Ut, st, ot]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [Ut, st, ot]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", Ut, st, ot]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [Ut, st, ot]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", Ut, st, ot]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          st,
          ot
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": xe()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [Ut, st, ot]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [Ut, st, ot]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", Ut, st, ot]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [Ut, st, ot]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", Ut, st, ot]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [Ut, st, ot]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [Ut, st, ot]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", Ut, st, ot]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": L()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": L()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": L()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", st, ot]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [Ut, "initial", st, ot]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", S, st, ot]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [Ut, st, ot]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", _, st, ot]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [x, st, ot]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": D()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: be()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": be()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": be()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": be()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: Ae()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": Ae()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": Ae()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": Ae()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: nt()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": nt()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": nt()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [st, ot, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: D()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: Ge()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": Ge()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": Ge()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": Ge()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: X()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: X()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", st, ot]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": L()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": L()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": L()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": L()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": L()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": L()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": L()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": L()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": L()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": L()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": L()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": L()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": L()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": L()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": L()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": L()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": L()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": L()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", st, ot]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...X()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Ut, om, Tu, Nk]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...X()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, eQ = /* @__PURE__ */ PJ(QJ);
function lt(...e) {
  return eQ(bc(e));
}
function yA({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsxs(
    uJ,
    {
      "data-slot": "scroll-area",
      className: lt("relative", e),
      ...n,
      children: [
        /* @__PURE__ */ v.jsx(
          dJ,
          {
            "data-slot": "scroll-area-viewport",
            className: "focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1",
            children: t
          }
        ),
        /* @__PURE__ */ v.jsx(tQ, {}),
        /* @__PURE__ */ v.jsx(fJ, {})
      ]
    }
  );
}
function tQ({
  className: e,
  orientation: t = "vertical",
  ...n
}) {
  return /* @__PURE__ */ v.jsx(
    R4,
    {
      "data-slot": "scroll-area-scrollbar",
      orientation: t,
      className: lt(
        "flex touch-none p-px transition-colors select-none",
        t === "vertical" && "h-full w-2.5 border-l border-l-transparent",
        t === "horizontal" && "h-2.5 flex-col border-t border-t-transparent",
        e
      ),
      ...n,
      children: /* @__PURE__ */ v.jsx(
        I4,
        {
          "data-slot": "scroll-area-thumb",
          className: "bg-border relative flex-1 rounded-full"
        }
      )
    }
  );
}
const vA = C.createContext({});
function qg(e) {
  const t = C.useRef(null);
  return t.current === null && (t.current = e()), t.current;
}
const Q4 = typeof window < "u", bA = Q4 ? C.useLayoutEffect : C.useEffect, lw = /* @__PURE__ */ C.createContext(null);
function xA(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function Gg(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
const ta = (e, t, n) => n > t ? t : n < e ? e : n;
let wA = () => {
};
const el = {}, eB = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
function tB(e) {
  return typeof e == "object" && e !== null;
}
const nB = (e) => /^0[^.\s]+$/u.test(e);
// @__NO_SIDE_EFFECTS__
function SA(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const Ho = /* @__NO_SIDE_EFFECTS__ */ (e) => e, nQ = (e, t) => (n) => t(e(n)), Kg = (...e) => e.reduce(nQ), mh = /* @__NO_SIDE_EFFECTS__ */ (e, t, n) => {
  const r = t - e;
  return r === 0 ? 1 : (n - e) / r;
};
class kA {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return xA(this.subscriptions, t), () => Gg(this.subscriptions, t);
  }
  notify(t, n, r) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](t, n, r);
      else
        for (let o = 0; o < i; o++) {
          const s = this.subscriptions[o];
          s && s(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const Xs = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, Fo = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3;
function rB(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const rQ = (e, t, n) => {
  const r = t - e;
  return ((n - e) % r + r) % r + e;
}, iB = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, iQ = 1e-7, oQ = 12;
function sQ(e, t, n, r, i) {
  let o, s, a = 0;
  do
    s = t + (n - t) / 2, o = iB(s, r, i) - e, o > 0 ? n = s : t = s;
  while (Math.abs(o) > iQ && ++a < oQ);
  return s;
}
function Zg(e, t, n, r) {
  if (e === t && n === r)
    return Ho;
  const i = (o) => sQ(o, 0, 1, e, n);
  return (o) => o === 0 || o === 1 ? o : iB(i(o), t, r);
}
const oB = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, sB = (e) => (t) => 1 - e(1 - t), aB = /* @__PURE__ */ Zg(0.33, 1.53, 0.69, 0.99), CA = /* @__PURE__ */ sB(aB), lB = /* @__PURE__ */ oB(CA), cB = (e) => (e *= 2) < 1 ? 0.5 * CA(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), EA = (e) => 1 - Math.sin(Math.acos(e)), uB = sB(EA), dB = oB(EA), aQ = /* @__PURE__ */ Zg(0.42, 0, 1, 1), lQ = /* @__PURE__ */ Zg(0, 0, 0.58, 1), fB = /* @__PURE__ */ Zg(0.42, 0, 0.58, 1), hB = (e) => Array.isArray(e) && typeof e[0] != "number";
function pB(e, t) {
  return hB(e) ? e[rQ(0, e.length, t)] : e;
}
const mB = (e) => Array.isArray(e) && typeof e[0] == "number", cQ = {
  linear: Ho,
  easeIn: aQ,
  easeInOut: fB,
  easeOut: lQ,
  circIn: EA,
  circInOut: dB,
  circOut: uB,
  backIn: CA,
  backInOut: lB,
  backOut: aB,
  anticipate: cB
}, uQ = (e) => typeof e == "string", JP = (e) => {
  if (mB(e)) {
    wA(e.length === 4);
    const [t, n, r, i] = e;
    return Zg(t, n, r, i);
  } else if (uQ(e))
    return cQ[e];
  return e;
}, Lv = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function dQ(e, t) {
  let n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), i = !1, o = !1;
  const s = /* @__PURE__ */ new WeakSet();
  let a = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function c(f) {
    s.has(f) && (u.schedule(f), e()), f(a);
  }
  const u = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (f, h = !1, m = !1) => {
      const b = m && i ? n : r;
      return h && s.add(f), b.has(f) || b.add(f), f;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (f) => {
      r.delete(f), s.delete(f);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (f) => {
      if (a = f, i) {
        o = !0;
        return;
      }
      i = !0, [n, r] = [r, n], n.forEach(c), n.clear(), i = !1, o && (o = !1, u.process(f));
    }
  };
  return u;
}
const fQ = 40;
function gB(e, t) {
  let n = !1, r = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, o = () => n = !0, s = Lv.reduce((M, N) => (M[N] = dQ(o), M), {}), { setup: a, read: c, resolveKeyframes: u, preUpdate: f, update: h, preRender: m, render: g, postRender: b } = s, x = () => {
    const M = el.useManualTiming ? i.timestamp : performance.now();
    n = !1, el.useManualTiming || (i.delta = r ? 1e3 / 60 : Math.max(Math.min(M - i.timestamp, fQ), 1)), i.timestamp = M, i.isProcessing = !0, a.process(i), c.process(i), u.process(i), f.process(i), h.process(i), m.process(i), g.process(i), b.process(i), i.isProcessing = !1, n && t && (r = !1, e(x));
  }, w = () => {
    n = !0, r = !0, i.isProcessing || e(x);
  };
  return { schedule: Lv.reduce((M, N) => {
    const D = s[N];
    return M[N] = (j, O = !1, L = !1) => (n || w(), D.schedule(j, O, L)), M;
  }, {}), cancel: (M) => {
    for (let N = 0; N < Lv.length; N++)
      s[Lv[N]].cancel(M);
  }, state: i, steps: s };
}
const { schedule: Tn, cancel: tl, state: ni, steps: Rk } = /* @__PURE__ */ gB(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Ho, !0);
let M0;
function hQ() {
  M0 = void 0;
}
const Oi = {
  now: () => (M0 === void 0 && Oi.set(ni.isProcessing || el.useManualTiming ? ni.timestamp : performance.now()), M0),
  set: (e) => {
    M0 = e, queueMicrotask(hQ);
  }
}, yB = (e) => (t) => typeof t == "string" && t.startsWith(e), vB = /* @__PURE__ */ yB("--"), pQ = /* @__PURE__ */ yB("var(--"), _A = (e) => pQ(e) ? mQ.test(e.split("/*")[0].trim()) : !1, mQ = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
function QP(e) {
  return typeof e != "string" ? !1 : e.split("/*")[0].includes("var(--");
}
const jh = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, og = {
  ...jh,
  transform: (e) => ta(0, 1, e)
}, Bv = {
  ...jh,
  default: 1
}, Im = (e) => Math.round(e * 1e5) / 1e5, TA = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function gQ(e) {
  return e == null;
}
const yQ = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, AA = (e, t) => (n) => !!(typeof n == "string" && yQ.test(n) && n.startsWith(e) || t && !gQ(n) && Object.prototype.hasOwnProperty.call(n, t)), bB = (e, t, n) => (r) => {
  if (typeof r != "string")
    return r;
  const [i, o, s, a] = r.match(TA);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(o),
    [n]: parseFloat(s),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, vQ = (e) => ta(0, 255, e), Ok = {
  ...jh,
  transform: (e) => Math.round(vQ(e))
}, Lu = {
  test: /* @__PURE__ */ AA("rgb", "red"),
  parse: /* @__PURE__ */ bB("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + Ok.transform(e) + ", " + Ok.transform(t) + ", " + Ok.transform(n) + ", " + Im(og.transform(r)) + ")"
};
function bQ(e) {
  let t = "", n = "", r = "", i = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const ZE = {
  test: /* @__PURE__ */ AA("#"),
  parse: bQ,
  transform: Lu.transform
}, Yg = /* @__NO_SIDE_EFFECTS__ */ (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), Jl = /* @__PURE__ */ Yg("deg"), Js = /* @__PURE__ */ Yg("%"), at = /* @__PURE__ */ Yg("px"), xQ = /* @__PURE__ */ Yg("vh"), wQ = /* @__PURE__ */ Yg("vw"), eD = {
  ...Js,
  parse: (e) => Js.parse(e) / 100,
  transform: (e) => Js.transform(e * 100)
}, Vf = {
  test: /* @__PURE__ */ AA("hsl", "hue"),
  parse: /* @__PURE__ */ bB("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + Js.transform(Im(t)) + ", " + Js.transform(Im(n)) + ", " + Im(og.transform(r)) + ")"
}, kr = {
  test: (e) => Lu.test(e) || ZE.test(e) || Vf.test(e),
  parse: (e) => Lu.test(e) ? Lu.parse(e) : Vf.test(e) ? Vf.parse(e) : ZE.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? Lu.transform(e) : Vf.transform(e),
  getAnimatableNone: (e) => {
    const t = kr.parse(e);
    return t.alpha = 0, kr.transform(t);
  }
}, SQ = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function kQ(e) {
  return isNaN(e) && typeof e == "string" && (e.match(TA)?.length || 0) + (e.match(SQ)?.length || 0) > 0;
}
const xB = "number", wB = "color", CQ = "var", EQ = "var(", tD = "${}", _Q = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function sg(e) {
  const t = e.toString(), n = [], r = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let o = 0;
  const a = t.replace(_Q, (c) => (kr.test(c) ? (r.color.push(o), i.push(wB), n.push(kr.parse(c))) : c.startsWith(EQ) ? (r.var.push(o), i.push(CQ), n.push(c)) : (r.number.push(o), i.push(xB), n.push(parseFloat(c))), ++o, tD)).split(tD);
  return { values: n, split: a, indexes: r, types: i };
}
function SB(e) {
  return sg(e).values;
}
function kB(e) {
  const { split: t, types: n } = sg(e), r = t.length;
  return (i) => {
    let o = "";
    for (let s = 0; s < r; s++)
      if (o += t[s], i[s] !== void 0) {
        const a = n[s];
        a === xB ? o += Im(i[s]) : a === wB ? o += kr.transform(i[s]) : o += i[s];
      }
    return o;
  };
}
const TQ = (e) => typeof e == "number" ? 0 : kr.test(e) ? kr.getAnimatableNone(e) : e;
function AQ(e) {
  const t = SB(e);
  return kB(e)(t.map(TQ));
}
const Mc = {
  test: kQ,
  parse: SB,
  createTransformer: kB,
  getAnimatableNone: AQ
};
function Pk(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function MQ({ hue: e, saturation: t, lightness: n, alpha: r }) {
  e /= 360, t /= 100, n /= 100;
  let i = 0, o = 0, s = 0;
  if (!t)
    i = o = s = n;
  else {
    const a = n < 0.5 ? n * (1 + t) : n + t - n * t, c = 2 * n - a;
    i = Pk(c, a, e + 1 / 3), o = Pk(c, a, e), s = Pk(c, a, e - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(o * 255),
    blue: Math.round(s * 255),
    alpha: r
  };
}
function mb(e, t) {
  return (n) => n > 0 ? t : e;
}
const Kn = (e, t, n) => e + (t - e) * n, Dk = (e, t, n) => {
  const r = e * e, i = n * (t * t - r) + r;
  return i < 0 ? 0 : Math.sqrt(i);
}, NQ = [ZE, Lu, Vf], RQ = (e) => NQ.find((t) => t.test(e));
function nD(e) {
  const t = RQ(e);
  if (!t)
    return !1;
  let n = t.parse(e);
  return t === Vf && (n = MQ(n)), n;
}
const rD = (e, t) => {
  const n = nD(e), r = nD(t);
  if (!n || !r)
    return mb(e, t);
  const i = { ...n };
  return (o) => (i.red = Dk(n.red, r.red, o), i.green = Dk(n.green, r.green, o), i.blue = Dk(n.blue, r.blue, o), i.alpha = Kn(n.alpha, r.alpha, o), Lu.transform(i));
}, YE = /* @__PURE__ */ new Set(["none", "hidden"]);
function OQ(e, t) {
  return YE.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function PQ(e, t) {
  return (n) => Kn(e, t, n);
}
function MA(e) {
  return typeof e == "number" ? PQ : typeof e == "string" ? _A(e) ? mb : kr.test(e) ? rD : jQ : Array.isArray(e) ? CB : typeof e == "object" ? kr.test(e) ? rD : DQ : mb;
}
function CB(e, t) {
  const n = [...e], r = n.length, i = e.map((o, s) => MA(o)(o, t[s]));
  return (o) => {
    for (let s = 0; s < r; s++)
      n[s] = i[s](o);
    return n;
  };
}
function DQ(e, t) {
  const n = { ...e, ...t }, r = {};
  for (const i in n)
    e[i] !== void 0 && t[i] !== void 0 && (r[i] = MA(e[i])(e[i], t[i]));
  return (i) => {
    for (const o in r)
      n[o] = r[o](i);
    return n;
  };
}
function IQ(e, t) {
  const n = [], r = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < t.values.length; i++) {
    const o = t.types[i], s = e.indexes[o][r[o]], a = e.values[s] ?? 0;
    n[i] = a, r[o]++;
  }
  return n;
}
const jQ = (e, t) => {
  const n = Mc.createTransformer(t), r = sg(e), i = sg(t);
  return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? YE.has(e) && !i.values.length || YE.has(t) && !r.values.length ? OQ(e, t) : Kg(CB(IQ(r, i), i.values), n) : mb(e, t);
};
function EB(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? Kn(e, t, n) : MA(e)(e, t);
}
const zQ = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: (n = !0) => Tn.update(t, n),
    stop: () => tl(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => ni.isProcessing ? ni.timestamp : Oi.now()
  };
}, _B = (e, t, n = 10) => {
  let r = "";
  const i = Math.max(Math.round(t / n), 2);
  for (let o = 0; o < i; o++)
    r += Math.round(e(o / (i - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
}, gb = 2e4;
function NA(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < gb; )
    t += n, r = e.next(t);
  return t >= gb ? 1 / 0 : t;
}
function TB(e, t = 100, n) {
  const r = n({ ...e, keyframes: [0, t] }), i = Math.min(NA(r), gb);
  return {
    type: "keyframes",
    ease: (o) => r.next(i * o).value / t,
    duration: /* @__PURE__ */ Fo(i)
  };
}
const LQ = 5;
function AB(e, t, n) {
  const r = Math.max(t - LQ, 0);
  return rB(n - e(r), t - r);
}
const nr = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, Ik = 1e-3;
function BQ({ duration: e = nr.duration, bounce: t = nr.bounce, velocity: n = nr.velocity, mass: r = nr.mass }) {
  let i, o, s = 1 - t;
  s = ta(nr.minDamping, nr.maxDamping, s), e = ta(nr.minDuration, nr.maxDuration, /* @__PURE__ */ Fo(e)), s < 1 ? (i = (u) => {
    const f = u * s, h = f * e, m = f - n, g = XE(u, s), b = Math.exp(-h);
    return Ik - m / g * b;
  }, o = (u) => {
    const h = u * s * e, m = h * n + n, g = Math.pow(s, 2) * Math.pow(u, 2) * e, b = Math.exp(-h), x = XE(Math.pow(u, 2), s);
    return (-i(u) + Ik > 0 ? -1 : 1) * ((m - g) * b) / x;
  }) : (i = (u) => {
    const f = Math.exp(-u * e), h = (u - n) * e + 1;
    return -Ik + f * h;
  }, o = (u) => {
    const f = Math.exp(-u * e), h = (n - u) * (e * e);
    return f * h;
  });
  const a = 5 / e, c = UQ(i, o, a);
  if (e = /* @__PURE__ */ Xs(e), isNaN(c))
    return {
      stiffness: nr.stiffness,
      damping: nr.damping,
      duration: e
    };
  {
    const u = Math.pow(c, 2) * r;
    return {
      stiffness: u,
      damping: s * 2 * Math.sqrt(r * u),
      duration: e
    };
  }
}
const $Q = 12;
function UQ(e, t, n) {
  let r = n;
  for (let i = 1; i < $Q; i++)
    r = r - e(r) / t(r);
  return r;
}
function XE(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const FQ = ["duration", "bounce"], VQ = ["stiffness", "damping", "mass"];
function iD(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function HQ(e) {
  let t = {
    velocity: nr.velocity,
    stiffness: nr.stiffness,
    damping: nr.damping,
    mass: nr.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!iD(e, VQ) && iD(e, FQ))
    if (e.visualDuration) {
      const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, o = 2 * ta(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i);
      t = {
        ...t,
        mass: nr.mass,
        stiffness: i,
        damping: o
      };
    } else {
      const n = BQ(e);
      t = {
        ...t,
        ...n,
        mass: nr.mass
      }, t.isResolvedFromDuration = !0;
    }
  return t;
}
function ag(e = nr.visualDuration, t = nr.bounce) {
  const n = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: t
  } : e;
  let { restSpeed: r, restDelta: i } = n;
  const o = n.keyframes[0], s = n.keyframes[n.keyframes.length - 1], a = { done: !1, value: o }, { stiffness: c, damping: u, mass: f, duration: h, velocity: m, isResolvedFromDuration: g } = HQ({
    ...n,
    velocity: -/* @__PURE__ */ Fo(n.velocity || 0)
  }), b = m || 0, x = u / (2 * Math.sqrt(c * f)), w = s - o, S = /* @__PURE__ */ Fo(Math.sqrt(c / f)), _ = Math.abs(w) < 5;
  r || (r = _ ? nr.restSpeed.granular : nr.restSpeed.default), i || (i = _ ? nr.restDelta.granular : nr.restDelta.default);
  let M;
  if (x < 1) {
    const D = XE(S, x);
    M = (j) => {
      const O = Math.exp(-x * S * j);
      return s - O * ((b + x * S * w) / D * Math.sin(D * j) + w * Math.cos(D * j));
    };
  } else if (x === 1)
    M = (D) => s - Math.exp(-S * D) * (w + (b + S * w) * D);
  else {
    const D = S * Math.sqrt(x * x - 1);
    M = (j) => {
      const O = Math.exp(-x * S * j), L = Math.min(D * j, 300);
      return s - O * ((b + x * S * w) * Math.sinh(L) + D * w * Math.cosh(L)) / D;
    };
  }
  const N = {
    calculatedDuration: g && h || null,
    next: (D) => {
      const j = M(D);
      if (g)
        a.done = D >= h;
      else {
        let O = D === 0 ? b : 0;
        x < 1 && (O = D === 0 ? /* @__PURE__ */ Xs(b) : AB(M, D, j));
        const L = Math.abs(O) <= r, U = Math.abs(s - j) <= i;
        a.done = L && U;
      }
      return a.value = a.done ? s : j, a;
    },
    toString: () => {
      const D = Math.min(NA(N), gb), j = _B((O) => N.next(D * O).value, D, 30);
      return D + "ms " + j;
    },
    toTransition: () => {
    }
  };
  return N;
}
ag.applyToOptions = (e) => {
  const t = TB(e, 100, ag);
  return e.ease = t.ease, e.duration = /* @__PURE__ */ Xs(t.duration), e.type = "keyframes", e;
};
function JE({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: s, min: a, max: c, restDelta: u = 0.5, restSpeed: f }) {
  const h = e[0], m = {
    done: !1,
    value: h
  }, g = (L) => a !== void 0 && L < a || c !== void 0 && L > c, b = (L) => a === void 0 ? c : c === void 0 || Math.abs(a - L) < Math.abs(c - L) ? a : c;
  let x = n * t;
  const w = h + x, S = s === void 0 ? w : s(w);
  S !== w && (x = S - h);
  const _ = (L) => -x * Math.exp(-L / r), M = (L) => S + _(L), N = (L) => {
    const U = _(L), B = M(L);
    m.done = Math.abs(U) <= u, m.value = m.done ? S : B;
  };
  let D, j;
  const O = (L) => {
    g(m.value) && (D = L, j = ag({
      keyframes: [m.value, b(m.value)],
      velocity: AB(M, L, m.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: o,
      restDelta: u,
      restSpeed: f
    }));
  };
  return O(0), {
    calculatedDuration: null,
    next: (L) => {
      let U = !1;
      return !j && D === void 0 && (U = !0, N(L), O(L)), D !== void 0 && L >= D ? j.next(L - D) : (!U && N(L), m);
    }
  };
}
function WQ(e, t, n) {
  const r = [], i = n || el.mix || EB, o = e.length - 1;
  for (let s = 0; s < o; s++) {
    let a = i(e[s], e[s + 1]);
    if (t) {
      const c = Array.isArray(t) ? t[s] || Ho : t;
      a = Kg(c, a);
    }
    r.push(a);
  }
  return r;
}
function MB(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const o = e.length;
  if (wA(o === t.length), o === 1)
    return () => t[0];
  if (o === 2 && t[0] === t[1])
    return () => t[1];
  const s = e[0] === e[1];
  e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const a = WQ(t, r, i), c = a.length, u = (f) => {
    if (s && f < e[0])
      return t[0];
    let h = 0;
    if (c > 1)
      for (; h < e.length - 2 && !(f < e[h + 1]); h++)
        ;
    const m = /* @__PURE__ */ mh(e[h], e[h + 1], f);
    return a[h](m);
  };
  return n ? (f) => u(ta(e[0], e[o - 1], f)) : u;
}
function NB(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    const i = /* @__PURE__ */ mh(0, t, r);
    e.push(Kn(n, 1, i));
  }
}
function RB(e) {
  const t = [0];
  return NB(t, e.length - 1), t;
}
function qQ(e, t) {
  return e.map((n) => n * t);
}
function GQ(e, t) {
  return e.map(() => t || fB).splice(0, e.length - 1);
}
function jm({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
  const i = hB(r) ? r.map(JP) : JP(r), o = {
    done: !1,
    value: t[0]
  }, s = qQ(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : RB(t),
    e
  ), a = MB(s, t, {
    ease: Array.isArray(i) ? i : GQ(t, i)
  });
  return {
    calculatedDuration: e,
    next: (c) => (o.value = a(c), o.done = c >= e, o)
  };
}
const KQ = (e) => e !== null;
function RA(e, { repeat: t, repeatType: n = "loop" }, r, i = 1) {
  const o = e.filter(KQ), a = i < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : o.length - 1;
  return !a || r === void 0 ? o[a] : r;
}
const ZQ = {
  decay: JE,
  inertia: JE,
  tween: jm,
  keyframes: jm,
  spring: ag
};
function OB(e) {
  typeof e.type == "string" && (e.type = ZQ[e.type]);
}
class OA {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
}
const YQ = (e) => e / 100;
class PA extends OA {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      const { motionValue: n } = this.options;
      n && n.updatedAt !== Oi.now() && this.tick(Oi.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.());
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    OB(t);
    const { type: n = jm, repeat: r = 0, repeatDelay: i = 0, repeatType: o, velocity: s = 0 } = t;
    let { keyframes: a } = t;
    const c = n || jm;
    c !== jm && typeof a[0] != "number" && (this.mixKeyframes = Kg(YQ, EB(a[0], a[1])), a = [0, 100]);
    const u = c({ ...t, keyframes: a });
    o === "mirror" && (this.mirroredGenerator = c({
      ...t,
      keyframes: [...a].reverse(),
      velocity: -s
    })), u.calculatedDuration === null && (u.calculatedDuration = NA(u));
    const { calculatedDuration: f } = u;
    this.calculatedDuration = f, this.resolvedDuration = f + i, this.totalDuration = this.resolvedDuration * (r + 1) - i, this.generator = u;
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(t, n = !1) {
    const { generator: r, totalDuration: i, mixKeyframes: o, mirroredGenerator: s, resolvedDuration: a, calculatedDuration: c } = this;
    if (this.startTime === null)
      return r.next(0);
    const { delay: u = 0, keyframes: f, repeat: h, repeatType: m, repeatDelay: g, type: b, onUpdate: x, finalKeyframe: w } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - i / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
    const S = this.currentTime - u * (this.playbackSpeed >= 0 ? 1 : -1), _ = this.playbackSpeed >= 0 ? S < 0 : S > i;
    this.currentTime = Math.max(S, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = i);
    let M = this.currentTime, N = r;
    if (h) {
      const L = Math.min(this.currentTime, i) / a;
      let U = Math.floor(L), B = L % 1;
      !B && L >= 1 && (B = 1), B === 1 && U--, U = Math.min(U, h + 1), U % 2 && (m === "reverse" ? (B = 1 - B, g && (B -= g / a)) : m === "mirror" && (N = s)), M = ta(0, 1, B) * a;
    }
    const D = _ ? { done: !1, value: f[0] } : N.next(M);
    o && (D.value = o(D.value));
    let { done: j } = D;
    !_ && c !== null && (j = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0);
    const O = this.holdTime === null && (this.state === "finished" || this.state === "running" && j);
    return O && b !== JE && (D.value = RA(f, this.options, w, this.speed)), x && x(D.value), O && this.finish(), D;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return /* @__PURE__ */ Fo(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ Fo(t);
  }
  get time() {
    return /* @__PURE__ */ Fo(this.currentTime);
  }
  set time(t) {
    t = /* @__PURE__ */ Xs(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), this.driver?.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(Oi.now());
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = /* @__PURE__ */ Fo(this.currentTime));
  }
  play() {
    if (this.isStopped)
      return;
    const { driver: t = zQ, startTime: n } = this.options;
    this.driver || (this.driver = t((i) => this.tick(i))), this.options.onPlay?.();
    const r = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = r) : this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime || (this.startTime = n ?? r), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(Oi.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.();
  }
  cancel() {
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), t.observe(this);
  }
}
function XQ(e) {
  for (let t = 1; t < e.length; t++)
    e[t] ?? (e[t] = e[t - 1]);
}
const Bu = (e) => e * 180 / Math.PI, QE = (e) => {
  const t = Bu(Math.atan2(e[1], e[0]));
  return e_(t);
}, JQ = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
  rotate: QE,
  rotateZ: QE,
  skewX: (e) => Bu(Math.atan(e[1])),
  skewY: (e) => Bu(Math.atan(e[2])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2
}, e_ = (e) => (e = e % 360, e < 0 && (e += 360), e), oD = QE, sD = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]), aD = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]), QQ = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: sD,
  scaleY: aD,
  scale: (e) => (sD(e) + aD(e)) / 2,
  rotateX: (e) => e_(Bu(Math.atan2(e[6], e[5]))),
  rotateY: (e) => e_(Bu(Math.atan2(-e[2], e[0]))),
  rotateZ: oD,
  rotate: oD,
  skewX: (e) => Bu(Math.atan(e[4])),
  skewY: (e) => Bu(Math.atan(e[1])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2
};
function t_(e) {
  return e.includes("scale") ? 1 : 0;
}
function n_(e, t) {
  if (!e || e === "none")
    return t_(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let r, i;
  if (n)
    r = QQ, i = n;
  else {
    const a = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    r = JQ, i = a;
  }
  if (!i)
    return t_(t);
  const o = r[t], s = i[1].split(",").map(tee);
  return typeof o == "function" ? o(s) : s[o];
}
const eee = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return n_(n, t);
};
function tee(e) {
  return parseFloat(e.trim());
}
const zh = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Lh = new Set(zh), lD = (e) => e === jh || e === at, nee = /* @__PURE__ */ new Set(["x", "y", "z"]), ree = zh.filter((e) => !nee.has(e));
function iee(e) {
  const t = [];
  return ree.forEach((n) => {
    const r = e.getValue(n);
    r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const hc = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: (e, { transform: t }) => n_(t, "x"),
  y: (e, { transform: t }) => n_(t, "y")
};
hc.translateX = hc.x;
hc.translateY = hc.y;
const Wu = /* @__PURE__ */ new Set();
let r_ = !1, i_ = !1, o_ = !1;
function PB() {
  if (i_) {
    const e = Array.from(Wu).filter((r) => r.needsMeasurement), t = new Set(e.map((r) => r.element)), n = /* @__PURE__ */ new Map();
    t.forEach((r) => {
      const i = iee(r);
      i.length && (n.set(r, i), r.render());
    }), e.forEach((r) => r.measureInitialState()), t.forEach((r) => {
      r.render();
      const i = n.get(r);
      i && i.forEach(([o, s]) => {
        r.getValue(o)?.set(s);
      });
    }), e.forEach((r) => r.measureEndState()), e.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  i_ = !1, r_ = !1, Wu.forEach((e) => e.complete(o_)), Wu.clear();
}
function DB() {
  Wu.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (i_ = !0);
  });
}
function oee() {
  o_ = !0, DB(), PB(), o_ = !1;
}
class DA {
  constructor(t, n, r, i, o, s = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = o, this.isAsync = s;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (Wu.add(this), r_ || (r_ = !0, Tn.read(DB), Tn.resolveKeyframes(PB))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this;
    if (t[0] === null) {
      const o = i?.get(), s = t[t.length - 1];
      if (o !== void 0)
        t[0] = o;
      else if (r && n) {
        const a = r.readValue(n, s);
        a != null && (t[0] = a);
      }
      t[0] === void 0 && (t[0] = s), i && o === void 0 && i.set(t[0]);
    }
    XQ(t);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(t = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), Wu.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (Wu.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const see = (e) => e.startsWith("--");
function aee(e, t, n) {
  see(t) ? e.style.setProperty(t, n) : e.style[t] = n;
}
const lee = /* @__PURE__ */ SA(() => window.ScrollTimeline !== void 0), cee = {};
function uee(e, t) {
  const n = /* @__PURE__ */ SA(e);
  return () => cee[t] ?? n();
}
const IB = /* @__PURE__ */ uee(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), vm = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, cD = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ vm([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ vm([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ vm([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ vm([0.33, 1.53, 0.69, 0.99])
};
function jB(e, t) {
  if (e)
    return typeof e == "function" ? IB() ? _B(e, t) : "ease-out" : mB(e) ? vm(e) : Array.isArray(e) ? e.map((n) => jB(n, t) || cD.easeOut) : cD[e];
}
function dee(e, t, n, { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: s = "loop", ease: a = "easeOut", times: c } = {}, u = void 0) {
  const f = {
    [t]: n
  };
  c && (f.offset = c);
  const h = jB(a, i);
  Array.isArray(h) && (f.easing = h);
  const m = {
    delay: r,
    duration: i,
    easing: Array.isArray(h) ? "linear" : h,
    fill: "both",
    iterations: o + 1,
    direction: s === "reverse" ? "alternate" : "normal"
  };
  return u && (m.pseudoElement = u), e.animate(f, m);
}
function IA(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
function fee({ type: e, ...t }) {
  return IA(e) && IB() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
class hee extends OA {
  constructor(t) {
    if (super(), this.finishedTime = null, this.isStopped = !1, this.manualStartTime = null, !t)
      return;
    const { element: n, name: r, keyframes: i, pseudoElement: o, allowFlatten: s = !1, finalKeyframe: a, onComplete: c } = t;
    this.isPseudoElement = !!o, this.allowFlatten = s, this.options = t, wA(typeof t.type != "string");
    const u = fee(t);
    this.animation = dee(n, r, i, u, o), u.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !o) {
        const f = RA(i, this.options, a, this.speed);
        this.updateMotionValue ? this.updateMotionValue(f) : aee(n, r, f), this.animation.cancel();
      }
      c?.(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.manualStartTime = null, this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    const t = this.options?.element;
    !this.isPseudoElement && t?.isConnected && this.animation.commitStyles?.();
  }
  get duration() {
    const t = this.animation.effect?.getComputedTiming?.().duration || 0;
    return /* @__PURE__ */ Fo(Number(t));
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ Fo(t);
  }
  get time() {
    return /* @__PURE__ */ Fo(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    this.manualStartTime = null, this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ Xs(t);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), this.animation.playbackRate = t;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return this.manualStartTime ?? Number(this.animation.startTime);
  }
  set startTime(t) {
    this.manualStartTime = this.animation.startTime = t;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: t, observe: n }) {
    return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, t && lee() ? (this.animation.timeline = t, Ho) : n(this);
  }
}
const zB = {
  anticipate: cB,
  backInOut: lB,
  circInOut: dB
};
function pee(e) {
  return e in zB;
}
function mee(e) {
  typeof e.ease == "string" && pee(e.ease) && (e.ease = zB[e.ease]);
}
const jk = 10;
class gee extends hee {
  constructor(t) {
    mee(t), OB(t), super(t), t.startTime !== void 0 && (this.startTime = t.startTime), this.options = t;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read committed styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: r, onComplete: i, element: o, ...s } = this.options;
    if (!n)
      return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const a = new PA({
      ...s,
      autoplay: !1
    }), c = Math.max(jk, Oi.now() - this.startTime), u = ta(0, jk, c - jk);
    n.setWithVelocity(a.sample(Math.max(0, c - u)).value, a.sample(c).value, u), a.stop();
  }
}
const uD = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(Mc.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function yee(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function vee(e, t, n, r) {
  const i = e[0];
  if (i === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const o = e[e.length - 1], s = uD(i, t), a = uD(o, t);
  return !s || !a ? !1 : yee(e) || (n === "spring" || IA(n)) && r;
}
function s_(e) {
  e.duration = 0, e.type = "keyframes";
}
const bee = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), xee = /* @__PURE__ */ SA(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function wee(e) {
  const { motionValue: t, name: n, repeatDelay: r, repeatType: i, damping: o, type: s } = e;
  if (!(t?.owner?.current instanceof HTMLElement))
    return !1;
  const { onUpdate: c, transformTemplate: u } = t.owner.getProps();
  return xee() && n && bee.has(n) && (n !== "transform" || !u) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !c && !r && i !== "mirror" && o !== 0 && s !== "inertia";
}
const See = 40;
class kee extends OA {
  constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: o = 0, repeatType: s = "loop", keyframes: a, name: c, motionValue: u, element: f, ...h }) {
    super(), this.stop = () => {
      this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel();
    }, this.createdAt = Oi.now();
    const m = {
      autoplay: t,
      delay: n,
      type: r,
      repeat: i,
      repeatDelay: o,
      repeatType: s,
      name: c,
      motionValue: u,
      element: f,
      ...h
    }, g = f?.KeyframeResolver || DA;
    this.keyframeResolver = new g(a, (b, x, w) => this.onKeyframesResolved(b, x, m, !w), c, u, f), this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(t, n, r, i) {
    this.keyframeResolver = void 0;
    const { name: o, type: s, velocity: a, delay: c, isHandoff: u, onUpdate: f } = r;
    this.resolvedAt = Oi.now(), vee(t, o, s, a) || ((el.instantAnimations || !c) && f?.(RA(t, r, n)), t[0] = t[t.length - 1], s_(r), r.repeat = 0);
    const m = {
      startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > See ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...r,
      keyframes: t
    }, g = !u && wee(m), b = m.motionValue?.owner?.current, x = g ? new gee({
      ...m,
      element: b
    }) : new PA(m);
    x.finished.then(() => {
      this.notifyFinished();
    }).catch(Ho), this.pendingTimeline && (this.stopTimeline = x.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = x;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    return this._animation || (this.keyframeResolver?.resume(), oee()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();
  }
}
class Cee {
  constructor(t) {
    this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((t) => t.finished));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(t) {
    return this.animations[0][t];
  }
  setAll(t, n) {
    for (let r = 0; r < this.animations.length; r++)
      this.animations[r][t] = n;
  }
  attachTimeline(t) {
    const n = this.animations.map((r) => r.attachTimeline(t));
    return () => {
      n.forEach((r, i) => {
        r && r(), this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(t) {
    this.setAll("time", t);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(t) {
    this.setAll("speed", t);
  }
  get state() {
    return this.getAll("state");
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    return dD(this.animations, "duration");
  }
  get iterationDuration() {
    return dD(this.animations, "iterationDuration");
  }
  runAll(t) {
    this.animations.forEach((n) => n[t]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function dD(e, t) {
  let n = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r][t];
    i !== null && i > n && (n = i);
  }
  return n;
}
class Eee extends Cee {
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
}
function LB(e, t, n, r = 0, i = 1) {
  const o = Array.from(e).sort((u, f) => u.sortNodePosition(f)).indexOf(t), s = e.size, a = (s - 1) * r;
  return typeof n == "function" ? n(o, s) : i === 1 ? o * r : a - o * r;
}
const _ee = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function Tee(e) {
  const t = _ee.exec(e);
  if (!t)
    return [,];
  const [, n, r, i] = t;
  return [`--${n ?? r}`, i];
}
function BB(e, t, n = 1) {
  const [r, i] = Tee(e);
  if (!r)
    return;
  const o = window.getComputedStyle(t).getPropertyValue(r);
  if (o) {
    const s = o.trim();
    return eB(s) ? parseFloat(s) : s;
  }
  return _A(i) ? BB(i, t, n + 1) : i;
}
const Aee = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, Mee = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), Nee = {
  type: "keyframes",
  duration: 0.8
}, Ree = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, Oee = (e, { keyframes: t }) => t.length > 2 ? Nee : Lh.has(e) ? e.startsWith("scale") ? Mee(t[1]) : Aee : Ree, Pee = (e) => e !== null;
function Dee(e, { repeat: t, repeatType: n = "loop" }, r) {
  const i = e.filter(Pee), o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
  return i[o];
}
function jA(e, t) {
  return e?.[t] ?? e?.default ?? e;
}
function Iee({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: c, elapsed: u, ...f }) {
  return !!Object.keys(f).length;
}
const zA = (e, t, n, r = {}, i, o) => (s) => {
  const a = jA(r, e) || {}, c = a.delay || r.delay || 0;
  let { elapsed: u = 0 } = r;
  u = u - /* @__PURE__ */ Xs(c);
  const f = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...a,
    delay: -u,
    onUpdate: (m) => {
      t.set(m), a.onUpdate && a.onUpdate(m);
    },
    onComplete: () => {
      s(), a.onComplete && a.onComplete();
    },
    name: e,
    motionValue: t,
    element: o ? void 0 : i
  };
  Iee(a) || Object.assign(f, Oee(e, f)), f.duration && (f.duration = /* @__PURE__ */ Xs(f.duration)), f.repeatDelay && (f.repeatDelay = /* @__PURE__ */ Xs(f.repeatDelay)), f.from !== void 0 && (f.keyframes[0] = f.from);
  let h = !1;
  if ((f.type === !1 || f.duration === 0 && !f.repeatDelay) && (s_(f), f.delay === 0 && (h = !0)), (el.instantAnimations || el.skipAnimations || i?.shouldSkipAnimations) && (h = !0, s_(f), f.delay = 0), f.allowFlatten = !a.type && !a.ease, h && !o && t.get() !== void 0) {
    const m = Dee(f.keyframes, a);
    if (m !== void 0) {
      Tn.update(() => {
        f.onUpdate(m), f.onComplete();
      });
      return;
    }
  }
  return a.isSync ? new PA(f) : new kee(f);
};
function fD(e) {
  const t = [{}, {}];
  return e?.values.forEach((n, r) => {
    t[0][r] = n.get(), t[1][r] = n.getVelocity();
  }), t;
}
function LA(e, t, n, r) {
  if (typeof t == "function") {
    const [i, o] = fD(r);
    t = t(n !== void 0 ? n : e.custom, i, o);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [i, o] = fD(r);
    t = t(n !== void 0 ? n : e.custom, i, o);
  }
  return t;
}
function th(e, t, n) {
  const r = e.getProps();
  return LA(r, t, n !== void 0 ? n : r.custom, e);
}
const $B = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...zh
]), hD = 30, jee = (e) => !isNaN(parseFloat(e)), zm = {
  current: void 0
};
class zee {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(t, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r) => {
      const i = Oi.now();
      if (this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents))
        for (const o of this.dependents)
          o.dirty();
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = Oi.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = jee(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new kA());
    const r = this.events[t].add(n);
    return t === "change" ? () => {
      r(), Tn.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t) {
    this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t);
  }
  setWithVelocity(t, n, r) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return zm.current && zm.current.push(this), this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = Oi.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > hD)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, hD);
    return rB(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Nc(e, t) {
  return new zee(e, t);
}
const a_ = (e) => Array.isArray(e);
function Lee(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Nc(n));
}
function Bee(e) {
  return a_(e) ? e[e.length - 1] || 0 : e;
}
function $ee(e, t) {
  const n = th(e, t);
  let { transitionEnd: r = {}, transition: i = {}, ...o } = n || {};
  o = { ...o, ...r };
  for (const s in o) {
    const a = Bee(o[s]);
    Lee(e, s, a);
  }
}
const Hr = (e) => !!(e && e.getVelocity);
function Uee(e) {
  return !!(Hr(e) && e.add);
}
function l_(e, t) {
  const n = e.getValue("willChange");
  if (Uee(n))
    return n.add(t);
  if (!n && el.WillChange) {
    const r = new el.WillChange("auto");
    e.addValue("willChange", r), r.add(t);
  }
}
function BA(e) {
  return e.replace(/([A-Z])/g, (t) => `-${t.toLowerCase()}`);
}
const Fee = "framerAppearId", UB = "data-" + BA(Fee);
function FB(e) {
  return e.props[UB];
}
function Vee({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r;
}
function $A(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  let { transition: o = e.getDefaultTransition(), transitionEnd: s, ...a } = t;
  const c = o?.reduceMotion;
  r && (o = r);
  const u = [], f = i && e.animationState && e.animationState.getState()[i];
  for (const h in a) {
    const m = e.getValue(h, e.latestValues[h] ?? null), g = a[h];
    if (g === void 0 || f && Vee(f, h))
      continue;
    const b = {
      delay: n,
      ...jA(o || {}, h)
    }, x = m.get();
    if (x !== void 0 && !m.isAnimating && !Array.isArray(g) && g === x && !b.velocity)
      continue;
    let w = !1;
    if (window.MotionHandoffAnimation) {
      const M = FB(e);
      if (M) {
        const N = window.MotionHandoffAnimation(M, h, Tn);
        N !== null && (b.startTime = N, w = !0);
      }
    }
    l_(e, h);
    const S = c ?? e.shouldReduceMotion;
    m.start(zA(h, m, g, S && $B.has(h) ? { type: !1 } : b, e, w));
    const _ = m.animation;
    _ && u.push(_);
  }
  return s && Promise.all(u).then(() => {
    Tn.update(() => {
      s && $ee(e, s);
    });
  }), u;
}
function c_(e, t, n = {}) {
  const r = th(e, t, n.type === "exit" ? e.presenceContext?.custom : void 0);
  let { transition: i = e.getDefaultTransition() || {} } = r || {};
  n.transitionOverride && (i = n.transitionOverride);
  const o = r ? () => Promise.all($A(e, r, n)) : () => Promise.resolve(), s = e.variantChildren && e.variantChildren.size ? (c = 0) => {
    const { delayChildren: u = 0, staggerChildren: f, staggerDirection: h } = i;
    return Hee(e, t, c, u, f, h, n);
  } : () => Promise.resolve(), { when: a } = i;
  if (a) {
    const [c, u] = a === "beforeChildren" ? [o, s] : [s, o];
    return c().then(() => u());
  } else
    return Promise.all([o(), s(n.delay)]);
}
function Hee(e, t, n = 0, r = 0, i = 0, o = 1, s) {
  const a = [];
  for (const c of e.variantChildren)
    c.notify("AnimationStart", t), a.push(c_(c, t, {
      ...s,
      delay: n + (typeof r == "function" ? 0 : r) + LB(e.variantChildren, c, r, i, o)
    }).then(() => c.notify("AnimationComplete", t)));
  return Promise.all(a);
}
function Wee(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const i = t.map((o) => c_(e, o, n));
    r = Promise.all(i);
  } else if (typeof t == "string")
    r = c_(e, t, n);
  else {
    const i = typeof t == "function" ? th(e, t, n.custom) : t;
    r = Promise.all($A(e, i, n));
  }
  return r.then(() => {
    e.notify("AnimationComplete", t);
  });
}
const qee = {
  test: (e) => e === "auto",
  parse: (e) => e
}, VB = (e) => (t) => t.test(e), HB = [jh, at, Js, Jl, wQ, xQ, qee], pD = (e) => HB.find(VB(e));
function Gee(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || nB(e) : !0;
}
const Kee = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function Zee(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [r] = n.match(TA) || [];
  if (!r)
    return e;
  const i = n.replace(r, "");
  let o = Kee.has(t) ? 1 : 0;
  return r !== n && (o *= 100), t + "(" + o + i + ")";
}
const Yee = /\b([a-z-]*)\(.*?\)/gu, u_ = {
  ...Mc,
  getAnimatableNone: (e) => {
    const t = e.match(Yee);
    return t ? t.map(Zee).join(" ") : e;
  }
}, mD = {
  ...jh,
  transform: Math.round
}, Xee = {
  rotate: Jl,
  rotateX: Jl,
  rotateY: Jl,
  rotateZ: Jl,
  scale: Bv,
  scaleX: Bv,
  scaleY: Bv,
  scaleZ: Bv,
  skew: Jl,
  skewX: Jl,
  skewY: Jl,
  distance: at,
  translateX: at,
  translateY: at,
  translateZ: at,
  x: at,
  y: at,
  z: at,
  perspective: at,
  transformPerspective: at,
  opacity: og,
  originX: eD,
  originY: eD,
  originZ: at
}, UA = {
  // Border props
  borderWidth: at,
  borderTopWidth: at,
  borderRightWidth: at,
  borderBottomWidth: at,
  borderLeftWidth: at,
  borderRadius: at,
  borderTopLeftRadius: at,
  borderTopRightRadius: at,
  borderBottomRightRadius: at,
  borderBottomLeftRadius: at,
  // Positioning props
  width: at,
  maxWidth: at,
  height: at,
  maxHeight: at,
  top: at,
  right: at,
  bottom: at,
  left: at,
  inset: at,
  insetBlock: at,
  insetBlockStart: at,
  insetBlockEnd: at,
  insetInline: at,
  insetInlineStart: at,
  insetInlineEnd: at,
  // Spacing props
  padding: at,
  paddingTop: at,
  paddingRight: at,
  paddingBottom: at,
  paddingLeft: at,
  paddingBlock: at,
  paddingBlockStart: at,
  paddingBlockEnd: at,
  paddingInline: at,
  paddingInlineStart: at,
  paddingInlineEnd: at,
  margin: at,
  marginTop: at,
  marginRight: at,
  marginBottom: at,
  marginLeft: at,
  marginBlock: at,
  marginBlockStart: at,
  marginBlockEnd: at,
  marginInline: at,
  marginInlineStart: at,
  marginInlineEnd: at,
  // Typography
  fontSize: at,
  // Misc
  backgroundPositionX: at,
  backgroundPositionY: at,
  ...Xee,
  zIndex: mD,
  // SVG
  fillOpacity: og,
  strokeOpacity: og,
  numOctaves: mD
}, Jee = {
  ...UA,
  // Color props
  color: kr,
  backgroundColor: kr,
  outlineColor: kr,
  fill: kr,
  stroke: kr,
  // Border props
  borderColor: kr,
  borderTopColor: kr,
  borderRightColor: kr,
  borderBottomColor: kr,
  borderLeftColor: kr,
  filter: u_,
  WebkitFilter: u_
}, WB = (e) => Jee[e];
function qB(e, t) {
  let n = WB(e);
  return n !== u_ && (n = Mc), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const Qee = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function ete(e, t, n) {
  let r = 0, i;
  for (; r < e.length && !i; ) {
    const o = e[r];
    typeof o == "string" && !Qee.has(o) && sg(o).values.length && (i = e[r]), r++;
  }
  if (i && n)
    for (const o of t)
      e[o] = qB(n, i);
}
class tte extends DA {
  constructor(t, n, r, i, o) {
    super(t, n, r, i, o, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let f = 0; f < t.length; f++) {
      let h = t[f];
      if (typeof h == "string" && (h = h.trim(), _A(h))) {
        const m = BB(h, n.current);
        m !== void 0 && (t[f] = m), f === t.length - 1 && (this.finalKeyframe = h);
      }
    }
    if (this.resolveNoneKeyframes(), !$B.has(r) || t.length !== 2)
      return;
    const [i, o] = t, s = pD(i), a = pD(o), c = QP(i), u = QP(o);
    if (c !== u && hc[r]) {
      this.needsMeasurement = !0;
      return;
    }
    if (s !== a)
      if (lD(s) && lD(a))
        for (let f = 0; f < t.length; f++) {
          const h = t[f];
          typeof h == "string" && (t[f] = parseFloat(h));
        }
      else hc[r] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, r = [];
    for (let i = 0; i < t.length; i++)
      (t[i] === null || Gee(t[i])) && r.push(i);
    r.length && ete(t, r, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: r } = this;
    if (!t || !t.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = hc[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const i = n[n.length - 1];
    i !== void 0 && t.getValue(r, i).jump(i, !1);
  }
  measureEndState() {
    const { element: t, name: n, unresolvedKeyframes: r } = this;
    if (!t || !t.current)
      return;
    const i = t.getValue(n);
    i && i.jump(this.measuredOrigin, !1);
    const o = r.length - 1, s = r[o];
    r[o] = hc[n](t.measureViewportBox(), window.getComputedStyle(t.current)), s !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = s), this.removedTransforms?.length && this.removedTransforms.forEach(([a, c]) => {
      t.getValue(a).set(c);
    }), this.resolveNoneKeyframes();
  }
}
function FA(e, t, n) {
  if (e == null)
    return [];
  if (e instanceof EventTarget)
    return [e];
  if (typeof e == "string") {
    let r = document;
    t && (r = t.current);
    const i = n?.[e] ?? r.querySelectorAll(e);
    return i ? Array.from(i) : [];
  }
  return Array.from(e).filter((r) => r != null);
}
const GB = (e, t) => t && typeof e == "number" ? t.transform(e) : e;
function d_(e) {
  return tB(e) && "offsetHeight" in e;
}
const { schedule: VA } = /* @__PURE__ */ gB(queueMicrotask, !1), ls = {
  x: !1,
  y: !1
};
function KB() {
  return ls.x || ls.y;
}
function nte(e) {
  return e === "x" || e === "y" ? ls[e] ? null : (ls[e] = !0, () => {
    ls[e] = !1;
  }) : ls.x || ls.y ? null : (ls.x = ls.y = !0, () => {
    ls.x = ls.y = !1;
  });
}
function ZB(e, t) {
  const n = FA(e), r = new AbortController(), i = {
    passive: !0,
    ...t,
    signal: r.signal
  };
  return [n, i, () => r.abort()];
}
function gD(e) {
  return !(e.pointerType === "touch" || KB());
}
function rte(e, t, n = {}) {
  const [r, i, o] = ZB(e, n), s = (a) => {
    if (!gD(a))
      return;
    const { target: c } = a, u = t(c, a);
    if (typeof u != "function" || !c)
      return;
    const f = (h) => {
      gD(h) && (u(h), c.removeEventListener("pointerleave", f));
    };
    c.addEventListener("pointerleave", f, i);
  };
  return r.forEach((a) => {
    a.addEventListener("pointerenter", s, i);
  }), o;
}
const YB = (e, t) => t ? e === t ? !0 : YB(e, t.parentElement) : !1, HA = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, ite = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function ote(e) {
  return ite.has(e.tagName) || e.isContentEditable === !0;
}
const ste = /* @__PURE__ */ new Set(["INPUT", "SELECT", "TEXTAREA"]);
function ate(e) {
  return ste.has(e.tagName) || e.isContentEditable === !0;
}
const N0 = /* @__PURE__ */ new WeakSet();
function yD(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function zk(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const lte = (e, t) => {
  const n = e.currentTarget;
  if (!n)
    return;
  const r = yD(() => {
    if (N0.has(n))
      return;
    zk(n, "down");
    const i = yD(() => {
      zk(n, "up");
    }), o = () => zk(n, "cancel");
    n.addEventListener("keyup", i, t), n.addEventListener("blur", o, t);
  });
  n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t);
};
function vD(e) {
  return HA(e) && !KB();
}
function cte(e, t, n = {}) {
  const [r, i, o] = ZB(e, n), s = (a) => {
    const c = a.currentTarget;
    if (!vD(a))
      return;
    N0.add(c);
    const u = t(c, a), f = (g, b) => {
      window.removeEventListener("pointerup", h), window.removeEventListener("pointercancel", m), N0.has(c) && N0.delete(c), vD(g) && typeof u == "function" && u(g, { success: b });
    }, h = (g) => {
      f(g, c === window || c === document || n.useGlobalTarget || YB(c, g.target));
    }, m = (g) => {
      f(g, !1);
    };
    window.addEventListener("pointerup", h, i), window.addEventListener("pointercancel", m, i);
  };
  return r.forEach((a) => {
    (n.useGlobalTarget ? window : a).addEventListener("pointerdown", s, i), d_(a) && (a.addEventListener("focus", (u) => lte(u, i)), !ote(a) && !a.hasAttribute("tabindex") && (a.tabIndex = 0));
  }), o;
}
function cw(e) {
  return tB(e) && "ownerSVGElement" in e;
}
const R0 = /* @__PURE__ */ new WeakMap();
let O0;
const XB = (e, t, n) => (r, i) => i && i[0] ? i[0][e + "Size"] : cw(r) && "getBBox" in r ? r.getBBox()[t] : r[n], ute = /* @__PURE__ */ XB("inline", "width", "offsetWidth"), dte = /* @__PURE__ */ XB("block", "height", "offsetHeight");
function fte({ target: e, borderBoxSize: t }) {
  R0.get(e)?.forEach((n) => {
    n(e, {
      get width() {
        return ute(e, t);
      },
      get height() {
        return dte(e, t);
      }
    });
  });
}
function hte(e) {
  e.forEach(fte);
}
function pte() {
  typeof ResizeObserver > "u" || (O0 = new ResizeObserver(hte));
}
function mte(e, t) {
  O0 || pte();
  const n = FA(e);
  return n.forEach((r) => {
    let i = R0.get(r);
    i || (i = /* @__PURE__ */ new Set(), R0.set(r, i)), i.add(t), O0?.observe(r);
  }), () => {
    n.forEach((r) => {
      const i = R0.get(r);
      i?.delete(t), i?.size || O0?.unobserve(r);
    });
  };
}
const P0 = /* @__PURE__ */ new Set();
let Hf;
function gte() {
  Hf = () => {
    const e = {
      get width() {
        return window.innerWidth;
      },
      get height() {
        return window.innerHeight;
      }
    };
    P0.forEach((t) => t(e));
  }, window.addEventListener("resize", Hf);
}
function yte(e) {
  return P0.add(e), Hf || gte(), () => {
    P0.delete(e), !P0.size && typeof Hf == "function" && (window.removeEventListener("resize", Hf), Hf = void 0);
  };
}
function bD(e, t) {
  return typeof e == "function" ? yte(e) : mte(e, t);
}
function JB(e) {
  return cw(e) && e.tagName === "svg";
}
function vte(...e) {
  const t = !Array.isArray(e[0]), n = t ? 0 : -1, r = e[0 + n], i = e[1 + n], o = e[2 + n], s = e[3 + n], a = MB(i, o, s);
  return t ? a(r) : a;
}
const bte = [...HB, kr, Mc], xte = (e) => bte.find(VB(e)), xD = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Wf = () => ({
  x: xD(),
  y: xD()
}), wD = () => ({ min: 0, max: 0 }), wr = () => ({
  x: wD(),
  y: wD()
}), f_ = { current: null }, QB = { current: !1 }, wte = typeof window < "u";
function Ste() {
  if (QB.current = !0, !!wte)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => f_.current = e.matches;
      e.addEventListener("change", t), t();
    } else
      f_.current = !1;
}
const lg = /* @__PURE__ */ new WeakMap();
function uw(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function cg(e) {
  return typeof e == "string" || Array.isArray(e);
}
const WA = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], qA = ["initial", ...WA];
function dw(e) {
  return uw(e.animate) || qA.some((t) => cg(e[t]));
}
function e6(e) {
  return !!(dw(e) || e.variants);
}
function kte(e, t, n) {
  for (const r in t) {
    const i = t[r], o = n[r];
    if (Hr(i))
      e.addValue(r, i);
    else if (Hr(o))
      e.addValue(r, Nc(i, { owner: e }));
    else if (o !== i)
      if (e.hasValue(r)) {
        const s = e.getValue(r);
        s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i);
      } else {
        const s = e.getStaticValue(r);
        e.addValue(r, Nc(s !== void 0 ? s : i, { owner: e }));
      }
  }
  for (const r in n)
    t[r] === void 0 && e.removeValue(r);
  return t;
}
const SD = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
let yb = {};
function t6(e) {
  yb = e;
}
function Cte() {
  return yb;
}
class n6 {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, r) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: i, skipAnimations: o, blockInitialAnimation: s, visualState: a }, c = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.shouldSkipAnimations = !1, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = DA, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const g = Oi.now();
      this.renderScheduledAt < g && (this.renderScheduledAt = g, Tn.render(this.render, !1, !0));
    };
    const { latestValues: u, renderState: f } = a;
    this.latestValues = u, this.baseTarget = { ...u }, this.initialValues = n.initial ? { ...u } : {}, this.renderState = f, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.skipAnimationsConfig = o, this.options = c, this.blockInitialAnimation = !!s, this.isControllingVariants = dw(n), this.isVariantNode = e6(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: h, ...m } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const g in m) {
      const b = m[g];
      u[g] !== void 0 && Hr(b) && b.set(u[g]);
    }
  }
  mount(t) {
    this.current = t, lg.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), this.reducedMotionConfig === "never" ? this.shouldReduceMotion = !1 : this.reducedMotionConfig === "always" ? this.shouldReduceMotion = !0 : (QB.current || Ste(), this.shouldReduceMotion = f_.current), this.shouldSkipAnimations = this.skipAnimationsConfig ?? !1, this.parent?.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), tl(this.notifyUpdate), tl(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features) {
      const n = this.features[t];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  addChild(t) {
    this.children.add(t), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(t);
  }
  removeChild(t) {
    this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t);
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const r = Lh.has(t);
    r && this.onBindTransform && this.onBindTransform();
    const i = n.on("change", (s) => {
      this.latestValues[t] = s, this.props.onUpdate && Tn.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let o;
    typeof window < "u" && window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      i(), o && o(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in yb) {
      const n = yb[t];
      if (!n)
        continue;
      const { isEnabled: r, Feature: i } = n;
      if (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)), this.features[t]) {
        const o = this.features[t];
        o.isMounted ? o.update() : (o.mount(), o.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : wr();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < SD.length; r++) {
      const i = SD[r];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const o = "on" + i, s = t[o];
      s && (this.propEventSubscriptions[i] = this.on(i, s));
    }
    this.prevMotionValues = kte(this, this.scrapeMotionValuesFromProps(t, this.prevProps || {}, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const r = this.values.get(t);
    n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let r = this.values.get(t);
    return r === void 0 && n !== void 0 && (r = Nc(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return r != null && (typeof r == "string" && (eB(r) || nB(r)) ? r = parseFloat(r) : !xte(r) && Mc.test(n) && (r = qB(t, n)), this.setBaseTarget(t, Hr(r) ? r.get() : r)), Hr(r) ? r.get() : r;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    const { initial: n } = this.props;
    let r;
    if (typeof n == "string" || typeof n == "object") {
      const o = LA(this.props, n, this.presenceContext?.custom);
      o && (r = o[t]);
    }
    if (n && r !== void 0)
      return r;
    const i = this.getBaseTargetFromProps(this.props, t);
    return i !== void 0 && !Hr(i) ? i : this.initialValues[t] !== void 0 && r === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new kA()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
  scheduleRenderMicrotask() {
    VA.render(this.render);
  }
}
class r6 extends n6 {
  constructor() {
    super(...arguments), this.KeyframeResolver = tte;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    const r = t.style;
    return r ? r[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    Hr(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
class $c {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
function i6({ top: e, left: t, right: n, bottom: r }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: r }
  };
}
function Ete({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function _te(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function Lk(e) {
  return e === void 0 || e === 1;
}
function h_({ scale: e, scaleX: t, scaleY: n }) {
  return !Lk(e) || !Lk(t) || !Lk(n);
}
function Pu(e) {
  return h_(e) || o6(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function o6(e) {
  return kD(e.x) || kD(e.y);
}
function kD(e) {
  return e && e !== "0%";
}
function vb(e, t, n) {
  const r = e - n, i = t * r;
  return n + i;
}
function CD(e, t, n, r, i) {
  return i !== void 0 && (e = vb(e, i, r)), vb(e, n, r) + t;
}
function p_(e, t = 0, n = 1, r, i) {
  e.min = CD(e.min, t, n, r, i), e.max = CD(e.max, t, n, r, i);
}
function s6(e, { x: t, y: n }) {
  p_(e.x, t.translate, t.scale, t.originPoint), p_(e.y, n.translate, n.scale, n.originPoint);
}
const ED = 0.999999999999, _D = 1.0000000000001;
function Tte(e, t, n, r = !1) {
  const i = n.length;
  if (!i)
    return;
  t.x = t.y = 1;
  let o, s;
  for (let a = 0; a < i; a++) {
    o = n[a], s = o.projectionDelta;
    const { visualElement: c } = o.options;
    c && c.props.style && c.props.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && Gf(e, {
      x: -o.scroll.offset.x,
      y: -o.scroll.offset.y
    }), s && (t.x *= s.x.scale, t.y *= s.y.scale, s6(e, s)), r && Pu(o.latestValues) && Gf(e, o.latestValues));
  }
  t.x < _D && t.x > ED && (t.x = 1), t.y < _D && t.y > ED && (t.y = 1);
}
function qf(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function TD(e, t, n, r, i = 0.5) {
  const o = Kn(e.min, e.max, i);
  p_(e, t, n, o, r);
}
function Gf(e, t) {
  TD(e.x, t.x, t.scaleX, t.scale, t.originX), TD(e.y, t.y, t.scaleY, t.scale, t.originY);
}
function a6(e, t) {
  return i6(_te(e.getBoundingClientRect(), t));
}
function Ate(e, t, n) {
  const r = a6(e, n), { scroll: i } = t;
  return i && (qf(r.x, i.offset.x), qf(r.y, i.offset.y)), r;
}
const Mte = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, Nte = zh.length;
function Rte(e, t, n) {
  let r = "", i = !0;
  for (let o = 0; o < Nte; o++) {
    const s = zh[o], a = e[s];
    if (a === void 0)
      continue;
    let c = !0;
    if (typeof a == "number")
      c = a === (s.startsWith("scale") ? 1 : 0);
    else {
      const u = parseFloat(a);
      c = s.startsWith("scale") ? u === 1 : u === 0;
    }
    if (!c || n) {
      const u = GB(a, UA[s]);
      if (!c) {
        i = !1;
        const f = Mte[s] || s;
        r += `${f}(${u}) `;
      }
      n && (t[s] = u);
    }
  }
  return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r;
}
function GA(e, t, n) {
  const { style: r, vars: i, transformOrigin: o } = e;
  let s = !1, a = !1;
  for (const c in t) {
    const u = t[c];
    if (Lh.has(c)) {
      s = !0;
      continue;
    } else if (vB(c)) {
      i[c] = u;
      continue;
    } else {
      const f = GB(u, UA[c]);
      c.startsWith("origin") ? (a = !0, o[c] = f) : r[c] = f;
    }
  }
  if (t.transform || (s || n ? r.transform = Rte(t, e.transform, n) : r.transform && (r.transform = "none")), a) {
    const { originX: c = "50%", originY: u = "50%", originZ: f = 0 } = o;
    r.transformOrigin = `${c} ${u} ${f}`;
  }
}
function l6(e, { style: t, vars: n }, r, i) {
  const o = e.style;
  let s;
  for (s in t)
    o[s] = t[s];
  i?.applyProjectionStyles(o, r);
  for (s in n)
    o.setProperty(s, n[s]);
}
function AD(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const sm = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (at.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = AD(e, t.target.x), r = AD(e, t.target.y);
    return `${n}% ${r}%`;
  }
}, Ote = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const r = e, i = Mc.parse(e);
    if (i.length > 5)
      return r;
    const o = Mc.createTransformer(e), s = typeof i[0] != "number" ? 1 : 0, a = n.x.scale * t.x, c = n.y.scale * t.y;
    i[0 + s] /= a, i[1 + s] /= c;
    const u = Kn(a, c, 0.5);
    return typeof i[2 + s] == "number" && (i[2 + s] /= u), typeof i[3 + s] == "number" && (i[3 + s] /= u), o(i);
  }
}, m_ = {
  borderRadius: {
    ...sm,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: sm,
  borderTopRightRadius: sm,
  borderBottomLeftRadius: sm,
  borderBottomRightRadius: sm,
  boxShadow: Ote
};
function c6(e, { layout: t, layoutId: n }) {
  return Lh.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!m_[e] || e === "opacity");
}
function KA(e, t, n) {
  const r = e.style, i = t?.style, o = {};
  if (!r)
    return o;
  for (const s in r)
    (Hr(r[s]) || i && Hr(i[s]) || c6(s, e) || n?.getValue(s)?.liveStyle !== void 0) && (o[s] = r[s]);
  return o;
}
function Pte(e) {
  return window.getComputedStyle(e);
}
class u6 extends r6 {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = l6;
  }
  readValueFromInstance(t, n) {
    if (Lh.has(n))
      return this.projection?.isProjecting ? t_(n) : eee(t, n);
    {
      const r = Pte(t), i = (vB(n) ? r.getPropertyValue(n) : r[n]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return a6(t, n);
  }
  build(t, n, r) {
    GA(t, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return KA(t, n, r);
  }
}
function Dte(e, t) {
  return e in t;
}
class Ite extends n6 {
  constructor() {
    super(...arguments), this.type = "object";
  }
  readValueFromInstance(t, n) {
    if (Dte(n, t)) {
      const r = t[n];
      if (typeof r == "string" || typeof r == "number")
        return r;
    }
  }
  getBaseTargetFromProps() {
  }
  removeValueFromRenderState(t, n) {
    delete n.output[t];
  }
  measureInstanceViewportBox() {
    return wr();
  }
  build(t, n) {
    Object.assign(t.output, n);
  }
  renderInstance(t, { output: n }) {
    Object.assign(t, n);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
const jte = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, zte = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Lte(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1;
  const o = i ? jte : zte;
  e[o.offset] = `${-r}`, e[o.array] = `${t} ${n}`;
}
const Bte = [
  "offsetDistance",
  "offsetPath",
  "offsetRotate",
  "offsetAnchor"
];
function d6(e, {
  attrX: t,
  attrY: n,
  attrScale: r,
  pathLength: i,
  pathSpacing: o = 1,
  pathOffset: s = 0,
  // This is object creation, which we try to avoid per-frame.
  ...a
}, c, u, f) {
  if (GA(e, a, u), c) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: h, style: m } = e;
  h.transform && (m.transform = h.transform, delete h.transform), (m.transform || h.transformOrigin) && (m.transformOrigin = h.transformOrigin ?? "50% 50%", delete h.transformOrigin), m.transform && (m.transformBox = f?.transformBox ?? "fill-box", delete h.transformBox);
  for (const g of Bte)
    h[g] !== void 0 && (m[g] = h[g], delete h[g]);
  t !== void 0 && (h.x = t), n !== void 0 && (h.y = n), r !== void 0 && (h.scale = r), i !== void 0 && Lte(h, i, o, s, !1);
}
const f6 = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]), h6 = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function $te(e, t, n, r) {
  l6(e, t, void 0, r);
  for (const i in t.attrs)
    e.setAttribute(f6.has(i) ? i : BA(i), t.attrs[i]);
}
function p6(e, t, n) {
  const r = KA(e, t, n);
  for (const i in e)
    if (Hr(e[i]) || Hr(t[i])) {
      const o = zh.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      r[o] = e[i];
    }
  return r;
}
class m6 extends r6 {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = wr;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (Lh.has(n)) {
      const r = WB(n);
      return r && r.default || 0;
    }
    return n = f6.has(n) ? n : BA(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return p6(t, n, r);
  }
  build(t, n, r) {
    d6(t, n, this.isSVGTag, r.transformTemplate, r.style);
  }
  renderInstance(t, n, r, i) {
    $te(t, n, r, i);
  }
  mount(t) {
    this.isSVGTag = h6(t.tagName), super.mount(t);
  }
}
const Ute = qA.length;
function g6(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const n = e.parent ? g6(e.parent) || {} : {};
    return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
  }
  const t = {};
  for (let n = 0; n < Ute; n++) {
    const r = qA[n], i = e.props[r];
    (cg(i) || i === !1) && (t[r] = i);
  }
  return t;
}
function y6(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const Fte = [...WA].reverse(), Vte = WA.length;
function Hte(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => Wee(e, n, r)));
}
function Wte(e) {
  let t = Hte(e), n = MD(), r = !0;
  const i = (c) => (u, f) => {
    const h = th(e, f, c === "exit" ? e.presenceContext?.custom : void 0);
    if (h) {
      const { transition: m, transitionEnd: g, ...b } = h;
      u = { ...u, ...b, ...g };
    }
    return u;
  };
  function o(c) {
    t = c(e);
  }
  function s(c) {
    const { props: u } = e, f = g6(e.parent) || {}, h = [], m = /* @__PURE__ */ new Set();
    let g = {}, b = 1 / 0;
    for (let w = 0; w < Vte; w++) {
      const S = Fte[w], _ = n[S], M = u[S] !== void 0 ? u[S] : f[S], N = cg(M), D = S === c ? _.isActive : null;
      D === !1 && (b = w);
      let j = M === f[S] && M !== u[S] && N;
      if (j && r && e.manuallyAnimateOnMount && (j = !1), _.protectedKeys = { ...g }, // If it isn't active and hasn't *just* been set as inactive
      !_.isActive && D === null || // If we didn't and don't have any defined prop for this animation type
      !M && !_.prevProp || // Or if the prop doesn't define an animation
      uw(M) || typeof M == "boolean")
        continue;
      const O = qte(_.prevProp, M);
      let L = O || // If we're making this variant active, we want to always make it active
      S === c && _.isActive && !j && N || // If we removed a higher-priority variant (i is in reverse order)
      w > b && N, U = !1;
      const B = Array.isArray(M) ? M : [M];
      let G = B.reduce(i(S), {});
      D === !1 && (G = {});
      const { prevResolvedValues: Y = {} } = _, he = {
        ...Y,
        ...G
      }, ie = (Q) => {
        L = !0, m.has(Q) && (U = !0, m.delete(Q)), _.needsAnimating[Q] = !0;
        const X = e.getValue(Q);
        X && (X.liveStyle = !1);
      };
      for (const Q in he) {
        const X = G[Q], Se = Y[Q];
        if (g.hasOwnProperty(Q))
          continue;
        let W = !1;
        a_(X) && a_(Se) ? W = !y6(X, Se) : W = X !== Se, W ? X != null ? ie(Q) : m.add(Q) : X !== void 0 && m.has(Q) ? ie(Q) : _.protectedKeys[Q] = !0;
      }
      _.prevProp = M, _.prevResolvedValues = G, _.isActive && (g = { ...g, ...G }), r && e.blockInitialAnimation && (L = !1);
      const ne = j && O;
      L && (!ne || U) && h.push(...B.map((Q) => {
        const X = { type: S };
        if (typeof Q == "string" && r && !ne && e.manuallyAnimateOnMount && e.parent) {
          const { parent: Se } = e, W = th(Se, Q);
          if (Se.enteringChildren && W) {
            const { delayChildren: Z } = W.transition || {};
            X.delay = LB(Se.enteringChildren, e, Z);
          }
        }
        return {
          animation: Q,
          options: X
        };
      }));
    }
    if (m.size) {
      const w = {};
      if (typeof u.initial != "boolean") {
        const S = th(e, Array.isArray(u.initial) ? u.initial[0] : u.initial);
        S && S.transition && (w.transition = S.transition);
      }
      m.forEach((S) => {
        const _ = e.getBaseTarget(S), M = e.getValue(S);
        M && (M.liveStyle = !0), w[S] = _ ?? null;
      }), h.push({ animation: w });
    }
    let x = !!h.length;
    return r && (u.initial === !1 || u.initial === u.animate) && !e.manuallyAnimateOnMount && (x = !1), r = !1, x ? t(h) : Promise.resolve();
  }
  function a(c, u) {
    if (n[c].isActive === u)
      return Promise.resolve();
    e.variantChildren?.forEach((h) => h.animationState?.setActive(c, u)), n[c].isActive = u;
    const f = s(c);
    for (const h in n)
      n[h].protectedKeys = {};
    return f;
  }
  return {
    animateChanges: s,
    setActive: a,
    setAnimateFunction: o,
    getState: () => n,
    reset: () => {
      n = MD();
    }
  };
}
function qte(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !y6(t, e) : !1;
}
function Au(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function MD() {
  return {
    animate: Au(!0),
    whileInView: Au(),
    whileHover: Au(),
    whileTap: Au(),
    whileDrag: Au(),
    whileFocus: Au(),
    exit: Au()
  };
}
function ND(e, t) {
  e.min = t.min, e.max = t.max;
}
function is(e, t) {
  ND(e.x, t.x), ND(e.y, t.y);
}
function RD(e, t) {
  e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin;
}
const v6 = 1e-4, Gte = 1 - v6, Kte = 1 + v6, b6 = 0.01, Zte = 0 - b6, Yte = 0 + b6;
function Pi(e) {
  return e.max - e.min;
}
function Xte(e, t, n) {
  return Math.abs(e - t) <= n;
}
function OD(e, t, n, r = 0.5) {
  e.origin = r, e.originPoint = Kn(t.min, t.max, e.origin), e.scale = Pi(n) / Pi(t), e.translate = Kn(n.min, n.max, e.origin) - e.originPoint, (e.scale >= Gte && e.scale <= Kte || isNaN(e.scale)) && (e.scale = 1), (e.translate >= Zte && e.translate <= Yte || isNaN(e.translate)) && (e.translate = 0);
}
function Lm(e, t, n, r) {
  OD(e.x, t.x, n.x, r ? r.originX : void 0), OD(e.y, t.y, n.y, r ? r.originY : void 0);
}
function PD(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + Pi(t);
}
function Jte(e, t, n) {
  PD(e.x, t.x, n.x), PD(e.y, t.y, n.y);
}
function DD(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + Pi(t);
}
function bb(e, t, n) {
  DD(e.x, t.x, n.x), DD(e.y, t.y, n.y);
}
function ID(e, t, n, r, i) {
  return e -= t, e = vb(e, 1 / n, r), i !== void 0 && (e = vb(e, 1 / i, r)), e;
}
function Qte(e, t = 0, n = 1, r = 0.5, i, o = e, s = e) {
  if (Js.test(t) && (t = parseFloat(t), t = Kn(s.min, s.max, t / 100) - s.min), typeof t != "number")
    return;
  let a = Kn(o.min, o.max, r);
  e === o && (a -= t), e.min = ID(e.min, t, n, a, i), e.max = ID(e.max, t, n, a, i);
}
function jD(e, t, [n, r, i], o, s) {
  Qte(e, t[n], t[r], t[i], t.scale, o, s);
}
const ene = ["x", "scaleX", "originX"], tne = ["y", "scaleY", "originY"];
function zD(e, t, n, r) {
  jD(e.x, t, ene, n ? n.x : void 0, r ? r.x : void 0), jD(e.y, t, tne, n ? n.y : void 0, r ? r.y : void 0);
}
function LD(e) {
  return e.translate === 0 && e.scale === 1;
}
function x6(e) {
  return LD(e.x) && LD(e.y);
}
function BD(e, t) {
  return e.min === t.min && e.max === t.max;
}
function nne(e, t) {
  return BD(e.x, t.x) && BD(e.y, t.y);
}
function $D(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function w6(e, t) {
  return $D(e.x, t.x) && $D(e.y, t.y);
}
function UD(e) {
  return Pi(e.x) / Pi(e.y);
}
function FD(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
function jo(e) {
  return [e("x"), e("y")];
}
function rne(e, t, n) {
  let r = "";
  const i = e.x.translate / t.x, o = e.y.translate / t.y, s = n?.z || 0;
  if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { transformPerspective: u, rotate: f, rotateX: h, rotateY: m, skewX: g, skewY: b } = n;
    u && (r = `perspective(${u}px) ${r}`), f && (r += `rotate(${f}deg) `), h && (r += `rotateX(${h}deg) `), m && (r += `rotateY(${m}deg) `), g && (r += `skewX(${g}deg) `), b && (r += `skewY(${b}deg) `);
  }
  const a = e.x.scale * t.x, c = e.y.scale * t.y;
  return (a !== 1 || c !== 1) && (r += `scale(${a}, ${c})`), r || "none";
}
const S6 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], ine = S6.length, VD = (e) => typeof e == "string" ? parseFloat(e) : e, HD = (e) => typeof e == "number" || at.test(e);
function one(e, t, n, r, i, o) {
  i ? (e.opacity = Kn(0, n.opacity ?? 1, sne(r)), e.opacityExit = Kn(t.opacity ?? 1, 0, ane(r))) : o && (e.opacity = Kn(t.opacity ?? 1, n.opacity ?? 1, r));
  for (let s = 0; s < ine; s++) {
    const a = `border${S6[s]}Radius`;
    let c = WD(t, a), u = WD(n, a);
    if (c === void 0 && u === void 0)
      continue;
    c || (c = 0), u || (u = 0), c === 0 || u === 0 || HD(c) === HD(u) ? (e[a] = Math.max(Kn(VD(c), VD(u), r), 0), (Js.test(u) || Js.test(c)) && (e[a] += "%")) : e[a] = u;
  }
  (t.rotate || n.rotate) && (e.rotate = Kn(t.rotate || 0, n.rotate || 0, r));
}
function WD(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const sne = /* @__PURE__ */ k6(0, 0.5, uB), ane = /* @__PURE__ */ k6(0.5, 0.95, Ho);
function k6(e, t, n) {
  return (r) => r < e ? 0 : r > t ? 1 : n(/* @__PURE__ */ mh(e, t, r));
}
function C6(e, t, n) {
  const r = Hr(e) ? e : Nc(e);
  return r.start(zA("", r, t, n)), r.animation;
}
function ug(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
}
const lne = (e, t) => e.depth - t.depth;
class cne {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    xA(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    Gg(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(lne), this.isDirty = !1, this.children.forEach(t);
  }
}
function une(e, t) {
  const n = Oi.now(), r = ({ timestamp: i }) => {
    const o = i - n;
    o >= t && (tl(r), e(o - t));
  };
  return Tn.setup(r, !0), () => tl(r);
}
function D0(e) {
  return Hr(e) ? e.get() : e;
}
class dne {
  constructor() {
    this.members = [];
  }
  add(t) {
    xA(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (Gg(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((i) => t === i);
    if (n === 0)
      return !1;
    let r;
    for (let i = n; i >= 0; i--) {
      const o = this.members[i];
      if (o.isPresent !== !1) {
        r = o;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(t, n) {
    const r = this.lead;
    if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) {
      r.instance && r.scheduleRender(), t.scheduleRender();
      const i = r.options.layoutDependency, o = t.options.layoutDependency;
      i !== void 0 && o !== void 0 && i === o || (t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0));
      const { crossfade: a } = t.options;
      a === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: r } = t;
      n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
const I0 = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
}, Bk = ["", "X", "Y", "Z"], fne = 1e3;
let hne = 0;
function $k(e, t, n, r) {
  const { latestValues: i } = t;
  i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0));
}
function E6(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: t } = e.options;
  if (!t)
    return;
  const n = FB(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: i, layoutId: o } = e.options;
    window.MotionCancelOptimisedAnimation(n, "transform", Tn, !(i || o));
  }
  const { parent: r } = e;
  r && !r.hasCheckedOptimisedAppear && E6(r);
}
function _6({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) {
  return class {
    constructor(s = {}, a = t?.()) {
      this.id = hne++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(gne), this.nodes.forEach(xne), this.nodes.forEach(wne), this.nodes.forEach(yne);
      }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = s, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let c = 0; c < this.path.length; c++)
        this.path[c].shouldResetTransform = !0;
      this.root === this && (this.nodes = new cne());
    }
    addEventListener(s, a) {
      return this.eventHandlers.has(s) || this.eventHandlers.set(s, new kA()), this.eventHandlers.get(s).add(a);
    }
    notifyListeners(s, ...a) {
      const c = this.eventHandlers.get(s);
      c && c.notify(...a);
    }
    hasListeners(s) {
      return this.eventHandlers.has(s);
    }
    /**
     * Lifecycles
     */
    mount(s) {
      if (this.instance)
        return;
      this.isSVG = cw(s) && !JB(s), this.instance = s;
      const { layoutId: a, layout: c, visualElement: u } = this.options;
      if (u && !u.current && u.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (c || a) && (this.isLayoutDirty = !0), e) {
        let f, h = 0;
        const m = () => this.root.updateBlockedByResize = !1;
        Tn.read(() => {
          h = window.innerWidth;
        }), e(s, () => {
          const g = window.innerWidth;
          g !== h && (h = g, this.root.updateBlockedByResize = !0, f && f(), f = une(m, 250), I0.hasAnimatedSinceResize && (I0.hasAnimatedSinceResize = !1, this.nodes.forEach(KD)));
        });
      }
      a && this.root.registerSharedNode(a, this), this.options.animate !== !1 && u && (a || c) && this.addEventListener("didUpdate", ({ delta: f, hasLayoutChanged: h, hasRelativeLayoutChanged: m, layout: g }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const b = this.options.transition || u.getDefaultTransition() || _ne, { onLayoutAnimationStart: x, onLayoutAnimationComplete: w } = u.getProps(), S = !this.targetLayout || !w6(this.targetLayout, g), _ = !h && m;
        if (this.options.layoutRoot || this.resumeFrom || _ || h && (S || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const M = {
            ...jA(b, "layout"),
            onPlay: x,
            onComplete: w
          };
          (u.shouldReduceMotion || this.options.layoutRoot) && (M.delay = 0, M.type = !1), this.startAnimation(M), this.setAnimationOrigin(f, _);
        } else
          h || KD(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = g;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const s = this.getStack();
      s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), tl(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Sne), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: s } = this.options;
      return s && s.getProps().transformTemplate;
    }
    willUpdate(s = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && E6(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let f = 0; f < this.path.length; f++) {
        const h = this.path[f];
        h.shouldResetTransform = !0, h.updateScroll("snapshot"), h.options.layoutRoot && h.willUpdate(!1);
      }
      const { layoutId: a, layout: c } = this.options;
      if (a === void 0 && !c)
        return;
      const u = this.getTransformTemplate();
      this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(qD);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(GD);
        return;
      }
      this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(bne), this.nodes.forEach(pne), this.nodes.forEach(mne)) : this.nodes.forEach(GD), this.clearAllSnapshots();
      const a = Oi.now();
      ni.delta = ta(0, 1e3 / 60, a - ni.timestamp), ni.timestamp = a, ni.isProcessing = !0, Rk.update.process(ni), Rk.preRender.process(ni), Rk.render.process(ni), ni.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, VA.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(vne), this.sharedNodes.forEach(kne);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Tn.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Tn.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !Pi(this.snapshot.measuredBox.x) && !Pi(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let c = 0; c < this.path.length; c++)
          this.path[c].updateScroll();
      const s = this.layout;
      this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = wr(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0);
    }
    updateScroll(s = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a && this.instance) {
        const c = r(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: s,
          isRoot: c,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : c
        };
      }
    }
    resetTransform() {
      if (!i)
        return;
      const s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !x6(this.projectionDelta), c = this.getTransformTemplate(), u = c ? c(this.latestValues, "") : void 0, f = u !== this.prevTransformTemplateValue;
      s && this.instance && (a || Pu(this.latestValues) || f) && (i(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(s = !0) {
      const a = this.measurePageBox();
      let c = this.removeElementScroll(a);
      return s && (c = this.removeTransform(c)), Tne(c), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: c,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: s } = this.options;
      if (!s)
        return wr();
      const a = s.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(Ane))) {
        const { scroll: u } = this.root;
        u && (qf(a.x, u.offset.x), qf(a.y, u.offset.y));
      }
      return a;
    }
    removeElementScroll(s) {
      const a = wr();
      if (is(a, s), this.scroll?.wasRoot)
        return a;
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c], { scroll: f, options: h } = u;
        u !== this.root && f && h.layoutScroll && (f.wasRoot && is(a, s), qf(a.x, f.offset.x), qf(a.y, f.offset.y));
      }
      return a;
    }
    applyTransform(s, a = !1) {
      const c = wr();
      is(c, s);
      for (let u = 0; u < this.path.length; u++) {
        const f = this.path[u];
        !a && f.options.layoutScroll && f.scroll && f !== f.root && Gf(c, {
          x: -f.scroll.offset.x,
          y: -f.scroll.offset.y
        }), Pu(f.latestValues) && Gf(c, f.latestValues);
      }
      return Pu(this.latestValues) && Gf(c, this.latestValues), c;
    }
    removeTransform(s) {
      const a = wr();
      is(a, s);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        if (!u.instance || !Pu(u.latestValues))
          continue;
        h_(u.latestValues) && u.updateSnapshot();
        const f = wr(), h = u.measurePageBox();
        is(f, h), zD(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, f);
      }
      return Pu(this.latestValues) && zD(a, this.latestValues), a;
    }
    setTargetDelta(s) {
      this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(s) {
      this.options = {
        ...this.options,
        ...s,
        crossfade: s.crossfade !== void 0 ? s.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== ni.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(s = !1) {
      const a = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty);
      const c = !!this.resumingFrom || this !== a;
      if (!(s || c && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: f, layoutId: h } = this.options;
      if (!this.layout || !(f || h))
        return;
      this.resolvedRelativeTargetAt = ni.timestamp;
      const m = this.getClosestProjectingParent();
      m && this.linkedParentVersion !== m.layoutVersion && !m.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (m && m.layout ? this.createRelativeTarget(m, this.layout.layoutBox, m.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = wr(), this.targetWithTransforms = wr()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Jte(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : is(this.target, this.layout.layoutBox), s6(this.target, this.targetDelta)) : is(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, m && !!m.resumingFrom == !!this.resumingFrom && !m.options.layoutScroll && m.target && this.animationProgress !== 1 ? this.createRelativeTarget(m, this.target, m.target) : this.relativeParent = this.relativeTarget = void 0));
    }
    getClosestProjectingParent() {
      if (!(!this.parent || h_(this.parent.latestValues) || o6(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    createRelativeTarget(s, a, c) {
      this.relativeParent = s, this.linkedParentVersion = s.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = wr(), this.relativeTargetOrigin = wr(), bb(this.relativeTargetOrigin, a, c), is(this.relativeTarget, this.relativeTargetOrigin);
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      const s = this.getLead(), a = !!this.resumingFrom || this !== s;
      let c = !0;
      if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (c = !1), a && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === ni.timestamp && (c = !1), c)
        return;
      const { layout: u, layoutId: f } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || f))
        return;
      is(this.layoutCorrected, this.layout.layoutBox);
      const h = this.treeScale.x, m = this.treeScale.y;
      Tte(this.layoutCorrected, this.treeScale, this.path, a), s.layout && !s.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (s.target = s.layout.layoutBox, s.targetWithTransforms = wr());
      const { target: g } = s;
      if (!g) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (RD(this.prevProjectionDelta.x, this.projectionDelta.x), RD(this.prevProjectionDelta.y, this.projectionDelta.y)), Lm(this.projectionDelta, this.layoutCorrected, g, this.latestValues), (this.treeScale.x !== h || this.treeScale.y !== m || !FD(this.projectionDelta.x, this.prevProjectionDelta.x) || !FD(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", g));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(s = !0) {
      if (this.options.visualElement?.scheduleRender(), s) {
        const a = this.getStack();
        a && a.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = Wf(), this.projectionDelta = Wf(), this.projectionDeltaWithTransform = Wf();
    }
    setAnimationOrigin(s, a = !1) {
      const c = this.snapshot, u = c ? c.latestValues : {}, f = { ...this.latestValues }, h = Wf();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const m = wr(), g = c ? c.source : void 0, b = this.layout ? this.layout.source : void 0, x = g !== b, w = this.getStack(), S = !w || w.members.length <= 1, _ = !!(x && !S && this.options.crossfade === !0 && !this.path.some(Ene));
      this.animationProgress = 0;
      let M;
      this.mixTargetDelta = (N) => {
        const D = N / 1e3;
        ZD(h.x, s.x, D), ZD(h.y, s.y, D), this.setTargetDelta(h), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (bb(m, this.layout.layoutBox, this.relativeParent.layout.layoutBox), Cne(this.relativeTarget, this.relativeTargetOrigin, m, D), M && nne(this.relativeTarget, M) && (this.isProjectionDirty = !1), M || (M = wr()), is(M, this.relativeTarget)), x && (this.animationValues = f, one(f, u, this.latestValues, D, _, S)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = D;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(s) {
      this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (tl(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Tn.update(() => {
        I0.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = Nc(0)), this.currentAnimation = C6(this.motionValue, [0, 1e3], {
          ...s,
          velocity: 0,
          isSync: !0,
          onUpdate: (a) => {
            this.mixTargetDelta(a), s.onUpdate && s.onUpdate(a);
          },
          onStop: () => {
          },
          onComplete: () => {
            s.onComplete && s.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const s = this.getStack();
      s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(fne), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const s = this.getLead();
      let { targetWithTransforms: a, target: c, layout: u, latestValues: f } = s;
      if (!(!a || !c || !u)) {
        if (this !== s && this.layout && u && T6(this.options.animationType, this.layout.layoutBox, u.layoutBox)) {
          c = this.target || wr();
          const h = Pi(this.layout.layoutBox.x);
          c.x.min = s.target.x.min, c.x.max = c.x.min + h;
          const m = Pi(this.layout.layoutBox.y);
          c.y.min = s.target.y.min, c.y.max = c.y.min + m;
        }
        is(a, c), Gf(a, f), Lm(this.projectionDeltaWithTransform, this.layoutCorrected, a, f);
      }
    }
    registerSharedNode(s, a) {
      this.sharedNodes.has(s) || this.sharedNodes.set(s, new dne()), this.sharedNodes.get(s).add(a);
      const u = a.options.initialPromotionConfig;
      a.promote({
        transition: u ? u.transition : void 0,
        preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const s = this.getStack();
      return s ? s.lead === this : !0;
    }
    getLead() {
      const { layoutId: s } = this.options;
      return s ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId: s } = this.options;
      return s ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId: s } = this.options;
      if (s)
        return this.root.sharedNodes.get(s);
    }
    promote({ needsReset: s, transition: a, preserveFollowOpacity: c } = {}) {
      const u = this.getStack();
      u && u.promote(this, c), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const s = this.getStack();
      return s ? s.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: s } = this.options;
      if (!s)
        return;
      let a = !1;
      const { latestValues: c } = s;
      if ((c.z || c.rotate || c.rotateX || c.rotateY || c.rotateZ || c.skewX || c.skewY) && (a = !0), !a)
        return;
      const u = {};
      c.z && $k("z", s, u, this.animationValues);
      for (let f = 0; f < Bk.length; f++)
        $k(`rotate${Bk[f]}`, s, u, this.animationValues), $k(`skew${Bk[f]}`, s, u, this.animationValues);
      s.render();
      for (const f in u)
        s.setStaticValue(f, u[f]), this.animationValues && (this.animationValues[f] = u[f]);
      s.scheduleRender();
    }
    applyProjectionStyles(s, a) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        s.visibility = "hidden";
        return;
      }
      const c = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = !1, s.visibility = "", s.opacity = "", s.pointerEvents = D0(a?.pointerEvents) || "", s.transform = c ? c(this.latestValues, "") : "none";
        return;
      }
      const u = this.getLead();
      if (!this.projectionDelta || !this.layout || !u.target) {
        this.options.layoutId && (s.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, s.pointerEvents = D0(a?.pointerEvents) || ""), this.hasProjected && !Pu(this.latestValues) && (s.transform = c ? c({}, "") : "none", this.hasProjected = !1);
        return;
      }
      s.visibility = "";
      const f = u.animationValues || u.latestValues;
      this.applyTransformsToTarget();
      let h = rne(this.projectionDeltaWithTransform, this.treeScale, f);
      c && (h = c(f, h)), s.transform = h;
      const { x: m, y: g } = this.projectionDelta;
      s.transformOrigin = `${m.origin * 100}% ${g.origin * 100}% 0`, u.animationValues ? s.opacity = u === this ? f.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : s.opacity = u === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0;
      for (const b in m_) {
        if (f[b] === void 0)
          continue;
        const { correct: x, applyTo: w, isCSSVariable: S } = m_[b], _ = h === "none" ? f[b] : x(f[b], u);
        if (w) {
          const M = w.length;
          for (let N = 0; N < M; N++)
            s[w[N]] = _;
        } else
          S ? this.options.visualElement.renderState.vars[b] = _ : s[b] = _;
      }
      this.options.layoutId && (s.pointerEvents = u === this ? D0(a?.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((s) => s.currentAnimation?.stop()), this.root.nodes.forEach(qD), this.root.sharedNodes.clear();
    }
  };
}
function pne(e) {
  e.updateLayout();
}
function mne(e) {
  const t = e.resumeFrom?.snapshot || e.snapshot;
  if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: r } = e.layout, { animationType: i } = e.options, o = t.source !== e.layout.source;
    i === "size" ? jo((f) => {
      const h = o ? t.measuredBox[f] : t.layoutBox[f], m = Pi(h);
      h.min = n[f].min, h.max = h.min + m;
    }) : T6(i, t.layoutBox, n) && jo((f) => {
      const h = o ? t.measuredBox[f] : t.layoutBox[f], m = Pi(n[f]);
      h.max = h.min + m, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[f].max = e.relativeTarget[f].min + m);
    });
    const s = Wf();
    Lm(s, n, t.layoutBox);
    const a = Wf();
    o ? Lm(a, e.applyTransform(r, !0), t.measuredBox) : Lm(a, n, t.layoutBox);
    const c = !x6(s);
    let u = !1;
    if (!e.resumeFrom) {
      const f = e.getClosestProjectingParent();
      if (f && !f.resumeFrom) {
        const { snapshot: h, layout: m } = f;
        if (h && m) {
          const g = wr();
          bb(g, t.layoutBox, h.layoutBox);
          const b = wr();
          bb(b, n, m.layoutBox), w6(g, b) || (u = !0), f.options.layoutRoot && (e.relativeTarget = b, e.relativeTargetOrigin = g, e.relativeParent = f);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: n,
      snapshot: t,
      delta: a,
      layoutDelta: s,
      hasLayoutChanged: c,
      hasRelativeLayoutChanged: u
    });
  } else if (e.isLead()) {
    const { onExitComplete: n } = e.options;
    n && n();
  }
  e.options.transition = void 0;
}
function gne(e) {
  e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function yne(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function vne(e) {
  e.clearSnapshot();
}
function qD(e) {
  e.clearMeasurements();
}
function GD(e) {
  e.isLayoutDirty = !1;
}
function bne(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function KD(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function xne(e) {
  e.resolveTargetDelta();
}
function wne(e) {
  e.calcProjection();
}
function Sne(e) {
  e.resetSkewAndRotation();
}
function kne(e) {
  e.removeLeadSnapshot();
}
function ZD(e, t, n) {
  e.translate = Kn(t.translate, 0, n), e.scale = Kn(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function YD(e, t, n, r) {
  e.min = Kn(t.min, n.min, r), e.max = Kn(t.max, n.max, r);
}
function Cne(e, t, n, r) {
  YD(e.x, t.x, n.x, r), YD(e.y, t.y, n.y, r);
}
function Ene(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const _ne = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, XD = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), JD = XD("applewebkit/") && !XD("chrome/") ? Math.round : Ho;
function QD(e) {
  e.min = JD(e.min), e.max = JD(e.max);
}
function Tne(e) {
  QD(e.x), QD(e.y);
}
function T6(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !Xte(UD(t), UD(n), 0.2);
}
function Ane(e) {
  return e !== e.root && e.scroll?.wasRoot;
}
const Mne = _6({
  attachResizeListener: (e, t) => ug(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body?.scrollLeft || 0,
    y: document.documentElement.scrollTop || document.body?.scrollTop || 0
  }),
  checkIsScrollRoot: () => !0
}), Uk = {
  current: void 0
}, A6 = _6({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!Uk.current) {
      const e = new Mne({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), Uk.current = e;
    }
    return Uk.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), fw = C.createContext({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
});
function eI(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function Nne(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const o = eI(i, t);
      return !n && typeof o == "function" && (n = !0), o;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const o = r[i];
          typeof o == "function" ? o() : eI(e[i], null);
        }
      };
  };
}
function Rne(...e) {
  return C.useCallback(Nne(...e), e);
}
class One extends C.Component {
  getSnapshotBeforeUpdate(t) {
    const n = this.props.childRef.current;
    if (n && t.isPresent && !this.props.isPresent) {
      const r = n.offsetParent, i = d_(r) && r.offsetWidth || 0, o = d_(r) && r.offsetHeight || 0, s = this.props.sizeRef.current;
      s.height = n.offsetHeight || 0, s.width = n.offsetWidth || 0, s.top = n.offsetTop, s.left = n.offsetLeft, s.right = i - s.width - s.left, s.bottom = o - s.height - s.top;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function Pne({ children: e, isPresent: t, anchorX: n, anchorY: r, root: i }) {
  const o = C.useId(), s = C.useRef(null), a = C.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }), { nonce: c } = C.useContext(fw), u = e.props?.ref ?? e?.ref, f = Rne(s, u);
  return C.useInsertionEffect(() => {
    const { width: h, height: m, top: g, left: b, right: x, bottom: w } = a.current;
    if (t || !s.current || !h || !m)
      return;
    const S = n === "left" ? `left: ${b}` : `right: ${x}`, _ = r === "bottom" ? `bottom: ${w}` : `top: ${g}`;
    s.current.dataset.motionPopId = o;
    const M = document.createElement("style");
    c && (M.nonce = c);
    const N = i ?? document.head;
    return N.appendChild(M), M.sheet && M.sheet.insertRule(`
          [data-motion-pop-id="${o}"] {
            position: absolute !important;
            width: ${h}px !important;
            height: ${m}px !important;
            ${S}px !important;
            ${_}px !important;
          }
        `), () => {
      N.contains(M) && N.removeChild(M);
    };
  }, [t]), v.jsx(One, { isPresent: t, childRef: s, sizeRef: a, children: C.cloneElement(e, { ref: f }) });
}
const Dne = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s, anchorX: a, anchorY: c, root: u }) => {
  const f = qg(Ine), h = C.useId();
  let m = !0, g = C.useMemo(() => (m = !1, {
    id: h,
    initial: t,
    isPresent: n,
    custom: i,
    onExitComplete: (b) => {
      f.set(b, !0);
      for (const x of f.values())
        if (!x)
          return;
      r && r();
    },
    register: (b) => (f.set(b, !1), () => f.delete(b))
  }), [n, f, r]);
  return o && m && (g = { ...g }), C.useMemo(() => {
    f.forEach((b, x) => f.set(x, !1));
  }, [n]), C.useEffect(() => {
    !n && !f.size && r && r();
  }, [n]), s === "popLayout" && (e = v.jsx(Pne, { isPresent: n, anchorX: a, anchorY: c, root: u, children: e })), v.jsx(lw.Provider, { value: g, children: e });
};
function Ine() {
  return /* @__PURE__ */ new Map();
}
function M6(e = !0) {
  const t = C.useContext(lw);
  if (t === null)
    return [!0, null];
  const { isPresent: n, onExitComplete: r, register: i } = t, o = C.useId();
  C.useEffect(() => {
    if (e)
      return i(o);
  }, [e]);
  const s = C.useCallback(() => e && r && r(o), [o, r, e]);
  return !n && r ? [!1, s] : [!0];
}
const $v = (e) => e.key || "";
function tI(e) {
  const t = [];
  return C.Children.forEach(e, (n) => {
    C.isValidElement(n) && t.push(n);
  }), t;
}
const ZA = ({ children: e, custom: t, initial: n = !0, onExitComplete: r, presenceAffectsLayout: i = !0, mode: o = "sync", propagate: s = !1, anchorX: a = "left", anchorY: c = "top", root: u }) => {
  const [f, h] = M6(s), m = C.useMemo(() => tI(e), [e]), g = s && !f ? [] : m.map($v), b = C.useRef(!0), x = C.useRef(m), w = qg(() => /* @__PURE__ */ new Map()), S = C.useRef(/* @__PURE__ */ new Set()), [_, M] = C.useState(m), [N, D] = C.useState(m);
  bA(() => {
    b.current = !1, x.current = m;
    for (let L = 0; L < N.length; L++) {
      const U = $v(N[L]);
      g.includes(U) ? (w.delete(U), S.current.delete(U)) : w.get(U) !== !0 && w.set(U, !1);
    }
  }, [N, g.length, g.join("-")]);
  const j = [];
  if (m !== _) {
    let L = [...m];
    for (let U = 0; U < N.length; U++) {
      const B = N[U], G = $v(B);
      g.includes(G) || (L.splice(U, 0, B), j.push(B));
    }
    return o === "wait" && j.length && (L = j), D(tI(L)), M(m), null;
  }
  const { forceRender: O } = C.useContext(vA);
  return v.jsx(v.Fragment, { children: N.map((L) => {
    const U = $v(L), B = s && !f ? !1 : m === N || g.includes(U), G = () => {
      if (S.current.has(U))
        return;
      if (S.current.add(U), w.has(U))
        w.set(U, !0);
      else
        return;
      let Y = !0;
      w.forEach((he) => {
        he || (Y = !1);
      }), Y && (O?.(), D(x.current), s && h?.(), r && r());
    };
    return v.jsx(Dne, { isPresent: B, initial: !b.current || n ? void 0 : !1, custom: t, presenceAffectsLayout: i, mode: o, root: u, onExitComplete: B ? void 0 : G, anchorX: a, anchorY: c, children: L }, U);
  }) });
}, N6 = C.createContext({ strict: !1 }), nI = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
let rI = !1;
function jne() {
  if (rI)
    return;
  const e = {};
  for (const t in nI)
    e[t] = {
      isEnabled: (n) => nI[t].some((r) => !!n[r])
    };
  t6(e), rI = !0;
}
function R6() {
  return jne(), Cte();
}
function zne(e) {
  const t = R6();
  for (const n in e)
    t[n] = {
      ...t[n],
      ...e[n]
    };
  t6(t);
}
const Lne = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function xb(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || Lne.has(e);
}
let O6 = (e) => !xb(e);
function Bne(e) {
  typeof e == "function" && (O6 = (t) => t.startsWith("on") ? !xb(t) : e(t));
}
try {
  Bne(require("@emotion/is-prop-valid").default);
} catch {
}
function $ne(e, t, n) {
  const r = {};
  for (const i in e)
    i === "values" && typeof e.values == "object" || (O6(i) || n === !0 && xb(i) || !t && !xb(i) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
  return r;
}
const hw = /* @__PURE__ */ C.createContext({});
function Une(e, t) {
  if (dw(e)) {
    const { initial: n, animate: r } = e;
    return {
      initial: n === !1 || cg(n) ? n : void 0,
      animate: cg(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function Fne(e) {
  const { initial: t, animate: n } = Une(e, C.useContext(hw));
  return C.useMemo(() => ({ initial: t, animate: n }), [iI(t), iI(n)]);
}
function iI(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const YA = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function P6(e, t, n) {
  for (const r in t)
    !Hr(t[r]) && !c6(r, n) && (e[r] = t[r]);
}
function Vne({ transformTemplate: e }, t) {
  return C.useMemo(() => {
    const n = YA();
    return GA(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function Hne(e, t) {
  const n = e.style || {}, r = {};
  return P6(r, n, e), Object.assign(r, Vne(e, t)), r;
}
function Wne(e, t) {
  const n = {}, r = Hne(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
const D6 = () => ({
  ...YA(),
  attrs: {}
});
function qne(e, t, n, r) {
  const i = C.useMemo(() => {
    const o = D6();
    return d6(o, t, h6(r), e.transformTemplate, e.style), {
      ...o.attrs,
      style: { ...o.style }
    };
  }, [t]);
  if (e.style) {
    const o = {};
    P6(o, e.style, e), i.style = { ...o, ...i.style };
  }
  return i;
}
const Gne = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function XA(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(Gne.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(e))
    )
  );
}
function Kne(e, t, n, { latestValues: r }, i, o = !1, s) {
  const c = (s ?? XA(e) ? qne : Wne)(t, r, i, e), u = $ne(t, typeof e == "string", o), f = e !== C.Fragment ? { ...u, ...c, ref: n } : {}, { children: h } = t, m = C.useMemo(() => Hr(h) ? h.get() : h, [h]);
  return C.createElement(e, {
    ...f,
    children: m
  });
}
function Zne({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, i) {
  return {
    latestValues: Yne(n, r, i, e),
    renderState: t()
  };
}
function Yne(e, t, n, r) {
  const i = {}, o = r(e, {});
  for (const m in o)
    i[m] = D0(o[m]);
  let { initial: s, animate: a } = e;
  const c = dw(e), u = e6(e);
  t && u && !c && e.inherit !== !1 && (s === void 0 && (s = t.initial), a === void 0 && (a = t.animate));
  let f = n ? n.initial === !1 : !1;
  f = f || s === !1;
  const h = f ? a : s;
  if (h && typeof h != "boolean" && !uw(h)) {
    const m = Array.isArray(h) ? h : [h];
    for (let g = 0; g < m.length; g++) {
      const b = LA(e, m[g]);
      if (b) {
        const { transitionEnd: x, transition: w, ...S } = b;
        for (const _ in S) {
          let M = S[_];
          if (Array.isArray(M)) {
            const N = f ? M.length - 1 : 0;
            M = M[N];
          }
          M !== null && (i[_] = M);
        }
        for (const _ in x)
          i[_] = x[_];
      }
    }
  }
  return i;
}
const I6 = (e) => (t, n) => {
  const r = C.useContext(hw), i = C.useContext(lw), o = () => Zne(e, t, r, i);
  return n ? o() : qg(o);
}, Xne = /* @__PURE__ */ I6({
  scrapeMotionValuesFromProps: KA,
  createRenderState: YA
}), Jne = /* @__PURE__ */ I6({
  scrapeMotionValuesFromProps: p6,
  createRenderState: D6
}), Qne = /* @__PURE__ */ Symbol.for("motionComponentSymbol");
function ere(e, t, n) {
  const r = C.useRef(n);
  C.useInsertionEffect(() => {
    r.current = n;
  });
  const i = C.useRef(null);
  return C.useCallback((o) => {
    o && e.onMount?.(o), t && (o ? t.mount(o) : t.unmount());
    const s = r.current;
    if (typeof s == "function")
      if (o) {
        const a = s(o);
        typeof a == "function" && (i.current = a);
      } else i.current ? (i.current(), i.current = null) : s(o);
    else s && (s.current = o);
  }, [t]);
}
const j6 = C.createContext({});
function Of(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function tre(e, t, n, r, i, o) {
  const { visualElement: s } = C.useContext(hw), a = C.useContext(N6), c = C.useContext(lw), u = C.useContext(fw), f = u.reducedMotion, h = u.skipAnimations, m = C.useRef(null), g = C.useRef(!1);
  r = r || a.renderer, !m.current && r && (m.current = r(e, {
    visualState: t,
    parent: s,
    props: n,
    presenceContext: c,
    blockInitialAnimation: c ? c.initial === !1 : !1,
    reducedMotionConfig: f,
    skipAnimations: h,
    isSVG: o
  }), g.current && m.current && (m.current.manuallyAnimateOnMount = !0));
  const b = m.current, x = C.useContext(j6);
  b && !b.projection && i && (b.type === "html" || b.type === "svg") && nre(m.current, n, i, x);
  const w = C.useRef(!1);
  C.useInsertionEffect(() => {
    b && w.current && b.update(n, c);
  });
  const S = n[UB], _ = C.useRef(!!S && !window.MotionHandoffIsComplete?.(S) && window.MotionHasOptimisedAnimation?.(S));
  return bA(() => {
    g.current = !0, b && (w.current = !0, window.MotionIsMounted = !0, b.updateFeatures(), b.scheduleRenderMicrotask(), _.current && b.animationState && b.animationState.animateChanges());
  }), C.useEffect(() => {
    b && (!_.current && b.animationState && b.animationState.animateChanges(), _.current && (queueMicrotask(() => {
      window.MotionHandoffMarkAsComplete?.(S);
    }), _.current = !1), b.enteringChildren = void 0);
  }), b;
}
function nre(e, t, n, r) {
  const { layoutId: i, layout: o, drag: s, dragConstraints: a, layoutScroll: c, layoutRoot: u, layoutCrossfade: f } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : z6(e.parent)), e.projection.setOptions({
    layoutId: i,
    layout: o,
    alwaysMeasureLayout: !!s || a && Of(a),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof o == "string" ? o : "both",
    initialPromotionConfig: r,
    crossfade: f,
    layoutScroll: c,
    layoutRoot: u
  });
}
function z6(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : z6(e.parent);
}
function Fk(e, { forwardMotionProps: t = !1, type: n } = {}, r, i) {
  r && zne(r);
  const o = n ? n === "svg" : XA(e), s = o ? Jne : Xne;
  function a(u, f) {
    let h;
    const m = {
      ...C.useContext(fw),
      ...u,
      layoutId: rre(u)
    }, { isStatic: g } = m, b = Fne(u), x = s(u, g);
    if (!g && Q4) {
      ire();
      const w = ore(m);
      h = w.MeasureLayout, b.visualElement = tre(e, x, m, i, w.ProjectionNode, o);
    }
    return v.jsxs(hw.Provider, { value: b, children: [h && b.visualElement ? v.jsx(h, { visualElement: b.visualElement, ...m }) : null, Kne(e, u, ere(x, b.visualElement, f), x, g, t, o)] });
  }
  a.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`;
  const c = C.forwardRef(a);
  return c[Qne] = e, c;
}
function rre({ layoutId: e }) {
  const t = C.useContext(vA).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function ire(e, t) {
  C.useContext(N6).strict;
}
function ore(e) {
  const t = R6(), { drag: n, layout: r } = t;
  if (!n && !r)
    return {};
  const i = { ...n, ...r };
  return {
    MeasureLayout: n?.isEnabled(e) || r?.isEnabled(e) ? i.MeasureLayout : void 0,
    ProjectionNode: i.ProjectionNode
  };
}
function sre(e, t) {
  if (typeof Proxy > "u")
    return Fk;
  const n = /* @__PURE__ */ new Map(), r = (o, s) => Fk(o, s, e, t), i = (o, s) => r(o, s);
  return new Proxy(i, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (o, s) => s === "create" ? r : (n.has(s) || n.set(s, Fk(s, void 0, e, t)), n.get(s))
  });
}
const are = (e, t) => t.isSVG ?? XA(e) ? new m6(t) : new u6(t, {
  allowProjection: e !== C.Fragment
});
class lre extends $c {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = Wte(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    uw(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    this.node.animationState.reset(), this.unmountControls?.();
  }
}
let cre = 0;
class ure extends $c {
  constructor() {
    super(...arguments), this.id = cre++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === r)
      return;
    const i = this.node.animationState.setActive("exit", !t);
    n && !t && i.then(() => {
      n(this.id);
    });
  }
  mount() {
    const { register: t, onExitComplete: n } = this.node.presenceContext || {};
    n && n(this.id), t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const dre = {
  animation: {
    Feature: lre
  },
  exit: {
    Feature: ure
  }
};
function Xg(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
const fre = (e) => (t) => HA(t) && e(t, Xg(t));
function Bm(e, t, n, r) {
  return ug(e, t, fre(n), r);
}
const L6 = ({ current: e }) => e ? e.ownerDocument.defaultView : null, oI = (e, t) => Math.abs(e - t);
function hre(e, t) {
  const n = oI(e.x, t.x), r = oI(e.y, t.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
const sI = /* @__PURE__ */ new Set(["auto", "scroll"]);
class B6 {
  constructor(t, n, { transformPagePoint: r, contextWindow: i = window, dragSnapToOrigin: o = !1, distanceThreshold: s = 3, element: a } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.scrollPositions = /* @__PURE__ */ new Map(), this.removeScrollListeners = null, this.onElementScroll = (g) => {
      this.handleScroll(g.target);
    }, this.onWindowScroll = () => {
      this.handleScroll(window);
    }, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const g = Hk(this.lastMoveEventInfo, this.history), b = this.startEvent !== null, x = hre(g.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!b && !x)
        return;
      const { point: w } = g, { timestamp: S } = ni;
      this.history.push({ ...w, timestamp: S });
      const { onStart: _, onMove: M } = this.handlers;
      b || (_ && _(this.lastMoveEvent, g), this.startEvent = this.lastMoveEvent), M && M(this.lastMoveEvent, g);
    }, this.handlePointerMove = (g, b) => {
      this.lastMoveEvent = g, this.lastMoveEventInfo = Vk(b, this.transformPagePoint), Tn.update(this.updatePoint, !0);
    }, this.handlePointerUp = (g, b) => {
      this.end();
      const { onEnd: x, onSessionEnd: w, resumeAnimation: S } = this.handlers;
      if ((this.dragSnapToOrigin || !this.startEvent) && S && S(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const _ = Hk(g.type === "pointercancel" ? this.lastMoveEventInfo : Vk(b, this.transformPagePoint), this.history);
      this.startEvent && x && x(g, _), w && w(g, _);
    }, !HA(t))
      return;
    this.dragSnapToOrigin = o, this.handlers = n, this.transformPagePoint = r, this.distanceThreshold = s, this.contextWindow = i || window;
    const c = Xg(t), u = Vk(c, this.transformPagePoint), { point: f } = u, { timestamp: h } = ni;
    this.history = [{ ...f, timestamp: h }];
    const { onSessionStart: m } = n;
    m && m(t, Hk(u, this.history)), this.removeListeners = Kg(Bm(this.contextWindow, "pointermove", this.handlePointerMove), Bm(this.contextWindow, "pointerup", this.handlePointerUp), Bm(this.contextWindow, "pointercancel", this.handlePointerUp)), a && this.startScrollTracking(a);
  }
  /**
   * Start tracking scroll on ancestors and window.
   */
  startScrollTracking(t) {
    let n = t.parentElement;
    for (; n; ) {
      const r = getComputedStyle(n);
      (sI.has(r.overflowX) || sI.has(r.overflowY)) && this.scrollPositions.set(n, {
        x: n.scrollLeft,
        y: n.scrollTop
      }), n = n.parentElement;
    }
    this.scrollPositions.set(window, {
      x: window.scrollX,
      y: window.scrollY
    }), window.addEventListener("scroll", this.onElementScroll, {
      capture: !0,
      passive: !0
    }), window.addEventListener("scroll", this.onWindowScroll, {
      passive: !0
    }), this.removeScrollListeners = () => {
      window.removeEventListener("scroll", this.onElementScroll, {
        capture: !0
      }), window.removeEventListener("scroll", this.onWindowScroll);
    };
  }
  /**
   * Handle scroll compensation during drag.
   *
   * For element scroll: adjusts history origin since pageX/pageY doesn't change.
   * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.
   */
  handleScroll(t) {
    const n = this.scrollPositions.get(t);
    if (!n)
      return;
    const r = t === window, i = r ? { x: window.scrollX, y: window.scrollY } : {
      x: t.scrollLeft,
      y: t.scrollTop
    }, o = { x: i.x - n.x, y: i.y - n.y };
    o.x === 0 && o.y === 0 || (r ? this.lastMoveEventInfo && (this.lastMoveEventInfo.point.x += o.x, this.lastMoveEventInfo.point.y += o.y) : this.history.length > 0 && (this.history[0].x -= o.x, this.history[0].y -= o.y), this.scrollPositions.set(t, i), Tn.update(this.updatePoint, !0));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), this.removeScrollListeners && this.removeScrollListeners(), this.scrollPositions.clear(), tl(this.updatePoint);
  }
}
function Vk(e, t) {
  return t ? { point: t(e.point) } : e;
}
function aI(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function Hk({ point: e }, t) {
  return {
    point: e,
    delta: aI(e, $6(t)),
    offset: aI(e, pre(t)),
    velocity: mre(t, 0.1)
  };
}
function pre(e) {
  return e[0];
}
function $6(e) {
  return e[e.length - 1];
}
function mre(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, r = null;
  const i = $6(e);
  for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > /* @__PURE__ */ Xs(t))); )
    n--;
  if (!r)
    return { x: 0, y: 0 };
  const o = /* @__PURE__ */ Fo(i.timestamp - r.timestamp);
  if (o === 0)
    return { x: 0, y: 0 };
  const s = {
    x: (i.x - r.x) / o,
    y: (i.y - r.y) / o
  };
  return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s;
}
function gre(e, { min: t, max: n }, r) {
  return t !== void 0 && e < t ? e = r ? Kn(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? Kn(n, e, r.max) : Math.min(e, n)), e;
}
function lI(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function yre(e, { top: t, left: n, bottom: r, right: i }) {
  return {
    x: lI(e.x, n, i),
    y: lI(e.y, t, r)
  };
}
function cI(e, t) {
  let n = t.min - e.min, r = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r };
}
function vre(e, t) {
  return {
    x: cI(e.x, t.x),
    y: cI(e.y, t.y)
  };
}
function bre(e, t) {
  let n = 0.5;
  const r = Pi(e), i = Pi(t);
  return i > r ? n = /* @__PURE__ */ mh(t.min, t.max - r, e.min) : r > i && (n = /* @__PURE__ */ mh(e.min, e.max - i, t.min)), ta(0, 1, n);
}
function xre(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const g_ = 0.35;
function wre(e = g_) {
  return e === !1 ? e = 0 : e === !0 && (e = g_), {
    x: uI(e, "left", "right"),
    y: uI(e, "top", "bottom")
  };
}
function uI(e, t, n) {
  return {
    min: dI(e, t),
    max: dI(e, n)
  };
}
function dI(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const Sre = /* @__PURE__ */ new WeakMap();
class kre {
  constructor(t) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = wr(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1, distanceThreshold: r } = {}) {
    const { presenceContext: i } = this.visualElement;
    if (i && i.isPresent === !1)
      return;
    const o = (h) => {
      n ? (this.stopAnimation(), this.snapToCursor(Xg(h).point)) : this.pauseAnimation();
    }, s = (h, m) => {
      this.stopAnimation();
      const { drag: g, dragPropagation: b, onDragStart: x } = this.getProps();
      if (g && !b && (this.openDragLock && this.openDragLock(), this.openDragLock = nte(g), !this.openDragLock))
        return;
      this.latestPointerEvent = h, this.latestPanInfo = m, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), jo((S) => {
        let _ = this.getAxisMotionValue(S).get() || 0;
        if (Js.test(_)) {
          const { projection: M } = this.visualElement;
          if (M && M.layout) {
            const N = M.layout.layoutBox[S];
            N && (_ = Pi(N) * (parseFloat(_) / 100));
          }
        }
        this.originPoint[S] = _;
      }), x && Tn.update(() => x(h, m), !1, !0), l_(this.visualElement, "transform");
      const { animationState: w } = this.visualElement;
      w && w.setActive("whileDrag", !0);
    }, a = (h, m) => {
      this.latestPointerEvent = h, this.latestPanInfo = m;
      const { dragPropagation: g, dragDirectionLock: b, onDirectionLock: x, onDrag: w } = this.getProps();
      if (!g && !this.openDragLock)
        return;
      const { offset: S } = m;
      if (b && this.currentDirection === null) {
        this.currentDirection = Ere(S), this.currentDirection !== null && x && x(this.currentDirection);
        return;
      }
      this.updateAxis("x", m.point, S), this.updateAxis("y", m.point, S), this.visualElement.render(), w && Tn.update(() => w(h, m), !1, !0);
    }, c = (h, m) => {
      this.latestPointerEvent = h, this.latestPanInfo = m, this.stop(h, m), this.latestPointerEvent = null, this.latestPanInfo = null;
    }, u = () => jo((h) => this.getAnimationState(h) === "paused" && this.getAxisMotionValue(h).animation?.play()), { dragSnapToOrigin: f } = this.getProps();
    this.panSession = new B6(t, {
      onSessionStart: o,
      onStart: s,
      onMove: a,
      onSessionEnd: c,
      resumeAnimation: u
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: f,
      distanceThreshold: r,
      contextWindow: L6(this.visualElement),
      element: this.visualElement.current
    });
  }
  /**
   * @internal
   */
  stop(t, n) {
    const r = t || this.latestPointerEvent, i = n || this.latestPanInfo, o = this.isDragging;
    if (this.cancel(), !o || !i || !r)
      return;
    const { velocity: s } = i;
    this.startAnimation(s);
    const { onDragEnd: a } = this.getProps();
    a && Tn.postRender(() => a(r, i));
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.endPanSession();
    const { dragPropagation: r } = this.getProps();
    !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1);
  }
  /**
   * Clean up the pan session without modifying other drag state.
   * This is used during unmount to ensure event listeners are removed
   * without affecting projection animations or drag locks.
   * @internal
   */
  endPanSession() {
    this.panSession && this.panSession.end(), this.panSession = void 0;
  }
  updateAxis(t, n, r) {
    const { drag: i } = this.getProps();
    if (!r || !Uv(t, i, this.currentDirection))
      return;
    const o = this.getAxisMotionValue(t);
    let s = this.originPoint[t] + r[t];
    this.constraints && this.constraints[t] && (s = gre(s, this.constraints[t], this.elastic[t])), o.set(s);
  }
  resolveConstraints() {
    const { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, i = this.constraints;
    t && Of(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = yre(r.layoutBox, t) : this.constraints = !1, this.elastic = wre(n), i !== this.constraints && !Of(t) && r && this.constraints && !this.hasMutatedConstraints && jo((o) => {
      this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = xre(r.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !Of(t))
      return !1;
    const r = t.current, { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const o = Ate(r, i.root, this.visualElement.getTransformPagePoint());
    let s = vre(i.layout.layoutBox, o);
    if (n) {
      const a = n(Ete(s));
      this.hasMutatedConstraints = !!a, a && (s = i6(a));
    }
    return s;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: o, dragSnapToOrigin: s, onDragTransitionEnd: a } = this.getProps(), c = this.constraints || {}, u = jo((f) => {
      if (!Uv(f, n, this.currentDirection))
        return;
      let h = c && c[f] || {};
      s && (h = { min: 0, max: 0 });
      const m = i ? 200 : 1e6, g = i ? 40 : 1e7, b = {
        type: "inertia",
        velocity: r ? t[f] : 0,
        bounceStiffness: m,
        bounceDamping: g,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...o,
        ...h
      };
      return this.startAxisValueAnimation(f, b);
    });
    return Promise.all(u).then(a);
  }
  startAxisValueAnimation(t, n) {
    const r = this.getAxisMotionValue(t);
    return l_(this.visualElement, t), r.start(zA(t, r, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    jo((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    jo((t) => this.getAxisMotionValue(t).animation?.pause());
  }
  getAnimationState(t) {
    return this.getAxisMotionValue(t).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), i = r[n];
    return i || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    jo((n) => {
      const { drag: r } = this.getProps();
      if (!Uv(n, r, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, o = this.getAxisMotionValue(n);
      if (i && i.layout) {
        const { min: s, max: a } = i.layout.layoutBox[n], c = o.get() || 0;
        o.set(t[n] - Kn(s, a, 0.5) + c);
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement;
    if (!Of(n) || !r || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    jo((s) => {
      const a = this.getAxisMotionValue(s);
      if (a && this.constraints !== !1) {
        const c = a.get();
        i[s] = bre({ min: c, max: c }, this.constraints[s]);
      }
    });
    const { transformTemplate: o } = this.visualElement.getProps();
    this.visualElement.current.style.transform = o ? o({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.constraints = !1, this.resolveConstraints(), jo((s) => {
      if (!Uv(s, t, null))
        return;
      const a = this.getAxisMotionValue(s), { min: c, max: u } = this.constraints[s];
      a.set(Kn(c, u, i[s]));
    }), this.visualElement.render();
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    Sre.set(this.visualElement, this);
    const t = this.visualElement.current, n = Bm(t, "pointerdown", (u) => {
      const { drag: f, dragListener: h = !0 } = this.getProps(), m = u.target, g = m !== t && ate(m);
      f && h && !g && this.start(u);
    });
    let r;
    const i = () => {
      const { dragConstraints: u } = this.getProps();
      Of(u) && u.current && (this.constraints = this.resolveRefConstraints(), r || (r = Cre(t, u.current, () => this.scalePositionWithinConstraints())));
    }, { projection: o } = this.visualElement, s = o.addEventListener("measure", i);
    o && !o.layout && (o.root && o.root.updateScroll(), o.updateLayout()), Tn.read(i);
    const a = ug(window, "resize", () => this.scalePositionWithinConstraints()), c = o.addEventListener("didUpdate", (({ delta: u, hasLayoutChanged: f }) => {
      this.isDragging && f && (jo((h) => {
        const m = this.getAxisMotionValue(h);
        m && (this.originPoint[h] += u[h].translate, m.set(m.get() + u[h].translate));
      }), this.visualElement.render());
    }));
    return () => {
      a(), n(), s(), c && c(), r && r();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: o = !1, dragElastic: s = g_, dragMomentum: a = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: i,
      dragConstraints: o,
      dragElastic: s,
      dragMomentum: a
    };
  }
}
function fI(e) {
  let t = !0;
  return () => {
    if (t) {
      t = !1;
      return;
    }
    e();
  };
}
function Cre(e, t, n) {
  const r = bD(e, fI(n)), i = bD(t, fI(n));
  return () => {
    r(), i();
  };
}
function Uv(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function Ere(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class _re extends $c {
  constructor(t) {
    super(t), this.removeGroupControls = Ho, this.removeListeners = Ho, this.controls = new kre(t);
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Ho;
  }
  update() {
    const { dragControls: t } = this.node.getProps(), { dragControls: n } = this.node.prevProps || {};
    t !== n && (this.removeGroupControls(), t && (this.removeGroupControls = t.subscribe(this.controls)));
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners(), this.controls.isDragging || this.controls.endPanSession();
  }
}
const Wk = (e) => (t, n) => {
  e && Tn.update(() => e(t, n), !1, !0);
};
class Tre extends $c {
  constructor() {
    super(...arguments), this.removePointerDownListener = Ho;
  }
  onPointerDown(t) {
    this.session = new B6(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: L6(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps();
    return {
      onSessionStart: Wk(t),
      onStart: Wk(n),
      onMove: Wk(r),
      onEnd: (o, s) => {
        delete this.session, i && Tn.postRender(() => i(o, s));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Bm(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
let qk = !1;
class Are extends C.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: o } = t;
    o && (n.group && n.group.add(o), r && r.register && i && r.register(o), qk && o.root.didUpdate(), o.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), o.setOptions({
      ...o.options,
      layoutDependency: this.props.layoutDependency,
      onExitComplete: () => this.safeToRemove()
    })), I0.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: r, drag: i, isPresent: o } = this.props, { projection: s } = r;
    return s && (s.isPresent = o, t.layoutDependency !== n && s.setOptions({
      ...s.options,
      layoutDependency: n
    }), qk = !0, i || t.layoutDependency !== n || n === void 0 || t.isPresent !== o ? s.willUpdate() : this.safeToRemove(), t.isPresent !== o && (o ? s.promote() : s.relegate() || Tn.postRender(() => {
      const a = s.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), VA.postRender(() => {
      !t.currentAnimation && t.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = t;
    qk = !0, i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function U6(e) {
  const [t, n] = M6(), r = C.useContext(vA);
  return v.jsx(Are, { ...e, layoutGroup: r, switchLayoutGroup: C.useContext(j6), isPresent: t, safeToRemove: n });
}
const Mre = {
  pan: {
    Feature: Tre
  },
  drag: {
    Feature: _re,
    ProjectionNode: A6,
    MeasureLayout: U6
  }
};
function hI(e, t, n) {
  const { props: r } = e;
  e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const i = "onHover" + n, o = r[i];
  o && Tn.postRender(() => o(t, Xg(t)));
}
class Nre extends $c {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = rte(t, (n, r) => (hI(this.node, r, "Start"), (i) => hI(this.node, i, "End"))));
  }
  unmount() {
  }
}
class Rre extends $c {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Kg(ug(this.node.current, "focus", () => this.onFocus()), ug(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function pI(e, t, n) {
  const { props: r } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled)
    return;
  e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const i = "onTap" + (n === "End" ? "" : n), o = r[i];
  o && Tn.postRender(() => o(t, Xg(t)));
}
class Ore extends $c {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = cte(t, (n, r) => (pI(this.node, r, "Start"), (i, { success: o }) => pI(this.node, i, o ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const y_ = /* @__PURE__ */ new WeakMap(), Gk = /* @__PURE__ */ new WeakMap(), Pre = (e) => {
  const t = y_.get(e.target);
  t && t(e);
}, Dre = (e) => {
  e.forEach(Pre);
};
function Ire({ root: e, ...t }) {
  const n = e || document;
  Gk.has(n) || Gk.set(n, {});
  const r = Gk.get(n), i = JSON.stringify(t);
  return r[i] || (r[i] = new IntersectionObserver(Dre, { root: e, ...t })), r[i];
}
function jre(e, t, n) {
  const r = Ire(t);
  return y_.set(e, n), r.observe(e), () => {
    y_.delete(e), r.unobserve(e);
  };
}
const zre = {
  some: 0,
  all: 1
};
class Lre extends $c {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: o } = t, s = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof i == "number" ? i : zre[i]
    }, a = (c) => {
      const { isIntersecting: u } = c;
      if (this.isInView === u || (this.isInView = u, o && !u && this.hasEnteredView))
        return;
      u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u);
      const { onViewportEnter: f, onViewportLeave: h } = this.node.getProps(), m = u ? f : h;
      m && m(c);
    };
    return jre(this.node.current, s, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(Bre(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function Bre({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const $re = {
  inView: {
    Feature: Lre
  },
  tap: {
    Feature: Ore
  },
  focus: {
    Feature: Rre
  },
  hover: {
    Feature: Nre
  }
}, Ure = {
  layout: {
    ProjectionNode: A6,
    MeasureLayout: U6
  }
}, Fre = {
  ...dre,
  ...$re,
  ...Mre,
  ...Ure
}, nh = /* @__PURE__ */ sre(Fre, are);
function F6(e) {
  const t = qg(() => Nc(e)), { isStatic: n } = C.useContext(fw);
  if (n) {
    const [, r] = C.useState(e);
    C.useEffect(() => t.on("change", r), []);
  }
  return t;
}
function V6(e, t) {
  const n = F6(t()), r = () => n.set(t());
  return r(), bA(() => {
    const i = () => Tn.preRender(r, !1, !0), o = e.map((s) => s.on("change", i));
    return () => {
      o.forEach((s) => s()), tl(r);
    };
  }), n;
}
function Vre(e) {
  zm.current = [], e();
  const t = V6(zm.current, e);
  return zm.current = void 0, t;
}
function Hre(e, t, n, r) {
  if (typeof e == "function")
    return Vre(e);
  const o = typeof t == "function" ? t : vte(t, n, r);
  return Array.isArray(e) ? mI(e, o) : mI([e], ([s]) => o(s));
}
function mI(e, t) {
  const n = qg(() => []);
  return V6(e, () => {
    n.length = 0;
    const r = e.length;
    for (let i = 0; i < r; i++)
      n[i] = e[i].get();
    return t(n);
  });
}
function JA(e) {
  return typeof e == "object" && !Array.isArray(e);
}
function H6(e, t, n, r) {
  return e == null ? [] : typeof e == "string" && JA(t) ? FA(e, n, r) : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e.filter((i) => i != null) : [e];
}
function Wre(e, t, n) {
  return e * (t + 1);
}
function gI(e, t, n, r) {
  return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : t.startsWith("<") ? Math.max(0, n + parseFloat(t.slice(1))) : r.get(t) ?? e;
}
function qre(e, t, n) {
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    i.at > t && i.at < n && (Gg(e, i), r--);
  }
}
function Gre(e, t, n, r, i, o) {
  qre(e, i, o);
  for (let s = 0; s < t.length; s++)
    e.push({
      value: t[s],
      at: Kn(i, o, r[s]),
      easing: pB(n, s)
    });
}
function Kre(e, t) {
  for (let n = 0; n < e.length; n++)
    e[n] = e[n] / (t + 1);
}
function Zre(e, t) {
  return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at;
}
const Yre = "easeInOut";
function Xre(e, { defaultTransition: t = {}, ...n } = {}, r, i) {
  const o = t.duration || 0.3, s = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), c = {}, u = /* @__PURE__ */ new Map();
  let f = 0, h = 0, m = 0;
  for (let g = 0; g < e.length; g++) {
    const b = e[g];
    if (typeof b == "string") {
      u.set(b, h);
      continue;
    } else if (!Array.isArray(b)) {
      u.set(b.name, gI(h, b.at, f, u));
      continue;
    }
    let [x, w, S = {}] = b;
    S.at !== void 0 && (h = gI(h, S.at, f, u));
    let _ = 0;
    const M = (N, D, j, O = 0, L = 0) => {
      const U = Jre(N), { delay: B = 0, times: G = RB(U), type: Y = t.type || "keyframes", repeat: he, repeatType: ie, repeatDelay: ne = 0, ...H } = D;
      let { ease: Q = t.ease || "easeOut", duration: X } = D;
      const Se = typeof B == "function" ? B(O, L) : B, W = U.length, Z = IA(Y) ? Y : i?.[Y || "keyframes"];
      if (W <= 2 && Z) {
        let ge = 100;
        if (W === 2 && tie(U)) {
          const xe = U[1] - U[0];
          ge = Math.abs(xe);
        }
        const re = {
          ...t,
          ...H
        };
        X !== void 0 && (re.duration = /* @__PURE__ */ Xs(X));
        const J = TB(re, ge, Z);
        Q = J.ease, X = J.duration;
      }
      X ?? (X = o);
      const pe = h + Se;
      G.length === 1 && G[0] === 0 && (G[1] = 1);
      const F = G.length - U.length;
      if (F > 0 && NB(G, F), U.length === 1 && U.unshift(null), he) {
        X = Wre(X, he);
        const ge = [...U], re = [...G];
        Q = Array.isArray(Q) ? [...Q] : [Q];
        const J = [...Q];
        for (let xe = 0; xe < he; xe++) {
          U.push(...ge);
          for (let be = 0; be < ge.length; be++)
            G.push(re[be] + (xe + 1)), Q.push(be === 0 ? "linear" : pB(J, be - 1));
        }
        Kre(G, he);
      }
      const ee = pe + X;
      Gre(j, U, Q, G, pe, ee), _ = Math.max(Se + X, _), m = Math.max(ee, m);
    };
    if (Hr(x)) {
      const N = yI(x, a);
      M(w, S, vI("default", N));
    } else {
      const N = H6(x, w, r, c), D = N.length;
      for (let j = 0; j < D; j++) {
        w = w, S = S;
        const O = N[j], L = yI(O, a);
        for (const U in w)
          M(w[U], Qre(S, U), vI(U, L), j, D);
      }
    }
    f = h, h += _;
  }
  return a.forEach((g, b) => {
    for (const x in g) {
      const w = g[x];
      w.sort(Zre);
      const S = [], _ = [], M = [];
      for (let O = 0; O < w.length; O++) {
        const { at: L, value: U, easing: B } = w[O];
        S.push(U), _.push(/* @__PURE__ */ mh(0, m, L)), M.push(B || "easeOut");
      }
      _[0] !== 0 && (_.unshift(0), S.unshift(S[0]), M.unshift(Yre)), _[_.length - 1] !== 1 && (_.push(1), S.push(null)), s.has(b) || s.set(b, {
        keyframes: {},
        transition: {}
      });
      const N = s.get(b);
      N.keyframes[x] = S;
      const { type: D, ...j } = t;
      N.transition[x] = {
        ...j,
        duration: m,
        ease: M,
        times: _,
        ...n
      };
    }
  }), s;
}
function yI(e, t) {
  return !t.has(e) && t.set(e, {}), t.get(e);
}
function vI(e, t) {
  return t[e] || (t[e] = []), t[e];
}
function Jre(e) {
  return Array.isArray(e) ? e : [e];
}
function Qre(e, t) {
  return e && e[t] ? {
    ...e,
    ...e[t]
  } : { ...e };
}
const eie = (e) => typeof e == "number", tie = (e) => e.every(eie);
function nie(e) {
  const t = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, n = cw(e) && !JB(e) ? new m6(t) : new u6(t);
  n.mount(e), lg.set(e, n);
}
function rie(e) {
  const t = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  }, n = new Ite(t);
  n.mount(e), lg.set(e, n);
}
function iie(e, t) {
  return Hr(e) || typeof e == "number" || typeof e == "string" && !JA(t);
}
function W6(e, t, n, r) {
  const i = [];
  if (iie(e, t))
    i.push(C6(e, JA(t) && t.default || t, n && (n.default || n)));
  else {
    if (e == null)
      return i;
    const o = H6(e, t, r), s = o.length;
    for (let a = 0; a < s; a++) {
      const c = o[a], u = c instanceof Element ? nie : rie;
      lg.has(c) || u(c);
      const f = lg.get(c), h = { ...n };
      "delay" in h && typeof h.delay == "function" && (h.delay = h.delay(a, s)), i.push(...$A(f, { ...t, transition: h }, {}));
    }
  }
  return i;
}
function oie(e, t, n) {
  const r = [], i = e.map((s) => {
    if (Array.isArray(s) && typeof s[0] == "function") {
      const a = s[0], c = Nc(0);
      return c.on("change", a), s.length === 1 ? [c, [0, 1]] : s.length === 2 ? [c, [0, 1], s[1]] : [c, s[1], s[2]];
    }
    return s;
  });
  return Xre(i, t, n, { spring: ag }).forEach(({ keyframes: s, transition: a }, c) => {
    r.push(...W6(c, s, a));
  }), r;
}
function sie(e) {
  return Array.isArray(e) && e.some(Array.isArray);
}
function aie(e = {}) {
  const { scope: t, reduceMotion: n } = e;
  function r(i, o, s) {
    let a = [], c;
    if (sie(i))
      a = oie(i, n !== void 0 ? { reduceMotion: n, ...o } : o, t);
    else {
      const { onComplete: f, ...h } = s || {};
      typeof f == "function" && (c = f), a = W6(i, o, n !== void 0 ? { reduceMotion: n, ...h } : h, t);
    }
    const u = new Eee(a);
    return c && u.finished.then(c), t && (t.animations.push(u), u.finished.then(() => {
      Gg(t.animations, u);
    })), u;
  }
  return r;
}
const lie = aie();
var cie = /* @__PURE__ */ Symbol.for("react.lazy"), wb = nw[" use ".trim().toString()];
function uie(e) {
  return typeof e == "object" && e !== null && "then" in e;
}
function q6(e) {
  return e != null && typeof e == "object" && "$$typeof" in e && e.$$typeof === cie && "_payload" in e && uie(e._payload);
}
// @__NO_SIDE_EFFECTS__
function G6(e) {
  const t = /* @__PURE__ */ die(e), n = C.forwardRef((r, i) => {
    let { children: o, ...s } = r;
    q6(o) && typeof wb == "function" && (o = wb(o._payload));
    const a = C.Children.toArray(o), c = a.find(hie);
    if (c) {
      const u = c.props.children, f = a.map((h) => h === c ? C.Children.count(u) > 1 ? C.Children.only(null) : C.isValidElement(u) ? u.props.children : null : h);
      return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: C.isValidElement(u) ? C.cloneElement(u, void 0, f) : null });
    }
    return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: o });
  });
  return n.displayName = `${e}.Slot`, n;
}
var K6 = /* @__PURE__ */ G6("Slot");
// @__NO_SIDE_EFFECTS__
function die(e) {
  const t = C.forwardRef((n, r) => {
    let { children: i, ...o } = n;
    if (q6(i) && typeof wb == "function" && (i = wb(i._payload)), C.isValidElement(i)) {
      const s = mie(i), a = pie(o, i.props);
      return i.type !== C.Fragment && (a.ref = r ? Wg(r, s) : s), C.cloneElement(i, a);
    }
    return C.Children.count(i) > 1 ? C.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var fie = /* @__PURE__ */ Symbol("radix.slottable");
function hie(e) {
  return C.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === fie;
}
function pie(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...a) => {
      const c = o(...a);
      return i(...a), c;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function mie(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
const bI = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, xI = bc, QA = (e, t) => (n) => {
  var r;
  if (t?.variants == null) return xI(e, n?.class, n?.className);
  const { variants: i, defaultVariants: o } = t, s = Object.keys(i).map((u) => {
    const f = n?.[u], h = o?.[u];
    if (f === null) return null;
    const m = bI(f) || bI(h);
    return i[u][m];
  }), a = n && Object.entries(n).reduce((u, f) => {
    let [h, m] = f;
    return m === void 0 || (u[h] = m), u;
  }, {}), c = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((u, f) => {
    let { class: h, className: m, ...g } = f;
    return Object.entries(g).every((b) => {
      let [x, w] = b;
      return Array.isArray(w) ? w.includes({
        ...o,
        ...a
      }[x]) : {
        ...o,
        ...a
      }[x] === w;
    }) ? [
      ...u,
      h,
      m
    ] : u;
  }, []);
  return xI(e, s, c, n?.class, n?.className);
};
function gie({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    ea,
    {
      role: "status",
      "aria-label": "Loading",
      className: lt("size-4 animate-spin", e),
      ...t
    }
  );
}
const yie = QA(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
function qt({
  className: e,
  variant: t,
  size: n,
  asChild: r = !1,
  isLoading: i = !1,
  ...o
}) {
  const s = r ? K6 : "button";
  return /* @__PURE__ */ v.jsxs(
    s,
    {
      "data-slot": "button",
      className: lt(yie({ variant: t, size: n, className: e })),
      ...o,
      children: [
        o.children,
        " ",
        i && /* @__PURE__ */ v.jsx(gie, {})
      ]
    }
  );
}
function vie(e, t = globalThis?.document) {
  const n = Ir(e);
  C.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var bie = "DismissableLayer", v_ = "dismissableLayer.update", xie = "dismissableLayer.pointerDownOutside", wie = "dismissableLayer.focusOutside", wI, Z6 = C.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Jg = C.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: o,
      onInteractOutside: s,
      onDismiss: a,
      ...c
    } = e, u = C.useContext(Z6), [f, h] = C.useState(null), m = f?.ownerDocument ?? globalThis?.document, [, g] = C.useState({}), b = Ht(t, (O) => h(O)), x = Array.from(u.layers), [w] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), S = x.indexOf(w), _ = f ? x.indexOf(f) : -1, M = u.layersWithOutsidePointerEventsDisabled.size > 0, N = _ >= S, D = Cie((O) => {
      const L = O.target, U = [...u.branches].some((B) => B.contains(L));
      !N || U || (i?.(O), s?.(O), O.defaultPrevented || a?.());
    }, m), j = Eie((O) => {
      const L = O.target;
      [...u.branches].some((B) => B.contains(L)) || (o?.(O), s?.(O), O.defaultPrevented || a?.());
    }, m);
    return vie((O) => {
      _ === u.layers.size - 1 && (r?.(O), !O.defaultPrevented && a && (O.preventDefault(), a()));
    }, m), C.useEffect(() => {
      if (f)
        return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (wI = m.body.style.pointerEvents, m.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(f)), u.layers.add(f), SI(), () => {
          n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (m.body.style.pointerEvents = wI);
        };
    }, [f, m, n, u]), C.useEffect(() => () => {
      f && (u.layers.delete(f), u.layersWithOutsidePointerEventsDisabled.delete(f), SI());
    }, [f, u]), C.useEffect(() => {
      const O = () => g({});
      return document.addEventListener(v_, O), () => document.removeEventListener(v_, O);
    }, []), /* @__PURE__ */ v.jsx(
      _t.div,
      {
        ...c,
        ref: b,
        style: {
          pointerEvents: M ? N ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Ye(e.onFocusCapture, j.onFocusCapture),
        onBlurCapture: Ye(e.onBlurCapture, j.onBlurCapture),
        onPointerDownCapture: Ye(
          e.onPointerDownCapture,
          D.onPointerDownCapture
        )
      }
    );
  }
);
Jg.displayName = bie;
var Sie = "DismissableLayerBranch", kie = C.forwardRef((e, t) => {
  const n = C.useContext(Z6), r = C.useRef(null), i = Ht(t, r);
  return C.useEffect(() => {
    const o = r.current;
    if (o)
      return n.branches.add(o), () => {
        n.branches.delete(o);
      };
  }, [n.branches]), /* @__PURE__ */ v.jsx(_t.div, { ...e, ref: i });
});
kie.displayName = Sie;
function Cie(e, t = globalThis?.document) {
  const n = Ir(e), r = C.useRef(!1), i = C.useRef(() => {
  });
  return C.useEffect(() => {
    const o = (a) => {
      if (a.target && !r.current) {
        let c = function() {
          Y6(
            xie,
            n,
            u,
            { discrete: !0 }
          );
        };
        const u = { originalEvent: a };
        a.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = c, t.addEventListener("click", i.current, { once: !0 })) : c();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      t.addEventListener("pointerdown", o);
    }, 0);
    return () => {
      window.clearTimeout(s), t.removeEventListener("pointerdown", o), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function Eie(e, t = globalThis?.document) {
  const n = Ir(e), r = C.useRef(!1);
  return C.useEffect(() => {
    const i = (o) => {
      o.target && !r.current && Y6(wie, n, { originalEvent: o }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function SI() {
  const e = new CustomEvent(v_);
  document.dispatchEvent(e);
}
function Y6(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? _4(i, o) : i.dispatchEvent(o);
}
var _ie = nw[" useId ".trim().toString()] || (() => {
}), Tie = 0;
function Wo(e) {
  const [t, n] = C.useState(_ie());
  return _r(() => {
    n((r) => r ?? String(Tie++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
const Aie = ["top", "right", "bottom", "left"], Rc = Math.min, ho = Math.max, Sb = Math.round, Fv = Math.floor, Qs = (e) => ({
  x: e,
  y: e
}), Mie = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Nie = {
  start: "end",
  end: "start"
};
function b_(e, t, n) {
  return ho(e, Rc(t, n));
}
function nl(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function rl(e) {
  return e.split("-")[0];
}
function Bh(e) {
  return e.split("-")[1];
}
function eM(e) {
  return e === "x" ? "y" : "x";
}
function tM(e) {
  return e === "y" ? "height" : "width";
}
const Rie = /* @__PURE__ */ new Set(["top", "bottom"]);
function Zs(e) {
  return Rie.has(rl(e)) ? "y" : "x";
}
function nM(e) {
  return eM(Zs(e));
}
function Oie(e, t, n) {
  n === void 0 && (n = !1);
  const r = Bh(e), i = nM(e), o = tM(i);
  let s = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (s = kb(s)), [s, kb(s)];
}
function Pie(e) {
  const t = kb(e);
  return [x_(e), t, x_(t)];
}
function x_(e) {
  return e.replace(/start|end/g, (t) => Nie[t]);
}
const kI = ["left", "right"], CI = ["right", "left"], Die = ["top", "bottom"], Iie = ["bottom", "top"];
function jie(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? CI : kI : t ? kI : CI;
    case "left":
    case "right":
      return t ? Die : Iie;
    default:
      return [];
  }
}
function zie(e, t, n, r) {
  const i = Bh(e);
  let o = jie(rl(e), n === "start", r);
  return i && (o = o.map((s) => s + "-" + i), t && (o = o.concat(o.map(x_)))), o;
}
function kb(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Mie[t]);
}
function Lie(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function X6(e) {
  return typeof e != "number" ? Lie(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Cb(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
function EI(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const o = Zs(t), s = nM(t), a = tM(s), c = rl(t), u = o === "y", f = r.x + r.width / 2 - i.width / 2, h = r.y + r.height / 2 - i.height / 2, m = r[a] / 2 - i[a] / 2;
  let g;
  switch (c) {
    case "top":
      g = {
        x: f,
        y: r.y - i.height
      };
      break;
    case "bottom":
      g = {
        x: f,
        y: r.y + r.height
      };
      break;
    case "right":
      g = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      g = {
        x: r.x - i.width,
        y: h
      };
      break;
    default:
      g = {
        x: r.x,
        y: r.y
      };
  }
  switch (Bh(t)) {
    case "start":
      g[s] -= m * (n && u ? -1 : 1);
      break;
    case "end":
      g[s] += m * (n && u ? -1 : 1);
      break;
  }
  return g;
}
async function Bie(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: o,
    rects: s,
    elements: a,
    strategy: c
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: h = "floating",
    altBoundary: m = !1,
    padding: g = 0
  } = nl(t, e), b = X6(g), w = a[m ? h === "floating" ? "reference" : "floating" : h], S = Cb(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(w))) == null || n ? w : w.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: f,
    strategy: c
  })), _ = h === "floating" ? {
    x: r,
    y: i,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, M = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), N = await (o.isElement == null ? void 0 : o.isElement(M)) ? await (o.getScale == null ? void 0 : o.getScale(M)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, D = Cb(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: _,
    offsetParent: M,
    strategy: c
  }) : _);
  return {
    top: (S.top - D.top + b.top) / N.y,
    bottom: (D.bottom - S.bottom + b.bottom) / N.y,
    left: (S.left - D.left + b.left) / N.x,
    right: (D.right - S.right + b.right) / N.x
  };
}
const $ie = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: s
  } = n, a = o.filter(Boolean), c = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let u = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: f,
    y: h
  } = EI(u, r, c), m = r, g = {}, b = 0;
  for (let w = 0; w < a.length; w++) {
    var x;
    const {
      name: S,
      fn: _
    } = a[w], {
      x: M,
      y: N,
      data: D,
      reset: j
    } = await _({
      x: f,
      y: h,
      initialPlacement: r,
      placement: m,
      strategy: i,
      middlewareData: g,
      rects: u,
      platform: {
        ...s,
        detectOverflow: (x = s.detectOverflow) != null ? x : Bie
      },
      elements: {
        reference: e,
        floating: t
      }
    });
    f = M ?? f, h = N ?? h, g = {
      ...g,
      [S]: {
        ...g[S],
        ...D
      }
    }, j && b <= 50 && (b++, typeof j == "object" && (j.placement && (m = j.placement), j.rects && (u = j.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : j.rects), {
      x: f,
      y: h
    } = EI(u, m, c)), w = -1);
  }
  return {
    x: f,
    y: h,
    placement: m,
    strategy: i,
    middlewareData: g
  };
}, Uie = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: o,
      platform: s,
      elements: a,
      middlewareData: c
    } = t, {
      element: u,
      padding: f = 0
    } = nl(e, t) || {};
    if (u == null)
      return {};
    const h = X6(f), m = {
      x: n,
      y: r
    }, g = nM(i), b = tM(g), x = await s.getDimensions(u), w = g === "y", S = w ? "top" : "left", _ = w ? "bottom" : "right", M = w ? "clientHeight" : "clientWidth", N = o.reference[b] + o.reference[g] - m[g] - o.floating[b], D = m[g] - o.reference[g], j = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));
    let O = j ? j[M] : 0;
    (!O || !await (s.isElement == null ? void 0 : s.isElement(j))) && (O = a.floating[M] || o.floating[b]);
    const L = N / 2 - D / 2, U = O / 2 - x[b] / 2 - 1, B = Rc(h[S], U), G = Rc(h[_], U), Y = B, he = O - x[b] - G, ie = O / 2 - x[b] / 2 + L, ne = b_(Y, ie, he), H = !c.arrow && Bh(i) != null && ie !== ne && o.reference[b] / 2 - (ie < Y ? B : G) - x[b] / 2 < 0, Q = H ? ie < Y ? ie - Y : ie - he : 0;
    return {
      [g]: m[g] + Q,
      data: {
        [g]: ne,
        centerOffset: ie - ne - Q,
        ...H && {
          alignmentOffset: Q
        }
      },
      reset: H
    };
  }
}), Fie = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        middlewareData: o,
        rects: s,
        initialPlacement: a,
        platform: c,
        elements: u
      } = t, {
        mainAxis: f = !0,
        crossAxis: h = !0,
        fallbackPlacements: m,
        fallbackStrategy: g = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: x = !0,
        ...w
      } = nl(e, t);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const S = rl(i), _ = Zs(a), M = rl(a) === a, N = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)), D = m || (M || !x ? [kb(a)] : Pie(a)), j = b !== "none";
      !m && j && D.push(...zie(a, x, b, N));
      const O = [a, ...D], L = await c.detectOverflow(t, w), U = [];
      let B = ((r = o.flip) == null ? void 0 : r.overflows) || [];
      if (f && U.push(L[S]), h) {
        const ie = Oie(i, s, N);
        U.push(L[ie[0]], L[ie[1]]);
      }
      if (B = [...B, {
        placement: i,
        overflows: U
      }], !U.every((ie) => ie <= 0)) {
        var G, Y;
        const ie = (((G = o.flip) == null ? void 0 : G.index) || 0) + 1, ne = O[ie];
        if (ne && (!(h === "alignment" ? _ !== Zs(ne) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        B.every((X) => Zs(X.placement) === _ ? X.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ie,
              overflows: B
            },
            reset: {
              placement: ne
            }
          };
        let H = (Y = B.filter((Q) => Q.overflows[0] <= 0).sort((Q, X) => Q.overflows[1] - X.overflows[1])[0]) == null ? void 0 : Y.placement;
        if (!H)
          switch (g) {
            case "bestFit": {
              var he;
              const Q = (he = B.filter((X) => {
                if (j) {
                  const Se = Zs(X.placement);
                  return Se === _ || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Se === "y";
                }
                return !0;
              }).map((X) => [X.placement, X.overflows.filter((Se) => Se > 0).reduce((Se, W) => Se + W, 0)]).sort((X, Se) => X[1] - Se[1])[0]) == null ? void 0 : he[0];
              Q && (H = Q);
              break;
            }
            case "initialPlacement":
              H = a;
              break;
          }
        if (i !== H)
          return {
            reset: {
              placement: H
            }
          };
      }
      return {};
    }
  };
};
function _I(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function TI(e) {
  return Aie.some((t) => e[t] >= 0);
}
const Vie = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n,
        platform: r
      } = t, {
        strategy: i = "referenceHidden",
        ...o
      } = nl(e, t);
      switch (i) {
        case "referenceHidden": {
          const s = await r.detectOverflow(t, {
            ...o,
            elementContext: "reference"
          }), a = _I(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: a,
              referenceHidden: TI(a)
            }
          };
        }
        case "escaped": {
          const s = await r.detectOverflow(t, {
            ...o,
            altBoundary: !0
          }), a = _I(s, n.floating);
          return {
            data: {
              escapedOffsets: a,
              escaped: TI(a)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, J6 = /* @__PURE__ */ new Set(["left", "top"]);
async function Hie(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), s = rl(n), a = Bh(n), c = Zs(n) === "y", u = J6.has(s) ? -1 : 1, f = o && c ? -1 : 1, h = nl(t, e);
  let {
    mainAxis: m,
    crossAxis: g,
    alignmentAxis: b
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return a && typeof b == "number" && (g = a === "end" ? b * -1 : b), c ? {
    x: g * f,
    y: m * u
  } : {
    x: m * u,
    y: g * f
  };
}
const Wie = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: o,
        placement: s,
        middlewareData: a
      } = t, c = await Hie(t, e);
      return s === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
        x: i + c.x,
        y: o + c.y,
        data: {
          ...c,
          placement: s
        }
      };
    }
  };
}, qie = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i,
        platform: o
      } = t, {
        mainAxis: s = !0,
        crossAxis: a = !1,
        limiter: c = {
          fn: (S) => {
            let {
              x: _,
              y: M
            } = S;
            return {
              x: _,
              y: M
            };
          }
        },
        ...u
      } = nl(e, t), f = {
        x: n,
        y: r
      }, h = await o.detectOverflow(t, u), m = Zs(rl(i)), g = eM(m);
      let b = f[g], x = f[m];
      if (s) {
        const S = g === "y" ? "top" : "left", _ = g === "y" ? "bottom" : "right", M = b + h[S], N = b - h[_];
        b = b_(M, b, N);
      }
      if (a) {
        const S = m === "y" ? "top" : "left", _ = m === "y" ? "bottom" : "right", M = x + h[S], N = x - h[_];
        x = b_(M, x, N);
      }
      const w = c.fn({
        ...t,
        [g]: b,
        [m]: x
      });
      return {
        ...w,
        data: {
          x: w.x - n,
          y: w.y - r,
          enabled: {
            [g]: s,
            [m]: a
          }
        }
      };
    }
  };
}, Gie = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: i,
        rects: o,
        middlewareData: s
      } = t, {
        offset: a = 0,
        mainAxis: c = !0,
        crossAxis: u = !0
      } = nl(e, t), f = {
        x: n,
        y: r
      }, h = Zs(i), m = eM(h);
      let g = f[m], b = f[h];
      const x = nl(a, t), w = typeof x == "number" ? {
        mainAxis: x,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...x
      };
      if (c) {
        const M = m === "y" ? "height" : "width", N = o.reference[m] - o.floating[M] + w.mainAxis, D = o.reference[m] + o.reference[M] - w.mainAxis;
        g < N ? g = N : g > D && (g = D);
      }
      if (u) {
        var S, _;
        const M = m === "y" ? "width" : "height", N = J6.has(rl(i)), D = o.reference[h] - o.floating[M] + (N && ((S = s.offset) == null ? void 0 : S[h]) || 0) + (N ? 0 : w.crossAxis), j = o.reference[h] + o.reference[M] + (N ? 0 : ((_ = s.offset) == null ? void 0 : _[h]) || 0) - (N ? w.crossAxis : 0);
        b < D ? b = D : b > j && (b = j);
      }
      return {
        [m]: g,
        [h]: b
      };
    }
  };
}, Kie = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        rects: o,
        platform: s,
        elements: a
      } = t, {
        apply: c = () => {
        },
        ...u
      } = nl(e, t), f = await s.detectOverflow(t, u), h = rl(i), m = Bh(i), g = Zs(i) === "y", {
        width: b,
        height: x
      } = o.floating;
      let w, S;
      h === "top" || h === "bottom" ? (w = h, S = m === (await (s.isRTL == null ? void 0 : s.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (S = h, w = m === "end" ? "top" : "bottom");
      const _ = x - f.top - f.bottom, M = b - f.left - f.right, N = Rc(x - f[w], _), D = Rc(b - f[S], M), j = !t.middlewareData.shift;
      let O = N, L = D;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (L = M), (r = t.middlewareData.shift) != null && r.enabled.y && (O = _), j && !m) {
        const B = ho(f.left, 0), G = ho(f.right, 0), Y = ho(f.top, 0), he = ho(f.bottom, 0);
        g ? L = b - 2 * (B !== 0 || G !== 0 ? B + G : ho(f.left, f.right)) : O = x - 2 * (Y !== 0 || he !== 0 ? Y + he : ho(f.top, f.bottom));
      }
      await c({
        ...t,
        availableWidth: L,
        availableHeight: O
      });
      const U = await s.getDimensions(a.floating);
      return b !== U.width || x !== U.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function pw() {
  return typeof window < "u";
}
function $h(e) {
  return Q6(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function yo(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function aa(e) {
  var t;
  return (t = (Q6(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Q6(e) {
  return pw() ? e instanceof Node || e instanceof yo(e).Node : !1;
}
function ys(e) {
  return pw() ? e instanceof Element || e instanceof yo(e).Element : !1;
}
function na(e) {
  return pw() ? e instanceof HTMLElement || e instanceof yo(e).HTMLElement : !1;
}
function AI(e) {
  return !pw() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof yo(e).ShadowRoot;
}
const Zie = /* @__PURE__ */ new Set(["inline", "contents"]);
function Qg(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = vs(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !Zie.has(i);
}
const Yie = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Xie(e) {
  return Yie.has($h(e));
}
const Jie = [":popover-open", ":modal"];
function mw(e) {
  return Jie.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const Qie = ["transform", "translate", "scale", "rotate", "perspective"], eoe = ["transform", "translate", "scale", "rotate", "perspective", "filter"], toe = ["paint", "layout", "strict", "content"];
function rM(e) {
  const t = iM(), n = ys(e) ? vs(e) : e;
  return Qie.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || eoe.some((r) => (n.willChange || "").includes(r)) || toe.some((r) => (n.contain || "").includes(r));
}
function noe(e) {
  let t = Oc(e);
  for (; na(t) && !gh(t); ) {
    if (rM(t))
      return t;
    if (mw(t))
      return null;
    t = Oc(t);
  }
  return null;
}
function iM() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const roe = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function gh(e) {
  return roe.has($h(e));
}
function vs(e) {
  return yo(e).getComputedStyle(e);
}
function gw(e) {
  return ys(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Oc(e) {
  if ($h(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    AI(e) && e.host || // Fallback.
    aa(e)
  );
  return AI(t) ? t.host : t;
}
function e$(e) {
  const t = Oc(e);
  return gh(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : na(t) && Qg(t) ? t : e$(t);
}
function dg(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = e$(e), o = i === ((r = e.ownerDocument) == null ? void 0 : r.body), s = yo(i);
  if (o) {
    const a = w_(s);
    return t.concat(s, s.visualViewport || [], Qg(i) ? i : [], a && n ? dg(a) : []);
  }
  return t.concat(i, dg(i, [], n));
}
function w_(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function t$(e) {
  const t = vs(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = na(e), o = i ? e.offsetWidth : n, s = i ? e.offsetHeight : r, a = Sb(n) !== o || Sb(r) !== s;
  return a && (n = o, r = s), {
    width: n,
    height: r,
    $: a
  };
}
function oM(e) {
  return ys(e) ? e : e.contextElement;
}
function rh(e) {
  const t = oM(e);
  if (!na(t))
    return Qs(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = t$(t);
  let s = (o ? Sb(n.width) : n.width) / r, a = (o ? Sb(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const ioe = /* @__PURE__ */ Qs(0);
function n$(e) {
  const t = yo(e);
  return !iM() || !t.visualViewport ? ioe : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function ooe(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== yo(e) ? !1 : t;
}
function ed(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), o = oM(e);
  let s = Qs(1);
  t && (r ? ys(r) && (s = rh(r)) : s = rh(e));
  const a = ooe(o, n, r) ? n$(o) : Qs(0);
  let c = (i.left + a.x) / s.x, u = (i.top + a.y) / s.y, f = i.width / s.x, h = i.height / s.y;
  if (o) {
    const m = yo(o), g = r && ys(r) ? yo(r) : r;
    let b = m, x = w_(b);
    for (; x && r && g !== b; ) {
      const w = rh(x), S = x.getBoundingClientRect(), _ = vs(x), M = S.left + (x.clientLeft + parseFloat(_.paddingLeft)) * w.x, N = S.top + (x.clientTop + parseFloat(_.paddingTop)) * w.y;
      c *= w.x, u *= w.y, f *= w.x, h *= w.y, c += M, u += N, b = yo(x), x = w_(b);
    }
  }
  return Cb({
    width: f,
    height: h,
    x: c,
    y: u
  });
}
function yw(e, t) {
  const n = gw(e).scrollLeft;
  return t ? t.left + n : ed(aa(e)).left + n;
}
function r$(e, t) {
  const n = e.getBoundingClientRect(), r = n.left + t.scrollLeft - yw(e, n), i = n.top + t.scrollTop;
  return {
    x: r,
    y: i
  };
}
function soe(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const o = i === "fixed", s = aa(r), a = t ? mw(t.floating) : !1;
  if (r === s || a && o)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = Qs(1);
  const f = Qs(0), h = na(r);
  if ((h || !h && !o) && (($h(r) !== "body" || Qg(s)) && (c = gw(r)), na(r))) {
    const g = ed(r);
    u = rh(r), f.x = g.x + r.clientLeft, f.y = g.y + r.clientTop;
  }
  const m = s && !h && !o ? r$(s, c) : Qs(0);
  return {
    width: n.width * u.x,
    height: n.height * u.y,
    x: n.x * u.x - c.scrollLeft * u.x + f.x + m.x,
    y: n.y * u.y - c.scrollTop * u.y + f.y + m.y
  };
}
function aoe(e) {
  return Array.from(e.getClientRects());
}
function loe(e) {
  const t = aa(e), n = gw(e), r = e.ownerDocument.body, i = ho(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = ho(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + yw(e);
  const a = -n.scrollTop;
  return vs(r).direction === "rtl" && (s += ho(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: o,
    x: s,
    y: a
  };
}
const MI = 25;
function coe(e, t) {
  const n = yo(e), r = aa(e), i = n.visualViewport;
  let o = r.clientWidth, s = r.clientHeight, a = 0, c = 0;
  if (i) {
    o = i.width, s = i.height;
    const f = iM();
    (!f || f && t === "fixed") && (a = i.offsetLeft, c = i.offsetTop);
  }
  const u = yw(r);
  if (u <= 0) {
    const f = r.ownerDocument, h = f.body, m = getComputedStyle(h), g = f.compatMode === "CSS1Compat" && parseFloat(m.marginLeft) + parseFloat(m.marginRight) || 0, b = Math.abs(r.clientWidth - h.clientWidth - g);
    b <= MI && (o -= b);
  } else u <= MI && (o += u);
  return {
    width: o,
    height: s,
    x: a,
    y: c
  };
}
const uoe = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function doe(e, t) {
  const n = ed(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = na(e) ? rh(e) : Qs(1), s = e.clientWidth * o.x, a = e.clientHeight * o.y, c = i * o.x, u = r * o.y;
  return {
    width: s,
    height: a,
    x: c,
    y: u
  };
}
function NI(e, t, n) {
  let r;
  if (t === "viewport")
    r = coe(e, n);
  else if (t === "document")
    r = loe(aa(e));
  else if (ys(t))
    r = doe(t, n);
  else {
    const i = n$(e);
    r = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return Cb(r);
}
function i$(e, t) {
  const n = Oc(e);
  return n === t || !ys(n) || gh(n) ? !1 : vs(n).position === "fixed" || i$(n, t);
}
function foe(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = dg(e, [], !1).filter((a) => ys(a) && $h(a) !== "body"), i = null;
  const o = vs(e).position === "fixed";
  let s = o ? Oc(e) : e;
  for (; ys(s) && !gh(s); ) {
    const a = vs(s), c = rM(s);
    !c && a.position === "fixed" && (i = null), (o ? !c && !i : !c && a.position === "static" && !!i && uoe.has(i.position) || Qg(s) && !c && i$(e, s)) ? r = r.filter((f) => f !== s) : i = a, s = Oc(s);
  }
  return t.set(e, r), r;
}
function hoe(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const s = [...n === "clippingAncestors" ? mw(t) ? [] : foe(t, this._c) : [].concat(n), r], a = s[0], c = s.reduce((u, f) => {
    const h = NI(t, f, i);
    return u.top = ho(h.top, u.top), u.right = Rc(h.right, u.right), u.bottom = Rc(h.bottom, u.bottom), u.left = ho(h.left, u.left), u;
  }, NI(t, a, i));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function poe(e) {
  const {
    width: t,
    height: n
  } = t$(e);
  return {
    width: t,
    height: n
  };
}
function moe(e, t, n) {
  const r = na(t), i = aa(t), o = n === "fixed", s = ed(e, !0, o, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = Qs(0);
  function u() {
    c.x = yw(i);
  }
  if (r || !r && !o)
    if (($h(t) !== "body" || Qg(i)) && (a = gw(t)), r) {
      const g = ed(t, !0, o, t);
      c.x = g.x + t.clientLeft, c.y = g.y + t.clientTop;
    } else i && u();
  o && !r && i && u();
  const f = i && !r && !o ? r$(i, a) : Qs(0), h = s.left + a.scrollLeft - c.x - f.x, m = s.top + a.scrollTop - c.y - f.y;
  return {
    x: h,
    y: m,
    width: s.width,
    height: s.height
  };
}
function Kk(e) {
  return vs(e).position === "static";
}
function RI(e, t) {
  if (!na(e) || vs(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return aa(e) === n && (n = n.ownerDocument.body), n;
}
function o$(e, t) {
  const n = yo(e);
  if (mw(e))
    return n;
  if (!na(e)) {
    let i = Oc(e);
    for (; i && !gh(i); ) {
      if (ys(i) && !Kk(i))
        return i;
      i = Oc(i);
    }
    return n;
  }
  let r = RI(e, t);
  for (; r && Xie(r) && Kk(r); )
    r = RI(r, t);
  return r && gh(r) && Kk(r) && !rM(r) ? n : r || noe(e) || n;
}
const goe = async function(e) {
  const t = this.getOffsetParent || o$, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: moe(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function yoe(e) {
  return vs(e).direction === "rtl";
}
const voe = {
  convertOffsetParentRelativeRectToViewportRelativeRect: soe,
  getDocumentElement: aa,
  getClippingRect: hoe,
  getOffsetParent: o$,
  getElementRects: goe,
  getClientRects: aoe,
  getDimensions: poe,
  getScale: rh,
  isElement: ys,
  isRTL: yoe
};
function s$(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function boe(e, t) {
  let n = null, r;
  const i = aa(e);
  function o() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
  }
  function s(a, c) {
    a === void 0 && (a = !1), c === void 0 && (c = 1), o();
    const u = e.getBoundingClientRect(), {
      left: f,
      top: h,
      width: m,
      height: g
    } = u;
    if (a || t(), !m || !g)
      return;
    const b = Fv(h), x = Fv(i.clientWidth - (f + m)), w = Fv(i.clientHeight - (h + g)), S = Fv(f), M = {
      rootMargin: -b + "px " + -x + "px " + -w + "px " + -S + "px",
      threshold: ho(0, Rc(1, c)) || 1
    };
    let N = !0;
    function D(j) {
      const O = j[0].intersectionRatio;
      if (O !== c) {
        if (!N)
          return s();
        O ? s(!1, O) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      O === 1 && !s$(u, e.getBoundingClientRect()) && s(), N = !1;
    }
    try {
      n = new IntersectionObserver(D, {
        ...M,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(D, M);
    }
    n.observe(e);
  }
  return s(!0), o;
}
function xoe(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, u = oM(e), f = i || o ? [...u ? dg(u) : [], ...dg(t)] : [];
  f.forEach((S) => {
    i && S.addEventListener("scroll", n, {
      passive: !0
    }), o && S.addEventListener("resize", n);
  });
  const h = u && a ? boe(u, n) : null;
  let m = -1, g = null;
  s && (g = new ResizeObserver((S) => {
    let [_] = S;
    _ && _.target === u && g && (g.unobserve(t), cancelAnimationFrame(m), m = requestAnimationFrame(() => {
      var M;
      (M = g) == null || M.observe(t);
    })), n();
  }), u && !c && g.observe(u), g.observe(t));
  let b, x = c ? ed(e) : null;
  c && w();
  function w() {
    const S = ed(e);
    x && !s$(x, S) && n(), x = S, b = requestAnimationFrame(w);
  }
  return n(), () => {
    var S;
    f.forEach((_) => {
      i && _.removeEventListener("scroll", n), o && _.removeEventListener("resize", n);
    }), h?.(), (S = g) == null || S.disconnect(), g = null, c && cancelAnimationFrame(b);
  };
}
const woe = Wie, Soe = qie, koe = Fie, Coe = Kie, Eoe = Vie, OI = Uie, _oe = Gie, Toe = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: voe,
    ...n
  }, o = {
    ...i.platform,
    _c: r
  };
  return $ie(e, t, {
    ...i,
    platform: o
  });
};
var Aoe = typeof document < "u", Moe = function() {
}, j0 = Aoe ? C.useLayoutEffect : Moe;
function Eb(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Eb(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && e.$$typeof) && !Eb(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function a$(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function PI(e, t) {
  const n = a$(e);
  return Math.round(t * n) / n;
}
function Zk(e) {
  const t = C.useRef(e);
  return j0(() => {
    t.current = e;
  }), t;
}
function Noe(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: o,
      floating: s
    } = {},
    transform: a = !0,
    whileElementsMounted: c,
    open: u
  } = e, [f, h] = C.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [m, g] = C.useState(r);
  Eb(m, r) || g(r);
  const [b, x] = C.useState(null), [w, S] = C.useState(null), _ = C.useCallback((X) => {
    X !== j.current && (j.current = X, x(X));
  }, []), M = C.useCallback((X) => {
    X !== O.current && (O.current = X, S(X));
  }, []), N = o || b, D = s || w, j = C.useRef(null), O = C.useRef(null), L = C.useRef(f), U = c != null, B = Zk(c), G = Zk(i), Y = Zk(u), he = C.useCallback(() => {
    if (!j.current || !O.current)
      return;
    const X = {
      placement: t,
      strategy: n,
      middleware: m
    };
    G.current && (X.platform = G.current), Toe(j.current, O.current, X).then((Se) => {
      const W = {
        ...Se,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: Y.current !== !1
      };
      ie.current && !Eb(L.current, W) && (L.current = W, sl.flushSync(() => {
        h(W);
      }));
    });
  }, [m, t, n, G, Y]);
  j0(() => {
    u === !1 && L.current.isPositioned && (L.current.isPositioned = !1, h((X) => ({
      ...X,
      isPositioned: !1
    })));
  }, [u]);
  const ie = C.useRef(!1);
  j0(() => (ie.current = !0, () => {
    ie.current = !1;
  }), []), j0(() => {
    if (N && (j.current = N), D && (O.current = D), N && D) {
      if (B.current)
        return B.current(N, D, he);
      he();
    }
  }, [N, D, he, B, U]);
  const ne = C.useMemo(() => ({
    reference: j,
    floating: O,
    setReference: _,
    setFloating: M
  }), [_, M]), H = C.useMemo(() => ({
    reference: N,
    floating: D
  }), [N, D]), Q = C.useMemo(() => {
    const X = {
      position: n,
      left: 0,
      top: 0
    };
    if (!H.floating)
      return X;
    const Se = PI(H.floating, f.x), W = PI(H.floating, f.y);
    return a ? {
      ...X,
      transform: "translate(" + Se + "px, " + W + "px)",
      ...a$(H.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: Se,
      top: W
    };
  }, [n, a, H.floating, f.x, f.y]);
  return C.useMemo(() => ({
    ...f,
    update: he,
    refs: ne,
    elements: H,
    floatingStyles: Q
  }), [f, he, ne, H, Q]);
}
const Roe = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: i
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? OI({
        element: r.current,
        padding: i
      }).fn(n) : {} : r ? OI({
        element: r,
        padding: i
      }).fn(n) : {};
    }
  };
}, Ooe = (e, t) => ({
  ...woe(e),
  options: [e, t]
}), Poe = (e, t) => ({
  ...Soe(e),
  options: [e, t]
}), Doe = (e, t) => ({
  ..._oe(e),
  options: [e, t]
}), Ioe = (e, t) => ({
  ...koe(e),
  options: [e, t]
}), joe = (e, t) => ({
  ...Coe(e),
  options: [e, t]
}), zoe = (e, t) => ({
  ...Eoe(e),
  options: [e, t]
}), Loe = (e, t) => ({
  ...Roe(e),
  options: [e, t]
});
var Boe = "Arrow", l$ = C.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: i = 5, ...o } = e;
  return /* @__PURE__ */ v.jsx(
    _t.svg,
    {
      ...o,
      ref: t,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ v.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
l$.displayName = Boe;
var $oe = l$;
function sM(e) {
  const [t, n] = C.useState(void 0);
  return _r(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const o = i[0];
        let s, a;
        if ("borderBoxSize" in o) {
          const c = o.borderBoxSize, u = Array.isArray(c) ? c[0] : c;
          s = u.inlineSize, a = u.blockSize;
        } else
          s = e.offsetWidth, a = e.offsetHeight;
        n({ width: s, height: a });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var aM = "Popper", [c$, Uh] = bs(aM), [Uoe, u$] = c$(aM), d$ = (e) => {
  const { __scopePopper: t, children: n } = e, [r, i] = C.useState(null);
  return /* @__PURE__ */ v.jsx(Uoe, { scope: t, anchor: r, onAnchorChange: i, children: n });
};
d$.displayName = aM;
var f$ = "PopperAnchor", h$ = C.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...i } = e, o = u$(f$, n), s = C.useRef(null), a = Ht(t, s), c = C.useRef(null);
    return C.useEffect(() => {
      const u = c.current;
      c.current = r?.current || s.current, u !== c.current && o.onAnchorChange(c.current);
    }), r ? null : /* @__PURE__ */ v.jsx(_t.div, { ...i, ref: a });
  }
);
h$.displayName = f$;
var lM = "PopperContent", [Foe, Voe] = c$(lM), p$ = C.forwardRef(
  (e, t) => {
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: i = 0,
      align: o = "center",
      alignOffset: s = 0,
      arrowPadding: a = 0,
      avoidCollisions: c = !0,
      collisionBoundary: u = [],
      collisionPadding: f = 0,
      sticky: h = "partial",
      hideWhenDetached: m = !1,
      updatePositionStrategy: g = "optimized",
      onPlaced: b,
      ...x
    } = e, w = u$(lM, n), [S, _] = C.useState(null), M = Ht(t, (J) => _(J)), [N, D] = C.useState(null), j = sM(N), O = j?.width ?? 0, L = j?.height ?? 0, U = r + (o !== "center" ? "-" + o : ""), B = typeof f == "number" ? f : { top: 0, right: 0, bottom: 0, left: 0, ...f }, G = Array.isArray(u) ? u : [u], Y = G.length > 0, he = {
      padding: B,
      boundary: G.filter(Woe),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: Y
    }, { refs: ie, floatingStyles: ne, placement: H, isPositioned: Q, middlewareData: X } = Noe({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: U,
      whileElementsMounted: (...J) => xoe(...J, {
        animationFrame: g === "always"
      }),
      elements: {
        reference: w.anchor
      },
      middleware: [
        Ooe({ mainAxis: i + L, alignmentAxis: s }),
        c && Poe({
          mainAxis: !0,
          crossAxis: !1,
          limiter: h === "partial" ? Doe() : void 0,
          ...he
        }),
        c && Ioe({ ...he }),
        joe({
          ...he,
          apply: ({ elements: J, rects: xe, availableWidth: be, availableHeight: Ae }) => {
            const { width: nt, height: Ge } = xe.reference, rt = J.floating.style;
            rt.setProperty("--radix-popper-available-width", `${be}px`), rt.setProperty("--radix-popper-available-height", `${Ae}px`), rt.setProperty("--radix-popper-anchor-width", `${nt}px`), rt.setProperty("--radix-popper-anchor-height", `${Ge}px`);
          }
        }),
        N && Loe({ element: N, padding: a }),
        qoe({ arrowWidth: O, arrowHeight: L }),
        m && zoe({ strategy: "referenceHidden", ...he })
      ]
    }), [Se, W] = y$(H), Z = Ir(b);
    _r(() => {
      Q && Z?.();
    }, [Q, Z]);
    const pe = X.arrow?.x, F = X.arrow?.y, ee = X.arrow?.centerOffset !== 0, [ge, re] = C.useState();
    return _r(() => {
      S && re(window.getComputedStyle(S).zIndex);
    }, [S]), /* @__PURE__ */ v.jsx(
      "div",
      {
        ref: ie.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...ne,
          transform: Q ? ne.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: ge,
          "--radix-popper-transform-origin": [
            X.transformOrigin?.x,
            X.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...X.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ v.jsx(
          Foe,
          {
            scope: n,
            placedSide: Se,
            onArrowChange: D,
            arrowX: pe,
            arrowY: F,
            shouldHideArrow: ee,
            children: /* @__PURE__ */ v.jsx(
              _t.div,
              {
                "data-side": Se,
                "data-align": W,
                ...x,
                ref: M,
                style: {
                  ...x.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: Q ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
p$.displayName = lM;
var m$ = "PopperArrow", Hoe = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, g$ = C.forwardRef(function(t, n) {
  const { __scopePopper: r, ...i } = t, o = Voe(m$, r), s = Hoe[o.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ v.jsx(
      "span",
      {
        ref: o.onArrowChange,
        style: {
          position: "absolute",
          left: o.arrowX,
          top: o.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[o.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[o.placedSide],
          visibility: o.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ v.jsx(
          $oe,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
g$.displayName = m$;
function Woe(e) {
  return e !== null;
}
var qoe = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    const { placement: n, rects: r, middlewareData: i } = t, s = i.arrow?.centerOffset !== 0, a = s ? 0 : e.arrowWidth, c = s ? 0 : e.arrowHeight, [u, f] = y$(n), h = { start: "0%", center: "50%", end: "100%" }[f], m = (i.arrow?.x ?? 0) + a / 2, g = (i.arrow?.y ?? 0) + c / 2;
    let b = "", x = "";
    return u === "bottom" ? (b = s ? h : `${m}px`, x = `${-c}px`) : u === "top" ? (b = s ? h : `${m}px`, x = `${r.floating.height + c}px`) : u === "right" ? (b = `${-c}px`, x = s ? h : `${g}px`) : u === "left" && (b = `${r.floating.width + c}px`, x = s ? h : `${g}px`), { data: { x: b, y: x } };
  }
});
function y$(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var vw = d$, cM = h$, uM = p$, dM = g$, Goe = "Portal", ey = C.forwardRef((e, t) => {
  const { container: n, ...r } = e, [i, o] = C.useState(!1);
  _r(() => o(!0), []);
  const s = n || i && globalThis?.document?.body;
  return s ? C4.createPortal(/* @__PURE__ */ v.jsx(_t.div, { ...r, ref: t }), s) : null;
});
ey.displayName = Goe;
var Koe = nw[" useInsertionEffect ".trim().toString()] || _r;
function il({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: r
}) {
  const [i, o, s] = Zoe({
    defaultProp: t,
    onChange: n
  }), a = e !== void 0, c = a ? e : i;
  {
    const f = C.useRef(e !== void 0);
    C.useEffect(() => {
      const h = f.current;
      h !== a && console.warn(
        `${r} is changing from ${h ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), f.current = a;
    }, [a, r]);
  }
  const u = C.useCallback(
    (f) => {
      if (a) {
        const h = Yoe(f) ? f(e) : f;
        h !== e && s.current?.(h);
      } else
        o(f);
    },
    [a, e, o, s]
  );
  return [c, u];
}
function Zoe({
  defaultProp: e,
  onChange: t
}) {
  const [n, r] = C.useState(e), i = C.useRef(n), o = C.useRef(t);
  return Koe(() => {
    o.current = t;
  }, [t]), C.useEffect(() => {
    i.current !== n && (o.current?.(n), i.current = n);
  }, [n, i]), [n, r, o];
}
function Yoe(e) {
  return typeof e == "function";
}
var v$ = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), Xoe = "VisuallyHidden", b$ = C.forwardRef(
  (e, t) => /* @__PURE__ */ v.jsx(
    _t.span,
    {
      ...e,
      ref: t,
      style: { ...v$, ...e.style }
    }
  )
);
b$.displayName = Xoe;
var Joe = b$, [bw] = bs("Tooltip", [
  Uh
]), xw = Uh(), x$ = "TooltipProvider", Qoe = 700, S_ = "tooltip.open", [ese, fM] = bw(x$), w$ = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: n = Qoe,
    skipDelayDuration: r = 300,
    disableHoverableContent: i = !1,
    children: o
  } = e, s = C.useRef(!0), a = C.useRef(!1), c = C.useRef(0);
  return C.useEffect(() => {
    const u = c.current;
    return () => window.clearTimeout(u);
  }, []), /* @__PURE__ */ v.jsx(
    ese,
    {
      scope: t,
      isOpenDelayedRef: s,
      delayDuration: n,
      onOpen: C.useCallback(() => {
        window.clearTimeout(c.current), s.current = !1;
      }, []),
      onClose: C.useCallback(() => {
        window.clearTimeout(c.current), c.current = window.setTimeout(
          () => s.current = !0,
          r
        );
      }, [r]),
      isPointerInTransitRef: a,
      onPointerInTransitChange: C.useCallback((u) => {
        a.current = u;
      }, []),
      disableHoverableContent: i,
      children: o
    }
  );
};
w$.displayName = x$;
var fg = "Tooltip", [tse, ty] = bw(fg), S$ = (e) => {
  const {
    __scopeTooltip: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    disableHoverableContent: s,
    delayDuration: a
  } = e, c = fM(fg, e.__scopeTooltip), u = xw(t), [f, h] = C.useState(null), m = Wo(), g = C.useRef(0), b = s ?? c.disableHoverableContent, x = a ?? c.delayDuration, w = C.useRef(!1), [S, _] = il({
    prop: r,
    defaultProp: i ?? !1,
    onChange: (O) => {
      O ? (c.onOpen(), document.dispatchEvent(new CustomEvent(S_))) : c.onClose(), o?.(O);
    },
    caller: fg
  }), M = C.useMemo(() => S ? w.current ? "delayed-open" : "instant-open" : "closed", [S]), N = C.useCallback(() => {
    window.clearTimeout(g.current), g.current = 0, w.current = !1, _(!0);
  }, [_]), D = C.useCallback(() => {
    window.clearTimeout(g.current), g.current = 0, _(!1);
  }, [_]), j = C.useCallback(() => {
    window.clearTimeout(g.current), g.current = window.setTimeout(() => {
      w.current = !0, _(!0), g.current = 0;
    }, x);
  }, [x, _]);
  return C.useEffect(() => () => {
    g.current && (window.clearTimeout(g.current), g.current = 0);
  }, []), /* @__PURE__ */ v.jsx(vw, { ...u, children: /* @__PURE__ */ v.jsx(
    tse,
    {
      scope: t,
      contentId: m,
      open: S,
      stateAttribute: M,
      trigger: f,
      onTriggerChange: h,
      onTriggerEnter: C.useCallback(() => {
        c.isOpenDelayedRef.current ? j() : N();
      }, [c.isOpenDelayedRef, j, N]),
      onTriggerLeave: C.useCallback(() => {
        b ? D() : (window.clearTimeout(g.current), g.current = 0);
      }, [D, b]),
      onOpen: N,
      onClose: D,
      disableHoverableContent: b,
      children: n
    }
  ) });
};
S$.displayName = fg;
var k_ = "TooltipTrigger", hM = C.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = ty(k_, n), o = fM(k_, n), s = xw(n), a = C.useRef(null), c = Ht(t, a, i.onTriggerChange), u = C.useRef(!1), f = C.useRef(!1), h = C.useCallback(() => u.current = !1, []);
    return C.useEffect(() => () => document.removeEventListener("pointerup", h), [h]), /* @__PURE__ */ v.jsx(cM, { asChild: !0, ...s, children: /* @__PURE__ */ v.jsx(
      _t.button,
      {
        "aria-describedby": i.open ? i.contentId : void 0,
        "data-state": i.stateAttribute,
        ...r,
        ref: c,
        onPointerMove: Ye(e.onPointerMove, (m) => {
          m.pointerType !== "touch" && !f.current && !o.isPointerInTransitRef.current && (i.onTriggerEnter(), f.current = !0);
        }),
        onPointerLeave: Ye(e.onPointerLeave, () => {
          i.onTriggerLeave(), f.current = !1;
        }),
        onPointerDown: Ye(e.onPointerDown, () => {
          i.open && i.onClose(), u.current = !0, document.addEventListener("pointerup", h, { once: !0 });
        }),
        onFocus: Ye(e.onFocus, () => {
          u.current || i.onOpen();
        }),
        onBlur: Ye(e.onBlur, i.onClose),
        onClick: Ye(e.onClick, i.onClose)
      }
    ) });
  }
);
hM.displayName = k_;
var pM = "TooltipPortal", [nse, rse] = bw(pM, {
  forceMount: void 0
}), k$ = (e) => {
  const { __scopeTooltip: t, forceMount: n, children: r, container: i } = e, o = ty(pM, t);
  return /* @__PURE__ */ v.jsx(nse, { scope: t, forceMount: n, children: /* @__PURE__ */ v.jsx(ji, { present: n || o.open, children: /* @__PURE__ */ v.jsx(ey, { asChild: !0, container: i, children: r }) }) });
};
k$.displayName = pM;
var yh = "TooltipContent", ww = C.forwardRef(
  (e, t) => {
    const n = rse(yh, e.__scopeTooltip), { forceMount: r = n.forceMount, side: i = "top", ...o } = e, s = ty(yh, e.__scopeTooltip);
    return /* @__PURE__ */ v.jsx(ji, { present: r || s.open, children: s.disableHoverableContent ? /* @__PURE__ */ v.jsx(C$, { side: i, ...o, ref: t }) : /* @__PURE__ */ v.jsx(ise, { side: i, ...o, ref: t }) });
  }
), ise = C.forwardRef((e, t) => {
  const n = ty(yh, e.__scopeTooltip), r = fM(yh, e.__scopeTooltip), i = C.useRef(null), o = Ht(t, i), [s, a] = C.useState(null), { trigger: c, onClose: u } = n, f = i.current, { onPointerInTransitChange: h } = r, m = C.useCallback(() => {
    a(null), h(!1);
  }, [h]), g = C.useCallback(
    (b, x) => {
      const w = b.currentTarget, S = { x: b.clientX, y: b.clientY }, _ = lse(S, w.getBoundingClientRect()), M = cse(S, _), N = use(x.getBoundingClientRect()), D = fse([...M, ...N]);
      a(D), h(!0);
    },
    [h]
  );
  return C.useEffect(() => () => m(), [m]), C.useEffect(() => {
    if (c && f) {
      const b = (w) => g(w, f), x = (w) => g(w, c);
      return c.addEventListener("pointerleave", b), f.addEventListener("pointerleave", x), () => {
        c.removeEventListener("pointerleave", b), f.removeEventListener("pointerleave", x);
      };
    }
  }, [c, f, g, m]), C.useEffect(() => {
    if (s) {
      const b = (x) => {
        const w = x.target, S = { x: x.clientX, y: x.clientY }, _ = c?.contains(w) || f?.contains(w), M = !dse(S, s);
        _ ? m() : M && (m(), u());
      };
      return document.addEventListener("pointermove", b), () => document.removeEventListener("pointermove", b);
    }
  }, [c, f, s, u, m]), /* @__PURE__ */ v.jsx(C$, { ...e, ref: o });
}), [ose, sse] = bw(fg, { isInside: !1 }), ase = /* @__PURE__ */ FX("TooltipContent"), C$ = C.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": i,
      onEscapeKeyDown: o,
      onPointerDownOutside: s,
      ...a
    } = e, c = ty(yh, n), u = xw(n), { onClose: f } = c;
    return C.useEffect(() => (document.addEventListener(S_, f), () => document.removeEventListener(S_, f)), [f]), C.useEffect(() => {
      if (c.trigger) {
        const h = (m) => {
          m.target?.contains(c.trigger) && f();
        };
        return window.addEventListener("scroll", h, { capture: !0 }), () => window.removeEventListener("scroll", h, { capture: !0 });
      }
    }, [c.trigger, f]), /* @__PURE__ */ v.jsx(
      Jg,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: o,
        onPointerDownOutside: s,
        onFocusOutside: (h) => h.preventDefault(),
        onDismiss: f,
        children: /* @__PURE__ */ v.jsxs(
          uM,
          {
            "data-state": c.stateAttribute,
            ...u,
            ...a,
            ref: t,
            style: {
              ...a.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ v.jsx(ase, { children: r }),
              /* @__PURE__ */ v.jsx(ose, { scope: n, isInside: !0, children: /* @__PURE__ */ v.jsx(Joe, { id: c.contentId, role: "tooltip", children: i || r }) })
            ]
          }
        )
      }
    );
  }
);
ww.displayName = yh;
var E$ = "TooltipArrow", _$ = C.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = xw(n);
    return sse(
      E$,
      n
    ).isInside ? null : /* @__PURE__ */ v.jsx(dM, { ...i, ...r, ref: t });
  }
);
_$.displayName = E$;
function lse(e, t) {
  const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), i = Math.abs(t.right - e.x), o = Math.abs(t.left - e.x);
  switch (Math.min(n, r, i, o)) {
    case o:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function cse(e, t, n = 5) {
  const r = [];
  switch (t) {
    case "top":
      r.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      r.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return r;
}
function use(e) {
  const { top: t, right: n, bottom: r, left: i } = e;
  return [
    { x: i, y: t },
    { x: n, y: t },
    { x: n, y: r },
    { x: i, y: r }
  ];
}
function dse(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const a = t[o], c = t[s], u = a.x, f = a.y, h = c.x, m = c.y;
    f > r != m > r && n < (h - u) * (r - f) / (m - f) + u && (i = !i);
  }
  return i;
}
function fse(e) {
  const t = e.slice();
  return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), hse(t);
}
function hse(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    for (; t.length >= 2; ) {
      const o = t[t.length - 1], s = t[t.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) t.pop();
      else break;
    }
    t.push(i);
  }
  t.pop();
  const n = [];
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1], s = n[n.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var pse = w$, mse = S$, gse = hM, yse = k$, vse = ww, bse = _$;
function Fh({
  delayDuration: e = 0,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    pse,
    {
      "data-slot": "tooltip-provider",
      delayDuration: e,
      ...t
    }
  );
}
function Yi({ ...e }) {
  return /* @__PURE__ */ v.jsx(Fh, { children: /* @__PURE__ */ v.jsx(mse, { "data-slot": "tooltip", ...e }) });
}
function go({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(gse, { "data-slot": "tooltip-trigger", ...e });
}
function Vo({
  className: e,
  sideOffset: t = 0,
  hasArrow: n = !1,
  children: r,
  ...i
}) {
  return /* @__PURE__ */ v.jsx(yse, { children: /* @__PURE__ */ v.jsxs(
    vse,
    {
      "data-slot": "tooltip-content",
      sideOffset: t,
      className: lt(
        "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
        e
      ),
      ...i,
      children: [
        r,
        /* @__PURE__ */ v.jsx(
          bse,
          {
            className: "bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] opacity-0 bg-transparent"
          }
        )
      ]
    }
  ) });
}
const xse = QA(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function Vh({
  className: e,
  variant: t,
  asChild: n = !1,
  ...r
}) {
  const i = n ? K6 : "span";
  return /* @__PURE__ */ v.jsx(
    i,
    {
      "data-slot": "badge",
      className: lt(xse({ variant: t }), e),
      ...r
    }
  );
}
var Yk = "focusScope.autoFocusOnMount", Xk = "focusScope.autoFocusOnUnmount", DI = { bubbles: !1, cancelable: !0 }, wse = "FocusScope", Sw = C.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: o,
    ...s
  } = e, [a, c] = C.useState(null), u = Ir(i), f = Ir(o), h = C.useRef(null), m = Ht(t, (x) => c(x)), g = C.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  C.useEffect(() => {
    if (r) {
      let x = function(M) {
        if (g.paused || !a) return;
        const N = M.target;
        a.contains(N) ? h.current = N : Ql(h.current, { select: !0 });
      }, w = function(M) {
        if (g.paused || !a) return;
        const N = M.relatedTarget;
        N !== null && (a.contains(N) || Ql(h.current, { select: !0 }));
      }, S = function(M) {
        if (document.activeElement === document.body)
          for (const D of M)
            D.removedNodes.length > 0 && Ql(a);
      };
      document.addEventListener("focusin", x), document.addEventListener("focusout", w);
      const _ = new MutationObserver(S);
      return a && _.observe(a, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", x), document.removeEventListener("focusout", w), _.disconnect();
      };
    }
  }, [r, a, g.paused]), C.useEffect(() => {
    if (a) {
      jI.add(g);
      const x = document.activeElement;
      if (!a.contains(x)) {
        const S = new CustomEvent(Yk, DI);
        a.addEventListener(Yk, u), a.dispatchEvent(S), S.defaultPrevented || (Sse(Tse(T$(a)), { select: !0 }), document.activeElement === x && Ql(a));
      }
      return () => {
        a.removeEventListener(Yk, u), setTimeout(() => {
          const S = new CustomEvent(Xk, DI);
          a.addEventListener(Xk, f), a.dispatchEvent(S), S.defaultPrevented || Ql(x ?? document.body, { select: !0 }), a.removeEventListener(Xk, f), jI.remove(g);
        }, 0);
      };
    }
  }, [a, u, f, g]);
  const b = C.useCallback(
    (x) => {
      if (!n && !r || g.paused) return;
      const w = x.key === "Tab" && !x.altKey && !x.ctrlKey && !x.metaKey, S = document.activeElement;
      if (w && S) {
        const _ = x.currentTarget, [M, N] = kse(_);
        M && N ? !x.shiftKey && S === N ? (x.preventDefault(), n && Ql(M, { select: !0 })) : x.shiftKey && S === M && (x.preventDefault(), n && Ql(N, { select: !0 })) : S === _ && x.preventDefault();
      }
    },
    [n, r, g.paused]
  );
  return /* @__PURE__ */ v.jsx(_t.div, { tabIndex: -1, ...s, ref: m, onKeyDown: b });
});
Sw.displayName = wse;
function Sse(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Ql(r, { select: t }), document.activeElement !== n) return;
}
function kse(e) {
  const t = T$(e), n = II(t, e), r = II(t.reverse(), e);
  return [n, r];
}
function T$(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function II(e, t) {
  for (const n of e)
    if (!Cse(n, { upTo: t })) return n;
}
function Cse(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function Ese(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Ql(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && Ese(e) && t && e.select();
  }
}
var jI = _se();
function _se() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && n?.pause(), e = zI(e, t), e.unshift(t);
    },
    remove(t) {
      e = zI(e, t), e[0]?.resume();
    }
  };
}
function zI(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function Tse(e) {
  return e.filter((t) => t.tagName !== "A");
}
var Jk = 0;
function mM() {
  C.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? LI()), document.body.insertAdjacentElement("beforeend", e[1] ?? LI()), Jk++, () => {
      Jk === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), Jk--;
    };
  }, []);
}
function LI() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Gs = function() {
  return Gs = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, Gs.apply(this, arguments);
};
function A$(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function Ase(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, o; r < i; r++)
    (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]);
  return e.concat(o || Array.prototype.slice.call(t));
}
var z0 = "right-scroll-bar-position", L0 = "width-before-scroll-bar", Mse = "with-scroll-bars-hidden", Nse = "--removed-body-scroll-bar-size";
function Qk(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function Rse(e, t) {
  var n = C.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var Ose = typeof window < "u" ? C.useLayoutEffect : C.useEffect, BI = /* @__PURE__ */ new WeakMap();
function Pse(e, t) {
  var n = Rse(null, function(r) {
    return e.forEach(function(i) {
      return Qk(i, r);
    });
  });
  return Ose(function() {
    var r = BI.get(n);
    if (r) {
      var i = new Set(r), o = new Set(e), s = n.current;
      i.forEach(function(a) {
        o.has(a) || Qk(a, null);
      }), o.forEach(function(a) {
        i.has(a) || Qk(a, s);
      });
    }
    BI.set(n, e);
  }, [e]), n;
}
function Dse(e) {
  return e;
}
function Ise(e, t) {
  t === void 0 && (t = Dse);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(o) {
      var s = t(o, r);
      return n.push(s), function() {
        n = n.filter(function(a) {
          return a !== s;
        });
      };
    },
    assignSyncMedium: function(o) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(o);
      }
      n = {
        push: function(a) {
          return o(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(o) {
      r = !0;
      var s = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(o), s = n;
      }
      var c = function() {
        var f = s;
        s = [], f.forEach(o);
      }, u = function() {
        return Promise.resolve().then(c);
      };
      u(), n = {
        push: function(f) {
          s.push(f), u();
        },
        filter: function(f) {
          return s = s.filter(f), n;
        }
      };
    }
  };
  return i;
}
function jse(e) {
  e === void 0 && (e = {});
  var t = Ise(null);
  return t.options = Gs({ async: !0, ssr: !1 }, e), t;
}
var M$ = function(e) {
  var t = e.sideCar, n = A$(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return C.createElement(r, Gs({}, n));
};
M$.isSideCarExport = !0;
function zse(e, t) {
  return e.useMedium(t), M$;
}
var N$ = jse(), eC = function() {
}, kw = C.forwardRef(function(e, t) {
  var n = C.useRef(null), r = C.useState({
    onScrollCapture: eC,
    onWheelCapture: eC,
    onTouchMoveCapture: eC
  }), i = r[0], o = r[1], s = e.forwardProps, a = e.children, c = e.className, u = e.removeScrollBar, f = e.enabled, h = e.shards, m = e.sideCar, g = e.noRelative, b = e.noIsolation, x = e.inert, w = e.allowPinchZoom, S = e.as, _ = S === void 0 ? "div" : S, M = e.gapMode, N = A$(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), D = m, j = Pse([n, t]), O = Gs(Gs({}, N), i);
  return C.createElement(
    C.Fragment,
    null,
    f && C.createElement(D, { sideCar: N$, removeScrollBar: u, shards: h, noRelative: g, noIsolation: b, inert: x, setCallbacks: o, allowPinchZoom: !!w, lockRef: n, gapMode: M }),
    s ? C.cloneElement(C.Children.only(a), Gs(Gs({}, O), { ref: j })) : C.createElement(_, Gs({}, O, { className: c, ref: j }), a)
  );
});
kw.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
kw.classNames = {
  fullWidth: L0,
  zeroRight: z0
};
var Lse = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Bse() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = Lse();
  return t && e.setAttribute("nonce", t), e;
}
function $se(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function Use(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var Fse = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = Bse()) && ($se(t, n), Use(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, Vse = function() {
  var e = Fse();
  return function(t, n) {
    C.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, R$ = function() {
  var e = Vse(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, Hse = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, tC = function(e) {
  return parseInt(e || "", 10) || 0;
}, Wse = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [tC(n), tC(r), tC(i)];
}, qse = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return Hse;
  var t = Wse(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, Gse = R$(), ih = "data-scroll-locked", Kse = function(e, t, n, r) {
  var i = e.left, o = e.top, s = e.right, a = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(Mse, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(ih, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(z0, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(L0, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(z0, " .").concat(z0, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(L0, " .").concat(L0, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(ih, `] {
    `).concat(Nse, ": ").concat(a, `px;
  }
`);
}, $I = function() {
  var e = parseInt(document.body.getAttribute(ih) || "0", 10);
  return isFinite(e) ? e : 0;
}, Zse = function() {
  C.useEffect(function() {
    return document.body.setAttribute(ih, ($I() + 1).toString()), function() {
      var e = $I() - 1;
      e <= 0 ? document.body.removeAttribute(ih) : document.body.setAttribute(ih, e.toString());
    };
  }, []);
}, Yse = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r;
  Zse();
  var o = C.useMemo(function() {
    return qse(i);
  }, [i]);
  return C.createElement(Gse, { styles: Kse(o, !t, i, n ? "" : "!important") });
}, C_ = !1;
if (typeof window < "u")
  try {
    var Vv = Object.defineProperty({}, "passive", {
      get: function() {
        return C_ = !0, !0;
      }
    });
    window.addEventListener("test", Vv, Vv), window.removeEventListener("test", Vv, Vv);
  } catch {
    C_ = !1;
  }
var wf = C_ ? { passive: !1 } : !1, Xse = function(e) {
  return e.tagName === "TEXTAREA";
}, O$ = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Xse(e) && n[t] === "visible")
  );
}, Jse = function(e) {
  return O$(e, "overflowY");
}, Qse = function(e) {
  return O$(e, "overflowX");
}, UI = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = P$(e, r);
    if (i) {
      var o = D$(e, r), s = o[1], a = o[2];
      if (s > a)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, eae = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, tae = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, P$ = function(e, t) {
  return e === "v" ? Jse(t) : Qse(t);
}, D$ = function(e, t) {
  return e === "v" ? eae(t) : tae(t);
}, nae = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, rae = function(e, t, n, r, i) {
  var o = nae(e, window.getComputedStyle(t).direction), s = o * r, a = n.target, c = t.contains(a), u = !1, f = s > 0, h = 0, m = 0;
  do {
    if (!a)
      break;
    var g = D$(e, a), b = g[0], x = g[1], w = g[2], S = x - w - o * b;
    (b || S) && P$(e, a) && (h += S, m += b);
    var _ = a.parentNode;
    a = _ && _.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? _.host : _;
  } while (
    // portaled content
    !c && a !== document.body || // self content
    c && (t.contains(a) || t === a)
  );
  return (f && Math.abs(h) < 1 || !f && Math.abs(m) < 1) && (u = !0), u;
}, Hv = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, FI = function(e) {
  return [e.deltaX, e.deltaY];
}, VI = function(e) {
  return e && "current" in e ? e.current : e;
}, iae = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, oae = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, sae = 0, Sf = [];
function aae(e) {
  var t = C.useRef([]), n = C.useRef([0, 0]), r = C.useRef(), i = C.useState(sae++)[0], o = C.useState(R$)[0], s = C.useRef(e);
  C.useEffect(function() {
    s.current = e;
  }, [e]), C.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var x = Ase([e.lockRef.current], (e.shards || []).map(VI), !0).filter(Boolean);
      return x.forEach(function(w) {
        return w.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), x.forEach(function(w) {
          return w.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var a = C.useCallback(function(x, w) {
    if ("touches" in x && x.touches.length === 2 || x.type === "wheel" && x.ctrlKey)
      return !s.current.allowPinchZoom;
    var S = Hv(x), _ = n.current, M = "deltaX" in x ? x.deltaX : _[0] - S[0], N = "deltaY" in x ? x.deltaY : _[1] - S[1], D, j = x.target, O = Math.abs(M) > Math.abs(N) ? "h" : "v";
    if ("touches" in x && O === "h" && j.type === "range")
      return !1;
    var L = window.getSelection(), U = L && L.anchorNode, B = U ? U === j || U.contains(j) : !1;
    if (B)
      return !1;
    var G = UI(O, j);
    if (!G)
      return !0;
    if (G ? D = O : (D = O === "v" ? "h" : "v", G = UI(O, j)), !G)
      return !1;
    if (!r.current && "changedTouches" in x && (M || N) && (r.current = D), !D)
      return !0;
    var Y = r.current || D;
    return rae(Y, w, x, Y === "h" ? M : N);
  }, []), c = C.useCallback(function(x) {
    var w = x;
    if (!(!Sf.length || Sf[Sf.length - 1] !== o)) {
      var S = "deltaY" in w ? FI(w) : Hv(w), _ = t.current.filter(function(D) {
        return D.name === w.type && (D.target === w.target || w.target === D.shadowParent) && iae(D.delta, S);
      })[0];
      if (_ && _.should) {
        w.cancelable && w.preventDefault();
        return;
      }
      if (!_) {
        var M = (s.current.shards || []).map(VI).filter(Boolean).filter(function(D) {
          return D.contains(w.target);
        }), N = M.length > 0 ? a(w, M[0]) : !s.current.noIsolation;
        N && w.cancelable && w.preventDefault();
      }
    }
  }, []), u = C.useCallback(function(x, w, S, _) {
    var M = { name: x, delta: w, target: S, should: _, shadowParent: lae(S) };
    t.current.push(M), setTimeout(function() {
      t.current = t.current.filter(function(N) {
        return N !== M;
      });
    }, 1);
  }, []), f = C.useCallback(function(x) {
    n.current = Hv(x), r.current = void 0;
  }, []), h = C.useCallback(function(x) {
    u(x.type, FI(x), x.target, a(x, e.lockRef.current));
  }, []), m = C.useCallback(function(x) {
    u(x.type, Hv(x), x.target, a(x, e.lockRef.current));
  }, []);
  C.useEffect(function() {
    return Sf.push(o), e.setCallbacks({
      onScrollCapture: h,
      onWheelCapture: h,
      onTouchMoveCapture: m
    }), document.addEventListener("wheel", c, wf), document.addEventListener("touchmove", c, wf), document.addEventListener("touchstart", f, wf), function() {
      Sf = Sf.filter(function(x) {
        return x !== o;
      }), document.removeEventListener("wheel", c, wf), document.removeEventListener("touchmove", c, wf), document.removeEventListener("touchstart", f, wf);
    };
  }, []);
  var g = e.removeScrollBar, b = e.inert;
  return C.createElement(
    C.Fragment,
    null,
    b ? C.createElement(o, { styles: oae(i) }) : null,
    g ? C.createElement(Yse, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function lae(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const cae = zse(N$, aae);
var Cw = C.forwardRef(function(e, t) {
  return C.createElement(kw, Gs({}, e, { ref: t, sideCar: cae }));
});
Cw.classNames = kw.classNames;
var uae = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, kf = /* @__PURE__ */ new WeakMap(), Wv = /* @__PURE__ */ new WeakMap(), qv = {}, nC = 0, I$ = function(e) {
  return e && (e.host || I$(e.parentNode));
}, dae = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = I$(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, fae = function(e, t, n, r) {
  var i = dae(t, Array.isArray(e) ? e : [e]);
  qv[n] || (qv[n] = /* @__PURE__ */ new WeakMap());
  var o = qv[n], s = [], a = /* @__PURE__ */ new Set(), c = new Set(i), u = function(h) {
    !h || a.has(h) || (a.add(h), u(h.parentNode));
  };
  i.forEach(u);
  var f = function(h) {
    !h || c.has(h) || Array.prototype.forEach.call(h.children, function(m) {
      if (a.has(m))
        f(m);
      else
        try {
          var g = m.getAttribute(r), b = g !== null && g !== "false", x = (kf.get(m) || 0) + 1, w = (o.get(m) || 0) + 1;
          kf.set(m, x), o.set(m, w), s.push(m), x === 1 && b && Wv.set(m, !0), w === 1 && m.setAttribute(n, "true"), b || m.setAttribute(r, "true");
        } catch (S) {
          console.error("aria-hidden: cannot operate on ", m, S);
        }
    });
  };
  return f(t), a.clear(), nC++, function() {
    s.forEach(function(h) {
      var m = kf.get(h) - 1, g = o.get(h) - 1;
      kf.set(h, m), o.set(h, g), m || (Wv.has(h) || h.removeAttribute(r), Wv.delete(h)), g || h.removeAttribute(n);
    }), nC--, nC || (kf = /* @__PURE__ */ new WeakMap(), kf = /* @__PURE__ */ new WeakMap(), Wv = /* @__PURE__ */ new WeakMap(), qv = {});
  };
}, gM = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = uae(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live], script"))), fae(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, Ew = "Dialog", [j$] = bs(Ew), [hae, xs] = j$(Ew), z$ = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    modal: s = !0
  } = e, a = C.useRef(null), c = C.useRef(null), [u, f] = il({
    prop: r,
    defaultProp: i ?? !1,
    onChange: o,
    caller: Ew
  });
  return /* @__PURE__ */ v.jsx(
    hae,
    {
      scope: t,
      triggerRef: a,
      contentRef: c,
      contentId: Wo(),
      titleId: Wo(),
      descriptionId: Wo(),
      open: u,
      onOpenChange: f,
      onOpenToggle: C.useCallback(() => f((h) => !h), [f]),
      modal: s,
      children: n
    }
  );
};
z$.displayName = Ew;
var L$ = "DialogTrigger", B$ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = xs(L$, n), o = Ht(t, i.triggerRef);
    return /* @__PURE__ */ v.jsx(
      _t.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": bM(i.open),
        ...r,
        ref: o,
        onClick: Ye(e.onClick, i.onOpenToggle)
      }
    );
  }
);
B$.displayName = L$;
var yM = "DialogPortal", [pae, $$] = j$(yM, {
  forceMount: void 0
}), U$ = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: i } = e, o = xs(yM, t);
  return /* @__PURE__ */ v.jsx(pae, { scope: t, forceMount: n, children: C.Children.map(r, (s) => /* @__PURE__ */ v.jsx(ji, { present: n || o.open, children: /* @__PURE__ */ v.jsx(ey, { asChild: !0, container: i, children: s }) })) });
};
U$.displayName = yM;
var _b = "DialogOverlay", F$ = C.forwardRef(
  (e, t) => {
    const n = $$(_b, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = xs(_b, e.__scopeDialog);
    return o.modal ? /* @__PURE__ */ v.jsx(ji, { present: r || o.open, children: /* @__PURE__ */ v.jsx(gae, { ...i, ref: t }) }) : null;
  }
);
F$.displayName = _b;
var mae = /* @__PURE__ */ hh("DialogOverlay.RemoveScroll"), gae = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = xs(_b, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ v.jsx(Cw, { as: mae, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ v.jsx(
        _t.div,
        {
          "data-state": bM(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), td = "DialogContent", V$ = C.forwardRef(
  (e, t) => {
    const n = $$(td, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = xs(td, e.__scopeDialog);
    return /* @__PURE__ */ v.jsx(ji, { present: r || o.open, children: o.modal ? /* @__PURE__ */ v.jsx(yae, { ...i, ref: t }) : /* @__PURE__ */ v.jsx(vae, { ...i, ref: t }) });
  }
);
V$.displayName = td;
var yae = C.forwardRef(
  (e, t) => {
    const n = xs(td, e.__scopeDialog), r = C.useRef(null), i = Ht(t, n.contentRef, r);
    return C.useEffect(() => {
      const o = r.current;
      if (o) return gM(o);
    }, []), /* @__PURE__ */ v.jsx(
      H$,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ye(e.onCloseAutoFocus, (o) => {
          o.preventDefault(), n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: Ye(e.onPointerDownOutside, (o) => {
          const s = o.detail.originalEvent, a = s.button === 0 && s.ctrlKey === !0;
          (s.button === 2 || a) && o.preventDefault();
        }),
        onFocusOutside: Ye(
          e.onFocusOutside,
          (o) => o.preventDefault()
        )
      }
    );
  }
), vae = C.forwardRef(
  (e, t) => {
    const n = xs(td, e.__scopeDialog), r = C.useRef(!1), i = C.useRef(!1);
    return /* @__PURE__ */ v.jsx(
      H$,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (o) => {
          e.onCloseAutoFocus?.(o), o.defaultPrevented || (r.current || n.triggerRef.current?.focus(), o.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (o) => {
          e.onInteractOutside?.(o), o.defaultPrevented || (r.current = !0, o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const s = o.target;
          n.triggerRef.current?.contains(s) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
        }
      }
    );
  }
), H$ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, ...s } = e, a = xs(td, n), c = C.useRef(null), u = Ht(t, c);
    return mM(), /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(
        Sw,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: o,
          children: /* @__PURE__ */ v.jsx(
            Jg,
            {
              role: "dialog",
              id: a.contentId,
              "aria-describedby": a.descriptionId,
              "aria-labelledby": a.titleId,
              "data-state": bM(a.open),
              ...s,
              ref: u,
              onDismiss: () => a.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
        /* @__PURE__ */ v.jsx(bae, { titleId: a.titleId }),
        /* @__PURE__ */ v.jsx(wae, { contentRef: c, descriptionId: a.descriptionId })
      ] })
    ] });
  }
), vM = "DialogTitle", W$ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = xs(vM, n);
    return /* @__PURE__ */ v.jsx(_t.h2, { id: i.titleId, ...r, ref: t });
  }
);
W$.displayName = vM;
var q$ = "DialogDescription", G$ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = xs(q$, n);
    return /* @__PURE__ */ v.jsx(_t.p, { id: i.descriptionId, ...r, ref: t });
  }
);
G$.displayName = q$;
var K$ = "DialogClose", Z$ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = xs(K$, n);
    return /* @__PURE__ */ v.jsx(
      _t.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Ye(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
Z$.displayName = K$;
function bM(e) {
  return e ? "open" : "closed";
}
var Y$ = "DialogTitleWarning", [C5e, X$] = YX(Y$, {
  contentName: td,
  titleName: vM,
  docsSlug: "dialog"
}), bae = ({ titleId: e }) => {
  const t = X$(Y$), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return C.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, xae = "DialogDescriptionWarning", wae = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${X$(xae).contentName}}.`;
  return C.useEffect(() => {
    const i = e.current?.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, Sae = z$, kae = B$, Cae = U$, Eae = F$, _ae = V$, Tae = W$, Aae = G$, Mae = Z$;
function Hh({ ...e }) {
  return /* @__PURE__ */ v.jsx(Sae, { "data-slot": "dialog", ...e });
}
function J$({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(kae, { "data-slot": "dialog-trigger", ...e });
}
function Q$({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Cae, { "data-slot": "dialog-portal", ...e });
}
function Nae({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Eae,
    {
      "data-slot": "dialog-overlay",
      className: lt(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        e
      ),
      ...t
    }
  );
}
function Wh({
  className: e,
  children: t,
  showCloseButton: n = !0,
  ...r
}) {
  return /* @__PURE__ */ v.jsxs(Q$, { "data-slot": "dialog-portal", children: [
    /* @__PURE__ */ v.jsx(Nae, {}),
    /* @__PURE__ */ v.jsxs(
      _ae,
      {
        "data-slot": "dialog-content",
        className: lt(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-[1000] grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          e
        ),
        ...r,
        onCloseAutoFocus: (i) => {
          i.preventDefault(), document.body.style.pointerEvents = "";
        },
        children: [
          t,
          n && /* @__PURE__ */ v.jsxs(
            Mae,
            {
              "data-slot": "dialog-close",
              className: "ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
              children: [
                /* @__PURE__ */ v.jsx(Hg, {}),
                /* @__PURE__ */ v.jsx("span", { className: "sr-only", children: "Close" })
              ]
            }
          )
        ]
      }
    )
  ] });
}
function ny({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "dialog-header",
      className: lt("flex flex-col gap-2 text-center sm:text-left", e),
      ...t
    }
  );
}
function e9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "dialog-footer",
      className: lt(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        e
      ),
      ...t
    }
  );
}
function qh({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Tae,
    {
      "data-slot": "dialog-title",
      className: lt("text-lg leading-none font-semibold", e),
      ...t
    }
  );
}
function t9({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Aae,
    {
      "data-slot": "dialog-description",
      className: lt("text-muted-foreground text-sm", e),
      ...t
    }
  );
}
var Rae = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], ry = Rae.reduce((e, t) => {
  const n = /* @__PURE__ */ G6(`Primitive.${t}`), r = C.forwardRef((i, o) => {
    const { asChild: s, ...a } = i, c = s ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ v.jsx(c, { ...a, ref: o });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Oae = "Label", n9 = C.forwardRef((e, t) => /* @__PURE__ */ v.jsx(
  ry.label,
  {
    ...e,
    ref: t,
    onMouseDown: (n) => {
      n.target.closest("button, input, select, textarea") || (e.onMouseDown?.(n), !n.defaultPrevented && n.detail > 1 && n.preventDefault());
    }
  }
));
n9.displayName = Oae;
var Pae = n9;
function Dae({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Pae,
    {
      "data-slot": "label",
      className: lt(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        e
      ),
      ...t
    }
  );
}
const Iae = { "gpt-4.1": "openai/gpt-4.1", "gpt-4.1-mini": "openai/gpt-4.1-mini", "gpt-4o-mini": "openai/gpt-4o-mini", "gpt-4o": "openai/gpt-4o", "gpt-5": "openai/gpt-5", "gpt-5.1": "openai/gpt-5.1", "gpt-5-mini": "openai/gpt-5-mini", "gpt-5-nano": "openai/gpt-5-nano", "gpt-oss-120b": "openai/gpt-oss-120b", "gpt-2.5-flash": "openai/gpt-2.5-flash" }, jae = { "gemini-2.5-flash-lite": "google/gemini-2.5-flash-lite", "gemini-2.5-flash": "google/gemini-2.5-flash", "gemini-2.5-pro": "google/gemini-2.5-pro", "gemini-2.0-flash": "google/gemini-2.0-flash" }, zae = { "claude-sonnet-4.5": "anthropic/claude-sonnet-4.5", "claude-sonnet-4": "anthropic/claude-sonnet-4", "claude-3.7-sonnet": "anthropic/claude-3.7-sonnet" }, Lae = { "grok-4-fast-reasoning": "xai/grok-4-fast-reasoning", "grok-4-fast-non-reasoning": "xai/grok-4-fast-non-reasoning" }, Bae = { "llama-4-maverick": "meta/llama-4-maverick" }, $ae = { "deepseek-v3.1": "deepseek/deepseek-v3.1" }, Uae = { "gemma3-1b": "ollama/gemma3:1b", "gemma3-4b": "ollama/gemma3:4b", "gemma3-12b": "ollama/gemma3:12b" }, Fae = { "gpt-oss-20b-free": "openai/gpt-oss-20b:free", "qwen3-8b-free": "qwen/qwen3-8b:free", "qwen3-14b-free": "qwen/qwen3-14b:free", "qwen3-coder-free": "qwen/qwen3-coder:free", "deepseek-r1-free": "deepseek/deepseek-r1-0528:free", "deepseek-v3-free": "deepseek/deepseek-chat-v3-0324:free", "gemini-2.0-flash-exp-free": "google/gemini-2.0-flash-exp:free" }, Vae = {
  openai: Iae,
  google: jae,
  anthropic: zae,
  xai: Lae,
  meta: Bae,
  deepseek: $ae,
  ollama: Uae,
  openRouter: Fae
};
function Hae(e) {
  if (typeof document > "u") return;
  let t = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
  n.type = "text/css", t.appendChild(n), n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e));
}
Array(12).fill(0);
let E_ = 1;
class Wae {
  constructor() {
    this.subscribe = (t) => (this.subscribers.push(t), () => {
      const n = this.subscribers.indexOf(t);
      this.subscribers.splice(n, 1);
    }), this.publish = (t) => {
      this.subscribers.forEach((n) => n(t));
    }, this.addToast = (t) => {
      this.publish(t), this.toasts = [
        ...this.toasts,
        t
      ];
    }, this.create = (t) => {
      var n;
      const { message: r, ...i } = t, o = typeof t?.id == "number" || ((n = t.id) == null ? void 0 : n.length) > 0 ? t.id : E_++, s = this.toasts.find((c) => c.id === o), a = t.dismissible === void 0 ? !0 : t.dismissible;
      return this.dismissedToasts.has(o) && this.dismissedToasts.delete(o), s ? this.toasts = this.toasts.map((c) => c.id === o ? (this.publish({
        ...c,
        ...t,
        id: o,
        title: r
      }), {
        ...c,
        ...t,
        id: o,
        dismissible: a,
        title: r
      }) : c) : this.addToast({
        title: r,
        ...i,
        dismissible: a,
        id: o
      }), o;
    }, this.dismiss = (t) => (t ? (this.dismissedToasts.add(t), requestAnimationFrame(() => this.subscribers.forEach((n) => n({
      id: t,
      dismiss: !0
    })))) : this.toasts.forEach((n) => {
      this.subscribers.forEach((r) => r({
        id: n.id,
        dismiss: !0
      }));
    }), t), this.message = (t, n) => this.create({
      ...n,
      message: t
    }), this.error = (t, n) => this.create({
      ...n,
      message: t,
      type: "error"
    }), this.success = (t, n) => this.create({
      ...n,
      type: "success",
      message: t
    }), this.info = (t, n) => this.create({
      ...n,
      type: "info",
      message: t
    }), this.warning = (t, n) => this.create({
      ...n,
      type: "warning",
      message: t
    }), this.loading = (t, n) => this.create({
      ...n,
      type: "loading",
      message: t
    }), this.promise = (t, n) => {
      if (!n)
        return;
      let r;
      n.loading !== void 0 && (r = this.create({
        ...n,
        promise: t,
        type: "loading",
        message: n.loading,
        description: typeof n.description != "function" ? n.description : void 0
      }));
      const i = Promise.resolve(t instanceof Function ? t() : t);
      let o = r !== void 0, s;
      const a = i.then(async (u) => {
        if (s = [
          "resolve",
          u
        ], Ne.isValidElement(u))
          o = !1, this.create({
            id: r,
            type: "default",
            message: u
          });
        else if (Gae(u) && !u.ok) {
          o = !1;
          const h = typeof n.error == "function" ? await n.error(`HTTP error! status: ${u.status}`) : n.error, m = typeof n.description == "function" ? await n.description(`HTTP error! status: ${u.status}`) : n.description, b = typeof h == "object" && !Ne.isValidElement(h) ? h : {
            message: h
          };
          this.create({
            id: r,
            type: "error",
            description: m,
            ...b
          });
        } else if (u instanceof Error) {
          o = !1;
          const h = typeof n.error == "function" ? await n.error(u) : n.error, m = typeof n.description == "function" ? await n.description(u) : n.description, b = typeof h == "object" && !Ne.isValidElement(h) ? h : {
            message: h
          };
          this.create({
            id: r,
            type: "error",
            description: m,
            ...b
          });
        } else if (n.success !== void 0) {
          o = !1;
          const h = typeof n.success == "function" ? await n.success(u) : n.success, m = typeof n.description == "function" ? await n.description(u) : n.description, b = typeof h == "object" && !Ne.isValidElement(h) ? h : {
            message: h
          };
          this.create({
            id: r,
            type: "success",
            description: m,
            ...b
          });
        }
      }).catch(async (u) => {
        if (s = [
          "reject",
          u
        ], n.error !== void 0) {
          o = !1;
          const f = typeof n.error == "function" ? await n.error(u) : n.error, h = typeof n.description == "function" ? await n.description(u) : n.description, g = typeof f == "object" && !Ne.isValidElement(f) ? f : {
            message: f
          };
          this.create({
            id: r,
            type: "error",
            description: h,
            ...g
          });
        }
      }).finally(() => {
        o && (this.dismiss(r), r = void 0), n.finally == null || n.finally.call(n);
      }), c = () => new Promise((u, f) => a.then(() => s[0] === "reject" ? f(s[1]) : u(s[1])).catch(f));
      return typeof r != "string" && typeof r != "number" ? {
        unwrap: c
      } : Object.assign(r, {
        unwrap: c
      });
    }, this.custom = (t, n) => {
      const r = n?.id || E_++;
      return this.create({
        jsx: t(r),
        id: r,
        ...n
      }), r;
    }, this.getActiveToasts = () => this.toasts.filter((t) => !this.dismissedToasts.has(t.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
}
const Lo = new Wae(), qae = (e, t) => {
  const n = t?.id || E_++;
  return Lo.addToast({
    title: e,
    ...t,
    id: n
  }), n;
}, Gae = (e) => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", Kae = qae, Zae = () => Lo.toasts, Yae = () => Lo.getActiveToasts(), Vt = Object.assign(Kae, {
  success: Lo.success,
  info: Lo.info,
  warning: Lo.warning,
  error: Lo.error,
  custom: Lo.custom,
  message: Lo.message,
  promise: Lo.promise,
  dismiss: Lo.dismiss,
  loading: Lo.loading
}, {
  getHistory: Zae,
  getToasts: Yae
});
Hae("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}");
function xM(e) {
  const t = e + "CollectionProvider", [n, r] = bs(t), [i, o] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s = (x) => {
    const { scope: w, children: S } = x, _ = Ne.useRef(null), M = Ne.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ v.jsx(i, { scope: w, itemMap: M, collectionRef: _, children: S });
  };
  s.displayName = t;
  const a = e + "CollectionSlot", c = /* @__PURE__ */ hh(a), u = Ne.forwardRef(
    (x, w) => {
      const { scope: S, children: _ } = x, M = o(a, S), N = Ht(w, M.collectionRef);
      return /* @__PURE__ */ v.jsx(c, { ref: N, children: _ });
    }
  );
  u.displayName = a;
  const f = e + "CollectionItemSlot", h = "data-radix-collection-item", m = /* @__PURE__ */ hh(f), g = Ne.forwardRef(
    (x, w) => {
      const { scope: S, children: _, ...M } = x, N = Ne.useRef(null), D = Ht(w, N), j = o(f, S);
      return Ne.useEffect(() => (j.itemMap.set(N, { ref: N, ...M }), () => {
        j.itemMap.delete(N);
      })), /* @__PURE__ */ v.jsx(m, { [h]: "", ref: D, children: _ });
    }
  );
  g.displayName = f;
  function b(x) {
    const w = o(e + "CollectionConsumer", x);
    return Ne.useCallback(() => {
      const _ = w.collectionRef.current;
      if (!_) return [];
      const M = Array.from(_.querySelectorAll(`[${h}]`));
      return Array.from(w.itemMap.values()).sort(
        (j, O) => M.indexOf(j.ref.current) - M.indexOf(O.ref.current)
      );
    }, [w.collectionRef, w.itemMap]);
  }
  return [
    { Provider: s, Slot: u, ItemSlot: g },
    b,
    r
  ];
}
function wM(e) {
  const t = C.useRef({ value: e, previous: e });
  return C.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var Xae = [" ", "Enter", "ArrowUp", "ArrowDown"], Jae = [" ", "Enter"], nd = "Select", [_w, Tw, Qae] = xM(nd), [Gh] = bs(nd, [
  Qae,
  Uh
]), Aw = Uh(), [ele, Uc] = Gh(nd), [tle, nle] = Gh(nd), r9 = (e) => {
  const {
    __scopeSelect: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    value: s,
    defaultValue: a,
    onValueChange: c,
    dir: u,
    name: f,
    autoComplete: h,
    disabled: m,
    required: g,
    form: b
  } = e, x = Aw(t), [w, S] = C.useState(null), [_, M] = C.useState(null), [N, D] = C.useState(!1), j = ow(u), [O, L] = il({
    prop: r,
    defaultProp: i ?? !1,
    onChange: o,
    caller: nd
  }), [U, B] = il({
    prop: s,
    defaultProp: a,
    onChange: c,
    caller: nd
  }), G = C.useRef(null), Y = w ? b || !!w.closest("form") : !0, [he, ie] = C.useState(/* @__PURE__ */ new Set()), ne = Array.from(he).map((H) => H.props.value).join(";");
  return /* @__PURE__ */ v.jsx(vw, { ...x, children: /* @__PURE__ */ v.jsxs(
    ele,
    {
      required: g,
      scope: t,
      trigger: w,
      onTriggerChange: S,
      valueNode: _,
      onValueNodeChange: M,
      valueNodeHasChildren: N,
      onValueNodeHasChildrenChange: D,
      contentId: Wo(),
      value: U,
      onValueChange: B,
      open: O,
      onOpenChange: L,
      dir: j,
      triggerPointerDownPosRef: G,
      disabled: m,
      children: [
        /* @__PURE__ */ v.jsx(_w.Provider, { scope: t, children: /* @__PURE__ */ v.jsx(
          tle,
          {
            scope: e.__scopeSelect,
            onNativeOptionAdd: C.useCallback((H) => {
              ie((Q) => new Set(Q).add(H));
            }, []),
            onNativeOptionRemove: C.useCallback((H) => {
              ie((Q) => {
                const X = new Set(Q);
                return X.delete(H), X;
              });
            }, []),
            children: n
          }
        ) }),
        Y ? /* @__PURE__ */ v.jsxs(
          T9,
          {
            "aria-hidden": !0,
            required: g,
            tabIndex: -1,
            name: f,
            autoComplete: h,
            value: U,
            onChange: (H) => B(H.target.value),
            disabled: m,
            form: b,
            children: [
              U === void 0 ? /* @__PURE__ */ v.jsx("option", { value: "" }) : null,
              Array.from(he)
            ]
          },
          ne
        ) : null
      ]
    }
  ) });
};
r9.displayName = nd;
var i9 = "SelectTrigger", o9 = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, disabled: r = !1, ...i } = e, o = Aw(n), s = Uc(i9, n), a = s.disabled || r, c = Ht(t, s.onTriggerChange), u = Tw(n), f = C.useRef("touch"), [h, m, g] = M9((x) => {
      const w = u().filter((M) => !M.disabled), S = w.find((M) => M.value === s.value), _ = N9(w, x, S);
      _ !== void 0 && s.onValueChange(_.value);
    }), b = (x) => {
      a || (s.onOpenChange(!0), g()), x && (s.triggerPointerDownPosRef.current = {
        x: Math.round(x.pageX),
        y: Math.round(x.pageY)
      });
    };
    return /* @__PURE__ */ v.jsx(cM, { asChild: !0, ...o, children: /* @__PURE__ */ v.jsx(
      _t.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": s.contentId,
        "aria-expanded": s.open,
        "aria-required": s.required,
        "aria-autocomplete": "none",
        dir: s.dir,
        "data-state": s.open ? "open" : "closed",
        disabled: a,
        "data-disabled": a ? "" : void 0,
        "data-placeholder": A9(s.value) ? "" : void 0,
        ...i,
        ref: c,
        onClick: Ye(i.onClick, (x) => {
          x.currentTarget.focus(), f.current !== "mouse" && b(x);
        }),
        onPointerDown: Ye(i.onPointerDown, (x) => {
          f.current = x.pointerType;
          const w = x.target;
          w.hasPointerCapture(x.pointerId) && w.releasePointerCapture(x.pointerId), x.button === 0 && x.ctrlKey === !1 && x.pointerType === "mouse" && (b(x), x.preventDefault());
        }),
        onKeyDown: Ye(i.onKeyDown, (x) => {
          const w = h.current !== "";
          !(x.ctrlKey || x.altKey || x.metaKey) && x.key.length === 1 && m(x.key), !(w && x.key === " ") && Xae.includes(x.key) && (b(), x.preventDefault());
        })
      }
    ) });
  }
);
o9.displayName = i9;
var s9 = "SelectValue", a9 = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: r, style: i, children: o, placeholder: s = "", ...a } = e, c = Uc(s9, n), { onValueNodeHasChildrenChange: u } = c, f = o !== void 0, h = Ht(t, c.onValueNodeChange);
    return _r(() => {
      u(f);
    }, [u, f]), /* @__PURE__ */ v.jsx(
      _t.span,
      {
        ...a,
        ref: h,
        style: { pointerEvents: "none" },
        children: A9(c.value) ? /* @__PURE__ */ v.jsx(v.Fragment, { children: s }) : o
      }
    );
  }
);
a9.displayName = s9;
var rle = "SelectIcon", l9 = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, children: r, ...i } = e;
    return /* @__PURE__ */ v.jsx(_t.span, { "aria-hidden": !0, ...i, ref: t, children: r || "" });
  }
);
l9.displayName = rle;
var ile = "SelectPortal", c9 = (e) => /* @__PURE__ */ v.jsx(ey, { asChild: !0, ...e });
c9.displayName = ile;
var rd = "SelectContent", u9 = C.forwardRef(
  (e, t) => {
    const n = Uc(rd, e.__scopeSelect), [r, i] = C.useState();
    if (_r(() => {
      i(new DocumentFragment());
    }, []), !n.open) {
      const o = r;
      return o ? sl.createPortal(
        /* @__PURE__ */ v.jsx(d9, { scope: e.__scopeSelect, children: /* @__PURE__ */ v.jsx(_w.Slot, { scope: e.__scopeSelect, children: /* @__PURE__ */ v.jsx("div", { children: e.children }) }) }),
        o
      ) : null;
    }
    return /* @__PURE__ */ v.jsx(f9, { ...e, ref: t });
  }
);
u9.displayName = rd;
var cs = 10, [d9, Fc] = Gh(rd), ole = "SelectContentImpl", sle = /* @__PURE__ */ hh("SelectContent.RemoveScroll"), f9 = C.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      position: r = "item-aligned",
      onCloseAutoFocus: i,
      onEscapeKeyDown: o,
      onPointerDownOutside: s,
      //
      // PopperContent props
      side: a,
      sideOffset: c,
      align: u,
      alignOffset: f,
      arrowPadding: h,
      collisionBoundary: m,
      collisionPadding: g,
      sticky: b,
      hideWhenDetached: x,
      avoidCollisions: w,
      //
      ...S
    } = e, _ = Uc(rd, n), [M, N] = C.useState(null), [D, j] = C.useState(null), O = Ht(t, (J) => N(J)), [L, U] = C.useState(null), [B, G] = C.useState(
      null
    ), Y = Tw(n), [he, ie] = C.useState(!1), ne = C.useRef(!1);
    C.useEffect(() => {
      if (M) return gM(M);
    }, [M]), mM();
    const H = C.useCallback(
      (J) => {
        const [xe, ...be] = Y().map((Ge) => Ge.ref.current), [Ae] = be.slice(-1), nt = document.activeElement;
        for (const Ge of J)
          if (Ge === nt || (Ge?.scrollIntoView({ block: "nearest" }), Ge === xe && D && (D.scrollTop = 0), Ge === Ae && D && (D.scrollTop = D.scrollHeight), Ge?.focus(), document.activeElement !== nt)) return;
      },
      [Y, D]
    ), Q = C.useCallback(
      () => H([L, M]),
      [H, L, M]
    );
    C.useEffect(() => {
      he && Q();
    }, [he, Q]);
    const { onOpenChange: X, triggerPointerDownPosRef: Se } = _;
    C.useEffect(() => {
      if (M) {
        let J = { x: 0, y: 0 };
        const xe = (Ae) => {
          J = {
            x: Math.abs(Math.round(Ae.pageX) - (Se.current?.x ?? 0)),
            y: Math.abs(Math.round(Ae.pageY) - (Se.current?.y ?? 0))
          };
        }, be = (Ae) => {
          J.x <= 10 && J.y <= 10 ? Ae.preventDefault() : M.contains(Ae.target) || X(!1), document.removeEventListener("pointermove", xe), Se.current = null;
        };
        return Se.current !== null && (document.addEventListener("pointermove", xe), document.addEventListener("pointerup", be, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", xe), document.removeEventListener("pointerup", be, { capture: !0 });
        };
      }
    }, [M, X, Se]), C.useEffect(() => {
      const J = () => X(!1);
      return window.addEventListener("blur", J), window.addEventListener("resize", J), () => {
        window.removeEventListener("blur", J), window.removeEventListener("resize", J);
      };
    }, [X]);
    const [W, Z] = M9((J) => {
      const xe = Y().filter((nt) => !nt.disabled), be = xe.find((nt) => nt.ref.current === document.activeElement), Ae = N9(xe, J, be);
      Ae && setTimeout(() => Ae.ref.current.focus());
    }), pe = C.useCallback(
      (J, xe, be) => {
        const Ae = !ne.current && !be;
        (_.value !== void 0 && _.value === xe || Ae) && (U(J), Ae && (ne.current = !0));
      },
      [_.value]
    ), F = C.useCallback(() => M?.focus(), [M]), ee = C.useCallback(
      (J, xe, be) => {
        const Ae = !ne.current && !be;
        (_.value !== void 0 && _.value === xe || Ae) && G(J);
      },
      [_.value]
    ), ge = r === "popper" ? __ : h9, re = ge === __ ? {
      side: a,
      sideOffset: c,
      align: u,
      alignOffset: f,
      arrowPadding: h,
      collisionBoundary: m,
      collisionPadding: g,
      sticky: b,
      hideWhenDetached: x,
      avoidCollisions: w
    } : {};
    return /* @__PURE__ */ v.jsx(
      d9,
      {
        scope: n,
        content: M,
        viewport: D,
        onViewportChange: j,
        itemRefCallback: pe,
        selectedItem: L,
        onItemLeave: F,
        itemTextRefCallback: ee,
        focusSelectedItem: Q,
        selectedItemText: B,
        position: r,
        isPositioned: he,
        searchRef: W,
        children: /* @__PURE__ */ v.jsx(Cw, { as: sle, allowPinchZoom: !0, children: /* @__PURE__ */ v.jsx(
          Sw,
          {
            asChild: !0,
            trapped: _.open,
            onMountAutoFocus: (J) => {
              J.preventDefault();
            },
            onUnmountAutoFocus: Ye(i, (J) => {
              _.trigger?.focus({ preventScroll: !0 }), J.preventDefault();
            }),
            children: /* @__PURE__ */ v.jsx(
              Jg,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: o,
                onPointerDownOutside: s,
                onFocusOutside: (J) => J.preventDefault(),
                onDismiss: () => _.onOpenChange(!1),
                children: /* @__PURE__ */ v.jsx(
                  ge,
                  {
                    role: "listbox",
                    id: _.contentId,
                    "data-state": _.open ? "open" : "closed",
                    dir: _.dir,
                    onContextMenu: (J) => J.preventDefault(),
                    ...S,
                    ...re,
                    onPlaced: () => ie(!0),
                    ref: O,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...S.style
                    },
                    onKeyDown: Ye(S.onKeyDown, (J) => {
                      const xe = J.ctrlKey || J.altKey || J.metaKey;
                      if (J.key === "Tab" && J.preventDefault(), !xe && J.key.length === 1 && Z(J.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(J.key)) {
                        let Ae = Y().filter((nt) => !nt.disabled).map((nt) => nt.ref.current);
                        if (["ArrowUp", "End"].includes(J.key) && (Ae = Ae.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(J.key)) {
                          const nt = J.target, Ge = Ae.indexOf(nt);
                          Ae = Ae.slice(Ge + 1);
                        }
                        setTimeout(() => H(Ae)), J.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
f9.displayName = ole;
var ale = "SelectItemAlignedPosition", h9 = C.forwardRef((e, t) => {
  const { __scopeSelect: n, onPlaced: r, ...i } = e, o = Uc(rd, n), s = Fc(rd, n), [a, c] = C.useState(null), [u, f] = C.useState(null), h = Ht(t, (O) => f(O)), m = Tw(n), g = C.useRef(!1), b = C.useRef(!0), { viewport: x, selectedItem: w, selectedItemText: S, focusSelectedItem: _ } = s, M = C.useCallback(() => {
    if (o.trigger && o.valueNode && a && u && x && w && S) {
      const O = o.trigger.getBoundingClientRect(), L = u.getBoundingClientRect(), U = o.valueNode.getBoundingClientRect(), B = S.getBoundingClientRect();
      if (o.dir !== "rtl") {
        const nt = B.left - L.left, Ge = U.left - nt, rt = O.left - Ge, Tt = O.width + rt, vn = Math.max(Tt, L.width), kt = window.innerWidth - cs, Wt = GE(Ge, [
          cs,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(cs, kt - vn)
        ]);
        a.style.minWidth = Tt + "px", a.style.left = Wt + "px";
      } else {
        const nt = L.right - B.right, Ge = window.innerWidth - U.right - nt, rt = window.innerWidth - O.right - Ge, Tt = O.width + rt, vn = Math.max(Tt, L.width), kt = window.innerWidth - cs, Wt = GE(Ge, [
          cs,
          Math.max(cs, kt - vn)
        ]);
        a.style.minWidth = Tt + "px", a.style.right = Wt + "px";
      }
      const G = m(), Y = window.innerHeight - cs * 2, he = x.scrollHeight, ie = window.getComputedStyle(u), ne = parseInt(ie.borderTopWidth, 10), H = parseInt(ie.paddingTop, 10), Q = parseInt(ie.borderBottomWidth, 10), X = parseInt(ie.paddingBottom, 10), Se = ne + H + he + X + Q, W = Math.min(w.offsetHeight * 5, Se), Z = window.getComputedStyle(x), pe = parseInt(Z.paddingTop, 10), F = parseInt(Z.paddingBottom, 10), ee = O.top + O.height / 2 - cs, ge = Y - ee, re = w.offsetHeight / 2, J = w.offsetTop + re, xe = ne + H + J, be = Se - xe;
      if (xe <= ee) {
        const nt = G.length > 0 && w === G[G.length - 1].ref.current;
        a.style.bottom = "0px";
        const Ge = u.clientHeight - x.offsetTop - x.offsetHeight, rt = Math.max(
          ge,
          re + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (nt ? F : 0) + Ge + Q
        ), Tt = xe + rt;
        a.style.height = Tt + "px";
      } else {
        const nt = G.length > 0 && w === G[0].ref.current;
        a.style.top = "0px";
        const rt = Math.max(
          ee,
          ne + x.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (nt ? pe : 0) + re
        ) + be;
        a.style.height = rt + "px", x.scrollTop = xe - ee + x.offsetTop;
      }
      a.style.margin = `${cs}px 0`, a.style.minHeight = W + "px", a.style.maxHeight = Y + "px", r?.(), requestAnimationFrame(() => g.current = !0);
    }
  }, [
    m,
    o.trigger,
    o.valueNode,
    a,
    u,
    x,
    w,
    S,
    o.dir,
    r
  ]);
  _r(() => M(), [M]);
  const [N, D] = C.useState();
  _r(() => {
    u && D(window.getComputedStyle(u).zIndex);
  }, [u]);
  const j = C.useCallback(
    (O) => {
      O && b.current === !0 && (M(), _?.(), b.current = !1);
    },
    [M, _]
  );
  return /* @__PURE__ */ v.jsx(
    cle,
    {
      scope: n,
      contentWrapper: a,
      shouldExpandOnScrollRef: g,
      onScrollButtonChange: j,
      children: /* @__PURE__ */ v.jsx(
        "div",
        {
          ref: c,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: N
          },
          children: /* @__PURE__ */ v.jsx(
            _t.div,
            {
              ...i,
              ref: h,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...i.style
              }
            }
          )
        }
      )
    }
  );
});
h9.displayName = ale;
var lle = "SelectPopperPosition", __ = C.forwardRef((e, t) => {
  const {
    __scopeSelect: n,
    align: r = "start",
    collisionPadding: i = cs,
    ...o
  } = e, s = Aw(n);
  return /* @__PURE__ */ v.jsx(
    uM,
    {
      ...s,
      ...o,
      ref: t,
      align: r,
      collisionPadding: i,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...o.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
__.displayName = lle;
var [cle, SM] = Gh(rd, {}), T_ = "SelectViewport", p9 = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, nonce: r, ...i } = e, o = Fc(T_, n), s = SM(T_, n), a = Ht(t, o.onViewportChange), c = C.useRef(0);
    return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: r
        }
      ),
      /* @__PURE__ */ v.jsx(_w.Slot, { scope: n, children: /* @__PURE__ */ v.jsx(
        _t.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...i,
          ref: a,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...i.style
          },
          onScroll: Ye(i.onScroll, (u) => {
            const f = u.currentTarget, { contentWrapper: h, shouldExpandOnScrollRef: m } = s;
            if (m?.current && h) {
              const g = Math.abs(c.current - f.scrollTop);
              if (g > 0) {
                const b = window.innerHeight - cs * 2, x = parseFloat(h.style.minHeight), w = parseFloat(h.style.height), S = Math.max(x, w);
                if (S < b) {
                  const _ = S + g, M = Math.min(b, _), N = _ - M;
                  h.style.height = M + "px", h.style.bottom === "0px" && (f.scrollTop = N > 0 ? N : 0, h.style.justifyContent = "flex-end");
                }
              }
            }
            c.current = f.scrollTop;
          })
        }
      ) })
    ] });
  }
);
p9.displayName = T_;
var m9 = "SelectGroup", [ule, dle] = Gh(m9), g9 = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, i = Wo();
    return /* @__PURE__ */ v.jsx(ule, { scope: n, id: i, children: /* @__PURE__ */ v.jsx(_t.div, { role: "group", "aria-labelledby": i, ...r, ref: t }) });
  }
);
g9.displayName = m9;
var y9 = "SelectLabel", v9 = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, i = dle(y9, n);
    return /* @__PURE__ */ v.jsx(_t.div, { id: i.id, ...r, ref: t });
  }
);
v9.displayName = y9;
var Tb = "SelectItem", [fle, b9] = Gh(Tb), x9 = C.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      value: r,
      disabled: i = !1,
      textValue: o,
      ...s
    } = e, a = Uc(Tb, n), c = Fc(Tb, n), u = a.value === r, [f, h] = C.useState(o ?? ""), [m, g] = C.useState(!1), b = Ht(
      t,
      (_) => c.itemRefCallback?.(_, r, i)
    ), x = Wo(), w = C.useRef("touch"), S = () => {
      i || (a.onValueChange(r), a.onOpenChange(!1));
    };
    if (r === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ v.jsx(
      fle,
      {
        scope: n,
        value: r,
        disabled: i,
        textId: x,
        isSelected: u,
        onItemTextChange: C.useCallback((_) => {
          h((M) => M || (_?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ v.jsx(
          _w.ItemSlot,
          {
            scope: n,
            value: r,
            disabled: i,
            textValue: f,
            children: /* @__PURE__ */ v.jsx(
              _t.div,
              {
                role: "option",
                "aria-labelledby": x,
                "data-highlighted": m ? "" : void 0,
                "aria-selected": u && m,
                "data-state": u ? "checked" : "unchecked",
                "aria-disabled": i || void 0,
                "data-disabled": i ? "" : void 0,
                tabIndex: i ? void 0 : -1,
                ...s,
                ref: b,
                onFocus: Ye(s.onFocus, () => g(!0)),
                onBlur: Ye(s.onBlur, () => g(!1)),
                onClick: Ye(s.onClick, () => {
                  w.current !== "mouse" && S();
                }),
                onPointerUp: Ye(s.onPointerUp, () => {
                  w.current === "mouse" && S();
                }),
                onPointerDown: Ye(s.onPointerDown, (_) => {
                  w.current = _.pointerType;
                }),
                onPointerMove: Ye(s.onPointerMove, (_) => {
                  w.current = _.pointerType, i ? c.onItemLeave?.() : w.current === "mouse" && _.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: Ye(s.onPointerLeave, (_) => {
                  _.currentTarget === document.activeElement && c.onItemLeave?.();
                }),
                onKeyDown: Ye(s.onKeyDown, (_) => {
                  c.searchRef?.current !== "" && _.key === " " || (Jae.includes(_.key) && S(), _.key === " " && _.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
x9.displayName = Tb;
var bm = "SelectItemText", w9 = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: r, style: i, ...o } = e, s = Uc(bm, n), a = Fc(bm, n), c = b9(bm, n), u = nle(bm, n), [f, h] = C.useState(null), m = Ht(
      t,
      (S) => h(S),
      c.onItemTextChange,
      (S) => a.itemTextRefCallback?.(S, c.value, c.disabled)
    ), g = f?.textContent, b = C.useMemo(
      () => /* @__PURE__ */ v.jsx("option", { value: c.value, disabled: c.disabled, children: g }, c.value),
      [c.disabled, c.value, g]
    ), { onNativeOptionAdd: x, onNativeOptionRemove: w } = u;
    return _r(() => (x(b), () => w(b)), [x, w, b]), /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(_t.span, { id: c.textId, ...o, ref: m }),
      c.isSelected && s.valueNode && !s.valueNodeHasChildren ? sl.createPortal(o.children, s.valueNode) : null
    ] });
  }
);
w9.displayName = bm;
var S9 = "SelectItemIndicator", k9 = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return b9(S9, n).isSelected ? /* @__PURE__ */ v.jsx(_t.span, { "aria-hidden": !0, ...r, ref: t }) : null;
  }
);
k9.displayName = S9;
var A_ = "SelectScrollUpButton", C9 = C.forwardRef((e, t) => {
  const n = Fc(A_, e.__scopeSelect), r = SM(A_, e.__scopeSelect), [i, o] = C.useState(!1), s = Ht(t, r.onScrollButtonChange);
  return _r(() => {
    if (n.viewport && n.isPositioned) {
      let a = function() {
        const u = c.scrollTop > 0;
        o(u);
      };
      const c = n.viewport;
      return a(), c.addEventListener("scroll", a), () => c.removeEventListener("scroll", a);
    }
  }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ v.jsx(
    _9,
    {
      ...e,
      ref: s,
      onAutoScroll: () => {
        const { viewport: a, selectedItem: c } = n;
        a && c && (a.scrollTop = a.scrollTop - c.offsetHeight);
      }
    }
  ) : null;
});
C9.displayName = A_;
var M_ = "SelectScrollDownButton", E9 = C.forwardRef((e, t) => {
  const n = Fc(M_, e.__scopeSelect), r = SM(M_, e.__scopeSelect), [i, o] = C.useState(!1), s = Ht(t, r.onScrollButtonChange);
  return _r(() => {
    if (n.viewport && n.isPositioned) {
      let a = function() {
        const u = c.scrollHeight - c.clientHeight, f = Math.ceil(c.scrollTop) < u;
        o(f);
      };
      const c = n.viewport;
      return a(), c.addEventListener("scroll", a), () => c.removeEventListener("scroll", a);
    }
  }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ v.jsx(
    _9,
    {
      ...e,
      ref: s,
      onAutoScroll: () => {
        const { viewport: a, selectedItem: c } = n;
        a && c && (a.scrollTop = a.scrollTop + c.offsetHeight);
      }
    }
  ) : null;
});
E9.displayName = M_;
var _9 = C.forwardRef((e, t) => {
  const { __scopeSelect: n, onAutoScroll: r, ...i } = e, o = Fc("SelectScrollButton", n), s = C.useRef(null), a = Tw(n), c = C.useCallback(() => {
    s.current !== null && (window.clearInterval(s.current), s.current = null);
  }, []);
  return C.useEffect(() => () => c(), [c]), _r(() => {
    a().find((f) => f.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [a]), /* @__PURE__ */ v.jsx(
    _t.div,
    {
      "aria-hidden": !0,
      ...i,
      ref: t,
      style: { flexShrink: 0, ...i.style },
      onPointerDown: Ye(i.onPointerDown, () => {
        s.current === null && (s.current = window.setInterval(r, 50));
      }),
      onPointerMove: Ye(i.onPointerMove, () => {
        o.onItemLeave?.(), s.current === null && (s.current = window.setInterval(r, 50));
      }),
      onPointerLeave: Ye(i.onPointerLeave, () => {
        c();
      })
    }
  );
}), hle = "SelectSeparator", ple = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return /* @__PURE__ */ v.jsx(_t.div, { "aria-hidden": !0, ...r, ref: t });
  }
);
ple.displayName = hle;
var N_ = "SelectArrow", mle = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, i = Aw(n), o = Uc(N_, n), s = Fc(N_, n);
    return o.open && s.position === "popper" ? /* @__PURE__ */ v.jsx(dM, { ...i, ...r, ref: t }) : null;
  }
);
mle.displayName = N_;
var gle = "SelectBubbleInput", T9 = C.forwardRef(
  ({ __scopeSelect: e, value: t, ...n }, r) => {
    const i = C.useRef(null), o = Ht(r, i), s = wM(t);
    return C.useEffect(() => {
      const a = i.current;
      if (!a) return;
      const c = window.HTMLSelectElement.prototype, f = Object.getOwnPropertyDescriptor(
        c,
        "value"
      ).set;
      if (s !== t && f) {
        const h = new Event("change", { bubbles: !0 });
        f.call(a, t), a.dispatchEvent(h);
      }
    }, [s, t]), /* @__PURE__ */ v.jsx(
      _t.select,
      {
        ...n,
        style: { ...v$, ...n.style },
        ref: o,
        defaultValue: t
      }
    );
  }
);
T9.displayName = gle;
function A9(e) {
  return e === "" || e === void 0;
}
function M9(e) {
  const t = Ir(e), n = C.useRef(""), r = C.useRef(0), i = C.useCallback(
    (s) => {
      const a = n.current + s;
      t(a), (function c(u) {
        n.current = u, window.clearTimeout(r.current), u !== "" && (r.current = window.setTimeout(() => c(""), 1e3));
      })(a);
    },
    [t]
  ), o = C.useCallback(() => {
    n.current = "", window.clearTimeout(r.current);
  }, []);
  return C.useEffect(() => () => window.clearTimeout(r.current), []), [n, i, o];
}
function N9(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let s = yle(e, Math.max(o, 0));
  i.length === 1 && (s = s.filter((u) => u !== n));
  const c = s.find(
    (u) => u.textValue.toLowerCase().startsWith(i.toLowerCase())
  );
  return c !== n ? c : void 0;
}
function yle(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var vle = r9, ble = o9, xle = a9, wle = l9, Sle = c9, kle = u9, Cle = p9, Ele = g9, _le = v9, Tle = x9, Ale = w9, Mle = k9, Nle = C9, Rle = E9;
function Ole({ ...e }) {
  return /* @__PURE__ */ v.jsx(vle, { "data-slot": "select", ...e });
}
function Ple({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Ele, { "data-slot": "select-group", ...e });
}
function Dle({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(xle, { "data-slot": "select-value", ...e });
}
function Ile({
  className: e,
  size: t = "default",
  children: n,
  ...r
}) {
  return /* @__PURE__ */ v.jsxs(
    ble,
    {
      "data-slot": "select-trigger",
      "data-size": t,
      className: lt(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ v.jsx(wle, { asChild: !0, children: /* @__PURE__ */ v.jsx(Fg, { className: "size-4 opacity-50" }) })
      ]
    }
  );
}
function jle({
  className: e,
  children: t,
  position: n = "popper",
  ...r
}) {
  return /* @__PURE__ */ v.jsx(Sle, { children: /* @__PURE__ */ v.jsxs(
    kle,
    {
      "data-slot": "select-content",
      className: lt(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
        n === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        e
      ),
      position: n,
      ...r,
      children: [
        /* @__PURE__ */ v.jsx(Ble, {}),
        /* @__PURE__ */ v.jsx(
          Cle,
          {
            className: lt(
              "p-1",
              n === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
            ),
            children: t
          }
        ),
        /* @__PURE__ */ v.jsx($le, {})
      ]
    }
  ) });
}
function zle({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    _le,
    {
      "data-slot": "select-label",
      className: lt("text-muted-foreground px-2 py-1.5 text-xs", e),
      ...t
    }
  );
}
function Lle({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsxs(
    Tle,
    {
      "data-slot": "select-item",
      className: lt(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        e
      ),
      ...n,
      children: [
        /* @__PURE__ */ v.jsx("span", { className: "absolute right-2 flex size-3.5 items-center justify-center", children: /* @__PURE__ */ v.jsx(Mle, { children: /* @__PURE__ */ v.jsx(Tc, { className: "size-4" }) }) }),
        /* @__PURE__ */ v.jsx(Ale, { children: t })
      ]
    }
  );
}
function Ble({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Nle,
    {
      "data-slot": "select-scroll-up-button",
      className: lt("flex cursor-default items-center justify-center py-1", e),
      ...t,
      children: /* @__PURE__ */ v.jsx(hY, { className: "size-4" })
    }
  );
}
function $le({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Rle,
    {
      "data-slot": "select-scroll-down-button",
      className: lt("flex cursor-default items-center justify-center py-1", e),
      ...t,
      children: /* @__PURE__ */ v.jsx(Fg, { className: "size-4" })
    }
  );
}
const R9 = "gpt-4.1", vh = {
  ALLOWED_MCP_SERVERS: "allowed-mcp-servers",
  AI_USE_NEXT_SUGGESTION: "ai-use-next-suggestion"
}, Ule = ({
  open: e,
  onOpenChange: t,
  setApiKeyByName: n
}) => {
  const [r, i] = C.useState(localStorage.getItem("ai-name") || R9), [o, s] = C.useState([]);
  C.useEffect(() => {
    const c = [];
    Object.entries(Vae).forEach(([u, f]) => {
      c.push({ provider: u, models: Object.keys(f) });
    }), s(c);
  }, []);
  const a = async () => {
    try {
      Vt.success("Settings saved successfully"), n && await n(r), t(!1);
    } catch (c) {
      Vt.error(c?.message || "Failed to save setting");
    }
  };
  return /* @__PURE__ */ v.jsx(Hh, { open: e, onOpenChange: t, children: /* @__PURE__ */ v.jsxs(Wh, { className: "max-w-sm", children: [
    /* @__PURE__ */ v.jsxs(ny, { children: [
      /* @__PURE__ */ v.jsx(qh, { children: "Settings" }),
      /* @__PURE__ */ v.jsx(t9, { className: "text-xs text-muted-foreground italic", children: "Configure your chatbot connection and identity. Your API key is kept locally and never shared." })
    ] }),
    /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 py-1", children: [
      /* @__PURE__ */ v.jsx(Dae, { htmlFor: "openai-name", children: "Model name" }),
      /* @__PURE__ */ v.jsxs(Ole, { value: r, onValueChange: i, children: [
        /* @__PURE__ */ v.jsx(Ile, { id: "openai-name", className: "w-full", children: /* @__PURE__ */ v.jsx(Dle, { placeholder: "Select a model" }) }),
        /* @__PURE__ */ v.jsx(
          jle,
          {
            position: "popper",
            className: "z-[9999] max-h-[30vh] overflow-y-auto",
            children: o.map((c) => /* @__PURE__ */ v.jsxs(Ple, { children: [
              /* @__PURE__ */ v.jsx(zle, { children: c.provider }),
              c.models.map((u) => /* @__PURE__ */ v.jsx(Lle, { value: u, children: u }, u))
            ] }, c.provider))
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ v.jsx(e9, { children: /* @__PURE__ */ v.jsx(qt, { onClick: a, type: "button", children: "Save" }) })
  ] }) });
};
function bh({ className: e }) {
  return /* @__PURE__ */ v.jsxs(
    "svg",
    {
      "aria-hidden": "true",
      viewBox: "0 0 24 24",
      version: "1.1",
      className: e,
      "data-view-component": "true",
      children: [
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "currentColor",
            d: "M15.688 2.343a2.588 2.588 0 00-3.61 0l-9.626 9.44a.863.863 0 01-1.203 0 .823.823 0 010-1.18l9.626-9.44a4.313 4.313 0 016.016 0 4.116 4.116 0 011.204 3.54 4.3 4.3 0 013.609 1.18l.05.05a4.115 4.115 0 010 5.9l-8.706 8.537a.274.274 0 000 .393l1.788 1.754a.823.823 0 010 1.18.863.863 0 01-1.203 0l-1.788-1.753a1.92 1.92 0 010-2.754l8.706-8.538a2.47 2.47 0 000-3.54l-.05-.049a2.588 2.588 0 00-3.607-.003l-7.172 7.034-.002.002-.098.097a.863.863 0 01-1.204 0 .823.823 0 010-1.18l7.273-7.133a2.47 2.47 0 00-.003-3.537z"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "currentColor",
            d: "M14.485 4.703a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a4.115 4.115 0 000 5.9 4.314 4.314 0 006.016 0l7.12-6.982a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a2.588 2.588 0 01-3.61 0 2.47 2.47 0 010-3.54l7.12-6.982z"
          }
        )
      ]
    }
  );
}
function O9(e) {
  const t = e.trim().replace(/\/$/, "");
  return t ? /\/api\/v1$/.test(t) ? t : `${t}/api/v1` : "http://localhost:5000/api/v1";
}
function Fle() {
  return "http://localhost:5000";
}
let fs = O9(Fle()), Ys = `${fs}/mcp`, bd = `${fs}/thread`, R_ = `${fs}/health-check`;
function Vle(e) {
  fs = O9(e), Ys = `${fs}/mcp`, bd = `${fs}/thread`, R_ = `${fs}/health-check`;
}
function Hle(e) {
  const t = e.trim();
  if (!(t.startsWith("{") && t.endsWith("}") || t.startsWith("[") && t.endsWith("]"))) return { success: !1, data: e };
  try {
    return { success: !0, data: JSON.parse(e) };
  } catch {
    return { success: !1, data: e };
  }
}
function Wle(e) {
  try {
    navigator.clipboard?.writeText(e);
  } catch {
  }
}
const id = C.memo(function({
  data: t,
  name: n,
  initialExpandDepth: r = 2,
  framed: i = !1,
  expandAll: o = !1
}) {
  const s = C.useMemo(() => {
    if (typeof t == "string") {
      const c = Hle(t);
      return c.success ? c.data : t;
    }
    return t;
  }, [t]), a = C.useMemo(() => {
    try {
      return typeof s == "string" ? s : JSON.stringify(s, null, 2);
    } catch {
      return String(s);
    }
  }, [s]);
  return /* @__PURE__ */ v.jsxs(
    "div",
    {
      className: bc(
        "text-sm transition-all duration-300 w-full",
        i && "rounded-lg border bg-card overflow-hidden"
      ),
      children: [
        i && /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 px-3 py-2 border-b bg-muted/40", children: [
          /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground font-medium", children: n ?? "JSON" }),
          /* @__PURE__ */ v.jsx("div", { className: "flex-1" }),
          /* @__PURE__ */ v.jsx(
            "button",
            {
              className: "text-xs px-2 py-1 rounded border bg-background hover:bg-secondary",
              onClick: () => Wle(a),
              title: "Copy JSON",
              children: "Copy"
            }
          )
        ] }),
        /* @__PURE__ */ v.jsx("div", { className: bc(i ? "px-3 py-3" : ""), children: /* @__PURE__ */ v.jsx(
          qle,
          {
            data: s,
            name: n,
            depth: 0,
            initialExpandDepth: r,
            expandAll: o
          }
        ) })
      ]
    }
  );
}), qle = C.memo(function e({
  data: t,
  name: n,
  depth: r,
  initialExpandDepth: i,
  expandAll: o = !1
}) {
  const a = ((m) => m === null ? "null" : Array.isArray(m) ? "array" : typeof m == "object" ? "object" : typeof m == "string" ? "string" : typeof m == "number" ? "number" : typeof m == "boolean" ? "boolean" : "undefined")(t), [c, u] = C.useState(
    a === "string" ? !!o : o ? !0 : r < i
  );
  C.useEffect(() => {
    u(
      a === "string" ? !!o : o ? !0 : r < i
    );
  }, [a, o, i, r, t]);
  const f = {
    key: "text-muted-foreground",
    string: "text-emerald-400",
    number: "text-sky-400",
    boolean: "text-amber-400",
    null: "text-fuchsia-400",
    undefined: "text-zinc-400",
    punct: "text-muted-foreground"
  }, h = n ? /* @__PURE__ */ v.jsxs("span", { className: bc("mr-1", f.key), children: [
    n,
    ":"
  ] }) : null;
  if (a === "object" || a === "array") {
    const m = a === "array", g = m ? t : Object.entries(t), b = g.length === 0, x = m ? "[" : "{", w = m ? "]" : "}";
    return b ? /* @__PURE__ */ v.jsxs("div", { className: "flex items-center", children: [
      h,
      /* @__PURE__ */ v.jsx("span", { className: f.punct, children: m ? "[]" : "{}" })
    ] }) : /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
      /* @__PURE__ */ v.jsxs(
        "div",
        {
          className: "flex items-center gap-1 rounded cursor-pointer hover:bg-input/30 px-1 -mx-1",
          onClick: () => u((S) => !S),
          title: c ? "Collapse" : "Expand",
          children: [
            h,
            c ? /* @__PURE__ */ v.jsx("span", { className: f.punct, children: x }) : /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
              /* @__PURE__ */ v.jsx("span", { className: f.punct, children: m ? "[  ]" : "{  }" }),
              /* @__PURE__ */ v.jsxs("span", { className: "ml-1 text-muted-foreground", children: [
                g.length,
                " ",
                g.length === 1 ? "item" : "items"
              ] })
            ] })
          ]
        }
      ),
      c && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
        /* @__PURE__ */ v.jsx("div", { className: "pl-3 ml-3 border-l border-border/60", children: m ? g.map((S, _) => /* @__PURE__ */ v.jsx("div", { className: "my-1", children: /* @__PURE__ */ v.jsx(
          e,
          {
            data: S,
            name: String(_),
            depth: r + 1,
            initialExpandDepth: i,
            expandAll: o
          }
        ) }, _)) : g.map(([S, _]) => /* @__PURE__ */ v.jsx("div", { className: "my-1", children: /* @__PURE__ */ v.jsx(
          e,
          {
            data: _,
            name: S,
            depth: r + 1,
            initialExpandDepth: i,
            expandAll: o
          }
        ) }, S)) }),
        /* @__PURE__ */ v.jsx("span", { className: bc("mt-0.5", f.punct), children: w })
      ] })
    ] });
  }
  if (a === "string") {
    const m = t, g = 120;
    return m.length > g ? /* @__PURE__ */ v.jsx(
      Gle,
      {
        label: h,
        value: m,
        styles: f,
        max: g,
        initialOpen: o
      }
    ) : /* @__PURE__ */ v.jsxs("div", { className: "flex items-start", children: [
      h,
      /* @__PURE__ */ v.jsxs(
        "pre",
        {
          className: bc(
            f.string,
            "whitespace-pre-wrap break-words"
          ),
          children: [
            '"',
            m,
            '"'
          ]
        }
      )
    ] });
  }
  return /* @__PURE__ */ v.jsxs("div", { className: "flex items-start", children: [
    h,
    a === "number" && /* @__PURE__ */ v.jsx("span", { className: f.number, children: String(t) }),
    a === "boolean" && /* @__PURE__ */ v.jsx("span", { className: f.boolean, children: String(t) }),
    a === "null" && /* @__PURE__ */ v.jsx("span", { className: f.null, children: "null" }),
    a === "undefined" && /* @__PURE__ */ v.jsx("span", { className: f.undefined, children: "undefined" })
  ] });
});
function Gle({
  label: e,
  value: t,
  styles: n,
  max: r,
  initialOpen: i = !1
}) {
  const [o, s] = C.useState(i);
  return /* @__PURE__ */ v.jsxs("div", { className: "flex items-start", children: [
    e,
    /* @__PURE__ */ v.jsx(
      "pre",
      {
        className: bc(
          n.string,
          "whitespace-pre-wrap wrap-break-word cursor-pointer hover:text-green-400"
        ),
        onClick: () => s((a) => !a),
        title: o ? "Collapse" : "Expand",
        children: o ? `"${t}"` : `"${t.slice(0, r)}..."`
      }
    )
  ] });
}
const Kle = {
  "Content-Type": "application/json"
};
let Zle = null;
function Yle() {
  if (typeof window > "u") return null;
  const e = window.__CHATBOT_CONFIG__;
  return !e || typeof e != "object" ? null : e;
}
async function Xle() {
  const e = Yle();
  try {
    const t = e?.getAuthToken;
    if (typeof t == "function") {
      const n = await t();
      if (typeof n == "string" && n.trim()) return n.trim();
    }
  } catch {
  }
  if (typeof e?.authToken == "string" && e.authToken.trim())
    return e.authToken.trim();
  try {
    const n = await window?.Clerk?.session?.getToken?.();
    if (typeof n == "string" && n.trim()) return n.trim();
  } catch {
  }
  try {
    const t = localStorage.getItem("access_token") ?? localStorage.getItem("token") ?? localStorage.getItem("jwt") ?? "";
    return t && t.trim() ? t.trim() : null;
  } catch {
    return null;
  }
}
async function Vc() {
  const e = await Xle();
  return {
    ...Kle,
    ...e ? { Authorization: `Bearer ${e}` } : {}
  };
}
const Jle = async (e, t) => {
  const n = await Vc(), r = await fetch(e, {
    redirect: "follow",
    cache: "no-store",
    ...t,
    headers: {
      ...n,
      ...t?.headers
    }
  });
  if (!r.ok) {
    let i;
    try {
      i = await r.json();
    } catch {
      i = { message: `Request failed with status ${r.status}` };
    }
    const o = new Error(
      i.message || "An error occurred while fetching the data."
    );
    throw Object.assign(o, { info: i, status: r.status }), o;
  }
  return r.json();
}, xh = (e) => typeof e == "string", Qle = (e) => Object(e) === e, ece = (e) => {
  try {
    if (typeof e == "string") {
      const t = e.trim();
      return JSON.parse(t), !0;
    } else if (Qle(e))
      return !0;
    return !1;
  } catch {
    return !1;
  }
}, E5e = () => {
  let e;
  const t = (n, r = 200) => (clearTimeout(e), e = setTimeout(() => n(), r), e);
  return t.clear = () => {
    clearTimeout(e);
  }, t;
};
function P9() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e) => {
    const t = Math.random() * 16 | 0;
    return (e === "x" ? t : t & 3 | 8).toString(16);
  });
}
function tce(e) {
  return e == null ? "unknown error" : typeof e == "string" ? e : e instanceof Error ? e.message : JSON.stringify(e);
}
function D9(e) {
  return {
    map: (t) => Object.fromEntries(
      Object.entries(e).map(([n, r]) => [n, t(r, n)])
    ),
    filter: (t) => Object.fromEntries(
      Object.entries(e).filter(([n, r]) => t(r, n))
    ),
    forEach: (t) => {
      Object.entries(e).forEach(([n, r]) => t(r, n));
    },
    some: (t) => Object.entries(e).some(([n, r]) => t(r, n)),
    every: (t) => Object.entries(e).every(([n, r]) => t(r, n)),
    find(t) {
      return Object.entries(e).find(([n, r]) => t(r, n))?.[1];
    },
    getByPath(t) {
      let n = e;
      return t.find((r) => (n = n?.[r], !n)), n;
    },
    setByPath(t, n) {
      return t.reduce((r, i, o) => o == t.length - 1 ? (r[i] = n, r) : (r[i] ??= {}, r[i]), e), e;
    }
  };
}
function _5e(e, t) {
  let n = e, r = 1;
  for (; t.includes(n); ) {
    const i = e.replace(/\d+$/, "");
    if (e !== i) {
      const s = parseInt(e.match(/\d+$/)?.[0] || "0");
      n = i + (s + r);
    } else
      n = i + r;
    r++;
  }
  return n;
}
function HI(e) {
  return e ? e.startsWith("user_") ? e.replace("user_", "") : e : null;
}
const Ab = (e, t) => (Vt.error(`${e?.name || "Error"}`, {
  description: /* @__PURE__ */ v.jsx("div", { className: "my-4 max-h-[340px] overflow-y-auto", children: /* @__PURE__ */ v.jsx(id, { data: tce(e) }) }),
  id: t
}), e), I9 = C.createContext(null);
function nce({ children: e, appStore: t, ...n }) {
  return /* @__PURE__ */ v.jsx(I9.Provider, { ...n, value: t, children: e });
}
function la() {
  const e = C.useContext(I9);
  if (!e)
    throw new Error("useAppStore must be used within an AppProvider");
  return e;
}
const j9 = 0, z9 = 1, L9 = 2, WI = 3;
var qI = Object.prototype.hasOwnProperty;
function O_(e, t) {
  var n, r;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((r = e.length) === t.length)
        for (; r-- && O_(e[r], t[r]); ) ;
      return r === -1;
    }
    if (!n || typeof e == "object") {
      r = 0;
      for (n in e)
        if (qI.call(e, n) && ++r && !qI.call(t, n) || !(n in t) || !O_(e[n], t[n])) return !1;
      return Object.keys(t).length === r;
    }
  }
  return e !== e && t !== t;
}
const Ga = /* @__PURE__ */ new WeakMap(), Za = () => {
}, yi = (
  /*#__NOINLINE__*/
  Za()
), P_ = Object, Qt = (e) => e === yi, Ks = (e) => typeof e == "function", Pc = (e, t) => ({
  ...e,
  ...t
}), B9 = (e) => Ks(e.then), rC = {}, Gv = {}, kM = "undefined", iy = typeof window != kM, D_ = typeof document != kM, rce = iy && "Deno" in window, ice = () => iy && typeof window.requestAnimationFrame != kM, $9 = (e, t) => {
  const n = Ga.get(e);
  return [
    // Getter
    () => !Qt(t) && e.get(t) || rC,
    // Setter
    (r) => {
      if (!Qt(t)) {
        const i = e.get(t);
        t in Gv || (Gv[t] = i), n[5](t, Pc(i, r), i || rC);
      }
    },
    // Subscriber
    n[6],
    // Get server cache snapshot
    () => !Qt(t) && t in Gv ? Gv[t] : !Qt(t) && e.get(t) || rC
  ];
};
let I_ = !0;
const oce = () => I_, [j_, z_] = iy && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  Za,
  Za
], sce = () => {
  const e = D_ && document.visibilityState;
  return Qt(e) || e !== "hidden";
}, ace = (e) => (D_ && document.addEventListener("visibilitychange", e), j_("focus", e), () => {
  D_ && document.removeEventListener("visibilitychange", e), z_("focus", e);
}), lce = (e) => {
  const t = () => {
    I_ = !0, e();
  }, n = () => {
    I_ = !1;
  };
  return j_("online", t), j_("offline", n), () => {
    z_("online", t), z_("offline", n);
  };
}, cce = {
  isOnline: oce,
  isVisible: sce
}, uce = {
  initFocus: ace,
  initReconnect: lce
}, GI = !Ne.useId, oh = !iy || rce, dce = (e) => ice() ? window.requestAnimationFrame(e) : setTimeout(e, 1), iC = oh ? C.useEffect : C.useLayoutEffect, oC = typeof navigator < "u" && navigator.connection, KI = !oh && oC && ([
  "slow-2g",
  "2g"
].includes(oC.effectiveType) || oC.saveData), Kv = /* @__PURE__ */ new WeakMap(), fce = (e) => P_.prototype.toString.call(e), sC = (e, t) => e === `[object ${t}]`;
let hce = 0;
const L_ = (e) => {
  const t = typeof e, n = fce(e), r = sC(n, "Date"), i = sC(n, "RegExp"), o = sC(n, "Object");
  let s, a;
  if (P_(e) === e && !r && !i) {
    if (s = Kv.get(e), s) return s;
    if (s = ++hce + "~", Kv.set(e, s), Array.isArray(e)) {
      for (s = "@", a = 0; a < e.length; a++)
        s += L_(e[a]) + ",";
      Kv.set(e, s);
    }
    if (o) {
      s = "#";
      const c = P_.keys(e).sort();
      for (; !Qt(a = c.pop()); )
        Qt(e[a]) || (s += a + ":" + L_(e[a]) + ",");
      Kv.set(e, s);
    }
  } else
    s = r ? e.toJSON() : t == "symbol" ? e.toString() : t == "string" ? JSON.stringify(e) : "" + e;
  return s;
}, CM = (e) => {
  if (Ks(e))
    try {
      e = e();
    } catch {
      e = "";
    }
  const t = e;
  return e = typeof e == "string" ? e : (Array.isArray(e) ? e.length : e) ? L_(e) : "", [
    e,
    t
  ];
};
let pce = 0;
const B_ = () => ++pce;
async function U9(...e) {
  const [t, n, r, i] = e, o = Pc({
    populateCache: !0,
    throwOnError: !0
  }, typeof i == "boolean" ? {
    revalidate: i
  } : i || {});
  let s = o.populateCache;
  const a = o.rollbackOnError;
  let c = o.optimisticData;
  const u = (m) => typeof a == "function" ? a(m) : a !== !1, f = o.throwOnError;
  if (Ks(n)) {
    const m = n, g = [], b = t.keys();
    for (const x of b)
      // Skip the special useSWRInfinite and useSWRSubscription keys.
      !/^\$(inf|sub)\$/.test(x) && m(t.get(x)._k) && g.push(x);
    return Promise.all(g.map(h));
  }
  return h(n);
  async function h(m) {
    const [g] = CM(m);
    if (!g) return;
    const [b, x] = $9(t, g), [w, S, _, M] = Ga.get(t), N = () => {
      const ie = w[g];
      return (Ks(o.revalidate) ? o.revalidate(b().data, m) : o.revalidate !== !1) && (delete _[g], delete M[g], ie && ie[0]) ? ie[0](L9).then(() => b().data) : b().data;
    };
    if (e.length < 3)
      return N();
    let D = r, j, O = !1;
    const L = B_();
    S[g] = [
      L,
      0
    ];
    const U = !Qt(c), B = b(), G = B.data, Y = B._c, he = Qt(Y) ? G : Y;
    if (U && (c = Ks(c) ? c(he, G) : c, x({
      data: c,
      _c: he
    })), Ks(D))
      try {
        D = D(he);
      } catch (ie) {
        j = ie, O = !0;
      }
    if (D && B9(D))
      if (D = await D.catch((ie) => {
        j = ie, O = !0;
      }), L !== S[g][0]) {
        if (O) throw j;
        return D;
      } else O && U && u(j) && (s = !0, x({
        data: he,
        _c: yi
      }));
    if (s && !O)
      if (Ks(s)) {
        const ie = s(D, he);
        x({
          data: ie,
          error: yi,
          _c: yi
        });
      } else
        x({
          data: D,
          error: yi,
          _c: yi
        });
    if (S[g][1] = B_(), Promise.resolve(N()).then(() => {
      x({
        _c: yi
      });
    }), O) {
      if (f) throw j;
      return;
    }
    return D;
  }
}
const ZI = (e, t) => {
  for (const n in e)
    e[n][0] && e[n][0](t);
}, mce = (e, t) => {
  if (!Ga.has(e)) {
    const n = Pc(uce, t), r = /* @__PURE__ */ Object.create(null), i = U9.bind(yi, e);
    let o = Za;
    const s = /* @__PURE__ */ Object.create(null), a = (f, h) => {
      const m = s[f] || [];
      return s[f] = m, m.push(h), () => m.splice(m.indexOf(h), 1);
    }, c = (f, h, m) => {
      e.set(f, h);
      const g = s[f];
      if (g)
        for (const b of g)
          b(h, m);
    }, u = () => {
      if (!Ga.has(e) && (Ga.set(e, [
        r,
        /* @__PURE__ */ Object.create(null),
        /* @__PURE__ */ Object.create(null),
        /* @__PURE__ */ Object.create(null),
        i,
        c,
        a
      ]), !oh)) {
        const f = n.initFocus(setTimeout.bind(yi, ZI.bind(yi, r, j9))), h = n.initReconnect(setTimeout.bind(yi, ZI.bind(yi, r, z9)));
        o = () => {
          f && f(), h && h(), Ga.delete(e);
        };
      }
    };
    return u(), [
      e,
      i,
      u,
      o
    ];
  }
  return [
    e,
    Ga.get(e)[4]
  ];
}, gce = (e, t, n, r, i) => {
  const o = n.errorRetryCount, s = i.retryCount, a = ~~((Math.random() + 0.5) * (1 << (s < 8 ? s : 8))) * n.errorRetryInterval;
  !Qt(o) && s > o || setTimeout(r, a, i);
}, yce = O_, [F9, $_] = mce(/* @__PURE__ */ new Map()), vce = Pc(
  {
    // events
    onLoadingSlow: Za,
    onSuccess: Za,
    onError: Za,
    onErrorRetry: gce,
    onDiscarded: Za,
    // switches
    revalidateOnFocus: !0,
    revalidateOnReconnect: !0,
    revalidateIfStale: !0,
    shouldRetryOnError: !0,
    // timeouts
    errorRetryInterval: KI ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: KI ? 5e3 : 3e3,
    // providers
    compare: yce,
    isPaused: () => !1,
    cache: F9,
    mutate: $_,
    fallback: {}
  },
  // use web preset by default
  cce
), bce = (e, t) => {
  const n = Pc(e, t);
  if (t) {
    const { use: r, fallback: i } = e, { use: o, fallback: s } = t;
    r && o && (n.use = r.concat(o)), i && s && (n.fallback = Pc(i, s));
  }
  return n;
}, xce = C.createContext({}), wce = "$inf$", V9 = iy && window.__SWR_DEVTOOLS_USE__, Sce = V9 ? window.__SWR_DEVTOOLS_USE__ : [], kce = () => {
  V9 && (window.__SWR_DEVTOOLS_REACT__ = Ne);
}, Cce = (e) => Ks(e[1]) ? [
  e[0],
  e[1],
  e[2] || {}
] : [
  e[0],
  null,
  (e[1] === null ? e[2] : e[1]) || {}
], H9 = () => {
  const e = C.useContext(xce);
  return C.useMemo(() => Pc(vce, e), [
    e
  ]);
}, Ece = (e) => (t, n, r) => e(t, n && ((...o) => {
  const [s] = CM(t), [, , , a] = Ga.get(F9);
  if (s.startsWith(wce))
    return n(...o);
  const c = a[s];
  return Qt(c) ? n(...o) : (delete a[s], c);
}), r), _ce = Sce.concat(Ece), Tce = (e) => function(...n) {
  const r = H9(), [i, o, s] = Cce(n), a = bce(r, s);
  let c = e;
  const { use: u } = a, f = (u || []).concat(_ce);
  for (let h = f.length; h--; )
    c = f[h](c);
  return c(i, o || a.fetcher || null, a);
}, Ace = (e, t, n) => {
  const r = t[e] || (t[e] = []);
  return r.push(n), () => {
    const i = r.indexOf(n);
    i >= 0 && (r[i] = r[r.length - 1], r.pop());
  };
};
kce();
const aC = Ne.use || // This extra generic is to avoid TypeScript mixing up the generic and JSX sytax
// and emitting an error.
// We assume that this is only for the `use(thenable)` case, not `use(context)`.
// https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45
((e) => {
  switch (e.status) {
    case "pending":
      throw e;
    case "fulfilled":
      return e.value;
    case "rejected":
      throw e.reason;
    default:
      throw e.status = "pending", e.then((t) => {
        e.status = "fulfilled", e.value = t;
      }, (t) => {
        e.status = "rejected", e.reason = t;
      }), e;
  }
}), lC = {
  dedupe: !0
}, YI = Promise.resolve(yi), Mce = () => Za, Nce = (e, t, n) => {
  const { cache: r, compare: i, suspense: o, fallbackData: s, revalidateOnMount: a, revalidateIfStale: c, refreshInterval: u, refreshWhenHidden: f, refreshWhenOffline: h, keepPreviousData: m, strictServerPrefetchWarning: g } = n, [b, x, w, S] = Ga.get(r), [_, M] = CM(e), N = C.useRef(!1), D = C.useRef(!1), j = C.useRef(_), O = C.useRef(t), L = C.useRef(n), U = () => L.current, B = () => U().isVisible() && U().isOnline(), [G, Y, he, ie] = $9(r, _), ne = C.useRef({}).current, H = Qt(s) ? Qt(n.fallback) ? yi : n.fallback[_] : s, Q = (kt, Wt) => {
    for (const wt in ne) {
      const Yt = wt;
      if (Yt === "data") {
        if (!i(kt[Yt], Wt[Yt]) && (!Qt(kt[Yt]) || !i(re, Wt[Yt])))
          return !1;
      } else if (Wt[Yt] !== kt[Yt])
        return !1;
    }
    return !0;
  }, X = !N.current, Se = C.useMemo(() => {
    const kt = G(), Wt = ie(), wt = (ln) => {
      const In = Pc(ln);
      return delete In._k, (() => {
        if (!_ || !t || U().isPaused()) return !1;
        if (X && !Qt(a)) return a;
        const gt = Qt(H) ? In.data : H;
        return Qt(gt) || c;
      })() ? {
        isValidating: !0,
        isLoading: !0,
        ...In
      } : In;
    }, Yt = wt(kt), Mn = kt === Wt ? Yt : wt(Wt);
    let Rt = Yt;
    return [
      () => {
        const ln = wt(G());
        return Q(ln, Rt) ? (Rt.data = ln.data, Rt.isLoading = ln.isLoading, Rt.isValidating = ln.isValidating, Rt.error = ln.error, Rt) : (Rt = ln, ln);
      },
      () => Mn
    ];
  }, [
    r,
    _
  ]), W = fh.useSyncExternalStore(C.useCallback(
    (kt) => he(_, (Wt, wt) => {
      Q(wt, Wt) || kt();
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      r,
      _
    ]
  ), Se[0], Se[1]), Z = b[_] && b[_].length > 0, pe = W.data, F = Qt(pe) ? H && B9(H) ? aC(H) : H : pe, ee = W.error, ge = C.useRef(F), re = m ? Qt(pe) ? Qt(ge.current) ? F : ge.current : pe : F, J = _ && Qt(F), xe = C.useRef(null);
  !oh && // getServerSnapshot is only called during hydration
  // eslint-disable-next-line react-hooks/rules-of-hooks
  fh.useSyncExternalStore(Mce, () => (xe.current = !1, xe), () => (xe.current = !0, xe));
  const be = xe.current;
  g && be && !o && J && console.warn(`Missing pre-initiated data for serialized key "${_}" during server-side rendering. Data fetching should be initiated on the server and provided to SWR via fallback data. You can set "strictServerPrefetchWarning: false" to disable this warning.`);
  const Ae = !_ || !t || U().isPaused() || Z && !Qt(ee) ? !1 : X && !Qt(a) ? a : o ? Qt(F) ? !1 : c : Qt(F) || c, nt = Qt(W.isValidating) ? Ae : W.isValidating, Ge = Qt(W.isLoading) ? Ae : W.isLoading, rt = C.useCallback(
    async (kt) => {
      const Wt = O.current;
      if (!_ || !Wt || D.current || U().isPaused())
        return !1;
      let wt, Yt, Mn = !0;
      const Rt = kt || {}, ln = !w[_] || !Rt.dedupe, In = () => GI ? !D.current && _ === j.current && N.current : _ === j.current, Nn = {
        isValidating: !1,
        isLoading: !1
      }, gt = () => {
        Y(Nn);
      }, ke = () => {
        const He = w[_];
        He && He[1] === Yt && delete w[_];
      }, De = {
        isValidating: !0
      };
      Qt(G().data) && (De.isLoading = !0);
      try {
        if (ln && (Y(De), n.loadingTimeout && Qt(G().data) && setTimeout(() => {
          Mn && In() && U().onLoadingSlow(_, n);
        }, n.loadingTimeout), w[_] = [
          Wt(M),
          B_()
        ]), [wt, Yt] = w[_], wt = await wt, ln && setTimeout(ke, n.dedupingInterval), !w[_] || w[_][1] !== Yt)
          return ln && In() && U().onDiscarded(_), !1;
        Nn.error = yi;
        const He = x[_];
        if (!Qt(He) && // case 1
        (Yt <= He[0] || // case 2
        Yt <= He[1] || // case 3
        He[1] === 0))
          return gt(), ln && In() && U().onDiscarded(_), !1;
        const tt = G().data;
        Nn.data = i(tt, wt) ? tt : wt, ln && In() && U().onSuccess(wt, _, n);
      } catch (He) {
        ke();
        const tt = U(), { shouldRetryOnError: xt } = tt;
        tt.isPaused() || (Nn.error = He, ln && In() && (tt.onError(He, _, tt), (xt === !0 || Ks(xt) && xt(He)) && (!U().revalidateOnFocus || !U().revalidateOnReconnect || B()) && tt.onErrorRetry(He, _, tt, (Et) => {
          const hn = b[_];
          hn && hn[0] && hn[0](WI, Et);
        }, {
          retryCount: (Rt.retryCount || 0) + 1,
          dedupe: !0
        })));
      }
      return Mn = !1, gt(), !0;
    },
    // `setState` is immutable, and `eventsCallback`, `fnArg`, and
    // `keyValidating` are depending on `key`, so we can exclude them from
    // the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // `useSWR('key', () => fetch('/api/'), { suspense: true })`
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      _,
      r
    ]
  ), Tt = C.useCallback(
    // Use callback to make sure `keyRef.current` returns latest result every time
    (...kt) => U9(r, j.current, ...kt),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (iC(() => {
    O.current = t, L.current = n, Qt(pe) || (ge.current = pe);
  }), iC(() => {
    if (!_) return;
    const kt = rt.bind(yi, lC);
    let Wt = 0;
    U().revalidateOnFocus && (Wt = Date.now() + U().focusThrottleInterval);
    const Yt = Ace(_, b, (Mn, Rt = {}) => {
      if (Mn == j9) {
        const ln = Date.now();
        U().revalidateOnFocus && ln > Wt && B() && (Wt = ln + U().focusThrottleInterval, kt());
      } else if (Mn == z9)
        U().revalidateOnReconnect && B() && kt();
      else {
        if (Mn == L9)
          return rt();
        if (Mn == WI)
          return rt(Rt);
      }
    });
    return D.current = !1, j.current = _, N.current = !0, Y({
      _k: M
    }), Ae && (w[_] || (Qt(F) || oh ? kt() : dce(kt))), () => {
      D.current = !0, Yt();
    };
  }, [
    _
  ]), iC(() => {
    let kt;
    function Wt() {
      const Yt = Ks(u) ? u(G().data) : u;
      Yt && kt !== -1 && (kt = setTimeout(wt, Yt));
    }
    function wt() {
      !G().error && (f || U().isVisible()) && (h || U().isOnline()) ? rt(lC).then(Wt) : Wt();
    }
    return Wt(), () => {
      kt && (clearTimeout(kt), kt = -1);
    };
  }, [
    u,
    f,
    h,
    _
  ]), C.useDebugValue(re), o) {
    if (!GI && oh && J)
      throw new Error("Fallback data is required when using Suspense in SSR.");
    J && (O.current = t, L.current = n, D.current = !1);
    const kt = S[_], Wt = !Qt(kt) && J ? Tt(kt) : YI;
    if (aC(Wt), !Qt(ee) && J)
      throw ee;
    const wt = J ? rt(lC) : YI;
    !Qt(re) && J && (wt.status = "fulfilled", wt.value = !0), aC(wt);
  }
  return {
    mutate: Tt,
    get data() {
      return ne.data = !0, re;
    },
    get error() {
      return ne.error = !0, ee;
    },
    get isValidating() {
      return ne.isValidating = !0, nt;
    },
    get isLoading() {
      return ne.isLoading = !0, Ge;
    }
  };
}, Rce = Tce(Nce);
function W9(e) {
  const t = la(), n = async (i, o) => {
    const s = await Jle(i, o);
    return Array.isArray(s) ? s : s && Array.isArray(s.servers) ? s.servers : [];
  }, r = Rce(`${Ys}/list`, n, {
    revalidateOnFocus: !1,
    errorRetryCount: 0,
    focusThrottleInterval: 1e3 * 60 * 5,
    // ensure returned data is an array for consumers
    fallbackData: [],
    onError: Ab,
    onSuccess: (i) => {
      if (!Array.isArray(i)) {
        t.chatbotServerStore.mcpServerList.value = [];
        return;
      }
      const o = new Set(i.map((s) => String(s.id)));
      t.chatbotServerStore.mcpServerList.value = i, t.chatbotServerStore.allowedMcpServers.value = D9(t.chatbotServerStore.allowedMcpServers.value || {}).filter(
        (s, a) => o.has(String(a))
      );
    },
    ...e
  });
  return C.useEffect(() => {
    (async () => {
      try {
        const i = await Vc();
        t.chatbotServerStore.loadMcpServersInBackground({
          token: null,
          baseUrl: "",
          headers: i
          // Pass full headers including auth
        });
      } catch (i) {
        console.warn("Failed to get auth headers for worker:", i), t.chatbotServerStore.loadMcpServersInBackground();
      }
    })();
  }, [t.chatbotServerStore]), r;
}
function q9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card",
      className: lt(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        e
      ),
      ...t
    }
  );
}
function G9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-header",
      className: lt(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        e
      ),
      ...t
    }
  );
}
function Oce({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-title",
      className: lt("leading-none font-semibold", e),
      ...t
    }
  );
}
function Pce({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-description",
      className: lt("text-muted-foreground text-sm", e),
      ...t
    }
  );
}
function K9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-content",
      className: lt("px-6", e),
      ...t
    }
  );
}
function EM({ className: e, type: t, ...n }) {
  return /* @__PURE__ */ v.jsx(
    "input",
    {
      type: t,
      "data-slot": "input",
      className: lt(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-sm border bg-transparent px-3 py-1 text-xs shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50",
        "focus:border-input focus-visible:border-input",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        e
      ),
      ...n
    }
  );
}
var Dce = "Separator", XI = "horizontal", Ice = ["horizontal", "vertical"], _M = C.forwardRef((e, t) => {
  const { decorative: n, orientation: r = XI, ...i } = e, o = jce(r) ? r : XI, a = n ? { role: "none" } : { "aria-orientation": o === "vertical" ? o : void 0, role: "separator" };
  return /* @__PURE__ */ v.jsx(
    ry.div,
    {
      "data-orientation": o,
      ...a,
      ...i,
      ref: t
    }
  );
});
_M.displayName = Dce;
function jce(e) {
  return Ice.includes(e);
}
var zce = _M;
function Mb({
  className: e,
  orientation: t = "horizontal",
  decorative: n = !0,
  ...r
}) {
  return /* @__PURE__ */ v.jsx(
    zce,
    {
      "data-slot": "separator",
      decorative: n,
      orientation: t,
      className: lt(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        e
      ),
      ...r
    }
  );
}
const Lce = (e) => {
  if (!e) return !0;
  const t = e.properties || e;
  return Object.keys(t).length === 0;
}, Bce = ({
  tool: e,
  children: t,
  serverId: n,
  onUpdate: r
}) => /* @__PURE__ */ v.jsxs(Hh, { children: [
  /* @__PURE__ */ v.jsx(J$, { asChild: !0, children: t }),
  /* @__PURE__ */ v.jsx(Q$, { children: /* @__PURE__ */ v.jsx(Wh, { className: "sm:max-w-[800px] fixed p-10 overflow-hidden", children: /* @__PURE__ */ v.jsx(
    $ce,
    {
      onUpdate: r,
      tool: e,
      serverId: n
    }
  ) }) })
] });
function $ce({
  tool: e,
  title: t
  // serverId,
  // onUpdate,
}) {
  return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col overflow-y-auto h-[70vh]", children: [
    /* @__PURE__ */ v.jsxs("div", { className: "space-y-6 pb-4", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3", children: [
        /* @__PURE__ */ v.jsx("div", { className: "shrink-0 w-8 h-8 rounded-lg bg-primary/10 flex items-center justify-center", children: /* @__PURE__ */ v.jsx(
          "svg",
          {
            className: "w-4 h-4 text-primary",
            fill: "none",
            strokeWidth: "2",
            stroke: "currentColor",
            viewBox: "0 0 24 24",
            children: /* @__PURE__ */ v.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M11.42 15.17L17.25 21A2.652 2.652 0 0021 17.25l-5.877-5.877M11.42 15.17l2.496-3.03c.317-.384.74-.626 1.208-.766M11.42 15.17l-4.655 5.653a2.548 2.548 0 11-3.586-3.586l6.837-5.63m5.108-.233c.55-.164 1.163-.188 1.743-.14a4.5 4.5 0 004.486-6.336l-3.276 3.277a3.004 3.004 0 01-2.25-2.25l3.276-3.276a4.5 4.5 0 00-6.336 4.486c.091 1.076-.071 2.264-.904 2.95l-.102.085m-1.745 1.437L5.909 7.5H4.5L2.25 3.75l1.5-1.5L7.5 4.5v1.409l4.26 4.26m-1.745 1.437l1.745-1.437m6.615 8.206L15.75 15.75M4.867 19.125h.008v.008h-.008v-.008z" })
          }
        ) }),
        /* @__PURE__ */ v.jsx(qh, { className: "text-xl font-normal tracking-tight", children: t || e.name })
      ] }),
      /* @__PURE__ */ v.jsx("div", { className: "space-y-2", children: /* @__PURE__ */ v.jsx(t9, { className: "text-sm leading-relaxed text-foreground/90 whitespace-pre-wrap", children: e.description }) })
    ] }),
    /* @__PURE__ */ v.jsx(Mb, { className: "my-6" }),
    /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-2 mb-3", children: /* @__PURE__ */ v.jsx("h5", { className: "text-sm font-normal text-foreground/90", children: "Input Schema" }) }),
    e.inputSchema ? /* @__PURE__ */ v.jsx("div", { className: "overflow-y-auto max-h-[40vh] space-y-3", children: Lce(e.inputSchema) ? /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground", children: "No schema properties available" }) : /* @__PURE__ */ v.jsx(id, { data: e.inputSchema?.properties || e.inputSchema }) }) : /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground", children: "No schema properties available" }),
    /* @__PURE__ */ v.jsx("div", { className: "absolute left-0 right-0 bottom-0 h-12 bg-linear-to-t from-background to-transparent pointer-events-none z-10" })
  ] });
}
const Uce = C.memo(
  ({ tools: e, serverId: t, searchQuery: n = "" }) => {
    const r = C.useMemo(() => {
      if (!n.trim()) return e;
      const i = n.toLowerCase();
      return e.filter(
        (o) => o.name.toLowerCase().includes(i) || o.description?.toLowerCase().includes(i)
      );
    }, [e, n]);
    return /* @__PURE__ */ v.jsx("div", { className: "space-y-2 pr-2", children: r.length > 0 ? r.map((i) => /* @__PURE__ */ v.jsxs(
      "div",
      {
        className: "flex items-start gap-2 bg-secondary rounded-md p-2 hover:bg-input transition-colors",
        children: [
          /* @__PURE__ */ v.jsx(Bce, { tool: i, serverId: t, children: /* @__PURE__ */ v.jsxs("div", { className: "flex-1 min-w-0 cursor-pointer", children: [
            /* @__PURE__ */ v.jsx("p", { className: "font-medium text-sm mb-1 truncate", children: i.name }),
            /* @__PURE__ */ v.jsx("p", { className: "text-xs text-muted-foreground line-clamp-1", children: i.description })
          ] }) }),
          /* @__PURE__ */ v.jsx("div", { className: "flex items-center px-1 justify-center self-stretch", children: /* @__PURE__ */ v.jsx(Vg, { size: 16 }) })
        ]
      },
      i.name
    )) : /* @__PURE__ */ v.jsxs("div", { className: "text-center py-6 text-sm text-muted-foreground", children: [
      'No tools found matching "',
      n,
      '"'
    ] }) });
  }
), Fce = QA(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive: "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function Z9({
  className: e,
  variant: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "alert",
      role: "alert",
      className: lt(Fce({ variant: t }), e),
      ...n
    }
  );
}
function Y9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "alert-title",
      className: lt(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        e
      ),
      ...t
    }
  );
}
function X9({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "alert-description",
      className: lt(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        e
      ),
      ...t
    }
  );
}
const J9 = C.memo(({ error: e }) => /* @__PURE__ */ v.jsx("div", { className: "px-6 pb-2", children: /* @__PURE__ */ v.jsxs(Z9, { variant: "destructive", className: "border-destructive", children: [
  /* @__PURE__ */ v.jsx(Y9, { children: "Error" }),
  /* @__PURE__ */ v.jsx(X9, { className: "whitespace-pre-wrap wrap-break-word", children: e })
] }) }));
J9.displayName = "ErrorAlert";
function Vce({ className: e }) {
  return /* @__PURE__ */ v.jsx(
    "svg",
    {
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      className: e,
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      "aria-hidden": "true",
      children: /* @__PURE__ */ v.jsx(
        "path",
        {
          d: "M15.6729 3.91287C16.8918 2.69392 18.8682 2.69392 20.0871 3.91287C21.3061 5.13182 21.3061 7.10813 20.0871 8.32708L14.1499 14.2643C13.3849 15.0293 12.3925 15.5255 11.3215 15.6785L9.14142 15.9899C8.82983 16.0344 8.51546 15.9297 8.29289 15.7071C8.07033 15.4845 7.96554 15.1701 8.01005 14.8586L8.32149 12.6785C8.47449 11.6075 8.97072 10.615 9.7357 9.85006L15.6729 3.91287ZM18.6729 5.32708C18.235 4.88918 17.525 4.88918 17.0871 5.32708L11.1499 11.2643C10.6909 11.7233 10.3932 12.3187 10.3014 12.9613L10.1785 13.8215L11.0386 13.6986C11.6812 13.6068 12.2767 13.3091 12.7357 12.8501L18.6729 6.91287C19.1108 6.47497 19.1108 5.76499 18.6729 5.32708ZM11 3.99929C11.0004 4.55157 10.5531 4.99963 10.0008 5.00007C9.00227 5.00084 8.29769 5.00827 7.74651 5.06064C7.20685 5.11191 6.88488 5.20117 6.63803 5.32695C6.07354 5.61457 5.6146 6.07351 5.32698 6.63799C5.19279 6.90135 5.10062 7.24904 5.05118 7.8542C5.00078 8.47105 5 9.26336 5 10.4V13.6C5 14.7366 5.00078 15.5289 5.05118 16.1457C5.10062 16.7509 5.19279 17.0986 5.32698 17.3619C5.6146 17.9264 6.07354 18.3854 6.63803 18.673C6.90138 18.8072 7.24907 18.8993 7.85424 18.9488C8.47108 18.9992 9.26339 19 10.4 19H13.6C14.7366 19 15.5289 18.9992 16.1458 18.9488C16.7509 18.8993 17.0986 18.8072 17.362 18.673C17.9265 18.3854 18.3854 17.9264 18.673 17.3619C18.7988 17.1151 18.8881 16.7931 18.9393 16.2535C18.9917 15.7023 18.9991 14.9977 18.9999 13.9992C19.0003 13.4469 19.4484 12.9995 20.0007 13C20.553 13.0004 21.0003 13.4485 20.9999 14.0007C20.9991 14.9789 20.9932 15.7808 20.9304 16.4426C20.8664 17.116 20.7385 17.7136 20.455 18.2699C19.9757 19.2107 19.2108 19.9756 18.27 20.455C17.6777 20.7568 17.0375 20.8826 16.3086 20.9421C15.6008 21 14.7266 21 13.6428 21H10.3572C9.27339 21 8.39925 21 7.69138 20.9421C6.96253 20.8826 6.32234 20.7568 5.73005 20.455C4.78924 19.9756 4.02433 19.2107 3.54497 18.2699C3.24318 17.6776 3.11737 17.0374 3.05782 16.3086C2.99998 15.6007 2.99999 14.7266 3 13.6428V10.3572C2.99999 9.27337 2.99998 8.39922 3.05782 7.69134C3.11737 6.96249 3.24318 6.3223 3.54497 5.73001C4.02433 4.7892 4.78924 4.0243 5.73005 3.54493C6.28633 3.26149 6.88399 3.13358 7.55735 3.06961C8.21919 3.00673 9.02103 3.00083 9.99922 3.00007C10.5515 2.99964 10.9996 3.447 11 3.99929Z",
          fill: "currentColor"
        }
      )
    }
  );
}
function ai(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function ol(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function U_({
  pathname: e = "/",
  search: t = "",
  hash: n = ""
}) {
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e;
}
function TM(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && (t.hash = e.substring(n), e = e.substring(0, n));
    let r = e.indexOf("?");
    r >= 0 && (t.search = e.substring(r), e = e.substring(0, r)), e && (t.pathname = e);
  }
  return t;
}
function Q9(e, t, n = "/") {
  return Hce(e, t, n, !1);
}
function Hce(e, t, n, r) {
  let i = typeof t == "string" ? TM(t) : t, o = Dc(i.pathname || "/", n);
  if (o == null)
    return null;
  let s = eU(e);
  Wce(s);
  let a = null;
  for (let c = 0; a == null && c < s.length; ++c) {
    let u = nue(o);
    a = eue(
      s[c],
      u,
      r
    );
  }
  return a;
}
function eU(e, t = [], n = [], r = "", i = !1) {
  let o = (s, a, c = i, u) => {
    let f = {
      relativePath: u === void 0 ? s.path || "" : u,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: a,
      route: s
    };
    if (f.relativePath.startsWith("/")) {
      if (!f.relativePath.startsWith(r) && c)
        return;
      ai(
        f.relativePath.startsWith(r),
        `Absolute route path "${f.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      ), f.relativePath = f.relativePath.slice(r.length);
    }
    let h = Xa([r, f.relativePath]), m = n.concat(f);
    s.children && s.children.length > 0 && (ai(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      s.index !== !0,
      `Index routes must not have child routes. Please remove all child routes from route path "${h}".`
    ), eU(
      s.children,
      t,
      m,
      h,
      c
    )), !(s.path == null && !s.index) && t.push({
      path: h,
      score: Jce(h, s.index),
      routesMeta: m
    });
  };
  return e.forEach((s, a) => {
    if (s.path === "" || !s.path?.includes("?"))
      o(s, a);
    else
      for (let c of tU(s.path))
        o(s, a, !0, c);
  }), t;
}
function tU(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, "");
  if (r.length === 0)
    return i ? [o, ""] : [o];
  let s = tU(r.join("/")), a = [];
  return a.push(
    ...s.map(
      (c) => c === "" ? o : [o, c].join("/")
    )
  ), i && a.push(...s), a.map(
    (c) => e.startsWith("/") && c === "" ? "/" : c
  );
}
function Wce(e) {
  e.sort(
    (t, n) => t.score !== n.score ? n.score - t.score : Qce(
      t.routesMeta.map((r) => r.childrenIndex),
      n.routesMeta.map((r) => r.childrenIndex)
    )
  );
}
var qce = /^:[\w-]+$/, Gce = 3, Kce = 2, Zce = 1, Yce = 10, Xce = -2, JI = (e) => e === "*";
function Jce(e, t) {
  let n = e.split("/"), r = n.length;
  return n.some(JI) && (r += Xce), t && (r += Kce), n.filter((i) => !JI(i)).reduce(
    (i, o) => i + (qce.test(o) ? Gce : o === "" ? Zce : Yce),
    r
  );
}
function Qce(e, t) {
  return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function eue(e, t, n = !1) {
  let { routesMeta: r } = e, i = {}, o = "/", s = [];
  for (let a = 0; a < r.length; ++a) {
    let c = r[a], u = a === r.length - 1, f = o === "/" ? t : t.slice(o.length) || "/", h = Nb(
      { path: c.relativePath, caseSensitive: c.caseSensitive, end: u },
      f
    ), m = c.route;
    if (!h && u && n && !r[r.length - 1].route.index && (h = Nb(
      {
        path: c.relativePath,
        caseSensitive: c.caseSensitive,
        end: !1
      },
      f
    )), !h)
      return null;
    Object.assign(i, h.params), s.push({
      // TODO: Can this as be avoided?
      params: i,
      pathname: Xa([o, h.pathname]),
      pathnameBase: sue(
        Xa([o, h.pathnameBase])
      ),
      route: m
    }), h.pathnameBase !== "/" && (o = Xa([o, h.pathnameBase]));
  }
  return s;
}
function Nb(e, t) {
  typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 });
  let [n, r] = tue(
    e.path,
    e.caseSensitive,
    e.end
  ), i = t.match(n);
  if (!i) return null;
  let o = i[0], s = o.replace(/(.)\/+$/, "$1"), a = i.slice(1);
  return {
    params: r.reduce(
      (u, { paramName: f, isOptional: h }, m) => {
        if (f === "*") {
          let b = a[m] || "";
          s = o.slice(0, o.length - b.length).replace(/(.)\/+$/, "$1");
        }
        const g = a[m];
        return h && !g ? u[f] = void 0 : u[f] = (g || "").replace(/%2F/g, "/"), u;
      },
      {}
    ),
    pathname: o,
    pathnameBase: s,
    pattern: e
  };
}
function tue(e, t = !1, n = !0) {
  ol(
    e === "*" || !e.endsWith("*") || e.endsWith("/*"),
    `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`
  );
  let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (s, a, c) => (r.push({ paramName: a, isOptional: c != null }), c ? "/?([^\\/]+)?" : "/([^\\/]+)")
  ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  return e.endsWith("*") ? (r.push({ paramName: "*" }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r];
}
function nue(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return ol(
      !1,
      `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`
    ), e;
  }
}
function Dc(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/";
}
var rue = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
function iue(e, t = "/") {
  let {
    pathname: n,
    search: r = "",
    hash: i = ""
  } = typeof e == "string" ? TM(e) : e, o;
  return n ? (n = n.replace(/\/\/+/g, "/"), n.startsWith("/") ? o = QI(n.substring(1), "/") : o = QI(n, t)) : o = t, {
    pathname: o,
    search: aue(r),
    hash: lue(i)
  };
}
function QI(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((i) => {
    i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
  }), n.length > 1 ? n.join("/") : "/";
}
function cC(e, t, n, r) {
  return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(
    r
  )}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function oue(e) {
  return e.filter(
    (t, n) => n === 0 || t.route.path && t.route.path.length > 0
  );
}
function nU(e) {
  let t = oue(e);
  return t.map(
    (n, r) => r === t.length - 1 ? n.pathname : n.pathnameBase
  );
}
function rU(e, t, n, r = !1) {
  let i;
  typeof e == "string" ? i = TM(e) : (i = { ...e }, ai(
    !i.pathname || !i.pathname.includes("?"),
    cC("?", "pathname", "search", i)
  ), ai(
    !i.pathname || !i.pathname.includes("#"),
    cC("#", "pathname", "hash", i)
  ), ai(
    !i.search || !i.search.includes("#"),
    cC("#", "search", "hash", i)
  ));
  let o = e === "" || i.pathname === "", s = o ? "/" : i.pathname, a;
  if (s == null)
    a = n;
  else {
    let h = t.length - 1;
    if (!r && s.startsWith("..")) {
      let m = s.split("/");
      for (; m[0] === ".."; )
        m.shift(), h -= 1;
      i.pathname = m.join("/");
    }
    a = h >= 0 ? t[h] : "/";
  }
  let c = iue(i, a), u = s && s !== "/" && s.endsWith("/"), f = (o || s === ".") && n.endsWith("/");
  return !c.pathname.endsWith("/") && (u || f) && (c.pathname += "/"), c;
}
var Xa = (e) => e.join("/").replace(/\/\/+/g, "/"), sue = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), aue = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, lue = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, cue = class {
  constructor(e, t, n, r = !1) {
    this.status = e, this.statusText = t || "", this.internal = r, n instanceof Error ? (this.data = n.toString(), this.error = n) : this.data = n;
  }
};
function uue(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
function due(e) {
  return e.map((t) => t.route.path).filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/";
}
var iU = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
function oU(e, t) {
  let n = e;
  if (typeof n != "string" || !rue.test(n))
    return {
      absoluteURL: void 0,
      isExternal: !1,
      to: n
    };
  let r = n, i = !1;
  if (iU)
    try {
      let o = new URL(window.location.href), s = n.startsWith("//") ? new URL(o.protocol + n) : new URL(n), a = Dc(s.pathname, t);
      s.origin === o.origin && a != null ? n = a + s.search + s.hash : i = !0;
    } catch {
      ol(
        !1,
        `<Link to="${n}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
      );
    }
  return {
    absoluteURL: r,
    isExternal: i,
    to: n
  };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var sU = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
new Set(
  sU
);
var fue = [
  "GET",
  ...sU
];
new Set(fue);
var Kh = C.createContext(null);
Kh.displayName = "DataRouter";
var Mw = C.createContext(null);
Mw.displayName = "DataRouterState";
var hue = C.createContext(!1), aU = C.createContext({
  isTransitioning: !1
});
aU.displayName = "ViewTransition";
var pue = C.createContext(
  /* @__PURE__ */ new Map()
);
pue.displayName = "Fetchers";
var mue = C.createContext(null);
mue.displayName = "Await";
var ws = C.createContext(
  null
);
ws.displayName = "Navigation";
var AM = C.createContext(
  null
);
AM.displayName = "Location";
var al = C.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
al.displayName = "Route";
var MM = C.createContext(null);
MM.displayName = "RouteError";
var lU = "REACT_ROUTER_ERROR", gue = "REDIRECT", yue = "ROUTE_ERROR_RESPONSE";
function vue(e) {
  if (e.startsWith(`${lU}:${gue}:{`))
    try {
      let t = JSON.parse(e.slice(28));
      if (typeof t == "object" && t && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.location == "string" && typeof t.reloadDocument == "boolean" && typeof t.replace == "boolean")
        return t;
    } catch {
    }
}
function bue(e) {
  if (e.startsWith(
    `${lU}:${yue}:{`
  ))
    try {
      let t = JSON.parse(e.slice(40));
      if (typeof t == "object" && t && typeof t.status == "number" && typeof t.statusText == "string")
        return new cue(
          t.status,
          t.statusText,
          t.data
        );
    } catch {
    }
}
function xue(e, { relative: t } = {}) {
  ai(
    Nw(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: n, navigator: r } = C.useContext(ws), { hash: i, pathname: o, search: s } = oy(e, { relative: t }), a = o;
  return n !== "/" && (a = o === "/" ? n : Xa([n, o])), r.createHref({ pathname: a, search: s, hash: i });
}
function Nw() {
  return C.useContext(AM) != null;
}
function xd() {
  return ai(
    Nw(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ), C.useContext(AM).location;
}
var cU = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function uU(e) {
  C.useContext(ws).static || C.useLayoutEffect(e);
}
function dU() {
  let { isDataRoute: e } = C.useContext(al);
  return e ? Pue() : wue();
}
function wue() {
  ai(
    Nw(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let e = C.useContext(Kh), { basename: t, navigator: n } = C.useContext(ws), { matches: r } = C.useContext(al), { pathname: i } = xd(), o = JSON.stringify(nU(r)), s = C.useRef(!1);
  return uU(() => {
    s.current = !0;
  }), C.useCallback(
    (c, u = {}) => {
      if (ol(s.current, cU), !s.current) return;
      if (typeof c == "number") {
        n.go(c);
        return;
      }
      let f = rU(
        c,
        JSON.parse(o),
        i,
        u.relative === "path"
      );
      e == null && t !== "/" && (f.pathname = f.pathname === "/" ? t : Xa([t, f.pathname])), (u.replace ? n.replace : n.push)(
        f,
        u.state,
        u
      );
    },
    [
      t,
      n,
      o,
      i,
      e
    ]
  );
}
C.createContext(null);
function oy(e, { relative: t } = {}) {
  let { matches: n } = C.useContext(al), { pathname: r } = xd(), i = JSON.stringify(nU(n));
  return C.useMemo(
    () => rU(
      e,
      JSON.parse(i),
      r,
      t === "path"
    ),
    [e, i, r, t]
  );
}
function Sue(e, t, n, r, i) {
  ai(
    Nw(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: o } = C.useContext(ws), { matches: s } = C.useContext(al), a = s[s.length - 1], c = a ? a.params : {}, u = a ? a.pathname : "/", f = a ? a.pathnameBase : "/", h = a && a.route;
  {
    let _ = h && h.path || "";
    hU(
      u,
      !h || _.endsWith("*") || _.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${_}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${_}"> to <Route path="${_ === "/" ? "*" : `${_}/*`}">.`
    );
  }
  let m = xd(), g;
  g = m;
  let b = g.pathname || "/", x = b;
  if (f !== "/") {
    let _ = f.replace(/^\//, "").split("/");
    x = "/" + b.replace(/^\//, "").split("/").slice(_.length).join("/");
  }
  let w = Q9(e, { pathname: x });
  return ol(
    h || w != null,
    `No routes matched location "${g.pathname}${g.search}${g.hash}" `
  ), ol(
    w == null || w[w.length - 1].route.element !== void 0 || w[w.length - 1].route.Component !== void 0 || w[w.length - 1].route.lazy !== void 0,
    `Matched leaf route at location "${g.pathname}${g.search}${g.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
  ), Tue(
    w && w.map(
      (_) => Object.assign({}, _, {
        params: Object.assign({}, c, _.params),
        pathname: Xa([
          f,
          // Re-encode pathnames that were decoded inside matchRoutes.
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          o.encodeLocation ? o.encodeLocation(
            _.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : _.pathname
        ]),
        pathnameBase: _.pathnameBase === "/" ? f : Xa([
          f,
          // Re-encode pathnames that were decoded inside matchRoutes
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          o.encodeLocation ? o.encodeLocation(
            _.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : _.pathnameBase
        ])
      })
    ),
    s,
    n,
    r,
    i
  );
}
function kue() {
  let e = Oue(), t = uue(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, r = "rgba(200,200,200, 0.5)", i = { padding: "0.5rem", backgroundColor: r }, o = { padding: "2px 4px", backgroundColor: r }, s = null;
  return console.error(
    "Error handled by React Router default ErrorBoundary:",
    e
  ), s = /* @__PURE__ */ C.createElement(C.Fragment, null, /* @__PURE__ */ C.createElement("p", null, " Hey developer "), /* @__PURE__ */ C.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ C.createElement("code", { style: o }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ C.createElement("code", { style: o }, "errorElement"), " prop on your route.")), /* @__PURE__ */ C.createElement(C.Fragment, null, /* @__PURE__ */ C.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ C.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? /* @__PURE__ */ C.createElement("pre", { style: i }, n) : null, s);
}
var Cue = /* @__PURE__ */ C.createElement(kue, null), fU = class extends C.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    this.props.onError ? this.props.onError(e, t) : console.error(
      "React Router caught the following error during render",
      e
    );
  }
  render() {
    let e = this.state.error;
    if (this.context && typeof e == "object" && e && "digest" in e && typeof e.digest == "string") {
      const n = bue(e.digest);
      n && (e = n);
    }
    let t = e !== void 0 ? /* @__PURE__ */ C.createElement(al.Provider, { value: this.props.routeContext }, /* @__PURE__ */ C.createElement(
      MM.Provider,
      {
        value: e,
        children: this.props.component
      }
    )) : this.props.children;
    return this.context ? /* @__PURE__ */ C.createElement(Eue, { error: e }, t) : t;
  }
};
fU.contextType = hue;
var uC = /* @__PURE__ */ new WeakMap();
function Eue({
  children: e,
  error: t
}) {
  let { basename: n } = C.useContext(ws);
  if (typeof t == "object" && t && "digest" in t && typeof t.digest == "string") {
    let r = vue(t.digest);
    if (r) {
      let i = uC.get(t);
      if (i) throw i;
      let o = oU(r.location, n);
      if (iU && !uC.get(t))
        if (o.isExternal || r.reloadDocument)
          window.location.href = o.absoluteURL || o.to;
        else {
          const s = Promise.resolve().then(
            () => window.__reactRouterDataRouter.navigate(o.to, {
              replace: r.replace
            })
          );
          throw uC.set(t, s), s;
        }
      return /* @__PURE__ */ C.createElement(
        "meta",
        {
          httpEquiv: "refresh",
          content: `0;url=${o.absoluteURL || o.to}`
        }
      );
    }
  }
  return e;
}
function _ue({ routeContext: e, match: t, children: n }) {
  let r = C.useContext(Kh);
  return r && r.static && r.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ C.createElement(al.Provider, { value: e }, n);
}
function Tue(e, t = [], n = null, r = null, i = null) {
  if (e == null) {
    if (!n)
      return null;
    if (n.errors)
      e = n.matches;
    else if (t.length === 0 && !n.initialized && n.matches.length > 0)
      e = n.matches;
    else
      return null;
  }
  let o = e, s = n?.errors;
  if (s != null) {
    let f = o.findIndex(
      (h) => h.route.id && s?.[h.route.id] !== void 0
    );
    ai(
      f >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        s
      ).join(",")}`
    ), o = o.slice(
      0,
      Math.min(o.length, f + 1)
    );
  }
  let a = !1, c = -1;
  if (n)
    for (let f = 0; f < o.length; f++) {
      let h = o[f];
      if ((h.route.HydrateFallback || h.route.hydrateFallbackElement) && (c = f), h.route.id) {
        let { loaderData: m, errors: g } = n, b = h.route.loader && !m.hasOwnProperty(h.route.id) && (!g || g[h.route.id] === void 0);
        if (h.route.lazy || b) {
          a = !0, c >= 0 ? o = o.slice(0, c + 1) : o = [o[0]];
          break;
        }
      }
    }
  let u = n && r ? (f, h) => {
    r(f, {
      location: n.location,
      params: n.matches?.[0]?.params ?? {},
      unstable_pattern: due(n.matches),
      errorInfo: h
    });
  } : void 0;
  return o.reduceRight(
    (f, h, m) => {
      let g, b = !1, x = null, w = null;
      n && (g = s && h.route.id ? s[h.route.id] : void 0, x = h.route.errorElement || Cue, a && (c < 0 && m === 0 ? (hU(
        "route-fallback",
        !1,
        "No `HydrateFallback` element provided to render during initial hydration"
      ), b = !0, w = null) : c === m && (b = !0, w = h.route.hydrateFallbackElement || null)));
      let S = t.concat(o.slice(0, m + 1)), _ = () => {
        let M;
        return g ? M = x : b ? M = w : h.route.Component ? M = /* @__PURE__ */ C.createElement(h.route.Component, null) : h.route.element ? M = h.route.element : M = f, /* @__PURE__ */ C.createElement(
          _ue,
          {
            match: h,
            routeContext: {
              outlet: f,
              matches: S,
              isDataRoute: n != null
            },
            children: M
          }
        );
      };
      return n && (h.route.ErrorBoundary || h.route.errorElement || m === 0) ? /* @__PURE__ */ C.createElement(
        fU,
        {
          location: n.location,
          revalidation: n.revalidation,
          component: x,
          error: g,
          children: _(),
          routeContext: { outlet: null, matches: S, isDataRoute: !0 },
          onError: u
        }
      ) : _();
    },
    null
  );
}
function NM(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function Aue(e) {
  let t = C.useContext(Kh);
  return ai(t, NM(e)), t;
}
function Mue(e) {
  let t = C.useContext(Mw);
  return ai(t, NM(e)), t;
}
function Nue(e) {
  let t = C.useContext(al);
  return ai(t, NM(e)), t;
}
function RM(e) {
  let t = Nue(e), n = t.matches[t.matches.length - 1];
  return ai(
    n.route.id,
    `${e} can only be used on routes that contain a unique "id"`
  ), n.route.id;
}
function Rue() {
  return RM(
    "useRouteId"
    /* UseRouteId */
  );
}
function Oue() {
  let e = C.useContext(MM), t = Mue(
    "useRouteError"
    /* UseRouteError */
  ), n = RM(
    "useRouteError"
    /* UseRouteError */
  );
  return e !== void 0 ? e : t.errors?.[n];
}
function Pue() {
  let { router: e } = Aue(
    "useNavigate"
    /* UseNavigateStable */
  ), t = RM(
    "useNavigate"
    /* UseNavigateStable */
  ), n = C.useRef(!1);
  return uU(() => {
    n.current = !0;
  }), C.useCallback(
    async (i, o = {}) => {
      ol(n.current, cU), n.current && (typeof i == "number" ? await e.navigate(i) : await e.navigate(i, { fromRouteId: t, ...o }));
    },
    [e, t]
  );
}
var ej = {};
function hU(e, t, n) {
  !t && !ej[e] && (ej[e] = !0, ol(!1, n));
}
C.memo(Due);
function Due({
  routes: e,
  future: t,
  state: n,
  onError: r
}) {
  return Sue(e, void 0, n, r, t);
}
var B0 = "get", $0 = "application/x-www-form-urlencoded";
function Rw(e) {
  return typeof HTMLElement < "u" && e instanceof HTMLElement;
}
function Iue(e) {
  return Rw(e) && e.tagName.toLowerCase() === "button";
}
function jue(e) {
  return Rw(e) && e.tagName.toLowerCase() === "form";
}
function zue(e) {
  return Rw(e) && e.tagName.toLowerCase() === "input";
}
function Lue(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function Bue(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !Lue(e);
}
var Zv = null;
function $ue() {
  if (Zv === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), Zv = !1;
    } catch {
      Zv = !0;
    }
  return Zv;
}
var Uue = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function dC(e) {
  return e != null && !Uue.has(e) ? (ol(
    !1,
    `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${$0}"`
  ), null) : e;
}
function Fue(e, t) {
  let n, r, i, o, s;
  if (jue(e)) {
    let a = e.getAttribute("action");
    r = a ? Dc(a, t) : null, n = e.getAttribute("method") || B0, i = dC(e.getAttribute("enctype")) || $0, o = new FormData(e);
  } else if (Iue(e) || zue(e) && (e.type === "submit" || e.type === "image")) {
    let a = e.form;
    if (a == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let c = e.getAttribute("formaction") || a.getAttribute("action");
    if (r = c ? Dc(c, t) : null, n = e.getAttribute("formmethod") || a.getAttribute("method") || B0, i = dC(e.getAttribute("formenctype")) || dC(a.getAttribute("enctype")) || $0, o = new FormData(a, e), !$ue()) {
      let { name: u, type: f, value: h } = e;
      if (f === "image") {
        let m = u ? `${u}.` : "";
        o.append(`${m}x`, "0"), o.append(`${m}y`, "0");
      } else u && o.append(u, h);
    }
  } else {
    if (Rw(e))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    n = B0, r = null, i = $0, s = e;
  }
  return o && i === "text/plain" && (s = o, o = void 0), { action: r, method: n.toLowerCase(), encType: i, formData: o, body: s };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function OM(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function Vue(e, t, n, r) {
  let i = typeof e == "string" ? new URL(
    e,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window > "u" ? "server://singlefetch/" : window.location.origin
  ) : e;
  return n ? i.pathname.endsWith("/") ? i.pathname = `${i.pathname}_.${r}` : i.pathname = `${i.pathname}.${r}` : i.pathname === "/" ? i.pathname = `_root.${r}` : t && Dc(i.pathname, t) === "/" ? i.pathname = `${t.replace(/\/$/, "")}/_root.${r}` : i.pathname = `${i.pathname.replace(/\/$/, "")}.${r}`, i;
}
async function Hue(e, t) {
  if (e.id in t)
    return t[e.id];
  try {
    let n = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e.module
    );
    return t[e.id] = n, n;
  } catch (n) {
    return console.error(
      `Error loading route module \`${e.module}\`, reloading page...`
    ), console.error(n), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
    });
  }
}
function Wue(e) {
  return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string";
}
async function que(e, t, n) {
  let r = await Promise.all(
    e.map(async (i) => {
      let o = t.routes[i.route.id];
      if (o) {
        let s = await Hue(o, n);
        return s.links ? s.links() : [];
      }
      return [];
    })
  );
  return Yue(
    r.flat(1).filter(Wue).filter((i) => i.rel === "stylesheet" || i.rel === "preload").map(
      (i) => i.rel === "stylesheet" ? { ...i, rel: "prefetch", as: "style" } : { ...i, rel: "prefetch" }
    )
  );
}
function tj(e, t, n, r, i, o) {
  let s = (c, u) => n[u] ? c.route.id !== n[u].route.id : !0, a = (c, u) => (
    // param change, /users/123 -> /users/456
    n[u].pathname !== c.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    n[u].route.path?.endsWith("*") && n[u].params["*"] !== c.params["*"]
  );
  return o === "assets" ? t.filter(
    (c, u) => s(c, u) || a(c, u)
  ) : o === "data" ? t.filter((c, u) => {
    let f = r.routes[c.route.id];
    if (!f || !f.hasLoader)
      return !1;
    if (s(c, u) || a(c, u))
      return !0;
    if (c.route.shouldRevalidate) {
      let h = c.route.shouldRevalidate({
        currentUrl: new URL(
          i.pathname + i.search + i.hash,
          window.origin
        ),
        currentParams: n[0]?.params || {},
        nextUrl: new URL(e, window.origin),
        nextParams: c.params,
        defaultShouldRevalidate: !0
      });
      if (typeof h == "boolean")
        return h;
    }
    return !0;
  }) : [];
}
function Gue(e, t, { includeHydrateFallback: n } = {}) {
  return Kue(
    e.map((r) => {
      let i = t.routes[r.route.id];
      if (!i) return [];
      let o = [i.module];
      return i.clientActionModule && (o = o.concat(i.clientActionModule)), i.clientLoaderModule && (o = o.concat(i.clientLoaderModule)), n && i.hydrateFallbackModule && (o = o.concat(i.hydrateFallbackModule)), i.imports && (o = o.concat(i.imports)), o;
    }).flat(1)
  );
}
function Kue(e) {
  return [...new Set(e)];
}
function Zue(e) {
  let t = {}, n = Object.keys(e).sort();
  for (let r of n)
    t[r] = e[r];
  return t;
}
function Yue(e, t) {
  let n = /* @__PURE__ */ new Set();
  return new Set(t), e.reduce((r, i) => {
    let o = JSON.stringify(Zue(i));
    return n.has(o) || (n.add(o), r.push({ key: o, link: i })), r;
  }, []);
}
function pU() {
  let e = C.useContext(Kh);
  return OM(
    e,
    "You must render this element inside a <DataRouterContext.Provider> element"
  ), e;
}
function Xue() {
  let e = C.useContext(Mw);
  return OM(
    e,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  ), e;
}
var PM = C.createContext(void 0);
PM.displayName = "FrameworkContext";
function mU() {
  let e = C.useContext(PM);
  return OM(
    e,
    "You must render this element inside a <HydratedRouter> element"
  ), e;
}
function Jue(e, t) {
  let n = C.useContext(PM), [r, i] = C.useState(!1), [o, s] = C.useState(!1), { onFocus: a, onBlur: c, onMouseEnter: u, onMouseLeave: f, onTouchStart: h } = t, m = C.useRef(null);
  C.useEffect(() => {
    if (e === "render" && s(!0), e === "viewport") {
      let x = (S) => {
        S.forEach((_) => {
          s(_.isIntersecting);
        });
      }, w = new IntersectionObserver(x, { threshold: 0.5 });
      return m.current && w.observe(m.current), () => {
        w.disconnect();
      };
    }
  }, [e]), C.useEffect(() => {
    if (r) {
      let x = setTimeout(() => {
        s(!0);
      }, 100);
      return () => {
        clearTimeout(x);
      };
    }
  }, [r]);
  let g = () => {
    i(!0);
  }, b = () => {
    i(!1), s(!1);
  };
  return n ? e !== "intent" ? [o, m, {}] : [
    o,
    m,
    {
      onFocus: am(a, g),
      onBlur: am(c, b),
      onMouseEnter: am(u, g),
      onMouseLeave: am(f, b),
      onTouchStart: am(h, g)
    }
  ] : [!1, m, {}];
}
function am(e, t) {
  return (n) => {
    e && e(n), n.defaultPrevented || t(n);
  };
}
function Que({ page: e, ...t }) {
  let { router: n } = pU(), r = C.useMemo(
    () => Q9(n.routes, e, n.basename),
    [n.routes, e, n.basename]
  );
  return r ? /* @__PURE__ */ C.createElement(tde, { page: e, matches: r, ...t }) : null;
}
function ede(e) {
  let { manifest: t, routeModules: n } = mU(), [r, i] = C.useState([]);
  return C.useEffect(() => {
    let o = !1;
    return que(e, t, n).then(
      (s) => {
        o || i(s);
      }
    ), () => {
      o = !0;
    };
  }, [e, t, n]), r;
}
function tde({
  page: e,
  matches: t,
  ...n
}) {
  let r = xd(), { future: i, manifest: o, routeModules: s } = mU(), { basename: a } = pU(), { loaderData: c, matches: u } = Xue(), f = C.useMemo(
    () => tj(
      e,
      t,
      u,
      o,
      r,
      "data"
    ),
    [e, t, u, o, r]
  ), h = C.useMemo(
    () => tj(
      e,
      t,
      u,
      o,
      r,
      "assets"
    ),
    [e, t, u, o, r]
  ), m = C.useMemo(() => {
    if (e === r.pathname + r.search + r.hash)
      return [];
    let x = /* @__PURE__ */ new Set(), w = !1;
    if (t.forEach((_) => {
      let M = o.routes[_.route.id];
      !M || !M.hasLoader || (!f.some((N) => N.route.id === _.route.id) && _.route.id in c && s[_.route.id]?.shouldRevalidate || M.hasClientLoader ? w = !0 : x.add(_.route.id));
    }), x.size === 0)
      return [];
    let S = Vue(
      e,
      a,
      i.unstable_trailingSlashAwareDataRequests,
      "data"
    );
    return w && x.size > 0 && S.searchParams.set(
      "_routes",
      t.filter((_) => x.has(_.route.id)).map((_) => _.route.id).join(",")
    ), [S.pathname + S.search];
  }, [
    a,
    i.unstable_trailingSlashAwareDataRequests,
    c,
    r,
    o,
    f,
    t,
    e,
    s
  ]), g = C.useMemo(
    () => Gue(h, o),
    [h, o]
  ), b = ede(h);
  return /* @__PURE__ */ C.createElement(C.Fragment, null, m.map((x) => /* @__PURE__ */ C.createElement("link", { key: x, rel: "prefetch", as: "fetch", href: x, ...n })), g.map((x) => /* @__PURE__ */ C.createElement("link", { key: x, rel: "modulepreload", href: x, ...n })), b.map(({ key: x, link: w }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ C.createElement(
      "link",
      {
        key: x,
        nonce: n.nonce,
        ...w,
        crossOrigin: w.crossOrigin ?? n.crossOrigin
      }
    )
  )));
}
function nde(...e) {
  return (t) => {
    e.forEach((n) => {
      typeof n == "function" ? n(t) : n != null && (n.current = t);
    });
  };
}
var rde = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
  rde && (window.__reactRouterVersion = // @ts-expect-error
  "7.13.0");
} catch {
}
var gU = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Ow = C.forwardRef(
  function({
    onClick: t,
    discover: n = "render",
    prefetch: r = "none",
    relative: i,
    reloadDocument: o,
    replace: s,
    state: a,
    target: c,
    to: u,
    preventScrollReset: f,
    viewTransition: h,
    unstable_defaultShouldRevalidate: m,
    ...g
  }, b) {
    let { basename: x, unstable_useTransitions: w } = C.useContext(ws), S = typeof u == "string" && gU.test(u), _ = oU(u, x);
    u = _.to;
    let M = xue(u, { relative: i }), [N, D, j] = Jue(
      r,
      g
    ), O = ade(u, {
      replace: s,
      state: a,
      target: c,
      preventScrollReset: f,
      relative: i,
      viewTransition: h,
      unstable_defaultShouldRevalidate: m,
      unstable_useTransitions: w
    });
    function L(B) {
      t && t(B), B.defaultPrevented || O(B);
    }
    let U = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ C.createElement(
        "a",
        {
          ...g,
          ...j,
          href: _.absoluteURL || M,
          onClick: _.isExternal || o ? t : L,
          ref: nde(b, D),
          target: c,
          "data-discover": !S && n === "render" ? "true" : void 0
        }
      )
    );
    return N && !S ? /* @__PURE__ */ C.createElement(C.Fragment, null, U, /* @__PURE__ */ C.createElement(Que, { page: M })) : U;
  }
);
Ow.displayName = "Link";
var ide = C.forwardRef(
  function({
    "aria-current": t = "page",
    caseSensitive: n = !1,
    className: r = "",
    end: i = !1,
    style: o,
    to: s,
    viewTransition: a,
    children: c,
    ...u
  }, f) {
    let h = oy(s, { relative: u.relative }), m = xd(), g = C.useContext(Mw), { navigator: b, basename: x } = C.useContext(ws), w = g != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    fde(h) && a === !0, S = b.encodeLocation ? b.encodeLocation(h).pathname : h.pathname, _ = m.pathname, M = g && g.navigation && g.navigation.location ? g.navigation.location.pathname : null;
    n || (_ = _.toLowerCase(), M = M ? M.toLowerCase() : null, S = S.toLowerCase()), M && x && (M = Dc(M, x) || M);
    const N = S !== "/" && S.endsWith("/") ? S.length - 1 : S.length;
    let D = _ === S || !i && _.startsWith(S) && _.charAt(N) === "/", j = M != null && (M === S || !i && M.startsWith(S) && M.charAt(S.length) === "/"), O = {
      isActive: D,
      isPending: j,
      isTransitioning: w
    }, L = D ? t : void 0, U;
    typeof r == "function" ? U = r(O) : U = [
      r,
      D ? "active" : null,
      j ? "pending" : null,
      w ? "transitioning" : null
    ].filter(Boolean).join(" ");
    let B = typeof o == "function" ? o(O) : o;
    return /* @__PURE__ */ C.createElement(
      Ow,
      {
        ...u,
        "aria-current": L,
        className: U,
        ref: f,
        style: B,
        to: s,
        viewTransition: a
      },
      typeof c == "function" ? c(O) : c
    );
  }
);
ide.displayName = "NavLink";
var ode = C.forwardRef(
  ({
    discover: e = "render",
    fetcherKey: t,
    navigate: n,
    reloadDocument: r,
    replace: i,
    state: o,
    method: s = B0,
    action: a,
    onSubmit: c,
    relative: u,
    preventScrollReset: f,
    viewTransition: h,
    unstable_defaultShouldRevalidate: m,
    ...g
  }, b) => {
    let { unstable_useTransitions: x } = C.useContext(ws), w = ude(), S = dde(a, { relative: u }), _ = s.toLowerCase() === "get" ? "get" : "post", M = typeof a == "string" && gU.test(a), N = (D) => {
      if (c && c(D), D.defaultPrevented) return;
      D.preventDefault();
      let j = D.nativeEvent.submitter, O = j?.getAttribute("formmethod") || s, L = () => w(j || D.currentTarget, {
        fetcherKey: t,
        method: O,
        navigate: n,
        replace: i,
        state: o,
        relative: u,
        preventScrollReset: f,
        viewTransition: h,
        unstable_defaultShouldRevalidate: m
      });
      x && n !== !1 ? C.startTransition(() => L()) : L();
    };
    return /* @__PURE__ */ C.createElement(
      "form",
      {
        ref: b,
        method: _,
        action: S,
        onSubmit: r ? c : N,
        ...g,
        "data-discover": !M && e === "render" ? "true" : void 0
      }
    );
  }
);
ode.displayName = "Form";
function sde(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function yU(e) {
  let t = C.useContext(Kh);
  return ai(t, sde(e)), t;
}
function ade(e, {
  target: t,
  replace: n,
  state: r,
  preventScrollReset: i,
  relative: o,
  viewTransition: s,
  unstable_defaultShouldRevalidate: a,
  unstable_useTransitions: c
} = {}) {
  let u = dU(), f = xd(), h = oy(e, { relative: o });
  return C.useCallback(
    (m) => {
      if (Bue(m, t)) {
        m.preventDefault();
        let g = n !== void 0 ? n : U_(f) === U_(h), b = () => u(e, {
          replace: g,
          state: r,
          preventScrollReset: i,
          relative: o,
          viewTransition: s,
          unstable_defaultShouldRevalidate: a
        });
        c ? C.startTransition(() => b()) : b();
      }
    },
    [
      f,
      u,
      h,
      n,
      r,
      t,
      e,
      i,
      o,
      s,
      a,
      c
    ]
  );
}
var lde = 0, cde = () => `__${String(++lde)}__`;
function ude() {
  let { router: e } = yU(
    "useSubmit"
    /* UseSubmit */
  ), { basename: t } = C.useContext(ws), n = Rue(), r = e.fetch, i = e.navigate;
  return C.useCallback(
    async (o, s = {}) => {
      let { action: a, method: c, encType: u, formData: f, body: h } = Fue(
        o,
        t
      );
      if (s.navigate === !1) {
        let m = s.fetcherKey || cde();
        await r(m, n, s.action || a, {
          unstable_defaultShouldRevalidate: s.unstable_defaultShouldRevalidate,
          preventScrollReset: s.preventScrollReset,
          formData: f,
          body: h,
          formMethod: s.method || c,
          formEncType: s.encType || u,
          flushSync: s.flushSync
        });
      } else
        await i(s.action || a, {
          unstable_defaultShouldRevalidate: s.unstable_defaultShouldRevalidate,
          preventScrollReset: s.preventScrollReset,
          formData: f,
          body: h,
          formMethod: s.method || c,
          formEncType: s.encType || u,
          replace: s.replace,
          state: s.state,
          fromRouteId: n,
          flushSync: s.flushSync,
          viewTransition: s.viewTransition
        });
    },
    [r, i, t, n]
  );
}
function dde(e, { relative: t } = {}) {
  let { basename: n } = C.useContext(ws), r = C.useContext(al);
  ai(r, "useFormAction must be used inside a RouteContext");
  let [i] = r.matches.slice(-1), o = { ...oy(e || ".", { relative: t }) }, s = xd();
  if (e == null) {
    o.search = s.search;
    let a = new URLSearchParams(o.search), c = a.getAll("index");
    if (c.some((f) => f === "")) {
      a.delete("index"), c.filter((h) => h).forEach((h) => a.append("index", h));
      let f = a.toString();
      o.search = f ? `?${f}` : "";
    }
  }
  return (!e || e === ".") && i.route.index && (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (o.pathname = o.pathname === "/" ? n : Xa([n, o.pathname])), U_(o);
}
function fde(e, { relative: t } = {}) {
  let n = C.useContext(aU);
  ai(
    n != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: r } = yU(
    "useViewTransitionState"
    /* useViewTransitionState */
  ), i = oy(e, { relative: t });
  if (!n.isTransitioning)
    return !1;
  let o = Dc(n.currentLocation.pathname, r) || n.currentLocation.pathname, s = Dc(n.nextLocation.pathname, r) || n.nextLocation.pathname;
  return Nb(i.pathname, s) != null || Nb(i.pathname, o) != null;
}
function hde({
  isOwner: e,
  isBookmarked: t = !1,
  editHref: n,
  onBookmarkToggle: r,
  onDelete: i,
  renderActions: o,
  isVisibilityChangeLoading: s = !1,
  isBookmarkToggleLoading: a = !1,
  isDeleteLoading: c = !1,
  disabled: u = !1
}) {
  const f = C.useMemo(
    () => s || a || c,
    [s, a, c]
  ), h = dU();
  return /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-0.5", children: [
    !e && r && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsxs(Yi, { children: [
        /* @__PURE__ */ v.jsx(go, { asChild: !0, children: /* @__PURE__ */ v.jsx(
          qt,
          {
            variant: "ghost",
            size: "icon",
            className: "h-8 w-8 rounded-md text-muted-foreground hover:text-foreground hover:bg-accent/50 transition-all cursor-pointer disabled:opacity-50",
            "data-testid": "bookmark-button",
            disabled: f || u,
            onClick: (m) => {
              m.preventDefault(), m.stopPropagation(), r(t);
            },
            children: a ? /* @__PURE__ */ v.jsx(ea, { className: "h-3.5 w-3.5 animate-spin" }) : t ? /* @__PURE__ */ v.jsx(eY, { className: "h-3.5 w-3.5 fill-current" }) : /* @__PURE__ */ v.jsx(w4, { className: "h-3.5 w-3.5" })
          }
        ) }),
        /* @__PURE__ */ v.jsx(Vo, { side: "bottom", className: "text-xs", children: t ? "Remove bookmark" : "Add bookmark" })
      ] }),
      /* @__PURE__ */ v.jsx(Mb, { orientation: "vertical", className: "h-4 mx-0.5" })
    ] }),
    e && n && /* @__PURE__ */ v.jsxs(Yi, { children: [
      /* @__PURE__ */ v.jsx(go, { asChild: !0, children: /* @__PURE__ */ v.jsx(
        qt,
        {
          variant: "ghost",
          size: "icon",
          className: "h-8 w-8 rounded-md text-muted-foreground hover:text-foreground hover:bg-accent/50 transition-all cursor-pointer disabled:opacity-50",
          disabled: f || u,
          onClick: (m) => {
            m.preventDefault(), m.stopPropagation(), h(n);
          },
          children: /* @__PURE__ */ v.jsx(Vce, { className: "h-3.5 w-3.5" })
        }
      ) }),
      /* @__PURE__ */ v.jsx(Vo, { side: "bottom", className: "text-xs", children: "Edit" })
    ] }),
    e && o && o(),
    e && i && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      n && /* @__PURE__ */ v.jsx(Mb, { orientation: "vertical", className: "h-4 mx-0.5" }),
      /* @__PURE__ */ v.jsxs(Yi, { children: [
        /* @__PURE__ */ v.jsx(go, { asChild: !0, children: /* @__PURE__ */ v.jsx(
          qt,
          {
            variant: "ghost",
            size: "icon",
            className: "h-8 w-8 rounded-md text-muted-foreground hover:text-destructive hover:bg-destructive/10 transition-all cursor-pointer disabled:opacity-50",
            disabled: f || u,
            onClick: (m) => {
              m.preventDefault(), m.stopPropagation(), i();
            },
            children: c ? /* @__PURE__ */ v.jsx(ea, { className: "h-3.5 w-3.5 animate-spin" }) : /* @__PURE__ */ v.jsx(k4, { className: "h-3.5 w-3.5" })
          }
        ) }),
        /* @__PURE__ */ v.jsx(Vo, { side: "bottom", className: "text-xs", children: "Delete" })
      ] })
    ] })
  ] });
}
async function pde(e) {
  const t = await Vc(), n = await fetch(`${Ys}/${encodeURIComponent(e)}`, {
    method: "DELETE",
    headers: t
  });
  if (!n.ok) throw new Error(`Failed to delete MCP server (${n.status})`);
}
async function mde(e) {
  const t = await Vc(), n = await fetch(`${Ys}/${encodeURIComponent(e)}/refresh`, {
    method: "POST",
    headers: t
  });
  if (!n.ok) throw new Error(`Failed to refresh MCP server (${n.status})`);
  return n.json().catch(() => null);
}
function gde({ className: e }) {
  return /* @__PURE__ */ v.jsxs(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      id: "Playwright--Streamline-Svg-Logos",
      height: "24",
      width: "24",
      className: e,
      children: [
        /* @__PURE__ */ v.jsx("desc", { children: "Playwright Streamline Icon: https://streamlinehq.com" }),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#2d4552",
            d: "M7.99585 13.141725c-0.87725 0.248975 -1.452775 0.685475 -1.8319 1.12165 0.363125 -0.317775 0.849525 -0.609425 1.505675 -0.795425 0.6711 -0.1902 1.243625 -0.188825 1.7167 -0.09755v-0.369925c-0.40355 -0.0369 -0.866225 -0.0075 -1.390475 0.14125Zm-1.872 -3.109775 -3.25795 0.858325s0.059375 0.083875 0.1693 0.195775l2.76235 -0.727875s-0.03915 0.5044 -0.379075 0.9556c0.643 -0.486475 0.705375 -1.281825 0.705375 -1.281825Zm2.727125 7.65675C4.26615 18.923575 1.8404825 13.61025 1.1060875 10.852425c-0.3393 -1.273 -0.487415 -2.2371 -0.5268925 -2.859275 -0.0042425 -0.0646 -0.0022825 -0.11905 0.002285 -0.16895 -0.237835 0.01435 -0.3517015 0.137975 -0.328535 0.49525 0.0394775 0.621825 0.187595 1.585875 0.526895 2.859275C1.5139075 13.936125 3.9399 19.24945 8.52475 18.0146c0.99795 -0.26885 1.747675 -0.758525 2.310475 -1.383625 -0.51875 0.468525 -1.168 0.8375 -1.98425 1.057725Zm0.861575 -10.90855v0.3263h1.79835c-0.0369 -0.115525 -0.074075 -0.219625 -0.110975 -0.3263h-1.687375Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#2d4552",
            d: "M11.9129 9.46735c0.80875 0.229675 1.2365 0.7967 1.462575 1.2985l0.90175 0.2561s-0.123 -1.756175 -1.711525 -2.2074c-1.486075 -0.422225 -2.400575 0.8257 -2.5118 0.9872 0.4323 -0.308 1.063575 -0.56015 1.859 -0.3344Zm7.178175 1.3066c-1.487425 -0.424125 -2.401575 0.8264 -2.511175 0.985625 0.432625 -0.307625 1.063575 -0.559875 1.85865 -0.3331 0.80745 0.23005 1.23485 0.796375 1.461625 1.298525l0.90305 0.25705s-0.125 -1.756525 -1.71215 -2.2081Zm-0.8959 4.6305 -7.501475 -2.097125s0.0812 0.411725 0.3928 0.94485l6.3159 1.765675c0.519975 -0.30085 0.792775 -0.6134 0.792775 -0.6134ZM12.994375 19.918475C7.054675 18.326 7.77275 10.758025 8.733875 7.171825c0.395725 -1.4779 0.802575 -2.576375 1.13995 -3.312725 -0.2013 -0.041425 -0.368025 0.0646 -0.532775 0.39965 -0.358225 0.726575 -0.8163 1.90955 -1.259625 3.5656 -0.96085 3.586125 -1.67895 11.15385 4.2605 12.746325 2.79955 0.75 4.980475 -0.3899 6.60625 -2.18005 -1.543175 1.3977 -3.513425 2.181325 -5.9538 1.52785Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#e2574c",
            d: "M9.7126 15.915175V14.388l-4.243175 1.2032s0.313525 -1.82175 2.526475 -2.4495c0.6711 -0.1902 1.2437 -0.1889 1.7167 -0.09755V6.780125h2.124575c-0.231325 -0.714825 -0.4551 -1.26515 -0.64305 -1.64755 -0.310925 -0.632925 -0.62965 -0.21335 -1.35325 0.39185 -0.50965 0.425775 -1.797675 1.33405 -3.7359 1.85635 -1.938275 0.522625 -3.50525 0.384025 -4.15906 0.2708 -0.9268825 -0.1599 -1.4116925 -0.36345 -1.3663375 0.34155 0.03947 0.621825 0.187595 1.58595 0.5268925 2.859275C1.8405325 13.609875 4.266525 18.9232 8.85135 17.68835c1.197625 -0.3227 2.04295 -0.960525 2.6289 -1.7735h-1.76765v0.000325ZM2.865625 10.89025l3.258275 -0.858325s-0.094975 1.25345 -1.31645 1.57545c-1.2218 0.321675 -1.941825 -0.717125 -1.941825 -0.717125Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#2ead33",
            d: "M21.975075 6.8525c-0.84695 0.148475 -2.878875 0.33345 -5.389975 -0.339625 -2.5118 -0.672675 -4.17835 -1.849175 -4.838625 -2.402175 -0.936 -0.783975 -1.347725 -1.328825 -1.752925 -0.5047 -0.358225 0.726875 -0.816325 1.909875 -1.259725 3.565925 -0.960775 3.586125 -1.67885 11.15385 4.260525 12.7463 5.938125 1.591125 9.09945 -5.322175 10.0603 -8.908625 0.4434 -1.655725 0.637825 -2.9095 0.691325 -3.717925 0.061 -0.915775 -0.568025 -0.64995 -1.7709 -0.439175ZM10.0418 9.81945s0.936 -1.45575 2.523525 -1.00455c1.588525 0.451225 1.711525 2.207425 1.711525 2.207425l-4.23505 -1.202875ZM13.917 16.352c-2.79235 -0.817975 -3.223 -3.04465 -3.223 -3.04465l7.501125 2.0972c0 -0.00035 -1.5141 1.755175 -4.278125 0.94745Zm2.6521 -4.57605s0.9347 -1.45475 2.521925 -1.00225c1.587175 0.4519 1.71215 2.2081 1.71215 2.2081l-4.234075 -1.20585Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#d65348",
            d: "M8.2299 14.808525 5.4695 15.590875s0.29985 -1.708225 2.33335 -2.385175l-1.563075 -5.865975 -0.135075 0.04105c-1.93825 0.5227 -3.505225 0.384025 -4.15903 0.2708 -0.9268775 -0.159825 -1.411685 -0.36345 -1.3663375 0.341625 0.0394775 0.621825 0.187595 1.585875 0.5268925 2.85925 0.7340675 2.757425 3.160075 8.07075 7.744875 6.8359l0.135075 -0.042425 -0.756275 -2.8374ZM2.8657 10.8903l3.258275 -0.858375s-0.094975 1.25345 -1.316425 1.57545c-1.221825 0.321675 -1.94185 -0.717075 -1.94185 -0.717075Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#1d8d22",
            d: "m14.04295 16.382625 -0.1263 -0.0307c-2.792325 -0.8179 -3.223 -3.044575 -3.223 -3.044575l3.86805 1.0812 2.047825 -7.86915 -0.024775 -0.006525c-2.5118 -0.672675 -4.17825 -1.849175 -4.838625 -2.402175 -0.936 -0.783975 -1.347725 -1.328825 -1.752925 -0.5047 -0.357875 0.726875 -0.815975 1.909875 -1.259375 3.565925 -0.960775 3.586125 -1.67885 11.15385 4.260525 12.74625l0.121725 0.027425 0.926875 -3.562975ZM10.0418 9.819475s0.936 -1.455775 2.523525 -1.004575c1.588525 0.451225 1.711525 2.207425 1.711525 2.207425l-4.23505 -1.20285Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#c04b41",
            d: "m8.37055 14.7683 -0.740275 0.2101c0.174875 0.9859 0.483125 1.93205 0.966975 2.7679 0.0842 -0.0186 0.167725 -0.034575 0.2535 -0.058075 0.2248 -0.06065 0.43325 -0.13575 0.63395 -0.21765 -0.5406 -0.802225 -0.898225 -1.726175 -1.11415 -2.702275Zm-0.289075 -6.9439c-0.3804 1.419825 -0.720725 3.46345 -0.62705 5.51325 0.167675 -0.072775 0.3448 -0.140575 0.54155 -0.1964l0.13705 -0.030625c-0.167075 -2.189525 0.194075 -4.4207 0.600925 -5.93875 0.103125 -0.384025 0.206525 -0.741225 0.3096 -1.07435 -0.166025 0.105675 -0.3448 0.213975 -0.548425 0.32555 -0.137325 0.42385 -0.276 0.887125 -0.41365 1.401325Z",
            strokeWidth: "0.25"
          }
        )
      ]
    }
  );
}
function yde({ className: e }) {
  return /* @__PURE__ */ v.jsx(
    "img",
    {
      className: e,
      src: "https://avatars.githubusercontent.com/u/133959746?s=48&v=4",
      alt: "PageIndex logo"
    }
  );
}
function vde({ className: e }) {
  return /* @__PURE__ */ v.jsx("svg", { className: e, viewBox: "0 0 317.68 137.05", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ v.jsx("path", { fill: "currentColor", d: "M25.99,135.17c-2.06,0-4.14-.68-5.86-2.09-3.98-3.24-4.58-9.1-1.34-13.08l46.64-57.29c.2-.24.41-.48.63-.7,9.83-9.83,9.83-25.82,0-35.65-4.72-4.72-14.94-9.06-26.23-7.43-6.74.97-16.09,4.54-22.37,16.06-2.46,4.51-8.11,6.17-12.61,3.71C.34,36.25-1.32,30.61,1.14,26.1,8.91,11.84,21.71,2.76,37.18.53c15.58-2.25,32.08,2.73,42.03,12.68,16.96,16.96,17.07,44.48.35,61.59l-46.36,56.94c-1.84,2.26-4.52,3.43-7.22,3.43ZM186.55,127.75v-24.69c0-5.14-4.16-9.3-9.3-9.3h-54.32l60.87-76.33c3.2-4.01,2.54-9.86-1.47-13.06-4.01-3.2-9.86-2.55-13.06,1.47l-72.91,91.42c-2.23,2.79-2.66,6.61-1.11,9.83,1.55,3.22,4.81,5.26,8.38,5.26h64.33v15.4c0,5.14,4.16,9.3,9.3,9.3s9.3-4.16,9.3-9.3ZM230.44,102.08l66.95-83.6c3.21-4.01,2.56-9.86-1.44-13.07-4.01-3.21-9.86-2.56-13.07,1.44l-50.39,62.93V10.16c0-5.14-4.16-9.3-9.3-9.3s-9.3,4.16-9.3,9.3v86.11c0,3.95,2.49,7.47,6.22,8.77,1.01.35,2.05.53,3.08.53,2.77,0,5.46-1.24,7.26-3.49ZM314.93,131.23c3.64-3.62,3.67-9.5.05-13.15l-59.63-60.08c-3.62-3.64-9.5-3.67-13.15-.05-3.64,3.62-3.67,9.5-.05,13.15l59.63,60.08c1.82,1.83,4.21,2.75,6.6,2.75s4.74-.9,6.55-2.7Z" }) });
}
const Rb = [
  {
    name: "24KTwin-Editor-MCP-Remote",
    label: "24K Twin Editor MCP Remote",
    config: {
      type: "http",
      url: "https://dev.24kstudio.surbana.tech/mcp-remote/mcp"
    },
    icon: vde
  },
  {
    name: "playwright",
    label: "Playwright",
    config: {
      command: "npx",
      args: ["@playwright/mcp@latest"]
    },
    icon: gde
  },
  {
    name: "pageindex",
    label: "PageIndex",
    config: {
      type: "http",
      url: "https://mcp.pageindex.ai/mcp"
    },
    icon: yde
  }
];
function bde() {
  const e = (t, n) => {
    t.preventDefault(), t.stopPropagation();
    const r = new URLSearchParams();
    r.set("name", n.name), r.set("config", JSON.stringify(n.config)), window.open(`/chat-bot/mcp/create?${r.toString()}`, "_blank");
  };
  return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-4", children: [
    /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col items-center justify-center space-y-4 my-20", children: [
      /* @__PURE__ */ v.jsxs("h3", { className: "text-2xl md:text-4xl font-semibold flex items-center gap-3", children: [
        /* @__PURE__ */ v.jsx(bh, { className: "fill-foreground size-6 hidden sm:block" }),
        "Connect Your First Server"
      ] }),
      /* @__PURE__ */ v.jsx("p", { className: "text-muted-foreground max-w-md", children: "Add MCP servers to unlock powerful AI integrations" }),
      /* @__PURE__ */ v.jsx(
        Ow,
        {
          to: "/chat-bot/mcp/create",
          className: "cursor-pointer",
          children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-xl font-bold overflow-hidden ", children: [
            "Add MCP Server",
            /* @__PURE__ */ v.jsx(XZ, { className: "size-6" })
          ] })
        }
      )
    ] }),
    /* @__PURE__ */ v.jsx("div", { className: "flex gap-2 flex-wrap justify-center", children: Rb.map((t) => {
      const n = t.icon;
      return /* @__PURE__ */ v.jsxs(
        qt,
        {
          variant: "secondary",
          className: "hover:-translate-y-0.5 transition-all duration-300 cursor-pointer flex items-center",
          onClick: (r) => e(r, t),
          children: [
            /* @__PURE__ */ v.jsx(n, { className: "h-6 w-6 my-auto text-primary-foreground stroke-primary-foreground" }),
            t.label
          ]
        },
        t.name
      );
    }) })
  ] });
}
const xde = 2500, vU = (e) => e.toLowerCase().replace(/[^a-z0-9]/g, ""), wde = new Map(
  Rb.map((e) => [vU(e.name), e.icon])
), nj = C.memo(function({
  id: t,
  config: n,
  error: r,
  status: i,
  name: o,
  toolInfo: s,
  visibility: a,
  authorizationUrl: c,
  icon: u
}) {
  const { mutate: f } = H9(), [h, m] = C.useState(!1), [g, b] = C.useState(!1), [x, w] = C.useState(""), [S, _] = C.useState(!1), M = C.useRef(null), N = C.useMemo(() => h || g || i === "loading", [h, g, i]), D = i === "authorizing", j = D && !!c, O = C.useMemo(() => r ? xh(r) ? r : JSON.stringify(r) : null, [r]), L = vU(o ?? ""), U = wde.get(L), B = u?.value?.trim(), G = u?.style?.backgroundColor, Y = !!B && (/^(data:image\/|https?:\/\/|\/)/i.test(B) || /\.(svg|png|jpe?g|webp|gif)$/i.test(B)), he = C.useCallback(async (Se) => {
    try {
      m(!0), await mde(Se), await f(`${Ys}/list`);
    } catch (W) {
      Ab(W);
    } finally {
      m(!1);
    }
  }, [f]), ie = C.useCallback(
    () => {
    },
    [t]
  ), ne = C.useCallback(async () => {
    try {
      b(!0), await pde(t), await f(`${Ys}/list`);
    } catch (Se) {
      Ab(Se);
    } finally {
      b(!1);
    }
  }, [t, f]), H = C.useCallback(() => {
    M.current !== null && (window.clearInterval(M.current), M.current = null), _(!1);
  }, []), Q = C.useCallback(() => {
    M.current === null && (M.current = window.setInterval(() => {
      f(`${Ys}/list`);
    }, xde), _(!0));
  }, [f]);
  C.useEffect(() => {
    (!D || r) && H();
  }, [r, D, H]), C.useEffect(() => {
    if (!D) return;
    const Se = sessionStorage.getItem("mcp:auto-authorize");
    Se && String(Se) === String(t) && (sessionStorage.removeItem("mcp:auto-authorize"), Q());
  }, [t, D, Q]), C.useEffect(() => H, [H]);
  const X = C.useCallback(() => {
    c && (window.open(c, "_blank", "noopener,noreferrer"), Q()), f(`${Ys}/list`);
  }, [c, f, Q]);
  return /* @__PURE__ */ v.jsxs(
    q9,
    {
      className: "relative hover:border-foreground/20 transition-colors bg-secondary/40",
      "data-testid": "mcp-server-card",
      "data-featured": a === "public",
      children: [
        N && /* @__PURE__ */ v.jsx("div", { className: "animate-pulse z-50 absolute inset-0 bg-background/50 flex items-center justify-center w-full h-full pointer-events-auto" }),
        /* @__PURE__ */ v.jsxs(
          G9,
          {
            className: "flex items-center gap-3 mb-2",
            children: [
              N && /* @__PURE__ */ v.jsx(dA, { className: "size-4 z-20 animate-spin mr-1" }),
              /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3", children: [
                /* @__PURE__ */ v.jsx(
                  "div",
                  {
                    className: "flex h-8 w-8 items-center justify-center rounded-xl border border-border/70 bg-muted/60",
                    style: G ? { backgroundColor: G } : void 0,
                    children: Y ? /* @__PURE__ */ v.jsx(
                      "img",
                      {
                        src: B,
                        alt: `${o} logo`,
                        className: "h-4 w-4 object-contain"
                      }
                    ) : B ? /* @__PURE__ */ v.jsx("span", { className: "text-base leading-none", children: B }) : U ? /* @__PURE__ */ v.jsx(U, { className: "size-4" }) : /* @__PURE__ */ v.jsx(bh, { className: "size-4 text-muted-foreground" })
                  }
                ),
                /* @__PURE__ */ v.jsx("h4", { className: "font-bold text-xs sm:text-lg flex items-center gap-1", children: o })
              ] }),
              /* @__PURE__ */ v.jsx("div", { className: "flex-1" }),
              D && /* @__PURE__ */ v.jsxs(
                qt,
                {
                  variant: "outline",
                  size: "sm",
                  className: "gap-2 cursor-pointer",
                  onClick: X,
                  disabled: !j,
                  children: [
                    /* @__PURE__ */ v.jsx(ub, { className: "size-3.5" }),
                    "Authorize"
                  ]
                }
              ),
              /* @__PURE__ */ v.jsx("div", { className: "h-4", children: /* @__PURE__ */ v.jsx(_M, { orientation: "vertical" }) }),
              /* @__PURE__ */ v.jsxs(Yi, { children: [
                /* @__PURE__ */ v.jsx(go, { asChild: !0, children: /* @__PURE__ */ v.jsx(
                  qt,
                  {
                    variant: "ghost",
                    size: "icon",
                    onClick: () => he(t),
                    className: "cursor-pointer",
                    disabled: N,
                    children: h ? /* @__PURE__ */ v.jsx(ea, { className: "size-4 animate-spin" }) : /* @__PURE__ */ v.jsx(pX, { className: "size-3.5 " })
                  }
                ) }),
                /* @__PURE__ */ v.jsx(ww, { children: "Refresh" })
              ] }),
              /* @__PURE__ */ v.jsx(
                hde,
                {
                  type: "mcp",
                  visibility: a === "public" ? "public" : "private",
                  isOwner: !0,
                  canChangeVisibility: !0,
                  editHref: `/chat-bot/mcp/modify?id=${encodeURIComponent(t)}&name=${encodeURIComponent(o)}&config=${encodeURIComponent(JSON.stringify(n))}`,
                  onVisibilityChange: ie,
                  onDelete: ne,
                  isVisibilityChangeLoading: !1,
                  isDeleteLoading: g,
                  disabled: N,
                  renderActions: () => null
                }
              )
            ]
          },
          `header-${i}-${D}`
        ),
        D && /* @__PURE__ */ v.jsxs("div", { className: "px-6 pb-2 text-xs text-muted-foreground flex items-center gap-2", children: [
          /* @__PURE__ */ v.jsx(ub, { className: "size-3.5" }),
          S ? "Waiting for authorization to complete." : "Pending authorization."
        ] }),
        O && /* @__PURE__ */ v.jsx(J9, { error: O }),
        /* @__PURE__ */ v.jsx("div", { className: "relative hidden sm:flex w-full", children: /* @__PURE__ */ v.jsxs(K9, { className: "flex min-w-0 w-full flex-row text-sm max-h-80 overflow-hidden border-r-0", children: [
          /* @__PURE__ */ v.jsxs("div", { className: "w-1/2 min-w-0 flex flex-col pr-2 border-r border-border", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 mb-2 pt-2 pb-1 z-10", children: [
              /* @__PURE__ */ v.jsx(S4, { size: 14, className: "text-muted-foreground" }),
              /* @__PURE__ */ v.jsx("h5", { className: "text-muted-foreground text-sm font-medium", children: "Configuration Preview" })
            ] }),
            /* @__PURE__ */ v.jsx("div", { className: "flex-1 overflow-y-auto", children: /* @__PURE__ */ v.jsx(id, { data: n }) })
          ] }),
          /* @__PURE__ */ v.jsxs("div", { className: "w-1/2 min-w-0 flex flex-col pl-4", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 mb-2 pt-2 pb-1 z-10", children: [
              /* @__PURE__ */ v.jsx(db, { size: 14, className: "text-muted-foreground" }),
              /* @__PURE__ */ v.jsxs("h5", { className: "text-muted-foreground text-sm font-medium", children: [
                "Available Tools ",
                s.length > 0 ? `(${s.length})` : ""
              ] })
            ] }),
            /* @__PURE__ */ v.jsxs("div", { className: "relative mb-3", children: [
              /* @__PURE__ */ v.jsx(gX, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" }),
              /* @__PURE__ */ v.jsx(
                EM,
                {
                  type: "text",
                  placeholder: "Search tools...",
                  value: x,
                  onChange: (Se) => w(Se.target.value),
                  className: "pl-9 h-8 text-sm"
                }
              )
            ] }),
            /* @__PURE__ */ v.jsx("div", { className: "flex-1 overflow-y-auto", children: s.length > 0 ? /* @__PURE__ */ v.jsx(Uce, { tools: s, serverId: t, searchQuery: x }) : /* @__PURE__ */ v.jsx("div", { className: "bg-secondary/30 rounded-md p-3 text-center", children: /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground", children: "No tools available" }) }) })
          ] })
        ] }) })
      ]
    },
    `mcp-card-${t}-${i}`
  );
});
var fC = "rovingFocusGroup.onEntryFocus", Sde = { bubbles: !1, cancelable: !0 }, sy = "RovingFocusGroup", [F_, bU, kde] = xM(sy), [Cde, xU] = bs(
  sy,
  [kde]
), [Ede, _de] = Cde(sy), wU = C.forwardRef(
  (e, t) => /* @__PURE__ */ v.jsx(F_.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ v.jsx(F_.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ v.jsx(Tde, { ...e, ref: t }) }) })
);
wU.displayName = sy;
var Tde = C.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: i = !1,
    dir: o,
    currentTabStopId: s,
    defaultCurrentTabStopId: a,
    onCurrentTabStopIdChange: c,
    onEntryFocus: u,
    preventScrollOnEntryFocus: f = !1,
    ...h
  } = e, m = C.useRef(null), g = Ht(t, m), b = ow(o), [x, w] = il({
    prop: s,
    defaultProp: a ?? null,
    onChange: c,
    caller: sy
  }), [S, _] = C.useState(!1), M = Ir(u), N = bU(n), D = C.useRef(!1), [j, O] = C.useState(0);
  return C.useEffect(() => {
    const L = m.current;
    if (L)
      return L.addEventListener(fC, M), () => L.removeEventListener(fC, M);
  }, [M]), /* @__PURE__ */ v.jsx(
    Ede,
    {
      scope: n,
      orientation: r,
      dir: b,
      loop: i,
      currentTabStopId: x,
      onItemFocus: C.useCallback(
        (L) => w(L),
        [w]
      ),
      onItemShiftTab: C.useCallback(() => _(!0), []),
      onFocusableItemAdd: C.useCallback(
        () => O((L) => L + 1),
        []
      ),
      onFocusableItemRemove: C.useCallback(
        () => O((L) => L - 1),
        []
      ),
      children: /* @__PURE__ */ v.jsx(
        _t.div,
        {
          tabIndex: S || j === 0 ? -1 : 0,
          "data-orientation": r,
          ...h,
          ref: g,
          style: { outline: "none", ...e.style },
          onMouseDown: Ye(e.onMouseDown, () => {
            D.current = !0;
          }),
          onFocus: Ye(e.onFocus, (L) => {
            const U = !D.current;
            if (L.target === L.currentTarget && U && !S) {
              const B = new CustomEvent(fC, Sde);
              if (L.currentTarget.dispatchEvent(B), !B.defaultPrevented) {
                const G = N().filter((H) => H.focusable), Y = G.find((H) => H.active), he = G.find((H) => H.id === x), ne = [Y, he, ...G].filter(
                  Boolean
                ).map((H) => H.ref.current);
                CU(ne, f);
              }
            }
            D.current = !1;
          }),
          onBlur: Ye(e.onBlur, () => _(!1))
        }
      )
    }
  );
}), SU = "RovingFocusGroupItem", kU = C.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: i = !1,
      tabStopId: o,
      children: s,
      ...a
    } = e, c = Wo(), u = o || c, f = _de(SU, n), h = f.currentTabStopId === u, m = bU(n), { onFocusableItemAdd: g, onFocusableItemRemove: b, currentTabStopId: x } = f;
    return C.useEffect(() => {
      if (r)
        return g(), () => b();
    }, [r, g, b]), /* @__PURE__ */ v.jsx(
      F_.ItemSlot,
      {
        scope: n,
        id: u,
        focusable: r,
        active: i,
        children: /* @__PURE__ */ v.jsx(
          _t.span,
          {
            tabIndex: h ? 0 : -1,
            "data-orientation": f.orientation,
            ...a,
            ref: t,
            onMouseDown: Ye(e.onMouseDown, (w) => {
              r ? f.onItemFocus(u) : w.preventDefault();
            }),
            onFocus: Ye(e.onFocus, () => f.onItemFocus(u)),
            onKeyDown: Ye(e.onKeyDown, (w) => {
              if (w.key === "Tab" && w.shiftKey) {
                f.onItemShiftTab();
                return;
              }
              if (w.target !== w.currentTarget) return;
              const S = Nde(w, f.orientation, f.dir);
              if (S !== void 0) {
                if (w.metaKey || w.ctrlKey || w.altKey || w.shiftKey) return;
                w.preventDefault();
                let M = m().filter((N) => N.focusable).map((N) => N.ref.current);
                if (S === "last") M.reverse();
                else if (S === "prev" || S === "next") {
                  S === "prev" && M.reverse();
                  const N = M.indexOf(w.currentTarget);
                  M = f.loop ? Rde(M, N + 1) : M.slice(N + 1);
                }
                setTimeout(() => CU(M));
              }
            }),
            children: typeof s == "function" ? s({ isCurrentTabStop: h, hasTabStop: x != null }) : s
          }
        )
      }
    );
  }
);
kU.displayName = SU;
var Ade = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Mde(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function Nde(e, t, n) {
  const r = Mde(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return Ade[r];
}
function CU(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function Rde(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var Ode = wU, Pde = kU, V_ = ["Enter", " "], Dde = ["ArrowDown", "PageUp", "Home"], EU = ["ArrowUp", "PageDown", "End"], Ide = [...Dde, ...EU], jde = {
  ltr: [...V_, "ArrowRight"],
  rtl: [...V_, "ArrowLeft"]
}, zde = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, ay = "Menu", [hg, Lde, Bde] = xM(ay), [wd, _U] = bs(ay, [
  Bde,
  Uh,
  xU
]), ly = Uh(), TU = xU(), [AU, Hc] = wd(ay), [$de, cy] = wd(ay), MU = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: i, onOpenChange: o, modal: s = !0 } = e, a = ly(t), [c, u] = C.useState(null), f = C.useRef(!1), h = Ir(o), m = ow(i);
  return C.useEffect(() => {
    const g = () => {
      f.current = !0, document.addEventListener("pointerdown", b, { capture: !0, once: !0 }), document.addEventListener("pointermove", b, { capture: !0, once: !0 });
    }, b = () => f.current = !1;
    return document.addEventListener("keydown", g, { capture: !0 }), () => {
      document.removeEventListener("keydown", g, { capture: !0 }), document.removeEventListener("pointerdown", b, { capture: !0 }), document.removeEventListener("pointermove", b, { capture: !0 });
    };
  }, []), /* @__PURE__ */ v.jsx(vw, { ...a, children: /* @__PURE__ */ v.jsx(
    AU,
    {
      scope: t,
      open: n,
      onOpenChange: h,
      content: c,
      onContentChange: u,
      children: /* @__PURE__ */ v.jsx(
        $de,
        {
          scope: t,
          onClose: C.useCallback(() => h(!1), [h]),
          isUsingKeyboardRef: f,
          dir: m,
          modal: s,
          children: r
        }
      )
    }
  ) });
};
MU.displayName = ay;
var Ude = "MenuAnchor", DM = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = ly(n);
    return /* @__PURE__ */ v.jsx(cM, { ...i, ...r, ref: t });
  }
);
DM.displayName = Ude;
var IM = "MenuPortal", [Fde, NU] = wd(IM, {
  forceMount: void 0
}), RU = (e) => {
  const { __scopeMenu: t, forceMount: n, children: r, container: i } = e, o = Hc(IM, t);
  return /* @__PURE__ */ v.jsx(Fde, { scope: t, forceMount: n, children: /* @__PURE__ */ v.jsx(ji, { present: n || o.open, children: /* @__PURE__ */ v.jsx(ey, { asChild: !0, container: i, children: r }) }) });
};
RU.displayName = IM;
var qo = "MenuContent", [Vde, jM] = wd(qo), OU = C.forwardRef(
  (e, t) => {
    const n = NU(qo, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = Hc(qo, e.__scopeMenu), s = cy(qo, e.__scopeMenu);
    return /* @__PURE__ */ v.jsx(hg.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ v.jsx(ji, { present: r || o.open, children: /* @__PURE__ */ v.jsx(hg.Slot, { scope: e.__scopeMenu, children: s.modal ? /* @__PURE__ */ v.jsx(Hde, { ...i, ref: t }) : /* @__PURE__ */ v.jsx(Wde, { ...i, ref: t }) }) }) });
  }
), Hde = C.forwardRef(
  (e, t) => {
    const n = Hc(qo, e.__scopeMenu), r = C.useRef(null), i = Ht(t, r);
    return C.useEffect(() => {
      const o = r.current;
      if (o) return gM(o);
    }, []), /* @__PURE__ */ v.jsx(
      zM,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Ye(
          e.onFocusOutside,
          (o) => o.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), Wde = C.forwardRef((e, t) => {
  const n = Hc(qo, e.__scopeMenu);
  return /* @__PURE__ */ v.jsx(
    zM,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), qde = /* @__PURE__ */ hh("MenuContent.ScrollLock"), zM = C.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: i,
      onOpenAutoFocus: o,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: a,
      onEntryFocus: c,
      onEscapeKeyDown: u,
      onPointerDownOutside: f,
      onFocusOutside: h,
      onInteractOutside: m,
      onDismiss: g,
      disableOutsideScroll: b,
      ...x
    } = e, w = Hc(qo, n), S = cy(qo, n), _ = ly(n), M = TU(n), N = Lde(n), [D, j] = C.useState(null), O = C.useRef(null), L = Ht(t, O, w.onContentChange), U = C.useRef(0), B = C.useRef(""), G = C.useRef(0), Y = C.useRef(null), he = C.useRef("right"), ie = C.useRef(0), ne = b ? Cw : C.Fragment, H = b ? { as: qde, allowPinchZoom: !0 } : void 0, Q = (Se) => {
      const W = B.current + Se, Z = N().filter((J) => !J.disabled), pe = document.activeElement, F = Z.find((J) => J.ref.current === pe)?.textValue, ee = Z.map((J) => J.textValue), ge = ife(ee, W, F), re = Z.find((J) => J.textValue === ge)?.ref.current;
      (function J(xe) {
        B.current = xe, window.clearTimeout(U.current), xe !== "" && (U.current = window.setTimeout(() => J(""), 1e3));
      })(W), re && setTimeout(() => re.focus());
    };
    C.useEffect(() => () => window.clearTimeout(U.current), []), mM();
    const X = C.useCallback((Se) => he.current === Y.current?.side && sfe(Se, Y.current?.area), []);
    return /* @__PURE__ */ v.jsx(
      Vde,
      {
        scope: n,
        searchRef: B,
        onItemEnter: C.useCallback(
          (Se) => {
            X(Se) && Se.preventDefault();
          },
          [X]
        ),
        onItemLeave: C.useCallback(
          (Se) => {
            X(Se) || (O.current?.focus(), j(null));
          },
          [X]
        ),
        onTriggerLeave: C.useCallback(
          (Se) => {
            X(Se) && Se.preventDefault();
          },
          [X]
        ),
        pointerGraceTimerRef: G,
        onPointerGraceIntentChange: C.useCallback((Se) => {
          Y.current = Se;
        }, []),
        children: /* @__PURE__ */ v.jsx(ne, { ...H, children: /* @__PURE__ */ v.jsx(
          Sw,
          {
            asChild: !0,
            trapped: i,
            onMountAutoFocus: Ye(o, (Se) => {
              Se.preventDefault(), O.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: s,
            children: /* @__PURE__ */ v.jsx(
              Jg,
              {
                asChild: !0,
                disableOutsidePointerEvents: a,
                onEscapeKeyDown: u,
                onPointerDownOutside: f,
                onFocusOutside: h,
                onInteractOutside: m,
                onDismiss: g,
                children: /* @__PURE__ */ v.jsx(
                  Ode,
                  {
                    asChild: !0,
                    ...M,
                    dir: S.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: D,
                    onCurrentTabStopIdChange: j,
                    onEntryFocus: Ye(c, (Se) => {
                      S.isUsingKeyboardRef.current || Se.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ v.jsx(
                      uM,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": ZU(w.open),
                        "data-radix-menu-content": "",
                        dir: S.dir,
                        ..._,
                        ...x,
                        ref: L,
                        style: { outline: "none", ...x.style },
                        onKeyDown: Ye(x.onKeyDown, (Se) => {
                          const Z = Se.target.closest("[data-radix-menu-content]") === Se.currentTarget, pe = Se.ctrlKey || Se.altKey || Se.metaKey, F = Se.key.length === 1;
                          Z && (Se.key === "Tab" && Se.preventDefault(), !pe && F && Q(Se.key));
                          const ee = O.current;
                          if (Se.target !== ee || !Ide.includes(Se.key)) return;
                          Se.preventDefault();
                          const re = N().filter((J) => !J.disabled).map((J) => J.ref.current);
                          EU.includes(Se.key) && re.reverse(), nfe(re);
                        }),
                        onBlur: Ye(e.onBlur, (Se) => {
                          Se.currentTarget.contains(Se.target) || (window.clearTimeout(U.current), B.current = "");
                        }),
                        onPointerMove: Ye(
                          e.onPointerMove,
                          pg((Se) => {
                            const W = Se.target, Z = ie.current !== Se.clientX;
                            if (Se.currentTarget.contains(W) && Z) {
                              const pe = Se.clientX > ie.current ? "right" : "left";
                              he.current = pe, ie.current = Se.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
OU.displayName = qo;
var Gde = "MenuGroup", LM = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ v.jsx(_t.div, { role: "group", ...r, ref: t });
  }
);
LM.displayName = Gde;
var Kde = "MenuLabel", PU = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ v.jsx(_t.div, { ...r, ref: t });
  }
);
PU.displayName = Kde;
var Ob = "MenuItem", rj = "menu.itemSelect", Pw = C.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...i } = e, o = C.useRef(null), s = cy(Ob, e.__scopeMenu), a = jM(Ob, e.__scopeMenu), c = Ht(t, o), u = C.useRef(!1), f = () => {
      const h = o.current;
      if (!n && h) {
        const m = new CustomEvent(rj, { bubbles: !0, cancelable: !0 });
        h.addEventListener(rj, (g) => r?.(g), { once: !0 }), _4(h, m), m.defaultPrevented ? u.current = !1 : s.onClose();
      }
    };
    return /* @__PURE__ */ v.jsx(
      DU,
      {
        ...i,
        ref: c,
        disabled: n,
        onClick: Ye(e.onClick, f),
        onPointerDown: (h) => {
          e.onPointerDown?.(h), u.current = !0;
        },
        onPointerUp: Ye(e.onPointerUp, (h) => {
          u.current || h.currentTarget?.click();
        }),
        onKeyDown: Ye(e.onKeyDown, (h) => {
          const m = a.searchRef.current !== "";
          n || m && h.key === " " || V_.includes(h.key) && (h.currentTarget.click(), h.preventDefault());
        })
      }
    );
  }
);
Pw.displayName = Ob;
var DU = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: i, ...o } = e, s = jM(Ob, n), a = TU(n), c = C.useRef(null), u = Ht(t, c), [f, h] = C.useState(!1), [m, g] = C.useState("");
    return C.useEffect(() => {
      const b = c.current;
      b && g((b.textContent ?? "").trim());
    }, [o.children]), /* @__PURE__ */ v.jsx(
      hg.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: i ?? m,
        children: /* @__PURE__ */ v.jsx(Pde, { asChild: !0, ...a, focusable: !r, children: /* @__PURE__ */ v.jsx(
          _t.div,
          {
            role: "menuitem",
            "data-highlighted": f ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...o,
            ref: u,
            onPointerMove: Ye(
              e.onPointerMove,
              pg((b) => {
                r ? s.onItemLeave(b) : (s.onItemEnter(b), b.defaultPrevented || b.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Ye(
              e.onPointerLeave,
              pg((b) => s.onItemLeave(b))
            ),
            onFocus: Ye(e.onFocus, () => h(!0)),
            onBlur: Ye(e.onBlur, () => h(!1))
          }
        ) })
      }
    );
  }
), Zde = "MenuCheckboxItem", IU = C.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...i } = e;
    return /* @__PURE__ */ v.jsx($U, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ v.jsx(
      Pw,
      {
        role: "menuitemcheckbox",
        "aria-checked": Pb(n) ? "mixed" : n,
        ...i,
        ref: t,
        "data-state": UM(n),
        onSelect: Ye(
          i.onSelect,
          () => r?.(Pb(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
IU.displayName = Zde;
var jU = "MenuRadioGroup", [Yde, Xde] = wd(
  jU,
  { value: void 0, onValueChange: () => {
  } }
), zU = C.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...i } = e, o = Ir(r);
    return /* @__PURE__ */ v.jsx(Yde, { scope: e.__scopeMenu, value: n, onValueChange: o, children: /* @__PURE__ */ v.jsx(LM, { ...i, ref: t }) });
  }
);
zU.displayName = jU;
var LU = "MenuRadioItem", BU = C.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, i = Xde(LU, e.__scopeMenu), o = n === i.value;
    return /* @__PURE__ */ v.jsx($U, { scope: e.__scopeMenu, checked: o, children: /* @__PURE__ */ v.jsx(
      Pw,
      {
        role: "menuitemradio",
        "aria-checked": o,
        ...r,
        ref: t,
        "data-state": UM(o),
        onSelect: Ye(
          r.onSelect,
          () => i.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
BU.displayName = LU;
var BM = "MenuItemIndicator", [$U, Jde] = wd(
  BM,
  { checked: !1 }
), UU = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...i } = e, o = Jde(BM, n);
    return /* @__PURE__ */ v.jsx(
      ji,
      {
        present: r || Pb(o.checked) || o.checked === !0,
        children: /* @__PURE__ */ v.jsx(
          _t.span,
          {
            ...i,
            ref: t,
            "data-state": UM(o.checked)
          }
        )
      }
    );
  }
);
UU.displayName = BM;
var Qde = "MenuSeparator", FU = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ v.jsx(
      _t.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
FU.displayName = Qde;
var efe = "MenuArrow", VU = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = ly(n);
    return /* @__PURE__ */ v.jsx(dM, { ...i, ...r, ref: t });
  }
);
VU.displayName = efe;
var $M = "MenuSub", [tfe, HU] = wd($M), WU = (e) => {
  const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: i } = e, o = Hc($M, t), s = ly(t), [a, c] = C.useState(null), [u, f] = C.useState(null), h = Ir(i);
  return C.useEffect(() => (o.open === !1 && h(!1), () => h(!1)), [o.open, h]), /* @__PURE__ */ v.jsx(vw, { ...s, children: /* @__PURE__ */ v.jsx(
    AU,
    {
      scope: t,
      open: r,
      onOpenChange: h,
      content: u,
      onContentChange: f,
      children: /* @__PURE__ */ v.jsx(
        tfe,
        {
          scope: t,
          contentId: Wo(),
          triggerId: Wo(),
          trigger: a,
          onTriggerChange: c,
          children: n
        }
      )
    }
  ) });
};
WU.displayName = $M;
var xm = "MenuSubTrigger", qU = C.forwardRef(
  (e, t) => {
    const n = Hc(xm, e.__scopeMenu), r = cy(xm, e.__scopeMenu), i = HU(xm, e.__scopeMenu), o = jM(xm, e.__scopeMenu), s = C.useRef(null), { pointerGraceTimerRef: a, onPointerGraceIntentChange: c } = o, u = { __scopeMenu: e.__scopeMenu }, f = C.useCallback(() => {
      s.current && window.clearTimeout(s.current), s.current = null;
    }, []);
    return C.useEffect(() => f, [f]), C.useEffect(() => {
      const h = a.current;
      return () => {
        window.clearTimeout(h), c(null);
      };
    }, [a, c]), /* @__PURE__ */ v.jsx(DM, { asChild: !0, ...u, children: /* @__PURE__ */ v.jsx(
      DU,
      {
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": i.contentId,
        "data-state": ZU(n.open),
        ...e,
        ref: Wg(t, i.onTriggerChange),
        onClick: (h) => {
          e.onClick?.(h), !(e.disabled || h.defaultPrevented) && (h.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Ye(
          e.onPointerMove,
          pg((h) => {
            o.onItemEnter(h), !h.defaultPrevented && !e.disabled && !n.open && !s.current && (o.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => {
              n.onOpenChange(!0), f();
            }, 100));
          })
        ),
        onPointerLeave: Ye(
          e.onPointerLeave,
          pg((h) => {
            f();
            const m = n.content?.getBoundingClientRect();
            if (m) {
              const g = n.content?.dataset.side, b = g === "right", x = b ? -5 : 5, w = m[b ? "left" : "right"], S = m[b ? "right" : "left"];
              o.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: h.clientX + x, y: h.clientY },
                  { x: w, y: m.top },
                  { x: S, y: m.top },
                  { x: S, y: m.bottom },
                  { x: w, y: m.bottom }
                ],
                side: g
              }), window.clearTimeout(a.current), a.current = window.setTimeout(
                () => o.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (o.onTriggerLeave(h), h.defaultPrevented) return;
              o.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Ye(e.onKeyDown, (h) => {
          const m = o.searchRef.current !== "";
          e.disabled || m && h.key === " " || jde[r.dir].includes(h.key) && (n.onOpenChange(!0), n.content?.focus(), h.preventDefault());
        })
      }
    ) });
  }
);
qU.displayName = xm;
var GU = "MenuSubContent", KU = C.forwardRef(
  (e, t) => {
    const n = NU(qo, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = Hc(qo, e.__scopeMenu), s = cy(qo, e.__scopeMenu), a = HU(GU, e.__scopeMenu), c = C.useRef(null), u = Ht(t, c);
    return /* @__PURE__ */ v.jsx(hg.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ v.jsx(ji, { present: r || o.open, children: /* @__PURE__ */ v.jsx(hg.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ v.jsx(
      zM,
      {
        id: a.contentId,
        "aria-labelledby": a.triggerId,
        ...i,
        ref: u,
        align: "start",
        side: s.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (f) => {
          s.isUsingKeyboardRef.current && c.current?.focus(), f.preventDefault();
        },
        onCloseAutoFocus: (f) => f.preventDefault(),
        onFocusOutside: Ye(e.onFocusOutside, (f) => {
          f.target !== a.trigger && o.onOpenChange(!1);
        }),
        onEscapeKeyDown: Ye(e.onEscapeKeyDown, (f) => {
          s.onClose(), f.preventDefault();
        }),
        onKeyDown: Ye(e.onKeyDown, (f) => {
          const h = f.currentTarget.contains(f.target), m = zde[s.dir].includes(f.key);
          h && m && (o.onOpenChange(!1), a.trigger?.focus(), f.preventDefault());
        })
      }
    ) }) }) });
  }
);
KU.displayName = GU;
function ZU(e) {
  return e ? "open" : "closed";
}
function Pb(e) {
  return e === "indeterminate";
}
function UM(e) {
  return Pb(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function nfe(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function rfe(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function ife(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let s = rfe(e, Math.max(o, 0));
  i.length === 1 && (s = s.filter((u) => u !== n));
  const c = s.find(
    (u) => u.toLowerCase().startsWith(i.toLowerCase())
  );
  return c !== n ? c : void 0;
}
function ofe(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const a = t[o], c = t[s], u = a.x, f = a.y, h = c.x, m = c.y;
    f > r != m > r && n < (h - u) * (r - f) / (m - f) + u && (i = !i);
  }
  return i;
}
function sfe(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return ofe(n, t);
}
function pg(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var afe = MU, lfe = DM, cfe = RU, ufe = OU, dfe = LM, ffe = PU, hfe = Pw, pfe = IU, mfe = zU, gfe = BU, yfe = UU, vfe = FU, bfe = VU, xfe = WU, wfe = qU, Sfe = KU, Dw = "DropdownMenu", [kfe] = bs(
  Dw,
  [_U]
), wi = _U(), [Cfe, YU] = kfe(Dw), XU = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: i,
    defaultOpen: o,
    onOpenChange: s,
    modal: a = !0
  } = e, c = wi(t), u = C.useRef(null), [f, h] = il({
    prop: i,
    defaultProp: o ?? !1,
    onChange: s,
    caller: Dw
  });
  return /* @__PURE__ */ v.jsx(
    Cfe,
    {
      scope: t,
      triggerId: Wo(),
      triggerRef: u,
      contentId: Wo(),
      open: f,
      onOpenChange: h,
      onOpenToggle: C.useCallback(() => h((m) => !m), [h]),
      modal: a,
      children: /* @__PURE__ */ v.jsx(afe, { ...c, open: f, onOpenChange: h, dir: r, modal: a, children: n })
    }
  );
};
XU.displayName = Dw;
var JU = "DropdownMenuTrigger", QU = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...i } = e, o = YU(JU, n), s = wi(n);
    return /* @__PURE__ */ v.jsx(lfe, { asChild: !0, ...s, children: /* @__PURE__ */ v.jsx(
      _t.button,
      {
        type: "button",
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": o.open,
        "aria-controls": o.open ? o.contentId : void 0,
        "data-state": o.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...i,
        ref: Wg(t, o.triggerRef),
        onPointerDown: Ye(e.onPointerDown, (a) => {
          !r && a.button === 0 && a.ctrlKey === !1 && (o.onOpenToggle(), o.open || a.preventDefault());
        }),
        onKeyDown: Ye(e.onKeyDown, (a) => {
          r || (["Enter", " "].includes(a.key) && o.onOpenToggle(), a.key === "ArrowDown" && o.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault());
        })
      }
    ) });
  }
);
QU.displayName = JU;
var Efe = "DropdownMenuPortal", eF = (e) => {
  const { __scopeDropdownMenu: t, ...n } = e, r = wi(t);
  return /* @__PURE__ */ v.jsx(cfe, { ...r, ...n });
};
eF.displayName = Efe;
var tF = "DropdownMenuContent", nF = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = YU(tF, n), o = wi(n), s = C.useRef(!1);
    return /* @__PURE__ */ v.jsx(
      ufe,
      {
        id: i.contentId,
        "aria-labelledby": i.triggerId,
        ...o,
        ...r,
        ref: t,
        onCloseAutoFocus: Ye(e.onCloseAutoFocus, (a) => {
          s.current || i.triggerRef.current?.focus(), s.current = !1, a.preventDefault();
        }),
        onInteractOutside: Ye(e.onInteractOutside, (a) => {
          const c = a.detail.originalEvent, u = c.button === 0 && c.ctrlKey === !0, f = c.button === 2 || u;
          (!i.modal || f) && (s.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
nF.displayName = tF;
var _fe = "DropdownMenuGroup", rF = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = wi(n);
    return /* @__PURE__ */ v.jsx(dfe, { ...i, ...r, ref: t });
  }
);
rF.displayName = _fe;
var Tfe = "DropdownMenuLabel", iF = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = wi(n);
    return /* @__PURE__ */ v.jsx(ffe, { ...i, ...r, ref: t });
  }
);
iF.displayName = Tfe;
var Afe = "DropdownMenuItem", oF = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = wi(n);
    return /* @__PURE__ */ v.jsx(hfe, { ...i, ...r, ref: t });
  }
);
oF.displayName = Afe;
var Mfe = "DropdownMenuCheckboxItem", sF = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = wi(n);
  return /* @__PURE__ */ v.jsx(pfe, { ...i, ...r, ref: t });
});
sF.displayName = Mfe;
var Nfe = "DropdownMenuRadioGroup", Rfe = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = wi(n);
  return /* @__PURE__ */ v.jsx(mfe, { ...i, ...r, ref: t });
});
Rfe.displayName = Nfe;
var Ofe = "DropdownMenuRadioItem", Pfe = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = wi(n);
  return /* @__PURE__ */ v.jsx(gfe, { ...i, ...r, ref: t });
});
Pfe.displayName = Ofe;
var Dfe = "DropdownMenuItemIndicator", aF = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = wi(n);
  return /* @__PURE__ */ v.jsx(yfe, { ...i, ...r, ref: t });
});
aF.displayName = Dfe;
var Ife = "DropdownMenuSeparator", lF = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = wi(n);
  return /* @__PURE__ */ v.jsx(vfe, { ...i, ...r, ref: t });
});
lF.displayName = Ife;
var jfe = "DropdownMenuArrow", zfe = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = wi(n);
    return /* @__PURE__ */ v.jsx(bfe, { ...i, ...r, ref: t });
  }
);
zfe.displayName = jfe;
var Lfe = (e) => {
  const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: i, defaultOpen: o } = e, s = wi(t), [a, c] = il({
    prop: r,
    defaultProp: o ?? !1,
    onChange: i,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ v.jsx(xfe, { ...s, open: a, onOpenChange: c, children: n });
}, Bfe = "DropdownMenuSubTrigger", cF = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = wi(n);
  return /* @__PURE__ */ v.jsx(wfe, { ...i, ...r, ref: t });
});
cF.displayName = Bfe;
var $fe = "DropdownMenuSubContent", uF = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = wi(n);
  return /* @__PURE__ */ v.jsx(
    Sfe,
    {
      ...i,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
uF.displayName = $fe;
var Ufe = XU, Ffe = QU, dF = eF, Vfe = nF, Hfe = rF, Wfe = iF, qfe = oF, Gfe = sF, Kfe = aF, fF = lF, Zfe = Lfe, Yfe = cF, Xfe = uF;
function od({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Ufe, { "data-slot": "dropdown-menu", ...e });
}
function Jfe({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(dF, { "data-slot": "dropdown-menu-portal", ...e });
}
function sd({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(
    Ffe,
    {
      "data-slot": "dropdown-menu-trigger",
      ...e
    }
  );
}
function ad({
  className: e,
  sideOffset: t = 4,
  ...n
}) {
  return /* @__PURE__ */ v.jsx(dF, { children: /* @__PURE__ */ v.jsx(
    Vfe,
    {
      "data-slot": "dropdown-menu-content",
      sideOffset: t,
      className: lt(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
        e
      ),
      ...n,
      onCloseAutoFocus: (r) => {
        r.preventDefault(), document.body.style.pointerEvents = "";
      }
    }
  ) });
}
function Qfe({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Hfe, { "data-slot": "dropdown-menu-group", ...e });
}
function hs({
  className: e,
  inset: t,
  variant: n = "default",
  ...r
}) {
  return /* @__PURE__ */ v.jsx(
    qfe,
    {
      "data-slot": "dropdown-menu-item",
      "data-inset": t,
      "data-variant": n,
      className: lt(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...r
    }
  );
}
function ehe({
  className: e,
  children: t,
  checked: n,
  ...r
}) {
  return /* @__PURE__ */ v.jsxs(
    Gfe,
    {
      "data-slot": "dropdown-menu-checkbox-item",
      className: lt(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      checked: n,
      ...r,
      children: [
        /* @__PURE__ */ v.jsx("span", { className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center", children: /* @__PURE__ */ v.jsx(Kfe, { children: /* @__PURE__ */ v.jsx(Tc, { className: "size-4" }) }) }),
        t
      ]
    }
  );
}
function the({
  className: e,
  inset: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsx(
    Wfe,
    {
      "data-slot": "dropdown-menu-label",
      "data-inset": t,
      className: lt("px-2 py-1.5 text-sm font-medium data-[inset]:pl-8", e),
      ...n
    }
  );
}
function Db({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    fF,
    {
      "data-slot": "dropdown-menu-separator",
      className: lt("bg-border -mx-1 my-1 h-px", e),
      ...t
    }
  );
}
function nhe({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Zfe, { "data-slot": "dropdown-menu-sub", ...e });
}
function rhe({
  className: e,
  inset: t,
  children: n,
  ...r
}) {
  return /* @__PURE__ */ v.jsxs(
    Yfe,
    {
      "data-slot": "dropdown-menu-sub-trigger",
      "data-inset": t,
      className: lt(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        e
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ v.jsx(Vg, { className: "ml-auto size-4" })
      ]
    }
  );
}
function ihe({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Xfe,
    {
      "data-slot": "dropdown-menu-sub-content",
      className: lt(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        e
      ),
      ...t
    }
  );
}
var ohe = class hF extends Error {
  static kind = "ClerkError";
  clerkError = !0;
  code;
  longMessage;
  docsUrl;
  cause;
  get name() {
    return this.constructor.name;
  }
  constructor(t) {
    super(new.target.formatMessage(new.target.kind, t.message, t.code, t.docsUrl), { cause: t.cause }), Object.setPrototypeOf(this, hF.prototype), this.code = t.code, this.docsUrl = t.docsUrl, this.longMessage = t.longMessage, this.cause = t.cause;
  }
  toString() {
    return `[${this.name}]
Message:${this.message}`;
  }
  static formatMessage(t, n, r, i) {
    const o = "Clerk:", s = new RegExp(o.replace(" ", "\\s*"), "i");
    return n = n.replace(s, ""), n = `${o} ${n.trim()}

(code="${r}")

`, i && (n += `

Docs: ${i}`), n;
  }
};
const she = Object.freeze({
  InvalidProxyUrlErrorMessage: "The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})",
  InvalidPublishableKeyErrorMessage: "The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})",
  MissingPublishableKeyErrorMessage: "Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.",
  MissingSecretKeyErrorMessage: "Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.",
  MissingClerkProvider: "{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider"
});
function pF({ packageName: e, customMessages: t }) {
  let n = e;
  function r(o, s) {
    if (!s) return `${n}: ${o}`;
    let a = o;
    const c = o.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);
    for (const u of c) {
      const f = (s[u[1]] || "").toString();
      a = a.replace(`{{${u[1]}}}`, f);
    }
    return `${n}: ${a}`;
  }
  const i = {
    ...she,
    ...t
  };
  return {
    setPackageName({ packageName: o }) {
      return typeof o == "string" && (n = o), this;
    },
    setMessages({ customMessages: o }) {
      return Object.assign(i, o || {}), this;
    },
    throwInvalidPublishableKeyError(o) {
      throw new Error(r(i.InvalidPublishableKeyErrorMessage, o));
    },
    throwInvalidProxyUrl(o) {
      throw new Error(r(i.InvalidProxyUrlErrorMessage, o));
    },
    throwMissingPublishableKeyError() {
      throw new Error(r(i.MissingPublishableKeyErrorMessage));
    },
    throwMissingSecretKeyError() {
      throw new Error(r(i.MissingSecretKeyErrorMessage));
    },
    throwMissingClerkProviderError(o) {
      throw new Error(r(i.MissingClerkProvider, o));
    },
    throw(o) {
      throw new Error(r(o));
    }
  };
}
var H_ = class mF extends ohe {
  static kind = "ClerkRuntimeError";
  /**
  * @deprecated Use `clerkError` property instead. This property is maintained for backward compatibility.
  */
  clerkRuntimeError = !0;
  constructor(t, n) {
    super({
      ...n,
      message: t
    }), Object.setPrototypeOf(this, mF.prototype);
  }
};
const ahe = [
  ".lcl.dev",
  ".stg.dev",
  ".lclstage.dev",
  ".stgstage.dev",
  ".dev.lclclerk.com",
  ".stg.lclclerk.com",
  ".accounts.lclclerk.com",
  "accountsstage.dev",
  "accounts.dev"
], gF = (e) => typeof atob < "u" && typeof atob == "function" ? atob(e) : typeof global < "u" && global.Buffer ? new global.Buffer(e, "base64").toString() : e, yF = "pk_live_", lhe = "pk_test_";
function vF(e) {
  if (!e.endsWith("$")) return !1;
  const t = e.slice(0, -1);
  return t.includes("$") ? !1 : t.includes(".");
}
function ij(e, t = {}) {
  if (e = e || "", !e || !oj(e)) {
    if (t.fatal && !e) throw new Error("Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys");
    if (t.fatal && !oj(e)) throw new Error("Publishable key not valid.");
    return null;
  }
  const n = e.startsWith(yF) ? "production" : "development";
  let r;
  try {
    r = gF(e.split("_")[2]);
  } catch {
    if (t.fatal) throw new Error("Publishable key not valid: Failed to decode key.");
    return null;
  }
  if (!vF(r)) {
    if (t.fatal) throw new Error("Publishable key not valid: Decoded key has invalid format.");
    return null;
  }
  let i = r.slice(0, -1);
  return t.proxyUrl ? i = t.proxyUrl : n !== "development" && t.domain && t.isSatellite && (i = `clerk.${t.domain}`), {
    instanceType: n,
    frontendApi: i
  };
}
function oj(e = "") {
  try {
    if (!(e.startsWith(yF) || e.startsWith(lhe))) return !1;
    const t = e.split("_");
    if (t.length !== 3) return !1;
    const n = t[2];
    return n ? vF(gF(n)) : !1;
  } catch {
    return !1;
  }
}
function che() {
  const e = /* @__PURE__ */ new Map();
  return { isDevOrStagingUrl: (t) => {
    if (!t) return !1;
    const n = typeof t == "string" ? t : t.hostname;
    let r = e.get(n);
    return r === void 0 && (r = ahe.some((i) => n.endsWith(i)), e.set(n, r)), r;
  } };
}
const uhe = "METHOD_CALLED", dhe = 0.1;
function fhe(e, t) {
  return {
    event: uhe,
    eventSamplingRate: dhe,
    payload: {
      method: e,
      ...t
    }
  };
}
var sj = Object.prototype.hasOwnProperty;
function aj(e, t, n) {
  for (n of e.keys())
    if ($m(n, t)) return n;
}
function $m(e, t) {
  var n, r, i;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((r = e.length) === t.length)
        for (; r-- && $m(e[r], t[r]); ) ;
      return r === -1;
    }
    if (n === Set) {
      if (e.size !== t.size)
        return !1;
      for (r of e)
        if (i = r, i && typeof i == "object" && (i = aj(t, i), !i) || !t.has(i)) return !1;
      return !0;
    }
    if (n === Map) {
      if (e.size !== t.size)
        return !1;
      for (r of e)
        if (i = r[0], i && typeof i == "object" && (i = aj(t, i), !i) || !$m(r[1], t.get(i)))
          return !1;
      return !0;
    }
    if (n === ArrayBuffer)
      e = new Uint8Array(e), t = new Uint8Array(t);
    else if (n === DataView) {
      if ((r = e.byteLength) === t.byteLength)
        for (; r-- && e.getInt8(r) === t.getInt8(r); ) ;
      return r === -1;
    }
    if (ArrayBuffer.isView(e)) {
      if ((r = e.byteLength) === t.byteLength)
        for (; r-- && e[r] === t[r]; ) ;
      return r === -1;
    }
    if (!n || typeof e == "object") {
      r = 0;
      for (n in e)
        if (sj.call(e, n) && ++r && !sj.call(t, n) || !(n in t) || !$m(e[n], t[n])) return !1;
      return Object.keys(t).length === r;
    }
  }
  return e !== e && t !== t;
}
function hhe(e, t) {
  if (!e) throw typeof t == "string" ? new Error(t) : /* @__PURE__ */ new Error(`${t.displayName} not found`);
}
const ll = (e, t) => {
  const { assertCtxFn: n = hhe } = {}, r = Ne.createContext(void 0);
  return r.displayName = e, [
    r,
    () => {
      const s = Ne.useContext(r);
      return n(s, `${e} not found`), s.value;
    },
    () => {
      const s = Ne.useContext(r);
      return s ? s.value : {};
    }
  ];
}, [phe, bF] = ll("ClerkInstanceContext"), [T5e, mhe] = ll("UserContext");
ll("ClientContext");
ll("SessionContext");
Ne.createContext({});
ll("CheckoutContext");
ll("OrganizationContext");
function xF(e) {
  if (!Ne.useContext(phe)) {
    if (typeof e == "function") {
      e();
      return;
    }
    throw new Error(`${e} can only be used within the <ClerkProvider /> component.

Possible fixes:
1. Ensure that the <ClerkProvider /> is correctly wrapping your application where this component is used.
2. Check for multiple versions of the \`@clerk/shared\` package in your project. Use a tool like \`npm ls @clerk/shared\` to identify multiple versions, and update your dependencies to only rely on one.

Learn more: https://clerk.com/docs/components/clerk-provider`.trim());
  }
}
typeof window < "u" ? Ne.useLayoutEffect : Ne.useEffect;
const lj = "useUser";
function wF() {
  xF(lj);
  const e = mhe();
  return bF().telemetry?.record(fhe(lj)), e === void 0 ? {
    isLoaded: !1,
    isSignedIn: void 0,
    user: void 0
  } : e === null ? {
    isLoaded: !0,
    isSignedIn: !1,
    user: null
  } : {
    isLoaded: !0,
    isSignedIn: !0,
    user: e
  };
}
const cj = $m, ghe = (e) => {
  const t = C.useRef(e);
  return C.useEffect(() => {
    t.current = e;
  }, [e]), t.current;
}, co = (e, t, n) => {
  const r = !!n, i = C.useRef(n);
  C.useEffect(() => {
    i.current = n;
  }, [n]), C.useEffect(() => {
    if (!r || !e) return () => {
    };
    const o = (...s) => {
      i.current && i.current(...s);
    };
    return e.on(t, o), () => {
      e.off(t, o);
    };
  }, [
    r,
    t,
    e,
    i
  ]);
}, SF = Ne.createContext(null);
SF.displayName = "ElementsContext";
const yhe = (e, t) => {
  if (!e) throw new Error(`Could not find Elements context; You need to wrap the part of your app that ${t} in an <Elements> provider.`);
  return e;
}, Ib = (e) => e !== null && typeof e == "object", vhe = (e, t, n) => Ib(e) ? Object.keys(e).reduce((r, i) => {
  const o = !Ib(t) || !kF(e[i], t[i]);
  return n.includes(i) ? (o && console.warn(`Unsupported prop change: options.${i} is not a mutable property.`), r) : o ? {
    ...r || {},
    [i]: e[i]
  } : r;
}, null) : null, uj = "[object Object]", kF = (e, t) => {
  if (!Ib(e) || !Ib(t)) return e === t;
  const n = Array.isArray(e);
  if (n !== Array.isArray(t)) return !1;
  const r = Object.prototype.toString.call(e) === uj;
  if (r !== (Object.prototype.toString.call(t) === uj)) return !1;
  if (!r && !n) return e === t;
  const i = Object.keys(e), o = Object.keys(t);
  if (i.length !== o.length) return !1;
  const s = {};
  for (let h = 0; h < i.length; h += 1) s[i[h]] = !0;
  for (let h = 0; h < o.length; h += 1) s[o[h]] = !0;
  const a = Object.keys(s);
  if (a.length !== i.length) return !1;
  const c = e, u = t, f = (h) => kF(c[h], u[h]);
  return a.every(f);
}, dj = (e) => yhe(Ne.useContext(SF), e), bhe = (e) => e.charAt(0).toUpperCase() + e.slice(1), xhe = (e, t) => {
  const n = `${bhe(e)}Element`, o = t ? (s) => {
    dj(`mounts <${n}>`);
    const { id: a, className: c } = s;
    return /* @__PURE__ */ Ne.createElement("div", {
      id: a,
      className: c
    });
  } : ({ id: s, className: a, fallback: c, options: u = {}, onBlur: f, onFocus: h, onReady: m, onChange: g, onEscape: b, onClick: x, onLoadError: w, onLoaderStart: S, onNetworksChange: _, onConfirm: M, onCancel: N, onShippingAddressChange: D, onShippingRateChange: j }) => {
    const O = dj(`mounts <${n}>`), L = "elements" in O ? O.elements : null, [U, B] = Ne.useState(null), G = Ne.useRef(null), Y = Ne.useRef(null), [he, ie] = C.useState(!1);
    co(U, "blur", f), co(U, "focus", h), co(U, "escape", b), co(U, "click", x), co(U, "loaderror", w), co(U, "loaderstart", S), co(U, "networkschange", _), co(U, "confirm", M), co(U, "cancel", N), co(U, "shippingaddresschange", D), co(U, "shippingratechange", j), co(U, "change", g);
    let ne;
    m && (ne = () => {
      ie(!0), m(U);
    }), co(U, "ready", ne), Ne.useLayoutEffect(() => {
      if (G.current === null && Y.current !== null && L) {
        let Q = null;
        L && (Q = L.create(e, u)), G.current = Q, B(Q), Q && Q.mount(Y.current);
      }
    }, [L, u]);
    const H = ghe(u);
    return Ne.useEffect(() => {
      if (!G.current) return;
      const Q = vhe(u, H, ["paymentRequest"]);
      Q && "update" in G.current && G.current.update(Q);
    }, [u, H]), Ne.useLayoutEffect(() => () => {
      if (G.current && typeof G.current.destroy == "function") try {
        G.current.destroy(), G.current = null;
      } catch {
      }
    }, []), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, !he && c, /* @__PURE__ */ Ne.createElement("div", {
      id: s,
      style: {
        height: he ? "unset" : "0px",
        visibility: he ? "visible" : "hidden"
      },
      className: a,
      ref: Y
    }));
  };
  return o.displayName = n, o.__elementType = e, o;
};
xhe("payment", typeof window > "u");
ll("PaymentElementContext");
ll("StripeUtilsContext");
var qu = pF({ packageName: "@clerk/clerk-react" });
function whe(e) {
  qu.setMessages(e).setPackageName(e);
}
ll("AuthContext");
var She = bF, khe = (e) => `You've passed multiple children components to <${e}/>. You can only pass a single child component or text.`, hC = "Unsupported usage of isSatellite, domain or proxyUrl. The usage of isSatellite, domain or proxyUrl as function is not supported in non-browser environments.", Che = "<UserProfile.Page /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.", Ehe = "<UserProfile.Link /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.", _he = "<OrganizationProfile.Page /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.", The = "<OrganizationProfile.Link /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.", Ahe = (e) => `<${e} /> can only accept <${e}.Page /> and <${e}.Link /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.`, Mhe = (e) => `Missing props. <${e}.Page /> component requires the following props: url, label, labelIcon, alongside with children to be rendered inside the page.`, Nhe = (e) => `Missing props. <${e}.Link /> component requires the following props: url, label and labelIcon.`, Rhe = "<UserButton /> can only accept <UserButton.UserProfilePage />, <UserButton.UserProfileLink /> and <UserButton.MenuItems /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.", Ohe = "<UserButton.MenuItems /> component can only accept <UserButton.Action /> and <UserButton.Link /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.", Phe = "<UserButton.MenuItems /> component needs to be a direct child of `<UserButton />`.", Dhe = "<UserButton.Action /> component needs to be a direct child of `<UserButton.MenuItems />`.", Ihe = "<UserButton.Link /> component needs to be a direct child of `<UserButton.MenuItems />`.", jhe = "Missing props. <UserButton.Link /> component requires the following props: href, label and labelIcon.", zhe = "Missing props. <UserButton.Action /> component requires the following props: label.", Lhe = (e) => {
  xF(() => {
    qu.throwMissingClerkProviderError({ source: e });
  });
}, Dn = (e, t) => {
  const r = (typeof t == "string" ? t : t?.component) || e.displayName || e.name || "Component";
  e.displayName = r;
  const i = typeof t == "string" ? void 0 : t, o = (s) => {
    Lhe(r || "withClerk");
    const a = She();
    return !a.loaded && !i?.renderWhileLoading ? null : /* @__PURE__ */ Ne.createElement(
      e,
      {
        ...s,
        component: r,
        clerk: a
      }
    );
  };
  return o.displayName = `withClerk(${r})`, o;
};
const Bhe = () => {
  try {
    return !1;
  } catch {
  }
  return !1;
}, $he = () => {
  try {
    return !1;
  } catch {
  }
  return !1;
}, Uhe = () => {
  try {
    return !0;
  } catch {
  }
  return !1;
}, fj = /* @__PURE__ */ new Set(), FM = (e, t, n) => {
  const r = $he() || Uhe(), i = e;
  fj.has(i) || r || (fj.add(i), console.warn(`Clerk - DEPRECATION WARNING: "${e}" is deprecated and will be removed in the next major release.
${t}`));
};
Dn(({ clerk: e, ...t }) => {
  const { client: n, session: r } = e, i = n.signedInSessions ? n.signedInSessions.length > 0 : (
    // Compat for clerk-js<5.54.0 (which was released with the `signedInSessions` property)
    n.activeSessions && n.activeSessions.length > 0
  );
  return Ne.useEffect(() => {
    r === null && i ? e.redirectToAfterSignOut() : e.redirectToSignIn(t);
  }, []), null;
}, "RedirectToSignIn");
Dn(({ clerk: e, ...t }) => (Ne.useEffect(() => {
  e.redirectToSignUp(t);
}, []), null), "RedirectToSignUp");
Dn(({ clerk: e, ...t }) => (Ne.useEffect(() => {
  e.redirectToTasks(t);
}, []), null), "RedirectToTasks");
Dn(({ clerk: e }) => (Ne.useEffect(() => {
  FM("RedirectToUserProfile", "Use the `redirectToUserProfile()` method instead."), e.redirectToUserProfile();
}, []), null), "RedirectToUserProfile");
Dn(({ clerk: e }) => (Ne.useEffect(() => {
  FM("RedirectToOrganizationProfile", "Use the `redirectToOrganizationProfile()` method instead."), e.redirectToOrganizationProfile();
}, []), null), "RedirectToOrganizationProfile");
Dn(({ clerk: e }) => (Ne.useEffect(() => {
  FM("RedirectToCreateOrganization", "Use the `redirectToCreateOrganization()` method instead."), e.redirectToCreateOrganization();
}, []), null), "RedirectToCreateOrganization");
Dn(
  ({ clerk: e, ...t }) => (Ne.useEffect(() => {
    e.handleRedirectCallback(t);
  }, []), null),
  "AuthenticateWithRedirectCallback"
);
function pC(e, t, n) {
  if (typeof e == "function") return e(t);
  if (typeof e < "u") return e;
  if (typeof n < "u") return n;
}
const Ni = (e) => {
  Bhe() && console.error(`Clerk: ${e}`);
}, hj = (e, ...t) => {
  const n = { ...e };
  for (const r of t) delete n[r];
  return n;
};
var Iw = (e) => (t) => {
  try {
    return Ne.Children.only(e);
  } catch {
    return qu.throw(khe(t));
  }
}, jw = (e, t) => (e || (e = t), typeof e == "string" && (e = /* @__PURE__ */ Ne.createElement("button", null, e)), e), zw = (e) => (...t) => {
  if (e && typeof e == "function")
    return e(...t);
};
function Fhe(e) {
  return typeof e == "function";
}
var Um = (e) => {
  const [t, n] = C.useState(/* @__PURE__ */ new Map());
  return e.map((r) => ({
    id: r.id,
    mount: (i) => n((o) => new Map(o).set(String(r.id), i)),
    unmount: () => n((i) => {
      const o = new Map(i);
      return o.set(String(r.id), null), o;
    }),
    portal: () => {
      const i = t.get(String(r.id));
      return i ? sl.createPortal(r.component, i) : null;
    }
  }));
}, Mi = (e, t) => !!e && Ne.isValidElement(e) && e?.type === t, CF = (e, t) => TF(
  {
    children: e,
    reorderItemsLabels: ["account", "security", "billing", "apiKeys"],
    LinkComponent: dy,
    PageComponent: uy,
    MenuItemsComponent: Bw,
    componentName: "UserProfile"
  },
  t
), EF = (e, t) => TF(
  {
    children: e,
    reorderItemsLabels: ["general", "members", "billing", "apiKeys"],
    LinkComponent: Uw,
    PageComponent: $w,
    componentName: "OrganizationProfile"
  },
  t
), _F = (e) => {
  const t = [], n = [
    Uw,
    $w,
    Bw,
    uy,
    dy
  ];
  return Ne.Children.forEach(e, (r) => {
    n.some((i) => Mi(r, i)) || t.push(r);
  }), t;
}, TF = (e, t) => {
  const { children: n, LinkComponent: r, PageComponent: i, MenuItemsComponent: o, reorderItemsLabels: s, componentName: a } = e, { allowForAnyChildren: c = !1 } = t || {}, u = [];
  Ne.Children.forEach(n, (_) => {
    if (!Mi(_, i) && !Mi(_, r) && !Mi(_, o)) {
      _ && !c && Ni(Ahe(a));
      return;
    }
    const { props: M } = _, { children: N, label: D, url: j, labelIcon: O } = M;
    if (Mi(_, i))
      if (pj(M, s))
        u.push({ label: D });
      else if (mC(M))
        u.push({ label: D, labelIcon: O, children: N, url: j });
      else {
        Ni(Mhe(a));
        return;
      }
    if (Mi(_, r))
      if (gC(M))
        u.push({ label: D, labelIcon: O, url: j });
      else {
        Ni(Nhe(a));
        return;
      }
  });
  const f = [], h = [], m = [];
  u.forEach((_, M) => {
    if (mC(_)) {
      f.push({ component: _.children, id: M }), h.push({ component: _.labelIcon, id: M });
      return;
    }
    gC(_) && m.push({ component: _.labelIcon, id: M });
  });
  const g = Um(f), b = Um(h), x = Um(m), w = [], S = [];
  return u.forEach((_, M) => {
    if (pj(_, s)) {
      w.push({ label: _.label });
      return;
    }
    if (mC(_)) {
      const {
        portal: N,
        mount: D,
        unmount: j
      } = g.find((B) => B.id === M), {
        portal: O,
        mount: L,
        unmount: U
      } = b.find((B) => B.id === M);
      w.push({ label: _.label, url: _.url, mount: D, unmount: j, mountIcon: L, unmountIcon: U }), S.push(N), S.push(O);
      return;
    }
    if (gC(_)) {
      const {
        portal: N,
        mount: D,
        unmount: j
      } = x.find((O) => O.id === M);
      w.push({ label: _.label, url: _.url, mountIcon: D, unmountIcon: j }), S.push(N);
      return;
    }
  }), { customPages: w, customPagesPortals: S };
}, pj = (e, t) => {
  const { children: n, label: r, url: i, labelIcon: o } = e;
  return !n && !i && !o && t.some((s) => s === r);
}, mC = (e) => {
  const { children: t, label: n, url: r, labelIcon: i } = e;
  return !!t && !!r && !!i && !!n;
}, gC = (e) => {
  const { children: t, label: n, url: r, labelIcon: i } = e;
  return !t && !!r && !!i && !!n;
}, Vhe = (e, t) => {
  var n;
  return Hhe({
    children: e,
    reorderItemsLabels: ["manageAccount", "signOut"],
    MenuItemsComponent: Bw,
    MenuActionComponent: MF,
    MenuLinkComponent: NF,
    UserProfileLinkComponent: dy,
    UserProfilePageComponent: uy,
    allowForAnyChildren: (n = t?.allowForAnyChildren) != null ? n : !1
  });
}, Hhe = ({
  children: e,
  MenuItemsComponent: t,
  MenuActionComponent: n,
  MenuLinkComponent: r,
  UserProfileLinkComponent: i,
  UserProfilePageComponent: o,
  reorderItemsLabels: s,
  allowForAnyChildren: a = !1
}) => {
  const c = [], u = [], f = [];
  Ne.Children.forEach(e, (x) => {
    if (!Mi(x, t) && !Mi(x, i) && !Mi(x, o)) {
      x && !a && Ni(Rhe);
      return;
    }
    if (Mi(x, i) || Mi(x, o))
      return;
    const { props: w } = x;
    Ne.Children.forEach(w.children, (S) => {
      if (!Mi(S, n) && !Mi(S, r)) {
        S && Ni(Ohe);
        return;
      }
      const { props: _ } = S, { label: M, labelIcon: N, href: D, onClick: j, open: O } = _;
      if (Mi(S, n))
        if (mj(_, s))
          c.push({ label: M });
        else if (yC(_)) {
          const L = {
            label: M,
            labelIcon: N
          };
          if (j !== void 0)
            c.push({
              ...L,
              onClick: j
            });
          else if (O !== void 0)
            c.push({
              ...L,
              open: O.startsWith("/") ? O : `/${O}`
            });
          else {
            Ni("Custom menu item must have either onClick or open property");
            return;
          }
        } else {
          Ni(zhe);
          return;
        }
      if (Mi(S, r))
        if (vC(_))
          c.push({ label: M, labelIcon: N, href: D });
        else {
          Ni(jhe);
          return;
        }
    });
  });
  const h = [], m = [];
  c.forEach((x, w) => {
    yC(x) && h.push({ component: x.labelIcon, id: w }), vC(x) && m.push({ component: x.labelIcon, id: w });
  });
  const g = Um(h), b = Um(m);
  return c.forEach((x, w) => {
    if (mj(x, s) && u.push({
      label: x.label
    }), yC(x)) {
      const {
        portal: S,
        mount: _,
        unmount: M
      } = g.find((D) => D.id === w), N = {
        label: x.label,
        mountIcon: _,
        unmountIcon: M
      };
      "onClick" in x ? N.onClick = x.onClick : "open" in x && (N.open = x.open), u.push(N), f.push(S);
    }
    if (vC(x)) {
      const {
        portal: S,
        mount: _,
        unmount: M
      } = b.find((N) => N.id === w);
      u.push({
        label: x.label,
        href: x.href,
        mountIcon: _,
        unmountIcon: M
      }), f.push(S);
    }
  }), { customMenuItems: u, customMenuItemsPortals: f };
}, mj = (e, t) => {
  const { children: n, label: r, onClick: i, labelIcon: o } = e;
  return !n && !i && !o && t.some((s) => s === r);
}, yC = (e) => {
  const { label: t, labelIcon: n, onClick: r, open: i } = e;
  return !!n && !!t && (typeof r == "function" || typeof i == "string");
}, vC = (e) => {
  const { label: t, href: n, labelIcon: r } = e;
  return !!n && !!r && !!t;
}, Whe = (e) => {
  const t = e?.isReady;
  return (n) => new Promise((r, i) => {
    const { root: o = document?.body, selector: s, timeout: a = 0 } = n;
    if (!o) {
      i(new Error("No root element provided"));
      return;
    }
    let c = o;
    if (s && (c = o?.querySelector(s)), t(c, s)) {
      r();
      return;
    }
    const u = new MutationObserver((f) => {
      for (const h of f)
        if (!c && s && (c = o?.querySelector(s)), (e.childList && h.type === "childList" || e.attributes && h.type === "attributes") && t(c, s)) {
          u.disconnect(), r();
          return;
        }
    });
    u.observe(o, e), a > 0 && setTimeout(() => {
      u.disconnect(), i(new Error(`Timeout waiting for ${s}`));
    }, a);
  });
}, qhe = Whe({
  childList: !0,
  subtree: !0,
  isReady: (e, t) => {
    var n;
    return !!e?.childElementCount && ((n = e?.matches) == null ? void 0 : n.call(e, t)) && e.childElementCount > 0;
  }
});
function zi(e, t) {
  const n = C.useRef(), [r, i] = C.useState("rendering");
  return C.useEffect(() => {
    if (!e)
      throw new Error("Clerk: no component name provided, unable to detect mount.");
    if (typeof window < "u" && !n.current) {
      const o = `[data-clerk-component="${e}"]`, s = t?.selector;
      n.current = qhe({
        selector: s ? (
          // Allows for `[data-clerk-component="xxxx"][data-some-attribute="123"] .my-class`
          o + s
        ) : o
      }).then(() => {
        i("rendered");
      }).catch(() => {
        i("error");
      });
    }
  }, [e, t?.selector]), r;
}
var Yv = (e) => "mount" in e, gj = (e) => "open" in e, yj = (e) => e?.map(({ mountIcon: t, unmountIcon: n, ...r }) => r), ci = class extends Ne.PureComponent {
  constructor() {
    super(...arguments), this.rootRef = Ne.createRef();
  }
  componentDidUpdate(e) {
    var t, n, r, i;
    if (!Yv(e) || !Yv(this.props))
      return;
    const o = hj(e.props, "customPages", "customMenuItems", "children"), s = hj(this.props.props, "customPages", "customMenuItems", "children"), a = ((t = o.customPages) == null ? void 0 : t.length) !== ((n = s.customPages) == null ? void 0 : n.length), c = ((r = o.customMenuItems) == null ? void 0 : r.length) !== ((i = s.customMenuItems) == null ? void 0 : i.length), u = yj(e.props.customMenuItems), f = yj(this.props.props.customMenuItems);
    (!cj(o, s) || !cj(u, f) || a || c) && this.rootRef.current && this.props.updateProps({ node: this.rootRef.current, props: this.props.props });
  }
  componentDidMount() {
    this.rootRef.current && (Yv(this.props) && this.props.mount(this.rootRef.current, this.props.props), gj(this.props) && this.props.open(this.props.props));
  }
  componentWillUnmount() {
    this.rootRef.current && (Yv(this.props) && this.props.unmount(this.rootRef.current), gj(this.props) && this.props.close());
  }
  render() {
    const { hideRootHtmlElement: e = !1 } = this.props, t = {
      ref: this.rootRef,
      ...this.props.rootProps,
      ...this.props.component && { "data-clerk-component": this.props.component }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, !e && /* @__PURE__ */ Ne.createElement("div", { ...t }), this.props.children);
  }
}, Lw = (e) => {
  var t, n;
  return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, (t = e?.customPagesPortals) == null ? void 0 : t.map((r, i) => C.createElement(r, { key: i })), (n = e?.customMenuItemsPortals) == null ? void 0 : n.map((r, i) => C.createElement(r, { key: i })));
};
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        mount: e.mountSignIn,
        unmount: e.unmountSignIn,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "SignIn", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        mount: e.mountSignUp,
        unmount: e.unmountSignUp,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "SignUp", renderWhileLoading: !0 }
);
function uy({ children: e }) {
  return Ni(Che), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function dy({ children: e }) {
  return Ni(Ehe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
var Ghe = Dn(
  ({
    clerk: e,
    component: t,
    fallback: n,
    ...r
  }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    }, { customPages: a, customPagesPortals: c } = CF(r.children);
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        mount: e.mountUserProfile,
        unmount: e.unmountUserProfile,
        updateProps: e.__unstable__updateProps,
        props: { ...r, customPages: a },
        rootProps: s
      },
      /* @__PURE__ */ Ne.createElement(Lw, { customPagesPortals: c })
    ));
  },
  { component: "UserProfile", renderWhileLoading: !0 }
);
Object.assign(Ghe, {
  Page: uy,
  Link: dy
});
var AF = C.createContext({
  mount: () => {
  },
  unmount: () => {
  },
  updateProps: () => {
  }
}), Khe = Dn(
  ({
    clerk: e,
    component: t,
    fallback: n,
    ...r
  }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    }, { customPages: a, customPagesPortals: c } = CF(r.children, {
      allowForAnyChildren: !!r.__experimental_asProvider
    }), u = { ...r.userProfileProps, customPages: a }, { customMenuItems: f, customMenuItemsPortals: h } = Vhe(r.children, {
      allowForAnyChildren: !!r.__experimental_asProvider
    }), m = _F(r.children), g = {
      mount: e.mountUserButton,
      unmount: e.unmountUserButton,
      updateProps: e.__unstable__updateProps,
      props: { ...r, userProfileProps: u, customMenuItems: f }
    }, b = {
      customPagesPortals: c,
      customMenuItemsPortals: h
    };
    return /* @__PURE__ */ Ne.createElement(AF.Provider, { value: g }, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        ...g,
        hideRootHtmlElement: !!r.__experimental_asProvider,
        rootProps: s
      },
      r.__experimental_asProvider ? m : null,
      /* @__PURE__ */ Ne.createElement(Lw, { ...b })
    ));
  },
  { component: "UserButton", renderWhileLoading: !0 }
);
function Bw({ children: e }) {
  return Ni(Phe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function MF({ children: e }) {
  return Ni(Dhe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function NF({ children: e }) {
  return Ni(Ihe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function Zhe(e) {
  const t = C.useContext(AF), n = {
    ...t,
    props: {
      ...t.props,
      ...e
    }
  };
  return /* @__PURE__ */ Ne.createElement(ci, { ...n });
}
Object.assign(Khe, {
  UserProfilePage: uy,
  UserProfileLink: dy,
  MenuItems: Bw,
  Action: MF,
  Link: NF,
  __experimental_Outlet: Zhe
});
function $w({ children: e }) {
  return Ni(_he), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function Uw({ children: e }) {
  return Ni(The), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
var Yhe = Dn(
  ({
    clerk: e,
    component: t,
    fallback: n,
    ...r
  }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    }, { customPages: a, customPagesPortals: c } = EF(r.children);
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        mount: e.mountOrganizationProfile,
        unmount: e.unmountOrganizationProfile,
        updateProps: e.__unstable__updateProps,
        props: { ...r, customPages: a },
        rootProps: s
      },
      /* @__PURE__ */ Ne.createElement(Lw, { customPagesPortals: c })
    ));
  },
  { component: "OrganizationProfile", renderWhileLoading: !0 }
);
Object.assign(Yhe, {
  Page: $w,
  Link: Uw
});
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        mount: e.mountCreateOrganization,
        unmount: e.unmountCreateOrganization,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "CreateOrganization", renderWhileLoading: !0 }
);
var RF = C.createContext({
  mount: () => {
  },
  unmount: () => {
  },
  updateProps: () => {
  }
}), Xhe = Dn(
  ({
    clerk: e,
    component: t,
    fallback: n,
    ...r
  }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    }, { customPages: a, customPagesPortals: c } = EF(r.children, {
      allowForAnyChildren: !!r.__experimental_asProvider
    }), u = { ...r.organizationProfileProps, customPages: a }, f = _F(r.children), h = {
      mount: e.mountOrganizationSwitcher,
      unmount: e.unmountOrganizationSwitcher,
      updateProps: e.__unstable__updateProps,
      props: { ...r, organizationProfileProps: u },
      rootProps: s,
      component: t
    };
    return e.__experimental_prefetchOrganizationSwitcher(), /* @__PURE__ */ Ne.createElement(RF.Provider, { value: h }, /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        ...h,
        hideRootHtmlElement: !!r.__experimental_asProvider
      },
      r.__experimental_asProvider ? f : null,
      /* @__PURE__ */ Ne.createElement(Lw, { customPagesPortals: c })
    )));
  },
  { component: "OrganizationSwitcher", renderWhileLoading: !0 }
);
function Jhe(e) {
  const t = C.useContext(RF), n = {
    ...t,
    props: {
      ...t.props,
      ...e
    }
  };
  return /* @__PURE__ */ Ne.createElement(ci, { ...n });
}
Object.assign(Xhe, {
  OrganizationProfilePage: $w,
  OrganizationProfileLink: Uw,
  __experimental_Outlet: Jhe
});
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        mount: e.mountOrganizationList,
        unmount: e.unmountOrganizationList,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "OrganizationList", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        open: e.openGoogleOneTap,
        close: e.closeGoogleOneTap,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "GoogleOneTap", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        mount: e.mountWaitlist,
        unmount: e.unmountWaitlist,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "Waitlist", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = zi(t, {
      // This attribute is added to the PricingTable root element after we've successfully fetched the plans asynchronously.
      selector: '[data-component-status="ready"]'
    }) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        mount: e.mountPricingTable,
        unmount: e.unmountPricingTable,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "PricingTable", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        mount: e.mountAPIKeys,
        unmount: e.unmountAPIKeys,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "ApiKeys", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        mount: e.mountUserAvatar,
        unmount: e.unmountUserAvatar,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "UserAvatar", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        mount: e.mountTaskChooseOrganization,
        unmount: e.unmountTaskChooseOrganization,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "TaskChooseOrganization", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = zi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      ci,
      {
        component: t,
        mount: e.mountTaskResetPassword,
        unmount: e.unmountTaskResetPassword,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "TaskResetPassword", renderWhileLoading: !0 }
);
var OF = (e) => {
  throw TypeError(e);
}, VM = (e, t, n) => t.has(e) || OF("Cannot " + n), Un = (e, t, n) => (VM(e, t, "read from private field"), n ? n.call(e) : t.get(e)), ec = (e, t, n) => t.has(e) ? OF("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), Mu = (e, t, n, r) => (VM(e, t, "write to private field"), t.set(e, n), n), bC = (e, t, n) => (VM(e, t, "access private method"), n);
const Qhe = {
  initialDelay: 125,
  maxDelayBetweenRetries: 0,
  factor: 2,
  shouldRetry: (e, t) => t < 5,
  retryImmediately: !1,
  jitter: !0
}, epe = 100, PF = async (e) => new Promise((t) => setTimeout(t, e)), DF = (e, t) => t ? e * (1 + Math.random()) : e, tpe = (e) => {
  let t = 0;
  const n = () => {
    const r = e.initialDelay, i = e.factor;
    let o = r * Math.pow(i, t);
    return o = DF(o, e.jitter), Math.min(e.maxDelayBetweenRetries || o, o);
  };
  return async () => {
    await PF(n()), t++;
  };
}, npe = async (e, t = {}) => {
  let n = 0;
  const { shouldRetry: r, initialDelay: i, maxDelayBetweenRetries: o, factor: s, retryImmediately: a, jitter: c, onBeforeRetry: u } = {
    ...Qhe,
    ...t
  }, f = tpe({
    initialDelay: i,
    maxDelayBetweenRetries: o,
    factor: s,
    jitter: c
  });
  for (; ; ) try {
    return await e();
  } catch (h) {
    if (n++, !r(h, n)) throw h;
    u && await u(n), a && n === 1 ? await PF(DF(epe, c)) : await f();
  }
}, rpe = "loadScript cannot be called when document does not exist", ipe = "loadScript cannot be called without a src";
async function ope(e = "", t) {
  const { async: n, defer: r, beforeLoad: i, crossOrigin: o, nonce: s } = t || {};
  return npe(() => new Promise((c, u) => {
    e || u(new Error(ipe)), (!document || !document.body) && u(new Error(rpe));
    const f = document.createElement("script");
    o && f.setAttribute("crossorigin", o), f.async = n || !1, f.defer = r || !1, f.addEventListener("load", () => {
      f.remove(), c(f);
    }), f.addEventListener("error", (h) => {
      f.remove(), u(h.error ?? /* @__PURE__ */ new Error(`failed to load script: ${e}`));
    }), f.src = e, f.nonce = s, i?.(f), document.body.appendChild(f);
  }), { shouldRetry: (c, u) => u <= 5 });
}
function spe(e) {
  return e ? ape(e) || IF(e) : !0;
}
function ape(e) {
  return /^http(s)?:\/\//.test(e || "");
}
function IF(e) {
  return e.startsWith("/");
}
function lpe(e) {
  return e ? IF(e) ? new URL(e, window.location.origin).toString() : e : "";
}
function cpe(e) {
  if (!e) return "";
  let t;
  if (e.match(/^(clerk\.)+\w*$/)) t = /(clerk\.)*(?=clerk\.)/;
  else {
    if (e.match(/\.clerk.accounts/)) return e;
    t = /^(clerk\.)*/gi;
  }
  return `clerk.${e.replace(t, "")}`;
}
const upe = (e, t = "5.122.0") => {
  if (e) return e;
  const n = dpe(t);
  return n ? n === "snapshot" ? "5.122.0" : n : fpe(t);
}, dpe = (e) => e.trim().replace(/^v/, "").match(/-(.+?)(\.|$)/)?.[1], fpe = (e) => e.trim().replace(/^v/, "").split(".")[0], jF = "failed_to_load_clerk_js", hpe = "failed_to_load_clerk_js_timeout", W_ = "Failed to load Clerk", { isDevOrStagingUrl: ppe } = che(), zF = pF({ packageName: "@clerk/shared" });
function mpe(e) {
  zF.setPackageName({ packageName: e });
}
function q_() {
  if (typeof window > "u" || !window.Clerk) return !1;
  const e = window.Clerk;
  return typeof e == "object" && typeof e.load == "function";
}
function gpe(e) {
  if (typeof window > "u" || !window.performance) return !1;
  const t = performance.getEntriesByName(e, "resource");
  if (t.length === 0) return !1;
  const n = t[t.length - 1];
  return n.transferSize === 0 && n.decodedBodySize === 0 && (n.responseEnd === 0 || n.responseEnd > 0 && n.responseStart > 0 || "responseStatus" in n && (n.responseStatus >= 400 || n.responseStatus === 0));
}
function vj(e, t) {
  return new Promise((n, r) => {
    let i = !1;
    const o = (f, h) => {
      clearTimeout(f), clearInterval(h);
    };
    t?.addEventListener("error", () => {
      o(c, u), r(new H_(W_, { code: jF }));
    });
    const s = () => {
      i || q_() && (i = !0, o(c, u), n(null));
    }, c = setTimeout(() => {
      i || (i = !0, o(c, u), q_() ? n(null) : r(new H_(W_, { code: hpe })));
    }, e);
    s();
    const u = setInterval(() => {
      if (i) {
        clearInterval(u);
        return;
      }
      s();
    }, 100);
  });
}
const ype = async (e) => {
  const t = e?.scriptLoadTimeout ?? 15e3;
  if (q_()) return null;
  if (!e?.publishableKey)
    return zF.throwMissingPublishableKeyError(), null;
  const n = vpe(e), r = document.querySelector("script[data-clerk-js-script]");
  if (r) if (gpe(n)) r.remove();
  else try {
    return await vj(t, r), null;
  } catch {
    r.remove();
  }
  const i = vj(t);
  return ope(n, {
    async: !0,
    crossOrigin: "anonymous",
    nonce: e.nonce,
    beforeLoad: xpe(e)
  }).catch((o) => {
    throw new H_(W_ + (o.message ? `, ${o.message}` : ""), {
      code: jF,
      cause: o
    });
  }), i;
}, vpe = (e) => {
  const { clerkJSUrl: t, clerkJSVariant: n, clerkJSVersion: r, proxyUrl: i, domain: o, publishableKey: s } = e;
  if (t) return t;
  let a = "";
  i && spe(i) ? a = lpe(i).replace(/http(s)?:\/\//, "") : o && !ppe(ij(s)?.frontendApi || "") ? a = cpe(o) : a = ij(s)?.frontendApi || "";
  const c = n ? `${n.replace(/\.+$/, "")}.` : "", u = upe(r);
  return `https://${a}/npm/@clerk/clerk-js@${u}/dist/clerk.${c}browser.js`;
}, bpe = (e) => {
  const t = {};
  return e.publishableKey && (t["data-clerk-publishable-key"] = e.publishableKey), e.proxyUrl && (t["data-clerk-proxy-url"] = e.proxyUrl), e.domain && (t["data-clerk-domain"] = e.domain), e.nonce && (t.nonce = e.nonce), t;
}, xpe = (e) => (t) => {
  const n = bpe(e);
  for (const r in n) t.setAttribute(r, n[r]);
};
function jb() {
  return typeof window < "u";
}
const bj = (e, t, n, r, i) => {
  const { notify: o } = i || {};
  let s = e.get(n);
  s || (s = [], e.set(n, s)), s.push(r), o && t.has(n) && r(t.get(n));
}, xj = (e, t, n) => (e.get(t) || []).map((r) => r(n)), wj = (e, t, n) => {
  const r = e.get(t);
  r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : e.set(t, []));
}, wpe = () => {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    on: (...i) => bj(e, t, ...i),
    prioritizedOn: (...i) => bj(n, t, ...i),
    emit: (i, o) => {
      t.set(i, o), xj(n, i, o), xj(e, i, o);
    },
    off: (...i) => wj(e, ...i),
    prioritizedOff: (...i) => wj(n, ...i),
    internal: { retrieveListeners: (i) => e.get(i) || [] }
  };
}, Xv = { Status: "status" }, Spe = () => wpe();
typeof window < "u" && !window.global && (window.global = typeof global > "u" ? window : global);
Dn(
  ({ clerk: e, children: t, ...n }) => {
    const {
      // @ts-expect-error - appearance is a valid prop for SignInProps & SignInButtonPropsModal
      appearance: r,
      signUpFallbackRedirectUrl: i,
      forceRedirectUrl: o,
      fallbackRedirectUrl: s,
      signUpForceRedirectUrl: a,
      mode: c,
      initialValues: u,
      withSignUp: f,
      oauthFlow: h,
      ...m
    } = n;
    t = jw(t, "Sign in");
    const g = Iw(t)("SignInButton"), b = () => {
      const S = {
        forceRedirectUrl: o,
        fallbackRedirectUrl: s,
        signUpFallbackRedirectUrl: i,
        signUpForceRedirectUrl: a,
        initialValues: u,
        withSignUp: f,
        oauthFlow: h
      };
      return c === "modal" ? e.openSignIn({ ...S, appearance: r }) : e.redirectToSignIn({
        ...S,
        signInFallbackRedirectUrl: s,
        signInForceRedirectUrl: o
      });
    }, w = { ...m, onClick: async (S) => (g && typeof g == "object" && "props" in g && await zw(g.props.onClick)(S), b()) };
    return Ne.cloneElement(g, w);
  },
  { component: "SignInButton", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, children: t, ...n }) => {
    const { redirectUrl: r, ...i } = n;
    t = jw(t, "Sign in with Metamask");
    const o = Iw(t)("SignInWithMetamaskButton"), s = async () => {
      async function u() {
        await e.authenticateWithMetamask({ redirectUrl: r || void 0 });
      }
      u();
    }, c = { ...i, onClick: async (u) => (await zw(o.props.onClick)(u), s()) };
    return Ne.cloneElement(o, c);
  },
  { component: "SignInWithMetamask", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, children: t, ...n }) => {
    const { redirectUrl: r = "/", signOutOptions: i, ...o } = n;
    t = jw(t, "Sign out");
    const s = Iw(t)("SignOutButton"), a = () => e.signOut({ redirectUrl: r, ...i }), u = { ...o, onClick: async (f) => (await zw(s.props.onClick)(f), a()) };
    return Ne.cloneElement(s, u);
  },
  { component: "SignOutButton", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, children: t, ...n }) => {
    const {
      // @ts-expect-error - appearance is a valid prop for SignUpProps & SignUpButtonPropsModal
      appearance: r,
      // @ts-expect-error - unsafeMetadata is a valid prop for SignUpProps & SignUpButtonPropsModal
      unsafeMetadata: i,
      fallbackRedirectUrl: o,
      forceRedirectUrl: s,
      signInFallbackRedirectUrl: a,
      signInForceRedirectUrl: c,
      mode: u,
      initialValues: f,
      oauthFlow: h,
      ...m
    } = n;
    t = jw(t, "Sign up");
    const g = Iw(t)("SignUpButton"), b = () => {
      const S = {
        fallbackRedirectUrl: o,
        forceRedirectUrl: s,
        signInFallbackRedirectUrl: a,
        signInForceRedirectUrl: c,
        initialValues: f,
        oauthFlow: h
      };
      return u === "modal" ? e.openSignUp({
        ...S,
        appearance: r,
        unsafeMetadata: i
      }) : e.redirectToSignUp({
        ...S,
        signUpFallbackRedirectUrl: o,
        signUpForceRedirectUrl: s
      });
    }, w = { ...m, onClick: async (S) => (g && typeof g == "object" && "props" in g && await zw(g.props.onClick)(S), b()) };
    return Ne.cloneElement(g, w);
  },
  { component: "SignUpButton", renderWhileLoading: !0 }
);
var kpe = () => ({
  fields: {
    identifier: null,
    password: null,
    code: null
  },
  raw: null,
  global: null
}), Cpe = () => ({
  fields: {
    firstName: null,
    lastName: null,
    emailAddress: null,
    phoneNumber: null,
    password: null,
    username: null,
    code: null,
    captcha: null,
    legalAccepted: null
  },
  raw: null,
  global: null
}), Epe = class {
  constructor(e) {
    this.isomorphicClerk = e, this.signInSignalProxy = this.buildSignInProxy(), this.signUpSignalProxy = this.buildSignUpProxy();
  }
  signInSignal() {
    return this.signInSignalProxy;
  }
  signUpSignal() {
    return this.signUpSignalProxy;
  }
  buildSignInProxy() {
    const e = this.gateProperty.bind(this), t = () => this.client.signIn.__internal_future;
    return {
      errors: kpe(),
      fetchStatus: "idle",
      signIn: {
        status: "needs_identifier",
        availableStrategies: [],
        isTransferable: !1,
        get id() {
          return e(t, "id", void 0);
        },
        get supportedFirstFactors() {
          return e(t, "supportedFirstFactors", []);
        },
        get supportedSecondFactors() {
          return e(t, "supportedSecondFactors", []);
        },
        get secondFactorVerification() {
          return e(t, "secondFactorVerification", {
            status: null,
            error: null,
            expireAt: null,
            externalVerificationRedirectURL: null,
            nonce: null,
            attempts: null,
            message: null,
            strategy: null,
            verifiedAtClient: null,
            verifiedFromTheSameClient: () => !1,
            __internal_toSnapshot: () => {
              throw new Error("__internal_toSnapshot called before Clerk is loaded");
            },
            pathRoot: "",
            reload: () => {
              throw new Error("__internal_toSnapshot called before Clerk is loaded");
            }
          });
        },
        get identifier() {
          return e(t, "identifier", null);
        },
        get createdSessionId() {
          return e(t, "createdSessionId", null);
        },
        get userData() {
          return e(t, "userData", {});
        },
        get firstFactorVerification() {
          return e(t, "firstFactorVerification", {
            status: null,
            error: null,
            expireAt: null,
            externalVerificationRedirectURL: null,
            nonce: null,
            attempts: null,
            message: null,
            strategy: null,
            verifiedAtClient: null,
            verifiedFromTheSameClient: () => !1,
            __internal_toSnapshot: () => {
              throw new Error("__internal_toSnapshot called before Clerk is loaded");
            },
            pathRoot: "",
            reload: () => {
              throw new Error("__internal_toSnapshot called before Clerk is loaded");
            }
          });
        },
        create: this.gateMethod(t, "create"),
        password: this.gateMethod(t, "password"),
        sso: this.gateMethod(t, "sso"),
        finalize: this.gateMethod(t, "finalize"),
        emailCode: this.wrapMethods(() => t().emailCode, ["sendCode", "verifyCode"]),
        emailLink: this.wrapStruct(
          () => t().emailLink,
          ["sendLink", "waitForVerification"],
          ["verification"],
          { verification: null }
        ),
        resetPasswordEmailCode: this.wrapMethods(() => t().resetPasswordEmailCode, [
          "sendCode",
          "verifyCode",
          "submitPassword"
        ]),
        phoneCode: this.wrapMethods(() => t().phoneCode, ["sendCode", "verifyCode"]),
        mfa: this.wrapMethods(() => t().mfa, [
          "sendPhoneCode",
          "verifyPhoneCode",
          "verifyTOTP",
          "verifyBackupCode"
        ]),
        ticket: this.gateMethod(t, "ticket"),
        passkey: this.gateMethod(t, "passkey"),
        web3: this.gateMethod(t, "web3")
      }
    };
  }
  buildSignUpProxy() {
    const e = this.gateProperty.bind(this), t = this.gateMethod.bind(this), n = this.wrapMethods.bind(this), r = () => this.client.signUp.__internal_future;
    return {
      errors: Cpe(),
      fetchStatus: "idle",
      signUp: {
        get id() {
          return e(r, "id", void 0);
        },
        get requiredFields() {
          return e(r, "requiredFields", []);
        },
        get optionalFields() {
          return e(r, "optionalFields", []);
        },
        get missingFields() {
          return e(r, "missingFields", []);
        },
        get username() {
          return e(r, "username", null);
        },
        get firstName() {
          return e(r, "firstName", null);
        },
        get lastName() {
          return e(r, "lastName", null);
        },
        get emailAddress() {
          return e(r, "emailAddress", null);
        },
        get phoneNumber() {
          return e(r, "phoneNumber", null);
        },
        get web3Wallet() {
          return e(r, "web3Wallet", null);
        },
        get hasPassword() {
          return e(r, "hasPassword", !1);
        },
        get unsafeMetadata() {
          return e(r, "unsafeMetadata", {});
        },
        get createdSessionId() {
          return e(r, "createdSessionId", null);
        },
        get createdUserId() {
          return e(r, "createdUserId", null);
        },
        get abandonAt() {
          return e(r, "abandonAt", null);
        },
        get legalAcceptedAt() {
          return e(r, "legalAcceptedAt", null);
        },
        get locale() {
          return e(r, "locale", null);
        },
        get status() {
          return e(r, "status", "missing_requirements");
        },
        get unverifiedFields() {
          return e(r, "unverifiedFields", []);
        },
        get isTransferable() {
          return e(r, "isTransferable", !1);
        },
        create: t(r, "create"),
        update: t(r, "update"),
        sso: t(r, "sso"),
        password: t(r, "password"),
        ticket: t(r, "ticket"),
        web3: t(r, "web3"),
        finalize: t(r, "finalize"),
        verifications: n(() => r().verifications, [
          "sendEmailCode",
          "verifyEmailCode",
          "sendPhoneCode",
          "verifyPhoneCode"
        ])
      }
    };
  }
  __internal_effect(e) {
    throw new Error("__internal_effect called before Clerk is loaded");
  }
  __internal_computed(e) {
    throw new Error("__internal_computed called before Clerk is loaded");
  }
  get client() {
    const e = this.isomorphicClerk.client;
    if (!e)
      throw new Error("Clerk client not ready");
    return e;
  }
  gateProperty(e, t, n) {
    return !jb() || !this.isomorphicClerk.loaded ? n : e()[t];
  }
  gateMethod(e, t) {
    return (async (...n) => {
      if (!jb())
        return qu.throw(`Attempted to call a method (${t}) that is not supported on the server.`);
      this.isomorphicClerk.loaded || await new Promise((i) => this.isomorphicClerk.addOnLoaded(i));
      const r = e();
      return r[t].apply(r, n);
    });
  }
  wrapMethods(e, t) {
    return Object.fromEntries(t.map((n) => [n, this.gateMethod(e, n)]));
  }
  wrapStruct(e, t, n, r) {
    const i = {};
    for (const o of t)
      i[o] = this.gateMethod(e, o);
    for (const o of n)
      Object.defineProperty(i, o, {
        get: () => this.gateProperty(e, o, r[o]),
        enumerable: !0
      });
    return i;
  }
};
typeof globalThis.__BUILD_DISABLE_RHC__ > "u" && (globalThis.__BUILD_DISABLE_RHC__ = !1);
var _pe = {
  name: "@clerk/clerk-react",
  version: "5.60.0",
  environment: "production"
}, U0, Pf, Df, tc, zs, F0, ic, wm, V0, Tpe = class LF {
  constructor(t) {
    ec(this, wm), this.clerkjs = null, this.preopenOneTap = null, this.preopenUserVerification = null, this.preopenEnableOrganizationsPrompt = null, this.preopenSignIn = null, this.preopenCheckout = null, this.preopenPlanDetails = null, this.preopenSubscriptionDetails = null, this.preopenSignUp = null, this.preopenUserProfile = null, this.preopenOrganizationProfile = null, this.preopenCreateOrganization = null, this.preOpenWaitlist = null, this.premountSignInNodes = /* @__PURE__ */ new Map(), this.premountSignUpNodes = /* @__PURE__ */ new Map(), this.premountUserAvatarNodes = /* @__PURE__ */ new Map(), this.premountUserProfileNodes = /* @__PURE__ */ new Map(), this.premountUserButtonNodes = /* @__PURE__ */ new Map(), this.premountOrganizationProfileNodes = /* @__PURE__ */ new Map(), this.premountCreateOrganizationNodes = /* @__PURE__ */ new Map(), this.premountOrganizationSwitcherNodes = /* @__PURE__ */ new Map(), this.premountOrganizationListNodes = /* @__PURE__ */ new Map(), this.premountMethodCalls = /* @__PURE__ */ new Map(), this.premountWaitlistNodes = /* @__PURE__ */ new Map(), this.premountPricingTableNodes = /* @__PURE__ */ new Map(), this.premountAPIKeysNodes = /* @__PURE__ */ new Map(), this.premountOAuthConsentNodes = /* @__PURE__ */ new Map(), this.premountTaskChooseOrganizationNodes = /* @__PURE__ */ new Map(), this.premountTaskResetPasswordNodes = /* @__PURE__ */ new Map(), this.premountAddListenerCalls = /* @__PURE__ */ new Map(), this.loadedListeners = [], ec(this, U0, "loading"), ec(this, Pf), ec(this, Df), ec(this, tc), ec(this, zs, Spe()), ec(this, F0), this.buildSignInUrl = (i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildSignInUrl(i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildSignInUrl", o);
    }, this.buildSignUpUrl = (i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildSignUpUrl(i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildSignUpUrl", o);
    }, this.buildAfterSignInUrl = (...i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildAfterSignInUrl(...i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildAfterSignInUrl", o);
    }, this.buildAfterSignUpUrl = (...i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildAfterSignUpUrl(...i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildAfterSignUpUrl", o);
    }, this.buildAfterSignOutUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildAfterSignOutUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildAfterSignOutUrl", i);
    }, this.buildNewSubscriptionRedirectUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildNewSubscriptionRedirectUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildNewSubscriptionRedirectUrl", i);
    }, this.buildAfterMultiSessionSingleSignOutUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildAfterMultiSessionSingleSignOutUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildAfterMultiSessionSingleSignOutUrl", i);
    }, this.buildUserProfileUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildUserProfileUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildUserProfileUrl", i);
    }, this.buildCreateOrganizationUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildCreateOrganizationUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildCreateOrganizationUrl", i);
    }, this.buildOrganizationProfileUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildOrganizationProfileUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildOrganizationProfileUrl", i);
    }, this.buildWaitlistUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildWaitlistUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildWaitlistUrl", i);
    }, this.buildTasksUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildTasksUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildTasksUrl", i);
    }, this.buildUrlWithAuth = (i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildUrlWithAuth(i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildUrlWithAuth", o);
    }, this.handleUnauthenticated = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.handleUnauthenticated();
      };
      this.clerkjs && this.loaded ? i() : this.premountMethodCalls.set("handleUnauthenticated", i);
    }, this.on = (...i) => {
      var o;
      if ((o = this.clerkjs) != null && o.on)
        return this.clerkjs.on(...i);
      Un(this, zs).on(...i);
    }, this.off = (...i) => {
      var o;
      if ((o = this.clerkjs) != null && o.off)
        return this.clerkjs.off(...i);
      Un(this, zs).off(...i);
    }, this.addOnLoaded = (i) => {
      this.loadedListeners.push(i), this.loaded && this.emitLoaded();
    }, this.emitLoaded = () => {
      this.loadedListeners.forEach((i) => i()), this.loadedListeners = [];
    }, this.beforeLoad = (i) => {
      if (!i)
        throw new Error("Failed to hydrate latest Clerk JS");
    }, this.hydrateClerkJS = (i) => {
      var o, s;
      if (!i)
        throw new Error("Failed to hydrate latest Clerk JS");
      return this.clerkjs = i, this.premountMethodCalls.forEach((a) => a()), this.premountAddListenerCalls.forEach((a, c) => {
        a.nativeUnsubscribe = i.addListener(c);
      }), (o = Un(this, zs).internal.retrieveListeners("status")) == null || o.forEach((a) => {
        this.on("status", a, { notify: !0 });
      }), (s = Un(this, zs).internal.retrieveListeners("queryClientStatus")) == null || s.forEach((a) => {
        this.on("queryClientStatus", a, { notify: !0 });
      }), this.preopenSignIn !== null && i.openSignIn(this.preopenSignIn), this.preopenCheckout !== null && i.__internal_openCheckout(this.preopenCheckout), this.preopenPlanDetails !== null && i.__internal_openPlanDetails(this.preopenPlanDetails), this.preopenSubscriptionDetails !== null && i.__internal_openSubscriptionDetails(this.preopenSubscriptionDetails), this.preopenSignUp !== null && i.openSignUp(this.preopenSignUp), this.preopenUserProfile !== null && i.openUserProfile(this.preopenUserProfile), this.preopenUserVerification !== null && i.__internal_openReverification(this.preopenUserVerification), this.preopenOneTap !== null && i.openGoogleOneTap(this.preopenOneTap), this.preopenOrganizationProfile !== null && i.openOrganizationProfile(this.preopenOrganizationProfile), this.preopenCreateOrganization !== null && i.openCreateOrganization(this.preopenCreateOrganization), this.preOpenWaitlist !== null && i.openWaitlist(this.preOpenWaitlist), this.preopenEnableOrganizationsPrompt && i.__internal_openEnableOrganizationsPrompt(this.preopenEnableOrganizationsPrompt), this.premountSignInNodes.forEach((a, c) => {
        i.mountSignIn(c, a);
      }), this.premountSignUpNodes.forEach((a, c) => {
        i.mountSignUp(c, a);
      }), this.premountUserProfileNodes.forEach((a, c) => {
        i.mountUserProfile(c, a);
      }), this.premountUserAvatarNodes.forEach((a, c) => {
        i.mountUserAvatar(c, a);
      }), this.premountUserButtonNodes.forEach((a, c) => {
        i.mountUserButton(c, a);
      }), this.premountOrganizationListNodes.forEach((a, c) => {
        i.mountOrganizationList(c, a);
      }), this.premountWaitlistNodes.forEach((a, c) => {
        i.mountWaitlist(c, a);
      }), this.premountPricingTableNodes.forEach((a, c) => {
        i.mountPricingTable(c, a);
      }), this.premountAPIKeysNodes.forEach((a, c) => {
        i.mountAPIKeys(c, a);
      }), this.premountOAuthConsentNodes.forEach((a, c) => {
        i.__internal_mountOAuthConsent(c, a);
      }), this.premountTaskChooseOrganizationNodes.forEach((a, c) => {
        i.mountTaskChooseOrganization(c, a);
      }), this.premountTaskResetPasswordNodes.forEach((a, c) => {
        i.mountTaskResetPassword(c, a);
      }), typeof this.clerkjs.status > "u" && Un(this, zs).emit(Xv.Status, "ready"), this.emitLoaded(), this.clerkjs;
    }, this.__experimental_checkout = (...i) => {
      var o;
      return (o = this.clerkjs) == null ? void 0 : o.__experimental_checkout(...i);
    }, this.__unstable__updateProps = async (i) => {
      const o = await bC(this, wm, V0).call(this);
      if (o && "__unstable__updateProps" in o)
        return o.__unstable__updateProps(i);
    }, this.setActive = (i) => this.clerkjs ? this.clerkjs.setActive(i) : Promise.reject(), this.openSignIn = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openSignIn(i) : this.preopenSignIn = i;
    }, this.closeSignIn = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeSignIn() : this.preopenSignIn = null;
    }, this.__internal_openCheckout = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openCheckout(i) : this.preopenCheckout = i;
    }, this.__internal_closeCheckout = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closeCheckout() : this.preopenCheckout = null;
    }, this.__internal_openPlanDetails = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openPlanDetails(i) : this.preopenPlanDetails = i;
    }, this.__internal_closePlanDetails = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closePlanDetails() : this.preopenPlanDetails = null;
    }, this.__internal_openSubscriptionDetails = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openSubscriptionDetails(i) : this.preopenSubscriptionDetails = i ?? null;
    }, this.__internal_closeSubscriptionDetails = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closeSubscriptionDetails() : this.preopenSubscriptionDetails = null;
    }, this.__internal_openReverification = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openReverification(i) : this.preopenUserVerification = i;
    }, this.__internal_closeReverification = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closeReverification() : this.preopenUserVerification = null;
    }, this.__internal_openEnableOrganizationsPrompt = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openEnableOrganizationsPrompt(i) : this.preopenEnableOrganizationsPrompt = i;
    }, this.__internal_closeEnableOrganizationsPrompt = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closeEnableOrganizationsPrompt() : this.preopenEnableOrganizationsPrompt = null;
    }, this.openGoogleOneTap = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openGoogleOneTap(i) : this.preopenOneTap = i;
    }, this.closeGoogleOneTap = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeGoogleOneTap() : this.preopenOneTap = null;
    }, this.openUserProfile = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openUserProfile(i) : this.preopenUserProfile = i;
    }, this.closeUserProfile = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeUserProfile() : this.preopenUserProfile = null;
    }, this.openOrganizationProfile = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openOrganizationProfile(i) : this.preopenOrganizationProfile = i;
    }, this.closeOrganizationProfile = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeOrganizationProfile() : this.preopenOrganizationProfile = null;
    }, this.openCreateOrganization = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openCreateOrganization(i) : this.preopenCreateOrganization = i;
    }, this.closeCreateOrganization = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeCreateOrganization() : this.preopenCreateOrganization = null;
    }, this.openWaitlist = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openWaitlist(i) : this.preOpenWaitlist = i;
    }, this.closeWaitlist = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeWaitlist() : this.preOpenWaitlist = null;
    }, this.openSignUp = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openSignUp(i) : this.preopenSignUp = i;
    }, this.closeSignUp = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeSignUp() : this.preopenSignUp = null;
    }, this.mountSignIn = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountSignIn(i, o) : this.premountSignInNodes.set(i, o);
    }, this.unmountSignIn = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountSignIn(i) : this.premountSignInNodes.delete(i);
    }, this.mountSignUp = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountSignUp(i, o) : this.premountSignUpNodes.set(i, o);
    }, this.unmountSignUp = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountSignUp(i) : this.premountSignUpNodes.delete(i);
    }, this.mountUserAvatar = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountUserAvatar(i, o) : this.premountUserAvatarNodes.set(i, o);
    }, this.unmountUserAvatar = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountUserAvatar(i) : this.premountUserAvatarNodes.delete(i);
    }, this.mountUserProfile = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountUserProfile(i, o) : this.premountUserProfileNodes.set(i, o);
    }, this.unmountUserProfile = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountUserProfile(i) : this.premountUserProfileNodes.delete(i);
    }, this.mountOrganizationProfile = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountOrganizationProfile(i, o) : this.premountOrganizationProfileNodes.set(i, o);
    }, this.unmountOrganizationProfile = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountOrganizationProfile(i) : this.premountOrganizationProfileNodes.delete(i);
    }, this.mountCreateOrganization = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountCreateOrganization(i, o) : this.premountCreateOrganizationNodes.set(i, o);
    }, this.unmountCreateOrganization = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountCreateOrganization(i) : this.premountCreateOrganizationNodes.delete(i);
    }, this.mountOrganizationSwitcher = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountOrganizationSwitcher(i, o) : this.premountOrganizationSwitcherNodes.set(i, o);
    }, this.unmountOrganizationSwitcher = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountOrganizationSwitcher(i) : this.premountOrganizationSwitcherNodes.delete(i);
    }, this.__experimental_prefetchOrganizationSwitcher = () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.__experimental_prefetchOrganizationSwitcher();
      };
      this.clerkjs && this.loaded ? i() : this.premountMethodCalls.set("__experimental_prefetchOrganizationSwitcher", i);
    }, this.mountOrganizationList = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountOrganizationList(i, o) : this.premountOrganizationListNodes.set(i, o);
    }, this.unmountOrganizationList = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountOrganizationList(i) : this.premountOrganizationListNodes.delete(i);
    }, this.mountUserButton = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountUserButton(i, o) : this.premountUserButtonNodes.set(i, o);
    }, this.unmountUserButton = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountUserButton(i) : this.premountUserButtonNodes.delete(i);
    }, this.mountWaitlist = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountWaitlist(i, o) : this.premountWaitlistNodes.set(i, o);
    }, this.unmountWaitlist = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountWaitlist(i) : this.premountWaitlistNodes.delete(i);
    }, this.mountPricingTable = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountPricingTable(i, o) : this.premountPricingTableNodes.set(i, o);
    }, this.unmountPricingTable = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountPricingTable(i) : this.premountPricingTableNodes.delete(i);
    }, this.mountAPIKeys = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountAPIKeys(i, o) : this.premountAPIKeysNodes.set(i, o);
    }, this.unmountAPIKeys = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountAPIKeys(i) : this.premountAPIKeysNodes.delete(i);
    }, this.__internal_mountOAuthConsent = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_mountOAuthConsent(i, o) : this.premountOAuthConsentNodes.set(i, o);
    }, this.__internal_unmountOAuthConsent = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_unmountOAuthConsent(i) : this.premountOAuthConsentNodes.delete(i);
    }, this.mountTaskChooseOrganization = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountTaskChooseOrganization(i, o) : this.premountTaskChooseOrganizationNodes.set(i, o);
    }, this.unmountTaskChooseOrganization = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountTaskChooseOrganization(i) : this.premountTaskChooseOrganizationNodes.delete(i);
    }, this.mountTaskResetPassword = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountTaskResetPassword(i, o) : this.premountTaskResetPasswordNodes.set(i, o);
    }, this.unmountTaskResetPassword = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountTaskResetPassword(i) : this.premountTaskResetPasswordNodes.delete(i);
    }, this.addListener = (i) => {
      if (this.clerkjs)
        return this.clerkjs.addListener(i);
      {
        const o = () => {
          var s;
          const a = this.premountAddListenerCalls.get(i);
          a && ((s = a.nativeUnsubscribe) == null || s.call(a), this.premountAddListenerCalls.delete(i));
        };
        return this.premountAddListenerCalls.set(i, { unsubscribe: o, nativeUnsubscribe: void 0 }), o;
      }
    }, this.navigate = (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.navigate(i);
      };
      this.clerkjs && this.loaded ? o() : this.premountMethodCalls.set("navigate", o);
    }, this.redirectWithAuth = async (...i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.redirectWithAuth(...i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("redirectWithAuth", o);
    }, this.redirectToSignIn = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.redirectToSignIn(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("redirectToSignIn", o);
    }, this.redirectToSignUp = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.redirectToSignUp(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("redirectToSignUp", o);
    }, this.redirectToUserProfile = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToUserProfile();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToUserProfile", i);
    }, this.redirectToAfterSignUp = () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToAfterSignUp();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToAfterSignUp", i);
    }, this.redirectToAfterSignIn = () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToAfterSignIn();
      };
      this.clerkjs && this.loaded ? i() : this.premountMethodCalls.set("redirectToAfterSignIn", i);
    }, this.redirectToAfterSignOut = () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToAfterSignOut();
      };
      this.clerkjs && this.loaded ? i() : this.premountMethodCalls.set("redirectToAfterSignOut", i);
    }, this.redirectToOrganizationProfile = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToOrganizationProfile();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToOrganizationProfile", i);
    }, this.redirectToCreateOrganization = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToCreateOrganization();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToCreateOrganization", i);
    }, this.redirectToWaitlist = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToWaitlist();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToWaitlist", i);
    }, this.redirectToTasks = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.redirectToTasks(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("redirectToTasks", o);
    }, this.handleRedirectCallback = async (i) => {
      var o;
      const s = () => {
        var a;
        return (a = this.clerkjs) == null ? void 0 : a.handleRedirectCallback(i);
      };
      this.clerkjs && this.loaded ? (o = s()) == null || o.catch(() => {
      }) : this.premountMethodCalls.set("handleRedirectCallback", s);
    }, this.handleGoogleOneTapCallback = async (i, o) => {
      var s;
      const a = () => {
        var c;
        return (c = this.clerkjs) == null ? void 0 : c.handleGoogleOneTapCallback(i, o);
      };
      this.clerkjs && this.loaded ? (s = a()) == null || s.catch(() => {
      }) : this.premountMethodCalls.set("handleGoogleOneTapCallback", a);
    }, this.handleEmailLinkVerification = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.handleEmailLinkVerification(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("handleEmailLinkVerification", o);
    }, this.authenticateWithMetamask = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithMetamask(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithMetamask", o);
    }, this.authenticateWithCoinbaseWallet = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithCoinbaseWallet(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithCoinbaseWallet", o);
    }, this.authenticateWithBase = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithBase(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithBase", o);
    }, this.authenticateWithOKXWallet = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithOKXWallet(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithOKXWallet", o);
    }, this.authenticateWithSolana = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithSolana(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithSolana", o);
    }, this.authenticateWithWeb3 = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithWeb3(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithWeb3", o);
    }, this.authenticateWithGoogleOneTap = async (i) => (await bC(this, wm, V0).call(this)).authenticateWithGoogleOneTap(i), this.__internal_loadStripeJs = async () => (await bC(this, wm, V0).call(this)).__internal_loadStripeJs(), this.createOrganization = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.createOrganization(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("createOrganization", o);
    }, this.getOrganization = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.getOrganization(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("getOrganization", o);
    }, this.joinWaitlist = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.joinWaitlist(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("joinWaitlist", o);
    }, this.signOut = async (...i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.signOut(...i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("signOut", o);
    }, this.__internal_attemptToEnableEnvironmentSetting = (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.__internal_attemptToEnableEnvironmentSetting(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("__internal_attemptToEnableEnvironmentSetting", o);
    };
    const { Clerk: n = null, publishableKey: r } = t || {};
    Mu(this, tc, r), Mu(this, Df, t?.proxyUrl), Mu(this, Pf, t?.domain), this.options = t, this.Clerk = n, this.mode = jb() ? "browser" : "server", Mu(this, F0, new Epe(this)), this.options.sdkMetadata || (this.options.sdkMetadata = _pe), Un(this, zs).emit(Xv.Status, "loading"), Un(this, zs).prioritizedOn(Xv.Status, (i) => Mu(this, U0, i)), Un(this, tc) && this.loadClerkJS();
  }
  get publishableKey() {
    return Un(this, tc);
  }
  get loaded() {
    var t;
    return ((t = this.clerkjs) == null ? void 0 : t.loaded) || !1;
  }
  get status() {
    var t;
    return this.clerkjs ? ((t = this.clerkjs) == null ? void 0 : t.status) || /**
    * Support older clerk-js versions.
    * If clerk-js is available but `.status` is missing it we need to fallback to `.loaded`.
    * Since "degraded" an "error" did not exist before,
    * map "loaded" to "ready" and "not loaded" to "loading".
    */
    (this.clerkjs.loaded ? "ready" : "loading") : Un(this, U0);
  }
  static getOrCreateInstance(t) {
    return (!jb() || !Un(this, ic) || t.Clerk && Un(this, ic).Clerk !== t.Clerk || // Allow hot swapping PKs on the client
    Un(this, ic).publishableKey !== t.publishableKey) && Mu(this, ic, new LF(t)), Un(this, ic);
  }
  static clearInstance() {
    Mu(this, ic, null);
  }
  get domain() {
    return typeof window < "u" && window.location ? pC(Un(this, Pf), new URL(window.location.href), "") : typeof Un(this, Pf) == "function" ? qu.throw(hC) : Un(this, Pf) || "";
  }
  get proxyUrl() {
    return typeof window < "u" && window.location ? pC(Un(this, Df), new URL(window.location.href), "") : typeof Un(this, Df) == "function" ? qu.throw(hC) : Un(this, Df) || "";
  }
  /**
   * Accesses private options from the `Clerk` instance and defaults to
   * `IsomorphicClerk` options when in SSR context.
   *  @internal
   */
  __internal_getOption(t) {
    var n, r;
    return (n = this.clerkjs) != null && n.__internal_getOption ? (r = this.clerkjs) == null ? void 0 : r.__internal_getOption(t) : this.options[t];
  }
  get sdkMetadata() {
    var t;
    return ((t = this.clerkjs) == null ? void 0 : t.sdkMetadata) || this.options.sdkMetadata || void 0;
  }
  get instanceType() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.instanceType;
  }
  get frontendApi() {
    var t;
    return ((t = this.clerkjs) == null ? void 0 : t.frontendApi) || "";
  }
  get isStandardBrowser() {
    var t;
    return ((t = this.clerkjs) == null ? void 0 : t.isStandardBrowser) || this.options.standardBrowser || !1;
  }
  get __internal_queryClient() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.__internal_queryClient;
  }
  get isSatellite() {
    return typeof window < "u" && window.location ? pC(this.options.isSatellite, new URL(window.location.href), !1) : typeof this.options.isSatellite == "function" ? qu.throw(hC) : !1;
  }
  async loadClerkJS() {
    var t;
    if (!(this.mode !== "browser" || this.loaded)) {
      typeof window < "u" && (window.__clerk_publishable_key = Un(this, tc), window.__clerk_proxy_url = this.proxyUrl, window.__clerk_domain = this.domain);
      try {
        if (this.Clerk) {
          let n;
          Fhe(this.Clerk) ? (n = new this.Clerk(Un(this, tc), {
            proxyUrl: this.proxyUrl,
            domain: this.domain
          }), this.beforeLoad(n), await n.load(this.options)) : (n = this.Clerk, n.loaded || (this.beforeLoad(n), await n.load(this.options))), global.Clerk = n;
        } else if (!__BUILD_DISABLE_RHC__) {
          if (global.Clerk || await ype({
            ...this.options,
            publishableKey: Un(this, tc),
            proxyUrl: this.proxyUrl,
            domain: this.domain,
            nonce: this.options.nonce
          }), !global.Clerk)
            throw new Error("Failed to download latest ClerkJS. Contact support@clerk.com.");
          this.beforeLoad(global.Clerk), await global.Clerk.load(this.options);
        }
        return (t = global.Clerk) != null && t.loaded ? this.hydrateClerkJS(global.Clerk) : void 0;
      } catch (n) {
        const r = n;
        Un(this, zs).emit(Xv.Status, "error"), console.error(r.stack || r.message || r);
        return;
      }
    }
  }
  get version() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.version;
  }
  get client() {
    if (this.clerkjs)
      return this.clerkjs.client;
  }
  get session() {
    if (this.clerkjs)
      return this.clerkjs.session;
  }
  get user() {
    if (this.clerkjs)
      return this.clerkjs.user;
  }
  get organization() {
    if (this.clerkjs)
      return this.clerkjs.organization;
  }
  get telemetry() {
    if (this.clerkjs)
      return this.clerkjs.telemetry;
  }
  get __unstable__environment() {
    if (this.clerkjs)
      return this.clerkjs.__unstable__environment;
  }
  get isSignedIn() {
    return this.clerkjs ? this.clerkjs.isSignedIn : !1;
  }
  get billing() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.billing;
  }
  get __internal_state() {
    return this.loaded && this.clerkjs ? this.clerkjs.__internal_state : Un(this, F0);
  }
  get apiKeys() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.apiKeys;
  }
  __unstable__setEnvironment(...t) {
    if (this.clerkjs && "__unstable__setEnvironment" in this.clerkjs)
      this.clerkjs.__unstable__setEnvironment(t);
    else
      return;
  }
};
U0 = /* @__PURE__ */ new WeakMap();
Pf = /* @__PURE__ */ new WeakMap();
Df = /* @__PURE__ */ new WeakMap();
tc = /* @__PURE__ */ new WeakMap();
zs = /* @__PURE__ */ new WeakMap();
F0 = /* @__PURE__ */ new WeakMap();
ic = /* @__PURE__ */ new WeakMap();
wm = /* @__PURE__ */ new WeakSet();
V0 = function() {
  return new Promise((e) => {
    this.addOnLoaded(() => e(this.clerkjs));
  });
};
ec(Tpe, ic);
whe({ packageName: "@clerk/clerk-react" });
mpe("@clerk/clerk-react");
const Ape = ({
  message: e = "Loading...",
  size: t = "md",
  variant: n = "dots"
}) => {
  const r = {
    sm: "h-1 w-1",
    md: "h-2 w-2",
    lg: "h-3 w-3"
  }, i = {
    sm: "gap-1",
    md: "gap-1.5",
    lg: "gap-2"
  }, o = {
    sm: "text-[10px]",
    md: "text-xs",
    lg: "text-sm"
  }, s = () => /* @__PURE__ */ v.jsxs("div", { className: `flex items-center ${i[t]}`, children: [
    /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${r[t]} animate-pulse rounded-full bg-primary`,
        style: { animationDelay: "0ms", animationDuration: "1s" }
      }
    ),
    /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${r[t]} animate-pulse rounded-full bg-primary`,
        style: { animationDelay: "150ms", animationDuration: "1s" }
      }
    ),
    /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${r[t]} animate-pulse rounded-full bg-primary`,
        style: { animationDelay: "300ms", animationDuration: "1s" }
      }
    )
  ] }), a = () => {
    const h = {
      sm: "h-4 w-4",
      md: "h-6 w-6",
      lg: "h-8 w-8"
    };
    return /* @__PURE__ */ v.jsx(
      "div",
      {
        className: `${h[t]} animate-spin rounded-full border-2 border-primary border-t-transparent`
      }
    );
  }, c = () => {
    const h = {
      sm: "h-4 w-4",
      md: "h-6 w-6",
      lg: "h-8 w-8"
    };
    return /* @__PURE__ */ v.jsxs("div", { className: "relative flex items-center justify-center", children: [
      /* @__PURE__ */ v.jsx(
        "span",
        {
          className: `${h[t]} absolute animate-ping rounded-full bg-primary/40`
        }
      ),
      /* @__PURE__ */ v.jsx("span", { className: `${h[t]} relative rounded-full bg-primary` })
    ] });
  }, u = () => {
    const h = {
      sm: "h-3",
      md: "h-4",
      lg: "h-5"
    }, m = {
      sm: "w-0.5",
      md: "w-1",
      lg: "w-1.5"
    };
    return /* @__PURE__ */ v.jsx("div", { className: `flex items-end ${i[t]}`, children: [0, 1, 2, 3].map((g) => /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${m[t]} ${h[t]} animate-pulse rounded-sm bg-primary`,
        style: {
          animationDelay: `${g * 100}ms`,
          animationDuration: "0.8s"
        }
      },
      g
    )) });
  }, f = () => {
    switch (n) {
      case "spinner":
        return a();
      case "pulse":
        return c();
      case "bars":
        return u();
      default:
        return s();
    }
  };
  return /* @__PURE__ */ v.jsxs("div", { className: "inline-flex items-center gap-2", children: [
    f(),
    e && /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${o[t]} tracking-wide text-muted-foreground`,
        children: e
      }
    )
  ] });
}, Mpe = (e = /* @__PURE__ */ new Date()) => e.toLocaleTimeString("en-GB", { hour12: !1 }), Npe = [
  "",
  "                                                   ",
  "                  24K TWIN EDITOR                  ",
  "                                                   ",
  "         Advanced Development Environment          ",
  "                                                   ",
  "                                                   ",
  "         Initializing System Components...         ",
  "                                                   ",
  ""
], Rpe = [
  { lines: ["[SYSTEM] Initializing connection..."], tone: "muted", delay: 500 },
  { lines: ["[SYSTEM] Loading application modules..."], tone: "muted", delay: 850 },
  { lines: Npe, tone: "banner", delay: 1200, timestamp: !1 },
  { lines: ["[CORE] Allocating resources..."], tone: "muted", delay: 900 },
  { lines: ["[CORE] Configuring environment..."], tone: "muted", delay: 950 },
  { lines: ["[ENGINE] Starting twin editor engine..."], tone: "normal", delay: 800 },
  { lines: ["[ENGINE] Mounting components..."], tone: "normal", delay: 850 },
  { lines: ["[UI] Rendering interface..."], tone: "normal", delay: 850 },
  { lines: ["[READY] All systems operational"], tone: "accent", delay: 850 },
  {
    lines: ["[STATUS] Twin Editor is ready for development"],
    tone: "accent",
    delay: 1100
  }
], Ope = {
  muted: "text-muted-foreground/60",
  normal: "text-foreground/85",
  accent: "text-primary font-semibold drop-shadow-[0_0_8px_hsl(var(--primary)/0.45)]",
  banner: "text-primary/70 font-semibold"
}, Ppe = () => {
  const [e, t] = C.useState([]), n = C.useRef(null), r = C.useRef(0);
  return C.useEffect(() => {
    const i = [];
    let o = 0;
    return t([]), Rpe.forEach((s) => {
      o += s.delay, i.push(
        window.setTimeout(() => {
          const a = Mpe();
          t((c) => {
            const u = [...c];
            return s.tone === "banner" ? (r.current += 1, u.push({
              id: String(r.current),
              message: s.lines.join(`
`),
              timestamp: s.timestamp === !1 ? void 0 : a,
              tone: s.tone ?? "normal"
            }), u) : (s.lines.forEach((f) => {
              r.current += 1, u.push({
                id: String(r.current),
                message: f,
                timestamp: s.timestamp === !1 ? void 0 : a,
                tone: s.tone ?? "normal"
              });
            }), u);
          });
        }, o)
      );
    }), () => {
      i.forEach((s) => window.clearTimeout(s));
    };
  }, []), C.useEffect(() => {
    const i = n.current;
    i && (i.scrollTop = i.scrollHeight);
  }, [e]), /* @__PURE__ */ v.jsxs(
    "section",
    {
      className: "relative w-full text-foreground",
      style: { fontFamily: '"Titillium Web", "Titillium_Web", sans-serif' },
      children: [
        /* @__PURE__ */ v.jsx(
          "div",
          {
            ref: n,
            role: "log",
            "aria-live": "polite",
            className: "no-scrollbar max-w-full overflow-x-auto overflow-y-auto pr-2 font-mono text-[11px] leading-snug text-foreground/80",
            children: e.length ? /* @__PURE__ */ v.jsx("div", { className: "flex flex-col gap-1", children: e.map((i) => /* @__PURE__ */ v.jsxs(
              "div",
              {
                className: "flex items-start gap-2 px-2 py-1 transition-colors hover:bg-primary/10 animate-logEntry",
                children: [
                  i.timestamp ? /* @__PURE__ */ v.jsx("span", { className: "w-[64px] shrink-0 text-primary/60 tabular-nums", children: i.timestamp }) : null,
                  /* @__PURE__ */ v.jsx("span", { className: `whitespace-pre ${Ope[i.tone]}`, children: i.message })
                ]
              },
              i.id
            )) }) : /* @__PURE__ */ v.jsx("div", { className: "text-muted-foreground", children: "Awaiting telemetry..." })
          }
        ),
        /* @__PURE__ */ v.jsx("div", { className: "mt-2 flex items-center gap-2 text-[10px] uppercase tracking-[0.3em] text-muted-foreground/60", children: /* @__PURE__ */ v.jsx(Ape, { variant: "bars", size: "sm", message: "Initializing" }) })
      ]
    }
  );
};
function Dpe({ message: e }) {
  const { user: t } = wF(), {
    data: n,
    isLoading: r,
    isValidating: i
  } = W9(), { myServers: o, featuredServers: s } = C.useMemo(() => {
    if (!n) return { myServers: [], featuredServers: [] };
    const S = (N, D) => N.status === D.status ? 0 : N.status === "authorizing" ? -1 : D.status === "authorizing" ? 1 : 0, _ = n.filter((N) => N.userId === HI(t?.id)).sort(S), M = n.filter((N) => N.userId !== HI(t?.id) && N.visibility === "public").sort(S);
    return { myServers: _, featuredServers: M };
  }, [n]), a = C.useMemo(() => [...Rb].sort(() => 0.5 - Math.random()).slice(0, 5), []), [c, u] = C.useState(!1), [f, h] = C.useState(!1), [m, g] = C.useState(!1), b = (S) => {
    const _ = new URLSearchParams();
    _.set("name", S.name), _.set("config", JSON.stringify(S.config)), window.open("/chat-bot/mcp/create?" + _.toString(), "_blank");
  }, x = (S) => {
    h(S), S && g(!1);
  }, w = (S) => {
    g(S), S && h(!1);
  };
  return C.useEffect(() => {
    if (i) {
      u(!1);
      const S = setTimeout(() => u(!0), 500);
      return () => clearTimeout(S);
    }
    u(!1);
  }, [i]), C.useEffect(() => {
    e && Vt(/* @__PURE__ */ v.jsx("p", { className: "whitespace-pre-wrap break-all", children: e }), {
      id: "mcp-list-message"
    });
  }, []), /* @__PURE__ */ v.jsx(v.Fragment, { children: /* @__PURE__ */ v.jsx(yA, { className: "h-full w-full z-40 bg-gradient-to-b from-background via-background to-muted/30", children: /* @__PURE__ */ v.jsx("div", { className: "flex-1 relative w-full mx-auto", children: /* @__PURE__ */ v.jsx("div", { className: "w-full mx-auto px-4 sm:px-6 lg:px-8 py-8", children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-8", children: [
    /* @__PURE__ */ v.jsxs("header", { className: "relative z-10 rounded-2xl border border-border/60 bg-gradient-to-br from-card/90 via-card/90 to-muted/40 p-6 sm:p-8 shadow-sm backdrop-blur", children: [
      /* @__PURE__ */ v.jsx("div", { className: "pointer-events-none absolute -top-20 right-0 h-56 w-56 rounded-full bg-primary/10 blur-3xl" }),
      /* @__PURE__ */ v.jsx("div", { className: "pointer-events-none absolute -bottom-24 left-0 h-56 w-56 rounded-full bg-muted/40 blur-3xl" }),
      /* @__PURE__ */ v.jsxs("div", { className: "relative flex flex-col gap-6", children: [
        /* @__PURE__ */ v.jsxs("div", { className: "flex flex-wrap items-center gap-3 text-xs uppercase tracking-wide text-muted-foreground", children: [
          /* @__PURE__ */ v.jsx("span", { className: "rounded-full border border-border/60 bg-muted/50 px-3 py-1 font-semibold", children: "MCP Directory" }),
          /* @__PURE__ */ v.jsxs("span", { className: "rounded-full border border-border/60 bg-muted/50 px-3 py-1 font-semibold", children: [
            o.length + s.length,
            " servers"
          ] }),
          c && i && !r && /* @__PURE__ */ v.jsxs("span", { className: "inline-flex items-center gap-2 rounded-full border border-border/60 bg-muted/50 px-3 py-1 font-semibold", children: [
            "Refreshing",
            /* @__PURE__ */ v.jsx(ea, { className: "size-3 animate-spin" })
          ] })
        ] }),
        /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col lg:flex-row lg:items-end lg:justify-between gap-6", children: [
          /* @__PURE__ */ v.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ v.jsx("h1", { className: "text-3xl md:text-4xl font-semibold flex items-center gap-3", children: "MCP Servers" }),
            /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground max-w-2xl", children: "Browse your MCP connections, manage visibility, and launch new integrations with confidence." })
          ] }),
          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-wrap items-center gap-2", children: [
            n?.length ? /* @__PURE__ */ v.jsxs(
              od,
              {
                open: f,
                onOpenChange: x,
                children: [
                  /* @__PURE__ */ v.jsx(sd, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
                    qt,
                    {
                      variant: "outline",
                      className: "gap-2 border-border/60 bg-card/80 shadow-sm transition-all hover:bg-card/90 hover:shadow-md cursor-pointer",
                      children: [
                        /* @__PURE__ */ v.jsx("div", { className: "flex -space-x-2 cursor-pointer", children: a.map((S, _) => {
                          const M = S.icon;
                          return /* @__PURE__ */ v.jsx(
                            "div",
                            {
                              className: "relative rounded-full border border-border/60 bg-muted/60 p-1",
                              style: {
                                zIndex: a.length - _
                              },
                              children: /* @__PURE__ */ v.jsx(M, { className: "size-3" })
                            },
                            S.name
                          );
                        }) }),
                        "Recommended MCPs"
                      ]
                    }
                  ) }),
                  /* @__PURE__ */ v.jsx(ad, { align: "end", className: "w-56 p-2 z-1000 bg-popover text-popover-foreground border-border/60 shadow-lg", children: Rb.map((S) => {
                    const _ = S.icon;
                    return /* @__PURE__ */ v.jsxs(
                      hs,
                      {
                        onClick: () => b(S),
                        className: "cursor-pointer flex items-center gap-3 rounded-lg px-3 py-2.5 text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
                        children: [
                          /* @__PURE__ */ v.jsx(_, { className: "size-4" }),
                          /* @__PURE__ */ v.jsx("span", { children: S.label })
                        ]
                      },
                      S.name
                    );
                  }) })
                ]
              }
            ) : null,
            /* @__PURE__ */ v.jsxs(
              qt,
              {
                className: "gap-2 font-semibold shadow-sm transition-all hover:shadow-md cursor-pointer",
                variant: "default",
                "data-testid": "add-mcp-server-button",
                onClick: () => window.open("/chat-bot/mcp/create", "_blank"),
                children: [
                  /* @__PURE__ */ v.jsx(bh, { className: "fill-foreground size-3.5" }),
                  "Add MCP Server"
                ]
              }
            ),
            /* @__PURE__ */ v.jsxs(
              od,
              {
                open: m,
                onOpenChange: w,
                children: [
                  /* @__PURE__ */ v.jsx(sd, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
                    qt,
                    {
                      className: "gap-2 font-semibold border-border/60 bg-card/80 shadow-sm transition-all hover:bg-card/90 hover:shadow-md cursor-pointer",
                      variant: "outline",
                      "data-testid": "marketplace-button",
                      children: [
                        /* @__PURE__ */ v.jsx(MX, { className: "size-3.5" }),
                        "Marketplace"
                      ]
                    }
                  ) }),
                  /* @__PURE__ */ v.jsxs(ad, { align: "end", className: "w-56 p-2 z-1000 bg-popover text-popover-foreground border-border/60 shadow-lg", children: [
                    /* @__PURE__ */ v.jsxs(
                      hs,
                      {
                        onClick: () => window.open("https://smithery.ai/", "_blank"),
                        className: "cursor-pointer flex items-center gap-3 rounded-lg px-3 py-2.5 text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
                        children: [
                          /* @__PURE__ */ v.jsx(EX, { className: "size-4 text-primary" }),
                          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
                            /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "Smithery.ai" }),
                            /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "3,700+ servers" })
                          ] })
                        ]
                      }
                    ),
                    /* @__PURE__ */ v.jsxs(
                      hs,
                      {
                        onClick: () => window.open("https://www.pulsemcp.com/servers", "_blank"),
                        className: "cursor-pointer flex items-center gap-3 rounded-lg px-3 py-2.5 text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
                        children: [
                          /* @__PURE__ */ v.jsx(jX, { className: "size-4 text-primary" }),
                          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
                            /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "PulseMCP" }),
                            /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Community servers" })
                          ] })
                        ]
                      }
                    ),
                    /* @__PURE__ */ v.jsxs(
                      hs,
                      {
                        onClick: () => window.open("https://mcpmarket.com/", "_blank"),
                        className: "cursor-pointer flex items-center gap-3 rounded-lg px-3 py-2.5 text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
                        children: [
                          /* @__PURE__ */ v.jsx(kX, { className: "size-4 text-primary" }),
                          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
                            /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "MCP Market" }),
                            /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Server marketplace" })
                          ] })
                        ]
                      }
                    )
                  ] })
                ]
              }
            )
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ v.jsx("main", { className: "space-y-8", children: r ? /* @__PURE__ */ v.jsx("div", { className: "space-y-6", children: /* @__PURE__ */ v.jsx(Ppe, {}) }) : o?.length || s?.length ? /* @__PURE__ */ v.jsxs(
      "div",
      {
        className: "flex flex-col gap-8",
        "data-testid": "mcp-servers-section",
        children: [
          o?.length > 0 && /* @__PURE__ */ v.jsxs("section", { className: "rounded-2xl border border-border/60 bg-card/80 p-6 shadow-sm", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-4", children: [
              /* @__PURE__ */ v.jsxs("h2", { className: "text-lg font-semibold", children: [
                "My MCP Servers ",
                o.length > 0 ? `(${o.length})` : ""
              ] }),
              /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Private workspace" })
            ] }),
            /* @__PURE__ */ v.jsx(
              "div",
              {
                className: "mt-6 flex flex-col gap-6",
                "data-testid": "my-mcp-servers-section",
                children: o.map((S) => /* @__PURE__ */ v.jsx(nj, { ...S, user: t }, S.id))
              }
            )
          ] }),
          s?.length > 0 && /* @__PURE__ */ v.jsxs("section", { className: "rounded-2xl border border-border/60 bg-card/80 p-6 shadow-sm", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-4", children: [
              /* @__PURE__ */ v.jsx("h2", { className: "text-lg font-semibold", children: "Featured MCP Servers" }),
              /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Curated by community" })
            ] }),
            /* @__PURE__ */ v.jsx(
              "div",
              {
                className: "mt-6 flex flex-col gap-6",
                "data-testid": "featured-mcp-servers-section",
                children: s.map((S) => /* @__PURE__ */ v.jsx(nj, { ...S, user: t }, S.id))
              }
            )
          ] })
        ]
      }
    ) : /* @__PURE__ */ v.jsx(bde, {}) })
  ] }) }) }) }) });
}
const Ipe = ({
  onClose: e,
  title: t = "Chatbot",
  version: n = "v1",
  setApiKeyByName: r,
  onToggleSidebar: i,
  isSidebarOpen: o = !1
}) => {
  const [s, a] = C.useState(!1), [c, u] = C.useState(!1);
  return /* @__PURE__ */ v.jsxs(Fh, { delayDuration: 150, children: [
    /* @__PURE__ */ v.jsxs("div", { className: "chatbot-drag-handle bg-background h-12 px-4 flex items-center justify-between border-b rounded-t-2xl cursor-grab active:cursor-grabbing", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ v.jsx("div", { className: "h-7 w-7 inline-flex items-center justify-center rounded-lg bg-blue-100 dark:bg-[#1abcfe]/10", children: /* @__PURE__ */ v.jsx(QY, { className: "h-4 w-4 text-blue-500 dark:text-[#1abcfe]" }) }),
        /* @__PURE__ */ v.jsx("h3", { className: "text-base font-semibold leading-none text-neutral-900 dark:text-white", children: t }),
        /* @__PURE__ */ v.jsx(Vh, { variant: "outline", className: "hidden sm:inline-flex border-blue-200 text-blue-500 bg-transparent dark:border-[#1abcfe]/40 dark:text-[#1abcfe]", children: n })
      ] }),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-1", children: [
        i && /* @__PURE__ */ v.jsxs(Yi, { children: [
          /* @__PURE__ */ v.jsx(go, { asChild: !0, children: /* @__PURE__ */ v.jsx(
            qt,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-blue-500 cursor-pointer",
              onClick: i,
              "aria-label": o ? "Hide chat history" : "Show chat history",
              children: /* @__PURE__ */ v.jsx(ZY, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ v.jsx(Vo, { children: o ? "Hide chat history" : "Show chat history" })
        ] }),
        /* @__PURE__ */ v.jsxs(Yi, { children: [
          /* @__PURE__ */ v.jsx(go, { asChild: !0, children: /* @__PURE__ */ v.jsx(
            qt,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-blue-500 cursor-pointer",
              "aria-label": "Open settings",
              onClick: () => a(!0),
              children: /* @__PURE__ */ v.jsx(S4, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ v.jsx(Vo, { children: "Settings" })
        ] }),
        /* @__PURE__ */ v.jsxs(Yi, { children: [
          /* @__PURE__ */ v.jsx(go, { asChild: !0, children: /* @__PURE__ */ v.jsx(
            qt,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-foreground cursor-pointer",
              onClick: () => u(!0),
              "aria-label": "MCP Configuration",
              children: /* @__PURE__ */ v.jsx(bh, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ v.jsx(Vo, { children: "MCP Configuration" })
        ] }),
        /* @__PURE__ */ v.jsxs(Yi, { children: [
          /* @__PURE__ */ v.jsx(go, { asChild: !0, children: /* @__PURE__ */ v.jsx(
            qt,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-foreground cursor-pointer",
              onClick: e,
              "aria-label": "Close",
              children: /* @__PURE__ */ v.jsx(Hg, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ v.jsx(Vo, { children: "Close" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ v.jsx(
      Ule,
      {
        open: s,
        onOpenChange: a,
        setApiKeyByName: r
      }
    ),
    /* @__PURE__ */ v.jsx(Hh, { open: c, onOpenChange: u, children: /* @__PURE__ */ v.jsxs(Wh, { className: "w-[90vw]! max-w-[1400px]! max-h-[85vh] overflow-hidden p-0 flex flex-col", children: [
      /* @__PURE__ */ v.jsx(ny, { className: "px-8 pt-6 pb-4 border-b bg-linear-to-r from-background to-muted/20", children: /* @__PURE__ */ v.jsxs(qh, { className: "flex items-center gap-3 text-xl font-bold", children: [
        /* @__PURE__ */ v.jsx("div", { className: "p-2 rounded-lg bg-primary/10", children: /* @__PURE__ */ v.jsx(bh, { className: "h-6 w-6 text-primary" }) }),
        "MCP Configuration"
      ] }) }),
      /* @__PURE__ */ v.jsx("div", { className: "overflow-y-auto px-4 flex-1", children: /* @__PURE__ */ v.jsx(Dpe, {}) })
    ] }) })
  ] });
};
async function Zh() {
  throw new Error("Auth token getter not initialized. Call initAuthTokenGetter() first.");
}
async function Sj(e) {
  if (!e) throw new Error("Missing threadId");
  const t = await Zh(), n = await fetch(`${bd}/${e}`, { headers: t });
  if (!n.ok) {
    const r = await n.json().catch(() => ({}));
    throw new Error(r?.error || "Server error");
  }
  return await n.json();
}
async function jpe(e) {
  if (!e) throw new Error("Missing threadId");
  const t = await Zh(), n = await fetch(`${bd}/${e}`, { method: "DELETE", headers: t });
  if (!n.ok) {
    const r = await n.json().catch(() => ({}));
    throw new Error(r?.error || "Server error");
  }
  return await n.json();
}
async function HM() {
  const e = await Zh(), t = await fetch(`${bd}`, { headers: e });
  if (!t.ok) {
    const n = await t.json().catch(() => ({}));
    throw new Error(n?.error || "Server error");
  }
  return await t.json();
}
async function zpe(e) {
  const t = await Zh(), n = await fetch(`${bd}`, {
    method: "POST",
    headers: t,
    body: JSON.stringify({
      title: e || "New conversation"
    })
  });
  if (!n.ok) {
    const r = await n.json().catch(() => ({}));
    throw new Error(r?.error || "Server error");
  }
  return await n.json();
}
async function Lpe(e, t) {
  if (!e) throw new Error("Missing threadId");
  if (!t || !t.trim()) throw new Error("Title cannot be empty");
  const n = await Zh(), r = await fetch(`${bd}/${e}`, {
    method: "PATCH",
    headers: n,
    body: JSON.stringify({
      title: t.trim()
    })
  });
  if (!r.ok) {
    const i = await r.json().catch(() => ({}));
    throw new Error(i?.error || "Failed to update thread title");
  }
  return await r.json();
}
async function kj(e, t) {
  if (!e) throw new Error("Missing threadId");
  const n = await Zh(), r = new URLSearchParams();
  t?.limit && r.append("limit", t.limit.toString()), t?.cursor && r.append("cursor", t.cursor), t?.direction && r.append("direction", t.direction);
  const i = `${bd}/${e}/messages${r.toString() ? `?${r.toString()}` : ""}`, o = await fetch(i, { headers: n });
  if (!o.ok) {
    const s = await o.json().catch(() => ({}));
    throw new Error(s?.error || "Failed to fetch messages");
  }
  return await o.json();
}
const ei = [];
for (let e = 0; e < 256; ++e)
  ei.push((e + 256).toString(16).slice(1));
function Bpe(e, t = 0) {
  return (ei[e[t + 0]] + ei[e[t + 1]] + ei[e[t + 2]] + ei[e[t + 3]] + "-" + ei[e[t + 4]] + ei[e[t + 5]] + "-" + ei[e[t + 6]] + ei[e[t + 7]] + "-" + ei[e[t + 8]] + ei[e[t + 9]] + "-" + ei[e[t + 10]] + ei[e[t + 11]] + ei[e[t + 12]] + ei[e[t + 13]] + ei[e[t + 14]] + ei[e[t + 15]]).toLowerCase();
}
let xC;
const $pe = new Uint8Array(16);
function Upe() {
  if (!xC) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    xC = crypto.getRandomValues.bind(crypto);
  }
  return xC($pe);
}
const Fpe = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Cj = { randomUUID: Fpe };
function Vpe(e, t, n) {
  e = e || {};
  const r = e.random ?? e.rng?.() ?? Upe();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Bpe(r);
}
function BF(e, t, n) {
  return Cj.randomUUID && !e ? Cj.randomUUID() : Vpe(e);
}
function Hpe() {
  return `temp-${BF()}`;
}
function ld(e) {
  return e.startsWith("temp-");
}
function Wpe(e) {
  if (!ld(e))
    throw new Error(`Invalid temporary thread ID: ${e}`);
  return e.substring(5);
}
function qpe({ open: e, onConfirm: t, onCancel: n }) {
  return /* @__PURE__ */ v.jsx(Hh, { open: e, onOpenChange: n, children: /* @__PURE__ */ v.jsxs(Wh, { className: "max-w-md", children: [
    /* @__PURE__ */ v.jsxs(ny, { children: [
      /* @__PURE__ */ v.jsx(qh, { children: "Delete Conversation" }),
      /* @__PURE__ */ v.jsx("p", { className: "text-xs italic text-muted-foreground mt-1", children: "Are you sure you want to delete this conversation? This action is irreversible and you will not be able to recover the deleted messages." })
    ] }),
    /* @__PURE__ */ v.jsxs(e9, { children: [
      /* @__PURE__ */ v.jsx(qt, { variant: "outline", onClick: n, type: "button", className: "cursor-pointer", children: "Cancel" }),
      /* @__PURE__ */ v.jsx(qt, { variant: "destructive", onClick: t, type: "button", className: "cursor-pointer", children: "Delete Conversation" })
    ] })
  ] }) });
}
const $F = ({
  message: e = "Loading..."
}) => /* @__PURE__ */ v.jsx("div", { className: "flex items-center justify-center h-full m-auto p-4", children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col items-center gap-3", children: [
  /* @__PURE__ */ v.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-primary" }),
  /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground", children: e })
] }) }), UF = ({
  id: e,
  name: t,
  versionId: n,
  classUri: r,
  copyContent: i,
  onIsolate: o,
  onReset: s,
  onCopy: a,
  position: c = "absolute",
  buttonSize: u = "md"
}) => {
  const f = u === "sm" ? "w-3 h-3" : "w-3.5 h-3.5", h = c === "absolute" ? "absolute -top-7 left-0 inline-flex items-center gap-2 bg-popover border rounded-md shadow-lg px-1.5 py-1 z-50 cursor-pointer whitespace-nowrap" : "inline-flex items-center gap-1 ml-1", m = (x) => {
    if (x.preventDefault(), x.stopPropagation(), o)
      o();
    else {
      const w = new CustomEvent("entity-isolate", {
        detail: { id: e, name: t, classUri: r, versionId: n }
      });
      window.dispatchEvent(w), Vt.success(`Isolated ${t}`);
    }
  }, g = (x) => {
    if (x.preventDefault(), x.stopPropagation(), s)
      s();
    else {
      const w = new CustomEvent("entity-reset-visibility", {
        detail: { id: e, name: t }
      });
      window.dispatchEvent(w), Vt.success("Reset visibility");
    }
  }, b = (x) => {
    if (x.preventDefault(), x.stopPropagation(), a)
      a();
    else {
      const w = i || e;
      navigator.clipboard.writeText(w).then(() => {
        Vt.success("Copied");
      }).catch(() => {
        Vt.error("Failed to copy");
      });
    }
  };
  return /* @__PURE__ */ v.jsxs("span", { className: h, children: [
    /* @__PURE__ */ v.jsx(
      "button",
      {
        onClick: m,
        onMouseDown: (x) => x.preventDefault(),
        className: "p-0.5 hover:bg-blue-500/20 rounded transition-colors text-foreground",
        title: "Isolate",
        children: /* @__PURE__ */ v.jsx(uA, { className: f })
      }
    ),
    /* @__PURE__ */ v.jsx(
      "button",
      {
        onClick: g,
        onMouseDown: (x) => x.preventDefault(),
        className: "p-0.5 hover:bg-blue-500/20 rounded transition-colors text-foreground",
        title: "Reset visibility",
        children: /* @__PURE__ */ v.jsx(fA, { className: f })
      }
    ),
    /* @__PURE__ */ v.jsx(
      "button",
      {
        onClick: b,
        onMouseDown: (x) => x.preventDefault(),
        className: "p-0.5 hover:bg-blue-500/20 rounded transition-colors text-foreground",
        title: "Copy",
        children: /* @__PURE__ */ v.jsx(Ac, { className: f })
      }
    )
  ] });
}, Ej = ({ entity: e, onClick: t, exists: n = !0, onlyText: r = !1 }) => {
  const [i, o] = C.useState(!1), s = () => {
    const h = [
      `Name: ${e.name}`,
      e.id ? `Element ID: ${e.id}` : null,
      e.versionId ? `Version ID: ${e.versionId}` : null,
      e.classUri ? `Class: ${e.classUri}` : null
    ].filter(Boolean).join(`
`);
    navigator.clipboard.writeText(h).then(() => {
      Vt.success("Copied entity info");
    }).catch(() => {
      Vt.error("Failed to copy");
    });
  }, a = () => {
    if (!n) {
      s();
      return;
    }
    if (!n) return;
    const h = new CustomEvent("entity-zoom-select", {
      detail: { id: e.id, name: e.name, classUri: e.classUri, versionId: e.versionId }
    });
    window.dispatchEvent(h), t && n && t(e);
  }, c = (h) => {
    if (h.preventDefault(), h.stopPropagation(), !e.id || !n) return;
    const m = new CustomEvent("entity-zoom-select", {
      detail: { id: e.id, name: e.name, classUri: e.classUri, versionId: e.versionId }
    });
    window.dispatchEvent(m);
  }, u = () => {
    if (o(!0), !e.id || !n) return;
    const h = new CustomEvent("entity-hover", {
      detail: { id: e.id, name: e.name, classUri: e.classUri, versionId: e.versionId, hover: !0 }
    });
    window.dispatchEvent(h);
  }, f = () => {
    if (o(!1), !e.id || !n) return;
    const h = new CustomEvent("entity-hover", {
      detail: { id: e.id, name: e.name, classUri: e.classUri, versionId: e.versionId, hover: !1 }
    });
    window.dispatchEvent(h);
  };
  return /* @__PURE__ */ v.jsx(Fh, { children: /* @__PURE__ */ v.jsxs(Yi, { delayDuration: 200, children: [
    /* @__PURE__ */ v.jsx(go, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
      "span",
      {
        className: "relative inline-block",
        onMouseEnter: u,
        onMouseLeave: f,
        children: [
          /* @__PURE__ */ v.jsxs(
            Vh,
            {
              variant: "default",
              className: lt(
                // base
                "inline-flex items-center gap-1.5 mx-0.5 h-5 transition-all hover:text-green-500",
                //onlyText mode
                r ? lt(
                  "bg-transparent border-0 shadow-none p-0 transition-colors cursor-pointer",
                  n ? "text-teal-600  hover:underline underline-offset-2" : "text-gray-400"
                ) : [
                  "cursor-pointer  mt-1 rounded-sm shadow-inner text-md font-medium",
                  n ? "bg-teal-900/90 text-white border-teal-600" : "bg-gray-600/50 text-gray-400 border-gray-500"
                ]
              ),
              onClick: a,
              onDoubleClick: c,
              children: [
                !r && /* @__PURE__ */ v.jsx(sY, { className: "w-2 h-2 opacity-90 shrink-0" }),
                /* @__PURE__ */ v.jsx("span", { className: lt("truncate max-w-40", r && "max-w-none"), children: e.name })
              ]
            }
          ),
          i && e.id && n && /* @__PURE__ */ v.jsx(
            UF,
            {
              id: e.id,
              name: e.name,
              versionId: e.versionId,
              classUri: e.classUri,
              position: "absolute",
              buttonSize: "md",
              onCopy: s
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ v.jsx(Vo, { side: "top", sideOffset: 20, className: "max-w-md bg-popover border shadow-lg", children: /* @__PURE__ */ v.jsxs("div", { className: "space-y-2 text-xs p-1", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-semibold text-muted-foreground min-w-20", children: "Name:" }),
        /* @__PURE__ */ v.jsx("span", { className: "text-foreground", children: e.name })
      ] }),
      e.id && /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-semibold text-muted-foreground min-w-20", children: "Element ID:" }),
        /* @__PURE__ */ v.jsx("code", { className: "bg-muted px-1.5 py-0.5 rounded text-xs font-mono break-all text-green-500", children: e.id })
      ] }),
      e.versionId && /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-semibold text-muted-foreground min-w-20", children: "Version ID:" }),
        /* @__PURE__ */ v.jsx("code", { className: "bg-muted px-1.5 py-0.5 rounded text-xs font-mono break-all", children: e.versionId })
      ] }),
      e.classUri && /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-semibold text-muted-foreground min-w-20", children: "Class:" }),
        /* @__PURE__ */ v.jsx("span", { className: "text-foreground", children: e.classUri })
      ] })
    ] }) })
  ] }) });
}, Gpe = ({ uuid: e, onClick: t, exists: n = !0, onlyText: r = !1 }) => {
  const [i, o] = C.useState(!1), s = () => {
    const f = window.getSelection();
    if (f && f.toString().length > 0)
      return;
    if (!n) {
      const m = new CustomEvent("copy-content-by-onclick", {
        detail: { id: e, name: e }
      });
      window.dispatchEvent(m);
      return;
    }
    const h = new CustomEvent("entity-zoom-select", {
      detail: { id: e, name: e }
    });
    window.dispatchEvent(h), t && t(e);
  }, a = (f) => {
    const h = window.getSelection();
    if (h && h.toString().length > 0 || (f.preventDefault(), f.stopPropagation(), !n)) return;
    const m = new CustomEvent("entity-zoom-select", {
      detail: { id: e, name: e }
    });
    window.dispatchEvent(m);
  }, c = () => {
    if (o(!0), !n) return;
    const f = new CustomEvent("entity-hover", {
      detail: { id: e, name: e, hover: !0 }
    });
    window.dispatchEvent(f);
  }, u = () => {
    if (o(!1), !n) return;
    const f = new CustomEvent("entity-hover", {
      detail: { id: e, name: e, hover: !1 }
    });
    window.dispatchEvent(f);
  };
  return /* @__PURE__ */ v.jsx(Fh, { children: /* @__PURE__ */ v.jsxs(Yi, { delayDuration: 200, children: [
    /* @__PURE__ */ v.jsx(go, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
      "span",
      {
        className: "relative inline-block",
        onMouseEnter: c,
        onMouseLeave: u,
        children: [
          /* @__PURE__ */ v.jsxs(
            "span",
            {
              className: lt(
                "cursor-pointer inline-flex items-center gap-1 font-mono text-sm select-text rounded-sm transition-colors bg-accent px-1 mt-1",
                n ? "text-blue-600 hover:text-green-500" : "text-gray-400",
                !r && (n ? "underline decoration-dotted underline-offset-2" : "no-underline")
              ),
              onClick: s,
              onDoubleClick: a,
              children: [
                /* @__PURE__ */ v.jsx(LY, { className: "w-3.5 h-3.5 shrink-0" }),
                /* @__PURE__ */ v.jsx("span", { className: "w-full select-text", children: e })
              ]
            }
          ),
          i && n && /* @__PURE__ */ v.jsx(
            UF,
            {
              id: e,
              name: e,
              copyContent: e
            }
          )
        ]
      }
    ) }),
    n && /* @__PURE__ */ v.jsx(Vo, { side: "top", sideOffset: 20, className: "max-w-md bg-popover border shadow-lg", children: /* @__PURE__ */ v.jsxs("div", { className: "space-y-2 text-xs p-1", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-medium text-muted-foreground min-w-20", children: "UUID:" }),
        /* @__PURE__ */ v.jsx("code", { className: "bg-muted px-1.5 py-0.5 rounded text-xs font-mono break-all", children: /* @__PURE__ */ v.jsx("span", { className: "text-sm text-green-500", children: e }) })
      ] }),
      /* @__PURE__ */ v.jsx("div", { className: "text-muted-foreground text-xs", children: "Double-click to zoom  Hover to highlight" })
    ] }) })
  ] }) });
}, mg = ({ text: e, onEntityClick: t, onlyText: n = !1 }) => {
  const { editorViewerStore: { models: { entities: r } } } = la(), i = r?.value ?? {}, o = (w) => w in i, s = (w) => {
    const S = Object.values(i).find((_) => _?.name === w);
    return S ? {
      name: S.name,
      id: S.id,
      classUri: S.classUri
    } : null;
  }, a = /\[Name:\s*([^,\]]+?)(?:,\s*Element Id:\s*([^:\]]+?))?(?::\s*VersionId:\s*([^\]]+?))?\]/g, c = /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi, u = Object.values(i).map((w) => w?.name).filter(Boolean), f = (w) => w.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), h = u.sort((w, S) => S.length - w.length), m = [];
  let g;
  for (; (g = a.exec(e)) !== null; ) {
    const w = g[1]?.trim() || "Entity", S = g[2]?.trim() || void 0, _ = g[3]?.trim() || void 0;
    m.push({
      index: g.index,
      length: g[0].length,
      type: "entity",
      data: { name: w, id: S, versionId: _ }
    });
  }
  for (; (g = c.exec(e)) !== null; ) {
    const w = g[0];
    m.some(
      (_) => _.type === "entity" && g.index >= _.index && g.index < _.index + _.length
    ) || m.push({
      index: g.index,
      length: g[0].length,
      type: "uuid",
      data: { name: w, id: w }
    });
  }
  for (const w of h) {
    if (!w || w.length < 3) continue;
    const S = new RegExp(`\\b${f(w)}\\b`, "gi");
    let _;
    for (; (_ = S.exec(e)) !== null; )
      if (!m.some(
        (N) => _.index >= N.index && _.index < N.index + N.length
      )) {
        const N = s(w);
        N && m.push({
          index: _.index,
          length: _[0].length,
          type: "name",
          data: N
        });
      }
  }
  m.sort((w, S) => w.index - S.index);
  const b = [];
  let x = 0;
  for (const w of m)
    w.index > x && b.push(e.slice(x, w.index)), b.push({
      type: w.type,
      entity: w.data
    }), x = w.index + w.length;
  return x < e.length && b.push(e.slice(x)), /* @__PURE__ */ v.jsx(v.Fragment, { children: b.map((w, S) => {
    if (typeof w == "string")
      return /* @__PURE__ */ v.jsx("span", { children: w }, S);
    if (w.type === "name")
      return /* @__PURE__ */ v.jsx(
        Ej,
        {
          entity: w.entity,
          onClick: n ? void 0 : t,
          exists: !0,
          onlyText: n
        },
        S
      );
    if (w.type === "uuid") {
      const M = o(w.entity.id);
      return /* @__PURE__ */ v.jsx(
        Gpe,
        {
          uuid: w.entity.id,
          onClick: n ? void 0 : () => t?.(w.entity),
          exists: typeof M == "boolean" ? M : !0,
          onlyText: n
        },
        S
      );
    }
    const _ = w.entity.id ? o(w.entity.id) : !0;
    return /* @__PURE__ */ v.jsx(
      Ej,
      {
        entity: w.entity,
        onClick: n ? void 0 : t,
        exists: typeof _ == "boolean" ? _ : !0,
        onlyText: n
      },
      S
    );
  }) });
}, Kpe = ({
  isOpen: e,
  onThreadSelect: t,
  onNewThread: n,
  className: r
}) => {
  const [i, o] = C.useState(!1), [s, a] = C.useState(null), [c, u] = C.useState(!1), [f, h] = C.useState(null), [m, g] = C.useState(null), [b, x] = C.useState(""), [w, S] = C.useState(""), [_, M] = C.useState(
    /* @__PURE__ */ new Set()
  ), [N, D] = C.useState(
    /* @__PURE__ */ new Set()
  ), [j, O] = C.useState(null), L = C.useRef(null), {
    chatbotStore: {
      storeThreads: U,
      isNewThread: B,
      currentThreadId: G,
      threadMessages: Y,
      isLoadingThread: he
    }
  } = la();
  C.useEffect(() => {
    e && ie();
  }, [e]), C.useEffect(() => {
    const re = U.value.map(
      (be) => String(be?.id ?? "")
    ), J = new Set(re.filter(Boolean)), xe = re.filter(
      (be) => !N.has(be)
    );
    if (xe.length > 0) {
      M(new Set(xe.map(String)));
      const be = setTimeout(() => {
        M(/* @__PURE__ */ new Set());
      }, 400);
      return () => clearTimeout(be);
    }
    (N.size !== J.size || !Array.from(J).every((be) => N.has(be))) && D(J);
  }, [U.value]), C.useEffect(() => {
    m && L.current && setTimeout(() => {
      L.current?.focus();
    }, 0);
  }, [m]);
  const ie = async () => {
    try {
      o(!0);
      const re = await HM(), J = U.value.filter((be) => be.isTemporary);
      let xe = [];
      re.ok ? xe = re.threads : (console.warn("API did not return an array, received:", re), xe = []), U.value = [...J, ...xe];
    } catch {
      U.value = [], Vt.error("Failed to load conversation list, please try again later.");
    } finally {
      o(!1);
    }
  }, ne = (re, J) => {
    J.stopPropagation(), h(re), u(!0);
  }, H = async () => {
    if (f)
      try {
        a(f), await new Promise((re) => setTimeout(re, 300)), await jpe(f), U.value = U.value.filter(
          (re) => re.id !== f
        ), G.value === f && (G.value = "", B.value = !0, O(null)), Y.value = { [f]: [] };
      } catch (re) {
        console.error("Failed to delete thread:", re), Vt.error("Failed to delete conversation");
      } finally {
        u(!1), a(null), h(null), Vt.success("Conversation deleted");
      }
  }, Q = () => {
    u(!1), h(null);
  }, X = () => {
    const re = Hpe();
    O(re), n?.(re), t(re);
  }, Se = async (re) => {
    const J = U.value.find((xe) => xe.id === re);
    if (!J || !J.title) {
      Vt.error("No title to copy");
      return;
    }
    try {
      await navigator.clipboard.writeText(J.title), Vt.success("Title copied to clipboard");
    } catch (xe) {
      console.error("Failed to copy title:", xe), Vt.error("Failed to copy title");
    }
  }, W = (re) => {
    const J = U.value.find((xe) => xe.id === re);
    if (J) {
      const xe = J.title || "";
      g(re), x(xe), S(xe);
    }
  }, Z = async (re) => {
    const J = b.trim();
    if (!J) {
      Vt.error("Title cannot be empty"), pe();
      return;
    }
    if (J === w.trim()) {
      pe();
      return;
    }
    try {
      await Lpe(re, J);
      const xe = U.value.map(
        (be) => be.id === re ? { ...be, title: J } : be
      );
      U.value = xe, g(null), x(""), S(""), Vt.success("Conversation renamed successfully");
    } catch (xe) {
      console.error("Failed to rename thread:", xe), Vt.error("Failed to rename conversation");
    }
  }, pe = () => {
    g(null), x(""), S("");
  }, F = (re) => {
    const J = new Date(re), xe = /* @__PURE__ */ new Date(), be = new Date(xe.getFullYear(), xe.getMonth(), xe.getDate()), Ae = new Date(
      J.getFullYear(),
      J.getMonth(),
      J.getDate()
    ), nt = new Date(be);
    nt.setDate(nt.getDate() - 1);
    const Ge = be.getTime() - Ae.getTime(), rt = Math.floor(Ge / (1e3 * 60 * 60 * 24));
    return rt === 0 ? "Today" : rt === 1 ? "Yesterday" : rt < 7 ? "Last 7 days" : rt < 30 ? "Last 30 days" : "Older";
  }, ee = (re) => {
    const J = {
      Today: [],
      Yesterday: [],
      "Last 7 days": [],
      "Last 30 days": [],
      Older: []
    };
    return re.forEach((xe) => {
      const be = F(xe.updatedAt);
      J[be].push(xe);
    }), J;
  }, ge = C.useMemo(() => {
    const re = U.value;
    return window.addThreadToSidebar = re, ee(re);
  }, [U.value, B.value, i]);
  return e ? /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
    /* @__PURE__ */ v.jsx(
      qpe,
      {
        open: c,
        onConfirm: H,
        onCancel: Q
      }
    ),
    /* @__PURE__ */ v.jsx(Fh, { delayDuration: 50, children: /* @__PURE__ */ v.jsxs(
      "div",
      {
        className: lt(
          " h-full flex flex-col bg-background border-r border-border",
          r
        ),
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "w-full p-4 border-b border-border shrink-0", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-2 flex-wrap", children: [
              /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ v.jsx(FP, { className: "h-5 w-5 text-blue-500" }),
                /* @__PURE__ */ v.jsx("h3", { className: "font-semibold text-foreground", children: "Conversations" })
              ] }),
              /* @__PURE__ */ v.jsxs(Yi, { children: [
                /* @__PURE__ */ v.jsx(go, { asChild: !0, children: /* @__PURE__ */ v.jsx(
                  qt,
                  {
                    variant: "ghost",
                    size: "icon",
                    className: "h-4 w-4 p-1 text-revert transition-colors hover:bg-blue-100 hover:text-blue-600 dark:hover:bg-blue-950/20 cursor-pointer",
                    onClick: X,
                    disabled: i,
                    "aria-label": "Create new conversation",
                    children: /* @__PURE__ */ v.jsx(cX, { className: "h-4 w-4" })
                  }
                ) }),
                /* @__PURE__ */ v.jsx(Vo, { children: "Create new conversation" })
              ] })
            ] }),
            /* @__PURE__ */ v.jsxs("p", { className: "text-sm text-muted-foreground mt-1", children: [
              U.value.length,
              " saved conversations"
            ] })
          ] }),
          /* @__PURE__ */ v.jsx("div", { className: "flex-1 w-full min-h-0", children: /* @__PURE__ */ v.jsx(yA, { className: "h-full w-full", children: i ? /* @__PURE__ */ v.jsx($F, { message: "Loading conversations..." }) : U.value.length === 0 ? /* @__PURE__ */ v.jsxs("div", { className: "p-4 text-center text-muted-foreground", children: [
            /* @__PURE__ */ v.jsx(FP, { className: "h-12 w-12 mx-auto mb-2 opacity-50" }),
            /* @__PURE__ */ v.jsx("p", { children: "No conversations yet" }),
            /* @__PURE__ */ v.jsx("p", { className: "text-xs mt-1", children: "Start chatting to create your first conversation" })
          ] }) : /* @__PURE__ */ v.jsx("div", { className: "w-full px-2 py-1 ", children: Object.entries(ge).map(
            ([re, J]) => J.length === 0 ? null : /* @__PURE__ */ v.jsxs("div", { className: "mb-4 w-full ", children: [
              /* @__PURE__ */ v.jsx("h5", { className: "text-xs font-semibold text-muted-foreground px-3 py-2 uppercase tracking-wide", children: re }),
              J.map((xe) => /* @__PURE__ */ v.jsx(
                "div",
                {
                  className: lt(
                    "group relative w-full p-2 rounded-lg cursor-pointer transition-all duration-300 ",
                    "hover:bg-blue-50/80 hover:shadow-sm ",
                    "dark:hover:bg-blue-950/30",
                    j === xe.id || G.value === xe.id ? "bg-blue-50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800 shadow-sm" : "border border-transparent",
                    s === xe.id && "animate-slideOutLeft opacity-0 scale-95",
                    _.has(xe.id) && "animate-slideInLeft"
                  ),
                  onClick: () => {
                    O(xe.id), t(xe.id);
                  },
                  children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-start justify-between gap-2 w-full min-w-0", children: [
                    /* @__PURE__ */ v.jsx(
                      "div",
                      {
                        className: "flex-1 min-w-0 overflow-visible p-0",
                        onDoubleClick: (be) => {
                          be.stopPropagation(), he.value || W(xe.id);
                        },
                        children: /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-2 mb-1 w-full ", children: m === xe.id ? /* @__PURE__ */ v.jsx(
                          EM,
                          {
                            ref: L,
                            type: "text",
                            value: b,
                            onChange: (be) => x(be.target.value),
                            onBlur: () => {
                              Z(xe.id);
                            },
                            onKeyDown: (be) => {
                              be.key === "Enter" ? (be.preventDefault(), Z(xe.id)) : be.key === "Escape" && (be.preventDefault(), pe());
                            },
                            onClick: (be) => be.stopPropagation(),
                            className: "h-9 text-sm font-semibold px-2 py-1 border-blue-400 focus:border-blue-500 focus:ring-blue-500 dark:border-blue-600 dark:focus:border-blue-500",
                            autoFocus: !0
                          }
                        ) : (
                          // Thread title
                          /* @__PURE__ */ v.jsx("div", { className: "text-ellipsis text-sm text-foreground break-all cursor-pointer w-full hover:bg-inherit dark:hover:bg-neutral-800/50 rounded transition-colors", children: /* @__PURE__ */ v.jsx(mg, { text: xe.title || "New conversation", onlyText: !0 }) })
                        ) })
                      }
                    ),
                    /* @__PURE__ */ v.jsxs(od, { children: [
                      /* @__PURE__ */ v.jsx(sd, { asChild: !0, children: /* @__PURE__ */ v.jsx(
                        qt,
                        {
                          variant: "ghost",
                          size: "icon",
                          className: lt(
                            "h-6 w-6 shrink-0 opacity-0 group-hover:opacity-100 transition-opacity",
                            "hover:bg-neutral-200 dark:hover:bg-neutral-700"
                          ),
                          onClick: (be) => be.stopPropagation(),
                          children: /* @__PURE__ */ v.jsx(kY, { className: "h-4 w-4" })
                        }
                      ) }),
                      /* @__PURE__ */ v.jsxs(
                        ad,
                        {
                          align: "end",
                          className: "w-48",
                          children: [
                            /* @__PURE__ */ v.jsxs(
                              hs,
                              {
                                onClick: (be) => {
                                  be.stopPropagation(), Se(xe.id);
                                },
                                className: "cursor-pointer",
                                children: [
                                  /* @__PURE__ */ v.jsx(Ac, { className: "h-4 w-4 mr-2" }),
                                  "Copy conversation"
                                ]
                              }
                            ),
                            /* @__PURE__ */ v.jsxs(
                              hs,
                              {
                                onClick: (be) => {
                                  be.stopPropagation(), W(xe.id);
                                },
                                className: "cursor-pointer",
                                children: [
                                  /* @__PURE__ */ v.jsx(TX, { className: "h-4 w-4 mr-2" }),
                                  "Rename"
                                ]
                              }
                            ),
                            /* @__PURE__ */ v.jsxs(
                              hs,
                              {
                                onClick: (be) => {
                                  be.stopPropagation(), ne(xe.id, be);
                                },
                                className: "cursor-pointer text-red-600 focus:text-red-600 dark:text-red-400 dark:focus:text-red-400",
                                disabled: s === xe.id,
                                children: [
                                  /* @__PURE__ */ v.jsx(k4, { className: "h-4 w-4 mr-2" }),
                                  "Delete"
                                ]
                              }
                            )
                          ]
                        }
                      )
                    ] })
                  ] })
                },
                xe.id
              ))
            ] }, re)
          ) }) }) })
        ]
      }
    ) })
  ] }) : null;
}, Zpe = (e) => {
  const { setMessages: t } = e, {
    chatbotStore: {
      fetchMessagesForThread: n,
      threadMessages: r,
      setTempThread: i,
      isLoadingThread: o,
      // loadThreadList,
      isNewThread: s,
      currentThreadId: a
    },
    chatbotThreadStore: { threadMentions: c }
  } = la();
  return {
    handleThreadSelect: async (h) => {
      if (a.value !== h)
        try {
          if (c.value = {}, e.stop?.(), a.value = h, Object.prototype.hasOwnProperty.call(
            r.value,
            h
          )) {
            s.value = ld(h), o.value = !1, t(r.value[h] || []);
            return;
          }
          t([]), o.value = !0, await n(h);
          const g = r.value[h] || [];
          t(g);
        } catch (m) {
          console.error("Failed to select thread:", m), Vt.error("Failed to load conversation");
        }
    },
    handleNewThread: (h) => {
      ld(h) && (i(h), c.value = {});
    }
  };
};
class Ype {
  steps = [];
  currentThreadId = null;
  displaySteps = Qe([]);
  isEnabled = Qe(!0);
  // Control flag to enable/disable logging
  // Store steps history for each message
  messageStepsHistory = /* @__PURE__ */ new Map();
  currentMessageId = null;
  maxMessageHistory = 50;
  startLogging(t, n) {
    this.currentThreadId = t, this.currentMessageId = n || `msg-${Date.now()}`, this.steps = [], this.displaySteps.value = [], this.log("start", { threadId: t, messageId: this.currentMessageId });
  }
  log(t, n) {
    if (!this.isEnabled.value) return;
    if (t === "chunk") {
      this.updateDisplaySteps(t, n);
      return;
    }
    const r = {
      timestamp: Date.now(),
      type: t,
      data: n
    };
    this.steps.push(r), console.log(
      `${{
        start: "",
        planning: "",
        tool_call: "",
        tool_result: "",
        chunk: "",
        finish: "",
        error: ""
      }[t]} [AI Step - ${t.toUpperCase()}]`,
      n
    ), this.updateDisplaySteps(t, n);
  }
  updateDisplaySteps(t, n) {
    const r = [...this.displaySteps.value];
    switch (t) {
      case "start":
        this.displaySteps.value = [{
          id: `step-${Date.now()}`,
          type: "processing",
          message: "Starting AI processing...",
          timestamp: Date.now()
        }];
        break;
      case "planning":
        r.push({
          id: `step-${Date.now()}`,
          type: "processing",
          message: " Planning strategy...",
          details: n.strategy || n.message,
          timestamp: Date.now()
        }), this.displaySteps.value = r;
        break;
      case "tool_call":
        const o = {
          read_file: " Reading file",
          write_file: " Writing file",
          grep_search: " Searching code",
          semantic_search: " Semantic search",
          replace_string_in_file: " Editing file",
          run_in_terminal: " Running command",
          file_search: " Finding files",
          get_errors: " Checking errors",
          list_dir: " Listing directory"
        }[n.toolName] || ` ${n.toolName}`, s = n.args?.filePath || n.args?.query || n.args?.command || (n.args ? Object.keys(n.args).join(", ") : "");
        r.push({
          id: `step-${Date.now()}`,
          type: "tool_call",
          message: o,
          details: s ? String(s).substring(0, 60) : void 0,
          timestamp: Date.now()
        }), this.displaySteps.value = r;
        break;
      case "tool_result":
        for (let c = r.length - 1; c >= 0; c--)
          if (r[c].type === "tool_call") {
            r[c] = {
              ...r[c],
              type: "complete"
            };
            break;
          }
        this.displaySteps.value = r;
        break;
      case "chunk":
        const a = r.findIndex((c) => c.type === "processing");
        a !== -1 && (r[a] = {
          ...r[a],
          message: "Generating response...",
          details: n.content ? n.content.substring(0, 50) + "..." : void 0
        }, this.displaySteps.value = r);
        break;
      case "finish":
        r.push({
          id: `step-${Date.now()}`,
          type: "complete",
          message: "Response completed",
          details: n.usage ? `Tokens: ${n.usage.totalTokens || "N/A"}` : void 0,
          timestamp: Date.now()
        }), this.displaySteps.value = r, this.currentMessageId && (this.messageStepsHistory.set(this.currentMessageId, [...r]), this.pruneMessageHistory()), setTimeout(() => {
          this.displaySteps.value = [];
        }, 3e3);
        break;
      case "error":
        r.push({
          id: `step-${Date.now()}`,
          type: "error",
          message: "Error occurred",
          details: n.message,
          timestamp: Date.now()
        }), this.displaySteps.value = r;
        break;
    }
  }
  getSteps() {
    return this.steps;
  }
  exportSteps() {
    return {
      threadId: this.currentThreadId,
      steps: this.steps,
      duration: this.steps.length > 0 ? this.steps[this.steps.length - 1].timestamp - this.steps[0].timestamp : 0
    };
  }
  clear() {
    this.steps = [], this.currentThreadId = null, this.displaySteps.value = [];
  }
  // Methods to enable/disable the UI logger
  enable() {
    this.isEnabled.value = !0;
  }
  disable() {
    this.isEnabled.value = !1, this.displaySteps.value = [];
  }
  toggle() {
    this.isEnabled.value = !this.isEnabled.value, this.isEnabled.value || (this.displaySteps.value = []);
  }
  // Log planning/strategy step
  logPlanning(t) {
    this.log("planning", { strategy: t });
  }
  // Log with custom message
  logCustomStep(t, n) {
    const r = [...this.displaySteps.value];
    r.push({
      id: `step-${Date.now()}`,
      type: "processing",
      message: t,
      details: n,
      timestamp: Date.now()
    }), this.displaySteps.value = r;
  }
  // Get steps history for a specific message
  getMessageSteps(t) {
    return this.messageStepsHistory.get(t);
  }
  // Get all steps history
  getAllMessageSteps() {
    return this.messageStepsHistory;
  }
  // Format steps as text for display
  formatStepsAsText(t) {
    const n = this.messageStepsHistory.get(t);
    return !n || n.length === 0 ? "" : n.filter((r) => r.type !== "processing").map((r) => `${r.type === "complete" ? "" : r.type === "error" ? "" : ""} ${r.message}${r.details ? ` (${r.details})` : ""}`).join(`
`);
  }
  // Clear specific message history
  clearMessageHistory(t) {
    this.messageStepsHistory.delete(t);
  }
  // Clear all history
  clearAllHistory() {
    this.messageStepsHistory.clear();
  }
  pruneMessageHistory() {
    for (; this.messageStepsHistory.size > this.maxMessageHistory; ) {
      const t = this.messageStepsHistory.keys().next().value;
      if (!t) break;
      this.messageStepsHistory.delete(t);
    }
  }
}
const Ha = new Ype(), Xpe = (e) => {
  let t = !1;
  return {
    onStart: (n) => {
      t = !1, Ha.startLogging(e, n);
    },
    onToolCall: (n) => {
      t || (Ha.startLogging(e, n.toolCallId), t = !0), Ha.log("tool_call", {
        toolCallId: n.toolCallId,
        toolName: n.toolName,
        args: n.args
      });
    },
    onChunk: (n) => {
      !t && n?.delta?.content && (Ha.startLogging(e), t = !0), n?.delta?.content && Ha.log("chunk", {
        content: n.delta.content,
        role: n.delta.role
      });
    },
    onFinish: (n) => {
      Ha.log("finish", {
        messageId: n.id,
        finishReason: n.finishReason,
        usage: n.usage,
        toolCalls: n.toolCalls?.length || 0
      });
      const r = Ha.exportSteps();
      console.log(" AI Execution Summary:", r), t = !1;
    },
    onError: (n) => {
      Ha.log("error", {
        message: n.message,
        stack: n.stack
      }), t = !1;
    }
  };
}, Jpe = (e, t, n, r) => {
  const i = C.useRef(null), o = C.useRef(null), s = C.useRef(null), a = C.useRef(null), c = C.useCallback((u = !0) => {
    requestAnimationFrame(() => {
      const f = i.current?.querySelector("[data-radix-scroll-area-viewport]");
      f && f.scrollTo({
        top: f.scrollHeight,
        behavior: u ? "smooth" : "auto"
      });
    });
  }, []);
  return C.useEffect(() => {
    if (!n || !r || !s.current) return;
    a.current && a.current.disconnect();
    const u = i.current?.querySelector("[data-radix-scroll-area-viewport]");
    return a.current = new IntersectionObserver(
      (f) => {
        f[0].isIntersecting && n();
      },
      {
        root: u,
        rootMargin: "100px",
        threshold: 0.1
      }
    ), a.current.observe(s.current), () => a.current?.disconnect();
  }, [n, r]), C.useEffect(() => {
    e.length > 0 && !t && c(!1);
  }, [e.length, t, c]), {
    scrollAreaRef: i,
    containerRef: o,
    topSentinelRef: s,
    scrollToBottom: c
  };
};
var H0 = { exports: {} }, Qpe = H0.exports, _j;
function eme() {
  return _j || (_j = 1, (function(e, t) {
    ((n, r) => {
      e.exports = r();
    })(Qpe, function() {
      var n = function(k, A) {
        return (n = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? function(R, P) {
          R.__proto__ = P;
        } : function(R, P) {
          for (var z in P) Object.prototype.hasOwnProperty.call(P, z) && (R[z] = P[z]);
        }))(k, A);
      }, r = function() {
        return (r = Object.assign || function(k) {
          for (var A, R = 1, P = arguments.length; R < P; R++) for (var z in A = arguments[R]) Object.prototype.hasOwnProperty.call(A, z) && (k[z] = A[z]);
          return k;
        }).apply(this, arguments);
      };
      function i(k, A, R) {
        for (var P, z = 0, $ = A.length; z < $; z++) !P && z in A || ((P = P || Array.prototype.slice.call(A, 0, z))[z] = A[z]);
        return k.concat(P || Array.prototype.slice.call(A));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : xZ, s = Object.keys, a = Array.isArray;
      function c(k, A) {
        return typeof A == "object" && s(A).forEach(function(R) {
          k[R] = A[R];
        }), k;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var u = Object.getPrototypeOf, f = {}.hasOwnProperty;
      function h(k, A) {
        return f.call(k, A);
      }
      function m(k, A) {
        typeof A == "function" && (A = A(u(k))), (typeof Reflect > "u" ? s : Reflect.ownKeys)(A).forEach(function(R) {
          b(k, R, A[R]);
        });
      }
      var g = Object.defineProperty;
      function b(k, A, R, P) {
        g(k, A, c(R && h(R, "get") && typeof R.get == "function" ? { get: R.get, set: R.set, configurable: !0 } : { value: R, configurable: !0, writable: !0 }, P));
      }
      function x(k) {
        return { from: function(A) {
          return k.prototype = Object.create(A.prototype), b(k.prototype, "constructor", k), { extend: m.bind(null, k.prototype) };
        } };
      }
      var w = Object.getOwnPropertyDescriptor, S = [].slice;
      function _(k, A, R) {
        return S.call(k, A, R);
      }
      function M(k, A) {
        return A(k);
      }
      function N(k) {
        if (!k) throw new Error("Assertion Failed");
      }
      function D(k) {
        o.setImmediate ? setImmediate(k) : setTimeout(k, 0);
      }
      function j(k, A) {
        if (typeof A == "string" && h(k, A)) return k[A];
        if (!A) return k;
        if (typeof A != "string") {
          for (var R = [], P = 0, z = A.length; P < z; ++P) {
            var $ = j(k, A[P]);
            R.push($);
          }
          return R;
        }
        var q, K = A.indexOf(".");
        return K === -1 || (q = k[A.substr(0, K)]) == null ? void 0 : j(q, A.substr(K + 1));
      }
      function O(k, A, R) {
        if (k && A !== void 0 && !("isFrozen" in Object && Object.isFrozen(k))) if (typeof A != "string" && "length" in A) {
          N(typeof R != "string" && "length" in R);
          for (var P = 0, z = A.length; P < z; ++P) O(k, A[P], R[P]);
        } else {
          var $, q, K = A.indexOf(".");
          K !== -1 ? ($ = A.substr(0, K), (K = A.substr(K + 1)) === "" ? R === void 0 ? a(k) && !isNaN(parseInt($)) ? k.splice($, 1) : delete k[$] : k[$] = R : O(q = (q = k[$]) && h(k, $) ? q : k[$] = {}, K, R)) : R === void 0 ? a(k) && !isNaN(parseInt(A)) ? k.splice(A, 1) : delete k[A] : k[A] = R;
        }
      }
      function L(k) {
        var A, R = {};
        for (A in k) h(k, A) && (R[A] = k[A]);
        return R;
      }
      var U = [].concat;
      function B(k) {
        return U.apply([], k);
      }
      var pe = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(B([8, 16, 32, 64].map(function(k) {
        return ["Int", "Uint", "Float"].map(function(A) {
          return A + k + "Array";
        });
      }))).filter(function(k) {
        return o[k];
      }), G = new Set(pe.map(function(k) {
        return o[k];
      })), Y = null;
      function he(k) {
        return Y = /* @__PURE__ */ new WeakMap(), k = (function A(R) {
          if (!R || typeof R != "object") return R;
          var P = Y.get(R);
          if (P) return P;
          if (a(R)) {
            P = [], Y.set(R, P);
            for (var z = 0, $ = R.length; z < $; ++z) P.push(A(R[z]));
          } else if (G.has(R.constructor)) P = R;
          else {
            var q, K = u(R);
            for (q in P = K === Object.prototype ? {} : Object.create(K), Y.set(R, P), R) h(R, q) && (P[q] = A(R[q]));
          }
          return P;
        })(k), Y = null, k;
      }
      var ie = {}.toString;
      function ne(k) {
        return ie.call(k).slice(8, -1);
      }
      var H = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Q = typeof H == "symbol" ? function(k) {
        var A;
        return k != null && (A = k[H]) && A.apply(k);
      } : function() {
        return null;
      };
      function X(k, A) {
        A = k.indexOf(A), 0 <= A && k.splice(A, 1);
      }
      var Se = {};
      function W(k) {
        var A, R, P, z;
        if (arguments.length === 1) {
          if (a(k)) return k.slice();
          if (this === Se && typeof k == "string") return [k];
          if (z = Q(k)) for (R = []; !(P = z.next()).done; ) R.push(P.value);
          else {
            if (k == null) return [k];
            if (typeof (A = k.length) != "number") return [k];
            for (R = new Array(A); A--; ) R[A] = k[A];
          }
        } else for (A = arguments.length, R = new Array(A); A--; ) R[A] = arguments[A];
        return R;
      }
      var Z = typeof Symbol < "u" ? function(k) {
        return k[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, pe = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], ke = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(pe), F = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function ee(k, A) {
        this.name = k, this.message = A;
      }
      function ge(k, A) {
        return k + ". Errors: " + Object.keys(A).map(function(R) {
          return A[R].toString();
        }).filter(function(R, P, z) {
          return z.indexOf(R) === P;
        }).join(`
`);
      }
      function re(k, A, R, P) {
        this.failures = A, this.failedKeys = P, this.successCount = R, this.message = ge(k, A);
      }
      function J(k, A) {
        this.name = "BulkError", this.failures = Object.keys(A).map(function(R) {
          return A[R];
        }), this.failuresByPos = A, this.message = ge(k, this.failures);
      }
      x(ee).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), x(re).from(ee), x(J).from(ee);
      var xe = ke.reduce(function(k, A) {
        return k[A] = A + "Error", k;
      }, {}), be = ee, Ae = ke.reduce(function(k, A) {
        var R = A + "Error";
        function P(z, $) {
          this.name = R, z ? typeof z == "string" ? (this.message = "".concat(z).concat($ ? `
 ` + $ : ""), this.inner = $ || null) : typeof z == "object" && (this.message = "".concat(z.name, " ").concat(z.message), this.inner = z) : (this.message = F[A] || R, this.inner = null);
        }
        return x(P).from(be), k[A] = P, k;
      }, {}), nt = (Ae.Syntax = SyntaxError, Ae.Type = TypeError, Ae.Range = RangeError, pe.reduce(function(k, A) {
        return k[A + "Error"] = Ae[A], k;
      }, {}));
      pe = ke.reduce(function(k, A) {
        return ["Syntax", "Type", "Range"].indexOf(A) === -1 && (k[A + "Error"] = Ae[A]), k;
      }, {});
      function Ge() {
      }
      function rt(k) {
        return k;
      }
      function Tt(k, A) {
        return k == null || k === rt ? A : function(R) {
          return A(k(R));
        };
      }
      function vn(k, A) {
        return function() {
          k.apply(this, arguments), A.apply(this, arguments);
        };
      }
      function kt(k, A) {
        return k === Ge ? A : function() {
          var R = k.apply(this, arguments), P = (R !== void 0 && (arguments[0] = R), this.onsuccess), z = this.onerror, $ = (this.onsuccess = null, this.onerror = null, A.apply(this, arguments));
          return P && (this.onsuccess = this.onsuccess ? vn(P, this.onsuccess) : P), z && (this.onerror = this.onerror ? vn(z, this.onerror) : z), $ !== void 0 ? $ : R;
        };
      }
      function Wt(k, A) {
        return k === Ge ? A : function() {
          k.apply(this, arguments);
          var R = this.onsuccess, P = this.onerror;
          this.onsuccess = this.onerror = null, A.apply(this, arguments), R && (this.onsuccess = this.onsuccess ? vn(R, this.onsuccess) : R), P && (this.onerror = this.onerror ? vn(P, this.onerror) : P);
        };
      }
      function wt(k, A) {
        return k === Ge ? A : function(z) {
          var P = k.apply(this, arguments), z = (c(z, P), this.onsuccess), $ = this.onerror, q = (this.onsuccess = null, this.onerror = null, A.apply(this, arguments));
          return z && (this.onsuccess = this.onsuccess ? vn(z, this.onsuccess) : z), $ && (this.onerror = this.onerror ? vn($, this.onerror) : $), P === void 0 ? q === void 0 ? void 0 : q : c(P, q);
        };
      }
      function Yt(k, A) {
        return k === Ge ? A : function() {
          return A.apply(this, arguments) !== !1 && k.apply(this, arguments);
        };
      }
      function Mn(k, A) {
        return k === Ge ? A : function() {
          var R = k.apply(this, arguments);
          if (R && typeof R.then == "function") {
            for (var P = this, z = arguments.length, $ = new Array(z); z--; ) $[z] = arguments[z];
            return R.then(function() {
              return A.apply(P, $);
            });
          }
          return A.apply(this, arguments);
        };
      }
      pe.ModifyError = re, pe.DexieError = ee, pe.BulkError = J;
      var Rt = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function ln(k) {
        Rt = k;
      }
      var In = {}, Nn = 100, gt = typeof Promise > "u" ? [] : (ke = Promise.resolve(), typeof crypto < "u" && crypto.subtle ? [gt = crypto.subtle.digest("SHA-512", new Uint8Array([0])), u(gt), ke] : [ke, u(ke), ke]), ke = gt[0], wa = gt[1], wa = wa && wa.then, De = ke && ke.constructor, He = !!gt[2], tt = function(k, A) {
        Bi.push([k, A]), Et && (queueMicrotask(Sy), Et = !1);
      }, xt = !0, Et = !0, hn = [], Bt = [], on = rt, jn = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Ge, pgp: !1, env: {}, finalize: Ge }, Ve = jn, Bi = [], Mr = 0, Td = [];
      function Ke(k) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var A = this._PSD = Ve;
        if (typeof k != "function") {
          if (k !== In) throw new TypeError("Not a function");
          this._state = arguments[1], this._value = arguments[2], this._state === !1 && Jo(this, this._value);
        } else this._state = null, this._value = null, ++A.ref, (function R(P, z) {
          try {
            z(function($) {
              if (P._state === null) {
                if ($ === P) throw new TypeError("A promise cannot be resolved with itself.");
                var q = P._lib && Ss();
                $ && typeof $.then == "function" ? R(P, function(K, se) {
                  $ instanceof Ke ? $._then(K, se) : $.then(K, se);
                }) : (P._state = !0, P._value = $, Jc(P)), q && wo();
              }
            }, Jo.bind(null, P));
          } catch ($) {
            Jo(P, $);
          }
        })(this, k);
      }
      var dl = { get: function() {
        var k = Ve, A = tu;
        function R(P, z) {
          var $ = this, q = !k.global && (k !== Ve || A !== tu), K = q && !Ci(), se = new Ke(function(ye, ae) {
            ua($, new Xc(Ad(P, k, q, K), Ad(z, k, q, K), ye, ae, k));
          });
          return this._consoleTask && (se._consoleTask = this._consoleTask), se;
        }
        return R.prototype = In, R;
      }, set: function(k) {
        b(this, "then", k && k.prototype === In ? dl : { get: function() {
          return k;
        }, set: dl.set });
      } };
      function Xc(k, A, R, P, z) {
        this.onFulfilled = typeof k == "function" ? k : null, this.onRejected = typeof A == "function" ? A : null, this.resolve = R, this.reject = P, this.psd = z;
      }
      function Jo(k, A) {
        var R, P;
        Bt.push(A), k._state === null && (R = k._lib && Ss(), A = on(A), k._state = !1, k._value = A, P = k, hn.some(function(z) {
          return z._value === P._value;
        }) || hn.push(P), Jc(k), R) && wo();
      }
      function Jc(k) {
        var A = k._listeners;
        k._listeners = [];
        for (var R = 0, P = A.length; R < P; ++R) ua(k, A[R]);
        var z = k._PSD;
        --z.ref || z.finalize(), Mr === 0 && (++Mr, tt(function() {
          --Mr == 0 && rp();
        }, []));
      }
      function ua(k, A) {
        if (k._state === null) k._listeners.push(A);
        else {
          var R = k._state ? A.onFulfilled : A.onRejected;
          if (R === null) return (k._state ? A.resolve : A.reject)(k._value);
          ++A.psd.ref, ++Mr, tt(T1, [R, k, A]);
        }
      }
      function T1(k, A, R) {
        try {
          var P, z = A._value;
          !A._state && Bt.length && (Bt = []), P = Rt && A._consoleTask ? A._consoleTask.run(function() {
            return k(z);
          }) : k(z), A._state || Bt.indexOf(z) !== -1 || (($) => {
            for (var q = hn.length; q; ) if (hn[--q]._value === $._value) return hn.splice(q, 1);
          })(A), R.resolve(P);
        } catch ($) {
          R.reject($);
        } finally {
          --Mr == 0 && rp(), --R.psd.ref || R.psd.finalize();
        }
      }
      function Sy() {
        eo(jn, function() {
          Ss() && wo();
        });
      }
      function Ss() {
        var k = xt;
        return Et = xt = !1, k;
      }
      function wo() {
        var k, A, R;
        do
          for (; 0 < Bi.length; ) for (k = Bi, Bi = [], R = k.length, A = 0; A < R; ++A) {
            var P = k[A];
            P[0].apply(null, P[1]);
          }
        while (0 < Bi.length);
        Et = xt = !0;
      }
      function rp() {
        for (var k = hn, A = (hn = [], k.forEach(function(P) {
          P._PSD.onunhandled.call(null, P._value, P);
        }), Td.slice(0)), R = A.length; R; ) A[--R]();
      }
      function Qc(k) {
        return new Ke(In, !1, k);
      }
      function Cn(k, A) {
        var R = Ve;
        return function() {
          var P = Ss(), z = Ve;
          try {
            return Cs(R, !0), k.apply(this, arguments);
          } catch ($) {
            A && A($);
          } finally {
            Cs(z, !1), P && wo();
          }
        };
      }
      m(Ke.prototype, { then: dl, _then: function(k, A) {
        ua(this, new Xc(null, null, k, A, Ve));
      }, catch: function(k) {
        var A, R;
        return arguments.length === 1 ? this.then(null, k) : (A = k, R = arguments[1], typeof A == "function" ? this.then(null, function(P) {
          return (P instanceof A ? R : Qc)(P);
        }) : this.then(null, function(P) {
          return (P && P.name === A ? R : Qc)(P);
        }));
      }, finally: function(k) {
        return this.then(function(A) {
          return Ke.resolve(k()).then(function() {
            return A;
          });
        }, function(A) {
          return Ke.resolve(k()).then(function() {
            return Qc(A);
          });
        });
      }, timeout: function(k, A) {
        var R = this;
        return k < 1 / 0 ? new Ke(function(P, z) {
          var $ = setTimeout(function() {
            return z(new Ae.Timeout(A));
          }, k);
          R.then(P, z).finally(clearTimeout.bind(null, $));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && b(Ke.prototype, Symbol.toStringTag, "Dexie.Promise"), jn.env = op(), m(Ke, { all: function() {
        var k = W.apply(null, arguments).map(hl);
        return new Ke(function(A, R) {
          k.length === 0 && A([]);
          var P = k.length;
          k.forEach(function(z, $) {
            return Ke.resolve(z).then(function(q) {
              k[$] = q, --P || A(k);
            }, R);
          });
        });
      }, resolve: function(k) {
        return k instanceof Ke ? k : k && typeof k.then == "function" ? new Ke(function(A, R) {
          k.then(A, R);
        }) : new Ke(In, !0, k);
      }, reject: Qc, race: function() {
        var k = W.apply(null, arguments).map(hl);
        return new Ke(function(A, R) {
          k.map(function(P) {
            return Ke.resolve(P).then(A, R);
          });
        });
      }, PSD: { get: function() {
        return Ve;
      }, set: function(k) {
        return Ve = k;
      } }, totalEchoes: { get: function() {
        return tu;
      } }, newPSD: Rn, usePSD: eo, scheduler: { get: function() {
        return tt;
      }, set: function(k) {
        tt = k;
      } }, rejectionMapper: { get: function() {
        return on;
      }, set: function(k) {
        on = k;
      } }, follow: function(k, A) {
        return new Ke(function(R, P) {
          return Rn(function(z, $) {
            var q = Ve;
            q.unhandleds = [], q.onunhandled = $, q.finalize = vn(function() {
              var K, se = this;
              K = function() {
                se.unhandleds.length === 0 ? z() : $(se.unhandleds[0]);
              }, Td.push(function ye() {
                K(), Td.splice(Td.indexOf(ye), 1);
              }), ++Mr, tt(function() {
                --Mr == 0 && rp();
              }, []);
            }, q.finalize), k();
          }, A, R, P);
        });
      } }), De && (De.allSettled && b(Ke, "allSettled", function() {
        var k = W.apply(null, arguments).map(hl);
        return new Ke(function(A) {
          k.length === 0 && A([]);
          var R = k.length, P = new Array(R);
          k.forEach(function(z, $) {
            return Ke.resolve(z).then(function(q) {
              return P[$] = { status: "fulfilled", value: q };
            }, function(q) {
              return P[$] = { status: "rejected", reason: q };
            }).then(function() {
              return --R || A(P);
            });
          });
        });
      }), De.any && typeof AggregateError < "u" && b(Ke, "any", function() {
        var k = W.apply(null, arguments).map(hl);
        return new Ke(function(A, R) {
          k.length === 0 && R(new AggregateError([]));
          var P = k.length, z = new Array(P);
          k.forEach(function($, q) {
            return Ke.resolve($).then(function(K) {
              return A(K);
            }, function(K) {
              z[q] = K, --P || R(new AggregateError(z));
            });
          });
        });
      }), De.withResolvers) && (Ke.withResolvers = De.withResolvers);
      var ar = { awaits: 0, echoes: 0, id: 0 }, ip = 0, fl = [], eu = 0, tu = 0, ks = 0;
      function Rn(k, q, R, P) {
        var z = Ve, $ = Object.create(z), q = ($.parent = z, $.ref = 0, $.global = !1, $.id = ++ks, jn.env, $.env = He ? { Promise: Ke, PromiseProp: { value: Ke, configurable: !0, writable: !0 }, all: Ke.all, race: Ke.race, allSettled: Ke.allSettled, any: Ke.any, resolve: Ke.resolve, reject: Ke.reject } : {}, q && c($, q), ++z.ref, $.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, eo($, k, R, P));
        return $.ref === 0 && $.finalize(), q;
      }
      function lr() {
        return ar.id || (ar.id = ++ip), ++ar.awaits, ar.echoes += Nn, ar.id;
      }
      function Ci() {
        return !!ar.awaits && (--ar.awaits == 0 && (ar.id = 0), ar.echoes = ar.awaits * Nn, !0);
      }
      function hl(k) {
        return ar.echoes && k && k.constructor === De ? (lr(), k.then(function(A) {
          return Ci(), A;
        }, function(A) {
          return Ci(), bn(A);
        })) : k;
      }
      function A1() {
        var k = fl[fl.length - 1];
        fl.pop(), Cs(k, !1);
      }
      function Cs(k, A) {
        var R, P, z = Ve;
        (A ? !ar.echoes || eu++ && k === Ve : !eu || --eu && k === Ve) || queueMicrotask(A ? (function($) {
          ++tu, ar.echoes && --ar.echoes != 0 || (ar.echoes = ar.awaits = ar.id = 0), fl.push(Ve), Cs($, !0);
        }).bind(null, k) : A1), k !== Ve && (Ve = k, z === jn && (jn.env = op()), He) && (R = jn.env.Promise, P = k.env, z.global || k.global) && (Object.defineProperty(o, "Promise", P.PromiseProp), R.all = P.all, R.race = P.race, R.resolve = P.resolve, R.reject = P.reject, P.allSettled && (R.allSettled = P.allSettled), P.any) && (R.any = P.any);
      }
      function op() {
        var k = o.Promise;
        return He ? { Promise: k, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: k.all, race: k.race, allSettled: k.allSettled, any: k.any, resolve: k.resolve, reject: k.reject } : {};
      }
      function eo(k, A, R, P, z) {
        var $ = Ve;
        try {
          return Cs(k, !0), A(R, P, z);
        } finally {
          Cs($, !1);
        }
      }
      function Ad(k, A, R, P) {
        return typeof k != "function" ? k : function() {
          var z = Ve;
          R && lr(), Cs(A, !0);
          try {
            return k.apply(this, arguments);
          } finally {
            Cs(z, !1), P && queueMicrotask(Ci);
          }
        };
      }
      function Es(k) {
        Promise === De && ar.echoes === 0 ? eu === 0 ? k() : enqueueNativeMicroTask(k) : setTimeout(k, 0);
      }
      ("" + wa).indexOf("[native code]") === -1 && (lr = Ci = Ge);
      var bn = Ke.reject, to = "", ui = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", cr = "String expected.", da = [], nu = "__dbnames", Qo = "readonly", _s = "readwrite";
      function fa(k, A) {
        return k ? A ? function() {
          return k.apply(this, arguments) && A.apply(this, arguments);
        } : k : A;
      }
      var sp = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function ru(k) {
        return typeof k != "string" || /\./.test(k) ? function(A) {
          return A;
        } : function(A) {
          return A[k] === void 0 && k in A && delete (A = he(A))[k], A;
        };
      }
      function ky() {
        throw Ae.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function It(k, A) {
        try {
          var R = iu(k), P = iu(A);
          if (R !== P) return R === "Array" ? 1 : P === "Array" ? -1 : R === "binary" ? 1 : P === "binary" ? -1 : R === "string" ? 1 : P === "string" ? -1 : R === "Date" ? 1 : P !== "Date" ? NaN : -1;
          switch (R) {
            case "number":
            case "Date":
            case "string":
              return A < k ? 1 : k < A ? -1 : 0;
            case "binary":
              for (var z = So(k), $ = So(A), q = z.length, K = $.length, se = q < K ? q : K, ye = 0; ye < se; ++ye) if (z[ye] !== $[ye]) return z[ye] < $[ye] ? -1 : 1;
              return q === K ? 0 : q < K ? -1 : 1;
            case "Array":
              for (var ae = k, oe = A, ue = ae.length, fe = oe.length, le = ue < fe ? ue : fe, ce = 0; ce < le; ++ce) {
                var we = It(ae[ce], oe[ce]);
                if (we !== 0) return we;
              }
              return ue === fe ? 0 : ue < fe ? -1 : 1;
          }
        } catch {
        }
        return NaN;
      }
      function iu(k) {
        var A = typeof k;
        return A == "object" && (ArrayBuffer.isView(k) || (A = ne(k)) === "ArrayBuffer") ? "binary" : A;
      }
      function So(k) {
        return k instanceof Uint8Array ? k : ArrayBuffer.isView(k) ? new Uint8Array(k.buffer, k.byteOffset, k.byteLength) : new Uint8Array(k);
      }
      function Zr(k, A, R) {
        var P = k.schema.yProps;
        return P ? (A && 0 < R.numFailures && (A = A.filter(function(z, $) {
          return !R.failures[$];
        })), Promise.all(P.map(function(z) {
          return z = z.updatesTable, A ? k.db.table(z).where("k").anyOf(A).delete() : k.db.table(z).clear();
        })).then(function() {
          return R;
        })) : R;
      }
      Cy.prototype.execute = function(k) {
        var A = this["@@propmod"];
        if (A.add !== void 0) {
          var R = A.add;
          if (a(R)) return i(i([], a(k) ? k : [], !0), R).sort();
          if (typeof R == "number") return (Number(k) || 0) + R;
          if (typeof R == "bigint") try {
            return BigInt(k) + R;
          } catch {
            return BigInt(0) + R;
          }
          throw new TypeError("Invalid term ".concat(R));
        }
        if (A.remove !== void 0) {
          var P = A.remove;
          if (a(P)) return a(k) ? k.filter(function(z) {
            return !P.includes(z);
          }).sort() : [];
          if (typeof P == "number") return Number(k) - P;
          if (typeof P == "bigint") try {
            return BigInt(k) - P;
          } catch {
            return BigInt(0) - P;
          }
          throw new TypeError("Invalid subtrahend ".concat(P));
        }
        return R = (R = A.replacePrefix) == null ? void 0 : R[0], R && typeof k == "string" && k.startsWith(R) ? A.replacePrefix[1] + k.substring(R.length) : k;
      };
      var pl = Cy;
      function Cy(k) {
        this["@@propmod"] = k;
      }
      function Md(k, A) {
        for (var R = s(A), P = R.length, z = !1, $ = 0; $ < P; ++$) {
          var q = R[$], K = A[q], se = j(k, q);
          K instanceof pl ? (O(k, q, K.execute(se)), z = !0) : se !== K && (O(k, q, K), z = !0);
        }
        return z;
      }
      cn.prototype._trans = function(k, A, R) {
        var P = this._tx || Ve.trans, z = this.name, $ = Rt && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(k === "readonly" ? "read" : "write", " ").concat(this.name));
        function q(ye, ae, oe) {
          if (oe.schema[z]) return A(oe.idbtrans, oe);
          throw new Ae.NotFound("Table " + z + " not part of transaction");
        }
        var K = Ss();
        try {
          var se = P && P.db._novip === this.db._novip ? P === Ve.trans ? P._promise(k, q, R) : Rn(function() {
            return P._promise(k, q, R);
          }, { trans: P, transless: Ve.transless || Ve }) : (function ye(ae, oe, ue, fe) {
            if (ae.idbdb && (ae._state.openComplete || Ve.letThrough || ae._vip)) {
              var le = ae._createTransaction(oe, ue, ae._dbSchema);
              try {
                le.create(), ae._state.PR1398_maxLoop = 3;
              } catch (ce) {
                return ce.name === xe.InvalidState && ae.isOpen() && 0 < --ae._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), ae.close({ disableAutoOpen: !1 }), ae.open().then(function() {
                  return ye(ae, oe, ue, fe);
                })) : bn(ce);
              }
              return le._promise(oe, function(ce, we) {
                return Rn(function() {
                  return Ve.trans = le, fe(ce, we, le);
                });
              }).then(function(ce) {
                if (oe === "readwrite") try {
                  le.idbtrans.commit();
                } catch {
                }
                return oe === "readonly" ? ce : le._completion.then(function() {
                  return ce;
                });
              });
            }
            if (ae._state.openComplete) return bn(new Ae.DatabaseClosed(ae._state.dbOpenError));
            if (!ae._state.isBeingOpened) {
              if (!ae._state.autoOpen) return bn(new Ae.DatabaseClosed());
              ae.open().catch(Ge);
            }
            return ae._state.dbReadyPromise.then(function() {
              return ye(ae, oe, ue, fe);
            });
          })(this.db, k, [this.name], q);
          return $ && (se._consoleTask = $, se = se.catch(function(ye) {
            return console.trace(ye), bn(ye);
          })), se;
        } finally {
          K && wo();
        }
      }, cn.prototype.get = function(k, A) {
        var R = this;
        return k && k.constructor === Object ? this.where(k).first(A) : k == null ? bn(new Ae.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(P) {
          return R.core.get({ trans: P, key: k }).then(function(z) {
            return R.hook.reading.fire(z);
          });
        }).then(A);
      }, cn.prototype.where = function(k) {
        if (typeof k == "string") return new this.db.WhereClause(this, k);
        if (a(k)) return new this.db.WhereClause(this, "[".concat(k.join("+"), "]"));
        var A = s(k);
        if (A.length === 1) return this.where(A[0]).equals(k[A[0]]);
        var R = this.schema.indexes.concat(this.schema.primKey).filter(function(K) {
          if (K.compound && A.every(function(ye) {
            return 0 <= K.keyPath.indexOf(ye);
          })) {
            for (var se = 0; se < A.length; ++se) if (A.indexOf(K.keyPath[se]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(K, se) {
          return K.keyPath.length - se.keyPath.length;
        })[0];
        if (R && this.db._maxKey !== to) return q = R.keyPath.slice(0, A.length), this.where(q).equals(q.map(function(K) {
          return k[K];
        }));
        !R && Rt && console.warn("The query ".concat(JSON.stringify(k), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(A.join("+"), "]"));
        var P = this.schema.idxByName;
        function z(K, se) {
          return It(K, se) === 0;
        }
        var q = A.reduce(function(ae, se) {
          var ye = ae[0], ae = ae[1], oe = P[se], ue = k[se];
          return [ye || oe, ye || !oe ? fa(ae, oe && oe.multi ? function(fe) {
            return fe = j(fe, se), a(fe) && fe.some(function(le) {
              return z(ue, le);
            });
          } : function(fe) {
            return z(ue, j(fe, se));
          }) : ae];
        }, [null, null]), $ = q[0], q = q[1];
        return $ ? this.where($.name).equals(k[$.keyPath]).filter(q) : R ? this.filter(q) : this.where(A).equals("");
      }, cn.prototype.filter = function(k) {
        return this.toCollection().and(k);
      }, cn.prototype.count = function(k) {
        return this.toCollection().count(k);
      }, cn.prototype.offset = function(k) {
        return this.toCollection().offset(k);
      }, cn.prototype.limit = function(k) {
        return this.toCollection().limit(k);
      }, cn.prototype.each = function(k) {
        return this.toCollection().each(k);
      }, cn.prototype.toArray = function(k) {
        return this.toCollection().toArray(k);
      }, cn.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, cn.prototype.orderBy = function(k) {
        return new this.db.Collection(new this.db.WhereClause(this, a(k) ? "[".concat(k.join("+"), "]") : k));
      }, cn.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, cn.prototype.mapToClass = function(k) {
        for (var A = this.db, R = this.name, P = ((this.schema.mappedClass = k).prototype instanceof ky && (k = ((q) => {
          var K = ae, se = q;
          if (typeof se != "function" && se !== null) throw new TypeError("Class extends value " + String(se) + " is not a constructor or null");
          function ye() {
            this.constructor = K;
          }
          function ae() {
            return q !== null && q.apply(this, arguments) || this;
          }
          return n(K, se), K.prototype = se === null ? Object.create(se) : (ye.prototype = se.prototype, new ye()), Object.defineProperty(ae.prototype, "db", { get: function() {
            return A;
          }, enumerable: !1, configurable: !0 }), ae.prototype.table = function() {
            return R;
          }, ae;
        })(k)), /* @__PURE__ */ new Set()), z = k.prototype; z; z = u(z)) Object.getOwnPropertyNames(z).forEach(function(q) {
          return P.add(q);
        });
        function $(q) {
          if (!q) return q;
          var K, se = Object.create(k.prototype);
          for (K in q) if (!P.has(K)) try {
            se[K] = q[K];
          } catch {
          }
          return se;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = $, this.hook("reading", $), k;
      }, cn.prototype.defineClass = function() {
        return this.mapToClass(function(k) {
          c(this, k);
        });
      }, cn.prototype.add = function(k, A) {
        var R = this, P = this.schema.primKey, z = P.auto, $ = P.keyPath, q = k;
        return $ && z && (q = ru($)(k)), this._trans("readwrite", function(K) {
          return R.core.mutate({ trans: K, type: "add", keys: A != null ? [A] : null, values: [q] });
        }).then(function(K) {
          return K.numFailures ? Ke.reject(K.failures[0]) : K.lastResult;
        }).then(function(K) {
          if ($) try {
            O(k, $, K);
          } catch {
          }
          return K;
        });
      }, cn.prototype.upsert = function(k, A) {
        var R = this, P = this.schema.primKey.keyPath;
        return this._trans("readwrite", function(z) {
          return R.core.get({ trans: z, key: k }).then(function($) {
            var q = $ ?? {};
            return Md(q, A), P && O(q, P, k), R.core.mutate({ trans: z, type: "put", values: [q], keys: [k], upsert: !0, updates: { keys: [k], changeSpecs: [A] } }).then(function(K) {
              return K.numFailures ? Ke.reject(K.failures[0]) : !!$;
            });
          });
        });
      }, cn.prototype.update = function(k, A) {
        return typeof k != "object" || a(k) ? this.where(":id").equals(k).modify(A) : (k = j(k, this.schema.primKey.keyPath)) === void 0 ? bn(new Ae.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(k).modify(A);
      }, cn.prototype.put = function(k, A) {
        var R = this, P = this.schema.primKey, z = P.auto, $ = P.keyPath, q = k;
        return $ && z && (q = ru($)(k)), this._trans("readwrite", function(K) {
          return R.core.mutate({ trans: K, type: "put", values: [q], keys: A != null ? [A] : null });
        }).then(function(K) {
          return K.numFailures ? Ke.reject(K.failures[0]) : K.lastResult;
        }).then(function(K) {
          if ($) try {
            O(k, $, K);
          } catch {
          }
          return K;
        });
      }, cn.prototype.delete = function(k) {
        var A = this;
        return this._trans("readwrite", function(R) {
          return A.core.mutate({ trans: R, type: "delete", keys: [k] }).then(function(P) {
            return Zr(A, [k], P);
          }).then(function(P) {
            return P.numFailures ? Ke.reject(P.failures[0]) : void 0;
          });
        });
      }, cn.prototype.clear = function() {
        var k = this;
        return this._trans("readwrite", function(A) {
          return k.core.mutate({ trans: A, type: "deleteRange", range: sp }).then(function(R) {
            return Zr(k, null, R);
          });
        }).then(function(A) {
          return A.numFailures ? Ke.reject(A.failures[0]) : void 0;
        });
      }, cn.prototype.bulkGet = function(k) {
        var A = this;
        return this._trans("readonly", function(R) {
          return A.core.getMany({ keys: k, trans: R }).then(function(P) {
            return P.map(function(z) {
              return A.hook.reading.fire(z);
            });
          });
        });
      }, cn.prototype.bulkAdd = function(k, A, R) {
        var P = this, z = Array.isArray(A) ? A : void 0, $ = (R = R || (z ? void 0 : A)) ? R.allKeys : void 0;
        return this._trans("readwrite", function(q) {
          var K = P.schema.primKey, ye = K.auto, K = K.keyPath;
          if (K && z) throw new Ae.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (z && z.length !== k.length) throw new Ae.InvalidArgument("Arguments objects and keys must have the same length");
          var se = k.length, ye = K && ye ? k.map(ru(K)) : k;
          return P.core.mutate({ trans: q, type: "add", keys: z, values: ye, wantResults: $ }).then(function(ae) {
            var oe = ae.numFailures, ue = ae.failures;
            if (oe === 0) return $ ? ae.results : ae.lastResult;
            throw new J("".concat(P.name, ".bulkAdd(): ").concat(oe, " of ").concat(se, " operations failed"), ue);
          });
        });
      }, cn.prototype.bulkPut = function(k, A, R) {
        var P = this, z = Array.isArray(A) ? A : void 0, $ = (R = R || (z ? void 0 : A)) ? R.allKeys : void 0;
        return this._trans("readwrite", function(q) {
          var K = P.schema.primKey, ye = K.auto, K = K.keyPath;
          if (K && z) throw new Ae.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (z && z.length !== k.length) throw new Ae.InvalidArgument("Arguments objects and keys must have the same length");
          var se = k.length, ye = K && ye ? k.map(ru(K)) : k;
          return P.core.mutate({ trans: q, type: "put", keys: z, values: ye, wantResults: $ }).then(function(ae) {
            var oe = ae.numFailures, ue = ae.failures;
            if (oe === 0) return $ ? ae.results : ae.lastResult;
            throw new J("".concat(P.name, ".bulkPut(): ").concat(oe, " of ").concat(se, " operations failed"), ue);
          });
        });
      }, cn.prototype.bulkUpdate = function(k) {
        var A = this, R = this.core, P = k.map(function(q) {
          return q.key;
        }), z = k.map(function(q) {
          return q.changes;
        }), $ = [];
        return this._trans("readwrite", function(q) {
          return R.getMany({ trans: q, keys: P, cache: "clone" }).then(function(K) {
            var se = [], ye = [], ae = (k.forEach(function(oe, ue) {
              var fe = oe.key, le = oe.changes, ce = K[ue];
              if (ce) {
                for (var we = 0, _e = Object.keys(le); we < _e.length; we++) {
                  var ve = _e[we], Re = le[ve];
                  if (ve === A.schema.primKey.keyPath) {
                    if (It(Re, fe) !== 0) throw new Ae.Constraint("Cannot update primary key in bulkUpdate()");
                  } else O(ce, ve, Re);
                }
                $.push(ue), se.push(fe), ye.push(ce);
              }
            }), se.length);
            return R.mutate({ trans: q, type: "put", keys: se, values: ye, updates: { keys: P, changeSpecs: z } }).then(function(oe) {
              var ue = oe.numFailures, fe = oe.failures;
              if (ue === 0) return ae;
              for (var le = 0, ce = Object.keys(fe); le < ce.length; le++) {
                var we, _e = ce[le], ve = $[Number(_e)];
                ve != null && (we = fe[_e], delete fe[_e], fe[ve] = we);
              }
              throw new J("".concat(A.name, ".bulkUpdate(): ").concat(ue, " of ").concat(ae, " operations failed"), fe);
            });
          });
        });
      }, cn.prototype.bulkDelete = function(k) {
        var A = this, R = k.length;
        return this._trans("readwrite", function(P) {
          return A.core.mutate({ trans: P, type: "delete", keys: k }).then(function(z) {
            return Zr(A, k, z);
          });
        }).then(function(P) {
          var z = P.numFailures, $ = P.failures;
          if (z === 0) return P.lastResult;
          throw new J("".concat(A.name, ".bulkDelete(): ").concat(z, " of ").concat(R, " operations failed"), $);
        });
      };
      var ap = cn;
      function cn() {
      }
      function ou(k) {
        function A(q, K) {
          if (K) {
            for (var se = arguments.length, ye = new Array(se - 1); --se; ) ye[se - 1] = arguments[se];
            return R[q].subscribe.apply(null, ye), k;
          }
          if (typeof q == "string") return R[q];
        }
        var R = {};
        A.addEventType = $;
        for (var P = 1, z = arguments.length; P < z; ++P) $(arguments[P]);
        return A;
        function $(q, K, se) {
          var ye, ae;
          if (typeof q != "object") return K = K || Yt, ae = { subscribers: [], fire: se = se || Ge, subscribe: function(oe) {
            ae.subscribers.indexOf(oe) === -1 && (ae.subscribers.push(oe), ae.fire = K(ae.fire, oe));
          }, unsubscribe: function(oe) {
            ae.subscribers = ae.subscribers.filter(function(ue) {
              return ue !== oe;
            }), ae.fire = ae.subscribers.reduce(K, se);
          } }, R[q] = A[q] = ae;
          s(ye = q).forEach(function(oe) {
            var ue = ye[oe];
            if (a(ue)) $(oe, ye[oe][0], ye[oe][1]);
            else {
              if (ue !== "asap") throw new Ae.InvalidArgument("Invalid event config");
              var fe = $(oe, rt, function() {
                for (var le = arguments.length, ce = new Array(le); le--; ) ce[le] = arguments[le];
                fe.subscribers.forEach(function(we) {
                  D(function() {
                    we.apply(null, ce);
                  });
                });
              });
            }
          });
        }
      }
      function zr(k, A) {
        return x(A).from({ prototype: k }), A;
      }
      function Ts(k, A) {
        return !(k.filter || k.algorithm || k.or) && (A ? k.justLimit : !k.replayFilter);
      }
      function Nd(k, A) {
        k.filter = fa(k.filter, A);
      }
      function su(k, A, R) {
        var P = k.replayFilter;
        k.replayFilter = P ? function() {
          return fa(P(), A());
        } : A, k.justLimit = R && !P;
      }
      function es(k, A) {
        if (k.isPrimKey) return A.primaryKey;
        var R = A.getIndexByKeyPath(k.index);
        if (R) return R;
        throw new Ae.Schema("KeyPath " + k.index + " on object store " + A.name + " is not indexed");
      }
      function lp(k, A, R) {
        var P = es(k, A.schema);
        return A.openCursor({ trans: R, values: !k.keysOnly, reverse: k.dir === "prev", unique: !!k.unique, query: { index: P, range: k.range } });
      }
      function au(k, A, R, P) {
        var z, $, q = k.replayFilter ? fa(k.filter, k.replayFilter()) : k.filter;
        return k.or ? (z = {}, $ = function(K, se, ye) {
          var ae, oe;
          q && !q(se, ye, function(ue) {
            return se.stop(ue);
          }, function(ue) {
            return se.fail(ue);
          }) || ((oe = "" + (ae = se.primaryKey)) == "[object ArrayBuffer]" && (oe = "" + new Uint8Array(ae)), h(z, oe)) || (z[oe] = !0, A(K, se, ye));
        }, Promise.all([k.or._iterate($, R), ha(lp(k, P, R), k.algorithm, $, !k.keysOnly && k.valueMapper)])) : ha(lp(k, P, R), fa(k.algorithm, q), A, !k.keysOnly && k.valueMapper);
      }
      function ha(k, A, R, P) {
        var z = Cn(P ? function($, q, K) {
          return R(P($), q, K);
        } : R);
        return k.then(function($) {
          if ($) return $.start(function() {
            var q = function() {
              return $.continue();
            };
            A && !A($, function(K) {
              return q = K;
            }, function(K) {
              $.stop(K), q = Ge;
            }, function(K) {
              $.fail(K), q = Ge;
            }) || z($.value, $, function(K) {
              return q = K;
            }), q();
          });
        });
      }
      en.prototype._read = function(k, A) {
        var R = this._ctx;
        return R.error ? R.table._trans(null, bn.bind(null, R.error)) : R.table._trans("readonly", k).then(A);
      }, en.prototype._write = function(k) {
        var A = this._ctx;
        return A.error ? A.table._trans(null, bn.bind(null, A.error)) : A.table._trans("readwrite", k, "locked");
      }, en.prototype._addAlgorithm = function(k) {
        var A = this._ctx;
        A.algorithm = fa(A.algorithm, k);
      }, en.prototype._iterate = function(k, A) {
        return au(this._ctx, k, A, this._ctx.table.core);
      }, en.prototype.clone = function(k) {
        var A = Object.create(this.constructor.prototype), R = Object.create(this._ctx);
        return k && c(R, k), A._ctx = R, A;
      }, en.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, en.prototype.each = function(k) {
        var A = this._ctx;
        return this._read(function(R) {
          return au(A, k, R, A.table.core);
        });
      }, en.prototype.count = function(k) {
        var A = this;
        return this._read(function(R) {
          var P, z = A._ctx, $ = z.table.core;
          return Ts(z, !0) ? $.count({ trans: R, query: { index: es(z, $.schema), range: z.range } }).then(function(q) {
            return Math.min(q, z.limit);
          }) : (P = 0, au(z, function() {
            return ++P, !1;
          }, R, $).then(function() {
            return P;
          }));
        }).then(k);
      }, en.prototype.sortBy = function(k, A) {
        var R = k.split(".").reverse(), P = R[0], z = R.length - 1;
        function $(se, ye) {
          return ye ? $(se[R[ye]], ye - 1) : se[P];
        }
        var q = this._ctx.dir === "next" ? 1 : -1;
        function K(se, ye) {
          return It($(se, z), $(ye, z)) * q;
        }
        return this.toArray(function(se) {
          return se.sort(K);
        }).then(A);
      }, en.prototype.toArray = function(k) {
        var A = this;
        return this._read(function(R) {
          var P, z, $, q = A._ctx;
          return q.dir === "next" && Ts(q, !0) && 0 < q.limit ? (P = q.valueMapper, z = es(q, q.table.core.schema), q.table.core.query({ trans: R, limit: q.limit, values: !0, query: { index: z, range: q.range } }).then(function(K) {
            return K = K.result, P ? K.map(P) : K;
          })) : ($ = [], au(q, function(K) {
            return $.push(K);
          }, R, q.table.core).then(function() {
            return $;
          }));
        }, k);
      }, en.prototype.offset = function(k) {
        var A = this._ctx;
        return k <= 0 || (A.offset += k, Ts(A) ? su(A, function() {
          var R = k;
          return function(P, z) {
            return R === 0 || (R === 1 ? --R : z(function() {
              P.advance(R), R = 0;
            }), !1);
          };
        }) : su(A, function() {
          var R = k;
          return function() {
            return --R < 0;
          };
        })), this;
      }, en.prototype.limit = function(k) {
        return this._ctx.limit = Math.min(this._ctx.limit, k), su(this._ctx, function() {
          var A = k;
          return function(R, P, z) {
            return --A <= 0 && P(z), 0 <= A;
          };
        }, !0), this;
      }, en.prototype.until = function(k, A) {
        return Nd(this._ctx, function(R, P, z) {
          return !k(R.value) || (P(z), A);
        }), this;
      }, en.prototype.first = function(k) {
        return this.limit(1).toArray(function(A) {
          return A[0];
        }).then(k);
      }, en.prototype.last = function(k) {
        return this.reverse().first(k);
      }, en.prototype.filter = function(k) {
        var A;
        return Nd(this._ctx, function(R) {
          return k(R.value);
        }), (A = this._ctx).isMatch = fa(A.isMatch, k), this;
      }, en.prototype.and = function(k) {
        return this.filter(k);
      }, en.prototype.or = function(k) {
        return new this.db.WhereClause(this._ctx.table, k, this);
      }, en.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, en.prototype.desc = function() {
        return this.reverse();
      }, en.prototype.eachKey = function(k) {
        var A = this._ctx;
        return A.keysOnly = !A.isMatch, this.each(function(R, P) {
          k(P.key, P);
        });
      }, en.prototype.eachUniqueKey = function(k) {
        return this._ctx.unique = "unique", this.eachKey(k);
      }, en.prototype.eachPrimaryKey = function(k) {
        var A = this._ctx;
        return A.keysOnly = !A.isMatch, this.each(function(R, P) {
          k(P.primaryKey, P);
        });
      }, en.prototype.keys = function(k) {
        var A = this._ctx, R = (A.keysOnly = !A.isMatch, []);
        return this.each(function(P, z) {
          R.push(z.key);
        }).then(function() {
          return R;
        }).then(k);
      }, en.prototype.primaryKeys = function(k) {
        var A = this._ctx;
        if (A.dir === "next" && Ts(A, !0) && 0 < A.limit) return this._read(function(P) {
          var z = es(A, A.table.core.schema);
          return A.table.core.query({ trans: P, values: !1, limit: A.limit, query: { index: z, range: A.range } });
        }).then(function(P) {
          return P.result;
        }).then(k);
        A.keysOnly = !A.isMatch;
        var R = [];
        return this.each(function(P, z) {
          R.push(z.primaryKey);
        }).then(function() {
          return R;
        }).then(k);
      }, en.prototype.uniqueKeys = function(k) {
        return this._ctx.unique = "unique", this.keys(k);
      }, en.prototype.firstKey = function(k) {
        return this.limit(1).keys(function(A) {
          return A[0];
        }).then(k);
      }, en.prototype.lastKey = function(k) {
        return this.reverse().firstKey(k);
      }, en.prototype.distinct = function() {
        var k, A = this._ctx, A = A.index && A.table.schema.idxByName[A.index];
        return A && A.multi && (k = {}, Nd(this._ctx, function(P) {
          var P = P.primaryKey.toString(), z = h(k, P);
          return k[P] = !0, !z;
        })), this;
      }, en.prototype.modify = function(k) {
        var A = this, R = this._ctx;
        return this._write(function(P) {
          function z(ce, we) {
            var _e = we.failures;
            ue += ce - we.numFailures;
            for (var ve = 0, Re = s(_e); ve < Re.length; ve++) {
              var ze = Re[ve];
              oe.push(_e[ze]);
            }
          }
          var $ = typeof k == "function" ? k : function(ce) {
            return Md(ce, k);
          }, q = R.table.core, ae = q.schema.primaryKey, K = ae.outbound, se = ae.extractKey, ye = 200, ae = A.db._options.modifyChunkSize, oe = (ae && (ye = typeof ae == "object" ? ae[q.name] || ae["*"] || 200 : ae), []), ue = 0, fe = [], le = k === cp;
          return A.clone().primaryKeys().then(function(ce) {
            function we(ve) {
              var Re = Math.min(ye, ce.length - ve), ze = ce.slice(ve, ve + Re);
              return (le ? Promise.resolve([]) : q.getMany({ trans: P, keys: ze, cache: "immutable" })).then(function(We) {
                var qe = [], Le = [], Xe = K ? [] : null, Ze = le ? ze : [];
                if (!le) for (var Be = 0; Be < Re; ++Be) {
                  var Je = We[Be], St = { value: he(Je), primKey: ce[ve + Be] };
                  $.call(St, St.value, St) !== !1 && (St.value == null ? Ze.push(ce[ve + Be]) : K || It(se(Je), se(St.value)) === 0 ? (Le.push(St.value), K && Xe.push(ce[ve + Be])) : (Ze.push(ce[ve + Be]), qe.push(St.value)));
                }
                return Promise.resolve(0 < qe.length && q.mutate({ trans: P, type: "add", values: qe }).then(function($t) {
                  for (var ft in $t.failures) Ze.splice(parseInt(ft), 1);
                  z(qe.length, $t);
                })).then(function() {
                  return (0 < Le.length || _e && typeof k == "object") && q.mutate({ trans: P, type: "put", keys: Xe, values: Le, criteria: _e, changeSpec: typeof k != "function" && k, isAdditionalChunk: 0 < ve }).then(function($t) {
                    return z(Le.length, $t);
                  });
                }).then(function() {
                  return (0 < Ze.length || _e && le) && q.mutate({ trans: P, type: "delete", keys: Ze, criteria: _e, isAdditionalChunk: 0 < ve }).then(function($t) {
                    return Zr(R.table, Ze, $t);
                  }).then(function($t) {
                    return z(Ze.length, $t);
                  });
                }).then(function() {
                  return ce.length > ve + Re && we(ve + ye);
                });
              });
            }
            var _e = Ts(R) && R.limit === 1 / 0 && (typeof k != "function" || le) && { index: R.index, range: R.range };
            return we(0).then(function() {
              if (0 < oe.length) throw new re("Error modifying one or more objects", oe, ue, fe);
              return ce.length;
            });
          });
        });
      }, en.prototype.delete = function() {
        var k = this._ctx, A = k.range;
        return !Ts(k) || k.table.schema.yProps || !k.isPrimKey && A.type !== 3 ? this.modify(cp) : this._write(function(R) {
          var P = k.table.core.schema.primaryKey, z = A;
          return k.table.core.count({ trans: R, query: { index: P, range: z } }).then(function($) {
            return k.table.core.mutate({ trans: R, type: "deleteRange", range: z }).then(function(se) {
              var K = se.failures, se = se.numFailures;
              if (se) throw new re("Could not delete some values", Object.keys(K).map(function(ye) {
                return K[ye];
              }), $ - se);
              return $ - se;
            });
          });
        });
      };
      var M1 = en;
      function en() {
      }
      var cp = function(k, A) {
        return A.value = null;
      };
      function up(k, A) {
        return k < A ? -1 : k === A ? 0 : 1;
      }
      function N1(k, A) {
        return A < k ? -1 : k === A ? 0 : 1;
      }
      function Ei(k, A, R) {
        return k = k instanceof pa ? new k.Collection(k) : k, k._ctx.error = new (R || TypeError)(A), k;
      }
      function ts(k) {
        return new k.Collection(k, function() {
          return Rd("");
        }).limit(0);
      }
      function $i(fe, A, R, P) {
        var z, $, q, K, se, ye, ae, oe = R.length;
        if (!R.every(function(ce) {
          return typeof ce == "string";
        })) return Ei(fe, cr);
        function ue(ce) {
          z = ce === "next" ? function(_e) {
            return _e.toUpperCase();
          } : function(_e) {
            return _e.toLowerCase();
          }, $ = ce === "next" ? function(_e) {
            return _e.toLowerCase();
          } : function(_e) {
            return _e.toUpperCase();
          }, q = ce === "next" ? up : N1;
          var we = R.map(function(_e) {
            return { lower: $(_e), upper: z(_e) };
          }).sort(function(_e, ve) {
            return q(_e.lower, ve.lower);
          });
          K = we.map(function(_e) {
            return _e.upper;
          }), se = we.map(function(_e) {
            return _e.lower;
          }), ae = (ye = ce) === "next" ? "" : P;
        }
        ue("next");
        var fe = new fe.Collection(fe, function() {
          return ko(K[0], se[oe - 1] + P);
        }), le = (fe._ondirectionchange = function(ce) {
          ue(ce);
        }, 0);
        return fe._addAlgorithm(function(ce, we, _e) {
          var ve = ce.key;
          if (typeof ve == "string") {
            var Re = $(ve);
            if (A(Re, se, le)) return !0;
            for (var ze = null, We = le; We < oe; ++We) {
              var qe = ((Le, Xe, Ze, Be, Je, St) => {
                for (var $t = Math.min(Le.length, Be.length), ft = -1, At = 0; At < $t; ++At) {
                  var xn = Xe[At];
                  if (xn !== Be[At]) return Je(Le[At], Ze[At]) < 0 ? Le.substr(0, At) + Ze[At] + Ze.substr(At + 1) : Je(Le[At], Be[At]) < 0 ? Le.substr(0, At) + Be[At] + Ze.substr(At + 1) : 0 <= ft ? Le.substr(0, ft) + Xe[ft] + Ze.substr(ft + 1) : null;
                  Je(Le[At], xn) < 0 && (ft = At);
                }
                return $t < Be.length && St === "next" ? Le + Ze.substr(Le.length) : $t < Le.length && St === "prev" ? Le.substr(0, Ze.length) : ft < 0 ? null : Le.substr(0, ft) + Be[ft] + Ze.substr(ft + 1);
              })(ve, Re, K[We], se[We], q, ye);
              qe === null && ze === null ? le = We + 1 : (ze === null || 0 < q(ze, qe)) && (ze = qe);
            }
            we(ze !== null ? function() {
              ce.continue(ze + ae);
            } : _e);
          }
          return !1;
        }), fe;
      }
      function ko(k, A, R, P) {
        return { type: 2, lower: k, upper: A, lowerOpen: R, upperOpen: P };
      }
      function Rd(k) {
        return { type: 1, lower: k, upper: k };
      }
      Object.defineProperty(zn.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), zn.prototype.between = function(k, A, R, P) {
        R = R !== !1, P = P === !0;
        try {
          return 0 < this._cmp(k, A) || this._cmp(k, A) === 0 && (R || P) && (!R || !P) ? ts(this) : new this.Collection(this, function() {
            return ko(k, A, !R, !P);
          });
        } catch {
          return Ei(this, ui);
        }
      }, zn.prototype.equals = function(k) {
        return k == null ? Ei(this, ui) : new this.Collection(this, function() {
          return Rd(k);
        });
      }, zn.prototype.above = function(k) {
        return k == null ? Ei(this, ui) : new this.Collection(this, function() {
          return ko(k, void 0, !0);
        });
      }, zn.prototype.aboveOrEqual = function(k) {
        return k == null ? Ei(this, ui) : new this.Collection(this, function() {
          return ko(k, void 0, !1);
        });
      }, zn.prototype.below = function(k) {
        return k == null ? Ei(this, ui) : new this.Collection(this, function() {
          return ko(void 0, k, !1, !0);
        });
      }, zn.prototype.belowOrEqual = function(k) {
        return k == null ? Ei(this, ui) : new this.Collection(this, function() {
          return ko(void 0, k);
        });
      }, zn.prototype.startsWith = function(k) {
        return typeof k != "string" ? Ei(this, cr) : this.between(k, k + to, !0, !0);
      }, zn.prototype.startsWithIgnoreCase = function(k) {
        return k === "" ? this.startsWith(k) : $i(this, function(A, R) {
          return A.indexOf(R[0]) === 0;
        }, [k], to);
      }, zn.prototype.equalsIgnoreCase = function(k) {
        return $i(this, function(A, R) {
          return A === R[0];
        }, [k], "");
      }, zn.prototype.anyOfIgnoreCase = function() {
        var k = W.apply(Se, arguments);
        return k.length === 0 ? ts(this) : $i(this, function(A, R) {
          return R.indexOf(A) !== -1;
        }, k, "");
      }, zn.prototype.startsWithAnyOfIgnoreCase = function() {
        var k = W.apply(Se, arguments);
        return k.length === 0 ? ts(this) : $i(this, function(A, R) {
          return R.some(function(P) {
            return A.indexOf(P) === 0;
          });
        }, k, to);
      }, zn.prototype.anyOf = function() {
        var k, A, R = this, P = W.apply(Se, arguments), z = this._cmp;
        try {
          P.sort(z);
        } catch {
          return Ei(this, ui);
        }
        return P.length === 0 ? ts(this) : ((k = new this.Collection(this, function() {
          return ko(P[0], P[P.length - 1]);
        }))._ondirectionchange = function($) {
          z = $ === "next" ? R._ascending : R._descending, P.sort(z);
        }, A = 0, k._addAlgorithm(function($, q, K) {
          for (var se = $.key; 0 < z(se, P[A]); ) if (++A === P.length) return q(K), !1;
          return z(se, P[A]) === 0 || (q(function() {
            $.continue(P[A]);
          }), !1);
        }), k);
      }, zn.prototype.notEqual = function(k) {
        return this.inAnyRange([[-1 / 0, k], [k, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, zn.prototype.noneOf = function() {
        var k = W.apply(Se, arguments);
        if (k.length === 0) return new this.Collection(this);
        try {
          k.sort(this._ascending);
        } catch {
          return Ei(this, ui);
        }
        var A = k.reduce(function(R, P) {
          return R ? R.concat([[R[R.length - 1][1], P]]) : [[-1 / 0, P]];
        }, null);
        return A.push([k[k.length - 1], this.db._maxKey]), this.inAnyRange(A, { includeLowers: !1, includeUppers: !1 });
      }, zn.prototype.inAnyRange = function(k, _e) {
        var R = this, P = this._cmp, z = this._ascending, $ = this._descending, q = this._min, K = this._max;
        if (k.length === 0) return ts(this);
        if (!k.every(function(ve) {
          return ve[0] !== void 0 && ve[1] !== void 0 && z(ve[0], ve[1]) <= 0;
        })) return Ei(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Ae.InvalidArgument);
        var se = !_e || _e.includeLowers !== !1, ye = _e && _e.includeUppers === !0, ae, oe = z;
        function ue(ve, Re) {
          return oe(ve[0], Re[0]);
        }
        try {
          (ae = k.reduce(function(ve, Re) {
            for (var ze = 0, We = ve.length; ze < We; ++ze) {
              var qe = ve[ze];
              if (P(Re[0], qe[1]) < 0 && 0 < P(Re[1], qe[0])) {
                qe[0] = q(qe[0], Re[0]), qe[1] = K(qe[1], Re[1]);
                break;
              }
            }
            return ze === We && ve.push(Re), ve;
          }, [])).sort(ue);
        } catch {
          return Ei(this, ui);
        }
        var fe = 0, le = ye ? function(ve) {
          return 0 < z(ve, ae[fe][1]);
        } : function(ve) {
          return 0 <= z(ve, ae[fe][1]);
        }, ce = se ? function(ve) {
          return 0 < $(ve, ae[fe][0]);
        } : function(ve) {
          return 0 <= $(ve, ae[fe][0]);
        }, we = le, _e = new this.Collection(this, function() {
          return ko(ae[0][0], ae[ae.length - 1][1], !se, !ye);
        });
        return _e._ondirectionchange = function(ve) {
          oe = ve === "next" ? (we = le, z) : (we = ce, $), ae.sort(ue);
        }, _e._addAlgorithm(function(ve, Re, ze) {
          for (var We, qe = ve.key; we(qe); ) if (++fe === ae.length) return Re(ze), !1;
          return !le(We = qe) && !ce(We) || (R._cmp(qe, ae[fe][1]) === 0 || R._cmp(qe, ae[fe][0]) === 0 || Re(function() {
            oe === z ? ve.continue(ae[fe][0]) : ve.continue(ae[fe][1]);
          }), !1);
        }), _e;
      }, zn.prototype.startsWithAnyOf = function() {
        var k = W.apply(Se, arguments);
        return k.every(function(A) {
          return typeof A == "string";
        }) ? k.length === 0 ? ts(this) : this.inAnyRange(k.map(function(A) {
          return [A, A + to];
        })) : Ei(this, "startsWithAnyOf() only works with strings");
      };
      var pa = zn;
      function zn() {
      }
      function no(k) {
        return Cn(function(A) {
          return ma(A), k(A.target.error), !1;
        });
      }
      function ma(k) {
        k.stopPropagation && k.stopPropagation(), k.preventDefault && k.preventDefault();
      }
      var ml = "storagemutated", ga = "x-storagemutated-1", Lr = ou(null, ml), dp = (di.prototype._lock = function() {
        return N(!Ve.global), ++this._reculock, this._reculock !== 1 || Ve.global || (Ve.lockOwnerFor = this), this;
      }, di.prototype._unlock = function() {
        if (N(!Ve.global), --this._reculock == 0) for (Ve.global || (Ve.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var k = this._blockedFuncs.shift();
          try {
            eo(k[1], k[0]);
          } catch {
          }
        }
        return this;
      }, di.prototype._locked = function() {
        return this._reculock && Ve.lockOwnerFor !== this;
      }, di.prototype.create = function(k) {
        var A = this;
        if (this.mode) {
          var R = this.db.idbdb, P = this.db._state.dbOpenError;
          if (N(!this.idbtrans), !k && !R) switch (P && P.name) {
            case "DatabaseClosedError":
              throw new Ae.DatabaseClosed(P);
            case "MissingAPIError":
              throw new Ae.MissingAPI(P.message, P);
            default:
              throw new Ae.OpenFailed(P);
          }
          if (!this.active) throw new Ae.TransactionInactive();
          N(this._completion._state === null), (k = this.idbtrans = k || (this.db.core || R).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Cn(function(z) {
            ma(z), A._reject(k.error);
          }), k.onabort = Cn(function(z) {
            ma(z), A.active && A._reject(new Ae.Abort(k.error)), A.active = !1, A.on("abort").fire(z);
          }), k.oncomplete = Cn(function() {
            A.active = !1, A._resolve(), "mutatedParts" in k && Lr.storagemutated.fire(k.mutatedParts);
          });
        }
        return this;
      }, di.prototype._promise = function(k, A, R) {
        var P, z = this;
        return k === "readwrite" && this.mode !== "readwrite" ? bn(new Ae.ReadOnly("Transaction is readonly")) : this.active ? this._locked() ? new Ke(function($, q) {
          z._blockedFuncs.push([function() {
            z._promise(k, A, R).then($, q);
          }, Ve]);
        }) : R ? Rn(function() {
          var $ = new Ke(function(q, K) {
            z._lock();
            var se = A(q, K, z);
            se && se.then && se.then(q, K);
          });
          return $.finally(function() {
            return z._unlock();
          }), $._lib = !0, $;
        }) : ((P = new Ke(function($, q) {
          var K = A($, q, z);
          K && K.then && K.then($, q);
        }))._lib = !0, P) : bn(new Ae.TransactionInactive());
      }, di.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, di.prototype.waitFor = function(k) {
        var A, R = this._root(), P = Ke.resolve(k), z = (R._waitingFor ? R._waitingFor = R._waitingFor.then(function() {
          return P;
        }) : (R._waitingFor = P, R._waitingQueue = [], A = R.idbtrans.objectStore(R.storeNames[0]), (function $() {
          for (++R._spinCount; R._waitingQueue.length; ) R._waitingQueue.shift()();
          R._waitingFor && (A.get(-1 / 0).onsuccess = $);
        })()), R._waitingFor);
        return new Ke(function($, q) {
          P.then(function(K) {
            return R._waitingQueue.push(Cn($.bind(null, K)));
          }, function(K) {
            return R._waitingQueue.push(Cn(q.bind(null, K)));
          }).finally(function() {
            R._waitingFor === z && (R._waitingFor = null);
          });
        });
      }, di.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Ae.Abort()));
      }, di.prototype.table = function(k) {
        var A = this._memoizedTables || (this._memoizedTables = {});
        if (h(A, k)) return A[k];
        var R = this.schema[k];
        if (R) return (R = new this.db.Table(k, R, this)).core = this.db.core.table(k), A[k] = R;
        throw new Ae.NotFound("Table " + k + " not part of transaction");
      }, di);
      function di() {
      }
      function Co(k, A, R, P, z, $, q, K) {
        return { name: k, keyPath: A, unique: R, multi: P, auto: z, compound: $, src: (R && !q ? "&" : "") + (P ? "*" : "") + (z ? "++" : "") + Od(A), type: K };
      }
      function Od(k) {
        return typeof k == "string" ? k : k ? "[" + [].join.call(k, "+") + "]" : "";
      }
      function gl(k, A, R) {
        return { name: k, primKey: A, indexes: R, mappedClass: null, idxByName: (P = function(z) {
          return [z.name, z];
        }, R.reduce(function(z, $, q) {
          return $ = P($, q), $ && (z[$[0]] = $[1]), z;
        }, {})) };
        var P;
      }
      var yl = function(k) {
        try {
          return k.only([[]]), yl = function() {
            return [[]];
          }, [[]];
        } catch {
          return yl = function() {
            return to;
          }, to;
        }
      };
      function vl(k) {
        return k == null ? function() {
        } : typeof k == "string" ? (A = k).split(".").length === 1 ? function(R) {
          return R[A];
        } : function(R) {
          return j(R, A);
        } : function(R) {
          return j(R, k);
        };
        var A;
      }
      function lu(k) {
        return [].slice.call(k);
      }
      var Ey = 0;
      function mr(k) {
        return k == null ? ":id" : typeof k == "string" ? k : "[".concat(k.join("+"), "]");
      }
      function ya(k, A, se) {
        function P(le) {
          if (le.type === 3) return null;
          if (le.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var oe = le.lower, ue = le.upper, fe = le.lowerOpen, le = le.upperOpen;
          return oe === void 0 ? ue === void 0 ? null : A.upperBound(ue, !!le) : ue === void 0 ? A.lowerBound(oe, !!fe) : A.bound(oe, ue, !!fe, !!le);
        }
        function z(ae) {
          var oe, ue = ae.name;
          return { name: ue, schema: ae, mutate: function(fe) {
            var le = fe.trans, ce = fe.type, we = fe.keys, _e = fe.values, ve = fe.range;
            return new Promise(function(Re, ze) {
              Re = Cn(Re);
              var We = le.objectStore(ue), qe = We.keyPath == null, Le = ce === "put" || ce === "add";
              if (!Le && ce !== "delete" && ce !== "deleteRange") throw new Error("Invalid operation type: " + ce);
              var Xe, Ze = (we || _e || { length: 1 }).length;
              if (we && _e && we.length !== _e.length) throw new Error("Given keys array must have same length as given values array.");
              if (Ze === 0) return Re({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function Be(dn) {
                ++$t, ma(dn);
              }
              var Je = [], St = [], $t = 0;
              if (ce === "deleteRange") {
                if (ve.type === 4) return Re({ numFailures: $t, failures: St, results: [], lastResult: void 0 });
                ve.type === 3 ? Je.push(Xe = We.clear()) : Je.push(Xe = We.delete(P(ve)));
              } else {
                var qe = Le ? qe ? [_e, we] : [_e, null] : [we, null], ft = qe[0], At = qe[1];
                if (Le) for (var xn = 0; xn < Ze; ++xn) Je.push(Xe = At && At[xn] !== void 0 ? We[ce](ft[xn], At[xn]) : We[ce](ft[xn])), Xe.onerror = Be;
                else for (xn = 0; xn < Ze; ++xn) Je.push(Xe = We[ce](ft[xn])), Xe.onerror = Be;
              }
              function hi(dn) {
                dn = dn.target.result, Je.forEach(function(Rs, Cl) {
                  return Rs.error != null && (St[Cl] = Rs.error);
                }), Re({ numFailures: $t, failures: St, results: ce === "delete" ? we : Je.map(function(Rs) {
                  return Rs.result;
                }), lastResult: dn });
              }
              Xe.onerror = function(dn) {
                Be(dn), hi(dn);
              }, Xe.onsuccess = hi;
            });
          }, getMany: function(fe) {
            var le = fe.trans, ce = fe.keys;
            return new Promise(function(we, _e) {
              we = Cn(we);
              for (var ve, Re = le.objectStore(ue), ze = ce.length, We = new Array(ze), qe = 0, Le = 0, Xe = function(Je) {
                Je = Je.target, We[Je._pos] = Je.result, ++Le === qe && we(We);
              }, Ze = no(_e), Be = 0; Be < ze; ++Be) ce[Be] != null && ((ve = Re.get(ce[Be]))._pos = Be, ve.onsuccess = Xe, ve.onerror = Ze, ++qe);
              qe === 0 && we(We);
            });
          }, get: function(fe) {
            var le = fe.trans, ce = fe.key;
            return new Promise(function(we, _e) {
              we = Cn(we);
              var ve = le.objectStore(ue).get(ce);
              ve.onsuccess = function(Re) {
                return we(Re.target.result);
              }, ve.onerror = no(_e);
            });
          }, query: (oe = K, function(fe) {
            return new Promise(function(le, ce) {
              le = Cn(le);
              var we, _e, ve, Le = fe.trans, Re = fe.values, ze = fe.limit, qe = fe.query, We = ze === 1 / 0 ? void 0 : ze, Xe = qe.index, qe = qe.range, Le = Le.objectStore(ue), Le = Xe.isPrimaryKey ? Le : Le.index(Xe.name), Xe = P(qe);
              if (ze === 0) return le({ result: [] });
              oe ? ((qe = Re ? Le.getAll(Xe, We) : Le.getAllKeys(Xe, We)).onsuccess = function(Ze) {
                return le({ result: Ze.target.result });
              }, qe.onerror = no(ce)) : (we = 0, _e = !Re && "openKeyCursor" in Le ? Le.openKeyCursor(Xe) : Le.openCursor(Xe), ve = [], _e.onsuccess = function(Ze) {
                var Be = _e.result;
                return !Be || (ve.push(Re ? Be.value : Be.primaryKey), ++we === ze) ? le({ result: ve }) : void Be.continue();
              }, _e.onerror = no(ce));
            });
          }), openCursor: function(fe) {
            var le = fe.trans, ce = fe.values, we = fe.query, _e = fe.reverse, ve = fe.unique;
            return new Promise(function(Re, ze) {
              Re = Cn(Re);
              var Le = we.index, We = we.range, qe = le.objectStore(ue), qe = Le.isPrimaryKey ? qe : qe.index(Le.name), Le = _e ? ve ? "prevunique" : "prev" : ve ? "nextunique" : "next", Xe = !ce && "openKeyCursor" in qe ? qe.openKeyCursor(P(We), Le) : qe.openCursor(P(We), Le);
              Xe.onerror = no(ze), Xe.onsuccess = Cn(function(Ze) {
                var Be, Je, St, $t, ft = Xe.result;
                ft ? (ft.___id = ++Ey, ft.done = !1, Be = ft.continue.bind(ft), Je = (Je = ft.continuePrimaryKey) && Je.bind(ft), St = ft.advance.bind(ft), $t = function() {
                  throw new Error("Cursor not stopped");
                }, ft.trans = le, ft.stop = ft.continue = ft.continuePrimaryKey = ft.advance = function() {
                  throw new Error("Cursor not started");
                }, ft.fail = Cn(ze), ft.next = function() {
                  var At = this, xn = 1;
                  return this.start(function() {
                    return xn-- ? At.continue() : At.stop();
                  }).then(function() {
                    return At;
                  });
                }, ft.start = function(At) {
                  function xn() {
                    if (Xe.result) try {
                      At();
                    } catch (dn) {
                      ft.fail(dn);
                    }
                    else ft.done = !0, ft.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, ft.stop();
                  }
                  var hi = new Promise(function(dn, Rs) {
                    dn = Cn(dn), Xe.onerror = no(Rs), ft.fail = Rs, ft.stop = function(Cl) {
                      ft.stop = ft.continue = ft.continuePrimaryKey = ft.advance = $t, dn(Cl);
                    };
                  });
                  return Xe.onsuccess = Cn(function(dn) {
                    Xe.onsuccess = xn, xn();
                  }), ft.continue = Be, ft.continuePrimaryKey = Je, ft.advance = St, xn(), hi;
                }, Re(ft)) : Re(null);
              }, ze);
            });
          }, count: function(fe) {
            var le = fe.query, ce = fe.trans, we = le.index, _e = le.range;
            return new Promise(function(ve, Re) {
              var ze = ce.objectStore(ue), ze = we.isPrimaryKey ? ze : ze.index(we.name), We = P(_e), We = We ? ze.count(We) : ze.count();
              We.onsuccess = Cn(function(qe) {
                return ve(qe.target.result);
              }), We.onerror = no(Re);
            });
          } };
        }
        $ = se, q = lu((se = k).objectStoreNames);
        var $, se = { schema: { name: se.name, tables: q.map(function(ae) {
          return $.objectStore(ae);
        }).map(function(ae) {
          var oe = ae.keyPath, ue = ae.autoIncrement, le = a(oe), fe = {}, le = { name: ae.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: oe == null, compound: le, keyPath: oe, autoIncrement: ue, unique: !0, extractKey: vl(oe) }, indexes: lu(ae.indexNames).map(function(ce) {
            return ae.index(ce);
          }).map(function(ve) {
            var Re = ve.name, we = ve.unique, _e = ve.multiEntry, ve = ve.keyPath, Re = { name: Re, compound: a(ve), keyPath: ve, unique: we, multiEntry: _e, extractKey: vl(ve) };
            return fe[mr(ve)] = Re;
          }), getIndexByKeyPath: function(ce) {
            return fe[mr(ce)];
          } };
          return fe[":id"] = le.primaryKey, oe != null && (fe[mr(oe)] = le.primaryKey), le;
        }) }, hasGetAll: 0 < q.length && "getAll" in $.objectStore(q[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }, q = se.schema, K = se.hasGetAll, se = q.tables.map(z), ye = {};
        return se.forEach(function(ae) {
          return ye[ae.name] = ae;
        }), { stack: "dbcore", transaction: k.transaction.bind(k), table: function(ae) {
          if (ye[ae]) return ye[ae];
          throw new Error("Table '".concat(ae, "' not found"));
        }, MIN_KEY: -1 / 0, MAX_KEY: yl(A), schema: q };
      }
      function Pd(k, A, R, P) {
        return R = R.IDBKeyRange, A = ya(A, R, P), { dbcore: k.dbcore.reduce(function(z, $) {
          return $ = $.create, r(r({}, z), $(z));
        }, A) };
      }
      function As(k, A) {
        var R = A.db, R = Pd(k._middlewares, R, k._deps, A);
        k.core = R.dbcore, k.tables.forEach(function(P) {
          var z = P.name;
          k.core.schema.tables.some(function($) {
            return $.name === z;
          }) && (P.core = k.core.table(z), k[z] instanceof k.Table) && (k[z].core = P.core);
        });
      }
      function Dd(k, A, R, P) {
        R.forEach(function(z) {
          var $ = P[z];
          A.forEach(function(q) {
            var K = (function se(ye, ae) {
              return w(ye, ae) || (ye = u(ye)) && se(ye, ae);
            })(q, z);
            (!K || "value" in K && K.value === void 0) && (q === k.Transaction.prototype || q instanceof k.Transaction ? b(q, z, { get: function() {
              return this.table(z);
            }, set: function(se) {
              g(this, z, { value: se, writable: !0, configurable: !0, enumerable: !0 });
            } }) : q[z] = new k.Table(z, $));
          });
        });
      }
      function cu(k, A) {
        A.forEach(function(R) {
          for (var P in R) R[P] instanceof k.Table && delete R[P];
        });
      }
      function fp(k, A) {
        return k._cfg.version - A._cfg.version;
      }
      function uu(k, A, R, P) {
        var z = k._dbSchema, $ = (R.objectStoreNames.contains("$meta") && !z.$meta && (z.$meta = gl("$meta", Ty("")[0], []), k._storeNames.push("$meta")), k._createTransaction("readwrite", k._storeNames, z)), q = ($.create(R), $._completion.catch(P), $._reject.bind($)), K = Ve.transless || Ve;
        Rn(function() {
          if (Ve.trans = $, Ve.transless = K, A !== 0) return As(k, R), ye = A, ((se = $).storeNames.includes("$meta") ? se.table("$meta").get("version").then(function(ae) {
            return ae ?? ye;
          }) : Ke.resolve(ye)).then(function(we) {
            var oe = k, ue = we, fe = $, le = R, ce = [], we = oe._versions, _e = oe._dbSchema = bl(0, oe.idbdb, le);
            return (we = we.filter(function(ve) {
              return ve._cfg.version >= ue;
            })).length === 0 ? Ke.resolve() : (we.forEach(function(ve) {
              ce.push(function() {
                var Re, ze, We, qe = _e, Le = ve._cfg.dbschema, Xe = (Ld(oe, qe, le), Ld(oe, Le, le), _e = oe._dbSchema = Le, jd(qe, Le)), Ze = (Xe.add.forEach(function(Be) {
                  hp(le, Be[0], Be[1].primKey, Be[1].indexes);
                }), Xe.change.forEach(function(Be) {
                  if (Be.recreate) throw new Ae.Upgrade("Not yet support for changing primary key");
                  var Je = le.objectStore(Be.name);
                  Be.add.forEach(function(St) {
                    return zd(Je, St);
                  }), Be.change.forEach(function(St) {
                    Je.deleteIndex(St.name), zd(Je, St);
                  }), Be.del.forEach(function(St) {
                    return Je.deleteIndex(St);
                  });
                }), ve._cfg.contentUpgrade);
                if (Ze && ve._cfg.version > ue) return As(oe, le), fe._memoizedTables = {}, Re = L(Le), Xe.del.forEach(function(Be) {
                  Re[Be] = qe[Be];
                }), cu(oe, [oe.Transaction.prototype]), Dd(oe, [oe.Transaction.prototype], s(Re), Re), fe.schema = Re, (ze = Z(Ze)) && lr(), Le = Ke.follow(function() {
                  var Be;
                  (We = Ze(fe)) && ze && (Be = Ci.bind(null, null), We.then(Be, Be));
                }), We && typeof We.then == "function" ? Ke.resolve(We) : Le.then(function() {
                  return We;
                });
              }), ce.push(function(Re) {
                var ze, We, qe = ve._cfg.dbschema;
                ze = qe, We = Re, [].slice.call(We.db.objectStoreNames).forEach(function(Le) {
                  return ze[Le] == null && We.db.deleteObjectStore(Le);
                }), cu(oe, [oe.Transaction.prototype]), Dd(oe, [oe.Transaction.prototype], oe._storeNames, oe._dbSchema), fe.schema = oe._dbSchema;
              }), ce.push(function(Re) {
                oe.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(oe.idbdb.version / 10) === ve._cfg.version ? (oe.idbdb.deleteObjectStore("$meta"), delete oe._dbSchema.$meta, oe._storeNames = oe._storeNames.filter(function(ze) {
                  return ze !== "$meta";
                })) : Re.objectStore("$meta").put(ve._cfg.version, "version"));
              });
            }), (function ve() {
              return ce.length ? Ke.resolve(ce.shift()(fe.idbtrans)).then(ve) : Ke.resolve();
            })().then(function() {
              _y(_e, le);
            }));
          }).catch(q);
          var se, ye;
          s(z).forEach(function(ae) {
            hp(R, ae, z[ae].primKey, z[ae].indexes);
          }), As(k, R), Ke.follow(function() {
            return k.on.populate.fire($);
          }).catch(q);
        });
      }
      function Id(k, A) {
        _y(k._dbSchema, A), A.db.version % 10 != 0 || A.objectStoreNames.contains("$meta") || A.db.createObjectStore("$meta").add(Math.ceil(A.db.version / 10 - 1), "version");
        var R = bl(0, k.idbdb, A);
        Ld(k, k._dbSchema, A);
        for (var P = 0, z = jd(R, k._dbSchema).change; P < z.length; P++) {
          var $ = ((q) => {
            if (q.change.length || q.recreate) return console.warn("Unable to patch indexes of table ".concat(q.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var K = A.objectStore(q.name);
            q.add.forEach(function(se) {
              Rt && console.debug("Dexie upgrade patch: Creating missing index ".concat(q.name, ".").concat(se.src)), zd(K, se);
            });
          })(z[P]);
          if (typeof $ == "object") return $.value;
        }
      }
      function jd(k, A) {
        var R, P = { del: [], add: [], change: [] };
        for (R in k) A[R] || P.del.push(R);
        for (R in A) {
          var z = k[R], $ = A[R];
          if (z) {
            var q = { name: R, def: $, recreate: !1, del: [], add: [], change: [] };
            if ("" + (z.primKey.keyPath || "") != "" + ($.primKey.keyPath || "") || z.primKey.auto !== $.primKey.auto) q.recreate = !0, P.change.push(q);
            else {
              var K = z.idxByName, se = $.idxByName, ye = void 0;
              for (ye in K) se[ye] || q.del.push(ye);
              for (ye in se) {
                var ae = K[ye], oe = se[ye];
                ae ? ae.src !== oe.src && q.change.push(oe) : q.add.push(oe);
              }
              (0 < q.del.length || 0 < q.add.length || 0 < q.change.length) && P.change.push(q);
            }
          } else P.add.push([R, $]);
        }
        return P;
      }
      function hp(k, A, R, P) {
        var z = k.db.createObjectStore(A, R.keyPath ? { keyPath: R.keyPath, autoIncrement: R.auto } : { autoIncrement: R.auto });
        P.forEach(function($) {
          return zd(z, $);
        });
      }
      function _y(k, A) {
        s(k).forEach(function(R) {
          A.db.objectStoreNames.contains(R) || (Rt && console.debug("Dexie: Creating missing table", R), hp(A, R, k[R].primKey, k[R].indexes));
        });
      }
      function zd(k, A) {
        k.createIndex(A.name, A.keyPath, { unique: A.unique, multiEntry: A.multi });
      }
      function bl(k, A, R) {
        var P = {};
        return _(A.objectStoreNames, 0).forEach(function(z) {
          for (var $ = R.objectStore(z), q = Co(Od(ye = $.keyPath), ye || "", !0, !1, !!$.autoIncrement, ye && typeof ye != "string", !0), K = [], se = 0; se < $.indexNames.length; ++se) {
            var ae = $.index($.indexNames[se]), ye = ae.keyPath, ae = Co(ae.name, ye, !!ae.unique, !!ae.multiEntry, !1, ye && typeof ye != "string", !1);
            K.push(ae);
          }
          P[z] = gl(z, q, K);
        }), P;
      }
      function Ld(k, A, R) {
        for (var P = R.db.objectStoreNames, z = 0; z < P.length; ++z) {
          var $ = P[z], q = R.objectStore($);
          k._hasGetAll = "getAll" in q;
          for (var K = 0; K < q.indexNames.length; ++K) {
            var se, ye = q.indexNames[K], ae = q.index(ye).keyPath, ae = typeof ae == "string" ? ae : "[" + _(ae).join("+") + "]";
            A[$] && (se = A[$].idxByName[ae]) && (se.name = ye, delete A[$].idxByName[ae], A[$].idxByName[ye] = se);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (k._hasGetAll = !1);
      }
      function Ty(k) {
        return k.split(",").map(function(A, R) {
          var z = A.split(":"), P = (P = z[1]) == null ? void 0 : P.trim(), z = (A = z[0].trim()).replace(/([&*]|\+\+)/g, ""), $ = /^\[/.test(z) ? z.match(/^\[(.*)\]$/)[1].split("+") : z;
          return Co(z, $ || null, /\&/.test(A), /\*/.test(A), /\+\+/.test(A), a($), R === 0, P);
        });
      }
      xl.prototype._createTableSchema = gl, xl.prototype._parseIndexSyntax = Ty, xl.prototype._parseStoresSpec = function(k, A) {
        var R = this;
        s(k).forEach(function(P) {
          if (k[P] !== null) {
            var z = R._parseIndexSyntax(k[P]), $ = z.shift();
            if (!$) throw new Ae.Schema("Invalid schema for table " + P + ": " + k[P]);
            if ($.unique = !0, $.multi) throw new Ae.Schema("Primary key cannot be multiEntry*");
            z.forEach(function(q) {
              if (q.auto) throw new Ae.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!q.keyPath) throw new Ae.Schema("Index must have a name and cannot be an empty string");
            }), $ = R._createTableSchema(P, $, z), A[P] = $;
          }
        });
      }, xl.prototype.stores = function(R) {
        var A = this.db, R = (this._cfg.storesSource = this._cfg.storesSource ? c(this._cfg.storesSource, R) : R, A._versions), P = {}, z = {};
        return R.forEach(function($) {
          c(P, $._cfg.storesSource), z = $._cfg.dbschema = {}, $._parseStoresSpec(P, z);
        }), A._dbSchema = z, cu(A, [A._allTables, A, A.Transaction.prototype]), Dd(A, [A._allTables, A, A.Transaction.prototype, this._cfg.tables], s(z), z), A._storeNames = s(z), this;
      }, xl.prototype.upgrade = function(k) {
        return this._cfg.contentUpgrade = Mn(this._cfg.contentUpgrade || Ge, k), this;
      };
      var R1 = xl;
      function xl() {
      }
      function pp(k, A) {
        var R = k._dbNamesDB;
        return R || (R = k._dbNamesDB = new Eo(nu, { addons: [], indexedDB: k, IDBKeyRange: A })).version(1).stores({ dbnames: "name" }), R.table("dbnames");
      }
      function Bd(k) {
        return k && typeof k.databases == "function";
      }
      function mp(k) {
        return Rn(function() {
          return Ve.letThrough = !0, k();
        });
      }
      function gp(k) {
        return !("from" in k);
      }
      var Br = function(k, A) {
        var R;
        if (!this) return R = new Br(), k && "d" in k && c(R, k), R;
        c(this, arguments.length ? { d: 1, from: k, to: 1 < arguments.length ? A : k } : { d: 0 });
      };
      function du(k, A, R) {
        var P = It(A, R);
        if (!isNaN(P)) {
          if (0 < P) throw RangeError();
          if (gp(k)) return c(k, { from: A, to: R, d: 1 });
          var P = k.l, z = k.r;
          if (It(R, k.from) < 0) return P ? du(P, A, R) : k.l = { from: A, to: R, d: 1, l: null, r: null }, My(k);
          if (0 < It(A, k.to)) return z ? du(z, A, R) : k.r = { from: A, to: R, d: 1, l: null, r: null }, My(k);
          It(A, k.from) < 0 && (k.from = A, k.l = null, k.d = z ? z.d + 1 : 1), 0 < It(R, k.to) && (k.to = R, k.r = null, k.d = k.l ? k.l.d + 1 : 1), A = !k.r, P && !k.l && va(k, P), z && A && va(k, z);
        }
      }
      function va(k, A) {
        gp(A) || (function R(P, z) {
          var $ = z.from, q = z.l, K = z.r;
          du(P, $, z.to), q && R(P, q), K && R(P, K);
        })(k, A);
      }
      function Ay(k, A) {
        var R = $d(A), P = R.next();
        if (!P.done) for (var z = P.value, $ = $d(k), q = $.next(z.from), K = q.value; !P.done && !q.done; ) {
          if (It(K.from, z.to) <= 0 && 0 <= It(K.to, z.from)) return !0;
          It(z.from, K.from) < 0 ? z = (P = R.next(K.from)).value : K = (q = $.next(z.from)).value;
        }
        return !1;
      }
      function $d(k) {
        var A = gp(k) ? null : { s: 0, n: k };
        return { next: function(R) {
          for (var P = 0 < arguments.length; A; ) switch (A.s) {
            case 0:
              if (A.s = 1, P) for (; A.n.l && It(R, A.n.from) < 0; ) A = { up: A, n: A.n.l, s: 1 };
              else for (; A.n.l; ) A = { up: A, n: A.n.l, s: 1 };
            case 1:
              if (A.s = 2, !P || It(R, A.n.to) <= 0) return { value: A.n, done: !1 };
            case 2:
              if (A.n.r) {
                A.s = 3, A = { up: A, n: A.n.r, s: 0 };
                continue;
              }
            case 3:
              A = A.up;
          }
          return { done: !0 };
        } };
      }
      function My(k) {
        var A, R, P, z = (((z = k.r) == null ? void 0 : z.d) || 0) - (((z = k.l) == null ? void 0 : z.d) || 0), z = 1 < z ? "r" : z < -1 ? "l" : "";
        z && (A = z == "r" ? "l" : "r", R = r({}, k), P = k[z], k.from = P.from, k.to = P.to, k[z] = P[z], R[z] = P[A], (k[A] = R).d = yp(R)), k.d = yp(k);
      }
      function yp(R) {
        var A = R.r, R = R.l;
        return (A ? R ? Math.max(A.d, R.d) : A.d : R ? R.d : 0) + 1;
      }
      function Ud(k, A) {
        return s(A).forEach(function(R) {
          k[R] ? va(k[R], A[R]) : k[R] = (function P(z) {
            var $, q, K = {};
            for ($ in z) h(z, $) && (q = z[$], K[$] = !q || typeof q != "object" || G.has(q.constructor) ? q : P(q));
            return K;
          })(A[R]);
        }), k;
      }
      function vp(k, A) {
        return k.all || A.all || Object.keys(k).some(function(R) {
          return A[R] && Ay(A[R], k[R]);
        });
      }
      m(Br.prototype, ((ke = { add: function(k) {
        return va(this, k), this;
      }, addKey: function(k) {
        return du(this, k, k), this;
      }, addKeys: function(k) {
        var A = this;
        return k.forEach(function(R) {
          return du(A, R, R);
        }), this;
      }, hasKey: function(k) {
        var A = $d(this).next(k).value;
        return A && It(A.from, k) <= 0 && 0 <= It(A.to, k);
      } })[H] = function() {
        return $d(this);
      }, ke));
      var ba = {}, bp = {}, xp = !1;
      function Fd(k) {
        Ud(bp, k), xp || (xp = !0, setTimeout(function() {
          xp = !1, wp(bp, !(bp = {}));
        }, 0));
      }
      function wp(k, A) {
        A === void 0 && (A = !1);
        var R = /* @__PURE__ */ new Set();
        if (k.all) for (var P = 0, z = Object.values(ba); P < z.length; P++) Ny(K = z[P], k, R, A);
        else for (var $ in k) {
          var q, K, $ = /^idb\:\/\/(.*)\/(.*)\//.exec($);
          $ && (q = $[1], $ = $[2], K = ba["idb://".concat(q, "/").concat($)]) && Ny(K, k, R, A);
        }
        R.forEach(function(se) {
          return se();
        });
      }
      function Ny(k, A, R, P) {
        for (var z = [], $ = 0, q = Object.entries(k.queries.query); $ < q.length; $++) {
          for (var K = q[$], se = K[0], ye = [], ae = 0, oe = K[1]; ae < oe.length; ae++) {
            var ue = oe[ae];
            vp(A, ue.obsSet) ? ue.subscribers.forEach(function(we) {
              return R.add(we);
            }) : P && ye.push(ue);
          }
          P && z.push([se, ye]);
        }
        if (P) for (var fe = 0, le = z; fe < le.length; fe++) {
          var ce = le[fe], se = ce[0], ye = ce[1];
          k.queries.query[se] = ye;
        }
      }
      function O1(k) {
        var A = k._state, R = k._deps.indexedDB;
        if (A.isBeingOpened || k.idbdb) return A.dbReadyPromise.then(function() {
          return A.dbOpenError ? bn(A.dbOpenError) : k;
        });
        A.isBeingOpened = !0, A.dbOpenError = null, A.openComplete = !1;
        var P = A.openCanceller, z = Math.round(10 * k.verno), $ = !1;
        function q() {
          if (A.openCanceller !== P) throw new Ae.DatabaseClosed("db.open() was cancelled");
        }
        function K() {
          return new Ke(function(ue, fe) {
            if (q(), !R) throw new Ae.MissingAPI();
            var le = k.name, ce = A.autoSchema || !z ? R.open(le) : R.open(le, z);
            if (!ce) throw new Ae.MissingAPI();
            ce.onerror = no(fe), ce.onblocked = Cn(k._fireOnBlocked), ce.onupgradeneeded = Cn(function(we) {
              var _e;
              ae = ce.transaction, A.autoSchema && !k._options.allowEmptyDB ? (ce.onerror = ma, ae.abort(), ce.result.close(), (_e = R.deleteDatabase(le)).onsuccess = _e.onerror = Cn(function() {
                fe(new Ae.NoSuchDatabase("Database ".concat(le, " doesnt exist")));
              })) : (ae.onerror = no(fe), _e = we.oldVersion > Math.pow(2, 62) ? 0 : we.oldVersion, oe = _e < 1, k.idbdb = ce.result, $ && Id(k, ae), uu(k, _e / 10, ae, fe));
            }, fe), ce.onsuccess = Cn(function() {
              ae = null;
              var we, _e, ve, Re, ze, We, qe = k.idbdb = ce.result, Le = _(qe.objectStoreNames);
              if (0 < Le.length) try {
                var Xe = qe.transaction((ze = Le).length === 1 ? ze[0] : ze, "readonly");
                if (A.autoSchema) We = qe, Re = Xe, (ve = k).verno = We.version / 10, Re = ve._dbSchema = bl(0, We, Re), ve._storeNames = _(We.objectStoreNames, 0), Dd(ve, [ve._allTables], s(Re), Re);
                else if (Ld(k, k._dbSchema, Xe), _e = Xe, ((_e = jd(bl(0, (we = k).idbdb, _e), we._dbSchema)).add.length || _e.change.some(function(Ze) {
                  return Ze.add.length || Ze.change.length;
                })) && !$) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), qe.close(), z = qe.version + 1, $ = !0, ue(K());
                As(k, Xe);
              } catch {
              }
              da.push(k), qe.onversionchange = Cn(function(Ze) {
                A.vcFired = !0, k.on("versionchange").fire(Ze);
              }), qe.onclose = Cn(function() {
                k.close({ disableAutoOpen: !1 });
              }), oe && (Le = k._deps, ze = le, Bd(We = Le.indexedDB) || ze === nu || pp(We, Le.IDBKeyRange).put({ name: ze }).catch(Ge)), ue();
            }, fe);
          }).catch(function(ue) {
            switch (ue?.name) {
              case "UnknownError":
                if (0 < A.PR1398_maxLoop) return A.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), K();
                break;
              case "VersionError":
                if (0 < z) return z = 0, K();
            }
            return Ke.reject(ue);
          });
        }
        var se, ye = A.dbReadyResolve, ae = null, oe = !1;
        return Ke.race([P, (typeof navigator > "u" ? Ke.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(ue) {
          function fe() {
            return indexedDB.databases().finally(ue);
          }
          se = setInterval(fe, 100), fe();
        }).finally(function() {
          return clearInterval(se);
        }) : Promise.resolve()).then(K)]).then(function() {
          return q(), A.onReadyBeingFired = [], Ke.resolve(mp(function() {
            return k.on.ready.fire(k.vip);
          })).then(function ue() {
            var fe;
            if (0 < A.onReadyBeingFired.length) return fe = A.onReadyBeingFired.reduce(Mn, Ge), A.onReadyBeingFired = [], Ke.resolve(mp(function() {
              return fe(k.vip);
            })).then(ue);
          });
        }).finally(function() {
          A.openCanceller === P && (A.onReadyBeingFired = null, A.isBeingOpened = !1);
        }).catch(function(ue) {
          A.dbOpenError = ue;
          try {
            ae && ae.abort();
          } catch {
          }
          return P === A.openCanceller && k._close(), bn(ue);
        }).finally(function() {
          A.openComplete = !0, ye();
        }).then(function() {
          var ue;
          return oe && (ue = {}, k.tables.forEach(function(fe) {
            fe.schema.indexes.forEach(function(le) {
              le.name && (ue["idb://".concat(k.name, "/").concat(fe.name, "/").concat(le.name)] = new Br(-1 / 0, [[[]]]));
            }), ue["idb://".concat(k.name, "/").concat(fe.name, "/")] = ue["idb://".concat(k.name, "/").concat(fe.name, "/:dels")] = new Br(-1 / 0, [[[]]]);
          }), Lr(ml).fire(ue), wp(ue, !0)), k;
        });
      }
      function fu(k) {
        function A($) {
          return k.next($);
        }
        var R = z(A), P = z(function($) {
          return k.throw($);
        });
        function z($) {
          return function(K) {
            var K = $(K), se = K.value;
            return K.done ? se : se && typeof se.then == "function" ? se.then(R, P) : a(se) ? Promise.all(se).then(R, P) : R(se);
          };
        }
        return z(A)();
      }
      function Ms(k, A, R) {
        for (var P = a(k) ? k.slice() : [k], z = 0; z < R; ++z) P.push(A);
        return P;
      }
      var P1 = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(k) {
        return r(r({}, k), { table: function(P) {
          var R = k.table(P), P = R.schema, z = {}, $ = [];
          function q(ue, fe, le) {
            var ve = mr(ue), ce = z[ve] = z[ve] || [], we = ue == null ? 0 : typeof ue == "string" ? 1 : ue.length, _e = 0 < fe, ve = r(r({}, le), { name: _e ? "".concat(ve, "(virtual-from:").concat(le.name, ")") : le.name, lowLevelIndex: le, isVirtual: _e, keyTail: fe, keyLength: we, extractKey: vl(ue), unique: !_e && le.unique });
            return ce.push(ve), ve.isPrimaryKey || $.push(ve), 1 < we && q(we === 2 ? ue[0] : ue.slice(0, we - 1), fe + 1, le), ce.sort(function(Re, ze) {
              return Re.keyTail - ze.keyTail;
            }), ve;
          }
          var K = q(P.primaryKey.keyPath, 0, P.primaryKey);
          z[":id"] = [K];
          for (var se = 0, ye = P.indexes; se < ye.length; se++) {
            var ae = ye[se];
            q(ae.keyPath, 0, ae);
          }
          function oe(ue) {
            var fe, le = ue.query.index;
            return le.isVirtual ? r(r({}, ue), { query: { index: le.lowLevelIndex, range: (fe = ue.query.range, le = le.keyTail, { type: fe.type === 1 ? 2 : fe.type, lower: Ms(fe.lower, fe.lowerOpen ? k.MAX_KEY : k.MIN_KEY, le), lowerOpen: !0, upper: Ms(fe.upper, fe.upperOpen ? k.MIN_KEY : k.MAX_KEY, le), upperOpen: !0 }) } }) : ue;
          }
          return r(r({}, R), { schema: r(r({}, P), { primaryKey: K, indexes: $, getIndexByKeyPath: function(ue) {
            return (ue = z[mr(ue)]) && ue[0];
          } }), count: function(ue) {
            return R.count(oe(ue));
          }, query: function(ue) {
            return R.query(oe(ue));
          }, openCursor: function(ue) {
            var fe = ue.query.index, le = fe.keyTail, ce = fe.keyLength;
            return fe.isVirtual ? R.openCursor(oe(ue)).then(function(_e) {
              return _e && we(_e);
            }) : R.openCursor(ue);
            function we(_e) {
              return Object.create(_e, { continue: { value: function(ve) {
                ve != null ? _e.continue(Ms(ve, ue.reverse ? k.MAX_KEY : k.MIN_KEY, le)) : ue.unique ? _e.continue(_e.key.slice(0, ce).concat(ue.reverse ? k.MIN_KEY : k.MAX_KEY, le)) : _e.continue();
              } }, continuePrimaryKey: { value: function(ve, Re) {
                _e.continuePrimaryKey(Ms(ve, k.MAX_KEY, le), Re);
              } }, primaryKey: { get: function() {
                return _e.primaryKey;
              } }, key: { get: function() {
                var ve = _e.key;
                return ce === 1 ? ve[0] : ve.slice(0, ce);
              } }, value: { get: function() {
                return _e.value;
              } } });
            }
          } });
        } });
      } };
      function Vd(k, A, R, P) {
        return R = R || {}, P = P || "", s(k).forEach(function(z) {
          var $, q, K;
          h(A, z) ? ($ = k[z], q = A[z], typeof $ == "object" && typeof q == "object" && $ && q ? (K = ne($)) !== ne(q) ? R[P + z] = A[z] : K === "Object" ? Vd($, q, R, P + z + ".") : $ !== q && (R[P + z] = A[z]) : $ !== q && (R[P + z] = A[z])) : R[P + z] = void 0;
        }), s(A).forEach(function(z) {
          h(k, z) || (R[P + z] = A[z]);
        }), R;
      }
      function Hd(k, A) {
        return A.type === "delete" ? A.keys : A.keys || A.values.map(k.extractKey);
      }
      var Ry = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(k) {
        return r(r({}, k), { table: function(A) {
          var R = k.table(A), P = R.schema.primaryKey;
          return r(r({}, R), { mutate: function(z) {
            var $ = Ve.trans, q = $.table(A).hook, K = q.deleting, se = q.creating, ye = q.updating;
            switch (z.type) {
              case "add":
                if (se.fire === Ge) break;
                return $._promise("readwrite", function() {
                  return ae(z);
                }, !0);
              case "put":
                if (se.fire === Ge && ye.fire === Ge) break;
                return $._promise("readwrite", function() {
                  return ae(z);
                }, !0);
              case "delete":
                if (K.fire === Ge) break;
                return $._promise("readwrite", function() {
                  return ae(z);
                }, !0);
              case "deleteRange":
                if (K.fire === Ge) break;
                return $._promise("readwrite", function() {
                  return (function oe(ue, fe, le) {
                    return R.query({ trans: ue, values: !1, query: { index: P, range: fe }, limit: le }).then(function(ce) {
                      var we = ce.result;
                      return ae({ type: "delete", keys: we, trans: ue }).then(function(_e) {
                        return 0 < _e.numFailures ? Promise.reject(_e.failures[0]) : we.length < le ? { failures: [], numFailures: 0, lastResult: void 0 } : oe(ue, r(r({}, fe), { lower: we[we.length - 1], lowerOpen: !0 }), le);
                      });
                    });
                  })(z.trans, z.range, 1e4);
                }, !0);
            }
            return R.mutate(z);
            function ae(oe) {
              var ue, fe, le, ce = Ve.trans, we = oe.keys || Hd(P, oe);
              if (we) return (oe = oe.type === "add" || oe.type === "put" ? r(r({}, oe), { keys: we }) : r({}, oe)).type !== "delete" && (oe.values = i([], oe.values)), oe.keys && (oe.keys = i([], oe.keys)), ue = R, le = we, ((fe = oe).type === "add" ? Promise.resolve([]) : ue.getMany({ trans: fe.trans, keys: le, cache: "immutable" })).then(function(_e) {
                var ve = we.map(function(Re, ze) {
                  var We, qe, Le, Xe = _e[ze], Ze = { onerror: null, onsuccess: null };
                  return oe.type === "delete" ? K.fire.call(Ze, Re, Xe, ce) : oe.type === "add" || Xe === void 0 ? (We = se.fire.call(Ze, Re, oe.values[ze], ce), Re == null && We != null && (oe.keys[ze] = Re = We, P.outbound || O(oe.values[ze], P.keyPath, Re))) : (We = Vd(Xe, oe.values[ze]), (qe = ye.fire.call(Ze, We, Re, Xe, ce)) && (Le = oe.values[ze], Object.keys(qe).forEach(function(Be) {
                    h(Le, Be) ? Le[Be] = qe[Be] : O(Le, Be, qe[Be]);
                  }))), Ze;
                });
                return R.mutate(oe).then(function(Re) {
                  for (var ze = Re.failures, We = Re.results, qe = Re.numFailures, Re = Re.lastResult, Le = 0; Le < we.length; ++Le) {
                    var Xe = (We || we)[Le], Ze = ve[Le];
                    Xe == null ? Ze.onerror && Ze.onerror(ze[Le]) : Ze.onsuccess && Ze.onsuccess(oe.type === "put" && _e[Le] ? oe.values[Le] : Xe);
                  }
                  return { failures: ze, results: We, numFailures: qe, lastResult: Re };
                }).catch(function(Re) {
                  return ve.forEach(function(ze) {
                    return ze.onerror && ze.onerror(Re);
                  }), Promise.reject(Re);
                });
              });
              throw new Error("Keys missing");
            }
          } });
        } });
      } };
      function Sp(k, A, R) {
        try {
          if (!A || A.keys.length < k.length) return null;
          for (var P = [], z = 0, $ = 0; z < A.keys.length && $ < k.length; ++z) It(A.keys[z], k[$]) === 0 && (P.push(R ? he(A.values[z]) : A.values[z]), ++$);
          return P.length === k.length ? P : null;
        } catch {
          return null;
        }
      }
      var Oy = { stack: "dbcore", level: -1, create: function(k) {
        return { table: function(A) {
          var R = k.table(A);
          return r(r({}, R), { getMany: function(P) {
            var z;
            return P.cache ? (z = Sp(P.keys, P.trans._cache, P.cache === "clone")) ? Ke.resolve(z) : R.getMany(P).then(function($) {
              return P.trans._cache = { keys: P.keys, values: P.cache === "clone" ? he($) : $ }, $;
            }) : R.getMany(P);
          }, mutate: function(P) {
            return P.type !== "add" && (P.trans._cache = null), R.mutate(P);
          } });
        } };
      } };
      function xa(k, A) {
        return k.trans.mode === "readonly" && !!k.subscr && !k.trans.explicit && k.trans.db._options.cache !== "disabled" && !A.schema.primaryKey.outbound;
      }
      function Py(k, A) {
        switch (k) {
          case "query":
            return A.values && !A.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var D1 = { stack: "dbcore", level: 0, name: "Observability", create: function(k) {
        var A = k.schema.name, R = new Br(k.MIN_KEY, k.MAX_KEY);
        return r(r({}, k), { transaction: function(P, z, $) {
          if (Ve.subscr && z !== "readonly") throw new Ae.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(Ve.querier));
          return k.transaction(P, z, $);
        }, table: function(P) {
          function z(we) {
            var ce, we = we.query;
            return [ce = we.index, new Br((ce = (we = we.range).lower) != null ? ce : k.MIN_KEY, (ce = we.upper) != null ? ce : k.MAX_KEY)];
          }
          var $ = k.table(P), q = $.schema, K = q.primaryKey, se = q.indexes, ye = K.extractKey, ae = K.outbound, oe = K.autoIncrement && se.filter(function(le) {
            return le.compound && le.keyPath.includes(K.keyPath);
          }), ue = r(r({}, $), { mutate: function(le) {
            function ce(Je) {
              return Je = "idb://".concat(A, "/").concat(P, "/").concat(Je), ze[Je] || (ze[Je] = new Br());
            }
            var we, _e, ve, Re = le.trans, ze = le.mutatedParts || (le.mutatedParts = {}), We = ce(""), qe = ce(":dels"), Le = le.type, Ze = le.type === "deleteRange" ? [le.range] : le.type === "delete" ? [le.keys] : le.values.length < 50 ? [Hd(K, le).filter(function(Je) {
              return Je;
            }), le.values] : [], Xe = Ze[0], Ze = Ze[1], Be = le.trans._cache;
            return a(Xe) ? (We.addKeys(Xe), (Le = Le === "delete" || Xe.length === Ze.length ? Sp(Xe, Be) : null) || qe.addKeys(Xe), (Le || Ze) && (we = ce, _e = Le, ve = Ze, q.indexes.forEach(function(Je) {
              var St = we(Je.name || "");
              function $t(At) {
                return At != null ? Je.extractKey(At) : null;
              }
              function ft(At) {
                Je.multiEntry && a(At) ? At.forEach(function(xn) {
                  return St.addKey(xn);
                }) : St.addKey(At);
              }
              (_e || ve).forEach(function(At, dn) {
                var hi = _e && $t(_e[dn]), dn = ve && $t(ve[dn]);
                It(hi, dn) !== 0 && (hi != null && ft(hi), dn != null) && ft(dn);
              });
            }))) : Xe ? (Ze = { from: (Be = Xe.lower) != null ? Be : k.MIN_KEY, to: (Le = Xe.upper) != null ? Le : k.MAX_KEY }, qe.add(Ze), We.add(Ze)) : (We.add(R), qe.add(R), q.indexes.forEach(function(Je) {
              return ce(Je.name).add(R);
            })), $.mutate(le).then(function(Je) {
              return !Xe || le.type !== "add" && le.type !== "put" || (We.addKeys(Je.results), oe && oe.forEach(function(St) {
                for (var $t = le.values.map(function(hi) {
                  return St.extractKey(hi);
                }), ft = St.keyPath.findIndex(function(hi) {
                  return hi === K.keyPath;
                }), At = 0, xn = Je.results.length; At < xn; ++At) $t[At][ft] = Je.results[At];
                ce(St.name).addKeys($t);
              })), Re.mutatedParts = Ud(Re.mutatedParts || {}, ze), Je;
            });
          } }), fe = { get: function(le) {
            return [K, new Br(le.key)];
          }, getMany: function(le) {
            return [K, new Br().addKeys(le.keys)];
          }, count: z, query: z, openCursor: z };
          return s(fe).forEach(function(le) {
            ue[le] = function(ce) {
              var we = Ve.subscr, _e = !!we, ve = xa(Ve, $) && Py(le, ce) ? ce.obsSet = {} : we;
              if (_e) {
                var Re, we = function(Ze) {
                  return Ze = "idb://".concat(A, "/").concat(P, "/").concat(Ze), ve[Ze] || (ve[Ze] = new Br());
                }, ze = we(""), We = we(":dels"), _e = fe[le](ce), qe = _e[0], _e = _e[1];
                if ((le === "query" && qe.isPrimaryKey && !ce.values ? We : we(qe.name || "")).add(_e), !qe.isPrimaryKey) {
                  if (le !== "count") return Re = le === "query" && ae && ce.values && $.query(r(r({}, ce), { values: !1 })), $[le].apply(this, arguments).then(function(Ze) {
                    if (le === "query") {
                      if (ae && ce.values) return Re.then(function($t) {
                        return $t = $t.result, ze.addKeys($t), Ze;
                      });
                      var Be = ce.values ? Ze.result.map(ye) : Ze.result;
                      (ce.values ? ze : We).addKeys(Be);
                    } else {
                      var Je, St;
                      if (le === "openCursor") return St = ce.values, (Je = Ze) && Object.create(Je, { key: { get: function() {
                        return We.addKey(Je.primaryKey), Je.key;
                      } }, primaryKey: { get: function() {
                        var $t = Je.primaryKey;
                        return We.addKey($t), $t;
                      } }, value: { get: function() {
                        return St && ze.addKey(Je.primaryKey), Je.value;
                      } } });
                    }
                    return Ze;
                  });
                  We.add(R);
                }
              }
              return $[le].apply(this, arguments);
            };
          }), ue;
        } });
      } };
      function Dy(k, A, R) {
        var P;
        return R.numFailures === 0 ? A : A.type === "deleteRange" || (P = A.keys ? A.keys.length : "values" in A && A.values ? A.values.length : 1, R.numFailures === P) ? null : (P = r({}, A), a(P.keys) && (P.keys = P.keys.filter(function(z, $) {
          return !($ in R.failures);
        })), "values" in P && a(P.values) && (P.values = P.values.filter(function(z, $) {
          return !($ in R.failures);
        })), P);
      }
      function Wd(k, A) {
        return R = k, ((P = A).lower === void 0 || (P.lowerOpen ? 0 < It(R, P.lower) : 0 <= It(R, P.lower))) && (R = k, (P = A).upper === void 0 || (P.upperOpen ? It(R, P.upper) < 0 : It(R, P.upper) <= 0));
        var R, P;
      }
      function kp(k, A, R, P, z, $) {
        var q, K, se, ye, ae, oe;
        return !R || R.length === 0 || (q = A.query.index, K = q.multiEntry, se = A.query.range, ye = P.schema.primaryKey.extractKey, ae = q.extractKey, oe = (q.lowLevelIndex || q).extractKey, (P = R.reduce(function(ue, fe) {
          var le = ue, ce = [];
          if (fe.type === "add" || fe.type === "put") for (var we = new Br(), _e = fe.values.length - 1; 0 <= _e; --_e) {
            var ve, Re = fe.values[_e], ze = ye(Re);
            !we.hasKey(ze) && (ve = ae(Re), K && a(ve) ? ve.some(function(Ze) {
              return Wd(Ze, se);
            }) : Wd(ve, se)) && (we.addKey(ze), ce.push(Re));
          }
          switch (fe.type) {
            case "add":
              var We = new Br().addKeys(A.values ? ue.map(function(Be) {
                return ye(Be);
              }) : ue), le = ue.concat(A.values ? ce.filter(function(Be) {
                return Be = ye(Be), !We.hasKey(Be) && (We.addKey(Be), !0);
              }) : ce.map(function(Be) {
                return ye(Be);
              }).filter(function(Be) {
                return !We.hasKey(Be) && (We.addKey(Be), !0);
              }));
              break;
            case "put":
              var qe = new Br().addKeys(fe.values.map(function(Be) {
                return ye(Be);
              }));
              le = ue.filter(function(Be) {
                return !qe.hasKey(A.values ? ye(Be) : Be);
              }).concat(A.values ? ce : ce.map(function(Be) {
                return ye(Be);
              }));
              break;
            case "delete":
              var Le = new Br().addKeys(fe.keys);
              le = ue.filter(function(Be) {
                return !Le.hasKey(A.values ? ye(Be) : Be);
              });
              break;
            case "deleteRange":
              var Xe = fe.range;
              le = ue.filter(function(Be) {
                return !Wd(ye(Be), Xe);
              });
          }
          return le;
        }, k)) === k) ? k : (P.sort(function(ue, fe) {
          return It(oe(ue), oe(fe)) || It(ye(ue), ye(fe));
        }), A.limit && A.limit < 1 / 0 && (P.length > A.limit ? P.length = A.limit : k.length === A.limit && P.length < A.limit && (z.dirty = !0)), $ ? Object.freeze(P) : P);
      }
      function wl(k, A) {
        return It(k.lower, A.lower) === 0 && It(k.upper, A.upper) === 0 && !!k.lowerOpen == !!A.lowerOpen && !!k.upperOpen == !!A.upperOpen;
      }
      function hu(k, A) {
        return ((R, P, z, $) => {
          if (R === void 0) return P !== void 0 ? -1 : 0;
          if (P === void 0) return 1;
          if ((R = It(R, P)) === 0) {
            if (z && $) return 0;
            if (z) return 1;
            if ($) return -1;
          }
          return R;
        })(k.lower, A.lower, k.lowerOpen, A.lowerOpen) <= 0 && 0 <= ((R, P, z, $) => {
          if (R === void 0) return P !== void 0 ? 1 : 0;
          if (P === void 0) return -1;
          if ((R = It(R, P)) === 0) {
            if (z && $) return 0;
            if (z) return -1;
            if ($) return 1;
          }
          return R;
        })(k.upper, A.upper, k.upperOpen, A.upperOpen);
      }
      function I1(k, A, R, P) {
        k.subscribers.add(R), P.addEventListener("abort", function() {
          var z, $;
          k.subscribers.delete(R), k.subscribers.size === 0 && (z = k, $ = A, setTimeout(function() {
            z.subscribers.size === 0 && X($, z);
          }, 3e3));
        });
      }
      var qd = { stack: "dbcore", level: 0, name: "Cache", create: function(k) {
        var A = k.schema.name;
        return r(r({}, k), { transaction: function(R, P, z) {
          var $, q, K = k.transaction(R, P, z);
          return P === "readwrite" && (z = ($ = new AbortController()).signal, K.addEventListener("abort", (q = function(se) {
            return function() {
              if ($.abort(), P === "readwrite") {
                for (var ye = /* @__PURE__ */ new Set(), ae = 0, oe = R; ae < oe.length; ae++) {
                  var ue = oe[ae], fe = ba["idb://".concat(A, "/").concat(ue)];
                  if (fe) {
                    var le = k.table(ue), ce = fe.optimisticOps.filter(function(Je) {
                      return Je.trans === K;
                    });
                    if (K._explicit && se && K.mutatedParts) for (var we = 0, _e = Object.values(fe.queries.query); we < _e.length; we++) for (var ve = 0, Re = (qe = _e[we]).slice(); ve < Re.length; ve++) vp((Le = Re[ve]).obsSet, K.mutatedParts) && (X(qe, Le), Le.subscribers.forEach(function(Je) {
                      return ye.add(Je);
                    }));
                    else if (0 < ce.length) {
                      fe.optimisticOps = fe.optimisticOps.filter(function(Je) {
                        return Je.trans !== K;
                      });
                      for (var ze = 0, We = Object.values(fe.queries.query); ze < We.length; ze++) for (var qe, Le, Xe, Ze = 0, Be = (qe = We[ze]).slice(); Ze < Be.length; Ze++) (Le = Be[Ze]).res != null && K.mutatedParts && (se && !Le.dirty ? (Xe = Object.isFrozen(Le.res), Xe = kp(Le.res, Le.req, ce, le, Le, Xe), Le.dirty ? (X(qe, Le), Le.subscribers.forEach(function(Je) {
                        return ye.add(Je);
                      })) : Xe !== Le.res && (Le.res = Xe, Le.promise = Ke.resolve({ result: Xe }))) : (Le.dirty && X(qe, Le), Le.subscribers.forEach(function(Je) {
                        return ye.add(Je);
                      })));
                    }
                  }
                }
                ye.forEach(function(Je) {
                  return Je();
                });
              }
            };
          })(!1), { signal: z }), K.addEventListener("error", q(!1), { signal: z }), K.addEventListener("complete", q(!0), { signal: z })), K;
        }, table: function(R) {
          var P = k.table(R), z = P.schema.primaryKey;
          return r(r({}, P), { mutate: function($) {
            var q, K = Ve.trans;
            return !z.outbound && K.db._options.cache !== "disabled" && !K.explicit && K.idbtrans.mode === "readwrite" && (q = ba["idb://".concat(A, "/").concat(R)]) ? (K = P.mutate($), $.type !== "add" && $.type !== "put" || !(50 <= $.values.length || Hd(z, $).some(function(se) {
              return se == null;
            })) ? (q.optimisticOps.push($), $.mutatedParts && Fd($.mutatedParts), K.then(function(se) {
              0 < se.numFailures && (X(q.optimisticOps, $), (se = Dy(0, $, se)) && q.optimisticOps.push(se), $.mutatedParts) && Fd($.mutatedParts);
            }), K.catch(function() {
              X(q.optimisticOps, $), $.mutatedParts && Fd($.mutatedParts);
            })) : K.then(function(se) {
              var ye = Dy(0, r(r({}, $), { values: $.values.map(function(ae, oe) {
                var ue;
                return se.failures[oe] ? ae : (O(ue = (ue = z.keyPath) != null && ue.includes(".") ? he(ae) : r({}, ae), z.keyPath, se.results[oe]), ue);
              }) }), se);
              q.optimisticOps.push(ye), queueMicrotask(function() {
                return $.mutatedParts && Fd($.mutatedParts);
              });
            }), K) : P.mutate($);
          }, query: function($) {
            var q, K, se, ye, ae, oe, ue;
            return xa(Ve, P) && Py("query", $) ? (q = ((se = Ve.trans) == null ? void 0 : se.db._options.cache) === "immutable", K = (se = Ve).requery, se = se.signal, oe = ((fe, le, ce, we) => {
              var _e = ba["idb://".concat(fe, "/").concat(le)];
              if (!_e) return [];
              if (!(fe = _e.queries[ce])) return [null, !1, _e, null];
              var ve = fe[(we.query ? we.query.index.name : null) || ""];
              if (!ve) return [null, !1, _e, null];
              switch (ce) {
                case "query":
                  var Re = ve.find(function(ze) {
                    return ze.req.limit === we.limit && ze.req.values === we.values && wl(ze.req.query.range, we.query.range);
                  });
                  return Re ? [Re, !0, _e, ve] : [ve.find(function(ze) {
                    return ("limit" in ze.req ? ze.req.limit : 1 / 0) >= we.limit && (!we.values || ze.req.values) && hu(ze.req.query.range, we.query.range);
                  }), !1, _e, ve];
                case "count":
                  return Re = ve.find(function(ze) {
                    return wl(ze.req.query.range, we.query.range);
                  }), [Re, !!Re, _e, ve];
              }
            })(A, R, "query", $), ue = oe[0], ye = oe[2], ae = oe[3], ue && oe[1] ? ue.obsSet = $.obsSet : (oe = P.query($).then(function(fe) {
              var le = fe.result;
              if (ue && (ue.res = le), q) {
                for (var ce = 0, we = le.length; ce < we; ++ce) Object.freeze(le[ce]);
                Object.freeze(le);
              } else fe.result = he(le);
              return fe;
            }).catch(function(fe) {
              return ae && ue && X(ae, ue), Promise.reject(fe);
            }), ue = { obsSet: $.obsSet, promise: oe, subscribers: /* @__PURE__ */ new Set(), type: "query", req: $, dirty: !1 }, ae ? ae.push(ue) : (ae = [ue], (ye = ye || (ba["idb://".concat(A, "/").concat(R)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[$.query.index.name || ""] = ae)), I1(ue, ae, K, se), ue.promise.then(function(fe) {
              return { result: kp(fe.result, $, ye?.optimisticOps, P, ue, q) };
            })) : P.query($);
          } });
        } });
      } };
      function pu(k, A) {
        return new Proxy(k, { get: function(R, P, z) {
          return P === "db" ? A : Reflect.get(R, P, z);
        } });
      }
      Ln.prototype.version = function(k) {
        if (isNaN(k) || k < 0.1) throw new Ae.Type("Given version is not a positive number");
        if (k = Math.round(10 * k) / 10, this.idbdb || this._state.isBeingOpened) throw new Ae.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, k);
        var A = this._versions, R = A.filter(function(P) {
          return P._cfg.version === k;
        })[0];
        return R || (R = new this.Version(k), A.push(R), A.sort(fp), R.stores({}), this._state.autoSchema = !1), R;
      }, Ln.prototype._whenReady = function(k) {
        var A = this;
        return this.idbdb && (this._state.openComplete || Ve.letThrough || this._vip) ? k() : new Ke(function(R, P) {
          if (A._state.openComplete) return P(new Ae.DatabaseClosed(A._state.dbOpenError));
          if (!A._state.isBeingOpened) {
            if (!A._state.autoOpen) return void P(new Ae.DatabaseClosed());
            A.open().catch(Ge);
          }
          A._state.dbReadyPromise.then(R, P);
        }).then(k);
      }, Ln.prototype.use = function(z) {
        var A = z.stack, R = z.create, P = z.level, z = z.name, $ = (z && this.unuse({ stack: A, name: z }), this._middlewares[A] || (this._middlewares[A] = []));
        return $.push({ stack: A, create: R, level: P ?? 10, name: z }), $.sort(function(q, K) {
          return q.level - K.level;
        }), this;
      }, Ln.prototype.unuse = function(k) {
        var A = k.stack, R = k.name, P = k.create;
        return A && this._middlewares[A] && (this._middlewares[A] = this._middlewares[A].filter(function(z) {
          return P ? z.create !== P : !!R && z.name !== R;
        })), this;
      }, Ln.prototype.open = function() {
        var k = this;
        return eo(jn, function() {
          return O1(k);
        });
      }, Ln.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var k = this._state, A = da.indexOf(this);
        if (0 <= A && da.splice(A, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        k.isBeingOpened || (k.dbReadyPromise = new Ke(function(R) {
          k.dbReadyResolve = R;
        }), k.openCanceller = new Ke(function(R, P) {
          k.cancelOpen = P;
        }));
      }, Ln.prototype.close = function(A) {
        var A = (A === void 0 ? { disableAutoOpen: !0 } : A).disableAutoOpen, R = this._state;
        A ? (R.isBeingOpened && R.cancelOpen(new Ae.DatabaseClosed()), this._close(), R.autoOpen = !1, R.dbOpenError = new Ae.DatabaseClosed()) : (this._close(), R.autoOpen = this._options.autoOpen || R.isBeingOpened, R.openComplete = !1, R.dbOpenError = null);
      }, Ln.prototype.delete = function(k) {
        var A = this, R = (k === void 0 && (k = { disableAutoOpen: !0 }), 0 < arguments.length && typeof arguments[0] != "object"), P = this._state;
        return new Ke(function(z, $) {
          function q() {
            A.close(k);
            var K = A._deps.indexedDB.deleteDatabase(A.name);
            K.onsuccess = Cn(function() {
              var se, ye, ae;
              se = A._deps, ye = A.name, Bd(ae = se.indexedDB) || ye === nu || pp(ae, se.IDBKeyRange).delete(ye).catch(Ge), z();
            }), K.onerror = no($), K.onblocked = A._fireOnBlocked;
          }
          if (R) throw new Ae.InvalidArgument("Invalid closeOptions argument to db.delete()");
          P.isBeingOpened ? P.dbReadyPromise.then(q) : q();
        });
      }, Ln.prototype.backendDB = function() {
        return this.idbdb;
      }, Ln.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, Ln.prototype.hasBeenClosed = function() {
        var k = this._state.dbOpenError;
        return k && k.name === "DatabaseClosed";
      }, Ln.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, Ln.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(Ln.prototype, "tables", { get: function() {
        var k = this;
        return s(this._allTables).map(function(A) {
          return k._allTables[A];
        });
      }, enumerable: !1, configurable: !0 }), Ln.prototype.transaction = function() {
        var k = (function(A, R, P) {
          var z = arguments.length;
          if (z < 2) throw new Ae.InvalidArgument("Too few arguments");
          for (var $ = new Array(z - 1); --z; ) $[z - 1] = arguments[z];
          return P = $.pop(), [A, B($), P];
        }).apply(this, arguments);
        return this._transaction.apply(this, k);
      }, Ln.prototype._transaction = function(k, A, R) {
        var P, z, $ = this, q = Ve.trans, K = (q && q.db === this && k.indexOf("!") === -1 || (q = null), k.indexOf("?") !== -1);
        k = k.replace("!", "").replace("?", "");
        try {
          if (z = A.map(function(ye) {
            if (ye = ye instanceof $.Table ? ye.name : ye, typeof ye != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return ye;
          }), k == "r" || k === Qo) P = Qo;
          else {
            if (k != "rw" && k != _s) throw new Ae.InvalidArgument("Invalid transaction mode: " + k);
            P = _s;
          }
          if (q) {
            if (q.mode === Qo && P === _s) {
              if (!K) throw new Ae.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              q = null;
            }
            q && z.forEach(function(ye) {
              if (q && q.storeNames.indexOf(ye) === -1) {
                if (!K) throw new Ae.SubTransaction("Table " + ye + " not included in parent transaction.");
                q = null;
              }
            }), K && q && !q.active && (q = null);
          }
        } catch (ye) {
          return q ? q._promise(null, function(ae, oe) {
            oe(ye);
          }) : bn(ye);
        }
        var se = (function ye(ae, oe, ue, fe, le) {
          return Ke.resolve().then(function() {
            var ve = Ve.transless || Ve, ce = ae._createTransaction(oe, ue, ae._dbSchema, fe), ve = (ce.explicit = !0, { trans: ce, transless: ve });
            if (fe) ce.idbtrans = fe.idbtrans;
            else try {
              ce.create(), ce.idbtrans._explicit = !0, ae._state.PR1398_maxLoop = 3;
            } catch (Re) {
              return Re.name === xe.InvalidState && ae.isOpen() && 0 < --ae._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), ae.close({ disableAutoOpen: !1 }), ae.open().then(function() {
                return ye(ae, oe, ue, null, le);
              })) : bn(Re);
            }
            var we, _e = Z(le), ve = (_e && lr(), Ke.follow(function() {
              var Re;
              (we = le.call(ce, ce)) && (_e ? (Re = Ci.bind(null, null), we.then(Re, Re)) : typeof we.next == "function" && typeof we.throw == "function" && (we = fu(we)));
            }, ve));
            return (we && typeof we.then == "function" ? Ke.resolve(we).then(function(Re) {
              return ce.active ? Re : bn(new Ae.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : ve.then(function() {
              return we;
            })).then(function(Re) {
              return fe && ce._resolve(), ce._completion.then(function() {
                return Re;
              });
            }).catch(function(Re) {
              return ce._reject(Re), bn(Re);
            });
          });
        }).bind(null, this, P, z, q, R);
        return q ? q._promise(P, se, "lock") : Ve.trans ? eo(Ve.transless, function() {
          return $._whenReady(se);
        }) : this._whenReady(se);
      }, Ln.prototype.table = function(k) {
        if (h(this._allTables, k)) return this._allTables[k];
        throw new Ae.InvalidTable("Table ".concat(k, " does not exist"));
      };
      var Eo = Ln;
      function Ln(k, A) {
        var R, P, z, $, q, K = this, se = (this._middlewares = {}, this.verno = 0, Ln.dependencies), se = (this._options = A = r({ addons: Ln.addons, autoOpen: !0, indexedDB: se.indexedDB, IDBKeyRange: se.IDBKeyRange, cache: "cloned" }, A), this._deps = { indexedDB: A.indexedDB, IDBKeyRange: A.IDBKeyRange }, A.addons), ye = (this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this, { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Ge, dbReadyPromise: null, cancelOpen: Ge, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: A.autoOpen }), ae = (ye.dbReadyPromise = new Ke(function(oe) {
          ye.dbReadyResolve = oe;
        }), ye.openCanceller = new Ke(function(oe, ue) {
          ye.cancelOpen = ue;
        }), this._state = ye, this.name = k, this.on = ou(this, "populate", "blocked", "versionchange", "close", { ready: [Mn, Ge] }), this.once = function(oe, ue) {
          var fe = function() {
            for (var le = [], ce = 0; ce < arguments.length; ce++) le[ce] = arguments[ce];
            K.on(oe).unsubscribe(fe), ue.apply(K, le);
          };
          return K.on(oe, fe);
        }, this.on.ready.subscribe = M(this.on.ready.subscribe, function(oe) {
          return function(ue, fe) {
            Ln.vip(function() {
              var le, ce = K._state;
              ce.openComplete ? (ce.dbOpenError || Ke.resolve().then(ue), fe && oe(ue)) : ce.onReadyBeingFired ? (ce.onReadyBeingFired.push(ue), fe && oe(ue)) : (oe(ue), le = K, fe || oe(function we() {
                le.on.ready.unsubscribe(ue), le.on.ready.unsubscribe(we);
              }));
            });
          };
        }), this.Collection = (R = this, zr(M1.prototype, function(we, ce) {
          this.db = R;
          var fe = sp, le = null;
          if (ce) try {
            fe = ce();
          } catch (ve) {
            le = ve;
          }
          var ce = we._ctx, we = ce.table, _e = we.hook.reading.fire;
          this._ctx = { table: we, index: ce.index, isPrimKey: !ce.index || we.schema.primKey.keyPath && ce.index === we.schema.primKey.name, range: fe, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: le, or: ce.or, valueMapper: _e !== rt ? _e : null };
        })), this.Table = (P = this, zr(ap.prototype, function(oe, ue, fe) {
          this.db = P, this._tx = fe, this.name = oe, this.schema = ue, this.hook = P._allTables[oe] ? P._allTables[oe].hook : ou(null, { creating: [kt, Ge], reading: [Tt, rt], updating: [wt, Ge], deleting: [Wt, Ge] });
        })), this.Transaction = (z = this, zr(dp.prototype, function(oe, ue, fe, le, ce) {
          var we = this;
          oe !== "readonly" && ue.forEach(function(_e) {
            _e = (_e = fe[_e]) == null ? void 0 : _e.yProps, _e && (ue = ue.concat(_e.map(function(ve) {
              return ve.updatesTable;
            })));
          }), this.db = z, this.mode = oe, this.storeNames = ue, this.schema = fe, this.chromeTransactionDurability = le, this.idbtrans = null, this.on = ou(this, "complete", "error", "abort"), this.parent = ce || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Ke(function(_e, ve) {
            we._resolve = _e, we._reject = ve;
          }), this._completion.then(function() {
            we.active = !1, we.on.complete.fire();
          }, function(_e) {
            var ve = we.active;
            return we.active = !1, we.on.error.fire(_e), we.parent ? we.parent._reject(_e) : ve && we.idbtrans && we.idbtrans.abort(), bn(_e);
          });
        })), this.Version = ($ = this, zr(R1.prototype, function(oe) {
          this.db = $, this._cfg = { version: oe, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (q = this, zr(pa.prototype, function(oe, ue, fe) {
          if (this.db = q, this._ctx = { table: oe, index: ue === ":id" ? null : ue, or: fe }, this._cmp = this._ascending = It, this._descending = function(le, ce) {
            return It(ce, le);
          }, this._max = function(le, ce) {
            return 0 < It(le, ce) ? le : ce;
          }, this._min = function(le, ce) {
            return It(le, ce) < 0 ? le : ce;
          }, this._IDBKeyRange = q._deps.IDBKeyRange, !this._IDBKeyRange) throw new Ae.MissingAPI();
        })), this.on("versionchange", function(oe) {
          0 < oe.newVersion ? console.warn("Another connection wants to upgrade database '".concat(K.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(K.name, "'. Closing db now to resume the delete request.")), K.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(oe) {
          !oe.newVersion || oe.newVersion < oe.oldVersion ? console.warn("Dexie.delete('".concat(K.name, "') was blocked")) : console.warn("Upgrade '".concat(K.name, "' blocked by other connection holding version ").concat(oe.oldVersion / 10));
        }), this._maxKey = yl(A.IDBKeyRange), this._createTransaction = function(oe, ue, fe, le) {
          return new K.Transaction(oe, ue, fe, K._options.chromeTransactionDurability, le);
        }, this._fireOnBlocked = function(oe) {
          K.on("blocked").fire(oe), da.filter(function(ue) {
            return ue.name === K.name && ue !== K && !ue._state.vcFired;
          }).map(function(ue) {
            return ue.on("versionchange").fire(oe);
          });
        }, this.use(Oy), this.use(qd), this.use(D1), this.use(P1), this.use(Ry), new Proxy(this, { get: function(oe, ue, fe) {
          var le;
          return ue === "_vip" || (ue === "table" ? function(ce) {
            return pu(K.table(ce), ae);
          } : (le = Reflect.get(oe, ue, fe)) instanceof ap ? pu(le, ae) : ue === "tables" ? le.map(function(ce) {
            return pu(ce, ae);
          }) : ue === "_createTransaction" ? function() {
            return pu(le.apply(this, arguments), ae);
          } : le);
        } }));
        this.vip = ae, se.forEach(function(oe) {
          return oe(K);
        });
      }
      var Sl, wa = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Iy = (Gd.prototype.subscribe = function(k, A, R) {
        return this._subscribe(k && typeof k != "function" ? k : { next: k, error: A, complete: R });
      }, Gd.prototype[wa] = function() {
        return this;
      }, Gd);
      function Gd(k) {
        this._subscribe = k;
      }
      try {
        Sl = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        Sl = { indexedDB: null, IDBKeyRange: null };
      }
      function jy(k) {
        var A, R = !1, P = new Iy(function(z) {
          var $ = Z(k), q, K = !1, se = {}, ye = {}, ae = { get closed() {
            return K;
          }, unsubscribe: function() {
            K || (K = !0, q && q.abort(), oe && Lr.storagemutated.unsubscribe(fe));
          } }, oe = (z.start && z.start(ae), !1), ue = function() {
            return Es(le);
          }, fe = function(ce) {
            Ud(se, ce), vp(ye, se) && ue();
          }, le = function() {
            var ce, we, _e;
            !K && Sl.indexedDB && (se = {}, ce = {}, q && q.abort(), q = new AbortController(), _e = ((ve) => {
              var Re = Ss();
              try {
                $ && lr();
                var ze = Rn(k, ve);
                return ze = $ ? ze.finally(Ci) : ze;
              } finally {
                Re && wo();
              }
            })(we = { subscr: ce, signal: q.signal, requery: ue, querier: k, trans: null }), Promise.resolve(_e).then(function(ve) {
              R = !0, A = ve, K || we.signal.aborted || (se = {}, ((Re) => {
                for (var ze in Re) if (h(Re, ze)) return;
                return 1;
              })(ye = ce) || oe || (Lr(ml, fe), oe = !0), Es(function() {
                return !K && z.next && z.next(ve);
              }));
            }, function(ve) {
              R = !1, ["DatabaseClosedError", "AbortError"].includes(ve?.name) || K || Es(function() {
                K || z.error && z.error(ve);
              });
            }));
          };
          return setTimeout(ue, 0), ae;
        });
        return P.hasValue = function() {
          return R;
        }, P.getValue = function() {
          return A;
        }, P;
      }
      var Sa = Eo;
      function Cp(k) {
        var A = Ns;
        try {
          Ns = !0, Lr.storagemutated.fire(k), wp(k, !0);
        } finally {
          Ns = A;
        }
      }
      m(Sa, r(r({}, pe), { delete: function(k) {
        return new Sa(k, { addons: [] }).delete();
      }, exists: function(k) {
        return new Sa(k, { addons: [] }).open().then(function(A) {
          return A.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(k) {
        try {
          return A = Sa.dependencies, R = A.indexedDB, A = A.IDBKeyRange, (Bd(R) ? Promise.resolve(R.databases()).then(function(P) {
            return P.map(function(z) {
              return z.name;
            }).filter(function(z) {
              return z !== nu;
            });
          }) : pp(R, A).toCollection().primaryKeys()).then(k);
        } catch {
          return bn(new Ae.MissingAPI());
        }
        var A, R;
      }, defineClass: function() {
        return function(k) {
          c(this, k);
        };
      }, ignoreTransaction: function(k) {
        return Ve.trans ? eo(Ve.transless, k) : k();
      }, vip: mp, async: function(k) {
        return function() {
          try {
            var A = fu(k.apply(this, arguments));
            return A && typeof A.then == "function" ? A : Ke.resolve(A);
          } catch (R) {
            return bn(R);
          }
        };
      }, spawn: function(k, A, R) {
        try {
          var P = fu(k.apply(R, A || []));
          return P && typeof P.then == "function" ? P : Ke.resolve(P);
        } catch (z) {
          return bn(z);
        }
      }, currentTransaction: { get: function() {
        return Ve.trans || null;
      } }, waitFor: function(k, A) {
        return k = Ke.resolve(typeof k == "function" ? Sa.ignoreTransaction(k) : k).timeout(A || 6e4), Ve.trans ? Ve.trans.waitFor(k) : k;
      }, Promise: Ke, debug: { get: function() {
        return Rt;
      }, set: function(k) {
        ln(k);
      } }, derive: x, extend: c, props: m, override: M, Events: ou, on: Lr, liveQuery: jy, extendObservabilitySet: Ud, getByKeyPath: j, setByKeyPath: O, delByKeyPath: function(k, A) {
        typeof A == "string" ? O(k, A, void 0) : "length" in A && [].map.call(A, function(R) {
          O(k, R, void 0);
        });
      }, shallowClone: L, deepClone: he, getObjectDiff: Vd, cmp: It, asap: D, minKey: -1 / 0, addons: [], connections: da, errnames: xe, dependencies: Sl, cache: ba, semVer: "4.3.0", version: "4.3.0".split(".").map(function(k) {
        return parseInt(k);
      }).reduce(function(k, A, R) {
        return k + A / Math.pow(10, 2 * R);
      }) })), Sa.maxKey = yl(Sa.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Lr(ml, function(k) {
        Ns || (k = new CustomEvent(ga, { detail: k }), Ns = !0, dispatchEvent(k), Ns = !1);
      }), addEventListener(ga, function(k) {
        k = k.detail, Ns || Cp(k);
      }));
      var kl, Ns = !1, fi = function() {
      };
      return typeof BroadcastChannel < "u" && ((fi = function() {
        (kl = new BroadcastChannel(ga)).onmessage = function(k) {
          return k.data && Cp(k.data);
        };
      })(), typeof kl.unref == "function" && kl.unref(), Lr(ml, function(k) {
        Ns || kl.postMessage(k);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(k) {
        if (!Eo.disableBfCache && k.persisted) {
          Rt && console.debug("Dexie: handling persisted pagehide"), kl?.close();
          for (var A = 0, R = da; A < R.length; A++) R[A].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(k) {
        !Eo.disableBfCache && k.persisted && (Rt && console.debug("Dexie: handling persisted pageshow"), fi(), Cp({ all: new Br(-1 / 0, [[]]) }));
      })), Ke.rejectionMapper = function(k, A) {
        return !k || k instanceof ee || k instanceof TypeError || k instanceof SyntaxError || !k.name || !nt[k.name] ? k : (A = new nt[k.name](A || k.message, k), "stack" in k && b(A, "stack", { get: function() {
          return this.inner.stack;
        } }), A);
      }, ln(Rt), r(Eo, Object.freeze({ __proto__: null, Dexie: Eo, Entity: ky, PropModification: pl, RangeSet: Br, add: function(k) {
        return new pl({ add: k });
      }, cmp: It, default: Eo, liveQuery: jy, mergeRanges: va, rangesOverlap: Ay, remove: function(k) {
        return new pl({ remove: k });
      }, replacePrefix: function(k, A) {
        return new pl({ replacePrefix: [k, A] });
      } }), { default: Eo }), Eo;
    });
  })(H0)), H0.exports;
}
var tme = eme();
const G_ = /* @__PURE__ */ Bc(tme), Tj = /* @__PURE__ */ Symbol.for("Dexie"), pc = globalThis[Tj] || (globalThis[Tj] = G_);
if (G_.semVer !== pc.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${G_.semVer} and ${pc.semVer}`);
const {
  liveQuery: A5e,
  mergeRanges: M5e,
  rangesOverlap: N5e,
  RangeSet: R5e,
  cmp: O5e,
  Entity: P5e,
  PropModification: D5e,
  replacePrefix: I5e,
  add: j5e,
  remove: z5e,
  DexieYProvider: L5e
} = pc;
class nme extends pc {
  messages;
  threads;
  constructor() {
    super("ChatbotDB"), this.version(1).stores({
      messages: "id, threadId, createdAt, [threadId+createdAt]",
      threads: "id, lastMessageAt"
    });
  }
}
const qi = new nme(), us = {
  /**
   * Save messages to IndexedDB
   */
  async saveMessages(e, t) {
    const n = t.map((r) => ({
      id: r.id,
      threadId: e,
      role: r.role,
      parts: r.parts || [],
      metadata: r.metadata,
      createdAt: r.createdAt || /* @__PURE__ */ new Date()
    }));
    if (await qi.messages.bulkPut(n), t.length > 0) {
      const r = t[t.length - 1], i = us.extractTextFromMessage(r);
      await qi.threads.put({
        id: e,
        lastMessageText: i,
        lastMessageAt: r.createdAt || /* @__PURE__ */ new Date(),
        messageCount: t.length
      });
    }
  },
  /**
   * Get messages from IndexedDB
   */
  async getMessages(e, t) {
    return t && t > 0 ? (await qi.messages.where("[threadId+createdAt]").between([e, pc.minKey], [e, pc.maxKey]).reverse().limit(t).toArray()).reverse() : qi.messages.where("threadId").equals(e).sortBy("createdAt");
  },
  /**
   * Get paginated messages (for infinite scroll)
   */
  async getMessagesPaginated(e, t, n = 20) {
    return (await qi.messages.where("[threadId+createdAt]").between(
      [e, /* @__PURE__ */ new Date(0)],
      [e, t]
    ).reverse().limit(n).toArray()).reverse();
  },
  /**
   * Delete old messages to free up space
   */
  async pruneOldMessages(e, t = 100) {
    const r = await qi.messages.where("threadId").equals(e).count() - t;
    if (r <= 0) return;
    const i = await qi.messages.where("[threadId+createdAt]").between([e, pc.minKey], [e, pc.maxKey]).limit(r).primaryKeys();
    i.length > 0 && await qi.messages.bulkDelete(i);
  },
  /**
   * Delete all messages for a thread
   */
  async deleteThread(e) {
    await qi.messages.where("threadId").equals(e).delete(), await qi.threads.delete(e);
  },
  /**
   * Get thread metadata
   */
  async getThreadMetadata(e) {
    return await qi.threads.get(e);
  },
  /**
   * Get all threads metadata
   */
  async getAllThreads() {
    return await qi.threads.orderBy("lastMessageAt").reverse().toArray();
  },
  /**
   * Extract text from message for preview
   */
  extractTextFromMessage(e) {
    if (!e.parts || e.parts.length === 0) return "";
    const t = e.parts.find((n) => n.type === "text");
    return t && typeof t.text == "string" ? t.text.substring(0, 100) : "";
  },
  /**
   * Get database size estimation
   */
  async getStorageStats() {
    const e = await qi.messages.count(), t = await qi.threads.count(), n = e * 3 * 1024, r = this.formatBytes(n);
    return {
      messageCount: e,
      threadCount: t,
      estimatedSize: r
    };
  },
  formatBytes(e) {
    if (e === 0) return "0 Bytes";
    const t = 1024, n = ["Bytes", "KB", "MB", "GB"], r = Math.floor(Math.log(e) / Math.log(t));
    return Math.round(e / Math.pow(t, r) * 100) / 100 + " " + n[r];
  }
}, wC = 3e4, Aj = 5;
function rme(e, t = 50, n = !0) {
  const [r, i] = C.useState([]), [o, s] = C.useState({
    nextCursor: null,
    hasMore: !0,
    isLoading: !1,
    isLoadingMore: !1,
    isFromCache: !1
  }), a = C.useRef(!1), c = C.useRef(e), u = C.useRef(
    /* @__PURE__ */ new Map()
  );
  C.useEffect(() => {
    if (c.current !== e) {
      c.current = e;
      const m = u.current.get(e);
      if (m && Date.now() - m.updatedAt < wC) {
        i(m.messages), s(m.pagination), a.current = !1;
        return;
      }
      i([]), s({
        nextCursor: null,
        hasMore: !0,
        isLoading: !1,
        isLoadingMore: !1,
        isFromCache: !1
      }), a.current = !1;
    }
  }, [e]), C.useEffect(() => {
    if (!n || o.isLoading || o.isLoadingMore || r.length === 0 && o.nextCursor === null && o.hasMore && !o.isFromCache) return;
    const g = Date.now(), b = u.current, x = [];
    if (b.forEach((w, S) => {
      g - w.updatedAt > wC && x.push(S);
    }), x.forEach((w) => b.delete(w)), b.size >= Aj) {
      const S = Array.from(b.entries()).sort((_, M) => M[1].updatedAt - _[1].updatedAt).slice(0, Aj);
      b.clear(), S.forEach(([_, M]) => b.set(_, M));
    }
    b.set(e, {
      messages: r,
      pagination: o,
      updatedAt: g
    });
  }, [n, e, r, o]), C.useEffect(() => {
    if (!n || r.length > 0 || a.current) return;
    const m = u.current.get(e);
    if (m && Date.now() - m.updatedAt < wC) {
      console.log(" Using in-memory cache, skipping load");
      return;
    }
    (async () => {
      const b = e;
      console.log(" Starting load initial messages..."), a.current = !0, s((x) => ({ ...x, isLoading: !0 }));
      try {
        console.time(" Load from IndexedDB");
        const x = await us.getMessages(b, t);
        if (console.timeEnd(" Load from IndexedDB"), c.current !== b) return;
        if (x.length > 0) {
          console.log(" Using IndexedDB cache, skipping server fetch");
          const S = x.map((_) => ({
            id: _.id,
            role: _.role,
            parts: _.parts,
            metadata: _.metadata,
            createdAt: _.createdAt
          }));
          i(S), s({
            nextCursor: null,
            hasMore: x.length >= t,
            isLoading: !1,
            isLoadingMore: !1,
            isFromCache: !0
          }), a.current = !1;
          return;
        }
        console.log(" No cached messages found, fetching from server..."), console.time(" Load from Server");
        const w = await kj(b, { limit: t });
        if (console.timeEnd(" Load from Server"), c.current !== b) return;
        i(w.messages || []), s({
          nextCursor: w.nextCursor,
          hasMore: w.hasMore,
          isLoading: !1,
          isLoadingMore: !1,
          isFromCache: !1
        }), w.messages && w.messages.length > 0 && (console.time(" Save to IndexedDB"), await us.saveMessages(b, w.messages), console.timeEnd(" Save to IndexedDB"));
      } catch (x) {
        console.error(" Failed to load messages:", x), s((w) => ({ ...w, isLoading: !1 }));
      } finally {
        a.current = !1;
      }
    })();
  }, [n, e, t, r.length]);
  const f = C.useCallback(async () => {
    if (!n || a.current || !o.hasMore || !o.nextCursor)
      return;
    const m = e;
    a.current = !0, s((g) => ({ ...g, isLoadingMore: !0 }));
    try {
      const g = r[0];
      if (g && g.createdAt) {
        console.time(" Load more from IndexedDB");
        const x = await us.getMessagesPaginated(
          m,
          g.createdAt,
          t
        );
        if (console.timeEnd(" Load more from IndexedDB"), c.current !== m) return;
        if (x.length > 0) {
          const w = x.map((S) => ({
            id: S.id,
            role: S.role,
            parts: S.parts,
            metadata: S.metadata,
            createdAt: S.createdAt
          }));
          i((S) => {
            const _ = new Set(S.map((N) => N.id));
            return [...w.filter((N) => !_.has(N.id)), ...S];
          });
        }
      }
      console.time(" Load more from Server");
      const b = await kj(m, {
        limit: t,
        cursor: o.nextCursor,
        direction: "older"
      });
      if (console.timeEnd(" Load more from Server"), c.current !== m) return;
      i((x) => {
        const w = new Set(x.map((_) => _.id)), S = (b.messages || []).filter((_) => !w.has(_.id));
        return [...x, ...S];
      }), s((x) => ({
        ...x,
        nextCursor: b.nextCursor,
        hasMore: b.hasMore,
        isLoadingMore: !1
      })), b.messages && b.messages.length > 0 && (console.time(" Save more to IndexedDB"), await us.saveMessages(m, b.messages), console.timeEnd(" Save more to IndexedDB"));
    } catch (g) {
      console.error(" Failed to load more messages:", g), s((b) => ({ ...b, isLoadingMore: !1 }));
    } finally {
      a.current = !1;
    }
  }, [n, e, t, o.hasMore, o.nextCursor, r]), h = C.useCallback(() => {
    i([]), s({
      nextCursor: null,
      hasMore: !0,
      isLoading: !1,
      isLoadingMore: !1,
      isFromCache: !1
    }), a.current = !1;
  }, []);
  return {
    messages: r,
    pagination: o,
    loadMore: f,
    reset: h
  };
}
function ime(e) {
  C.useEffect(() => {
    try {
      localStorage.setItem(vh.AI_USE_NEXT_SUGGESTION, JSON.stringify(e.value));
    } catch (t) {
      console.error("Error saving useNextSuggestion to localStorage:", t);
    }
  }, [e.value]), C.useEffect(() => {
    try {
      const t = localStorage.getItem(vh.AI_USE_NEXT_SUGGESTION);
      t !== null && (e.value = JSON.parse(t));
    } catch (t) {
      console.error("Error loading useNextSuggestion from localStorage:", t);
    }
  }, [e]);
}
function ome({
  threadId: e,
  enabled: t = !0,
  maxInMemory: n = 20
}) {
  const [r, i] = C.useState(!1), [o, s] = C.useState(null), a = C.useCallback(
    async (m) => {
      if (!(!t || !e))
        try {
          i(!0), s(null), await us.saveMessages(e, m), await us.pruneOldMessages(e, 500);
        } catch (g) {
          console.error("Failed to save messages to IndexedDB:", g), s(g);
        } finally {
          i(!1);
        }
    },
    [e, t, n]
  ), c = C.useCallback(
    async (m) => {
      if (!t || !e) return [];
      try {
        i(!0), s(null);
        const g = m ?? n;
        return (await us.getMessages(
          e,
          g
        )).map((x) => ({
          id: x.id,
          role: x.role,
          parts: x.parts,
          metadata: x.metadata,
          createdAt: x.createdAt
        }));
      } catch (g) {
        return console.error("Failed to load messages from IndexedDB:", g), s(g), [];
      } finally {
        i(!1);
      }
    },
    [e, t, n]
  ), u = C.useCallback(
    async (m, g = 20) => {
      if (!t || !e) return [];
      try {
        return (await us.getMessagesPaginated(
          e,
          m,
          g
        )).map((x) => ({
          id: x.id,
          role: x.role,
          parts: x.parts,
          metadata: x.metadata,
          createdAt: x.createdAt
        }));
      } catch (b) {
        return console.error("Failed to load older messages from IndexedDB:", b), s(b), [];
      }
    },
    [e, t]
  ), f = C.useCallback(async () => {
    if (!(!t || !e))
      try {
        await us.deleteThread(e);
      } catch (m) {
        console.error("Failed to delete thread from IndexedDB:", m), s(m);
      }
  }, [e, t]), h = C.useCallback(async () => {
    if (!t) return null;
    try {
      return await us.getStorageStats();
    } catch (m) {
      return console.error("Failed to get storage stats:", m), null;
    }
  }, [t]);
  return {
    saveMessages: a,
    loadMessages: c,
    loadOlderMessages: u,
    deleteThread: f,
    getStorageStats: h,
    isLoading: r,
    error: o
  };
}
var FF = "vercel.ai.error", sme = Symbol.for(FF), Mj, Nj, ra = class VF extends (Nj = Error, Mj = sme, Nj) {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: t,
    message: n,
    cause: r
  }) {
    super(n), this[Mj] = !0, this.name = t, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(t) {
    return VF.hasMarker(t, FF);
  }
  static hasMarker(t, n) {
    const r = Symbol.for(n);
    return t != null && typeof t == "object" && r in t && typeof t[r] == "boolean" && t[r] === !0;
  }
};
function WM(e) {
  return e == null ? "unknown error" : typeof e == "string" ? e : e instanceof Error ? e.message : JSON.stringify(e);
}
var HF = "AI_InvalidArgumentError", WF = `vercel.ai.error.${HF}`, ame = Symbol.for(WF), Rj, Oj, lme = class extends (Oj = ra, Rj = ame, Oj) {
  constructor({
    message: e,
    cause: t,
    argument: n
  }) {
    super({ name: HF, message: e, cause: t }), this[Rj] = !0, this.argument = n;
  }
  static isInstance(e) {
    return ra.hasMarker(e, WF);
  }
}, qF = "AI_JSONParseError", GF = `vercel.ai.error.${qF}`, cme = Symbol.for(GF), Pj, Dj, Ij = class extends (Dj = ra, Pj = cme, Dj) {
  constructor({ text: e, cause: t }) {
    super({
      name: qF,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${WM(t)}`,
      cause: t
    }), this[Pj] = !0, this.text = e;
  }
  static isInstance(e) {
    return ra.hasMarker(e, GF);
  }
}, KF = "AI_TypeValidationError", ZF = `vercel.ai.error.${KF}`, ume = Symbol.for(ZF), jj, zj, zb = class K_ extends (zj = ra, jj = ume, zj) {
  constructor({ value: t, cause: n }) {
    super({
      name: KF,
      message: `Type validation failed: Value: ${JSON.stringify(t)}.
Error message: ${WM(n)}`,
      cause: n
    }), this[jj] = !0, this.value = t;
  }
  static isInstance(t) {
    return ra.hasMarker(t, ZF);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: t,
    cause: n
  }) {
    return K_.isInstance(n) && n.value === t ? n : new K_({ value: t, cause: n });
  }
};
class Lj extends Error {
  constructor(t, n) {
    super(t), this.name = "ParseError", this.type = n.type, this.field = n.field, this.value = n.value, this.line = n.line;
  }
}
function SC(e) {
}
function dme(e) {
  if (typeof e == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent: t = SC, onError: n = SC, onRetry: r = SC, onComment: i } = e;
  let o = "", s = !0, a, c = "", u = "";
  function f(x) {
    const w = s ? x.replace(/^\xEF\xBB\xBF/, "") : x, [S, _] = fme(`${o}${w}`);
    for (const M of S)
      h(M);
    o = _, s = !1;
  }
  function h(x) {
    if (x === "") {
      g();
      return;
    }
    if (x.startsWith(":")) {
      i && i(x.slice(x.startsWith(": ") ? 2 : 1));
      return;
    }
    const w = x.indexOf(":");
    if (w !== -1) {
      const S = x.slice(0, w), _ = x[w + 1] === " " ? 2 : 1, M = x.slice(w + _);
      m(S, M, x);
      return;
    }
    m(x, "", x);
  }
  function m(x, w, S) {
    switch (x) {
      case "event":
        u = w;
        break;
      case "data":
        c = `${c}${w}
`;
        break;
      case "id":
        a = w.includes("\0") ? void 0 : w;
        break;
      case "retry":
        /^\d+$/.test(w) ? r(parseInt(w, 10)) : n(
          new Lj(`Invalid \`retry\` value: "${w}"`, {
            type: "invalid-retry",
            value: w,
            line: S
          })
        );
        break;
      default:
        n(
          new Lj(
            `Unknown field "${x.length > 20 ? `${x.slice(0, 20)}` : x}"`,
            { type: "unknown-field", field: x, value: w, line: S }
          )
        );
        break;
    }
  }
  function g() {
    c.length > 0 && t({
      id: a,
      event: u || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: c.endsWith(`
`) ? c.slice(0, -1) : c
    }), a = void 0, c = "", u = "";
  }
  function b(x = {}) {
    o && x.consume && h(o), s = !0, a = void 0, c = "", u = "", o = "";
  }
  return { feed: f, reset: b };
}
function fme(e) {
  const t = [];
  let n = "", r = 0;
  for (; r < e.length; ) {
    const i = e.indexOf("\r", r), o = e.indexOf(`
`, r);
    let s = -1;
    if (i !== -1 && o !== -1 ? s = Math.min(i, o) : i !== -1 ? i === e.length - 1 ? s = -1 : s = i : o !== -1 && (s = o), s === -1) {
      n = e.slice(r);
      break;
    } else {
      const a = e.slice(r, s);
      t.push(a), r = s + 1, e[r - 1] === "\r" && e[r] === `
` && r++;
    }
  }
  return [t, n];
}
class hme extends TransformStream {
  constructor({ onError: t, onRetry: n, onComment: r } = {}) {
    let i;
    super({
      start(o) {
        i = dme({
          onEvent: (s) => {
            o.enqueue(s);
          },
          onError(s) {
            t === "terminate" ? o.error(s) : typeof t == "function" && t(s);
          },
          onRetry: n,
          onComment: r
        });
      },
      transform(o) {
        i.feed(o);
      }
    });
  }
}
function Pe(e, t, n) {
  function r(a, c) {
    if (a._zod || Object.defineProperty(a, "_zod", {
      value: {
        def: c,
        constr: s,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), a._zod.traits.has(e))
      return;
    a._zod.traits.add(e), t(a, c);
    const u = s.prototype, f = Object.keys(u);
    for (let h = 0; h < f.length; h++) {
      const m = f[h];
      m in a || (a[m] = u[m].bind(a));
    }
  }
  const i = n?.Parent ?? Object;
  class o extends i {
  }
  Object.defineProperty(o, "name", { value: e });
  function s(a) {
    var c;
    const u = n?.Parent ? new o() : this;
    r(u, a), (c = u._zod).deferred ?? (c.deferred = []);
    for (const f of u._zod.deferred)
      f();
    return u;
  }
  return Object.defineProperty(s, "init", { value: r }), Object.defineProperty(s, Symbol.hasInstance, {
    value: (a) => n?.Parent && a instanceof n.Parent ? !0 : a?._zod?.traits?.has(e)
  }), Object.defineProperty(s, "name", { value: e }), s;
}
class sh extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class YF extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
}
const XF = {};
function Ic(e) {
  return XF;
}
function JF(e) {
  const t = Object.values(e).filter((r) => typeof r == "number");
  return Object.entries(e).filter(([r, i]) => t.indexOf(+r) === -1).map(([r, i]) => i);
}
function Z_(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function Fw(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function qM(e) {
  return e == null;
}
function GM(e) {
  const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function pme(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = t.toString();
  let i = (r.split(".")[1] || "").length;
  if (i === 0 && /\d?e-\d?/.test(r)) {
    const c = r.match(/\d?e-(\d?)/);
    c?.[1] && (i = Number.parseInt(c[1]));
  }
  const o = n > i ? n : i, s = Number.parseInt(e.toFixed(o).replace(".", "")), a = Number.parseInt(t.toFixed(o).replace(".", ""));
  return s % a / 10 ** o;
}
const Bj = /* @__PURE__ */ Symbol("evaluating");
function nn(e, t, n) {
  let r;
  Object.defineProperty(e, t, {
    get() {
      if (r !== Bj)
        return r === void 0 && (r = Bj, r = n()), r;
    },
    set(i) {
      Object.defineProperty(e, t, {
        value: i
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function Sd(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function Wc(...e) {
  const t = {};
  for (const n of e) {
    const r = Object.getOwnPropertyDescriptors(n);
    Object.assign(t, r);
  }
  return Object.defineProperties({}, t);
}
function $j(e) {
  return JSON.stringify(e);
}
function mme(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const QF = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function gg(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const gme = Fw(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function wh(e) {
  if (gg(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0 || typeof t != "function")
    return !0;
  const n = t.prototype;
  return !(gg(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
function e8(e) {
  return wh(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
const yme = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function Sh(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function qc(e, t, n) {
  const r = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (r._zod.parent = e), r;
}
function ut(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function vme(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const bme = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function xme(e, t) {
  const n = e._zod.def, r = n.checks;
  if (r && r.length > 0)
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  const o = Wc(e._zod.def, {
    get shape() {
      const s = {};
      for (const a in t) {
        if (!(a in n.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        t[a] && (s[a] = n.shape[a]);
      }
      return Sd(this, "shape", s), s;
    },
    checks: []
  });
  return qc(e, o);
}
function wme(e, t) {
  const n = e._zod.def, r = n.checks;
  if (r && r.length > 0)
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  const o = Wc(e._zod.def, {
    get shape() {
      const s = { ...e._zod.def.shape };
      for (const a in t) {
        if (!(a in n.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        t[a] && delete s[a];
      }
      return Sd(this, "shape", s), s;
    },
    checks: []
  });
  return qc(e, o);
}
function Sme(e, t) {
  if (!wh(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const n = e._zod.def.checks;
  if (n && n.length > 0) {
    const o = e._zod.def.shape;
    for (const s in t)
      if (Object.getOwnPropertyDescriptor(o, s) !== void 0)
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  const i = Wc(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape, ...t };
      return Sd(this, "shape", o), o;
    }
  });
  return qc(e, i);
}
function kme(e, t) {
  if (!wh(t))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const n = Wc(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t };
      return Sd(this, "shape", r), r;
    }
  });
  return qc(e, n);
}
function Cme(e, t) {
  const n = Wc(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t._zod.def.shape };
      return Sd(this, "shape", r), r;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return qc(e, n);
}
function Eme(e, t, n) {
  const i = t._zod.def.checks;
  if (i && i.length > 0)
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  const s = Wc(t._zod.def, {
    get shape() {
      const a = t._zod.def.shape, c = { ...a };
      if (n)
        for (const u in n) {
          if (!(u in a))
            throw new Error(`Unrecognized key: "${u}"`);
          n[u] && (c[u] = e ? new e({
            type: "optional",
            innerType: a[u]
          }) : a[u]);
        }
      else
        for (const u in a)
          c[u] = e ? new e({
            type: "optional",
            innerType: a[u]
          }) : a[u];
      return Sd(this, "shape", c), c;
    },
    checks: []
  });
  return qc(t, s);
}
function _me(e, t, n) {
  const r = Wc(t._zod.def, {
    get shape() {
      const i = t._zod.def.shape, o = { ...i };
      if (n)
        for (const s in n) {
          if (!(s in o))
            throw new Error(`Unrecognized key: "${s}"`);
          n[s] && (o[s] = new e({
            type: "nonoptional",
            innerType: i[s]
          }));
        }
      else
        for (const s in i)
          o[s] = new e({
            type: "nonoptional",
            innerType: i[s]
          });
      return Sd(this, "shape", o), o;
    }
  });
  return qc(t, r);
}
function Kf(e, t = 0) {
  if (e.aborted === !0)
    return !0;
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n]?.continue !== !0)
      return !0;
  return !1;
}
function Zf(e, t) {
  return t.map((n) => {
    var r;
    return (r = n).path ?? (r.path = []), n.path.unshift(e), n;
  });
}
function Jv(e) {
  return typeof e == "string" ? e : e?.message;
}
function jc(e, t, n) {
  const r = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const i = Jv(e.inst?._zod.def?.error?.(e)) ?? Jv(t?.error?.(e)) ?? Jv(n.customError?.(e)) ?? Jv(n.localeError?.(e)) ?? "Invalid input";
    r.message = i;
  }
  return delete r.inst, delete r.continue, t?.reportInput || delete r.input, r;
}
function KM(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function yg(...e) {
  const [t, n, r] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: n,
    inst: r
  } : { ...t };
}
const t8 = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, Z_, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, n8 = Pe("$ZodError", t8), r8 = Pe("$ZodError", t8, { Parent: Error });
function Tme(e, t = (n) => n.message) {
  const n = {}, r = [];
  for (const i of e.issues)
    i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
  return { formErrors: r, fieldErrors: n };
}
function Ame(e, t = (n) => n.message) {
  const n = { _errors: [] }, r = (i) => {
    for (const o of i.issues)
      if (o.code === "invalid_union" && o.errors.length)
        o.errors.map((s) => r({ issues: s }));
      else if (o.code === "invalid_key")
        r({ issues: o.issues });
      else if (o.code === "invalid_element")
        r({ issues: o.issues });
      else if (o.path.length === 0)
        n._errors.push(t(o));
      else {
        let s = n, a = 0;
        for (; a < o.path.length; ) {
          const c = o.path[a];
          a === o.path.length - 1 ? (s[c] = s[c] || { _errors: [] }, s[c]._errors.push(t(o))) : s[c] = s[c] || { _errors: [] }, s = s[c], a++;
        }
      }
  };
  return r(e), n;
}
const ZM = (e) => (t, n, r, i) => {
  const o = r ? Object.assign(r, { async: !1 }) : { async: !1 }, s = t._zod.run({ value: n, issues: [] }, o);
  if (s instanceof Promise)
    throw new sh();
  if (s.issues.length) {
    const a = new (i?.Err ?? e)(s.issues.map((c) => jc(c, o, Ic())));
    throw QF(a, i?.callee), a;
  }
  return s.value;
}, YM = (e) => async (t, n, r, i) => {
  const o = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let s = t._zod.run({ value: n, issues: [] }, o);
  if (s instanceof Promise && (s = await s), s.issues.length) {
    const a = new (i?.Err ?? e)(s.issues.map((c) => jc(c, o, Ic())));
    throw QF(a, i?.callee), a;
  }
  return s.value;
}, Vw = (e) => (t, n, r) => {
  const i = r ? { ...r, async: !1 } : { async: !1 }, o = t._zod.run({ value: n, issues: [] }, i);
  if (o instanceof Promise)
    throw new sh();
  return o.issues.length ? {
    success: !1,
    error: new (e ?? n8)(o.issues.map((s) => jc(s, i, Ic())))
  } : { success: !0, data: o.value };
}, Mme = /* @__PURE__ */ Vw(r8), Hw = (e) => async (t, n, r) => {
  const i = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let o = t._zod.run({ value: n, issues: [] }, i);
  return o instanceof Promise && (o = await o), o.issues.length ? {
    success: !1,
    error: new e(o.issues.map((s) => jc(s, i, Ic())))
  } : { success: !0, data: o.value };
}, Nme = /* @__PURE__ */ Hw(r8), Rme = (e) => (t, n, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return ZM(e)(t, n, i);
}, Ome = (e) => (t, n, r) => ZM(e)(t, n, r), Pme = (e) => async (t, n, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return YM(e)(t, n, i);
}, Dme = (e) => async (t, n, r) => YM(e)(t, n, r), Ime = (e) => (t, n, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Vw(e)(t, n, i);
}, jme = (e) => (t, n, r) => Vw(e)(t, n, r), zme = (e) => async (t, n, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Hw(e)(t, n, i);
}, Lme = (e) => async (t, n, r) => Hw(e)(t, n, r), Bme = /^[cC][^\s-]{8,}$/, $me = /^[0-9a-z]+$/, Ume = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, Fme = /^[0-9a-vA-V]{20}$/, Vme = /^[A-Za-z0-9]{27}$/, Hme = /^[a-zA-Z0-9_-]{21}$/, Wme = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, qme = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, Uj = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, Gme = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, Kme = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Zme() {
  return new RegExp(Kme, "u");
}
const Yme = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Xme = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, Jme = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, Qme = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, ege = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, i8 = /^[A-Za-z0-9_-]*$/, tge = /^\+[1-9]\d{6,14}$/, o8 = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", nge = /* @__PURE__ */ new RegExp(`^${o8}$`);
function s8(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function rge(e) {
  return new RegExp(`^${s8(e)}$`);
}
function ige(e) {
  const t = s8({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const r = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${o8}T(?:${r})$`);
}
const oge = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, sge = /^-?\d+$/, a8 = /^-?\d+(?:\.\d+)?$/, age = /^(?:true|false)$/i, lge = /^null$/i, cge = /^[^A-Z]*$/, uge = /^[^a-z]*$/, Ji = /* @__PURE__ */ Pe("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), l8 = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, c8 = /* @__PURE__ */ Pe("$ZodCheckLessThan", (e, t) => {
  Ji.init(e, t);
  const n = l8[typeof t.value];
  e._zod.onattach.push((r) => {
    const i = r._zod.bag, o = (t.inclusive ? i.maximum : i.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < o && (t.inclusive ? i.maximum = t.value : i.exclusiveMaximum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value <= t.value : r.value < t.value) || r.issues.push({
      origin: n,
      code: "too_big",
      maximum: typeof t.value == "object" ? t.value.getTime() : t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), u8 = /* @__PURE__ */ Pe("$ZodCheckGreaterThan", (e, t) => {
  Ji.init(e, t);
  const n = l8[typeof t.value];
  e._zod.onattach.push((r) => {
    const i = r._zod.bag, o = (t.inclusive ? i.minimum : i.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > o && (t.inclusive ? i.minimum = t.value : i.exclusiveMinimum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value >= t.value : r.value > t.value) || r.issues.push({
      origin: n,
      code: "too_small",
      minimum: typeof t.value == "object" ? t.value.getTime() : t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), dge = /* @__PURE__ */ Pe("$ZodCheckMultipleOf", (e, t) => {
  Ji.init(e, t), e._zod.onattach.push((n) => {
    var r;
    (r = n._zod.bag).multipleOf ?? (r.multipleOf = t.value);
  }), e._zod.check = (n) => {
    if (typeof n.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof n.value == "bigint" ? n.value % t.value === BigInt(0) : pme(n.value, t.value) === 0) || n.issues.push({
      origin: typeof n.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), fge = /* @__PURE__ */ Pe("$ZodCheckNumberFormat", (e, t) => {
  Ji.init(e, t), t.format = t.format || "float64";
  const n = t.format?.includes("int"), r = n ? "int" : "number", [i, o] = bme[t.format];
  e._zod.onattach.push((s) => {
    const a = s._zod.bag;
    a.format = t.format, a.minimum = i, a.maximum = o, n && (a.pattern = sge);
  }), e._zod.check = (s) => {
    const a = s.value;
    if (n) {
      if (!Number.isInteger(a)) {
        s.issues.push({
          expected: r,
          format: t.format,
          code: "invalid_type",
          continue: !1,
          input: a,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(a)) {
        a > 0 ? s.issues.push({
          input: a,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          inclusive: !0,
          continue: !t.abort
        }) : s.issues.push({
          input: a,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          inclusive: !0,
          continue: !t.abort
        });
        return;
      }
    }
    a < i && s.issues.push({
      origin: "number",
      input: a,
      code: "too_small",
      minimum: i,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), a > o && s.issues.push({
      origin: "number",
      input: a,
      code: "too_big",
      maximum: o,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    });
  };
}), hge = /* @__PURE__ */ Pe("$ZodCheckMaxLength", (e, t) => {
  var n;
  Ji.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const i = r.value;
    return !qM(i) && i.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const i = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < i && (r._zod.bag.maximum = t.maximum);
  }), e._zod.check = (r) => {
    const i = r.value;
    if (i.length <= t.maximum)
      return;
    const s = KM(i);
    r.issues.push({
      origin: s,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: i,
      inst: e,
      continue: !t.abort
    });
  };
}), pge = /* @__PURE__ */ Pe("$ZodCheckMinLength", (e, t) => {
  var n;
  Ji.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const i = r.value;
    return !qM(i) && i.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const i = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > i && (r._zod.bag.minimum = t.minimum);
  }), e._zod.check = (r) => {
    const i = r.value;
    if (i.length >= t.minimum)
      return;
    const s = KM(i);
    r.issues.push({
      origin: s,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: i,
      inst: e,
      continue: !t.abort
    });
  };
}), mge = /* @__PURE__ */ Pe("$ZodCheckLengthEquals", (e, t) => {
  var n;
  Ji.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const i = r.value;
    return !qM(i) && i.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.minimum = t.length, i.maximum = t.length, i.length = t.length;
  }), e._zod.check = (r) => {
    const i = r.value, o = i.length;
    if (o === t.length)
      return;
    const s = KM(i), a = o > t.length;
    r.issues.push({
      origin: s,
      ...a ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Ww = /* @__PURE__ */ Pe("$ZodCheckStringFormat", (e, t) => {
  var n, r;
  Ji.init(e, t), e._zod.onattach.push((i) => {
    const o = i._zod.bag;
    o.format = t.format, t.pattern && (o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(t.pattern));
  }), t.pattern ? (n = e._zod).check ?? (n.check = (i) => {
    t.pattern.lastIndex = 0, !t.pattern.test(i.value) && i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: i.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (r = e._zod).check ?? (r.check = () => {
  });
}), gge = /* @__PURE__ */ Pe("$ZodCheckRegex", (e, t) => {
  Ww.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: n.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), yge = /* @__PURE__ */ Pe("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = cge), Ww.init(e, t);
}), vge = /* @__PURE__ */ Pe("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = uge), Ww.init(e, t);
}), bge = /* @__PURE__ */ Pe("$ZodCheckIncludes", (e, t) => {
  Ji.init(e, t);
  const n = Sh(t.includes), r = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = r, e._zod.onattach.push((i) => {
    const o = i._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(r);
  }), e._zod.check = (i) => {
    i.value.includes(t.includes, t.position) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), xge = /* @__PURE__ */ Pe("$ZodCheckStartsWith", (e, t) => {
  Ji.init(e, t);
  const n = new RegExp(`^${Sh(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.startsWith(t.prefix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), wge = /* @__PURE__ */ Pe("$ZodCheckEndsWith", (e, t) => {
  Ji.init(e, t);
  const n = new RegExp(`.*${Sh(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.endsWith(t.suffix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Sge = /* @__PURE__ */ Pe("$ZodCheckOverwrite", (e, t) => {
  Ji.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
class kge {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const r = t.split(`
`).filter((s) => s), i = Math.min(...r.map((s) => s.length - s.trimStart().length)), o = r.map((s) => s.slice(i)).map((s) => " ".repeat(this.indent * 2) + s);
    for (const s of o)
      this.content.push(s);
  }
  compile() {
    const t = Function, n = this?.args, i = [...(this?.content ?? [""]).map((o) => `  ${o}`)];
    return new t(...n, i.join(`
`));
  }
}
const Cge = {
  major: 4,
  minor: 3,
  patch: 6
}, Hn = /* @__PURE__ */ Pe("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = Cge;
  const r = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && r.unshift(e);
  for (const i of r)
    for (const o of i._zod.onattach)
      o(e);
  if (r.length === 0)
    (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const i = (s, a, c) => {
      let u = Kf(s), f;
      for (const h of a) {
        if (h._zod.def.when) {
          if (!h._zod.def.when(s))
            continue;
        } else if (u)
          continue;
        const m = s.issues.length, g = h._zod.check(s);
        if (g instanceof Promise && c?.async === !1)
          throw new sh();
        if (f || g instanceof Promise)
          f = (f ?? Promise.resolve()).then(async () => {
            await g, s.issues.length !== m && (u || (u = Kf(s, m)));
          });
        else {
          if (s.issues.length === m)
            continue;
          u || (u = Kf(s, m));
        }
      }
      return f ? f.then(() => s) : s;
    }, o = (s, a, c) => {
      if (Kf(s))
        return s.aborted = !0, s;
      const u = i(a, r, c);
      if (u instanceof Promise) {
        if (c.async === !1)
          throw new sh();
        return u.then((f) => e._zod.parse(f, c));
      }
      return e._zod.parse(u, c);
    };
    e._zod.run = (s, a) => {
      if (a.skipChecks)
        return e._zod.parse(s, a);
      if (a.direction === "backward") {
        const u = e._zod.parse({ value: s.value, issues: [] }, { ...a, skipChecks: !0 });
        return u instanceof Promise ? u.then((f) => o(f, s, a)) : o(u, s, a);
      }
      const c = e._zod.parse(s, a);
      if (c instanceof Promise) {
        if (a.async === !1)
          throw new sh();
        return c.then((u) => i(u, r, a));
      }
      return i(c, r, a);
    };
  }
  nn(e, "~standard", () => ({
    validate: (i) => {
      try {
        const o = Mme(e, i);
        return o.success ? { value: o.data } : { issues: o.error?.issues };
      } catch {
        return Nme(e, i).then((s) => s.success ? { value: s.data } : { issues: s.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), XM = /* @__PURE__ */ Pe("$ZodString", (e, t) => {
  Hn.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? oge(e._zod.bag), e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), Zn = /* @__PURE__ */ Pe("$ZodStringFormat", (e, t) => {
  Ww.init(e, t), XM.init(e, t);
}), Ege = /* @__PURE__ */ Pe("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = qme), Zn.init(e, t);
}), _ge = /* @__PURE__ */ Pe("$ZodUUID", (e, t) => {
  if (t.version) {
    const r = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (r === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = Uj(r));
  } else
    t.pattern ?? (t.pattern = Uj());
  Zn.init(e, t);
}), Tge = /* @__PURE__ */ Pe("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = Gme), Zn.init(e, t);
}), Age = /* @__PURE__ */ Pe("$ZodURL", (e, t) => {
  Zn.init(e, t), e._zod.check = (n) => {
    try {
      const r = n.value.trim(), i = new URL(r);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(i.hostname) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: t.hostname.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(i.protocol.endsWith(":") ? i.protocol.slice(0, -1) : i.protocol) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? n.value = i.href : n.value = r;
      return;
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "url",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), Mge = /* @__PURE__ */ Pe("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = Zme()), Zn.init(e, t);
}), Nge = /* @__PURE__ */ Pe("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = Hme), Zn.init(e, t);
}), Rge = /* @__PURE__ */ Pe("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = Bme), Zn.init(e, t);
}), Oge = /* @__PURE__ */ Pe("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = $me), Zn.init(e, t);
}), Pge = /* @__PURE__ */ Pe("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = Ume), Zn.init(e, t);
}), Dge = /* @__PURE__ */ Pe("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = Fme), Zn.init(e, t);
}), Ige = /* @__PURE__ */ Pe("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = Vme), Zn.init(e, t);
}), jge = /* @__PURE__ */ Pe("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = ige(t)), Zn.init(e, t);
}), zge = /* @__PURE__ */ Pe("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = nge), Zn.init(e, t);
}), Lge = /* @__PURE__ */ Pe("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = rge(t)), Zn.init(e, t);
}), Bge = /* @__PURE__ */ Pe("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = Wme), Zn.init(e, t);
}), $ge = /* @__PURE__ */ Pe("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = Yme), Zn.init(e, t), e._zod.bag.format = "ipv4";
}), Uge = /* @__PURE__ */ Pe("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = Xme), Zn.init(e, t), e._zod.bag.format = "ipv6", e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), Fge = /* @__PURE__ */ Pe("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = Jme), Zn.init(e, t);
}), Vge = /* @__PURE__ */ Pe("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = Qme), Zn.init(e, t), e._zod.check = (n) => {
    const r = n.value.split("/");
    try {
      if (r.length !== 2)
        throw new Error();
      const [i, o] = r;
      if (!o)
        throw new Error();
      const s = Number(o);
      if (`${s}` !== o)
        throw new Error();
      if (s < 0 || s > 128)
        throw new Error();
      new URL(`http://[${i}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function d8(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const Hge = /* @__PURE__ */ Pe("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = ege), Zn.init(e, t), e._zod.bag.contentEncoding = "base64", e._zod.check = (n) => {
    d8(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function Wge(e) {
  if (!i8.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (r) => r === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return d8(n);
}
const qge = /* @__PURE__ */ Pe("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = i8), Zn.init(e, t), e._zod.bag.contentEncoding = "base64url", e._zod.check = (n) => {
    Wge(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Gge = /* @__PURE__ */ Pe("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = tge), Zn.init(e, t);
});
function Kge(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3)
      return !1;
    const [r] = n;
    if (!r)
      return !1;
    const i = JSON.parse(atob(r));
    return !("typ" in i && i?.typ !== "JWT" || !i.alg || t && (!("alg" in i) || i.alg !== t));
  } catch {
    return !1;
  }
}
const Zge = /* @__PURE__ */ Pe("$ZodJWT", (e, t) => {
  Zn.init(e, t), e._zod.check = (n) => {
    Kge(n.value, t.alg) || n.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), f8 = /* @__PURE__ */ Pe("$ZodNumber", (e, t) => {
  Hn.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? a8, e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = Number(n.value);
      } catch {
      }
    const i = n.value;
    if (typeof i == "number" && !Number.isNaN(i) && Number.isFinite(i))
      return n;
    const o = typeof i == "number" ? Number.isNaN(i) ? "NaN" : Number.isFinite(i) ? void 0 : "Infinity" : void 0;
    return n.issues.push({
      expected: "number",
      code: "invalid_type",
      input: i,
      inst: e,
      ...o ? { received: o } : {}
    }), n;
  };
}), Yge = /* @__PURE__ */ Pe("$ZodNumberFormat", (e, t) => {
  fge.init(e, t), f8.init(e, t);
}), Xge = /* @__PURE__ */ Pe("$ZodBoolean", (e, t) => {
  Hn.init(e, t), e._zod.pattern = age, e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = !!n.value;
      } catch {
      }
    const i = n.value;
    return typeof i == "boolean" || n.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: i,
      inst: e
    }), n;
  };
}), Jge = /* @__PURE__ */ Pe("$ZodNull", (e, t) => {
  Hn.init(e, t), e._zod.pattern = lge, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (n, r) => {
    const i = n.value;
    return i === null || n.issues.push({
      expected: "null",
      code: "invalid_type",
      input: i,
      inst: e
    }), n;
  };
}), Qge = /* @__PURE__ */ Pe("$ZodUnknown", (e, t) => {
  Hn.init(e, t), e._zod.parse = (n) => n;
}), eye = /* @__PURE__ */ Pe("$ZodNever", (e, t) => {
  Hn.init(e, t), e._zod.parse = (n, r) => (n.issues.push({
    expected: "never",
    code: "invalid_type",
    input: n.value,
    inst: e
  }), n);
});
function Fj(e, t, n) {
  e.issues.length && t.issues.push(...Zf(n, e.issues)), t.value[n] = e.value;
}
const tye = /* @__PURE__ */ Pe("$ZodArray", (e, t) => {
  Hn.init(e, t), e._zod.parse = (n, r) => {
    const i = n.value;
    if (!Array.isArray(i))
      return n.issues.push({
        expected: "array",
        code: "invalid_type",
        input: i,
        inst: e
      }), n;
    n.value = Array(i.length);
    const o = [];
    for (let s = 0; s < i.length; s++) {
      const a = i[s], c = t.element._zod.run({
        value: a,
        issues: []
      }, r);
      c instanceof Promise ? o.push(c.then((u) => Fj(u, n, s))) : Fj(c, n, s);
    }
    return o.length ? Promise.all(o).then(() => n) : n;
  };
});
function Lb(e, t, n, r, i) {
  if (e.issues.length) {
    if (i && !(n in r))
      return;
    t.issues.push(...Zf(n, e.issues));
  }
  e.value === void 0 ? n in r && (t.value[n] = void 0) : t.value[n] = e.value;
}
function h8(e) {
  const t = Object.keys(e.shape);
  for (const r of t)
    if (!e.shape?.[r]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${r}": expected a Zod schema`);
  const n = vme(e.shape);
  return {
    ...e,
    keys: t,
    keySet: new Set(t),
    numKeys: t.length,
    optionalKeys: new Set(n)
  };
}
function p8(e, t, n, r, i, o) {
  const s = [], a = i.keySet, c = i.catchall._zod, u = c.def.type, f = c.optout === "optional";
  for (const h in t) {
    if (a.has(h))
      continue;
    if (u === "never") {
      s.push(h);
      continue;
    }
    const m = c.run({ value: t[h], issues: [] }, r);
    m instanceof Promise ? e.push(m.then((g) => Lb(g, n, h, t, f))) : Lb(m, n, h, t, f);
  }
  return s.length && n.issues.push({
    code: "unrecognized_keys",
    keys: s,
    input: t,
    inst: o
  }), e.length ? Promise.all(e).then(() => n) : n;
}
const nye = /* @__PURE__ */ Pe("$ZodObject", (e, t) => {
  if (Hn.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
    const a = t.shape;
    Object.defineProperty(t, "shape", {
      get: () => {
        const c = { ...a };
        return Object.defineProperty(t, "shape", {
          value: c
        }), c;
      }
    });
  }
  const r = Fw(() => h8(t));
  nn(e._zod, "propValues", () => {
    const a = t.shape, c = {};
    for (const u in a) {
      const f = a[u]._zod;
      if (f.values) {
        c[u] ?? (c[u] = /* @__PURE__ */ new Set());
        for (const h of f.values)
          c[u].add(h);
      }
    }
    return c;
  });
  const i = gg, o = t.catchall;
  let s;
  e._zod.parse = (a, c) => {
    s ?? (s = r.value);
    const u = a.value;
    if (!i(u))
      return a.issues.push({
        expected: "object",
        code: "invalid_type",
        input: u,
        inst: e
      }), a;
    a.value = {};
    const f = [], h = s.shape;
    for (const m of s.keys) {
      const g = h[m], b = g._zod.optout === "optional", x = g._zod.run({ value: u[m], issues: [] }, c);
      x instanceof Promise ? f.push(x.then((w) => Lb(w, a, m, u, b))) : Lb(x, a, m, u, b);
    }
    return o ? p8(f, u, a, c, r.value, e) : f.length ? Promise.all(f).then(() => a) : a;
  };
}), rye = /* @__PURE__ */ Pe("$ZodObjectJIT", (e, t) => {
  nye.init(e, t);
  const n = e._zod.parse, r = Fw(() => h8(t)), i = (m) => {
    const g = new kge(["shape", "payload", "ctx"]), b = r.value, x = (M) => {
      const N = $j(M);
      return `shape[${N}]._zod.run({ value: input[${N}], issues: [] }, ctx)`;
    };
    g.write("const input = payload.value;");
    const w = /* @__PURE__ */ Object.create(null);
    let S = 0;
    for (const M of b.keys)
      w[M] = `key_${S++}`;
    g.write("const newResult = {};");
    for (const M of b.keys) {
      const N = w[M], D = $j(M), O = m[M]?._zod?.optout === "optional";
      g.write(`const ${N} = ${x(M)};`), O ? g.write(`
        if (${N}.issues.length) {
          if (${D} in input) {
            payload.issues = payload.issues.concat(${N}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${D}, ...iss.path] : [${D}]
            })));
          }
        }
        
        if (${N}.value === undefined) {
          if (${D} in input) {
            newResult[${D}] = undefined;
          }
        } else {
          newResult[${D}] = ${N}.value;
        }
        
      `) : g.write(`
        if (${N}.issues.length) {
          payload.issues = payload.issues.concat(${N}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${D}, ...iss.path] : [${D}]
          })));
        }
        
        if (${N}.value === undefined) {
          if (${D} in input) {
            newResult[${D}] = undefined;
          }
        } else {
          newResult[${D}] = ${N}.value;
        }
        
      `);
    }
    g.write("payload.value = newResult;"), g.write("return payload;");
    const _ = g.compile();
    return (M, N) => _(m, M, N);
  };
  let o;
  const s = gg, a = !XF.jitless, u = a && gme.value, f = t.catchall;
  let h;
  e._zod.parse = (m, g) => {
    h ?? (h = r.value);
    const b = m.value;
    return s(b) ? a && u && g?.async === !1 && g.jitless !== !0 ? (o || (o = i(t.shape)), m = o(m, g), f ? p8([], b, m, g, h, e) : m) : n(m, g) : (m.issues.push({
      expected: "object",
      code: "invalid_type",
      input: b,
      inst: e
    }), m);
  };
});
function Vj(e, t, n, r) {
  for (const o of e)
    if (o.issues.length === 0)
      return t.value = o.value, t;
  const i = e.filter((o) => !Kf(o));
  return i.length === 1 ? (t.value = i[0].value, i[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: n,
    errors: e.map((o) => o.issues.map((s) => jc(s, r, Ic())))
  }), t);
}
const m8 = /* @__PURE__ */ Pe("$ZodUnion", (e, t) => {
  Hn.init(e, t), nn(e._zod, "optin", () => t.options.some((i) => i._zod.optin === "optional") ? "optional" : void 0), nn(e._zod, "optout", () => t.options.some((i) => i._zod.optout === "optional") ? "optional" : void 0), nn(e._zod, "values", () => {
    if (t.options.every((i) => i._zod.values))
      return new Set(t.options.flatMap((i) => Array.from(i._zod.values)));
  }), nn(e._zod, "pattern", () => {
    if (t.options.every((i) => i._zod.pattern)) {
      const i = t.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${i.map((o) => GM(o.source)).join("|")})$`);
    }
  });
  const n = t.options.length === 1, r = t.options[0]._zod.run;
  e._zod.parse = (i, o) => {
    if (n)
      return r(i, o);
    let s = !1;
    const a = [];
    for (const c of t.options) {
      const u = c._zod.run({
        value: i.value,
        issues: []
      }, o);
      if (u instanceof Promise)
        a.push(u), s = !0;
      else {
        if (u.issues.length === 0)
          return u;
        a.push(u);
      }
    }
    return s ? Promise.all(a).then((c) => Vj(c, i, e, o)) : Vj(a, i, e, o);
  };
}), iye = /* @__PURE__ */ Pe("$ZodDiscriminatedUnion", (e, t) => {
  t.inclusive = !1, m8.init(e, t);
  const n = e._zod.parse;
  nn(e._zod, "propValues", () => {
    const i = {};
    for (const o of t.options) {
      const s = o._zod.propValues;
      if (!s || Object.keys(s).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(o)}"`);
      for (const [a, c] of Object.entries(s)) {
        i[a] || (i[a] = /* @__PURE__ */ new Set());
        for (const u of c)
          i[a].add(u);
      }
    }
    return i;
  });
  const r = Fw(() => {
    const i = t.options, o = /* @__PURE__ */ new Map();
    for (const s of i) {
      const a = s._zod.propValues?.[t.discriminator];
      if (!a || a.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(s)}"`);
      for (const c of a) {
        if (o.has(c))
          throw new Error(`Duplicate discriminator value "${String(c)}"`);
        o.set(c, s);
      }
    }
    return o;
  });
  e._zod.parse = (i, o) => {
    const s = i.value;
    if (!gg(s))
      return i.issues.push({
        code: "invalid_type",
        expected: "object",
        input: s,
        inst: e
      }), i;
    const a = r.value.get(s?.[t.discriminator]);
    return a ? a._zod.run(i, o) : t.unionFallback ? n(i, o) : (i.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: t.discriminator,
      input: s,
      path: [t.discriminator],
      inst: e
    }), i);
  };
}), oye = /* @__PURE__ */ Pe("$ZodIntersection", (e, t) => {
  Hn.init(e, t), e._zod.parse = (n, r) => {
    const i = n.value, o = t.left._zod.run({ value: i, issues: [] }, r), s = t.right._zod.run({ value: i, issues: [] }, r);
    return o instanceof Promise || s instanceof Promise ? Promise.all([o, s]).then(([c, u]) => Hj(n, c, u)) : Hj(n, o, s);
  };
});
function Y_(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (wh(e) && wh(t)) {
    const n = Object.keys(t), r = Object.keys(e).filter((o) => n.indexOf(o) !== -1), i = { ...e, ...t };
    for (const o of r) {
      const s = Y_(e[o], t[o]);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [o, ...s.mergeErrorPath]
        };
      i[o] = s.data;
    }
    return { valid: !0, data: i };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const i = e[r], o = t[r], s = Y_(i, o);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...s.mergeErrorPath]
        };
      n.push(s.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function Hj(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  let i;
  for (const a of t.issues)
    if (a.code === "unrecognized_keys") {
      i ?? (i = a);
      for (const c of a.keys)
        r.has(c) || r.set(c, {}), r.get(c).l = !0;
    } else
      e.issues.push(a);
  for (const a of n.issues)
    if (a.code === "unrecognized_keys")
      for (const c of a.keys)
        r.has(c) || r.set(c, {}), r.get(c).r = !0;
    else
      e.issues.push(a);
  const o = [...r].filter(([, a]) => a.l && a.r).map(([a]) => a);
  if (o.length && i && e.issues.push({ ...i, keys: o }), Kf(e))
    return e;
  const s = Y_(t.value, n.value);
  if (!s.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(s.mergeErrorPath)}`);
  return e.value = s.data, e;
}
const sye = /* @__PURE__ */ Pe("$ZodRecord", (e, t) => {
  Hn.init(e, t), e._zod.parse = (n, r) => {
    const i = n.value;
    if (!wh(i))
      return n.issues.push({
        expected: "record",
        code: "invalid_type",
        input: i,
        inst: e
      }), n;
    const o = [], s = t.keyType._zod.values;
    if (s) {
      n.value = {};
      const a = /* @__PURE__ */ new Set();
      for (const u of s)
        if (typeof u == "string" || typeof u == "number" || typeof u == "symbol") {
          a.add(typeof u == "number" ? u.toString() : u);
          const f = t.valueType._zod.run({ value: i[u], issues: [] }, r);
          f instanceof Promise ? o.push(f.then((h) => {
            h.issues.length && n.issues.push(...Zf(u, h.issues)), n.value[u] = h.value;
          })) : (f.issues.length && n.issues.push(...Zf(u, f.issues)), n.value[u] = f.value);
        }
      let c;
      for (const u in i)
        a.has(u) || (c = c ?? [], c.push(u));
      c && c.length > 0 && n.issues.push({
        code: "unrecognized_keys",
        input: i,
        inst: e,
        keys: c
      });
    } else {
      n.value = {};
      for (const a of Reflect.ownKeys(i)) {
        if (a === "__proto__")
          continue;
        let c = t.keyType._zod.run({ value: a, issues: [] }, r);
        if (c instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (typeof a == "string" && a8.test(a) && c.issues.length) {
          const h = t.keyType._zod.run({ value: Number(a), issues: [] }, r);
          if (h instanceof Promise)
            throw new Error("Async schemas not supported in object keys currently");
          h.issues.length === 0 && (c = h);
        }
        if (c.issues.length) {
          t.mode === "loose" ? n.value[a] = i[a] : n.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: c.issues.map((h) => jc(h, r, Ic())),
            input: a,
            path: [a],
            inst: e
          });
          continue;
        }
        const f = t.valueType._zod.run({ value: i[a], issues: [] }, r);
        f instanceof Promise ? o.push(f.then((h) => {
          h.issues.length && n.issues.push(...Zf(a, h.issues)), n.value[c.value] = h.value;
        })) : (f.issues.length && n.issues.push(...Zf(a, f.issues)), n.value[c.value] = f.value);
      }
    }
    return o.length ? Promise.all(o).then(() => n) : n;
  };
}), aye = /* @__PURE__ */ Pe("$ZodEnum", (e, t) => {
  Hn.init(e, t);
  const n = JF(t.entries), r = new Set(n);
  e._zod.values = r, e._zod.pattern = new RegExp(`^(${n.filter((i) => yme.has(typeof i)).map((i) => typeof i == "string" ? Sh(i) : i.toString()).join("|")})$`), e._zod.parse = (i, o) => {
    const s = i.value;
    return r.has(s) || i.issues.push({
      code: "invalid_value",
      values: n,
      input: s,
      inst: e
    }), i;
  };
}), lye = /* @__PURE__ */ Pe("$ZodLiteral", (e, t) => {
  if (Hn.init(e, t), t.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  const n = new Set(t.values);
  e._zod.values = n, e._zod.pattern = new RegExp(`^(${t.values.map((r) => typeof r == "string" ? Sh(r) : r ? Sh(r.toString()) : String(r)).join("|")})$`), e._zod.parse = (r, i) => {
    const o = r.value;
    return n.has(o) || r.issues.push({
      code: "invalid_value",
      values: t.values,
      input: o,
      inst: e
    }), r;
  };
}), cye = /* @__PURE__ */ Pe("$ZodTransform", (e, t) => {
  Hn.init(e, t), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      throw new YF(e.constructor.name);
    const i = t.transform(n.value, n);
    if (r.async)
      return (i instanceof Promise ? i : Promise.resolve(i)).then((s) => (n.value = s, n));
    if (i instanceof Promise)
      throw new sh();
    return n.value = i, n;
  };
});
function Wj(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
const g8 = /* @__PURE__ */ Pe("$ZodOptional", (e, t) => {
  Hn.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", nn(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), nn(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${GM(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, r) => {
    if (t.innerType._zod.optin === "optional") {
      const i = t.innerType._zod.run(n, r);
      return i instanceof Promise ? i.then((o) => Wj(o, n.value)) : Wj(i, n.value);
    }
    return n.value === void 0 ? n : t.innerType._zod.run(n, r);
  };
}), uye = /* @__PURE__ */ Pe("$ZodExactOptional", (e, t) => {
  g8.init(e, t), nn(e._zod, "values", () => t.innerType._zod.values), nn(e._zod, "pattern", () => t.innerType._zod.pattern), e._zod.parse = (n, r) => t.innerType._zod.run(n, r);
}), dye = /* @__PURE__ */ Pe("$ZodNullable", (e, t) => {
  Hn.init(e, t), nn(e._zod, "optin", () => t.innerType._zod.optin), nn(e._zod, "optout", () => t.innerType._zod.optout), nn(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${GM(n.source)}|null)$`) : void 0;
  }), nn(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, r) => n.value === null ? n : t.innerType._zod.run(n, r);
}), fye = /* @__PURE__ */ Pe("$ZodDefault", (e, t) => {
  Hn.init(e, t), e._zod.optin = "optional", nn(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    if (n.value === void 0)
      return n.value = t.defaultValue, n;
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((o) => qj(o, t)) : qj(i, t);
  };
});
function qj(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const hye = /* @__PURE__ */ Pe("$ZodPrefault", (e, t) => {
  Hn.init(e, t), e._zod.optin = "optional", nn(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => (r.direction === "backward" || n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, r));
}), pye = /* @__PURE__ */ Pe("$ZodNonOptional", (e, t) => {
  Hn.init(e, t), nn(e._zod, "values", () => {
    const n = t.innerType._zod.values;
    return n ? new Set([...n].filter((r) => r !== void 0)) : void 0;
  }), e._zod.parse = (n, r) => {
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((o) => Gj(o, e)) : Gj(i, e);
  };
});
function Gj(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const mye = /* @__PURE__ */ Pe("$ZodCatch", (e, t) => {
  Hn.init(e, t), nn(e._zod, "optin", () => t.innerType._zod.optin), nn(e._zod, "optout", () => t.innerType._zod.optout), nn(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((o) => (n.value = o.value, o.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: o.issues.map((s) => jc(s, r, Ic()))
      },
      input: n.value
    }), n.issues = []), n)) : (n.value = i.value, i.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: i.issues.map((o) => jc(o, r, Ic()))
      },
      input: n.value
    }), n.issues = []), n);
  };
}), gye = /* @__PURE__ */ Pe("$ZodPipe", (e, t) => {
  Hn.init(e, t), nn(e._zod, "values", () => t.in._zod.values), nn(e._zod, "optin", () => t.in._zod.optin), nn(e._zod, "optout", () => t.out._zod.optout), nn(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, r) => {
    if (r.direction === "backward") {
      const o = t.out._zod.run(n, r);
      return o instanceof Promise ? o.then((s) => Qv(s, t.in, r)) : Qv(o, t.in, r);
    }
    const i = t.in._zod.run(n, r);
    return i instanceof Promise ? i.then((o) => Qv(o, t.out, r)) : Qv(i, t.out, r);
  };
});
function Qv(e, t, n) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, n);
}
const yye = /* @__PURE__ */ Pe("$ZodReadonly", (e, t) => {
  Hn.init(e, t), nn(e._zod, "propValues", () => t.innerType._zod.propValues), nn(e._zod, "values", () => t.innerType._zod.values), nn(e._zod, "optin", () => t.innerType?._zod?.optin), nn(e._zod, "optout", () => t.innerType?._zod?.optout), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then(Kj) : Kj(i);
  };
});
function Kj(e) {
  return e.value = Object.freeze(e.value), e;
}
const vye = /* @__PURE__ */ Pe("$ZodLazy", (e, t) => {
  Hn.init(e, t), nn(e._zod, "innerType", () => t.getter()), nn(e._zod, "pattern", () => e._zod.innerType?._zod?.pattern), nn(e._zod, "propValues", () => e._zod.innerType?._zod?.propValues), nn(e._zod, "optin", () => e._zod.innerType?._zod?.optin ?? void 0), nn(e._zod, "optout", () => e._zod.innerType?._zod?.optout ?? void 0), e._zod.parse = (n, r) => e._zod.innerType._zod.run(n, r);
}), bye = /* @__PURE__ */ Pe("$ZodCustom", (e, t) => {
  Ji.init(e, t), Hn.init(e, t), e._zod.parse = (n, r) => n, e._zod.check = (n) => {
    const r = n.value, i = t.fn(r);
    if (i instanceof Promise)
      return i.then((o) => Zj(o, n, r, e));
    Zj(i, n, r, e);
  };
});
function Zj(e, t, n, r) {
  if (!e) {
    const i = {
      code: "custom",
      input: n,
      inst: r,
      // incorporates params.error into issue reporting
      path: [...r._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !r._zod.def.abort
      // params: inst._zod.def.params,
    };
    r._zod.def.params && (i.params = r._zod.def.params), t.issues.push(yg(i));
  }
}
var Yj;
class xye {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    const r = n[0];
    return this._map.set(t, r), r && typeof r == "object" && "id" in r && this._idmap.set(r.id, t), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const n = this._map.get(t);
    return n && typeof n == "object" && "id" in n && this._idmap.delete(n.id), this._map.delete(t), this;
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const r = { ...this.get(n) ?? {} };
      delete r.id;
      const i = { ...r, ...this._map.get(t) };
      return Object.keys(i).length ? i : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function wye() {
  return new xye();
}
(Yj = globalThis).__zod_globalRegistry ?? (Yj.__zod_globalRegistry = wye());
const Sm = globalThis.__zod_globalRegistry;
// @__NO_SIDE_EFFECTS__
function Sye(e, t) {
  return new e({
    type: "string",
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function kye(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Xj(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Cye(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Eye(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function _ye(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Tye(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Aye(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Mye(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Nye(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Rye(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Oye(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Pye(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Dye(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Iye(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function jye(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function zye(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Lye(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Bye(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function $ye(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Uye(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Fye(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Vye(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Hye(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Wye(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function qye(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Gye(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Kye(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Zye(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Yye(e, t) {
  return new e({
    type: "boolean",
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Xye(e, t) {
  return new e({
    type: "null",
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Jye(e) {
  return new e({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function Qye(e, t) {
  return new e({
    type: "never",
    ...ut(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Jj(e, t) {
  return new c8({
    check: "less_than",
    ...ut(t),
    value: e,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function kC(e, t) {
  return new c8({
    check: "less_than",
    ...ut(t),
    value: e,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function Qj(e, t) {
  return new u8({
    check: "greater_than",
    ...ut(t),
    value: e,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function CC(e, t) {
  return new u8({
    check: "greater_than",
    ...ut(t),
    value: e,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function ez(e, t) {
  return new dge({
    check: "multiple_of",
    ...ut(t),
    value: e
  });
}
// @__NO_SIDE_EFFECTS__
function y8(e, t) {
  return new hge({
    check: "max_length",
    ...ut(t),
    maximum: e
  });
}
// @__NO_SIDE_EFFECTS__
function Bb(e, t) {
  return new pge({
    check: "min_length",
    ...ut(t),
    minimum: e
  });
}
// @__NO_SIDE_EFFECTS__
function v8(e, t) {
  return new mge({
    check: "length_equals",
    ...ut(t),
    length: e
  });
}
// @__NO_SIDE_EFFECTS__
function eve(e, t) {
  return new gge({
    check: "string_format",
    format: "regex",
    ...ut(t),
    pattern: e
  });
}
// @__NO_SIDE_EFFECTS__
function tve(e) {
  return new yge({
    check: "string_format",
    format: "lowercase",
    ...ut(e)
  });
}
// @__NO_SIDE_EFFECTS__
function nve(e) {
  return new vge({
    check: "string_format",
    format: "uppercase",
    ...ut(e)
  });
}
// @__NO_SIDE_EFFECTS__
function rve(e, t) {
  return new bge({
    check: "string_format",
    format: "includes",
    ...ut(t),
    includes: e
  });
}
// @__NO_SIDE_EFFECTS__
function ive(e, t) {
  return new xge({
    check: "string_format",
    format: "starts_with",
    ...ut(t),
    prefix: e
  });
}
// @__NO_SIDE_EFFECTS__
function ove(e, t) {
  return new wge({
    check: "string_format",
    format: "ends_with",
    ...ut(t),
    suffix: e
  });
}
// @__NO_SIDE_EFFECTS__
function Yh(e) {
  return new Sge({
    check: "overwrite",
    tx: e
  });
}
// @__NO_SIDE_EFFECTS__
function sve(e) {
  return /* @__PURE__ */ Yh((t) => t.normalize(e));
}
// @__NO_SIDE_EFFECTS__
function ave() {
  return /* @__PURE__ */ Yh((e) => e.trim());
}
// @__NO_SIDE_EFFECTS__
function lve() {
  return /* @__PURE__ */ Yh((e) => e.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function cve() {
  return /* @__PURE__ */ Yh((e) => e.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function uve() {
  return /* @__PURE__ */ Yh((e) => mme(e));
}
// @__NO_SIDE_EFFECTS__
function dve(e, t, n) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...ut(n)
  });
}
// @__NO_SIDE_EFFECTS__
function fve(e, t, n) {
  const r = ut(n);
  return r.abort ?? (r.abort = !0), new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...r
  });
}
// @__NO_SIDE_EFFECTS__
function hve(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...ut(n)
  });
}
// @__NO_SIDE_EFFECTS__
function pve(e) {
  const t = /* @__PURE__ */ mve((n) => (n.addIssue = (r) => {
    if (typeof r == "string")
      n.issues.push(yg(r, n.value, t._zod.def));
    else {
      const i = r;
      i.fatal && (i.continue = !1), i.code ?? (i.code = "custom"), i.input ?? (i.input = n.value), i.inst ?? (i.inst = t), i.continue ?? (i.continue = !t._zod.def.abort), n.issues.push(yg(i));
    }
  }, e(n.value, n)));
  return t;
}
// @__NO_SIDE_EFFECTS__
function mve(e, t) {
  const n = new Ji({
    check: "custom",
    ...ut(t)
  });
  return n._zod.check = e, n;
}
function $b(e) {
  let t = e?.target ?? "draft-2020-12";
  return t === "draft-4" && (t = "draft-04"), t === "draft-7" && (t = "draft-07"), {
    processors: e.processors ?? {},
    metadataRegistry: e?.metadata ?? Sm,
    target: t,
    unrepresentable: e?.unrepresentable ?? "throw",
    override: e?.override ?? (() => {
    }),
    io: e?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: e?.cycles ?? "ref",
    reused: e?.reused ?? "inline",
    external: e?.external ?? void 0
  };
}
function Pn(e, t, n = { path: [], schemaPath: [] }) {
  var r;
  const i = e._zod.def, o = t.seen.get(e);
  if (o)
    return o.count++, n.schemaPath.includes(e) && (o.cycle = n.path), o.schema;
  const s = { schema: {}, count: 1, cycle: void 0, path: n.path };
  t.seen.set(e, s);
  const a = e._zod.toJSONSchema?.();
  if (a)
    s.schema = a;
  else {
    const f = {
      ...n,
      schemaPath: [...n.schemaPath, e],
      path: n.path
    };
    if (e._zod.processJSONSchema)
      e._zod.processJSONSchema(t, s.schema, f);
    else {
      const m = s.schema, g = t.processors[i.type];
      if (!g)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${i.type}`);
      g(e, t, m, f);
    }
    const h = e._zod.parent;
    h && (s.ref || (s.ref = h), Pn(h, t, f), t.seen.get(h).isParent = !0);
  }
  const c = t.metadataRegistry.get(e);
  return c && Object.assign(s.schema, c), t.io === "input" && Ai(e) && (delete s.schema.examples, delete s.schema.default), t.io === "input" && s.schema._prefault && ((r = s.schema).default ?? (r.default = s.schema._prefault)), delete s.schema._prefault, t.seen.get(e).schema;
}
function Ub(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const r = /* @__PURE__ */ new Map();
  for (const s of e.seen.entries()) {
    const a = e.metadataRegistry.get(s[0])?.id;
    if (a) {
      const c = r.get(a);
      if (c && c !== s[0])
        throw new Error(`Duplicate schema id "${a}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      r.set(a, s[0]);
    }
  }
  const i = (s) => {
    const a = e.target === "draft-2020-12" ? "$defs" : "definitions";
    if (e.external) {
      const h = e.external.registry.get(s[0])?.id, m = e.external.uri ?? ((b) => b);
      if (h)
        return { ref: m(h) };
      const g = s[1].defId ?? s[1].schema.id ?? `schema${e.counter++}`;
      return s[1].defId = g, { defId: g, ref: `${m("__shared")}#/${a}/${g}` };
    }
    if (s[1] === n)
      return { ref: "#" };
    const u = `#/${a}/`, f = s[1].schema.id ?? `__schema${e.counter++}`;
    return { defId: f, ref: u + f };
  }, o = (s) => {
    if (s[1].schema.$ref)
      return;
    const a = s[1], { ref: c, defId: u } = i(s);
    a.def = { ...a.schema }, u && (a.defId = u);
    const f = a.schema;
    for (const h in f)
      delete f[h];
    f.$ref = c;
  };
  if (e.cycles === "throw")
    for (const s of e.seen.entries()) {
      const a = s[1];
      if (a.cycle)
        throw new Error(`Cycle detected: #/${a.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (const s of e.seen.entries()) {
    const a = s[1];
    if (t === s[0]) {
      o(s);
      continue;
    }
    if (e.external) {
      const u = e.external.registry.get(s[0])?.id;
      if (t !== s[0] && u) {
        o(s);
        continue;
      }
    }
    if (e.metadataRegistry.get(s[0])?.id) {
      o(s);
      continue;
    }
    if (a.cycle) {
      o(s);
      continue;
    }
    if (a.count > 1 && e.reused === "ref") {
      o(s);
      continue;
    }
  }
}
function Fb(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const r = (s) => {
    const a = e.seen.get(s);
    if (a.ref === null)
      return;
    const c = a.def ?? a.schema, u = { ...c }, f = a.ref;
    if (a.ref = null, f) {
      r(f);
      const m = e.seen.get(f), g = m.schema;
      if (g.$ref && (e.target === "draft-07" || e.target === "draft-04" || e.target === "openapi-3.0") ? (c.allOf = c.allOf ?? [], c.allOf.push(g)) : Object.assign(c, g), Object.assign(c, u), s._zod.parent === f)
        for (const x in c)
          x === "$ref" || x === "allOf" || x in u || delete c[x];
      if (g.$ref && m.def)
        for (const x in c)
          x === "$ref" || x === "allOf" || x in m.def && JSON.stringify(c[x]) === JSON.stringify(m.def[x]) && delete c[x];
    }
    const h = s._zod.parent;
    if (h && h !== f) {
      r(h);
      const m = e.seen.get(h);
      if (m?.schema.$ref && (c.$ref = m.schema.$ref, m.def))
        for (const g in c)
          g === "$ref" || g === "allOf" || g in m.def && JSON.stringify(c[g]) === JSON.stringify(m.def[g]) && delete c[g];
    }
    e.override({
      zodSchema: s,
      jsonSchema: c,
      path: a.path ?? []
    });
  };
  for (const s of [...e.seen.entries()].reverse())
    r(s[0]);
  const i = {};
  if (e.target === "draft-2020-12" ? i.$schema = "https://json-schema.org/draft/2020-12/schema" : e.target === "draft-07" ? i.$schema = "http://json-schema.org/draft-07/schema#" : e.target === "draft-04" ? i.$schema = "http://json-schema.org/draft-04/schema#" : e.target, e.external?.uri) {
    const s = e.external.registry.get(t)?.id;
    if (!s)
      throw new Error("Schema is missing an `id` property");
    i.$id = e.external.uri(s);
  }
  Object.assign(i, n.def ?? n.schema);
  const o = e.external?.defs ?? {};
  for (const s of e.seen.entries()) {
    const a = s[1];
    a.def && a.defId && (o[a.defId] = a.def);
  }
  e.external || Object.keys(o).length > 0 && (e.target === "draft-2020-12" ? i.$defs = o : i.definitions = o);
  try {
    const s = JSON.parse(JSON.stringify(i));
    return Object.defineProperty(s, "~standard", {
      value: {
        ...t["~standard"],
        jsonSchema: {
          input: Vb(t, "input", e.processors),
          output: Vb(t, "output", e.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), s;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function Ai(e, t) {
  const n = t ?? { seen: /* @__PURE__ */ new Set() };
  if (n.seen.has(e))
    return !1;
  n.seen.add(e);
  const r = e._zod.def;
  if (r.type === "transform")
    return !0;
  if (r.type === "array")
    return Ai(r.element, n);
  if (r.type === "set")
    return Ai(r.valueType, n);
  if (r.type === "lazy")
    return Ai(r.getter(), n);
  if (r.type === "promise" || r.type === "optional" || r.type === "nonoptional" || r.type === "nullable" || r.type === "readonly" || r.type === "default" || r.type === "prefault")
    return Ai(r.innerType, n);
  if (r.type === "intersection")
    return Ai(r.left, n) || Ai(r.right, n);
  if (r.type === "record" || r.type === "map")
    return Ai(r.keyType, n) || Ai(r.valueType, n);
  if (r.type === "pipe")
    return Ai(r.in, n) || Ai(r.out, n);
  if (r.type === "object") {
    for (const i in r.shape)
      if (Ai(r.shape[i], n))
        return !0;
    return !1;
  }
  if (r.type === "union") {
    for (const i of r.options)
      if (Ai(i, n))
        return !0;
    return !1;
  }
  if (r.type === "tuple") {
    for (const i of r.items)
      if (Ai(i, n))
        return !0;
    return !!(r.rest && Ai(r.rest, n));
  }
  return !1;
}
const gve = (e, t = {}) => (n) => {
  const r = $b({ ...n, processors: t });
  return Pn(e, r), Ub(r, e), Fb(r, e);
}, Vb = (e, t, n = {}) => (r) => {
  const { libraryOptions: i, target: o } = r ?? {}, s = $b({ ...i ?? {}, target: o, io: t, processors: n });
  return Pn(e, s), Ub(s, e), Fb(s, e);
}, yve = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, b8 = (e, t, n, r) => {
  const i = n;
  i.type = "string";
  const { minimum: o, maximum: s, format: a, patterns: c, contentEncoding: u } = e._zod.bag;
  if (typeof o == "number" && (i.minLength = o), typeof s == "number" && (i.maxLength = s), a && (i.format = yve[a] ?? a, i.format === "" && delete i.format, a === "time" && delete i.format), u && (i.contentEncoding = u), c && c.size > 0) {
    const f = [...c];
    f.length === 1 ? i.pattern = f[0].source : f.length > 1 && (i.allOf = [
      ...f.map((h) => ({
        ...t.target === "draft-07" || t.target === "draft-04" || t.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: h.source
      }))
    ]);
  }
}, x8 = (e, t, n, r) => {
  const i = n, { minimum: o, maximum: s, format: a, multipleOf: c, exclusiveMaximum: u, exclusiveMinimum: f } = e._zod.bag;
  typeof a == "string" && a.includes("int") ? i.type = "integer" : i.type = "number", typeof f == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (i.minimum = f, i.exclusiveMinimum = !0) : i.exclusiveMinimum = f), typeof o == "number" && (i.minimum = o, typeof f == "number" && t.target !== "draft-04" && (f >= o ? delete i.minimum : delete i.exclusiveMinimum)), typeof u == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (i.maximum = u, i.exclusiveMaximum = !0) : i.exclusiveMaximum = u), typeof s == "number" && (i.maximum = s, typeof u == "number" && t.target !== "draft-04" && (u <= s ? delete i.maximum : delete i.exclusiveMaximum)), typeof c == "number" && (i.multipleOf = c);
}, w8 = (e, t, n, r) => {
  n.type = "boolean";
}, vve = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("BigInt cannot be represented in JSON Schema");
}, bve = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Symbols cannot be represented in JSON Schema");
}, S8 = (e, t, n, r) => {
  t.target === "openapi-3.0" ? (n.type = "string", n.nullable = !0, n.enum = [null]) : n.type = "null";
}, xve = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Undefined cannot be represented in JSON Schema");
}, wve = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Void cannot be represented in JSON Schema");
}, k8 = (e, t, n, r) => {
  n.not = {};
}, Sve = (e, t, n, r) => {
}, C8 = (e, t, n, r) => {
}, kve = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Date cannot be represented in JSON Schema");
}, E8 = (e, t, n, r) => {
  const i = e._zod.def, o = JF(i.entries);
  o.every((s) => typeof s == "number") && (n.type = "number"), o.every((s) => typeof s == "string") && (n.type = "string"), n.enum = o;
}, _8 = (e, t, n, r) => {
  const i = e._zod.def, o = [];
  for (const s of i.values)
    if (s === void 0) {
      if (t.unrepresentable === "throw")
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof s == "bigint") {
      if (t.unrepresentable === "throw")
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      o.push(Number(s));
    } else
      o.push(s);
  if (o.length !== 0) if (o.length === 1) {
    const s = o[0];
    n.type = s === null ? "null" : typeof s, t.target === "draft-04" || t.target === "openapi-3.0" ? n.enum = [s] : n.const = s;
  } else
    o.every((s) => typeof s == "number") && (n.type = "number"), o.every((s) => typeof s == "string") && (n.type = "string"), o.every((s) => typeof s == "boolean") && (n.type = "boolean"), o.every((s) => s === null) && (n.type = "null"), n.enum = o;
}, Cve = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("NaN cannot be represented in JSON Schema");
}, Eve = (e, t, n, r) => {
  const i = n, o = e._zod.pattern;
  if (!o)
    throw new Error("Pattern not found in template literal");
  i.type = "string", i.pattern = o.source;
}, _ve = (e, t, n, r) => {
  const i = n, o = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  }, { minimum: s, maximum: a, mime: c } = e._zod.bag;
  s !== void 0 && (o.minLength = s), a !== void 0 && (o.maxLength = a), c ? c.length === 1 ? (o.contentMediaType = c[0], Object.assign(i, o)) : (Object.assign(i, o), i.anyOf = c.map((u) => ({ contentMediaType: u }))) : Object.assign(i, o);
}, Tve = (e, t, n, r) => {
  n.type = "boolean";
}, T8 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, Ave = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Function types cannot be represented in JSON Schema");
}, A8 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, Mve = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Map cannot be represented in JSON Schema");
}, Nve = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Set cannot be represented in JSON Schema");
}, M8 = (e, t, n, r) => {
  const i = n, o = e._zod.def, { minimum: s, maximum: a } = e._zod.bag;
  typeof s == "number" && (i.minItems = s), typeof a == "number" && (i.maxItems = a), i.type = "array", i.items = Pn(o.element, t, { ...r, path: [...r.path, "items"] });
}, N8 = (e, t, n, r) => {
  const i = n, o = e._zod.def;
  i.type = "object", i.properties = {};
  const s = o.shape;
  for (const u in s)
    i.properties[u] = Pn(s[u], t, {
      ...r,
      path: [...r.path, "properties", u]
    });
  const a = new Set(Object.keys(s)), c = new Set([...a].filter((u) => {
    const f = o.shape[u]._zod;
    return t.io === "input" ? f.optin === void 0 : f.optout === void 0;
  }));
  c.size > 0 && (i.required = Array.from(c)), o.catchall?._zod.def.type === "never" ? i.additionalProperties = !1 : o.catchall ? o.catchall && (i.additionalProperties = Pn(o.catchall, t, {
    ...r,
    path: [...r.path, "additionalProperties"]
  })) : t.io === "output" && (i.additionalProperties = !1);
}, R8 = (e, t, n, r) => {
  const i = e._zod.def, o = i.inclusive === !1, s = i.options.map((a, c) => Pn(a, t, {
    ...r,
    path: [...r.path, o ? "oneOf" : "anyOf", c]
  }));
  o ? n.oneOf = s : n.anyOf = s;
}, O8 = (e, t, n, r) => {
  const i = e._zod.def, o = Pn(i.left, t, {
    ...r,
    path: [...r.path, "allOf", 0]
  }), s = Pn(i.right, t, {
    ...r,
    path: [...r.path, "allOf", 1]
  }), a = (u) => "allOf" in u && Object.keys(u).length === 1, c = [
    ...a(o) ? o.allOf : [o],
    ...a(s) ? s.allOf : [s]
  ];
  n.allOf = c;
}, Rve = (e, t, n, r) => {
  const i = n, o = e._zod.def;
  i.type = "array";
  const s = t.target === "draft-2020-12" ? "prefixItems" : "items", a = t.target === "draft-2020-12" || t.target === "openapi-3.0" ? "items" : "additionalItems", c = o.items.map((m, g) => Pn(m, t, {
    ...r,
    path: [...r.path, s, g]
  })), u = o.rest ? Pn(o.rest, t, {
    ...r,
    path: [...r.path, a, ...t.target === "openapi-3.0" ? [o.items.length] : []]
  }) : null;
  t.target === "draft-2020-12" ? (i.prefixItems = c, u && (i.items = u)) : t.target === "openapi-3.0" ? (i.items = {
    anyOf: c
  }, u && i.items.anyOf.push(u), i.minItems = c.length, u || (i.maxItems = c.length)) : (i.items = c, u && (i.additionalItems = u));
  const { minimum: f, maximum: h } = e._zod.bag;
  typeof f == "number" && (i.minItems = f), typeof h == "number" && (i.maxItems = h);
}, P8 = (e, t, n, r) => {
  const i = n, o = e._zod.def;
  i.type = "object";
  const s = o.keyType, c = s._zod.bag?.patterns;
  if (o.mode === "loose" && c && c.size > 0) {
    const f = Pn(o.valueType, t, {
      ...r,
      path: [...r.path, "patternProperties", "*"]
    });
    i.patternProperties = {};
    for (const h of c)
      i.patternProperties[h.source] = f;
  } else
    (t.target === "draft-07" || t.target === "draft-2020-12") && (i.propertyNames = Pn(o.keyType, t, {
      ...r,
      path: [...r.path, "propertyNames"]
    })), i.additionalProperties = Pn(o.valueType, t, {
      ...r,
      path: [...r.path, "additionalProperties"]
    });
  const u = s._zod.values;
  if (u) {
    const f = [...u].filter((h) => typeof h == "string" || typeof h == "number");
    f.length > 0 && (i.required = f);
  }
}, D8 = (e, t, n, r) => {
  const i = e._zod.def, o = Pn(i.innerType, t, r), s = t.seen.get(e);
  t.target === "openapi-3.0" ? (s.ref = i.innerType, n.nullable = !0) : n.anyOf = [o, { type: "null" }];
}, I8 = (e, t, n, r) => {
  const i = e._zod.def;
  Pn(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType;
}, j8 = (e, t, n, r) => {
  const i = e._zod.def;
  Pn(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType, n.default = JSON.parse(JSON.stringify(i.defaultValue));
}, z8 = (e, t, n, r) => {
  const i = e._zod.def;
  Pn(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType, t.io === "input" && (n._prefault = JSON.parse(JSON.stringify(i.defaultValue)));
}, L8 = (e, t, n, r) => {
  const i = e._zod.def;
  Pn(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType;
  let s;
  try {
    s = i.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  n.default = s;
}, B8 = (e, t, n, r) => {
  const i = e._zod.def, o = t.io === "input" ? i.in._zod.def.type === "transform" ? i.out : i.in : i.out;
  Pn(o, t, r);
  const s = t.seen.get(e);
  s.ref = o;
}, $8 = (e, t, n, r) => {
  const i = e._zod.def;
  Pn(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType, n.readOnly = !0;
}, Ove = (e, t, n, r) => {
  const i = e._zod.def;
  Pn(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType;
}, JM = (e, t, n, r) => {
  const i = e._zod.def;
  Pn(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType;
}, U8 = (e, t, n, r) => {
  const i = e._zod.innerType;
  Pn(i, t, r);
  const o = t.seen.get(e);
  o.ref = i;
}, tz = {
  string: b8,
  number: x8,
  boolean: w8,
  bigint: vve,
  symbol: bve,
  null: S8,
  undefined: xve,
  void: wve,
  never: k8,
  any: Sve,
  unknown: C8,
  date: kve,
  enum: E8,
  literal: _8,
  nan: Cve,
  template_literal: Eve,
  file: _ve,
  success: Tve,
  custom: T8,
  function: Ave,
  transform: A8,
  map: Mve,
  set: Nve,
  array: M8,
  object: N8,
  union: R8,
  intersection: O8,
  tuple: Rve,
  record: P8,
  nullable: D8,
  nonoptional: I8,
  default: j8,
  prefault: z8,
  catch: L8,
  pipe: B8,
  readonly: $8,
  promise: Ove,
  optional: JM,
  lazy: U8
};
function Pve(e, t) {
  if ("_idmap" in e) {
    const r = e, i = $b({ ...t, processors: tz }), o = {};
    for (const c of r._idmap.entries()) {
      const [u, f] = c;
      Pn(f, i);
    }
    const s = {}, a = {
      registry: r,
      uri: t?.uri,
      defs: o
    };
    i.external = a;
    for (const c of r._idmap.entries()) {
      const [u, f] = c;
      Ub(i, f), s[u] = Fb(i, f);
    }
    if (Object.keys(o).length > 0) {
      const c = i.target === "draft-2020-12" ? "$defs" : "definitions";
      s.__shared = {
        [c]: o
      };
    }
    return { schemas: s };
  }
  const n = $b({ ...t, processors: tz });
  return Pn(e, n), Ub(n, e), Fb(n, e);
}
const Dve = /* @__PURE__ */ Pe("ZodISODateTime", (e, t) => {
  jge.init(e, t), Jn.init(e, t);
});
function Ive(e) {
  return /* @__PURE__ */ Hye(Dve, e);
}
const jve = /* @__PURE__ */ Pe("ZodISODate", (e, t) => {
  zge.init(e, t), Jn.init(e, t);
});
function zve(e) {
  return /* @__PURE__ */ Wye(jve, e);
}
const Lve = /* @__PURE__ */ Pe("ZodISOTime", (e, t) => {
  Lge.init(e, t), Jn.init(e, t);
});
function Bve(e) {
  return /* @__PURE__ */ qye(Lve, e);
}
const $ve = /* @__PURE__ */ Pe("ZodISODuration", (e, t) => {
  Bge.init(e, t), Jn.init(e, t);
});
function Uve(e) {
  return /* @__PURE__ */ Gye($ve, e);
}
const Fve = (e, t) => {
  n8.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (n) => Ame(e, n)
      // enumerable: false,
    },
    flatten: {
      value: (n) => Tme(e, n)
      // enumerable: false,
    },
    addIssue: {
      value: (n) => {
        e.issues.push(n), e.message = JSON.stringify(e.issues, Z_, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (n) => {
        e.issues.push(...n), e.message = JSON.stringify(e.issues, Z_, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, Xo = Pe("ZodError", Fve, {
  Parent: Error
}), Vve = /* @__PURE__ */ ZM(Xo), Hve = /* @__PURE__ */ YM(Xo), Wve = /* @__PURE__ */ Vw(Xo), F8 = /* @__PURE__ */ Hw(Xo), qve = /* @__PURE__ */ Rme(Xo), Gve = /* @__PURE__ */ Ome(Xo), Kve = /* @__PURE__ */ Pme(Xo), Zve = /* @__PURE__ */ Dme(Xo), Yve = /* @__PURE__ */ Ime(Xo), Xve = /* @__PURE__ */ jme(Xo), Jve = /* @__PURE__ */ zme(Xo), Qve = /* @__PURE__ */ Lme(Xo), Wn = /* @__PURE__ */ Pe("ZodType", (e, t) => (Hn.init(e, t), Object.assign(e["~standard"], {
  jsonSchema: {
    input: Vb(e, "input"),
    output: Vb(e, "output")
  }
}), e.toJSONSchema = gve(e, {}), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(Wc(t, {
  checks: [
    ...t.checks ?? [],
    ...n.map((r) => typeof r == "function" ? { _zod: { check: r, def: { check: "custom" }, onattach: [] } } : r)
  ]
}), {
  parent: !0
}), e.with = e.check, e.clone = (n, r) => qc(e, n, r), e.brand = () => e, e.register = ((n, r) => (n.add(e, r), e)), e.parse = (n, r) => Vve(e, n, r, { callee: e.parse }), e.safeParse = (n, r) => Wve(e, n, r), e.parseAsync = async (n, r) => Hve(e, n, r, { callee: e.parseAsync }), e.safeParseAsync = async (n, r) => F8(e, n, r), e.spa = e.safeParseAsync, e.encode = (n, r) => qve(e, n, r), e.decode = (n, r) => Gve(e, n, r), e.encodeAsync = async (n, r) => Kve(e, n, r), e.decodeAsync = async (n, r) => Zve(e, n, r), e.safeEncode = (n, r) => Yve(e, n, r), e.safeDecode = (n, r) => Xve(e, n, r), e.safeEncodeAsync = async (n, r) => Jve(e, n, r), e.safeDecodeAsync = async (n, r) => Qve(e, n, r), e.refine = (n, r) => e.check(Z0e(n, r)), e.superRefine = (n) => e.check(Y0e(n)), e.overwrite = (n) => e.check(/* @__PURE__ */ Yh(n)), e.optional = () => iz(e), e.exactOptional = () => I0e(e), e.nullable = () => oz(e), e.nullish = () => iz(oz(e)), e.nonoptional = (n) => U0e(e, n), e.array = () => Xh(e), e.or = (n) => Zo([e, n]), e.and = (n) => M0e(e, n), e.transform = (n) => sz(e, P0e(n)), e.default = (n) => L0e(e, n), e.prefault = (n) => $0e(e, n), e.catch = (n) => V0e(e, n), e.pipe = (n) => sz(e, n), e.readonly = () => q0e(e), e.describe = (n) => {
  const r = e.clone();
  return Sm.add(r, { description: n }), r;
}, Object.defineProperty(e, "description", {
  get() {
    return Sm.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...n) => {
  if (n.length === 0)
    return Sm.get(e);
  const r = e.clone();
  return Sm.add(r, n[0]), r;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e.apply = (n) => n(e), e)), V8 = /* @__PURE__ */ Pe("_ZodString", (e, t) => {
  XM.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (r, i, o) => b8(e, r, i);
  const n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...r) => e.check(/* @__PURE__ */ eve(...r)), e.includes = (...r) => e.check(/* @__PURE__ */ rve(...r)), e.startsWith = (...r) => e.check(/* @__PURE__ */ ive(...r)), e.endsWith = (...r) => e.check(/* @__PURE__ */ ove(...r)), e.min = (...r) => e.check(/* @__PURE__ */ Bb(...r)), e.max = (...r) => e.check(/* @__PURE__ */ y8(...r)), e.length = (...r) => e.check(/* @__PURE__ */ v8(...r)), e.nonempty = (...r) => e.check(/* @__PURE__ */ Bb(1, ...r)), e.lowercase = (r) => e.check(/* @__PURE__ */ tve(r)), e.uppercase = (r) => e.check(/* @__PURE__ */ nve(r)), e.trim = () => e.check(/* @__PURE__ */ ave()), e.normalize = (...r) => e.check(/* @__PURE__ */ sve(...r)), e.toLowerCase = () => e.check(/* @__PURE__ */ lve()), e.toUpperCase = () => e.check(/* @__PURE__ */ cve()), e.slugify = () => e.check(/* @__PURE__ */ uve());
}), e0e = /* @__PURE__ */ Pe("ZodString", (e, t) => {
  XM.init(e, t), V8.init(e, t), e.email = (n) => e.check(/* @__PURE__ */ kye(t0e, n)), e.url = (n) => e.check(/* @__PURE__ */ Aye(n0e, n)), e.jwt = (n) => e.check(/* @__PURE__ */ Vye(y0e, n)), e.emoji = (n) => e.check(/* @__PURE__ */ Mye(r0e, n)), e.guid = (n) => e.check(/* @__PURE__ */ Xj(nz, n)), e.uuid = (n) => e.check(/* @__PURE__ */ Cye(e0, n)), e.uuidv4 = (n) => e.check(/* @__PURE__ */ Eye(e0, n)), e.uuidv6 = (n) => e.check(/* @__PURE__ */ _ye(e0, n)), e.uuidv7 = (n) => e.check(/* @__PURE__ */ Tye(e0, n)), e.nanoid = (n) => e.check(/* @__PURE__ */ Nye(i0e, n)), e.guid = (n) => e.check(/* @__PURE__ */ Xj(nz, n)), e.cuid = (n) => e.check(/* @__PURE__ */ Rye(o0e, n)), e.cuid2 = (n) => e.check(/* @__PURE__ */ Oye(s0e, n)), e.ulid = (n) => e.check(/* @__PURE__ */ Pye(a0e, n)), e.base64 = (n) => e.check(/* @__PURE__ */ $ye(p0e, n)), e.base64url = (n) => e.check(/* @__PURE__ */ Uye(m0e, n)), e.xid = (n) => e.check(/* @__PURE__ */ Dye(l0e, n)), e.ksuid = (n) => e.check(/* @__PURE__ */ Iye(c0e, n)), e.ipv4 = (n) => e.check(/* @__PURE__ */ jye(u0e, n)), e.ipv6 = (n) => e.check(/* @__PURE__ */ zye(d0e, n)), e.cidrv4 = (n) => e.check(/* @__PURE__ */ Lye(f0e, n)), e.cidrv6 = (n) => e.check(/* @__PURE__ */ Bye(h0e, n)), e.e164 = (n) => e.check(/* @__PURE__ */ Fye(g0e, n)), e.datetime = (n) => e.check(Ive(n)), e.date = (n) => e.check(zve(n)), e.time = (n) => e.check(Bve(n)), e.duration = (n) => e.check(Uve(n));
});
function yt(e) {
  return /* @__PURE__ */ Sye(e0e, e);
}
const Jn = /* @__PURE__ */ Pe("ZodStringFormat", (e, t) => {
  Zn.init(e, t), V8.init(e, t);
}), t0e = /* @__PURE__ */ Pe("ZodEmail", (e, t) => {
  Tge.init(e, t), Jn.init(e, t);
}), nz = /* @__PURE__ */ Pe("ZodGUID", (e, t) => {
  Ege.init(e, t), Jn.init(e, t);
}), e0 = /* @__PURE__ */ Pe("ZodUUID", (e, t) => {
  _ge.init(e, t), Jn.init(e, t);
}), n0e = /* @__PURE__ */ Pe("ZodURL", (e, t) => {
  Age.init(e, t), Jn.init(e, t);
}), r0e = /* @__PURE__ */ Pe("ZodEmoji", (e, t) => {
  Mge.init(e, t), Jn.init(e, t);
}), i0e = /* @__PURE__ */ Pe("ZodNanoID", (e, t) => {
  Nge.init(e, t), Jn.init(e, t);
}), o0e = /* @__PURE__ */ Pe("ZodCUID", (e, t) => {
  Rge.init(e, t), Jn.init(e, t);
}), s0e = /* @__PURE__ */ Pe("ZodCUID2", (e, t) => {
  Oge.init(e, t), Jn.init(e, t);
}), a0e = /* @__PURE__ */ Pe("ZodULID", (e, t) => {
  Pge.init(e, t), Jn.init(e, t);
}), l0e = /* @__PURE__ */ Pe("ZodXID", (e, t) => {
  Dge.init(e, t), Jn.init(e, t);
}), c0e = /* @__PURE__ */ Pe("ZodKSUID", (e, t) => {
  Ige.init(e, t), Jn.init(e, t);
}), u0e = /* @__PURE__ */ Pe("ZodIPv4", (e, t) => {
  $ge.init(e, t), Jn.init(e, t);
}), d0e = /* @__PURE__ */ Pe("ZodIPv6", (e, t) => {
  Uge.init(e, t), Jn.init(e, t);
}), f0e = /* @__PURE__ */ Pe("ZodCIDRv4", (e, t) => {
  Fge.init(e, t), Jn.init(e, t);
}), h0e = /* @__PURE__ */ Pe("ZodCIDRv6", (e, t) => {
  Vge.init(e, t), Jn.init(e, t);
}), p0e = /* @__PURE__ */ Pe("ZodBase64", (e, t) => {
  Hge.init(e, t), Jn.init(e, t);
}), m0e = /* @__PURE__ */ Pe("ZodBase64URL", (e, t) => {
  qge.init(e, t), Jn.init(e, t);
}), g0e = /* @__PURE__ */ Pe("ZodE164", (e, t) => {
  Gge.init(e, t), Jn.init(e, t);
}), y0e = /* @__PURE__ */ Pe("ZodJWT", (e, t) => {
  Zge.init(e, t), Jn.init(e, t);
}), H8 = /* @__PURE__ */ Pe("ZodNumber", (e, t) => {
  f8.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (r, i, o) => x8(e, r, i), e.gt = (r, i) => e.check(/* @__PURE__ */ Qj(r, i)), e.gte = (r, i) => e.check(/* @__PURE__ */ CC(r, i)), e.min = (r, i) => e.check(/* @__PURE__ */ CC(r, i)), e.lt = (r, i) => e.check(/* @__PURE__ */ Jj(r, i)), e.lte = (r, i) => e.check(/* @__PURE__ */ kC(r, i)), e.max = (r, i) => e.check(/* @__PURE__ */ kC(r, i)), e.int = (r) => e.check(rz(r)), e.safe = (r) => e.check(rz(r)), e.positive = (r) => e.check(/* @__PURE__ */ Qj(0, r)), e.nonnegative = (r) => e.check(/* @__PURE__ */ CC(0, r)), e.negative = (r) => e.check(/* @__PURE__ */ Jj(0, r)), e.nonpositive = (r) => e.check(/* @__PURE__ */ kC(0, r)), e.multipleOf = (r, i) => e.check(/* @__PURE__ */ ez(r, i)), e.step = (r, i) => e.check(/* @__PURE__ */ ez(r, i)), e.finite = () => e;
  const n = e._zod.bag;
  e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? 0.5), e.isFinite = !0, e.format = n.format ?? null;
});
function v0e(e) {
  return /* @__PURE__ */ Kye(H8, e);
}
const b0e = /* @__PURE__ */ Pe("ZodNumberFormat", (e, t) => {
  Yge.init(e, t), H8.init(e, t);
});
function rz(e) {
  return /* @__PURE__ */ Zye(b0e, e);
}
const x0e = /* @__PURE__ */ Pe("ZodBoolean", (e, t) => {
  Xge.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => w8(e, n, r);
});
function Ki(e) {
  return /* @__PURE__ */ Yye(x0e, e);
}
const w0e = /* @__PURE__ */ Pe("ZodNull", (e, t) => {
  Jge.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => S8(e, n, r);
});
function S0e(e) {
  return /* @__PURE__ */ Xye(w0e, e);
}
const k0e = /* @__PURE__ */ Pe("ZodUnknown", (e, t) => {
  Qge.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => C8();
});
function qs() {
  return /* @__PURE__ */ Jye(k0e);
}
const C0e = /* @__PURE__ */ Pe("ZodNever", (e, t) => {
  eye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => k8(e, n, r);
});
function W8(e) {
  return /* @__PURE__ */ Qye(C0e, e);
}
const E0e = /* @__PURE__ */ Pe("ZodArray", (e, t) => {
  tye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => M8(e, n, r, i), e.element = t.element, e.min = (n, r) => e.check(/* @__PURE__ */ Bb(n, r)), e.nonempty = (n) => e.check(/* @__PURE__ */ Bb(1, n)), e.max = (n, r) => e.check(/* @__PURE__ */ y8(n, r)), e.length = (n, r) => e.check(/* @__PURE__ */ v8(n, r)), e.unwrap = () => e.element;
});
function Xh(e, t) {
  return /* @__PURE__ */ dve(E0e, e, t);
}
const q8 = /* @__PURE__ */ Pe("ZodObject", (e, t) => {
  rye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => N8(e, n, r, i), nn(e, "shape", () => t.shape), e.keyof = () => K8(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: qs() }), e.loose = () => e.clone({ ...e._zod.def, catchall: qs() }), e.strict = () => e.clone({ ...e._zod.def, catchall: W8() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => Sme(e, n), e.safeExtend = (n) => kme(e, n), e.merge = (n) => Cme(e, n), e.pick = (n) => xme(e, n), e.omit = (n) => wme(e, n), e.partial = (...n) => Eme(Z8, e, n[0]), e.required = (...n) => _me(Y8, e, n[0]);
});
function ri(e, t) {
  const n = {
    type: "object",
    shape: e ?? {},
    ...ut(t)
  };
  return new q8(n);
}
function Xn(e, t) {
  return new q8({
    type: "object",
    shape: e,
    catchall: W8(),
    ...ut(t)
  });
}
const G8 = /* @__PURE__ */ Pe("ZodUnion", (e, t) => {
  m8.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => R8(e, n, r, i), e.options = t.options;
});
function Zo(e, t) {
  return new G8({
    type: "union",
    options: e,
    ...ut(t)
  });
}
const _0e = /* @__PURE__ */ Pe("ZodDiscriminatedUnion", (e, t) => {
  G8.init(e, t), iye.init(e, t);
});
function T0e(e, t, n) {
  return new _0e({
    type: "union",
    options: t,
    discriminator: e,
    ...ut(n)
  });
}
const A0e = /* @__PURE__ */ Pe("ZodIntersection", (e, t) => {
  oye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => O8(e, n, r, i);
});
function M0e(e, t) {
  return new A0e({
    type: "intersection",
    left: e,
    right: t
  });
}
const N0e = /* @__PURE__ */ Pe("ZodRecord", (e, t) => {
  sye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => P8(e, n, r, i), e.keyType = t.keyType, e.valueType = t.valueType;
});
function X_(e, t, n) {
  return new N0e({
    type: "record",
    keyType: e,
    valueType: t,
    ...ut(n)
  });
}
const J_ = /* @__PURE__ */ Pe("ZodEnum", (e, t) => {
  aye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (r, i, o) => E8(e, r, i), e.enum = t.entries, e.options = Object.values(t.entries);
  const n = new Set(Object.keys(t.entries));
  e.extract = (r, i) => {
    const o = {};
    for (const s of r)
      if (n.has(s))
        o[s] = t.entries[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new J_({
      ...t,
      checks: [],
      ...ut(i),
      entries: o
    });
  }, e.exclude = (r, i) => {
    const o = { ...t.entries };
    for (const s of r)
      if (n.has(s))
        delete o[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new J_({
      ...t,
      checks: [],
      ...ut(i),
      entries: o
    });
  };
});
function K8(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((r) => [r, r])) : e;
  return new J_({
    type: "enum",
    entries: n,
    ...ut(t)
  });
}
const R0e = /* @__PURE__ */ Pe("ZodLiteral", (e, t) => {
  lye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => _8(e, n, r), e.values = new Set(t.values), Object.defineProperty(e, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function Ft(e, t) {
  return new R0e({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...ut(t)
  });
}
const O0e = /* @__PURE__ */ Pe("ZodTransform", (e, t) => {
  cye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => A8(e, n), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      throw new YF(e.constructor.name);
    n.addIssue = (o) => {
      if (typeof o == "string")
        n.issues.push(yg(o, n.value, t));
      else {
        const s = o;
        s.fatal && (s.continue = !1), s.code ?? (s.code = "custom"), s.input ?? (s.input = n.value), s.inst ?? (s.inst = e), n.issues.push(yg(s));
      }
    };
    const i = t.transform(n.value, n);
    return i instanceof Promise ? i.then((o) => (n.value = o, n)) : (n.value = i, n);
  };
});
function P0e(e) {
  return new O0e({
    type: "transform",
    transform: e
  });
}
const Z8 = /* @__PURE__ */ Pe("ZodOptional", (e, t) => {
  g8.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => JM(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function iz(e) {
  return new Z8({
    type: "optional",
    innerType: e
  });
}
const D0e = /* @__PURE__ */ Pe("ZodExactOptional", (e, t) => {
  uye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => JM(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function I0e(e) {
  return new D0e({
    type: "optional",
    innerType: e
  });
}
const j0e = /* @__PURE__ */ Pe("ZodNullable", (e, t) => {
  dye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => D8(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function oz(e) {
  return new j0e({
    type: "nullable",
    innerType: e
  });
}
const z0e = /* @__PURE__ */ Pe("ZodDefault", (e, t) => {
  fye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => j8(e, n, r, i), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function L0e(e, t) {
  return new z0e({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : e8(t);
    }
  });
}
const B0e = /* @__PURE__ */ Pe("ZodPrefault", (e, t) => {
  hye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => z8(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function $0e(e, t) {
  return new B0e({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : e8(t);
    }
  });
}
const Y8 = /* @__PURE__ */ Pe("ZodNonOptional", (e, t) => {
  pye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => I8(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function U0e(e, t) {
  return new Y8({
    type: "nonoptional",
    innerType: e,
    ...ut(t)
  });
}
const F0e = /* @__PURE__ */ Pe("ZodCatch", (e, t) => {
  mye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => L8(e, n, r, i), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function V0e(e, t) {
  return new F0e({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const H0e = /* @__PURE__ */ Pe("ZodPipe", (e, t) => {
  gye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => B8(e, n, r, i), e.in = t.in, e.out = t.out;
});
function sz(e, t) {
  return new H0e({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const W0e = /* @__PURE__ */ Pe("ZodReadonly", (e, t) => {
  yye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => $8(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function q0e(e) {
  return new W0e({
    type: "readonly",
    innerType: e
  });
}
const G0e = /* @__PURE__ */ Pe("ZodLazy", (e, t) => {
  vye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => U8(e, n, r, i), e.unwrap = () => e._zod.def.getter();
});
function K0e(e) {
  return new G0e({
    type: "lazy",
    getter: e
  });
}
const QM = /* @__PURE__ */ Pe("ZodCustom", (e, t) => {
  bye.init(e, t), Wn.init(e, t), e._zod.processJSONSchema = (n, r, i) => T8(e, n);
});
function X8(e, t) {
  return /* @__PURE__ */ fve(QM, e ?? (() => !0), t);
}
function Z0e(e, t = {}) {
  return /* @__PURE__ */ hve(QM, e, t);
}
function Y0e(e) {
  return /* @__PURE__ */ pve(e);
}
function Hb(e, t = {}) {
  const n = new QM({
    type: "custom",
    check: "custom",
    fn: (r) => r instanceof e,
    abort: !0,
    ...ut(t)
  });
  return n._zod.bag.Class = e, n._zod.check = (r) => {
    r.value instanceof e || r.issues.push({
      code: "invalid_type",
      expected: e.name,
      input: r.value,
      inst: n,
      path: [...n._zod.def.path ?? []]
    });
  }, n;
}
var vg;
(function(e) {
  e.assertEqual = (i) => {
  };
  function t(i) {
  }
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (i) => {
    const o = {};
    for (const s of i)
      o[s] = s;
    return o;
  }, e.getValidEnumValues = (i) => {
    const o = e.objectKeys(i).filter((a) => typeof i[i[a]] != "number"), s = {};
    for (const a of o)
      s[a] = i[a];
    return e.objectValues(s);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(o) {
    return i[o];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const o = [];
    for (const s in i)
      Object.prototype.hasOwnProperty.call(i, s) && o.push(s);
    return o;
  }, e.find = (i, o) => {
    for (const s of i)
      if (o(s))
        return s;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && Number.isFinite(i) && Math.floor(i) === i;
  function r(i, o = " | ") {
    return i.map((s) => typeof s == "string" ? `'${s}'` : s).join(o);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (i, o) => typeof o == "bigint" ? o.toString() : o;
})(vg || (vg = {}));
var az;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(az || (az = {}));
vg.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
vg.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class Wb extends Error {
  get errors() {
    return this.issues;
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  format(t) {
    const n = t || function(o) {
      return o.message;
    }, r = { _errors: [] }, i = (o) => {
      for (const s of o.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(i);
        else if (s.code === "invalid_return_type")
          i(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          i(s.argumentsError);
        else if (s.path.length === 0)
          r._errors.push(n(s));
        else {
          let a = r, c = 0;
          for (; c < s.path.length; ) {
            const u = s.path[c];
            c === s.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(n(s))) : a[u] = a[u] || { _errors: [] }, a = a[u], c++;
          }
        }
    };
    return i(this), r;
  }
  static assert(t) {
    if (!(t instanceof Wb))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, vg.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = /* @__PURE__ */ Object.create(null), r = [];
    for (const i of this.issues)
      if (i.path.length > 0) {
        const o = i.path[0];
        n[o] = n[o] || [], n[o].push(t(i));
      } else
        r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
Wb.create = (e) => new Wb(e);
var lz;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
})(lz || (lz = {}));
var Nt;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Nt || (Nt = {}));
var fy = ({
  prefix: e,
  size: t = 16,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: r = "-"
} = {}) => {
  const i = () => {
    const o = n.length, s = new Array(t);
    for (let a = 0; a < t; a++)
      s[a] = n[Math.random() * o | 0];
    return s.join("");
  };
  if (e == null)
    return i;
  if (n.includes(r))
    throw new lme({
      argument: "separator",
      message: `The separator "${r}" must not be part of the alphabet "${n}".`
    });
  return () => `${e}${r}${i()}`;
}, X0e = fy();
function cz(e = globalThis) {
  var t, n, r;
  return e.window ? "runtime/browser" : (t = e.navigator) != null && t.userAgent ? `runtime/${e.navigator.userAgent.toLowerCase()}` : (r = (n = e.process) == null ? void 0 : n.versions) != null && r.node ? `runtime/node.js/${e.process.version.substring(0)}` : e.EdgeRuntime ? "runtime/vercel-edge" : "runtime/unknown";
}
function Du(e) {
  if (e == null)
    return {};
  const t = {};
  if (e instanceof Headers)
    e.forEach((n, r) => {
      t[r.toLowerCase()] = n;
    });
  else {
    Array.isArray(e) || (e = Object.entries(e));
    for (const [n, r] of e)
      r != null && (t[n.toLowerCase()] = r);
  }
  return t;
}
function uz(e, ...t) {
  const n = new Headers(Du(e)), r = n.get("user-agent") || "";
  return n.set(
    "user-agent",
    [r, ...t].filter(Boolean).join(" ")
  ), Object.fromEntries(n.entries());
}
var J0e = /"__proto__"\s*:/, Q0e = /"constructor"\s*:/;
function dz(e) {
  const t = JSON.parse(e);
  return t === null || typeof t != "object" || J0e.test(e) === !1 && Q0e.test(e) === !1 ? t : ebe(t);
}
function ebe(e) {
  let t = [e];
  for (; t.length; ) {
    const n = t;
    t = [];
    for (const r of n) {
      if (Object.prototype.hasOwnProperty.call(r, "__proto__"))
        throw new SyntaxError("Object contains forbidden prototype property");
      if (Object.prototype.hasOwnProperty.call(r, "constructor") && Object.prototype.hasOwnProperty.call(r.constructor, "prototype"))
        throw new SyntaxError("Object contains forbidden prototype property");
      for (const i in r) {
        const o = r[i];
        o && typeof o == "object" && t.push(o);
      }
    }
  }
  return e;
}
function tbe(e) {
  const { stackTraceLimit: t } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch {
    return dz(e);
  }
  try {
    return dz(e);
  } finally {
    Error.stackTraceLimit = t;
  }
}
var qb = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function nbe(e) {
  return { [qb]: !0, validate: e };
}
function rbe(e) {
  return typeof e == "object" && e !== null && qb in e && e[qb] === !0 && "validate" in e;
}
function ibe(e) {
  let t;
  return () => (t == null && (t = e()), t);
}
function obe(e) {
  return rbe(e) ? e : typeof e == "function" ? e() : sbe(e);
}
function sbe(e) {
  return nbe(async (t) => {
    const n = await e["~standard"].validate(t);
    return n.issues == null ? { success: !0, value: n.value } : {
      success: !1,
      error: new zb({
        value: t,
        cause: n.issues
      })
    };
  });
}
async function fz({
  value: e,
  schema: t
}) {
  const n = await eN({ value: e, schema: t });
  if (!n.success)
    throw zb.wrap({ value: e, cause: n.error });
  return n.value;
}
async function eN({
  value: e,
  schema: t
}) {
  const n = obe(t);
  try {
    if (n.validate == null)
      return { success: !0, value: e, rawValue: e };
    const r = await n.validate(e);
    return r.success ? { success: !0, value: r.value, rawValue: e } : {
      success: !1,
      error: zb.wrap({ value: e, cause: r.error }),
      rawValue: e
    };
  } catch (r) {
    return {
      success: !1,
      error: zb.wrap({ value: e, cause: r }),
      rawValue: e
    };
  }
}
async function Gb({
  text: e,
  schema: t
}) {
  try {
    const n = tbe(e);
    return t == null ? { success: !0, value: n, rawValue: n } : await eN({ value: n, schema: t });
  } catch (n) {
    return {
      success: !1,
      error: Ij.isInstance(n) ? n : new Ij({ text: e, cause: n }),
      rawValue: void 0
    };
  }
}
function abe({
  stream: e,
  schema: t
}) {
  return e.pipeThrough(new TextDecoderStream()).pipeThrough(new hme()).pipeThrough(
    new TransformStream({
      async transform({ data: n }, r) {
        n !== "[DONE]" && r.enqueue(await Gb({ text: n, schema: t }));
      }
    })
  );
}
async function Cf(e) {
  return typeof e == "function" && (e = e()), Promise.resolve(e);
}
function W0(e) {
  if (e.type === "object") {
    e.additionalProperties = !1;
    const t = e.properties;
    if (t != null)
      for (const n in t)
        t[n] = W0(
          t[n]
        );
  }
  return e.type === "array" && e.items != null && (Array.isArray(e.items) ? e.items = e.items.map(
    (t) => W0(t)
  ) : e.items = W0(
    e.items
  )), e;
}
var lbe = (e, t) => {
  let n = 0;
  for (; n < e.length && n < t.length && e[n] === t[n]; n++)
    ;
  return [(e.length - n).toString(), ...t.slice(n)].join("/");
}, cbe = /* @__PURE__ */ Symbol(
  "Let zodToJsonSchema decide on which parser to use"
), hz = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, ube = (e) => typeof e == "string" ? {
  ...hz,
  name: e
} : {
  ...hz,
  ...e
};
function xo() {
  return {};
}
function dbe(e, t) {
  var n, r, i;
  const o = {
    type: "array"
  };
  return (n = e.type) != null && n._def && ((i = (r = e.type) == null ? void 0 : r._def) == null ? void 0 : i.typeName) !== Nt.ZodAny && (o.items = yn(e.type._def, {
    ...t,
    currentPath: [...t.currentPath, "items"]
  })), e.minLength && (o.minItems = e.minLength.value), e.maxLength && (o.maxItems = e.maxLength.value), e.exactLength && (o.minItems = e.exactLength.value, o.maxItems = e.exactLength.value), o;
}
function fbe(e) {
  const t = {
    type: "integer",
    format: "int64"
  };
  if (!e.checks) return t;
  for (const n of e.checks)
    switch (n.kind) {
      case "min":
        n.inclusive ? t.minimum = n.value : t.exclusiveMinimum = n.value;
        break;
      case "max":
        n.inclusive ? t.maximum = n.value : t.exclusiveMaximum = n.value;
        break;
      case "multipleOf":
        t.multipleOf = n.value;
        break;
    }
  return t;
}
function hbe() {
  return { type: "boolean" };
}
function J8(e, t) {
  return yn(e.type._def, t);
}
var pbe = (e, t) => yn(e.innerType._def, t);
function Q8(e, t, n) {
  const r = n ?? t.dateStrategy;
  if (Array.isArray(r))
    return {
      anyOf: r.map((i, o) => Q8(e, t, i))
    };
  switch (r) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return mbe(e);
  }
}
var mbe = (e) => {
  const t = {
    type: "integer",
    format: "unix-time"
  };
  for (const n of e.checks)
    switch (n.kind) {
      case "min":
        t.minimum = n.value;
        break;
      case "max":
        t.maximum = n.value;
        break;
    }
  return t;
};
function gbe(e, t) {
  return {
    ...yn(e.innerType._def, t),
    default: e.defaultValue()
  };
}
function ybe(e, t) {
  return t.effectStrategy === "input" ? yn(e.schema._def, t) : xo();
}
function vbe(e) {
  return {
    type: "string",
    enum: Array.from(e.values)
  };
}
var bbe = (e) => "type" in e && e.type === "string" ? !1 : "allOf" in e;
function xbe(e, t) {
  const n = [
    yn(e.left._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "0"]
    }),
    yn(e.right._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "1"]
    })
  ].filter((i) => !!i), r = [];
  return n.forEach((i) => {
    if (bbe(i))
      r.push(...i.allOf);
    else {
      let o = i;
      if ("additionalProperties" in i && i.additionalProperties === !1) {
        const { additionalProperties: s, ...a } = i;
        o = a;
      }
      r.push(o);
    }
  }), r.length ? { allOf: r } : void 0;
}
function wbe(e) {
  const t = typeof e.value;
  return t !== "bigint" && t !== "number" && t !== "boolean" && t !== "string" ? {
    type: Array.isArray(e.value) ? "array" : "object"
  } : {
    type: t === "bigint" ? "integer" : t,
    const: e.value
  };
}
var EC = void 0, ss = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (EC === void 0 && (EC = RegExp(
    "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
    "u"
  )), EC),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function eV(e, t) {
  const n = {
    type: "string"
  };
  if (e.checks)
    for (const r of e.checks)
      switch (r.kind) {
        case "min":
          n.minLength = typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value;
          break;
        case "max":
          n.maxLength = typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value;
          break;
        case "email":
          switch (t.emailStrategy) {
            case "format:email":
              as(n, "email", r.message, t);
              break;
            case "format:idn-email":
              as(n, "idn-email", r.message, t);
              break;
            case "pattern:zod":
              Ti(n, ss.email, r.message, t);
              break;
          }
          break;
        case "url":
          as(n, "uri", r.message, t);
          break;
        case "uuid":
          as(n, "uuid", r.message, t);
          break;
        case "regex":
          Ti(n, r.regex, r.message, t);
          break;
        case "cuid":
          Ti(n, ss.cuid, r.message, t);
          break;
        case "cuid2":
          Ti(n, ss.cuid2, r.message, t);
          break;
        case "startsWith":
          Ti(
            n,
            RegExp(`^${_C(r.value, t)}`),
            r.message,
            t
          );
          break;
        case "endsWith":
          Ti(
            n,
            RegExp(`${_C(r.value, t)}$`),
            r.message,
            t
          );
          break;
        case "datetime":
          as(n, "date-time", r.message, t);
          break;
        case "date":
          as(n, "date", r.message, t);
          break;
        case "time":
          as(n, "time", r.message, t);
          break;
        case "duration":
          as(n, "duration", r.message, t);
          break;
        case "length":
          n.minLength = typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value, n.maxLength = typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value;
          break;
        case "includes": {
          Ti(
            n,
            RegExp(_C(r.value, t)),
            r.message,
            t
          );
          break;
        }
        case "ip": {
          r.version !== "v6" && as(n, "ipv4", r.message, t), r.version !== "v4" && as(n, "ipv6", r.message, t);
          break;
        }
        case "base64url":
          Ti(n, ss.base64url, r.message, t);
          break;
        case "jwt":
          Ti(n, ss.jwt, r.message, t);
          break;
        case "cidr": {
          r.version !== "v6" && Ti(n, ss.ipv4Cidr, r.message, t), r.version !== "v4" && Ti(n, ss.ipv6Cidr, r.message, t);
          break;
        }
        case "emoji":
          Ti(n, ss.emoji(), r.message, t);
          break;
        case "ulid": {
          Ti(n, ss.ulid, r.message, t);
          break;
        }
        case "base64": {
          switch (t.base64Strategy) {
            case "format:binary": {
              as(n, "binary", r.message, t);
              break;
            }
            case "contentEncoding:base64": {
              n.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              Ti(n, ss.base64, r.message, t);
              break;
            }
          }
          break;
        }
        case "nanoid":
          Ti(n, ss.nanoid, r.message, t);
      }
  return n;
}
function _C(e, t) {
  return t.patternStrategy === "escape" ? kbe(e) : e;
}
var Sbe = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function kbe(e) {
  let t = "";
  for (let n = 0; n < e.length; n++)
    Sbe.has(e[n]) || (t += "\\"), t += e[n];
  return t;
}
function as(e, t, n, r) {
  var i;
  e.format || (i = e.anyOf) != null && i.some((o) => o.format) ? (e.anyOf || (e.anyOf = []), e.format && (e.anyOf.push({
    format: e.format
  }), delete e.format), e.anyOf.push({
    format: t,
    ...n && r.errorMessages && { errorMessage: { format: n } }
  })) : e.format = t;
}
function Ti(e, t, n, r) {
  var i;
  e.pattern || (i = e.allOf) != null && i.some((o) => o.pattern) ? (e.allOf || (e.allOf = []), e.pattern && (e.allOf.push({
    pattern: e.pattern
  }), delete e.pattern), e.allOf.push({
    pattern: pz(t, r),
    ...n && r.errorMessages && { errorMessage: { pattern: n } }
  })) : e.pattern = pz(t, r);
}
function pz(e, t) {
  var n;
  if (!t.applyRegexFlags || !e.flags)
    return e.source;
  const r = {
    i: e.flags.includes("i"),
    // Case-insensitive
    m: e.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: e.flags.includes("s")
    // `.` matches newlines
  }, i = r.i ? e.source.toLowerCase() : e.source;
  let o = "", s = !1, a = !1, c = !1;
  for (let u = 0; u < i.length; u++) {
    if (s) {
      o += i[u], s = !1;
      continue;
    }
    if (r.i) {
      if (a) {
        if (i[u].match(/[a-z]/)) {
          c ? (o += i[u], o += `${i[u - 2]}-${i[u]}`.toUpperCase(), c = !1) : i[u + 1] === "-" && ((n = i[u + 2]) != null && n.match(/[a-z]/)) ? (o += i[u], c = !0) : o += `${i[u]}${i[u].toUpperCase()}`;
          continue;
        }
      } else if (i[u].match(/[a-z]/)) {
        o += `[${i[u]}${i[u].toUpperCase()}]`;
        continue;
      }
    }
    if (r.m) {
      if (i[u] === "^") {
        o += `(^|(?<=[\r
]))`;
        continue;
      } else if (i[u] === "$") {
        o += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (r.s && i[u] === ".") {
      o += a ? `${i[u]}\r
` : `[${i[u]}\r
]`;
      continue;
    }
    o += i[u], i[u] === "\\" ? s = !0 : a && i[u] === "]" ? a = !1 : !a && i[u] === "[" && (a = !0);
  }
  try {
    new RegExp(o);
  } catch {
    return console.warn(
      `Could not convert regex pattern at ${t.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    ), e.source;
  }
  return o;
}
function tV(e, t) {
  var n, r, i, o, s, a;
  const c = {
    type: "object",
    additionalProperties: (n = yn(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    })) != null ? n : t.allowedAdditionalProperties
  };
  if (((r = e.keyType) == null ? void 0 : r._def.typeName) === Nt.ZodString && ((i = e.keyType._def.checks) != null && i.length)) {
    const { type: u, ...f } = eV(e.keyType._def, t);
    return {
      ...c,
      propertyNames: f
    };
  } else {
    if (((o = e.keyType) == null ? void 0 : o._def.typeName) === Nt.ZodEnum)
      return {
        ...c,
        propertyNames: {
          enum: e.keyType._def.values
        }
      };
    if (((s = e.keyType) == null ? void 0 : s._def.typeName) === Nt.ZodBranded && e.keyType._def.type._def.typeName === Nt.ZodString && ((a = e.keyType._def.type._def.checks) != null && a.length)) {
      const { type: u, ...f } = J8(
        e.keyType._def,
        t
      );
      return {
        ...c,
        propertyNames: f
      };
    }
  }
  return c;
}
function Cbe(e, t) {
  if (t.mapStrategy === "record")
    return tV(e, t);
  const n = yn(e.keyType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "0"]
  }) || xo(), r = yn(e.valueType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "1"]
  }) || xo();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, r],
      minItems: 2,
      maxItems: 2
    }
  };
}
function Ebe(e) {
  const t = e.values, r = Object.keys(e.values).filter((o) => typeof t[t[o]] != "number").map((o) => t[o]), i = Array.from(
    new Set(r.map((o) => typeof o))
  );
  return {
    type: i.length === 1 ? i[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: r
  };
}
function _be() {
  return { not: xo() };
}
function Tbe() {
  return {
    type: "null"
  };
}
var Q_ = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function Abe(e, t) {
  const n = e.options instanceof Map ? Array.from(e.options.values()) : e.options;
  if (n.every(
    (r) => r._def.typeName in Q_ && (!r._def.checks || !r._def.checks.length)
  )) {
    const r = n.reduce((i, o) => {
      const s = Q_[o._def.typeName];
      return s && !i.includes(s) ? [...i, s] : i;
    }, []);
    return {
      type: r.length > 1 ? r : r[0]
    };
  } else if (n.every((r) => r._def.typeName === "ZodLiteral" && !r.description)) {
    const r = n.reduce(
      (i, o) => {
        const s = typeof o._def.value;
        switch (s) {
          case "string":
          case "number":
          case "boolean":
            return [...i, s];
          case "bigint":
            return [...i, "integer"];
          case "object":
            if (o._def.value === null) return [...i, "null"];
          default:
            return i;
        }
      },
      []
    );
    if (r.length === n.length) {
      const i = r.filter((o, s, a) => a.indexOf(o) === s);
      return {
        type: i.length > 1 ? i : i[0],
        enum: n.reduce(
          (o, s) => o.includes(s._def.value) ? o : [...o, s._def.value],
          []
        )
      };
    }
  } else if (n.every((r) => r._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce(
        (r, i) => [
          ...r,
          ...i._def.values.filter((o) => !r.includes(o))
        ],
        []
      )
    };
  return Mbe(e, t);
}
var Mbe = (e, t) => {
  const n = (e.options instanceof Map ? Array.from(e.options.values()) : e.options).map(
    (r, i) => yn(r._def, {
      ...t,
      currentPath: [...t.currentPath, "anyOf", `${i}`]
    })
  ).filter(
    (r) => !!r && (!t.strictUnions || typeof r == "object" && Object.keys(r).length > 0)
  );
  return n.length ? { anyOf: n } : void 0;
};
function Nbe(e, t) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    e.innerType._def.typeName
  ) && (!e.innerType._def.checks || !e.innerType._def.checks.length))
    return {
      type: [
        Q_[e.innerType._def.typeName],
        "null"
      ]
    };
  const n = yn(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "0"]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function Rbe(e) {
  const t = {
    type: "number"
  };
  if (!e.checks) return t;
  for (const n of e.checks)
    switch (n.kind) {
      case "int":
        t.type = "integer";
        break;
      case "min":
        n.inclusive ? t.minimum = n.value : t.exclusiveMinimum = n.value;
        break;
      case "max":
        n.inclusive ? t.maximum = n.value : t.exclusiveMaximum = n.value;
        break;
      case "multipleOf":
        t.multipleOf = n.value;
        break;
    }
  return t;
}
function Obe(e, t) {
  const n = {
    type: "object",
    properties: {}
  }, r = [], i = e.shape();
  for (const s in i) {
    let a = i[s];
    if (a === void 0 || a._def === void 0)
      continue;
    const c = Dbe(a), u = yn(a._def, {
      ...t,
      currentPath: [...t.currentPath, "properties", s],
      propertyPath: [...t.currentPath, "properties", s]
    });
    u !== void 0 && (n.properties[s] = u, c || r.push(s));
  }
  r.length && (n.required = r);
  const o = Pbe(e, t);
  return o !== void 0 && (n.additionalProperties = o), n;
}
function Pbe(e, t) {
  if (e.catchall._def.typeName !== "ZodNever")
    return yn(e.catchall._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    });
  switch (e.unknownKeys) {
    case "passthrough":
      return t.allowedAdditionalProperties;
    case "strict":
      return t.rejectedAdditionalProperties;
    case "strip":
      return t.removeAdditionalStrategy === "strict" ? t.allowedAdditionalProperties : t.rejectedAdditionalProperties;
  }
}
function Dbe(e) {
  try {
    return e.isOptional();
  } catch {
    return !0;
  }
}
var Ibe = (e, t) => {
  var n;
  if (t.currentPath.toString() === ((n = t.propertyPath) == null ? void 0 : n.toString()))
    return yn(e.innerType._def, t);
  const r = yn(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "1"]
  });
  return r ? { anyOf: [{ not: xo() }, r] } : xo();
}, jbe = (e, t) => {
  if (t.pipeStrategy === "input")
    return yn(e.in._def, t);
  if (t.pipeStrategy === "output")
    return yn(e.out._def, t);
  const n = yn(e.in._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", "0"]
  }), r = yn(e.out._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", n ? "1" : "0"]
  });
  return {
    allOf: [n, r].filter((i) => i !== void 0)
  };
};
function zbe(e, t) {
  return yn(e.type._def, t);
}
function Lbe(e, t) {
  const r = {
    type: "array",
    uniqueItems: !0,
    items: yn(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "items"]
    })
  };
  return e.minSize && (r.minItems = e.minSize.value), e.maxSize && (r.maxItems = e.maxSize.value), r;
}
function Bbe(e, t) {
  return e.rest ? {
    type: "array",
    minItems: e.items.length,
    items: e.items.map(
      (n, r) => yn(n._def, {
        ...t,
        currentPath: [...t.currentPath, "items", `${r}`]
      })
    ).reduce(
      (n, r) => r === void 0 ? n : [...n, r],
      []
    ),
    additionalItems: yn(e.rest._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: e.items.length,
    maxItems: e.items.length,
    items: e.items.map(
      (n, r) => yn(n._def, {
        ...t,
        currentPath: [...t.currentPath, "items", `${r}`]
      })
    ).reduce(
      (n, r) => r === void 0 ? n : [...n, r],
      []
    )
  };
}
function $be() {
  return {
    not: xo()
  };
}
function Ube() {
  return xo();
}
var Fbe = (e, t) => yn(e.innerType._def, t), Vbe = (e, t, n) => {
  switch (t) {
    case Nt.ZodString:
      return eV(e, n);
    case Nt.ZodNumber:
      return Rbe(e);
    case Nt.ZodObject:
      return Obe(e, n);
    case Nt.ZodBigInt:
      return fbe(e);
    case Nt.ZodBoolean:
      return hbe();
    case Nt.ZodDate:
      return Q8(e, n);
    case Nt.ZodUndefined:
      return $be();
    case Nt.ZodNull:
      return Tbe();
    case Nt.ZodArray:
      return dbe(e, n);
    case Nt.ZodUnion:
    case Nt.ZodDiscriminatedUnion:
      return Abe(e, n);
    case Nt.ZodIntersection:
      return xbe(e, n);
    case Nt.ZodTuple:
      return Bbe(e, n);
    case Nt.ZodRecord:
      return tV(e, n);
    case Nt.ZodLiteral:
      return wbe(e);
    case Nt.ZodEnum:
      return vbe(e);
    case Nt.ZodNativeEnum:
      return Ebe(e);
    case Nt.ZodNullable:
      return Nbe(e, n);
    case Nt.ZodOptional:
      return Ibe(e, n);
    case Nt.ZodMap:
      return Cbe(e, n);
    case Nt.ZodSet:
      return Lbe(e, n);
    case Nt.ZodLazy:
      return () => e.getter()._def;
    case Nt.ZodPromise:
      return zbe(e, n);
    case Nt.ZodNaN:
    case Nt.ZodNever:
      return _be();
    case Nt.ZodEffects:
      return ybe(e, n);
    case Nt.ZodAny:
      return xo();
    case Nt.ZodUnknown:
      return Ube();
    case Nt.ZodDefault:
      return gbe(e, n);
    case Nt.ZodBranded:
      return J8(e, n);
    case Nt.ZodReadonly:
      return Fbe(e, n);
    case Nt.ZodCatch:
      return pbe(e, n);
    case Nt.ZodPipeline:
      return jbe(e, n);
    case Nt.ZodFunction:
    case Nt.ZodVoid:
    case Nt.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((r) => {
      })();
  }
};
function yn(e, t, n = !1) {
  var r;
  const i = t.seen.get(e);
  if (t.override) {
    const c = (r = t.override) == null ? void 0 : r.call(
      t,
      e,
      t,
      i,
      n
    );
    if (c !== cbe)
      return c;
  }
  if (i && !n) {
    const c = Hbe(i, t);
    if (c !== void 0)
      return c;
  }
  const o = { def: e, path: t.currentPath, jsonSchema: void 0 };
  t.seen.set(e, o);
  const s = Vbe(e, e.typeName, t), a = typeof s == "function" ? yn(s(), t) : s;
  if (a && Wbe(e, t, a), t.postProcess) {
    const c = t.postProcess(a, e, t);
    return o.jsonSchema = a, c;
  }
  return o.jsonSchema = a, a;
}
var Hbe = (e, t) => {
  switch (t.$refStrategy) {
    case "root":
      return { $ref: e.path.join("/") };
    case "relative":
      return { $ref: lbe(t.currentPath, e.path) };
    case "none":
    case "seen":
      return e.path.length < t.currentPath.length && e.path.every((n, r) => t.currentPath[r] === n) ? (console.warn(
        `Recursive reference detected at ${t.currentPath.join(
          "/"
        )}! Defaulting to any`
      ), xo()) : t.$refStrategy === "seen" ? xo() : void 0;
  }
}, Wbe = (e, t, n) => (e.description && (n.description = e.description), n), qbe = (e) => {
  const t = ube(e), n = t.name !== void 0 ? [...t.basePath, t.definitionPath, t.name] : t.basePath;
  return {
    ...t,
    currentPath: n,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(t.definitions).map(([r, i]) => [
        i._def,
        {
          def: i._def,
          path: [...t.basePath, t.definitionPath, r],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
}, Gbe = (e, t) => {
  var n;
  const r = qbe(t);
  let i = typeof t == "object" && t.definitions ? Object.entries(t.definitions).reduce(
    (u, [f, h]) => {
      var m;
      return {
        ...u,
        [f]: (m = yn(
          h._def,
          {
            ...r,
            currentPath: [...r.basePath, r.definitionPath, f]
          },
          !0
        )) != null ? m : xo()
      };
    },
    {}
  ) : void 0;
  const o = typeof t == "string" ? t : t?.nameStrategy === "title" ? void 0 : t?.name, s = (n = yn(
    e._def,
    o === void 0 ? r : {
      ...r,
      currentPath: [...r.basePath, r.definitionPath, o]
    },
    !1
  )) != null ? n : xo(), a = typeof t == "object" && t.name !== void 0 && t.nameStrategy === "title" ? t.name : void 0;
  a !== void 0 && (s.title = a);
  const c = o === void 0 ? i ? {
    ...s,
    [r.definitionPath]: i
  } : s : {
    $ref: [
      ...r.$refStrategy === "relative" ? [] : r.basePath,
      r.definitionPath,
      o
    ].join("/"),
    [r.definitionPath]: {
      ...i,
      [o]: s
    }
  };
  return c.$schema = "http://json-schema.org/draft-07/schema#", c;
}, Kbe = Gbe;
function Zbe(e, t) {
  var n;
  const r = (n = void 0) != null ? n : !1;
  return tN(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => Kbe(e, {
      $refStrategy: r ? "root" : "none"
    }),
    {
      validate: async (i) => {
        const o = await e.safeParseAsync(i);
        return o.success ? { success: !0, value: o.data } : { success: !1, error: o.error };
      }
    }
  );
}
function Ybe(e, t) {
  var n;
  const r = (n = void 0) != null ? n : !1;
  return tN(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => W0(
      Pve(e, {
        target: "draft-7",
        io: "input",
        reused: r ? "ref" : "inline"
      })
    ),
    {
      validate: async (i) => {
        const o = await F8(e, i);
        return o.success ? { success: !0, value: o.data } : { success: !1, error: o.error };
      }
    }
  );
}
function Xbe(e) {
  return "_zod" in e;
}
function nV(e, t) {
  return Xbe(e) ? Ybe(e) : Zbe(e);
}
var eT = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function tN(e, {
  validate: t
} = {}) {
  return {
    [eT]: !0,
    _type: void 0,
    // should never be used directly
    [qb]: !0,
    get jsonSchema() {
      return typeof e == "function" && (e = e()), e;
    },
    validate: t
  };
}
function Jbe(e) {
  return typeof e == "object" && e !== null && eT in e && e[eT] === !0 && "jsonSchema" in e && "validate" in e;
}
function Qbe(e) {
  return e == null ? tN({
    properties: {},
    additionalProperties: !1
  }) : Jbe(e) ? e : typeof e == "function" ? e() : nV(e);
}
var exe = Object.defineProperty, txe = (e, t) => {
  for (var n in t)
    exe(e, n, { get: t[n], enumerable: !0 });
}, rV = "AI_NoObjectGeneratedError", iV = `vercel.ai.error.${rV}`, nxe = Symbol.for(iV), oV, mz = class extends ra {
  constructor({
    message: e = "No object generated.",
    cause: t,
    text: n,
    response: r,
    usage: i,
    finishReason: o
  }) {
    super({ name: rV, message: e, cause: t }), this[oV] = !0, this.text = n, this.response = r, this.usage = i, this.finishReason = o;
  }
  static isInstance(e) {
    return ra.hasMarker(e, iV);
  }
};
oV = nxe;
var sV = "AI_MessageConversionError", aV = `vercel.ai.error.${sV}`, rxe = Symbol.for(aV), lV, ixe = class extends ra {
  constructor({
    originalMessage: e,
    message: t
  }) {
    super({ name: sV, message: t }), this[lV] = !0, this.originalMessage = e;
  }
  static isInstance(e) {
    return ra.hasMarker(e, aV);
  }
};
lV = rxe;
var gz = "5.0.126", cV = Zo([
  yt(),
  Hb(Uint8Array),
  Hb(ArrayBuffer),
  X8(
    // Buffer might not be available in some environments such as CloudFlare:
    (e) => {
      var t, n;
      return (n = (t = globalThis.Buffer) == null ? void 0 : t.isBuffer(e)) != null ? n : !1;
    },
    { message: "Must be a Buffer" }
  )
]), bg = K0e(
  () => Zo([
    S0e(),
    yt(),
    v0e(),
    Ki(),
    X_(yt(), bg),
    Xh(bg)
  ])
), hr = X_(
  yt(),
  X_(yt(), bg)
), uV = ri({
  type: Ft("text"),
  text: yt(),
  providerOptions: hr.optional()
}), oxe = ri({
  type: Ft("image"),
  image: Zo([cV, Hb(URL)]),
  mediaType: yt().optional(),
  providerOptions: hr.optional()
}), dV = ri({
  type: Ft("file"),
  data: Zo([cV, Hb(URL)]),
  filename: yt().optional(),
  mediaType: yt(),
  providerOptions: hr.optional()
}), sxe = ri({
  type: Ft("reasoning"),
  text: yt(),
  providerOptions: hr.optional()
}), axe = ri({
  type: Ft("tool-call"),
  toolCallId: yt(),
  toolName: yt(),
  input: qs(),
  providerOptions: hr.optional(),
  providerExecuted: Ki().optional()
}), lxe = T0e("type", [
  ri({
    type: Ft("text"),
    value: yt()
  }),
  ri({
    type: Ft("json"),
    value: bg
  }),
  ri({
    type: Ft("error-text"),
    value: yt()
  }),
  ri({
    type: Ft("error-json"),
    value: bg
  }),
  ri({
    type: Ft("content"),
    value: Xh(
      Zo([
        ri({
          type: Ft("text"),
          text: yt()
        }),
        ri({
          type: Ft("media"),
          data: yt(),
          mediaType: yt()
        })
      ])
    )
  })
]), fV = ri({
  type: Ft("tool-result"),
  toolCallId: yt(),
  toolName: yt(),
  output: lxe,
  providerOptions: hr.optional()
}), cxe = ri(
  {
    role: Ft("system"),
    content: yt(),
    providerOptions: hr.optional()
  }
), uxe = ri({
  role: Ft("user"),
  content: Zo([
    yt(),
    Xh(Zo([uV, oxe, dV]))
  ]),
  providerOptions: hr.optional()
}), dxe = ri({
  role: Ft("assistant"),
  content: Zo([
    yt(),
    Xh(
      Zo([
        uV,
        dV,
        sxe,
        axe,
        fV
      ])
    )
  ]),
  providerOptions: hr.optional()
}), fxe = ri({
  role: Ft("tool"),
  content: Xh(fV),
  providerOptions: hr.optional()
});
Zo([
  cxe,
  uxe,
  dxe,
  fxe
]);
function yz({
  output: e,
  tool: t,
  errorMode: n
}) {
  return n === "text" ? { type: "error-text", value: WM(e) } : n === "json" ? { type: "error-json", value: vz(e) } : t?.toModelOutput ? t.toModelOutput(e) : typeof e == "string" ? { type: "text", value: e } : { type: "json", value: vz(e) };
}
function vz(e) {
  return e === void 0 ? null : e;
}
fy({
  prefix: "aitxt",
  size: 24
});
(class extends TransformStream {
  constructor() {
    super({
      transform(e, t) {
        t.enqueue(`data: ${JSON.stringify(e)}

`);
      },
      flush(e) {
        e.enqueue(`data: [DONE]

`);
      }
    });
  }
});
var hxe = ibe(
  () => nV(
    Zo([
      Xn({
        type: Ft("text-start"),
        id: yt(),
        providerMetadata: hr.optional()
      }),
      Xn({
        type: Ft("text-delta"),
        id: yt(),
        delta: yt(),
        providerMetadata: hr.optional()
      }),
      Xn({
        type: Ft("text-end"),
        id: yt(),
        providerMetadata: hr.optional()
      }),
      Xn({
        type: Ft("error"),
        errorText: yt()
      }),
      Xn({
        type: Ft("tool-input-start"),
        toolCallId: yt(),
        toolName: yt(),
        providerExecuted: Ki().optional(),
        dynamic: Ki().optional()
      }),
      Xn({
        type: Ft("tool-input-delta"),
        toolCallId: yt(),
        inputTextDelta: yt()
      }),
      Xn({
        type: Ft("tool-input-available"),
        toolCallId: yt(),
        toolName: yt(),
        input: qs(),
        providerExecuted: Ki().optional(),
        providerMetadata: hr.optional(),
        dynamic: Ki().optional()
      }),
      Xn({
        type: Ft("tool-input-error"),
        toolCallId: yt(),
        toolName: yt(),
        input: qs(),
        providerExecuted: Ki().optional(),
        providerMetadata: hr.optional(),
        dynamic: Ki().optional(),
        errorText: yt()
      }),
      Xn({
        type: Ft("tool-output-available"),
        toolCallId: yt(),
        output: qs(),
        providerExecuted: Ki().optional(),
        dynamic: Ki().optional(),
        preliminary: Ki().optional()
      }),
      Xn({
        type: Ft("tool-output-error"),
        toolCallId: yt(),
        errorText: yt(),
        providerExecuted: Ki().optional(),
        dynamic: Ki().optional()
      }),
      Xn({
        type: Ft("reasoning-start"),
        id: yt(),
        providerMetadata: hr.optional()
      }),
      Xn({
        type: Ft("reasoning-delta"),
        id: yt(),
        delta: yt(),
        providerMetadata: hr.optional()
      }),
      Xn({
        type: Ft("reasoning-end"),
        id: yt(),
        providerMetadata: hr.optional()
      }),
      Xn({
        type: Ft("source-url"),
        sourceId: yt(),
        url: yt(),
        title: yt().optional(),
        providerMetadata: hr.optional()
      }),
      Xn({
        type: Ft("source-document"),
        sourceId: yt(),
        mediaType: yt(),
        title: yt(),
        filename: yt().optional(),
        providerMetadata: hr.optional()
      }),
      Xn({
        type: Ft("file"),
        url: yt(),
        mediaType: yt(),
        providerMetadata: hr.optional()
      }),
      Xn({
        type: X8(
          (e) => typeof e == "string" && e.startsWith("data-"),
          { message: 'Type must start with "data-"' }
        ),
        id: yt().optional(),
        data: qs(),
        transient: Ki().optional()
      }),
      Xn({
        type: Ft("start-step")
      }),
      Xn({
        type: Ft("finish-step")
      }),
      Xn({
        type: Ft("start"),
        messageId: yt().optional(),
        messageMetadata: qs().optional()
      }),
      Xn({
        type: Ft("finish"),
        finishReason: K8([
          "stop",
          "length",
          "content-filter",
          "tool-calls",
          "error",
          "other",
          "unknown"
        ]).optional(),
        messageMetadata: qs().optional()
      }),
      Xn({
        type: Ft("abort")
      }),
      Xn({
        type: Ft("message-metadata"),
        messageMetadata: qs()
      })
    ])
  )
);
function pxe(e) {
  return e.type.startsWith("data-");
}
function hV(e, t) {
  if (e === void 0 && t === void 0)
    return;
  if (e === void 0)
    return t;
  if (t === void 0)
    return e;
  const n = { ...e };
  for (const r in t)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      const i = t[r];
      if (i === void 0)
        continue;
      const o = r in e ? e[r] : void 0, s = i !== null && typeof i == "object" && !Array.isArray(i) && !(i instanceof Date) && !(i instanceof RegExp), a = o != null && typeof o == "object" && !Array.isArray(o) && !(o instanceof Date) && !(o instanceof RegExp);
      s && a ? n[r] = hV(
        o,
        i
      ) : n[r] = i;
    }
  return n;
}
function mxe(e) {
  const t = ["ROOT"];
  let n = -1, r = null;
  function i(c, u, f) {
    switch (c) {
      case '"': {
        n = u, t.pop(), t.push(f), t.push("INSIDE_STRING");
        break;
      }
      case "f":
      case "t":
      case "n": {
        n = u, r = u, t.pop(), t.push(f), t.push("INSIDE_LITERAL");
        break;
      }
      case "-": {
        t.pop(), t.push(f), t.push("INSIDE_NUMBER");
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9": {
        n = u, t.pop(), t.push(f), t.push("INSIDE_NUMBER");
        break;
      }
      case "{": {
        n = u, t.pop(), t.push(f), t.push("INSIDE_OBJECT_START");
        break;
      }
      case "[": {
        n = u, t.pop(), t.push(f), t.push("INSIDE_ARRAY_START");
        break;
      }
    }
  }
  function o(c, u) {
    switch (c) {
      case ",": {
        t.pop(), t.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        n = u, t.pop();
        break;
      }
    }
  }
  function s(c, u) {
    switch (c) {
      case ",": {
        t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        n = u, t.pop();
        break;
      }
    }
  }
  for (let c = 0; c < e.length; c++) {
    const u = e[c];
    switch (t[t.length - 1]) {
      case "ROOT":
        i(u, c, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (u) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            n = c, t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        u === '"' && (t.pop(), t.push("INSIDE_OBJECT_KEY"));
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        u === '"' && (t.pop(), t.push("INSIDE_OBJECT_AFTER_KEY"));
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        u === ":" && (t.pop(), t.push("INSIDE_OBJECT_BEFORE_VALUE"));
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        i(u, c, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        o(u, c);
        break;
      }
      case "INSIDE_STRING": {
        switch (u) {
          case '"': {
            t.pop(), n = c;
            break;
          }
          case "\\": {
            t.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default:
            n = c;
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        u === "]" ? (n = c, t.pop()) : (n = c, i(u, c, "INSIDE_ARRAY_AFTER_VALUE"));
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (u) {
          case ",": {
            t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            n = c, t.pop();
            break;
          }
          default: {
            n = c;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        i(u, c, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        t.pop(), n = c;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (u) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            n = c;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".":
            break;
          case ",": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && s(u, c), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && o(u, c);
            break;
          }
          case "}": {
            t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && o(u, c);
            break;
          }
          case "]": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && s(u, c);
            break;
          }
          default: {
            t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const h = e.substring(r, c + 1);
        !"false".startsWith(h) && !"true".startsWith(h) && !"null".startsWith(h) ? (t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" ? o(u, c) : t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && s(u, c)) : n = c;
        break;
      }
    }
  }
  let a = e.slice(0, n + 1);
  for (let c = t.length - 1; c >= 0; c--)
    switch (t[c]) {
      case "INSIDE_STRING": {
        a += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        a += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        a += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const f = e.substring(r, e.length);
        "true".startsWith(f) ? a += "true".slice(f.length) : "false".startsWith(f) ? a += "false".slice(f.length) : "null".startsWith(f) && (a += "null".slice(f.length));
      }
    }
  return a;
}
async function pV(e) {
  if (e === void 0)
    return { value: void 0, state: "undefined-input" };
  let t = await Gb({ text: e });
  return t.success ? { value: t.value, state: "successful-parse" } : (t = await Gb({ text: mxe(e) }), t.success ? { value: t.value, state: "repaired-parse" } : { value: void 0, state: "failed-parse" });
}
function TC(e) {
  return e.type.startsWith("data-");
}
function AC(e) {
  return e.type === "text";
}
function MC(e) {
  return e.type === "file";
}
function bz(e) {
  return e.type === "reasoning";
}
function Gu(e) {
  return e.type.startsWith("tool-");
}
function nN(e) {
  return e.type === "dynamic-tool";
}
function xg(e) {
  return Gu(e) || nN(e);
}
function wg(e) {
  return e.type.split("-").slice(1).join("-");
}
function gxe(e) {
  return nN(e) ? e.toolName : wg(e);
}
function yxe({
  lastMessage: e,
  messageId: t
}) {
  return {
    message: e?.role === "assistant" ? e : {
      id: t,
      metadata: void 0,
      role: "assistant",
      parts: []
    },
    activeTextParts: {},
    activeReasoningParts: {},
    partialToolCalls: {}
  };
}
function vxe({
  stream: e,
  messageMetadataSchema: t,
  dataPartSchemas: n,
  runUpdateMessageJob: r,
  onError: i,
  onToolCall: o,
  onData: s
}) {
  return e.pipeThrough(
    new TransformStream({
      async transform(a, c) {
        await r(async ({ state: u, write: f }) => {
          var h, m, g, b;
          function x(N) {
            const j = u.message.parts.filter(Gu).find(
              (O) => O.toolCallId === N
            );
            if (j == null)
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available"
              );
            return j;
          }
          function w(N) {
            const j = u.message.parts.filter(
              (O) => O.type === "dynamic-tool"
            ).find(
              (O) => O.toolCallId === N
            );
            if (j == null)
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available"
              );
            return j;
          }
          function S(N) {
            var D;
            const j = u.message.parts.find(
              (U) => Gu(U) && U.toolCallId === N.toolCallId
            ), O = N, L = j;
            j != null ? (j.state = N.state, L.input = O.input, L.output = O.output, L.errorText = O.errorText, L.rawInput = O.rawInput, L.preliminary = O.preliminary, L.providerExecuted = (D = O.providerExecuted) != null ? D : j.providerExecuted, O.providerMetadata != null && j.state === "input-available" && (j.callProviderMetadata = O.providerMetadata)) : u.message.parts.push({
              type: `tool-${N.toolName}`,
              toolCallId: N.toolCallId,
              state: N.state,
              input: O.input,
              output: O.output,
              rawInput: O.rawInput,
              errorText: O.errorText,
              providerExecuted: O.providerExecuted,
              preliminary: O.preliminary,
              ...O.providerMetadata != null ? { callProviderMetadata: O.providerMetadata } : {}
            });
          }
          function _(N) {
            var D, j;
            const O = u.message.parts.find(
              (B) => B.type === "dynamic-tool" && B.toolCallId === N.toolCallId
            ), L = N, U = O;
            O != null ? (O.state = N.state, U.toolName = N.toolName, U.input = L.input, U.output = L.output, U.errorText = L.errorText, U.rawInput = (D = L.rawInput) != null ? D : U.rawInput, U.preliminary = L.preliminary, U.providerExecuted = (j = L.providerExecuted) != null ? j : O.providerExecuted, L.providerMetadata != null && O.state === "input-available" && (O.callProviderMetadata = L.providerMetadata)) : u.message.parts.push({
              type: "dynamic-tool",
              toolName: N.toolName,
              toolCallId: N.toolCallId,
              state: N.state,
              input: L.input,
              output: L.output,
              errorText: L.errorText,
              preliminary: L.preliminary,
              providerExecuted: L.providerExecuted,
              ...L.providerMetadata != null ? { callProviderMetadata: L.providerMetadata } : {}
            });
          }
          async function M(N) {
            if (N != null) {
              const D = u.message.metadata != null ? hV(u.message.metadata, N) : N;
              t != null && await fz({
                value: D,
                schema: t
              }), u.message.metadata = D;
            }
          }
          switch (a.type) {
            case "text-start": {
              const N = {
                type: "text",
                text: "",
                providerMetadata: a.providerMetadata,
                state: "streaming"
              };
              u.activeTextParts[a.id] = N, u.message.parts.push(N), f();
              break;
            }
            case "text-delta": {
              const N = u.activeTextParts[a.id];
              N.text += a.delta, N.providerMetadata = (h = a.providerMetadata) != null ? h : N.providerMetadata, f();
              break;
            }
            case "text-end": {
              const N = u.activeTextParts[a.id];
              N.state = "done", N.providerMetadata = (m = a.providerMetadata) != null ? m : N.providerMetadata, delete u.activeTextParts[a.id], f();
              break;
            }
            case "reasoning-start": {
              const N = {
                type: "reasoning",
                text: "",
                providerMetadata: a.providerMetadata,
                state: "streaming"
              };
              u.activeReasoningParts[a.id] = N, u.message.parts.push(N), f();
              break;
            }
            case "reasoning-delta": {
              const N = u.activeReasoningParts[a.id];
              N.text += a.delta, N.providerMetadata = (g = a.providerMetadata) != null ? g : N.providerMetadata, f();
              break;
            }
            case "reasoning-end": {
              const N = u.activeReasoningParts[a.id];
              N.providerMetadata = (b = a.providerMetadata) != null ? b : N.providerMetadata, N.state = "done", delete u.activeReasoningParts[a.id], f();
              break;
            }
            case "file": {
              u.message.parts.push({
                type: "file",
                mediaType: a.mediaType,
                url: a.url
              }), f();
              break;
            }
            case "source-url": {
              u.message.parts.push({
                type: "source-url",
                sourceId: a.sourceId,
                url: a.url,
                title: a.title,
                providerMetadata: a.providerMetadata
              }), f();
              break;
            }
            case "source-document": {
              u.message.parts.push({
                type: "source-document",
                sourceId: a.sourceId,
                mediaType: a.mediaType,
                title: a.title,
                filename: a.filename,
                providerMetadata: a.providerMetadata
              }), f();
              break;
            }
            case "tool-input-start": {
              const N = u.message.parts.filter(Gu);
              u.partialToolCalls[a.toolCallId] = {
                text: "",
                toolName: a.toolName,
                index: N.length,
                dynamic: a.dynamic
              }, a.dynamic ? _({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: a.providerExecuted
              }) : S({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: a.providerExecuted
              }), f();
              break;
            }
            case "tool-input-delta": {
              const N = u.partialToolCalls[a.toolCallId];
              N.text += a.inputTextDelta;
              const { value: D } = await pV(
                N.text
              );
              N.dynamic ? _({
                toolCallId: a.toolCallId,
                toolName: N.toolName,
                state: "input-streaming",
                input: D
              }) : S({
                toolCallId: a.toolCallId,
                toolName: N.toolName,
                state: "input-streaming",
                input: D
              }), f();
              break;
            }
            case "tool-input-available": {
              a.dynamic ? _({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "input-available",
                input: a.input,
                providerExecuted: a.providerExecuted,
                providerMetadata: a.providerMetadata
              }) : S({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "input-available",
                input: a.input,
                providerExecuted: a.providerExecuted,
                providerMetadata: a.providerMetadata
              }), f(), o && !a.providerExecuted && await o({
                toolCall: a
              });
              break;
            }
            case "tool-input-error": {
              a.dynamic ? _({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "output-error",
                input: a.input,
                errorText: a.errorText,
                providerExecuted: a.providerExecuted,
                providerMetadata: a.providerMetadata
              }) : S({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "output-error",
                input: void 0,
                rawInput: a.input,
                errorText: a.errorText,
                providerExecuted: a.providerExecuted,
                providerMetadata: a.providerMetadata
              }), f();
              break;
            }
            case "tool-output-available": {
              if (a.dynamic) {
                const N = w(
                  a.toolCallId
                );
                _({
                  toolCallId: a.toolCallId,
                  toolName: N.toolName,
                  state: "output-available",
                  input: N.input,
                  output: a.output,
                  preliminary: a.preliminary
                });
              } else {
                const N = x(a.toolCallId);
                S({
                  toolCallId: a.toolCallId,
                  toolName: wg(N),
                  state: "output-available",
                  input: N.input,
                  output: a.output,
                  providerExecuted: a.providerExecuted,
                  preliminary: a.preliminary
                });
              }
              f();
              break;
            }
            case "tool-output-error": {
              if (a.dynamic) {
                const N = w(
                  a.toolCallId
                );
                _({
                  toolCallId: a.toolCallId,
                  toolName: N.toolName,
                  state: "output-error",
                  input: N.input,
                  errorText: a.errorText,
                  providerExecuted: a.providerExecuted
                });
              } else {
                const N = x(a.toolCallId);
                S({
                  toolCallId: a.toolCallId,
                  toolName: wg(N),
                  state: "output-error",
                  input: N.input,
                  rawInput: N.rawInput,
                  errorText: a.errorText,
                  providerExecuted: a.providerExecuted
                });
              }
              f();
              break;
            }
            case "start-step": {
              u.message.parts.push({ type: "step-start" });
              break;
            }
            case "finish-step": {
              u.activeTextParts = {}, u.activeReasoningParts = {};
              break;
            }
            case "start": {
              a.messageId != null && (u.message.id = a.messageId), await M(a.messageMetadata), (a.messageId != null || a.messageMetadata != null) && f();
              break;
            }
            case "finish": {
              a.finishReason != null && (u.finishReason = a.finishReason), await M(a.messageMetadata), a.messageMetadata != null && f();
              break;
            }
            case "message-metadata": {
              await M(a.messageMetadata), a.messageMetadata != null && f();
              break;
            }
            case "error": {
              i?.(new Error(a.errorText));
              break;
            }
            default:
              if (pxe(a)) {
                n?.[a.type] != null && await fz({
                  value: a.data,
                  schema: n[a.type]
                });
                const N = a;
                if (N.transient) {
                  s?.(N);
                  break;
                }
                const D = N.id != null ? u.message.parts.find(
                  (j) => N.type === j.type && N.id === j.id
                ) : void 0;
                D != null ? D.data = N.data : u.message.parts.push(N), s?.(N), f();
              }
          }
          c.enqueue(a);
        });
      }
    })
  );
}
async function bxe({
  stream: e,
  onError: t
}) {
  const n = e.getReader();
  try {
    for (; ; ) {
      const { done: r } = await n.read();
      if (r)
        break;
    }
  } catch (r) {
    t?.(r);
  } finally {
    n.releaseLock();
  }
}
fy({
  prefix: "aitxt",
  size: 24
});
function xxe(e, t) {
  const n = [];
  t?.ignoreIncompleteToolCalls && (e = e.map((r) => ({
    ...r,
    parts: r.parts.filter(
      (i) => !xg(i) || i.state !== "input-streaming" && i.state !== "input-available"
    )
  })));
  for (const r of e)
    switch (r.role) {
      case "system": {
        const i = r.parts.filter(
          (s) => s.type === "text"
        ), o = i.reduce((s, a) => a.providerMetadata != null ? { ...s, ...a.providerMetadata } : s, {});
        n.push({
          role: "system",
          content: i.map((s) => s.text).join(""),
          ...Object.keys(o).length > 0 ? { providerOptions: o } : {}
        });
        break;
      }
      case "user": {
        n.push({
          role: "user",
          content: r.parts.map((i) => {
            var o;
            if (AC(i))
              return {
                type: "text",
                text: i.text,
                ...i.providerMetadata != null ? { providerOptions: i.providerMetadata } : {}
              };
            if (MC(i))
              return {
                type: "file",
                mediaType: i.mediaType,
                filename: i.filename,
                data: i.url,
                ...i.providerMetadata != null ? { providerOptions: i.providerMetadata } : {}
              };
            if (TC(i))
              return (o = t?.convertDataPart) == null ? void 0 : o.call(
                t,
                i
              );
          }).filter((i) => i != null)
        });
        break;
      }
      case "assistant": {
        if (r.parts != null) {
          let i = function() {
            var s, a, c;
            if (o.length === 0)
              return;
            const u = [];
            for (const h of o)
              if (AC(h))
                u.push({
                  type: "text",
                  text: h.text,
                  ...h.providerMetadata != null ? { providerOptions: h.providerMetadata } : {}
                });
              else if (MC(h))
                u.push({
                  type: "file",
                  mediaType: h.mediaType,
                  filename: h.filename,
                  data: h.url
                });
              else if (bz(h))
                u.push({
                  type: "reasoning",
                  text: h.text,
                  providerOptions: h.providerMetadata
                });
              else if (nN(h)) {
                const m = h.toolName;
                h.state !== "input-streaming" && u.push({
                  type: "tool-call",
                  toolCallId: h.toolCallId,
                  toolName: m,
                  input: h.input,
                  ...h.callProviderMetadata != null ? { providerOptions: h.callProviderMetadata } : {}
                });
              } else if (Gu(h)) {
                const m = wg(h);
                h.state !== "input-streaming" && (u.push({
                  type: "tool-call",
                  toolCallId: h.toolCallId,
                  toolName: m,
                  input: h.state === "output-error" ? (s = h.input) != null ? s : h.rawInput : h.input,
                  providerExecuted: h.providerExecuted,
                  ...h.callProviderMetadata != null ? { providerOptions: h.callProviderMetadata } : {}
                }), h.providerExecuted === !0 && (h.state === "output-available" || h.state === "output-error") && u.push({
                  type: "tool-result",
                  toolCallId: h.toolCallId,
                  toolName: m,
                  output: yz({
                    output: h.state === "output-error" ? h.errorText : h.output,
                    tool: (a = t?.tools) == null ? void 0 : a[m],
                    errorMode: h.state === "output-error" ? "json" : "none"
                  }),
                  ...h.callProviderMetadata != null ? { providerOptions: h.callProviderMetadata } : {}
                }));
              } else if (TC(h)) {
                const m = (c = t?.convertDataPart) == null ? void 0 : c.call(
                  t,
                  h
                );
                m != null && u.push(m);
              } else {
                const m = h;
                throw new Error(`Unsupported part: ${m}`);
              }
            n.push({
              role: "assistant",
              content: u
            });
            const f = o.filter(
              (h) => Gu(h) && h.providerExecuted !== !0 || h.type === "dynamic-tool"
            );
            f.length > 0 && n.push({
              role: "tool",
              content: f.map((h) => {
                var m;
                switch (h.state) {
                  case "output-error":
                  case "output-available": {
                    const g = gxe(h);
                    return {
                      type: "tool-result",
                      toolCallId: h.toolCallId,
                      toolName: g,
                      output: yz({
                        output: h.state === "output-error" ? h.errorText : h.output,
                        tool: (m = t?.tools) == null ? void 0 : m[g],
                        errorMode: h.state === "output-error" ? "text" : "none"
                      }),
                      ...h.callProviderMetadata != null ? { providerOptions: h.callProviderMetadata } : {}
                    };
                  }
                  default:
                    return null;
                }
              }).filter(
                (h) => h != null
              )
            }), o = [];
          }, o = [];
          for (const s of r.parts)
            AC(s) || bz(s) || MC(s) || xg(s) || TC(s) ? o.push(s) : s.type === "step-start" && i();
          i();
          break;
        }
        break;
      }
      default: {
        const i = r.role;
        throw new ixe({
          originalMessage: r,
          message: `Unsupported role: ${i}`
        });
      }
    }
  return n;
}
fy({ prefix: "aiobj", size: 24 });
var wxe = class {
  constructor() {
    this.queue = [], this.isProcessing = !1;
  }
  async processQueue() {
    if (!this.isProcessing) {
      for (this.isProcessing = !0; this.queue.length > 0; )
        await this.queue[0](), this.queue.shift();
      this.isProcessing = !1;
    }
  }
  async run(e) {
    return new Promise((t, n) => {
      this.queue.push(async () => {
        try {
          await e(), t();
        } catch (r) {
          n(r);
        }
      }), this.processQueue();
    });
  }
};
fy({ prefix: "aiobj", size: 24 });
var Sxe = {};
txe(Sxe, {
  object: () => Cxe,
  text: () => kxe
});
var kxe = () => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: e }) {
    return { partial: e };
  },
  async parseOutput({ text: e }) {
    return e;
  }
}), Cxe = ({
  schema: e
}) => {
  const t = Qbe(e);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: t.jsonSchema
    },
    async parsePartial({ text: n }) {
      const r = await pV(n);
      switch (r.state) {
        case "failed-parse":
        case "undefined-input":
          return;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: r.value
          };
        default: {
          const i = r.state;
          throw new Error(`Unsupported parse state: ${i}`);
        }
      }
    },
    async parseOutput({ text: n }, r) {
      const i = await Gb({ text: n });
      if (!i.success)
        throw new mz({
          message: "No object generated: could not parse the response.",
          cause: i.error,
          text: n,
          response: r.response,
          usage: r.usage,
          finishReason: r.finishReason
        });
      const o = await eN({
        value: i.value,
        schema: t
      });
      if (!o.success)
        throw new mz({
          message: "No object generated: response did not match schema.",
          cause: o.error,
          text: n,
          response: r.response,
          usage: r.usage,
          finishReason: r.finishReason
        });
      return o.value;
    }
  };
};
async function Exe(e) {
  if (e == null)
    return [];
  if (!globalThis.FileList || !(e instanceof globalThis.FileList))
    throw new Error("FileList is not supported in the current environment");
  return Promise.all(
    Array.from(e).map(async (t) => {
      const { name: n, type: r } = t, i = await new Promise((o, s) => {
        const a = new FileReader();
        a.onload = (c) => {
          var u;
          o((u = c.target) == null ? void 0 : u.result);
        }, a.onerror = (c) => s(c), a.readAsDataURL(t);
      });
      return {
        type: "file",
        mediaType: r,
        filename: n,
        url: i
      };
    })
  );
}
var _xe = class {
  constructor({
    api: e = "/api/chat",
    credentials: t,
    headers: n,
    body: r,
    fetch: i,
    prepareSendMessagesRequest: o,
    prepareReconnectToStreamRequest: s
  }) {
    this.api = e, this.credentials = t, this.headers = n, this.body = r, this.fetch = i, this.prepareSendMessagesRequest = o, this.prepareReconnectToStreamRequest = s;
  }
  async sendMessages({
    abortSignal: e,
    ...t
  }) {
    var n, r, i, o, s;
    const a = await Cf(this.body), c = await Cf(this.headers), u = await Cf(this.credentials), f = {
      ...Du(c),
      ...Du(t.headers)
    }, h = await ((n = this.prepareSendMessagesRequest) == null ? void 0 : n.call(this, {
      api: this.api,
      id: t.chatId,
      messages: t.messages,
      body: { ...a, ...t.body },
      headers: f,
      credentials: u,
      requestMetadata: t.metadata,
      trigger: t.trigger,
      messageId: t.messageId
    })), m = (r = h?.api) != null ? r : this.api, g = h?.headers !== void 0 ? Du(h.headers) : f, b = h?.body !== void 0 ? h.body : {
      ...a,
      ...t.body,
      id: t.chatId,
      messages: t.messages,
      trigger: t.trigger,
      messageId: t.messageId
    }, x = (i = h?.credentials) != null ? i : u, S = await ((o = this.fetch) != null ? o : globalThis.fetch)(m, {
      method: "POST",
      headers: uz(
        {
          "Content-Type": "application/json",
          ...g
        },
        `ai-sdk/${gz}`,
        cz()
      ),
      body: JSON.stringify(b),
      credentials: x,
      signal: e
    });
    if (!S.ok)
      throw new Error(
        (s = await S.text()) != null ? s : "Failed to fetch the chat response."
      );
    if (!S.body)
      throw new Error("The response body is empty.");
    return this.processResponseStream(S.body);
  }
  async reconnectToStream(e) {
    var t, n, r, i, o;
    const s = await Cf(this.body), a = await Cf(this.headers), c = await Cf(this.credentials), u = {
      ...Du(a),
      ...Du(e.headers)
    }, f = await ((t = this.prepareReconnectToStreamRequest) == null ? void 0 : t.call(this, {
      api: this.api,
      id: e.chatId,
      body: { ...s, ...e.body },
      headers: u,
      credentials: c,
      requestMetadata: e.metadata
    })), h = (n = f?.api) != null ? n : `${this.api}/${e.chatId}/stream`, m = f?.headers !== void 0 ? Du(f.headers) : u, g = (r = f?.credentials) != null ? r : c, x = await ((i = this.fetch) != null ? i : globalThis.fetch)(h, {
      method: "GET",
      headers: uz(
        m,
        `ai-sdk/${gz}`,
        cz()
      ),
      credentials: g
    });
    if (x.status === 204)
      return null;
    if (!x.ok)
      throw new Error(
        (o = await x.text()) != null ? o : "Failed to fetch the chat response."
      );
    if (!x.body)
      throw new Error("The response body is empty.");
    return this.processResponseStream(x.body);
  }
}, mV = class extends _xe {
  constructor(e = {}) {
    super(e);
  }
  processResponseStream(e) {
    return abe({
      stream: e,
      schema: hxe
    }).pipeThrough(
      new TransformStream({
        async transform(t, n) {
          if (!t.success)
            throw t.error;
          n.enqueue(t.value);
        }
      })
    );
  }
}, Txe = class {
  constructor({
    generateId: e = X0e,
    id: t = e(),
    transport: n = new mV(),
    messageMetadataSchema: r,
    dataPartSchemas: i,
    state: o,
    onError: s,
    onToolCall: a,
    onFinish: c,
    onData: u,
    sendAutomaticallyWhen: f
  }) {
    this.activeResponse = void 0, this.jobExecutor = new wxe(), this.sendMessage = async (h, m) => {
      var g, b, x, w;
      if (h == null) {
        await this.makeRequest({
          trigger: "submit-message",
          messageId: (g = this.lastMessage) == null ? void 0 : g.id,
          ...m
        });
        return;
      }
      let S;
      if ("text" in h || "files" in h ? S = {
        parts: [
          ...Array.isArray(h.files) ? h.files : await Exe(h.files),
          ..."text" in h && h.text != null ? [{ type: "text", text: h.text }] : []
        ]
      } : S = h, h.messageId != null) {
        const _ = this.state.messages.findIndex(
          (M) => M.id === h.messageId
        );
        if (_ === -1)
          throw new Error(`message with id ${h.messageId} not found`);
        if (this.state.messages[_].role !== "user")
          throw new Error(
            `message with id ${h.messageId} is not a user message`
          );
        this.state.messages = this.state.messages.slice(0, _ + 1), this.state.replaceMessage(_, {
          ...S,
          id: h.messageId,
          role: (b = S.role) != null ? b : "user",
          metadata: h.metadata
        });
      } else
        this.state.pushMessage({
          ...S,
          id: (x = S.id) != null ? x : this.generateId(),
          role: (w = S.role) != null ? w : "user",
          metadata: h.metadata
        });
      await this.makeRequest({
        trigger: "submit-message",
        messageId: h.messageId,
        ...m
      });
    }, this.regenerate = async ({
      messageId: h,
      ...m
    } = {}) => {
      const g = h == null ? this.state.messages.length - 1 : this.state.messages.findIndex((b) => b.id === h);
      if (g === -1)
        throw new Error(`message ${h} not found`);
      this.state.messages = this.state.messages.slice(
        0,
        // if the message is a user message, we need to include it in the request:
        this.messages[g].role === "assistant" ? g : g + 1
      ), await this.makeRequest({
        trigger: "regenerate-message",
        messageId: h,
        ...m
      });
    }, this.resumeStream = async (h = {}) => {
      await this.makeRequest({ trigger: "resume-stream", ...h });
    }, this.clearError = () => {
      this.status === "error" && (this.state.error = void 0, this.setStatus({ status: "ready" }));
    }, this.addToolOutput = async ({
      state: h = "output-available",
      tool: m,
      toolCallId: g,
      output: b,
      errorText: x
    }) => this.jobExecutor.run(async () => {
      var w, S;
      const _ = this.state.messages, M = _[_.length - 1];
      this.state.replaceMessage(_.length - 1, {
        ...M,
        parts: M.parts.map(
          (N) => xg(N) && N.toolCallId === g ? { ...N, state: h, output: b, errorText: x } : N
        )
      }), this.activeResponse && (this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(
        (N) => xg(N) && N.toolCallId === g ? {
          ...N,
          state: h,
          output: b,
          errorText: x
        } : N
      )), this.status !== "streaming" && this.status !== "submitted" && ((w = this.sendAutomaticallyWhen) != null && w.call(this, { messages: this.state.messages })) && this.makeRequest({
        trigger: "submit-message",
        messageId: (S = this.lastMessage) == null ? void 0 : S.id
      });
    }), this.addToolResult = this.addToolOutput, this.stop = async () => {
      var h;
      this.status !== "streaming" && this.status !== "submitted" || (h = this.activeResponse) != null && h.abortController && this.activeResponse.abortController.abort();
    }, this.id = t, this.transport = n, this.generateId = e, this.messageMetadataSchema = r, this.dataPartSchemas = i, this.state = o, this.onError = s, this.onToolCall = a, this.onFinish = c, this.onData = u, this.sendAutomaticallyWhen = f;
  }
  /**
   * Hook status:
   *
   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.
   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.
   * - `ready`: The full response has been received and processed; a new user message can be submitted.
   * - `error`: An error occurred during the API request, preventing successful completion.
   */
  get status() {
    return this.state.status;
  }
  setStatus({
    status: e,
    error: t
  }) {
    this.status !== e && (this.state.status = e, this.state.error = t);
  }
  get error() {
    return this.state.error;
  }
  get messages() {
    return this.state.messages;
  }
  get lastMessage() {
    return this.state.messages[this.state.messages.length - 1];
  }
  set messages(e) {
    this.state.messages = e;
  }
  async makeRequest({
    trigger: e,
    metadata: t,
    headers: n,
    body: r,
    messageId: i
  }) {
    var o, s, a, c;
    this.setStatus({ status: "submitted", error: void 0 });
    const u = this.lastMessage;
    let f = !1, h = !1, m = !1;
    try {
      const g = {
        state: yxe({
          lastMessage: this.state.snapshot(u),
          messageId: this.generateId()
        }),
        abortController: new AbortController()
      };
      g.abortController.signal.addEventListener("abort", () => {
        f = !0;
      }), this.activeResponse = g;
      let b;
      if (e === "resume-stream") {
        const w = await this.transport.reconnectToStream({
          chatId: this.id,
          metadata: t,
          headers: n,
          body: r
        });
        if (w == null) {
          this.setStatus({ status: "ready" });
          return;
        }
        b = w;
      } else
        b = await this.transport.sendMessages({
          chatId: this.id,
          messages: this.state.messages,
          abortSignal: g.abortController.signal,
          metadata: t,
          headers: n,
          body: r,
          trigger: e,
          messageId: i
        });
      const x = (w) => (
        // serialize the job execution to avoid race conditions:
        this.jobExecutor.run(
          () => w({
            state: g.state,
            write: () => {
              var S;
              this.setStatus({ status: "streaming" }), g.state.message.id === ((S = this.lastMessage) == null ? void 0 : S.id) ? this.state.replaceMessage(
                this.state.messages.length - 1,
                g.state.message
              ) : this.state.pushMessage(g.state.message);
            }
          })
        )
      );
      await bxe({
        stream: vxe({
          stream: b,
          onToolCall: this.onToolCall,
          onData: this.onData,
          messageMetadataSchema: this.messageMetadataSchema,
          dataPartSchemas: this.dataPartSchemas,
          runUpdateMessageJob: x,
          onError: (w) => {
            throw w;
          }
        }),
        onError: (w) => {
          throw w;
        }
      }), this.setStatus({ status: "ready" });
    } catch (g) {
      if (f || g.name === "AbortError")
        return f = !0, this.setStatus({ status: "ready" }), null;
      m = !0, g instanceof TypeError && (g.message.toLowerCase().includes("fetch") || g.message.toLowerCase().includes("network")) && (h = !0), this.onError && g instanceof Error && this.onError(g), this.setStatus({ status: "error", error: g });
    } finally {
      try {
        (s = this.onFinish) == null || s.call(this, {
          message: this.activeResponse.state.message,
          messages: this.state.messages,
          isAbort: f,
          isDisconnect: h,
          isError: m,
          finishReason: (o = this.activeResponse) == null ? void 0 : o.state.finishReason
        });
      } catch (g) {
        console.error(g);
      }
      this.activeResponse = void 0;
    }
    (a = this.sendAutomaticallyWhen) != null && a.call(this, { messages: this.state.messages }) && !m && await this.makeRequest({
      trigger: "submit-message",
      messageId: (c = this.lastMessage) == null ? void 0 : c.id,
      metadata: t,
      headers: n,
      body: r
    });
  }
};
function Axe({
  messages: e
}) {
  const t = e[e.length - 1];
  if (!t || t.role !== "assistant")
    return !1;
  const n = t.parts.reduce((i, o, s) => o.type === "step-start" ? s : i, -1), r = t.parts.slice(n + 1).filter(xg).filter((i) => !i.providerExecuted);
  return r.length > 0 && r.every(
    (i) => i.state === "output-available" || i.state === "output-error"
  );
}
var NC, xz;
function Mxe() {
  if (xz) return NC;
  xz = 1;
  function e(t, n) {
    if (typeof t != "function")
      throw new TypeError(`Expected the first argument to be a \`function\`, got \`${typeof t}\`.`);
    let r, i = 0;
    return function(...s) {
      clearTimeout(r);
      const a = Date.now(), c = a - i, u = n - c;
      u <= 0 ? (i = a, t.apply(this, s)) : r = setTimeout(() => {
        i = Date.now(), t.apply(this, s);
      }, u);
    };
  }
  return NC = e, NC;
}
var Nxe = /* @__PURE__ */ Mxe();
const Rxe = /* @__PURE__ */ Bc(Nxe);
var gV = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, Fn = (e, t, n) => (gV(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Ls = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, nc = (e, t, n, r) => (gV(e, t, "write to private field"), t.set(e, n), n);
function Oxe(e, t) {
  return t != null ? Rxe(e, t) : e;
}
var Do, q0, G0, km, Cm, Em, If, tT, nT, Pxe = class {
  constructor(e = []) {
    Ls(this, Do, void 0), Ls(this, q0, "ready"), Ls(this, G0, void 0), Ls(this, km, /* @__PURE__ */ new Set()), Ls(this, Cm, /* @__PURE__ */ new Set()), Ls(this, Em, /* @__PURE__ */ new Set()), this.pushMessage = (t) => {
      nc(this, Do, Fn(this, Do).concat(t)), Fn(this, If).call(this);
    }, this.popMessage = () => {
      nc(this, Do, Fn(this, Do).slice(0, -1)), Fn(this, If).call(this);
    }, this.replaceMessage = (t, n) => {
      nc(this, Do, [
        ...Fn(this, Do).slice(0, t),
        // We deep clone the message here to ensure the new React Compiler (currently in RC) detects deeply nested parts/metadata changes:
        this.snapshot(n),
        ...Fn(this, Do).slice(t + 1)
      ]), Fn(this, If).call(this);
    }, this.snapshot = (t) => structuredClone(t), this["~registerMessagesCallback"] = (t, n) => {
      const r = n ? Oxe(t, n) : t;
      return Fn(this, km).add(r), () => {
        Fn(this, km).delete(r);
      };
    }, this["~registerStatusCallback"] = (t) => (Fn(this, Cm).add(t), () => {
      Fn(this, Cm).delete(t);
    }), this["~registerErrorCallback"] = (t) => (Fn(this, Em).add(t), () => {
      Fn(this, Em).delete(t);
    }), Ls(this, If, () => {
      Fn(this, km).forEach((t) => t());
    }), Ls(this, tT, () => {
      Fn(this, Cm).forEach((t) => t());
    }), Ls(this, nT, () => {
      Fn(this, Em).forEach((t) => t());
    }), nc(this, Do, e);
  }
  get status() {
    return Fn(this, q0);
  }
  set status(e) {
    nc(this, q0, e), Fn(this, tT).call(this);
  }
  get error() {
    return Fn(this, G0);
  }
  set error(e) {
    nc(this, G0, e), Fn(this, nT).call(this);
  }
  get messages() {
    return Fn(this, Do);
  }
  set messages(e) {
    nc(this, Do, [...e]), Fn(this, If).call(this);
  }
};
Do = /* @__PURE__ */ new WeakMap();
q0 = /* @__PURE__ */ new WeakMap();
G0 = /* @__PURE__ */ new WeakMap();
km = /* @__PURE__ */ new WeakMap();
Cm = /* @__PURE__ */ new WeakMap();
Em = /* @__PURE__ */ new WeakMap();
If = /* @__PURE__ */ new WeakMap();
tT = /* @__PURE__ */ new WeakMap();
nT = /* @__PURE__ */ new WeakMap();
var jf, wz = class extends Txe {
  constructor({ messages: e, ...t }) {
    const n = new Pxe(e);
    super({ ...t, state: n }), Ls(this, jf, void 0), this["~registerMessagesCallback"] = (r, i) => Fn(this, jf)["~registerMessagesCallback"](r, i), this["~registerStatusCallback"] = (r) => Fn(this, jf)["~registerStatusCallback"](r), this["~registerErrorCallback"] = (r) => Fn(this, jf)["~registerErrorCallback"](r), nc(this, jf, n);
  }
};
jf = /* @__PURE__ */ new WeakMap();
function Dxe({
  experimental_throttle: e,
  resume: t = !1,
  ...n
} = {}) {
  const r = C.useRef(
    "chat" in n ? n.chat : new wz(n)
  );
  ("chat" in n && n.chat !== r.current || "id" in n && r.current.id !== n.id) && (r.current = "chat" in n ? n.chat : new wz(n));
  const o = C.useCallback(
    (f) => r.current["~registerMessagesCallback"](f, e),
    // `chatRef.current.id` is required to trigger re-subscription when the chat ID changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [e, r.current.id]
  ), s = C.useSyncExternalStore(
    o,
    () => r.current.messages,
    () => r.current.messages
  ), a = C.useSyncExternalStore(
    r.current["~registerStatusCallback"],
    () => r.current.status,
    () => r.current.status
  ), c = C.useSyncExternalStore(
    r.current["~registerErrorCallback"],
    () => r.current.error,
    () => r.current.error
  ), u = C.useCallback(
    (f) => {
      typeof f == "function" && (f = f(r.current.messages)), r.current.messages = f;
    },
    [r]
  );
  return C.useEffect(() => {
    t && r.current.resumeStream();
  }, [t, r]), {
    id: r.current.id,
    messages: s,
    setMessages: u,
    sendMessage: r.current.sendMessage,
    regenerate: r.current.regenerate,
    clearError: r.current.clearError,
    stop: r.current.stop,
    error: c,
    resumeStream: r.current.resumeStream,
    status: a,
    /**
     * @deprecated Use `addToolOutput` instead.
     */
    addToolResult: r.current.addToolOutput,
    addToolOutput: r.current.addToolOutput
  };
}
function Fm(e, t) {
  if (e === t) return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (Object.getPrototypeOf(e) !== Object.getPrototypeOf(t)) return !1;
    if (Array.isArray(e)) {
      if (!Array.isArray(t) || e.length !== t.length) return !1;
      for (let i = 0; i < e.length; i++)
        if (!Fm(e[i], t[i])) return !1;
      return !0;
    }
    if (e instanceof Date)
      return t instanceof Date && e.getTime() === t.getTime();
    if (e instanceof RegExp)
      return t instanceof RegExp && e.source === t.source && e.flags === t.flags;
    if (e instanceof Map) {
      if (!(t instanceof Map) || e.size !== t.size) return !1;
      for (const [i, o] of e)
        if (!t.has(i) || !Fm(o, t.get(i))) return !1;
      return !0;
    }
    if (e instanceof Set) {
      if (!(t instanceof Set) || e.size !== t.size) return !1;
      for (const i of e)
        if (!t.has(i)) return !1;
      return !0;
    }
    const n = Object.keys(e), r = Object.keys(t);
    if (n.length !== r.length) return !1;
    for (const i of n)
      if (!Object.prototype.hasOwnProperty.call(t, i) || !Fm(e[i], t[i])) return !1;
    return !0;
  }
  return Number.isNaN(e) && Number.isNaN(t);
}
function yV(e, t) {
  const n = t || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const Ixe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, jxe = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, zxe = {};
function Sz(e, t) {
  return (zxe.jsx ? jxe : Ixe).test(e);
}
const Lxe = /[ \t\n\f\r]/g;
function qw(e) {
  return typeof e == "object" ? e.type === "text" ? kz(e.value) : !1 : kz(e);
}
function kz(e) {
  return e.replace(Lxe, "") === "";
}
let hy = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
};
hy.prototype.normal = {};
hy.prototype.property = {};
hy.prototype.space = void 0;
function vV(e, t) {
  const n = {}, r = {};
  for (const i of e)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new hy(n, r, t);
}
function rT(e) {
  return e.toLowerCase();
}
class Qi {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
Qi.prototype.attribute = "";
Qi.prototype.booleanish = !1;
Qi.prototype.boolean = !1;
Qi.prototype.commaOrSpaceSeparated = !1;
Qi.prototype.commaSeparated = !1;
Qi.prototype.defined = !1;
Qi.prototype.mustUseProperty = !1;
Qi.prototype.number = !1;
Qi.prototype.overloadedBoolean = !1;
Qi.prototype.property = "";
Qi.prototype.spaceSeparated = !1;
Qi.prototype.space = void 0;
let Bxe = 0;
const Dt = kd(), Sr = kd(), iT = kd(), Fe = kd(), On = kd(), ah = kd(), uo = kd();
function kd() {
  return 2 ** ++Bxe;
}
const oT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Dt,
  booleanish: Sr,
  commaOrSpaceSeparated: uo,
  commaSeparated: ah,
  number: Fe,
  overloadedBoolean: iT,
  spaceSeparated: On
}, Symbol.toStringTag, { value: "Module" })), RC = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(oT)
);
class rN extends Qi {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, i) {
    let o = -1;
    if (super(t, n), Cz(this, "space", i), typeof r == "number")
      for (; ++o < RC.length; ) {
        const s = RC[o];
        Cz(this, RC[o], (r & oT[s]) === oT[s]);
      }
  }
}
rN.prototype.defined = !0;
function Cz(e, t, n) {
  n && (e[t] = n);
}
function Jh(e) {
  const t = {}, n = {};
  for (const [r, i] of Object.entries(e.properties)) {
    const o = new rN(
      r,
      e.transform(e.attributes || {}, r),
      i,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (o.mustUseProperty = !0), t[r] = o, n[rT(r)] = r, n[rT(o.attribute)] = r;
  }
  return new hy(t, n, e.space);
}
const bV = Jh({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Sr,
    ariaAutoComplete: null,
    ariaBusy: Sr,
    ariaChecked: Sr,
    ariaColCount: Fe,
    ariaColIndex: Fe,
    ariaColSpan: Fe,
    ariaControls: On,
    ariaCurrent: null,
    ariaDescribedBy: On,
    ariaDetails: null,
    ariaDisabled: Sr,
    ariaDropEffect: On,
    ariaErrorMessage: null,
    ariaExpanded: Sr,
    ariaFlowTo: On,
    ariaGrabbed: Sr,
    ariaHasPopup: null,
    ariaHidden: Sr,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: On,
    ariaLevel: Fe,
    ariaLive: null,
    ariaModal: Sr,
    ariaMultiLine: Sr,
    ariaMultiSelectable: Sr,
    ariaOrientation: null,
    ariaOwns: On,
    ariaPlaceholder: null,
    ariaPosInSet: Fe,
    ariaPressed: Sr,
    ariaReadOnly: Sr,
    ariaRelevant: null,
    ariaRequired: Sr,
    ariaRoleDescription: On,
    ariaRowCount: Fe,
    ariaRowIndex: Fe,
    ariaRowSpan: Fe,
    ariaSelected: Sr,
    ariaSetSize: Fe,
    ariaSort: null,
    ariaValueMax: Fe,
    ariaValueMin: Fe,
    ariaValueNow: Fe,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function xV(e, t) {
  return t in e ? e[t] : t;
}
function wV(e, t) {
  return xV(e, t.toLowerCase());
}
const $xe = Jh({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: ah,
    acceptCharset: On,
    accessKey: On,
    action: null,
    allow: null,
    allowFullScreen: Dt,
    allowPaymentRequest: Dt,
    allowUserMedia: Dt,
    alt: null,
    as: null,
    async: Dt,
    autoCapitalize: null,
    autoComplete: On,
    autoFocus: Dt,
    autoPlay: Dt,
    blocking: On,
    capture: null,
    charSet: null,
    checked: Dt,
    cite: null,
    className: On,
    cols: Fe,
    colSpan: null,
    content: null,
    contentEditable: Sr,
    controls: Dt,
    controlsList: On,
    coords: Fe | ah,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Dt,
    defer: Dt,
    dir: null,
    dirName: null,
    disabled: Dt,
    download: iT,
    draggable: Sr,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Dt,
    formTarget: null,
    headers: On,
    height: Fe,
    hidden: iT,
    high: Fe,
    href: null,
    hrefLang: null,
    htmlFor: On,
    httpEquiv: On,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Dt,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Dt,
    itemId: null,
    itemProp: On,
    itemRef: On,
    itemScope: Dt,
    itemType: On,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Dt,
    low: Fe,
    manifest: null,
    max: null,
    maxLength: Fe,
    media: null,
    method: null,
    min: null,
    minLength: Fe,
    multiple: Dt,
    muted: Dt,
    name: null,
    nonce: null,
    noModule: Dt,
    noValidate: Dt,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Dt,
    optimum: Fe,
    pattern: null,
    ping: On,
    placeholder: null,
    playsInline: Dt,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Dt,
    referrerPolicy: null,
    rel: On,
    required: Dt,
    reversed: Dt,
    rows: Fe,
    rowSpan: Fe,
    sandbox: On,
    scope: null,
    scoped: Dt,
    seamless: Dt,
    selected: Dt,
    shadowRootClonable: Dt,
    shadowRootDelegatesFocus: Dt,
    shadowRootMode: null,
    shape: null,
    size: Fe,
    sizes: null,
    slot: null,
    span: Fe,
    spellCheck: Sr,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: Fe,
    step: null,
    style: null,
    tabIndex: Fe,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Dt,
    useMap: null,
    value: Sr,
    width: Fe,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: On,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: Fe,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: Fe,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Dt,
    // Lists. Use CSS to reduce space between items instead
    declare: Dt,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: Fe,
    // `<img>` and `<object>`
    leftMargin: Fe,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: Fe,
    // `<body>`
    marginWidth: Fe,
    // `<body>`
    noResize: Dt,
    // `<frame>`
    noHref: Dt,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Dt,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Dt,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: Fe,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Sr,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: Fe,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: Fe,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Dt,
    disableRemotePlayback: Dt,
    prefix: null,
    property: null,
    results: Fe,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: wV
}), Uxe = Jh({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: uo,
    accentHeight: Fe,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: Fe,
    amplitude: Fe,
    arabicForm: null,
    ascent: Fe,
    attributeName: null,
    attributeType: null,
    azimuth: Fe,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: Fe,
    by: null,
    calcMode: null,
    capHeight: Fe,
    className: On,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: Fe,
    diffuseConstant: Fe,
    direction: null,
    display: null,
    dur: null,
    divisor: Fe,
    dominantBaseline: null,
    download: Dt,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: Fe,
    enableBackground: null,
    end: null,
    event: null,
    exponent: Fe,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: Fe,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: ah,
    g2: ah,
    glyphName: ah,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: Fe,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: Fe,
    horizOriginX: Fe,
    horizOriginY: Fe,
    id: null,
    ideographic: Fe,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: Fe,
    k: Fe,
    k1: Fe,
    k2: Fe,
    k3: Fe,
    k4: Fe,
    kernelMatrix: uo,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: Fe,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: Fe,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: Fe,
    overlineThickness: Fe,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: Fe,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: On,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: Fe,
    pointsAtY: Fe,
    pointsAtZ: Fe,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: uo,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: uo,
    rev: uo,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: uo,
    requiredFeatures: uo,
    requiredFonts: uo,
    requiredFormats: uo,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: Fe,
    specularExponent: Fe,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: Fe,
    strikethroughThickness: Fe,
    string: null,
    stroke: null,
    strokeDashArray: uo,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: Fe,
    strokeOpacity: Fe,
    strokeWidth: null,
    style: null,
    surfaceScale: Fe,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: uo,
    tabIndex: Fe,
    tableValues: null,
    target: null,
    targetX: Fe,
    targetY: Fe,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: uo,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: Fe,
    underlineThickness: Fe,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: Fe,
    values: null,
    vAlphabetic: Fe,
    vMathematical: Fe,
    vectorEffect: null,
    vHanging: Fe,
    vIdeographic: Fe,
    version: null,
    vertAdvY: Fe,
    vertOriginX: Fe,
    vertOriginY: Fe,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: Fe,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: xV
}), SV = Jh({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), kV = Jh({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: wV
}), CV = Jh({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), Fxe = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, Vxe = /[A-Z]/g, Ez = /-[a-z]/g, Hxe = /^data[-\w.:]+$/i;
function EV(e, t) {
  const n = rT(t);
  let r = t, i = Qi;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && Hxe.test(t)) {
    if (t.charAt(4) === "-") {
      const o = t.slice(5).replace(Ez, qxe);
      r = "data" + o.charAt(0).toUpperCase() + o.slice(1);
    } else {
      const o = t.slice(4);
      if (!Ez.test(o)) {
        let s = o.replace(Vxe, Wxe);
        s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s;
      }
    }
    i = rN;
  }
  return new i(r, t);
}
function Wxe(e) {
  return "-" + e.toLowerCase();
}
function qxe(e) {
  return e.charAt(1).toUpperCase();
}
const _V = vV([bV, $xe, SV, kV, CV], "html"), py = vV([bV, Uxe, SV, kV, CV], "svg");
function TV(e) {
  return e.join(" ").trim();
}
var Ef = {}, OC, _z;
function Gxe() {
  if (_z) return OC;
  _z = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, i = /^:\s*/, o = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, s = /^[;\s]*/, a = /^\s+|\s+$/g, c = `
`, u = "/", f = "*", h = "", m = "comment", g = "declaration";
  function b(w, S) {
    if (typeof w != "string")
      throw new TypeError("First argument must be a string");
    if (!w) return [];
    S = S || {};
    var _ = 1, M = 1;
    function N(ie) {
      var ne = ie.match(t);
      ne && (_ += ne.length);
      var H = ie.lastIndexOf(c);
      M = ~H ? ie.length - H : M + ie.length;
    }
    function D() {
      var ie = { line: _, column: M };
      return function(ne) {
        return ne.position = new j(ie), U(), ne;
      };
    }
    function j(ie) {
      this.start = ie, this.end = { line: _, column: M }, this.source = S.source;
    }
    j.prototype.content = w;
    function O(ie) {
      var ne = new Error(
        S.source + ":" + _ + ":" + M + ": " + ie
      );
      if (ne.reason = ie, ne.filename = S.source, ne.line = _, ne.column = M, ne.source = w, !S.silent) throw ne;
    }
    function L(ie) {
      var ne = ie.exec(w);
      if (ne) {
        var H = ne[0];
        return N(H), w = w.slice(H.length), ne;
      }
    }
    function U() {
      L(n);
    }
    function B(ie) {
      var ne;
      for (ie = ie || []; ne = G(); )
        ne !== !1 && ie.push(ne);
      return ie;
    }
    function G() {
      var ie = D();
      if (!(u != w.charAt(0) || f != w.charAt(1))) {
        for (var ne = 2; h != w.charAt(ne) && (f != w.charAt(ne) || u != w.charAt(ne + 1)); )
          ++ne;
        if (ne += 2, h === w.charAt(ne - 1))
          return O("End of comment missing");
        var H = w.slice(2, ne - 2);
        return M += 2, N(H), w = w.slice(ne), M += 2, ie({
          type: m,
          comment: H
        });
      }
    }
    function Y() {
      var ie = D(), ne = L(r);
      if (ne) {
        if (G(), !L(i)) return O("property missing ':'");
        var H = L(o), Q = ie({
          type: g,
          property: x(ne[0].replace(e, h)),
          value: H ? x(H[0].replace(e, h)) : h
        });
        return L(s), Q;
      }
    }
    function he() {
      var ie = [];
      B(ie);
      for (var ne; ne = Y(); )
        ne !== !1 && (ie.push(ne), B(ie));
      return ie;
    }
    return U(), he();
  }
  function x(w) {
    return w ? w.replace(a, h) : h;
  }
  return OC = b, OC;
}
var Tz;
function Kxe() {
  if (Tz) return Ef;
  Tz = 1;
  var e = Ef && Ef.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(Ef, "__esModule", { value: !0 }), Ef.default = n;
  const t = e(Gxe());
  function n(r, i) {
    let o = null;
    if (!r || typeof r != "string")
      return o;
    const s = (0, t.default)(r), a = typeof i == "function";
    return s.forEach((c) => {
      if (c.type !== "declaration")
        return;
      const { property: u, value: f } = c;
      a ? i(u, f, c) : f && (o = o || {}, o[u] = f);
    }), o;
  }
  return Ef;
}
var lm = {}, Az;
function Zxe() {
  if (Az) return lm;
  Az = 1, Object.defineProperty(lm, "__esModule", { value: !0 }), lm.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, i = /^-(ms)-/, o = function(u) {
    return !u || n.test(u) || e.test(u);
  }, s = function(u, f) {
    return f.toUpperCase();
  }, a = function(u, f) {
    return "".concat(f, "-");
  }, c = function(u, f) {
    return f === void 0 && (f = {}), o(u) ? u : (u = u.toLowerCase(), f.reactCompat ? u = u.replace(i, a) : u = u.replace(r, a), u.replace(t, s));
  };
  return lm.camelCase = c, lm;
}
var cm, Mz;
function Yxe() {
  if (Mz) return cm;
  Mz = 1;
  var e = cm && cm.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  }, t = e(Kxe()), n = Zxe();
  function r(i, o) {
    var s = {};
    return !i || typeof i != "string" || (0, t.default)(i, function(a, c) {
      a && c && (s[(0, n.camelCase)(a, o)] = c);
    }), s;
  }
  return r.default = r, cm = r, cm;
}
var Xxe = Yxe();
const Jxe = /* @__PURE__ */ Bc(Xxe), AV = MV("end"), iN = MV("start");
function MV(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function Qxe(e) {
  const t = iN(e), n = AV(e);
  if (t && n)
    return { start: t, end: n };
}
function Vm(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Nz(e.position) : "start" in e || "end" in e ? Nz(e) : "line" in e || "column" in e ? sT(e) : "";
}
function sT(e) {
  return Rz(e && e.line) + ":" + Rz(e && e.column);
}
function Nz(e) {
  return sT(e && e.start) + "-" + sT(e && e.end);
}
function Rz(e) {
  return e && typeof e == "number" ? e : 1;
}
class Si extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", o = {}, s = !1;
    if (n && ("line" in n && "column" in n ? o = { place: n } : "start" in n && "end" in n ? o = { place: n } : "type" in n ? o = {
      ancestors: [n],
      place: n.position
    } : o = { ...n }), typeof t == "string" ? i = t : !o.cause && t && (s = !0, i = t.message, o.cause = t), !o.ruleId && !o.source && typeof r == "string") {
      const c = r.indexOf(":");
      c === -1 ? o.ruleId = r : (o.source = r.slice(0, c), o.ruleId = r.slice(c + 1));
    }
    if (!o.place && o.ancestors && o.ancestors) {
      const c = o.ancestors[o.ancestors.length - 1];
      c && (o.place = c.position);
    }
    const a = o.place && "start" in o.place ? o.place.start : o.place;
    this.ancestors = o.ancestors || void 0, this.cause = o.cause || void 0, this.column = a ? a.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = a ? a.line : void 0, this.name = Vm(o.place) || "1:1", this.place = o.place || void 0, this.reason = this.message, this.ruleId = o.ruleId || void 0, this.source = o.source || void 0, this.stack = s && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
Si.prototype.file = "";
Si.prototype.name = "";
Si.prototype.reason = "";
Si.prototype.message = "";
Si.prototype.stack = "";
Si.prototype.column = void 0;
Si.prototype.line = void 0;
Si.prototype.ancestors = void 0;
Si.prototype.cause = void 0;
Si.prototype.fatal = void 0;
Si.prototype.place = void 0;
Si.prototype.ruleId = void 0;
Si.prototype.source = void 0;
const oN = {}.hasOwnProperty, ewe = /* @__PURE__ */ new Map(), twe = /[A-Z]/g, nwe = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), rwe = /* @__PURE__ */ new Set(["td", "th"]), NV = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function RV(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = dwe(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = uwe(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? py : _V,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, o = OV(i, e, void 0);
  return o && typeof o != "string" ? o : i.create(
    e,
    i.Fragment,
    { children: o || void 0 },
    void 0
  );
}
function OV(e, t, n) {
  if (t.type === "element")
    return iwe(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return owe(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return awe(e, t, n);
  if (t.type === "mdxjsEsm")
    return swe(e, t);
  if (t.type === "root")
    return lwe(e, t, n);
  if (t.type === "text")
    return cwe(e, t);
}
function iwe(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = py, e.schema = i), e.ancestors.push(t);
  const o = DV(e, t.tagName, !1), s = fwe(e, t);
  let a = aN(e, t);
  return nwe.has(t.tagName) && (a = a.filter(function(c) {
    return typeof c == "string" ? !qw(c) : !0;
  })), PV(e, s, o, t), sN(s, a), e.ancestors.pop(), e.schema = r, e.create(t, o, s, n);
}
function owe(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  Sg(e, t.position);
}
function swe(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Sg(e, t.position);
}
function awe(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = py, e.schema = i), e.ancestors.push(t);
  const o = t.name === null ? e.Fragment : DV(e, t.name, !0), s = hwe(e, t), a = aN(e, t);
  return PV(e, s, o, t), sN(s, a), e.ancestors.pop(), e.schema = r, e.create(t, o, s, n);
}
function lwe(e, t, n) {
  const r = {};
  return sN(r, aN(e, t)), e.create(t, e.Fragment, r, n);
}
function cwe(e, t) {
  return t.value;
}
function PV(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function sN(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function uwe(e, t, n) {
  return r;
  function r(i, o, s, a) {
    const u = Array.isArray(s.children) ? n : t;
    return a ? u(o, s, a) : u(o, s);
  }
}
function dwe(e, t) {
  return n;
  function n(r, i, o, s) {
    const a = Array.isArray(o.children), c = iN(r);
    return t(
      i,
      o,
      s,
      a,
      {
        columnNumber: c ? c.column - 1 : void 0,
        fileName: e,
        lineNumber: c ? c.line : void 0
      },
      void 0
    );
  }
}
function fwe(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && oN.call(t.properties, i)) {
      const o = pwe(e, i, t.properties[i]);
      if (o) {
        const [s, a] = o;
        e.tableCellAlignToStyle && s === "align" && typeof a == "string" && rwe.has(t.tagName) ? r = a : n[s] = a;
      }
    }
  if (r) {
    const o = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    o[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function hwe(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const o = r.data.estree.body[0];
        o.type;
        const s = o.expression;
        s.type;
        const a = s.properties[0];
        a.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(a.argument)
        );
      } else
        Sg(e, t.position);
    else {
      const i = r.name;
      let o;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const a = r.value.data.estree.body[0];
          a.type, o = e.evaluater.evaluateExpression(a.expression);
        } else
          Sg(e, t.position);
      else
        o = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      o;
    }
  return n;
}
function aN(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : ewe;
  for (; ++r < t.children.length; ) {
    const o = t.children[r];
    let s;
    if (e.passKeys) {
      const c = o.type === "element" ? o.tagName : o.type === "mdxJsxFlowElement" || o.type === "mdxJsxTextElement" ? o.name : void 0;
      if (c) {
        const u = i.get(c) || 0;
        s = c + "-" + u, i.set(c, u + 1);
      }
    }
    const a = OV(e, o, s);
    a !== void 0 && n.push(a);
  }
  return n;
}
function pwe(e, t, n) {
  const r = EV(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? yV(n) : TV(n)), r.property === "style") {
      let i = typeof n == "object" ? n : mwe(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = gwe(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? Fxe[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function mwe(e, t) {
  try {
    return Jxe(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), i = new Si("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw i.file = e.filePath || void 0, i.url = NV + "#cannot-parse-style-attribute", i;
  }
}
function DV(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let o = -1, s;
    for (; ++o < i.length; ) {
      const a = Sz(i[o]) ? { type: "Identifier", name: i[o] } : { type: "Literal", value: i[o] };
      s = s ? {
        type: "MemberExpression",
        object: s,
        property: a,
        computed: !!(o && a.type === "Literal"),
        optional: !1
      } : a;
    }
    r = s;
  } else
    r = Sz(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {string | number} */
      r.value
    );
    return oN.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Sg(e);
}
function Sg(e, t) {
  const n = new Si(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = NV + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function gwe(e) {
  const t = {};
  let n;
  for (n in e)
    oN.call(e, n) && (t[ywe(n)] = e[n]);
  return t;
}
function ywe(e) {
  let t = e.replace(twe, vwe);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function vwe(e) {
  return "-" + e.toLowerCase();
}
const PC = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, bwe = {};
function lN(e, t) {
  const n = bwe, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return IV(e, r, i);
}
function IV(e, t, n) {
  if (xwe(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Oz(e.children, t, n);
  }
  return Array.isArray(e) ? Oz(e, t, n) : "";
}
function Oz(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = IV(e[i], t, n);
  return r.join("");
}
function xwe(e) {
  return !!(e && typeof e == "object");
}
const Pz = document.createElement("i");
function cN(e) {
  const t = "&" + e + ";";
  Pz.innerHTML = t;
  const n = Pz.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function vo(e, t, n, r) {
  const i = e.length;
  let o = 0, s;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    s = Array.from(r), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); o < r.length; )
      s = r.slice(o, o + 1e4), s.unshift(t, 0), e.splice(...s), o += 1e4, t += 1e4;
}
function $o(e, t) {
  return e.length > 0 ? (vo(e, e.length, 0, t), e) : t;
}
const Dz = {}.hasOwnProperty;
function jV(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    wwe(t, e[n]);
  return t;
}
function wwe(e, t) {
  let n;
  for (n in t) {
    const i = (Dz.call(e, n) ? e[n] : void 0) || (e[n] = {}), o = t[n];
    let s;
    if (o)
      for (s in o) {
        Dz.call(i, s) || (i[s] = []);
        const a = o[s];
        Swe(
          // @ts-expect-error Looks like a list.
          i[s],
          Array.isArray(a) ? a : a ? [a] : []
        );
      }
  }
}
function Swe(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  vo(e, 0, 0, r);
}
function zV(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function ms(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Ri = Gc(/[A-Za-z]/), bi = Gc(/[\dA-Za-z]/), kwe = Gc(/[#-'*+\--9=?A-Z^-~]/);
function Kb(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const aT = Gc(/\d/), Cwe = Gc(/[\dA-Fa-f]/), Ewe = Gc(/[!-/:-@[-`{-~]/);
function vt(e) {
  return e !== null && e < -2;
}
function An(e) {
  return e !== null && (e < 0 || e === 32);
}
function Zt(e) {
  return e === -2 || e === -1 || e === 32;
}
const Gw = Gc(new RegExp("\\p{P}|\\p{S}", "u")), cd = Gc(/\s/);
function Gc(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Qh(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const o = e.charCodeAt(n);
    let s = "";
    if (o === 37 && bi(e.charCodeAt(n + 1)) && bi(e.charCodeAt(n + 2)))
      i = 2;
    else if (o < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (s = String.fromCharCode(o));
    else if (o > 55295 && o < 57344) {
      const a = e.charCodeAt(n + 1);
      o < 56320 && a > 56319 && a < 57344 ? (s = String.fromCharCode(o, a), i = 1) : s = "";
    } else
      s = String.fromCharCode(o);
    s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + i + 1, s = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function rn(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let o = 0;
  return s;
  function s(c) {
    return Zt(c) ? (e.enter(n), a(c)) : t(c);
  }
  function a(c) {
    return Zt(c) && o++ < i ? (e.consume(c), a) : (e.exit(n), t(c));
  }
}
const _we = {
  tokenize: Twe
};
function Twe(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return t;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), rn(e, t, "linePrefix");
  }
  function i(a) {
    return e.enter("paragraph"), o(a);
  }
  function o(a) {
    const c = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = c), n = c, s(a);
  }
  function s(a) {
    if (a === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(a);
      return;
    }
    return vt(a) ? (e.consume(a), e.exit("chunkText"), o) : (e.consume(a), s);
  }
}
const Awe = {
  tokenize: Mwe
}, Iz = {
  tokenize: Nwe
};
function Mwe(e) {
  const t = this, n = [];
  let r = 0, i, o, s;
  return a;
  function a(M) {
    if (r < n.length) {
      const N = n[r];
      return t.containerState = N[1], e.attempt(N[0].continuation, c, u)(M);
    }
    return u(M);
  }
  function c(M) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && _();
      const N = t.events.length;
      let D = N, j;
      for (; D--; )
        if (t.events[D][0] === "exit" && t.events[D][1].type === "chunkFlow") {
          j = t.events[D][1].end;
          break;
        }
      S(r);
      let O = N;
      for (; O < t.events.length; )
        t.events[O][1].end = {
          ...j
        }, O++;
      return vo(t.events, D + 1, 0, t.events.slice(N)), t.events.length = O, u(M);
    }
    return a(M);
  }
  function u(M) {
    if (r === n.length) {
      if (!i)
        return m(M);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return b(M);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(Iz, f, h)(M);
  }
  function f(M) {
    return i && _(), S(r), m(M);
  }
  function h(M) {
    return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, b(M);
  }
  function m(M) {
    return t.containerState = {}, e.attempt(Iz, g, b)(M);
  }
  function g(M) {
    return r++, n.push([t.currentConstruct, t.containerState]), m(M);
  }
  function b(M) {
    if (M === null) {
      i && _(), S(0), e.consume(M);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: o
    }), x(M);
  }
  function x(M) {
    if (M === null) {
      w(e.exit("chunkFlow"), !0), S(0), e.consume(M);
      return;
    }
    return vt(M) ? (e.consume(M), w(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, a) : (e.consume(M), x);
  }
  function w(M, N) {
    const D = t.sliceStream(M);
    if (N && D.push(null), M.previous = o, o && (o.next = M), o = M, i.defineSkip(M.start), i.write(D), t.parser.lazy[M.start.line]) {
      let j = i.events.length;
      for (; j--; )
        if (
          // The token starts before the line ending
          i.events[j][1].start.offset < s && // and either is not ended yet
          (!i.events[j][1].end || // or ends after it.
          i.events[j][1].end.offset > s)
        )
          return;
      const O = t.events.length;
      let L = O, U, B;
      for (; L--; )
        if (t.events[L][0] === "exit" && t.events[L][1].type === "chunkFlow") {
          if (U) {
            B = t.events[L][1].end;
            break;
          }
          U = !0;
        }
      for (S(r), j = O; j < t.events.length; )
        t.events[j][1].end = {
          ...B
        }, j++;
      vo(t.events, L + 1, 0, t.events.slice(O)), t.events.length = j;
    }
  }
  function S(M) {
    let N = n.length;
    for (; N-- > M; ) {
      const D = n[N];
      t.containerState = D[1], D[0].exit.call(t, e);
    }
    n.length = M;
  }
  function _() {
    i.write([null]), o = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function Nwe(e, t, n) {
  return rn(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function kh(e) {
  if (e === null || An(e) || cd(e))
    return 1;
  if (Gw(e))
    return 2;
}
function Kw(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const o = e[i].resolveAll;
    o && !r.includes(o) && (t = o(t, n), r.push(o));
  }
  return t;
}
const lT = {
  name: "attention",
  resolveAll: Rwe,
  tokenize: Owe
};
function Rwe(e, t) {
  let n = -1, r, i, o, s, a, c, u, f;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          c = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const h = {
            ...e[r][1].end
          }, m = {
            ...e[n][1].start
          };
          jz(h, -c), jz(m, c), s = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: {
              ...e[r][1].end
            }
          }, a = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: m
          }, o = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, i = {
            type: c > 1 ? "strong" : "emphasis",
            start: {
              ...s.start
            },
            end: {
              ...a.end
            }
          }, e[r][1].end = {
            ...s.start
          }, e[n][1].start = {
            ...a.end
          }, u = [], e[r][1].end.offset - e[r][1].start.offset && (u = $o(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])), u = $o(u, [["enter", i, t], ["enter", s, t], ["exit", s, t], ["enter", o, t]]), u = $o(u, Kw(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), u = $o(u, [["exit", o, t], ["enter", a, t], ["exit", a, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (f = 2, u = $o(u, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : f = 0, vo(e, r - 1, n - r + 3, u), n = r + u.length - f - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function Owe(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = kh(r);
  let o;
  return s;
  function s(c) {
    return o = c, e.enter("attentionSequence"), a(c);
  }
  function a(c) {
    if (c === o)
      return e.consume(c), a;
    const u = e.exit("attentionSequence"), f = kh(c), h = !f || f === 2 && i || n.includes(c), m = !i || i === 2 && f || n.includes(r);
    return u._open = !!(o === 42 ? h : h && (i || !m)), u._close = !!(o === 42 ? m : m && (f || !h)), t(c);
  }
}
function jz(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const Pwe = {
  name: "autolink",
  tokenize: Dwe
};
function Dwe(e, t, n) {
  let r = 0;
  return i;
  function i(g) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), o;
  }
  function o(g) {
    return Ri(g) ? (e.consume(g), s) : g === 64 ? n(g) : u(g);
  }
  function s(g) {
    return g === 43 || g === 45 || g === 46 || bi(g) ? (r = 1, a(g)) : u(g);
  }
  function a(g) {
    return g === 58 ? (e.consume(g), r = 0, c) : (g === 43 || g === 45 || g === 46 || bi(g)) && r++ < 32 ? (e.consume(g), a) : (r = 0, u(g));
  }
  function c(g) {
    return g === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.exit("autolink"), t) : g === null || g === 32 || g === 60 || Kb(g) ? n(g) : (e.consume(g), c);
  }
  function u(g) {
    return g === 64 ? (e.consume(g), f) : kwe(g) ? (e.consume(g), u) : n(g);
  }
  function f(g) {
    return bi(g) ? h(g) : n(g);
  }
  function h(g) {
    return g === 46 ? (e.consume(g), r = 0, f) : g === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.exit("autolink"), t) : m(g);
  }
  function m(g) {
    if ((g === 45 || bi(g)) && r++ < 63) {
      const b = g === 45 ? m : h;
      return e.consume(g), b;
    }
    return n(g);
  }
}
const my = {
  partial: !0,
  tokenize: Iwe
};
function Iwe(e, t, n) {
  return r;
  function r(o) {
    return Zt(o) ? rn(e, i, "linePrefix")(o) : i(o);
  }
  function i(o) {
    return o === null || vt(o) ? t(o) : n(o);
  }
}
const LV = {
  continuation: {
    tokenize: zwe
  },
  exit: Lwe,
  name: "blockQuote",
  tokenize: jwe
};
function jwe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    if (s === 62) {
      const a = r.containerState;
      return a.open || (e.enter("blockQuote", {
        _container: !0
      }), a.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), o;
    }
    return n(s);
  }
  function o(s) {
    return Zt(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s));
  }
}
function zwe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return Zt(s) ? rn(e, o, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) : o(s);
  }
  function o(s) {
    return e.attempt(LV, t, n)(s);
  }
}
function Lwe(e) {
  e.exit("blockQuote");
}
const BV = {
  name: "characterEscape",
  tokenize: Bwe
};
function Bwe(e, t, n) {
  return r;
  function r(o) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(o), e.exit("escapeMarker"), i;
  }
  function i(o) {
    return Ewe(o) ? (e.enter("characterEscapeValue"), e.consume(o), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(o);
  }
}
const $V = {
  name: "characterReference",
  tokenize: $we
};
function $we(e, t, n) {
  const r = this;
  let i = 0, o, s;
  return a;
  function a(h) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), c;
  }
  function c(h) {
    return h === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(h), e.exit("characterReferenceMarkerNumeric"), u) : (e.enter("characterReferenceValue"), o = 31, s = bi, f(h));
  }
  function u(h) {
    return h === 88 || h === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(h), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), o = 6, s = Cwe, f) : (e.enter("characterReferenceValue"), o = 7, s = aT, f(h));
  }
  function f(h) {
    if (h === 59 && i) {
      const m = e.exit("characterReferenceValue");
      return s === bi && !cN(r.sliceSerialize(m)) ? n(h) : (e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return s(h) && i++ < o ? (e.consume(h), f) : n(h);
  }
}
const zz = {
  partial: !0,
  tokenize: Fwe
}, Lz = {
  concrete: !0,
  name: "codeFenced",
  tokenize: Uwe
};
function Uwe(e, t, n) {
  const r = this, i = {
    partial: !0,
    tokenize: D
  };
  let o = 0, s = 0, a;
  return c;
  function c(j) {
    return u(j);
  }
  function u(j) {
    const O = r.events[r.events.length - 1];
    return o = O && O[1].type === "linePrefix" ? O[2].sliceSerialize(O[1], !0).length : 0, a = j, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), f(j);
  }
  function f(j) {
    return j === a ? (s++, e.consume(j), f) : s < 3 ? n(j) : (e.exit("codeFencedFenceSequence"), Zt(j) ? rn(e, h, "whitespace")(j) : h(j));
  }
  function h(j) {
    return j === null || vt(j) ? (e.exit("codeFencedFence"), r.interrupt ? t(j) : e.check(zz, x, N)(j)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), m(j));
  }
  function m(j) {
    return j === null || vt(j) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), h(j)) : Zt(j) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), rn(e, g, "whitespace")(j)) : j === 96 && j === a ? n(j) : (e.consume(j), m);
  }
  function g(j) {
    return j === null || vt(j) ? h(j) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), b(j));
  }
  function b(j) {
    return j === null || vt(j) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), h(j)) : j === 96 && j === a ? n(j) : (e.consume(j), b);
  }
  function x(j) {
    return e.attempt(i, N, w)(j);
  }
  function w(j) {
    return e.enter("lineEnding"), e.consume(j), e.exit("lineEnding"), S;
  }
  function S(j) {
    return o > 0 && Zt(j) ? rn(e, _, "linePrefix", o + 1)(j) : _(j);
  }
  function _(j) {
    return j === null || vt(j) ? e.check(zz, x, N)(j) : (e.enter("codeFlowValue"), M(j));
  }
  function M(j) {
    return j === null || vt(j) ? (e.exit("codeFlowValue"), _(j)) : (e.consume(j), M);
  }
  function N(j) {
    return e.exit("codeFenced"), t(j);
  }
  function D(j, O, L) {
    let U = 0;
    return B;
    function B(ne) {
      return j.enter("lineEnding"), j.consume(ne), j.exit("lineEnding"), G;
    }
    function G(ne) {
      return j.enter("codeFencedFence"), Zt(ne) ? rn(j, Y, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(ne) : Y(ne);
    }
    function Y(ne) {
      return ne === a ? (j.enter("codeFencedFenceSequence"), he(ne)) : L(ne);
    }
    function he(ne) {
      return ne === a ? (U++, j.consume(ne), he) : U >= s ? (j.exit("codeFencedFenceSequence"), Zt(ne) ? rn(j, ie, "whitespace")(ne) : ie(ne)) : L(ne);
    }
    function ie(ne) {
      return ne === null || vt(ne) ? (j.exit("codeFencedFence"), O(ne)) : L(ne);
    }
  }
}
function Fwe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o);
  }
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const DC = {
  name: "codeIndented",
  tokenize: Hwe
}, Vwe = {
  partial: !0,
  tokenize: Wwe
};
function Hwe(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return e.enter("codeIndented"), rn(e, o, "linePrefix", 5)(u);
  }
  function o(u) {
    const f = r.events[r.events.length - 1];
    return f && f[1].type === "linePrefix" && f[2].sliceSerialize(f[1], !0).length >= 4 ? s(u) : n(u);
  }
  function s(u) {
    return u === null ? c(u) : vt(u) ? e.attempt(Vwe, s, c)(u) : (e.enter("codeFlowValue"), a(u));
  }
  function a(u) {
    return u === null || vt(u) ? (e.exit("codeFlowValue"), s(u)) : (e.consume(u), a);
  }
  function c(u) {
    return e.exit("codeIndented"), t(u);
  }
}
function Wwe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : vt(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i) : rn(e, o, "linePrefix", 5)(s);
  }
  function o(s) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(s) : vt(s) ? i(s) : n(s);
  }
}
const qwe = {
  name: "codeText",
  previous: Kwe,
  resolve: Gwe,
  tokenize: Zwe
};
function Gwe(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function Kwe(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function Zwe(e, t, n) {
  let r = 0, i, o;
  return s;
  function s(h) {
    return e.enter("codeText"), e.enter("codeTextSequence"), a(h);
  }
  function a(h) {
    return h === 96 ? (e.consume(h), r++, a) : (e.exit("codeTextSequence"), c(h));
  }
  function c(h) {
    return h === null ? n(h) : h === 32 ? (e.enter("space"), e.consume(h), e.exit("space"), c) : h === 96 ? (o = e.enter("codeTextSequence"), i = 0, f(h)) : vt(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), c) : (e.enter("codeTextData"), u(h));
  }
  function u(h) {
    return h === null || h === 32 || h === 96 || vt(h) ? (e.exit("codeTextData"), c(h)) : (e.consume(h), u);
  }
  function f(h) {
    return h === 96 ? (e.consume(h), i++, f) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(h)) : (o.type = "codeTextData", u(h));
  }
}
class Ywe {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const o = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && um(this.left, r), o.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), um(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), um(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        um(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        um(this.left, n.reverse());
      }
  }
}
function um(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function UV(e) {
  const t = {};
  let n = -1, r, i, o, s, a, c, u;
  const f = new Ywe(e);
  for (; ++n < f.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = f.get(n), n && r[1].type === "chunkFlow" && f.get(n - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, o = 0, o < c.length && c[o][1].type === "lineEndingBlank" && (o += 2), o < c.length && c[o][1].type === "content"))
      for (; ++o < c.length && c[o][1].type !== "content"; )
        c[o][1].type === "chunkText" && (c[o][1]._isInFirstContentOfListItem = !0, o++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, Xwe(f, n)), n = t[n], u = !0);
    else if (r[1]._container) {
      for (o = n, i = void 0; o--; )
        if (s = f.get(o), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank")
          s[0] === "enter" && (i && (f.get(i)[1].type = "lineEndingBlank"), s[1].type = "lineEnding", i = o);
        else if (!(s[1].type === "linePrefix" || s[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...f.get(i)[1].start
      }, a = f.slice(i, n), a.unshift(r), f.splice(i, n - i + 1, a));
    }
  }
  return vo(e, 0, Number.POSITIVE_INFINITY, f.slice(0)), !u;
}
function Xwe(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let i = t - 1;
  const o = [];
  let s = n._tokenizer;
  s || (s = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (s._contentTypeTextTrailing = !0));
  const a = s.events, c = [], u = {};
  let f, h, m = -1, g = n, b = 0, x = 0;
  const w = [x];
  for (; g; ) {
    for (; e.get(++i)[1] !== g; )
      ;
    o.push(i), g._tokenizer || (f = r.sliceStream(g), g.next || f.push(null), h && s.defineSkip(g.start), g._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(f), g._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), h = g, g = g.next;
  }
  for (g = n; ++m < a.length; )
    // Find a void token that includes a break.
    a[m][0] === "exit" && a[m - 1][0] === "enter" && a[m][1].type === a[m - 1][1].type && a[m][1].start.line !== a[m][1].end.line && (x = m + 1, w.push(x), g._tokenizer = void 0, g.previous = void 0, g = g.next);
  for (s.events = [], g ? (g._tokenizer = void 0, g.previous = void 0) : w.pop(), m = w.length; m--; ) {
    const S = a.slice(w[m], w[m + 1]), _ = o.pop();
    c.push([_, _ + S.length - 1]), e.splice(_, 2, S);
  }
  for (c.reverse(), m = -1; ++m < c.length; )
    u[b + c[m][0]] = b + c[m][1], b += c[m][1] - c[m][0] - 1;
  return u;
}
const Jwe = {
  resolve: e1e,
  tokenize: t1e
}, Qwe = {
  partial: !0,
  tokenize: n1e
};
function e1e(e) {
  return UV(e), e;
}
function t1e(e, t) {
  let n;
  return r;
  function r(a) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(a);
  }
  function i(a) {
    return a === null ? o(a) : vt(a) ? e.check(Qwe, s, o)(a) : (e.consume(a), i);
  }
  function o(a) {
    return e.exit("chunkContent"), e.exit("content"), t(a);
  }
  function s(a) {
    return e.consume(a), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function n1e(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), rn(e, o, "linePrefix");
  }
  function o(s) {
    if (s === null || vt(s))
      return n(s);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function FV(e, t, n, r, i, o, s, a, c) {
  const u = c || Number.POSITIVE_INFINITY;
  let f = 0;
  return h;
  function h(S) {
    return S === 60 ? (e.enter(r), e.enter(i), e.enter(o), e.consume(S), e.exit(o), m) : S === null || S === 32 || S === 41 || Kb(S) ? n(S) : (e.enter(r), e.enter(s), e.enter(a), e.enter("chunkString", {
      contentType: "string"
    }), x(S));
  }
  function m(S) {
    return S === 62 ? (e.enter(o), e.consume(S), e.exit(o), e.exit(i), e.exit(r), t) : (e.enter(a), e.enter("chunkString", {
      contentType: "string"
    }), g(S));
  }
  function g(S) {
    return S === 62 ? (e.exit("chunkString"), e.exit(a), m(S)) : S === null || S === 60 || vt(S) ? n(S) : (e.consume(S), S === 92 ? b : g);
  }
  function b(S) {
    return S === 60 || S === 62 || S === 92 ? (e.consume(S), g) : g(S);
  }
  function x(S) {
    return !f && (S === null || S === 41 || An(S)) ? (e.exit("chunkString"), e.exit(a), e.exit(s), e.exit(r), t(S)) : f < u && S === 40 ? (e.consume(S), f++, x) : S === 41 ? (e.consume(S), f--, x) : S === null || S === 32 || S === 40 || Kb(S) ? n(S) : (e.consume(S), S === 92 ? w : x);
  }
  function w(S) {
    return S === 40 || S === 41 || S === 92 ? (e.consume(S), x) : x(S);
  }
}
function VV(e, t, n, r, i, o) {
  const s = this;
  let a = 0, c;
  return u;
  function u(g) {
    return e.enter(r), e.enter(i), e.consume(g), e.exit(i), e.enter(o), f;
  }
  function f(g) {
    return a > 999 || g === null || g === 91 || g === 93 && !c || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    g === 94 && !a && "_hiddenFootnoteSupport" in s.parser.constructs ? n(g) : g === 93 ? (e.exit(o), e.enter(i), e.consume(g), e.exit(i), e.exit(r), t) : vt(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), f) : (e.enter("chunkString", {
      contentType: "string"
    }), h(g));
  }
  function h(g) {
    return g === null || g === 91 || g === 93 || vt(g) || a++ > 999 ? (e.exit("chunkString"), f(g)) : (e.consume(g), c || (c = !Zt(g)), g === 92 ? m : h);
  }
  function m(g) {
    return g === 91 || g === 92 || g === 93 ? (e.consume(g), a++, h) : h(g);
  }
}
function HV(e, t, n, r, i, o) {
  let s;
  return a;
  function a(m) {
    return m === 34 || m === 39 || m === 40 ? (e.enter(r), e.enter(i), e.consume(m), e.exit(i), s = m === 40 ? 41 : m, c) : n(m);
  }
  function c(m) {
    return m === s ? (e.enter(i), e.consume(m), e.exit(i), e.exit(r), t) : (e.enter(o), u(m));
  }
  function u(m) {
    return m === s ? (e.exit(o), c(s)) : m === null ? n(m) : vt(m) ? (e.enter("lineEnding"), e.consume(m), e.exit("lineEnding"), rn(e, u, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), f(m));
  }
  function f(m) {
    return m === s || m === null || vt(m) ? (e.exit("chunkString"), u(m)) : (e.consume(m), m === 92 ? h : f);
  }
  function h(m) {
    return m === s || m === 92 ? (e.consume(m), f) : f(m);
  }
}
function Hm(e, t) {
  let n;
  return r;
  function r(i) {
    return vt(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : Zt(i) ? rn(e, r, n ? "linePrefix" : "lineSuffix")(i) : t(i);
  }
}
const r1e = {
  name: "definition",
  tokenize: o1e
}, i1e = {
  partial: !0,
  tokenize: s1e
};
function o1e(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(g) {
    return e.enter("definition"), s(g);
  }
  function s(g) {
    return VV.call(
      r,
      e,
      a,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(g);
  }
  function a(g) {
    return i = ms(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), g === 58 ? (e.enter("definitionMarker"), e.consume(g), e.exit("definitionMarker"), c) : n(g);
  }
  function c(g) {
    return An(g) ? Hm(e, u)(g) : u(g);
  }
  function u(g) {
    return FV(
      e,
      f,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(g);
  }
  function f(g) {
    return e.attempt(i1e, h, h)(g);
  }
  function h(g) {
    return Zt(g) ? rn(e, m, "whitespace")(g) : m(g);
  }
  function m(g) {
    return g === null || vt(g) ? (e.exit("definition"), r.parser.defined.push(i), t(g)) : n(g);
  }
}
function s1e(e, t, n) {
  return r;
  function r(a) {
    return An(a) ? Hm(e, i)(a) : n(a);
  }
  function i(a) {
    return HV(e, o, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(a);
  }
  function o(a) {
    return Zt(a) ? rn(e, s, "whitespace")(a) : s(a);
  }
  function s(a) {
    return a === null || vt(a) ? t(a) : n(a);
  }
}
const a1e = {
  name: "hardBreakEscape",
  tokenize: l1e
};
function l1e(e, t, n) {
  return r;
  function r(o) {
    return e.enter("hardBreakEscape"), e.consume(o), i;
  }
  function i(o) {
    return vt(o) ? (e.exit("hardBreakEscape"), t(o)) : n(o);
  }
}
const c1e = {
  name: "headingAtx",
  resolve: u1e,
  tokenize: d1e
};
function u1e(e, t) {
  let n = e.length - 2, r = 3, i, o;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, o = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, vo(e, r, n - r + 1, [["enter", i, t], ["enter", o, t], ["exit", o, t], ["exit", i, t]])), e;
}
function d1e(e, t, n) {
  let r = 0;
  return i;
  function i(f) {
    return e.enter("atxHeading"), o(f);
  }
  function o(f) {
    return e.enter("atxHeadingSequence"), s(f);
  }
  function s(f) {
    return f === 35 && r++ < 6 ? (e.consume(f), s) : f === null || An(f) ? (e.exit("atxHeadingSequence"), a(f)) : n(f);
  }
  function a(f) {
    return f === 35 ? (e.enter("atxHeadingSequence"), c(f)) : f === null || vt(f) ? (e.exit("atxHeading"), t(f)) : Zt(f) ? rn(e, a, "whitespace")(f) : (e.enter("atxHeadingText"), u(f));
  }
  function c(f) {
    return f === 35 ? (e.consume(f), c) : (e.exit("atxHeadingSequence"), a(f));
  }
  function u(f) {
    return f === null || f === 35 || An(f) ? (e.exit("atxHeadingText"), a(f)) : (e.consume(f), u);
  }
}
const f1e = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Bz = ["pre", "script", "style", "textarea"], h1e = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: g1e,
  tokenize: y1e
}, p1e = {
  partial: !0,
  tokenize: b1e
}, m1e = {
  partial: !0,
  tokenize: v1e
};
function g1e(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function y1e(e, t, n) {
  const r = this;
  let i, o, s, a, c;
  return u;
  function u(F) {
    return f(F);
  }
  function f(F) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(F), h;
  }
  function h(F) {
    return F === 33 ? (e.consume(F), m) : F === 47 ? (e.consume(F), o = !0, x) : F === 63 ? (e.consume(F), i = 3, r.interrupt ? t : W) : Ri(F) ? (e.consume(F), s = String.fromCharCode(F), w) : n(F);
  }
  function m(F) {
    return F === 45 ? (e.consume(F), i = 2, g) : F === 91 ? (e.consume(F), i = 5, a = 0, b) : Ri(F) ? (e.consume(F), i = 4, r.interrupt ? t : W) : n(F);
  }
  function g(F) {
    return F === 45 ? (e.consume(F), r.interrupt ? t : W) : n(F);
  }
  function b(F) {
    const ee = "CDATA[";
    return F === ee.charCodeAt(a++) ? (e.consume(F), a === ee.length ? r.interrupt ? t : Y : b) : n(F);
  }
  function x(F) {
    return Ri(F) ? (e.consume(F), s = String.fromCharCode(F), w) : n(F);
  }
  function w(F) {
    if (F === null || F === 47 || F === 62 || An(F)) {
      const ee = F === 47, ge = s.toLowerCase();
      return !ee && !o && Bz.includes(ge) ? (i = 1, r.interrupt ? t(F) : Y(F)) : f1e.includes(s.toLowerCase()) ? (i = 6, ee ? (e.consume(F), S) : r.interrupt ? t(F) : Y(F)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(F) : o ? _(F) : M(F));
    }
    return F === 45 || bi(F) ? (e.consume(F), s += String.fromCharCode(F), w) : n(F);
  }
  function S(F) {
    return F === 62 ? (e.consume(F), r.interrupt ? t : Y) : n(F);
  }
  function _(F) {
    return Zt(F) ? (e.consume(F), _) : B(F);
  }
  function M(F) {
    return F === 47 ? (e.consume(F), B) : F === 58 || F === 95 || Ri(F) ? (e.consume(F), N) : Zt(F) ? (e.consume(F), M) : B(F);
  }
  function N(F) {
    return F === 45 || F === 46 || F === 58 || F === 95 || bi(F) ? (e.consume(F), N) : D(F);
  }
  function D(F) {
    return F === 61 ? (e.consume(F), j) : Zt(F) ? (e.consume(F), D) : M(F);
  }
  function j(F) {
    return F === null || F === 60 || F === 61 || F === 62 || F === 96 ? n(F) : F === 34 || F === 39 ? (e.consume(F), c = F, O) : Zt(F) ? (e.consume(F), j) : L(F);
  }
  function O(F) {
    return F === c ? (e.consume(F), c = null, U) : F === null || vt(F) ? n(F) : (e.consume(F), O);
  }
  function L(F) {
    return F === null || F === 34 || F === 39 || F === 47 || F === 60 || F === 61 || F === 62 || F === 96 || An(F) ? D(F) : (e.consume(F), L);
  }
  function U(F) {
    return F === 47 || F === 62 || Zt(F) ? M(F) : n(F);
  }
  function B(F) {
    return F === 62 ? (e.consume(F), G) : n(F);
  }
  function G(F) {
    return F === null || vt(F) ? Y(F) : Zt(F) ? (e.consume(F), G) : n(F);
  }
  function Y(F) {
    return F === 45 && i === 2 ? (e.consume(F), H) : F === 60 && i === 1 ? (e.consume(F), Q) : F === 62 && i === 4 ? (e.consume(F), Z) : F === 63 && i === 3 ? (e.consume(F), W) : F === 93 && i === 5 ? (e.consume(F), Se) : vt(F) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(p1e, pe, he)(F)) : F === null || vt(F) ? (e.exit("htmlFlowData"), he(F)) : (e.consume(F), Y);
  }
  function he(F) {
    return e.check(m1e, ie, pe)(F);
  }
  function ie(F) {
    return e.enter("lineEnding"), e.consume(F), e.exit("lineEnding"), ne;
  }
  function ne(F) {
    return F === null || vt(F) ? he(F) : (e.enter("htmlFlowData"), Y(F));
  }
  function H(F) {
    return F === 45 ? (e.consume(F), W) : Y(F);
  }
  function Q(F) {
    return F === 47 ? (e.consume(F), s = "", X) : Y(F);
  }
  function X(F) {
    if (F === 62) {
      const ee = s.toLowerCase();
      return Bz.includes(ee) ? (e.consume(F), Z) : Y(F);
    }
    return Ri(F) && s.length < 8 ? (e.consume(F), s += String.fromCharCode(F), X) : Y(F);
  }
  function Se(F) {
    return F === 93 ? (e.consume(F), W) : Y(F);
  }
  function W(F) {
    return F === 62 ? (e.consume(F), Z) : F === 45 && i === 2 ? (e.consume(F), W) : Y(F);
  }
  function Z(F) {
    return F === null || vt(F) ? (e.exit("htmlFlowData"), pe(F)) : (e.consume(F), Z);
  }
  function pe(F) {
    return e.exit("htmlFlow"), t(F);
  }
}
function v1e(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return vt(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o) : n(s);
  }
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function b1e(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(my, t, n);
  }
}
const x1e = {
  name: "htmlText",
  tokenize: w1e
};
function w1e(e, t, n) {
  const r = this;
  let i, o, s;
  return a;
  function a(W) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(W), c;
  }
  function c(W) {
    return W === 33 ? (e.consume(W), u) : W === 47 ? (e.consume(W), D) : W === 63 ? (e.consume(W), M) : Ri(W) ? (e.consume(W), L) : n(W);
  }
  function u(W) {
    return W === 45 ? (e.consume(W), f) : W === 91 ? (e.consume(W), o = 0, b) : Ri(W) ? (e.consume(W), _) : n(W);
  }
  function f(W) {
    return W === 45 ? (e.consume(W), g) : n(W);
  }
  function h(W) {
    return W === null ? n(W) : W === 45 ? (e.consume(W), m) : vt(W) ? (s = h, Q(W)) : (e.consume(W), h);
  }
  function m(W) {
    return W === 45 ? (e.consume(W), g) : h(W);
  }
  function g(W) {
    return W === 62 ? H(W) : W === 45 ? m(W) : h(W);
  }
  function b(W) {
    const Z = "CDATA[";
    return W === Z.charCodeAt(o++) ? (e.consume(W), o === Z.length ? x : b) : n(W);
  }
  function x(W) {
    return W === null ? n(W) : W === 93 ? (e.consume(W), w) : vt(W) ? (s = x, Q(W)) : (e.consume(W), x);
  }
  function w(W) {
    return W === 93 ? (e.consume(W), S) : x(W);
  }
  function S(W) {
    return W === 62 ? H(W) : W === 93 ? (e.consume(W), S) : x(W);
  }
  function _(W) {
    return W === null || W === 62 ? H(W) : vt(W) ? (s = _, Q(W)) : (e.consume(W), _);
  }
  function M(W) {
    return W === null ? n(W) : W === 63 ? (e.consume(W), N) : vt(W) ? (s = M, Q(W)) : (e.consume(W), M);
  }
  function N(W) {
    return W === 62 ? H(W) : M(W);
  }
  function D(W) {
    return Ri(W) ? (e.consume(W), j) : n(W);
  }
  function j(W) {
    return W === 45 || bi(W) ? (e.consume(W), j) : O(W);
  }
  function O(W) {
    return vt(W) ? (s = O, Q(W)) : Zt(W) ? (e.consume(W), O) : H(W);
  }
  function L(W) {
    return W === 45 || bi(W) ? (e.consume(W), L) : W === 47 || W === 62 || An(W) ? U(W) : n(W);
  }
  function U(W) {
    return W === 47 ? (e.consume(W), H) : W === 58 || W === 95 || Ri(W) ? (e.consume(W), B) : vt(W) ? (s = U, Q(W)) : Zt(W) ? (e.consume(W), U) : H(W);
  }
  function B(W) {
    return W === 45 || W === 46 || W === 58 || W === 95 || bi(W) ? (e.consume(W), B) : G(W);
  }
  function G(W) {
    return W === 61 ? (e.consume(W), Y) : vt(W) ? (s = G, Q(W)) : Zt(W) ? (e.consume(W), G) : U(W);
  }
  function Y(W) {
    return W === null || W === 60 || W === 61 || W === 62 || W === 96 ? n(W) : W === 34 || W === 39 ? (e.consume(W), i = W, he) : vt(W) ? (s = Y, Q(W)) : Zt(W) ? (e.consume(W), Y) : (e.consume(W), ie);
  }
  function he(W) {
    return W === i ? (e.consume(W), i = void 0, ne) : W === null ? n(W) : vt(W) ? (s = he, Q(W)) : (e.consume(W), he);
  }
  function ie(W) {
    return W === null || W === 34 || W === 39 || W === 60 || W === 61 || W === 96 ? n(W) : W === 47 || W === 62 || An(W) ? U(W) : (e.consume(W), ie);
  }
  function ne(W) {
    return W === 47 || W === 62 || An(W) ? U(W) : n(W);
  }
  function H(W) {
    return W === 62 ? (e.consume(W), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(W);
  }
  function Q(W) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(W), e.exit("lineEnding"), X;
  }
  function X(W) {
    return Zt(W) ? rn(e, Se, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(W) : Se(W);
  }
  function Se(W) {
    return e.enter("htmlTextData"), s(W);
  }
}
const uN = {
  name: "labelEnd",
  resolveAll: E1e,
  resolveTo: _1e,
  tokenize: T1e
}, S1e = {
  tokenize: A1e
}, k1e = {
  tokenize: M1e
}, C1e = {
  tokenize: N1e
};
function E1e(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += i;
    }
  }
  return e.length !== n.length && vo(e, 0, e.length, n), e;
}
function _1e(e, t) {
  let n = e.length, r = 0, i, o, s, a;
  for (; n--; )
    if (i = e[n][1], o) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (s) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (o = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (s = n);
  const c = {
    type: e[o][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[o][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, u = {
    type: "label",
    start: {
      ...e[o][1].start
    },
    end: {
      ...e[s][1].end
    }
  }, f = {
    type: "labelText",
    start: {
      ...e[o + r + 2][1].end
    },
    end: {
      ...e[s - 2][1].start
    }
  };
  return a = [["enter", c, t], ["enter", u, t]], a = $o(a, e.slice(o + 1, o + r + 3)), a = $o(a, [["enter", f, t]]), a = $o(a, Kw(t.parser.constructs.insideSpan.null, e.slice(o + r + 4, s - 3), t)), a = $o(a, [["exit", f, t], e[s - 2], e[s - 1], ["exit", u, t]]), a = $o(a, e.slice(s + 1)), a = $o(a, [["exit", c, t]]), vo(e, o, e.length, a), e;
}
function T1e(e, t, n) {
  const r = this;
  let i = r.events.length, o, s;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      o = r.events[i][1];
      break;
    }
  return a;
  function a(m) {
    return o ? o._inactive ? h(m) : (s = r.parser.defined.includes(ms(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(m), e.exit("labelMarker"), e.exit("labelEnd"), c) : n(m);
  }
  function c(m) {
    return m === 40 ? e.attempt(S1e, f, s ? f : h)(m) : m === 91 ? e.attempt(k1e, f, s ? u : h)(m) : s ? f(m) : h(m);
  }
  function u(m) {
    return e.attempt(C1e, f, h)(m);
  }
  function f(m) {
    return t(m);
  }
  function h(m) {
    return o._balanced = !0, n(m);
  }
}
function A1e(e, t, n) {
  return r;
  function r(h) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), i;
  }
  function i(h) {
    return An(h) ? Hm(e, o)(h) : o(h);
  }
  function o(h) {
    return h === 41 ? f(h) : FV(e, s, a, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function s(h) {
    return An(h) ? Hm(e, c)(h) : f(h);
  }
  function a(h) {
    return n(h);
  }
  function c(h) {
    return h === 34 || h === 39 || h === 40 ? HV(e, u, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : f(h);
  }
  function u(h) {
    return An(h) ? Hm(e, f)(h) : f(h);
  }
  function f(h) {
    return h === 41 ? (e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), e.exit("resource"), t) : n(h);
  }
}
function M1e(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return VV.call(r, e, o, s, "reference", "referenceMarker", "referenceString")(a);
  }
  function o(a) {
    return r.parser.defined.includes(ms(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(a) : n(a);
  }
  function s(a) {
    return n(a);
  }
}
function N1e(e, t, n) {
  return r;
  function r(o) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), i;
  }
  function i(o) {
    return o === 93 ? (e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), e.exit("reference"), t) : n(o);
  }
}
const R1e = {
  name: "labelStartImage",
  resolveAll: uN.resolveAll,
  tokenize: O1e
};
function O1e(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(a), e.exit("labelImageMarker"), o;
  }
  function o(a) {
    return a === 91 ? (e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelImage"), s) : n(a);
  }
  function s(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a);
  }
}
const P1e = {
  name: "labelStartLink",
  resolveAll: uN.resolveAll,
  tokenize: D1e
};
function D1e(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), o;
  }
  function o(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const IC = {
  name: "lineEnding",
  tokenize: I1e
};
function I1e(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), rn(e, t, "linePrefix");
  }
}
const K0 = {
  name: "thematicBreak",
  tokenize: j1e
};
function j1e(e, t, n) {
  let r = 0, i;
  return o;
  function o(u) {
    return e.enter("thematicBreak"), s(u);
  }
  function s(u) {
    return i = u, a(u);
  }
  function a(u) {
    return u === i ? (e.enter("thematicBreakSequence"), c(u)) : r >= 3 && (u === null || vt(u)) ? (e.exit("thematicBreak"), t(u)) : n(u);
  }
  function c(u) {
    return u === i ? (e.consume(u), r++, c) : (e.exit("thematicBreakSequence"), Zt(u) ? rn(e, a, "whitespace")(u) : a(u));
  }
}
const Gi = {
  continuation: {
    tokenize: $1e
  },
  exit: F1e,
  name: "list",
  tokenize: B1e
}, z1e = {
  partial: !0,
  tokenize: V1e
}, L1e = {
  partial: !0,
  tokenize: U1e
};
function B1e(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, s = 0;
  return a;
  function a(g) {
    const b = r.containerState.type || (g === 42 || g === 43 || g === 45 ? "listUnordered" : "listOrdered");
    if (b === "listUnordered" ? !r.containerState.marker || g === r.containerState.marker : aT(g)) {
      if (r.containerState.type || (r.containerState.type = b, e.enter(b, {
        _container: !0
      })), b === "listUnordered")
        return e.enter("listItemPrefix"), g === 42 || g === 45 ? e.check(K0, n, u)(g) : u(g);
      if (!r.interrupt || g === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), c(g);
    }
    return n(g);
  }
  function c(g) {
    return aT(g) && ++s < 10 ? (e.consume(g), c) : (!r.interrupt || s < 2) && (r.containerState.marker ? g === r.containerState.marker : g === 41 || g === 46) ? (e.exit("listItemValue"), u(g)) : n(g);
  }
  function u(g) {
    return e.enter("listItemMarker"), e.consume(g), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || g, e.check(
      my,
      // Cant be empty when interrupting.
      r.interrupt ? n : f,
      e.attempt(z1e, m, h)
    );
  }
  function f(g) {
    return r.containerState.initialBlankLine = !0, o++, m(g);
  }
  function h(g) {
    return Zt(g) ? (e.enter("listItemPrefixWhitespace"), e.consume(g), e.exit("listItemPrefixWhitespace"), m) : n(g);
  }
  function m(g) {
    return r.containerState.size = o + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(g);
  }
}
function $1e(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(my, i, o);
  function i(a) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, rn(e, t, "listItemIndent", r.containerState.size + 1)(a);
  }
  function o(a) {
    return r.containerState.furtherBlankLines || !Zt(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(L1e, t, s)(a));
  }
  function s(a) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, rn(e, e.attempt(Gi, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a);
  }
}
function U1e(e, t, n) {
  const r = this;
  return rn(e, i, "listItemIndent", r.containerState.size + 1);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(o) : n(o);
  }
}
function F1e(e) {
  e.exit(this.containerState.type);
}
function V1e(e, t, n) {
  const r = this;
  return rn(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return !Zt(o) && s && s[1].type === "listItemPrefixWhitespace" ? t(o) : n(o);
  }
}
const $z = {
  name: "setextUnderline",
  resolveTo: H1e,
  tokenize: W1e
};
function H1e(e, t) {
  let n = e.length, r, i, o;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !o && e[n][1].type === "definition" && (o = n);
  const s = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[i][1].type = "setextHeadingText", o ? (e.splice(i, 0, ["enter", s, t]), e.splice(o + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[o][1].end
  }) : e[r][1] = s, e.push(["exit", s, t]), e;
}
function W1e(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(u) {
    let f = r.events.length, h;
    for (; f--; )
      if (r.events[f][1].type !== "lineEnding" && r.events[f][1].type !== "linePrefix" && r.events[f][1].type !== "content") {
        h = r.events[f][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (e.enter("setextHeadingLine"), i = u, s(u)) : n(u);
  }
  function s(u) {
    return e.enter("setextHeadingLineSequence"), a(u);
  }
  function a(u) {
    return u === i ? (e.consume(u), a) : (e.exit("setextHeadingLineSequence"), Zt(u) ? rn(e, c, "lineSuffix")(u) : c(u));
  }
  function c(u) {
    return u === null || vt(u) ? (e.exit("setextHeadingLine"), t(u)) : n(u);
  }
}
const q1e = {
  tokenize: G1e
};
function G1e(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    my,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, i, rn(e, e.attempt(this.parser.constructs.flow, i, e.attempt(Jwe, i)), "linePrefix"))
  );
  return n;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(o), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const K1e = {
  resolveAll: qV()
}, Z1e = WV("string"), Y1e = WV("text");
function WV(e) {
  return {
    resolveAll: qV(e === "text" ? X1e : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], o = n.attempt(i, s, a);
    return s;
    function s(f) {
      return u(f) ? o(f) : a(f);
    }
    function a(f) {
      if (f === null) {
        n.consume(f);
        return;
      }
      return n.enter("data"), n.consume(f), c;
    }
    function c(f) {
      return u(f) ? (n.exit("data"), o(f)) : (n.consume(f), c);
    }
    function u(f) {
      if (f === null)
        return !0;
      const h = i[f];
      let m = -1;
      if (h)
        for (; ++m < h.length; ) {
          const g = h[m];
          if (!g.previous || g.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function qV(e) {
  return t;
  function t(n, r) {
    let i = -1, o;
    for (; ++i <= n.length; )
      o === void 0 ? n[i] && n[i][1].type === "data" && (o = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== o + 2 && (n[o][1].end = n[i - 1][1].end, n.splice(o + 2, i - o - 2), i = o + 2), o = void 0);
    return e ? e(n, r) : n;
  }
}
function X1e(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let o = i.length, s = -1, a = 0, c;
      for (; o--; ) {
        const u = i[o];
        if (typeof u == "string") {
          for (s = u.length; u.charCodeAt(s - 1) === 32; )
            a++, s--;
          if (s) break;
          s = -1;
        } else if (u === -2)
          c = !0, a++;
        else if (u !== -1) {
          o++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (a = 0), a) {
        const u = {
          type: n === e.length || c || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: o ? s : r.start._bufferIndex + s,
            _index: r.start._index + o,
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...u.start
        }, r.start.offset === r.end.offset ? Object.assign(r, u) : (e.splice(n, 0, ["enter", u, t], ["exit", u, t]), n += 2);
      }
      n++;
    }
  return e;
}
const J1e = {
  42: Gi,
  43: Gi,
  45: Gi,
  48: Gi,
  49: Gi,
  50: Gi,
  51: Gi,
  52: Gi,
  53: Gi,
  54: Gi,
  55: Gi,
  56: Gi,
  57: Gi,
  62: LV
}, Q1e = {
  91: r1e
}, eSe = {
  [-2]: DC,
  [-1]: DC,
  32: DC
}, tSe = {
  35: c1e,
  42: K0,
  45: [$z, K0],
  60: h1e,
  61: $z,
  95: K0,
  96: Lz,
  126: Lz
}, nSe = {
  38: $V,
  92: BV
}, rSe = {
  [-5]: IC,
  [-4]: IC,
  [-3]: IC,
  33: R1e,
  38: $V,
  42: lT,
  60: [Pwe, x1e],
  91: P1e,
  92: [a1e, BV],
  93: uN,
  95: lT,
  96: qwe
}, iSe = {
  null: [lT, K1e]
}, oSe = {
  null: [42, 95]
}, sSe = {
  null: []
}, aSe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: oSe,
  contentInitial: Q1e,
  disable: sSe,
  document: J1e,
  flow: tSe,
  flowInitial: eSe,
  insideSpan: iSe,
  string: nSe,
  text: rSe
}, Symbol.toStringTag, { value: "Module" }));
function lSe(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const i = {}, o = [];
  let s = [], a = [];
  const c = {
    attempt: O(D),
    check: O(j),
    consume: _,
    enter: M,
    exit: N,
    interrupt: O(j, {
      interrupt: !0
    })
  }, u = {
    code: null,
    containerState: {},
    defineSkip: x,
    events: [],
    now: b,
    parser: e,
    previous: null,
    sliceSerialize: m,
    sliceStream: g,
    write: h
  };
  let f = t.tokenize.call(u, c);
  return t.resolveAll && o.push(t), u;
  function h(G) {
    return s = $o(s, G), w(), s[s.length - 1] !== null ? [] : (L(t, 0), u.events = Kw(o, u.events, u), u.events);
  }
  function m(G, Y) {
    return uSe(g(G), Y);
  }
  function g(G) {
    return cSe(s, G);
  }
  function b() {
    const {
      _bufferIndex: G,
      _index: Y,
      line: he,
      column: ie,
      offset: ne
    } = r;
    return {
      _bufferIndex: G,
      _index: Y,
      line: he,
      column: ie,
      offset: ne
    };
  }
  function x(G) {
    i[G.line] = G.column, B();
  }
  function w() {
    let G;
    for (; r._index < s.length; ) {
      const Y = s[r._index];
      if (typeof Y == "string")
        for (G = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === G && r._bufferIndex < Y.length; )
          S(Y.charCodeAt(r._bufferIndex));
      else
        S(Y);
    }
  }
  function S(G) {
    f = f(G);
  }
  function _(G) {
    vt(G) ? (r.line++, r.column = 1, r.offset += G === -3 ? 2 : 1, B()) : G !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    s[r._index].length && (r._bufferIndex = -1, r._index++)), u.previous = G;
  }
  function M(G, Y) {
    const he = Y || {};
    return he.type = G, he.start = b(), u.events.push(["enter", he, u]), a.push(he), he;
  }
  function N(G) {
    const Y = a.pop();
    return Y.end = b(), u.events.push(["exit", Y, u]), Y;
  }
  function D(G, Y) {
    L(G, Y.from);
  }
  function j(G, Y) {
    Y.restore();
  }
  function O(G, Y) {
    return he;
    function he(ie, ne, H) {
      let Q, X, Se, W;
      return Array.isArray(ie) ? (
        /* c8 ignore next 1 */
        pe(ie)
      ) : "tokenize" in ie ? (
        // Looks like a construct.
        pe([
          /** @type {Construct} */
          ie
        ])
      ) : Z(ie);
      function Z(re) {
        return J;
        function J(xe) {
          const be = xe !== null && re[xe], Ae = xe !== null && re.null, nt = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(be) ? be : be ? [be] : [],
            ...Array.isArray(Ae) ? Ae : Ae ? [Ae] : []
          ];
          return pe(nt)(xe);
        }
      }
      function pe(re) {
        return Q = re, X = 0, re.length === 0 ? H : F(re[X]);
      }
      function F(re) {
        return J;
        function J(xe) {
          return W = U(), Se = re, re.partial || (u.currentConstruct = re), re.name && u.parser.constructs.disable.null.includes(re.name) ? ge() : re.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            Y ? Object.assign(Object.create(u), Y) : u,
            c,
            ee,
            ge
          )(xe);
        }
      }
      function ee(re) {
        return G(Se, W), ne;
      }
      function ge(re) {
        return W.restore(), ++X < Q.length ? F(Q[X]) : H;
      }
    }
  }
  function L(G, Y) {
    G.resolveAll && !o.includes(G) && o.push(G), G.resolve && vo(u.events, Y, u.events.length - Y, G.resolve(u.events.slice(Y), u)), G.resolveTo && (u.events = G.resolveTo(u.events, u));
  }
  function U() {
    const G = b(), Y = u.previous, he = u.currentConstruct, ie = u.events.length, ne = Array.from(a);
    return {
      from: ie,
      restore: H
    };
    function H() {
      r = G, u.previous = Y, u.currentConstruct = he, u.events.length = ie, a = ne, B();
    }
  }
  function B() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function cSe(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, o = t.end._bufferIndex;
  let s;
  if (n === i)
    s = [e[n].slice(r, o)];
  else {
    if (s = e.slice(n, i), r > -1) {
      const a = s[0];
      typeof a == "string" ? s[0] = a.slice(r) : s.shift();
    }
    o > 0 && s.push(e[i].slice(0, o));
  }
  return s;
}
function uSe(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const o = e[n];
    let s;
    if (typeof o == "string")
      s = o;
    else switch (o) {
      case -5: {
        s = "\r";
        break;
      }
      case -4: {
        s = `
`;
        break;
      }
      case -3: {
        s = `\r
`;
        break;
      }
      case -2: {
        s = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && i) continue;
        s = " ";
        break;
      }
      default:
        s = String.fromCharCode(o);
    }
    i = o === -2, r.push(s);
  }
  return r.join("");
}
function dSe(e) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      jV([aSe, ...(e || {}).extensions || []])
    ),
    content: i(_we),
    defined: [],
    document: i(Awe),
    flow: i(q1e),
    lazy: {},
    string: i(Z1e),
    text: i(Y1e)
  };
  return r;
  function i(o) {
    return s;
    function s(a) {
      return lSe(r, o, a);
    }
  }
}
function fSe(e) {
  for (; !UV(e); )
    ;
  return e;
}
const Uz = /[\0\t\n\r]/g;
function hSe() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(o, s, a) {
    const c = [];
    let u, f, h, m, g;
    for (o = t + (typeof o == "string" ? o.toString() : new TextDecoder(s || void 0).decode(o)), h = 0, t = "", n && (o.charCodeAt(0) === 65279 && h++, n = void 0); h < o.length; ) {
      if (Uz.lastIndex = h, u = Uz.exec(o), m = u && u.index !== void 0 ? u.index : o.length, g = o.charCodeAt(m), !u) {
        t = o.slice(h);
        break;
      }
      if (g === 10 && h === m && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), h < m && (c.push(o.slice(h, m)), e += m - h), g) {
          case 0: {
            c.push(65533), e++;
            break;
          }
          case 9: {
            for (f = Math.ceil(e / 4) * 4, c.push(-2); e++ < f; ) c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      h = m + 1;
    }
    return a && (r && c.push(-5), t && c.push(t), c.push(null)), c;
  }
}
const pSe = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function mSe(e) {
  return e.replace(pSe, gSe);
}
function gSe(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), o = i === 120 || i === 88;
    return zV(n.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return cN(n) || e;
}
const GV = {}.hasOwnProperty;
function ySe(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), vSe(n)(fSe(dSe(n).document().write(hSe()(e, t, !0))));
}
function vSe(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: o(Yt),
      autolinkProtocol: U,
      autolinkEmail: U,
      atxHeading: o(vn),
      blockQuote: o(Ae),
      characterEscape: U,
      characterReference: U,
      codeFenced: o(nt),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: o(nt, s),
      codeText: o(Ge, s),
      codeTextData: U,
      data: U,
      codeFlowValue: U,
      definition: o(rt),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: o(Tt),
      hardBreakEscape: o(kt),
      hardBreakTrailing: o(kt),
      htmlFlow: o(Wt, s),
      htmlFlowData: U,
      htmlText: o(Wt, s),
      htmlTextData: U,
      image: o(wt),
      label: s,
      link: o(Yt),
      listItem: o(Rt),
      listItemValue: m,
      listOrdered: o(Mn, h),
      listUnordered: o(Mn),
      paragraph: o(ln),
      reference: F,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: o(vn),
      strong: o(In),
      thematicBreak: o(gt)
    },
    exit: {
      atxHeading: c(),
      atxHeadingSequence: D,
      autolink: c(),
      autolinkEmail: be,
      autolinkProtocol: xe,
      blockQuote: c(),
      characterEscapeValue: B,
      characterReferenceMarkerHexadecimal: ge,
      characterReferenceMarkerNumeric: ge,
      characterReferenceValue: re,
      characterReference: J,
      codeFenced: c(w),
      codeFencedFence: x,
      codeFencedFenceInfo: g,
      codeFencedFenceMeta: b,
      codeFlowValue: B,
      codeIndented: c(S),
      codeText: c(ne),
      codeTextData: B,
      data: B,
      definition: c(),
      definitionDestinationString: N,
      definitionLabelString: _,
      definitionTitleString: M,
      emphasis: c(),
      hardBreakEscape: c(Y),
      hardBreakTrailing: c(Y),
      htmlFlow: c(he),
      htmlFlowData: B,
      htmlText: c(ie),
      htmlTextData: B,
      image: c(Q),
      label: Se,
      labelText: X,
      lineEnding: G,
      link: c(H),
      listItem: c(),
      listOrdered: c(),
      listUnordered: c(),
      paragraph: c(),
      referenceString: ee,
      resourceDestinationString: W,
      resourceTitleString: Z,
      resource: pe,
      setextHeading: c(L),
      setextHeadingLineSequence: O,
      setextHeadingText: j,
      strong: c(),
      thematicBreak: c()
    }
  };
  KV(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(ke) {
    let De = {
      type: "root",
      children: []
    };
    const He = {
      stack: [De],
      tokenStack: [],
      config: t,
      enter: a,
      exit: u,
      buffer: s,
      resume: f,
      data: n
    }, tt = [];
    let xt = -1;
    for (; ++xt < ke.length; )
      if (ke[xt][1].type === "listOrdered" || ke[xt][1].type === "listUnordered")
        if (ke[xt][0] === "enter")
          tt.push(xt);
        else {
          const Et = tt.pop();
          xt = i(ke, Et, xt);
        }
    for (xt = -1; ++xt < ke.length; ) {
      const Et = t[ke[xt][0]];
      GV.call(Et, ke[xt][1].type) && Et[ke[xt][1].type].call(Object.assign({
        sliceSerialize: ke[xt][2].sliceSerialize
      }, He), ke[xt][1]);
    }
    if (He.tokenStack.length > 0) {
      const Et = He.tokenStack[He.tokenStack.length - 1];
      (Et[1] || Fz).call(He, void 0, Et[0]);
    }
    for (De.position = {
      start: Kl(ke.length > 0 ? ke[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Kl(ke.length > 0 ? ke[ke.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, xt = -1; ++xt < t.transforms.length; )
      De = t.transforms[xt](De) || De;
    return De;
  }
  function i(ke, De, He) {
    let tt = De - 1, xt = -1, Et = !1, hn, Bt, on, jn;
    for (; ++tt <= He; ) {
      const Ve = ke[tt];
      switch (Ve[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Ve[0] === "enter" ? xt++ : xt--, jn = void 0;
          break;
        }
        case "lineEndingBlank": {
          Ve[0] === "enter" && (hn && !jn && !xt && !on && (on = tt), jn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          jn = void 0;
      }
      if (!xt && Ve[0] === "enter" && Ve[1].type === "listItemPrefix" || xt === -1 && Ve[0] === "exit" && (Ve[1].type === "listUnordered" || Ve[1].type === "listOrdered")) {
        if (hn) {
          let Bi = tt;
          for (Bt = void 0; Bi--; ) {
            const Mr = ke[Bi];
            if (Mr[1].type === "lineEnding" || Mr[1].type === "lineEndingBlank") {
              if (Mr[0] === "exit") continue;
              Bt && (ke[Bt][1].type = "lineEndingBlank", Et = !0), Mr[1].type = "lineEnding", Bt = Bi;
            } else if (!(Mr[1].type === "linePrefix" || Mr[1].type === "blockQuotePrefix" || Mr[1].type === "blockQuotePrefixWhitespace" || Mr[1].type === "blockQuoteMarker" || Mr[1].type === "listItemIndent")) break;
          }
          on && (!Bt || on < Bt) && (hn._spread = !0), hn.end = Object.assign({}, Bt ? ke[Bt][1].start : Ve[1].end), ke.splice(Bt || tt, 0, ["exit", hn, Ve[2]]), tt++, He++;
        }
        if (Ve[1].type === "listItemPrefix") {
          const Bi = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Ve[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          hn = Bi, ke.splice(tt, 0, ["enter", Bi, Ve[2]]), tt++, He++, on = void 0, jn = !0;
        }
      }
    }
    return ke[De][1]._spread = Et, He;
  }
  function o(ke, De) {
    return He;
    function He(tt) {
      a.call(this, ke(tt), tt), De && De.call(this, tt);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function a(ke, De, He) {
    this.stack[this.stack.length - 1].children.push(ke), this.stack.push(ke), this.tokenStack.push([De, He || void 0]), ke.position = {
      start: Kl(De.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function c(ke) {
    return De;
    function De(He) {
      ke && ke.call(this, He), u.call(this, He);
    }
  }
  function u(ke, De) {
    const He = this.stack.pop(), tt = this.tokenStack.pop();
    if (tt)
      tt[0].type !== ke.type && (De ? De.call(this, ke, tt[0]) : (tt[1] || Fz).call(this, ke, tt[0]));
    else throw new Error("Cannot close `" + ke.type + "` (" + Vm({
      start: ke.start,
      end: ke.end
    }) + "): its not open");
    He.position.end = Kl(ke.end);
  }
  function f() {
    return lN(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function m(ke) {
    if (this.data.expectingFirstListItemValue) {
      const De = this.stack[this.stack.length - 2];
      De.start = Number.parseInt(this.sliceSerialize(ke), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function g() {
    const ke = this.resume(), De = this.stack[this.stack.length - 1];
    De.lang = ke;
  }
  function b() {
    const ke = this.resume(), De = this.stack[this.stack.length - 1];
    De.meta = ke;
  }
  function x() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function w() {
    const ke = this.resume(), De = this.stack[this.stack.length - 1];
    De.value = ke.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function S() {
    const ke = this.resume(), De = this.stack[this.stack.length - 1];
    De.value = ke.replace(/(\r?\n|\r)$/g, "");
  }
  function _(ke) {
    const De = this.resume(), He = this.stack[this.stack.length - 1];
    He.label = De, He.identifier = ms(this.sliceSerialize(ke)).toLowerCase();
  }
  function M() {
    const ke = this.resume(), De = this.stack[this.stack.length - 1];
    De.title = ke;
  }
  function N() {
    const ke = this.resume(), De = this.stack[this.stack.length - 1];
    De.url = ke;
  }
  function D(ke) {
    const De = this.stack[this.stack.length - 1];
    if (!De.depth) {
      const He = this.sliceSerialize(ke).length;
      De.depth = He;
    }
  }
  function j() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function O(ke) {
    const De = this.stack[this.stack.length - 1];
    De.depth = this.sliceSerialize(ke).codePointAt(0) === 61 ? 1 : 2;
  }
  function L() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function U(ke) {
    const He = this.stack[this.stack.length - 1].children;
    let tt = He[He.length - 1];
    (!tt || tt.type !== "text") && (tt = Nn(), tt.position = {
      start: Kl(ke.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, He.push(tt)), this.stack.push(tt);
  }
  function B(ke) {
    const De = this.stack.pop();
    De.value += this.sliceSerialize(ke), De.position.end = Kl(ke.end);
  }
  function G(ke) {
    const De = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const He = De.children[De.children.length - 1];
      He.position.end = Kl(ke.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(De.type) && (U.call(this, ke), B.call(this, ke));
  }
  function Y() {
    this.data.atHardBreak = !0;
  }
  function he() {
    const ke = this.resume(), De = this.stack[this.stack.length - 1];
    De.value = ke;
  }
  function ie() {
    const ke = this.resume(), De = this.stack[this.stack.length - 1];
    De.value = ke;
  }
  function ne() {
    const ke = this.resume(), De = this.stack[this.stack.length - 1];
    De.value = ke;
  }
  function H() {
    const ke = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const De = this.data.referenceType || "shortcut";
      ke.type += "Reference", ke.referenceType = De, delete ke.url, delete ke.title;
    } else
      delete ke.identifier, delete ke.label;
    this.data.referenceType = void 0;
  }
  function Q() {
    const ke = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const De = this.data.referenceType || "shortcut";
      ke.type += "Reference", ke.referenceType = De, delete ke.url, delete ke.title;
    } else
      delete ke.identifier, delete ke.label;
    this.data.referenceType = void 0;
  }
  function X(ke) {
    const De = this.sliceSerialize(ke), He = this.stack[this.stack.length - 2];
    He.label = mSe(De), He.identifier = ms(De).toLowerCase();
  }
  function Se() {
    const ke = this.stack[this.stack.length - 1], De = this.resume(), He = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, He.type === "link") {
      const tt = ke.children;
      He.children = tt;
    } else
      He.alt = De;
  }
  function W() {
    const ke = this.resume(), De = this.stack[this.stack.length - 1];
    De.url = ke;
  }
  function Z() {
    const ke = this.resume(), De = this.stack[this.stack.length - 1];
    De.title = ke;
  }
  function pe() {
    this.data.inReference = void 0;
  }
  function F() {
    this.data.referenceType = "collapsed";
  }
  function ee(ke) {
    const De = this.resume(), He = this.stack[this.stack.length - 1];
    He.label = De, He.identifier = ms(this.sliceSerialize(ke)).toLowerCase(), this.data.referenceType = "full";
  }
  function ge(ke) {
    this.data.characterReferenceType = ke.type;
  }
  function re(ke) {
    const De = this.sliceSerialize(ke), He = this.data.characterReferenceType;
    let tt;
    He ? (tt = zV(De, He === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : tt = cN(De);
    const xt = this.stack[this.stack.length - 1];
    xt.value += tt;
  }
  function J(ke) {
    const De = this.stack.pop();
    De.position.end = Kl(ke.end);
  }
  function xe(ke) {
    B.call(this, ke);
    const De = this.stack[this.stack.length - 1];
    De.url = this.sliceSerialize(ke);
  }
  function be(ke) {
    B.call(this, ke);
    const De = this.stack[this.stack.length - 1];
    De.url = "mailto:" + this.sliceSerialize(ke);
  }
  function Ae() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function nt() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Ge() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function rt() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function Tt() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function vn() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function kt() {
    return {
      type: "break"
    };
  }
  function Wt() {
    return {
      type: "html",
      value: ""
    };
  }
  function wt() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Yt() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Mn(ke) {
    return {
      type: "list",
      ordered: ke.type === "listOrdered",
      start: null,
      spread: ke._spread,
      children: []
    };
  }
  function Rt(ke) {
    return {
      type: "listItem",
      spread: ke._spread,
      checked: null,
      children: []
    };
  }
  function ln() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function In() {
    return {
      type: "strong",
      children: []
    };
  }
  function Nn() {
    return {
      type: "text",
      value: ""
    };
  }
  function gt() {
    return {
      type: "thematicBreak"
    };
  }
}
function Kl(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function KV(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? KV(e, r) : bSe(e, r);
  }
}
function bSe(e, t) {
  let n;
  for (n in t)
    if (GV.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function Fz(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Vm({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Vm({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Vm({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function xSe(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return ySe(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function wSe(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function SSe(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function kSe(e, t) {
  const n = t.value ? t.value + `
` : "", r = {}, i = t.lang ? t.lang.split(/\s+/) : [];
  i.length > 0 && (r.className = ["language-" + i[0]]);
  let o = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (o.data = { meta: t.meta }), e.patch(t, o), o = e.applyData(t, o), o = { type: "element", tagName: "pre", properties: {}, children: [o] }, e.patch(t, o), o;
}
function CSe(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function ESe(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function _Se(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = Qh(r.toLowerCase()), o = e.footnoteOrder.indexOf(r);
  let s, a = e.footnoteCounts.get(r);
  a === void 0 ? (a = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = o + 1, a += 1, e.footnoteCounts.set(r, a);
  const c = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (a > 1 ? "-" + a : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  e.patch(t, c);
  const u = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [c]
  };
  return e.patch(t, u), e.applyData(t, u);
}
function TSe(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function ASe(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function ZV(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), o = i[0];
  o && o.type === "text" ? o.value = "[" + o.value : i.unshift({ type: "text", value: "[" });
  const s = i[i.length - 1];
  return s && s.type === "text" ? s.value += r : i.push({ type: "text", value: r }), i;
}
function MSe(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return ZV(e, t);
  const i = { src: Qh(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const o = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, o), e.applyData(t, o);
}
function NSe(e, t) {
  const n = { src: Qh(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function RSe(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function OSe(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return ZV(e, t);
  const i = { href: Qh(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const o = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function PSe(e, t) {
  const n = { href: Qh(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function DSe(e, t, n) {
  const r = e.all(t), i = n ? ISe(n) : YV(t), o = {}, s = [];
  if (typeof t.checked == "boolean") {
    const f = r[0];
    let h;
    f && f.type === "element" && f.tagName === "p" ? h = f : (h = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(h)), h.children.length > 0 && h.children.unshift({ type: "text", value: " " }), h.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), o.className = ["task-list-item"];
  }
  let a = -1;
  for (; ++a < r.length; ) {
    const f = r[a];
    (i || a !== 0 || f.type !== "element" || f.tagName !== "p") && s.push({ type: "text", value: `
` }), f.type === "element" && f.tagName === "p" && !i ? s.push(...f.children) : s.push(f);
  }
  const c = r[r.length - 1];
  c && (i || c.type !== "element" || c.tagName !== "p") && s.push({ type: "text", value: `
` });
  const u = { type: "element", tagName: "li", properties: o, children: s };
  return e.patch(t, u), e.applyData(t, u);
}
function ISe(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = YV(n[r]);
  }
  return t;
}
function YV(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function jSe(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const s = r[i];
    if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const o = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function zSe(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function LSe(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function BSe(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function $Se(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const s = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], s), i.push(s);
  }
  if (n.length > 0) {
    const s = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, a = iN(t.children[1]), c = AV(t.children[t.children.length - 1]);
    a && c && (s.position = { start: a, end: c }), i.push(s);
  }
  const o = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function USe(e, t, n) {
  const r = n ? n.children : void 0, o = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, a = s ? s.length : t.children.length;
  let c = -1;
  const u = [];
  for (; ++c < a; ) {
    const h = t.children[c], m = {}, g = s ? s[c] : void 0;
    g && (m.align = g);
    let b = { type: "element", tagName: o, properties: m, children: [] };
    h && (b.children = e.all(h), e.patch(h, b), b = e.applyData(h, b)), u.push(b);
  }
  const f = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, f), e.applyData(t, f);
}
function FSe(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Vz = 9, Hz = 32;
function VSe(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const o = [];
  for (; r; )
    o.push(
      Wz(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return o.push(Wz(t.slice(i), i > 0, !1)), o.join("");
}
function Wz(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let o = e.codePointAt(r);
    for (; o === Vz || o === Hz; )
      r++, o = e.codePointAt(r);
  }
  if (n) {
    let o = e.codePointAt(i - 1);
    for (; o === Vz || o === Hz; )
      i--, o = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function HSe(e, t) {
  const n = { type: "text", value: VSe(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function WSe(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const qSe = {
  blockquote: wSe,
  break: SSe,
  code: kSe,
  delete: CSe,
  emphasis: ESe,
  footnoteReference: _Se,
  heading: TSe,
  html: ASe,
  imageReference: MSe,
  image: NSe,
  inlineCode: RSe,
  linkReference: OSe,
  link: PSe,
  listItem: DSe,
  list: jSe,
  paragraph: zSe,
  // @ts-expect-error: root is different, but hard to type.
  root: LSe,
  strong: BSe,
  table: $Se,
  tableCell: FSe,
  tableRow: USe,
  text: HSe,
  thematicBreak: WSe,
  toml: t0,
  yaml: t0,
  definition: t0,
  footnoteDefinition: t0
};
function t0() {
}
const XV = -1, Zw = 0, Wm = 1, Zb = 2, dN = 3, fN = 4, hN = 5, pN = 6, JV = 7, QV = 8, qz = typeof self == "object" ? self : globalThis, GSe = (e, t) => {
  const n = (i, o) => (e.set(o, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [o, s] = t[i];
    switch (o) {
      case Zw:
      case XV:
        return n(s, i);
      case Wm: {
        const a = n([], i);
        for (const c of s)
          a.push(r(c));
        return a;
      }
      case Zb: {
        const a = n({}, i);
        for (const [c, u] of s)
          a[r(c)] = r(u);
        return a;
      }
      case dN:
        return n(new Date(s), i);
      case fN: {
        const { source: a, flags: c } = s;
        return n(new RegExp(a, c), i);
      }
      case hN: {
        const a = n(/* @__PURE__ */ new Map(), i);
        for (const [c, u] of s)
          a.set(r(c), r(u));
        return a;
      }
      case pN: {
        const a = n(/* @__PURE__ */ new Set(), i);
        for (const c of s)
          a.add(r(c));
        return a;
      }
      case JV: {
        const { name: a, message: c } = s;
        return n(new qz[a](c), i);
      }
      case QV:
        return n(BigInt(s), i);
      case "BigInt":
        return n(Object(BigInt(s)), i);
      case "ArrayBuffer":
        return n(new Uint8Array(s).buffer, s);
      case "DataView": {
        const { buffer: a } = new Uint8Array(s);
        return n(new DataView(a), s);
      }
    }
    return n(new qz[o](s), i);
  };
  return r;
}, Gz = (e) => GSe(/* @__PURE__ */ new Map(), e)(0), _f = "", { toString: KSe } = {}, { keys: ZSe } = Object, dm = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Zw, t];
  const n = KSe.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Wm, _f];
    case "Object":
      return [Zb, _f];
    case "Date":
      return [dN, _f];
    case "RegExp":
      return [fN, _f];
    case "Map":
      return [hN, _f];
    case "Set":
      return [pN, _f];
    case "DataView":
      return [Wm, n];
  }
  return n.includes("Array") ? [Wm, n] : n.includes("Error") ? [JV, n] : [Zb, n];
}, n0 = ([e, t]) => e === Zw && (t === "function" || t === "symbol"), YSe = (e, t, n, r) => {
  const i = (s, a) => {
    const c = r.push(s) - 1;
    return n.set(a, c), c;
  }, o = (s) => {
    if (n.has(s))
      return n.get(s);
    let [a, c] = dm(s);
    switch (a) {
      case Zw: {
        let f = s;
        switch (c) {
          case "bigint":
            a = QV, f = s.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + c);
            f = null;
            break;
          case "undefined":
            return i([XV], s);
        }
        return i([a, f], s);
      }
      case Wm: {
        if (c) {
          let m = s;
          return c === "DataView" ? m = new Uint8Array(s.buffer) : c === "ArrayBuffer" && (m = new Uint8Array(s)), i([c, [...m]], s);
        }
        const f = [], h = i([a, f], s);
        for (const m of s)
          f.push(o(m));
        return h;
      }
      case Zb: {
        if (c)
          switch (c) {
            case "BigInt":
              return i([c, s.toString()], s);
            case "Boolean":
            case "Number":
            case "String":
              return i([c, s.valueOf()], s);
          }
        if (t && "toJSON" in s)
          return o(s.toJSON());
        const f = [], h = i([a, f], s);
        for (const m of ZSe(s))
          (e || !n0(dm(s[m]))) && f.push([o(m), o(s[m])]);
        return h;
      }
      case dN:
        return i([a, s.toISOString()], s);
      case fN: {
        const { source: f, flags: h } = s;
        return i([a, { source: f, flags: h }], s);
      }
      case hN: {
        const f = [], h = i([a, f], s);
        for (const [m, g] of s)
          (e || !(n0(dm(m)) || n0(dm(g)))) && f.push([o(m), o(g)]);
        return h;
      }
      case pN: {
        const f = [], h = i([a, f], s);
        for (const m of s)
          (e || !n0(dm(m))) && f.push(o(m));
        return h;
      }
    }
    const { message: u } = s;
    return i([a, { name: c, message: u }], s);
  };
  return o;
}, Kz = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return YSe(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Yb = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? Gz(Kz(e, t)) : structuredClone(e)
) : (e, t) => Gz(Kz(e, t));
function XSe(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function JSe(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function QSe(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || XSe, r = e.options.footnoteBackLabel || JSe, i = e.options.footnoteLabel || "Footnotes", o = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, a = [];
  let c = -1;
  for (; ++c < e.footnoteOrder.length; ) {
    const u = e.footnoteById.get(
      e.footnoteOrder[c]
    );
    if (!u)
      continue;
    const f = e.all(u), h = String(u.identifier).toUpperCase(), m = Qh(h.toLowerCase());
    let g = 0;
    const b = [], x = e.footnoteCounts.get(h);
    for (; x !== void 0 && ++g <= x; ) {
      b.length > 0 && b.push({ type: "text", value: " " });
      let _ = typeof n == "string" ? n : n(c, g);
      typeof _ == "string" && (_ = { type: "text", value: _ }), b.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + m + (g > 1 ? "-" + g : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(c, g),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(_) ? _ : [_]
      });
    }
    const w = f[f.length - 1];
    if (w && w.type === "element" && w.tagName === "p") {
      const _ = w.children[w.children.length - 1];
      _ && _.type === "text" ? _.value += " " : w.children.push({ type: "text", value: " " }), w.children.push(...b);
    } else
      f.push(...b);
    const S = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + m },
      children: e.wrap(f, !0)
    };
    e.patch(u, S), a.push(S);
  }
  if (a.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: o,
          properties: {
            ...Yb(s),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(a, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Yw = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(e) {
    if (e == null)
      return rke;
    if (typeof e == "function")
      return Xw(e);
    if (typeof e == "object")
      return Array.isArray(e) ? eke(e) : (
        // Cast because `ReadonlyArray` goes into the above but `isArray`
        // narrows to `Array`.
        tke(
          /** @type {Props} */
          e
        )
      );
    if (typeof e == "string")
      return nke(e);
    throw new Error("Expected function, string, or object as test");
  })
);
function eke(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Yw(e[n]);
  return Xw(r);
  function r(...i) {
    let o = -1;
    for (; ++o < t.length; )
      if (t[o].apply(this, i)) return !0;
    return !1;
  }
}
function tke(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Xw(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let o;
    for (o in e)
      if (i[o] !== t[o]) return !1;
    return !0;
  }
}
function nke(e) {
  return Xw(t);
  function t(n) {
    return n && n.type === e;
  }
}
function Xw(e) {
  return t;
  function t(n, r, i) {
    return !!(ike(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function rke() {
  return !0;
}
function ike(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const e7 = [], oke = !0, cT = !1, ske = "skip";
function t7(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const o = Yw(i), s = r ? -1 : 1;
  a(e, void 0, [])();
  function a(c, u, f) {
    const h = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof h.type == "string") {
      const g = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(m, "name", {
        value: "node (" + (c.type + (g ? "<" + g + ">" : "")) + ")"
      });
    }
    return m;
    function m() {
      let g = e7, b, x, w;
      if ((!t || o(c, u, f[f.length - 1] || void 0)) && (g = ake(n(c, f)), g[0] === cT))
        return g;
      if ("children" in c && c.children) {
        const S = (
          /** @type {UnistParent} */
          c
        );
        if (S.children && g[0] !== ske)
          for (x = (r ? S.children.length : -1) + s, w = f.concat(S); x > -1 && x < S.children.length; ) {
            const _ = S.children[x];
            if (b = a(_, x, w)(), b[0] === cT)
              return b;
            x = typeof b[1] == "number" ? b[1] : x + s;
          }
      }
      return g;
    }
  }
}
function ake(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [oke, e] : e == null ? e7 : [e];
}
function mN(e, t, n, r) {
  let i, o, s;
  typeof t == "function" && typeof n != "function" ? (o = void 0, s = t, i = n) : (o = t, s = n, i = r), t7(e, o, a, i);
  function a(c, u) {
    const f = u[u.length - 1], h = f ? f.children.indexOf(c) : void 0;
    return s(c, h, f);
  }
}
const uT = {}.hasOwnProperty, lke = {};
function cke(e, t) {
  const n = t || lke, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), s = { ...qSe, ...n.handlers }, a = {
    all: u,
    applyData: dke,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: o,
    footnoteOrder: [],
    handlers: s,
    one: c,
    options: n,
    patch: uke,
    wrap: hke
  };
  return mN(e, function(f) {
    if (f.type === "definition" || f.type === "footnoteDefinition") {
      const h = f.type === "definition" ? r : i, m = String(f.identifier).toUpperCase();
      h.has(m) || h.set(m, f);
    }
  }), a;
  function c(f, h) {
    const m = f.type, g = a.handlers[m];
    if (uT.call(a.handlers, m) && g)
      return g(a, f, h);
    if (a.options.passThrough && a.options.passThrough.includes(m)) {
      if ("children" in f) {
        const { children: x, ...w } = f, S = Yb(w);
        return S.children = a.all(f), S;
      }
      return Yb(f);
    }
    return (a.options.unknownHandler || fke)(a, f, h);
  }
  function u(f) {
    const h = [];
    if ("children" in f) {
      const m = f.children;
      let g = -1;
      for (; ++g < m.length; ) {
        const b = a.one(m[g], f);
        if (b) {
          if (g && m[g - 1].type === "break" && (!Array.isArray(b) && b.type === "text" && (b.value = Zz(b.value)), !Array.isArray(b) && b.type === "element")) {
            const x = b.children[0];
            x && x.type === "text" && (x.value = Zz(x.value));
          }
          Array.isArray(b) ? h.push(...b) : h.push(b);
        }
      }
    }
    return h;
  }
}
function uke(e, t) {
  e.position && (t.position = Qxe(e));
}
function dke(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, o = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const s = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: s };
      }
    n.type === "element" && o && Object.assign(n.properties, Yb(o)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function fke(e, t) {
  const n = t.data || {}, r = "value" in t && !(uT.call(n, "hProperties") || uT.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function hke(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Zz(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function Yz(e, t) {
  const n = cke(e, t), r = n.one(e, void 0), i = QSe(n), o = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && o.children.push({ type: "text", value: `
` }, i), o;
}
function pke(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      Yz(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      Yz(n, { file: r, ...e || t })
    );
  };
}
function Xz(e) {
  if (e)
    throw e;
}
var jC, Jz;
function mke() {
  if (Jz) return jC;
  Jz = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = function(u) {
    return typeof Array.isArray == "function" ? Array.isArray(u) : t.call(u) === "[object Array]";
  }, o = function(u) {
    if (!u || t.call(u) !== "[object Object]")
      return !1;
    var f = e.call(u, "constructor"), h = u.constructor && u.constructor.prototype && e.call(u.constructor.prototype, "isPrototypeOf");
    if (u.constructor && !f && !h)
      return !1;
    var m;
    for (m in u)
      ;
    return typeof m > "u" || e.call(u, m);
  }, s = function(u, f) {
    n && f.name === "__proto__" ? n(u, f.name, {
      enumerable: !0,
      configurable: !0,
      value: f.newValue,
      writable: !0
    }) : u[f.name] = f.newValue;
  }, a = function(u, f) {
    if (f === "__proto__")
      if (e.call(u, f)) {
        if (r)
          return r(u, f).value;
      } else return;
    return u[f];
  };
  return jC = function c() {
    var u, f, h, m, g, b, x = arguments[0], w = 1, S = arguments.length, _ = !1;
    for (typeof x == "boolean" && (_ = x, x = arguments[1] || {}, w = 2), (x == null || typeof x != "object" && typeof x != "function") && (x = {}); w < S; ++w)
      if (u = arguments[w], u != null)
        for (f in u)
          h = a(x, f), m = a(u, f), x !== m && (_ && m && (o(m) || (g = i(m))) ? (g ? (g = !1, b = h && i(h) ? h : []) : b = h && o(h) ? h : {}, s(x, { name: f, newValue: c(_, b, m) })) : typeof m < "u" && s(x, { name: f, newValue: m }));
    return x;
  }, jC;
}
var gke = mke();
const zC = /* @__PURE__ */ Bc(gke);
function dT(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function yke() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let o = -1;
    const s = i.pop();
    if (typeof s != "function")
      throw new TypeError("Expected function as last argument, not " + s);
    a(null, ...i);
    function a(c, ...u) {
      const f = e[++o];
      let h = -1;
      if (c) {
        s(c);
        return;
      }
      for (; ++h < i.length; )
        (u[h] === null || u[h] === void 0) && (u[h] = i[h]);
      i = u, f ? vke(f, a)(...u) : s(null, ...u);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function vke(e, t) {
  let n;
  return r;
  function r(...s) {
    const a = e.length > s.length;
    let c;
    a && s.push(i);
    try {
      c = e.apply(this, s);
    } catch (u) {
      const f = (
        /** @type {Error} */
        u
      );
      if (a && n)
        throw f;
      return i(f);
    }
    a || (c && c.then && typeof c.then == "function" ? c.then(o, i) : c instanceof Error ? i(c) : o(c));
  }
  function i(s, ...a) {
    n || (n = !0, t(s, ...a));
  }
  function o(s) {
    i(null, s);
  }
}
const Us = { basename: bke, dirname: xke, extname: wke, join: Ske, sep: "/" };
function bke(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  gy(e);
  let n = 0, r = -1, i = e.length, o;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (o) {
          n = i + 1;
          break;
        }
      } else r < 0 && (o = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let s = -1, a = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (o) {
        n = i + 1;
        break;
      }
    } else
      s < 0 && (o = !0, s = i + 1), a > -1 && (e.codePointAt(i) === t.codePointAt(a--) ? a < 0 && (r = i) : (a = -1, r = s));
  return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r);
}
function xke(e) {
  if (gy(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function wke(e) {
  gy(e);
  let t = e.length, n = -1, r = 0, i = -1, o = 0, s;
  for (; t--; ) {
    const a = e.codePointAt(t);
    if (a === 47) {
      if (s) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (s = !0, n = t + 1), a === 46 ? i < 0 ? i = t : o !== 1 && (o = 1) : i > -1 && (o = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  o === 0 || // The (right-most) trimmed path component is exactly `..`.
  o === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function Ske(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    gy(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : kke(n);
}
function kke(e) {
  gy(e);
  const t = e.codePointAt(0) === 47;
  let n = Cke(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function Cke(e, t) {
  let n = "", r = 0, i = -1, o = 0, s = -1, a, c;
  for (; ++s <= e.length; ) {
    if (s < e.length)
      a = e.codePointAt(s);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(i === s - 1 || o === 1)) if (i !== s - 1 && o === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (c = n.lastIndexOf("/"), c !== n.length - 1) {
              c < 0 ? (n = "", r = 0) : (n = n.slice(0, c), r = n.length - 1 - n.lastIndexOf("/")), i = s, o = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = s, o = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(i + 1, s) : n = e.slice(i + 1, s), r = s - i - 1;
      i = s, o = 0;
    } else a === 46 && o > -1 ? o++ : o = -1;
  }
  return n;
}
function gy(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const Eke = { cwd: _ke };
function _ke() {
  return "/";
}
function fT(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function Tke(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!fT(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return Ake(e);
}
function Ake(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const LC = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class n7 {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? fT(t) ? n = { path: t } : typeof t == "string" || Mke(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : Eke.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < LC.length; ) {
      const o = LC[r];
      o in n && n[o] !== void 0 && n[o] !== null && (this[o] = o === "history" ? [...n[o]] : n[o]);
    }
    let i;
    for (i in n)
      LC.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Us.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    $C(t, "basename"), BC(t, "basename"), this.path = Us.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Us.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Qz(this.basename, "dirname"), this.path = Us.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Us.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (BC(t, "extname"), Qz(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Us.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    fT(t) && (t = Tke(t)), $C(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Us.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    $C(t, "stem"), BC(t, "stem"), this.path = Us.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new Si(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function BC(e, t) {
  if (e && e.includes(Us.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Us.sep + "`"
    );
}
function $C(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Qz(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function Mke(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const Nke = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], o = function() {
      return i.apply(o, arguments);
    };
    return Object.setPrototypeOf(o, r), o;
  })
), Rke = {}.hasOwnProperty;
class gN extends Nke {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = yke();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new gN()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(zC(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (VC("data", this.frozen), this.namespace[t] = n, this) : Rke.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (VC("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = r0(t), r = this.parser || this.Parser;
    return UC("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), UC("process", this.parser || this.Parser), FC("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(o, s) {
      const a = r0(t), c = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(a)
      );
      r.run(c, a, function(f, h, m) {
        if (f || !h || !m)
          return u(f);
        const g = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), b = r.stringify(g, m);
        Dke(b) ? m.value = b : m.result = b, u(
          f,
          /** @type {VFileWithOutput<CompileResult>} */
          m
        );
      });
      function u(f, h) {
        f || !h ? s(f) : o ? o(h) : n(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), UC("processSync", this.parser || this.Parser), FC("processSync", this.compiler || this.Compiler), this.process(t, i), tL("processSync", "process", n), r;
    function i(o, s) {
      n = !0, Xz(o), r = s;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    eL(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? o(void 0, r) : new Promise(o);
    function o(s, a) {
      const c = r0(n);
      i.run(t, c, u);
      function u(f, h, m) {
        const g = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || t
        );
        f ? a(f) : s ? s(g) : r(void 0, g, m);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, o), tL("runSync", "run", r), i;
    function o(s, a) {
      Xz(s), i = a, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = r0(n), i = this.compiler || this.Compiler;
    return FC("stringify", i), eL(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (VC("use", this.frozen), t != null) if (typeof t == "function")
      c(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? a(t) : s(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function o(u) {
      if (typeof u == "function")
        c(u, []);
      else if (typeof u == "object")
        if (Array.isArray(u)) {
          const [f, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            u
          );
          c(f, h);
        } else
          s(u);
      else
        throw new TypeError("Expected usable value, not `" + u + "`");
    }
    function s(u) {
      if (!("plugins" in u) && !("settings" in u))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      a(u.plugins), u.settings && (i.settings = zC(!0, i.settings, u.settings));
    }
    function a(u) {
      let f = -1;
      if (u != null) if (Array.isArray(u))
        for (; ++f < u.length; ) {
          const h = u[f];
          o(h);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + u + "`");
    }
    function c(u, f) {
      let h = -1, m = -1;
      for (; ++h < r.length; )
        if (r[h][0] === u) {
          m = h;
          break;
        }
      if (m === -1)
        r.push([u, ...f]);
      else if (f.length > 0) {
        let [g, ...b] = f;
        const x = r[m][1];
        dT(x) && dT(g) && (g = zC(!0, x, g)), r[m] = [u, g, ...b];
      }
    }
  }
}
const Oke = new gN().freeze();
function UC(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function FC(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function VC(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function eL(e) {
  if (!dT(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function tL(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function r0(e) {
  return Pke(e) ? e : new n7(e);
}
function Pke(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function Dke(e) {
  return typeof e == "string" || Ike(e);
}
function Ike(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const jke = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", nL = [], rL = { allowDangerousHtml: !0 }, zke = /^(https?|ircs?|mailto|xmpp)$/i, Lke = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Bke(e) {
  const t = $ke(e), n = Uke(e);
  return Fke(t.runSync(t.parse(n), n), e);
}
function $ke(e) {
  const t = e.rehypePlugins || nL, n = e.remarkPlugins || nL, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...rL } : rL;
  return Oke().use(xSe).use(n).use(pke, r).use(t);
}
function Uke(e) {
  const t = e.children || "", n = new n7();
  return typeof t == "string" && (n.value = t), n;
}
function Fke(e, t) {
  const n = t.allowedElements, r = t.allowElement, i = t.components, o = t.disallowedElements, s = t.skipHtml, a = t.unwrapDisallowed, c = t.urlTransform || Vke;
  for (const f of Lke)
    Object.hasOwn(t, f.from) && ("" + f.from + (f.to ? "use `" + f.to + "` instead" : "remove it") + jke + f.id, void 0);
  return mN(e, u), RV(e, {
    Fragment: v.Fragment,
    components: i,
    ignoreInvalidStyle: !0,
    jsx: v.jsx,
    jsxs: v.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function u(f, h, m) {
    if (f.type === "raw" && m && typeof h == "number")
      return s ? m.children.splice(h, 1) : m.children[h] = { type: "text", value: f.value }, h;
    if (f.type === "element") {
      let g;
      for (g in PC)
        if (Object.hasOwn(PC, g) && Object.hasOwn(f.properties, g)) {
          const b = f.properties[g], x = PC[g];
          (x === null || x.includes(f.tagName)) && (f.properties[g] = c(String(b || ""), g, f));
        }
    }
    if (f.type === "element") {
      let g = n ? !n.includes(f.tagName) : o ? o.includes(f.tagName) : !1;
      if (!g && r && typeof h == "number" && (g = !r(f, h, m)), g && m && typeof h == "number")
        return a && f.children ? m.children.splice(h, 1, ...f.children) : m.children.splice(h, 1), h;
    }
  }
}
function Vke(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    i !== -1 && t > i || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    zke.test(e.slice(0, t)) ? e : ""
  );
}
function Xb(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
function Hke(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Wke(e, t, n) {
  const i = Yw((n || {}).ignore || []), o = qke(t);
  let s = -1;
  for (; ++s < o.length; )
    t7(e, "text", a);
  function a(u, f) {
    let h = -1, m;
    for (; ++h < f.length; ) {
      const g = f[h], b = m ? m.children : void 0;
      if (i(
        g,
        b ? b.indexOf(g) : void 0,
        m
      ))
        return;
      m = g;
    }
    if (m)
      return c(u, f);
  }
  function c(u, f) {
    const h = f[f.length - 1], m = o[s][0], g = o[s][1];
    let b = 0;
    const w = h.children.indexOf(u);
    let S = !1, _ = [];
    m.lastIndex = 0;
    let M = m.exec(u.value);
    for (; M; ) {
      const N = M.index, D = {
        index: M.index,
        input: M.input,
        stack: [...f, u]
      };
      let j = g(...M, D);
      if (typeof j == "string" && (j = j.length > 0 ? { type: "text", value: j } : void 0), j === !1 ? m.lastIndex = N + 1 : (b !== N && _.push({
        type: "text",
        value: u.value.slice(b, N)
      }), Array.isArray(j) ? _.push(...j) : j && _.push(j), b = N + M[0].length, S = !0), !m.global)
        break;
      M = m.exec(u.value);
    }
    return S ? (b < u.value.length && _.push({ type: "text", value: u.value.slice(b) }), h.children.splice(w, 1, ..._)) : _ = [u], w + _.length;
  }
}
function qke(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([Gke(i[0]), Kke(i[1])]);
  }
  return t;
}
function Gke(e) {
  return typeof e == "string" ? new RegExp(Hke(e), "g") : e;
}
function Kke(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const HC = "phrasing", WC = ["autolink", "link", "image", "label"];
function Zke() {
  return {
    transforms: [nCe],
    enter: {
      literalAutolink: Xke,
      literalAutolinkEmail: qC,
      literalAutolinkHttp: qC,
      literalAutolinkWww: qC
    },
    exit: {
      literalAutolink: tCe,
      literalAutolinkEmail: eCe,
      literalAutolinkHttp: Jke,
      literalAutolinkWww: Qke
    }
  };
}
function Yke() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: HC,
        notInConstruct: WC
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: HC,
        notInConstruct: WC
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: HC,
        notInConstruct: WC
      }
    ]
  };
}
function Xke(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function qC(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function Jke(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function Qke(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function eCe(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function tCe(e) {
  this.exit(e);
}
function nCe(e) {
  Wke(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, rCe],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), iCe]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function rCe(e, t, n, r, i) {
  let o = "";
  if (!r7(i) || (/^w/i.test(t) && (n = t + n, t = "", o = "http://"), !oCe(n)))
    return !1;
  const s = sCe(n + r);
  if (!s[0]) return !1;
  const a = {
    type: "link",
    title: null,
    url: o + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [a, { type: "text", value: s[1] }] : a;
}
function iCe(e, t, n, r) {
  return (
    // Not an expected previous character.
    !r7(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function oCe(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function sCe(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = Xb(e, "(");
  let o = Xb(e, ")");
  for (; r !== -1 && i > o; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), o++;
  return [e, n];
}
function r7(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || cd(n) || Gw(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
i7.peek = mCe;
function aCe() {
  this.buffer();
}
function lCe(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function cCe() {
  this.buffer();
}
function uCe(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function dCe(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = ms(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function fCe(e) {
  this.exit(e);
}
function hCe(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = ms(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function pCe(e) {
  this.exit(e);
}
function mCe() {
  return "[";
}
function i7(e, t, n, r) {
  const i = n.createTracker(r);
  let o = i.move("[^");
  const s = n.enter("footnoteReference"), a = n.enter("reference");
  return o += i.move(
    n.safe(n.associationId(e), { after: "]", before: o })
  ), a(), s(), o += i.move("]"), o;
}
function gCe() {
  return {
    enter: {
      gfmFootnoteCallString: aCe,
      gfmFootnoteCall: lCe,
      gfmFootnoteDefinitionLabelString: cCe,
      gfmFootnoteDefinition: uCe
    },
    exit: {
      gfmFootnoteCallString: dCe,
      gfmFootnoteCall: fCe,
      gfmFootnoteDefinitionLabelString: hCe,
      gfmFootnoteDefinition: pCe
    }
  };
}
function yCe(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: i7 },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, i, o, s) {
    const a = o.createTracker(s);
    let c = a.move("[^");
    const u = o.enter("footnoteDefinition"), f = o.enter("label");
    return c += a.move(
      o.safe(o.associationId(r), { before: c, after: "]" })
    ), f(), c += a.move("]:"), r.children && r.children.length > 0 && (a.shift(4), c += a.move(
      (t ? `
` : " ") + o.indentLines(
        o.containerFlow(r, a.current()),
        t ? o7 : vCe
      )
    )), u(), c;
  }
}
function vCe(e, t, n) {
  return t === 0 ? e : o7(e, t, n);
}
function o7(e, t, n) {
  return (n ? "" : "    ") + e;
}
const bCe = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
s7.peek = CCe;
function xCe() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: SCe },
    exit: { strikethrough: kCe }
  };
}
function wCe() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: bCe
      }
    ],
    handlers: { delete: s7 }
  };
}
function SCe(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function kCe(e) {
  this.exit(e);
}
function s7(e, t, n, r) {
  const i = n.createTracker(r), o = n.enter("strikethrough");
  let s = i.move("~~");
  return s += n.containerPhrasing(e, {
    ...i.current(),
    before: s,
    after: "~"
  }), s += i.move("~~"), o(), s;
}
function CCe() {
  return "~";
}
function ECe(e) {
  return e.length;
}
function _Ce(e, t) {
  const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || ECe, o = [], s = [], a = [], c = [];
  let u = 0, f = -1;
  for (; ++f < e.length; ) {
    const x = [], w = [];
    let S = -1;
    for (e[f].length > u && (u = e[f].length); ++S < e[f].length; ) {
      const _ = TCe(e[f][S]);
      if (n.alignDelimiters !== !1) {
        const M = i(_);
        w[S] = M, (c[S] === void 0 || M > c[S]) && (c[S] = M);
      }
      x.push(_);
    }
    s[f] = x, a[f] = w;
  }
  let h = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++h < u; )
      o[h] = iL(r[h]);
  else {
    const x = iL(r);
    for (; ++h < u; )
      o[h] = x;
  }
  h = -1;
  const m = [], g = [];
  for (; ++h < u; ) {
    const x = o[h];
    let w = "", S = "";
    x === 99 ? (w = ":", S = ":") : x === 108 ? w = ":" : x === 114 && (S = ":");
    let _ = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      c[h] - w.length - S.length
    );
    const M = w + "-".repeat(_) + S;
    n.alignDelimiters !== !1 && (_ = w.length + _ + S.length, _ > c[h] && (c[h] = _), g[h] = _), m[h] = M;
  }
  s.splice(1, 0, m), a.splice(1, 0, g), f = -1;
  const b = [];
  for (; ++f < s.length; ) {
    const x = s[f], w = a[f];
    h = -1;
    const S = [];
    for (; ++h < u; ) {
      const _ = x[h] || "";
      let M = "", N = "";
      if (n.alignDelimiters !== !1) {
        const D = c[h] - (w[h] || 0), j = o[h];
        j === 114 ? M = " ".repeat(D) : j === 99 ? D % 2 ? (M = " ".repeat(D / 2 + 0.5), N = " ".repeat(D / 2 - 0.5)) : (M = " ".repeat(D / 2), N = M) : N = " ".repeat(D);
      }
      n.delimiterStart !== !1 && !h && S.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && _ === "") && (n.delimiterStart !== !1 || h) && S.push(" "), n.alignDelimiters !== !1 && S.push(M), S.push(_), n.alignDelimiters !== !1 && S.push(N), n.padding !== !1 && S.push(" "), (n.delimiterEnd !== !1 || h !== u - 1) && S.push("|");
    }
    b.push(
      n.delimiterEnd === !1 ? S.join("").replace(/ +$/, "") : S.join("")
    );
  }
  return b.join(`
`);
}
function TCe(e) {
  return e == null ? "" : String(e);
}
function iL(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
const oL = {}.hasOwnProperty;
function ACe(e, t) {
  const n = t || {};
  function r(i, ...o) {
    let s = r.invalid;
    const a = r.handlers;
    if (i && oL.call(i, e)) {
      const c = String(i[e]);
      s = oL.call(a, c) ? a[c] : r.unknown;
    }
    if (s)
      return s.call(this, i, ...o);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
function MCe(e, t, n, r) {
  const i = n.enter("blockquote"), o = n.createTracker(r);
  o.move("> "), o.shift(2);
  const s = n.indentLines(
    n.containerFlow(e, o.current()),
    NCe
  );
  return i(), s;
}
function NCe(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function RCe(e, t) {
  return sL(e, t.inConstruct, !0) && !sL(e, t.notInConstruct, !1);
}
function sL(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function aL(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && RCe(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function OCe(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, o = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++o > s && (s = o) : o = 1, i = r + t.length, r = n.indexOf(t, i);
  return s;
}
function PCe(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function DCe(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function ICe(e, t, n, r) {
  const i = DCe(n), o = e.value || "", s = i === "`" ? "GraveAccent" : "Tilde";
  if (PCe(e, n)) {
    const h = n.enter("codeIndented"), m = n.indentLines(o, jCe);
    return h(), m;
  }
  const a = n.createTracker(r), c = i.repeat(Math.max(OCe(o, i) + 1, 3)), u = n.enter("codeFenced");
  let f = a.move(c);
  if (e.lang) {
    const h = n.enter(`codeFencedLang${s}`);
    f += a.move(
      n.safe(e.lang, {
        before: f,
        after: " ",
        encode: ["`"],
        ...a.current()
      })
    ), h();
  }
  if (e.lang && e.meta) {
    const h = n.enter(`codeFencedMeta${s}`);
    f += a.move(" "), f += a.move(
      n.safe(e.meta, {
        before: f,
        after: `
`,
        encode: ["`"],
        ...a.current()
      })
    ), h();
  }
  return f += a.move(`
`), o && (f += a.move(o + `
`)), f += a.move(c), u(), f;
}
function jCe(e, t, n) {
  return (n ? "" : "    ") + e;
}
function yN(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function zCe(e, t, n, r) {
  const i = yN(n), o = i === '"' ? "Quote" : "Apostrophe", s = n.enter("definition");
  let a = n.enter("label");
  const c = n.createTracker(r);
  let u = c.move("[");
  return u += c.move(
    n.safe(n.associationId(e), {
      before: u,
      after: "]",
      ...c.current()
    })
  ), u += c.move("]: "), a(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    n.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (a = n.enter("destinationRaw"), u += c.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), a(), e.title && (a = n.enter(`title${o}`), u += c.move(" " + i), u += c.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), a()), s(), u;
}
function LCe(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function kg(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Jb(e, t, n) {
  const r = kh(e), i = kh(t);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
a7.peek = BCe;
function a7(e, t, n, r) {
  const i = LCe(n), o = n.enter("emphasis"), s = n.createTracker(r), a = s.move(i);
  let c = s.move(
    n.containerPhrasing(e, {
      after: i,
      before: a,
      ...s.current()
    })
  );
  const u = c.charCodeAt(0), f = Jb(
    r.before.charCodeAt(r.before.length - 1),
    u,
    i
  );
  f.inside && (c = kg(u) + c.slice(1));
  const h = c.charCodeAt(c.length - 1), m = Jb(r.after.charCodeAt(0), h, i);
  m.inside && (c = c.slice(0, -1) + kg(h));
  const g = s.move(i);
  return o(), n.attentionEncodeSurroundingInfo = {
    after: m.outside,
    before: f.outside
  }, a + c + g;
}
function BCe(e, t, n) {
  return n.options.emphasis || "*";
}
function $Ce(e, t) {
  let n = !1;
  return mN(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, cT;
  }), !!((!e.depth || e.depth < 3) && lN(e) && (t.options.setext || n));
}
function UCe(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), o = n.createTracker(r);
  if ($Ce(e, n)) {
    const f = n.enter("headingSetext"), h = n.enter("phrasing"), m = n.containerPhrasing(e, {
      ...o.current(),
      before: `
`,
      after: `
`
    });
    return h(), f(), m + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size
      m.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(m.lastIndexOf("\r"), m.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(i), a = n.enter("headingAtx"), c = n.enter("phrasing");
  o.move(s + " ");
  let u = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...o.current()
  });
  return /^[\t ]/.test(u) && (u = kg(u.charCodeAt(0)) + u.slice(1)), u = u ? s + " " + u : s, n.options.closeAtx && (u += " " + s), c(), a(), u;
}
l7.peek = FCe;
function l7(e) {
  return e.value || "";
}
function FCe() {
  return "<";
}
c7.peek = VCe;
function c7(e, t, n, r) {
  const i = yN(n), o = i === '"' ? "Quote" : "Apostrophe", s = n.enter("image");
  let a = n.enter("label");
  const c = n.createTracker(r);
  let u = c.move("![");
  return u += c.move(
    n.safe(e.alt, { before: u, after: "]", ...c.current() })
  ), u += c.move("]("), a(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    n.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (a = n.enter("destinationRaw"), u += c.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), a(), e.title && (a = n.enter(`title${o}`), u += c.move(" " + i), u += c.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), a()), u += c.move(")"), s(), u;
}
function VCe() {
  return "!";
}
u7.peek = HCe;
function u7(e, t, n, r) {
  const i = e.referenceType, o = n.enter("imageReference");
  let s = n.enter("label");
  const a = n.createTracker(r);
  let c = a.move("![");
  const u = n.safe(e.alt, {
    before: c,
    after: "]",
    ...a.current()
  });
  c += a.move(u + "]["), s();
  const f = n.stack;
  n.stack = [], s = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...a.current()
  });
  return s(), n.stack = f, o(), i === "full" || !u || u !== h ? c += a.move(h + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += a.move("]"), c;
}
function HCe() {
  return "!";
}
d7.peek = WCe;
function d7(e, t, n) {
  let r = e.value || "", i = "`", o = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++o < n.unsafe.length; ) {
    const s = n.unsafe[o], a = n.compilePattern(s);
    let c;
    if (s.atBreak)
      for (; c = a.exec(r); ) {
        let u = c.index;
        r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--, r = r.slice(0, u) + " " + r.slice(c.index + 1);
      }
  }
  return i + r + i;
}
function WCe() {
  return "`";
}
function f7(e, t) {
  const n = lN(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
h7.peek = qCe;
function h7(e, t, n, r) {
  const i = yN(n), o = i === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r);
  let a, c;
  if (f7(e, n)) {
    const f = n.stack;
    n.stack = [], a = n.enter("autolink");
    let h = s.move("<");
    return h += s.move(
      n.containerPhrasing(e, {
        before: h,
        after: ">",
        ...s.current()
      })
    ), h += s.move(">"), a(), n.stack = f, h;
  }
  a = n.enter("link"), c = n.enter("label");
  let u = s.move("[");
  return u += s.move(
    n.containerPhrasing(e, {
      before: u,
      after: "](",
      ...s.current()
    })
  ), u += s.move("]("), c(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), u += s.move("<"), u += s.move(
    n.safe(e.url, { before: u, after: ">", ...s.current() })
  ), u += s.move(">")) : (c = n.enter("destinationRaw"), u += s.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), c(), e.title && (c = n.enter(`title${o}`), u += s.move(" " + i), u += s.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...s.current()
    })
  ), u += s.move(i), c()), u += s.move(")"), a(), u;
}
function qCe(e, t, n) {
  return f7(e, n) ? "<" : "[";
}
p7.peek = GCe;
function p7(e, t, n, r) {
  const i = e.referenceType, o = n.enter("linkReference");
  let s = n.enter("label");
  const a = n.createTracker(r);
  let c = a.move("[");
  const u = n.containerPhrasing(e, {
    before: c,
    after: "]",
    ...a.current()
  });
  c += a.move(u + "]["), s();
  const f = n.stack;
  n.stack = [], s = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...a.current()
  });
  return s(), n.stack = f, o(), i === "full" || !u || u !== h ? c += a.move(h + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += a.move("]"), c;
}
function GCe() {
  return "[";
}
function vN(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function KCe(e) {
  const t = vN(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function ZCe(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function m7(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function YCe(e, t, n, r) {
  const i = n.enter("list"), o = n.bulletCurrent;
  let s = e.ordered ? ZCe(n) : vN(n);
  const a = e.ordered ? s === "." ? ")" : "." : KCe(n);
  let c = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const f = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      f && (!f.children || !f.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (c = !0), m7(n) === s && f
    ) {
      let h = -1;
      for (; ++h < e.children.length; ) {
        const m = e.children[h];
        if (m && m.type === "listItem" && m.children && m.children[0] && m.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (s = a), n.bulletCurrent = s;
  const u = n.containerFlow(e, r);
  return n.bulletLastUsed = s, n.bulletCurrent = o, i(), u;
}
function XCe(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function JCe(e, t, n, r) {
  const i = XCe(n);
  let o = n.bulletCurrent || vN(n);
  t && t.type === "list" && t.ordered && (o = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + o);
  let s = o.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const a = n.createTracker(r);
  a.move(o + " ".repeat(s - o.length)), a.shift(s);
  const c = n.enter("listItem"), u = n.indentLines(
    n.containerFlow(e, a.current()),
    f
  );
  return c(), u;
  function f(h, m, g) {
    return m ? (g ? "" : " ".repeat(s)) + h : (g ? o : o + " ".repeat(s - o.length)) + h;
  }
}
function QCe(e, t, n, r) {
  const i = n.enter("paragraph"), o = n.enter("phrasing"), s = n.containerPhrasing(e, r);
  return o(), i(), s;
}
const eEe = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Yw([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function tEe(e, t, n, r) {
  return (e.children.some(function(s) {
    return eEe(s);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function nEe(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
g7.peek = rEe;
function g7(e, t, n, r) {
  const i = nEe(n), o = n.enter("strong"), s = n.createTracker(r), a = s.move(i + i);
  let c = s.move(
    n.containerPhrasing(e, {
      after: i,
      before: a,
      ...s.current()
    })
  );
  const u = c.charCodeAt(0), f = Jb(
    r.before.charCodeAt(r.before.length - 1),
    u,
    i
  );
  f.inside && (c = kg(u) + c.slice(1));
  const h = c.charCodeAt(c.length - 1), m = Jb(r.after.charCodeAt(0), h, i);
  m.inside && (c = c.slice(0, -1) + kg(h));
  const g = s.move(i + i);
  return o(), n.attentionEncodeSurroundingInfo = {
    after: m.outside,
    before: f.outside
  }, a + c + g;
}
function rEe(e, t, n) {
  return n.options.strong || "*";
}
function iEe(e, t, n, r) {
  return n.safe(e.value, r);
}
function oEe(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function sEe(e, t, n) {
  const r = (m7(n) + (n.options.ruleSpaces ? " " : "")).repeat(oEe(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const y7 = {
  blockquote: MCe,
  break: aL,
  code: ICe,
  definition: zCe,
  emphasis: a7,
  hardBreak: aL,
  heading: UCe,
  html: l7,
  image: c7,
  imageReference: u7,
  inlineCode: d7,
  link: h7,
  linkReference: p7,
  list: YCe,
  listItem: JCe,
  paragraph: QCe,
  root: tEe,
  strong: g7,
  text: iEe,
  thematicBreak: sEe
};
function aEe() {
  return {
    enter: {
      table: lEe,
      tableData: lL,
      tableHeader: lL,
      tableRow: uEe
    },
    exit: {
      codeText: dEe,
      table: cEe,
      tableData: GC,
      tableHeader: GC,
      tableRow: GC
    }
  };
}
function lEe(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function cEe(e) {
  this.exit(e), this.data.inTable = void 0;
}
function uEe(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function GC(e) {
  this.exit(e);
}
function lL(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function dEe(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, fEe));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function fEe(e, t) {
  return t === "|" ? t : e;
}
function hEe(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, o = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: m,
      table: s,
      tableCell: c,
      tableRow: a
    }
  };
  function s(g, b, x, w) {
    return u(f(g, x, w), g.align);
  }
  function a(g, b, x, w) {
    const S = h(g, x, w), _ = u([S]);
    return _.slice(0, _.indexOf(`
`));
  }
  function c(g, b, x, w) {
    const S = x.enter("tableCell"), _ = x.enter("phrasing"), M = x.containerPhrasing(g, {
      ...w,
      before: o,
      after: o
    });
    return _(), S(), M;
  }
  function u(g, b) {
    return _Ce(g, {
      align: b,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function f(g, b, x) {
    const w = g.children;
    let S = -1;
    const _ = [], M = b.enter("table");
    for (; ++S < w.length; )
      _[S] = h(w[S], b, x);
    return M(), _;
  }
  function h(g, b, x) {
    const w = g.children;
    let S = -1;
    const _ = [], M = b.enter("tableRow");
    for (; ++S < w.length; )
      _[S] = c(w[S], g, b, x);
    return M(), _;
  }
  function m(g, b, x) {
    let w = y7.inlineCode(g, b, x);
    return x.stack.includes("tableCell") && (w = w.replace(/\|/g, "\\$&")), w;
  }
}
function pEe() {
  return {
    exit: {
      taskListCheckValueChecked: cL,
      taskListCheckValueUnchecked: cL,
      paragraph: gEe
    }
  };
}
function mEe() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: yEe }
  };
}
function cL(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function gEe(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let o = -1, s;
      for (; ++o < i.length; ) {
        const a = i[o];
        if (a.type === "paragraph") {
          s = a;
          break;
        }
      }
      s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function yEe(e, t, n, r) {
  const i = e.children[0], o = typeof e.checked == "boolean" && i && i.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", a = n.createTracker(r);
  o && a.move(s);
  let c = y7.listItem(e, t, n, {
    ...r,
    ...a.current()
  });
  return o && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), c;
  function u(f) {
    return f + s;
  }
}
function vEe() {
  return [
    Zke(),
    gCe(),
    xCe(),
    aEe(),
    pEe()
  ];
}
function bEe(e) {
  return {
    extensions: [
      Yke(),
      yCe(e),
      wCe(),
      hEe(e),
      mEe()
    ]
  };
}
const xEe = {
  tokenize: _Ee,
  partial: !0
}, v7 = {
  tokenize: TEe,
  partial: !0
}, b7 = {
  tokenize: AEe,
  partial: !0
}, x7 = {
  tokenize: MEe,
  partial: !0
}, wEe = {
  tokenize: NEe,
  partial: !0
}, w7 = {
  name: "wwwAutolink",
  tokenize: CEe,
  previous: k7
}, S7 = {
  name: "protocolAutolink",
  tokenize: EEe,
  previous: C7
}, cl = {
  name: "emailAutolink",
  tokenize: kEe,
  previous: E7
}, ca = {};
function SEe() {
  return {
    text: ca
  };
}
let Nu = 48;
for (; Nu < 123; )
  ca[Nu] = cl, Nu++, Nu === 58 ? Nu = 65 : Nu === 91 && (Nu = 97);
ca[43] = cl;
ca[45] = cl;
ca[46] = cl;
ca[95] = cl;
ca[72] = [cl, S7];
ca[104] = [cl, S7];
ca[87] = [cl, w7];
ca[119] = [cl, w7];
function kEe(e, t, n) {
  const r = this;
  let i, o;
  return s;
  function s(h) {
    return !hT(h) || !E7.call(r, r.previous) || bN(r.events) ? n(h) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), a(h));
  }
  function a(h) {
    return hT(h) ? (e.consume(h), a) : h === 64 ? (e.consume(h), c) : n(h);
  }
  function c(h) {
    return h === 46 ? e.check(wEe, f, u)(h) : h === 45 || h === 95 || bi(h) ? (o = !0, e.consume(h), c) : f(h);
  }
  function u(h) {
    return e.consume(h), i = !0, c;
  }
  function f(h) {
    return o && i && Ri(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(h)) : n(h);
  }
}
function CEe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s !== 87 && s !== 119 || !k7.call(r, r.previous) || bN(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(xEe, e.attempt(v7, e.attempt(b7, o), n), n)(s));
  }
  function o(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function EEe(e, t, n) {
  const r = this;
  let i = "", o = !1;
  return s;
  function s(h) {
    return (h === 72 || h === 104) && C7.call(r, r.previous) && !bN(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(h), e.consume(h), a) : n(h);
  }
  function a(h) {
    if (Ri(h) && i.length < 5)
      return i += String.fromCodePoint(h), e.consume(h), a;
    if (h === 58) {
      const m = i.toLowerCase();
      if (m === "http" || m === "https")
        return e.consume(h), c;
    }
    return n(h);
  }
  function c(h) {
    return h === 47 ? (e.consume(h), o ? u : (o = !0, c)) : n(h);
  }
  function u(h) {
    return h === null || Kb(h) || An(h) || cd(h) || Gw(h) ? n(h) : e.attempt(v7, e.attempt(b7, f), n)(h);
  }
  function f(h) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(h);
  }
}
function _Ee(e, t, n) {
  let r = 0;
  return i;
  function i(s) {
    return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), i) : s === 46 && r === 3 ? (e.consume(s), o) : n(s);
  }
  function o(s) {
    return s === null ? n(s) : t(s);
  }
}
function TEe(e, t, n) {
  let r, i, o;
  return s;
  function s(u) {
    return u === 46 || u === 95 ? e.check(x7, c, a)(u) : u === null || An(u) || cd(u) || u !== 45 && Gw(u) ? c(u) : (o = !0, e.consume(u), s);
  }
  function a(u) {
    return u === 95 ? r = !0 : (i = r, r = void 0), e.consume(u), s;
  }
  function c(u) {
    return i || r || !o ? n(u) : t(u);
  }
}
function AEe(e, t) {
  let n = 0, r = 0;
  return i;
  function i(s) {
    return s === 40 ? (n++, e.consume(s), i) : s === 41 && r < n ? o(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(x7, t, o)(s) : s === null || An(s) || cd(s) ? t(s) : (e.consume(s), i);
  }
  function o(s) {
    return s === 41 && r++, e.consume(s), i;
  }
}
function MEe(e, t, n) {
  return r;
  function r(a) {
    return a === 33 || a === 34 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 63 || a === 95 || a === 126 ? (e.consume(a), r) : a === 38 ? (e.consume(a), o) : a === 93 ? (e.consume(a), i) : (
      // `<` is an end.
      a === 60 || // So is whitespace.
      a === null || An(a) || cd(a) ? t(a) : n(a)
    );
  }
  function i(a) {
    return a === null || a === 40 || a === 91 || An(a) || cd(a) ? t(a) : r(a);
  }
  function o(a) {
    return Ri(a) ? s(a) : n(a);
  }
  function s(a) {
    return a === 59 ? (e.consume(a), r) : Ri(a) ? (e.consume(a), s) : n(a);
  }
}
function NEe(e, t, n) {
  return r;
  function r(o) {
    return e.consume(o), i;
  }
  function i(o) {
    return bi(o) ? n(o) : t(o);
  }
}
function k7(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || An(e);
}
function C7(e) {
  return !Ri(e);
}
function E7(e) {
  return !(e === 47 || hT(e));
}
function hT(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || bi(e);
}
function bN(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const REe = {
  tokenize: BEe,
  partial: !0
};
function OEe() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: jEe,
        continuation: {
          tokenize: zEe
        },
        exit: LEe
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: IEe
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: PEe,
        resolveTo: DEe
      }
    }
  };
}
function PEe(e, t, n) {
  const r = this;
  let i = r.events.length;
  const o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s;
  for (; i--; ) {
    const c = r.events[i][1];
    if (c.type === "labelImage") {
      s = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return a;
  function a(c) {
    if (!s || !s._balanced)
      return n(c);
    const u = ms(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }));
    return u.codePointAt(0) !== 94 || !o.includes(u.slice(1)) ? n(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function DEe(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const o = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, o.start),
    end: Object.assign({}, o.end)
  }, a = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", o, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", o, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...a), e;
}
function IEe(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o = 0, s;
  return a;
  function a(h) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(h) {
    return h !== 94 ? n(h) : (e.enter("gfmFootnoteCallMarker"), e.consume(h), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
  }
  function u(h) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      h === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || An(h)
    )
      return n(h);
    if (h === 93) {
      e.exit("chunkString");
      const m = e.exit("gfmFootnoteCallString");
      return i.includes(ms(r.sliceSerialize(m))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(h);
    }
    return An(h) || (s = !0), o++, e.consume(h), h === 92 ? f : u;
  }
  function f(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), o++, u) : u(h);
  }
}
function jEe(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o, s = 0, a;
  return c;
  function c(b) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
  }
  function u(b) {
    return b === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", f) : n(b);
  }
  function f(b) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      b === 93 && !a || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      b === null || b === 91 || An(b)
    )
      return n(b);
    if (b === 93) {
      e.exit("chunkString");
      const x = e.exit("gfmFootnoteDefinitionLabelString");
      return o = ms(r.sliceSerialize(x)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), m;
    }
    return An(b) || (a = !0), s++, e.consume(b), b === 92 ? h : f;
  }
  function h(b) {
    return b === 91 || b === 92 || b === 93 ? (e.consume(b), s++, f) : f(b);
  }
  function m(b) {
    return b === 58 ? (e.enter("definitionMarker"), e.consume(b), e.exit("definitionMarker"), i.includes(o) || i.push(o), rn(e, g, "gfmFootnoteDefinitionWhitespace")) : n(b);
  }
  function g(b) {
    return t(b);
  }
}
function zEe(e, t, n) {
  return e.check(my, t, e.attempt(REe, t, n));
}
function LEe(e) {
  e.exit("gfmFootnoteDefinition");
}
function BEe(e, t, n) {
  const r = this;
  return rn(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(o) : n(o);
  }
}
function $Ee(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: o,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(s, a) {
    let c = -1;
    for (; ++c < s.length; )
      if (s[c][0] === "enter" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._close) {
        let u = c;
        for (; u--; )
          if (s[u][0] === "exit" && s[u][1].type === "strikethroughSequenceTemporary" && s[u][1]._open && // If the sizes are the same:
          s[c][1].end.offset - s[c][1].start.offset === s[u][1].end.offset - s[u][1].start.offset) {
            s[c][1].type = "strikethroughSequence", s[u][1].type = "strikethroughSequence";
            const f = {
              type: "strikethrough",
              start: Object.assign({}, s[u][1].start),
              end: Object.assign({}, s[c][1].end)
            }, h = {
              type: "strikethroughText",
              start: Object.assign({}, s[u][1].end),
              end: Object.assign({}, s[c][1].start)
            }, m = [["enter", f, a], ["enter", s[u][1], a], ["exit", s[u][1], a], ["enter", h, a]], g = a.parser.constructs.insideSpan.null;
            g && vo(m, m.length, 0, Kw(g, s.slice(u + 1, c), a)), vo(m, m.length, 0, [["exit", h, a], ["enter", s[c][1], a], ["exit", s[c][1], a], ["exit", f, a]]), vo(s, u - 1, c - u + 3, m), c = u + m.length - 2;
            break;
          }
      }
    for (c = -1; ++c < s.length; )
      s[c][1].type === "strikethroughSequenceTemporary" && (s[c][1].type = "data");
    return s;
  }
  function o(s, a, c) {
    const u = this.previous, f = this.events;
    let h = 0;
    return m;
    function m(b) {
      return u === 126 && f[f.length - 1][1].type !== "characterEscape" ? c(b) : (s.enter("strikethroughSequenceTemporary"), g(b));
    }
    function g(b) {
      const x = kh(u);
      if (b === 126)
        return h > 1 ? c(b) : (s.consume(b), h++, g);
      if (h < 2 && !n) return c(b);
      const w = s.exit("strikethroughSequenceTemporary"), S = kh(b);
      return w._open = !S || S === 2 && !!x, w._close = !x || x === 2 && !!S, a(b);
    }
  }
}
class UEe {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    FEe(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(o, s) {
      return o[0] - s[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const o of i)
        t.push(o);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function FEe(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function VEe(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const o = r.length - 1;
          r[o] = r[o] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function HEe() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: WEe,
        resolveAll: qEe
      }
    }
  };
}
function WEe(e, t, n) {
  const r = this;
  let i = 0, o = 0, s;
  return a;
  function a(B) {
    let G = r.events.length - 1;
    for (; G > -1; ) {
      const ie = r.events[G][1].type;
      if (ie === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      ie === "linePrefix") G--;
      else break;
    }
    const Y = G > -1 ? r.events[G][1].type : null, he = Y === "tableHead" || Y === "tableRow" ? j : c;
    return he === j && r.parser.lazy[r.now().line] ? n(B) : he(B);
  }
  function c(B) {
    return e.enter("tableHead"), e.enter("tableRow"), u(B);
  }
  function u(B) {
    return B === 124 || (s = !0, o += 1), f(B);
  }
  function f(B) {
    return B === null ? n(B) : vt(B) ? o > 1 ? (o = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(B), e.exit("lineEnding"), g) : n(B) : Zt(B) ? rn(e, f, "whitespace")(B) : (o += 1, s && (s = !1, i += 1), B === 124 ? (e.enter("tableCellDivider"), e.consume(B), e.exit("tableCellDivider"), s = !0, f) : (e.enter("data"), h(B)));
  }
  function h(B) {
    return B === null || B === 124 || An(B) ? (e.exit("data"), f(B)) : (e.consume(B), B === 92 ? m : h);
  }
  function m(B) {
    return B === 92 || B === 124 ? (e.consume(B), h) : h(B);
  }
  function g(B) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(B) : (e.enter("tableDelimiterRow"), s = !1, Zt(B) ? rn(e, b, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(B) : b(B));
  }
  function b(B) {
    return B === 45 || B === 58 ? w(B) : B === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(B), e.exit("tableCellDivider"), x) : D(B);
  }
  function x(B) {
    return Zt(B) ? rn(e, w, "whitespace")(B) : w(B);
  }
  function w(B) {
    return B === 58 ? (o += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(B), e.exit("tableDelimiterMarker"), S) : B === 45 ? (o += 1, S(B)) : B === null || vt(B) ? N(B) : D(B);
  }
  function S(B) {
    return B === 45 ? (e.enter("tableDelimiterFiller"), _(B)) : D(B);
  }
  function _(B) {
    return B === 45 ? (e.consume(B), _) : B === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(B), e.exit("tableDelimiterMarker"), M) : (e.exit("tableDelimiterFiller"), M(B));
  }
  function M(B) {
    return Zt(B) ? rn(e, N, "whitespace")(B) : N(B);
  }
  function N(B) {
    return B === 124 ? b(B) : B === null || vt(B) ? !s || i !== o ? D(B) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(B)) : D(B);
  }
  function D(B) {
    return n(B);
  }
  function j(B) {
    return e.enter("tableRow"), O(B);
  }
  function O(B) {
    return B === 124 ? (e.enter("tableCellDivider"), e.consume(B), e.exit("tableCellDivider"), O) : B === null || vt(B) ? (e.exit("tableRow"), t(B)) : Zt(B) ? rn(e, O, "whitespace")(B) : (e.enter("data"), L(B));
  }
  function L(B) {
    return B === null || B === 124 || An(B) ? (e.exit("data"), O(B)) : (e.consume(B), B === 92 ? U : L);
  }
  function U(B) {
    return B === 92 || B === 124 ? (e.consume(B), L) : L(B);
  }
}
function qEe(e, t) {
  let n = -1, r = !0, i = 0, o = [0, 0, 0, 0], s = [0, 0, 0, 0], a = !1, c = 0, u, f, h;
  const m = new UEe();
  for (; ++n < e.length; ) {
    const g = e[n], b = g[1];
    g[0] === "enter" ? b.type === "tableHead" ? (a = !1, c !== 0 && (uL(m, t, c, u, f), f = void 0, c = 0), u = {
      type: "table",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, m.add(n, 0, [["enter", u, t]])) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (r = !0, h = void 0, o = [0, 0, 0, 0], s = [0, n + 1, 0, 0], a && (a = !1, f = {
      type: "tableBody",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, m.add(n, 0, [["enter", f, t]])), i = b.type === "tableDelimiterRow" ? 2 : f ? 3 : 1) : i && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (o[1] !== 0 && (s[0] = s[1], h = i0(m, t, o, i, void 0, h), o = [0, 0, 0, 0]), s[2] = n)) : b.type === "tableCellDivider" && (r ? r = !1 : (o[1] !== 0 && (s[0] = s[1], h = i0(m, t, o, i, void 0, h)), o = s, s = [o[1], n, 0, 0])) : b.type === "tableHead" ? (a = !0, c = n) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (c = n, o[1] !== 0 ? (s[0] = s[1], h = i0(m, t, o, i, n, h)) : s[1] !== 0 && (h = i0(m, t, s, i, n, h)), i = 0) : i && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (c !== 0 && uL(m, t, c, u, f), m.consume(t.events), n = -1; ++n < t.events.length; ) {
    const g = t.events[n];
    g[0] === "enter" && g[1].type === "table" && (g[1]._align = VEe(t.events, n));
  }
  return e;
}
function i0(e, t, n, r, i, o) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", a = "tableContent";
  n[0] !== 0 && (o.end = Object.assign({}, zf(t.events, n[0])), e.add(n[0], 0, [["exit", o, t]]));
  const c = zf(t.events, n[1]);
  if (o = {
    type: s,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(n[1], 0, [["enter", o, t]]), n[2] !== 0) {
    const u = zf(t.events, n[2]), f = zf(t.events, n[3]), h = {
      type: a,
      start: Object.assign({}, u),
      end: Object.assign({}, f)
    };
    if (e.add(n[2], 0, [["enter", h, t]]), r !== 2) {
      const m = t.events[n[2]], g = t.events[n[3]];
      if (m[1].end = Object.assign({}, g[1].end), m[1].type = "chunkText", m[1].contentType = "text", n[3] > n[2] + 1) {
        const b = n[2] + 1, x = n[3] - n[2] - 1;
        e.add(b, x, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", h, t]]);
  }
  return i !== void 0 && (o.end = Object.assign({}, zf(t.events, i)), e.add(i, 0, [["exit", o, t]]), o = void 0), o;
}
function uL(e, t, n, r, i) {
  const o = [], s = zf(t.events, n);
  i && (i.end = Object.assign({}, s), o.push(["exit", i, t])), r.end = Object.assign({}, s), o.push(["exit", r, t]), e.add(n + 1, 0, o);
}
function zf(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const GEe = {
  name: "tasklistCheck",
  tokenize: ZEe
};
function KEe() {
  return {
    text: {
      91: GEe
    }
  };
}
function ZEe(e, t, n) {
  const r = this;
  return i;
  function i(c) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), o)
    );
  }
  function o(c) {
    return An(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), s) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), s) : n(c);
  }
  function s(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), a) : n(c);
  }
  function a(c) {
    return vt(c) ? t(c) : Zt(c) ? e.check({
      tokenize: YEe
    }, t, n)(c) : n(c);
  }
}
function YEe(e, t, n) {
  return rn(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function XEe(e) {
  return jV([
    SEe(),
    OEe(),
    $Ee(e),
    HEe(),
    KEe()
  ]);
}
const JEe = {};
function QEe(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || JEe, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), o = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(XEe(n)), o.push(vEe()), s.push(bEe(n));
}
let Cr = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
};
function e_e(e) {
  return xN(e);
}
function xN(e) {
  return Array.isArray(e) ? t_e(e) : e instanceof RegExp ? e : typeof e == "object" ? n_e(e) : e;
}
function t_e(e) {
  let t = [];
  for (let n = 0, r = e.length; n < r; n++)
    t[n] = xN(e[n]);
  return t;
}
function n_e(e) {
  let t = {};
  for (let n in e)
    t[n] = xN(e[n]);
  return t;
}
function _7(e, ...t) {
  return t.forEach((n) => {
    for (let r in n)
      e[r] = n[r];
  }), e;
}
function T7(e) {
  const t = ~e.lastIndexOf("/") || ~e.lastIndexOf("\\");
  return t === 0 ? e : ~t === e.length - 1 ? T7(e.substring(0, e.length - 1)) : e.substr(~t + 1);
}
var KC = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g, o0 = class {
  static hasCaptures(e) {
    return e === null ? !1 : (KC.lastIndex = 0, KC.test(e));
  }
  static replaceCaptures(e, t, n) {
    return e.replace(KC, (r, i, o, s) => {
      let a = n[parseInt(i || o, 10)];
      if (a) {
        let c = t.substring(a.start, a.end);
        for (; c[0] === "."; )
          c = c.substring(1);
        switch (s) {
          case "downcase":
            return c.toLowerCase();
          case "upcase":
            return c.toUpperCase();
          default:
            return c;
        }
      } else
        return r;
    });
  }
};
function A7(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function M7(e, t) {
  if (e === null && t === null)
    return 0;
  if (!e)
    return -1;
  if (!t)
    return 1;
  let n = e.length, r = t.length;
  if (n === r) {
    for (let i = 0; i < n; i++) {
      let o = A7(e[i], t[i]);
      if (o !== 0)
        return o;
    }
    return 0;
  }
  return n - r;
}
function dL(e) {
  return !!(/^#[0-9a-f]{6}$/i.test(e) || /^#[0-9a-f]{8}$/i.test(e) || /^#[0-9a-f]{3}$/i.test(e) || /^#[0-9a-f]{4}$/i.test(e));
}
function N7(e) {
  return e.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var R7 = class {
  constructor(e) {
    this.fn = e;
  }
  cache = /* @__PURE__ */ new Map();
  get(e) {
    if (this.cache.has(e))
      return this.cache.get(e);
    const t = this.fn(e);
    return this.cache.set(e, t), t;
  }
}, Qb = class {
  constructor(e, t, n) {
    this._colorMap = e, this._defaults = t, this._root = n;
  }
  static createFromRawTheme(e, t) {
    return this.createFromParsedTheme(o_e(e), t);
  }
  static createFromParsedTheme(e, t) {
    return a_e(e, t);
  }
  _cachedMatchRoot = new R7(
    (e) => this._root.match(e)
  );
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  getDefaults() {
    return this._defaults;
  }
  match(e) {
    if (e === null)
      return this._defaults;
    const t = e.scopeName, r = this._cachedMatchRoot.get(t).find(
      (i) => r_e(e.parent, i.parentScopes)
    );
    return r ? new O7(
      r.fontStyle,
      r.foreground,
      r.background
    ) : null;
  }
}, ZC = class Z0 {
  constructor(t, n) {
    this.parent = t, this.scopeName = n;
  }
  static push(t, n) {
    for (const r of n)
      t = new Z0(t, r);
    return t;
  }
  static from(...t) {
    let n = null;
    for (let r = 0; r < t.length; r++)
      n = new Z0(n, t[r]);
    return n;
  }
  push(t) {
    return new Z0(this, t);
  }
  getSegments() {
    let t = this;
    const n = [];
    for (; t; )
      n.push(t.scopeName), t = t.parent;
    return n.reverse(), n;
  }
  toString() {
    return this.getSegments().join(" ");
  }
  extends(t) {
    return this === t ? !0 : this.parent === null ? !1 : this.parent.extends(t);
  }
  getExtensionIfDefined(t) {
    const n = [];
    let r = this;
    for (; r && r !== t; )
      n.push(r.scopeName), r = r.parent;
    return r === t ? n.reverse() : void 0;
  }
};
function r_e(e, t) {
  if (t.length === 0)
    return !0;
  for (let n = 0; n < t.length; n++) {
    let r = t[n], i = !1;
    if (r === ">") {
      if (n === t.length - 1)
        return !1;
      r = t[++n], i = !0;
    }
    for (; e && !i_e(e.scopeName, r); ) {
      if (i)
        return !1;
      e = e.parent;
    }
    if (!e)
      return !1;
    e = e.parent;
  }
  return !0;
}
function i_e(e, t) {
  return t === e || e.startsWith(t) && e[t.length] === ".";
}
var O7 = class {
  constructor(e, t, n) {
    this.fontStyle = e, this.foregroundId = t, this.backgroundId = n;
  }
};
function o_e(e) {
  if (!e)
    return [];
  if (!e.settings || !Array.isArray(e.settings))
    return [];
  let t = e.settings, n = [], r = 0;
  for (let i = 0, o = t.length; i < o; i++) {
    let s = t[i];
    if (!s.settings)
      continue;
    let a;
    if (typeof s.scope == "string") {
      let h = s.scope;
      h = h.replace(/^[,]+/, ""), h = h.replace(/[,]+$/, ""), a = h.split(",");
    } else Array.isArray(s.scope) ? a = s.scope : a = [""];
    let c = -1;
    if (typeof s.settings.fontStyle == "string") {
      c = 0;
      let h = s.settings.fontStyle.split(" ");
      for (let m = 0, g = h.length; m < g; m++)
        switch (h[m]) {
          case "italic":
            c = c | 1;
            break;
          case "bold":
            c = c | 2;
            break;
          case "underline":
            c = c | 4;
            break;
          case "strikethrough":
            c = c | 8;
            break;
        }
    }
    let u = null;
    typeof s.settings.foreground == "string" && dL(s.settings.foreground) && (u = s.settings.foreground);
    let f = null;
    typeof s.settings.background == "string" && dL(s.settings.background) && (f = s.settings.background);
    for (let h = 0, m = a.length; h < m; h++) {
      let b = a[h].trim().split(" "), x = b[b.length - 1], w = null;
      b.length > 1 && (w = b.slice(0, b.length - 1), w.reverse()), n[r++] = new s_e(
        x,
        w,
        i,
        c,
        u,
        f
      );
    }
  }
  return n;
}
var s_e = class {
  constructor(e, t, n, r, i, o) {
    this.scope = e, this.parentScopes = t, this.index = n, this.fontStyle = r, this.foreground = i, this.background = o;
  }
}, vi = /* @__PURE__ */ ((e) => (e[e.NotSet = -1] = "NotSet", e[e.None = 0] = "None", e[e.Italic = 1] = "Italic", e[e.Bold = 2] = "Bold", e[e.Underline = 4] = "Underline", e[e.Strikethrough = 8] = "Strikethrough", e))(vi || {});
function a_e(e, t) {
  e.sort((c, u) => {
    let f = A7(c.scope, u.scope);
    return f !== 0 || (f = M7(c.parentScopes, u.parentScopes), f !== 0) ? f : c.index - u.index;
  });
  let n = 0, r = "#000000", i = "#ffffff";
  for (; e.length >= 1 && e[0].scope === ""; ) {
    let c = e.shift();
    c.fontStyle !== -1 && (n = c.fontStyle), c.foreground !== null && (r = c.foreground), c.background !== null && (i = c.background);
  }
  let o = new l_e(t), s = new O7(n, o.getId(r), o.getId(i)), a = new u_e(new pT(0, null, -1, 0, 0), []);
  for (let c = 0, u = e.length; c < u; c++) {
    let f = e[c];
    a.insert(0, f.scope, f.parentScopes, f.fontStyle, o.getId(f.foreground), o.getId(f.background));
  }
  return new Qb(o, s, a);
}
var l_e = class {
  _isFrozen;
  _lastColorId;
  _id2color;
  _color2id;
  constructor(e) {
    if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(e)) {
      this._isFrozen = !0;
      for (let t = 0, n = e.length; t < n; t++)
        this._color2id[e[t]] = t, this._id2color[t] = e[t];
    } else
      this._isFrozen = !1;
  }
  getId(e) {
    if (e === null)
      return 0;
    e = e.toUpperCase();
    let t = this._color2id[e];
    if (t)
      return t;
    if (this._isFrozen)
      throw new Error(`Missing color in color map - ${e}`);
    return t = ++this._lastColorId, this._color2id[e] = t, this._id2color[t] = e, t;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}, c_e = Object.freeze([]), pT = class P7 {
  scopeDepth;
  parentScopes;
  fontStyle;
  foreground;
  background;
  constructor(t, n, r, i, o) {
    this.scopeDepth = t, this.parentScopes = n || c_e, this.fontStyle = r, this.foreground = i, this.background = o;
  }
  clone() {
    return new P7(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
  }
  static cloneArr(t) {
    let n = [];
    for (let r = 0, i = t.length; r < i; r++)
      n[r] = t[r].clone();
    return n;
  }
  acceptOverwrite(t, n, r, i) {
    this.scopeDepth > t ? console.log("how did this happen?") : this.scopeDepth = t, n !== -1 && (this.fontStyle = n), r !== 0 && (this.foreground = r), i !== 0 && (this.background = i);
  }
}, u_e = class mT {
  constructor(t, n = [], r = {}) {
    this._mainRule = t, this._children = r, this._rulesWithParentScopes = n;
  }
  _rulesWithParentScopes;
  static _cmpBySpecificity(t, n) {
    if (t.scopeDepth !== n.scopeDepth)
      return n.scopeDepth - t.scopeDepth;
    let r = 0, i = 0;
    for (; t.parentScopes[r] === ">" && r++, n.parentScopes[i] === ">" && i++, !(r >= t.parentScopes.length || i >= n.parentScopes.length); ) {
      const o = n.parentScopes[i].length - t.parentScopes[r].length;
      if (o !== 0)
        return o;
      r++, i++;
    }
    return n.parentScopes.length - t.parentScopes.length;
  }
  match(t) {
    if (t !== "") {
      let r = t.indexOf("."), i, o;
      if (r === -1 ? (i = t, o = "") : (i = t.substring(0, r), o = t.substring(r + 1)), this._children.hasOwnProperty(i))
        return this._children[i].match(o);
    }
    const n = this._rulesWithParentScopes.concat(this._mainRule);
    return n.sort(mT._cmpBySpecificity), n;
  }
  insert(t, n, r, i, o, s) {
    if (n === "") {
      this._doInsertHere(t, r, i, o, s);
      return;
    }
    let a = n.indexOf("."), c, u;
    a === -1 ? (c = n, u = "") : (c = n.substring(0, a), u = n.substring(a + 1));
    let f;
    this._children.hasOwnProperty(c) ? f = this._children[c] : (f = new mT(this._mainRule.clone(), pT.cloneArr(this._rulesWithParentScopes)), this._children[c] = f), f.insert(t + 1, u, r, i, o, s);
  }
  _doInsertHere(t, n, r, i, o) {
    if (n === null) {
      this._mainRule.acceptOverwrite(t, r, i, o);
      return;
    }
    for (let s = 0, a = this._rulesWithParentScopes.length; s < a; s++) {
      let c = this._rulesWithParentScopes[s];
      if (M7(c.parentScopes, n) === 0) {
        c.acceptOverwrite(t, r, i, o);
        return;
      }
    }
    r === -1 && (r = this._mainRule.fontStyle), i === 0 && (i = this._mainRule.foreground), o === 0 && (o = this._mainRule.background), this._rulesWithParentScopes.push(new pT(t, n, r, i, o));
  }
}, Ch = class Io {
  static toBinaryStr(t) {
    return t.toString(2).padStart(32, "0");
  }
  static print(t) {
    const n = Io.getLanguageId(t), r = Io.getTokenType(t), i = Io.getFontStyle(t), o = Io.getForeground(t), s = Io.getBackground(t);
    console.log({
      languageId: n,
      tokenType: r,
      fontStyle: i,
      foreground: o,
      background: s
    });
  }
  static getLanguageId(t) {
    return (t & 255) >>> 0;
  }
  static getTokenType(t) {
    return (t & 768) >>> 8;
  }
  static containsBalancedBrackets(t) {
    return (t & 1024) !== 0;
  }
  static getFontStyle(t) {
    return (t & 30720) >>> 11;
  }
  static getForeground(t) {
    return (t & 16744448) >>> 15;
  }
  static getBackground(t) {
    return (t & 4278190080) >>> 24;
  }
  /**
   * Updates the fields in `metadata`.
   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.
   */
  static set(t, n, r, i, o, s, a) {
    let c = Io.getLanguageId(t), u = Io.getTokenType(t), f = Io.containsBalancedBrackets(t) ? 1 : 0, h = Io.getFontStyle(t), m = Io.getForeground(t), g = Io.getBackground(t);
    return n !== 0 && (c = n), r !== 8 && (u = r), i !== null && (f = i ? 1 : 0), o !== -1 && (h = o), s !== 0 && (m = s), a !== 0 && (g = a), (c << 0 | u << 8 | f << 10 | h << 11 | m << 15 | g << 24) >>> 0;
  }
};
function ex(e, t) {
  const n = [], r = d_e(e);
  let i = r.next();
  for (; i !== null; ) {
    let c = 0;
    if (i.length === 2 && i.charAt(1) === ":") {
      switch (i.charAt(0)) {
        case "R":
          c = 1;
          break;
        case "L":
          c = -1;
          break;
        default:
          console.log(`Unknown priority ${i} in scope selector`);
      }
      i = r.next();
    }
    let u = s();
    if (n.push({ matcher: u, priority: c }), i !== ",")
      break;
    i = r.next();
  }
  return n;
  function o() {
    if (i === "-") {
      i = r.next();
      const c = o();
      return (u) => !!c && !c(u);
    }
    if (i === "(") {
      i = r.next();
      const c = a();
      return i === ")" && (i = r.next()), c;
    }
    if (fL(i)) {
      const c = [];
      do
        c.push(i), i = r.next();
      while (fL(i));
      return (u) => t(c, u);
    }
    return null;
  }
  function s() {
    const c = [];
    let u = o();
    for (; u; )
      c.push(u), u = o();
    return (f) => c.every((h) => h(f));
  }
  function a() {
    const c = [];
    let u = s();
    for (; u && (c.push(u), i === "|" || i === ","); ) {
      do
        i = r.next();
      while (i === "|" || i === ",");
      u = s();
    }
    return (f) => c.some((h) => h(f));
  }
}
function fL(e) {
  return !!e && !!e.match(/[\w\.:]+/);
}
function d_e(e) {
  let t = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, n = t.exec(e);
  return {
    next: () => {
      if (!n)
        return null;
      const r = n[0];
      return n = t.exec(e), r;
    }
  };
}
function D7(e) {
  typeof e.dispose == "function" && e.dispose();
}
var Cg = class {
  constructor(e) {
    this.scopeName = e;
  }
  toKey() {
    return this.scopeName;
  }
}, f_e = class {
  constructor(e, t) {
    this.scopeName = e, this.ruleName = t;
  }
  toKey() {
    return `${this.scopeName}#${this.ruleName}`;
  }
}, h_e = class {
  _references = [];
  _seenReferenceKeys = /* @__PURE__ */ new Set();
  get references() {
    return this._references;
  }
  visitedRule = /* @__PURE__ */ new Set();
  add(e) {
    const t = e.toKey();
    this._seenReferenceKeys.has(t) || (this._seenReferenceKeys.add(t), this._references.push(e));
  }
}, p_e = class {
  constructor(e, t) {
    this.repo = e, this.initialScopeName = t, this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new Cg(this.initialScopeName)];
  }
  seenFullScopeRequests = /* @__PURE__ */ new Set();
  seenPartialScopeRequests = /* @__PURE__ */ new Set();
  Q;
  processQueue() {
    const e = this.Q;
    this.Q = [];
    const t = new h_e();
    for (const n of e)
      m_e(n, this.initialScopeName, this.repo, t);
    for (const n of t.references)
      if (n instanceof Cg) {
        if (this.seenFullScopeRequests.has(n.scopeName))
          continue;
        this.seenFullScopeRequests.add(n.scopeName), this.Q.push(n);
      } else {
        if (this.seenFullScopeRequests.has(n.scopeName) || this.seenPartialScopeRequests.has(n.toKey()))
          continue;
        this.seenPartialScopeRequests.add(n.toKey()), this.Q.push(n);
      }
  }
};
function m_e(e, t, n, r) {
  const i = n.lookup(e.scopeName);
  if (!i) {
    if (e.scopeName === t)
      throw new Error(`No grammar provided for <${t}>`);
    return;
  }
  const o = n.lookup(t);
  e instanceof Cg ? Y0({ baseGrammar: o, selfGrammar: i }, r) : gT(
    e.ruleName,
    { baseGrammar: o, selfGrammar: i, repository: i.repository },
    r
  );
  const s = n.injections(e.scopeName);
  if (s)
    for (const a of s)
      r.add(new Cg(a));
}
function gT(e, t, n) {
  if (t.repository && t.repository[e]) {
    const r = t.repository[e];
    tx([r], t, n);
  }
}
function Y0(e, t) {
  e.selfGrammar.patterns && Array.isArray(e.selfGrammar.patterns) && tx(
    e.selfGrammar.patterns,
    { ...e, repository: e.selfGrammar.repository },
    t
  ), e.selfGrammar.injections && tx(
    Object.values(e.selfGrammar.injections),
    { ...e, repository: e.selfGrammar.repository },
    t
  );
}
function tx(e, t, n) {
  for (const r of e) {
    if (n.visitedRule.has(r))
      continue;
    n.visitedRule.add(r);
    const i = r.repository ? _7({}, t.repository, r.repository) : t.repository;
    Array.isArray(r.patterns) && tx(r.patterns, { ...t, repository: i }, n);
    const o = r.include;
    if (!o)
      continue;
    const s = I7(o);
    switch (s.kind) {
      case 0:
        Y0({ ...t, selfGrammar: t.baseGrammar }, n);
        break;
      case 1:
        Y0(t, n);
        break;
      case 2:
        gT(s.ruleName, { ...t, repository: i }, n);
        break;
      case 3:
      case 4:
        const a = s.scopeName === t.selfGrammar.scopeName ? t.selfGrammar : s.scopeName === t.baseGrammar.scopeName ? t.baseGrammar : void 0;
        if (a) {
          const c = { baseGrammar: t.baseGrammar, selfGrammar: a, repository: i };
          s.kind === 4 ? gT(s.ruleName, c, n) : Y0(c, n);
        } else
          s.kind === 4 ? n.add(new f_e(s.scopeName, s.ruleName)) : n.add(new Cg(s.scopeName));
        break;
    }
  }
}
var g_e = class {
  kind = 0;
}, y_e = class {
  kind = 1;
}, v_e = class {
  constructor(e) {
    this.ruleName = e;
  }
  kind = 2;
}, b_e = class {
  constructor(e) {
    this.scopeName = e;
  }
  kind = 3;
}, x_e = class {
  constructor(e, t) {
    this.scopeName = e, this.ruleName = t;
  }
  kind = 4;
};
function I7(e) {
  if (e === "$base")
    return new g_e();
  if (e === "$self")
    return new y_e();
  const t = e.indexOf("#");
  if (t === -1)
    return new b_e(e);
  if (t === 0)
    return new v_e(e.substring(1));
  {
    const n = e.substring(0, t), r = e.substring(t + 1);
    return new x_e(n, r);
  }
}
var w_e = /\\(\d+)/, hL = /\\(\d+)/g, S_e = -1, j7 = -2;
var yy = class {
  $location;
  id;
  _nameIsCapturing;
  _name;
  _contentNameIsCapturing;
  _contentName;
  constructor(e, t, n, r) {
    this.$location = e, this.id = t, this._name = n || null, this._nameIsCapturing = o0.hasCaptures(this._name), this._contentName = r || null, this._contentNameIsCapturing = o0.hasCaptures(this._contentName);
  }
  get debugName() {
    const e = this.$location ? `${T7(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${e}`;
  }
  getName(e, t) {
    return !this._nameIsCapturing || this._name === null || e === null || t === null ? this._name : o0.replaceCaptures(this._name, e, t);
  }
  getContentName(e, t) {
    return !this._contentNameIsCapturing || this._contentName === null ? this._contentName : o0.replaceCaptures(this._contentName, e, t);
  }
}, k_e = class extends yy {
  retokenizeCapturedWithRuleId;
  constructor(e, t, n, r, i) {
    super(e, t, n, r), this.retokenizeCapturedWithRuleId = i;
  }
  dispose() {
  }
  collectPatterns(e, t) {
    throw new Error("Not supported!");
  }
  compile(e, t) {
    throw new Error("Not supported!");
  }
  compileAG(e, t, n, r) {
    throw new Error("Not supported!");
  }
}, C_e = class extends yy {
  _match;
  captures;
  _cachedCompiledPatterns;
  constructor(e, t, n, r, i) {
    super(e, t, n, null), this._match = new Eg(r, this.id), this.captures = i, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugMatchRegExp() {
    return `${this._match.source}`;
  }
  collectPatterns(e, t) {
    t.push(this._match);
  }
  compile(e, t) {
    return this._getCachedCompiledPatterns(e).compile(e);
  }
  compileAG(e, t, n, r) {
    return this._getCachedCompiledPatterns(e).compileAG(e, n, r);
  }
  _getCachedCompiledPatterns(e) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new _g(), this.collectPatterns(e, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, pL = class extends yy {
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(e, t, n, r, i) {
    super(e, t, n, r), this.patterns = i.patterns, this.hasMissingPatterns = i.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  collectPatterns(e, t) {
    for (const n of this.patterns)
      e.getRule(n).collectPatterns(e, t);
  }
  compile(e, t) {
    return this._getCachedCompiledPatterns(e).compile(e);
  }
  compileAG(e, t, n, r) {
    return this._getCachedCompiledPatterns(e).compileAG(e, n, r);
  }
  _getCachedCompiledPatterns(e) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new _g(), this.collectPatterns(e, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, yT = class extends yy {
  _begin;
  beginCaptures;
  _end;
  endHasBackReferences;
  endCaptures;
  applyEndPatternLast;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(e, t, n, r, i, o, s, a, c, u) {
    super(e, t, n, r), this._begin = new Eg(i, this.id), this.beginCaptures = o, this._end = new Eg(s || "", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = a, this.applyEndPatternLast = c || !1, this.patterns = u.patterns, this.hasMissingPatterns = u.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugEndRegExp() {
    return `${this._end.source}`;
  }
  getEndWithResolvedBackReferences(e, t) {
    return this._end.resolveBackReferences(e, t);
  }
  collectPatterns(e, t) {
    t.push(this._begin);
  }
  compile(e, t) {
    return this._getCachedCompiledPatterns(e, t).compile(e);
  }
  compileAG(e, t, n, r) {
    return this._getCachedCompiledPatterns(e, t).compileAG(e, n, r);
  }
  _getCachedCompiledPatterns(e, t) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new _g();
      for (const n of this.patterns)
        e.getRule(n).collectPatterns(e, this._cachedCompiledPatterns);
      this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
    }
    return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, t) : this._cachedCompiledPatterns.setSource(0, t)), this._cachedCompiledPatterns;
  }
}, nx = class extends yy {
  _begin;
  beginCaptures;
  whileCaptures;
  _while;
  whileHasBackReferences;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  _cachedCompiledWhilePatterns;
  constructor(e, t, n, r, i, o, s, a, c) {
    super(e, t, n, r), this._begin = new Eg(i, this.id), this.beginCaptures = o, this.whileCaptures = a, this._while = new Eg(s, j7), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = c.patterns, this.hasMissingPatterns = c.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugWhileRegExp() {
    return `${this._while.source}`;
  }
  getWhileWithResolvedBackReferences(e, t) {
    return this._while.resolveBackReferences(e, t);
  }
  collectPatterns(e, t) {
    t.push(this._begin);
  }
  compile(e, t) {
    return this._getCachedCompiledPatterns(e).compile(e);
  }
  compileAG(e, t, n, r) {
    return this._getCachedCompiledPatterns(e).compileAG(e, n, r);
  }
  _getCachedCompiledPatterns(e) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new _g();
      for (const t of this.patterns)
        e.getRule(t).collectPatterns(e, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
  compileWhile(e, t) {
    return this._getCachedCompiledWhilePatterns(e, t).compile(e);
  }
  compileWhileAG(e, t, n, r) {
    return this._getCachedCompiledWhilePatterns(e, t).compileAG(e, n, r);
  }
  _getCachedCompiledWhilePatterns(e, t) {
    return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new _g(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, t || ""), this._cachedCompiledWhilePatterns;
  }
}, z7 = class mi {
  static createCaptureRule(t, n, r, i, o) {
    return t.registerRule((s) => new k_e(n, s, r, i, o));
  }
  static getCompiledRuleId(t, n, r) {
    return t.id || n.registerRule((i) => {
      if (t.id = i, t.match)
        return new C_e(
          t.$vscodeTextmateLocation,
          t.id,
          t.name,
          t.match,
          mi._compileCaptures(t.captures, n, r)
        );
      if (typeof t.begin > "u") {
        t.repository && (r = _7({}, r, t.repository));
        let o = t.patterns;
        return typeof o > "u" && t.include && (o = [{ include: t.include }]), new pL(
          t.$vscodeTextmateLocation,
          t.id,
          t.name,
          t.contentName,
          mi._compilePatterns(o, n, r)
        );
      }
      return t.while ? new nx(
        t.$vscodeTextmateLocation,
        t.id,
        t.name,
        t.contentName,
        t.begin,
        mi._compileCaptures(t.beginCaptures || t.captures, n, r),
        t.while,
        mi._compileCaptures(t.whileCaptures || t.captures, n, r),
        mi._compilePatterns(t.patterns, n, r)
      ) : new yT(
        t.$vscodeTextmateLocation,
        t.id,
        t.name,
        t.contentName,
        t.begin,
        mi._compileCaptures(t.beginCaptures || t.captures, n, r),
        t.end,
        mi._compileCaptures(t.endCaptures || t.captures, n, r),
        t.applyEndPatternLast,
        mi._compilePatterns(t.patterns, n, r)
      );
    }), t.id;
  }
  static _compileCaptures(t, n, r) {
    let i = [];
    if (t) {
      let o = 0;
      for (const s in t) {
        if (s === "$vscodeTextmateLocation")
          continue;
        const a = parseInt(s, 10);
        a > o && (o = a);
      }
      for (let s = 0; s <= o; s++)
        i[s] = null;
      for (const s in t) {
        if (s === "$vscodeTextmateLocation")
          continue;
        const a = parseInt(s, 10);
        let c = 0;
        t[s].patterns && (c = mi.getCompiledRuleId(t[s], n, r)), i[a] = mi.createCaptureRule(n, t[s].$vscodeTextmateLocation, t[s].name, t[s].contentName, c);
      }
    }
    return i;
  }
  static _compilePatterns(t, n, r) {
    let i = [];
    if (t)
      for (let o = 0, s = t.length; o < s; o++) {
        const a = t[o];
        let c = -1;
        if (a.include) {
          const u = I7(a.include);
          switch (u.kind) {
            case 0:
            case 1:
              c = mi.getCompiledRuleId(r[a.include], n, r);
              break;
            case 2:
              let f = r[u.ruleName];
              f && (c = mi.getCompiledRuleId(f, n, r));
              break;
            case 3:
            case 4:
              const h = u.scopeName, m = u.kind === 4 ? u.ruleName : null, g = n.getExternalGrammar(h, r);
              if (g)
                if (m) {
                  let b = g.repository[m];
                  b && (c = mi.getCompiledRuleId(b, n, g.repository));
                } else
                  c = mi.getCompiledRuleId(g.repository.$self, n, g.repository);
              break;
          }
        } else
          c = mi.getCompiledRuleId(a, n, r);
        if (c !== -1) {
          const u = n.getRule(c);
          let f = !1;
          if ((u instanceof pL || u instanceof yT || u instanceof nx) && u.hasMissingPatterns && u.patterns.length === 0 && (f = !0), f)
            continue;
          i.push(c);
        }
      }
    return {
      patterns: i,
      hasMissingPatterns: (t ? t.length : 0) !== i.length
    };
  }
}, Eg = class L7 {
  source;
  ruleId;
  hasAnchor;
  hasBackReferences;
  _anchorCache;
  constructor(t, n) {
    if (t && typeof t == "string") {
      const r = t.length;
      let i = 0, o = [], s = !1;
      for (let a = 0; a < r; a++)
        if (t.charAt(a) === "\\" && a + 1 < r) {
          const u = t.charAt(a + 1);
          u === "z" ? (o.push(t.substring(i, a)), o.push("$(?!\\n)(?<!\\n)"), i = a + 2) : (u === "A" || u === "G") && (s = !0), a++;
        }
      this.hasAnchor = s, i === 0 ? this.source = t : (o.push(t.substring(i, r)), this.source = o.join(""));
    } else
      this.hasAnchor = !1, this.source = t;
    this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = n, typeof this.source == "string" ? this.hasBackReferences = w_e.test(this.source) : this.hasBackReferences = !1;
  }
  clone() {
    return new L7(this.source, this.ruleId);
  }
  setSource(t) {
    this.source !== t && (this.source = t, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
  }
  resolveBackReferences(t, n) {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let r = n.map((i) => t.substring(i.start, i.end));
    return hL.lastIndex = 0, this.source.replace(hL, (i, o) => N7(r[parseInt(o, 10)] || ""));
  }
  _buildAnchorCache() {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let t = [], n = [], r = [], i = [], o, s, a, c;
    for (o = 0, s = this.source.length; o < s; o++)
      a = this.source.charAt(o), t[o] = a, n[o] = a, r[o] = a, i[o] = a, a === "\\" && o + 1 < s && (c = this.source.charAt(o + 1), c === "A" ? (t[o + 1] = "", n[o + 1] = "", r[o + 1] = "A", i[o + 1] = "A") : c === "G" ? (t[o + 1] = "", n[o + 1] = "G", r[o + 1] = "", i[o + 1] = "G") : (t[o + 1] = c, n[o + 1] = c, r[o + 1] = c, i[o + 1] = c), o++);
    return {
      A0_G0: t.join(""),
      A0_G1: n.join(""),
      A1_G0: r.join(""),
      A1_G1: i.join("")
    };
  }
  resolveAnchors(t, n) {
    return !this.hasAnchor || !this._anchorCache || typeof this.source != "string" ? this.source : t ? n ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : n ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0;
  }
}, _g = class {
  _items;
  _hasAnchors;
  _cached;
  _anchorCache;
  constructor() {
    this._items = [], this._hasAnchors = !1, this._cached = null, this._anchorCache = {
      A0_G0: null,
      A0_G1: null,
      A1_G0: null,
      A1_G1: null
    };
  }
  dispose() {
    this._disposeCaches();
  }
  _disposeCaches() {
    this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
  }
  push(e) {
    this._items.push(e), this._hasAnchors = this._hasAnchors || e.hasAnchor;
  }
  unshift(e) {
    this._items.unshift(e), this._hasAnchors = this._hasAnchors || e.hasAnchor;
  }
  length() {
    return this._items.length;
  }
  setSource(e, t) {
    this._items[e].source !== t && (this._disposeCaches(), this._items[e].setSource(t));
  }
  compile(e) {
    if (!this._cached) {
      let t = this._items.map((n) => n.source);
      this._cached = new mL(e, t, this._items.map((n) => n.ruleId));
    }
    return this._cached;
  }
  compileAG(e, t, n) {
    return this._hasAnchors ? t ? n ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(e, t, n)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(e, t, n)), this._anchorCache.A1_G0) : n ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(e, t, n)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(e, t, n)), this._anchorCache.A0_G0) : this.compile(e);
  }
  _resolveAnchors(e, t, n) {
    let r = this._items.map((i) => i.resolveAnchors(t, n));
    return new mL(e, r, this._items.map((i) => i.ruleId));
  }
}, mL = class {
  constructor(e, t, n) {
    this.regExps = t, this.rules = n, this.scanner = e.createOnigScanner(t);
  }
  scanner;
  dispose() {
    typeof this.scanner.dispose == "function" && this.scanner.dispose();
  }
  toString() {
    const e = [];
    for (let t = 0, n = this.rules.length; t < n; t++)
      e.push("   - " + this.rules[t] + ": " + this.regExps[t]);
    return e.join(`
`);
  }
  findNextMatchSync(e, t, n) {
    const r = this.scanner.findNextMatchSync(e, t, n);
    return r ? {
      ruleId: this.rules[r.index],
      captureIndices: r.captureIndices
    } : null;
  }
}, YC = class {
  constructor(e, t) {
    this.languageId = e, this.tokenType = t;
  }
}, E_e = class vT {
  _defaultAttributes;
  _embeddedLanguagesMatcher;
  constructor(t, n) {
    this._defaultAttributes = new YC(
      t,
      8
      /* NotSet */
    ), this._embeddedLanguagesMatcher = new __e(Object.entries(n || {}));
  }
  getDefaultAttributes() {
    return this._defaultAttributes;
  }
  getBasicScopeAttributes(t) {
    return t === null ? vT._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(t);
  }
  static _NULL_SCOPE_METADATA = new YC(0, 0);
  _getBasicScopeAttributes = new R7((t) => {
    const n = this._scopeToLanguage(t), r = this._toStandardTokenType(t);
    return new YC(n, r);
  });
  /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */
  _scopeToLanguage(t) {
    return this._embeddedLanguagesMatcher.match(t) || 0;
  }
  _toStandardTokenType(t) {
    const n = t.match(vT.STANDARD_TOKEN_TYPE_REGEXP);
    if (!n)
      return 8;
    switch (n[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "meta.embedded":
        return 0;
    }
    throw new Error("Unexpected match for standard token type!");
  }
  static STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/;
}, __e = class {
  values;
  scopesRegExp;
  constructor(e) {
    if (e.length === 0)
      this.values = null, this.scopesRegExp = null;
    else {
      this.values = new Map(e);
      const t = e.map(
        ([n, r]) => N7(n)
      );
      t.sort(), t.reverse(), this.scopesRegExp = new RegExp(
        `^((${t.join(")|(")}))($|\\.)`,
        ""
      );
    }
  }
  match(e) {
    if (!this.scopesRegExp)
      return;
    const t = e.match(this.scopesRegExp);
    if (t)
      return this.values.get(t[1]);
  }
};
typeof process < "u" && process.env.VSCODE_TEXTMATE_DEBUG;
var gL = class {
  constructor(e, t) {
    this.stack = e, this.stoppedEarly = t;
  }
};
function B7(e, t, n, r, i, o, s, a) {
  const c = t.content.length;
  let u = !1, f = -1;
  if (s) {
    const g = T_e(
      e,
      t,
      n,
      r,
      i,
      o
    );
    i = g.stack, r = g.linePos, n = g.isFirstLine, f = g.anchorPosition;
  }
  const h = Date.now();
  for (; !u; ) {
    if (a !== 0 && Date.now() - h > a)
      return new gL(i, !0);
    m();
  }
  return new gL(i, !1);
  function m() {
    const g = A_e(
      e,
      t,
      n,
      r,
      i,
      f
    );
    if (!g) {
      o.produce(i, c), u = !0;
      return;
    }
    const b = g.captureIndices, x = g.matchedRuleId, w = b && b.length > 0 ? b[0].end > r : !1;
    if (x === S_e) {
      const S = i.getRule(e);
      o.produce(i, b[0].start), i = i.withContentNameScopesList(i.nameScopesList), _m(
        e,
        t,
        n,
        i,
        o,
        S.endCaptures,
        b
      ), o.produce(i, b[0].end);
      const _ = i;
      if (i = i.parent, f = _.getAnchorPos(), !w && _.getEnterPos() === r) {
        i = _, o.produce(i, c), u = !0;
        return;
      }
    } else {
      const S = e.getRule(x);
      o.produce(i, b[0].start);
      const _ = i, M = S.getName(t.content, b), N = i.contentNameScopesList.pushAttributed(
        M,
        e
      );
      if (i = i.push(
        x,
        r,
        f,
        b[0].end === c,
        null,
        N,
        N
      ), S instanceof yT) {
        const D = S;
        _m(
          e,
          t,
          n,
          i,
          o,
          D.beginCaptures,
          b
        ), o.produce(i, b[0].end), f = b[0].end;
        const j = D.getContentName(
          t.content,
          b
        ), O = N.pushAttributed(
          j,
          e
        );
        if (i = i.withContentNameScopesList(O), D.endHasBackReferences && (i = i.withEndRule(
          D.getEndWithResolvedBackReferences(
            t.content,
            b
          )
        )), !w && _.hasSameRuleAs(i)) {
          i = i.pop(), o.produce(i, c), u = !0;
          return;
        }
      } else if (S instanceof nx) {
        const D = S;
        _m(
          e,
          t,
          n,
          i,
          o,
          D.beginCaptures,
          b
        ), o.produce(i, b[0].end), f = b[0].end;
        const j = D.getContentName(
          t.content,
          b
        ), O = N.pushAttributed(
          j,
          e
        );
        if (i = i.withContentNameScopesList(O), D.whileHasBackReferences && (i = i.withEndRule(
          D.getWhileWithResolvedBackReferences(
            t.content,
            b
          )
        )), !w && _.hasSameRuleAs(i)) {
          i = i.pop(), o.produce(i, c), u = !0;
          return;
        }
      } else if (_m(
        e,
        t,
        n,
        i,
        o,
        S.captures,
        b
      ), o.produce(i, b[0].end), i = i.pop(), !w) {
        i = i.safePop(), o.produce(i, c), u = !0;
        return;
      }
    }
    b[0].end > r && (r = b[0].end, n = !1);
  }
}
function T_e(e, t, n, r, i, o) {
  let s = i.beginRuleCapturedEOL ? 0 : -1;
  const a = [];
  for (let c = i; c; c = c.pop()) {
    const u = c.getRule(e);
    u instanceof nx && a.push({
      rule: u,
      stack: c
    });
  }
  for (let c = a.pop(); c; c = a.pop()) {
    const { ruleScanner: u, findOptions: f } = R_e(c.rule, e, c.stack.endRule, n, r === s), h = u.findNextMatchSync(t, r, f);
    if (h) {
      if (h.ruleId !== j7) {
        i = c.stack.pop();
        break;
      }
      h.captureIndices && h.captureIndices.length && (o.produce(c.stack, h.captureIndices[0].start), _m(e, t, n, c.stack, o, c.rule.whileCaptures, h.captureIndices), o.produce(c.stack, h.captureIndices[0].end), s = h.captureIndices[0].end, h.captureIndices[0].end > r && (r = h.captureIndices[0].end, n = !1));
    } else {
      i = c.stack.pop();
      break;
    }
  }
  return { stack: i, linePos: r, anchorPosition: s, isFirstLine: n };
}
function A_e(e, t, n, r, i, o) {
  const s = M_e(e, t, n, r, i, o), a = e.getInjections();
  if (a.length === 0)
    return s;
  const c = N_e(a, e, t, n, r, i, o);
  if (!c)
    return s;
  if (!s)
    return c;
  const u = s.captureIndices[0].start, f = c.captureIndices[0].start;
  return f < u || c.priorityMatch && f === u ? c : s;
}
function M_e(e, t, n, r, i, o) {
  const s = i.getRule(e), { ruleScanner: a, findOptions: c } = $7(s, e, i.endRule, n, r === o), u = a.findNextMatchSync(t, r, c);
  return u ? {
    captureIndices: u.captureIndices,
    matchedRuleId: u.ruleId
  } : null;
}
function N_e(e, t, n, r, i, o, s) {
  let a = Number.MAX_VALUE, c = null, u, f = 0;
  const h = o.contentNameScopesList.getScopeNames();
  for (let m = 0, g = e.length; m < g; m++) {
    const b = e[m];
    if (!b.matcher(h))
      continue;
    const x = t.getRule(b.ruleId), { ruleScanner: w, findOptions: S } = $7(x, t, null, r, i === s), _ = w.findNextMatchSync(n, i, S);
    if (!_)
      continue;
    const M = _.captureIndices[0].start;
    if (!(M >= a) && (a = M, c = _.captureIndices, u = _.ruleId, f = b.priority, a === i))
      break;
  }
  return c ? {
    priorityMatch: f === -1,
    captureIndices: c,
    matchedRuleId: u
  } : null;
}
function $7(e, t, n, r, i) {
  return {
    ruleScanner: e.compileAG(t, n, r, i),
    findOptions: 0
    /* None */
  };
}
function R_e(e, t, n, r, i) {
  return {
    ruleScanner: e.compileWhileAG(t, n, r, i),
    findOptions: 0
    /* None */
  };
}
function _m(e, t, n, r, i, o, s) {
  if (o.length === 0)
    return;
  const a = t.content, c = Math.min(o.length, s.length), u = [], f = s[0].end;
  for (let h = 0; h < c; h++) {
    const m = o[h];
    if (m === null)
      continue;
    const g = s[h];
    if (g.length === 0)
      continue;
    if (g.start > f)
      break;
    for (; u.length > 0 && u[u.length - 1].endPos <= g.start; )
      i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
    if (u.length > 0 ? i.produceFromScopes(u[u.length - 1].scopes, g.start) : i.produce(r, g.start), m.retokenizeCapturedWithRuleId) {
      const x = m.getName(a, s), w = r.contentNameScopesList.pushAttributed(x, e), S = m.getContentName(a, s), _ = w.pushAttributed(S, e), M = r.push(m.retokenizeCapturedWithRuleId, g.start, -1, !1, null, w, _), N = e.createOnigString(a.substring(0, g.end));
      B7(
        e,
        N,
        n && g.start === 0,
        g.start,
        M,
        i,
        !1,
        /* no time limit */
        0
      ), D7(N);
      continue;
    }
    const b = m.getName(a, s);
    if (b !== null) {
      const w = (u.length > 0 ? u[u.length - 1].scopes : r.contentNameScopesList).pushAttributed(b, e);
      u.push(new O_e(w, g.end));
    }
  }
  for (; u.length > 0; )
    i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
}
var O_e = class {
  scopes;
  endPos;
  constructor(e, t) {
    this.scopes = e, this.endPos = t;
  }
};
function P_e(e, t, n, r, i, o, s, a) {
  return new I_e(
    e,
    t,
    n,
    r,
    i,
    o,
    s,
    a
  );
}
function yL(e, t, n, r, i) {
  const o = ex(t, rx), s = z7.getCompiledRuleId(n, r, i.repository);
  for (const a of o)
    e.push({
      debugSelector: t,
      matcher: a.matcher,
      ruleId: s,
      grammar: i,
      priority: a.priority
    });
}
function rx(e, t) {
  if (t.length < e.length)
    return !1;
  let n = 0;
  return e.every((r) => {
    for (let i = n; i < t.length; i++)
      if (D_e(t[i], r))
        return n = i + 1, !0;
    return !1;
  });
}
function D_e(e, t) {
  if (!e)
    return !1;
  if (e === t)
    return !0;
  const n = t.length;
  return e.length > n && e.substr(0, n) === t && e[n] === ".";
}
var I_e = class {
  constructor(e, t, n, r, i, o, s, a) {
    if (this._rootScopeName = e, this.balancedBracketSelectors = o, this._onigLib = a, this._basicScopeAttributesProvider = new E_e(
      n,
      r
    ), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = s, this._grammar = vL(t, null), this._injections = null, this._tokenTypeMatchers = [], i)
      for (const c of Object.keys(i)) {
        const u = ex(c, rx);
        for (const f of u)
          this._tokenTypeMatchers.push({
            matcher: f.matcher,
            type: i[c]
          });
      }
  }
  _rootId;
  _lastRuleId;
  _ruleId2desc;
  _includedGrammars;
  _grammarRepository;
  _grammar;
  _injections;
  _basicScopeAttributesProvider;
  _tokenTypeMatchers;
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (const e of this._ruleId2desc)
      e && e.dispose();
  }
  createOnigScanner(e) {
    return this._onigLib.createOnigScanner(e);
  }
  createOnigString(e) {
    return this._onigLib.createOnigString(e);
  }
  getMetadataForScope(e) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(e);
  }
  _collectInjections() {
    const e = {
      lookup: (i) => i === this._rootScopeName ? this._grammar : this.getExternalGrammar(i),
      injections: (i) => this._grammarRepository.injections(i)
    }, t = [], n = this._rootScopeName, r = e.lookup(n);
    if (r) {
      const i = r.injections;
      if (i)
        for (let s in i)
          yL(
            t,
            s,
            i[s],
            this,
            r
          );
      const o = this._grammarRepository.injections(n);
      o && o.forEach((s) => {
        const a = this.getExternalGrammar(s);
        if (a) {
          const c = a.injectionSelector;
          c && yL(
            t,
            c,
            a,
            this,
            a
          );
        }
      });
    }
    return t.sort((i, o) => i.priority - o.priority), t;
  }
  getInjections() {
    return this._injections === null && (this._injections = this._collectInjections()), this._injections;
  }
  registerRule(e) {
    const t = ++this._lastRuleId, n = e(t);
    return this._ruleId2desc[t] = n, n;
  }
  getRule(e) {
    return this._ruleId2desc[e];
  }
  getExternalGrammar(e, t) {
    if (this._includedGrammars[e])
      return this._includedGrammars[e];
    if (this._grammarRepository) {
      const n = this._grammarRepository.lookup(e);
      if (n)
        return this._includedGrammars[e] = vL(
          n,
          t && t.$base
        ), this._includedGrammars[e];
    }
  }
  tokenizeLine(e, t, n = 0) {
    const r = this._tokenize(e, t, !1, n);
    return {
      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  tokenizeLine2(e, t, n = 0) {
    const r = this._tokenize(e, t, !0, n);
    return {
      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  _tokenize(e, t, n, r) {
    this._rootId === -1 && (this._rootId = z7.getCompiledRuleId(
      this._grammar.repository.$self,
      this,
      this._grammar.repository
    ), this.getInjections());
    let i;
    if (!t || t === bT.NULL) {
      i = !0;
      const u = this._basicScopeAttributesProvider.getDefaultAttributes(), f = this.themeProvider.getDefaults(), h = Ch.set(
        0,
        u.languageId,
        u.tokenType,
        null,
        f.fontStyle,
        f.foregroundId,
        f.backgroundId
      ), m = this.getRule(this._rootId).getName(
        null,
        null
      );
      let g;
      m ? g = qm.createRootAndLookUpScopeName(
        m,
        h,
        this
      ) : g = qm.createRoot(
        "unknown",
        h
      ), t = new bT(
        null,
        this._rootId,
        -1,
        -1,
        !1,
        null,
        g,
        g
      );
    } else
      i = !1, t.reset();
    e = e + `
`;
    const o = this.createOnigString(e), s = o.content.length, a = new z_e(
      n,
      e,
      this._tokenTypeMatchers,
      this.balancedBracketSelectors
    ), c = B7(
      this,
      o,
      i,
      0,
      t,
      a,
      !0,
      r
    );
    return D7(o), {
      lineLength: s,
      lineTokens: a,
      ruleStack: c.stack,
      stoppedEarly: c.stoppedEarly
    };
  }
};
function vL(e, t) {
  return e = e_e(e), e.repository = e.repository || {}, e.repository.$self = {
    $vscodeTextmateLocation: e.$vscodeTextmateLocation,
    patterns: e.patterns,
    name: e.scopeName
  }, e.repository.$base = t || e.repository.$self, e;
}
var qm = class Bs {
  /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(t, n, r) {
    this.parent = t, this.scopePath = n, this.tokenAttributes = r;
  }
  static fromExtension(t, n) {
    let r = t, i = t?.scopePath ?? null;
    for (const o of n)
      i = ZC.push(i, o.scopeNames), r = new Bs(r, i, o.encodedTokenAttributes);
    return r;
  }
  static createRoot(t, n) {
    return new Bs(null, new ZC(null, t), n);
  }
  static createRootAndLookUpScopeName(t, n, r) {
    const i = r.getMetadataForScope(t), o = new ZC(null, t), s = r.themeProvider.themeMatch(o), a = Bs.mergeAttributes(
      n,
      i,
      s
    );
    return new Bs(null, o, a);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(t) {
    return Bs.equals(this, t);
  }
  static equals(t, n) {
    do {
      if (t === n || !t && !n)
        return !0;
      if (!t || !n || t.scopeName !== n.scopeName || t.tokenAttributes !== n.tokenAttributes)
        return !1;
      t = t.parent, n = n.parent;
    } while (!0);
  }
  static mergeAttributes(t, n, r) {
    let i = -1, o = 0, s = 0;
    return r !== null && (i = r.fontStyle, o = r.foregroundId, s = r.backgroundId), Ch.set(
      t,
      n.languageId,
      n.tokenType,
      null,
      i,
      o,
      s
    );
  }
  pushAttributed(t, n) {
    if (t === null)
      return this;
    if (t.indexOf(" ") === -1)
      return Bs._pushAttributed(this, t, n);
    const r = t.split(/ /g);
    let i = this;
    for (const o of r)
      i = Bs._pushAttributed(i, o, n);
    return i;
  }
  static _pushAttributed(t, n, r) {
    const i = r.getMetadataForScope(n), o = t.scopePath.push(n), s = r.themeProvider.themeMatch(o), a = Bs.mergeAttributes(
      t.tokenAttributes,
      i,
      s
    );
    return new Bs(t, o, a);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(t) {
    const n = [];
    let r = this;
    for (; r && r !== t; )
      n.push({
        encodedTokenAttributes: r.tokenAttributes,
        scopeNames: r.scopePath.getExtensionIfDefined(r.parent?.scopePath ?? null)
      }), r = r.parent;
    return r === t ? n.reverse() : void 0;
  }
}, bT = class Iu {
  /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(t, n, r, i, o, s, a, c) {
    this.parent = t, this.ruleId = n, this.beginRuleCapturedEOL = o, this.endRule = s, this.nameScopesList = a, this.contentNameScopesList = c, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = r, this._anchorPos = i;
  }
  _stackElementBrand = void 0;
  // TODO remove me
  static NULL = new Iu(
    null,
    0,
    0,
    0,
    !1,
    null,
    null,
    null
  );
  /**
   * The position on the current line where this state was pushed.
   * This is relevant only while tokenizing a line, to detect endless loops.
   * Its value is meaningless across lines.
   */
  _enterPos;
  /**
   * The captured anchor position when this stack element was pushed.
   * This is relevant only while tokenizing a line, to restore the anchor position when popping.
   * Its value is meaningless across lines.
   */
  _anchorPos;
  /**
   * The depth of the stack.
   */
  depth;
  equals(t) {
    return t === null ? !1 : Iu._equals(this, t);
  }
  static _equals(t, n) {
    return t === n ? !0 : this._structuralEquals(t, n) ? qm.equals(t.contentNameScopesList, n.contentNameScopesList) : !1;
  }
  /**
   * A structural equals check. Does not take into account `scopes`.
   */
  static _structuralEquals(t, n) {
    do {
      if (t === n || !t && !n)
        return !0;
      if (!t || !n || t.depth !== n.depth || t.ruleId !== n.ruleId || t.endRule !== n.endRule)
        return !1;
      t = t.parent, n = n.parent;
    } while (!0);
  }
  clone() {
    return this;
  }
  static _reset(t) {
    for (; t; )
      t._enterPos = -1, t._anchorPos = -1, t = t.parent;
  }
  reset() {
    Iu._reset(this);
  }
  pop() {
    return this.parent;
  }
  safePop() {
    return this.parent ? this.parent : this;
  }
  push(t, n, r, i, o, s, a) {
    return new Iu(
      this,
      t,
      n,
      r,
      i,
      o,
      s,
      a
    );
  }
  getEnterPos() {
    return this._enterPos;
  }
  getAnchorPos() {
    return this._anchorPos;
  }
  getRule(t) {
    return t.getRule(this.ruleId);
  }
  toString() {
    const t = [];
    return this._writeString(t, 0), "[" + t.join(",") + "]";
  }
  _writeString(t, n) {
    return this.parent && (n = this.parent._writeString(t, n)), t[n++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`, n;
  }
  withContentNameScopesList(t) {
    return this.contentNameScopesList === t ? this : this.parent.push(
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      this.endRule,
      this.nameScopesList,
      t
    );
  }
  withEndRule(t) {
    return this.endRule === t ? this : new Iu(
      this.parent,
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      t,
      this.nameScopesList,
      this.contentNameScopesList
    );
  }
  // Used to warn of endless loops
  hasSameRuleAs(t) {
    let n = this;
    for (; n && n._enterPos === t._enterPos; ) {
      if (n.ruleId === t.ruleId)
        return !0;
      n = n.parent;
    }
    return !1;
  }
  toStateStackFrame() {
    return {
      ruleId: this.ruleId,
      beginRuleCapturedEOL: this.beginRuleCapturedEOL,
      endRule: this.endRule,
      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],
      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []
    };
  }
  static pushFrame(t, n) {
    const r = qm.fromExtension(t?.nameScopesList ?? null, n.nameScopesList);
    return new Iu(
      t,
      n.ruleId,
      n.enterPos ?? -1,
      n.anchorPos ?? -1,
      n.beginRuleCapturedEOL,
      n.endRule,
      r,
      qm.fromExtension(r, n.contentNameScopesList)
    );
  }
}, j_e = class {
  balancedBracketScopes;
  unbalancedBracketScopes;
  allowAny = !1;
  constructor(e, t) {
    this.balancedBracketScopes = e.flatMap(
      (n) => n === "*" ? (this.allowAny = !0, []) : ex(n, rx).map((r) => r.matcher)
    ), this.unbalancedBracketScopes = t.flatMap(
      (n) => ex(n, rx).map((r) => r.matcher)
    );
  }
  get matchesAlways() {
    return this.allowAny && this.unbalancedBracketScopes.length === 0;
  }
  get matchesNever() {
    return this.balancedBracketScopes.length === 0 && !this.allowAny;
  }
  match(e) {
    for (const t of this.unbalancedBracketScopes)
      if (t(e))
        return !1;
    for (const t of this.balancedBracketScopes)
      if (t(e))
        return !0;
    return this.allowAny;
  }
}, z_e = class {
  constructor(e, t, n, r) {
    this.balancedBracketSelectors = r, this._emitBinaryTokens = e, this._tokenTypeOverrides = n, this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
  }
  _emitBinaryTokens;
  /**
   * defined only if `false`.
   */
  _lineText;
  /**
   * used only if `_emitBinaryTokens` is false.
   */
  _tokens;
  /**
   * used only if `_emitBinaryTokens` is true.
   */
  _binaryTokens;
  _lastTokenEndIndex;
  _tokenTypeOverrides;
  produce(e, t) {
    this.produceFromScopes(e.contentNameScopesList, t);
  }
  produceFromScopes(e, t) {
    if (this._lastTokenEndIndex >= t)
      return;
    if (this._emitBinaryTokens) {
      let r = e?.tokenAttributes ?? 0, i = !1;
      if (this.balancedBracketSelectors?.matchesAlways && (i = !0), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
        const o = e?.getScopeNames() ?? [];
        for (const s of this._tokenTypeOverrides)
          s.matcher(o) && (r = Ch.set(
            r,
            0,
            s.type,
            null,
            -1,
            0,
            0
          ));
        this.balancedBracketSelectors && (i = this.balancedBracketSelectors.match(o));
      }
      if (i && (r = Ch.set(
        r,
        0,
        8,
        i,
        -1,
        0,
        0
      )), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === r) {
        this._lastTokenEndIndex = t;
        return;
      }
      this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(r), this._lastTokenEndIndex = t;
      return;
    }
    const n = e?.getScopeNames() ?? [];
    this._tokens.push({
      startIndex: this._lastTokenEndIndex,
      endIndex: t,
      // value: lineText.substring(lastTokenEndIndex, endIndex),
      scopes: n
    }), this._lastTokenEndIndex = t;
  }
  getResult(e, t) {
    return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === t - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(e, t), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
  }
  getBinaryResult(e, t) {
    this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === t - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(e, t), this._binaryTokens[this._binaryTokens.length - 2] = 0);
    const n = new Uint32Array(this._binaryTokens.length);
    for (let r = 0, i = this._binaryTokens.length; r < i; r++)
      n[r] = this._binaryTokens[r];
    return n;
  }
}, L_e = class {
  constructor(e, t) {
    this._onigLib = t, this._theme = e;
  }
  _grammars = /* @__PURE__ */ new Map();
  _rawGrammars = /* @__PURE__ */ new Map();
  _injectionGrammars = /* @__PURE__ */ new Map();
  _theme;
  dispose() {
    for (const e of this._grammars.values())
      e.dispose();
  }
  setTheme(e) {
    this._theme = e;
  }
  getColorMap() {
    return this._theme.getColorMap();
  }
  /**
   * Add `grammar` to registry and return a list of referenced scope names
   */
  addGrammar(e, t) {
    this._rawGrammars.set(e.scopeName, e), t && this._injectionGrammars.set(e.scopeName, t);
  }
  /**
   * Lookup a raw grammar.
   */
  lookup(e) {
    return this._rawGrammars.get(e);
  }
  /**
   * Returns the injections for the given grammar
   */
  injections(e) {
    return this._injectionGrammars.get(e);
  }
  /**
   * Get the default theme settings
   */
  getDefaults() {
    return this._theme.getDefaults();
  }
  /**
   * Match a scope in the theme.
   */
  themeMatch(e) {
    return this._theme.match(e);
  }
  /**
   * Lookup a grammar.
   */
  grammarForScopeName(e, t, n, r, i) {
    if (!this._grammars.has(e)) {
      let o = this._rawGrammars.get(e);
      if (!o)
        return null;
      this._grammars.set(e, P_e(
        e,
        o,
        t,
        n,
        r,
        i,
        this,
        this._onigLib
      ));
    }
    return this._grammars.get(e);
  }
}, B_e = class {
  _options;
  _syncRegistry;
  _ensureGrammarCache;
  constructor(t) {
    this._options = t, this._syncRegistry = new L_e(
      Qb.createFromRawTheme(t.theme, t.colorMap),
      t.onigLib
    ), this._ensureGrammarCache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._syncRegistry.dispose();
  }
  /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */
  setTheme(t, n) {
    this._syncRegistry.setTheme(Qb.createFromRawTheme(t, n));
  }
  /**
   * Returns a lookup array for color ids.
   */
  getColorMap() {
    return this._syncRegistry.getColorMap();
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithEmbeddedLanguages(t, n, r) {
    return this.loadGrammarWithConfiguration(t, n, { embeddedLanguages: r });
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithConfiguration(t, n, r) {
    return this._loadGrammar(
      t,
      n,
      r.embeddedLanguages,
      r.tokenTypes,
      new j_e(
        r.balancedBracketSelectors || [],
        r.unbalancedBracketSelectors || []
      )
    );
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */
  loadGrammar(t) {
    return this._loadGrammar(t, 0, null, null, null);
  }
  _loadGrammar(t, n, r, i, o) {
    const s = new p_e(this._syncRegistry, t);
    for (; s.Q.length > 0; )
      s.Q.map((a) => this._loadSingleGrammar(a.scopeName)), s.processQueue();
    return this._grammarForScopeName(
      t,
      n,
      r,
      i,
      o
    );
  }
  _loadSingleGrammar(t) {
    this._ensureGrammarCache.has(t) || (this._doLoadSingleGrammar(t), this._ensureGrammarCache.set(t, !0));
  }
  _doLoadSingleGrammar(t) {
    const n = this._options.loadGrammar(t);
    if (n) {
      const r = typeof this._options.getInjections == "function" ? this._options.getInjections(t) : void 0;
      this._syncRegistry.addGrammar(n, r);
    }
  }
  /**
   * Adds a rawGrammar.
   */
  addGrammar(t, n = [], r = 0, i = null) {
    return this._syncRegistry.addGrammar(t, n), this._grammarForScopeName(t.scopeName, r, i);
  }
  /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */
  _grammarForScopeName(t, n = 0, r = null, i = null, o = null) {
    return this._syncRegistry.grammarForScopeName(
      t,
      n,
      r,
      i,
      o
    );
  }
}, xT = bT.NULL;
const $_e = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], U_e = /["&'<>`]/g, F_e = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, V_e = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), H_e = /[|\\{}()[\]^$+*?.]/g, bL = /* @__PURE__ */ new WeakMap();
function W_e(e, t) {
  if (e = e.replace(
    t.subset ? q_e(t.subset) : U_e,
    r
  ), t.subset || t.escapeOnly)
    return e;
  return e.replace(F_e, n).replace(V_e, r);
  function n(i, o, s) {
    return t.format(
      (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
      s.charCodeAt(o + 2),
      t
    );
  }
  function r(i, o, s) {
    return t.format(
      i.charCodeAt(0),
      s.charCodeAt(o + 1),
      t
    );
  }
}
function q_e(e) {
  let t = bL.get(e);
  return t || (t = G_e(e), bL.set(e, t)), t;
}
function G_e(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t.push(e[n].replace(H_e, "\\$&"));
  return new RegExp("(?:" + t.join("|") + ")", "g");
}
const K_e = /[\dA-Fa-f]/;
function Z_e(e, t, n) {
  const r = "&#x" + e.toString(16).toUpperCase();
  return n && t && !K_e.test(String.fromCharCode(t)) ? r : r + ";";
}
const Y_e = /\d/;
function X_e(e, t, n) {
  const r = "&#" + String(e);
  return n && t && !Y_e.test(String.fromCharCode(t)) ? r : r + ";";
}
const J_e = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], XC = {
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  fnof: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  bull: "",
  hellip: "",
  prime: "",
  Prime: "",
  oline: "",
  frasl: "",
  weierp: "",
  image: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: "",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  circ: "",
  tilde: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  permil: "",
  lsaquo: "",
  rsaquo: "",
  euro: ""
}, Q_e = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], U7 = {}.hasOwnProperty, wT = {};
let s0;
for (s0 in XC)
  U7.call(XC, s0) && (wT[XC[s0]] = s0);
const eTe = /[^\dA-Za-z]/;
function tTe(e, t, n, r) {
  const i = String.fromCharCode(e);
  if (U7.call(wT, i)) {
    const o = wT[i], s = "&" + o;
    return n && J_e.includes(o) && !Q_e.includes(o) && (!r || t && t !== 61 && eTe.test(String.fromCharCode(t))) ? s : s + ";";
  }
  return "";
}
function nTe(e, t, n) {
  let r = Z_e(e, t, n.omitOptionalSemicolons), i;
  if ((n.useNamedReferences || n.useShortestReferences) && (i = tTe(
    e,
    t,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !i) && n.useShortestReferences) {
    const o = X_e(e, t, n.omitOptionalSemicolons);
    o.length < r.length && (r = o);
  }
  return i && (!n.useShortestReferences || i.length < r.length) ? i : r;
}
function lh(e, t) {
  return W_e(e, Object.assign({ format: nTe }, t));
}
const rTe = /^>|^->|<!--|-->|--!>|<!-$/g, iTe = [">"], oTe = ["<", ">"];
function sTe(e, t, n, r) {
  return r.settings.bogusComments ? "<?" + lh(
    e.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: iTe
    })
  ) + ">" : "<!--" + e.value.replace(rTe, i) + "-->";
  function i(o) {
    return lh(
      o,
      Object.assign({}, r.settings.characterReferences, {
        subset: oTe
      })
    );
  }
}
function aTe(e, t, n, r) {
  return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>";
}
const jr = V7(1), F7 = V7(-1), lTe = [];
function V7(e) {
  return t;
  function t(n, r, i) {
    const o = n ? n.children : lTe;
    let s = (r || 0) + e, a = o[s];
    if (!i)
      for (; a && qw(a); )
        s += e, a = o[s];
    return a;
  }
}
const cTe = {}.hasOwnProperty;
function H7(e) {
  return t;
  function t(n, r, i) {
    return cTe.call(e, n.tagName) && e[n.tagName](n, r, i);
  }
}
const wN = H7({
  body: dTe,
  caption: JC,
  colgroup: JC,
  dd: mTe,
  dt: pTe,
  head: JC,
  html: uTe,
  li: hTe,
  optgroup: gTe,
  option: yTe,
  p: fTe,
  rp: xL,
  rt: xL,
  tbody: bTe,
  td: wL,
  tfoot: xTe,
  th: wL,
  thead: vTe,
  tr: wTe
});
function JC(e, t, n) {
  const r = jr(n, t, !0);
  return !r || r.type !== "comment" && !(r.type === "text" && qw(r.value.charAt(0)));
}
function uTe(e, t, n) {
  const r = jr(n, t);
  return !r || r.type !== "comment";
}
function dTe(e, t, n) {
  const r = jr(n, t);
  return !r || r.type !== "comment";
}
function fTe(e, t, n) {
  const r = jr(n, t);
  return r ? r.type === "element" && (r.tagName === "address" || r.tagName === "article" || r.tagName === "aside" || r.tagName === "blockquote" || r.tagName === "details" || r.tagName === "div" || r.tagName === "dl" || r.tagName === "fieldset" || r.tagName === "figcaption" || r.tagName === "figure" || r.tagName === "footer" || r.tagName === "form" || r.tagName === "h1" || r.tagName === "h2" || r.tagName === "h3" || r.tagName === "h4" || r.tagName === "h5" || r.tagName === "h6" || r.tagName === "header" || r.tagName === "hgroup" || r.tagName === "hr" || r.tagName === "main" || r.tagName === "menu" || r.tagName === "nav" || r.tagName === "ol" || r.tagName === "p" || r.tagName === "pre" || r.tagName === "section" || r.tagName === "table" || r.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function hTe(e, t, n) {
  const r = jr(n, t);
  return !r || r.type === "element" && r.tagName === "li";
}
function pTe(e, t, n) {
  const r = jr(n, t);
  return !!(r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd"));
}
function mTe(e, t, n) {
  const r = jr(n, t);
  return !r || r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function xL(e, t, n) {
  const r = jr(n, t);
  return !r || r.type === "element" && (r.tagName === "rp" || r.tagName === "rt");
}
function gTe(e, t, n) {
  const r = jr(n, t);
  return !r || r.type === "element" && r.tagName === "optgroup";
}
function yTe(e, t, n) {
  const r = jr(n, t);
  return !r || r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup");
}
function vTe(e, t, n) {
  const r = jr(n, t);
  return !!(r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot"));
}
function bTe(e, t, n) {
  const r = jr(n, t);
  return !r || r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function xTe(e, t, n) {
  return !jr(n, t);
}
function wTe(e, t, n) {
  const r = jr(n, t);
  return !r || r.type === "element" && r.tagName === "tr";
}
function wL(e, t, n) {
  const r = jr(n, t);
  return !r || r.type === "element" && (r.tagName === "td" || r.tagName === "th");
}
const STe = H7({
  body: ETe,
  colgroup: _Te,
  head: CTe,
  html: kTe,
  tbody: TTe
});
function kTe(e) {
  const t = jr(e, -1);
  return !t || t.type !== "comment";
}
function CTe(e) {
  const t = /* @__PURE__ */ new Set();
  for (const r of e.children)
    if (r.type === "element" && (r.tagName === "base" || r.tagName === "title")) {
      if (t.has(r.tagName)) return !1;
      t.add(r.tagName);
    }
  const n = e.children[0];
  return !n || n.type === "element";
}
function ETe(e) {
  const t = jr(e, -1, !0);
  return !t || t.type !== "comment" && !(t.type === "text" && qw(t.value.charAt(0))) && !(t.type === "element" && (t.tagName === "meta" || t.tagName === "link" || t.tagName === "script" || t.tagName === "style" || t.tagName === "template"));
}
function _Te(e, t, n) {
  const r = F7(n, t), i = jr(e, -1, !0);
  return n && r && r.type === "element" && r.tagName === "colgroup" && wN(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "col");
}
function TTe(e, t, n) {
  const r = F7(n, t), i = jr(e, -1);
  return n && r && r.type === "element" && (r.tagName === "thead" || r.tagName === "tbody") && wN(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "tr");
}
const a0 = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function ATe(e, t, n, r) {
  const i = r.schema, o = i.space === "svg" ? !1 : r.settings.omitOptionalTags;
  let s = i.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(e.tagName.toLowerCase());
  const a = [];
  let c;
  i.space === "html" && e.tagName === "svg" && (r.schema = py);
  const u = MTe(r, e.properties), f = r.all(
    i.space === "html" && e.tagName === "template" ? e.content : e
  );
  return r.schema = i, f && (s = !1), (u || !o || !STe(e, t, n)) && (a.push("<", e.tagName, u ? " " + u : ""), s && (i.space === "svg" || r.settings.closeSelfClosing) && (c = u.charAt(u.length - 1), (!r.settings.tightSelfClosing || c === "/" || c && c !== '"' && c !== "'") && a.push(" "), a.push("/")), a.push(">")), a.push(f), !s && (!o || !wN(e, t, n)) && a.push("</" + e.tagName + ">"), a.join("");
}
function MTe(e, t) {
  const n = [];
  let r = -1, i;
  if (t) {
    for (i in t)
      if (t[i] !== null && t[i] !== void 0) {
        const o = NTe(e, i, t[i]);
        o && n.push(o);
      }
  }
  for (; ++r < n.length; ) {
    const o = e.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : void 0;
    r !== n.length - 1 && o !== '"' && o !== "'" && (n[r] += " ");
  }
  return n.join("");
}
function NTe(e, t, n) {
  const r = EV(e.schema, t), i = e.settings.allowParseErrors && e.schema.space === "html" ? 0 : 1, o = e.settings.allowDangerousCharacters ? 0 : 1;
  let s = e.quote, a;
  if (r.overloadedBoolean && (n === r.attribute || n === "") ? n = !0 : (r.boolean || r.overloadedBoolean) && (typeof n != "string" || n === r.attribute || n === "") && (n = !!n), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const c = lh(
    r.attribute,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: a0.name[i][o]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (r.commaSeparated ? yV : TV)(n, {
    padLeft: !e.settings.tightCommaSeparatedLists
  }) : String(n), e.settings.collapseEmptyAttributes && !n) ? c : (e.settings.preferUnquoted && (a = lh(
    n,
    Object.assign({}, e.settings.characterReferences, {
      attribute: !0,
      subset: a0.unquoted[i][o]
    })
  )), a !== n && (e.settings.quoteSmart && Xb(n, s) > Xb(n, e.alternative) && (s = e.alternative), a = s + lh(
    n,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (s === "'" ? a0.single : a0.double)[i][o],
      attribute: !0
    })
  ) + s), c + (a && "=" + a));
}
const RTe = ["<", "&"];
function W7(e, t, n, r) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? e.value : lh(
    e.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: RTe
    })
  );
}
function OTe(e, t, n, r) {
  return r.settings.allowDangerousHtml ? e.value : W7(e, t, n, r);
}
function PTe(e, t, n, r) {
  return r.all(e);
}
const DTe = ACe("type", {
  invalid: ITe,
  unknown: jTe,
  handlers: { comment: sTe, doctype: aTe, element: ATe, raw: OTe, root: PTe, text: W7 }
});
function ITe(e) {
  throw new Error("Expected node, not `" + e + "`");
}
function jTe(e) {
  const t = (
    /** @type {Nodes} */
    e
  );
  throw new Error("Cannot compile unknown node `" + t.type + "`");
}
const zTe = {}, LTe = {}, BTe = [];
function $Te(e, t) {
  const n = t || zTe, r = n.quote || '"', i = r === '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
  return {
    one: UTe,
    all: FTe,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || $_e,
      characterReferences: n.characterReferences || LTe,
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? py : _V,
    quote: r,
    alternative: i
  }.one(
    Array.isArray(e) ? { type: "root", children: e } : e,
    void 0,
    void 0
  );
}
function UTe(e, t, n) {
  return DTe(e, t, n, this);
}
function FTe(e) {
  const t = [], n = e && e.children || BTe;
  let r = -1;
  for (; ++r < n.length; )
    t[r] = this.one(n[r], r, e);
  return t.join("");
}
function ix(e, t) {
  const n = typeof e == "string" ? {} : { ...e.colorReplacements }, r = typeof e == "string" ? e : e.name;
  for (const [i, o] of Object.entries(t?.colorReplacements || {}))
    typeof o == "string" ? n[i] = o : i === r && Object.assign(n, o);
  return n;
}
function xc(e, t) {
  return e && (t?.[e?.toLowerCase()] || e);
}
function VTe(e) {
  return Array.isArray(e) ? e : [e];
}
async function q7(e) {
  return Promise.resolve(typeof e == "function" ? e() : e).then((t) => t.default || t);
}
function SN(e) {
  return !e || ["plaintext", "txt", "text", "plain"].includes(e);
}
function G7(e) {
  return e === "ansi" || SN(e);
}
function kN(e) {
  return e === "none";
}
function K7(e) {
  return kN(e);
}
function Z7(e, t) {
  if (!t)
    return e;
  e.properties ||= {}, e.properties.class ||= [], typeof e.properties.class == "string" && (e.properties.class = e.properties.class.split(/\s+/g)), Array.isArray(e.properties.class) || (e.properties.class = []);
  const n = Array.isArray(t) ? t : t.split(/\s+/g);
  for (const r of n)
    r && !e.properties.class.includes(r) && e.properties.class.push(r);
  return e;
}
function Jw(e, t = !1) {
  if (e.length === 0)
    return [["", 0]];
  const n = e.split(/(\r?\n)/g);
  let r = 0;
  const i = [];
  for (let o = 0; o < n.length; o += 2) {
    const s = t ? n[o] + (n[o + 1] || "") : n[o];
    i.push([s, r]), r += n[o].length, r += n[o + 1]?.length || 0;
  }
  return i;
}
function HTe(e) {
  const t = Jw(e, !0).map(([i]) => i);
  function n(i) {
    if (i === e.length)
      return {
        line: t.length - 1,
        character: t[t.length - 1].length
      };
    let o = i, s = 0;
    for (const a of t) {
      if (o < a.length)
        break;
      o -= a.length, s++;
    }
    return { line: s, character: o };
  }
  function r(i, o) {
    let s = 0;
    for (let a = 0; a < i; a++)
      s += t[a].length;
    return s += o, s;
  }
  return {
    lines: t,
    indexToPos: n,
    posToIndex: r
  };
}
function WTe(e, t, n) {
  const r = /* @__PURE__ */ new Set();
  for (const o of e.matchAll(/:?lang=["']([^"']+)["']/g)) {
    const s = o[1].toLowerCase().trim();
    s && r.add(s);
  }
  for (const o of e.matchAll(/(?:```|~~~)([\w-]+)/g)) {
    const s = o[1].toLowerCase().trim();
    s && r.add(s);
  }
  for (const o of e.matchAll(/\\begin\{([\w-]+)\}/g)) {
    const s = o[1].toLowerCase().trim();
    s && r.add(s);
  }
  for (const o of e.matchAll(/<script\s+(?:type|lang)=["']([^"']+)["']/gi)) {
    const s = o[1].toLowerCase().trim(), a = s.includes("/") ? s.split("/").pop() : s;
    a && r.add(a);
  }
  if (!n)
    return Array.from(r);
  const i = n.getBundledLanguages();
  return Array.from(r).filter((o) => o && i[o]);
}
const CN = "light-dark()", qTe = ["color", "background-color"];
function GTe(e, t) {
  let n = 0;
  const r = [];
  for (const i of t)
    i > n && r.push({
      ...e,
      content: e.content.slice(n, i),
      offset: e.offset + n
    }), n = i;
  return n < e.content.length && r.push({
    ...e,
    content: e.content.slice(n),
    offset: e.offset + n
  }), r;
}
function KTe(e, t) {
  const n = Array.from(t instanceof Set ? t : new Set(t)).sort((r, i) => r - i);
  return n.length ? e.map((r) => r.flatMap((i) => {
    const o = n.filter((s) => i.offset < s && s < i.offset + i.content.length).map((s) => s - i.offset).sort((s, a) => s - a);
    return o.length ? GTe(i, o) : i;
  })) : e;
}
function ZTe(e, t, n, r, i = "css-vars") {
  const o = {
    content: e.content,
    explanation: e.explanation,
    offset: e.offset
  }, s = t.map((f) => ox(e.variants[f])), a = new Set(s.flatMap((f) => Object.keys(f))), c = {}, u = (f, h) => {
    const m = h === "color" ? "" : h === "background-color" ? "-bg" : `-${h}`;
    return n + t[f] + (h === "color" ? "" : m);
  };
  return s.forEach((f, h) => {
    for (const m of a) {
      const g = f[m] || "inherit";
      if (h === 0 && r && qTe.includes(m))
        if (r === CN && s.length > 1) {
          const b = t.findIndex((_) => _ === "light"), x = t.findIndex((_) => _ === "dark");
          if (b === -1 || x === -1)
            throw new Cr('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
          const w = s[b][m] || "inherit", S = s[x][m] || "inherit";
          c[m] = `light-dark(${w}, ${S})`, i === "css-vars" && (c[u(h, m)] = g);
        } else
          c[m] = g;
      else
        i === "css-vars" && (c[u(h, m)] = g);
    }
  }), o.htmlStyle = c, o;
}
function ox(e) {
  const t = {};
  if (e.color && (t.color = e.color), e.bgColor && (t["background-color"] = e.bgColor), e.fontStyle) {
    e.fontStyle & vi.Italic && (t["font-style"] = "italic"), e.fontStyle & vi.Bold && (t["font-weight"] = "bold");
    const n = [];
    e.fontStyle & vi.Underline && n.push("underline"), e.fontStyle & vi.Strikethrough && n.push("line-through"), n.length && (t["text-decoration"] = n.join(" "));
  }
  return t;
}
function ST(e) {
  return typeof e == "string" ? e : Object.entries(e).map(([t, n]) => `${t}:${n}`).join(";");
}
const Y7 = /* @__PURE__ */ new WeakMap();
function Qw(e, t) {
  Y7.set(e, t);
}
function Tg(e) {
  return Y7.get(e);
}
class ep {
  /**
   * Theme to Stack mapping
   */
  _stacks = {};
  lang;
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(t, n) {
    return new ep(
      Object.fromEntries(VTe(n).map((r) => [r, xT])),
      t
    );
  }
  constructor(...t) {
    if (t.length === 2) {
      const [n, r] = t;
      this.lang = r, this._stacks = n;
    } else {
      const [n, r, i] = t;
      this.lang = r, this._stacks = { [i]: n };
    }
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(t = this.theme) {
    return this._stacks[t];
  }
  getScopes(t = this.theme) {
    return YTe(this._stacks[t]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.getScopes()
    };
  }
}
function YTe(e) {
  const t = [], n = /* @__PURE__ */ new Set();
  function r(i) {
    if (n.has(i))
      return;
    n.add(i);
    const o = i?.nameScopesList?.scopeName;
    o && t.push(o), i.parent && r(i.parent);
  }
  return r(e), t;
}
function XTe(e, t) {
  if (!(e instanceof ep))
    throw new Cr("Invalid grammar state");
  return e.getInternalStack(t);
}
function JTe() {
  const e = /* @__PURE__ */ new WeakMap();
  function t(n) {
    if (!e.has(n.meta)) {
      let r = function(s) {
        if (typeof s == "number") {
          if (s < 0 || s > n.source.length)
            throw new Cr(`Invalid decoration offset: ${s}. Code length: ${n.source.length}`);
          return {
            ...i.indexToPos(s),
            offset: s
          };
        } else {
          const a = i.lines[s.line];
          if (a === void 0)
            throw new Cr(`Invalid decoration position ${JSON.stringify(s)}. Lines length: ${i.lines.length}`);
          let c = s.character;
          if (c < 0 && (c = a.length + c), c < 0 || c > a.length)
            throw new Cr(`Invalid decoration position ${JSON.stringify(s)}. Line ${s.line} length: ${a.length}`);
          return {
            ...s,
            character: c,
            offset: i.posToIndex(s.line, c)
          };
        }
      };
      const i = HTe(n.source), o = (n.options.decorations || []).map((s) => ({
        ...s,
        start: r(s.start),
        end: r(s.end)
      }));
      QTe(o), e.set(n.meta, {
        decorations: o,
        converter: i,
        source: n.source
      });
    }
    return e.get(n.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(n) {
      if (!this.options.decorations?.length)
        return;
      const i = t(this).decorations.flatMap((s) => [s.start.offset, s.end.offset]);
      return KTe(n, i);
    },
    code(n) {
      if (!this.options.decorations?.length)
        return;
      const r = t(this), i = Array.from(n.children).filter((f) => f.type === "element" && f.tagName === "span");
      if (i.length !== r.converter.lines.length)
        throw new Cr(`Number of lines in code element (${i.length}) does not match the number of lines in the source (${r.converter.lines.length}). Failed to apply decorations.`);
      function o(f, h, m, g) {
        const b = i[f];
        let x = "", w = -1, S = -1;
        if (h === 0 && (w = 0), m === 0 && (S = 0), m === Number.POSITIVE_INFINITY && (S = b.children.length), w === -1 || S === -1)
          for (let M = 0; M < b.children.length; M++)
            x += X7(b.children[M]), w === -1 && x.length === h && (w = M + 1), S === -1 && x.length === m && (S = M + 1);
        if (w === -1)
          throw new Cr(`Failed to find start index for decoration ${JSON.stringify(g.start)}`);
        if (S === -1)
          throw new Cr(`Failed to find end index for decoration ${JSON.stringify(g.end)}`);
        const _ = b.children.slice(w, S);
        if (!g.alwaysWrap && _.length === b.children.length)
          a(b, g, "line");
        else if (!g.alwaysWrap && _.length === 1 && _[0].type === "element")
          a(_[0], g, "token");
        else {
          const M = {
            type: "element",
            tagName: "span",
            properties: {},
            children: _
          };
          a(M, g, "wrapper"), b.children.splice(w, _.length, M);
        }
      }
      function s(f, h) {
        i[f] = a(i[f], h, "line");
      }
      function a(f, h, m) {
        const g = h.properties || {}, b = h.transform || ((x) => x);
        return f.tagName = h.tagName || "span", f.properties = {
          ...f.properties,
          ...g,
          class: f.properties.class
        }, h.properties?.class && Z7(f, h.properties.class), f = b(f, m) || f, f;
      }
      const c = [], u = r.decorations.sort((f, h) => h.start.offset - f.start.offset || f.end.offset - h.end.offset);
      for (const f of u) {
        const { start: h, end: m } = f;
        if (h.line === m.line)
          o(h.line, h.character, m.character, f);
        else if (h.line < m.line) {
          o(h.line, h.character, Number.POSITIVE_INFINITY, f);
          for (let g = h.line + 1; g < m.line; g++)
            c.unshift(() => s(g, f));
          o(m.line, 0, m.character, f);
        }
      }
      c.forEach((f) => f());
    }
  };
}
function QTe(e) {
  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    if (n.start.offset > n.end.offset)
      throw new Cr(`Invalid decoration range: ${JSON.stringify(n.start)} - ${JSON.stringify(n.end)}`);
    for (let r = t + 1; r < e.length; r++) {
      const i = e[r], o = n.start.offset <= i.start.offset && i.start.offset < n.end.offset, s = n.start.offset < i.end.offset && i.end.offset <= n.end.offset, a = i.start.offset <= n.start.offset && n.start.offset < i.end.offset, c = i.start.offset < n.end.offset && n.end.offset <= i.end.offset;
      if (o || s || a || c) {
        if (o && s || a && c || a && n.start.offset === n.end.offset || s && i.start.offset === i.end.offset)
          continue;
        throw new Cr(`Decorations ${JSON.stringify(n.start)} and ${JSON.stringify(i.start)} intersect.`);
      }
    }
  }
}
function X7(e) {
  return e.type === "text" ? e.value : e.type === "element" ? e.children.map(X7).join("") : "";
}
const eAe = [
  /* @__PURE__ */ JTe()
];
function sx(e) {
  const t = tAe(e.transformers || []);
  return [
    ...t.pre,
    ...t.normal,
    ...t.post,
    ...eAe
  ];
}
function tAe(e) {
  const t = [], n = [], r = [];
  for (const i of e)
    switch (i.enforce) {
      case "pre":
        t.push(i);
        break;
      case "post":
        n.push(i);
        break;
      default:
        r.push(i);
    }
  return { pre: t, post: n, normal: r };
}
var $u = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
], QC = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  8: "hidden",
  9: "strikethrough"
};
function nAe(e, t) {
  const n = e.indexOf("\x1B", t);
  if (n !== -1 && e[n + 1] === "[") {
    const r = e.indexOf("m", n);
    if (r !== -1)
      return {
        sequence: e.substring(n + 2, r).split(";"),
        startPosition: n,
        position: r + 1
      };
  }
  return {
    position: e.length
  };
}
function SL(e) {
  const t = e.shift();
  if (t === "2") {
    const n = e.splice(0, 3).map((r) => Number.parseInt(r));
    return n.length !== 3 || n.some((r) => Number.isNaN(r)) ? void 0 : {
      type: "rgb",
      rgb: n
    };
  } else if (t === "5") {
    const n = e.shift();
    if (n)
      return { type: "table", index: Number(n) };
  }
}
function rAe(e) {
  const t = [];
  for (; e.length > 0; ) {
    const n = e.shift();
    if (!n)
      continue;
    const r = Number.parseInt(n);
    if (!Number.isNaN(r))
      if (r === 0)
        t.push({ type: "resetAll" });
      else if (r <= 9)
        QC[r] && t.push({
          type: "setDecoration",
          value: QC[r]
        });
      else if (r <= 29) {
        const i = QC[r - 20];
        i && (t.push({
          type: "resetDecoration",
          value: i
        }), i === "dim" && t.push({
          type: "resetDecoration",
          value: "bold"
        }));
      } else if (r <= 37)
        t.push({
          type: "setForegroundColor",
          value: { type: "named", name: $u[r - 30] }
        });
      else if (r === 38) {
        const i = SL(e);
        i && t.push({
          type: "setForegroundColor",
          value: i
        });
      } else if (r === 39)
        t.push({
          type: "resetForegroundColor"
        });
      else if (r <= 47)
        t.push({
          type: "setBackgroundColor",
          value: { type: "named", name: $u[r - 40] }
        });
      else if (r === 48) {
        const i = SL(e);
        i && t.push({
          type: "setBackgroundColor",
          value: i
        });
      } else r === 49 ? t.push({
        type: "resetBackgroundColor"
      }) : r === 53 ? t.push({
        type: "setDecoration",
        value: "overline"
      }) : r === 55 ? t.push({
        type: "resetDecoration",
        value: "overline"
      }) : r >= 90 && r <= 97 ? t.push({
        type: "setForegroundColor",
        value: { type: "named", name: $u[r - 90 + 8] }
      }) : r >= 100 && r <= 107 && t.push({
        type: "setBackgroundColor",
        value: { type: "named", name: $u[r - 100 + 8] }
      });
  }
  return t;
}
function iAe() {
  let e = null, t = null, n = /* @__PURE__ */ new Set();
  return {
    parse(r) {
      const i = [];
      let o = 0;
      do {
        const s = nAe(r, o), a = s.sequence ? r.substring(o, s.startPosition) : r.substring(o);
        if (a.length > 0 && i.push({
          value: a,
          foreground: e,
          background: t,
          decorations: new Set(n)
        }), s.sequence) {
          const c = rAe(s.sequence);
          for (const u of c)
            u.type === "resetAll" ? (e = null, t = null, n.clear()) : u.type === "resetForegroundColor" ? e = null : u.type === "resetBackgroundColor" ? t = null : u.type === "resetDecoration" && n.delete(u.value);
          for (const u of c)
            u.type === "setForegroundColor" ? e = u.value : u.type === "setBackgroundColor" ? t = u.value : u.type === "setDecoration" && n.add(u.value);
        }
        o = s.position;
      } while (o < r.length);
      return i;
    }
  };
}
var oAe = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function sAe(e = oAe) {
  function t(a) {
    return e[a];
  }
  function n(a) {
    return `#${a.map((c) => Math.max(0, Math.min(c, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let r;
  function i() {
    if (r)
      return r;
    r = [];
    for (let u = 0; u < $u.length; u++)
      r.push(t($u[u]));
    let a = [0, 95, 135, 175, 215, 255];
    for (let u = 0; u < 6; u++)
      for (let f = 0; f < 6; f++)
        for (let h = 0; h < 6; h++)
          r.push(n([a[u], a[f], a[h]]));
    let c = 8;
    for (let u = 0; u < 24; u++, c += 10)
      r.push(n([c, c, c]));
    return r;
  }
  function o(a) {
    return i()[a];
  }
  function s(a) {
    switch (a.type) {
      case "named":
        return t(a.name);
      case "rgb":
        return n(a.rgb);
      case "table":
        return o(a.index);
    }
  }
  return {
    value: s
  };
}
const aAe = {
  black: "#000000",
  red: "#cd3131",
  green: "#0DBC79",
  yellow: "#E5E510",
  blue: "#2472C8",
  magenta: "#BC3FBC",
  cyan: "#11A8CD",
  white: "#E5E5E5",
  brightBlack: "#666666",
  brightRed: "#F14C4C",
  brightGreen: "#23D18B",
  brightYellow: "#F5F543",
  brightBlue: "#3B8EEA",
  brightMagenta: "#D670D6",
  brightCyan: "#29B8DB",
  brightWhite: "#FFFFFF"
};
function lAe(e, t, n) {
  const r = ix(e, n), i = Jw(t), o = Object.fromEntries(
    $u.map((c) => {
      const u = `terminal.ansi${c[0].toUpperCase()}${c.substring(1)}`, f = e.colors?.[u];
      return [c, f || aAe[c]];
    })
  ), s = sAe(o), a = iAe();
  return i.map(
    (c) => a.parse(c[0]).map((u) => {
      let f, h;
      u.decorations.has("reverse") ? (f = u.background ? s.value(u.background) : e.bg, h = u.foreground ? s.value(u.foreground) : e.fg) : (f = u.foreground ? s.value(u.foreground) : e.fg, h = u.background ? s.value(u.background) : void 0), f = xc(f, r), h = xc(h, r), u.decorations.has("dim") && (f = cAe(f));
      let m = vi.None;
      return u.decorations.has("bold") && (m |= vi.Bold), u.decorations.has("italic") && (m |= vi.Italic), u.decorations.has("underline") && (m |= vi.Underline), u.decorations.has("strikethrough") && (m |= vi.Strikethrough), {
        content: u.value,
        offset: c[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color: f,
        bgColor: h,
        fontStyle: m
      };
    })
  );
}
function cAe(e) {
  const t = e.match(/#([0-9a-f]{3,8})/i);
  if (t) {
    const r = t[1];
    if (r.length === 8) {
      const i = Math.round(Number.parseInt(r.slice(6, 8), 16) / 2).toString(16).padStart(2, "0");
      return `#${r.slice(0, 6)}${i}`;
    } else {
      if (r.length === 6)
        return `#${r}80`;
      if (r.length === 4) {
        const i = r[0], o = r[1], s = r[2], a = r[3], c = Math.round(Number.parseInt(`${a}${a}`, 16) / 2).toString(16).padStart(2, "0");
        return `#${i}${i}${o}${o}${s}${s}${c}`;
      } else if (r.length === 3) {
        const i = r[0], o = r[1], s = r[2];
        return `#${i}${i}${o}${o}${s}${s}80`;
      }
    }
  }
  const n = e.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  return n ? `var(${n[1]}-dim)` : e;
}
function EN(e, t, n = {}) {
  const {
    theme: r = e.getLoadedThemes()[0]
  } = n, i = e.resolveLangAlias(n.lang || "text");
  if (SN(i) || kN(r))
    return Jw(t).map((c) => [{ content: c[0], offset: c[1] }]);
  const { theme: o, colorMap: s } = e.setTheme(r);
  if (i === "ansi")
    return lAe(o, t, n);
  const a = e.getLanguage(n.lang || "text");
  if (n.grammarState) {
    if (n.grammarState.lang !== a.name)
      throw new Cr(`Grammar state language "${n.grammarState.lang}" does not match highlight language "${a.name}"`);
    if (!n.grammarState.themes.includes(o.name))
      throw new Cr(`Grammar state themes "${n.grammarState.themes}" do not contain highlight theme "${o.name}"`);
  }
  return dAe(t, a, o, s, n);
}
function uAe(...e) {
  if (e.length === 2)
    return Tg(e[1]);
  const [t, n, r = {}] = e, {
    lang: i = "text",
    theme: o = t.getLoadedThemes()[0]
  } = r;
  if (SN(i) || kN(o))
    throw new Cr("Plain language does not have grammar state");
  if (i === "ansi")
    throw new Cr("ANSI language does not have grammar state");
  const { theme: s, colorMap: a } = t.setTheme(o), c = t.getLanguage(i);
  return new ep(
    _N(n, c, s, a, r).stateStack,
    c.name,
    s.name
  );
}
function dAe(e, t, n, r, i) {
  const o = _N(e, t, n, r, i), s = new ep(
    o.stateStack,
    t.name,
    n.name
  );
  return Qw(o.tokens, s), o.tokens;
}
function _N(e, t, n, r, i) {
  const o = ix(n, i), {
    tokenizeMaxLineLength: s = 0,
    tokenizeTimeLimit: a = 500
  } = i, c = Jw(e);
  let u = i.grammarState ? XTe(i.grammarState, n.name) ?? xT : i.grammarContextCode != null ? _N(
    i.grammarContextCode,
    t,
    n,
    r,
    {
      ...i,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : xT, f = [];
  const h = [];
  for (let m = 0, g = c.length; m < g; m++) {
    const [b, x] = c[m];
    if (b === "") {
      f = [], h.push([]);
      continue;
    }
    if (s > 0 && b.length >= s) {
      f = [], h.push([{
        content: b,
        offset: x,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let w, S, _;
    i.includeExplanation && (w = t.tokenizeLine(b, u, a), S = w.tokens, _ = 0);
    const M = t.tokenizeLine2(b, u, a), N = M.tokens.length / 2;
    for (let D = 0; D < N; D++) {
      const j = M.tokens[2 * D], O = D + 1 < N ? M.tokens[2 * D + 2] : b.length;
      if (j === O)
        continue;
      const L = M.tokens[2 * D + 1], U = xc(
        r[Ch.getForeground(L)],
        o
      ), B = Ch.getFontStyle(L), G = {
        content: b.substring(j, O),
        offset: x + j,
        color: U,
        fontStyle: B
      };
      if (i.includeExplanation) {
        const Y = [];
        if (i.includeExplanation !== "scopeName")
          for (const ie of n.settings) {
            let ne;
            switch (typeof ie.scope) {
              case "string":
                ne = ie.scope.split(/,/).map((H) => H.trim());
                break;
              case "object":
                ne = ie.scope;
                break;
              default:
                continue;
            }
            Y.push({
              settings: ie,
              selectors: ne.map((H) => H.split(/ /))
            });
          }
        G.explanation = [];
        let he = 0;
        for (; j + he < O; ) {
          const ie = S[_], ne = b.substring(
            ie.startIndex,
            ie.endIndex
          );
          he += ne.length, G.explanation.push({
            content: ne,
            scopes: i.includeExplanation === "scopeName" ? fAe(
              ie.scopes
            ) : hAe(
              Y,
              ie.scopes
            )
          }), _ += 1;
        }
      }
      f.push(G);
    }
    h.push(f), f = [], u = M.ruleStack;
  }
  return {
    tokens: h,
    stateStack: u
  };
}
function fAe(e) {
  return e.map((t) => ({ scopeName: t }));
}
function hAe(e, t) {
  const n = [];
  for (let r = 0, i = t.length; r < i; r++) {
    const o = t[r];
    n[r] = {
      scopeName: o,
      themeMatches: mAe(e, o, t.slice(0, r))
    };
  }
  return n;
}
function kL(e, t) {
  return e === t || t.substring(0, e.length) === e && t[e.length] === ".";
}
function pAe(e, t, n) {
  if (!kL(e[e.length - 1], t))
    return !1;
  let r = e.length - 2, i = n.length - 1;
  for (; r >= 0 && i >= 0; )
    kL(e[r], n[i]) && (r -= 1), i -= 1;
  return r === -1;
}
function mAe(e, t, n) {
  const r = [];
  for (const { selectors: i, settings: o } of e)
    for (const s of i)
      if (pAe(s, t, n)) {
        r.push(o);
        break;
      }
  return r;
}
function J7(e, t, n) {
  const r = Object.entries(n.themes).filter((c) => c[1]).map((c) => ({ color: c[0], theme: c[1] })), i = r.map((c) => {
    const u = EN(e, t, {
      ...n,
      theme: c.theme
    }), f = Tg(u), h = typeof c.theme == "string" ? c.theme : c.theme.name;
    return {
      tokens: u,
      state: f,
      theme: h
    };
  }), o = gAe(
    ...i.map((c) => c.tokens)
  ), s = o[0].map(
    (c, u) => c.map((f, h) => {
      const m = {
        content: f.content,
        variants: {},
        offset: f.offset
      };
      return "includeExplanation" in n && n.includeExplanation && (m.explanation = f.explanation), o.forEach((g, b) => {
        const {
          content: x,
          explanation: w,
          offset: S,
          ..._
        } = g[u][h];
        m.variants[r[b].color] = _;
      }), m;
    })
  ), a = i[0].state ? new ep(
    Object.fromEntries(i.map((c) => [c.theme, c.state?.getInternalStack(c.theme)])),
    i[0].state.lang
  ) : void 0;
  return a && Qw(s, a), s;
}
function gAe(...e) {
  const t = e.map(() => []), n = e.length;
  for (let r = 0; r < e[0].length; r++) {
    const i = e.map((c) => c[r]), o = t.map(() => []);
    t.forEach((c, u) => c.push(o[u]));
    const s = i.map(() => 0), a = i.map((c) => c[0]);
    for (; a.every((c) => c); ) {
      const c = Math.min(...a.map((u) => u.content.length));
      for (let u = 0; u < n; u++) {
        const f = a[u];
        f.content.length === c ? (o[u].push(f), s[u] += 1, a[u] = i[u][s[u]]) : (o[u].push({
          ...f,
          content: f.content.slice(0, c)
        }), a[u] = {
          ...f,
          content: f.content.slice(c),
          offset: f.offset + c
        });
      }
    }
  }
  return t;
}
function ax(e, t, n) {
  let r, i, o, s, a, c;
  if ("themes" in n) {
    const {
      defaultColor: u = "light",
      cssVariablePrefix: f = "--shiki-",
      colorsRendering: h = "css-vars"
    } = n, m = Object.entries(n.themes).filter((S) => S[1]).map((S) => ({ color: S[0], theme: S[1] })).sort((S, _) => S.color === u ? -1 : _.color === u ? 1 : 0);
    if (m.length === 0)
      throw new Cr("`themes` option must not be empty");
    const g = J7(
      e,
      t,
      n
    );
    if (c = Tg(g), u && CN !== u && !m.find((S) => S.color === u))
      throw new Cr(`\`themes\` option must contain the defaultColor key \`${u}\``);
    const b = m.map((S) => e.getTheme(S.theme)), x = m.map((S) => S.color);
    o = g.map((S) => S.map((_) => ZTe(_, x, f, u, h))), c && Qw(o, c);
    const w = m.map((S) => ix(S.theme, n));
    i = CL(m, b, w, f, u, "fg", h), r = CL(m, b, w, f, u, "bg", h), s = `shiki-themes ${b.map((S) => S.name).join(" ")}`, a = u ? void 0 : [i, r].join(";");
  } else if ("theme" in n) {
    const u = ix(n.theme, n);
    o = EN(
      e,
      t,
      n
    );
    const f = e.getTheme(n.theme);
    r = xc(f.bg, u), i = xc(f.fg, u), s = f.name, c = Tg(o);
  } else
    throw new Cr("Invalid options, either `theme` or `themes` must be provided");
  return {
    tokens: o,
    fg: i,
    bg: r,
    themeName: s,
    rootStyle: a,
    grammarState: c
  };
}
function CL(e, t, n, r, i, o, s) {
  return e.map((a, c) => {
    const u = xc(t[c][o], n[c]) || "inherit", f = `${r + a.color}${o === "bg" ? "-bg" : ""}:${u}`;
    if (c === 0 && i) {
      if (i === CN && e.length > 1) {
        const h = e.findIndex((x) => x.color === "light"), m = e.findIndex((x) => x.color === "dark");
        if (h === -1 || m === -1)
          throw new Cr('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
        const g = xc(t[h][o], n[h]) || "inherit", b = xc(t[m][o], n[m]) || "inherit";
        return `light-dark(${g}, ${b});${f}`;
      }
      return u;
    }
    return s === "css-vars" ? f : null;
  }).filter((a) => !!a).join(";");
}
function lx(e, t, n, r = {
  meta: {},
  options: n,
  codeToHast: (i, o) => lx(e, i, o),
  codeToTokens: (i, o) => ax(e, i, o)
}) {
  let i = t;
  for (const b of sx(n))
    i = b.preprocess?.call(r, i, n) || i;
  let {
    tokens: o,
    fg: s,
    bg: a,
    themeName: c,
    rootStyle: u,
    grammarState: f
  } = ax(e, i, n);
  const {
    mergeWhitespaces: h = !0,
    mergeSameStyleTokens: m = !1
  } = n;
  h === !0 ? o = vAe(o) : h === "never" && (o = bAe(o)), m && (o = xAe(o));
  const g = {
    ...r,
    get source() {
      return i;
    }
  };
  for (const b of sx(n))
    o = b.tokens?.call(g, o) || o;
  return yAe(
    o,
    {
      ...n,
      fg: s,
      bg: a,
      themeName: c,
      rootStyle: n.rootStyle === !1 ? !1 : n.rootStyle ?? u
    },
    g,
    f
  );
}
function yAe(e, t, n, r = Tg(e)) {
  const i = sx(t), o = [], s = {
    type: "root",
    children: []
  }, {
    structure: a = "classic",
    tabindex: c = "0"
  } = t, u = {
    class: `shiki ${t.themeName || ""}`
  };
  t.rootStyle !== !1 && (t.rootStyle != null ? u.style = t.rootStyle : u.style = `background-color:${t.bg};color:${t.fg}`), c !== !1 && c != null && (u.tabindex = c.toString());
  for (const [x, w] of Object.entries(t.meta || {}))
    x.startsWith("_") || (u[x] = w);
  let f = {
    type: "element",
    tagName: "pre",
    properties: u,
    children: [],
    data: t.data
  }, h = {
    type: "element",
    tagName: "code",
    properties: {},
    children: o
  };
  const m = [], g = {
    ...n,
    structure: a,
    addClassToHast: Z7,
    get source() {
      return n.source;
    },
    get tokens() {
      return e;
    },
    get options() {
      return t;
    },
    get root() {
      return s;
    },
    get pre() {
      return f;
    },
    get code() {
      return h;
    },
    get lines() {
      return m;
    }
  };
  if (e.forEach((x, w) => {
    w && (a === "inline" ? s.children.push({ type: "element", tagName: "br", properties: {}, children: [] }) : a === "classic" && o.push({ type: "text", value: `
` }));
    let S = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    }, _ = 0;
    for (const M of x) {
      let N = {
        type: "element",
        tagName: "span",
        properties: {
          ...M.htmlAttrs
        },
        children: [{ type: "text", value: M.content }]
      };
      const D = ST(M.htmlStyle || ox(M));
      D && (N.properties.style = D);
      for (const j of i)
        N = j?.span?.call(g, N, w + 1, _, S, M) || N;
      a === "inline" ? s.children.push(N) : a === "classic" && S.children.push(N), _ += M.content.length;
    }
    if (a === "classic") {
      for (const M of i)
        S = M?.line?.call(g, S, w + 1) || S;
      m.push(S), o.push(S);
    } else a === "inline" && m.push(S);
  }), a === "classic") {
    for (const x of i)
      h = x?.code?.call(g, h) || h;
    f.children.push(h);
    for (const x of i)
      f = x?.pre?.call(g, f) || f;
    s.children.push(f);
  } else if (a === "inline") {
    const x = [];
    let w = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    };
    for (const M of s.children)
      M.type === "element" && M.tagName === "br" ? (x.push(w), w = {
        type: "element",
        tagName: "span",
        properties: { class: "line" },
        children: []
      }) : (M.type === "element" || M.type === "text") && w.children.push(M);
    x.push(w);
    let _ = {
      type: "element",
      tagName: "code",
      properties: {},
      children: x
    };
    for (const M of i)
      _ = M?.code?.call(g, _) || _;
    s.children = [];
    for (let M = 0; M < _.children.length; M++) {
      M > 0 && s.children.push({ type: "element", tagName: "br", properties: {}, children: [] });
      const N = _.children[M];
      N.type === "element" && s.children.push(...N.children);
    }
  }
  let b = s;
  for (const x of i)
    b = x?.root?.call(g, b) || b;
  return r && Qw(b, r), b;
}
function vAe(e) {
  return e.map((t) => {
    const n = [];
    let r = "", i;
    return t.forEach((o, s) => {
      const c = !(o.fontStyle && (o.fontStyle & vi.Underline || o.fontStyle & vi.Strikethrough));
      c && o.content.match(/^\s+$/) && t[s + 1] ? (i === void 0 && (i = o.offset), r += o.content) : r ? (c ? n.push({
        ...o,
        offset: i,
        content: r + o.content
      }) : n.push(
        {
          content: r,
          offset: i
        },
        o
      ), i = void 0, r = "") : n.push(o);
    }), n;
  });
}
function bAe(e) {
  return e.map((t) => t.flatMap((n) => {
    if (n.content.match(/^\s+$/))
      return n;
    const r = n.content.match(/^(\s*)(.*?)(\s*)$/);
    if (!r)
      return n;
    const [, i, o, s] = r;
    if (!i && !s)
      return n;
    const a = [{
      ...n,
      offset: n.offset + i.length,
      content: o
    }];
    return i && a.unshift({
      content: i,
      offset: n.offset
    }), s && a.push({
      content: s,
      offset: n.offset + i.length + o.length
    }), a;
  }));
}
function xAe(e) {
  return e.map((t) => {
    const n = [];
    for (const r of t) {
      if (n.length === 0) {
        n.push({ ...r });
        continue;
      }
      const i = n[n.length - 1], o = ST(i.htmlStyle || ox(i)), s = ST(r.htmlStyle || ox(r)), a = i.fontStyle && (i.fontStyle & vi.Underline || i.fontStyle & vi.Strikethrough), c = r.fontStyle && (r.fontStyle & vi.Underline || r.fontStyle & vi.Strikethrough);
      !a && !c && o === s ? i.content += r.content : n.push({ ...r });
    }
    return n;
  });
}
const wAe = $Te;
function SAe(e, t, n) {
  const r = {
    meta: {},
    options: n,
    codeToHast: (o, s) => lx(e, o, s),
    codeToTokens: (o, s) => ax(e, o, s)
  };
  let i = wAe(lx(e, t, n, r));
  for (const o of sx(n))
    i = o.postprocess?.call(r, i, n) || i;
  return i;
}
const EL = { light: "#333333", dark: "#bbbbbb" }, _L = { light: "#fffffe", dark: "#1e1e1e" }, TL = "__shiki_resolved";
function TN(e) {
  if (e?.[TL])
    return e;
  const t = {
    ...e
  };
  t.tokenColors && !t.settings && (t.settings = t.tokenColors, delete t.tokenColors), t.type ||= "dark", t.colorReplacements = { ...t.colorReplacements }, t.settings ||= [];
  let { bg: n, fg: r } = t;
  if (!n || !r) {
    const a = t.settings ? t.settings.find((c) => !c.name && !c.scope) : void 0;
    a?.settings?.foreground && (r = a.settings.foreground), a?.settings?.background && (n = a.settings.background), !r && t?.colors?.["editor.foreground"] && (r = t.colors["editor.foreground"]), !n && t?.colors?.["editor.background"] && (n = t.colors["editor.background"]), r || (r = t.type === "light" ? EL.light : EL.dark), n || (n = t.type === "light" ? _L.light : _L.dark), t.fg = r, t.bg = n;
  }
  t.settings[0] && t.settings[0].settings && !t.settings[0].scope || t.settings.unshift({
    settings: {
      foreground: t.fg,
      background: t.bg
    }
  });
  let i = 0;
  const o = /* @__PURE__ */ new Map();
  function s(a) {
    if (o.has(a))
      return o.get(a);
    i += 1;
    const c = `#${i.toString(16).padStart(8, "0").toLowerCase()}`;
    return t.colorReplacements?.[`#${c}`] ? s(a) : (o.set(a, c), c);
  }
  t.settings = t.settings.map((a) => {
    const c = a.settings?.foreground && !a.settings.foreground.startsWith("#"), u = a.settings?.background && !a.settings.background.startsWith("#");
    if (!c && !u)
      return a;
    const f = {
      ...a,
      settings: {
        ...a.settings
      }
    };
    if (c) {
      const h = s(a.settings.foreground);
      t.colorReplacements[h] = a.settings.foreground, f.settings.foreground = h;
    }
    if (u) {
      const h = s(a.settings.background);
      t.colorReplacements[h] = a.settings.background, f.settings.background = h;
    }
    return f;
  });
  for (const a of Object.keys(t.colors || {}))
    if ((a === "editor.foreground" || a === "editor.background" || a.startsWith("terminal.ansi")) && !t.colors[a]?.startsWith("#")) {
      const c = s(t.colors[a]);
      t.colorReplacements[c] = t.colors[a], t.colors[a] = c;
    }
  return Object.defineProperty(t, TL, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), t;
}
async function Q7(e) {
  return Array.from(new Set((await Promise.all(
    e.filter((t) => !G7(t)).map(async (t) => await q7(t).then((n) => Array.isArray(n) ? n : [n]))
  )).flat()));
}
async function eH(e) {
  return (await Promise.all(
    e.map(
      async (n) => K7(n) ? null : TN(await q7(n))
    )
  )).filter((n) => !!n);
}
let kAe = 3;
function CAe(e, t = 3) {
  t > kAe || console.trace(`[SHIKI DEPRECATE]: ${e}`);
}
let Yf = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
};
function tH(e, t) {
  if (!t)
    return e;
  if (t[e]) {
    const n = /* @__PURE__ */ new Set([e]);
    for (; t[e]; ) {
      if (e = t[e], n.has(e))
        throw new Yf(`Circular alias \`${Array.from(n).join(" -> ")} -> ${e}\``);
      n.add(e);
    }
  }
  return e;
}
class EAe extends B_e {
  constructor(t, n, r, i = {}) {
    super(t), this._resolver = t, this._themes = n, this._langs = r, this._alias = i, this._themes.map((o) => this.loadTheme(o)), this.loadLanguages(this._langs);
  }
  _resolvedThemes = /* @__PURE__ */ new Map();
  _resolvedGrammars = /* @__PURE__ */ new Map();
  _langMap = /* @__PURE__ */ new Map();
  _langGraph = /* @__PURE__ */ new Map();
  _textmateThemeCache = /* @__PURE__ */ new WeakMap();
  _loadedThemesCache = null;
  _loadedLanguagesCache = null;
  getTheme(t) {
    return typeof t == "string" ? this._resolvedThemes.get(t) : this.loadTheme(t);
  }
  loadTheme(t) {
    const n = TN(t);
    return n.name && (this._resolvedThemes.set(n.name, n), this._loadedThemesCache = null), n;
  }
  getLoadedThemes() {
    return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]), this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(t) {
    let n = this._textmateThemeCache.get(t);
    n || (n = Qb.createFromRawTheme(t), this._textmateThemeCache.set(t, n)), this._syncRegistry.setTheme(n);
  }
  getGrammar(t) {
    return t = tH(t, this._alias), this._resolvedGrammars.get(t);
  }
  loadLanguage(t) {
    if (this.getGrammar(t.name))
      return;
    const n = new Set(
      [...this._langMap.values()].filter((o) => o.embeddedLangsLazy?.includes(t.name))
    );
    this._resolver.addLanguage(t);
    const r = {
      balancedBracketSelectors: t.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: t.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(t.scopeName, t);
    const i = this.loadGrammarWithConfiguration(t.scopeName, 1, r);
    if (i.name = t.name, this._resolvedGrammars.set(t.name, i), t.aliases && t.aliases.forEach((o) => {
      this._alias[o] = t.name;
    }), this._loadedLanguagesCache = null, n.size)
      for (const o of n)
        this._resolvedGrammars.delete(o.name), this._loadedLanguagesCache = null, this._syncRegistry?._injectionGrammars?.delete(o.scopeName), this._syncRegistry?._grammars?.delete(o.scopeName), this.loadLanguage(this._langMap.get(o.name));
  }
  dispose() {
    super.dispose(), this._resolvedThemes.clear(), this._resolvedGrammars.clear(), this._langMap.clear(), this._langGraph.clear(), this._loadedThemesCache = null;
  }
  loadLanguages(t) {
    for (const i of t)
      this.resolveEmbeddedLanguages(i);
    const n = Array.from(this._langGraph.entries()), r = n.filter(([i, o]) => !o);
    if (r.length) {
      const i = n.filter(([o, s]) => s ? (s.embeddedLanguages || s.embeddedLangs)?.some((c) => r.map(([u]) => u).includes(c)) : !1).filter((o) => !r.includes(o));
      throw new Yf(`Missing languages ${r.map(([o]) => `\`${o}\``).join(", ")}, required by ${i.map(([o]) => `\`${o}\``).join(", ")}`);
    }
    for (const [i, o] of n)
      this._resolver.addLanguage(o);
    for (const [i, o] of n)
      this.loadLanguage(o);
  }
  getLoadedLanguages() {
    return this._loadedLanguagesCache || (this._loadedLanguagesCache = [
      .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
    ]), this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(t) {
    this._langMap.set(t.name, t), this._langGraph.set(t.name, t);
    const n = t.embeddedLanguages ?? t.embeddedLangs;
    if (n)
      for (const r of n)
        this._langGraph.set(r, this._langMap.get(r));
  }
}
class _Ae {
  _langs = /* @__PURE__ */ new Map();
  _scopeToLang = /* @__PURE__ */ new Map();
  _injections = /* @__PURE__ */ new Map();
  _onigLib;
  constructor(t, n) {
    this._onigLib = {
      createOnigScanner: (r) => t.createScanner(r),
      createOnigString: (r) => t.createString(r)
    }, n.forEach((r) => this.addLanguage(r));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(t) {
    return this._langs.get(t);
  }
  loadGrammar(t) {
    return this._scopeToLang.get(t);
  }
  addLanguage(t) {
    this._langs.set(t.name, t), t.aliases && t.aliases.forEach((n) => {
      this._langs.set(n, t);
    }), this._scopeToLang.set(t.scopeName, t), t.injectTo && t.injectTo.forEach((n) => {
      this._injections.get(n) || this._injections.set(n, []), this._injections.get(n).push(t.scopeName);
    });
  }
  getInjections(t) {
    const n = t.split(".");
    let r = [];
    for (let i = 1; i <= n.length; i++) {
      const o = n.slice(0, i).join(".");
      r = [...r, ...this._injections.get(o) || []];
    }
    return r;
  }
}
let fm = 0;
function TAe(e) {
  fm += 1, e.warnings !== !1 && fm >= 10 && fm % 10 === 0 && console.warn(`[Shiki] ${fm} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let t = !1;
  if (!e.engine)
    throw new Yf("`engine` option is required for synchronous mode");
  const n = (e.langs || []).flat(1), r = (e.themes || []).flat(1).map(TN), i = new _Ae(e.engine, n), o = new EAe(i, r, n, e.langAlias);
  let s;
  function a(M) {
    return tH(M, e.langAlias);
  }
  function c(M) {
    S();
    const N = o.getGrammar(typeof M == "string" ? M : M.name);
    if (!N)
      throw new Yf(`Language \`${M}\` not found, you may need to load it first`);
    return N;
  }
  function u(M) {
    if (M === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    S();
    const N = o.getTheme(M);
    if (!N)
      throw new Yf(`Theme \`${M}\` not found, you may need to load it first`);
    return N;
  }
  function f(M) {
    S();
    const N = u(M);
    s !== M && (o.setTheme(N), s = M);
    const D = o.getColorMap();
    return {
      theme: N,
      colorMap: D
    };
  }
  function h() {
    return S(), o.getLoadedThemes();
  }
  function m() {
    return S(), o.getLoadedLanguages();
  }
  function g(...M) {
    S(), o.loadLanguages(M.flat(1));
  }
  async function b(...M) {
    return g(await Q7(M));
  }
  function x(...M) {
    S();
    for (const N of M.flat(1))
      o.loadTheme(N);
  }
  async function w(...M) {
    return S(), x(await eH(M));
  }
  function S() {
    if (t)
      throw new Yf("Shiki instance has been disposed");
  }
  function _() {
    t || (t = !0, o.dispose(), fm -= 1);
  }
  return {
    setTheme: f,
    getTheme: u,
    getLanguage: c,
    getLoadedThemes: h,
    getLoadedLanguages: m,
    resolveLangAlias: a,
    loadLanguage: b,
    loadLanguageSync: g,
    loadTheme: w,
    loadThemeSync: x,
    dispose: _,
    [Symbol.dispose]: _
  };
}
async function AAe(e) {
  e.engine || CAe("`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.");
  const [
    t,
    n,
    r
  ] = await Promise.all([
    eH(e.themes || []),
    Q7(e.langs || []),
    e.engine
  ]);
  return TAe({
    ...e,
    themes: t,
    langs: n,
    engine: r
  });
}
async function MAe(e) {
  const t = await AAe(e);
  return {
    getLastGrammarState: (...n) => uAe(t, ...n),
    codeToTokensBase: (n, r) => EN(t, n, r),
    codeToTokensWithThemes: (n, r) => J7(t, n, r),
    codeToTokens: (n, r) => ax(t, n, r),
    codeToHast: (n, r) => lx(t, n, r),
    codeToHtml: (n, r) => SAe(t, n, r),
    getBundledLanguages: () => ({}),
    getBundledThemes: () => ({}),
    ...t,
    getInternalContext: () => t
  };
}
function NAe(e) {
  const t = e.langs, n = e.themes, r = e.engine;
  async function i(o) {
    function s(h) {
      if (typeof h == "string") {
        if (h = o.langAlias?.[h] || h, G7(h))
          return [];
        const m = t[h];
        if (!m)
          throw new Cr(`Language \`${h}\` is not included in this bundle. You may want to load it from external source.`);
        return m;
      }
      return h;
    }
    function a(h) {
      if (K7(h))
        return "none";
      if (typeof h == "string") {
        const m = n[h];
        if (!m)
          throw new Cr(`Theme \`${h}\` is not included in this bundle. You may want to load it from external source.`);
        return m;
      }
      return h;
    }
    const c = (o.themes ?? []).map((h) => a(h)), u = (o.langs ?? []).map((h) => s(h)), f = await MAe({
      engine: o.engine ?? r(),
      ...o,
      themes: c,
      langs: u
    });
    return {
      ...f,
      loadLanguage(...h) {
        return f.loadLanguage(...h.map(s));
      },
      loadTheme(...h) {
        return f.loadTheme(...h.map(a));
      },
      getBundledLanguages() {
        return t;
      },
      getBundledThemes() {
        return n;
      }
    };
  }
  return i;
}
function RAe(e) {
  let t;
  async function n(r = {}) {
    if (t) {
      const i = await t;
      return await Promise.all([
        i.loadTheme(...r.themes || []),
        i.loadLanguage(...r.langs || [])
      ]), i;
    } else {
      t = e({
        ...r,
        themes: [],
        langs: []
      });
      const i = await t;
      return await Promise.all([
        i.loadTheme(...r.themes || []),
        i.loadLanguage(...r.langs || [])
      ]), i;
    }
  }
  return n;
}
function OAe(e, t) {
  const n = RAe(e);
  async function r(i, o) {
    const s = await n({
      langs: [o.lang],
      themes: "theme" in o ? [o.theme] : Object.values(o.themes)
    }), a = await t?.guessEmbeddedLanguages?.(i, o.lang, s);
    return a && await s.loadLanguage(...a), s;
  }
  return {
    getSingletonHighlighter(i) {
      return n(i);
    },
    async codeToHtml(i, o) {
      return (await r(i, o)).codeToHtml(i, o);
    },
    async codeToHast(i, o) {
      return (await r(i, o)).codeToHast(i, o);
    },
    async codeToTokens(i, o) {
      return (await r(i, o)).codeToTokens(i, o);
    },
    async codeToTokensBase(i, o) {
      return (await r(i, o)).codeToTokensBase(i, o);
    },
    async codeToTokensWithThemes(i, o) {
      return (await r(i, o)).codeToTokensWithThemes(i, o);
    },
    async getLastGrammarState(i, o) {
      return (await n({
        langs: [o.lang],
        themes: [o.theme]
      })).getLastGrammarState(i, o);
    }
  };
}
const PAe = [
  {
    id: "andromeeda",
    displayName: "Andromeeda",
    type: "dark",
    import: (() => import("./andromeeda-BbmzSJq1.js"))
  },
  {
    id: "aurora-x",
    displayName: "Aurora X",
    type: "dark",
    import: (() => import("./aurora-x-BwoVEUWZ.js"))
  },
  {
    id: "ayu-dark",
    displayName: "Ayu Dark",
    type: "dark",
    import: (() => import("./ayu-dark-Dsjk_2Jx.js"))
  },
  {
    id: "ayu-light",
    displayName: "Ayu Light",
    type: "light",
    import: (() => import("./ayu-light-R7pgdmWq.js"))
  },
  {
    id: "ayu-mirage",
    displayName: "Ayu Mirage",
    type: "dark",
    import: (() => import("./ayu-mirage-DraY-SDX.js"))
  },
  {
    id: "catppuccin-frappe",
    displayName: "Catppuccin Frapp",
    type: "dark",
    import: (() => import("./catppuccin-frappe-D3cH2rXe.js"))
  },
  {
    id: "catppuccin-latte",
    displayName: "Catppuccin Latte",
    type: "light",
    import: (() => import("./catppuccin-latte-C0LRGUW4.js"))
  },
  {
    id: "catppuccin-macchiato",
    displayName: "Catppuccin Macchiato",
    type: "dark",
    import: (() => import("./catppuccin-macchiato-c5wQ11TT.js"))
  },
  {
    id: "catppuccin-mocha",
    displayName: "Catppuccin Mocha",
    type: "dark",
    import: (() => import("./catppuccin-mocha-WMD6Qvya.js"))
  },
  {
    id: "dark-plus",
    displayName: "Dark Plus",
    type: "dark",
    import: (() => import("./dark-plus-pUHDTVV0.js"))
  },
  {
    id: "dracula",
    displayName: "Dracula Theme",
    type: "dark",
    import: (() => import("./dracula-BtZx2Kac.js"))
  },
  {
    id: "dracula-soft",
    displayName: "Dracula Theme Soft",
    type: "dark",
    import: (() => import("./dracula-soft-BKa-aqBv.js"))
  },
  {
    id: "everforest-dark",
    displayName: "Everforest Dark",
    type: "dark",
    import: (() => import("./everforest-dark-DMCBqXCK.js"))
  },
  {
    id: "everforest-light",
    displayName: "Everforest Light",
    type: "light",
    import: (() => import("./everforest-light-BbXl82Em.js"))
  },
  {
    id: "github-dark",
    displayName: "GitHub Dark",
    type: "dark",
    import: (() => import("./github-dark-DenFmJkN.js"))
  },
  {
    id: "github-dark-default",
    displayName: "GitHub Dark Default",
    type: "dark",
    import: (() => import("./github-dark-default-BJPUVz4H.js"))
  },
  {
    id: "github-dark-dimmed",
    displayName: "GitHub Dark Dimmed",
    type: "dark",
    import: (() => import("./github-dark-dimmed-DUshB20C.js"))
  },
  {
    id: "github-dark-high-contrast",
    displayName: "GitHub Dark High Contrast",
    type: "dark",
    import: (() => import("./github-dark-high-contrast-D3aGCnF8.js"))
  },
  {
    id: "github-light",
    displayName: "GitHub Light",
    type: "light",
    import: (() => import("./github-light-JYsPkUQd.js"))
  },
  {
    id: "github-light-default",
    displayName: "GitHub Light Default",
    type: "light",
    import: (() => import("./github-light-default-D99KPAby.js"))
  },
  {
    id: "github-light-high-contrast",
    displayName: "GitHub Light High Contrast",
    type: "light",
    import: (() => import("./github-light-high-contrast-BbmZE-Mp.js"))
  },
  {
    id: "gruvbox-dark-hard",
    displayName: "Gruvbox Dark Hard",
    type: "dark",
    import: (() => import("./gruvbox-dark-hard-C5HOtKIh.js"))
  },
  {
    id: "gruvbox-dark-medium",
    displayName: "Gruvbox Dark Medium",
    type: "dark",
    import: (() => import("./gruvbox-dark-medium-FVgwJHuz.js"))
  },
  {
    id: "gruvbox-dark-soft",
    displayName: "Gruvbox Dark Soft",
    type: "dark",
    import: (() => import("./gruvbox-dark-soft-B46F314v.js"))
  },
  {
    id: "gruvbox-light-hard",
    displayName: "Gruvbox Light Hard",
    type: "light",
    import: (() => import("./gruvbox-light-hard-CJD38wDZ.js"))
  },
  {
    id: "gruvbox-light-medium",
    displayName: "Gruvbox Light Medium",
    type: "light",
    import: (() => import("./gruvbox-light-medium-BlIhMYTA.js"))
  },
  {
    id: "gruvbox-light-soft",
    displayName: "Gruvbox Light Soft",
    type: "light",
    import: (() => import("./gruvbox-light-soft-DoPHyLVZ.js"))
  },
  {
    id: "horizon",
    displayName: "Horizon",
    type: "dark",
    import: (() => import("./horizon-CJQ10nlf.js"))
  },
  {
    id: "houston",
    displayName: "Houston",
    type: "dark",
    import: (() => import("./houston-BDYrDoDW.js"))
  },
  {
    id: "kanagawa-dragon",
    displayName: "Kanagawa Dragon",
    type: "dark",
    import: (() => import("./kanagawa-dragon-CiKur4Hl.js"))
  },
  {
    id: "kanagawa-lotus",
    displayName: "Kanagawa Lotus",
    type: "light",
    import: (() => import("./kanagawa-lotus-BKu-smKu.js"))
  },
  {
    id: "kanagawa-wave",
    displayName: "Kanagawa Wave",
    type: "dark",
    import: (() => import("./kanagawa-wave-CQwozSzG.js"))
  },
  {
    id: "laserwave",
    displayName: "LaserWave",
    type: "dark",
    import: (() => import("./laserwave-6a00oqik.js"))
  },
  {
    id: "light-plus",
    displayName: "Light Plus",
    type: "light",
    import: (() => import("./light-plus-CZuVqSLX.js"))
  },
  {
    id: "material-theme",
    displayName: "Material Theme",
    type: "dark",
    import: (() => import("./material-theme-D6KBX41T.js"))
  },
  {
    id: "material-theme-darker",
    displayName: "Material Theme Darker",
    type: "dark",
    import: (() => import("./material-theme-darker-CkRroheE.js"))
  },
  {
    id: "material-theme-lighter",
    displayName: "Material Theme Lighter",
    type: "light",
    import: (() => import("./material-theme-lighter-BUBw43Yz.js"))
  },
  {
    id: "material-theme-ocean",
    displayName: "Material Theme Ocean",
    type: "dark",
    import: (() => import("./material-theme-ocean-ClGX14Ja.js"))
  },
  {
    id: "material-theme-palenight",
    displayName: "Material Theme Palenight",
    type: "dark",
    import: (() => import("./material-theme-palenight-C1RVm8K1.js"))
  },
  {
    id: "min-dark",
    displayName: "Min Dark",
    type: "dark",
    import: (() => import("./min-dark-C7ak0t6c.js"))
  },
  {
    id: "min-light",
    displayName: "Min Light",
    type: "light",
    import: (() => import("./min-light-CKFxVcPp.js"))
  },
  {
    id: "monokai",
    displayName: "Monokai",
    type: "dark",
    import: (() => import("./monokai-C1KBYcO0.js"))
  },
  {
    id: "night-owl",
    displayName: "Night Owl",
    type: "dark",
    import: (() => import("./night-owl-Bm2rzalh.js"))
  },
  {
    id: "night-owl-light",
    displayName: "Night Owl Light",
    type: "light",
    import: (() => import("./night-owl-light-CBI5u5kw.js"))
  },
  {
    id: "nord",
    displayName: "Nord",
    type: "dark",
    import: (() => import("./nord-CC5OiUXg.js"))
  },
  {
    id: "one-dark-pro",
    displayName: "One Dark Pro",
    type: "dark",
    import: (() => import("./one-dark-pro-DTA3VF0_.js"))
  },
  {
    id: "one-light",
    displayName: "One Light",
    type: "light",
    import: (() => import("./one-light-LkMrt1Cf.js"))
  },
  {
    id: "plastic",
    displayName: "Plastic",
    type: "dark",
    import: (() => import("./plastic-CSTz3KZp.js"))
  },
  {
    id: "poimandres",
    displayName: "Poimandres",
    type: "dark",
    import: (() => import("./poimandres-C-VADXHD.js"))
  },
  {
    id: "red",
    displayName: "Red",
    type: "dark",
    import: (() => import("./red-7y8PH7HH.js"))
  },
  {
    id: "rose-pine",
    displayName: "Ros Pine",
    type: "dark",
    import: (() => import("./rose-pine-BKc3yVeu.js"))
  },
  {
    id: "rose-pine-dawn",
    displayName: "Ros Pine Dawn",
    type: "light",
    import: (() => import("./rose-pine-dawn-BulJcPZT.js"))
  },
  {
    id: "rose-pine-moon",
    displayName: "Ros Pine Moon",
    type: "dark",
    import: (() => import("./rose-pine-moon-j6jiXKV8.js"))
  },
  {
    id: "slack-dark",
    displayName: "Slack Dark",
    type: "dark",
    import: (() => import("./slack-dark-i7wN4OET.js"))
  },
  {
    id: "slack-ochin",
    displayName: "Slack Ochin",
    type: "light",
    import: (() => import("./slack-ochin-ndHf0LoP.js"))
  },
  {
    id: "snazzy-light",
    displayName: "Snazzy Light",
    type: "light",
    import: (() => import("./snazzy-light-BlSJXAu4.js"))
  },
  {
    id: "solarized-dark",
    displayName: "Solarized Dark",
    type: "dark",
    import: (() => import("./solarized-dark-UTmkh7lw.js"))
  },
  {
    id: "solarized-light",
    displayName: "Solarized Light",
    type: "light",
    import: (() => import("./solarized-light-BheCkDPT.js"))
  },
  {
    id: "synthwave-84",
    displayName: "Synthwave '84",
    type: "dark",
    import: (() => import("./synthwave-84-NU3C_KFZ.js"))
  },
  {
    id: "tokyo-night",
    displayName: "Tokyo Night",
    type: "dark",
    import: (() => import("./tokyo-night-DP4TmcQl.js"))
  },
  {
    id: "vesper",
    displayName: "Vesper",
    type: "dark",
    import: (() => import("./vesper-BckBta1U.js"))
  },
  {
    id: "vitesse-black",
    displayName: "Vitesse Black",
    type: "dark",
    import: (() => import("./vitesse-black-BoGvW84i.js"))
  },
  {
    id: "vitesse-dark",
    displayName: "Vitesse Dark",
    type: "dark",
    import: (() => import("./vitesse-dark-Cym-eLtO.js"))
  },
  {
    id: "vitesse-light",
    displayName: "Vitesse Light",
    type: "light",
    import: (() => import("./vitesse-light-CcmG315c.js"))
  }
], DAe = Object.fromEntries(PAe.map((e) => [e.id, e.import]));
class AN extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
}
function IAe() {
  return 2147483648;
}
function jAe() {
  return typeof performance < "u" ? performance.now() : Date.now();
}
const zAe = (e, t) => e + (t - e % t) % t;
async function LAe(e) {
  let t, n;
  const r = {};
  function i(g) {
    n = g, r.HEAPU8 = new Uint8Array(g), r.HEAPU32 = new Uint32Array(g);
  }
  function o(g, b, x) {
    r.HEAPU8.copyWithin(g, b, b + x);
  }
  function s(g) {
    try {
      return t.grow(g - n.byteLength + 65535 >>> 16), i(t.buffer), 1;
    } catch {
    }
  }
  function a(g) {
    const b = r.HEAPU8.length;
    g = g >>> 0;
    const x = IAe();
    if (g > x)
      return !1;
    for (let w = 1; w <= 4; w *= 2) {
      let S = b * (1 + 0.2 / w);
      S = Math.min(S, g + 100663296);
      const _ = Math.min(x, zAe(Math.max(g, S), 65536));
      if (s(_))
        return !0;
    }
    return !1;
  }
  const c = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
  function u(g, b, x = 1024) {
    const w = b + x;
    let S = b;
    for (; g[S] && !(S >= w); ) ++S;
    if (S - b > 16 && g.buffer && c)
      return c.decode(g.subarray(b, S));
    let _ = "";
    for (; b < S; ) {
      let M = g[b++];
      if (!(M & 128)) {
        _ += String.fromCharCode(M);
        continue;
      }
      const N = g[b++] & 63;
      if ((M & 224) === 192) {
        _ += String.fromCharCode((M & 31) << 6 | N);
        continue;
      }
      const D = g[b++] & 63;
      if ((M & 240) === 224 ? M = (M & 15) << 12 | N << 6 | D : M = (M & 7) << 18 | N << 12 | D << 6 | g[b++] & 63, M < 65536)
        _ += String.fromCharCode(M);
      else {
        const j = M - 65536;
        _ += String.fromCharCode(55296 | j >> 10, 56320 | j & 1023);
      }
    }
    return _;
  }
  function f(g, b) {
    return g ? u(r.HEAPU8, g, b) : "";
  }
  const h = {
    emscripten_get_now: jAe,
    emscripten_memcpy_big: o,
    emscripten_resize_heap: a,
    fd_write: () => 0
  };
  async function m() {
    const b = await e({
      env: h,
      wasi_snapshot_preview1: h
    });
    t = b.memory, i(t.buffer), Object.assign(r, b), r.UTF8ToString = f;
  }
  return await m(), r;
}
var BAe = Object.defineProperty, $Ae = (e, t, n) => t in e ? BAe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Dr = (e, t, n) => $Ae(e, typeof t != "symbol" ? t + "" : t, n);
let Fr = null;
function UAe(e) {
  throw new AN(e.UTF8ToString(e.getLastOnigError()));
}
class e1 {
  constructor(t) {
    Dr(this, "utf16Length"), Dr(this, "utf8Length"), Dr(this, "utf16Value"), Dr(this, "utf8Value"), Dr(this, "utf16OffsetToUtf8"), Dr(this, "utf8OffsetToUtf16");
    const n = t.length, r = e1._utf8ByteLength(t), i = r !== n, o = i ? new Uint32Array(n + 1) : null;
    i && (o[n] = r);
    const s = i ? new Uint32Array(r + 1) : null;
    i && (s[r] = n);
    const a = new Uint8Array(r);
    let c = 0;
    for (let u = 0; u < n; u++) {
      const f = t.charCodeAt(u);
      let h = f, m = !1;
      if (f >= 55296 && f <= 56319 && u + 1 < n) {
        const g = t.charCodeAt(u + 1);
        g >= 56320 && g <= 57343 && (h = (f - 55296 << 10) + 65536 | g - 56320, m = !0);
      }
      i && (o[u] = c, m && (o[u + 1] = c), h <= 127 ? s[c + 0] = u : h <= 2047 ? (s[c + 0] = u, s[c + 1] = u) : h <= 65535 ? (s[c + 0] = u, s[c + 1] = u, s[c + 2] = u) : (s[c + 0] = u, s[c + 1] = u, s[c + 2] = u, s[c + 3] = u)), h <= 127 ? a[c++] = h : h <= 2047 ? (a[c++] = 192 | (h & 1984) >>> 6, a[c++] = 128 | (h & 63) >>> 0) : h <= 65535 ? (a[c++] = 224 | (h & 61440) >>> 12, a[c++] = 128 | (h & 4032) >>> 6, a[c++] = 128 | (h & 63) >>> 0) : (a[c++] = 240 | (h & 1835008) >>> 18, a[c++] = 128 | (h & 258048) >>> 12, a[c++] = 128 | (h & 4032) >>> 6, a[c++] = 128 | (h & 63) >>> 0), m && u++;
    }
    this.utf16Length = n, this.utf8Length = r, this.utf16Value = t, this.utf8Value = a, this.utf16OffsetToUtf8 = o, this.utf8OffsetToUtf16 = s;
  }
  static _utf8ByteLength(t) {
    let n = 0;
    for (let r = 0, i = t.length; r < i; r++) {
      const o = t.charCodeAt(r);
      let s = o, a = !1;
      if (o >= 55296 && o <= 56319 && r + 1 < i) {
        const c = t.charCodeAt(r + 1);
        c >= 56320 && c <= 57343 && (s = (o - 55296 << 10) + 65536 | c - 56320, a = !0);
      }
      s <= 127 ? n += 1 : s <= 2047 ? n += 2 : s <= 65535 ? n += 3 : n += 4, a && r++;
    }
    return n;
  }
  createString(t) {
    const n = t.omalloc(this.utf8Length);
    return t.HEAPU8.set(this.utf8Value, n), n;
  }
}
const t1 = class $s {
  constructor(t) {
    if (Dr(this, "id", ++$s.LAST_ID), Dr(this, "_onigBinding"), Dr(this, "content"), Dr(this, "utf16Length"), Dr(this, "utf8Length"), Dr(this, "utf16OffsetToUtf8"), Dr(this, "utf8OffsetToUtf16"), Dr(this, "ptr"), !Fr)
      throw new AN("Must invoke loadWasm first.");
    this._onigBinding = Fr, this.content = t;
    const n = new e1(t);
    this.utf16Length = n.utf16Length, this.utf8Length = n.utf8Length, this.utf16OffsetToUtf8 = n.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = n.utf8OffsetToUtf16, this.utf8Length < 1e4 && !$s._sharedPtrInUse ? ($s._sharedPtr || ($s._sharedPtr = Fr.omalloc(1e4)), $s._sharedPtrInUse = !0, Fr.HEAPU8.set(n.utf8Value, $s._sharedPtr), this.ptr = $s._sharedPtr) : this.ptr = n.createString(Fr);
  }
  convertUtf8OffsetToUtf16(t) {
    return this.utf8OffsetToUtf16 ? t < 0 ? 0 : t > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[t] : t;
  }
  convertUtf16OffsetToUtf8(t) {
    return this.utf16OffsetToUtf8 ? t < 0 ? 0 : t > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[t] : t;
  }
  dispose() {
    this.ptr === $s._sharedPtr ? $s._sharedPtrInUse = !1 : this._onigBinding.ofree(this.ptr);
  }
};
Dr(t1, "LAST_ID", 0);
Dr(t1, "_sharedPtr", 0);
Dr(t1, "_sharedPtrInUse", !1);
let nH = t1;
class FAe {
  constructor(t) {
    if (Dr(this, "_onigBinding"), Dr(this, "_ptr"), !Fr)
      throw new AN("Must invoke loadWasm first.");
    const n = [], r = [];
    for (let a = 0, c = t.length; a < c; a++) {
      const u = new e1(t[a]);
      n[a] = u.createString(Fr), r[a] = u.utf8Length;
    }
    const i = Fr.omalloc(4 * t.length);
    Fr.HEAPU32.set(n, i / 4);
    const o = Fr.omalloc(4 * t.length);
    Fr.HEAPU32.set(r, o / 4);
    const s = Fr.createOnigScanner(i, o, t.length);
    for (let a = 0, c = t.length; a < c; a++)
      Fr.ofree(n[a]);
    Fr.ofree(o), Fr.ofree(i), s === 0 && UAe(Fr), this._onigBinding = Fr, this._ptr = s;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(t, n, r) {
    let i = 0;
    if (typeof r == "number" && (i = r), typeof t == "string") {
      t = new nH(t);
      const o = this._findNextMatchSync(t, n, !1, i);
      return t.dispose(), o;
    }
    return this._findNextMatchSync(t, n, !1, i);
  }
  _findNextMatchSync(t, n, r, i) {
    const o = this._onigBinding, s = o.findNextOnigScannerMatch(this._ptr, t.id, t.ptr, t.utf8Length, t.convertUtf16OffsetToUtf8(n), i);
    if (s === 0)
      return null;
    const a = o.HEAPU32;
    let c = s / 4;
    const u = a[c++], f = a[c++], h = [];
    for (let m = 0; m < f; m++) {
      const g = t.convertUtf8OffsetToUtf16(a[c++]), b = t.convertUtf8OffsetToUtf16(a[c++]);
      h[m] = {
        start: g,
        end: b,
        length: b - g
      };
    }
    return {
      index: u,
      captureIndices: h
    };
  }
}
function VAe(e) {
  return typeof e.instantiator == "function";
}
function HAe(e) {
  return typeof e.default == "function";
}
function WAe(e) {
  return typeof e.data < "u";
}
function qAe(e) {
  return typeof Response < "u" && e instanceof Response;
}
function GAe(e) {
  return typeof ArrayBuffer < "u" && (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) || typeof Buffer < "u" && Buffer.isBuffer?.(e) || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer || typeof Uint32Array < "u" && e instanceof Uint32Array;
}
let l0;
function KAe(e) {
  if (l0)
    return l0;
  async function t() {
    Fr = await LAe(async (n) => {
      let r = e;
      return r = await r, typeof r == "function" && (r = await r(n)), typeof r == "function" && (r = await r(n)), VAe(r) ? r = await r.instantiator(n) : HAe(r) ? r = await r.default(n) : (WAe(r) && (r = r.data), qAe(r) ? typeof WebAssembly.instantiateStreaming == "function" ? r = await ZAe(r)(n) : r = await YAe(r)(n) : GAe(r) ? r = await eE(r)(n) : r instanceof WebAssembly.Module ? r = await eE(r)(n) : "default" in r && r.default instanceof WebAssembly.Module && (r = await eE(r.default)(n))), "instance" in r && (r = r.instance), "exports" in r && (r = r.exports), r;
    });
  }
  return l0 = t(), l0;
}
function eE(e) {
  return (t) => WebAssembly.instantiate(e, t);
}
function ZAe(e) {
  return (t) => WebAssembly.instantiateStreaming(e, t);
}
function YAe(e) {
  return async (t) => {
    const n = await e.arrayBuffer();
    return WebAssembly.instantiate(n, t);
  };
}
async function XAe(e) {
  return e && await KAe(e), {
    createScanner(t) {
      return new FAe(t.map((n) => typeof n == "string" ? n : n.source));
    },
    createString(t) {
      return new nH(t);
    }
  };
}
const rH = [
  {
    id: "angular-html",
    name: "Angular HTML",
    import: (() => import("./angular-html-DPB4Rf0C.js").then((e) => e.f))
  },
  {
    id: "angular-ts",
    name: "Angular TypeScript",
    import: (() => import("./angular-ts-CTOR2ofC.js"))
  },
  {
    id: "astro",
    name: "Astro",
    import: (() => import("./astro-CFFExE8Q.js"))
  },
  {
    id: "blade",
    name: "Blade",
    import: (() => import("./blade-D0HyNvCw.js"))
  },
  {
    id: "c",
    name: "C",
    import: (() => import("./c-eeMepfLm.js"))
  },
  {
    id: "coffee",
    name: "CoffeeScript",
    aliases: [
      "coffeescript"
    ],
    import: (() => import("./coffee-DGBR_nr_.js"))
  },
  {
    id: "cpp",
    name: "C++",
    aliases: [
      "c++"
    ],
    import: (() => import("./cpp-Cj177cuW.js"))
  },
  {
    id: "css",
    name: "CSS",
    import: (() => import("./css-CECN5uSL.js"))
  },
  {
    id: "csv",
    name: "CSV",
    import: (() => import("./csv-CmYOceLb.js"))
  },
  {
    id: "glsl",
    name: "GLSL",
    import: (() => import("./glsl-CkUcVZNK.js"))
  },
  {
    id: "graphql",
    name: "GraphQL",
    aliases: [
      "gql"
    ],
    import: (() => import("./graphql-CBu2ehBn.js"))
  },
  {
    id: "haml",
    name: "Ruby Haml",
    import: (() => import("./haml-NZLVzu_R.js"))
  },
  {
    id: "handlebars",
    name: "Handlebars",
    aliases: [
      "hbs"
    ],
    import: (() => import("./handlebars-mxStpSE7.js"))
  },
  {
    id: "html",
    name: "HTML",
    import: (() => import("./html-B50bmoVb.js"))
  },
  {
    id: "html-derivative",
    name: "HTML (Derivative)",
    import: (() => import("./html-derivative-C6bxFbFW.js"))
  },
  {
    id: "http",
    name: "HTTP",
    import: (() => import("./http-DLvAkeD-.js"))
  },
  {
    id: "hurl",
    name: "Hurl",
    import: (() => import("./hurl-CgkFN90t.js"))
  },
  {
    id: "imba",
    name: "Imba",
    import: (() => import("./imba-CimUv-Uh.js"))
  },
  {
    id: "java",
    name: "Java",
    import: (() => import("./java-DY6VlHhP.js"))
  },
  {
    id: "javascript",
    name: "JavaScript",
    aliases: [
      "js",
      "cjs",
      "mjs"
    ],
    import: (() => import("./javascript-C25yR2R2.js"))
  },
  {
    id: "jinja",
    name: "Jinja",
    import: (() => import("./jinja-CFW5uAwY.js"))
  },
  {
    id: "jison",
    name: "Jison",
    import: (() => import("./jison-DdreslRX.js"))
  },
  {
    id: "json",
    name: "JSON",
    import: (() => import("./json-DxJze_jm.js"))
  },
  {
    id: "json5",
    name: "JSON5",
    import: (() => import("./json5-BT4Fjg39.js"))
  },
  {
    id: "jsonc",
    name: "JSON with Comments",
    import: (() => import("./jsonc-CHjZD8gR.js"))
  },
  {
    id: "jsonl",
    name: "JSON Lines",
    import: (() => import("./jsonl-BGuvDmy9.js"))
  },
  {
    id: "jsx",
    name: "JSX",
    import: (() => import("./jsx-BtKADgXT.js"))
  },
  {
    id: "julia",
    name: "Julia",
    aliases: [
      "jl"
    ],
    import: (() => import("./julia-CZiKXNNP.js"))
  },
  {
    id: "less",
    name: "Less",
    import: (() => import("./less-B1GLI2Di.js"))
  },
  {
    id: "markdown",
    name: "Markdown",
    aliases: [
      "md"
    ],
    import: (() => import("./markdown-CrScaQ96.js"))
  },
  {
    id: "marko",
    name: "Marko",
    import: (() => import("./marko-Ns9BYtDO.js"))
  },
  {
    id: "mdc",
    name: "MDC",
    import: (() => import("./mdc-uaivvctV.js"))
  },
  {
    id: "mdx",
    name: "MDX",
    import: (() => import("./mdx-BOhZZUJ8.js"))
  },
  {
    id: "php",
    name: "PHP",
    import: (() => import("./php-BIzsF_5x.js"))
  },
  {
    id: "postcss",
    name: "PostCSS",
    import: (() => import("./postcss-05aHdL-n.js"))
  },
  {
    id: "pug",
    name: "Pug",
    aliases: [
      "jade"
    ],
    import: (() => import("./pug-XOw9Q1Ho.js"))
  },
  {
    id: "python",
    name: "Python",
    aliases: [
      "py"
    ],
    import: (() => import("./python-BFNSHbwJ.js"))
  },
  {
    id: "r",
    name: "R",
    import: (() => import("./r-CSmzDPi7.js"))
  },
  {
    id: "regexp",
    name: "RegExp",
    aliases: [
      "regex"
    ],
    import: (() => import("./regexp-BazyLpPg.js"))
  },
  {
    id: "sass",
    name: "Sass",
    import: (() => import("./sass-DxHp5rTx.js"))
  },
  {
    id: "scss",
    name: "SCSS",
    import: (() => import("./scss-B1FaCqwR.js"))
  },
  {
    id: "shellscript",
    name: "Shell",
    aliases: [
      "bash",
      "sh",
      "shell",
      "zsh"
    ],
    import: (() => import("./shellscript-InADTalH.js"))
  },
  {
    id: "sql",
    name: "SQL",
    import: (() => import("./sql-Cn_v3PB0.js"))
  },
  {
    id: "stylus",
    name: "Stylus",
    aliases: [
      "styl"
    ],
    import: (() => import("./stylus-CyKEU1Ej.js"))
  },
  {
    id: "svelte",
    name: "Svelte",
    import: (() => import("./svelte-CYf4HR3U.js"))
  },
  {
    id: "ts-tags",
    name: "TypeScript with Tags",
    aliases: [
      "lit"
    ],
    import: (() => import("./ts-tags-ioVe2PKw.js"))
  },
  {
    id: "tsx",
    name: "TSX",
    import: (() => import("./tsx-B8rCNbgL.js"))
  },
  {
    id: "typescript",
    name: "TypeScript",
    aliases: [
      "ts",
      "cts",
      "mts"
    ],
    import: (() => import("./typescript-RycA9KXf.js"))
  },
  {
    id: "vue",
    name: "Vue",
    import: (() => import("./vue-DXEmyXn9.js"))
  },
  {
    id: "vue-html",
    name: "Vue HTML",
    import: (() => import("./vue-html-j9xNEdu3.js"))
  },
  {
    id: "vue-vine",
    name: "Vue Vine",
    import: (() => import("./vue-vine-D41-N99t.js"))
  },
  {
    id: "wasm",
    name: "WebAssembly",
    import: (() => import("./wasm-BBXxrAl7.js"))
  },
  {
    id: "wgsl",
    name: "WGSL",
    import: (() => import("./wgsl-DY4iK1q1.js"))
  },
  {
    id: "wit",
    name: "WebAssembly Interface Types",
    import: (() => import("./wit-CQMQOlTg.js"))
  },
  {
    id: "xml",
    name: "XML",
    import: (() => import("./xml-C2J0sS9M.js"))
  },
  {
    id: "yaml",
    name: "YAML",
    aliases: [
      "yml"
    ],
    import: (() => import("./yaml-DaO7k5B1.js"))
  }
], JAe = Object.fromEntries(rH.map((e) => [e.id, e.import])), QAe = Object.fromEntries(rH.flatMap((e) => e.aliases?.map((t) => [t, e.import]) || [])), iH = {
  ...JAe,
  ...QAe
}, eMe = /* @__PURE__ */ NAe({
  langs: iH,
  themes: DAe,
  engine: () => XAe(import("./wasm-DQxwEHae.js"))
}), {
  codeToHast: tMe
} = /* @__PURE__ */ OAe(
  eMe,
  { guessEmbeddedLanguages: WTe }
);
var oH = (e) => typeof e == "function", Xf = (e) => oH(e?.then), nMe = (e) => {
  try {
    return e instanceof Error ? e : typeof e == "string" ? new Error(e) : new Error(JSON.stringify(e));
  } catch (t) {
    return t;
  }
}, X0 = (e) => ({ isOk: !0, error: void 0, value: e }), J0 = (e) => ({ isOk: !1, error: nMe(e), value: void 0 }), rMe = (e, t) => {
  if (Xf(e)) return e.then(t).then(X0, J0);
  try {
    let n = t(e);
    return Xf(n) ? n.then((r) => Promise.resolve(X0(r)), (r) => Promise.resolve(J0(r))) : X0(n);
  } catch (n) {
    return J0(n);
  }
}, n1 = { ok: X0, fail: J0, update: rMe }, r1 = (e) => {
  let t = (n) => r1(n1.update(e, n));
  return { map(n) {
    return t((r) => {
      if (r.isOk) return n(r.value);
      throw r.error;
    });
  }, flatMap(n) {
    return t((r) => {
      if (r.isOk) return n(r.value).unwrap();
      throw r.error;
    });
  }, effect(n) {
    return t((r) => {
      if (!r.isOk) throw r.error;
      let i = n(r.value);
      return Xf(i) ? i.then(() => r.value) : r.value;
    });
  }, ifOk(n) {
    return t((r) => {
      if (!r.isOk) throw r.error;
      let i = n(r.value);
      return Xf(i) ? i.then(() => r.value) : r.value;
    });
  }, watch(n) {
    return t((r) => {
      try {
        n({ ...r });
      } catch {
      }
      if (r.isOk) return r.value;
      throw r.error;
    });
  }, catch(n) {
    return t((r) => r.isOk ? r.value : n(r.error));
  }, ifFail(n) {
    return t((r) => r.isOk ? r.value : n(r.error));
  }, unwrap() {
    if (Xf(e)) return e.then((n) => {
      if (n.isOk) return n.value;
      throw n.error;
    });
    if (e.isOk) return e.value;
    throw e.error;
  }, isOk: Xf(e) ? e.then((n) => Promise.resolve(n.isOk)) : e.isOk, orElse(n) {
    return t((r) => r.isOk ? r.value : n).unwrap();
  } };
};
function sH(e) {
  let t = r1(n1.ok(void 0));
  try {
    return t.map(() => e);
  } catch (n) {
    return t.map(() => {
      throw n;
    });
  }
}
function iMe(e) {
  let t = r1(n1.ok(void 0));
  try {
    return t.map(() => e());
  } catch (n) {
    return t.map(() => {
      throw n;
    });
  }
}
function oMe() {
  return r1(n1.ok(void 0));
}
function sMe(...e) {
  return (t) => {
    let n = sH(t);
    return e.reduce((r, i) => r.map(i), n);
  };
}
function MN(e) {
  return e === void 0 ? oMe() : oH(e) ? iMe(e) : sH(e);
}
MN.pipe = sMe;
const NN = (e = 2e3) => {
  const [t, n] = C.useState(!1);
  return { copied: t, copy: (i) => {
    navigator.clipboard.writeText(i), n(!0), setTimeout(() => {
      n(!1);
    }, e);
  } };
};
function RN(...e) {
  return e.filter(Boolean).join(" ");
}
function aMe() {
  const [e, t] = C.useState(
    () => typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
  );
  return C.useEffect(() => {
    if (typeof window > "u" || !window.matchMedia) return;
    const n = window.matchMedia("(prefers-color-scheme: dark)"), r = () => t(n.matches ? "dark" : "light");
    return n.addEventListener?.("change", r), () => n.removeEventListener?.("change", r);
  }, []), e;
}
const lMe = Ne.lazy(async () => ({ default: (await import("./mermaid-diagram-B0fiyy13.js")).MermaidDiagram })), cMe = () => /* @__PURE__ */ v.jsxs("div", { className: "text-sm flex bg-accent/30 flex-col rounded-2xl relative my-4 overflow-hidden border", children: [
  /* @__PURE__ */ v.jsx("div", { className: "w-full flex z-20 py-2 px-4 items-center", children: /* @__PURE__ */ v.jsx("span", { className: "text-sm text-muted-foreground", children: "mermaid" }) }),
  /* @__PURE__ */ v.jsx("div", { className: "relative overflow-x-auto px-6 pb-6", children: /* @__PURE__ */ v.jsx("div", { className: "h-20 w-full flex items-center justify-center", children: /* @__PURE__ */ v.jsx("span", { className: "text-muted-foreground", children: "Loading Mermaid renderer" }) }) })
] }), uMe = C.memo(function(t) {
  const { className: n, active: r, ...i } = t;
  return /* @__PURE__ */ v.jsx(
    "button",
    {
      ...i,
      className: RN(
        "inline-flex items-center justify-center rounded-sm",
        "transition-colors focus:outline-none",
        r ? "bg-secondary text-foreground" : "hover:bg-muted text-muted-foreground",
        "h-7 w-7",
        n
      )
    }
  );
});
function Q0({
  lang: e,
  code: t,
  children: n,
  className: r
}) {
  const { copied: i, copy: o } = NN();
  return /* @__PURE__ */ v.jsxs("pre", { className: RN("relative", r), children: [
    /* @__PURE__ */ v.jsx("div", { className: "p-1.5 border-b mb-4 z-20 bg-secondary", children: /* @__PURE__ */ v.jsxs("div", { className: "w-full flex z-20 py-0.5 px-4 items-center gap-2", children: [
      /* @__PURE__ */ v.jsx("span", { className: "text-xs uppercase tracking-wide text-muted-foreground", children: e }),
      /* @__PURE__ */ v.jsx(
        uMe,
        {
          onClick: () => o(t),
          title: "Copy code",
          "aria-label": "Copy",
          active: i,
          className: "ml-auto",
          children: i ? /* @__PURE__ */ v.jsx(Tc, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(Ac, { className: "h-4 w-4" })
        }
      )
    ] }) }),
    /* @__PURE__ */ v.jsx("div", { className: "relative overflow-x-auto px-6 pb-6", children: n })
  ] });
}
async function dMe(e, t, n) {
  const r = typeof t == "string" && t in iH ? t : "md";
  if (t === "json")
    return /* @__PURE__ */ v.jsx(Q0, { code: e, lang: "json", children: /* @__PURE__ */ v.jsx(id, { data: e, initialExpandDepth: 3 }) });
  if (t === "mermaid")
    return /* @__PURE__ */ v.jsx(Q0, { code: e, lang: "mermaid", children: /* @__PURE__ */ v.jsx(C.Suspense, { fallback: /* @__PURE__ */ v.jsx(cMe, {}), children: /* @__PURE__ */ v.jsx(lMe, { chart: e }) }) });
  const i = await tMe(e, { lang: r, theme: n });
  return RV(i, {
    Fragment: C.Fragment,
    jsx: v.jsx,
    jsxs: v.jsxs,
    components: {
      pre: (o) => /* @__PURE__ */ v.jsx(Q0, { ...o, code: e, lang: String(t) })
    }
  });
}
function fMe({ children: e }) {
  const t = e?.props?.children ?? "", n = e?.props?.className?.split("-")?.[1] || "bash", i = aMe() === "dark" ? "dark-plus" : "github-light", [o, s] = C.useState(!0), [a, c] = C.useState(
    /* @__PURE__ */ v.jsx(Q0, { className: "animate-pulse", code: t, lang: n, children: e })
  );
  return C.useLayoutEffect(() => {
    MN().map(() => dMe(t, n, i)).ifOk(c).watch(() => s(!1));
  }, [i, n, t]), /* @__PURE__ */ v.jsx(
    "div",
    {
      className: RN(
        o && "animate-pulse",
        "text-sm flex bg-secondary/40 shadow border flex-col rounded relative my-4 overflow-hidden"
      ),
      children: a
    }
  );
}
function aH({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "table-container",
      className: "relative w-full overflow-x-auto",
      children: /* @__PURE__ */ v.jsx(
        "table",
        {
          "data-slot": "table",
          className: lt("w-full caption-bottom text-sm", e),
          ...t
        }
      )
    }
  );
}
function lH({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "thead",
    {
      "data-slot": "table-header",
      className: lt("[&_tr]:border-b", e),
      ...t
    }
  );
}
function cH({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "tbody",
    {
      "data-slot": "table-body",
      className: lt("[&_tr:last-child]:border-0", e),
      ...t
    }
  );
}
function eb({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "tr",
    {
      "data-slot": "table-row",
      className: lt(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        e
      ),
      ...t
    }
  );
}
function uH({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "th",
    {
      "data-slot": "table-head",
      className: lt(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        e
      ),
      ...t
    }
  );
}
function kT({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "td",
    {
      "data-slot": "table-cell",
      className: lt(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        e
      ),
      ...t
    }
  );
}
const dH = C.memo(({ children: e }) => /* @__PURE__ */ v.jsxs("span", { className: "fade-in animate-in duration-1000", children: [
  e,
  " "
] }));
dH.displayName = "FadeIn";
const hMe = C.memo(({ children: e }) => xh(e) ? /* @__PURE__ */ v.jsx(mg, { text: e }) : /* @__PURE__ */ v.jsx(v.Fragment, { children: e }));
hMe.displayName = "EntityText";
const Ur = C.memo(({ children: e }) => {
  if (xh(e))
    return /* @__PURE__ */ v.jsx("span", { className: "fade-in animate-in duration-1000", children: /* @__PURE__ */ v.jsx(mg, { text: e }) });
  const t = [e].flat();
  return /* @__PURE__ */ v.jsx(v.Fragment, { children: t.map(
    (n, r) => xh(n) ? /* @__PURE__ */ v.jsx(dH, { children: /* @__PURE__ */ v.jsx(mg, { text: n }) }, r) : n
  ) });
});
Ur.displayName = "WordByWordFadeIn";
const pMe = {
  table: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("div", { className: "my-1", children: /* @__PURE__ */ v.jsx(aH, { ...n, children: t }) }),
  thead: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(lH, { ...n, children: t }),
  tbody: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(cH, { ...n, children: t }),
  tr: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(eb, { ...n, children: t }),
  th: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(uH, { ...n, children: /* @__PURE__ */ v.jsx(Ur, { children: t }) }),
  td: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(kT, { ...n, children: /* @__PURE__ */ v.jsx(Ur, { children: t }) }),
  code: ({ children: e }) => /* @__PURE__ */ v.jsx("code", { className: "text-sm rounded-md bg-accent text-primary py-1 px-2 mx-0.5", children: /* @__PURE__ */ v.jsx(Ur, { children: e }) }),
  blockquote: ({ children: e }) => /* @__PURE__ */ v.jsx("div", { className: "px-4", children: /* @__PURE__ */ v.jsx("blockquote", { className: "relative bg-accent/30 p-6 rounded-2xl my-2 overflow-hidden border", children: /* @__PURE__ */ v.jsx(Ur, { children: e }) }) }),
  p: ({ children: e }) => /* @__PURE__ */ v.jsx("p", { className: "leading-6 my-1 break-words", children: /* @__PURE__ */ v.jsx(Ur, { children: e }) }),
  pre: ({ children: e }) => /* @__PURE__ */ v.jsx("div", { className: "px-4 py-2", children: /* @__PURE__ */ v.jsx(fMe, { children: e }) }),
  ol: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("ol", { className: "px-4 list-decimal list-outside ol-context", ...n, children: /* @__PURE__ */ v.jsx(Ur, { children: t }) }),
  ul: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("ul", { className: "px-4 list-none ul-context", ...n, children: /* @__PURE__ */ v.jsx(Ur, { children: t }) }),
  li: ({ node: e, children: t, ...n }) => {
    const r = C.useRef(null), [i, o] = C.useState(!1);
    return C.useEffect(() => {
      r.current?.parentElement?.tagName === "UL" && o(!0);
    }, []), /* @__PURE__ */ v.jsx("li", { ref: r, className: "py-1 break-words", ...n, children: i ? /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
      /* @__PURE__ */ v.jsx("span", { className: "text-green-500 mt-0.5", children: "" }),
      /* @__PURE__ */ v.jsx("div", { className: "flex-1", children: /* @__PURE__ */ v.jsx(Ur, { children: t }) })
    ] }) : /* @__PURE__ */ v.jsx(Ur, { children: t }) });
  },
  strong: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("span", { className: "font-semibold", ...n, children: /* @__PURE__ */ v.jsx(Ur, { children: t }) }),
  a: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsxs(
    "a",
    {
      className: "text-primary hover:underline flex gap-1.5 items-center",
      target: "_blank",
      rel: "noreferrer",
      ...n,
      children: [
        /* @__PURE__ */ v.jsx(HY, { className: "size-3.5" }),
        /* @__PURE__ */ v.jsx(Ur, { children: t })
      ]
    }
  ),
  h1: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h1", { className: "text-3xl font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Ur, { children: t }) }),
  h2: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h2", { className: "text-2xl font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Ur, { children: t }) }),
  h3: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h3", { className: "text-xl font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Ur, { children: t }) }),
  h4: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h4", { className: "text-lg font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Ur, { children: t }) }),
  h5: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h5", { className: "text-base font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Ur, { children: t }) }),
  h6: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h6", { className: "text-sm font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Ur, { children: t }) }),
  img: ({ node: e, children: t, ...n }) => {
    const { src: r, alt: i, ...o } = n;
    return r ? (
      // eslint-disable-next-line @next/next/no-img-element
      /* @__PURE__ */ v.jsx("img", { className: "mx-auto rounded-lg", src: r, alt: i, ...o })
    ) : null;
  }
}, mMe = ({ children: e }) => /* @__PURE__ */ v.jsx("article", { className: "w-full h-full relative", children: ece(e) ? /* @__PURE__ */ v.jsx(id, { data: e }) : /* @__PURE__ */ v.jsx(Bke, { components: pMe, remarkPlugins: [QEe], children: e }) }), fH = C.memo(
  mMe,
  (e, t) => e.children === t.children
), gMe = ({
  reasoningText: e,
  isThinking: t
}) => {
  const [n, r] = C.useState(!!t), [i, o] = C.useState(!!t);
  return C.useEffect(() => {
    t && !i ? (r(!0), o(!0)) : !t && i && (r(!1), o(!1));
  }, [t, i]), !e && !t ? null : /* @__PURE__ */ v.jsx("div", { className: "text-xs", children: n && /* @__PURE__ */ v.jsx("div", { className: "mt-2 pl-4 text-muted-foreground bg-muted/20 p-2 rounded-md", children: /* @__PURE__ */ v.jsx(fH, { children: e || (t ? "Reasoning..." : "No reasoning content available") }) }) });
}, yMe = C.memo(gMe), hH = ({
  text: e,
  onReuseMessage: t,
  onRegenerate: n,
  className: r = ""
}) => {
  const [i, o] = C.useState(!1), [s, a] = C.useState(!1), [c, u] = C.useState(!1), f = async (g) => {
    g.preventDefault(), g.stopPropagation();
    try {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(e ?? ""), o(!0), Vt.success("Message copied to clipboard", { duration: 2e3 }), setTimeout(() => o(!1), 3e3);
        return;
      }
      if (navigator.clipboard)
        try {
          await navigator.clipboard.writeText(e ?? ""), o(!0), setTimeout(() => o(!1), 3e3);
          return;
        } catch (x) {
          console.warn("Clipboard API failed, trying selection fallback:", x);
        }
      const b = document.createElement("textarea");
      b.value = e ?? "", b.style.position = "fixed", b.style.left = "-9999px", b.style.top = "-9999px", b.style.opacity = "0", b.setAttribute("readonly", ""), document.body.appendChild(b);
      try {
        b.select(), b.setSelectionRange(0, b.value.length);
        const x = window.getSelection();
        if (x) {
          x.removeAllRanges();
          const w = document.createRange();
          w.selectNodeContents(b), x.addRange(w), o(!0), setTimeout(() => o(!1), 3e3);
        } else
          throw new Error("Selection API not supported");
      } finally {
        document.body.removeChild(b);
      }
    } catch (b) {
      console.warn("All copy methods failed:", b), alert("Unable to copy automatically. Please select and copy the text manually.");
    }
  }, h = async (g) => {
    if (g.preventDefault(), g.stopPropagation(), t && e && !s)
      try {
        a(!0), await new Promise((b) => setTimeout(b, 300)), t(e);
      } finally {
        a(!1);
      }
  }, m = async (g) => {
    if (g.preventDefault(), g.stopPropagation(), n && !c)
      try {
        u(!0), await n(), Vt.success("Regenerating response...", { duration: 2e3 });
      } catch {
        Vt.error("Failed to regenerate", { duration: 2e3 });
      } finally {
        u(!1);
      }
  };
  return /* @__PURE__ */ v.jsxs("div", { className: `flex gap-1 ${r}`, "data-testid": "message-action-buttons", children: [
    n && /* @__PURE__ */ v.jsx(
      "button",
      {
        "aria-label": c ? "Regenerating..." : "Regenerate response",
        title: c ? "Regenerating..." : "Regenerate response",
        onClick: (g) => m(g),
        disabled: c,
        className: `p-1 rounded-lg transition-all cursor-pointer ${c ? "opacity-100 bg-purple-100 dark:bg-purple-900/30" : "hover:bg-muted/20 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 md:opacity-0 md:group-hover:opacity-100"}`,
        children: c ? /* @__PURE__ */ v.jsx(ea, { className: "h-4 w-4 text-purple-500 animate-spin" }) : /* @__PURE__ */ v.jsx(dX, { className: "h-4 w-4 text-muted-foreground" })
      }
    ),
    /* @__PURE__ */ v.jsx(
      "button",
      {
        "aria-label": s ? "Loading..." : "Reuse this message",
        title: s ? "Loading..." : "Reuse this message",
        onClick: (g) => h(g),
        disabled: s,
        className: `p-1 rounded-lg transition-all cursor-pointer ${s ? "opacity-100 bg-blue-100 dark:bg-blue-900/30" : "hover:bg-muted/20 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 md:opacity-0 md:group-hover:opacity-100"}`,
        children: s ? /* @__PURE__ */ v.jsx(ea, { className: "h-4 w-4 text-blue-500 animate-spin" }) : /* @__PURE__ */ v.jsx(fA, { className: "h-4 w-4 text-muted-foreground" })
      }
    ),
    /* @__PURE__ */ v.jsx(
      "button",
      {
        "aria-label": "Copy message",
        title: "Copy message",
        onClick: (g) => f(g),
        className: `p-1 rounded-lg transition-all cursor-pointer ${i ? "opacity-100 bg-green-100 dark:bg-green-900/30" : "hover:bg-muted/20 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 md:opacity-0 md:group-hover:opacity-100"}`,
        children: i ? /* @__PURE__ */ v.jsx(Tc, { className: "h-4 w-4 text-green-500" }) : /* @__PURE__ */ v.jsx(Ac, { className: "h-4 w-4 text-muted-foreground" })
      }
    )
  ] });
};
async function vMe(e) {
  const t = await Vc(), n = new FormData();
  n.append("file", e);
  const r = await fetch(`${fs}/files/upload`, { method: "POST", headers: t, body: n });
  if (!r.ok) throw new Error(`Upload failed (${r.status})`);
  return r.json().catch(() => null);
}
async function bMe(e, t) {
  const n = await Vc(), r = await fetch(`${fs}/files/${encodeURIComponent(e)}`, { headers: n });
  if (!r.ok) throw new Error(`Download failed (${r.status})`);
  const i = await r.blob(), o = URL.createObjectURL(i);
  {
    const s = document.createElement("a");
    s.href = o, s.download = e, document.body.appendChild(s), s.click(), s.remove(), setTimeout(() => URL.revokeObjectURL(o), 1e3);
  }
}
const xMe = ({ files: e, className: t = "" }) => {
  const n = (s) => s.startsWith("image/") ? /* @__PURE__ */ v.jsx($Y, { className: "h-4 w-4" }) : s === "application/pdf" ? /* @__PURE__ */ v.jsx(OY, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(DY, { className: "h-4 w-4" }), r = (s) => s.startsWith("image/"), i = async (s) => {
    try {
      if (s.s3Key) {
        bMe(s.s3Key, { forceDownload: !0 }), Vt.success("Download started");
        return;
      }
      if (s.s3Url) {
        const a = document.createElement("a");
        a.href = s.s3Url, a.rel = "noopener", a.target = "_blank", a.download = s.fileName, document.body.appendChild(a), a.click(), a.remove(), Vt.success("Download started");
        return;
      }
      Vt.error("File not available");
    } catch (a) {
      console.error(a), Vt.error("Download failed");
    }
  }, o = (s) => s < 1024 ? `${s} B` : s < 1048576 ? `${(s / 1024).toFixed(1)} KB` : `${(s / 1048576).toFixed(1)} MB`;
  return /* @__PURE__ */ v.jsx("div", { className: `flex flex-row justify-end flex-wrap gap-3 ${t} relative`, children: e.map((s, a) => {
    const c = s.status === "uploading";
    return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 items-end", children: [
      /* @__PURE__ */ v.jsxs(
        Vh,
        {
          variant: "outline",
          className: `flex items-center gap-2 w-fit px-3 py-2 rounded-lg shadow-sm transition-all duration-200 border-1 border-gray-300 dark:border-gray-600 ${c ? "opacity-80 cursor-default" : "cursor-pointer hover:bg-primary/10 hover:shadow-lg hover:border-primary/60 focus-visible:ring-2 focus-visible:ring-primary/40"}`,
          onClick: c ? void 0 : () => i(s),
          style: { userSelect: "text" },
          children: [
            n(s.mimeType),
            /* @__PURE__ */ v.jsx("span", { className: "text-sm font-medium truncate max-w-[180px]", children: s.fileName }),
            /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground ml-2", children: o(s.fileSize) }),
            c ? /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-1 ml-1 text-xs text-muted-foreground", children: [
              /* @__PURE__ */ v.jsx(ea, { className: "h-3 w-3 animate-spin" }),
              /* @__PURE__ */ v.jsx("span", { children: "Uploading" })
            ] }) : /* @__PURE__ */ v.jsx(qE, { className: "h-3 w-3 ml-1 opacity-70 group-hover:opacity-100 transition" })
          ]
        }
      ),
      r(s.mimeType) && s.s3Url && /* @__PURE__ */ v.jsx(
        "img",
        {
          src: s.s3Url,
          alt: s.fileName,
          className: "max-w-xs max-h-64 rounded-xl border-2 border-gray-300 dark:border-gray-600 mt-1 shadow-md transition-all duration-200 hover:shadow-xl hover:border-primary/60 cursor-pointer",
          style: { objectFit: "cover" },
          onClick: () => i(s),
          title: "Click  ti nh"
        }
      )
    ] }, a);
  }) });
};
function wMe(e) {
  if (!e?.attachments || !Array.isArray(e.attachments)) return [];
  const t = [];
  for (const n of e.attachments) {
    if (!n) continue;
    const r = n.results;
    if (Array.isArray(r) && r.length > 0) {
      for (const o of r)
        o && t.push({
          fileName: o.fileName ?? o.file_name ?? o.name,
          fileSize: o.fileSize ?? o.size ?? 0,
          mimeType: o.mimeType ?? o.type ?? "application/octet-stream",
          s3Key: o.s3Key ?? o.key ?? o.keyName ?? void 0,
          s3Url: o.s3Url ?? o.url ?? o.location ?? void 0,
          status: o.status,
          ...o
        });
      continue;
    }
    const i = n;
    (i.fileName || i.mimeType || i.s3Key) && t.push({
      fileName: i.fileName ?? i.name,
      fileSize: i.fileSize ?? i.size ?? 0,
      mimeType: i.mimeType ?? i.type ?? "application/octet-stream",
      s3Key: i.s3Key ?? i.key ?? void 0,
      s3Url: i.s3Url ?? i.url ?? i.location ?? void 0,
      status: i.status,
      ...i
    });
  }
  return t;
}
const SMe = ({ mentions: e, className: t = "" }) => {
  if (!e || e.length === 0) return null;
  const n = (i) => {
    switch (i) {
      case "mcpTool":
        return /* @__PURE__ */ v.jsx(db, { className: "h-3 w-3" });
      case "defaultTool":
        return /* @__PURE__ */ v.jsx(db, { className: "h-3 w-3" });
      case "mcpServer":
        return /* @__PURE__ */ v.jsx(HP, { className: "h-3 w-3" });
      case "workflow":
        return /* @__PURE__ */ v.jsx(LX, { className: "h-3 w-3" });
      case "agent":
        return /* @__PURE__ */ v.jsx(iY, { className: "h-3 w-3" });
      default:
        return /* @__PURE__ */ v.jsx(x4, { className: "h-3 w-3" });
    }
  }, r = (i) => i.label || i.name;
  return /* @__PURE__ */ v.jsx(Fh, { children: /* @__PURE__ */ v.jsx("div", { className: `flex flex-wrap gap-1 ${t}`, children: e.map((i, o) => /* @__PURE__ */ v.jsxs(Yi, { delayDuration: 200, children: [
    /* @__PURE__ */ v.jsx(go, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
      Vh,
      {
        variant: "outline",
        className: "flex items-center gap-1 text-xs px-2  bg-blue-50 dark:bg-blue-950 border-blue-200 dark:border-blue-800 text-blue-700 dark:text-blue-300",
        children: [
          n(i.type),
          /* @__PURE__ */ v.jsx("span", { className: "font-mono", children: r(i) })
        ]
      }
    ) }),
    /* @__PURE__ */ v.jsx(Vo, { className: "text-xs bg-card border border-border max-w-xs", children: /* @__PURE__ */ v.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
        n(i.type),
        /* @__PURE__ */ v.jsx("span", { className: "font-mono font-semibold", children: r(i) })
      ] }),
      /* @__PURE__ */ v.jsx("hr", { className: "border-border" }),
      /* @__PURE__ */ v.jsxs("div", { children: [
        /* @__PURE__ */ v.jsx("strong", { children: "Description:" }),
        " ",
        i.description || "No description"
      ] }),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-1", children: [
        /* @__PURE__ */ v.jsx(HP, { className: "h-3 w-3" }),
        /* @__PURE__ */ v.jsx("strong", { children: "Server:" }),
        " ",
        i.serverName || "Unknown"
      ] })
    ] }) })
  ] }, o)) }) });
};
function kMe(e, t = []) {
  let n = [];
  function r(o, s) {
    const a = C.createContext(s);
    a.displayName = o + "Context";
    const c = n.length;
    n = [...n, s];
    const u = (h) => {
      const { scope: m, children: g, ...b } = h, x = m?.[e]?.[c] || a, w = C.useMemo(() => b, Object.values(b));
      return /* @__PURE__ */ v.jsx(x.Provider, { value: w, children: g });
    };
    u.displayName = o + "Provider";
    function f(h, m) {
      const g = m?.[e]?.[c] || a, b = C.useContext(g);
      if (b) return b;
      if (s !== void 0) return s;
      throw new Error(`\`${h}\` must be used within \`${o}\``);
    }
    return [u, f];
  }
  const i = () => {
    const o = n.map((s) => C.createContext(s));
    return function(a) {
      const c = a?.[e] || o;
      return C.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: c } }),
        [a, c]
      );
    };
  };
  return i.scopeName = e, [r, CMe(i, ...t)];
}
function CMe(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(o) {
      const s = r.reduce((a, { useScope: c, scopeName: u }) => {
        const h = c(o)[`__scope${u}`];
        return { ...a, ...h };
      }, {});
      return C.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function EMe() {
  return fh.useSyncExternalStore(
    _Me,
    () => !0,
    () => !1
  );
}
function _Me() {
  return () => {
  };
}
var ON = "Avatar", [TMe] = kMe(ON), [AMe, pH] = TMe(ON), mH = C.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, ...r } = e, [i, o] = C.useState("idle");
    return /* @__PURE__ */ v.jsx(
      AMe,
      {
        scope: n,
        imageLoadingStatus: i,
        onImageLoadingStatusChange: o,
        children: /* @__PURE__ */ v.jsx(ry.span, { ...r, ref: t })
      }
    );
  }
);
mH.displayName = ON;
var gH = "AvatarImage", MMe = C.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, src: r, onLoadingStatusChange: i = () => {
    }, ...o } = e, s = pH(gH, n), a = NMe(r, o), c = Ir((u) => {
      i(u), s.onImageLoadingStatusChange(u);
    });
    return _r(() => {
      a !== "idle" && c(a);
    }, [a, c]), a === "loaded" ? /* @__PURE__ */ v.jsx(ry.img, { ...o, ref: t, src: r }) : null;
  }
);
MMe.displayName = gH;
var yH = "AvatarFallback", vH = C.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, delayMs: r, ...i } = e, o = pH(yH, n), [s, a] = C.useState(r === void 0);
    return C.useEffect(() => {
      if (r !== void 0) {
        const c = window.setTimeout(() => a(!0), r);
        return () => window.clearTimeout(c);
      }
    }, [r]), s && o.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ v.jsx(ry.span, { ...i, ref: t }) : null;
  }
);
vH.displayName = yH;
function AL(e, t) {
  return e ? t ? (e.src !== t && (e.src = t), e.complete && e.naturalWidth > 0 ? "loaded" : "loading") : "error" : "idle";
}
function NMe(e, { referrerPolicy: t, crossOrigin: n }) {
  const r = EMe(), i = C.useRef(null), o = r ? (i.current || (i.current = new window.Image()), i.current) : null, [s, a] = C.useState(
    () => AL(o, e)
  );
  return _r(() => {
    a(AL(o, e));
  }, [o, e]), _r(() => {
    const c = (h) => () => {
      a(h);
    };
    if (!o) return;
    const u = c("loaded"), f = c("error");
    return o.addEventListener("load", u), o.addEventListener("error", f), t && (o.referrerPolicy = t), typeof n == "string" && (o.crossOrigin = n), () => {
      o.removeEventListener("load", u), o.removeEventListener("error", f);
    };
  }, [o, n, t]), s;
}
var RMe = mH, OMe = vH;
function ML({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    RMe,
    {
      "data-slot": "avatar",
      className: lt("relative flex size-8 shrink-0 overflow-hidden rounded-full", e),
      ...t
    }
  );
}
function NL({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    OMe,
    {
      "data-slot": "avatar-fallback",
      className: lt("bg-muted flex size-full items-center justify-center rounded-full", e),
      ...t
    }
  );
}
function PMe(e) {
  let t = 0;
  for (let r = 0; r < e.length; r++)
    t = e.charCodeAt(r) + ((t << 5) - t);
  return `hsl(${Math.abs(t) % 360}, 70%, 45%)`;
}
const DMe = ({
  part: e,
  isLast: t,
  message: n,
  onReuseMessage: r
}) => {
  const i = C.useRef(null), [o, s] = C.useState(!1), [a, c] = C.useState([]), { user: u } = wF();
  if (!n.parts) return null;
  const f = (() => {
    const m = n.metadata;
    if (!m?.attachments || !Array.isArray(m.attachments))
      return 0;
    let g = 0;
    for (const b of m.attachments)
      b && (Array.isArray(b.results) ? g += b.results.length : g += 1);
    return g;
  })();
  C.useEffect(() => {
    const m = n.metadata, g = wMe(m);
    c(g);
  }, [n.id, f, n.metadata?.attachments]), C.useEffect(() => {
    t && !o && (s(!0), i.current?.scrollIntoView({ behavior: "smooth" }));
  }, [t, o]);
  const h = n.metadata?.mentions;
  return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-1 w-full", ref: i, children: [
    /* @__PURE__ */ v.jsx("div", { className: "flex justify-end my-2 ", children: /* @__PURE__ */ v.jsxs("div", { className: "group flex items-start gap-2", children: [
      /* @__PURE__ */ v.jsx("div", { className: "relative flex flex-col gap-2 items-end", children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ v.jsx(
          hH,
          {
            text: e.text ?? "",
            onReuseMessage: r,
            className: "ml-2"
          }
        ),
        /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2", children: [
          /* @__PURE__ */ v.jsx("div", { className: "bg-neutral-200 dark:bg-neutral-700 px-3 py-2 rounded-md text-sm text-foreground", children: /* @__PURE__ */ v.jsx(mg, { text: e.text ?? "" }) }),
          h && h.length > 0 && /* @__PURE__ */ v.jsx(SMe, { mentions: h, className: "justify-end" })
        ] })
      ] }) }),
      /* @__PURE__ */ v.jsx("span", { className: "shrink-0 mt-1", children: u != null ? /* @__PURE__ */ v.jsx(ML, { children: /* @__PURE__ */ v.jsx(
        NL,
        {
          className: "text-xs text-primary-foreground items-center",
          title: u.emailAddresses[0]?.emailAddress ?? "",
          style: {
            backgroundColor: PMe(u.id)
          },
          children: u.emailAddresses[0]?.emailAddress.slice(0, 2).toUpperCase() ?? ""
        }
      ) }) : /* @__PURE__ */ v.jsx(ML, { children: /* @__PURE__ */ v.jsx(NL, { children: "No Avatar" }) }) })
    ] }) }),
    /* @__PURE__ */ v.jsx("div", { className: "px-10", children: a.length > 0 && /* @__PURE__ */ v.jsx(xMe, { files: a, className: "mt-1" }) })
  ] });
}, IMe = ({
  steps: e,
  defaultExpanded: t = !1
}) => {
  const [n, r] = C.useState(t), i = e.filter(
    (a) => a.type === "tool_call" || a.type === "complete" || a.type === "error" || a.type === "planning"
  );
  if (i.length === 0) return null;
  const o = i.filter((a) => a.type === "complete").length, s = i.filter((a) => a.type === "error").length;
  return /* @__PURE__ */ v.jsxs("div", { className: "mt-2 text-xs", children: [
    /* @__PURE__ */ v.jsxs(
      "button",
      {
        onClick: () => r(!n),
        className: "flex items-center gap-1.5 text-gray-500 dark:text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 transition-colors",
        children: [
          n ? /* @__PURE__ */ v.jsx(Fg, { className: "w-3.5 h-3.5" }) : /* @__PURE__ */ v.jsx(Vg, { className: "w-3.5 h-3.5" }),
          /* @__PURE__ */ v.jsxs("span", { className: "text-xs", children: [
            o > 0 && `${o} step${o > 1 ? "s" : ""}`,
            s > 0 && `  ${s} error${s > 1 ? "s" : ""}`
          ] })
        ]
      }
    ),
    /* @__PURE__ */ v.jsx(ZA, { children: n && /* @__PURE__ */ v.jsx(
      nh.div,
      {
        initial: { opacity: 0, height: 0 },
        animate: { opacity: 1, height: "auto" },
        exit: { opacity: 0, height: 0 },
        transition: { duration: 0.2 },
        className: "mt-2 pl-5 space-y-1.5 overflow-hidden",
        children: i.map((a) => /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
          /* @__PURE__ */ v.jsx("div", { className: "mt-0.5 shrink-0", children: a.type === "complete" ? /* @__PURE__ */ v.jsx("div", { className: "w-3.5 h-3.5 rounded-full bg-green-500 flex items-center justify-center", children: /* @__PURE__ */ v.jsx(Tc, { className: "w-2.5 h-2.5 text-white", strokeWidth: 3 }) }) : a.type === "error" ? /* @__PURE__ */ v.jsx("div", { className: "w-3.5 h-3.5 rounded-full bg-red-500 flex items-center justify-center", children: /* @__PURE__ */ v.jsx(Hg, { className: "w-2.5 h-2.5 text-white", strokeWidth: 3 }) }) : /* @__PURE__ */ v.jsx("div", { className: "w-3.5 h-3.5 rounded-full bg-blue-500" }) }),
          /* @__PURE__ */ v.jsxs("div", { className: "flex-1 min-w-0", children: [
            /* @__PURE__ */ v.jsx(
              "div",
              {
                className: lt(
                  "text-xs",
                  a.type === "complete" && "text-gray-600 dark:text-gray-400",
                  a.type === "error" && "text-red-600 dark:text-red-400",
                  a.type !== "complete" && a.type !== "error" && "text-gray-700 dark:text-gray-300"
                ),
                children: a.message
              }
            ),
            a.details && /* @__PURE__ */ v.jsx("div", { className: "text-[10px] text-gray-400 dark:text-gray-600 mt-0.5 truncate", children: a.details })
          ] })
        ] }, a.id))
      }
    ) })
  ] });
}, jMe = ({
  part: e,
  message: t,
  // showActions,
  // isLoading,
  showAvatar: n,
  regenerate: r,
  onReuseMessage: i
}) => {
  const o = Ha.getMessageSteps(t.id);
  return /* @__PURE__ */ v.jsx(v.Fragment, { children: /* @__PURE__ */ v.jsxs("div", { className: "group flex items-start gap-2", children: [
    n && /* @__PURE__ */ v.jsx("span", { className: "shrink-0 mt-1", children: /* @__PURE__ */ v.jsx(cA, { className: "h-5 w-5 text-blue-400" }) }),
    /* @__PURE__ */ v.jsxs("div", { className: "relative flex flex-col w-full", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ v.jsx("div", { className: "text-foreground text-sm max-w-[70vw] wrap-break-word", children: /* @__PURE__ */ v.jsx("div", { className: "prose prose-sm dark:prose-invert prose-p:my-0 prose-ul:my-1 prose-ol:my-1 prose-pre:my-1", children: /* @__PURE__ */ v.jsx(fH, { children: e.text }) }) }),
        /* @__PURE__ */ v.jsx(
          hH,
          {
            text: e.text ?? "",
            onReuseMessage: i,
            onRegenerate: r ? () => r({ messageId: t.id }) : void 0,
            className: "ml-2"
          }
        )
      ] }),
      o && o.length > 0 && /* @__PURE__ */ v.jsx(
        IMe,
        {
          steps: o,
          messageId: t.id,
          defaultExpanded: !1
        }
      )
    ] })
  ] }) });
}, zMe = C.memo(jMe, (e, t) => !(e.isLoading !== t.isLoading || e.showActions !== t.showActions || e.part.text !== t.part.text));
function bH({
  data: e,
  className: t = "",
  defaultExpandAll: n = !0
}) {
  const { copied: r, copy: i } = NN(), [o, s] = C.useState(n), [a, c] = C.useState(!1);
  return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
    /* @__PURE__ */ v.jsxs("div", { className: `w-full flex flex-col ${t}`, children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex gap-2 ml-auto mb-2", children: [
        /* @__PURE__ */ v.jsx(
          qt,
          {
            variant: "ghost",
            size: "icon",
            className: "size-3! p-4! cursor-pointer",
            onClick: () => s(!o),
            title: o ? "Collapse All" : "Expand All",
            children: o ? /* @__PURE__ */ v.jsx(VP, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(UP, { className: "h-4 w-4" })
          }
        ),
        /* @__PURE__ */ v.jsx(
          qt,
          {
            variant: "ghost",
            size: "icon",
            className: "size-3! p-4! cursor-pointer",
            onClick: () => i(xh(e) ? e : JSON.stringify(e)),
            title: "Copy JSON",
            children: r ? /* @__PURE__ */ v.jsx(Tc, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(Ac, { className: "h-4 w-4" })
          }
        ),
        /* @__PURE__ */ v.jsx(
          qt,
          {
            variant: "ghost",
            size: "icon",
            className: "size-3! p-4! cursor-pointer",
            onClick: () => c(!0),
            title: "Open in Popup",
            children: /* @__PURE__ */ v.jsx(EY, { className: "h-4 w-4" })
          }
        )
      ] }),
      /* @__PURE__ */ v.jsx(id, { data: e, expandAll: o })
    ] }),
    /* @__PURE__ */ v.jsx(Hh, { open: a, onOpenChange: c, children: /* @__PURE__ */ v.jsxs(Wh, { className: "max-w-4xl max-h-[80vh] flex flex-col", children: [
      /* @__PURE__ */ v.jsx(ny, { children: /* @__PURE__ */ v.jsxs(qh, { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ v.jsx("span", { children: "JSON Data Viewer" }),
        /* @__PURE__ */ v.jsxs("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ v.jsx(
            qt,
            {
              variant: "ghost",
              size: "icon",
              className: "size-8! cursor-pointer",
              onClick: () => s(!o),
              title: o ? "Collapse All" : "Expand All",
              children: o ? /* @__PURE__ */ v.jsx(VP, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(UP, { className: "h-4 w-4" })
            }
          ),
          /* @__PURE__ */ v.jsx(
            qt,
            {
              variant: "ghost",
              size: "icon",
              className: "size-8! cursor-pointer",
              onClick: () => i(xh(e) ? e : JSON.stringify(e)),
              title: "Copy JSON",
              children: r ? /* @__PURE__ */ v.jsx(Tc, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(Ac, { className: "h-4 w-4" })
            }
          )
        ] })
      ] }) }),
      /* @__PURE__ */ v.jsx("div", { className: "flex-1 overflow-auto p-4 bg-muted/20 rounded-md", children: /* @__PURE__ */ v.jsx(id, { data: e, expandAll: o }) })
    ] }) })
  ] });
}
function LMe({
  data: e,
  open: t,
  onOpenChange: n,
  children: r
}) {
  return /* @__PURE__ */ v.jsxs(Hh, { open: t, onOpenChange: n, children: [
    /* @__PURE__ */ v.jsx(J$, { asChild: !0, children: r || /* @__PURE__ */ v.jsx(
      qt,
      {
        variant: "ghost",
        size: "sm",
        className: "text-muted-foreground text-xs",
        children: "JSON"
      }
    ) }),
    /* @__PURE__ */ v.jsxs(Wh, { className: "max-w-[70vw] min-w-[40vw]", children: [
      /* @__PURE__ */ v.jsx(ny, { children: /* @__PURE__ */ v.jsx(qh, { className: "cursor-pointer", children: "JSON" }) }),
      /* @__PURE__ */ v.jsx("div", { className: "max-h-[70vh] w-full overflow-y-auto p-6 pt-0", children: /* @__PURE__ */ v.jsx(bH, { data: e }) })
    ] })
  ] });
}
var i1 = "Checkbox", [BMe] = bs(i1), [$Me, PN] = BMe(i1);
function UMe(e) {
  const {
    __scopeCheckbox: t,
    checked: n,
    children: r,
    defaultChecked: i,
    disabled: o,
    form: s,
    name: a,
    onCheckedChange: c,
    required: u,
    value: f = "on",
    // @ts-expect-error
    internal_do_not_use_render: h
  } = e, [m, g] = il({
    prop: n,
    defaultProp: i ?? !1,
    onChange: c,
    caller: i1
  }), [b, x] = C.useState(null), [w, S] = C.useState(null), _ = C.useRef(!1), M = b ? !!s || !!b.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    !0
  ), N = {
    checked: m,
    disabled: o,
    setChecked: g,
    control: b,
    setControl: x,
    name: a,
    form: s,
    value: f,
    hasConsumerStoppedPropagationRef: _,
    required: u,
    defaultChecked: wc(i) ? !1 : i,
    isFormControl: M,
    bubbleInput: w,
    setBubbleInput: S
  };
  return /* @__PURE__ */ v.jsx(
    $Me,
    {
      scope: t,
      ...N,
      children: FMe(h) ? h(N) : r
    }
  );
}
var xH = "CheckboxTrigger", wH = C.forwardRef(
  ({ __scopeCheckbox: e, onKeyDown: t, onClick: n, ...r }, i) => {
    const {
      control: o,
      value: s,
      disabled: a,
      checked: c,
      required: u,
      setControl: f,
      setChecked: h,
      hasConsumerStoppedPropagationRef: m,
      isFormControl: g,
      bubbleInput: b
    } = PN(xH, e), x = Ht(i, f), w = C.useRef(c);
    return C.useEffect(() => {
      const S = o?.form;
      if (S) {
        const _ = () => h(w.current);
        return S.addEventListener("reset", _), () => S.removeEventListener("reset", _);
      }
    }, [o, h]), /* @__PURE__ */ v.jsx(
      _t.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": wc(c) ? "mixed" : c,
        "aria-required": u,
        "data-state": TH(c),
        "data-disabled": a ? "" : void 0,
        disabled: a,
        value: s,
        ...r,
        ref: x,
        onKeyDown: Ye(t, (S) => {
          S.key === "Enter" && S.preventDefault();
        }),
        onClick: Ye(n, (S) => {
          h((_) => wc(_) ? !0 : !_), b && g && (m.current = S.isPropagationStopped(), m.current || S.stopPropagation());
        })
      }
    );
  }
);
wH.displayName = xH;
var SH = C.forwardRef(
  (e, t) => {
    const {
      __scopeCheckbox: n,
      name: r,
      checked: i,
      defaultChecked: o,
      required: s,
      disabled: a,
      value: c,
      onCheckedChange: u,
      form: f,
      ...h
    } = e;
    return /* @__PURE__ */ v.jsx(
      UMe,
      {
        __scopeCheckbox: n,
        checked: i,
        defaultChecked: o,
        disabled: a,
        required: s,
        onCheckedChange: u,
        name: r,
        form: f,
        value: c,
        internal_do_not_use_render: ({ isFormControl: m }) => /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
          /* @__PURE__ */ v.jsx(
            wH,
            {
              ...h,
              ref: t,
              __scopeCheckbox: n
            }
          ),
          m && /* @__PURE__ */ v.jsx(
            _H,
            {
              __scopeCheckbox: n
            }
          )
        ] })
      }
    );
  }
);
SH.displayName = i1;
var kH = "CheckboxIndicator", CH = C.forwardRef(
  (e, t) => {
    const { __scopeCheckbox: n, forceMount: r, ...i } = e, o = PN(kH, n);
    return /* @__PURE__ */ v.jsx(
      ji,
      {
        present: r || wc(o.checked) || o.checked === !0,
        children: /* @__PURE__ */ v.jsx(
          _t.span,
          {
            "data-state": TH(o.checked),
            "data-disabled": o.disabled ? "" : void 0,
            ...i,
            ref: t,
            style: { pointerEvents: "none", ...e.style }
          }
        )
      }
    );
  }
);
CH.displayName = kH;
var EH = "CheckboxBubbleInput", _H = C.forwardRef(
  ({ __scopeCheckbox: e, ...t }, n) => {
    const {
      control: r,
      hasConsumerStoppedPropagationRef: i,
      checked: o,
      defaultChecked: s,
      required: a,
      disabled: c,
      name: u,
      value: f,
      form: h,
      bubbleInput: m,
      setBubbleInput: g
    } = PN(EH, e), b = Ht(n, g), x = wM(o), w = sM(r);
    C.useEffect(() => {
      const _ = m;
      if (!_) return;
      const M = window.HTMLInputElement.prototype, D = Object.getOwnPropertyDescriptor(
        M,
        "checked"
      ).set, j = !i.current;
      if (x !== o && D) {
        const O = new Event("click", { bubbles: j });
        _.indeterminate = wc(o), D.call(_, wc(o) ? !1 : o), _.dispatchEvent(O);
      }
    }, [m, x, o, i]);
    const S = C.useRef(wc(o) ? !1 : o);
    return /* @__PURE__ */ v.jsx(
      _t.input,
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: s ?? S.current,
        required: a,
        disabled: c,
        name: u,
        value: f,
        form: h,
        ...t,
        tabIndex: -1,
        ref: b,
        style: {
          ...t.style,
          ...w,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
_H.displayName = EH;
function FMe(e) {
  return typeof e == "function";
}
function wc(e) {
  return e === "indeterminate";
}
function TH(e) {
  return wc(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function AH({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    SH,
    {
      "data-slot": "checkbox",
      className: lt(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        e
      ),
      ...t,
      children: /* @__PURE__ */ v.jsx(
        CH,
        {
          "data-slot": "checkbox-indicator",
          className: "flex items-center justify-center text-current transition-none",
          children: /* @__PURE__ */ v.jsx(Tc, { className: "size-3.5" })
        }
      )
    }
  );
}
const VMe = async () => {
  if (typeof window > "u")
    throw new Error("XLSX can only be loaded in browser environment");
  return window.XLSX ? window.XLSX : new Promise((e, t) => {
    const n = document.createElement("script");
    n.src = "https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js", n.onload = () => {
      window.XLSX ? e(window.XLSX) : t(new Error("Failed to load XLSX library"));
    }, n.onerror = () => t(new Error("Failed to load XLSX script")), document.head.appendChild(n);
  });
};
function HMe(e) {
  const { title: t, data: n, columns: r, description: i } = e, o = 20, s = !0, [a, c] = C.useState(""), [u, f] = C.useState(null), [h, m] = C.useState(null), [g, b] = C.useState(1), [x, w] = C.useState(
    new Set(r.map((B) => B.key))
  ), S = (B, G = "string") => {
    if (B == null) return "";
    switch (G) {
      case "number":
        return typeof B == "number" ? B.toLocaleString() : B;
      case "boolean":
        return B ? "Yes" : "No";
      case "date":
        try {
          return new Date(B).toLocaleDateString();
        } catch {
          return B;
        }
      default:
        return String(B);
    }
  }, _ = (B, G) => {
    if (!G || !B) return B;
    const Y = new RegExp(`(${G})`, "gi");
    return String(B).split(Y).map(
      (ie, ne) => Y.test(ie) ? /* @__PURE__ */ v.jsx("mark", { className: "bg-yellow-200 dark:bg-yellow-800", children: ie }, ne) : ie
    );
  }, M = C.useMemo(() => {
    let B = [...n];
    return a && s && (B = B.filter(
      (G) => Object.values(G).some(
        (Y) => String(Y).toLowerCase().includes(a.toLowerCase())
      )
    )), u && h && B.sort((G, Y) => {
      const he = G[u], ie = Y[u], H = r.find((X) => X.key === u)?.type || "string";
      let Q = 0;
      switch (H) {
        case "number":
          Q = Number(he || 0) - Number(ie || 0);
          break;
        case "date":
          Q = new Date(he || 0).getTime() - new Date(ie || 0).getTime();
          break;
        case "boolean":
          Q = (he ? 1 : 0) - (ie ? 1 : 0);
          break;
        default:
          Q = String(he || "").localeCompare(
            String(ie || "")
          );
      }
      return h === "asc" ? Q : -Q;
    }), B;
  }, [n, a, u, h]), N = Math.ceil(M.length / o), D = M.slice(
    (g - 1) * o,
    g * o
  ), j = (B) => {
    u === B ? (m(
      h === "asc" ? "desc" : h === "desc" ? null : "asc"
    ), h === "desc" && f(null)) : (f(B), m("asc"));
  }, O = () => {
    const B = r.filter((ne) => x.has(ne.key)), G = [
      // Header
      B.map((ne) => ne.label).join(","),
      // Data rows
      ...M.map(
        (ne) => B.map((H) => `"${S(ne[H.key], H.type)}"`).join(",")
      )
    ].join(`
`), Y = new Blob([G], { type: "text/csv" }), he = URL.createObjectURL(Y), ie = document.createElement("a");
    ie.href = he, ie.download = `${t.replace(/\s+/g, "_")}.csv`, ie.click(), URL.revokeObjectURL(he);
  }, L = async () => {
    try {
      const B = await VMe(), G = r.filter((H) => x.has(H.key)), Y = [
        // Header row
        G.map((H) => H.label),
        // Data rows
        ...M.map(
          (H) => G.map((Q) => {
            const X = H[Q.key];
            switch (Q.type) {
              case "number":
                return typeof X == "number" ? X : Number(X) || X;
              case "date":
                return X instanceof Date ? X : new Date(X);
              case "boolean":
                return X;
              default:
                return X;
            }
          })
        )
      ], he = B.utils.book_new(), ie = B.utils.aoa_to_sheet(Y), ne = G.map((H) => {
        const Q = Math.max(
          H.label.length,
          ...M.map(
            (X) => String(S(X[H.key], H.type) || "").length
          )
        );
        return { wch: Math.min(Math.max(Q + 2, 10), 50) };
      });
      ie["!cols"] = ne, B.utils.book_append_sheet(he, ie, "Data"), B.writeFile(he, `${t.replace(/\s+/g, "_")}.xlsx`);
    } catch (B) {
      console.error("Failed to export Excel:", B), O();
    }
  }, U = r.filter(
    (B) => x.has(B.key)
  );
  return /* @__PURE__ */ v.jsx("div", { className: "px-6", children: /* @__PURE__ */ v.jsxs(q9, { className: "w-full px-0", children: [
    /* @__PURE__ */ v.jsxs(G9, { children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
        /* @__PURE__ */ v.jsxs(Oce, { className: "w-full flex items-center gap-2 justify-between", children: [
          "Interactive Table - ",
          t,
          /* @__PURE__ */ v.jsx(LMe, { data: e })
        ] }),
        i && /* @__PURE__ */ v.jsx(Pce, { className: "mt-2 ", children: i })
      ] }),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 mt-4", children: [
        /* @__PURE__ */ v.jsx("div", { className: "flex-1", children: /* @__PURE__ */ v.jsx(
          EM,
          {
            placeholder: "Search across all columns...",
            value: a,
            onChange: (B) => {
              c(B.target.value), b(1);
            },
            className: "hover:bg-input bg-secondary/40 transition-colors border-transparent border-none! focus-visible:bg-input! ring-0!"
          }
        ) }),
        /* @__PURE__ */ v.jsxs(od, { children: [
          /* @__PURE__ */ v.jsx(sd, { asChild: !0, children: /* @__PURE__ */ v.jsxs(qt, { variant: "ghost", className: "data-[state=open]:bg-accent", children: [
            /* @__PURE__ */ v.jsx(uA, { className: "size-3.5" }),
            "Columns"
          ] }) }),
          /* @__PURE__ */ v.jsx(ad, { children: r.map((B) => /* @__PURE__ */ v.jsx(
            ehe,
            {
              checked: x.has(B.key),
              onClick: (G) => {
                G.stopPropagation(), G.preventDefault();
                const Y = new Set(x);
                !Y.has(B.key) ? Y.add(B.key) : Y.delete(B.key), w(Y);
              },
              children: B.label
            },
            B.key
          )) })
        ] }),
        /* @__PURE__ */ v.jsxs(od, { children: [
          /* @__PURE__ */ v.jsx(sd, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
            qt,
            {
              variant: "ghost",
              className: "data-[state=open]:bg-accent",
              children: [
                /* @__PURE__ */ v.jsx(qE, { className: "size-3.5" }),
                "Export"
              ]
            }
          ) }),
          /* @__PURE__ */ v.jsxs(ad, { children: [
            /* @__PURE__ */ v.jsxs(hs, { onClick: O, children: [
              /* @__PURE__ */ v.jsx(qE, { className: "h-4 w-4 mr-2" }),
              "CSV"
            ] }),
            /* @__PURE__ */ v.jsxs(hs, { onClick: L, children: [
              /* @__PURE__ */ v.jsx(NY, { className: "h-4 w-4 mr-2" }),
              "Excel"
            ] })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ v.jsxs(K9, { className: "px-0 relative", children: [
      /* @__PURE__ */ v.jsxs(aH, { children: [
        /* @__PURE__ */ v.jsx(lH, { className: "bg-secondary border-t", children: /* @__PURE__ */ v.jsx(eb, { children: U.map((B, G) => /* @__PURE__ */ v.jsx(
          uH,
          {
            className: `relative select-none ${G === 0 ? "pl-6" : G === U.length - 1 ? "pr-6" : ""} ${B.type === "number" || B.type === "date" || B.type === "boolean" ? "text-center" : ""}`,
            children: /* @__PURE__ */ v.jsxs(
              "div",
              {
                className: `flex items-center gap-2 cursor-pointer ${B.type === "number" || B.type === "date" ? "justify-center" : ""}`,
                onClick: () => j(B.key),
                children: [
                  /* @__PURE__ */ v.jsx("span", { className: "hover:text-primary", children: B.label }),
                  /* @__PURE__ */ v.jsx(
                    ZZ,
                    {
                      className: `h-3 w-3 ${u === B.key ? "" : "text-muted-foreground/30"}`
                    }
                  )
                ]
              }
            )
          },
          B.key
        )) }) }),
        /* @__PURE__ */ v.jsx(cH, { className: "min-h-[24rem]", children: D.length === 0 ? /* @__PURE__ */ v.jsx(eb, { children: /* @__PURE__ */ v.jsx(
          kT,
          {
            colSpan: U.length,
            className: "text-center h-48",
            children: "No data found"
          }
        ) }) : D.map((B, G) => /* @__PURE__ */ v.jsx(eb, { className: "border-b!", children: U.map((Y, he) => /* @__PURE__ */ v.jsx(
          kT,
          {
            className: `py-3 ${he === 0 ? "pl-6" : he === U.length - 1 ? "pr-6" : ""} ${Y.type === "number" || Y.type === "date" ? "text-center" : Y.type == "boolean" ? "flex items-center justify-center" : ""}`,
            children: Y.type == "boolean" ? /* @__PURE__ */ v.jsx(v.Fragment, { children: /* @__PURE__ */ v.jsx(AH, { checked: B[Y.key] }) }) : a && s ? _(
              S(B[Y.key], Y.type),
              a
            ) : S(B[Y.key], Y.type)
          },
          Y.key
        )) }, G)) })
      ] }),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between pt-4 px-6", children: [
        /* @__PURE__ */ v.jsxs("div", { className: "text-xs text-muted-foreground", children: [
          "Total rows: ",
          n.length
        ] }),
        N > 1 && /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ v.jsxs(
            qt,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => b((B) => Math.max(1, B - 1)),
              disabled: g === 1,
              children: [
                /* @__PURE__ */ v.jsx(uY, { className: "h-4 w-4" }),
                "Previous"
              ]
            }
          ),
          /* @__PURE__ */ v.jsxs("span", { className: "text-sm px-2", children: [
            "Page ",
            g,
            " of ",
            N
          ] }),
          /* @__PURE__ */ v.jsxs(
            qt,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => b((B) => Math.min(N, B + 1)),
              disabled: g === N,
              children: [
                "Next",
                /* @__PURE__ */ v.jsx(Vg, { className: "h-4 w-4" })
              ]
            }
          )
        ] })
      ] })
    ] })
  ] }) });
}
function RL(e, t) {
  const n = (o) => o && (o.data || o.columns || o.rows || o.points || o.content || o.results), r = t?.content;
  if (n(r)) return r;
  if (n(t)) return t;
  const i = e?.content;
  return n(i) ? i : e ?? {};
}
function MH(e, t) {
  const {
    chatbotStore: { isStopStream: n }
  } = la(), r = n.value;
  return C.useMemo(() => e === "output-error" ? {
    label: "Tool error",
    icon: /* @__PURE__ */ v.jsx(AY, { className: "h-4 w-4 text-yellow-700" }),
    detail: t ?? "An error occurred while calling the tool."
  } : e.startsWith("output") ? {
    label: "Called tool",
    icon: /* @__PURE__ */ v.jsx(mY, { className: "h-4 w-4 text-emerald-400" })
  } : e === "input-available" ? {
    label: "Calling tool",
    icon: /* @__PURE__ */ v.jsx(ea, { className: "h-4 w-4 animate-spin text-muted-foreground" })
  } : r && e === "input-streaming" ? {
    label: "Tool call stopped",
    icon: /* @__PURE__ */ v.jsx(yY, { className: "h-4 w-4 text-red-700" }),
    detail: "The tool call was stopped by the user."
  } : {
    label: "Connecting to app",
    icon: /* @__PURE__ */ v.jsx(ea, { className: "h-4 w-4 animate-spin text-muted-foreground" })
  }, [e, t, r]);
}
const WMe = ({ toolName: e, state: t }) => {
  const n = MH(t), [r, i] = C.useState(!0);
  return /* @__PURE__ */ v.jsxs("div", { className: "", children: [
    /* @__PURE__ */ v.jsxs(
      qt,
      {
        type: "button",
        variant: "ghost",
        size: "sm",
        onClick: () => i((o) => !o),
        className: "flex items-center gap-2 cursor-pointer px-3 py-2",
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-sm", children: [
            n.icon,
            /* @__PURE__ */ v.jsx("span", { className: "text-sm text-muted-foreground", children: n.label })
          ] }),
          /* @__PURE__ */ v.jsx(
            Fg,
            {
              className: `h-4 w-4 text-muted-foreground transition ${r ? "rotate-180" : ""}`
            }
          )
        ]
      }
    ),
    r && /* @__PURE__ */ v.jsxs(
      "div",
      {
        title: "AI Tool - Automated Data Processing",
        className: "flex items-center gap-2 border border-accent-background p-2",
        children: [
          /* @__PURE__ */ v.jsx("span", { className: "relative flex items-center", children: /* @__PURE__ */ v.jsx(RX, { className: "w-5 h-5 opacity-90" }) }),
          /* @__PURE__ */ v.jsx("div", { className: " py-0.5 rounded bg-muted text-foreground", children: e }),
          /* @__PURE__ */ v.jsx(fF, { className: "h-4 w-px bg-border" }),
          /* @__PURE__ */ v.jsx("div", { className: "text-muted-foreground", children: t })
        ]
      }
    )
  ] });
}, OL = C.memo(WMe), rr = {
  // General tools
  MODAL: "modal",
  CONTROL_BY_NAME: "controlbyname",
  PARSE_COORDINATES_SEARCH: "parsecoordinatesfromsearch",
  PARSE_COORDINATES: "parsecoordinates",
  PYTHON_EXECUTION: "python-execution",
  JAVASCRIPT_EXECUTION: "javascript-execution",
  CREATE_MODEL: "createmodel",
  HIDDEN: "hidden",
  PREPARE_ENTITY_UPDATE: "prepareentityupdate",
  // 24KTwin-Editor-MCP-Remote tools
  ENTITY_CONNECTION: "connect_entities",
  OPEN_CREATE_MANY_RELATIONSHIPS_UI: "open_create_many_relationships_ui",
  MOVE_ENTITIES: "move_entities",
  DELETE_ENTITIES: "delete_entities",
  CREATE_ENTITIES: "create_entities",
  ABC_TOOL: "abc",
  // Example: New ABC tool
  FALLBACK: "fallback"
};
function qMe(e) {
  const t = e.match(/^_([^_]+?)(?:-(?:\d+|latest))?_(.+)$/);
  return t ? {
    serverName: t[1],
    toolName: t[2]
  } : null;
}
const GMe = {
  [rr.MODAL]: /^(tool-?open-?modal|openModal|tool_open_modal|open-modal)$/i,
  [rr.CONTROL_BY_NAME]: /^contro(lbyname|lbyName|lbyNames|Names)$/i,
  [rr.PARSE_COORDINATES_SEARCH]: /^parsecoordinatesfromsearch$/i,
  [rr.PARSE_COORDINATES]: /^parsecoordinates$/i,
  [rr.PYTHON_EXECUTION]: /^python-execution$/i,
  [rr.JAVASCRIPT_EXECUTION]: /^javascript-execution$/i,
  [rr.CREATE_MODEL]: /^(createmodel|create-?model|createModel)$/i,
  [rr.PREPARE_ENTITY_UPDATE]: /^\s*(?:tool-)?prepareentityupdate/i
}, PL = {
  // 24KTwin-Editor-MCP-Remote tools
  "24KTwin-Editor-MCP-Remote.abc": rr.ABC_TOOL,
  //  New ABC tool added here 
  "24KTwin-Editor-MCP-Remote.connect_entities": rr.ENTITY_CONNECTION,
  "24KTwin-Editor-MCP-Remote.open_create_many_relationships_ui": rr.OPEN_CREATE_MANY_RELATIONSHIPS_UI,
  "24KTwin-Editor-MCP-Remote.move_entities": rr.MOVE_ENTITIES,
  "24KTwin-Editor-MCP-Remote.delete_entities": rr.DELETE_ENTITIES,
  "24KTwin-Editor-MCP-Remote.create_entities": rr.CREATE_ENTITIES
  // Add other MCP servers here
  // 'OtherServer.same_tool_name': TOOL_CATEGORIES.OTHER_CATEGORY,
}, DL = {
  connect_entities: rr.ENTITY_CONNECTION,
  open_create_many_relationships_ui: rr.OPEN_CREATE_MANY_RELATIONSHIPS_UI,
  move_entities: rr.MOVE_ENTITIES,
  delete_entities: rr.DELETE_ENTITIES,
  create_entities: rr.CREATE_ENTITIES
}, KMe = ["webSearch", "web-search", "search", "websearch"], Tf = /* @__PURE__ */ new Map();
function ZMe(e) {
  const t = Tf.get(e);
  if (t) return t;
  let n;
  if (KMe.includes(e))
    return n = rr.HIDDEN, Tf.set(e, n), n;
  const r = qMe(e);
  if (r) {
    const i = `${r.serverName}.${r.toolName}`;
    if (PL[i])
      return n = PL[i], Tf.set(e, n), n;
    if (DL[r.toolName])
      return n = DL[r.toolName], Tf.set(e, n), n;
  }
  for (const [i, o] of Object.entries(GMe))
    if (o.test(e))
      return n = i, Tf.set(e, n), n;
  return n = rr.FALLBACK, Tf.set(e, n), n;
}
const YMe = ({
  toolName: e,
  state: t,
  parts: n,
  errorText: r
}) => {
  const [i, o] = C.useState(!1), s = MH(t, r), a = C.useMemo(() => {
    if (n == null) return "No payload available.";
    try {
      return JSON.stringify(n, null, 2);
    } catch {
      return String(n);
    }
  }, [n]), c = C.useMemo(() => {
    if (!n && !n.input) return null;
    try {
      return JSON.stringify(n.input, null, 2);
    } catch {
      return String(n);
    }
  }, [n]), u = C.useMemo(() => {
    if (!n) return null;
    try {
      return JSON.stringify(n, null, 2);
    } catch {
      return String(n);
    }
  }, [n]), { copy: f, copied: h } = NN(), m = !c && !u, g = (b, x) => /* @__PURE__ */ v.jsxs("div", { className: "rounded-xl border border-border bg-card/20 p-3 text-xs text-foreground", children: [
    /* @__PURE__ */ v.jsx("div", { className: "flex items-center justify-between gap-2 text-[10px] uppercase tracking-[0.3em] text-muted-foreground", children: /* @__PURE__ */ v.jsx("span", { children: b }) }),
    /* @__PURE__ */ v.jsx("div", { className: "mt-2 max-h-full w-full overflow-auto whitespace-pre-wrap wrap-break-word text-sm text-foreground", children: /* @__PURE__ */ v.jsx(bH, { data: x }) })
  ] });
  return /* @__PURE__ */ v.jsxs("div", { className: "space-y-2 text-xs py-2", children: [
    /* @__PURE__ */ v.jsxs(
      qt,
      {
        type: "button",
        variant: "ghost",
        size: "sm",
        onClick: () => o((b) => !b),
        className: "flex items-center gap-2 cursor-pointer px-3 py-2",
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-sm text-muted-foreground", children: [
            s.icon,
            /* @__PURE__ */ v.jsx("span", { className: "text-sm", children: s.label })
          ] }),
          /* @__PURE__ */ v.jsx(
            Fg,
            {
              className: `h-4 w-4 text-muted-foreground transition ${i ? "rotate-180" : ""}`
            }
          )
        ]
      }
    ),
    i && /* @__PURE__ */ v.jsxs("div", { className: "space-y-4 rounded-md border border-border p-4 dark:bg-zinc-950 shadow-lg shadow-black/40", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3 text-xs font-semibold text-muted-foreground", children: [
          /* @__PURE__ */ v.jsx("div", { className: "flex h-10 w-10 items-center justify-center rounded-2xl bg-muted text-sm font-semibold uppercase text-foreground", children: e?.[0] ?? "T" }),
          /* @__PURE__ */ v.jsxs("div", { children: [
            /* @__PURE__ */ v.jsx("p", { className: "text-sm font-semibold text-foreground", children: e }),
            /* @__PURE__ */ v.jsx("p", { className: "text-[11px] text-muted-foreground", children: t })
          ] })
        ] }),
        /* @__PURE__ */ v.jsx("p", { className: "text-[11px] text-muted-foreground", children: s.detail ?? "The agent is currently handling a tool request; expand to view the payload." })
      ] }),
      m ? /* @__PURE__ */ v.jsxs("div", { className: "rounded-md border border-border bg-card/20 p-3 text-xs text-foreground", children: [
        /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-2 text-[10px] uppercase tracking-[0.3em] text-muted-foreground", children: [
          /* @__PURE__ */ v.jsx("span", { children: "Tool payload (raw)" }),
          /* @__PURE__ */ v.jsxs(
            "button",
            {
              type: "button",
              onClick: () => f(a),
              className: "flex items-center gap-1 rounded-full border border-border px-3 py-1 text-[10px] font-semibold text-muted-foreground transition hover:border-foreground hover:text-foreground",
              children: [
                /* @__PURE__ */ v.jsx(Ac, { className: "h-3 w-3" }),
                h ? "Copied" : "Copy"
              ]
            }
          )
        ] }),
        /* @__PURE__ */ v.jsx("div", { className: "mt-2 max-h-52 overflow-auto whitespace-pre-wrap break-words text-[12px] text-foreground", children: a })
      ] }) : /* @__PURE__ */ v.jsxs("div", { className: `grid gap-3 ${c && u ? "sm:grid-cols-2" : ""}`, children: [
        c && g("Request", c),
        u && g("Response", u)
      ] })
    ] })
  ] });
}, XMe = C.memo(YMe), JMe = C.lazy(
  () => import("./pie-chart-lmWv5b93.js").then((e) => ({ default: e.PieChart }))
), QMe = C.lazy(
  () => import("./bar-chart-Di2QRuXc.js").then((e) => ({ default: e.BarChart }))
), eNe = C.lazy(
  () => import("./line-chart-CPWPIjT4.js").then((e) => ({ default: e.LineChart }))
), tNe = ({
  part: e,
  addToolResult: t
}) => {
  const { input: n, output: r, state: i, errorText: o, toolCallId: s } = e, a = C.useMemo(() => wg(e), [e.type]), c = i.startsWith("output");
  C.useCallback(
    (m) => {
      t?.({
        tool: a,
        toolCallId: s,
        output: m
      }), console.log("Result", m);
    },
    [t, s, a]
  );
  const u = C.useMemo(() => {
    if (!(a === "createTable" || a === "CreateTable" || /table$/i.test(a))) return null;
    const g = RL(n, r), b = Array.isArray(g?.columns) ? g.columns : [], x = Array.isArray(g?.data) ? g.data : [], w = g?.title ?? "Table", S = g?.description;
    return !b.length || !x.length ? null : /* @__PURE__ */ v.jsx(
      HMe,
      {
        title: w,
        columns: b,
        data: x,
        description: S
      }
    );
  }, [a, n, r, c]), f = C.useMemo(() => {
    const m = /^(create)?bar(chart)?$/i.test(a), g = /^(create)?line(chart)?$/i.test(a), b = /^(create)?pie(chart)?$/i.test(a);
    if (!m && !g && !b) return null;
    const x = RL(n, r), w = x?.data ?? x?.rows ?? x?.points ?? [];
    if (!Array.isArray(w) || w.length === 0) return null;
    const S = x?.title ?? (m ? "Bar Chart" : g ? "Line Chart" : "Pie Chart"), _ = x?.description ?? void 0, M = x?.yAxisLabel ?? void 0;
    if (b) {
      const D = w.map((j) => ({
        label: j.label ?? j.xAxisLabel ?? "",
        value: j.value ?? 0
      }));
      return /* @__PURE__ */ v.jsx(JMe, { title: S, data: D, description: _ });
    }
    const N = "series" in w[0] ? w : w.map((D) => ({
      xAxisLabel: D.xAxisLabel,
      series: [{ seriesName: "Value", value: D.value }]
    }));
    return m ? /* @__PURE__ */ v.jsx(
      QMe,
      {
        title: S,
        data: N,
        description: _,
        yAxisLabel: M
      }
    ) : /* @__PURE__ */ v.jsx(
      eNe,
      {
        title: S,
        data: N,
        description: _,
        yAxisLabel: M
      }
    );
  }, [a, n, r, i]);
  switch (u ? "table" : f ? "chart" : ZMe(a)) {
    case "table":
      return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 text-xs", children: [
        /* @__PURE__ */ v.jsx(OL, { toolName: a, state: i }),
        u
      ] });
    case "chart":
      return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 text-xs", children: [
        /* @__PURE__ */ v.jsx(OL, { toolName: a, state: i }),
        /* @__PURE__ */ v.jsx("div", { className: "rounded border bg-card p-3", children: /* @__PURE__ */ v.jsx(
          C.Suspense,
          {
            fallback: /* @__PURE__ */ v.jsx("div", { className: "h-44 w-full rounded-md opacity-50" }),
            children: f
          }
        ) })
      ] });
    // case TOOL_CATEGORIES.MODAL:
    //   return (
    //     <ModalOutput
    //       input={input}
    //       output={output}
    //       state={state}
    //       toolName={toolName}
    //     />
    //   );
    // case TOOL_CATEGORIES.CONTROL_BY_NAME:
    //   const controlData = getPayload(input, output);
    //   const items = Array.isArray(controlData && controlData.data && controlData.data.items)
    //   ? controlData.data.items
    //   : Array.isArray(controlData)
    //   ? controlData
    //   : [];
    //   return (
    //     items.length > 0 && (
    //       <div className="flex flex-col gap-2 text-xs">
    //         <RenderToolHeader toolName={toolName} state={state} />
    //         <div className="rounded border bg-card p-4">
    //           <ControlByNameHandler
    //             controlData={controlData}
    //             items={items}
    //           />
    //         </div>
    //       </div>
    //     )
    //   );
    // case TOOL_CATEGORIES.PARSE_COORDINATES_SEARCH:
    // case TOOL_CATEGORIES.PARSE_COORDINATES:
    //   return <GISModelCreator2
    //     input={input}
    //     output={output}
    //     toolName={toolName}
    //     state={state}
    //     isCompleted={isCompleted}
    //   />
    // case TOOL_CATEGORIES.JAVASCRIPT_EXECUTION:
    //   console.log("Rendering JavascriptExecution for toolName:", toolName);
    //   return (
    //     <CodeExecutor
    //       part={part}
    //       key={part.toolCallId}
    //       onResult={onToolCallDirect}
    //       type="javascript"
    //     />
    //   );
    // case TOOL_CATEGORIES.PYTHON_EXECUTION:
    //   console.log("Rendering PythonExecution for toolName:", toolName);
    //   return (
    //     <CodeExecutor
    //       part={part}
    //       key={part.toolCallId}
    //       onResult={onToolCallDirect}
    //       type="python"
    //     />
    //   );
    // case TOOL_CATEGORIES.CREATE_MODEL:  
    //   if (!isCompleted) return null;
    //   return <BrickModelCreators
    //     output={output}
    //     toolName={toolName}
    //     state={state}
    //     isCompleted={isCompleted}
    //   />;
    // case TOOL_CATEGORIES.ENTITY_CONNECTION: {
    //   const relationshipData = getPayload(input, output);
    //   if (!isCompleted) return null;
    //   if (!relationshipData || relationshipData.isError) return null;
    //   const connections = relationshipData.content[0].text.connections;
    //   return (
    //     <div className="flex flex-col gap-2 text-xs">
    //       <RenderToolHeader toolName={toolName} state={state} />
    //       <SetRelationshipOutput data={connections} />
    //     </div>
    //   );
    // }
    // case TOOL_CATEGORIES.OPEN_CREATE_MANY_RELATIONSHIPS_UI:
    //   const data = getPayload(input, output);
    //   if (!isCompleted) return null;
    //   if (!data) return null;
    //   const content = data.content[0].text;
    //   return (
    //     null
    //     // <ItemModals values={content} />
    //   );
    // case TOOL_CATEGORIES.PREPARE_ENTITY_UPDATE:
    //   const updateData = getPayload(input, output);
    //   if (!isCompleted) return null;
    //   if (!updateData) return null;
    //   return (
    //     <>
    //       <ToolMessageFallback  
    //       parts={part}
    //       toolName={toolName}
    //       state={state}
    //       errorText={errorText}
    //       />
    //       <EntityEditors data={output}  />
    //     </>
    //   );
    //   case TOOL_CATEGORIES.MOVE_ENTITIES:
    //     const moveData = getPayload(input, output);
    //     console.log(output);
    //     if (!isCompleted) return null;
    //     if (!moveData) return null;
    //     return (
    //       <>
    //         <ToolMessageFallback  
    //       parts={part}
    //       toolName={toolName}
    //       state={state}
    //       errorText={errorText}
    //       />
    //         <MoveEntitiesOutput data={output} />
    //       </>
    //     );
    //   case TOOL_CATEGORIES.DELETE_ENTITIES:
    //     const deleteData = getPayload(input, output);
    //     if (!isCompleted) return null;
    //     if (!deleteData) return null;
    //     return (
    //       <>
    //         <ToolMessageFallback  
    //       parts={part}
    //       toolName={toolName}
    //       state={state}
    //       errorText={errorText}
    //       />
    //         <DeleteEntitiesOutput data={output} />
    //       </>
    //     );
    //   case TOOL_CATEGORIES.CREATE_ENTITIES:
    //     const createData = getPayload(input, output);
    //     if (!isCompleted) return null;
    //     if (!createData) return null;
    //     return (
    //       <>
    //         <ToolMessageFallback  
    //       parts={part}
    //       toolName={toolName}
    //       state={state}
    //       errorText={errorText}
    //       />
    //         <CreateEntitiesOutput data={output} />
    //       </>
    //     );
    // case TOOL_CATEGORIES.HIDDEN:
    //   // Hide tools that should not be shown to end users
    //   return null;
    case rr.FALLBACK:
    default:
      return /* @__PURE__ */ v.jsx(
        XMe,
        {
          parts: e,
          toolName: a,
          state: i,
          errorText: o
        }
      );
  }
}, nNe = C.memo(tNe), rNe = ({
  message: e,
  prevMessage: t,
  threadId: n,
  isLoading: r,
  isLastMessage: i,
  status: o,
  className: s,
  setMessages: a,
  regenerate: c,
  addToolResult: u,
  messageIndex: f,
  sendMessage: h,
  onReuseMessage: m
}) => {
  const g = C.useMemo(() => e.role === "user", [e.role]);
  if (e.role === "system" || !e.parts.length) return null;
  let b = !1;
  return /* @__PURE__ */ v.jsx("div", { className: "w-full mx-auto max-w-3xl px-4 ", "data-role": e.role, children: /* @__PURE__ */ v.jsx("div", { className: s, children: /* @__PURE__ */ v.jsx("div", { className: "flex flex-col w-full", children: e.parts.map((x, w) => {
    const S = `message-${f}-part-${x.type}-${w}`, _ = w === e.parts.length - 1, N = e.role === "assistant" && x.type === "text" && !b;
    if (N && (b = !0), x.type === "reasoning")
      return /* @__PURE__ */ v.jsx(
        yMe,
        {
          reasoningText: x.text,
          isThinking: _ && i && r
        },
        S
      );
    if (g && x.type === "text" && x.text)
      return t ? /* @__PURE__ */ v.jsxs(C.Fragment, { children: [
        f !== 0 && /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-muted-foreground px-2", children: [
          /* @__PURE__ */ v.jsx(w4, { className: "w-4 h-4 opacity-50", "aria-hidden": !0 }),
          /* @__PURE__ */ v.jsx("div", { className: "flex-1 h-px border-t border-dashed border-muted-foreground/40" })
        ] }),
        /* @__PURE__ */ v.jsx(
          DMe,
          {
            status: o,
            part: x,
            isLast: _,
            message: e,
            setMessages: a,
            sendMessage: h,
            onReuseMessage: m
          },
          S
        )
      ] }, S) : null;
    if (Gu(x)) {
      const D = e.metadata?.toolChoice === "manual" && i && _ && x.state === "input-available" && r;
      return /* @__PURE__ */ v.jsx(
        nNe,
        {
          part: x,
          messageId: e.id,
          isLast: i && _,
          isManualToolInvocation: D,
          showActions: i ? _ && !r : _,
          addToolResult: u
        },
        S
      );
    }
    return x.type === "text" && !g ? /* @__PURE__ */ v.jsx(
      zMe,
      {
        part: x,
        isLast: i && _,
        isLoading: r,
        message: e,
        prevMessage: t,
        showActions: i ? _ && !r : _,
        setMessages: a,
        sendMessage: h,
        regenerate: c,
        threadId: n,
        showAvatar: N,
        onReuseMessage: m
      },
      S
    ) : x.type === "step-start" ? null : /* @__PURE__ */ v.jsxs("div", { children: [
      " unknown part ",
      x.type
    ] }, S);
  }) }) }) });
}, iNe = C.memo(rNe, (e, t) => !(e.message.id !== t.message.id || e.isLoading !== t.isLoading || e.isLastMessage !== t.isLastMessage || e.className !== t.className || t.isLoading && t.isLastMessage || !Fm(e.message.metadata, t.message.metadata) || e.message.parts.length !== t.message.parts.length || !Fm(e.message.parts, t.message.parts)));
function oNe() {
  const [e, t] = C.useState(!1);
  return C.useEffect(() => {
    t(!0);
  }, []), e;
}
const sNe = ({
  words: e,
  duration: t = 3e3,
  className: n
}) => {
  const [r, i] = C.useState(e[0]), [o, s] = C.useState(!1), a = oNe(), c = C.useCallback(() => {
    const u = e[e.indexOf(r) + 1] || e[0];
    i(u), s(!0);
  }, [r, e]);
  return C.useEffect(() => {
    o || setTimeout(() => {
      c();
    }, t);
  }, [o, t, c]), a ? /* @__PURE__ */ v.jsx(
    ZA,
    {
      onExitComplete: () => {
        s(!1);
      },
      children: /* @__PURE__ */ v.jsx(
        nh.div,
        {
          initial: {
            opacity: 0,
            y: 10
          },
          animate: {
            opacity: 1,
            y: 0
          },
          transition: {
            type: "spring",
            stiffness: 100,
            damping: 10
          },
          exit: {
            opacity: 0,
            y: -40,
            x: 40,
            filter: "blur(8px)",
            scale: 2,
            position: "absolute"
          },
          className: lt(
            "z-10 inline-block relative text-left text-foreground px-2",
            n
          ),
          children: r.split(" ").map((u, f) => /* @__PURE__ */ v.jsxs(
            nh.span,
            {
              initial: { opacity: 0, y: 10, filter: "blur(4px)" },
              animate: { opacity: 1, y: 0, filter: "blur(0px)" },
              transition: {
                delay: f * 0.01,
                duration: 0.03
              },
              className: "inline-block whitespace-nowrap",
              children: [
                u.split("").map((h, m) => /* @__PURE__ */ v.jsx(
                  nh.span,
                  {
                    initial: { opacity: 0, y: 10, filter: "blur(4px)" },
                    animate: { opacity: 1, y: 0, filter: "blur(0px)" },
                    transition: {
                      delay: f * 0.2 + m * 0.08,
                      duration: 0.2
                    },
                    className: "inline-block",
                    children: h
                  },
                  u + m
                )),
                /* @__PURE__ */ v.jsx("span", { className: "inline-block", children: "" })
              ]
            },
            u + f
          ))
        },
        r
      )
    }
  ) : null;
};
function aNe() {
  const e = (/* @__PURE__ */ new Date()).getHours();
  return e < 12 ? "goodMorning" : e < 18 ? "goodAfternoon" : "goodEvening";
}
const lNe = () => {
  const e = { name: "User" }, t = C.useMemo(() => {
    if (!e) return "";
    const n = [
      `Good ${aNe().replace("good", "")}, ${e.name}!`,
      `Nice to see you again, ${e.name}.`,
      `What are you working on today, ${e.name}?`,
      "Let me know when you're ready to begin.",
      "What are your thoughts today?",
      "Where would you like to start?",
      `What are you thinking, ${e.name}?`
    ];
    return n[Math.floor(Math.random() * n.length)];
  }, [e.name]);
  return /* @__PURE__ */ v.jsx(
    nh.div,
    {
      className: "max-w-3xl mx-auto my-1",
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      transition: { delay: 0.3 },
      children: /* @__PURE__ */ v.jsx("div", { className: "rounded-xl p-2 flex flex-col gap-2 leading-relaxed text-center", children: /* @__PURE__ */ v.jsx("h1", { className: "text-sm md:text-base text-blue-700 dark:text-[#1abcfe] drop-shadow-sm font-sans", children: t ? /* @__PURE__ */ v.jsx(sNe, { words: [t], className: "" }) : "" }) })
    },
    "welcome"
  );
};
var o1 = "Switch", [cNe] = bs(o1), [uNe, dNe] = cNe(o1), NH = C.forwardRef(
  (e, t) => {
    const {
      __scopeSwitch: n,
      name: r,
      checked: i,
      defaultChecked: o,
      required: s,
      disabled: a,
      value: c = "on",
      onCheckedChange: u,
      form: f,
      ...h
    } = e, [m, g] = C.useState(null), b = Ht(t, (M) => g(M)), x = C.useRef(!1), w = m ? f || !!m.closest("form") : !0, [S, _] = il({
      prop: i,
      defaultProp: o ?? !1,
      onChange: u,
      caller: o1
    });
    return /* @__PURE__ */ v.jsxs(uNe, { scope: n, checked: S, disabled: a, children: [
      /* @__PURE__ */ v.jsx(
        _t.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": S,
          "aria-required": s,
          "data-state": DH(S),
          "data-disabled": a ? "" : void 0,
          disabled: a,
          value: c,
          ...h,
          ref: b,
          onClick: Ye(e.onClick, (M) => {
            _((N) => !N), w && (x.current = M.isPropagationStopped(), x.current || M.stopPropagation());
          })
        }
      ),
      w && /* @__PURE__ */ v.jsx(
        PH,
        {
          control: m,
          bubbles: !x.current,
          name: r,
          value: c,
          checked: S,
          required: s,
          disabled: a,
          form: f,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
NH.displayName = o1;
var RH = "SwitchThumb", OH = C.forwardRef(
  (e, t) => {
    const { __scopeSwitch: n, ...r } = e, i = dNe(RH, n);
    return /* @__PURE__ */ v.jsx(
      _t.span,
      {
        "data-state": DH(i.checked),
        "data-disabled": i.disabled ? "" : void 0,
        ...r,
        ref: t
      }
    );
  }
);
OH.displayName = RH;
var fNe = "SwitchBubbleInput", PH = C.forwardRef(
  ({
    __scopeSwitch: e,
    control: t,
    checked: n,
    bubbles: r = !0,
    ...i
  }, o) => {
    const s = C.useRef(null), a = Ht(s, o), c = wM(n), u = sM(t);
    return C.useEffect(() => {
      const f = s.current;
      if (!f) return;
      const h = window.HTMLInputElement.prototype, g = Object.getOwnPropertyDescriptor(
        h,
        "checked"
      ).set;
      if (c !== n && g) {
        const b = new Event("click", { bubbles: r });
        g.call(f, n), f.dispatchEvent(b);
      }
    }, [c, n, r]), /* @__PURE__ */ v.jsx(
      "input",
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: n,
        ...i,
        tabIndex: -1,
        ref: a,
        style: {
          ...i.style,
          ...u,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
PH.displayName = fNe;
function DH(e) {
  return e ? "checked" : "unchecked";
}
var hNe = NH, pNe = OH;
function IH({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    hNe,
    {
      "data-slot": "switch",
      className: lt(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        e
      ),
      ...t,
      children: /* @__PURE__ */ v.jsx(
        pNe,
        {
          "data-slot": "switch-thumb",
          className: lt(
            "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
          )
        }
      )
    }
  );
}
const mNe = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", jH = mNe ? C.useLayoutEffect : C.useEffect;
function zH(e) {
  const t = C.useRef(e);
  return jH(() => {
    t.current = e;
  }), C.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
      r[i] = arguments[i];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
function IL(e, t) {
  t === void 0 && (t = [e]);
  const n = C.useRef(e);
  return jH(() => {
    n.current !== e && (n.current = e);
  }, t), n;
}
function gNe(e) {
  const t = zH(e), n = C.useRef(null), r = C.useCallback(
    (i) => {
      i !== n.current && t?.(i, n.current), n.current = i;
    },
    //eslint-disable-next-line
    []
  );
  return [n, r];
}
let tE = {};
function yNe(e, t) {
  return C.useMemo(() => {
    const n = tE[e] == null ? 0 : tE[e] + 1;
    return tE[e] = n, e + "-" + n;
  }, [e, t]);
}
var Gm;
(function(e) {
  e.DragStart = "dragStart", e.DragMove = "dragMove", e.DragEnd = "dragEnd", e.DragCancel = "dragCancel", e.DragOver = "dragOver", e.RegisterDroppable = "registerDroppable", e.SetDroppableDisabled = "setDroppableDisabled", e.UnregisterDroppable = "unregisterDroppable";
})(Gm || (Gm = {}));
function jL() {
}
const vNe = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
var Jf;
(function(e) {
  e[e.Forward = 1] = "Forward", e[e.Backward = -1] = "Backward";
})(Jf || (Jf = {}));
var zL;
(function(e) {
  e.Click = "click", e.DragStart = "dragstart", e.Keydown = "keydown", e.ContextMenu = "contextmenu", e.Resize = "resize", e.SelectionChange = "selectionchange", e.VisibilityChange = "visibilitychange";
})(zL || (zL = {}));
var oc;
(function(e) {
  e.Space = "Space", e.Down = "ArrowDown", e.Right = "ArrowRight", e.Left = "ArrowLeft", e.Up = "ArrowUp", e.Esc = "Escape", e.Enter = "Enter", e.Tab = "Tab";
})(oc || (oc = {}));
oc.Space, oc.Enter, oc.Esc, oc.Space, oc.Enter, oc.Tab;
var LL;
(function(e) {
  e[e.RightClick = 2] = "RightClick";
})(LL || (LL = {}));
var BL;
(function(e) {
  e[e.Pointer = 0] = "Pointer", e[e.DraggableRect = 1] = "DraggableRect";
})(BL || (BL = {}));
var $L;
(function(e) {
  e[e.TreeOrder = 0] = "TreeOrder", e[e.ReversedTreeOrder = 1] = "ReversedTreeOrder";
})($L || ($L = {}));
Jf.Backward + "", Jf.Forward + "", Jf.Backward + "", Jf.Forward + "";
var CT;
(function(e) {
  e[e.Always = 0] = "Always", e[e.BeforeDragging = 1] = "BeforeDragging", e[e.WhileDragging = 2] = "WhileDragging";
})(CT || (CT = {}));
var ET;
(function(e) {
  e.Optimized = "optimized";
})(ET || (ET = {}));
function bNe(e) {
  let {
    callback: t,
    disabled: n
  } = e;
  const r = zH(t), i = C.useMemo(
    () => {
      if (n || typeof window > "u" || typeof window.ResizeObserver > "u")
        return;
      const {
        ResizeObserver: o
      } = window;
      return new o(r);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [n]
  );
  return C.useEffect(() => () => i?.disconnect(), [i]), i;
}
CT.WhileDragging, ET.Optimized;
const xNe = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: jL,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: jL
}, wNe = /* @__PURE__ */ C.createContext(xNe);
({
  ...vNe
});
var UL;
(function(e) {
  e[e.Uninitialized = 0] = "Uninitialized", e[e.Initializing = 1] = "Initializing", e[e.Initialized = 2] = "Initialized";
})(UL || (UL = {}));
const SNe = "Droppable", kNe = {
  timeout: 25
};
function CNe(e) {
  let {
    data: t,
    disabled: n = !1,
    id: r,
    resizeObserverConfig: i
  } = e;
  const o = yNe(SNe), {
    active: s,
    dispatch: a,
    over: c,
    measureDroppableContainers: u
  } = C.useContext(wNe), f = C.useRef({
    disabled: n
  }), h = C.useRef(!1), m = C.useRef(null), g = C.useRef(null), {
    disabled: b,
    updateMeasurementsFor: x,
    timeout: w
  } = {
    ...kNe,
    ...i
  }, S = IL(x ?? r), _ = C.useCallback(
    () => {
      if (!h.current) {
        h.current = !0;
        return;
      }
      g.current != null && clearTimeout(g.current), g.current = setTimeout(() => {
        u(Array.isArray(S.current) ? S.current : [S.current]), g.current = null;
      }, w);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [w]
  ), M = bNe({
    callback: _,
    disabled: b || !s
  }), N = C.useCallback((L, U) => {
    M && (U && (M.unobserve(U), h.current = !1), L && M.observe(L));
  }, [M]), [D, j] = gNe(N), O = IL(t);
  return C.useEffect(() => {
    !M || !D.current || (M.disconnect(), h.current = !1, M.observe(D.current));
  }, [D, M]), C.useEffect(
    () => (a({
      type: Gm.RegisterDroppable,
      element: {
        id: r,
        key: o,
        disabled: n,
        node: D,
        rect: m,
        data: O
      }
    }), () => a({
      type: Gm.UnregisterDroppable,
      key: o,
      id: r
    })),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [r]
  ), C.useEffect(() => {
    n !== f.current.disabled && (a({
      type: Gm.SetDroppableDisabled,
      id: r,
      key: o,
      disabled: n
    }), f.current.disabled = n);
  }, [r, o, n, a]), {
    active: s,
    rect: m,
    isOver: c?.id === r,
    node: D,
    over: c,
    setNodeRef: j
  };
}
function ENe(e) {
  return {
    name: e.name,
    size: e.size,
    type: e.type,
    uploadedAt: /* @__PURE__ */ new Date()
  };
}
const _Ne = ({ onFilesChange: e, files: t, isAIThinking: n }) => {
  const r = C.useRef(null), [i, o] = C.useState([]), [s, a] = C.useState(!1);
  Ne.useEffect(() => {
    o(t || []);
  }, [t]);
  const c = (x) => {
    o(x), e && e(x);
  }, u = () => {
    const x = document.createElement("input");
    x.type = "file", x.accept = ".json,.xlsx,.xls,.geojson,.ifc", x.multiple = !0, x.click(), x.onchange = async (w) => {
      const S = w.target.files;
      o([...S ? Array.from(S) : []]), f(S), x.remove();
    };
  }, f = (x) => {
    if (!x) return;
    const w = Array.from(x);
    w.forEach((_) => ENe(_));
    const S = [...i, ...w];
    c(S);
  }, h = (x) => {
    f(x.target.files), x.target && (x.target.value = "");
  }, m = (x) => {
    x.preventDefault(), a(!1), f(x.dataTransfer.files);
  }, g = (x) => {
    x.preventDefault(), a(!0);
  }, b = () => a(!1);
  return /* @__PURE__ */ v.jsx("div", { className: "flex flex-col items-end", children: /* @__PURE__ */ v.jsxs(
    "div",
    {
      onDrop: m,
      onDragOver: g,
      onDragLeave: b,
      className: `flex items-center gap-2 rounded-md ${s ? "bg-neutral-100 dark:bg-neutral-800" : ""}`,
      style: { minWidth: 40 },
      children: [
        /* @__PURE__ */ v.jsx(
          "input",
          {
            ref: r,
            type: "file",
            multiple: !0,
            onChange: h,
            className: "hidden",
            disabled: n
          }
        ),
        /* @__PURE__ */ v.jsx(
          qt,
          {
            disabled: n,
            size: "icon",
            variant: "ghost",
            onClick: u,
            title: "Upload files",
            className: "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
            children: /* @__PURE__ */ v.jsx(bY, { className: "h-5 w-5" })
          }
        )
      ]
    }
  ) });
};
function ti(e) {
  this.content = e;
}
ti.prototype = {
  constructor: ti,
  find: function(e) {
    for (var t = 0; t < this.content.length; t += 2)
      if (this.content[t] === e) return t;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(e) {
    var t = this.find(e);
    return t == -1 ? void 0 : this.content[t + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(e, t, n) {
    var r = n && n != e ? this.remove(n) : this, i = r.find(e), o = r.content.slice();
    return i == -1 ? o.push(n || e, t) : (o[i + 1] = t, n && (o[i] = n)), new ti(o);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(e) {
    var t = this.find(e);
    if (t == -1) return this;
    var n = this.content.slice();
    return n.splice(t, 2), new ti(n);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(e, t) {
    return new ti([e, t].concat(this.remove(e).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(e, t) {
    var n = this.remove(e).content.slice();
    return n.push(e, t), new ti(n);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(e, t, n) {
    var r = this.remove(t), i = r.content.slice(), o = r.find(e);
    return i.splice(o == -1 ? i.length : o, 0, t, n), new ti(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(e) {
    for (var t = 0; t < this.content.length; t += 2)
      e(this.content[t], this.content[t + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(e) {
    return e = ti.from(e), e.size ? new ti(e.content.concat(this.subtract(e).content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(e) {
    return e = ti.from(e), e.size ? new ti(this.subtract(e).content.concat(e.content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(e) {
    var t = this;
    e = ti.from(e);
    for (var n = 0; n < e.content.length; n += 2)
      t = t.remove(e.content[n]);
    return t;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var e = {};
    return this.forEach(function(t, n) {
      e[t] = n;
    }), e;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
ti.from = function(e) {
  if (e instanceof ti) return e;
  var t = [];
  if (e) for (var n in e) t.push(n, e[n]);
  return new ti(t);
};
function LH(e, t, n) {
  for (let r = 0; ; r++) {
    if (r == e.childCount || r == t.childCount)
      return e.childCount == t.childCount ? null : n;
    let i = e.child(r), o = t.child(r);
    if (i == o) {
      n += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(o))
      return n;
    if (i.isText && i.text != o.text) {
      for (let s = 0; i.text[s] == o.text[s]; s++)
        n++;
      return n;
    }
    if (i.content.size || o.content.size) {
      let s = LH(i.content, o.content, n + 1);
      if (s != null)
        return s;
    }
    n += i.nodeSize;
  }
}
function BH(e, t, n, r) {
  for (let i = e.childCount, o = t.childCount; ; ) {
    if (i == 0 || o == 0)
      return i == o ? null : { a: n, b: r };
    let s = e.child(--i), a = t.child(--o), c = s.nodeSize;
    if (s == a) {
      n -= c, r -= c;
      continue;
    }
    if (!s.sameMarkup(a))
      return { a: n, b: r };
    if (s.isText && s.text != a.text) {
      let u = 0, f = Math.min(s.text.length, a.text.length);
      for (; u < f && s.text[s.text.length - u - 1] == a.text[a.text.length - u - 1]; )
        u++, n--, r--;
      return { a: n, b: r };
    }
    if (s.content.size || a.content.size) {
      let u = BH(s.content, a.content, n - 1, r - 1);
      if (u)
        return u;
    }
    n -= c, r -= c;
  }
}
class $e {
  /**
  @internal
  */
  constructor(t, n) {
    if (this.content = t, this.size = n || 0, n == null)
      for (let r = 0; r < t.length; r++)
        this.size += t[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(t, n, r, i = 0, o) {
    for (let s = 0, a = 0; a < n; s++) {
      let c = this.content[s], u = a + c.nodeSize;
      if (u > t && r(c, i + a, o || null, s) !== !1 && c.content.size) {
        let f = a + 1;
        c.nodesBetween(Math.max(0, t - f), Math.min(c.content.size, n - f), r, i + f);
      }
      a = u;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(t) {
    this.nodesBetween(0, this.size, t);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(t, n, r, i) {
    let o = "", s = !0;
    return this.nodesBetween(t, n, (a, c) => {
      let u = a.isText ? a.text.slice(Math.max(t, c) - c, n - c) : a.isLeaf ? i ? typeof i == "function" ? i(a) : i : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && u || a.isTextblock) && r && (s ? s = !1 : o += r), o += u;
    }, 0), o;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(t) {
    if (!t.size)
      return this;
    if (!this.size)
      return t;
    let n = this.lastChild, r = t.firstChild, i = this.content.slice(), o = 0;
    for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), o = 1); o < t.content.length; o++)
      i.push(t.content[o]);
    return new $e(i, this.size + t.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(t, n = this.size) {
    if (t == 0 && n == this.size)
      return this;
    let r = [], i = 0;
    if (n > t)
      for (let o = 0, s = 0; s < n; o++) {
        let a = this.content[o], c = s + a.nodeSize;
        c > t && ((s < t || c > n) && (a.isText ? a = a.cut(Math.max(0, t - s), Math.min(a.text.length, n - s)) : a = a.cut(Math.max(0, t - s - 1), Math.min(a.content.size, n - s - 1))), r.push(a), i += a.nodeSize), s = c;
      }
    return new $e(r, i);
  }
  /**
  @internal
  */
  cutByIndex(t, n) {
    return t == n ? $e.empty : t == 0 && n == this.content.length ? this : new $e(this.content.slice(t, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(t, n) {
    let r = this.content[t];
    if (r == n)
      return this;
    let i = this.content.slice(), o = this.size + n.nodeSize - r.nodeSize;
    return i[t] = n, new $e(i, o);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(t) {
    return new $e([t].concat(this.content), this.size + t.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(t) {
    return new $e(this.content.concat(t), this.size + t.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(t) {
    if (this.content.length != t.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(t.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(t) {
    let n = this.content[t];
    if (!n)
      throw new RangeError("Index " + t + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(t) {
    return this.content[t] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(t) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n];
      t(i, r, n), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(t, n = 0) {
    return LH(this, t, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(t, n = this.size, r = t.size) {
    return BH(this, t, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(t) {
    if (t == 0)
      return c0(0, t);
    if (t == this.size)
      return c0(this.content.length, t);
    if (t > this.size || t < 0)
      throw new RangeError(`Position ${t} outside of fragment (${this})`);
    for (let n = 0, r = 0; ; n++) {
      let i = this.child(n), o = r + i.nodeSize;
      if (o >= t)
        return o == t ? c0(n + 1, o) : c0(n, r);
      r = o;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((t) => t.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(t, n) {
    if (!n)
      return $e.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new $e(n.map(t.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(t) {
    if (!t.length)
      return $e.empty;
    let n, r = 0;
    for (let i = 0; i < t.length; i++) {
      let o = t[i];
      r += o.nodeSize, i && o.isText && t[i - 1].sameMarkup(o) ? (n || (n = t.slice(0, i)), n[n.length - 1] = o.withText(n[n.length - 1].text + o.text)) : n && n.push(o);
    }
    return new $e(n || t, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(t) {
    if (!t)
      return $e.empty;
    if (t instanceof $e)
      return t;
    if (Array.isArray(t))
      return this.fromArray(t);
    if (t.attrs)
      return new $e([t], t.nodeSize);
    throw new RangeError("Can not convert " + t + " to a Fragment" + (t.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
$e.empty = new $e([], 0);
const nE = { index: 0, offset: 0 };
function c0(e, t) {
  return nE.index = e, nE.offset = t, nE;
}
function cx(e, t) {
  if (e === t)
    return !0;
  if (!(e && typeof e == "object") || !(t && typeof t == "object"))
    return !1;
  let n = Array.isArray(e);
  if (Array.isArray(t) != n)
    return !1;
  if (n) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!cx(e[r], t[r]))
        return !1;
  } else {
    for (let r in e)
      if (!(r in t) || !cx(e[r], t[r]))
        return !1;
    for (let r in t)
      if (!(r in e))
        return !1;
  }
  return !0;
}
let _n = class _T {
  /**
  @internal
  */
  constructor(t, n) {
    this.type = t, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(t) {
    let n, r = !1;
    for (let i = 0; i < t.length; i++) {
      let o = t[i];
      if (this.eq(o))
        return t;
      if (this.type.excludes(o.type))
        n || (n = t.slice(0, i));
      else {
        if (o.type.excludes(this.type))
          return t;
        !r && o.type.rank > this.type.rank && (n || (n = t.slice(0, i)), n.push(this), r = !0), n && n.push(o);
      }
    }
    return n || (n = t.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(t) {
    for (let n = 0; n < t.length; n++)
      if (this.eq(t[n]))
        return t.slice(0, n).concat(t.slice(n + 1));
    return t;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(t) {
    for (let n = 0; n < t.length; n++)
      if (this.eq(t[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(t) {
    return this == t || this.type == t.type && cx(this.attrs, t.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let t = { type: this.type.name };
    for (let n in this.attrs) {
      t.attrs = this.attrs;
      break;
    }
    return t;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(t, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = t.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let i = r.create(n.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(t, n) {
    if (t == n)
      return !0;
    if (t.length != n.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!t[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(t) {
    if (!t || Array.isArray(t) && t.length == 0)
      return _T.none;
    if (t instanceof _T)
      return [t];
    let n = t.slice();
    return n.sort((r, i) => r.type.rank - i.type.rank), n;
  }
};
_n.none = [];
class ux extends Error {
}
class et {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(t, n, r) {
    this.content = t, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(t, n) {
    let r = UH(this.content, t + this.openStart, n);
    return r && new et(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(t, n) {
    return new et($H(this.content, t + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(t) {
    return this.content.eq(t.content) && this.openStart == t.openStart && this.openEnd == t.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let t = { content: this.content.toJSON() };
    return this.openStart > 0 && (t.openStart = this.openStart), this.openEnd > 0 && (t.openEnd = this.openEnd), t;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(t, n) {
    if (!n)
      return et.empty;
    let r = n.openStart || 0, i = n.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new et($e.fromJSON(t, n.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(t, n = !0) {
    let r = 0, i = 0;
    for (let o = t.firstChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.firstChild)
      r++;
    for (let o = t.lastChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.lastChild)
      i++;
    return new et(t, r, i);
  }
}
et.empty = new et($e.empty, 0, 0);
function $H(e, t, n) {
  let { index: r, offset: i } = e.findIndex(t), o = e.maybeChild(r), { index: s, offset: a } = e.findIndex(n);
  if (i == t || o.isText) {
    if (a != n && !e.child(s).isText)
      throw new RangeError("Removing non-flat range");
    return e.cut(0, t).append(e.cut(n));
  }
  if (r != s)
    throw new RangeError("Removing non-flat range");
  return e.replaceChild(r, o.copy($H(o.content, t - i - 1, n - i - 1)));
}
function UH(e, t, n, r) {
  let { index: i, offset: o } = e.findIndex(t), s = e.maybeChild(i);
  if (o == t || s.isText)
    return r && !r.canReplace(i, i, n) ? null : e.cut(0, t).append(n).append(e.cut(t));
  let a = UH(s.content, t - o - 1, n, s);
  return a && e.replaceChild(i, s.copy(a));
}
function TNe(e, t, n) {
  if (n.openStart > e.depth)
    throw new ux("Inserted content deeper than insertion position");
  if (e.depth - n.openStart != t.depth - n.openEnd)
    throw new ux("Inconsistent open depths");
  return FH(e, t, n, 0);
}
function FH(e, t, n, r) {
  let i = e.index(r), o = e.node(r);
  if (i == t.index(r) && r < e.depth - n.openStart) {
    let s = FH(e, t, n, r + 1);
    return o.copy(o.content.replaceChild(i, s));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && e.depth == r && t.depth == r) {
      let s = e.parent, a = s.content;
      return Zu(s, a.cut(0, e.parentOffset).append(n.content).append(a.cut(t.parentOffset)));
    } else {
      let { start: s, end: a } = ANe(n, e);
      return Zu(o, HH(e, s, a, t, r));
    }
  else return Zu(o, dx(e, t, r));
}
function VH(e, t) {
  if (!t.type.compatibleContent(e.type))
    throw new ux("Cannot join " + t.type.name + " onto " + e.type.name);
}
function TT(e, t, n) {
  let r = e.node(n);
  return VH(r, t.node(n)), r;
}
function Ku(e, t) {
  let n = t.length - 1;
  n >= 0 && e.isText && e.sameMarkup(t[n]) ? t[n] = e.withText(t[n].text + e.text) : t.push(e);
}
function Km(e, t, n, r) {
  let i = (t || e).node(n), o = 0, s = t ? t.index(n) : i.childCount;
  e && (o = e.index(n), e.depth > n ? o++ : e.textOffset && (Ku(e.nodeAfter, r), o++));
  for (let a = o; a < s; a++)
    Ku(i.child(a), r);
  t && t.depth == n && t.textOffset && Ku(t.nodeBefore, r);
}
function Zu(e, t) {
  return e.type.checkContent(t), e.copy(t);
}
function HH(e, t, n, r, i) {
  let o = e.depth > i && TT(e, t, i + 1), s = r.depth > i && TT(n, r, i + 1), a = [];
  return Km(null, e, i, a), o && s && t.index(i) == n.index(i) ? (VH(o, s), Ku(Zu(o, HH(e, t, n, r, i + 1)), a)) : (o && Ku(Zu(o, dx(e, t, i + 1)), a), Km(t, n, i, a), s && Ku(Zu(s, dx(n, r, i + 1)), a)), Km(r, null, i, a), new $e(a);
}
function dx(e, t, n) {
  let r = [];
  if (Km(null, e, n, r), e.depth > n) {
    let i = TT(e, t, n + 1);
    Ku(Zu(i, dx(e, t, n + 1)), r);
  }
  return Km(t, null, n, r), new $e(r);
}
function ANe(e, t) {
  let n = t.depth - e.openStart, i = t.node(n).copy(e.content);
  for (let o = n - 1; o >= 0; o--)
    i = t.node(o).copy($e.from(i));
  return {
    start: i.resolveNoCache(e.openStart + n),
    end: i.resolveNoCache(i.content.size - e.openEnd - n)
  };
}
class Ag {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.pos = t, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(t) {
    return t == null ? this.depth : t < 0 ? this.depth + t : t;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(t) {
    return this.path[this.resolveDepth(t) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(t) {
    return this.path[this.resolveDepth(t) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(t) {
    return t = this.resolveDepth(t), this.index(t) + (t == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(t) {
    return t = this.resolveDepth(t), t == 0 ? 0 : this.path[t * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(t) {
    return t = this.resolveDepth(t), this.start(t) + this.node(t).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(t) {
    if (t = this.resolveDepth(t), !t)
      throw new RangeError("There is no position before the top-level node");
    return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(t) {
    if (t = this.resolveDepth(t), !t)
      throw new RangeError("There is no position after the top-level node");
    return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1] + this.path[t * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let t = this.parent, n = this.index(this.depth);
    if (n == t.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = t.child(n);
    return r ? t.child(n).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let t = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(t).cut(0, n) : t == 0 ? null : this.parent.child(t - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(t, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let o = 0; o < t; o++)
      i += r.child(o).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let t = this.parent, n = this.index();
    if (t.content.size == 0)
      return _n.none;
    if (this.textOffset)
      return t.child(n).marks;
    let r = t.maybeChild(n - 1), i = t.maybeChild(n);
    if (!r) {
      let a = r;
      r = i, i = a;
    }
    let o = r.marks;
    for (var s = 0; s < o.length; s++)
      o[s].type.spec.inclusive === !1 && (!i || !o[s].isInSet(i.marks)) && (o = o[s--].removeFromSet(o));
    return o;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(t) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, i = t.parent.maybeChild(t.index());
    for (var o = 0; o < r.length; o++)
      r[o].type.spec.inclusive === !1 && (!i || !r[o].isInSet(i.marks)) && (r = r[o--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(t) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= t && this.end(n) >= t)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(t = this, n) {
    if (t.pos < this.pos)
      return t.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == t.pos ? 1 : 0); r >= 0; r--)
      if (t.pos <= this.end(r) && (!n || n(this.node(r))))
        return new fx(this, t, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(t) {
    return this.pos - this.parentOffset == t.pos - t.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(t) {
    return t.pos > this.pos ? t : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(t) {
    return t.pos < this.pos ? t : this;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let n = 1; n <= this.depth; n++)
      t += (t ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return t + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(t, n) {
    if (!(n >= 0 && n <= t.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], i = 0, o = n;
    for (let s = t; ; ) {
      let { index: a, offset: c } = s.content.findIndex(o), u = o - c;
      if (r.push(s, a, i + c), !u || (s = s.child(a), s.isText))
        break;
      o = u - 1, i += c + 1;
    }
    return new Ag(n, r, o);
  }
  /**
  @internal
  */
  static resolveCached(t, n) {
    let r = FL.get(t);
    if (r)
      for (let o = 0; o < r.elts.length; o++) {
        let s = r.elts[o];
        if (s.pos == n)
          return s;
      }
    else
      FL.set(t, r = new MNe());
    let i = r.elts[r.i] = Ag.resolve(t, n);
    return r.i = (r.i + 1) % NNe, i;
  }
}
class MNe {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const NNe = 12, FL = /* @__PURE__ */ new WeakMap();
class fx {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(t, n, r) {
    this.$from = t, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const RNe = /* @__PURE__ */ Object.create(null);
let Sc = class AT {
  /**
  @internal
  */
  constructor(t, n, r, i = _n.none) {
    this.type = t, this.attrs = n, this.marks = i, this.content = r || $e.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(t) {
    return this.content.child(t);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(t) {
    return this.content.maybeChild(t);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(t) {
    this.content.forEach(t);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(t, n, r, i = 0) {
    this.content.nodesBetween(t, n, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(t) {
    this.nodesBetween(0, this.content.size, t);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(t, n, r, i) {
    return this.content.textBetween(t, n, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(t) {
    return this == t || this.sameMarkup(t) && this.content.eq(t.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(t) {
    return this.hasMarkup(t.type, t.attrs, t.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(t, n, r) {
    return this.type == t && cx(this.attrs, n || t.defaultAttrs || RNe) && _n.sameSet(this.marks, r || _n.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(t = null) {
    return t == this.content ? this : new AT(this.type, this.attrs, t, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(t) {
    return t == this.marks ? this : new AT(this.type, this.attrs, this.content, t);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(t, n = this.content.size) {
    return t == 0 && n == this.content.size ? this : this.copy(this.content.cut(t, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(t, n = this.content.size, r = !1) {
    if (t == n)
      return et.empty;
    let i = this.resolve(t), o = this.resolve(n), s = r ? 0 : i.sharedDepth(n), a = i.start(s), u = i.node(s).content.cut(i.pos - a, o.pos - a);
    return new et(u, i.depth - s, o.depth - s);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(t, n, r) {
    return TNe(this.resolve(t), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(t) {
    for (let n = this; ; ) {
      let { index: r, offset: i } = n.content.findIndex(t);
      if (n = n.maybeChild(r), !n)
        return null;
      if (i == t || n.isText)
        return n;
      t -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(t) {
    let { index: n, offset: r } = this.content.findIndex(t);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(t) {
    if (t == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(t);
    if (r < t)
      return { node: this.content.child(n), index: n, offset: r };
    let i = this.content.child(n - 1);
    return { node: i, index: n - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(t) {
    return Ag.resolveCached(this, t);
  }
  /**
  @internal
  */
  resolveNoCache(t) {
    return Ag.resolve(this, t);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(t, n, r) {
    let i = !1;
    return n > t && this.nodesBetween(t, n, (o) => (r.isInSet(o.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let t = this.type.name;
    return this.content.size && (t += "(" + this.content.toStringInner() + ")"), WH(this.marks, t);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(t) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, t);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(t, n, r = $e.empty, i = 0, o = r.childCount) {
    let s = this.contentMatchAt(t).matchFragment(r, i, o), a = s && s.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let c = i; c < o; c++)
      if (!this.type.allowsMarks(r.child(c).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(t, n, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let o = this.contentMatchAt(t).matchType(r), s = o && o.matchFragment(this.content, n);
    return s ? s.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(t) {
    return t.content.size ? this.canReplace(this.childCount, this.childCount, t.content) : this.type.compatibleContent(t.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let t = _n.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), t = r.addToSet(t);
    }
    if (!_n.sameSet(t, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let t = { type: this.type.name };
    for (let n in this.attrs) {
      t.attrs = this.attrs;
      break;
    }
    return this.content.size && (t.content = this.content.toJSON()), this.marks.length && (t.marks = this.marks.map((n) => n.toJSON())), t;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(t, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(t.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return t.text(n.text, r);
    }
    let i = $e.fromJSON(t, n.content), o = t.nodeType(n.type).create(n.attrs, i, r);
    return o.type.checkAttrs(o.attrs), o;
  }
};
Sc.prototype.text = void 0;
class hx extends Sc {
  /**
  @internal
  */
  constructor(t, n, r, i) {
    if (super(t, n, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : WH(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(t, n) {
    return this.text.slice(t, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(t) {
    return t == this.marks ? this : new hx(this.type, this.attrs, this.text, t);
  }
  withText(t) {
    return t == this.text ? this : new hx(this.type, this.attrs, t, this.marks);
  }
  cut(t = 0, n = this.text.length) {
    return t == 0 && n == this.text.length ? this : this.withText(this.text.slice(t, n));
  }
  eq(t) {
    return this.sameMarkup(t) && this.text == t.text;
  }
  toJSON() {
    let t = super.toJSON();
    return t.text = this.text, t;
  }
}
function WH(e, t) {
  for (let n = e.length - 1; n >= 0; n--)
    t = e[n].type.name + "(" + t + ")";
  return t;
}
class ud {
  /**
  @internal
  */
  constructor(t) {
    this.validEnd = t, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(t, n) {
    let r = new ONe(t, n);
    if (r.next == null)
      return ud.empty;
    let i = qH(r);
    r.next && r.err("Unexpected trailing text");
    let o = BNe(LNe(i));
    return $Ne(o, r), o;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(t) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == t)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(t, n = 0, r = t.childCount) {
    let i = this;
    for (let o = n; i && o < r; o++)
      i = i.matchType(t.child(o).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let t = 0; t < this.next.length; t++) {
      let { type: n } = this.next[t];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(t) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < t.next.length; r++)
        if (this.next[n].type == t.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(t, n = !1, r = 0) {
    let i = [this];
    function o(s, a) {
      let c = s.matchFragment(t, r);
      if (c && (!n || c.validEnd))
        return $e.from(a.map((u) => u.createAndFill()));
      for (let u = 0; u < s.next.length; u++) {
        let { type: f, next: h } = s.next[u];
        if (!(f.isText || f.hasRequiredAttrs()) && i.indexOf(h) == -1) {
          i.push(h);
          let m = o(h, a.concat(f));
          if (m)
            return m;
        }
      }
      return null;
    }
    return o(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(t) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == t)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(t);
    return this.wrapCache.push(t, n), n;
  }
  /**
  @internal
  */
  computeWrapping(t) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), o = i.match;
      if (o.matchType(t)) {
        let s = [];
        for (let a = i; a.type; a = a.via)
          s.push(a.type);
        return s.reverse();
      }
      for (let s = 0; s < o.next.length; s++) {
        let { type: a, next: c } = o.next[s];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!i.type || c.validEnd) && (r.push({ match: a.contentMatch, type: a, via: i }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(t) {
    if (t >= this.next.length)
      throw new RangeError(`There's no ${t}th edge in this content match`);
    return this.next[t];
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    function n(r) {
      t.push(r);
      for (let i = 0; i < r.next.length; i++)
        t.indexOf(r.next[i].next) == -1 && n(r.next[i].next);
    }
    return n(this), t.map((r, i) => {
      let o = i + (r.validEnd ? "*" : " ") + " ";
      for (let s = 0; s < r.next.length; s++)
        o += (s ? ", " : "") + r.next[s].type.name + "->" + t.indexOf(r.next[s].next);
      return o;
    }).join(`
`);
  }
}
ud.empty = new ud(!0);
class ONe {
  constructor(t, n) {
    this.string = t, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = t.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(t) {
    return this.next == t && (this.pos++ || !0);
  }
  err(t) {
    throw new SyntaxError(t + " (in content expression '" + this.string + "')");
  }
}
function qH(e) {
  let t = [];
  do
    t.push(PNe(e));
  while (e.eat("|"));
  return t.length == 1 ? t[0] : { type: "choice", exprs: t };
}
function PNe(e) {
  let t = [];
  do
    t.push(DNe(e));
  while (e.next && e.next != ")" && e.next != "|");
  return t.length == 1 ? t[0] : { type: "seq", exprs: t };
}
function DNe(e) {
  let t = zNe(e);
  for (; ; )
    if (e.eat("+"))
      t = { type: "plus", expr: t };
    else if (e.eat("*"))
      t = { type: "star", expr: t };
    else if (e.eat("?"))
      t = { type: "opt", expr: t };
    else if (e.eat("{"))
      t = INe(e, t);
    else
      break;
  return t;
}
function VL(e) {
  /\D/.test(e.next) && e.err("Expected number, got '" + e.next + "'");
  let t = Number(e.next);
  return e.pos++, t;
}
function INe(e, t) {
  let n = VL(e), r = n;
  return e.eat(",") && (e.next != "}" ? r = VL(e) : r = -1), e.eat("}") || e.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: t };
}
function jNe(e, t) {
  let n = e.nodeTypes, r = n[t];
  if (r)
    return [r];
  let i = [];
  for (let o in n) {
    let s = n[o];
    s.isInGroup(t) && i.push(s);
  }
  return i.length == 0 && e.err("No node type or group '" + t + "' found"), i;
}
function zNe(e) {
  if (e.eat("(")) {
    let t = qH(e);
    return e.eat(")") || e.err("Missing closing paren"), t;
  } else if (/\W/.test(e.next))
    e.err("Unexpected token '" + e.next + "'");
  else {
    let t = jNe(e, e.next).map((n) => (e.inline == null ? e.inline = n.isInline : e.inline != n.isInline && e.err("Mixing inline and block content"), { type: "name", value: n }));
    return e.pos++, t.length == 1 ? t[0] : { type: "choice", exprs: t };
  }
}
function LNe(e) {
  let t = [[]];
  return i(o(e, 0), n()), t;
  function n() {
    return t.push([]) - 1;
  }
  function r(s, a, c) {
    let u = { term: c, to: a };
    return t[s].push(u), u;
  }
  function i(s, a) {
    s.forEach((c) => c.to = a);
  }
  function o(s, a) {
    if (s.type == "choice")
      return s.exprs.reduce((c, u) => c.concat(o(u, a)), []);
    if (s.type == "seq")
      for (let c = 0; ; c++) {
        let u = o(s.exprs[c], a);
        if (c == s.exprs.length - 1)
          return u;
        i(u, a = n());
      }
    else if (s.type == "star") {
      let c = n();
      return r(a, c), i(o(s.expr, c), c), [r(c)];
    } else if (s.type == "plus") {
      let c = n();
      return i(o(s.expr, a), c), i(o(s.expr, c), c), [r(c)];
    } else {
      if (s.type == "opt")
        return [r(a)].concat(o(s.expr, a));
      if (s.type == "range") {
        let c = a;
        for (let u = 0; u < s.min; u++) {
          let f = n();
          i(o(s.expr, c), f), c = f;
        }
        if (s.max == -1)
          i(o(s.expr, c), c);
        else
          for (let u = s.min; u < s.max; u++) {
            let f = n();
            r(c, f), i(o(s.expr, c), f), c = f;
          }
        return [r(c)];
      } else {
        if (s.type == "name")
          return [r(a, void 0, s.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function GH(e, t) {
  return t - e;
}
function HL(e, t) {
  let n = [];
  return r(t), n.sort(GH);
  function r(i) {
    let o = e[i];
    if (o.length == 1 && !o[0].term)
      return r(o[0].to);
    n.push(i);
    for (let s = 0; s < o.length; s++) {
      let { term: a, to: c } = o[s];
      !a && n.indexOf(c) == -1 && r(c);
    }
  }
}
function BNe(e) {
  let t = /* @__PURE__ */ Object.create(null);
  return n(HL(e, 0));
  function n(r) {
    let i = [];
    r.forEach((s) => {
      e[s].forEach(({ term: a, to: c }) => {
        if (!a)
          return;
        let u;
        for (let f = 0; f < i.length; f++)
          i[f][0] == a && (u = i[f][1]);
        HL(e, c).forEach((f) => {
          u || i.push([a, u = []]), u.indexOf(f) == -1 && u.push(f);
        });
      });
    });
    let o = t[r.join(",")] = new ud(r.indexOf(e.length - 1) > -1);
    for (let s = 0; s < i.length; s++) {
      let a = i[s][1].sort(GH);
      o.next.push({ type: i[s][0], next: t[a.join(",")] || n(a) });
    }
    return o;
  }
}
function $Ne(e, t) {
  for (let n = 0, r = [e]; n < r.length; n++) {
    let i = r[n], o = !i.validEnd, s = [];
    for (let a = 0; a < i.next.length; a++) {
      let { type: c, next: u } = i.next[a];
      s.push(c.name), o && !(c.isText || c.hasRequiredAttrs()) && (o = !1), r.indexOf(u) == -1 && r.push(u);
    }
    o && t.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function KH(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in e) {
    let r = e[n];
    if (!r.hasDefault)
      return null;
    t[n] = r.default;
  }
  return t;
}
function ZH(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in e) {
    let i = t && t[r];
    if (i === void 0) {
      let o = e[r];
      if (o.hasDefault)
        i = o.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = i;
  }
  return n;
}
function YH(e, t, n, r) {
  for (let i in t)
    if (!(i in e))
      throw new RangeError(`Unsupported attribute ${i} for ${n} of type ${i}`);
  for (let i in e) {
    let o = e[i];
    o.validate && o.validate(t[i]);
  }
}
function XH(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  if (t)
    for (let r in t)
      n[r] = new FNe(e, r, t[r]);
  return n;
}
let WL = class JH {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.name = t, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = XH(t, r.attrs), this.defaultAttrs = KH(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || t == "text"), this.isText = t == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ud.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(t) {
    return this.groups.indexOf(t) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let t in this.attrs)
      if (this.attrs[t].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(t) {
    return this == t || this.contentMatch.compatible(t.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(t) {
    return !t && this.defaultAttrs ? this.defaultAttrs : ZH(this.attrs, t);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(t = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Sc(this, this.computeAttrs(t), $e.from(n), _n.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(t = null, n, r) {
    return n = $e.from(n), this.checkContent(n), new Sc(this, this.computeAttrs(t), n, _n.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(t = null, n, r) {
    if (t = this.computeAttrs(t), n = $e.from(n), n.size) {
      let s = this.contentMatch.fillBefore(n);
      if (!s)
        return null;
      n = s.append(n);
    }
    let i = this.contentMatch.matchFragment(n), o = i && i.fillBefore($e.empty, !0);
    return o ? new Sc(this, t, n.append(o), _n.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(t) {
    let n = this.contentMatch.matchFragment(t);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < t.childCount; r++)
      if (!this.allowsMarks(t.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(t) {
    if (!this.validContent(t))
      throw new RangeError(`Invalid content for node ${this.name}: ${t.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(t) {
    YH(this.attrs, t, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(t) {
    return this.markSet == null || this.markSet.indexOf(t) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(t) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < t.length; n++)
      if (!this.allowsMarkType(t[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(t) {
    if (this.markSet == null)
      return t;
    let n;
    for (let r = 0; r < t.length; r++)
      this.allowsMarkType(t[r].type) ? n && n.push(t[r]) : n || (n = t.slice(0, r));
    return n ? n.length ? n : _n.none : t;
  }
  /**
  @internal
  */
  static compile(t, n) {
    let r = /* @__PURE__ */ Object.create(null);
    t.forEach((o, s) => r[o] = new JH(o, n, s));
    let i = n.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let o in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function UNe(e, t, n) {
  let r = n.split("|");
  return (i) => {
    let o = i === null ? "null" : typeof i;
    if (r.indexOf(o) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${t} on type ${e}, got ${o}`);
  };
}
class FNe {
  constructor(t, n, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? UNe(t, n, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class s1 {
  /**
  @internal
  */
  constructor(t, n, r, i) {
    this.name = t, this.rank = n, this.schema = r, this.spec = i, this.attrs = XH(t, i.attrs), this.excluded = null;
    let o = KH(this.attrs);
    this.instance = o ? new _n(this, o) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(t = null) {
    return !t && this.instance ? this.instance : new _n(this, ZH(this.attrs, t));
  }
  /**
  @internal
  */
  static compile(t, n) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return t.forEach((o, s) => r[o] = new s1(o, i++, n, s)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(t) {
    for (var n = 0; n < t.length; n++)
      t[n].type == this && (t = t.slice(0, n).concat(t.slice(n + 1)), n--);
    return t;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(t) {
    for (let n = 0; n < t.length; n++)
      if (t[n].type == this)
        return t[n];
  }
  /**
  @internal
  */
  checkAttrs(t) {
    YH(this.attrs, t, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(t) {
    return this.excluded.indexOf(t) > -1;
  }
}
class QH {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(t) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let i in t)
      n[i] = t[i];
    n.nodes = ti.from(t.nodes), n.marks = ti.from(t.marks || {}), this.nodes = WL.compile(this.spec.nodes, this), this.marks = s1.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let o = this.nodes[i], s = o.spec.content || "", a = o.spec.marks;
      if (o.contentMatch = r[s] || (r[s] = ud.parse(s, this.nodes)), o.inlineContent = o.contentMatch.inlineContent, o.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!o.isInline || !o.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = o;
      }
      o.markSet = a == "_" ? null : a ? qL(this, a.split(" ")) : a == "" || !o.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let o = this.marks[i], s = o.spec.excludes;
      o.excluded = s == null ? [o] : s == "" ? [] : qL(this, s.split(" "));
    }
    this.nodeFromJSON = (i) => Sc.fromJSON(this, i), this.markFromJSON = (i) => _n.fromJSON(this, i), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(t, n = null, r, i) {
    if (typeof t == "string")
      t = this.nodeType(t);
    else if (t instanceof WL) {
      if (t.schema != this)
        throw new RangeError("Node type from different schema used (" + t.name + ")");
    } else throw new RangeError("Invalid node type: " + t);
    return t.createChecked(n, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(t, n) {
    let r = this.nodes.text;
    return new hx(r, r.defaultAttrs, t, _n.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(t, n) {
    return typeof t == "string" && (t = this.marks[t]), t.create(n);
  }
  /**
  @internal
  */
  nodeType(t) {
    let n = this.nodes[t];
    if (!n)
      throw new RangeError("Unknown node type: " + t);
    return n;
  }
}
function qL(e, t) {
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r], o = e.marks[i], s = o;
    if (o)
      n.push(o);
    else
      for (let a in e.marks) {
        let c = e.marks[a];
        (i == "_" || c.spec.group && c.spec.group.split(" ").indexOf(i) > -1) && n.push(s = c);
      }
    if (!s)
      throw new SyntaxError("Unknown mark type: '" + t[r] + "'");
  }
  return n;
}
function VNe(e) {
  return e.tag != null;
}
function HNe(e) {
  return e.style != null;
}
class kc {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(t, n) {
    this.schema = t, this.rules = n, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    n.forEach((i) => {
      if (VNe(i))
        this.tags.push(i);
      else if (HNe(i)) {
        let o = /[^=]*/.exec(i.style)[0];
        r.indexOf(o) < 0 && r.push(o), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let o = t.nodes[i.node];
      return o.contentMatch.matchType(o);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(t, n = {}) {
    let r = new KL(this, n, !1);
    return r.addAll(t, _n.none, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(t, n = {}) {
    let r = new KL(this, n, !0);
    return r.addAll(t, _n.none, n.from, n.to), et.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(t, n, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let o = this.tags[i];
      if (GNe(t, o.tag) && (o.namespace === void 0 || t.namespaceURI == o.namespace) && (!o.context || n.matchesContext(o.context))) {
        if (o.getAttrs) {
          let s = o.getAttrs(t);
          if (s === !1)
            continue;
          o.attrs = s || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(t, n, r, i) {
    for (let o = i ? this.styles.indexOf(i) + 1 : 0; o < this.styles.length; o++) {
      let s = this.styles[o], a = s.style;
      if (!(a.indexOf(t) != 0 || s.context && !r.matchesContext(s.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > t.length && (a.charCodeAt(t.length) != 61 || a.slice(t.length + 1) != n))) {
        if (s.getAttrs) {
          let c = s.getAttrs(n);
          if (c === !1)
            continue;
          s.attrs = c || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(t) {
    let n = [];
    function r(i) {
      let o = i.priority == null ? 50 : i.priority, s = 0;
      for (; s < n.length; s++) {
        let a = n[s];
        if ((a.priority == null ? 50 : a.priority) < o)
          break;
      }
      n.splice(s, 0, i);
    }
    for (let i in t.marks) {
      let o = t.marks[i].spec.parseDOM;
      o && o.forEach((s) => {
        r(s = ZL(s)), s.mark || s.ignore || s.clearMark || (s.mark = i);
      });
    }
    for (let i in t.nodes) {
      let o = t.nodes[i].spec.parseDOM;
      o && o.forEach((s) => {
        r(s = ZL(s)), s.node || s.ignore || s.mark || (s.node = i);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(t) {
    return t.cached.domParser || (t.cached.domParser = new kc(t, kc.schemaRules(t)));
  }
}
const eW = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, WNe = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, tW = { ol: !0, ul: !0 }, Mg = 1, MT = 2, Zm = 4;
function GL(e, t, n) {
  return t != null ? (t ? Mg : 0) | (t === "full" ? MT : 0) : e && e.whitespace == "pre" ? Mg | MT : n & ~Zm;
}
class u0 {
  constructor(t, n, r, i, o, s) {
    this.type = t, this.attrs = n, this.marks = r, this.solid = i, this.options = s, this.content = [], this.activeMarks = _n.none, this.match = o || (s & Zm ? null : t.contentMatch);
  }
  findWrapping(t) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore($e.from(t));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(t.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(t.type);
  }
  finish(t) {
    if (!(this.options & Mg)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let o = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = o.withText(o.text.slice(0, o.text.length - i[0].length));
      }
    }
    let n = $e.from(this.content);
    return !t && this.match && (n = n.append(this.match.fillBefore($e.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(t) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : t.parentNode && !eW.hasOwnProperty(t.parentNode.nodeName.toLowerCase());
  }
}
class KL {
  constructor(t, n, r) {
    this.parser = t, this.options = n, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let i = n.topNode, o, s = GL(null, n.preserveWhitespace, 0) | (r ? Zm : 0);
    i ? o = new u0(i.type, i.attrs, _n.none, !0, n.topMatch || i.type.contentMatch, s) : r ? o = new u0(null, null, _n.none, !0, null, s) : o = new u0(t.schema.topNodeType, null, _n.none, !0, null, s), this.nodes = [o], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(t, n) {
    t.nodeType == 3 ? this.addTextNode(t, n) : t.nodeType == 1 && this.addElement(t, n);
  }
  addTextNode(t, n) {
    let r = t.nodeValue, i = this.top, o = i.options & MT ? "full" : this.localPreserveWS || (i.options & Mg) > 0, { schema: s } = this.parser;
    if (o === "full" || i.inlineContext(t) || /[^ \t\r\n\u000c]/.test(r)) {
      if (o)
        if (o === "full")
          r = r.replace(/\r\n?/g, `
`);
        else if (s.linebreakReplacement && /[\r\n]/.test(r) && this.top.findWrapping(s.linebreakReplacement.create())) {
          let a = r.split(/\r?\n|\r/);
          for (let c = 0; c < a.length; c++)
            c && this.insertNode(s.linebreakReplacement.create(), n, !0), a[c] && this.insertNode(s.text(a[c]), n, !/\S/.test(a[c]));
          r = "";
        } else
          r = r.replace(/\r?\n|\r/g, " ");
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let a = i.content[i.content.length - 1], c = t.previousSibling;
        (!a || c && c.nodeName == "BR" || a.isText && /[ \t\r\n\u000c]$/.test(a.text)) && (r = r.slice(1));
      }
      r && this.insertNode(s.text(r), n, !/\S/.test(r)), this.findInText(t);
    } else
      this.findInside(t);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(t, n, r) {
    let i = this.localPreserveWS, o = this.top;
    (t.tagName == "PRE" || /pre/.test(t.style && t.style.whiteSpace)) && (this.localPreserveWS = !0);
    let s = t.nodeName.toLowerCase(), a;
    tW.hasOwnProperty(s) && this.parser.normalizeLists && qNe(t);
    let c = this.options.ruleFromNode && this.options.ruleFromNode(t) || (a = this.parser.matchTag(t, this, r));
    e: if (c ? c.ignore : WNe.hasOwnProperty(s))
      this.findInside(t), this.ignoreFallback(t, n);
    else if (!c || c.skip || c.closeParent) {
      c && c.closeParent ? this.open = Math.max(0, this.open - 1) : c && c.skip.nodeType && (t = c.skip);
      let u, f = this.needsBlock;
      if (eW.hasOwnProperty(s))
        o.content.length && o.content[0].isInline && this.open && (this.open--, o = this.top), u = !0, o.type || (this.needsBlock = !0);
      else if (!t.firstChild) {
        this.leafFallback(t, n);
        break e;
      }
      let h = c && c.skip ? n : this.readStyles(t, n);
      h && this.addAll(t, h), u && this.sync(o), this.needsBlock = f;
    } else {
      let u = this.readStyles(t, n);
      u && this.addElementByRule(t, c, u, c.consuming === !1 ? a : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(t, n) {
    t.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(t.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(t, n) {
    t.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(t, n) {
    let r = t.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let o = this.parser.matchedStyles[i], s = r.getPropertyValue(o);
        if (s)
          for (let a = void 0; ; ) {
            let c = this.parser.matchStyle(o, s, this, a);
            if (!c)
              break;
            if (c.ignore)
              return null;
            if (c.clearMark ? n = n.filter((u) => !c.clearMark(u)) : n = n.concat(this.parser.schema.marks[c.mark].create(c.attrs)), c.consuming === !1)
              a = c;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(t, n, r, i) {
    let o, s;
    if (n.node)
      if (s = this.parser.schema.nodes[n.node], s.isLeaf)
        this.insertNode(s.create(n.attrs), r, t.nodeName == "BR") || this.leafFallback(t, r);
      else {
        let c = this.enter(s, n.attrs || null, r, n.preserveWhitespace);
        c && (o = !0, r = c);
      }
    else {
      let c = this.parser.schema.marks[n.mark];
      r = r.concat(c.create(n.attrs));
    }
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(t);
    else if (i)
      this.addElement(t, r, i);
    else if (n.getContent)
      this.findInside(t), n.getContent(t, this.parser.schema).forEach((c) => this.insertNode(c, r, !1));
    else {
      let c = t;
      typeof n.contentElement == "string" ? c = t.querySelector(n.contentElement) : typeof n.contentElement == "function" ? c = n.contentElement(t) : n.contentElement && (c = n.contentElement), this.findAround(t, c, !0), this.addAll(c, r), this.findAround(t, c, !1);
    }
    o && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(t, n, r, i) {
    let o = r || 0;
    for (let s = r ? t.childNodes[r] : t.firstChild, a = i == null ? null : t.childNodes[i]; s != a; s = s.nextSibling, ++o)
      this.findAtPoint(t, o), this.addDOM(s, n);
    this.findAtPoint(t, o);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(t, n, r) {
    let i, o;
    for (let s = this.open, a = 0; s >= 0; s--) {
      let c = this.nodes[s], u = c.findWrapping(t);
      if (u && (!i || i.length > u.length + a) && (i = u, o = c, !u.length))
        break;
      if (c.solid) {
        if (r)
          break;
        a += 2;
      }
    }
    if (!i)
      return null;
    this.sync(o);
    for (let s = 0; s < i.length; s++)
      n = this.enterInner(i[s], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(t, n, r) {
    if (t.isInline && this.needsBlock && !this.top.type) {
      let o = this.textblockFromContext();
      o && (n = this.enterInner(o, null, n));
    }
    let i = this.findPlace(t, n, r);
    if (i) {
      this.closeExtra();
      let o = this.top;
      o.match && (o.match = o.match.matchType(t.type));
      let s = _n.none;
      for (let a of i.concat(t.marks))
        (o.type ? o.type.allowsMarkType(a.type) : YL(a.type, t.type)) && (s = a.addToSet(s));
      return o.content.push(t.mark(s)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(t, n, r, i) {
    let o = this.findPlace(t.create(n), r, !1);
    return o && (o = this.enterInner(t, n, r, !0, i)), o;
  }
  // Open a node of the given type
  enterInner(t, n, r, i = !1, o) {
    this.closeExtra();
    let s = this.top;
    s.match = s.match && s.match.matchType(t);
    let a = GL(t, o, s.options);
    s.options & Zm && s.content.length == 0 && (a |= Zm);
    let c = _n.none;
    return r = r.filter((u) => (s.type ? s.type.allowsMarkType(u.type) : YL(u.type, t)) ? (c = u.addToSet(c), !1) : !0), this.nodes.push(new u0(t, n, c, i, null, a)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(t = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(t));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(t) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == t)
        return this.open = n, !0;
      this.localPreserveWS && (this.nodes[n].options |= Mg);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let t = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let i = r.length - 1; i >= 0; i--)
        t += r[i].nodeSize;
      n && t++;
    }
    return t;
  }
  findAtPoint(t, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == t && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(t) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && t.nodeType == 1 && t.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(t, n, r) {
    if (t != n && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && t.nodeType == 1 && t.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(t) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == t && (this.find[n].pos = this.currentPos - (t.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(t) {
    if (t.indexOf("|") > -1)
      return t.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = t.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), o = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), s = (a, c) => {
      for (; a >= 0; a--) {
        let u = n[a];
        if (u == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; c >= o; c--)
            if (s(a - 1, c))
              return !0;
          return !1;
        } else {
          let f = c > 0 || c == 0 && i ? this.nodes[c].type : r && c >= o ? r.node(c - o).type : null;
          if (!f || f.name != u && !f.isInGroup(u))
            return !1;
          c--;
        }
      }
      return !0;
    };
    return s(n.length - 1, this.open);
  }
  textblockFromContext() {
    let t = this.options.context;
    if (t)
      for (let n = t.depth; n >= 0; n--) {
        let r = t.node(n).contentMatchAt(t.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function qNe(e) {
  for (let t = e.firstChild, n = null; t; t = t.nextSibling) {
    let r = t.nodeType == 1 ? t.nodeName.toLowerCase() : null;
    r && tW.hasOwnProperty(r) && n ? (n.appendChild(t), t = n) : r == "li" ? n = t : r && (n = null);
  }
}
function GNe(e, t) {
  return (e.matches || e.msMatchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector).call(e, t);
}
function ZL(e) {
  let t = {};
  for (let n in e)
    t[n] = e[n];
  return t;
}
function YL(e, t) {
  let n = t.schema.nodes;
  for (let r in n) {
    let i = n[r];
    if (!i.allowsMarkType(e))
      continue;
    let o = [], s = (a) => {
      o.push(a);
      for (let c = 0; c < a.edgeCount; c++) {
        let { type: u, next: f } = a.edge(c);
        if (u == t || o.indexOf(f) < 0 && s(f))
          return !0;
      }
    };
    if (s(i.contentMatch))
      return !0;
  }
}
class Cd {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(t, n) {
    this.nodes = t, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(t, n = {}, r) {
    r || (r = rE(n).createDocumentFragment());
    let i = r, o = [];
    return t.forEach((s) => {
      if (o.length || s.marks.length) {
        let a = 0, c = 0;
        for (; a < o.length && c < s.marks.length; ) {
          let u = s.marks[c];
          if (!this.marks[u.type.name]) {
            c++;
            continue;
          }
          if (!u.eq(o[a][0]) || u.type.spec.spanning === !1)
            break;
          a++, c++;
        }
        for (; a < o.length; )
          i = o.pop()[1];
        for (; c < s.marks.length; ) {
          let u = s.marks[c++], f = this.serializeMark(u, s.isInline, n);
          f && (o.push([u, i]), i.appendChild(f.dom), i = f.contentDOM || f.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(s, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(t, n) {
    let { dom: r, contentDOM: i } = tb(rE(n), this.nodes[t.type.name](t), null, t.attrs);
    if (i) {
      if (t.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(t.content, n, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(t, n = {}) {
    let r = this.serializeNodeInner(t, n);
    for (let i = t.marks.length - 1; i >= 0; i--) {
      let o = this.serializeMark(t.marks[i], t.isInline, n);
      o && ((o.contentDOM || o.dom).appendChild(r), r = o.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(t, n, r = {}) {
    let i = this.marks[t.type.name];
    return i && tb(rE(r), i(t, n), null, t.attrs);
  }
  static renderSpec(t, n, r = null, i) {
    return tb(t, n, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(t) {
    return t.cached.domSerializer || (t.cached.domSerializer = new Cd(this.nodesFromSchema(t), this.marksFromSchema(t)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(t) {
    let n = XL(t.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(t) {
    return XL(t.marks);
  }
}
function XL(e) {
  let t = {};
  for (let n in e) {
    let r = e[n].spec.toDOM;
    r && (t[n] = r);
  }
  return t;
}
function rE(e) {
  return e.document || window.document;
}
const JL = /* @__PURE__ */ new WeakMap();
function KNe(e) {
  let t = JL.get(e);
  return t === void 0 && JL.set(e, t = ZNe(e)), t;
}
function ZNe(e) {
  let t = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          t || (t = []), t.push(r);
        else
          for (let i = 0; i < r.length; i++)
            n(r[i]);
      else
        for (let i in r)
          n(r[i]);
  }
  return n(e), t;
}
function tb(e, t, n, r) {
  if (typeof t == "string")
    return { dom: e.createTextNode(t) };
  if (t.nodeType != null)
    return { dom: t };
  if (t.dom && t.dom.nodeType != null)
    return t;
  let i = t[0], o;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (o = KNe(r)) && o.indexOf(t) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let s = i.indexOf(" ");
  s > 0 && (n = i.slice(0, s), i = i.slice(s + 1));
  let a, c = n ? e.createElementNS(n, i) : e.createElement(i), u = t[1], f = 1;
  if (u && typeof u == "object" && u.nodeType == null && !Array.isArray(u)) {
    f = 2;
    for (let h in u)
      if (u[h] != null) {
        let m = h.indexOf(" ");
        m > 0 ? c.setAttributeNS(h.slice(0, m), h.slice(m + 1), u[h]) : h == "style" && c.style ? c.style.cssText = u[h] : c.setAttribute(h, u[h]);
      }
  }
  for (let h = f; h < t.length; h++) {
    let m = t[h];
    if (m === 0) {
      if (h < t.length - 1 || h > f)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: c, contentDOM: c };
    } else {
      let { dom: g, contentDOM: b } = tb(e, m, n, r);
      if (c.appendChild(g), b) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = b;
      }
    }
  }
  return { dom: c, contentDOM: a };
}
const nW = 65535, rW = Math.pow(2, 16);
function YNe(e, t) {
  return e + t * rW;
}
function QL(e) {
  return e & nW;
}
function XNe(e) {
  return (e - (e & nW)) / rW;
}
const iW = 1, oW = 2, nb = 4, sW = 8;
class NT {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.pos = t, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & sW) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (iW | nb)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (oW | nb)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & nb) > 0;
  }
}
class mo {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(t, n = !1) {
    if (this.ranges = t, this.inverted = n, !t.length && mo.empty)
      return mo.empty;
  }
  /**
  @internal
  */
  recover(t) {
    let n = 0, r = QL(t);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + n + XNe(t);
  }
  mapResult(t, n = 1) {
    return this._map(t, n, !1);
  }
  map(t, n = 1) {
    return this._map(t, n, !0);
  }
  /**
  @internal
  */
  _map(t, n, r) {
    let i = 0, o = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let c = this.ranges[a] - (this.inverted ? i : 0);
      if (c > t)
        break;
      let u = this.ranges[a + o], f = this.ranges[a + s], h = c + u;
      if (t <= h) {
        let m = u ? t == c ? -1 : t == h ? 1 : n : n, g = c + i + (m < 0 ? 0 : f);
        if (r)
          return g;
        let b = t == (n < 0 ? c : h) ? null : YNe(a / 3, t - c), x = t == c ? oW : t == h ? iW : nb;
        return (n < 0 ? t != c : t != h) && (x |= sW), new NT(g, x, b);
      }
      i += f - u;
    }
    return r ? t + i : new NT(t + i, 0, null);
  }
  /**
  @internal
  */
  touches(t, n) {
    let r = 0, i = QL(n), o = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let c = this.ranges[a] - (this.inverted ? r : 0);
      if (c > t)
        break;
      let u = this.ranges[a + o], f = c + u;
      if (t <= f && a == i * 3)
        return !0;
      r += this.ranges[a + s] - u;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(t) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, o = 0; i < this.ranges.length; i += 3) {
      let s = this.ranges[i], a = s - (this.inverted ? o : 0), c = s + (this.inverted ? 0 : o), u = this.ranges[i + n], f = this.ranges[i + r];
      t(a, a + u, c, c + f), o += f - u;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new mo(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(t) {
    return t == 0 ? mo.empty : new mo(t < 0 ? [0, -t, 0] : [0, 0, t]);
  }
}
mo.empty = new mo([]);
class Ng {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(t, n, r = 0, i = t ? t.length : 0) {
    this.mirror = n, this.from = r, this.to = i, this._maps = t || [], this.ownData = !(t || n);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(t = 0, n = this.maps.length) {
    return new Ng(this._maps, this.mirror, t, n);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(t, n) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(t), n != null && this.setMirror(this._maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(t) {
    for (let n = 0, r = this._maps.length; n < t._maps.length; n++) {
      let i = t.getMirror(n);
      this.appendMap(t._maps[n], i != null && i < n ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(t) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == t)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(t, n) {
    this.mirror || (this.mirror = []), this.mirror.push(t, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(t) {
    for (let n = t.maps.length - 1, r = this._maps.length + t._maps.length; n >= 0; n--) {
      let i = t.getMirror(n);
      this.appendMap(t._maps[n].invert(), i != null && i > n ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let t = new Ng();
    return t.appendMappingInverted(this), t;
  }
  /**
  Map a position through this mapping.
  */
  map(t, n = 1) {
    if (this.mirror)
      return this._map(t, n, !0);
    for (let r = this.from; r < this.to; r++)
      t = this._maps[r].map(t, n);
    return t;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(t, n = 1) {
    return this._map(t, n, !1);
  }
  /**
  @internal
  */
  _map(t, n, r) {
    let i = 0;
    for (let o = this.from; o < this.to; o++) {
      let s = this._maps[o], a = s.mapResult(t, n);
      if (a.recover != null) {
        let c = this.getMirror(o);
        if (c != null && c > o && c < this.to) {
          o = c, t = this._maps[c].recover(a.recover);
          continue;
        }
      }
      i |= a.delInfo, t = a.pos;
    }
    return r ? t : new NT(t, i, null);
  }
}
const iE = /* @__PURE__ */ Object.create(null);
class ki {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return mo.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(t) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(t, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = iE[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(t, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(t, n) {
    if (t in iE)
      throw new RangeError("Duplicate use of step JSON ID " + t);
    return iE[t] = n, n.prototype.jsonID = t, n;
  }
}
class Er {
  /**
  @internal
  */
  constructor(t, n) {
    this.doc = t, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(t) {
    return new Er(t, null);
  }
  /**
  Create a failed step result.
  */
  static fail(t) {
    return new Er(null, t);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(t, n, r, i) {
    try {
      return Er.ok(t.replace(n, r, i));
    } catch (o) {
      if (o instanceof ux)
        return Er.fail(o.message);
      throw o;
    }
  }
}
function DN(e, t, n) {
  let r = [];
  for (let i = 0; i < e.childCount; i++) {
    let o = e.child(i);
    o.content.size && (o = o.copy(DN(o.content, t, o))), o.isInline && (o = t(o, n, i)), r.push(o);
  }
  return $e.fromArray(r);
}
class mc extends ki {
  /**
  Create a mark step.
  */
  constructor(t, n, r) {
    super(), this.from = t, this.to = n, this.mark = r;
  }
  apply(t) {
    let n = t.slice(this.from, this.to), r = t.resolve(this.from), i = r.node(r.sharedDepth(this.to)), o = new et(DN(n.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), i), n.openStart, n.openEnd);
    return Er.fromReplace(t, this.from, this.to, o);
  }
  invert() {
    return new ps(this.from, this.to, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new mc(n.pos, r.pos, this.mark);
  }
  merge(t) {
    return t instanceof mc && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from ? new mc(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new mc(n.from, n.to, t.markFromJSON(n.mark));
  }
}
ki.jsonID("addMark", mc);
class ps extends ki {
  /**
  Create a mark-removing step.
  */
  constructor(t, n, r) {
    super(), this.from = t, this.to = n, this.mark = r;
  }
  apply(t) {
    let n = t.slice(this.from, this.to), r = new et(DN(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), t), n.openStart, n.openEnd);
    return Er.fromReplace(t, this.from, this.to, r);
  }
  invert() {
    return new mc(this.from, this.to, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new ps(n.pos, r.pos, this.mark);
  }
  merge(t) {
    return t instanceof ps && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from ? new ps(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new ps(n.from, n.to, t.markFromJSON(n.mark));
  }
}
ki.jsonID("removeMark", ps);
class gc extends ki {
  /**
  Create a node mark step.
  */
  constructor(t, n) {
    super(), this.pos = t, this.mark = n;
  }
  apply(t) {
    let n = t.nodeAt(this.pos);
    if (!n)
      return Er.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return Er.fromReplace(t, this.pos, this.pos + 1, new et($e.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(t) {
    let n = t.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r))
            return new gc(this.pos, n.marks[i]);
        return new gc(this.pos, this.mark);
      }
    }
    return new dd(this.pos, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new gc(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new gc(n.pos, t.markFromJSON(n.mark));
  }
}
ki.jsonID("addNodeMark", gc);
class dd extends ki {
  /**
  Create a mark-removing step.
  */
  constructor(t, n) {
    super(), this.pos = t, this.mark = n;
  }
  apply(t) {
    let n = t.nodeAt(this.pos);
    if (!n)
      return Er.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return Er.fromReplace(t, this.pos, this.pos + 1, new et($e.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(t) {
    let n = t.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new gc(this.pos, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new dd(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new dd(n.pos, t.markFromJSON(n.mark));
  }
}
ki.jsonID("removeNodeMark", dd);
class Vr extends ki {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(t, n, r, i = !1) {
    super(), this.from = t, this.to = n, this.slice = r, this.structure = i;
  }
  apply(t) {
    return this.structure && RT(t, this.from, this.to) ? Er.fail("Structure replace would overwrite content") : Er.fromReplace(t, this.from, this.to, this.slice);
  }
  getMap() {
    return new mo([this.from, this.to - this.from, this.slice.size]);
  }
  invert(t) {
    return new Vr(this.from, this.from + this.slice.size, t.slice(this.from, this.to));
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new Vr(n.pos, Math.max(n.pos, r.pos), this.slice, this.structure);
  }
  merge(t) {
    if (!(t instanceof Vr) || t.structure || this.structure)
      return null;
    if (this.from + this.slice.size == t.from && !this.slice.openEnd && !t.slice.openStart) {
      let n = this.slice.size + t.slice.size == 0 ? et.empty : new et(this.slice.content.append(t.slice.content), this.slice.openStart, t.slice.openEnd);
      return new Vr(this.from, this.to + (t.to - t.from), n, this.structure);
    } else if (t.to == this.from && !this.slice.openStart && !t.slice.openEnd) {
      let n = this.slice.size + t.slice.size == 0 ? et.empty : new et(t.slice.content.append(this.slice.content), t.slice.openStart, this.slice.openEnd);
      return new Vr(t.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let t = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (t.slice = this.slice.toJSON()), this.structure && (t.structure = !0), t;
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new Vr(n.from, n.to, et.fromJSON(t, n.slice), !!n.structure);
  }
}
ki.jsonID("replace", Vr);
class qr extends ki {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(t, n, r, i, o, s, a = !1) {
    super(), this.from = t, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = o, this.insert = s, this.structure = a;
  }
  apply(t) {
    if (this.structure && (RT(t, this.from, this.gapFrom) || RT(t, this.gapTo, this.to)))
      return Er.fail("Structure gap-replace would overwrite content");
    let n = t.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return Er.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? Er.fromReplace(t, this.from, this.to, r) : Er.fail("Content does not fit in gap");
  }
  getMap() {
    return new mo([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(t) {
    let n = this.gapTo - this.gapFrom;
    return new qr(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, t.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1), i = this.from == this.gapFrom ? n.pos : t.map(this.gapFrom, -1), o = this.to == this.gapTo ? r.pos : t.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || i < n.pos || o > r.pos ? null : new qr(n.pos, r.pos, i, o, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let t = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (t.slice = this.slice.toJSON()), this.structure && (t.structure = !0), t;
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new qr(n.from, n.to, n.gapFrom, n.gapTo, et.fromJSON(t, n.slice), n.insert, !!n.structure);
  }
}
ki.jsonID("replaceAround", qr);
function RT(e, t, n) {
  let r = e.resolve(t), i = n - t, o = r.depth;
  for (; i > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount; )
    o--, i--;
  if (i > 0) {
    let s = r.node(o).maybeChild(r.indexAfter(o));
    for (; i > 0; ) {
      if (!s || s.isLeaf)
        return !0;
      s = s.firstChild, i--;
    }
  }
  return !1;
}
function JNe(e, t, n, r) {
  let i = [], o = [], s, a;
  e.doc.nodesBetween(t, n, (c, u, f) => {
    if (!c.isInline)
      return;
    let h = c.marks;
    if (!r.isInSet(h) && f.type.allowsMarkType(r.type)) {
      let m = Math.max(u, t), g = Math.min(u + c.nodeSize, n), b = r.addToSet(h);
      for (let x = 0; x < h.length; x++)
        h[x].isInSet(b) || (s && s.to == m && s.mark.eq(h[x]) ? s.to = g : i.push(s = new ps(m, g, h[x])));
      a && a.to == m ? a.to = g : o.push(a = new mc(m, g, r));
    }
  }), i.forEach((c) => e.step(c)), o.forEach((c) => e.step(c));
}
function QNe(e, t, n, r) {
  let i = [], o = 0;
  e.doc.nodesBetween(t, n, (s, a) => {
    if (!s.isInline)
      return;
    o++;
    let c = null;
    if (r instanceof s1) {
      let u = s.marks, f;
      for (; f = r.isInSet(u); )
        (c || (c = [])).push(f), u = f.removeFromSet(u);
    } else r ? r.isInSet(s.marks) && (c = [r]) : c = s.marks;
    if (c && c.length) {
      let u = Math.min(a + s.nodeSize, n);
      for (let f = 0; f < c.length; f++) {
        let h = c[f], m;
        for (let g = 0; g < i.length; g++) {
          let b = i[g];
          b.step == o - 1 && h.eq(i[g].style) && (m = b);
        }
        m ? (m.to = u, m.step = o) : i.push({ style: h, from: Math.max(a, t), to: u, step: o });
      }
    }
  }), i.forEach((s) => e.step(new ps(s.from, s.to, s.style)));
}
function IN(e, t, n, r = n.contentMatch, i = !0) {
  let o = e.doc.nodeAt(t), s = [], a = t + 1;
  for (let c = 0; c < o.childCount; c++) {
    let u = o.child(c), f = a + u.nodeSize, h = r.matchType(u.type);
    if (!h)
      s.push(new Vr(a, f, et.empty));
    else {
      r = h;
      for (let m = 0; m < u.marks.length; m++)
        n.allowsMarkType(u.marks[m].type) || e.step(new ps(a, f, u.marks[m]));
      if (i && u.isText && n.whitespace != "pre") {
        let m, g = /\r?\n|\r/g, b;
        for (; m = g.exec(u.text); )
          b || (b = new et($e.from(n.schema.text(" ", n.allowedMarks(u.marks))), 0, 0)), s.push(new Vr(a + m.index, a + m.index + m[0].length, b));
      }
    }
    a = f;
  }
  if (!r.validEnd) {
    let c = r.fillBefore($e.empty, !0);
    e.replace(a, a, new et(c, 0, 0));
  }
  for (let c = s.length - 1; c >= 0; c--)
    e.step(s[c]);
}
function eRe(e, t, n) {
  return (t == 0 || e.canReplace(t, e.childCount)) && (n == e.childCount || e.canReplace(0, n));
}
function tp(e) {
  let n = e.parent.content.cutByIndex(e.startIndex, e.endIndex);
  for (let r = e.depth, i = 0, o = 0; ; --r) {
    let s = e.$from.node(r), a = e.$from.index(r) + i, c = e.$to.indexAfter(r) - o;
    if (r < e.depth && s.canReplace(a, c, n))
      return r;
    if (r == 0 || s.type.spec.isolating || !eRe(s, a, c))
      break;
    a && (i = 1), c < s.childCount && (o = 1);
  }
  return null;
}
function tRe(e, t, n) {
  let { $from: r, $to: i, depth: o } = t, s = r.before(o + 1), a = i.after(o + 1), c = s, u = a, f = $e.empty, h = 0;
  for (let b = o, x = !1; b > n; b--)
    x || r.index(b) > 0 ? (x = !0, f = $e.from(r.node(b).copy(f)), h++) : c--;
  let m = $e.empty, g = 0;
  for (let b = o, x = !1; b > n; b--)
    x || i.after(b + 1) < i.end(b) ? (x = !0, m = $e.from(i.node(b).copy(m)), g++) : u++;
  e.step(new qr(c, u, s, a, new et(f.append(m), h, g), f.size - h, !0));
}
function jN(e, t, n = null, r = e) {
  let i = nRe(e, t), o = i && rRe(r, t);
  return o ? i.map(e5).concat({ type: t, attrs: n }).concat(o.map(e5)) : null;
}
function e5(e) {
  return { type: e, attrs: null };
}
function nRe(e, t) {
  let { parent: n, startIndex: r, endIndex: i } = e, o = n.contentMatchAt(r).findWrapping(t);
  if (!o)
    return null;
  let s = o.length ? o[0] : t;
  return n.canReplaceWith(r, i, s) ? o : null;
}
function rRe(e, t) {
  let { parent: n, startIndex: r, endIndex: i } = e, o = n.child(r), s = t.contentMatch.findWrapping(o.type);
  if (!s)
    return null;
  let c = (s.length ? s[s.length - 1] : t).contentMatch;
  for (let u = r; c && u < i; u++)
    c = c.matchType(n.child(u).type);
  return !c || !c.validEnd ? null : s;
}
function iRe(e, t, n) {
  let r = $e.empty;
  for (let s = n.length - 1; s >= 0; s--) {
    if (r.size) {
      let a = n[s].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = $e.from(n[s].type.create(n[s].attrs, r));
  }
  let i = t.start, o = t.end;
  e.step(new qr(i, o, i, o, new et(r, 0, 0), n.length, !0));
}
function oRe(e, t, n, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let o = e.steps.length;
  e.doc.nodesBetween(t, n, (s, a) => {
    let c = typeof i == "function" ? i(s) : i;
    if (s.isTextblock && !s.hasMarkup(r, c) && sRe(e.doc, e.mapping.slice(o).map(a), r)) {
      let u = null;
      if (r.schema.linebreakReplacement) {
        let g = r.whitespace == "pre", b = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        g && !b ? u = !1 : !g && b && (u = !0);
      }
      u === !1 && lW(e, s, a, o), IN(e, e.mapping.slice(o).map(a, 1), r, void 0, u === null);
      let f = e.mapping.slice(o), h = f.map(a, 1), m = f.map(a + s.nodeSize, 1);
      return e.step(new qr(h, m, h + 1, m - 1, new et($e.from(r.create(c, null, s.marks)), 0, 0), 1, !0)), u === !0 && aW(e, s, a, o), !1;
    }
  });
}
function aW(e, t, n, r) {
  t.forEach((i, o) => {
    if (i.isText) {
      let s, a = /\r?\n|\r/g;
      for (; s = a.exec(i.text); ) {
        let c = e.mapping.slice(r).map(n + 1 + o + s.index);
        e.replaceWith(c, c + 1, t.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function lW(e, t, n, r) {
  t.forEach((i, o) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let s = e.mapping.slice(r).map(n + 1 + o);
      e.replaceWith(s, s + 1, t.type.schema.text(`
`));
    }
  });
}
function sRe(e, t, n) {
  let r = e.resolve(t), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, n);
}
function aRe(e, t, n, r, i) {
  let o = e.doc.nodeAt(t);
  if (!o)
    throw new RangeError("No node at given position");
  n || (n = o.type);
  let s = n.create(r, null, i || o.marks);
  if (o.isLeaf)
    return e.replaceWith(t, t + o.nodeSize, s);
  if (!n.validContent(o.content))
    throw new RangeError("Invalid content for node type " + n.name);
  e.step(new qr(t, t + o.nodeSize, t + 1, t + o.nodeSize - 1, new et($e.from(s), 0, 0), 1, !0));
}
function Ja(e, t, n = 1, r) {
  let i = e.resolve(t), o = i.depth - n, s = r && r[r.length - 1] || i.parent;
  if (o < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !s.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let u = i.depth - 1, f = n - 2; u > o; u--, f--) {
    let h = i.node(u), m = i.index(u);
    if (h.type.spec.isolating)
      return !1;
    let g = h.content.cutByIndex(m, h.childCount), b = r && r[f + 1];
    b && (g = g.replaceChild(0, b.type.create(b.attrs)));
    let x = r && r[f] || h;
    if (!h.canReplace(m + 1, h.childCount) || !x.type.validContent(g))
      return !1;
  }
  let a = i.indexAfter(o), c = r && r[0];
  return i.node(o).canReplaceWith(a, a, c ? c.type : i.node(o + 1).type);
}
function lRe(e, t, n = 1, r) {
  let i = e.doc.resolve(t), o = $e.empty, s = $e.empty;
  for (let a = i.depth, c = i.depth - n, u = n - 1; a > c; a--, u--) {
    o = $e.from(i.node(a).copy(o));
    let f = r && r[u];
    s = $e.from(f ? f.type.create(f.attrs, s) : i.node(a).copy(s));
  }
  e.step(new Vr(t, t, new et(o.append(s), n, n), !0));
}
function Kc(e, t) {
  let n = e.resolve(t), r = n.index();
  return cW(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function cRe(e, t) {
  t.content.size || e.type.compatibleContent(t.type);
  let n = e.contentMatchAt(e.childCount), { linebreakReplacement: r } = e.type.schema;
  for (let i = 0; i < t.childCount; i++) {
    let o = t.child(i), s = o.type == r ? e.type.schema.nodes.text : o.type;
    if (n = n.matchType(s), !n || !e.type.allowsMarks(o.marks))
      return !1;
  }
  return n.validEnd;
}
function cW(e, t) {
  return !!(e && t && !e.isLeaf && cRe(e, t));
}
function a1(e, t, n = -1) {
  let r = e.resolve(t);
  for (let i = r.depth; ; i--) {
    let o, s, a = r.index(i);
    if (i == r.depth ? (o = r.nodeBefore, s = r.nodeAfter) : n > 0 ? (o = r.node(i + 1), a++, s = r.node(i).maybeChild(a)) : (o = r.node(i).maybeChild(a - 1), s = r.node(i + 1)), o && !o.isTextblock && cW(o, s) && r.node(i).canReplace(a, a + 1))
      return t;
    if (i == 0)
      break;
    t = n < 0 ? r.before(i) : r.after(i);
  }
}
function uRe(e, t, n) {
  let r = null, { linebreakReplacement: i } = e.doc.type.schema, o = e.doc.resolve(t - n), s = o.node().type;
  if (i && s.inlineContent) {
    let f = s.whitespace == "pre", h = !!s.contentMatch.matchType(i);
    f && !h ? r = !1 : !f && h && (r = !0);
  }
  let a = e.steps.length;
  if (r === !1) {
    let f = e.doc.resolve(t + n);
    lW(e, f.node(), f.before(), a);
  }
  s.inlineContent && IN(e, t + n - 1, s, o.node().contentMatchAt(o.index()), r == null);
  let c = e.mapping.slice(a), u = c.map(t - n);
  if (e.step(new Vr(u, c.map(t + n, -1), et.empty, !0)), r === !0) {
    let f = e.doc.resolve(u);
    aW(e, f.node(), f.before(), e.steps.length);
  }
  return e;
}
function dRe(e, t, n) {
  let r = e.resolve(t);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return t;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.index(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.before(i + 1);
      if (o > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.indexAfter(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.after(i + 1);
      if (o < r.node(i).childCount)
        return null;
    }
  return null;
}
function uW(e, t, n) {
  let r = e.resolve(t);
  if (!n.content.size)
    return t;
  let i = n.content;
  for (let o = 0; o < n.openStart; o++)
    i = i.firstChild.content;
  for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++)
    for (let s = r.depth; s >= 0; s--) {
      let a = s == r.depth ? 0 : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2 ? -1 : 1, c = r.index(s) + (a > 0 ? 1 : 0), u = r.node(s), f = !1;
      if (o == 1)
        f = u.canReplace(c, c, i);
      else {
        let h = u.contentMatchAt(c).findWrapping(i.firstChild.type);
        f = h && u.canReplaceWith(c, c, h[0]);
      }
      if (f)
        return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1);
    }
  return null;
}
function l1(e, t, n = t, r = et.empty) {
  if (t == n && !r.size)
    return null;
  let i = e.resolve(t), o = e.resolve(n);
  return dW(i, o, r) ? new Vr(t, n, r) : new fRe(i, o, r).fit();
}
function dW(e, t, n) {
  return !n.openStart && !n.openEnd && e.start() == t.start() && e.parent.canReplace(e.index(), t.index(), n.content);
}
class fRe {
  constructor(t, n, r) {
    this.$from = t, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = $e.empty;
    for (let i = 0; i <= t.depth; i++) {
      let o = t.node(i);
      this.frontier.push({
        type: o.type,
        match: o.contentMatchAt(t.indexAfter(i))
      });
    }
    for (let i = t.depth; i > 0; i--)
      this.placed = $e.from(t.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let u = this.findFittable();
      u ? this.placeNodes(u) : this.openMore() || this.dropNode();
    }
    let t = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(t < 0 ? this.$to : r.doc.resolve(t));
    if (!i)
      return null;
    let o = this.placed, s = r.depth, a = i.depth;
    for (; s && a && o.childCount == 1; )
      o = o.firstChild.content, s--, a--;
    let c = new et(o, s, a);
    return t > -1 ? new qr(r.pos, t, this.$to.pos, this.$to.end(), c, n) : c.size || r.pos != this.$to.pos ? new Vr(r.pos, i.pos, c) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let t = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < t; r++) {
      let o = n.firstChild;
      if (n.childCount > 1 && (i = 0), o.type.spec.isolating && i <= r) {
        t = r;
        break;
      }
      n = o.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? t : this.unplaced.openStart; r >= 0; r--) {
        let i, o = null;
        r ? (o = oE(this.unplaced.content, r - 1).firstChild, i = o.content) : i = this.unplaced.content;
        let s = i.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: c, match: u } = this.frontier[a], f, h = null;
          if (n == 1 && (s ? u.matchType(s.type) || (h = u.fillBefore($e.from(s), !1)) : o && c.compatibleContent(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: o, inject: h };
          if (n == 2 && s && (f = u.findWrapping(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: o, wrap: f };
          if (o && u.matchType(o.type))
            break;
        }
      }
  }
  openMore() {
    let { content: t, openStart: n, openEnd: r } = this.unplaced, i = oE(t, n);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new et(t, n + 1, Math.max(r, i.size + n >= t.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: t, openStart: n, openEnd: r } = this.unplaced, i = oE(t, n);
    if (i.childCount <= 1 && n > 0) {
      let o = t.size - n <= n + i.size;
      this.unplaced = new et(Tm(t, n - 1, 1), n - 1, o ? n - 1 : r);
    } else
      this.unplaced = new et(Tm(t, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: t, frontierDepth: n, parent: r, inject: i, wrap: o }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (o)
      for (let x = 0; x < o.length; x++)
        this.openFrontierNode(o[x]);
    let s = this.unplaced, a = r ? r.content : s.content, c = s.openStart - t, u = 0, f = [], { match: h, type: m } = this.frontier[n];
    if (i) {
      for (let x = 0; x < i.childCount; x++)
        f.push(i.child(x));
      h = h.matchFragment(i);
    }
    let g = a.size + t - (s.content.size - s.openEnd);
    for (; u < a.childCount; ) {
      let x = a.child(u), w = h.matchType(x.type);
      if (!w)
        break;
      u++, (u > 1 || c == 0 || x.content.size) && (h = w, f.push(fW(x.mark(m.allowedMarks(x.marks)), u == 1 ? c : 0, u == a.childCount ? g : -1)));
    }
    let b = u == a.childCount;
    b || (g = -1), this.placed = Am(this.placed, n, $e.from(f)), this.frontier[n].match = h, b && g < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let x = 0, w = a; x < g; x++) {
      let S = w.lastChild;
      this.frontier.push({ type: S.type, match: S.contentMatchAt(S.childCount) }), w = S.content;
    }
    this.unplaced = b ? t == 0 ? et.empty : new et(Tm(s.content, t - 1, 1), t - 1, g < 0 ? s.openEnd : t - 1) : new et(Tm(s.content, t, u), s.openStart, s.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let t = this.frontier[this.depth], n;
    if (!t.type.isTextblock || !sE(this.$to, this.$to.depth, t.type, t.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(t) {
    e: for (let n = Math.min(this.depth, t.depth); n >= 0; n--) {
      let { match: r, type: i } = this.frontier[n], o = n < t.depth && t.end(n + 1) == t.pos + (t.depth - (n + 1)), s = sE(t, n, i, r, o);
      if (s) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: c, type: u } = this.frontier[a], f = sE(t, a, u, c, !0);
          if (!f || f.childCount)
            continue e;
        }
        return { depth: n, fit: s, move: o ? t.doc.resolve(t.after(n + 1)) : t };
      }
    }
  }
  close(t) {
    let n = this.findCloseLevel(t);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = Am(this.placed, n.depth, n.fit)), t = n.move;
    for (let r = n.depth + 1; r <= t.depth; r++) {
      let i = t.node(r), o = i.type.contentMatch.fillBefore(i.content, !0, t.index(r));
      this.openFrontierNode(i.type, i.attrs, o);
    }
    return t;
  }
  openFrontierNode(t, n = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(t), this.placed = Am(this.placed, this.depth, $e.from(t.create(n, r))), this.frontier.push({ type: t, match: t.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore($e.empty, !0);
    n.childCount && (this.placed = Am(this.placed, this.frontier.length, n));
  }
}
function Tm(e, t, n) {
  return t == 0 ? e.cutByIndex(n, e.childCount) : e.replaceChild(0, e.firstChild.copy(Tm(e.firstChild.content, t - 1, n)));
}
function Am(e, t, n) {
  return t == 0 ? e.append(n) : e.replaceChild(e.childCount - 1, e.lastChild.copy(Am(e.lastChild.content, t - 1, n)));
}
function oE(e, t) {
  for (let n = 0; n < t; n++)
    e = e.firstChild.content;
  return e;
}
function fW(e, t, n) {
  if (t <= 0)
    return e;
  let r = e.content;
  return t > 1 && (r = r.replaceChild(0, fW(r.firstChild, t - 1, r.childCount == 1 ? n - 1 : 0))), t > 0 && (r = e.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(e.type.contentMatch.matchFragment(r).fillBefore($e.empty, !0)))), e.copy(r);
}
function sE(e, t, n, r, i) {
  let o = e.node(t), s = i ? e.indexAfter(t) : e.index(t);
  if (s == o.childCount && !n.compatibleContent(o.type))
    return null;
  let a = r.fillBefore(o.content, !0, s);
  return a && !hRe(n, o.content, s) ? a : null;
}
function hRe(e, t, n) {
  for (let r = n; r < t.childCount; r++)
    if (!e.allowsMarks(t.child(r).marks))
      return !0;
  return !1;
}
function pRe(e) {
  return e.spec.defining || e.spec.definingForContent;
}
function mRe(e, t, n, r) {
  if (!r.size)
    return e.deleteRange(t, n);
  let i = e.doc.resolve(t), o = e.doc.resolve(n);
  if (dW(i, o, r))
    return e.step(new Vr(t, n, r));
  let s = pW(i, o);
  s[s.length - 1] == 0 && s.pop();
  let a = -(i.depth + 1);
  s.unshift(a);
  for (let m = i.depth, g = i.pos - 1; m > 0; m--, g--) {
    let b = i.node(m).type.spec;
    if (b.defining || b.definingAsContext || b.isolating)
      break;
    s.indexOf(m) > -1 ? a = m : i.before(m) == g && s.splice(1, 0, -m);
  }
  let c = s.indexOf(a), u = [], f = r.openStart;
  for (let m = r.content, g = 0; ; g++) {
    let b = m.firstChild;
    if (u.push(b), g == r.openStart)
      break;
    m = b.content;
  }
  for (let m = f - 1; m >= 0; m--) {
    let g = u[m], b = pRe(g.type);
    if (b && !g.sameMarkup(i.node(Math.abs(a) - 1)))
      f = m;
    else if (b || !g.type.isTextblock)
      break;
  }
  for (let m = r.openStart; m >= 0; m--) {
    let g = (m + f + 1) % (r.openStart + 1), b = u[g];
    if (b)
      for (let x = 0; x < s.length; x++) {
        let w = s[(x + c) % s.length], S = !0;
        w < 0 && (S = !1, w = -w);
        let _ = i.node(w - 1), M = i.index(w - 1);
        if (_.canReplaceWith(M, M, b.type, b.marks))
          return e.replace(i.before(w), S ? o.after(w) : n, new et(hW(r.content, 0, r.openStart, g), g, r.openEnd));
      }
  }
  let h = e.steps.length;
  for (let m = s.length - 1; m >= 0 && (e.replace(t, n, r), !(e.steps.length > h)); m--) {
    let g = s[m];
    g < 0 || (t = i.before(g), n = o.after(g));
  }
}
function hW(e, t, n, r, i) {
  if (t < n) {
    let o = e.firstChild;
    e = e.replaceChild(0, o.copy(hW(o.content, t + 1, n, r, o)));
  }
  if (t > r) {
    let o = i.contentMatchAt(0), s = o.fillBefore(e).append(e);
    e = s.append(o.matchFragment(s).fillBefore($e.empty, !0));
  }
  return e;
}
function gRe(e, t, n, r) {
  if (!r.isInline && t == n && e.doc.resolve(t).parent.content.size) {
    let i = dRe(e.doc, t, r.type);
    i != null && (t = n = i);
  }
  e.replaceRange(t, n, new et($e.from(r), 0, 0));
}
function yRe(e, t, n) {
  let r = e.doc.resolve(t), i = e.doc.resolve(n), o = pW(r, i);
  for (let s = 0; s < o.length; s++) {
    let a = o[s], c = s == o.length - 1;
    if (c && a == 0 || r.node(a).type.contentMatch.validEnd)
      return e.delete(r.start(a), i.end(a));
    if (a > 0 && (c || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
      return e.delete(r.before(a), i.after(a));
  }
  for (let s = 1; s <= r.depth && s <= i.depth; s++)
    if (t - r.start(s) == r.depth - s && n > r.end(s) && i.end(s) - n != i.depth - s && r.start(s - 1) == i.start(s - 1) && r.node(s - 1).canReplace(r.index(s - 1), i.index(s - 1)))
      return e.delete(r.before(s), n);
  e.delete(t, n);
}
function pW(e, t) {
  let n = [], r = Math.min(e.depth, t.depth);
  for (let i = r; i >= 0; i--) {
    let o = e.start(i);
    if (o < e.pos - (e.depth - i) || t.end(i) > t.pos + (t.depth - i) || e.node(i).type.spec.isolating || t.node(i).type.spec.isolating)
      break;
    (o == t.start(i) || i == e.depth && i == t.depth && e.parent.inlineContent && t.parent.inlineContent && i && t.start(i - 1) == o - 1) && n.push(i);
  }
  return n;
}
class ch extends ki {
  /**
  Construct an attribute step.
  */
  constructor(t, n, r) {
    super(), this.pos = t, this.attr = n, this.value = r;
  }
  apply(t) {
    let n = t.nodeAt(this.pos);
    if (!n)
      return Er.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in n.attrs)
      r[o] = n.attrs[o];
    r[this.attr] = this.value;
    let i = n.type.create(r, null, n.marks);
    return Er.fromReplace(t, this.pos, this.pos + 1, new et($e.from(i), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return mo.empty;
  }
  invert(t) {
    return new ch(this.pos, this.attr, t.nodeAt(this.pos).attrs[this.attr]);
  }
  map(t) {
    let n = t.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new ch(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(t, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new ch(n.pos, n.attr, n.value);
  }
}
ki.jsonID("attr", ch);
class Rg extends ki {
  /**
  Construct an attribute step.
  */
  constructor(t, n) {
    super(), this.attr = t, this.value = n;
  }
  apply(t) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in t.attrs)
      n[i] = t.attrs[i];
    n[this.attr] = this.value;
    let r = t.type.create(n, t.content, t.marks);
    return Er.ok(r);
  }
  getMap() {
    return mo.empty;
  }
  invert(t) {
    return new Rg(this.attr, t.attrs[this.attr]);
  }
  map(t) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(t, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new Rg(n.attr, n.value);
  }
}
ki.jsonID("docAttr", Rg);
let Eh = class extends Error {
};
Eh = function e(t) {
  let n = Error.call(this, t);
  return n.__proto__ = e.prototype, n;
};
Eh.prototype = Object.create(Error.prototype);
Eh.prototype.constructor = Eh;
Eh.prototype.name = "TransformError";
class mW {
  /**
  Create a transform that starts with the given document.
  */
  constructor(t) {
    this.doc = t, this.steps = [], this.docs = [], this.mapping = new Ng();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(t) {
    let n = this.maybeStep(t);
    if (n.failed)
      throw new Eh(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(t) {
    let n = t.apply(this.doc);
    return n.failed || this.addStep(t, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  Return a single range, in post-transform document positions,
  that covers all content changed by this transform. Returns null
  if no replacements are made. Note that this will ignore changes
  that add/remove marks without replacing the underlying content.
  */
  changedRange() {
    let t = 1e9, n = -1e9;
    for (let r = 0; r < this.mapping.maps.length; r++) {
      let i = this.mapping.maps[r];
      r && (t = i.map(t, 1), n = i.map(n, -1)), i.forEach((o, s, a, c) => {
        t = Math.min(t, a), n = Math.max(n, c);
      });
    }
    return t == 1e9 ? null : { from: t, to: n };
  }
  /**
  @internal
  */
  addStep(t, n) {
    this.docs.push(this.doc), this.steps.push(t), this.mapping.appendMap(t.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(t, n = t, r = et.empty) {
    let i = l1(this.doc, t, n, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(t, n, r) {
    return this.replace(t, n, new et($e.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(t, n) {
    return this.replace(t, n, et.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(t, n) {
    return this.replaceWith(t, t, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(t, n, r) {
    return mRe(this, t, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(t, n, r) {
    return gRe(this, t, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(t, n) {
    return yRe(this, t, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(t, n) {
    return tRe(this, t, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(t, n = 1) {
    return uRe(this, t, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(t, n) {
    return iRe(this, t, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(t, n = t, r, i = null) {
    return oRe(this, t, n, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(t, n, r = null, i) {
    return aRe(this, t, n, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(t, n, r) {
    return this.step(new ch(t, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(t, n) {
    return this.step(new Rg(t, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(t, n) {
    return this.step(new gc(t, n)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(t, n) {
    let r = this.doc.nodeAt(t);
    if (!r)
      throw new RangeError("No node at position " + t);
    if (n instanceof _n)
      n.isInSet(r.marks) && this.step(new dd(t, n));
    else {
      let i = r.marks, o, s = [];
      for (; o = n.isInSet(i); )
        s.push(new dd(t, o)), i = o.removeFromSet(i);
      for (let a = s.length - 1; a >= 0; a--)
        this.step(s[a]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(t, n = 1, r) {
    return lRe(this, t, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(t, n, r) {
    return JNe(this, t, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(t, n, r) {
    return QNe(this, t, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(t, n, r) {
    return IN(this, t, n, r), this;
  }
}
const aE = /* @__PURE__ */ Object.create(null);
class Lt {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(t, n, r) {
    this.$anchor = t, this.$head = n, this.ranges = r || [new vRe(t.min(n), t.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let t = this.ranges;
    for (let n = 0; n < t.length; n++)
      if (t[n].$from.pos != t[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(t, n = et.empty) {
    let r = n.content.lastChild, i = null;
    for (let a = 0; a < n.openEnd; a++)
      i = r, r = r.lastChild;
    let o = t.steps.length, s = this.ranges;
    for (let a = 0; a < s.length; a++) {
      let { $from: c, $to: u } = s[a], f = t.mapping.slice(o);
      t.replaceRange(f.map(c.pos), f.map(u.pos), a ? et.empty : n), a == 0 && r5(t, o, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(t, n) {
    let r = t.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      let { $from: s, $to: a } = i[o], c = t.mapping.slice(r), u = c.map(s.pos), f = c.map(a.pos);
      o ? t.deleteRange(u, f) : (t.replaceRangeWith(u, f, n), r5(t, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(t, n, r = !1) {
    let i = t.parent.inlineContent ? new Ct(t) : Lf(t.node(0), t.parent, t.pos, t.index(), n, r);
    if (i)
      return i;
    for (let o = t.depth - 1; o >= 0; o--) {
      let s = n < 0 ? Lf(t.node(0), t.node(o), t.before(o + 1), t.index(o), n, r) : Lf(t.node(0), t.node(o), t.after(o + 1), t.index(o) + 1, n, r);
      if (s)
        return s;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(t, n = 1) {
    return this.findFrom(t, n) || this.findFrom(t, -n) || new bo(t.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(t) {
    return Lf(t, t, 0, 0, 1) || new bo(t);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(t) {
    return Lf(t, t, t.content.size, t.childCount, -1) || new bo(t);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(t, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = aE[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(t, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(t, n) {
    if (t in aE)
      throw new RangeError("Duplicate use of selection JSON ID " + t);
    return aE[t] = n, n.prototype.jsonID = t, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Ct.between(this.$anchor, this.$head).getBookmark();
  }
}
Lt.prototype.visible = !0;
class vRe {
  /**
  Create a range.
  */
  constructor(t, n) {
    this.$from = t, this.$to = n;
  }
}
let t5 = !1;
function n5(e) {
  !t5 && !e.parent.inlineContent && (t5 = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + e.parent.type.name + ")"));
}
class Ct extends Lt {
  /**
  Construct a text selection between the given points.
  */
  constructor(t, n = t) {
    n5(t), n5(n), super(t, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(t, n) {
    let r = t.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return Lt.near(r);
    let i = t.resolve(n.map(this.anchor));
    return new Ct(i.parent.inlineContent ? i : r, r);
  }
  replace(t, n = et.empty) {
    if (super.replace(t, n), n == et.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && t.ensureMarks(r);
    }
  }
  eq(t) {
    return t instanceof Ct && t.anchor == this.anchor && t.head == this.head;
  }
  getBookmark() {
    return new c1(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Ct(t.resolve(n.anchor), t.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(t, n, r = n) {
    let i = t.resolve(n);
    return new this(i, r == n ? i : t.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(t, n, r) {
    let i = t.pos - n.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let o = Lt.findFrom(n, r, !0) || Lt.findFrom(n, -r, !0);
      if (o)
        n = o.$head;
      else
        return Lt.near(n, r);
    }
    return t.parent.inlineContent || (i == 0 ? t = n : (t = (Lt.findFrom(t, -r, !0) || Lt.findFrom(t, r, !0)).$anchor, t.pos < n.pos != i < 0 && (t = n))), new Ct(t, n);
  }
}
Lt.jsonID("text", Ct);
class c1 {
  constructor(t, n) {
    this.anchor = t, this.head = n;
  }
  map(t) {
    return new c1(t.map(this.anchor), t.map(this.head));
  }
  resolve(t) {
    return Ct.between(t.resolve(this.anchor), t.resolve(this.head));
  }
}
class pt extends Lt {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(t) {
    let n = t.nodeAfter, r = t.node(0).resolve(t.pos + n.nodeSize);
    super(t, r), this.node = n;
  }
  map(t, n) {
    let { deleted: r, pos: i } = n.mapResult(this.anchor), o = t.resolve(i);
    return r ? Lt.near(o) : new pt(o);
  }
  content() {
    return new et($e.from(this.node), 0, 0);
  }
  eq(t) {
    return t instanceof pt && t.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new zN(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new pt(t.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(t, n) {
    return new pt(t.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(t) {
    return !t.isText && t.type.spec.selectable !== !1;
  }
}
pt.prototype.visible = !1;
Lt.jsonID("node", pt);
class zN {
  constructor(t) {
    this.anchor = t;
  }
  map(t) {
    let { deleted: n, pos: r } = t.mapResult(this.anchor);
    return n ? new c1(r, r) : new zN(r);
  }
  resolve(t) {
    let n = t.resolve(this.anchor), r = n.nodeAfter;
    return r && pt.isSelectable(r) ? new pt(n) : Lt.near(n);
  }
}
class bo extends Lt {
  /**
  Create an all-selection over the given document.
  */
  constructor(t) {
    super(t.resolve(0), t.resolve(t.content.size));
  }
  replace(t, n = et.empty) {
    if (n == et.empty) {
      t.delete(0, t.doc.content.size);
      let r = Lt.atStart(t.doc);
      r.eq(t.selection) || t.setSelection(r);
    } else
      super.replace(t, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(t) {
    return new bo(t);
  }
  map(t) {
    return new bo(t);
  }
  eq(t) {
    return t instanceof bo;
  }
  getBookmark() {
    return bRe;
  }
}
Lt.jsonID("all", bo);
const bRe = {
  map() {
    return this;
  },
  resolve(e) {
    return new bo(e);
  }
};
function Lf(e, t, n, r, i, o = !1) {
  if (t.inlineContent)
    return Ct.create(e, n);
  for (let s = r - (i > 0 ? 0 : 1); i > 0 ? s < t.childCount : s >= 0; s += i) {
    let a = t.child(s);
    if (a.isAtom) {
      if (!o && pt.isSelectable(a))
        return pt.create(e, n - (i < 0 ? a.nodeSize : 0));
    } else {
      let c = Lf(e, a, n + i, i < 0 ? a.childCount : 0, i, o);
      if (c)
        return c;
    }
    n += a.nodeSize * i;
  }
  return null;
}
function r5(e, t, n) {
  let r = e.steps.length - 1;
  if (r < t)
    return;
  let i = e.steps[r];
  if (!(i instanceof Vr || i instanceof qr))
    return;
  let o = e.mapping.maps[r], s;
  o.forEach((a, c, u, f) => {
    s == null && (s = f);
  }), e.setSelection(Lt.near(e.doc.resolve(s), n));
}
const i5 = 1, d0 = 2, o5 = 4;
class xRe extends mW {
  /**
  @internal
  */
  constructor(t) {
    super(t.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = t.selection, this.storedMarks = t.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(t) {
    if (t.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = t, this.curSelectionFor = this.steps.length, this.updated = (this.updated | i5) & ~d0, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & i5) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(t) {
    return this.storedMarks = t, this.updated |= d0, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(t) {
    return _n.sameSet(this.storedMarks || this.selection.$from.marks(), t) || this.setStoredMarks(t), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(t) {
    return this.ensureMarks(t.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(t) {
    return this.ensureMarks(t.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & d0) > 0;
  }
  /**
  @internal
  */
  addStep(t, n) {
    super.addStep(t, n), this.updated = this.updated & ~d0, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(t) {
    return this.time = t, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(t) {
    return this.selection.replace(this, t), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(t, n = !0) {
    let r = this.selection;
    return n && (t = t.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || _n.none))), r.replaceWith(this, t), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(t, n, r) {
    let i = this.doc.type.schema;
    if (n == null)
      return t ? this.replaceSelectionWith(i.text(t), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), !t)
        return this.deleteRange(n, r);
      let o = this.storedMarks;
      if (!o) {
        let s = this.doc.resolve(n);
        o = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, i.text(t, o)), !this.selection.empty && this.selection.to == n + t.length && this.setSelection(Lt.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(t, n) {
    return this.meta[typeof t == "string" ? t : t.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(t) {
    return this.meta[typeof t == "string" ? t : t.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let t in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= o5, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & o5) > 0;
  }
}
function s5(e, t) {
  return !t || !e ? e : e.bind(t);
}
class Mm {
  constructor(t, n, r) {
    this.name = t, this.init = s5(n.init, r), this.apply = s5(n.apply, r);
  }
}
const wRe = [
  new Mm("doc", {
    init(e) {
      return e.doc || e.schema.topNodeType.createAndFill();
    },
    apply(e) {
      return e.doc;
    }
  }),
  new Mm("selection", {
    init(e, t) {
      return e.selection || Lt.atStart(t.doc);
    },
    apply(e) {
      return e.selection;
    }
  }),
  new Mm("storedMarks", {
    init(e) {
      return e.storedMarks || null;
    },
    apply(e, t, n, r) {
      return r.selection.$cursor ? e.storedMarks : null;
    }
  }),
  new Mm("scrollToSelection", {
    init() {
      return 0;
    },
    apply(e, t) {
      return e.scrolledIntoView ? t + 1 : t;
    }
  })
];
class lE {
  constructor(t, n) {
    this.schema = t, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = wRe.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new Mm(r.key, r.spec.state, r));
    });
  }
}
class Qf {
  /**
  @internal
  */
  constructor(t) {
    this.config = t;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(t) {
    return this.applyTransaction(t).state;
  }
  /**
  @internal
  */
  filterTransaction(t, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, t, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(t) {
    if (!this.filterTransaction(t))
      return { state: this, transactions: [] };
    let n = [t], r = this.applyInner(t), i = null;
    for (; ; ) {
      let o = !1;
      for (let s = 0; s < this.config.plugins.length; s++) {
        let a = this.config.plugins[s];
        if (a.spec.appendTransaction) {
          let c = i ? i[s].n : 0, u = i ? i[s].state : this, f = c < n.length && a.spec.appendTransaction.call(a, c ? n.slice(c) : n, u, r);
          if (f && r.filterTransaction(f, s)) {
            if (f.setMeta("appendedTransaction", t), !i) {
              i = [];
              for (let h = 0; h < this.config.plugins.length; h++)
                i.push(h < s ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(f), r = r.applyInner(f), o = !0;
          }
          i && (i[s] = { state: r, n: n.length });
        }
      }
      if (!o)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(t) {
    if (!t.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Qf(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let o = r[i];
      n[o.name] = o.apply(t, this[o.name], this, n);
    }
    return n;
  }
  /**
  Accessor that constructs and returns a new [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new xRe(this);
  }
  /**
  Create a new state.
  */
  static create(t) {
    let n = new lE(t.doc ? t.doc.type.schema : t.schema, t.plugins), r = new Qf(n);
    for (let i = 0; i < n.fields.length; i++)
      r[n.fields[i].name] = n.fields[i].init(t, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(t) {
    let n = new lE(this.schema, t.plugins), r = n.fields, i = new Qf(n);
    for (let o = 0; o < r.length; o++) {
      let s = r[o].name;
      i[s] = this.hasOwnProperty(s) ? this[s] : r[o].init(t, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(t) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), t && typeof t == "object")
      for (let r in t) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = t[r], o = i.spec.state;
        o && o.toJSON && (n[r] = o.toJSON.call(i, this[i.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(t, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!t.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new lE(t.schema, t.plugins), o = new Qf(i);
    return i.fields.forEach((s) => {
      if (s.name == "doc")
        o.doc = Sc.fromJSON(t.schema, n.doc);
      else if (s.name == "selection")
        o.selection = Lt.fromJSON(o.doc, n.selection);
      else if (s.name == "storedMarks")
        n.storedMarks && (o.storedMarks = n.storedMarks.map(t.schema.markFromJSON));
      else {
        if (r)
          for (let a in r) {
            let c = r[a], u = c.spec.state;
            if (c.key == s.name && u && u.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              o[s.name] = u.fromJSON.call(c, t, n[a], o);
              return;
            }
          }
        o[s.name] = s.init(t, o);
      }
    }), o;
  }
}
function gW(e, t, n) {
  for (let r in e) {
    let i = e[r];
    i instanceof Function ? i = i.bind(t) : r == "handleDOMEvents" && (i = gW(i, t, {})), n[r] = i;
  }
  return n;
}
class Yn {
  /**
  Create a plugin.
  */
  constructor(t) {
    this.spec = t, this.props = {}, t.props && gW(t.props, this, this.props), this.key = t.key ? t.key.key : yW("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(t) {
    return t[this.key];
  }
}
const cE = /* @__PURE__ */ Object.create(null);
function yW(e) {
  return e in cE ? e + "$" + ++cE[e] : (cE[e] = 0, e + "$");
}
class Ar {
  /**
  Create a plugin key.
  */
  constructor(t = "key") {
    this.key = yW(t);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(t) {
    return t.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(t) {
    return t[this.key];
  }
}
const LN = (e, t) => e.selection.empty ? !1 : (t && t(e.tr.deleteSelection().scrollIntoView()), !0);
function vW(e, t) {
  let { $cursor: n } = e.selection;
  return !n || (t ? !t.endOfTextblock("backward", e) : n.parentOffset > 0) ? null : n;
}
const bW = (e, t, n) => {
  let r = vW(e, n);
  if (!r)
    return !1;
  let i = BN(r);
  if (!i) {
    let s = r.blockRange(), a = s && tp(s);
    return a == null ? !1 : (t && t(e.tr.lift(s, a).scrollIntoView()), !0);
  }
  let o = i.nodeBefore;
  if (AW(e, i, t, -1))
    return !0;
  if (r.parent.content.size == 0 && (_h(o, "end") || pt.isSelectable(o)))
    for (let s = r.depth; ; s--) {
      let a = l1(e.doc, r.before(s), r.after(s), et.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (t) {
          let c = e.tr.step(a);
          c.setSelection(_h(o, "end") ? Lt.findFrom(c.doc.resolve(c.mapping.map(i.pos, -1)), -1) : pt.create(c.doc, i.pos - o.nodeSize)), t(c.scrollIntoView());
        }
        return !0;
      }
      if (s == 1 || r.node(s - 1).childCount > 1)
        break;
    }
  return o.isAtom && i.depth == r.depth - 1 ? (t && t(e.tr.delete(i.pos - o.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, SRe = (e, t, n) => {
  let r = vW(e, n);
  if (!r)
    return !1;
  let i = BN(r);
  return i ? xW(e, i, t) : !1;
}, kRe = (e, t, n) => {
  let r = SW(e, n);
  if (!r)
    return !1;
  let i = $N(r);
  return i ? xW(e, i, t) : !1;
};
function xW(e, t, n) {
  let r = t.nodeBefore, i = r, o = t.pos - 1;
  for (; !i.isTextblock; o--) {
    if (i.type.spec.isolating)
      return !1;
    let f = i.lastChild;
    if (!f)
      return !1;
    i = f;
  }
  let s = t.nodeAfter, a = s, c = t.pos + 1;
  for (; !a.isTextblock; c++) {
    if (a.type.spec.isolating)
      return !1;
    let f = a.firstChild;
    if (!f)
      return !1;
    a = f;
  }
  let u = l1(e.doc, o, c, et.empty);
  if (!u || u.from != o || u instanceof Vr && u.slice.size >= c - o)
    return !1;
  if (n) {
    let f = e.tr.step(u);
    f.setSelection(Ct.create(f.doc, o)), n(f.scrollIntoView());
  }
  return !0;
}
function _h(e, t, n = !1) {
  for (let r = e; r; r = t == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const wW = (e, t, n) => {
  let { $head: r, empty: i } = e.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0)
      return !1;
    o = BN(r);
  }
  let s = o && o.nodeBefore;
  return !s || !pt.isSelectable(s) ? !1 : (t && t(e.tr.setSelection(pt.create(e.doc, o.pos - s.nodeSize)).scrollIntoView()), !0);
};
function BN(e) {
  if (!e.parent.type.spec.isolating)
    for (let t = e.depth - 1; t >= 0; t--) {
      if (e.index(t) > 0)
        return e.doc.resolve(e.before(t + 1));
      if (e.node(t).type.spec.isolating)
        break;
    }
  return null;
}
function SW(e, t) {
  let { $cursor: n } = e.selection;
  return !n || (t ? !t.endOfTextblock("forward", e) : n.parentOffset < n.parent.content.size) ? null : n;
}
const kW = (e, t, n) => {
  let r = SW(e, n);
  if (!r)
    return !1;
  let i = $N(r);
  if (!i)
    return !1;
  let o = i.nodeAfter;
  if (AW(e, i, t, 1))
    return !0;
  if (r.parent.content.size == 0 && (_h(o, "start") || pt.isSelectable(o))) {
    let s = l1(e.doc, r.before(), r.after(), et.empty);
    if (s && s.slice.size < s.to - s.from) {
      if (t) {
        let a = e.tr.step(s);
        a.setSelection(_h(o, "start") ? Lt.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1) : pt.create(a.doc, a.mapping.map(i.pos))), t(a.scrollIntoView());
      }
      return !0;
    }
  }
  return o.isAtom && i.depth == r.depth - 1 ? (t && t(e.tr.delete(i.pos, i.pos + o.nodeSize).scrollIntoView()), !0) : !1;
}, CW = (e, t, n) => {
  let { $head: r, empty: i } = e.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size)
      return !1;
    o = $N(r);
  }
  let s = o && o.nodeAfter;
  return !s || !pt.isSelectable(s) ? !1 : (t && t(e.tr.setSelection(pt.create(e.doc, o.pos)).scrollIntoView()), !0);
};
function $N(e) {
  if (!e.parent.type.spec.isolating)
    for (let t = e.depth - 1; t >= 0; t--) {
      let n = e.node(t);
      if (e.index(t) + 1 < n.childCount)
        return e.doc.resolve(e.after(t + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const CRe = (e, t) => {
  let n = e.selection, r = n instanceof pt, i;
  if (r) {
    if (n.node.isTextblock || !Kc(e.doc, n.from))
      return !1;
    i = n.from;
  } else if (i = a1(e.doc, n.from, -1), i == null)
    return !1;
  if (t) {
    let o = e.tr.join(i);
    r && o.setSelection(pt.create(o.doc, i - e.doc.resolve(i).nodeBefore.nodeSize)), t(o.scrollIntoView());
  }
  return !0;
}, ERe = (e, t) => {
  let n = e.selection, r;
  if (n instanceof pt) {
    if (n.node.isTextblock || !Kc(e.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = a1(e.doc, n.to, 1), r == null)
    return !1;
  return t && t(e.tr.join(r).scrollIntoView()), !0;
}, _Re = (e, t) => {
  let { $from: n, $to: r } = e.selection, i = n.blockRange(r), o = i && tp(i);
  return o == null ? !1 : (t && t(e.tr.lift(i, o).scrollIntoView()), !0);
}, EW = (e, t) => {
  let { $head: n, $anchor: r } = e.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (t && t(e.tr.insertText(`
`).scrollIntoView()), !0);
};
function UN(e) {
  for (let t = 0; t < e.edgeCount; t++) {
    let { type: n } = e.edge(t);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const TRe = (e, t) => {
  let { $head: n, $anchor: r } = e.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let i = n.node(-1), o = n.indexAfter(-1), s = UN(i.contentMatchAt(o));
  if (!s || !i.canReplaceWith(o, o, s))
    return !1;
  if (t) {
    let a = n.after(), c = e.tr.replaceWith(a, a, s.createAndFill());
    c.setSelection(Lt.near(c.doc.resolve(a), 1)), t(c.scrollIntoView());
  }
  return !0;
}, _W = (e, t) => {
  let n = e.selection, { $from: r, $to: i } = n;
  if (n instanceof bo || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let o = UN(i.parent.contentMatchAt(i.indexAfter()));
  if (!o || !o.isTextblock)
    return !1;
  if (t) {
    let s = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, a = e.tr.insert(s, o.createAndFill());
    a.setSelection(Ct.create(a.doc, s + 1)), t(a.scrollIntoView());
  }
  return !0;
}, TW = (e, t) => {
  let { $cursor: n } = e.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let o = n.before();
    if (Ja(e.doc, o))
      return t && t(e.tr.split(o).scrollIntoView()), !0;
  }
  let r = n.blockRange(), i = r && tp(r);
  return i == null ? !1 : (t && t(e.tr.lift(r, i).scrollIntoView()), !0);
};
function ARe(e) {
  return (t, n) => {
    let { $from: r, $to: i } = t.selection;
    if (t.selection instanceof pt && t.selection.node.isBlock)
      return !r.parentOffset || !Ja(t.doc, r.pos) ? !1 : (n && n(t.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let o = [], s, a, c = !1, u = !1;
    for (let g = r.depth; ; g--)
      if (r.node(g).isBlock) {
        c = r.end(g) == r.pos + (r.depth - g), u = r.start(g) == r.pos - (r.depth - g), a = UN(r.node(g - 1).contentMatchAt(r.indexAfter(g - 1))), o.unshift(c && a ? { type: a } : null), s = g;
        break;
      } else {
        if (g == 1)
          return !1;
        o.unshift(null);
      }
    let f = t.tr;
    (t.selection instanceof Ct || t.selection instanceof bo) && f.deleteSelection();
    let h = f.mapping.map(r.pos), m = Ja(f.doc, h, o.length, o);
    if (m || (o[0] = a ? { type: a } : null, m = Ja(f.doc, h, o.length, o)), !m)
      return !1;
    if (f.split(h, o.length, o), !c && u && r.node(s).type != a) {
      let g = f.mapping.map(r.before(s)), b = f.doc.resolve(g);
      a && r.node(s - 1).canReplaceWith(b.index(), b.index() + 1, a) && f.setNodeMarkup(f.mapping.map(r.before(s)), a);
    }
    return n && n(f.scrollIntoView()), !0;
  };
}
const MRe = ARe(), NRe = (e, t) => {
  let { $from: n, to: r } = e.selection, i, o = n.sharedDepth(r);
  return o == 0 ? !1 : (i = n.before(o), t && t(e.tr.setSelection(pt.create(e.doc, i))), !0);
};
function RRe(e, t, n) {
  let r = t.nodeBefore, i = t.nodeAfter, o = t.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && t.parent.canReplace(o - 1, o) ? (n && n(e.tr.delete(t.pos - r.nodeSize, t.pos).scrollIntoView()), !0) : !t.parent.canReplace(o, o + 1) || !(i.isTextblock || Kc(e.doc, t.pos)) ? !1 : (n && n(e.tr.join(t.pos).scrollIntoView()), !0);
}
function AW(e, t, n, r) {
  let i = t.nodeBefore, o = t.nodeAfter, s, a, c = i.type.spec.isolating || o.type.spec.isolating;
  if (!c && RRe(e, t, n))
    return !0;
  let u = !c && t.parent.canReplace(t.index(), t.index() + 1);
  if (u && (s = (a = i.contentMatchAt(i.childCount)).findWrapping(o.type)) && a.matchType(s[0] || o.type).validEnd) {
    if (n) {
      let g = t.pos + o.nodeSize, b = $e.empty;
      for (let S = s.length - 1; S >= 0; S--)
        b = $e.from(s[S].create(null, b));
      b = $e.from(i.copy(b));
      let x = e.tr.step(new qr(t.pos - 1, g, t.pos, g, new et(b, 1, 0), s.length, !0)), w = x.doc.resolve(g + 2 * s.length);
      w.nodeAfter && w.nodeAfter.type == i.type && Kc(x.doc, w.pos) && x.join(w.pos), n(x.scrollIntoView());
    }
    return !0;
  }
  let f = o.type.spec.isolating || r > 0 && c ? null : Lt.findFrom(t, 1), h = f && f.$from.blockRange(f.$to), m = h && tp(h);
  if (m != null && m >= t.depth)
    return n && n(e.tr.lift(h, m).scrollIntoView()), !0;
  if (u && _h(o, "start", !0) && _h(i, "end")) {
    let g = i, b = [];
    for (; b.push(g), !g.isTextblock; )
      g = g.lastChild;
    let x = o, w = 1;
    for (; !x.isTextblock; x = x.firstChild)
      w++;
    if (g.canReplace(g.childCount, g.childCount, x.content)) {
      if (n) {
        let S = $e.empty;
        for (let M = b.length - 1; M >= 0; M--)
          S = $e.from(b[M].copy(S));
        let _ = e.tr.step(new qr(t.pos - b.length, t.pos + o.nodeSize, t.pos + w, t.pos + o.nodeSize - w, new et(S, b.length, 0), 0, !0));
        n(_.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function MW(e) {
  return function(t, n) {
    let r = t.selection, i = e < 0 ? r.$from : r.$to, o = i.depth;
    for (; i.node(o).isInline; ) {
      if (!o)
        return !1;
      o--;
    }
    return i.node(o).isTextblock ? (n && n(t.tr.setSelection(Ct.create(t.doc, e < 0 ? i.start(o) : i.end(o)))), !0) : !1;
  };
}
const ORe = MW(-1), PRe = MW(1);
function DRe(e, t = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, s = i.blockRange(o), a = s && jN(s, e, t);
    return a ? (r && r(n.tr.wrap(s, a).scrollIntoView()), !0) : !1;
  };
}
function a5(e, t = null) {
  return function(n, r) {
    let i = !1;
    for (let o = 0; o < n.selection.ranges.length && !i; o++) {
      let { $from: { pos: s }, $to: { pos: a } } = n.selection.ranges[o];
      n.doc.nodesBetween(s, a, (c, u) => {
        if (i)
          return !1;
        if (!(!c.isTextblock || c.hasMarkup(e, t)))
          if (c.type == e)
            i = !0;
          else {
            let f = n.doc.resolve(u), h = f.index();
            i = f.parent.canReplaceWith(h, h + 1, e);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let o = n.tr;
      for (let s = 0; s < n.selection.ranges.length; s++) {
        let { $from: { pos: a }, $to: { pos: c } } = n.selection.ranges[s];
        o.setBlockType(a, c, e, t);
      }
      r(o.scrollIntoView());
    }
    return !0;
  };
}
function FN(...e) {
  return function(t, n, r) {
    for (let i = 0; i < e.length; i++)
      if (e[i](t, n, r))
        return !0;
    return !1;
  };
}
FN(LN, bW, wW);
FN(LN, kW, CW);
FN(EW, _W, TW, MRe);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function IRe(e, t = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, s = i.blockRange(o);
    if (!s)
      return !1;
    let a = r ? n.tr : null;
    return jRe(a, s, e, t) ? (r && r(a.scrollIntoView()), !0) : !1;
  };
}
function jRe(e, t, n, r = null) {
  let i = !1, o = t, s = t.$from.doc;
  if (t.depth >= 2 && t.$from.node(t.depth - 1).type.compatibleContent(n) && t.startIndex == 0) {
    if (t.$from.index(t.depth - 1) == 0)
      return !1;
    let c = s.resolve(t.start - 2);
    o = new fx(c, c, t.depth), t.endIndex < t.parent.childCount && (t = new fx(t.$from, s.resolve(t.$to.end(t.depth)), t.depth)), i = !0;
  }
  let a = jN(o, n, r, t);
  return a ? (e && zRe(e, t, a, i, n), !0) : !1;
}
function zRe(e, t, n, r, i) {
  let o = $e.empty;
  for (let f = n.length - 1; f >= 0; f--)
    o = $e.from(n[f].type.create(n[f].attrs, o));
  e.step(new qr(t.start - (r ? 2 : 0), t.end, t.start, t.end, new et(o, 0, 0), n.length, !0));
  let s = 0;
  for (let f = 0; f < n.length; f++)
    n[f].type == i && (s = f + 1);
  let a = n.length - s, c = t.start + n.length - (r ? 2 : 0), u = t.parent;
  for (let f = t.startIndex, h = t.endIndex, m = !0; f < h; f++, m = !1)
    !m && Ja(e.doc, c, a) && (e.split(c, a), c += 2 * a), c += u.child(f).nodeSize;
  return e;
}
function LRe(e) {
  return function(t, n) {
    let { $from: r, $to: i } = t.selection, o = r.blockRange(i, (s) => s.childCount > 0 && s.firstChild.type == e);
    return o ? n ? r.node(o.depth - 1).type == e ? BRe(t, n, e, o) : $Re(t, n, o) : !0 : !1;
  };
}
function BRe(e, t, n, r) {
  let i = e.tr, o = r.end, s = r.$to.end(r.depth);
  o < s && (i.step(new qr(o - 1, s, o, s, new et($e.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new fx(i.doc.resolve(r.$from.pos), i.doc.resolve(s), r.depth));
  const a = tp(r);
  if (a == null)
    return !1;
  i.lift(r, a);
  let c = i.doc.resolve(i.mapping.map(o, -1) - 1);
  return Kc(i.doc, c.pos) && c.nodeBefore.type == c.nodeAfter.type && i.join(c.pos), t(i.scrollIntoView()), !0;
}
function $Re(e, t, n) {
  let r = e.tr, i = n.parent;
  for (let g = n.end, b = n.endIndex - 1, x = n.startIndex; b > x; b--)
    g -= i.child(b).nodeSize, r.delete(g - 1, g + 1);
  let o = r.doc.resolve(n.start), s = o.nodeAfter;
  if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, c = n.endIndex == i.childCount, u = o.node(-1), f = o.index(-1);
  if (!u.canReplace(f + (a ? 0 : 1), f + 1, s.content.append(c ? $e.empty : $e.from(i))))
    return !1;
  let h = o.pos, m = h + s.nodeSize;
  return r.step(new qr(h - (a ? 1 : 0), m + (c ? 1 : 0), h + 1, m - 1, new et((a ? $e.empty : $e.from(i.copy($e.empty))).append(c ? $e.empty : $e.from(i.copy($e.empty))), a ? 0 : 1, c ? 0 : 1), a ? 0 : 1)), t(r.scrollIntoView()), !0;
}
function URe(e) {
  return function(t, n) {
    let { $from: r, $to: i } = t.selection, o = r.blockRange(i, (u) => u.childCount > 0 && u.firstChild.type == e);
    if (!o)
      return !1;
    let s = o.startIndex;
    if (s == 0)
      return !1;
    let a = o.parent, c = a.child(s - 1);
    if (c.type != e)
      return !1;
    if (n) {
      let u = c.lastChild && c.lastChild.type == a.type, f = $e.from(u ? e.create() : null), h = new et($e.from(e.create(null, $e.from(a.type.create(null, f)))), u ? 3 : 1, 0), m = o.start, g = o.end;
      n(t.tr.step(new qr(m - (u ? 3 : 1), g, m, g, h, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
const ii = function(e) {
  for (var t = 0; ; t++)
    if (e = e.previousSibling, !e)
      return t;
}, Th = function(e) {
  let t = e.assignedSlot || e.parentNode;
  return t && t.nodeType == 11 ? t.host : t;
};
let OT = null;
const qa = function(e, t, n) {
  let r = OT || (OT = document.createRange());
  return r.setEnd(e, n ?? e.nodeValue.length), r.setStart(e, t || 0), r;
}, FRe = function() {
  OT = null;
}, fd = function(e, t, n, r) {
  return n && (l5(e, t, n, r, -1) || l5(e, t, n, r, 1));
}, VRe = /^(img|br|input|textarea|hr)$/i;
function l5(e, t, n, r, i) {
  for (var o; ; ) {
    if (e == n && t == r)
      return !0;
    if (t == (i < 0 ? 0 : Uo(e))) {
      let s = e.parentNode;
      if (!s || s.nodeType != 1 || vy(e) || VRe.test(e.nodeName) || e.contentEditable == "false")
        return !1;
      t = ii(e) + (i < 0 ? 0 : 1), e = s;
    } else if (e.nodeType == 1) {
      let s = e.childNodes[t + (i < 0 ? -1 : 0)];
      if (s.nodeType == 1 && s.contentEditable == "false")
        if (!((o = s.pmViewDesc) === null || o === void 0) && o.ignoreForSelection)
          t += i;
        else
          return !1;
      else
        e = s, t = i < 0 ? Uo(e) : 0;
    } else
      return !1;
  }
}
function Uo(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length;
}
function HRe(e, t) {
  for (; ; ) {
    if (e.nodeType == 3 && t)
      return e;
    if (e.nodeType == 1 && t > 0) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[t - 1], t = Uo(e);
    } else if (e.parentNode && !vy(e))
      t = ii(e), e = e.parentNode;
    else
      return null;
  }
}
function WRe(e, t) {
  for (; ; ) {
    if (e.nodeType == 3 && t < e.nodeValue.length)
      return e;
    if (e.nodeType == 1 && t < e.childNodes.length) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[t], t = 0;
    } else if (e.parentNode && !vy(e))
      t = ii(e) + 1, e = e.parentNode;
    else
      return null;
  }
}
function qRe(e, t, n) {
  for (let r = t == 0, i = t == Uo(e); r || i; ) {
    if (e == n)
      return !0;
    let o = ii(e);
    if (e = e.parentNode, !e)
      return !1;
    r = r && o == 0, i = i && o == Uo(e);
  }
}
function vy(e) {
  let t;
  for (let n = e; n && !(t = n.pmViewDesc); n = n.parentNode)
    ;
  return t && t.node && t.node.isBlock && (t.dom == e || t.contentDOM == e);
}
const u1 = function(e) {
  return e.focusNode && fd(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset);
};
function ju(e, t) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = e, n.key = n.code = t, n;
}
function GRe(e) {
  let t = e.activeElement;
  for (; t && t.shadowRoot; )
    t = t.shadowRoot.activeElement;
  return t;
}
function KRe(e, t, n) {
  if (e.caretPositionFromPoint)
    try {
      let r = e.caretPositionFromPoint(t, n);
      if (r)
        return { node: r.offsetNode, offset: Math.min(Uo(r.offsetNode), r.offset) };
    } catch {
    }
  if (e.caretRangeFromPoint) {
    let r = e.caretRangeFromPoint(t, n);
    if (r)
      return { node: r.startContainer, offset: Math.min(Uo(r.startContainer), r.startOffset) };
  }
}
const ia = typeof navigator < "u" ? navigator : null, c5 = typeof document < "u" ? document : null, Zc = ia && ia.userAgent || "", PT = /Edge\/(\d+)/.exec(Zc), NW = /MSIE \d/.exec(Zc), DT = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Zc), Xi = !!(NW || DT || PT), Cc = NW ? document.documentMode : DT ? +DT[1] : PT ? +PT[1] : 0, Go = !Xi && /gecko\/(\d+)/i.test(Zc);
Go && +(/Firefox\/(\d+)/.exec(Zc) || [0, 0])[1];
const IT = !Xi && /Chrome\/(\d+)/.exec(Zc), Wr = !!IT, RW = IT ? +IT[1] : 0, li = !Xi && !!ia && /Apple Computer/.test(ia.vendor), Ah = li && (/Mobile\/\w+/.test(Zc) || !!ia && ia.maxTouchPoints > 2), Bo = Ah || (ia ? /Mac/.test(ia.platform) : !1), OW = ia ? /Win/.test(ia.platform) : !1, Ya = /Android \d/.test(Zc), by = !!c5 && "webkitFontSmoothing" in c5.documentElement.style, ZRe = by ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function YRe(e) {
  let t = e.defaultView && e.defaultView.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: e.documentElement.clientWidth,
    top: 0,
    bottom: e.documentElement.clientHeight
  };
}
function Ba(e, t) {
  return typeof e == "number" ? e : e[t];
}
function XRe(e) {
  let t = e.getBoundingClientRect(), n = t.width / e.offsetWidth || 1, r = t.height / e.offsetHeight || 1;
  return {
    left: t.left,
    right: t.left + e.clientWidth * n,
    top: t.top,
    bottom: t.top + e.clientHeight * r
  };
}
function u5(e, t, n) {
  let r = e.someProp("scrollThreshold") || 0, i = e.someProp("scrollMargin") || 5, o = e.dom.ownerDocument;
  for (let s = n || e.dom; s; ) {
    if (s.nodeType != 1) {
      s = Th(s);
      continue;
    }
    let a = s, c = a == o.body, u = c ? YRe(o) : XRe(a), f = 0, h = 0;
    if (t.top < u.top + Ba(r, "top") ? h = -(u.top - t.top + Ba(i, "top")) : t.bottom > u.bottom - Ba(r, "bottom") && (h = t.bottom - t.top > u.bottom - u.top ? t.top + Ba(i, "top") - u.top : t.bottom - u.bottom + Ba(i, "bottom")), t.left < u.left + Ba(r, "left") ? f = -(u.left - t.left + Ba(i, "left")) : t.right > u.right - Ba(r, "right") && (f = t.right - u.right + Ba(i, "right")), f || h)
      if (c)
        o.defaultView.scrollBy(f, h);
      else {
        let g = a.scrollLeft, b = a.scrollTop;
        h && (a.scrollTop += h), f && (a.scrollLeft += f);
        let x = a.scrollLeft - g, w = a.scrollTop - b;
        t = { left: t.left - x, top: t.top - w, right: t.right - x, bottom: t.bottom - w };
      }
    let m = c ? "fixed" : getComputedStyle(s).position;
    if (/^(fixed|sticky)$/.test(m))
      break;
    s = m == "absolute" ? s.offsetParent : Th(s);
  }
}
function JRe(e) {
  let t = e.dom.getBoundingClientRect(), n = Math.max(0, t.top), r, i;
  for (let o = (t.left + t.right) / 2, s = n + 1; s < Math.min(innerHeight, t.bottom); s += 5) {
    let a = e.root.elementFromPoint(o, s);
    if (!a || a == e.dom || !e.dom.contains(a))
      continue;
    let c = a.getBoundingClientRect();
    if (c.top >= n - 20) {
      r = a, i = c.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: PW(e.dom) };
}
function PW(e) {
  let t = [], n = e.ownerDocument;
  for (let r = e; r && (t.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), e != n); r = Th(r))
    ;
  return t;
}
function QRe({ refDOM: e, refTop: t, stack: n }) {
  let r = e ? e.getBoundingClientRect().top : 0;
  DW(n, r == 0 ? 0 : r - t);
}
function DW(e, t) {
  for (let n = 0; n < e.length; n++) {
    let { dom: r, top: i, left: o } = e[n];
    r.scrollTop != i + t && (r.scrollTop = i + t), r.scrollLeft != o && (r.scrollLeft = o);
  }
}
let Af = null;
function e2e(e) {
  if (e.setActive)
    return e.setActive();
  if (Af)
    return e.focus(Af);
  let t = PW(e);
  e.focus(Af == null ? {
    get preventScroll() {
      return Af = { preventScroll: !0 }, !0;
    }
  } : void 0), Af || (Af = !1, DW(t, 0));
}
function IW(e, t) {
  let n, r = 2e8, i, o = 0, s = t.top, a = t.top, c, u;
  for (let f = e.firstChild, h = 0; f; f = f.nextSibling, h++) {
    let m;
    if (f.nodeType == 1)
      m = f.getClientRects();
    else if (f.nodeType == 3)
      m = qa(f).getClientRects();
    else
      continue;
    for (let g = 0; g < m.length; g++) {
      let b = m[g];
      if (b.top <= s && b.bottom >= a) {
        s = Math.max(b.bottom, s), a = Math.min(b.top, a);
        let x = b.left > t.left ? b.left - t.left : b.right < t.left ? t.left - b.right : 0;
        if (x < r) {
          n = f, r = x, i = x && n.nodeType == 3 ? {
            left: b.right < t.left ? b.right : b.left,
            top: t.top
          } : t, f.nodeType == 1 && x && (o = h + (t.left >= (b.left + b.right) / 2 ? 1 : 0));
          continue;
        }
      } else b.top > t.top && !c && b.left <= t.left && b.right >= t.left && (c = f, u = { left: Math.max(b.left, Math.min(b.right, t.left)), top: b.top });
      !n && (t.left >= b.right && t.top >= b.top || t.left >= b.left && t.top >= b.bottom) && (o = h + 1);
    }
  }
  return !n && c && (n = c, i = u, r = 0), n && n.nodeType == 3 ? t2e(n, i) : !n || r && n.nodeType == 1 ? { node: e, offset: o } : IW(n, i);
}
function t2e(e, t) {
  let n = e.nodeValue.length, r = document.createRange(), i;
  for (let o = 0; o < n; o++) {
    r.setEnd(e, o + 1), r.setStart(e, o);
    let s = rc(r, 1);
    if (s.top != s.bottom && VN(t, s)) {
      i = { node: e, offset: o + (t.left >= (s.left + s.right) / 2 ? 1 : 0) };
      break;
    }
  }
  return r.detach(), i || { node: e, offset: 0 };
}
function VN(e, t) {
  return e.left >= t.left - 1 && e.left <= t.right + 1 && e.top >= t.top - 1 && e.top <= t.bottom + 1;
}
function n2e(e, t) {
  let n = e.parentNode;
  return n && /^li$/i.test(n.nodeName) && t.left < e.getBoundingClientRect().left ? n : e;
}
function r2e(e, t, n) {
  let { node: r, offset: i } = IW(t, n), o = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let s = r.getBoundingClientRect();
    o = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
  }
  return e.docView.posFromDOM(r, i, o);
}
function i2e(e, t, n, r) {
  let i = -1;
  for (let o = t, s = !1; o != e.dom; ) {
    let a = e.docView.nearestDesc(o, !0), c;
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((c = a.dom.getBoundingClientRect()).width || c.height) && (a.node.isBlock && a.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(a.dom.nodeName) && (!s && c.left > r.left || c.top > r.top ? i = a.posBefore : (!s && c.right < r.left || c.bottom < r.top) && (i = a.posAfter), s = !0), !a.contentDOM && i < 0 && !a.node.isText))
      return (a.node.isBlock ? r.top < (c.top + c.bottom) / 2 : r.left < (c.left + c.right) / 2) ? a.posBefore : a.posAfter;
    o = a.dom.parentNode;
  }
  return i > -1 ? i : e.docView.posFromDOM(t, n, -1);
}
function jW(e, t, n) {
  let r = e.childNodes.length;
  if (r && n.top < n.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (t.top - n.top) / (n.bottom - n.top)) - 2)), o = i; ; ) {
      let s = e.childNodes[o];
      if (s.nodeType == 1) {
        let a = s.getClientRects();
        for (let c = 0; c < a.length; c++) {
          let u = a[c];
          if (VN(t, u))
            return jW(s, t, u);
        }
      }
      if ((o = (o + 1) % r) == i)
        break;
    }
  return e;
}
function o2e(e, t) {
  let n = e.dom.ownerDocument, r, i = 0, o = KRe(n, t.left, t.top);
  o && ({ node: r, offset: i } = o);
  let s = (e.root.elementFromPoint ? e.root : n).elementFromPoint(t.left, t.top), a;
  if (!s || !e.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let u = e.dom.getBoundingClientRect();
    if (!VN(t, u) || (s = jW(e.dom, t, u), !s))
      return null;
  }
  if (li)
    for (let u = s; r && u; u = Th(u))
      u.draggable && (r = void 0);
  if (s = n2e(s, t), r) {
    if (Go && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let f = r.childNodes[i], h;
      f.nodeName == "IMG" && (h = f.getBoundingClientRect()).right <= t.left && h.bottom > t.top && i++;
    }
    let u;
    by && i && r.nodeType == 1 && (u = r.childNodes[i - 1]).nodeType == 1 && u.contentEditable == "false" && u.getBoundingClientRect().top >= t.top && i--, r == e.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && t.top > r.lastChild.getBoundingClientRect().bottom ? a = e.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (a = i2e(e, r, i, t));
  }
  a == null && (a = r2e(e, s, t));
  let c = e.docView.nearestDesc(s, !0);
  return { pos: a, inside: c ? c.posAtStart - c.border : -1 };
}
function d5(e) {
  return e.top < e.bottom || e.left < e.right;
}
function rc(e, t) {
  let n = e.getClientRects();
  if (n.length) {
    let r = n[t < 0 ? 0 : n.length - 1];
    if (d5(r))
      return r;
  }
  return Array.prototype.find.call(n, d5) || e.getBoundingClientRect();
}
const s2e = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function zW(e, t, n) {
  let { node: r, offset: i, atom: o } = e.docView.domFromPos(t, n < 0 ? -1 : 1), s = by || Go;
  if (r.nodeType == 3)
    if (s && (s2e.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
      let c = rc(qa(r, i, i), n);
      if (Go && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let u = rc(qa(r, i - 1, i - 1), -1);
        if (u.top == c.top) {
          let f = rc(qa(r, i, i + 1), -1);
          if (f.top != c.top)
            return hm(f, f.left < u.left);
        }
      }
      return c;
    } else {
      let c = i, u = i, f = n < 0 ? 1 : -1;
      return n < 0 && !i ? (u++, f = -1) : n >= 0 && i == r.nodeValue.length ? (c--, f = 1) : n < 0 ? c-- : u++, hm(rc(qa(r, c, u), f), f < 0);
    }
  if (!e.state.doc.resolve(t - (o || 0)).parent.inlineContent) {
    if (o == null && i && (n < 0 || i == Uo(r))) {
      let c = r.childNodes[i - 1];
      if (c.nodeType == 1)
        return uE(c.getBoundingClientRect(), !1);
    }
    if (o == null && i < Uo(r)) {
      let c = r.childNodes[i];
      if (c.nodeType == 1)
        return uE(c.getBoundingClientRect(), !0);
    }
    return uE(r.getBoundingClientRect(), n >= 0);
  }
  if (o == null && i && (n < 0 || i == Uo(r))) {
    let c = r.childNodes[i - 1], u = c.nodeType == 3 ? qa(c, Uo(c) - (s ? 0 : 1)) : c.nodeType == 1 && (c.nodeName != "BR" || !c.nextSibling) ? c : null;
    if (u)
      return hm(rc(u, 1), !1);
  }
  if (o == null && i < Uo(r)) {
    let c = r.childNodes[i];
    for (; c.pmViewDesc && c.pmViewDesc.ignoreForCoords; )
      c = c.nextSibling;
    let u = c ? c.nodeType == 3 ? qa(c, 0, s ? 0 : 1) : c.nodeType == 1 ? c : null : null;
    if (u)
      return hm(rc(u, -1), !0);
  }
  return hm(rc(r.nodeType == 3 ? qa(r) : r, -n), n >= 0);
}
function hm(e, t) {
  if (e.width == 0)
    return e;
  let n = t ? e.left : e.right;
  return { top: e.top, bottom: e.bottom, left: n, right: n };
}
function uE(e, t) {
  if (e.height == 0)
    return e;
  let n = t ? e.top : e.bottom;
  return { top: n, bottom: n, left: e.left, right: e.right };
}
function LW(e, t, n) {
  let r = e.state, i = e.root.activeElement;
  r != t && e.updateState(t), i != e.dom && e.focus();
  try {
    return n();
  } finally {
    r != t && e.updateState(r), i != e.dom && i && i.focus();
  }
}
function a2e(e, t, n) {
  let r = t.selection, i = n == "up" ? r.$from : r.$to;
  return LW(e, t, () => {
    let { node: o } = e.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = e.docView.nearestDesc(o, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        o = a.contentDOM || a.dom;
        break;
      }
      o = a.dom.parentNode;
    }
    let s = zW(e, i.pos, 1);
    for (let a = o.firstChild; a; a = a.nextSibling) {
      let c;
      if (a.nodeType == 1)
        c = a.getClientRects();
      else if (a.nodeType == 3)
        c = qa(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let u = 0; u < c.length; u++) {
        let f = c[u];
        if (f.bottom > f.top + 1 && (n == "up" ? s.top - f.top > (f.bottom - s.top) * 2 : f.bottom - s.bottom > (s.bottom - f.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const l2e = /[\u0590-\u08ac]/;
function c2e(e, t, n) {
  let { $head: r } = t.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, o = !i, s = i == r.parent.content.size, a = e.domSelection();
  return a ? !l2e.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? o : s : LW(e, t, () => {
    let { focusNode: c, focusOffset: u, anchorNode: f, anchorOffset: h } = e.domSelectionRange(), m = a.caretBidiLevel;
    a.modify("move", n, "character");
    let g = r.depth ? e.docView.domAfterPos(r.before()) : e.dom, { focusNode: b, focusOffset: x } = e.domSelectionRange(), w = b && !g.contains(b.nodeType == 1 ? b : b.parentNode) || c == b && u == x;
    try {
      a.collapse(f, h), c && (c != f || u != h) && a.extend && a.extend(c, u);
    } catch {
    }
    return m != null && (a.caretBidiLevel = m), w;
  }) : r.pos == r.start() || r.pos == r.end();
}
let f5 = null, h5 = null, p5 = !1;
function u2e(e, t, n) {
  return f5 == t && h5 == n ? p5 : (f5 = t, h5 = n, p5 = n == "up" || n == "down" ? a2e(e, t, n) : c2e(e, t, n));
}
const Ko = 0, m5 = 1, Uu = 2, oa = 3;
class xy {
  constructor(t, n, r, i) {
    this.parent = t, this.children = n, this.dom = r, this.contentDOM = i, this.dirty = Ko, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(t) {
    return !1;
  }
  matchesMark(t) {
    return !1;
  }
  matchesNode(t, n, r) {
    return !1;
  }
  matchesHack(t) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(t) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let t = 0;
    for (let n = 0; n < this.children.length; n++)
      t += this.children[n].size;
    return t;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let t = 0; t < this.children.length; t++)
      this.children[t].destroy();
  }
  posBeforeChild(t) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let i = this.children[n];
      if (i == t)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(t, n, r) {
    if (this.contentDOM && this.contentDOM.contains(t.nodeType == 1 ? t : t.parentNode))
      if (r < 0) {
        let o, s;
        if (t == this.contentDOM)
          o = t.childNodes[n - 1];
        else {
          for (; t.parentNode != this.contentDOM; )
            t = t.parentNode;
          o = t.previousSibling;
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this); )
          o = o.previousSibling;
        return o ? this.posBeforeChild(s) + s.size : this.posAtStart;
      } else {
        let o, s;
        if (t == this.contentDOM)
          o = t.childNodes[n];
        else {
          for (; t.parentNode != this.contentDOM; )
            t = t.parentNode;
          o = t.nextSibling;
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this); )
          o = o.nextSibling;
        return o ? this.posBeforeChild(s) : this.posAtEnd;
      }
    let i;
    if (t == this.dom && this.contentDOM)
      i = n > ii(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = t.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let o = t; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !1;
            break;
          }
          if (o.previousSibling)
            break;
        }
      if (i == null && n == t.childNodes.length)
        for (let o = t; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !0;
            break;
          }
          if (o.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(t, n = !1) {
    for (let r = !0, i = t; i; i = i.parentNode) {
      let o = this.getDesc(i), s;
      if (o && (!n || o.node))
        if (r && (s = o.nodeDOM) && !(s.nodeType == 1 ? s.contains(t.nodeType == 1 ? t : t.parentNode) : s == t))
          r = !1;
        else
          return o;
    }
  }
  getDesc(t) {
    let n = t.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(t, n, r) {
    for (let i = t; i; i = i.parentNode) {
      let o = this.getDesc(i);
      if (o)
        return o.localPosFromDOM(t, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(t) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let i = this.children[n], o = r + i.size;
      if (r == t && o != r) {
        for (; !i.border && i.children.length; )
          for (let s = 0; s < i.children.length; s++) {
            let a = i.children[s];
            if (a.size) {
              i = a;
              break;
            }
          }
        return i;
      }
      if (t < o)
        return i.descAt(t - r - i.border);
      r = o;
    }
  }
  domFromPos(t, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: t + 1 };
    let r = 0, i = 0;
    for (let o = 0; r < this.children.length; r++) {
      let s = this.children[r], a = o + s.size;
      if (a > t || s instanceof $W) {
        i = t - o;
        break;
      }
      o = a;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, n);
    for (let o; r && !(o = this.children[r - 1]).size && o instanceof BW && o.side >= 0; r--)
      ;
    if (n <= 0) {
      let o, s = !0;
      for (; o = r ? this.children[r - 1] : null, !(!o || o.dom.parentNode == this.contentDOM); r--, s = !1)
        ;
      return o && n && s && !o.border && !o.domAtom ? o.domFromPos(o.size, n) : { node: this.contentDOM, offset: o ? ii(o.dom) + 1 : 0 };
    } else {
      let o, s = !0;
      for (; o = r < this.children.length ? this.children[r] : null, !(!o || o.dom.parentNode == this.contentDOM); r++, s = !1)
        ;
      return o && s && !o.border && !o.domAtom ? o.domFromPos(0, n) : { node: this.contentDOM, offset: o ? ii(o.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(t, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: t, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, o = -1;
    for (let s = r, a = 0; ; a++) {
      let c = this.children[a], u = s + c.size;
      if (i == -1 && t <= u) {
        let f = s + c.border;
        if (t >= f && n <= u - c.border && c.node && c.contentDOM && this.contentDOM.contains(c.contentDOM))
          return c.parseRange(t, n, f);
        t = s;
        for (let h = a; h > 0; h--) {
          let m = this.children[h - 1];
          if (m.size && m.dom.parentNode == this.contentDOM && !m.emptyChildAt(1)) {
            i = ii(m.dom) + 1;
            break;
          }
          t -= m.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (u > n || a == this.children.length - 1)) {
        n = u;
        for (let f = a + 1; f < this.children.length; f++) {
          let h = this.children[f];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
            o = ii(h.dom);
            break;
          }
          n += h.size;
        }
        o == -1 && (o = this.contentDOM.childNodes.length);
        break;
      }
      s = u;
    }
    return { node: this.contentDOM, from: t, to: n, fromOffset: i, toOffset: o };
  }
  emptyChildAt(t) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[t < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(t);
  }
  domAfterPos(t) {
    let { node: n, offset: r } = this.domFromPos(t, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + t);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(t, n, r, i = !1) {
    let o = Math.min(t, n), s = Math.max(t, n);
    for (let g = 0, b = 0; g < this.children.length; g++) {
      let x = this.children[g], w = b + x.size;
      if (o > b && s < w)
        return x.setSelection(t - b - x.border, n - b - x.border, r, i);
      b = w;
    }
    let a = this.domFromPos(t, t ? -1 : 1), c = n == t ? a : this.domFromPos(n, n ? -1 : 1), u = r.root.getSelection(), f = r.domSelectionRange(), h = !1;
    if ((Go || li) && t == n) {
      let { node: g, offset: b } = a;
      if (g.nodeType == 3) {
        if (h = !!(b && g.nodeValue[b - 1] == `
`), h && b == g.nodeValue.length)
          for (let x = g, w; x; x = x.parentNode) {
            if (w = x.nextSibling) {
              w.nodeName == "BR" && (a = c = { node: w.parentNode, offset: ii(w) + 1 });
              break;
            }
            let S = x.pmViewDesc;
            if (S && S.node && S.node.isBlock)
              break;
          }
      } else {
        let x = g.childNodes[b - 1];
        h = x && (x.nodeName == "BR" || x.contentEditable == "false");
      }
    }
    if (Go && f.focusNode && f.focusNode != c.node && f.focusNode.nodeType == 1) {
      let g = f.focusNode.childNodes[f.focusOffset];
      g && g.contentEditable == "false" && (i = !0);
    }
    if (!(i || h && li) && fd(a.node, a.offset, f.anchorNode, f.anchorOffset) && fd(c.node, c.offset, f.focusNode, f.focusOffset))
      return;
    let m = !1;
    if ((u.extend || t == n) && !(h && Go)) {
      u.collapse(a.node, a.offset);
      try {
        t != n && u.extend(c.node, c.offset), m = !0;
      } catch {
      }
    }
    if (!m) {
      if (t > n) {
        let b = a;
        a = c, c = b;
      }
      let g = document.createRange();
      g.setEnd(c.node, c.offset), g.setStart(a.node, a.offset), u.removeAllRanges(), u.addRange(g);
    }
  }
  ignoreMutation(t) {
    return !this.contentDOM && t.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(t, n) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let o = this.children[i], s = r + o.size;
      if (r == s ? t <= s && n >= r : t < s && n > r) {
        let a = r + o.border, c = s - o.border;
        if (t >= a && n <= c) {
          this.dirty = t == r || n == s ? Uu : m5, t == a && n == c && (o.contentLost || o.dom.parentNode != this.contentDOM) ? o.dirty = oa : o.markDirty(t - a, n - a);
          return;
        } else
          o.dirty = o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length ? Uu : oa;
      }
      r = s;
    }
    this.dirty = Uu;
  }
  markParentsDirty() {
    let t = 1;
    for (let n = this.parent; n; n = n.parent, t++) {
      let r = t == 1 ? Uu : m5;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(t) {
    return !1;
  }
}
class BW extends xy {
  constructor(t, n, r, i) {
    let o, s = n.type.toDOM;
    if (typeof s == "function" && (s = s(r, () => {
      if (!o)
        return i;
      if (o.parent)
        return o.parent.posBeforeChild(o);
    })), !n.type.spec.raw) {
      if (s.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(s), s = a;
      }
      s.contentEditable = "false", s.classList.add("ProseMirror-widget");
    }
    super(t, [], s, null), this.widget = n, this.widget = n, o = this;
  }
  matchesWidget(t) {
    return this.dirty == Ko && t.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(t) {
    let n = this.widget.spec.stopEvent;
    return n ? n(t) : !1;
  }
  ignoreMutation(t) {
    return t.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class d2e extends xy {
  constructor(t, n, r, i) {
    super(t, [], n, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(t, n) {
    return t != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(t) {
    return { node: this.textDOM, offset: t };
  }
  ignoreMutation(t) {
    return t.type === "characterData" && t.target.nodeValue == t.oldValue;
  }
}
class hd extends xy {
  constructor(t, n, r, i, o) {
    super(t, [], r, i), this.mark = n, this.spec = o;
  }
  static create(t, n, r, i) {
    let o = i.nodeViews[n.type.name], s = o && o(n, i, r);
    return (!s || !s.dom) && (s = Cd.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new hd(t, n, s.dom, s.contentDOM || s.dom, s);
  }
  parseRule() {
    return this.dirty & oa || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(t) {
    return this.dirty != oa && this.mark.eq(t);
  }
  markDirty(t, n) {
    if (super.markDirty(t, n), this.dirty != Ko) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Ko;
    }
  }
  slice(t, n, r) {
    let i = hd.create(this.parent, this.mark, !0, r), o = this.children, s = this.size;
    n < s && (o = zT(o, n, s, r)), t > 0 && (o = zT(o, 0, t, r));
    for (let a = 0; a < o.length; a++)
      o[a].parent = i;
    return i.children = o, i;
  }
  ignoreMutation(t) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(t) : super.ignoreMutation(t);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class Ec extends xy {
  constructor(t, n, r, i, o, s, a, c, u) {
    super(t, [], o, s), this.node = n, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(t, n, r, i, o, s) {
    let a = o.nodeViews[n.type.name], c, u = a && a(n, o, () => {
      if (!c)
        return s;
      if (c.parent)
        return c.parent.posBeforeChild(c);
    }, r, i), f = u && u.dom, h = u && u.contentDOM;
    if (n.isText) {
      if (!f)
        f = document.createTextNode(n.text);
      else if (f.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else f || ({ dom: f, contentDOM: h } = Cd.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !h && !n.isText && f.nodeName != "BR" && (f.hasAttribute("contenteditable") || (f.contentEditable = "false"), n.type.spec.draggable && (f.draggable = !0));
    let m = f;
    return f = VW(f, r, n), u ? c = new f2e(t, n, r, i, f, h || null, m, u, o, s + 1) : n.isText ? new d1(t, n, r, i, f, m, o) : new Ec(t, n, r, i, f, h || null, m, o, s + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let t = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (t.preserveWhitespace = "full"), !this.contentDOM)
      t.getContent = () => this.node.content;
    else if (!this.contentLost)
      t.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          t.contentElement = r.dom.parentNode;
          break;
        }
      }
      t.contentElement || (t.getContent = () => $e.empty);
    }
    return t;
  }
  matchesNode(t, n, r) {
    return this.dirty == Ko && t.eq(this.node) && px(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(t, n) {
    let r = this.node.inlineContent, i = n, o = t.composing ? this.localCompositionInfo(t, n) : null, s = o && o.pos > -1 ? o : null, a = o && o.pos < 0, c = new p2e(this, s && s.node, t);
    y2e(this.node, this.innerDeco, (u, f, h) => {
      u.spec.marks ? c.syncToMarks(u.spec.marks, r, t, f) : u.type.side >= 0 && !h && c.syncToMarks(f == this.node.childCount ? _n.none : this.node.child(f).marks, r, t, f), c.placeWidget(u, t, i);
    }, (u, f, h, m) => {
      c.syncToMarks(u.marks, r, t, m);
      let g;
      c.findNodeMatch(u, f, h, m) || a && t.state.selection.from > i && t.state.selection.to < i + u.nodeSize && (g = c.findIndexWithChild(o.node)) > -1 && c.updateNodeAt(u, f, h, g, t) || c.updateNextNode(u, f, h, t, m, i) || c.addNode(u, f, h, t, i), i += u.nodeSize;
    }), c.syncToMarks([], r, t, 0), this.node.isTextblock && c.addTextblockHacks(), c.destroyRest(), (c.changed || this.dirty == Uu) && (s && this.protectLocalComposition(t, s), UW(this.contentDOM, this.children, t), Ah && v2e(this.dom));
  }
  localCompositionInfo(t, n) {
    let { from: r, to: i } = t.state.selection;
    if (!(t.state.selection instanceof Ct) || r < n || i > n + this.node.content.size)
      return null;
    let o = t.input.compositionNode;
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let s = o.nodeValue, a = b2e(this.node.content, s, r - n, i - n);
      return a < 0 ? null : { node: o, pos: a, text: s };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(t, { node: n, pos: r, text: i }) {
    if (this.getDesc(n))
      return;
    let o = n;
    for (; o.parentNode != this.contentDOM; o = o.parentNode) {
      for (; o.previousSibling; )
        o.parentNode.removeChild(o.previousSibling);
      for (; o.nextSibling; )
        o.parentNode.removeChild(o.nextSibling);
      o.pmViewDesc && (o.pmViewDesc = void 0);
    }
    let s = new d2e(this, o, n, i);
    t.input.compositionNodes.push(s), this.children = zT(this.children, r, r + i.length, t, s);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(t, n, r, i) {
    return this.dirty == oa || !t.sameMarkup(this.node) ? !1 : (this.updateInner(t, n, r, i), !0);
  }
  updateInner(t, n, r, i) {
    this.updateOuterDeco(n), this.node = t, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Ko;
  }
  updateOuterDeco(t) {
    if (px(t, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = FW(this.dom, this.nodeDOM, jT(this.outerDeco, this.node, n), jT(t, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = t;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.nodeDOM.draggable = !0));
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.nodeDOM.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function g5(e, t, n, r, i) {
  VW(r, t, e);
  let o = new Ec(void 0, e, t, n, r, r, r, i, 0);
  return o.contentDOM && o.updateChildren(i, 0), o;
}
class d1 extends Ec {
  constructor(t, n, r, i, o, s, a) {
    super(t, n, r, i, o, null, s, a, 0);
  }
  parseRule() {
    let t = this.nodeDOM.parentNode;
    for (; t && t != this.dom && !t.pmIsDeco; )
      t = t.parentNode;
    return { skip: t || !0 };
  }
  update(t, n, r, i) {
    return this.dirty == oa || this.dirty != Ko && !this.inParent() || !t.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != Ko || t.text != this.node.text) && t.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = t.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = t, this.dirty = Ko, !0);
  }
  inParent() {
    let t = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == t)
        return !0;
    return !1;
  }
  domFromPos(t) {
    return { node: this.nodeDOM, offset: t };
  }
  localPosFromDOM(t, n, r) {
    return t == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(t, n, r);
  }
  ignoreMutation(t) {
    return t.type != "characterData" && t.type != "selection";
  }
  slice(t, n, r) {
    let i = this.node.cut(t, n), o = document.createTextNode(i.text);
    return new d1(this.parent, i, this.outerDeco, this.innerDeco, o, o, r);
  }
  markDirty(t, n) {
    super.markDirty(t, n), this.dom != this.nodeDOM && (t == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = oa);
  }
  get domAtom() {
    return !1;
  }
  isText(t) {
    return this.node.text == t;
  }
}
class $W extends xy {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(t) {
    return this.dirty == Ko && this.dom.nodeName == t;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class f2e extends Ec {
  constructor(t, n, r, i, o, s, a, c, u, f) {
    super(t, n, r, i, o, s, a, u, f), this.spec = c;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(t, n, r, i) {
    if (this.dirty == oa)
      return !1;
    if (this.spec.update && (this.node.type == t.type || this.spec.multiType)) {
      let o = this.spec.update(t, n, r);
      return o && this.updateInner(t, n, r, i), o;
    } else return !this.contentDOM && !t.isLeaf ? !1 : super.update(t, n, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(t, n, r, i) {
    this.spec.setSelection ? this.spec.setSelection(t, n, r.root) : super.setSelection(t, n, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(t) {
    return this.spec.stopEvent ? this.spec.stopEvent(t) : !1;
  }
  ignoreMutation(t) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(t) : super.ignoreMutation(t);
  }
}
function UW(e, t, n) {
  let r = e.firstChild, i = !1;
  for (let o = 0; o < t.length; o++) {
    let s = t[o], a = s.dom;
    if (a.parentNode == e) {
      for (; a != r; )
        r = y5(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, e.insertBefore(a, r);
    if (s instanceof hd) {
      let c = r ? r.previousSibling : e.lastChild;
      UW(s.contentDOM, s.children, n), r = c ? c.nextSibling : e.firstChild;
    }
  }
  for (; r; )
    r = y5(r), i = !0;
  i && n.trackWrites == e && (n.trackWrites = null);
}
const Ym = function(e) {
  e && (this.nodeName = e);
};
Ym.prototype = /* @__PURE__ */ Object.create(null);
const Fu = [new Ym()];
function jT(e, t, n) {
  if (e.length == 0)
    return Fu;
  let r = n ? Fu[0] : new Ym(), i = [r];
  for (let o = 0; o < e.length; o++) {
    let s = e[o].type.attrs;
    if (s) {
      s.nodeName && i.push(r = new Ym(s.nodeName));
      for (let a in s) {
        let c = s[a];
        c != null && (n && i.length == 1 && i.push(r = new Ym(t.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + c : a == "style" ? r.style = (r.style ? r.style + ";" : "") + c : a != "nodeName" && (r[a] = c));
      }
    }
  }
  return i;
}
function FW(e, t, n, r) {
  if (n == Fu && r == Fu)
    return t;
  let i = t;
  for (let o = 0; o < r.length; o++) {
    let s = r[o], a = n[o];
    if (o) {
      let c;
      a && a.nodeName == s.nodeName && i != e && (c = i.parentNode) && c.nodeName.toLowerCase() == s.nodeName || (c = document.createElement(s.nodeName), c.pmIsDeco = !0, c.appendChild(i), a = Fu[0]), i = c;
    }
    h2e(i, a || Fu[0], s);
  }
  return i;
}
function h2e(e, t, n) {
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && e.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != t[r] && e.setAttribute(r, n[r]);
  if (t.class != n.class) {
    let r = t.class ? t.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let o = 0; o < r.length; o++)
      i.indexOf(r[o]) == -1 && e.classList.remove(r[o]);
    for (let o = 0; o < i.length; o++)
      r.indexOf(i[o]) == -1 && e.classList.add(i[o]);
    e.classList.length == 0 && e.removeAttribute("class");
  }
  if (t.style != n.style) {
    if (t.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(t.style); )
        e.style.removeProperty(i[1]);
    }
    n.style && (e.style.cssText += n.style);
  }
}
function VW(e, t, n) {
  return FW(e, e, Fu, jT(t, n, e.nodeType != 1));
}
function px(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!e[n].type.eq(t[n].type))
      return !1;
  return !0;
}
function y5(e) {
  let t = e.nextSibling;
  return e.parentNode.removeChild(e), t;
}
class p2e {
  constructor(t, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = t, this.preMatch = m2e(t.node.content, t);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(t, n) {
    if (t != n) {
      for (let r = t; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(t, n - t), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(t, n, r, i) {
    let o = 0, s = this.stack.length >> 1, a = Math.min(s, t.length);
    for (; o < a && (o == s - 1 ? this.top : this.stack[o + 1 << 1]).matchesMark(t[o]) && t[o].type.spec.spanning !== !1; )
      o++;
    for (; o < s; )
      this.destroyRest(), this.top.dirty = Ko, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < t.length; ) {
      this.stack.push(this.top, this.index + 1);
      let c = -1, u = this.top.children.length;
      i < this.preMatch.index && (u = Math.min(this.index + 3, u));
      for (let f = this.index; f < u; f++) {
        let h = this.top.children[f];
        if (h.matchesMark(t[s]) && !this.isLocked(h.dom)) {
          c = f;
          break;
        }
      }
      if (c > -1)
        c > this.index && (this.changed = !0, this.destroyBetween(this.index, c)), this.top = this.top.children[this.index];
      else {
        let f = hd.create(this.top, t[s], n, r);
        this.top.children.splice(this.index, 0, f), this.top = f, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(t, n, r, i) {
    let o = -1, s;
    if (i >= this.preMatch.index && (s = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && s.matchesNode(t, n, r))
      o = this.top.children.indexOf(s, this.index);
    else
      for (let a = this.index, c = Math.min(this.top.children.length, a + 5); a < c; a++) {
        let u = this.top.children[a];
        if (u.matchesNode(t, n, r) && !this.preMatch.matched.has(u)) {
          o = a;
          break;
        }
      }
    return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
  }
  updateNodeAt(t, n, r, i, o) {
    let s = this.top.children[i];
    return s.dirty == oa && s.dom == s.contentDOM && (s.dirty = Uu), s.update(t, n, r, o) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(t) {
    for (; ; ) {
      let n = t.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = t.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      t = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(t, n, r, i, o, s) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let c = this.top.children[a];
      if (c instanceof Ec) {
        let u = this.preMatch.matched.get(c);
        if (u != null && u != o)
          return !1;
        let f = c.dom, h, m = this.isLocked(f) && !(t.isText && c.node && c.node.isText && c.nodeDOM.nodeValue == t.text && c.dirty != oa && px(n, c.outerDeco));
        if (!m && c.update(t, n, r, i))
          return this.destroyBetween(this.index, a), c.dom != f && (this.changed = !0), this.index++, !0;
        if (!m && (h = this.recreateWrapper(c, t, n, r, i, s)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = h, h.contentDOM && (h.dirty = Uu, h.updateChildren(i, s + 1), h.dirty = Ko), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(t, n, r, i, o, s) {
    if (t.dirty || n.isAtom || !t.children.length || !t.node.content.eq(n.content) || !px(r, t.outerDeco) || !i.eq(t.innerDeco))
      return null;
    let a = Ec.create(this.top, n, r, i, o, s);
    if (a.contentDOM) {
      a.children = t.children, t.children = [];
      for (let c of a.children)
        c.parent = a;
    }
    return t.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(t, n, r, i, o) {
    let s = Ec.create(this.top, t, n, r, i, o);
    s.contentDOM && s.updateChildren(i, o + 1), this.top.children.splice(this.index++, 0, s), this.changed = !0;
  }
  placeWidget(t, n, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(t) && (t == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let o = new BW(this.top, t, n, r);
      this.top.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let t = this.top.children[this.index - 1], n = this.top;
    for (; t instanceof hd; )
      n = t, t = n.children[n.children.length - 1];
    (!t || // Empty textblock
    !(t instanceof d1) || /\n$/.test(t.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(t.node.text)) && ((li || Wr) && t && t.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(t, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(t))
      this.index++;
    else {
      let r = document.createElement(t);
      t == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), t == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new $W(this.top, [], r, null);
      n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(t) {
    return this.lock && (t == this.lock || t.nodeType == 1 && t.contains(this.lock.parentNode));
  }
}
function m2e(e, t) {
  let n = t, r = n.children.length, i = e.childCount, o = /* @__PURE__ */ new Map(), s = [];
  e: for (; i > 0; ) {
    let a;
    for (; ; )
      if (r) {
        let u = n.children[r - 1];
        if (u instanceof hd)
          n = u, r = u.children.length;
        else {
          a = u, r--;
          break;
        }
      } else {
        if (n == t)
          break e;
        r = n.parent.children.indexOf(n), n = n.parent;
      }
    let c = a.node;
    if (c) {
      if (c != e.child(i - 1))
        break;
      --i, o.set(a, i), s.push(a);
    }
  }
  return { index: i, matched: o, matches: s.reverse() };
}
function g2e(e, t) {
  return e.type.side - t.type.side;
}
function y2e(e, t, n, r) {
  let i = t.locals(e), o = 0;
  if (i.length == 0) {
    for (let u = 0; u < e.childCount; u++) {
      let f = e.child(u);
      r(f, i, t.forChild(o, f), u), o += f.nodeSize;
    }
    return;
  }
  let s = 0, a = [], c = null;
  for (let u = 0; ; ) {
    let f, h;
    for (; s < i.length && i[s].to == o; ) {
      let w = i[s++];
      w.widget && (f ? (h || (h = [f])).push(w) : f = w);
    }
    if (f)
      if (h) {
        h.sort(g2e);
        for (let w = 0; w < h.length; w++)
          n(h[w], u, !!c);
      } else
        n(f, u, !!c);
    let m, g;
    if (c)
      g = -1, m = c, c = null;
    else if (u < e.childCount)
      g = u, m = e.child(u++);
    else
      break;
    for (let w = 0; w < a.length; w++)
      a[w].to <= o && a.splice(w--, 1);
    for (; s < i.length && i[s].from <= o && i[s].to > o; )
      a.push(i[s++]);
    let b = o + m.nodeSize;
    if (m.isText) {
      let w = b;
      s < i.length && i[s].from < w && (w = i[s].from);
      for (let S = 0; S < a.length; S++)
        a[S].to < w && (w = a[S].to);
      w < b && (c = m.cut(w - o), m = m.cut(0, w - o), b = w, g = -1);
    } else
      for (; s < i.length && i[s].to < b; )
        s++;
    let x = m.isInline && !m.isLeaf ? a.filter((w) => !w.inline) : a.slice();
    r(m, x, t.forChild(o, m), g), o = b;
  }
}
function v2e(e) {
  if (e.nodeName == "UL" || e.nodeName == "OL") {
    let t = e.style.cssText;
    e.style.cssText = t + "; list-style: square !important", window.getComputedStyle(e).listStyle, e.style.cssText = t;
  }
}
function b2e(e, t, n, r) {
  for (let i = 0, o = 0; i < e.childCount && o <= r; ) {
    let s = e.child(i++), a = o;
    if (o += s.nodeSize, !s.isText)
      continue;
    let c = s.text;
    for (; i < e.childCount; ) {
      let u = e.child(i++);
      if (o += u.nodeSize, !u.isText)
        break;
      c += u.text;
    }
    if (o >= n) {
      if (o >= r && c.slice(r - t.length - a, r - a) == t)
        return r - t.length;
      let u = a < r ? c.lastIndexOf(t, r - a - 1) : -1;
      if (u >= 0 && u + t.length + a >= n)
        return a + u;
      if (n == r && c.length >= r + t.length - a && c.slice(r - a, r - a + t.length) == t)
        return r;
    }
  }
  return -1;
}
function zT(e, t, n, r, i) {
  let o = [];
  for (let s = 0, a = 0; s < e.length; s++) {
    let c = e[s], u = a, f = a += c.size;
    u >= n || f <= t ? o.push(c) : (u < t && o.push(c.slice(0, t - u, r)), i && (o.push(i), i = void 0), f > n && o.push(c.slice(n - u, c.size, r)));
  }
  return o;
}
function HN(e, t = null) {
  let n = e.domSelectionRange(), r = e.state.doc;
  if (!n.focusNode)
    return null;
  let i = e.docView.nearestDesc(n.focusNode), o = i && i.size == 0, s = e.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (s < 0)
    return null;
  let a = r.resolve(s), c, u;
  if (u1(n)) {
    for (c = s; i && !i.node; )
      i = i.parent;
    let h = i.node;
    if (i && h.isAtom && pt.isSelectable(h) && i.parent && !(h.isInline && qRe(n.focusNode, n.focusOffset, i.dom))) {
      let m = i.posBefore;
      u = new pt(s == m ? a : r.resolve(m));
    }
  } else {
    if (n instanceof e.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let h = s, m = s;
      for (let g = 0; g < n.rangeCount; g++) {
        let b = n.getRangeAt(g);
        h = Math.min(h, e.docView.posFromDOM(b.startContainer, b.startOffset, 1)), m = Math.max(m, e.docView.posFromDOM(b.endContainer, b.endOffset, -1));
      }
      if (h < 0)
        return null;
      [c, s] = m == e.state.selection.anchor ? [m, h] : [h, m], a = r.resolve(s);
    } else
      c = e.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (c < 0)
      return null;
  }
  let f = r.resolve(c);
  if (!u) {
    let h = t == "pointer" || e.state.selection.head < a.pos && !o ? 1 : -1;
    u = WN(e, f, a, h);
  }
  return u;
}
function HW(e) {
  return e.editable ? e.hasFocus() : qW(e) && document.activeElement && document.activeElement.contains(e.dom);
}
function Qa(e, t = !1) {
  let n = e.state.selection;
  if (WW(e, n), !!HW(e)) {
    if (!t && e.input.mouseDown && e.input.mouseDown.allowDefault && Wr) {
      let r = e.domSelectionRange(), i = e.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && fd(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        e.input.mouseDown.delayedSelectionSync = !0, e.domObserver.setCurSelection();
        return;
      }
    }
    if (e.domObserver.disconnectSelection(), e.cursorWrapper)
      w2e(e);
    else {
      let { anchor: r, head: i } = n, o, s;
      v5 && !(n instanceof Ct) && (n.$from.parent.inlineContent || (o = b5(e, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = b5(e, n.to))), e.docView.setSelection(r, i, e, t), v5 && (o && x5(o), s && x5(s)), n.visible ? e.dom.classList.remove("ProseMirror-hideselection") : (e.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && x2e(e));
    }
    e.domObserver.setCurSelection(), e.domObserver.connectSelection();
  }
}
const v5 = li || Wr && RW < 63;
function b5(e, t) {
  let { node: n, offset: r } = e.docView.domFromPos(t, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, o = r ? n.childNodes[r - 1] : null;
  if (li && i && i.contentEditable == "false")
    return dE(i);
  if ((!i || i.contentEditable == "false") && (!o || o.contentEditable == "false")) {
    if (i)
      return dE(i);
    if (o)
      return dE(o);
  }
}
function dE(e) {
  return e.contentEditable = "true", li && e.draggable && (e.draggable = !1, e.wasDraggable = !0), e;
}
function x5(e) {
  e.contentEditable = "false", e.wasDraggable && (e.draggable = !0, e.wasDraggable = null);
}
function x2e(e) {
  let t = e.dom.ownerDocument;
  t.removeEventListener("selectionchange", e.input.hideSelectionGuard);
  let n = e.domSelectionRange(), r = n.anchorNode, i = n.anchorOffset;
  t.addEventListener("selectionchange", e.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != i) && (t.removeEventListener("selectionchange", e.input.hideSelectionGuard), setTimeout(() => {
      (!HW(e) || e.state.selection.visible) && e.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function w2e(e) {
  let t = e.domSelection();
  if (!t)
    return;
  let n = e.cursorWrapper.dom, r = n.nodeName == "IMG";
  r ? t.collapse(n.parentNode, ii(n) + 1) : t.collapse(n, 0), !r && !e.state.selection.visible && Xi && Cc <= 11 && (n.disabled = !0, n.disabled = !1);
}
function WW(e, t) {
  if (t instanceof pt) {
    let n = e.docView.descAt(t.from);
    n != e.lastSelectedViewDesc && (w5(e), n && n.selectNode(), e.lastSelectedViewDesc = n);
  } else
    w5(e);
}
function w5(e) {
  e.lastSelectedViewDesc && (e.lastSelectedViewDesc.parent && e.lastSelectedViewDesc.deselectNode(), e.lastSelectedViewDesc = void 0);
}
function WN(e, t, n, r) {
  return e.someProp("createSelectionBetween", (i) => i(e, t, n)) || Ct.between(t, n, r);
}
function S5(e) {
  return e.editable && !e.hasFocus() ? !1 : qW(e);
}
function qW(e) {
  let t = e.domSelectionRange();
  if (!t.anchorNode)
    return !1;
  try {
    return e.dom.contains(t.anchorNode.nodeType == 3 ? t.anchorNode.parentNode : t.anchorNode) && (e.editable || e.dom.contains(t.focusNode.nodeType == 3 ? t.focusNode.parentNode : t.focusNode));
  } catch {
    return !1;
  }
}
function S2e(e) {
  let t = e.docView.domFromPos(e.state.selection.anchor, 0), n = e.domSelectionRange();
  return fd(t.node, t.offset, n.anchorNode, n.anchorOffset);
}
function LT(e, t) {
  let { $anchor: n, $head: r } = e.selection, i = t > 0 ? n.max(r) : n.min(r), o = i.parent.inlineContent ? i.depth ? e.doc.resolve(t > 0 ? i.after() : i.before()) : null : i;
  return o && Lt.findFrom(o, t);
}
function sc(e, t) {
  return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()), !0;
}
function k5(e, t, n) {
  let r = e.state.selection;
  if (r instanceof Ct)
    if (n.indexOf("s") > -1) {
      let { $head: i } = r, o = i.textOffset ? null : t < 0 ? i.nodeBefore : i.nodeAfter;
      if (!o || o.isText || !o.isLeaf)
        return !1;
      let s = e.state.doc.resolve(i.pos + o.nodeSize * (t < 0 ? -1 : 1));
      return sc(e, new Ct(r.$anchor, s));
    } else if (r.empty) {
      if (e.endOfTextblock(t > 0 ? "forward" : "backward")) {
        let i = LT(e.state, t);
        return i && i instanceof pt ? sc(e, i) : !1;
      } else if (!(Bo && n.indexOf("m") > -1)) {
        let i = r.$head, o = i.textOffset ? null : t < 0 ? i.nodeBefore : i.nodeAfter, s;
        if (!o || o.isText)
          return !1;
        let a = t < 0 ? i.pos - o.nodeSize : i.pos;
        return o.isAtom || (s = e.docView.descAt(a)) && !s.contentDOM ? pt.isSelectable(o) ? sc(e, new pt(t < 0 ? e.state.doc.resolve(i.pos - o.nodeSize) : i)) : by ? sc(e, new Ct(e.state.doc.resolve(t < 0 ? a : a + o.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof pt && r.node.isInline)
      return sc(e, new Ct(t > 0 ? r.$to : r.$from));
    {
      let i = LT(e.state, t);
      return i ? sc(e, i) : !1;
    }
  }
}
function mx(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length;
}
function Xm(e, t) {
  let n = e.pmViewDesc;
  return n && n.size == 0 && (t < 0 || e.nextSibling || e.nodeName != "BR");
}
function Mf(e, t) {
  return t < 0 ? k2e(e) : C2e(e);
}
function k2e(e) {
  let t = e.domSelectionRange(), n = t.focusNode, r = t.focusOffset;
  if (!n)
    return;
  let i, o, s = !1;
  for (Go && n.nodeType == 1 && r < mx(n) && Xm(n.childNodes[r], -1) && (s = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[r - 1];
        if (Xm(a, -1))
          i = n, o = --r;
        else if (a.nodeType == 3)
          n = a, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (GW(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && Xm(a, -1); )
          i = n.parentNode, o = ii(a), a = a.previousSibling;
        if (a)
          n = a, r = mx(n);
        else {
          if (n = n.parentNode, n == e.dom)
            break;
          r = 0;
        }
      }
    }
  s ? BT(e, n, r) : i && BT(e, i, o);
}
function C2e(e) {
  let t = e.domSelectionRange(), n = t.focusNode, r = t.focusOffset;
  if (!n)
    return;
  let i = mx(n), o, s;
  for (; ; )
    if (r < i) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[r];
      if (Xm(a, 1))
        o = n, s = ++r;
      else
        break;
    } else {
      if (GW(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && Xm(a, 1); )
          o = a.parentNode, s = ii(a) + 1, a = a.nextSibling;
        if (a)
          n = a, r = 0, i = mx(n);
        else {
          if (n = n.parentNode, n == e.dom)
            break;
          r = i = 0;
        }
      }
    }
  o && BT(e, o, s);
}
function GW(e) {
  let t = e.pmViewDesc;
  return t && t.node && t.node.isBlock;
}
function E2e(e, t) {
  for (; e && t == e.childNodes.length && !vy(e); )
    t = ii(e) + 1, e = e.parentNode;
  for (; e && t < e.childNodes.length; ) {
    let n = e.childNodes[t];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    e = n, t = 0;
  }
}
function _2e(e, t) {
  for (; e && !t && !vy(e); )
    t = ii(e), e = e.parentNode;
  for (; e && t; ) {
    let n = e.childNodes[t - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    e = n, t = e.childNodes.length;
  }
}
function BT(e, t, n) {
  if (t.nodeType != 3) {
    let o, s;
    (s = E2e(t, n)) ? (t = s, n = 0) : (o = _2e(t, n)) && (t = o, n = o.nodeValue.length);
  }
  let r = e.domSelection();
  if (!r)
    return;
  if (u1(r)) {
    let o = document.createRange();
    o.setEnd(t, n), o.setStart(t, n), r.removeAllRanges(), r.addRange(o);
  } else r.extend && r.extend(t, n);
  e.domObserver.setCurSelection();
  let { state: i } = e;
  setTimeout(() => {
    e.state == i && Qa(e);
  }, 50);
}
function C5(e, t) {
  let n = e.state.doc.resolve(t);
  if (!(Wr || OW) && n.parent.inlineContent) {
    let i = e.coordsAtPos(t);
    if (t > n.start()) {
      let o = e.coordsAtPos(t - 1), s = (o.top + o.bottom) / 2;
      if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left < i.left ? "ltr" : "rtl";
    }
    if (t < n.end()) {
      let o = e.coordsAtPos(t + 1), s = (o.top + o.bottom) / 2;
      if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(e.dom).direction == "rtl" ? "rtl" : "ltr";
}
function E5(e, t, n) {
  let r = e.state.selection;
  if (r instanceof Ct && !r.empty || n.indexOf("s") > -1 || Bo && n.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: o } = r;
  if (!i.parent.inlineContent || e.endOfTextblock(t < 0 ? "up" : "down")) {
    let s = LT(e.state, t);
    if (s && s instanceof pt)
      return sc(e, s);
  }
  if (!i.parent.inlineContent) {
    let s = t < 0 ? i : o, a = r instanceof bo ? Lt.near(s, t) : Lt.findFrom(s, t);
    return a ? sc(e, a) : !1;
  }
  return !1;
}
function _5(e, t) {
  if (!(e.state.selection instanceof Ct))
    return !0;
  let { $head: n, $anchor: r, empty: i } = e.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (e.endOfTextblock(t > 0 ? "forward" : "backward"))
    return !0;
  let o = !n.textOffset && (t < 0 ? n.nodeBefore : n.nodeAfter);
  if (o && !o.isText) {
    let s = e.state.tr;
    return t < 0 ? s.delete(n.pos - o.nodeSize, n.pos) : s.delete(n.pos, n.pos + o.nodeSize), e.dispatch(s), !0;
  }
  return !1;
}
function T5(e, t, n) {
  e.domObserver.stop(), t.contentEditable = n, e.domObserver.start();
}
function T2e(e) {
  if (!li || e.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: t, focusOffset: n } = e.domSelectionRange();
  if (t && t.nodeType == 1 && n == 0 && t.firstChild && t.firstChild.contentEditable == "false") {
    let r = t.firstChild;
    T5(e, r, "true"), setTimeout(() => T5(e, r, "false"), 20);
  }
  return !1;
}
function A2e(e) {
  let t = "";
  return e.ctrlKey && (t += "c"), e.metaKey && (t += "m"), e.altKey && (t += "a"), e.shiftKey && (t += "s"), t;
}
function M2e(e, t) {
  let n = t.keyCode, r = A2e(t);
  if (n == 8 || Bo && n == 72 && r == "c")
    return _5(e, -1) || Mf(e, -1);
  if (n == 46 && !t.shiftKey || Bo && n == 68 && r == "c")
    return _5(e, 1) || Mf(e, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || Bo && n == 66 && r == "c") {
    let i = n == 37 ? C5(e, e.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return k5(e, i, r) || Mf(e, i);
  } else if (n == 39 || Bo && n == 70 && r == "c") {
    let i = n == 39 ? C5(e, e.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return k5(e, i, r) || Mf(e, i);
  } else {
    if (n == 38 || Bo && n == 80 && r == "c")
      return E5(e, -1, r) || Mf(e, -1);
    if (n == 40 || Bo && n == 78 && r == "c")
      return T2e(e) || E5(e, 1, r) || Mf(e, 1);
    if (r == (Bo ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function qN(e, t) {
  e.someProp("transformCopied", (g) => {
    t = g(t, e);
  });
  let n = [], { content: r, openStart: i, openEnd: o } = t;
  for (; i > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, o--;
    let g = r.firstChild;
    n.push(g.type.name, g.attrs != g.type.defaultAttrs ? g.attrs : null), r = g.content;
  }
  let s = e.someProp("clipboardSerializer") || Cd.fromSchema(e.state.schema), a = QW(), c = a.createElement("div");
  c.appendChild(s.serializeFragment(r, { document: a }));
  let u = c.firstChild, f, h = 0;
  for (; u && u.nodeType == 1 && (f = JW[u.nodeName.toLowerCase()]); ) {
    for (let g = f.length - 1; g >= 0; g--) {
      let b = a.createElement(f[g]);
      for (; c.firstChild; )
        b.appendChild(c.firstChild);
      c.appendChild(b), h++;
    }
    u = c.firstChild;
  }
  u && u.nodeType == 1 && u.setAttribute("data-pm-slice", `${i} ${o}${h ? ` -${h}` : ""} ${JSON.stringify(n)}`);
  let m = e.someProp("clipboardTextSerializer", (g) => g(t, e)) || t.content.textBetween(0, t.content.size, `

`);
  return { dom: c, text: m, slice: t };
}
function KW(e, t, n, r, i) {
  let o = i.parent.type.spec.code, s, a;
  if (!n && !t)
    return null;
  let c = !!t && (r || o || !n);
  if (c) {
    if (e.someProp("transformPastedText", (m) => {
      t = m(t, o || r, e);
    }), o)
      return a = new et($e.from(e.state.schema.text(t.replace(/\r\n?/g, `
`))), 0, 0), e.someProp("transformPasted", (m) => {
        a = m(a, e, !0);
      }), a;
    let h = e.someProp("clipboardTextParser", (m) => m(t, i, r, e));
    if (h)
      a = h;
    else {
      let m = i.marks(), { schema: g } = e.state, b = Cd.fromSchema(g);
      s = document.createElement("div"), t.split(/(?:\r\n?|\n)+/).forEach((x) => {
        let w = s.appendChild(document.createElement("p"));
        x && w.appendChild(b.serializeNode(g.text(x, m)));
      });
    }
  } else
    e.someProp("transformPastedHTML", (h) => {
      n = h(n, e);
    }), s = P2e(n), by && D2e(s);
  let u = s && s.querySelector("[data-pm-slice]"), f = u && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(u.getAttribute("data-pm-slice") || "");
  if (f && f[3])
    for (let h = +f[3]; h > 0; h--) {
      let m = s.firstChild;
      for (; m && m.nodeType != 1; )
        m = m.nextSibling;
      if (!m)
        break;
      s = m;
    }
  if (a || (a = (e.someProp("clipboardParser") || e.someProp("domParser") || kc.fromSchema(e.state.schema)).parseSlice(s, {
    preserveWhitespace: !!(c || f),
    context: i,
    ruleFromNode(m) {
      return m.nodeName == "BR" && !m.nextSibling && m.parentNode && !N2e.test(m.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), f)
    a = I2e(A5(a, +f[1], +f[2]), f[4]);
  else if (a = et.maxOpen(R2e(a.content, i), !0), a.openStart || a.openEnd) {
    let h = 0, m = 0;
    for (let g = a.content.firstChild; h < a.openStart && !g.type.spec.isolating; h++, g = g.firstChild)
      ;
    for (let g = a.content.lastChild; m < a.openEnd && !g.type.spec.isolating; m++, g = g.lastChild)
      ;
    a = A5(a, h, m);
  }
  return e.someProp("transformPasted", (h) => {
    a = h(a, e, c);
  }), a;
}
const N2e = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function R2e(e, t) {
  if (e.childCount < 2)
    return e;
  for (let n = t.depth; n >= 0; n--) {
    let i = t.node(n).contentMatchAt(t.index(n)), o, s = [];
    if (e.forEach((a) => {
      if (!s)
        return;
      let c = i.findWrapping(a.type), u;
      if (!c)
        return s = null;
      if (u = s.length && o.length && YW(c, o, a, s[s.length - 1], 0))
        s[s.length - 1] = u;
      else {
        s.length && (s[s.length - 1] = XW(s[s.length - 1], o.length));
        let f = ZW(a, c);
        s.push(f), i = i.matchType(f.type), o = c;
      }
    }), s)
      return $e.from(s);
  }
  return e;
}
function ZW(e, t, n = 0) {
  for (let r = t.length - 1; r >= n; r--)
    e = t[r].create(null, $e.from(e));
  return e;
}
function YW(e, t, n, r, i) {
  if (i < e.length && i < t.length && e[i] == t[i]) {
    let o = YW(e, t, n, r.lastChild, i + 1);
    if (o)
      return r.copy(r.content.replaceChild(r.childCount - 1, o));
    if (r.contentMatchAt(r.childCount).matchType(i == e.length - 1 ? n.type : e[i + 1]))
      return r.copy(r.content.append($e.from(ZW(n, e, i + 1))));
  }
}
function XW(e, t) {
  if (t == 0)
    return e;
  let n = e.content.replaceChild(e.childCount - 1, XW(e.lastChild, t - 1)), r = e.contentMatchAt(e.childCount).fillBefore($e.empty, !0);
  return e.copy(n.append(r));
}
function $T(e, t, n, r, i, o) {
  let s = t < 0 ? e.firstChild : e.lastChild, a = s.content;
  return e.childCount > 1 && (o = 0), i < r - 1 && (a = $T(a, t, n, r, i + 1, o)), i >= n && (a = t < 0 ? s.contentMatchAt(0).fillBefore(a, o <= i).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore($e.empty, !0))), e.replaceChild(t < 0 ? 0 : e.childCount - 1, s.copy(a));
}
function A5(e, t, n) {
  return t < e.openStart && (e = new et($T(e.content, -1, t, e.openStart, 0, e.openEnd), t, e.openEnd)), n < e.openEnd && (e = new et($T(e.content, 1, n, e.openEnd, 0, 0), e.openStart, n)), e;
}
const JW = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let M5 = null;
function QW() {
  return M5 || (M5 = document.implementation.createHTMLDocument("title"));
}
let fE = null;
function O2e(e) {
  let t = window.trustedTypes;
  return t ? (fE || (fE = t.defaultPolicy || t.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), fE.createHTML(e)) : e;
}
function P2e(e) {
  let t = /^(\s*<meta [^>]*>)*/.exec(e);
  t && (e = e.slice(t[0].length));
  let n = QW().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(e), i;
  if ((i = r && JW[r[1].toLowerCase()]) && (e = i.map((o) => "<" + o + ">").join("") + e + i.map((o) => "</" + o + ">").reverse().join("")), n.innerHTML = O2e(e), i)
    for (let o = 0; o < i.length; o++)
      n = n.querySelector(i[o]) || n;
  return n;
}
function D2e(e) {
  let t = e.querySelectorAll(Wr ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < t.length; n++) {
    let r = t[n];
    r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "), r);
  }
}
function I2e(e, t) {
  if (!e.size)
    return e;
  let n = e.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(t);
  } catch {
    return e;
  }
  let { content: i, openStart: o, openEnd: s } = e;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let c = n.nodes[r[a]];
    if (!c || c.hasRequiredAttrs())
      break;
    i = $e.from(c.create(r[a + 1], i)), o++, s++;
  }
  return new et(i, o, s);
}
const Di = {}, Ii = {}, j2e = { touchstart: !0, touchmove: !0 };
class z2e {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.badSafariComposition = !1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function L2e(e) {
  for (let t in Di) {
    let n = Di[t];
    e.dom.addEventListener(t, e.input.eventHandlers[t] = (r) => {
      $2e(e, r) && !GN(e, r) && (e.editable || !(r.type in Ii)) && n(e, r);
    }, j2e[t] ? { passive: !0 } : void 0);
  }
  li && e.dom.addEventListener("input", () => null), UT(e);
}
function yc(e, t) {
  e.input.lastSelectionOrigin = t, e.input.lastSelectionTime = Date.now();
}
function B2e(e) {
  e.domObserver.stop();
  for (let t in e.input.eventHandlers)
    e.dom.removeEventListener(t, e.input.eventHandlers[t]);
  clearTimeout(e.input.composingTimeout), clearTimeout(e.input.lastIOSEnterFallbackTimeout);
}
function UT(e) {
  e.someProp("handleDOMEvents", (t) => {
    for (let n in t)
      e.input.eventHandlers[n] || e.dom.addEventListener(n, e.input.eventHandlers[n] = (r) => GN(e, r));
  });
}
function GN(e, t) {
  return e.someProp("handleDOMEvents", (n) => {
    let r = n[t.type];
    return r ? r(e, t) || t.defaultPrevented : !1;
  });
}
function $2e(e, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let n = t.target; n != e.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(t))
      return !1;
  return !0;
}
function U2e(e, t) {
  !GN(e, t) && Di[t.type] && (e.editable || !(t.type in Ii)) && Di[t.type](e, t);
}
Ii.keydown = (e, t) => {
  let n = t;
  if (e.input.shiftKey = n.keyCode == 16 || n.shiftKey, !tq(e, n) && (e.input.lastKeyCode = n.keyCode, e.input.lastKeyCodeTime = Date.now(), !(Ya && Wr && n.keyCode == 13)))
    if (n.keyCode != 229 && e.domObserver.forceFlush(), Ah && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      e.input.lastIOSEnter = r, e.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        e.input.lastIOSEnter == r && (e.someProp("handleKeyDown", (i) => i(e, ju(13, "Enter"))), e.input.lastIOSEnter = 0);
      }, 200);
    } else e.someProp("handleKeyDown", (r) => r(e, n)) || M2e(e, n) ? n.preventDefault() : yc(e, "key");
};
Ii.keyup = (e, t) => {
  t.keyCode == 16 && (e.input.shiftKey = !1);
};
Ii.keypress = (e, t) => {
  let n = t;
  if (tq(e, n) || !n.charCode || n.ctrlKey && !n.altKey || Bo && n.metaKey)
    return;
  if (e.someProp("handleKeyPress", (i) => i(e, n))) {
    n.preventDefault();
    return;
  }
  let r = e.state.selection;
  if (!(r instanceof Ct) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(n.charCode), o = () => e.state.tr.insertText(i).scrollIntoView();
    !/[\r\n]/.test(i) && !e.someProp("handleTextInput", (s) => s(e, r.$from.pos, r.$to.pos, i, o)) && e.dispatch(o()), n.preventDefault();
  }
};
function f1(e) {
  return { left: e.clientX, top: e.clientY };
}
function F2e(e, t) {
  let n = t.x - e.clientX, r = t.y - e.clientY;
  return n * n + r * r < 100;
}
function KN(e, t, n, r, i) {
  if (r == -1)
    return !1;
  let o = e.state.doc.resolve(r);
  for (let s = o.depth + 1; s > 0; s--)
    if (e.someProp(t, (a) => s > o.depth ? a(e, n, o.nodeAfter, o.before(s), i, !0) : a(e, n, o.node(s), o.before(s), i, !1)))
      return !0;
  return !1;
}
function uh(e, t, n) {
  if (e.focused || e.focus(), e.state.selection.eq(t))
    return;
  let r = e.state.tr.setSelection(t);
  r.setMeta("pointer", !0), e.dispatch(r);
}
function V2e(e, t) {
  if (t == -1)
    return !1;
  let n = e.state.doc.resolve(t), r = n.nodeAfter;
  return r && r.isAtom && pt.isSelectable(r) ? (uh(e, new pt(n)), !0) : !1;
}
function H2e(e, t) {
  if (t == -1)
    return !1;
  let n = e.state.selection, r, i;
  n instanceof pt && (r = n.node);
  let o = e.state.doc.resolve(t);
  for (let s = o.depth + 1; s > 0; s--) {
    let a = s > o.depth ? o.nodeAfter : o.node(s);
    if (pt.isSelectable(a)) {
      r && n.$from.depth > 0 && s >= n.$from.depth && o.before(n.$from.depth + 1) == n.$from.pos ? i = o.before(n.$from.depth) : i = o.before(s);
      break;
    }
  }
  return i != null ? (uh(e, pt.create(e.state.doc, i)), !0) : !1;
}
function W2e(e, t, n, r, i) {
  return KN(e, "handleClickOn", t, n, r) || e.someProp("handleClick", (o) => o(e, t, r)) || (i ? H2e(e, n) : V2e(e, n));
}
function q2e(e, t, n, r) {
  return KN(e, "handleDoubleClickOn", t, n, r) || e.someProp("handleDoubleClick", (i) => i(e, t, r));
}
function G2e(e, t, n, r) {
  return KN(e, "handleTripleClickOn", t, n, r) || e.someProp("handleTripleClick", (i) => i(e, t, r)) || K2e(e, n, r);
}
function K2e(e, t, n) {
  if (n.button != 0)
    return !1;
  let r = e.state.doc;
  if (t == -1)
    return r.inlineContent ? (uh(e, Ct.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(t);
  for (let o = i.depth + 1; o > 0; o--) {
    let s = o > i.depth ? i.nodeAfter : i.node(o), a = i.before(o);
    if (s.inlineContent)
      uh(e, Ct.create(r, a + 1, a + 1 + s.content.size));
    else if (pt.isSelectable(s))
      uh(e, pt.create(r, a));
    else
      continue;
    return !0;
  }
}
function ZN(e) {
  return gx(e);
}
const eq = Bo ? "metaKey" : "ctrlKey";
Di.mousedown = (e, t) => {
  let n = t;
  e.input.shiftKey = n.shiftKey;
  let r = ZN(e), i = Date.now(), o = "singleClick";
  i - e.input.lastClick.time < 500 && F2e(n, e.input.lastClick) && !n[eq] && e.input.lastClick.button == n.button && (e.input.lastClick.type == "singleClick" ? o = "doubleClick" : e.input.lastClick.type == "doubleClick" && (o = "tripleClick")), e.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: o, button: n.button };
  let s = e.posAtCoords(f1(n));
  s && (o == "singleClick" ? (e.input.mouseDown && e.input.mouseDown.done(), e.input.mouseDown = new Z2e(e, s, n, !!r)) : (o == "doubleClick" ? q2e : G2e)(e, s.pos, s.inside, n) ? n.preventDefault() : yc(e, "pointer"));
};
class Z2e {
  constructor(t, n, r, i) {
    this.view = t, this.pos = n, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = t.state.doc, this.selectNode = !!r[eq], this.allowDefault = r.shiftKey;
    let o, s;
    if (n.inside > -1)
      o = t.state.doc.nodeAt(n.inside), s = n.inside;
    else {
      let f = t.state.doc.resolve(n.pos);
      o = f.parent, s = f.depth ? f.before() : 0;
    }
    const a = i ? null : r.target, c = a ? t.docView.nearestDesc(a, !0) : null;
    this.target = c && c.nodeDOM.nodeType == 1 ? c.nodeDOM : null;
    let { selection: u } = t.state;
    (r.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1 || u instanceof pt && u.from <= s && u.to > s) && (this.mightDrag = {
      node: o,
      pos: s,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Go && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), t.root.addEventListener("mouseup", this.up = this.up.bind(this)), t.root.addEventListener("mousemove", this.move = this.move.bind(this)), yc(t, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Qa(this.view)), this.view.input.mouseDown = null;
  }
  up(t) {
    if (this.done(), !this.view.dom.contains(t.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(f1(t))), this.updateAllowDefault(t), this.allowDefault || !n ? yc(this.view, "pointer") : W2e(this.view, n.pos, n.inside, t, this.selectNode) ? t.preventDefault() : t.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    li && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Wr && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (uh(this.view, Lt.near(this.view.state.doc.resolve(n.pos))), t.preventDefault()) : yc(this.view, "pointer");
  }
  move(t) {
    this.updateAllowDefault(t), yc(this.view, "pointer"), t.buttons == 0 && this.done();
  }
  updateAllowDefault(t) {
    !this.allowDefault && (Math.abs(this.event.x - t.clientX) > 4 || Math.abs(this.event.y - t.clientY) > 4) && (this.allowDefault = !0);
  }
}
Di.touchstart = (e) => {
  e.input.lastTouch = Date.now(), ZN(e), yc(e, "pointer");
};
Di.touchmove = (e) => {
  e.input.lastTouch = Date.now(), yc(e, "pointer");
};
Di.contextmenu = (e) => ZN(e);
function tq(e, t) {
  return e.composing ? !0 : li && Math.abs(t.timeStamp - e.input.compositionEndedAt) < 500 ? (e.input.compositionEndedAt = -2e8, !0) : !1;
}
const Y2e = Ya ? 5e3 : -1;
Ii.compositionstart = Ii.compositionupdate = (e) => {
  if (!e.composing) {
    e.domObserver.flush();
    let { state: t } = e, n = t.selection.$to;
    if (t.selection instanceof Ct && (t.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1) || Wr && OW && X2e(e)))
      e.markCursor = e.state.storedMarks || n.marks(), gx(e, !0), e.markCursor = null;
    else if (gx(e, !t.selection.empty), Go && t.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = e.domSelectionRange();
      for (let i = r.focusNode, o = r.focusOffset; i && i.nodeType == 1 && o != 0; ) {
        let s = o < 0 ? i.lastChild : i.childNodes[o - 1];
        if (!s)
          break;
        if (s.nodeType == 3) {
          let a = e.domSelection();
          a && a.collapse(s, s.nodeValue.length);
          break;
        } else
          i = s, o = -1;
      }
    }
    e.input.composing = !0;
  }
  nq(e, Y2e);
};
function X2e(e) {
  let { focusNode: t, focusOffset: n } = e.domSelectionRange();
  if (!t || t.nodeType != 1 || n >= t.childNodes.length)
    return !1;
  let r = t.childNodes[n];
  return r.nodeType == 1 && r.contentEditable == "false";
}
Ii.compositionend = (e, t) => {
  e.composing && (e.input.composing = !1, e.input.compositionEndedAt = t.timeStamp, e.input.compositionPendingChanges = e.domObserver.pendingRecords().length ? e.input.compositionID : 0, e.input.compositionNode = null, e.input.badSafariComposition ? e.domObserver.forceFlush() : e.input.compositionPendingChanges && Promise.resolve().then(() => e.domObserver.flush()), e.input.compositionID++, nq(e, 20));
};
function nq(e, t) {
  clearTimeout(e.input.composingTimeout), t > -1 && (e.input.composingTimeout = setTimeout(() => gx(e), t));
}
function rq(e) {
  for (e.composing && (e.input.composing = !1, e.input.compositionEndedAt = Q2e()); e.input.compositionNodes.length > 0; )
    e.input.compositionNodes.pop().markParentsDirty();
}
function J2e(e) {
  let t = e.domSelectionRange();
  if (!t.focusNode)
    return null;
  let n = HRe(t.focusNode, t.focusOffset), r = WRe(t.focusNode, t.focusOffset);
  if (n && r && n != r) {
    let i = r.pmViewDesc, o = e.domObserver.lastChangedTextNode;
    if (n == o || r == o)
      return o;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (e.input.compositionNode == r) {
      let s = n.pmViewDesc;
      if (!(!s || !s.isText(n.nodeValue)))
        return r;
    }
  }
  return n || r;
}
function Q2e() {
  let e = document.createEvent("Event");
  return e.initEvent("event", !0, !0), e.timeStamp;
}
function gx(e, t = !1) {
  if (!(Ya && e.domObserver.flushingSoon >= 0)) {
    if (e.domObserver.forceFlush(), rq(e), t || e.docView && e.docView.dirty) {
      let n = HN(e), r = e.state.selection;
      return n && !n.eq(r) ? e.dispatch(e.state.tr.setSelection(n)) : (e.markCursor || t) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? e.dispatch(e.state.tr.deleteSelection()) : e.updateState(e.state), !0;
    }
    return !1;
  }
}
function eOe(e, t) {
  if (!e.dom.parentNode)
    return;
  let n = e.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(t), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(t), e.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), e.focus();
  }, 50);
}
const Og = Xi && Cc < 15 || Ah && ZRe < 604;
Di.copy = Ii.cut = (e, t) => {
  let n = t, r = e.state.selection, i = n.type == "cut";
  if (r.empty)
    return;
  let o = Og ? null : n.clipboardData, s = r.content(), { dom: a, text: c } = qN(e, s);
  o ? (n.preventDefault(), o.clearData(), o.setData("text/html", a.innerHTML), o.setData("text/plain", c)) : eOe(e, a), i && e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function tOe(e) {
  return e.openStart == 0 && e.openEnd == 0 && e.content.childCount == 1 ? e.content.firstChild : null;
}
function nOe(e, t) {
  if (!e.dom.parentNode)
    return;
  let n = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code, r = e.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = e.input.shiftKey && e.input.lastKeyCode != 45;
  setTimeout(() => {
    e.focus(), r.parentNode && r.parentNode.removeChild(r), n ? Pg(e, r.value, null, i, t) : Pg(e, r.textContent, r.innerHTML, i, t);
  }, 50);
}
function Pg(e, t, n, r, i) {
  let o = KW(e, t, n, r, e.state.selection.$from);
  if (e.someProp("handlePaste", (c) => c(e, i, o || et.empty)))
    return !0;
  if (!o)
    return !1;
  let s = tOe(o), a = s ? e.state.tr.replaceSelectionWith(s, r) : e.state.tr.replaceSelection(o);
  return e.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function iq(e) {
  let t = e.getData("text/plain") || e.getData("Text");
  if (t)
    return t;
  let n = e.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
Ii.paste = (e, t) => {
  let n = t;
  if (e.composing && !Ya)
    return;
  let r = Og ? null : n.clipboardData, i = e.input.shiftKey && e.input.lastKeyCode != 45;
  r && Pg(e, iq(r), r.getData("text/html"), i, n) ? n.preventDefault() : nOe(e, n);
};
class oq {
  constructor(t, n, r) {
    this.slice = t, this.move = n, this.node = r;
  }
}
const rOe = Bo ? "altKey" : "ctrlKey";
function sq(e, t) {
  let n = e.someProp("dragCopies", (r) => !r(t));
  return n ?? !t[rOe];
}
Di.dragstart = (e, t) => {
  let n = t, r = e.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let i = e.state.selection, o = i.empty ? null : e.posAtCoords(f1(n)), s;
  if (!(o && o.pos >= i.from && o.pos <= (i instanceof pt ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      s = pt.create(e.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let h = e.docView.nearestDesc(n.target, !0);
      h && h.node.type.spec.draggable && h != e.docView && (s = pt.create(e.state.doc, h.posBefore));
    }
  }
  let a = (s || e.state.selection).content(), { dom: c, text: u, slice: f } = qN(e, a);
  (!n.dataTransfer.files.length || !Wr || RW > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(Og ? "Text" : "text/html", c.innerHTML), n.dataTransfer.effectAllowed = "copyMove", Og || n.dataTransfer.setData("text/plain", u), e.dragging = new oq(f, sq(e, n), s);
};
Di.dragend = (e) => {
  let t = e.dragging;
  window.setTimeout(() => {
    e.dragging == t && (e.dragging = null);
  }, 50);
};
Ii.dragover = Ii.dragenter = (e, t) => t.preventDefault();
Ii.drop = (e, t) => {
  try {
    iOe(e, t, e.dragging);
  } finally {
    e.dragging = null;
  }
};
function iOe(e, t, n) {
  if (!t.dataTransfer)
    return;
  let r = e.posAtCoords(f1(t));
  if (!r)
    return;
  let i = e.state.doc.resolve(r.pos), o = n && n.slice;
  o ? e.someProp("transformPasted", (g) => {
    o = g(o, e, !1);
  }) : o = KW(e, iq(t.dataTransfer), Og ? null : t.dataTransfer.getData("text/html"), !1, i);
  let s = !!(n && sq(e, t));
  if (e.someProp("handleDrop", (g) => g(e, t, o || et.empty, s))) {
    t.preventDefault();
    return;
  }
  if (!o)
    return;
  t.preventDefault();
  let a = o ? uW(e.state.doc, i.pos, o) : i.pos;
  a == null && (a = i.pos);
  let c = e.state.tr;
  if (s) {
    let { node: g } = n;
    g ? g.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(a), f = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, h = c.doc;
  if (f ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(h))
    return;
  let m = c.doc.resolve(u);
  if (f && pt.isSelectable(o.content.firstChild) && m.nodeAfter && m.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new pt(m));
  else {
    let g = c.mapping.map(a);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((b, x, w, S) => g = S), c.setSelection(WN(e, m, c.doc.resolve(g)));
  }
  e.focus(), e.dispatch(c.setMeta("uiEvent", "drop"));
}
Di.focus = (e) => {
  e.input.lastFocus = Date.now(), e.focused || (e.domObserver.stop(), e.dom.classList.add("ProseMirror-focused"), e.domObserver.start(), e.focused = !0, setTimeout(() => {
    e.docView && e.hasFocus() && !e.domObserver.currentSelection.eq(e.domSelectionRange()) && Qa(e);
  }, 20));
};
Di.blur = (e, t) => {
  let n = t;
  e.focused && (e.domObserver.stop(), e.dom.classList.remove("ProseMirror-focused"), e.domObserver.start(), n.relatedTarget && e.dom.contains(n.relatedTarget) && e.domObserver.currentSelection.clear(), e.focused = !1);
};
Di.beforeinput = (e, t) => {
  if (Wr && Ya && t.inputType == "deleteContentBackward") {
    e.domObserver.flushSoon();
    let { domChangeCount: r } = e.input;
    setTimeout(() => {
      if (e.input.domChangeCount != r || (e.dom.blur(), e.focus(), e.someProp("handleKeyDown", (o) => o(e, ju(8, "Backspace")))))
        return;
      let { $cursor: i } = e.state.selection;
      i && i.pos > 0 && e.dispatch(e.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let e in Ii)
  Di[e] = Ii[e];
function Dg(e, t) {
  if (e == t)
    return !0;
  for (let n in e)
    if (e[n] !== t[n])
      return !1;
  for (let n in t)
    if (!(n in e))
      return !1;
  return !0;
}
class yx {
  constructor(t, n) {
    this.toDOM = t, this.spec = n || Yu, this.side = this.spec.side || 0;
  }
  map(t, n, r, i) {
    let { pos: o, deleted: s } = t.mapResult(n.from + i, this.side < 0 ? -1 : 1);
    return s ? null : new xi(o - r, o - r, this);
  }
  valid() {
    return !0;
  }
  eq(t) {
    return this == t || t instanceof yx && (this.spec.key && this.spec.key == t.spec.key || this.toDOM == t.toDOM && Dg(this.spec, t.spec));
  }
  destroy(t) {
    this.spec.destroy && this.spec.destroy(t);
  }
}
class _c {
  constructor(t, n) {
    this.attrs = t, this.spec = n || Yu;
  }
  map(t, n, r, i) {
    let o = t.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r, s = t.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return o >= s ? null : new xi(o, s, this);
  }
  valid(t, n) {
    return n.from < n.to;
  }
  eq(t) {
    return this == t || t instanceof _c && Dg(this.attrs, t.attrs) && Dg(this.spec, t.spec);
  }
  static is(t) {
    return t.type instanceof _c;
  }
  destroy() {
  }
}
class YN {
  constructor(t, n) {
    this.attrs = t, this.spec = n || Yu;
  }
  map(t, n, r, i) {
    let o = t.mapResult(n.from + i, 1);
    if (o.deleted)
      return null;
    let s = t.mapResult(n.to + i, -1);
    return s.deleted || s.pos <= o.pos ? null : new xi(o.pos - r, s.pos - r, this);
  }
  valid(t, n) {
    let { index: r, offset: i } = t.content.findIndex(n.from), o;
    return i == n.from && !(o = t.child(r)).isText && i + o.nodeSize == n.to;
  }
  eq(t) {
    return this == t || t instanceof YN && Dg(this.attrs, t.attrs) && Dg(this.spec, t.spec);
  }
  destroy() {
  }
}
class xi {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.from = t, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(t, n) {
    return new xi(t, n, this.type);
  }
  /**
  @internal
  */
  eq(t, n = 0) {
    return this.type.eq(t.type) && this.from + n == t.from && this.to + n == t.to;
  }
  /**
  @internal
  */
  map(t, n, r) {
    return this.type.map(t, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(t, n, r) {
    return new xi(t, t, new yx(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(t, n, r, i) {
    return new xi(t, n, new _c(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(t, n, r, i) {
    return new xi(t, n, new YN(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof _c;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof yx;
  }
}
const Bf = [], Yu = {};
class Gn {
  /**
  @internal
  */
  constructor(t, n) {
    this.local = t.length ? t : Bf, this.children = n.length ? n : Bf;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(t, n) {
    return n.length ? vx(n, t, 0, Yu) : gi;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(t, n, r) {
    let i = [];
    return this.findInner(t ?? 0, n ?? 1e9, i, 0, r), i;
  }
  findInner(t, n, r, i, o) {
    for (let s = 0; s < this.local.length; s++) {
      let a = this.local[s];
      a.from <= n && a.to >= t && (!o || o(a.spec)) && r.push(a.copy(a.from + i, a.to + i));
    }
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] < n && this.children[s + 1] > t) {
        let a = this.children[s] + 1;
        this.children[s + 2].findInner(t - a, n - a, r, i + a, o);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(t, n, r) {
    return this == gi || t.maps.length == 0 ? this : this.mapInner(t, n, 0, 0, r || Yu);
  }
  /**
  @internal
  */
  mapInner(t, n, r, i, o) {
    let s;
    for (let a = 0; a < this.local.length; a++) {
      let c = this.local[a].map(t, r, i);
      c && c.type.valid(n, c) ? (s || (s = [])).push(c) : o.onRemove && o.onRemove(this.local[a].spec);
    }
    return this.children.length ? oOe(this.children, s || [], t, n, r, i, o) : s ? new Gn(s.sort(Xu), Bf) : gi;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(t, n) {
    return n.length ? this == gi ? Gn.create(t, n) : this.addInner(t, n, 0) : this;
  }
  addInner(t, n, r) {
    let i, o = 0;
    t.forEach((a, c) => {
      let u = c + r, f;
      if (f = lq(n, a, u)) {
        for (i || (i = this.children.slice()); o < i.length && i[o] < c; )
          o += 3;
        i[o] == c ? i[o + 2] = i[o + 2].addInner(a, f, u + 1) : i.splice(o, 0, c, c + a.nodeSize, vx(f, a, u + 1, Yu)), o += 3;
      }
    });
    let s = aq(o ? cq(n) : n, -r);
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(t, s[a]) || s.splice(a--, 1);
    return new Gn(s.length ? this.local.concat(s).sort(Xu) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(t) {
    return t.length == 0 || this == gi ? this : this.removeInner(t, 0);
  }
  removeInner(t, n) {
    let r = this.children, i = this.local;
    for (let o = 0; o < r.length; o += 3) {
      let s, a = r[o] + n, c = r[o + 1] + n;
      for (let f = 0, h; f < t.length; f++)
        (h = t[f]) && h.from > a && h.to < c && (t[f] = null, (s || (s = [])).push(h));
      if (!s)
        continue;
      r == this.children && (r = this.children.slice());
      let u = r[o + 2].removeInner(s, a + 1);
      u != gi ? r[o + 2] = u : (r.splice(o, 3), o -= 3);
    }
    if (i.length) {
      for (let o = 0, s; o < t.length; o++)
        if (s = t[o])
          for (let a = 0; a < i.length; a++)
            i[a].eq(s, n) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new Gn(i, r) : gi;
  }
  forChild(t, n) {
    if (this == gi)
      return this;
    if (n.isLeaf)
      return Gn.empty;
    let r, i;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= t) {
        this.children[a] == t && (r = this.children[a + 2]);
        break;
      }
    let o = t + 1, s = o + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let c = this.local[a];
      if (c.from < s && c.to > o && c.type instanceof _c) {
        let u = Math.max(o, c.from) - o, f = Math.min(s, c.to) - o;
        u < f && (i || (i = [])).push(c.copy(u, f));
      }
    }
    if (i) {
      let a = new Gn(i.sort(Xu), Bf);
      return r ? new cc([a, r]) : a;
    }
    return r || gi;
  }
  /**
  @internal
  */
  eq(t) {
    if (this == t)
      return !0;
    if (!(t instanceof Gn) || this.local.length != t.local.length || this.children.length != t.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(t.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != t.children[n] || this.children[n + 1] != t.children[n + 1] || !this.children[n + 2].eq(t.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(t) {
    return XN(this.localsInner(t));
  }
  /**
  @internal
  */
  localsInner(t) {
    if (this == gi)
      return Bf;
    if (t.inlineContent || !this.local.some(_c.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof _c || n.push(this.local[r]);
    return n;
  }
  forEachSet(t) {
    t(this);
  }
}
Gn.empty = new Gn([], []);
Gn.removeOverlap = XN;
const gi = Gn.empty;
class cc {
  constructor(t) {
    this.members = t;
  }
  map(t, n) {
    const r = this.members.map((i) => i.map(t, n, Yu));
    return cc.from(r);
  }
  forChild(t, n) {
    if (n.isLeaf)
      return Gn.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].forChild(t, n);
      o != gi && (o instanceof cc ? r = r.concat(o.members) : r.push(o));
    }
    return cc.from(r);
  }
  eq(t) {
    if (!(t instanceof cc) || t.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(t.members[n]))
        return !1;
    return !0;
  }
  locals(t) {
    let n, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].localsInner(t);
      if (o.length)
        if (!n)
          n = o;
        else {
          r && (n = n.slice(), r = !1);
          for (let s = 0; s < o.length; s++)
            n.push(o[s]);
        }
    }
    return n ? XN(r ? n : n.sort(Xu)) : Bf;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(t) {
    switch (t.length) {
      case 0:
        return gi;
      case 1:
        return t[0];
      default:
        return new cc(t.every((n) => n instanceof Gn) ? t : t.reduce((n, r) => n.concat(r instanceof Gn ? r : r.members), []));
    }
  }
  forEachSet(t) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(t);
  }
}
function oOe(e, t, n, r, i, o, s) {
  let a = e.slice();
  for (let u = 0, f = o; u < n.maps.length; u++) {
    let h = 0;
    n.maps[u].forEach((m, g, b, x) => {
      let w = x - b - (g - m);
      for (let S = 0; S < a.length; S += 3) {
        let _ = a[S + 1];
        if (_ < 0 || m > _ + f - h)
          continue;
        let M = a[S] + f - h;
        g >= M ? a[S + 1] = m <= M ? -2 : -1 : m >= f && w && (a[S] += w, a[S + 1] += w);
      }
      h += w;
    }), f = n.maps[u].map(f, -1);
  }
  let c = !1;
  for (let u = 0; u < a.length; u += 3)
    if (a[u + 1] < 0) {
      if (a[u + 1] == -2) {
        c = !0, a[u + 1] = -1;
        continue;
      }
      let f = n.map(e[u] + o), h = f - i;
      if (h < 0 || h >= r.content.size) {
        c = !0;
        continue;
      }
      let m = n.map(e[u + 1] + o, -1), g = m - i, { index: b, offset: x } = r.content.findIndex(h), w = r.maybeChild(b);
      if (w && x == h && x + w.nodeSize == g) {
        let S = a[u + 2].mapInner(n, w, f + 1, e[u] + o + 1, s);
        S != gi ? (a[u] = h, a[u + 1] = g, a[u + 2] = S) : (a[u + 1] = -2, c = !0);
      } else
        c = !0;
    }
  if (c) {
    let u = sOe(a, e, t, n, i, o, s), f = vx(u, r, 0, s);
    t = f.local;
    for (let h = 0; h < a.length; h += 3)
      a[h + 1] < 0 && (a.splice(h, 3), h -= 3);
    for (let h = 0, m = 0; h < f.children.length; h += 3) {
      let g = f.children[h];
      for (; m < a.length && a[m] < g; )
        m += 3;
      a.splice(m, 0, f.children[h], f.children[h + 1], f.children[h + 2]);
    }
  }
  return new Gn(t.sort(Xu), a);
}
function aq(e, t) {
  if (!t || !e.length)
    return e;
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    n.push(new xi(i.from + t, i.to + t, i.type));
  }
  return n;
}
function sOe(e, t, n, r, i, o, s) {
  function a(c, u) {
    for (let f = 0; f < c.local.length; f++) {
      let h = c.local[f].map(r, i, u);
      h ? n.push(h) : s.onRemove && s.onRemove(c.local[f].spec);
    }
    for (let f = 0; f < c.children.length; f += 3)
      a(c.children[f + 2], c.children[f] + u + 1);
  }
  for (let c = 0; c < e.length; c += 3)
    e[c + 1] == -1 && a(e[c + 2], t[c] + o + 1);
  return n;
}
function lq(e, t, n) {
  if (t.isLeaf)
    return null;
  let r = n + t.nodeSize, i = null;
  for (let o = 0, s; o < e.length; o++)
    (s = e[o]) && s.from > n && s.to < r && ((i || (i = [])).push(s), e[o] = null);
  return i;
}
function cq(e) {
  let t = [];
  for (let n = 0; n < e.length; n++)
    e[n] != null && t.push(e[n]);
  return t;
}
function vx(e, t, n, r) {
  let i = [], o = !1;
  t.forEach((a, c) => {
    let u = lq(e, a, c + n);
    if (u) {
      o = !0;
      let f = vx(u, a, n + c + 1, r);
      f != gi && i.push(c, c + a.nodeSize, f);
    }
  });
  let s = aq(o ? cq(e) : e, -n).sort(Xu);
  for (let a = 0; a < s.length; a++)
    s[a].type.valid(t, s[a]) || (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
  return s.length || i.length ? new Gn(s, i) : gi;
}
function Xu(e, t) {
  return e.from - t.from || e.to - t.to;
}
function XN(e) {
  let t = e;
  for (let n = 0; n < t.length - 1; n++) {
    let r = t[n];
    if (r.from != r.to)
      for (let i = n + 1; i < t.length; i++) {
        let o = t[i];
        if (o.from == r.from) {
          o.to != r.to && (t == e && (t = e.slice()), t[i] = o.copy(o.from, r.to), N5(t, i + 1, o.copy(r.to, o.to)));
          continue;
        } else {
          o.from < r.to && (t == e && (t = e.slice()), t[n] = r.copy(r.from, o.from), N5(t, i, r.copy(o.from, r.to)));
          break;
        }
      }
  }
  return t;
}
function N5(e, t, n) {
  for (; t < e.length && Xu(n, e[t]) > 0; )
    t++;
  e.splice(t, 0, n);
}
function hE(e) {
  let t = [];
  return e.someProp("decorations", (n) => {
    let r = n(e.state);
    r && r != gi && t.push(r);
  }), e.cursorWrapper && t.push(Gn.create(e.state.doc, [e.cursorWrapper.deco])), cc.from(t);
}
const aOe = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, lOe = Xi && Cc <= 11;
class cOe {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(t) {
    this.anchorNode = t.anchorNode, this.anchorOffset = t.anchorOffset, this.focusNode = t.focusNode, this.focusOffset = t.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(t) {
    return t.anchorNode == this.anchorNode && t.anchorOffset == this.anchorOffset && t.focusNode == this.focusNode && t.focusOffset == this.focusOffset;
  }
}
class uOe {
  constructor(t, n) {
    this.view = t, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new cOe(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      Xi && Cc <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : li && t.composing && r.some((i) => i.type == "childList" && i.target.nodeName == "TR") ? (t.input.badSafariComposition = !0, this.flushSoon()) : this.flush();
    }), lOe && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, aOe)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let t = this.observer.takeRecords();
      if (t.length) {
        for (let n = 0; n < t.length; n++)
          this.queue.push(t[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (S5(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Qa(this.view);
      if (Xi && Cc <= 11 && !this.view.state.selection.empty) {
        let t = this.view.domSelectionRange();
        if (t.focusNode && fd(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(t) {
    if (!t.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let o = t.focusNode; o; o = Th(o))
      n.add(o);
    for (let o = t.anchorNode; o; o = Th(o))
      if (n.has(o)) {
        r = o;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let t of this.observer.takeRecords())
        this.queue.push(t);
    return this.queue;
  }
  flush() {
    let { view: t } = this;
    if (!t.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = t.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && S5(t) && !this.ignoreSelectionChange(r), o = -1, s = -1, a = !1, c = [];
    if (t.editable)
      for (let f = 0; f < n.length; f++) {
        let h = this.registerMutation(n[f], c);
        h && (o = o < 0 ? h.from : Math.min(h.from, o), s = s < 0 ? h.to : Math.max(h.to, s), h.typeOver && (a = !0));
      }
    if (Go && c.length) {
      let f = c.filter((h) => h.nodeName == "BR");
      if (f.length == 2) {
        let [h, m] = f;
        h.parentNode && h.parentNode.parentNode == m.parentNode ? m.remove() : h.remove();
      } else {
        let { focusNode: h } = this.currentSelection;
        for (let m of f) {
          let g = m.parentNode;
          g && g.nodeName == "LI" && (!h || hOe(t, h) != g) && m.remove();
        }
      }
    } else if ((Wr || li) && c.some((f) => f.nodeName == "BR") && (t.input.lastKeyCode == 8 || t.input.lastKeyCode == 46)) {
      for (let f of c)
        if (f.nodeName == "BR" && f.parentNode) {
          let h = f.nextSibling;
          h && h.nodeType == 1 && h.contentEditable == "false" && f.parentNode.removeChild(f);
        }
    }
    let u = null;
    o < 0 && i && t.input.lastFocus > Date.now() - 200 && Math.max(t.input.lastTouch, t.input.lastClick.time) < Date.now() - 300 && u1(r) && (u = HN(t)) && u.eq(Lt.near(t.state.doc.resolve(0), 1)) ? (t.input.lastFocus = 0, Qa(t), this.currentSelection.set(r), t.scrollToSelection()) : (o > -1 || i) && (o > -1 && (t.docView.markDirty(o, s), dOe(t)), t.input.badSafariComposition && (t.input.badSafariComposition = !1, pOe(t, c)), this.handleDOMChange(o, s, a, c), t.docView && t.docView.dirty ? t.updateState(t.state) : this.currentSelection.eq(r) || Qa(t), this.currentSelection.set(r));
  }
  registerMutation(t, n) {
    if (n.indexOf(t.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(t.target);
    if (t.type == "attributes" && (r == this.view.docView || t.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    t.attributeName == "style" && !t.oldValue && !t.target.getAttribute("style")) || !r || r.ignoreMutation(t))
      return null;
    if (t.type == "childList") {
      for (let f = 0; f < t.addedNodes.length; f++) {
        let h = t.addedNodes[f];
        n.push(h), h.nodeType == 3 && (this.lastChangedTextNode = h);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(t.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = t.previousSibling, o = t.nextSibling;
      if (Xi && Cc <= 11 && t.addedNodes.length)
        for (let f = 0; f < t.addedNodes.length; f++) {
          let { previousSibling: h, nextSibling: m } = t.addedNodes[f];
          (!h || Array.prototype.indexOf.call(t.addedNodes, h) < 0) && (i = h), (!m || Array.prototype.indexOf.call(t.addedNodes, m) < 0) && (o = m);
        }
      let s = i && i.parentNode == t.target ? ii(i) + 1 : 0, a = r.localPosFromDOM(t.target, s, -1), c = o && o.parentNode == t.target ? ii(o) : t.target.childNodes.length, u = r.localPosFromDOM(t.target, c, 1);
      return { from: a, to: u };
    } else return t.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = t.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: t.target.nodeValue == t.oldValue
    });
  }
}
let R5 = /* @__PURE__ */ new WeakMap(), O5 = !1;
function dOe(e) {
  if (!R5.has(e) && (R5.set(e, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(e.dom).whiteSpace) !== -1)) {
    if (e.requiresGeckoHackNode = Go, O5)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), O5 = !0;
  }
}
function P5(e, t) {
  let n = t.startContainer, r = t.startOffset, i = t.endContainer, o = t.endOffset, s = e.domAtPos(e.state.selection.anchor);
  return fd(s.node, s.offset, i, o) && ([n, r, i, o] = [i, o, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o };
}
function fOe(e, t) {
  if (t.getComposedRanges) {
    let i = t.getComposedRanges(e.root)[0];
    if (i)
      return P5(e, i);
  }
  let n;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return e.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), e.dom.removeEventListener("beforeinput", r, !0), n ? P5(e, n) : null;
}
function hOe(e, t) {
  for (let n = t.parentNode; n && n != e.dom; n = n.parentNode) {
    let r = e.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock)
      return n;
  }
  return null;
}
function pOe(e, t) {
  var n;
  let { focusNode: r, focusOffset: i } = e.domSelectionRange();
  for (let o of t)
    if (((n = o.parentNode) === null || n === void 0 ? void 0 : n.nodeName) == "TR") {
      let s = o.nextSibling;
      for (; s && s.nodeName != "TD" && s.nodeName != "TH"; )
        s = s.nextSibling;
      if (s) {
        let a = s;
        for (; ; ) {
          let c = a.firstChild;
          if (!c || c.nodeType != 1 || c.contentEditable == "false" || /^(BR|IMG)$/.test(c.nodeName))
            break;
          a = c;
        }
        a.insertBefore(o, a.firstChild), r == o && e.domSelection().collapse(o, i);
      } else
        o.parentNode.removeChild(o);
    }
}
function mOe(e, t, n) {
  let { node: r, fromOffset: i, toOffset: o, from: s, to: a } = e.docView.parseRange(t, n), c = e.domSelectionRange(), u, f = c.anchorNode;
  if (f && e.dom.contains(f.nodeType == 1 ? f : f.parentNode) && (u = [{ node: f, offset: c.anchorOffset }], u1(c) || u.push({ node: c.focusNode, offset: c.focusOffset })), Wr && e.input.lastKeyCode === 8)
    for (let w = o; w > i; w--) {
      let S = r.childNodes[w - 1], _ = S.pmViewDesc;
      if (S.nodeName == "BR" && !_) {
        o = w;
        break;
      }
      if (!_ || _.size)
        break;
    }
  let h = e.state.doc, m = e.someProp("domParser") || kc.fromSchema(e.state.schema), g = h.resolve(s), b = null, x = m.parse(r, {
    topNode: g.parent,
    topMatch: g.parent.contentMatchAt(g.index()),
    topOpen: !0,
    from: i,
    to: o,
    preserveWhitespace: g.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: u,
    ruleFromNode: gOe,
    context: g
  });
  if (u && u[0].pos != null) {
    let w = u[0].pos, S = u[1] && u[1].pos;
    S == null && (S = w), b = { anchor: w + s, head: S + s };
  }
  return { doc: x, sel: b, from: s, to: a };
}
function gOe(e) {
  let t = e.pmViewDesc;
  if (t)
    return t.parseRule();
  if (e.nodeName == "BR" && e.parentNode) {
    if (li && /^(ul|ol)$/i.test(e.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (e.parentNode.lastChild == e || li && /^(tr|table)$/i.test(e.parentNode.nodeName))
      return { ignore: !0 };
  } else if (e.nodeName == "IMG" && e.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const yOe = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function vOe(e, t, n, r, i) {
  let o = e.input.compositionPendingChanges || (e.composing ? e.input.compositionID : 0);
  if (e.input.compositionPendingChanges = 0, t < 0) {
    let O = e.input.lastSelectionTime > Date.now() - 50 ? e.input.lastSelectionOrigin : null, L = HN(e, O);
    if (L && !e.state.selection.eq(L)) {
      if (Wr && Ya && e.input.lastKeyCode === 13 && Date.now() - 100 < e.input.lastKeyCodeTime && e.someProp("handleKeyDown", (B) => B(e, ju(13, "Enter"))))
        return;
      let U = e.state.tr.setSelection(L);
      O == "pointer" ? U.setMeta("pointer", !0) : O == "key" && U.scrollIntoView(), o && U.setMeta("composition", o), e.dispatch(U);
    }
    return;
  }
  let s = e.state.doc.resolve(t), a = s.sharedDepth(n);
  t = s.before(a + 1), n = e.state.doc.resolve(n).after(a + 1);
  let c = e.state.selection, u = mOe(e, t, n), f = e.state.doc, h = f.slice(u.from, u.to), m, g;
  e.input.lastKeyCode === 8 && Date.now() - 100 < e.input.lastKeyCodeTime ? (m = e.state.selection.to, g = "end") : (m = e.state.selection.from, g = "start"), e.input.lastKeyCode = null;
  let b = wOe(h.content, u.doc.content, u.from, m, g);
  if (b && e.input.domChangeCount++, (Ah && e.input.lastIOSEnter > Date.now() - 225 || Ya) && i.some((O) => O.nodeType == 1 && !yOe.test(O.nodeName)) && (!b || b.endA >= b.endB) && e.someProp("handleKeyDown", (O) => O(e, ju(13, "Enter")))) {
    e.input.lastIOSEnter = 0;
    return;
  }
  if (!b)
    if (r && c instanceof Ct && !c.empty && c.$head.sameParent(c.$anchor) && !e.composing && !(u.sel && u.sel.anchor != u.sel.head))
      b = { start: c.from, endA: c.to, endB: c.to };
    else {
      if (u.sel) {
        let O = D5(e, e.state.doc, u.sel);
        if (O && !O.eq(e.state.selection)) {
          let L = e.state.tr.setSelection(O);
          o && L.setMeta("composition", o), e.dispatch(L);
        }
      }
      return;
    }
  e.state.selection.from < e.state.selection.to && b.start == b.endB && e.state.selection instanceof Ct && (b.start > e.state.selection.from && b.start <= e.state.selection.from + 2 && e.state.selection.from >= u.from ? b.start = e.state.selection.from : b.endA < e.state.selection.to && b.endA >= e.state.selection.to - 2 && e.state.selection.to <= u.to && (b.endB += e.state.selection.to - b.endA, b.endA = e.state.selection.to)), Xi && Cc <= 11 && b.endB == b.start + 1 && b.endA == b.start && b.start > u.from && u.doc.textBetween(b.start - u.from - 1, b.start - u.from + 1) == " " && (b.start--, b.endA--, b.endB--);
  let x = u.doc.resolveNoCache(b.start - u.from), w = u.doc.resolveNoCache(b.endB - u.from), S = f.resolve(b.start), _ = x.sameParent(w) && x.parent.inlineContent && S.end() >= b.endA;
  if ((Ah && e.input.lastIOSEnter > Date.now() - 225 && (!_ || i.some((O) => O.nodeName == "DIV" || O.nodeName == "P")) || !_ && x.pos < u.doc.content.size && (!x.sameParent(w) || !x.parent.inlineContent) && x.pos < w.pos && !/\S/.test(u.doc.textBetween(x.pos, w.pos, "", ""))) && e.someProp("handleKeyDown", (O) => O(e, ju(13, "Enter")))) {
    e.input.lastIOSEnter = 0;
    return;
  }
  if (e.state.selection.anchor > b.start && xOe(f, b.start, b.endA, x, w) && e.someProp("handleKeyDown", (O) => O(e, ju(8, "Backspace")))) {
    Ya && Wr && e.domObserver.suppressSelectionUpdates();
    return;
  }
  Wr && b.endB == b.start && (e.input.lastChromeDelete = Date.now()), Ya && !_ && x.start() != w.start() && w.parentOffset == 0 && x.depth == w.depth && u.sel && u.sel.anchor == u.sel.head && u.sel.head == b.endA && (b.endB -= 2, w = u.doc.resolveNoCache(b.endB - u.from), setTimeout(() => {
    e.someProp("handleKeyDown", function(O) {
      return O(e, ju(13, "Enter"));
    });
  }, 20));
  let M = b.start, N = b.endA, D = (O) => {
    let L = O || e.state.tr.replace(M, N, u.doc.slice(b.start - u.from, b.endB - u.from));
    if (u.sel) {
      let U = D5(e, L.doc, u.sel);
      U && !(Wr && e.composing && U.empty && (b.start != b.endB || e.input.lastChromeDelete < Date.now() - 100) && (U.head == M || U.head == L.mapping.map(N) - 1) || Xi && U.empty && U.head == M) && L.setSelection(U);
    }
    return o && L.setMeta("composition", o), L.scrollIntoView();
  }, j;
  if (_)
    if (x.pos == w.pos) {
      Xi && Cc <= 11 && x.parentOffset == 0 && (e.domObserver.suppressSelectionUpdates(), setTimeout(() => Qa(e), 20));
      let O = D(e.state.tr.delete(M, N)), L = f.resolve(b.start).marksAcross(f.resolve(b.endA));
      L && O.ensureMarks(L), e.dispatch(O);
    } else if (
      // Adding or removing a mark
      b.endA == b.endB && (j = bOe(x.parent.content.cut(x.parentOffset, w.parentOffset), S.parent.content.cut(S.parentOffset, b.endA - S.start())))
    ) {
      let O = D(e.state.tr);
      j.type == "add" ? O.addMark(M, N, j.mark) : O.removeMark(M, N, j.mark), e.dispatch(O);
    } else if (x.parent.child(x.index()).isText && x.index() == w.index() - (w.textOffset ? 0 : 1)) {
      let O = x.parent.textBetween(x.parentOffset, w.parentOffset), L = () => D(e.state.tr.insertText(O, M, N));
      e.someProp("handleTextInput", (U) => U(e, M, N, O, L)) || e.dispatch(L());
    } else
      e.dispatch(D());
  else
    e.dispatch(D());
}
function D5(e, t, n) {
  return Math.max(n.anchor, n.head) > t.content.size ? null : WN(e, t.resolve(n.anchor), t.resolve(n.head));
}
function bOe(e, t) {
  let n = e.firstChild.marks, r = t.firstChild.marks, i = n, o = r, s, a, c;
  for (let f = 0; f < r.length; f++)
    i = r[f].removeFromSet(i);
  for (let f = 0; f < n.length; f++)
    o = n[f].removeFromSet(o);
  if (i.length == 1 && o.length == 0)
    a = i[0], s = "add", c = (f) => f.mark(a.addToSet(f.marks));
  else if (i.length == 0 && o.length == 1)
    a = o[0], s = "remove", c = (f) => f.mark(a.removeFromSet(f.marks));
  else
    return null;
  let u = [];
  for (let f = 0; f < t.childCount; f++)
    u.push(c(t.child(f)));
  if ($e.from(u).eq(e))
    return { mark: a, type: s };
}
function xOe(e, t, n, r, i) {
  if (
    // The content must have shrunk
    n - t <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    pE(r, !0, !1) < i.pos
  )
    return !1;
  let o = e.resolve(t);
  if (!r.parent.isTextblock) {
    let a = o.nodeAfter;
    return a != null && n == t + a.nodeSize;
  }
  if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
    return !1;
  let s = e.resolve(pE(o, !0, !0));
  return !s.parent.isTextblock || s.pos > n || pE(s, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
}
function pE(e, t, n) {
  let r = e.depth, i = t ? e.end() : e.pos;
  for (; r > 0 && (t || e.indexAfter(r) == e.node(r).childCount); )
    r--, i++, t = !1;
  if (n) {
    let o = e.node(r).maybeChild(e.indexAfter(r));
    for (; o && !o.isLeaf; )
      o = o.firstChild, i++;
  }
  return i;
}
function wOe(e, t, n, r, i) {
  let o = e.findDiffStart(t, n);
  if (o == null)
    return null;
  let { a: s, b: a } = e.findDiffEnd(t, n + e.size, n + t.size);
  if (i == "end") {
    let c = Math.max(0, o - Math.min(s, a));
    r -= s + c - o;
  }
  if (s < o && e.size < t.size) {
    let c = r <= o && r >= s ? o - r : 0;
    o -= c, o && o < t.size && I5(t.textBetween(o - 1, o + 1)) && (o += c ? 1 : -1), a = o + (a - s), s = o;
  } else if (a < o) {
    let c = r <= o && r >= a ? o - r : 0;
    o -= c, o && o < e.size && I5(e.textBetween(o - 1, o + 1)) && (o += c ? 1 : -1), s = o + (s - a), a = o;
  }
  return { start: o, endA: s, endB: a };
}
function I5(e) {
  if (e.length != 2)
    return !1;
  let t = e.charCodeAt(0), n = e.charCodeAt(1);
  return t >= 56320 && t <= 57343 && n >= 55296 && n <= 56319;
}
class uq {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(t, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new z2e(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach($5), this.dispatch = this.dispatch.bind(this), this.dom = t && t.mount || document.createElement("div"), t && (t.appendChild ? t.appendChild(this.dom) : typeof t == "function" ? t(this.dom) : t.mount && (this.mounted = !0)), this.editable = L5(this), z5(this), this.nodeViews = B5(this), this.docView = g5(this.state.doc, j5(this), hE(this), this.dom, this), this.domObserver = new uOe(this, (r, i, o, s) => vOe(this, r, i, o, s)), this.domObserver.start(), L2e(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let t = this._props;
      this._props = {};
      for (let n in t)
        this._props[n] = t[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(t) {
    t.handleDOMEvents != this._props.handleDOMEvents && UT(this);
    let n = this._props;
    this._props = t, t.plugins && (t.plugins.forEach($5), this.directPlugins = t.plugins), this.updateStateInner(t.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(t) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in t)
      n[r] = t[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(t) {
    this.updateStateInner(t, this._props);
  }
  updateStateInner(t, n) {
    var r;
    let i = this.state, o = !1, s = !1;
    t.storedMarks && this.composing && (rq(this), s = !0), this.state = t;
    let a = i.plugins != t.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let g = B5(this);
      kOe(g, this.nodeViews) && (this.nodeViews = g, o = !0);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && UT(this), this.editable = L5(this), z5(this);
    let c = hE(this), u = j5(this), f = i.plugins != t.plugins && !i.doc.eq(t.doc) ? "reset" : t.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", h = o || !this.docView.matchesNode(t.doc, u, c);
    (h || !t.selection.eq(i.selection)) && (s = !0);
    let m = f == "preserve" && s && this.dom.style.overflowAnchor == null && JRe(this);
    if (s) {
      this.domObserver.stop();
      let g = h && (Xi || Wr) && !this.composing && !i.selection.empty && !t.selection.empty && SOe(i.selection, t.selection);
      if (h) {
        let b = Wr ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = J2e(this)), (o || !this.docView.update(t.doc, u, c, this)) && (this.docView.updateOuterDeco(u), this.docView.destroy(), this.docView = g5(t.doc, u, c, this.dom, this)), b && (!this.trackWrites || !this.dom.contains(this.trackWrites)) && (g = !0);
      }
      g || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && S2e(this)) ? Qa(this, g) : (WW(this, t.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(t.doc) && this.updateDraggedNode(this.dragging, i), f == "reset" ? this.dom.scrollTop = 0 : f == "to selection" ? this.scrollToSelection() : m && QRe(m);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let t = this.domSelectionRange().focusNode;
    if (!(!t || !this.dom.contains(t.nodeType == 1 ? t : t.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof pt) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && u5(this, n.getBoundingClientRect(), t);
      } else
        u5(this, this.coordsAtPos(this.state.selection.head, 1), t);
    }
  }
  destroyPluginViews() {
    let t;
    for (; t = this.pluginViews.pop(); )
      t.destroy && t.destroy();
  }
  updatePluginViews(t) {
    if (!t || t.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, t);
      }
  }
  updateDraggedNode(t, n) {
    let r = t.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let o = r.from + (this.state.doc.content.size - n.doc.content.size);
      (o > 0 && this.state.doc.nodeAt(o)) == r.node && (i = o);
    }
    this.dragging = new oq(t.slice, t.move, i < 0 ? void 0 : pt.create(this.state.doc, i));
  }
  someProp(t, n) {
    let r = this._props && this._props[t], i;
    if (r != null && (i = n ? n(r) : r))
      return i;
    for (let s = 0; s < this.directPlugins.length; s++) {
      let a = this.directPlugins[s].props[t];
      if (a != null && (i = n ? n(a) : a))
        return i;
    }
    let o = this.state.plugins;
    if (o)
      for (let s = 0; s < o.length; s++) {
        let a = o[s].props[t];
        if (a != null && (i = n ? n(a) : a))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Xi) {
      let t = this.root.activeElement;
      if (t == this.dom)
        return !0;
      if (!t || !this.dom.contains(t))
        return !1;
      for (; t && this.dom != t && this.dom.contains(t); ) {
        if (t.contentEditable == "false")
          return !1;
        t = t.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && e2e(this.dom), Qa(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let t = this._root;
    if (t == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return t || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(t) {
    return o2e(this, t);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(t, n = 1) {
    return zW(this, t, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(t, n = 0) {
    return this.docView.domFromPos(t, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(t) {
    let n = this.docView.descAt(t);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(t, n, r = -1) {
    let i = this.docView.posFromDOM(t, n, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(t, n) {
    return u2e(this, n || this.state, t);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(t, n) {
    return Pg(this, "", t, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(t, n) {
    return Pg(this, t, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(t) {
    return qN(this, t);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (B2e(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], hE(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, FRe());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(t) {
    return U2e(this, t);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let t = this.domSelection();
    return t ? li && this.root.nodeType === 11 && GRe(this.dom.ownerDocument) == this.dom && fOe(this, t) || t : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
uq.prototype.dispatch = function(e) {
  let t = this._props.dispatchTransaction;
  t ? t.call(this, e) : this.updateState(this.state.apply(e));
};
function j5(e) {
  let t = /* @__PURE__ */ Object.create(null);
  return t.class = "ProseMirror", t.contenteditable = String(e.editable), e.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(e.state)), n)
      for (let r in n)
        r == "class" ? t.class += " " + n[r] : r == "style" ? t.style = (t.style ? t.style + ";" : "") + n[r] : !t[r] && r != "contenteditable" && r != "nodeName" && (t[r] = String(n[r]));
  }), t.translate || (t.translate = "no"), [xi.node(0, e.state.doc.content.size, t)];
}
function z5(e) {
  if (e.markCursor) {
    let t = document.createElement("img");
    t.className = "ProseMirror-separator", t.setAttribute("mark-placeholder", "true"), t.setAttribute("alt", ""), e.cursorWrapper = { dom: t, deco: xi.widget(e.state.selection.from, t, { raw: !0, marks: e.markCursor }) };
  } else
    e.cursorWrapper = null;
}
function L5(e) {
  return !e.someProp("editable", (t) => t(e.state) === !1);
}
function SOe(e, t) {
  let n = Math.min(e.$anchor.sharedDepth(e.head), t.$anchor.sharedDepth(t.head));
  return e.$anchor.start(n) != t.$anchor.start(n);
}
function B5(e) {
  let t = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(t, i) || (t[i] = r[i]);
  }
  return e.someProp("nodeViews", n), e.someProp("markViews", n), t;
}
function kOe(e, t) {
  let n = 0, r = 0;
  for (let i in e) {
    if (e[i] != t[i])
      return !0;
    n++;
  }
  for (let i in t)
    r++;
  return n != r;
}
function $5(e) {
  if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var zc = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, bx = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, COe = typeof navigator < "u" && /Mac/.test(navigator.platform), EOe = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var oi = 0; oi < 10; oi++) zc[48 + oi] = zc[96 + oi] = String(oi);
for (var oi = 1; oi <= 24; oi++) zc[oi + 111] = "F" + oi;
for (var oi = 65; oi <= 90; oi++)
  zc[oi] = String.fromCharCode(oi + 32), bx[oi] = String.fromCharCode(oi);
for (var mE in zc) bx.hasOwnProperty(mE) || (bx[mE] = zc[mE]);
function _Oe(e) {
  var t = COe && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || EOe && e.shiftKey && e.key && e.key.length == 1 || e.key == "Unidentified", n = !t && e.key || (e.shiftKey ? bx : zc)[e.keyCode] || e.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const TOe = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), AOe = typeof navigator < "u" && /Win/.test(navigator.platform);
function MOe(e) {
  let t = e.split(/-(?!$)/), n = t[t.length - 1];
  n == "Space" && (n = " ");
  let r, i, o, s;
  for (let a = 0; a < t.length - 1; a++) {
    let c = t[a];
    if (/^(cmd|meta|m)$/i.test(c))
      s = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      i = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      TOe ? s = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return r && (n = "Alt-" + n), i && (n = "Ctrl-" + n), s && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function NOe(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in e)
    t[MOe(n)] = e[n];
  return t;
}
function gE(e, t, n = !0) {
  return t.altKey && (e = "Alt-" + e), t.ctrlKey && (e = "Ctrl-" + e), t.metaKey && (e = "Meta-" + e), n && t.shiftKey && (e = "Shift-" + e), e;
}
function ROe(e) {
  return new Yn({ props: { handleKeyDown: dq(e) } });
}
function dq(e) {
  let t = NOe(e);
  return function(n, r) {
    let i = _Oe(r), o, s = t[gE(i, r)];
    if (s && s(n.state, n.dispatch, n))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let a = t[gE(i, r, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(AOe && r.ctrlKey && r.altKey) && (o = zc[r.keyCode]) && o != i) {
        let a = t[gE(o, r)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
var OOe = Object.defineProperty, JN = (e, t) => {
  for (var n in t)
    OOe(e, n, { get: t[n], enumerable: !0 });
};
function h1(e) {
  const { state: t, transaction: n } = e;
  let { selection: r } = n, { doc: i } = n, { storedMarks: o } = n;
  return {
    ...t,
    apply: t.apply.bind(t),
    applyTransaction: t.applyTransaction.bind(t),
    plugins: t.plugins,
    schema: t.schema,
    reconfigure: t.reconfigure.bind(t),
    toJSON: t.toJSON.bind(t),
    get storedMarks() {
      return o;
    },
    get selection() {
      return r;
    },
    get doc() {
      return i;
    },
    get tr() {
      return r = n.selection, i = n.doc, o = n.storedMarks, n;
    }
  };
}
var p1 = class {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: t, state: n } = this, { view: r } = t, { tr: i } = n, o = this.buildProps(i);
    return Object.fromEntries(
      Object.entries(e).map(([s, a]) => [s, (...u) => {
        const f = a(...u)(o);
        return !i.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(i), f;
      }])
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, t = !0) {
    const { rawCommands: n, editor: r, state: i } = this, { view: o } = r, s = [], a = !!e, c = e || i.tr, u = () => (!a && t && !c.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(c), s.every((h) => h === !0)), f = {
      ...Object.fromEntries(
        Object.entries(n).map(([h, m]) => [h, (...b) => {
          const x = this.buildProps(c, t), w = m(...b)(x);
          return s.push(w), f;
        }])
      ),
      run: u
    };
    return f;
  }
  createCan(e) {
    const { rawCommands: t, state: n } = this, r = !1, i = e || n.tr, o = this.buildProps(i, r);
    return {
      ...Object.fromEntries(
        Object.entries(t).map(([a, c]) => [a, (...u) => c(...u)({ ...o, dispatch: void 0 })])
      ),
      chain: () => this.createChain(i, r)
    };
  }
  buildProps(e, t = !0) {
    const { rawCommands: n, editor: r, state: i } = this, { view: o } = r, s = {
      tr: e,
      editor: r,
      view: o,
      state: h1({
        state: i,
        transaction: e
      }),
      dispatch: t ? () => {
      } : void 0,
      chain: () => this.createChain(e, t),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(
          Object.entries(n).map(([a, c]) => [a, (...u) => c(...u)(s)])
        );
      }
    };
    return s;
  }
}, fq = {};
JN(fq, {
  blur: () => POe,
  clearContent: () => DOe,
  clearNodes: () => IOe,
  command: () => jOe,
  createParagraphNear: () => zOe,
  cut: () => LOe,
  deleteCurrentNode: () => BOe,
  deleteNode: () => $Oe,
  deleteRange: () => UOe,
  deleteSelection: () => FOe,
  enter: () => VOe,
  exitCode: () => HOe,
  extendMarkRange: () => WOe,
  first: () => qOe,
  focus: () => KOe,
  forEach: () => ZOe,
  insertContent: () => YOe,
  insertContentAt: () => QOe,
  joinBackward: () => nPe,
  joinDown: () => tPe,
  joinForward: () => rPe,
  joinItemBackward: () => iPe,
  joinItemForward: () => oPe,
  joinTextblockBackward: () => sPe,
  joinTextblockForward: () => aPe,
  joinUp: () => ePe,
  keyboardShortcut: () => cPe,
  lift: () => uPe,
  liftEmptyBlock: () => dPe,
  liftListItem: () => fPe,
  newlineInCode: () => hPe,
  resetAttributes: () => pPe,
  scrollIntoView: () => mPe,
  selectAll: () => gPe,
  selectNodeBackward: () => yPe,
  selectNodeForward: () => vPe,
  selectParentNode: () => bPe,
  selectTextblockEnd: () => xPe,
  selectTextblockStart: () => wPe,
  setContent: () => SPe,
  setMark: () => FPe,
  setMeta: () => VPe,
  setNode: () => HPe,
  setNodeSelection: () => WPe,
  setTextDirection: () => qPe,
  setTextSelection: () => GPe,
  sinkListItem: () => KPe,
  splitBlock: () => ZPe,
  splitListItem: () => YPe,
  toggleList: () => XPe,
  toggleMark: () => JPe,
  toggleNode: () => QPe,
  toggleWrap: () => eDe,
  undoInputRule: () => tDe,
  unsetAllMarks: () => nDe,
  unsetMark: () => rDe,
  unsetTextDirection: () => iDe,
  updateAttributes: () => oDe,
  wrapIn: () => sDe,
  wrapInList: () => aDe
});
var POe = () => ({ editor: e, view: t }) => (requestAnimationFrame(() => {
  var n;
  e.isDestroyed || (t.dom.blur(), (n = window?.getSelection()) == null || n.removeAllRanges());
}), !0), DOe = (e = !0) => ({ commands: t }) => t.setContent("", { emitUpdate: e }), IOe = () => ({ state: e, tr: t, dispatch: n }) => {
  const { selection: r } = t, { ranges: i } = r;
  return n && i.forEach(({ $from: o, $to: s }) => {
    e.doc.nodesBetween(o.pos, s.pos, (a, c) => {
      if (a.type.isText)
        return;
      const { doc: u, mapping: f } = t, h = u.resolve(f.map(c)), m = u.resolve(f.map(c + a.nodeSize)), g = h.blockRange(m);
      if (!g)
        return;
      const b = tp(g);
      if (a.type.isTextblock) {
        const { defaultType: x } = h.parent.contentMatchAt(h.index());
        t.setNodeMarkup(g.start, x);
      }
      (b || b === 0) && t.lift(g, b);
    });
  }), !0;
}, jOe = (e) => (t) => e(t), zOe = () => ({ state: e, dispatch: t }) => _W(e, t), LOe = (e, t) => ({ editor: n, tr: r }) => {
  const { state: i } = n, o = i.doc.slice(e.from, e.to);
  r.deleteRange(e.from, e.to);
  const s = r.mapping.map(t);
  return r.insert(s, o.content), r.setSelection(new Ct(r.doc.resolve(Math.max(s - 1, 0)))), !0;
}, BOe = () => ({ tr: e, dispatch: t }) => {
  const { selection: n } = e, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const i = e.selection.$anchor;
  for (let o = i.depth; o > 0; o -= 1)
    if (i.node(o).type === r.type) {
      if (t) {
        const a = i.before(o), c = i.after(o);
        e.delete(a, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
};
function Tr(e, t) {
  if (typeof e == "string") {
    if (!t.nodes[e])
      throw Error(`There is no node type named '${e}'. Maybe you forgot to add the extension?`);
    return t.nodes[e];
  }
  return e;
}
var $Oe = (e) => ({ tr: t, state: n, dispatch: r }) => {
  const i = Tr(e, n.schema), o = t.selection.$anchor;
  for (let s = o.depth; s > 0; s -= 1)
    if (o.node(s).type === i) {
      if (r) {
        const c = o.before(s), u = o.after(s);
        t.delete(c, u).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, UOe = (e) => ({ tr: t, dispatch: n }) => {
  const { from: r, to: i } = e;
  return n && t.delete(r, i), !0;
}, FOe = () => ({ state: e, dispatch: t }) => LN(e, t), VOe = () => ({ commands: e }) => e.keyboardShortcut("Enter"), HOe = () => ({ state: e, dispatch: t }) => TRe(e, t);
function QN(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
function xx(e, t, n = { strict: !0 }) {
  const r = Object.keys(t);
  return r.length ? r.every((i) => n.strict ? t[i] === e[i] : QN(t[i]) ? t[i].test(e[i]) : t[i] === e[i]) : !0;
}
function hq(e, t, n = {}) {
  return e.find((r) => r.type === t && xx(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((i) => [i, r.attrs[i]])),
    n
  ));
}
function U5(e, t, n = {}) {
  return !!hq(e, t, n);
}
function eR(e, t, n) {
  var r;
  if (!e || !t)
    return;
  let i = e.parent.childAfter(e.parentOffset);
  if ((!i.node || !i.node.marks.some((f) => f.type === t)) && (i = e.parent.childBefore(e.parentOffset)), !i.node || !i.node.marks.some((f) => f.type === t) || (n = n || ((r = i.node.marks[0]) == null ? void 0 : r.attrs), !hq([...i.node.marks], t, n)))
    return;
  let s = i.index, a = e.start() + i.offset, c = s + 1, u = a + i.node.nodeSize;
  for (; s > 0 && U5([...e.parent.child(s - 1).marks], t, n); )
    s -= 1, a -= e.parent.child(s).nodeSize;
  for (; c < e.parent.childCount && U5([...e.parent.child(c).marks], t, n); )
    u += e.parent.child(c).nodeSize, c += 1;
  return {
    from: a,
    to: u
  };
}
function ul(e, t) {
  if (typeof e == "string") {
    if (!t.marks[e])
      throw Error(`There is no mark type named '${e}'. Maybe you forgot to add the extension?`);
    return t.marks[e];
  }
  return e;
}
var WOe = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const o = ul(e, r.schema), { doc: s, selection: a } = n, { $from: c, from: u, to: f } = a;
  if (i) {
    const h = eR(c, o, t);
    if (h && h.from <= u && h.to >= f) {
      const m = Ct.create(s, h.from, h.to);
      n.setSelection(m);
    }
  }
  return !0;
}, qOe = (e) => (t) => {
  const n = typeof e == "function" ? e(t) : e;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](t))
      return !0;
  return !1;
};
function pq(e) {
  return e instanceof Ct;
}
function Vu(e = 0, t = 0, n = 0) {
  return Math.min(Math.max(e, t), n);
}
function mq(e, t = null) {
  if (!t)
    return null;
  const n = Lt.atStart(e), r = Lt.atEnd(e);
  if (t === "start" || t === !0)
    return n;
  if (t === "end")
    return r;
  const i = n.from, o = r.to;
  return t === "all" ? Ct.create(e, Vu(0, i, o), Vu(e.content.size, i, o)) : Ct.create(e, Vu(t, i, o), Vu(t, i, o));
}
function FT() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function Ig() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function GOe() {
  return typeof navigator < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1;
}
var KOe = (e = null, t = {}) => ({ editor: n, view: r, tr: i, dispatch: o }) => {
  t = {
    scrollIntoView: !0,
    ...t
  };
  const s = () => {
    (Ig() || FT()) && r.dom.focus(), GOe() && !Ig() && !FT() && r.dom.focus({ preventScroll: !0 }), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), t?.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  try {
    if (r.hasFocus() && e === null || e === !1)
      return !0;
  } catch {
    return !1;
  }
  if (o && e === null && !pq(n.state.selection))
    return s(), !0;
  const a = mq(i.doc, e) || n.state.selection, c = n.state.selection.eq(a);
  return o && (c || i.setSelection(a), c && i.storedMarks && i.setStoredMarks(i.storedMarks), s()), !0;
}, ZOe = (e, t) => (n) => e.every((r, i) => t(r, { ...n, index: i })), YOe = (e, t) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, e, t), gq = (e) => {
  const t = e.childNodes;
  for (let n = t.length - 1; n >= 0; n -= 1) {
    const r = t[n];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? e.removeChild(r) : r.nodeType === 1 && gq(r);
  }
  return e;
};
function f0(e) {
  if (typeof window > "u")
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  const t = `<body>${e}</body>`, n = new window.DOMParser().parseFromString(t, "text/html").body;
  return gq(n);
}
function jg(e, t, n) {
  if (e instanceof Sc || e instanceof $e)
    return e;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const r = typeof e == "object" && e !== null, i = typeof e == "string";
  if (r)
    try {
      if (Array.isArray(e) && e.length > 0)
        return $e.fromArray(e.map((a) => t.nodeFromJSON(a)));
      const s = t.nodeFromJSON(e);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (o) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: o });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", e, "Error:", o), jg("", t, n);
    }
  if (i) {
    if (n.errorOnInvalidContent) {
      let s = !1, a = "";
      const c = new QH({
        topNode: t.spec.topNode,
        marks: t.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: t.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (u) => (s = !0, a = typeof u == "string" ? u : u.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? kc.fromSchema(c).parseSlice(f0(e), n.parseOptions) : kc.fromSchema(c).parse(f0(e), n.parseOptions), n.errorOnInvalidContent && s)
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${a}`)
        });
    }
    const o = kc.fromSchema(t);
    return n.slice ? o.parseSlice(f0(e), n.parseOptions).content : o.parse(f0(e), n.parseOptions);
  }
  return jg("", t, n);
}
function XOe(e, t, n) {
  const r = e.steps.length - 1;
  if (r < t)
    return;
  const i = e.steps[r];
  if (!(i instanceof Vr || i instanceof qr))
    return;
  const o = e.mapping.maps[r];
  let s = 0;
  o.forEach((a, c, u, f) => {
    s === 0 && (s = f);
  }), e.setSelection(Lt.near(e.doc.resolve(s), n));
}
var JOe = (e) => !("type" in e), QOe = (e, t, n) => ({ tr: r, dispatch: i, editor: o }) => {
  var s;
  if (i) {
    n = {
      parseOptions: o.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    const c = (w) => {
      o.emit("contentError", {
        editor: o,
        error: w,
        disableCollaboration: () => {
          "collaboration" in o.storage && typeof o.storage.collaboration == "object" && o.storage.collaboration && (o.storage.collaboration.isDisabled = !0);
        }
      });
    }, u = {
      preserveWhitespace: "full",
      ...n.parseOptions
    };
    if (!n.errorOnInvalidContent && !o.options.enableContentCheck && o.options.emitContentError)
      try {
        jg(t, o.schema, {
          parseOptions: u,
          errorOnInvalidContent: !0
        });
      } catch (w) {
        c(w);
      }
    try {
      a = jg(t, o.schema, {
        parseOptions: u,
        errorOnInvalidContent: (s = n.errorOnInvalidContent) != null ? s : o.options.enableContentCheck
      });
    } catch (w) {
      return c(w), !1;
    }
    let { from: f, to: h } = typeof e == "number" ? { from: e, to: e } : { from: e.from, to: e.to }, m = !0, g = !0;
    if ((JOe(a) ? a : [a]).forEach((w) => {
      w.check(), m = m ? w.isText && w.marks.length === 0 : !1, g = g ? w.isBlock : !1;
    }), f === h && g) {
      const { parent: w } = r.doc.resolve(f);
      w.isTextblock && !w.type.spec.code && !w.childCount && (f -= 1, h += 1);
    }
    let x;
    if (m) {
      if (Array.isArray(t))
        x = t.map((w) => w.text || "").join("");
      else if (t instanceof $e) {
        let w = "";
        t.forEach((S) => {
          S.text && (w += S.text);
        }), x = w;
      } else typeof t == "object" && t && t.text ? x = t.text : x = t;
      r.insertText(x, f, h);
    } else {
      x = a;
      const w = r.doc.resolve(f), S = w.node(), _ = w.parentOffset === 0, M = S.isText || S.isTextblock, N = S.content.size > 0;
      _ && M && N && (f = Math.max(0, f - 1)), r.replaceWith(f, h, x);
    }
    n.updateSelection && XOe(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: f, text: x }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: f, text: x });
  }
  return !0;
}, ePe = () => ({ state: e, dispatch: t }) => CRe(e, t), tPe = () => ({ state: e, dispatch: t }) => ERe(e, t), nPe = () => ({ state: e, dispatch: t }) => bW(e, t), rPe = () => ({ state: e, dispatch: t }) => kW(e, t), iPe = () => ({ state: e, dispatch: t, tr: n }) => {
  try {
    const r = a1(e.doc, e.selection.$from.pos, -1);
    return r == null ? !1 : (n.join(r, 2), t && t(n), !0);
  } catch {
    return !1;
  }
}, oPe = () => ({ state: e, dispatch: t, tr: n }) => {
  try {
    const r = a1(e.doc, e.selection.$from.pos, 1);
    return r == null ? !1 : (n.join(r, 2), t && t(n), !0);
  } catch {
    return !1;
  }
}, sPe = () => ({ state: e, dispatch: t }) => SRe(e, t), aPe = () => ({ state: e, dispatch: t }) => kRe(e, t);
function yq() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function lPe(e) {
  const t = e.split(/-(?!$)/);
  let n = t[t.length - 1];
  n === "Space" && (n = " ");
  let r, i, o, s;
  for (let a = 0; a < t.length - 1; a += 1) {
    const c = t[a];
    if (/^(cmd|meta|m)$/i.test(c))
      s = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      i = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      Ig() || yq() ? s = !0 : i = !0;
    else
      throw new Error(`Unrecognized modifier name: ${c}`);
  }
  return r && (n = `Alt-${n}`), i && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), o && (n = `Shift-${n}`), n;
}
var cPe = (e) => ({ editor: t, view: n, tr: r, dispatch: i }) => {
  const o = lPe(e).split(/-(?!$)/), s = o.find((u) => !["Alt", "Ctrl", "Meta", "Shift"].includes(u)), a = new KeyboardEvent("keydown", {
    key: s === "Space" ? " " : s,
    altKey: o.includes("Alt"),
    ctrlKey: o.includes("Ctrl"),
    metaKey: o.includes("Meta"),
    shiftKey: o.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), c = t.captureTransaction(() => {
    n.someProp("handleKeyDown", (u) => u(n, a));
  });
  return c?.steps.forEach((u) => {
    const f = u.map(r.mapping);
    f && i && r.maybeStep(f);
  }), !0;
};
function Lc(e, t, n = {}) {
  const { from: r, to: i, empty: o } = e.selection, s = t ? Tr(t, e.schema) : null, a = [];
  e.doc.nodesBetween(r, i, (h, m) => {
    if (h.isText)
      return;
    const g = Math.max(r, m), b = Math.min(i, m + h.nodeSize);
    a.push({
      node: h,
      from: g,
      to: b
    });
  });
  const c = i - r, u = a.filter((h) => s ? s.name === h.node.type.name : !0).filter((h) => xx(h.node.attrs, n, { strict: !1 }));
  return o ? !!u.length : u.reduce((h, m) => h + m.to - m.from, 0) >= c;
}
var uPe = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const i = Tr(e, n.schema);
  return Lc(n, i, t) ? _Re(n, r) : !1;
}, dPe = () => ({ state: e, dispatch: t }) => TW(e, t), fPe = (e) => ({ state: t, dispatch: n }) => {
  const r = Tr(e, t.schema);
  return LRe(r)(t, n);
}, hPe = () => ({ state: e, dispatch: t }) => EW(e, t);
function m1(e, t) {
  return t.nodes[e] ? "node" : t.marks[e] ? "mark" : null;
}
function F5(e, t) {
  const n = typeof t == "string" ? [t] : t;
  return Object.keys(e).reduce((r, i) => (n.includes(i) || (r[i] = e[i]), r), {});
}
var pPe = (e, t) => ({ tr: n, state: r, dispatch: i }) => {
  let o = null, s = null;
  const a = m1(
    typeof e == "string" ? e : e.name,
    r.schema
  );
  if (!a)
    return !1;
  a === "node" && (o = Tr(e, r.schema)), a === "mark" && (s = ul(e, r.schema));
  let c = !1;
  return n.selection.ranges.forEach((u) => {
    r.doc.nodesBetween(u.$from.pos, u.$to.pos, (f, h) => {
      o && o === f.type && (c = !0, i && n.setNodeMarkup(h, void 0, F5(f.attrs, t))), s && f.marks.length && f.marks.forEach((m) => {
        s === m.type && (c = !0, i && n.addMark(h, h + f.nodeSize, s.create(F5(m.attrs, t))));
      });
    });
  }), c;
}, mPe = () => ({ tr: e, dispatch: t }) => (t && e.scrollIntoView(), !0), gPe = () => ({ tr: e, dispatch: t }) => {
  if (t) {
    const n = new bo(e.doc);
    e.setSelection(n);
  }
  return !0;
}, yPe = () => ({ state: e, dispatch: t }) => wW(e, t), vPe = () => ({ state: e, dispatch: t }) => CW(e, t), bPe = () => ({ state: e, dispatch: t }) => NRe(e, t), xPe = () => ({ state: e, dispatch: t }) => PRe(e, t), wPe = () => ({ state: e, dispatch: t }) => ORe(e, t);
function VT(e, t, n = {}, r = {}) {
  return jg(e, t, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
var SPe = (e, { errorOnInvalidContent: t, emitUpdate: n = !0, parseOptions: r = {} } = {}) => ({ editor: i, tr: o, dispatch: s, commands: a }) => {
  const { doc: c } = o;
  if (r.preserveWhitespace !== "full") {
    const u = VT(e, i.schema, r, {
      errorOnInvalidContent: t ?? i.options.enableContentCheck
    });
    return s && o.replaceWith(0, c.content.size, u).setMeta("preventUpdate", !n), !0;
  }
  return s && o.setMeta("preventUpdate", !n), a.insertContentAt({ from: 0, to: c.content.size }, e, {
    parseOptions: r,
    errorOnInvalidContent: t ?? i.options.enableContentCheck
  });
};
function vq(e, t) {
  const n = ul(t, e.schema), { from: r, to: i, empty: o } = e.selection, s = [];
  o ? (e.storedMarks && s.push(...e.storedMarks), s.push(...e.selection.$head.marks())) : e.doc.nodesBetween(r, i, (c) => {
    s.push(...c.marks);
  });
  const a = s.find((c) => c.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function bq(e, t) {
  const n = new mW(e);
  return t.forEach((r) => {
    r.steps.forEach((i) => {
      n.step(i);
    });
  }), n;
}
function kPe(e) {
  for (let t = 0; t < e.edgeCount; t += 1) {
    const { type: n } = e.edge(t);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function CPe(e, t, n) {
  const r = [];
  return e.nodesBetween(t.from, t.to, (i, o) => {
    n(i) && r.push({
      node: i,
      pos: o
    });
  }), r;
}
function EPe(e, t) {
  for (let n = e.depth; n > 0; n -= 1) {
    const r = e.node(n);
    if (t(r))
      return {
        pos: n > 0 ? e.before(n) : 0,
        start: e.start(n),
        depth: n,
        node: r
      };
  }
}
function g1(e) {
  return (t) => EPe(t.$from, e);
}
function ht(e, t, n) {
  return e.config[t] === void 0 && e.parent ? ht(e.parent, t, n) : typeof e.config[t] == "function" ? e.config[t].bind({
    ...n,
    parent: e.parent ? ht(e.parent, t, n) : null
  }) : e.config[t];
}
function tR(e) {
  return e.map((t) => {
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    }, r = ht(t, "addExtensions", n);
    return r ? [t, ...tR(r())] : t;
  }).flat(10);
}
function nR(e, t) {
  const n = Cd.fromSchema(t).serializeFragment(e), i = document.implementation.createHTMLDocument().createElement("div");
  return i.appendChild(n), i.innerHTML;
}
function xq(e) {
  return typeof e == "function";
}
function gn(e, t = void 0, ...n) {
  return xq(e) ? t ? e.bind(t)(...n) : e(...n) : e;
}
function _Pe(e = {}) {
  return Object.keys(e).length === 0 && e.constructor === Object;
}
function Mh(e) {
  const t = e.filter((i) => i.type === "extension"), n = e.filter((i) => i.type === "node"), r = e.filter((i) => i.type === "mark");
  return {
    baseExtensions: t,
    nodeExtensions: n,
    markExtensions: r
  };
}
function wq(e) {
  const t = [], { nodeExtensions: n, markExtensions: r } = Mh(e), i = [...n, ...r], o = {
    default: null,
    validate: void 0,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return e.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage,
      extensions: i
    }, c = ht(
      s,
      "addGlobalAttributes",
      a
    );
    if (!c)
      return;
    c().forEach((f) => {
      f.types.forEach((h) => {
        Object.entries(f.attributes).forEach(([m, g]) => {
          t.push({
            type: h,
            name: m,
            attribute: {
              ...o,
              ...g
            }
          });
        });
      });
    });
  }), i.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage
    }, c = ht(
      s,
      "addAttributes",
      a
    );
    if (!c)
      return;
    const u = c();
    Object.entries(u).forEach(([f, h]) => {
      const m = {
        ...o,
        ...h
      };
      typeof m?.default == "function" && (m.default = m.default()), m?.isRequired && m?.default === void 0 && delete m.default, t.push({
        type: s.name,
        name: f,
        attribute: m
      });
    });
  }), t;
}
function sr(...e) {
  return e.filter((t) => !!t).reduce((t, n) => {
    const r = { ...t };
    return Object.entries(n).forEach(([i, o]) => {
      if (!r[i]) {
        r[i] = o;
        return;
      }
      if (i === "class") {
        const a = o ? String(o).split(" ") : [], c = r[i] ? r[i].split(" ") : [], u = a.filter((f) => !c.includes(f));
        r[i] = [...c, ...u].join(" ");
      } else if (i === "style") {
        const a = o ? o.split(";").map((f) => f.trim()).filter(Boolean) : [], c = r[i] ? r[i].split(";").map((f) => f.trim()).filter(Boolean) : [], u = /* @__PURE__ */ new Map();
        c.forEach((f) => {
          const [h, m] = f.split(":").map((g) => g.trim());
          u.set(h, m);
        }), a.forEach((f) => {
          const [h, m] = f.split(":").map((g) => g.trim());
          u.set(h, m);
        }), r[i] = Array.from(u.entries()).map(([f, h]) => `${f}: ${h}`).join("; ");
      } else
        r[i] = o;
    }), r;
  }, {});
}
function Nh(e, t) {
  return t.filter((n) => n.type === e.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(e.attrs) || {} : {
    [n.name]: e.attrs[n.name]
  }).reduce((n, r) => sr(n, r), {});
}
function TPe(e) {
  return typeof e != "string" ? e : e.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(e) : e === "true" ? !0 : e === "false" ? !1 : e;
}
function V5(e, t) {
  return "style" in e ? e : {
    ...e,
    getAttrs: (n) => {
      const r = e.getAttrs ? e.getAttrs(n) : e.attrs;
      if (r === !1)
        return !1;
      const i = t.reduce((o, s) => {
        const a = s.attribute.parseHTML ? s.attribute.parseHTML(n) : TPe(n.getAttribute(s.name));
        return a == null ? o : {
          ...o,
          [s.name]: a
        };
      }, {});
      return { ...r, ...i };
    }
  };
}
function H5(e) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(e).filter(([t, n]) => t === "attrs" && _Pe(n) ? !1 : n != null)
  );
}
function W5(e) {
  var t, n;
  const r = {};
  return !((t = e?.attribute) != null && t.isRequired) && "default" in (e?.attribute || {}) && (r.default = e.attribute.default), ((n = e?.attribute) == null ? void 0 : n.validate) !== void 0 && (r.validate = e.attribute.validate), [e.name, r];
}
function APe(e, t) {
  var n;
  const r = wq(e), { nodeExtensions: i, markExtensions: o } = Mh(e), s = (n = i.find((u) => ht(u, "topNode"))) == null ? void 0 : n.name, a = Object.fromEntries(
    i.map((u) => {
      const f = r.filter((S) => S.type === u.name), h = {
        name: u.name,
        options: u.options,
        storage: u.storage,
        editor: t
      }, m = e.reduce((S, _) => {
        const M = ht(_, "extendNodeSchema", h);
        return {
          ...S,
          ...M ? M(u) : {}
        };
      }, {}), g = H5({
        ...m,
        content: gn(ht(u, "content", h)),
        marks: gn(ht(u, "marks", h)),
        group: gn(ht(u, "group", h)),
        inline: gn(ht(u, "inline", h)),
        atom: gn(ht(u, "atom", h)),
        selectable: gn(ht(u, "selectable", h)),
        draggable: gn(ht(u, "draggable", h)),
        code: gn(ht(u, "code", h)),
        whitespace: gn(ht(u, "whitespace", h)),
        linebreakReplacement: gn(
          ht(u, "linebreakReplacement", h)
        ),
        defining: gn(ht(u, "defining", h)),
        isolating: gn(ht(u, "isolating", h)),
        attrs: Object.fromEntries(f.map(W5))
      }), b = gn(ht(u, "parseHTML", h));
      b && (g.parseDOM = b.map(
        (S) => V5(S, f)
      ));
      const x = ht(u, "renderHTML", h);
      x && (g.toDOM = (S) => x({
        node: S,
        HTMLAttributes: Nh(S, f)
      }));
      const w = ht(u, "renderText", h);
      return w && (g.toText = w), [u.name, g];
    })
  ), c = Object.fromEntries(
    o.map((u) => {
      const f = r.filter((w) => w.type === u.name), h = {
        name: u.name,
        options: u.options,
        storage: u.storage,
        editor: t
      }, m = e.reduce((w, S) => {
        const _ = ht(S, "extendMarkSchema", h);
        return {
          ...w,
          ..._ ? _(u) : {}
        };
      }, {}), g = H5({
        ...m,
        inclusive: gn(ht(u, "inclusive", h)),
        excludes: gn(ht(u, "excludes", h)),
        group: gn(ht(u, "group", h)),
        spanning: gn(ht(u, "spanning", h)),
        code: gn(ht(u, "code", h)),
        attrs: Object.fromEntries(f.map(W5))
      }), b = gn(ht(u, "parseHTML", h));
      b && (g.parseDOM = b.map(
        (w) => V5(w, f)
      ));
      const x = ht(u, "renderHTML", h);
      return x && (g.toDOM = (w) => x({
        mark: w,
        HTMLAttributes: Nh(w, f)
      })), [u.name, g];
    })
  );
  return new QH({
    topNode: s,
    nodes: a,
    marks: c
  });
}
function MPe(e) {
  const t = e.filter((n, r) => e.indexOf(n) !== r);
  return Array.from(new Set(t));
}
function wx(e) {
  return e.sort((n, r) => {
    const i = ht(n, "priority") || 100, o = ht(r, "priority") || 100;
    return i > o ? -1 : i < o ? 1 : 0;
  });
}
function Sq(e) {
  const t = wx(tR(e)), n = MPe(t.map((r) => r.name));
  return n.length && console.warn(
    `[tiptap warn]: Duplicate extension names found: [${n.map((r) => `'${r}'`).join(", ")}]. This can lead to issues.`
  ), t;
}
function kq(e, t, n) {
  const { from: r, to: i } = t, { blockSeparator: o = `

`, textSerializers: s = {} } = n || {};
  let a = "";
  return e.nodesBetween(r, i, (c, u, f, h) => {
    var m;
    c.isBlock && u > r && (a += o);
    const g = s?.[c.type.name];
    if (g)
      return f && (a += g({
        node: c,
        pos: u,
        parent: f,
        index: h,
        range: t
      })), !1;
    c.isText && (a += (m = c?.text) == null ? void 0 : m.slice(Math.max(r, u) - u, i - u));
  }), a;
}
function NPe(e, t) {
  const n = {
    from: 0,
    to: e.content.size
  };
  return kq(e, n, t);
}
function Cq(e) {
  return Object.fromEntries(
    Object.entries(e.nodes).filter(([, t]) => t.spec.toText).map(([t, n]) => [t, n.spec.toText])
  );
}
function RPe(e, t) {
  const n = Tr(t, e.schema), { from: r, to: i } = e.selection, o = [];
  e.doc.nodesBetween(r, i, (a) => {
    o.push(a);
  });
  const s = o.reverse().find((a) => a.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function Eq(e, t) {
  const n = m1(
    typeof t == "string" ? t : t.name,
    e.schema
  );
  return n === "node" ? RPe(e, t) : n === "mark" ? vq(e, t) : {};
}
function OPe(e, t = JSON.stringify) {
  const n = {};
  return e.filter((r) => {
    const i = t(r);
    return Object.prototype.hasOwnProperty.call(n, i) ? !1 : n[i] = !0;
  });
}
function PPe(e) {
  const t = OPe(e);
  return t.length === 1 ? t : t.filter((n, r) => !t.filter((o, s) => s !== r).some((o) => n.oldRange.from >= o.oldRange.from && n.oldRange.to <= o.oldRange.to && n.newRange.from >= o.newRange.from && n.newRange.to <= o.newRange.to));
}
function _q(e) {
  const { mapping: t, steps: n } = e, r = [];
  return t.maps.forEach((i, o) => {
    const s = [];
    if (i.ranges.length)
      i.forEach((a, c) => {
        s.push({ from: a, to: c });
      });
    else {
      const { from: a, to: c } = n[o];
      if (a === void 0 || c === void 0)
        return;
      s.push({ from: a, to: c });
    }
    s.forEach(({ from: a, to: c }) => {
      const u = t.slice(o).map(a, -1), f = t.slice(o).map(c), h = t.invert().map(u, -1), m = t.invert().map(f);
      r.push({
        oldRange: {
          from: h,
          to: m
        },
        newRange: {
          from: u,
          to: f
        }
      });
    });
  }), PPe(r);
}
function rR(e, t, n) {
  const r = [];
  return e === t ? n.resolve(e).marks().forEach((i) => {
    const o = n.resolve(e), s = eR(o, i.type);
    s && r.push({
      mark: i,
      ...s
    });
  }) : n.nodesBetween(e, t, (i, o) => {
    !i || i?.nodeSize === void 0 || r.push(
      ...i.marks.map((s) => ({
        from: o,
        to: o + i.nodeSize,
        mark: s
      }))
    );
  }), r;
}
var DPe = (e, t, n, r = 20) => {
  const i = e.doc.resolve(n);
  let o = r, s = null;
  for (; o > 0 && s === null; ) {
    const a = i.node(o);
    a?.type.name === t ? s = a : o -= 1;
  }
  return [s, o];
};
function h0(e, t) {
  return t.nodes[e] || t.marks[e] || null;
}
function rb(e, t, n) {
  return Object.fromEntries(
    Object.entries(n).filter(([r]) => {
      const i = e.find((o) => o.type === t && o.name === r);
      return i ? i.attribute.keepOnSplit : !1;
    })
  );
}
var IPe = (e, t = 500) => {
  let n = "";
  const r = e.parentOffset;
  return e.parent.nodesBetween(Math.max(0, r - t), r, (i, o, s, a) => {
    var c, u;
    const f = ((u = (c = i.type.spec).toText) == null ? void 0 : u.call(c, {
      node: i,
      pos: o,
      parent: s,
      index: a
    })) || i.textContent || "%leaf%";
    n += i.isAtom && !i.isText ? f : f.slice(0, Math.max(0, r - o));
  }), n;
};
function HT(e, t, n = {}) {
  const { empty: r, ranges: i } = e.selection, o = t ? ul(t, e.schema) : null;
  if (r)
    return !!(e.storedMarks || e.selection.$from.marks()).filter((h) => o ? o.name === h.type.name : !0).find((h) => xx(h.attrs, n, { strict: !1 }));
  let s = 0;
  const a = [];
  if (i.forEach(({ $from: h, $to: m }) => {
    const g = h.pos, b = m.pos;
    e.doc.nodesBetween(g, b, (x, w) => {
      if (!x.isText && !x.marks.length)
        return;
      const S = Math.max(g, w), _ = Math.min(b, w + x.nodeSize), M = _ - S;
      s += M, a.push(
        ...x.marks.map((N) => ({
          mark: N,
          from: S,
          to: _
        }))
      );
    });
  }), s === 0)
    return !1;
  const c = a.filter((h) => o ? o.name === h.mark.type.name : !0).filter((h) => xx(h.mark.attrs, n, { strict: !1 })).reduce((h, m) => h + m.to - m.from, 0), u = a.filter((h) => o ? h.mark.type !== o && h.mark.type.excludes(o) : !0).reduce((h, m) => h + m.to - m.from, 0);
  return (c > 0 ? c + u : c) >= s;
}
function jPe(e, t, n = {}) {
  if (!t)
    return Lc(e, null, n) || HT(e, null, n);
  const r = m1(t, e.schema);
  return r === "node" ? Lc(e, t, n) : r === "mark" ? HT(e, t, n) : !1;
}
var zPe = (e, t) => {
  const { $from: n, $to: r, $anchor: i } = e.selection;
  if (t) {
    const o = g1((a) => a.type.name === t)(e.selection);
    if (!o)
      return !1;
    const s = e.doc.resolve(o.pos + 1);
    return i.pos + 1 === s.end();
  }
  return !(r.parentOffset < r.parent.nodeSize - 2 || n.pos !== r.pos);
}, LPe = (e) => {
  const { $from: t, $to: n } = e.selection;
  return !(t.parentOffset > 0 || t.pos !== n.pos);
};
function q5(e, t) {
  return Array.isArray(t) ? t.some((n) => (typeof n == "string" ? n : n.name) === e.name) : t;
}
function G5(e, t) {
  const { nodeExtensions: n } = Mh(t), r = n.find((s) => s.name === e);
  if (!r)
    return !1;
  const i = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, o = gn(ht(r, "group", i));
  return typeof o != "string" ? !1 : o.split(" ").includes("list");
}
function y1(e, {
  checkChildren: t = !0,
  ignoreWhitespace: n = !1
} = {}) {
  var r;
  if (n) {
    if (e.type.name === "hardBreak")
      return !0;
    if (e.isText)
      return /^\s*$/m.test((r = e.text) != null ? r : "");
  }
  if (e.isText)
    return !e.text;
  if (e.isAtom || e.isLeaf)
    return !1;
  if (e.content.childCount === 0)
    return !0;
  if (t) {
    let i = !0;
    return e.content.forEach((o) => {
      i !== !1 && (y1(o, { ignoreWhitespace: n, checkChildren: t }) || (i = !1));
    }), i;
  }
  return !1;
}
function Tq(e) {
  return e instanceof pt;
}
var Aq = class Mq {
  constructor(t) {
    this.position = t;
  }
  /**
   * Creates a MappablePosition from a JSON object.
   */
  static fromJSON(t) {
    return new Mq(t.position);
  }
  /**
   * Converts the MappablePosition to a JSON object.
   */
  toJSON() {
    return {
      position: this.position
    };
  }
};
function BPe(e, t) {
  const n = t.mapping.mapResult(e.position);
  return {
    position: new Aq(n.pos),
    mapResult: n
  };
}
function $Pe(e) {
  return new Aq(e);
}
function UPe(e, t, n) {
  var r;
  const { selection: i } = t;
  let o = null;
  if (pq(i) && (o = i.$cursor), o) {
    const a = (r = e.storedMarks) != null ? r : o.marks();
    return o.parent.type.allowsMarkType(n) && (!!n.isInSet(a) || !a.some((u) => u.type.excludes(n)));
  }
  const { ranges: s } = i;
  return s.some(({ $from: a, $to: c }) => {
    let u = a.depth === 0 ? e.doc.inlineContent && e.doc.type.allowsMarkType(n) : !1;
    return e.doc.nodesBetween(a.pos, c.pos, (f, h, m) => {
      if (u)
        return !1;
      if (f.isInline) {
        const g = !m || m.type.allowsMarkType(n), b = !!n.isInSet(f.marks) || !f.marks.some((x) => x.type.excludes(n));
        u = g && b;
      }
      return !u;
    }), u;
  });
}
var FPe = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const { selection: o } = n, { empty: s, ranges: a } = o, c = ul(e, r.schema);
  if (i)
    if (s) {
      const u = vq(r, c);
      n.addStoredMark(
        c.create({
          ...u,
          ...t
        })
      );
    } else
      a.forEach((u) => {
        const f = u.$from.pos, h = u.$to.pos;
        r.doc.nodesBetween(f, h, (m, g) => {
          const b = Math.max(g, f), x = Math.min(g + m.nodeSize, h);
          m.marks.find((S) => S.type === c) ? m.marks.forEach((S) => {
            c === S.type && n.addMark(
              b,
              x,
              c.create({
                ...S.attrs,
                ...t
              })
            );
          }) : n.addMark(b, x, c.create(t));
        });
      });
  return UPe(r, n, c);
}, VPe = (e, t) => ({ tr: n }) => (n.setMeta(e, t), !0), HPe = (e, t = {}) => ({ state: n, dispatch: r, chain: i }) => {
  const o = Tr(e, n.schema);
  let s;
  return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), o.isTextblock ? i().command(({ commands: a }) => a5(o, { ...s, ...t })(n) ? !0 : a.clearNodes()).command(({ state: a }) => a5(o, { ...s, ...t })(a, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, WPe = (e) => ({ tr: t, dispatch: n }) => {
  if (n) {
    const { doc: r } = t, i = Vu(e, 0, r.content.size), o = pt.create(r, i);
    t.setSelection(o);
  }
  return !0;
}, qPe = (e, t) => ({ tr: n, state: r, dispatch: i }) => {
  const { selection: o } = r;
  let s, a;
  return typeof t == "number" ? (s = t, a = t) : t && "from" in t && "to" in t ? (s = t.from, a = t.to) : (s = o.from, a = o.to), i && n.doc.nodesBetween(s, a, (c, u) => {
    c.isText || n.setNodeMarkup(u, void 0, {
      ...c.attrs,
      dir: e
    });
  }), !0;
}, GPe = (e) => ({ tr: t, dispatch: n }) => {
  if (n) {
    const { doc: r } = t, { from: i, to: o } = typeof e == "number" ? { from: e, to: e } : e, s = Ct.atStart(r).from, a = Ct.atEnd(r).to, c = Vu(i, s, a), u = Vu(o, s, a), f = Ct.create(r, c, u);
    t.setSelection(f);
  }
  return !0;
}, KPe = (e) => ({ state: t, dispatch: n }) => {
  const r = Tr(e, t.schema);
  return URe(r)(t, n);
};
function K5(e, t) {
  const n = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks();
  if (n) {
    const r = n.filter((i) => t?.includes(i.type.name));
    e.tr.ensureMarks(r);
  }
}
var ZPe = ({ keepMarks: e = !0 } = {}) => ({ tr: t, state: n, dispatch: r, editor: i }) => {
  const { selection: o, doc: s } = t, { $from: a, $to: c } = o, u = i.extensionManager.attributes, f = rb(u, a.node().type.name, a.node().attrs);
  if (o instanceof pt && o.node.isBlock)
    return !a.parentOffset || !Ja(s, a.pos) ? !1 : (r && (e && K5(n, i.extensionManager.splittableMarks), t.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const h = c.parentOffset === c.parent.content.size, m = a.depth === 0 ? void 0 : kPe(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let g = h && m ? [
    {
      type: m,
      attrs: f
    }
  ] : void 0, b = Ja(t.doc, t.mapping.map(a.pos), 1, g);
  if (!g && !b && Ja(t.doc, t.mapping.map(a.pos), 1, m ? [{ type: m }] : void 0) && (b = !0, g = m ? [
    {
      type: m,
      attrs: f
    }
  ] : void 0), r) {
    if (b && (o instanceof Ct && t.deleteSelection(), t.split(t.mapping.map(a.pos), 1, g), m && !h && !a.parentOffset && a.parent.type !== m)) {
      const x = t.mapping.map(a.before()), w = t.doc.resolve(x);
      a.node(-1).canReplaceWith(w.index(), w.index() + 1, m) && t.setNodeMarkup(t.mapping.map(a.before()), m);
    }
    e && K5(n, i.extensionManager.splittableMarks), t.scrollIntoView();
  }
  return b;
}, YPe = (e, t = {}) => ({ tr: n, state: r, dispatch: i, editor: o }) => {
  var s;
  const a = Tr(e, r.schema), { $from: c, $to: u } = r.selection, f = r.selection.node;
  if (f && f.isBlock || c.depth < 2 || !c.sameParent(u))
    return !1;
  const h = c.node(-1);
  if (h.type !== a)
    return !1;
  const m = o.extensionManager.attributes;
  if (c.parent.content.size === 0 && c.node(-1).childCount === c.indexAfter(-1)) {
    if (c.depth === 2 || c.node(-3).type !== a || c.index(-2) !== c.node(-2).childCount - 1)
      return !1;
    if (i) {
      let S = $e.empty;
      const _ = c.index(-1) ? 1 : c.index(-2) ? 2 : 3;
      for (let L = c.depth - _; L >= c.depth - 3; L -= 1)
        S = $e.from(c.node(L).copy(S));
      const M = (
        // eslint-disable-next-line no-nested-ternary
        c.indexAfter(-1) < c.node(-2).childCount ? 1 : c.indexAfter(-2) < c.node(-3).childCount ? 2 : 3
      ), N = {
        ...rb(m, c.node().type.name, c.node().attrs),
        ...t
      }, D = ((s = a.contentMatch.defaultType) == null ? void 0 : s.createAndFill(N)) || void 0;
      S = S.append($e.from(a.createAndFill(null, D) || void 0));
      const j = c.before(c.depth - (_ - 1));
      n.replace(j, c.after(-M), new et(S, 4 - _, 0));
      let O = -1;
      n.doc.nodesBetween(j, n.doc.content.size, (L, U) => {
        if (O > -1)
          return !1;
        L.isTextblock && L.content.size === 0 && (O = U + 1);
      }), O > -1 && n.setSelection(Ct.near(n.doc.resolve(O))), n.scrollIntoView();
    }
    return !0;
  }
  const g = u.pos === c.end() ? h.contentMatchAt(0).defaultType : null, b = {
    ...rb(m, h.type.name, h.attrs),
    ...t
  }, x = {
    ...rb(m, c.node().type.name, c.node().attrs),
    ...t
  };
  n.delete(c.pos, u.pos);
  const w = g ? [
    { type: a, attrs: b },
    { type: g, attrs: x }
  ] : [{ type: a, attrs: b }];
  if (!Ja(n.doc, c.pos, 2))
    return !1;
  if (i) {
    const { selection: S, storedMarks: _ } = r, { splittableMarks: M } = o.extensionManager, N = _ || S.$to.parentOffset && S.$from.marks();
    if (n.split(c.pos, 2, w).scrollIntoView(), !N || !i)
      return !0;
    const D = N.filter((j) => M.includes(j.type.name));
    n.ensureMarks(D);
  }
  return !0;
}, yE = (e, t) => {
  const n = g1((s) => s.type === t)(e.selection);
  if (!n)
    return !0;
  const r = e.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const i = e.doc.nodeAt(r);
  return n.node.type === i?.type && Kc(e.doc, n.pos) && e.join(n.pos), !0;
}, vE = (e, t) => {
  const n = g1((s) => s.type === t)(e.selection);
  if (!n)
    return !0;
  const r = e.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const i = e.doc.nodeAt(r);
  return n.node.type === i?.type && Kc(e.doc, r) && e.join(r), !0;
}, XPe = (e, t, n, r = {}) => ({ editor: i, tr: o, state: s, dispatch: a, chain: c, commands: u, can: f }) => {
  const { extensions: h, splittableMarks: m } = i.extensionManager, g = Tr(e, s.schema), b = Tr(t, s.schema), { selection: x, storedMarks: w } = s, { $from: S, $to: _ } = x, M = S.blockRange(_), N = w || x.$to.parentOffset && x.$from.marks();
  if (!M)
    return !1;
  const D = g1((j) => G5(j.type.name, h))(x);
  if (M.depth >= 1 && D && M.depth - D.depth <= 1) {
    if (D.node.type === g)
      return u.liftListItem(b);
    if (G5(D.node.type.name, h) && g.validContent(D.node.content) && a)
      return c().command(() => (o.setNodeMarkup(D.pos, g), !0)).command(() => yE(o, g)).command(() => vE(o, g)).run();
  }
  return !n || !N || !a ? c().command(() => f().wrapInList(g, r) ? !0 : u.clearNodes()).wrapInList(g, r).command(() => yE(o, g)).command(() => vE(o, g)).run() : c().command(() => {
    const j = f().wrapInList(g, r), O = N.filter((L) => m.includes(L.type.name));
    return o.ensureMarks(O), j ? !0 : u.clearNodes();
  }).wrapInList(g, r).command(() => yE(o, g)).command(() => vE(o, g)).run();
}, JPe = (e, t = {}, n = {}) => ({ state: r, commands: i }) => {
  const { extendEmptyMarkRange: o = !1 } = n, s = ul(e, r.schema);
  return HT(r, s, t) ? i.unsetMark(s, { extendEmptyMarkRange: o }) : i.setMark(s, t);
}, QPe = (e, t, n = {}) => ({ state: r, commands: i }) => {
  const o = Tr(e, r.schema), s = Tr(t, r.schema), a = Lc(r, o, n);
  let c;
  return r.selection.$anchor.sameParent(r.selection.$head) && (c = r.selection.$anchor.parent.attrs), a ? i.setNode(s, c) : i.setNode(o, { ...c, ...n });
}, eDe = (e, t = {}) => ({ state: n, commands: r }) => {
  const i = Tr(e, n.schema);
  return Lc(n, i, t) ? r.lift(i) : r.wrapIn(i, t);
}, tDe = () => ({ state: e, dispatch: t }) => {
  const n = e.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const i = n[r];
    let o;
    if (i.spec.isInputRules && (o = i.getState(e))) {
      if (t) {
        const s = e.tr, a = o.transform;
        for (let c = a.steps.length - 1; c >= 0; c -= 1)
          s.step(a.steps[c].invert(a.docs[c]));
        if (o.text) {
          const c = s.doc.resolve(o.from).marks();
          s.replaceWith(o.from, o.to, e.schema.text(o.text, c));
        } else
          s.delete(o.from, o.to);
      }
      return !0;
    }
  }
  return !1;
}, nDe = () => ({ tr: e, dispatch: t }) => {
  const { selection: n } = e, { empty: r, ranges: i } = n;
  return r || t && i.forEach((o) => {
    e.removeMark(o.$from.pos, o.$to.pos);
  }), !0;
}, rDe = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  var o;
  const { extendEmptyMarkRange: s = !1 } = t, { selection: a } = n, c = ul(e, r.schema), { $from: u, empty: f, ranges: h } = a;
  if (!i)
    return !0;
  if (f && s) {
    let { from: m, to: g } = a;
    const b = (o = u.marks().find((w) => w.type === c)) == null ? void 0 : o.attrs, x = eR(u, c, b);
    x && (m = x.from, g = x.to), n.removeMark(m, g, c);
  } else
    h.forEach((m) => {
      n.removeMark(m.$from.pos, m.$to.pos, c);
    });
  return n.removeStoredMark(c), !0;
}, iDe = (e) => ({ tr: t, state: n, dispatch: r }) => {
  const { selection: i } = n;
  let o, s;
  return typeof e == "number" ? (o = e, s = e) : e && "from" in e && "to" in e ? (o = e.from, s = e.to) : (o = i.from, s = i.to), r && t.doc.nodesBetween(o, s, (a, c) => {
    if (a.isText)
      return;
    const u = { ...a.attrs };
    delete u.dir, t.setNodeMarkup(c, void 0, u);
  }), !0;
}, oDe = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  let o = null, s = null;
  const a = m1(
    typeof e == "string" ? e : e.name,
    r.schema
  );
  if (!a)
    return !1;
  a === "node" && (o = Tr(e, r.schema)), a === "mark" && (s = ul(e, r.schema));
  let c = !1;
  return n.selection.ranges.forEach((u) => {
    const f = u.$from.pos, h = u.$to.pos;
    let m, g, b, x;
    n.selection.empty ? r.doc.nodesBetween(f, h, (w, S) => {
      o && o === w.type && (c = !0, b = Math.max(S, f), x = Math.min(S + w.nodeSize, h), m = S, g = w);
    }) : r.doc.nodesBetween(f, h, (w, S) => {
      S < f && o && o === w.type && (c = !0, b = Math.max(S, f), x = Math.min(S + w.nodeSize, h), m = S, g = w), S >= f && S <= h && (o && o === w.type && (c = !0, i && n.setNodeMarkup(S, void 0, {
        ...w.attrs,
        ...t
      })), s && w.marks.length && w.marks.forEach((_) => {
        if (s === _.type && (c = !0, i)) {
          const M = Math.max(S, f), N = Math.min(S + w.nodeSize, h);
          n.addMark(
            M,
            N,
            s.create({
              ..._.attrs,
              ...t
            })
          );
        }
      }));
    }), g && (m !== void 0 && i && n.setNodeMarkup(m, void 0, {
      ...g.attrs,
      ...t
    }), s && g.marks.length && g.marks.forEach((w) => {
      s === w.type && i && n.addMark(
        b,
        x,
        s.create({
          ...w.attrs,
          ...t
        })
      );
    }));
  }), c;
}, sDe = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const i = Tr(e, n.schema);
  return DRe(i, t)(n, r);
}, aDe = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const i = Tr(e, n.schema);
  return IRe(i, t)(n, r);
}, lDe = class {
  constructor() {
    this.callbacks = {};
  }
  on(e, t) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
  }
  emit(e, ...t) {
    const n = this.callbacks[e];
    return n && n.forEach((r) => r.apply(this, t)), this;
  }
  off(e, t) {
    const n = this.callbacks[e];
    return n && (t ? this.callbacks[e] = n.filter((r) => r !== t) : delete this.callbacks[e]), this;
  }
  once(e, t) {
    const n = (...r) => {
      this.off(e, n), t.apply(this, r);
    };
    return this.on(e, n);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}, v1 = class {
  constructor(e) {
    var t;
    this.find = e.find, this.handler = e.handler, this.undoable = (t = e.undoable) != null ? t : !0;
  }
}, cDe = (e, t) => {
  if (QN(t))
    return t.exec(e);
  const n = t(e);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = e, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function p0(e) {
  var t;
  const { editor: n, from: r, to: i, text: o, rules: s, plugin: a } = e, { view: c } = n;
  if (c.composing)
    return !1;
  const u = c.state.doc.resolve(r);
  if (
    // check for code node
    u.parent.type.spec.code || (t = u.nodeBefore || u.nodeAfter) != null && t.marks.find((m) => m.type.spec.code)
  )
    return !1;
  let f = !1;
  const h = IPe(u) + o;
  return s.forEach((m) => {
    if (f)
      return;
    const g = cDe(h, m.find);
    if (!g)
      return;
    const b = c.state.tr, x = h1({
      state: c.state,
      transaction: b
    }), w = {
      from: r - (g[0].length - o.length),
      to: i
    }, { commands: S, chain: _, can: M } = new p1({
      editor: n,
      state: x
    });
    m.handler({
      state: x,
      range: w,
      match: g,
      commands: S,
      chain: _,
      can: M
    }) === null || !b.steps.length || (m.undoable && b.setMeta(a, {
      transform: b,
      from: r,
      to: i,
      text: o
    }), c.dispatch(b), f = !0);
  }), f;
}
function uDe(e) {
  const { editor: t, rules: n } = e, r = new Yn({
    state: {
      init() {
        return null;
      },
      apply(i, o, s) {
        const a = i.getMeta(r);
        if (a)
          return a;
        const c = i.getMeta("applyInputRules");
        return c && setTimeout(() => {
          let { text: f } = c;
          typeof f == "string" ? f = f : f = nR($e.from(f), s.schema);
          const { from: h } = c, m = h + f.length;
          p0({
            editor: t,
            from: h,
            to: m,
            text: f,
            rules: n,
            plugin: r
          });
        }), i.selectionSet || i.docChanged ? null : o;
      }
    },
    props: {
      handleTextInput(i, o, s, a) {
        return p0({
          editor: t,
          from: o,
          to: s,
          text: a,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (i) => (setTimeout(() => {
          const { $cursor: o } = i.state.selection;
          o && p0({
            editor: t,
            from: o.pos,
            to: o.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(i, o) {
        if (o.key !== "Enter")
          return !1;
        const { $cursor: s } = i.state.selection;
        return s ? p0({
          editor: t,
          from: s.pos,
          to: s.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function dDe(e) {
  return Object.prototype.toString.call(e).slice(8, -1);
}
function m0(e) {
  return dDe(e) !== "Object" ? !1 : e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype;
}
function Nq(e, t) {
  const n = { ...e };
  return m0(e) && m0(t) && Object.keys(t).forEach((r) => {
    m0(t[r]) && m0(e[r]) ? n[r] = Nq(e[r], t[r]) : n[r] = t[r];
  }), n;
}
var iR = class {
  constructor(e = {}) {
    this.type = "extendable", this.parent = null, this.child = null, this.name = "", this.config = {
      name: this.name
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name;
  }
  get options() {
    return {
      ...gn(
        ht(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...gn(
        ht(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => Nq(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new this.constructor({ ...this.config, ...e });
    return t.parent = this, this.child = t, t.name = "name" in e ? e.name : t.parent.name, t;
  }
}, Ed = class Rq extends iR {
  constructor() {
    super(...arguments), this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new Rq(n);
  }
  static handleExit({ editor: t, mark: n }) {
    const { tr: r } = t.state, i = t.state.selection.$from;
    if (i.pos === i.end()) {
      const s = i.marks();
      if (!!!s.find((u) => u?.type.name === n.name))
        return !1;
      const c = s.find((u) => u?.type.name === n.name);
      return c && r.removeStoredMark(c), r.insertText(" ", i.pos), t.view.dispatch(r), !0;
    }
    return !1;
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
};
function fDe(e) {
  return typeof e == "number";
}
var hDe = class {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}, pDe = (e, t, n) => {
  if (QN(t))
    return [...e.matchAll(t)];
  const r = t(e, n);
  return r ? r.map((i) => {
    const o = [i.text];
    return o.index = i.index, o.input = e, o.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), o.push(i.replaceWith)), o;
  }) : [];
};
function mDe(e) {
  const { editor: t, state: n, from: r, to: i, rule: o, pasteEvent: s, dropEvent: a } = e, { commands: c, chain: u, can: f } = new p1({
    editor: t,
    state: n
  }), h = [];
  return n.doc.nodesBetween(r, i, (g, b) => {
    var x, w, S, _, M;
    if ((w = (x = g.type) == null ? void 0 : x.spec) != null && w.code || !(g.isText || g.isTextblock || g.isInline))
      return;
    const N = (M = (_ = (S = g.content) == null ? void 0 : S.size) != null ? _ : g.nodeSize) != null ? M : 0, D = Math.max(r, b), j = Math.min(i, b + N);
    if (D >= j)
      return;
    const O = g.isText ? g.text || "" : g.textBetween(D - b, j - b, void 0, "");
    pDe(O, o.find, s).forEach((U) => {
      if (U.index === void 0)
        return;
      const B = D + U.index + 1, G = B + U[0].length, Y = {
        from: n.tr.mapping.map(B),
        to: n.tr.mapping.map(G)
      }, he = o.handler({
        state: n,
        range: Y,
        match: U,
        commands: c,
        chain: u,
        can: f,
        pasteEvent: s,
        dropEvent: a
      });
      h.push(he);
    });
  }), h.every((g) => g !== null);
}
var g0 = null, gDe = (e) => {
  var t;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (t = n.clipboardData) == null || t.setData("text/html", e), n;
};
function yDe(e) {
  const { editor: t, rules: n } = e;
  let r = null, i = !1, o = !1, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const c = ({
    state: f,
    from: h,
    to: m,
    rule: g,
    pasteEvt: b
  }) => {
    const x = f.tr, w = h1({
      state: f,
      transaction: x
    });
    if (!(!mDe({
      editor: t,
      state: w,
      from: Math.max(h - 1, 0),
      to: m.b - 1,
      rule: g,
      pasteEvent: b,
      dropEvent: a
    }) || !x.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, x;
    }
  };
  return n.map((f) => new Yn({
    // we register a global drag handler to track the current drag source element
    view(h) {
      const m = (b) => {
        var x;
        r = (x = h.dom.parentElement) != null && x.contains(b.target) ? h.dom.parentElement : null, r && (g0 = t);
      }, g = () => {
        g0 && (g0 = null);
      };
      return window.addEventListener("dragstart", m), window.addEventListener("dragend", g), {
        destroy() {
          window.removeEventListener("dragstart", m), window.removeEventListener("dragend", g);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (h, m) => {
          if (o = r === h.dom.parentElement, a = m, !o) {
            const g = g0;
            g?.isEditable && setTimeout(() => {
              const b = g.state.selection;
              b && g.commands.deleteRange({ from: b.from, to: b.to });
            }, 10);
          }
          return !1;
        },
        paste: (h, m) => {
          var g;
          const b = (g = m.clipboardData) == null ? void 0 : g.getData("text/html");
          return s = m, i = !!b?.includes("data-pm-slice"), !1;
        }
      }
    },
    appendTransaction: (h, m, g) => {
      const b = h[0], x = b.getMeta("uiEvent") === "paste" && !i, w = b.getMeta("uiEvent") === "drop" && !o, S = b.getMeta("applyPasteRules"), _ = !!S;
      if (!x && !w && !_)
        return;
      if (_) {
        let { text: D } = S;
        typeof D == "string" ? D = D : D = nR($e.from(D), g.schema);
        const { from: j } = S, O = j + D.length, L = gDe(D);
        return c({
          rule: f,
          state: g,
          from: j,
          to: { b: O },
          pasteEvt: L
        });
      }
      const M = m.doc.content.findDiffStart(g.doc.content), N = m.doc.content.findDiffEnd(g.doc.content);
      if (!(!fDe(M) || !N || M === N.b))
        return c({
          rule: f,
          state: g,
          from: M,
          to: N,
          pasteEvt: s
        });
    }
  }));
}
var b1 = class {
  constructor(e, t) {
    this.splittableMarks = [], this.editor = t, this.baseExtensions = e, this.extensions = Sq(e), this.schema = APe(this.extensions, t), this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, t) => {
      const n = {
        name: t.name,
        options: t.options,
        storage: this.editor.extensionStorage[t.name],
        editor: this.editor,
        type: h0(t.name, this.schema)
      }, r = ht(t, "addCommands", n);
      return r ? {
        ...e,
        ...r()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this;
    return wx([...this.extensions].reverse()).flatMap((r) => {
      const i = {
        name: r.name,
        options: r.options,
        storage: this.editor.extensionStorage[r.name],
        editor: e,
        type: h0(r.name, this.schema)
      }, o = [], s = ht(
        r,
        "addKeyboardShortcuts",
        i
      );
      let a = {};
      if (r.type === "mark" && ht(r, "exitable", i) && (a.ArrowRight = () => Ed.handleExit({ editor: e, mark: r })), s) {
        const m = Object.fromEntries(
          Object.entries(s()).map(([g, b]) => [g, () => b({ editor: e })])
        );
        a = { ...a, ...m };
      }
      const c = ROe(a);
      o.push(c);
      const u = ht(r, "addInputRules", i);
      if (q5(r, e.options.enableInputRules) && u) {
        const m = u();
        if (m && m.length) {
          const g = uDe({
            editor: e,
            rules: m
          }), b = Array.isArray(g) ? g : [g];
          o.push(...b);
        }
      }
      const f = ht(r, "addPasteRules", i);
      if (q5(r, e.options.enablePasteRules) && f) {
        const m = f();
        if (m && m.length) {
          const g = yDe({ editor: e, rules: m });
          o.push(...g);
        }
      }
      const h = ht(
        r,
        "addProseMirrorPlugins",
        i
      );
      if (h) {
        const m = h();
        o.push(...m);
      }
      return o;
    });
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return wq(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: t } = Mh(this.extensions);
    return Object.fromEntries(
      t.filter((n) => !!ht(n, "addNodeView")).map((n) => {
        const r = this.attributes.filter((c) => c.type === n.name), i = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: e,
          type: Tr(n.name, this.schema)
        }, o = ht(n, "addNodeView", i);
        if (!o)
          return [];
        const s = o();
        if (!s)
          return [];
        const a = (c, u, f, h, m) => {
          const g = Nh(c, r);
          return s({
            // pass-through
            node: c,
            view: u,
            getPos: f,
            decorations: h,
            innerDecorations: m,
            // tiptap-specific
            editor: e,
            extension: n,
            HTMLAttributes: g
          });
        };
        return [n.name, a];
      })
    );
  }
  /**
   * Get the composed dispatchTransaction function from all extensions.
   * @param baseDispatch The base dispatch function (e.g. from the editor or user props)
   * @returns A composed dispatch function
   */
  dispatchTransaction(e) {
    const { editor: t } = this;
    return wx([...this.extensions].reverse()).reduceRight((r, i) => {
      const o = {
        name: i.name,
        options: i.options,
        storage: this.editor.extensionStorage[i.name],
        editor: t,
        type: h0(i.name, this.schema)
      }, s = ht(
        i,
        "dispatchTransaction",
        o
      );
      return s ? (a) => {
        s.call(o, { transaction: a, next: r });
      } : r;
    }, e);
  }
  get markViews() {
    const { editor: e } = this, { markExtensions: t } = Mh(this.extensions);
    return Object.fromEntries(
      t.filter((n) => !!ht(n, "addMarkView")).map((n) => {
        const r = this.attributes.filter((a) => a.type === n.name), i = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: e,
          type: ul(n.name, this.schema)
        }, o = ht(n, "addMarkView", i);
        if (!o)
          return [];
        const s = (a, c, u) => {
          const f = Nh(a, r);
          return o()({
            // pass-through
            mark: a,
            view: c,
            inline: u,
            // tiptap-specific
            editor: e,
            extension: n,
            HTMLAttributes: f,
            updateAttributes: (h) => {
              ODe(a, e, h);
            }
          });
        };
        return [n.name, s];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const e = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      e.map((t) => [t.name, t.storage])
    ), e.forEach((t) => {
      var n;
      const r = {
        name: t.name,
        options: t.options,
        storage: this.editor.extensionStorage[t.name],
        editor: this.editor,
        type: h0(t.name, this.schema)
      };
      t.type === "mark" && ((n = gn(ht(t, "keepOnSplit", r))) == null || n) && this.splittableMarks.push(t.name);
      const i = ht(t, "onBeforeCreate", r), o = ht(t, "onCreate", r), s = ht(t, "onUpdate", r), a = ht(
        t,
        "onSelectionUpdate",
        r
      ), c = ht(t, "onTransaction", r), u = ht(t, "onFocus", r), f = ht(t, "onBlur", r), h = ht(t, "onDestroy", r);
      i && this.editor.on("beforeCreate", i), o && this.editor.on("create", o), s && this.editor.on("update", s), a && this.editor.on("selectionUpdate", a), c && this.editor.on("transaction", c), u && this.editor.on("focus", u), f && this.editor.on("blur", f), h && this.editor.on("destroy", h);
    });
  }
};
b1.resolve = Sq;
b1.sort = wx;
b1.flatten = tR;
var vDe = {};
JN(vDe, {
  ClipboardTextSerializer: () => Pq,
  Commands: () => Dq,
  Delete: () => Iq,
  Drop: () => jq,
  Editable: () => zq,
  FocusEvents: () => Bq,
  Keymap: () => $q,
  Paste: () => Uq,
  Tabindex: () => Fq,
  TextDirection: () => Vq,
  focusEventsPluginKey: () => Lq
});
var pr = class Oq extends iR {
  constructor() {
    super(...arguments), this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new Oq(n);
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
}, Pq = pr.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Yn({
        key: new Ar("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: e } = this, { state: t, schema: n } = e, { doc: r, selection: i } = t, { ranges: o } = i, s = Math.min(...o.map((f) => f.$from.pos)), a = Math.max(...o.map((f) => f.$to.pos)), c = Cq(n);
            return kq(r, { from: s, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: c
            });
          }
        }
      })
    ];
  }
}), Dq = pr.create({
  name: "commands",
  addCommands() {
    return {
      ...fq
    };
  }
}), Iq = pr.create({
  name: "delete",
  onUpdate({ transaction: e, appendedTransactions: t }) {
    var n, r, i;
    const o = () => {
      var s, a, c, u;
      if ((u = (c = (a = (s = this.editor.options.coreExtensionOptions) == null ? void 0 : s.delete) == null ? void 0 : a.filterTransaction) == null ? void 0 : c.call(a, e)) != null ? u : e.getMeta("y-sync$"))
        return;
      const f = bq(e.before, [e, ...t]);
      _q(f).forEach((g) => {
        f.mapping.mapResult(g.oldRange.from).deletedAfter && f.mapping.mapResult(g.oldRange.to).deletedBefore && f.before.nodesBetween(g.oldRange.from, g.oldRange.to, (b, x) => {
          const w = x + b.nodeSize - 2, S = g.oldRange.from <= x && w <= g.oldRange.to;
          this.editor.emit("delete", {
            type: "node",
            node: b,
            from: x,
            to: w,
            newFrom: f.mapping.map(x),
            newTo: f.mapping.map(w),
            deletedRange: g.oldRange,
            newRange: g.newRange,
            partial: !S,
            editor: this.editor,
            transaction: e,
            combinedTransform: f
          });
        });
      });
      const m = f.mapping;
      f.steps.forEach((g, b) => {
        var x, w;
        if (g instanceof ps) {
          const S = m.slice(b).map(g.from, -1), _ = m.slice(b).map(g.to), M = m.invert().map(S, -1), N = m.invert().map(_), D = (x = f.doc.nodeAt(S - 1)) == null ? void 0 : x.marks.some((O) => O.eq(g.mark)), j = (w = f.doc.nodeAt(_)) == null ? void 0 : w.marks.some((O) => O.eq(g.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: g.mark,
            from: g.from,
            to: g.to,
            deletedRange: {
              from: M,
              to: N
            },
            newRange: {
              from: S,
              to: _
            },
            partial: !!(j || D),
            editor: this.editor,
            transaction: e,
            combinedTransform: f
          });
        }
      });
    };
    (i = (r = (n = this.editor.options.coreExtensionOptions) == null ? void 0 : n.delete) == null ? void 0 : r.async) == null || i ? setTimeout(o, 0) : o();
  }
}), jq = pr.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Yn({
        key: new Ar("tiptapDrop"),
        props: {
          handleDrop: (e, t, n, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: t,
              slice: n,
              moved: r
            });
          }
        }
      })
    ];
  }
}), zq = pr.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Yn({
        key: new Ar("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), Lq = new Ar("focusEvents"), Bq = pr.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: e } = this;
    return [
      new Yn({
        key: Lq,
        props: {
          handleDOMEvents: {
            focus: (t, n) => {
              e.isFocused = !0;
              const r = e.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return t.dispatch(r), !1;
            },
            blur: (t, n) => {
              e.isFocused = !1;
              const r = e.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return t.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), $q = pr.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const e = () => this.editor.commands.first(({ commands: s }) => [
      () => s.undoInputRule(),
      // maybe convert first text block node to default node
      () => s.command(({ tr: a }) => {
        const { selection: c, doc: u } = a, { empty: f, $anchor: h } = c, { pos: m, parent: g } = h, b = h.parent.isTextblock && m > 0 ? a.doc.resolve(m - 1) : h, x = b.parent.type.spec.isolating, w = h.pos - h.parentOffset, S = x && b.parent.childCount === 1 ? w === h.pos : Lt.atStart(u).from === m;
        return !f || !g.type.isTextblock || g.textContent.length || !S || S && h.parent.type.name === "paragraph" ? !1 : s.clearNodes();
      }),
      () => s.deleteSelection(),
      () => s.joinBackward(),
      () => s.selectNodeBackward()
    ]), t = () => this.editor.commands.first(({ commands: s }) => [
      () => s.deleteSelection(),
      () => s.deleteCurrentNode(),
      () => s.joinForward(),
      () => s.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: s }) => [
        () => s.newlineInCode(),
        () => s.createParagraphNear(),
        () => s.liftEmptyBlock(),
        () => s.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: e,
      "Mod-Backspace": e,
      "Shift-Backspace": e,
      Delete: t,
      "Mod-Delete": t,
      "Mod-a": () => this.editor.commands.selectAll()
    }, i = {
      ...r
    }, o = {
      ...r,
      "Ctrl-h": e,
      "Alt-Backspace": e,
      "Ctrl-d": t,
      "Ctrl-Alt-Backspace": t,
      "Alt-Delete": t,
      "Alt-d": t,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return Ig() || yq() ? o : i;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new Yn({
        key: new Ar("clearDocument"),
        appendTransaction: (e, t, n) => {
          if (e.some((x) => x.getMeta("composition")))
            return;
          const r = e.some((x) => x.docChanged) && !t.doc.eq(n.doc), i = e.some((x) => x.getMeta("preventClearDocument"));
          if (!r || i)
            return;
          const { empty: o, from: s, to: a } = t.selection, c = Lt.atStart(t.doc).from, u = Lt.atEnd(t.doc).to;
          if (o || !(s === c && a === u) || !y1(n.doc))
            return;
          const m = n.tr, g = h1({
            state: n,
            transaction: m
          }), { commands: b } = new p1({
            editor: this.editor,
            state: g
          });
          if (b.clearNodes(), !!m.steps.length)
            return m;
        }
      })
    ];
  }
}), Uq = pr.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Yn({
        key: new Ar("tiptapPaste"),
        props: {
          handlePaste: (e, t, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: t,
              slice: n
            });
          }
        }
      })
    ];
  }
}), Fq = pr.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Yn({
        key: new Ar("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
}), Vq = pr.create({
  name: "textDirection",
  addOptions() {
    return {
      direction: void 0
    };
  },
  addGlobalAttributes() {
    if (!this.options.direction)
      return [];
    const { nodeExtensions: e } = Mh(this.extensions);
    return [
      {
        types: e.filter((t) => t.name !== "text").map((t) => t.name),
        attributes: {
          dir: {
            default: this.options.direction,
            parseHTML: (t) => {
              const n = t.getAttribute("dir");
              return n && (n === "ltr" || n === "rtl" || n === "auto") ? n : this.options.direction;
            },
            renderHTML: (t) => t.dir ? {
              dir: t.dir
            } : {}
          }
        }
      }
    ];
  },
  addProseMirrorPlugins() {
    return [
      new Yn({
        key: new Ar("textDirection"),
        props: {
          attributes: () => {
            const e = this.options.direction;
            return e ? {
              dir: e
            } : {};
          }
        }
      })
    ];
  }
}), bDe = class Nm {
  constructor(t, n, r = !1, i = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = t, this.editor = n, this.currentNode = i;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var t;
    return (t = this.actualDepth) != null ? t : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(t) {
    let n = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, t);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const t = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(t);
    return new Nm(n, this.editor);
  }
  get before() {
    let t = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return t.depth !== this.depth && (t = this.resolvedPos.doc.resolve(this.from - 3)), new Nm(t, this.editor);
  }
  get after() {
    let t = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return t.depth !== this.depth && (t = this.resolvedPos.doc.resolve(this.to + 3)), new Nm(t, this.editor);
  }
  get children() {
    const t = [];
    return this.node.content.forEach((n, r) => {
      const i = n.isBlock && !n.isTextblock, o = n.isAtom && !n.isText, s = n.isInline, a = this.pos + r + (o ? 0 : 1);
      if (a < 0 || a > this.resolvedPos.doc.nodeSize - 2)
        return;
      const c = this.resolvedPos.doc.resolve(a);
      if (!i && !s && c.depth <= this.depth)
        return;
      const u = new Nm(c, this.editor, i, i || s ? n : null);
      i && (u.actualDepth = this.depth + 1), t.push(u);
    }), t;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const t = this.children;
    return t[t.length - 1] || null;
  }
  closest(t, n = {}) {
    let r = null, i = this.parent;
    for (; i && !r; ) {
      if (i.node.type.name === t)
        if (Object.keys(n).length > 0) {
          const o = i.node.attrs, s = Object.keys(n);
          for (let a = 0; a < s.length; a += 1) {
            const c = s[a];
            if (o[c] !== n[c])
              break;
          }
        } else
          r = i;
      i = i.parent;
    }
    return r;
  }
  querySelector(t, n = {}) {
    return this.querySelectorAll(t, n, !0)[0] || null;
  }
  querySelectorAll(t, n = {}, r = !1) {
    let i = [];
    if (!this.children || this.children.length === 0)
      return i;
    const o = Object.keys(n);
    return this.children.forEach((s) => {
      r && i.length > 0 || (s.node.type.name === t && o.every((c) => n[c] === s.node.attrs[c]) && i.push(s), !(r && i.length > 0) && (i = i.concat(s.querySelectorAll(t, n, r))));
    }), i;
  }
  setAttribute(t) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...t
    }), this.editor.view.dispatch(n);
  }
}, xDe = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function wDe(e, t, n) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null)
    return r;
  const i = document.createElement("style");
  return t && i.setAttribute("nonce", t), i.setAttribute("data-tiptap-style", ""), i.innerHTML = e, document.getElementsByTagName("head")[0].appendChild(i), i;
}
var SDe = class extends lDe {
  constructor(e = {}) {
    super(), this.css = null, this.className = "tiptap", this.editorView = null, this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.instanceId = Math.random().toString(36).slice(2, 9), this.options = {
      element: typeof document < "u" ? document.createElement("div") : null,
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      textDirection: void 0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      emitContentError: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onMount: () => null,
      onUnmount: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: r }) => {
        throw r;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null,
      enableExtensionDispatchTransaction: !0
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.utils = {
      getUpdatedPosition: BPe,
      createMappablePosition: $Pe
    }, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("mount", this.options.onMount), this.on("unmount", this.options.onUnmount), this.on("contentError", this.options.onContentError), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: r, slice: i, moved: o }) => this.options.onDrop(r, i, o)), this.on("paste", ({ event: r, slice: i }) => this.options.onPaste(r, i)), this.on("delete", this.options.onDelete);
    const t = this.createDoc(), n = mq(t, this.options.autofocus);
    this.editorState = Qf.create({
      doc: t,
      schema: this.schema,
      selection: n || void 0
    }), this.options.element && this.mount(this.options.element);
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(e) {
    if (typeof document > "u")
      throw new Error(
        "[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment."
      );
    this.createView(e), this.emit("mount", { editor: this }), this.css && !document.head.contains(this.css) && document.head.appendChild(this.css), window.setTimeout(() => {
      this.isDestroyed || (this.options.autofocus !== !1 && this.options.autofocus !== null && this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    if (this.editorView) {
      const e = this.editorView.dom;
      e?.editor && delete e.editor, this.editorView.destroy();
    }
    if (this.editorView = null, this.isInitialized = !1, this.css && !document.querySelectorAll(`.${this.className}`).length)
      try {
        typeof this.css.remove == "function" ? this.css.remove() : this.css.parentNode && this.css.parentNode.removeChild(this.css);
      } catch (e) {
        console.warn("Failed to remove CSS element:", e);
      }
    this.css = null, this.emit("unmount", { editor: this });
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && typeof document < "u" && (this.css = wDe(xDe, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.editorView || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, t = !0) {
    this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    return this.editorView ? this.editorView : new Proxy(
      {
        state: this.editorState,
        updateState: (e) => {
          this.editorState = e;
        },
        dispatch: (e) => {
          this.dispatchTransaction(e);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: !1,
        dragging: null,
        editable: !0,
        isDestroyed: !1
      },
      {
        get: (e, t) => {
          if (this.editorView)
            return this.editorView[t];
          if (t === "state")
            return this.editorState;
          if (t in e)
            return Reflect.get(e, t);
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${t}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.editorView && (this.editorState = this.view.state), this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, t) {
    const n = xq(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], r = this.state.reconfigure({ plugins: n });
    return this.view.updateState(r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const t = this.state.plugins;
    let n = t;
    if ([].concat(e).forEach((i) => {
      const o = typeof i == "string" ? `${i}$` : i.key;
      n = n.filter((s) => !s.key.startsWith(o));
    }), t.length === n.length)
      return;
    const r = this.state.reconfigure({
      plugins: n
    });
    return this.view.updateState(r), r;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, t;
    const r = [...this.options.enableCoreExtensions ? [
      zq,
      Pq.configure({
        blockSeparator: (t = (e = this.options.coreExtensionOptions) == null ? void 0 : e.clipboardTextSerializer) == null ? void 0 : t.blockSeparator
      }),
      Dq,
      Bq,
      $q,
      Fq,
      jq,
      Uq,
      Iq,
      Vq.configure({
        direction: this.options.textDirection
      })
    ].filter((i) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[i.name] !== !1 : !0) : [], ...this.options.extensions].filter((i) => ["extension", "node", "mark"].includes(i?.type));
    this.extensionManager = new b1(r, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new p1({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let e;
    try {
      e = VT(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (t) {
      if (!(t instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(t.message))
        throw t;
      this.emit("contentError", {
        editor: this,
        error: t,
        disableCollaboration: () => {
          "collaboration" in this.storage && typeof this.storage.collaboration == "object" && this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((n) => n.name !== "collaboration"), this.createExtensionManager();
        }
      }), e = VT(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: !1
      });
    }
    return e;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(e) {
    const { editorProps: t, enableExtensionDispatchTransaction: n } = this.options, r = t.dispatchTransaction || this.dispatchTransaction.bind(this), i = n ? this.extensionManager.dispatchTransaction(r) : r;
    this.editorView = new uq(e, {
      ...t,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...t?.attributes
      },
      dispatchTransaction: i,
      state: this.editorState,
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
    const o = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(o), this.prependClass(), this.injectCSS();
    const s = this.view.dom;
    s.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `${this.className} ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const t = this.capturedTransaction;
    return this.capturedTransaction = null, t;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((u) => {
        var f;
        return (f = this.capturedTransaction) == null ? void 0 : f.step(u);
      });
      return;
    }
    const { state: t, transactions: n } = this.state.applyTransaction(e), r = !this.state.selection.eq(t.selection), i = n.includes(e), o = this.state;
    if (this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: t
    }), !i)
      return;
    this.view.updateState(t), this.emit("transaction", {
      editor: this,
      transaction: e,
      appendedTransactions: n.slice(1)
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const s = n.findLast((u) => u.getMeta("focus") || u.getMeta("blur")), a = s?.getMeta("focus"), c = s?.getMeta("blur");
    a && this.emit("focus", {
      editor: this,
      event: a.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: s
    }), c && this.emit("blur", {
      editor: this,
      event: c.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: s
    }), !(e.getMeta("preventUpdate") || !n.some((u) => u.docChanged) || o.doc.eq(t.doc)) && this.emit("update", {
      editor: this,
      transaction: e,
      appendedTransactions: n.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return Eq(this.state, e);
  }
  isActive(e, t) {
    const n = typeof e == "string" ? e : null, r = typeof e == "string" ? t : e;
    return jPe(this.state, n, r);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return nR(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: t = `

`, textSerializers: n = {} } = e || {};
    return NPe(this.state.doc, {
      blockSeparator: t,
      textSerializers: {
        ...Cq(this.schema),
        ...n
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return y1(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy"), this.unmount(), this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e, t;
    return (t = (e = this.editorView) == null ? void 0 : e.isDestroyed) != null ? t : !0;
  }
  $node(e, t) {
    var n;
    return ((n = this.$doc) == null ? void 0 : n.querySelector(e, t)) || null;
  }
  $nodes(e, t) {
    var n;
    return ((n = this.$doc) == null ? void 0 : n.querySelectorAll(e, t)) || null;
  }
  $pos(e) {
    const t = this.state.doc.resolve(e);
    return new bDe(t, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function Rh(e) {
  return new v1({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const i = gn(e.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: o } = t, s = r[r.length - 1], a = r[0];
      if (s) {
        const c = a.search(/\S/), u = n.from + a.indexOf(s), f = u + s.length;
        if (rR(n.from, n.to, t.doc).filter((g) => g.mark.type.excluded.find((x) => x === e.type && x !== g.mark.type)).filter((g) => g.to > u).length)
          return null;
        f < n.to && o.delete(f, n.to), u > n.from && o.delete(n.from + c, u);
        const m = n.from + c + s.length;
        o.addMark(n.from + c, m, e.type.create(i || {})), o.removeStoredMark(e.type);
      }
    },
    undoable: e.undoable
  });
}
function kDe(e) {
  return new v1({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const i = gn(e.getAttributes, void 0, r) || {}, { tr: o } = t, s = n.from;
      let a = n.to;
      const c = e.type.create(i);
      if (r[1]) {
        const u = r[0].lastIndexOf(r[1]);
        let f = s + u;
        f > a ? f = a : a = f + r[1].length;
        const h = r[0][r[0].length - 1];
        o.insertText(h, s + r[0].length - 1), o.replaceWith(f, a, c);
      } else if (r[0]) {
        const u = e.type.isInline ? s : s - 1;
        o.insert(u, e.type.create(i)).delete(o.mapping.map(s), o.mapping.map(a));
      }
      o.scrollIntoView();
    },
    undoable: e.undoable
  });
}
function WT(e) {
  return new v1({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const i = t.doc.resolve(n.from), o = gn(e.getAttributes, void 0, r) || {};
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), e.type))
        return null;
      t.tr.delete(n.from, n.to).setBlockType(n.from, n.from, e.type, o);
    },
    undoable: e.undoable
  });
}
function Oh(e) {
  return new v1({
    find: e.find,
    handler: ({ state: t, range: n, match: r, chain: i }) => {
      const o = gn(e.getAttributes, void 0, r) || {}, s = t.tr.delete(n.from, n.to), c = s.doc.resolve(n.from).blockRange(), u = c && jN(c, e.type, o);
      if (!u)
        return null;
      if (s.wrap(c, u), e.keepMarks && e.editor) {
        const { selection: h, storedMarks: m } = t, { splittableMarks: g } = e.editor.extensionManager, b = m || h.$to.parentOffset && h.$from.marks();
        if (b) {
          const x = b.filter((w) => g.includes(w.type.name));
          s.ensureMarks(x);
        }
      }
      if (e.keepAttributes) {
        const h = e.type.name === "bulletList" || e.type.name === "orderedList" ? "listItem" : "taskList";
        i().updateAttributes(h, o).run();
      }
      const f = s.doc.resolve(n.from - 1).nodeBefore;
      f && f.type === e.type && Kc(s.doc, n.from - 1) && (!e.joinPredicate || e.joinPredicate(r, f)) && s.join(n.from - 1);
    },
    undoable: e.undoable
  });
}
function CDe(e, t) {
  const { selection: n } = e, { $from: r } = n;
  if (n instanceof pt) {
    const o = r.index();
    return r.parent.canReplaceWith(o, o + 1, t);
  }
  let i = r.depth;
  for (; i >= 0; ) {
    const o = r.index(i);
    if (r.node(i).contentMatchAt(o).matchType(t))
      return !0;
    i -= 1;
  }
  return !1;
}
function EDe(e) {
  return e.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var _De = {};
JN(_De, {
  createAtomBlockMarkdownSpec: () => TDe,
  createBlockMarkdownSpec: () => ADe,
  createInlineMarkdownSpec: () => RDe,
  parseAttributes: () => oR,
  parseIndentedBlocks: () => qT,
  renderNestedMarkdownContent: () => aR,
  serializeAttributes: () => sR
});
function oR(e) {
  if (!e?.trim())
    return {};
  const t = {}, n = [], r = e.replace(/["']([^"']*)["']/g, (u) => (n.push(u), `__QUOTED_${n.length - 1}__`)), i = r.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);
  if (i) {
    const u = i.map((f) => f.trim().slice(1));
    t.class = u.join(" ");
  }
  const o = r.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);
  o && (t.id = o[1]);
  const s = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;
  Array.from(r.matchAll(s)).forEach(([, u, f]) => {
    var h;
    const m = parseInt(((h = f.match(/__QUOTED_(\d+)__/)) == null ? void 0 : h[1]) || "0", 10), g = n[m];
    g && (t[u] = g.slice(1, -1));
  });
  const c = r.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, "").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, "").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, "").trim();
  return c && c.split(/\s+/).filter(Boolean).forEach((f) => {
    f.match(/^[a-zA-Z][\w-]*$/) && (t[f] = !0);
  }), t;
}
function sR(e) {
  if (!e || Object.keys(e).length === 0)
    return "";
  const t = [];
  return e.class && String(e.class).split(/\s+/).filter(Boolean).forEach((r) => t.push(`.${r}`)), e.id && t.push(`#${e.id}`), Object.entries(e).forEach(([n, r]) => {
    n === "class" || n === "id" || (r === !0 ? t.push(n) : r !== !1 && r != null && t.push(`${n}="${String(r)}"`));
  }), t.join(" ");
}
function TDe(e) {
  const {
    nodeName: t,
    name: n,
    parseAttributes: r = oR,
    serializeAttributes: i = sR,
    defaultAttributes: o = {},
    requiredAttributes: s = [],
    allowedAttributes: a
  } = e, c = n || t, u = (f) => {
    if (!a)
      return f;
    const h = {};
    return a.forEach((m) => {
      m in f && (h[m] = f[m]);
    }), h;
  };
  return {
    parseMarkdown: (f, h) => {
      const m = { ...o, ...f.attributes };
      return h.createNode(t, m, []);
    },
    markdownTokenizer: {
      name: t,
      level: "block",
      start(f) {
        var h;
        const m = new RegExp(`^:::${c}(?:\\s|$)`, "m"), g = (h = f.match(m)) == null ? void 0 : h.index;
        return g !== void 0 ? g : -1;
      },
      tokenize(f, h, m) {
        const g = new RegExp(`^:::${c}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`), b = f.match(g);
        if (!b)
          return;
        const x = b[1] || "", w = r(x);
        if (!s.find((_) => !(_ in w)))
          return {
            type: t,
            raw: b[0],
            attributes: w
          };
      }
    },
    renderMarkdown: (f) => {
      const h = u(f.attrs || {}), m = i(h), g = m ? ` {${m}}` : "";
      return `:::${c}${g} :::`;
    }
  };
}
function ADe(e) {
  const {
    nodeName: t,
    name: n,
    getContent: r,
    parseAttributes: i = oR,
    serializeAttributes: o = sR,
    defaultAttributes: s = {},
    content: a = "block",
    allowedAttributes: c
  } = e, u = n || t, f = (h) => {
    if (!c)
      return h;
    const m = {};
    return c.forEach((g) => {
      g in h && (m[g] = h[g]);
    }), m;
  };
  return {
    parseMarkdown: (h, m) => {
      let g;
      if (r) {
        const x = r(h);
        g = typeof x == "string" ? [{ type: "text", text: x }] : x;
      } else a === "block" ? g = m.parseChildren(h.tokens || []) : g = m.parseInline(h.tokens || []);
      const b = { ...s, ...h.attributes };
      return m.createNode(t, b, g);
    },
    markdownTokenizer: {
      name: t,
      level: "block",
      start(h) {
        var m;
        const g = new RegExp(`^:::${u}`, "m"), b = (m = h.match(g)) == null ? void 0 : m.index;
        return b !== void 0 ? b : -1;
      },
      tokenize(h, m, g) {
        var b;
        const x = new RegExp(`^:::${u}(?:\\s+\\{([^}]*)\\})?\\s*\\n`), w = h.match(x);
        if (!w)
          return;
        const [S, _ = ""] = w, M = i(_);
        let N = 1;
        const D = S.length;
        let j = "";
        const O = /^:::([\w-]*)(\s.*)?/gm, L = h.slice(D);
        for (O.lastIndex = 0; ; ) {
          const U = O.exec(L);
          if (U === null)
            break;
          const B = U.index, G = U[1];
          if (!((b = U[2]) != null && b.endsWith(":::"))) {
            if (G)
              N += 1;
            else if (N -= 1, N === 0) {
              const Y = L.slice(0, B);
              j = Y.trim();
              const he = h.slice(0, D + B + U[0].length);
              let ie = [];
              if (j)
                if (a === "block")
                  for (ie = g.blockTokens(Y), ie.forEach((ne) => {
                    ne.text && (!ne.tokens || ne.tokens.length === 0) && (ne.tokens = g.inlineTokens(ne.text));
                  }); ie.length > 0; ) {
                    const ne = ie[ie.length - 1];
                    if (ne.type === "paragraph" && (!ne.text || ne.text.trim() === ""))
                      ie.pop();
                    else
                      break;
                  }
                else
                  ie = g.inlineTokens(j);
              return {
                type: t,
                raw: he,
                attributes: M,
                content: j,
                tokens: ie
              };
            }
          }
        }
      }
    },
    renderMarkdown: (h, m) => {
      const g = f(h.attrs || {}), b = o(g), x = b ? ` {${b}}` : "", w = m.renderChildren(h.content || [], `

`);
      return `:::${u}${x}

${w}

:::`;
    }
  };
}
function MDe(e) {
  if (!e.trim())
    return {};
  const t = {}, n = /(\w+)=(?:"([^"]*)"|'([^']*)')/g;
  let r = n.exec(e);
  for (; r !== null; ) {
    const [, i, o, s] = r;
    t[i] = o || s, r = n.exec(e);
  }
  return t;
}
function NDe(e) {
  return Object.entries(e).filter(([, t]) => t != null).map(([t, n]) => `${t}="${n}"`).join(" ");
}
function RDe(e) {
  const {
    nodeName: t,
    name: n,
    getContent: r,
    parseAttributes: i = MDe,
    serializeAttributes: o = NDe,
    defaultAttributes: s = {},
    selfClosing: a = !1,
    allowedAttributes: c
  } = e, u = n || t, f = (m) => {
    if (!c)
      return m;
    const g = {};
    return c.forEach((b) => {
      const x = typeof b == "string" ? b : b.name, w = typeof b == "string" ? void 0 : b.skipIfDefault;
      if (x in m) {
        const S = m[x];
        if (w !== void 0 && S === w)
          return;
        g[x] = S;
      }
    }), g;
  }, h = u.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  return {
    parseMarkdown: (m, g) => {
      const b = { ...s, ...m.attributes };
      if (a)
        return g.createNode(t, b);
      const x = r ? r(m) : m.content || "";
      return x ? g.createNode(t, b, [g.createTextNode(x)]) : g.createNode(t, b, []);
    },
    markdownTokenizer: {
      name: t,
      level: "inline",
      start(m) {
        const g = a ? new RegExp(`\\[${h}\\s*[^\\]]*\\]`) : new RegExp(`\\[${h}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${h}\\]`), b = m.match(g), x = b?.index;
        return x !== void 0 ? x : -1;
      },
      tokenize(m, g, b) {
        const x = a ? new RegExp(`^\\[${h}\\s*([^\\]]*)\\]`) : new RegExp(`^\\[${h}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${h}\\]`), w = m.match(x);
        if (!w)
          return;
        let S = "", _ = "";
        if (a) {
          const [, N] = w;
          _ = N;
        } else {
          const [, N, D] = w;
          _ = N, S = D || "";
        }
        const M = i(_.trim());
        return {
          type: t,
          raw: w[0],
          content: S.trim(),
          attributes: M
        };
      }
    },
    renderMarkdown: (m) => {
      let g = "";
      r ? g = r(m) : m.content && m.content.length > 0 && (g = m.content.filter((S) => S.type === "text").map((S) => S.text).join(""));
      const b = f(m.attrs || {}), x = o(b), w = x ? ` ${x}` : "";
      return a ? `[${u}${w}]` : `[${u}${w}]${g}[/${u}]`;
    }
  };
}
function qT(e, t, n) {
  var r, i, o, s;
  const a = e.split(`
`), c = [];
  let u = "", f = 0;
  const h = t.baseIndentSize || 2;
  for (; f < a.length; ) {
    const m = a[f], g = m.match(t.itemPattern);
    if (!g) {
      if (c.length > 0)
        break;
      if (m.trim() === "") {
        f += 1, u = `${u}${m}
`;
        continue;
      } else
        return;
    }
    const b = t.extractItemData(g), { indentLevel: x, mainContent: w } = b;
    u = `${u}${m}
`;
    const S = [w];
    for (f += 1; f < a.length; ) {
      const D = a[f];
      if (D.trim() === "") {
        const O = a.slice(f + 1).findIndex((B) => B.trim() !== "");
        if (O === -1)
          break;
        if ((((i = (r = a[f + 1 + O].match(/^(\s*)/)) == null ? void 0 : r[1]) == null ? void 0 : i.length) || 0) > x) {
          S.push(D), u = `${u}${D}
`, f += 1;
          continue;
        } else
          break;
      }
      if ((((s = (o = D.match(/^(\s*)/)) == null ? void 0 : o[1]) == null ? void 0 : s.length) || 0) > x)
        S.push(D), u = `${u}${D}
`, f += 1;
      else
        break;
    }
    let _;
    const M = S.slice(1);
    if (M.length > 0) {
      const D = M.map((j) => j.slice(x + h)).join(`
`);
      D.trim() && (t.customNestedParser ? _ = t.customNestedParser(D) : _ = n.blockTokens(D));
    }
    const N = t.createToken(b, _);
    c.push(N);
  }
  if (c.length !== 0)
    return {
      items: c,
      raw: u
    };
}
function aR(e, t, n, r) {
  if (!e || !Array.isArray(e.content))
    return "";
  const i = typeof n == "function" ? n(r) : n, [o, ...s] = e.content, a = t.renderChildren([o]), c = [`${i}${a}`];
  return s && s.length > 0 && s.forEach((u) => {
    const f = t.renderChildren([u]);
    if (f) {
      const h = f.split(`
`).map((m) => m ? t.indent(m) : "").join(`
`);
      c.push(h);
    }
  }), c.join(`
`);
}
function ODe(e, t, n = {}) {
  const { state: r } = t, { doc: i, tr: o } = r, s = e;
  i.descendants((a, c) => {
    const u = o.mapping.map(c), f = o.mapping.map(c) + a.nodeSize;
    let h = null;
    if (a.marks.forEach((g) => {
      if (g !== s)
        return !1;
      h = g;
    }), !h)
      return;
    let m = !1;
    if (Object.keys(n).forEach((g) => {
      n[g] !== h.attrs[g] && (m = !0);
    }), m) {
      const g = e.type.create({
        ...e.attrs,
        ...n
      });
      o.removeMark(u, f, e.type), o.addMark(u, f, g);
    }
  }), o.docChanged && t.view.dispatch(o);
}
var Li = class Hq extends iR {
  constructor() {
    super(...arguments), this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new Hq(n);
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
}, PDe = class {
  constructor(e, t, n) {
    this.isDragging = !1, this.component = e, this.editor = t.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...n
    }, this.extension = t.extension, this.node = t.node, this.decorations = t.decorations, this.innerDecorations = t.innerDecorations, this.view = t.view, this.HTMLAttributes = t.HTMLAttributes, this.getPos = t.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(e) {
    var t, n, r, i, o, s, a;
    const { view: c } = this.editor, u = e.target, f = u.nodeType === 3 ? (t = u.parentElement) == null ? void 0 : t.closest("[data-drag-handle]") : u.closest("[data-drag-handle]");
    if (!this.dom || (n = this.contentDOM) != null && n.contains(u) || !f)
      return;
    let h = 0, m = 0;
    if (this.dom !== f) {
      const _ = this.dom.getBoundingClientRect(), M = f.getBoundingClientRect(), N = (i = e.offsetX) != null ? i : (r = e.nativeEvent) == null ? void 0 : r.offsetX, D = (s = e.offsetY) != null ? s : (o = e.nativeEvent) == null ? void 0 : o.offsetY;
      h = M.x - _.x + N, m = M.y - _.y + D;
    }
    const g = this.dom.cloneNode(!0);
    try {
      const _ = this.dom.getBoundingClientRect();
      g.style.width = `${Math.round(_.width)}px`, g.style.height = `${Math.round(_.height)}px`, g.style.boxSizing = "border-box", g.style.pointerEvents = "none";
    } catch {
    }
    let b = null;
    try {
      b = document.createElement("div"), b.style.position = "absolute", b.style.top = "-9999px", b.style.left = "-9999px", b.style.pointerEvents = "none", b.appendChild(g), document.body.appendChild(b), (a = e.dataTransfer) == null || a.setDragImage(g, h, m);
    } finally {
      b && setTimeout(() => {
        try {
          b?.remove();
        } catch {
        }
      }, 0);
    }
    const x = this.getPos();
    if (typeof x != "number")
      return;
    const w = pt.create(c.state.doc, x), S = c.state.tr.setSelection(w);
    c.dispatch(S);
  }
  stopEvent(e) {
    var t;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: e });
    const n = e.target;
    if (!(this.dom.contains(n) && !((t = this.contentDOM) != null && t.contains(n))))
      return !1;
    const i = e.type.startsWith("drag"), o = e.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(n.tagName) || n.isContentEditable) && !o && !i)
      return !0;
    const { isEditable: a } = this.editor, { isDragging: c } = this, u = !!this.node.type.spec.draggable, f = pt.isSelectable(this.node), h = e.type === "copy", m = e.type === "paste", g = e.type === "cut", b = e.type === "mousedown";
    if (!u && f && i && e.target === this.dom && e.preventDefault(), u && i && !c && e.target === this.dom)
      return e.preventDefault(), !1;
    if (u && a && !c && b) {
      const x = n.closest("[data-drag-handle]");
      x && (this.dom === x || this.dom.contains(x)) && (this.isDragging = !0, document.addEventListener(
        "dragend",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ), document.addEventListener(
        "drop",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ), document.addEventListener(
        "mouseup",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ));
    }
    return !(c || o || h || m || g || b && f);
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? !0 : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (Ig() || FT()) && this.editor.isFocused && [...Array.from(e.addedNodes), ...Array.from(e.removedNodes)].every((n) => n.isContentEditable) ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(e) {
    this.editor.commands.command(({ tr: t }) => {
      const n = this.getPos();
      return typeof n != "number" ? !1 : (t.setNodeMarkup(n, void 0, {
        ...this.node.attrs,
        ...e
      }), !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const e = this.getPos();
    if (typeof e != "number")
      return;
    const t = e + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: e, to: t });
  }
};
function pd(e) {
  return new hDe({
    find: e.find,
    handler: ({ state: t, range: n, match: r, pasteEvent: i }) => {
      const o = gn(e.getAttributes, void 0, r, i);
      if (o === !1 || o === null)
        return null;
      const { tr: s } = t, a = r[r.length - 1], c = r[0];
      let u = n.to;
      if (a) {
        const f = c.search(/\S/), h = n.from + c.indexOf(a), m = h + a.length;
        if (rR(n.from, n.to, t.doc).filter((b) => b.mark.type.excluded.find((w) => w === e.type && w !== b.mark.type)).filter((b) => b.to > h).length)
          return null;
        m < n.to && s.delete(m, n.to), h > n.from && s.delete(n.from + f, h), u = n.from + f + a.length, s.addMark(n.from + f, u, e.type.create(o || {})), s.removeStoredMark(e.type);
      }
    }
  });
}
const { getOwnPropertyNames: DDe, getOwnPropertySymbols: IDe } = Object, { hasOwnProperty: jDe } = Object.prototype;
function bE(e, t) {
  return function(r, i, o) {
    return e(r, i, o) && t(r, i, o);
  };
}
function y0(e) {
  return function(n, r, i) {
    if (!n || !r || typeof n != "object" || typeof r != "object")
      return e(n, r, i);
    const { cache: o } = i, s = o.get(n), a = o.get(r);
    if (s && a)
      return s === r && a === n;
    o.set(n, r), o.set(r, n);
    const c = e(n, r, i);
    return o.delete(n), o.delete(r), c;
  };
}
function zDe(e) {
  return e?.[Symbol.toStringTag];
}
function Z5(e) {
  return DDe(e).concat(IDe(e));
}
const LDe = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  Object.hasOwn || ((e, t) => jDe.call(e, t))
);
function _d(e, t) {
  return e === t || !e && !t && e !== e && t !== t;
}
const BDe = "__v", $De = "__o", UDe = "_owner", { getOwnPropertyDescriptor: Y5, keys: X5 } = Object;
function FDe(e, t) {
  return e.byteLength === t.byteLength && Sx(new Uint8Array(e), new Uint8Array(t));
}
function VDe(e, t, n) {
  let r = e.length;
  if (t.length !== r)
    return !1;
  for (; r-- > 0; )
    if (!n.equals(e[r], t[r], r, r, e, t, n))
      return !1;
  return !0;
}
function HDe(e, t) {
  return e.byteLength === t.byteLength && Sx(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), new Uint8Array(t.buffer, t.byteOffset, t.byteLength));
}
function WDe(e, t) {
  return _d(e.getTime(), t.getTime());
}
function qDe(e, t) {
  return e.name === t.name && e.message === t.message && e.cause === t.cause && e.stack === t.stack;
}
function GDe(e, t) {
  return e === t;
}
function J5(e, t, n) {
  const r = e.size;
  if (r !== t.size)
    return !1;
  if (!r)
    return !0;
  const i = new Array(r), o = e.entries();
  let s, a, c = 0;
  for (; (s = o.next()) && !s.done; ) {
    const u = t.entries();
    let f = !1, h = 0;
    for (; (a = u.next()) && !a.done; ) {
      if (i[h]) {
        h++;
        continue;
      }
      const m = s.value, g = a.value;
      if (n.equals(m[0], g[0], c, h, e, t, n) && n.equals(m[1], g[1], m[0], g[0], e, t, n)) {
        f = i[h] = !0;
        break;
      }
      h++;
    }
    if (!f)
      return !1;
    c++;
  }
  return !0;
}
const KDe = _d;
function ZDe(e, t, n) {
  const r = X5(e);
  let i = r.length;
  if (X5(t).length !== i)
    return !1;
  for (; i-- > 0; )
    if (!Wq(e, t, n, r[i]))
      return !1;
  return !0;
}
function pm(e, t, n) {
  const r = Z5(e);
  let i = r.length;
  if (Z5(t).length !== i)
    return !1;
  let o, s, a;
  for (; i-- > 0; )
    if (o = r[i], !Wq(e, t, n, o) || (s = Y5(e, o), a = Y5(t, o), (s || a) && (!s || !a || s.configurable !== a.configurable || s.enumerable !== a.enumerable || s.writable !== a.writable)))
      return !1;
  return !0;
}
function YDe(e, t) {
  return _d(e.valueOf(), t.valueOf());
}
function XDe(e, t) {
  return e.source === t.source && e.flags === t.flags;
}
function Q5(e, t, n) {
  const r = e.size;
  if (r !== t.size)
    return !1;
  if (!r)
    return !0;
  const i = new Array(r), o = e.values();
  let s, a;
  for (; (s = o.next()) && !s.done; ) {
    const c = t.values();
    let u = !1, f = 0;
    for (; (a = c.next()) && !a.done; ) {
      if (!i[f] && n.equals(s.value, a.value, s.value, a.value, e, t, n)) {
        u = i[f] = !0;
        break;
      }
      f++;
    }
    if (!u)
      return !1;
  }
  return !0;
}
function Sx(e, t) {
  let n = e.byteLength;
  if (t.byteLength !== n || e.byteOffset !== t.byteOffset)
    return !1;
  for (; n-- > 0; )
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function JDe(e, t) {
  return e.hostname === t.hostname && e.pathname === t.pathname && e.protocol === t.protocol && e.port === t.port && e.hash === t.hash && e.username === t.username && e.password === t.password;
}
function Wq(e, t, n, r) {
  return (r === UDe || r === $De || r === BDe) && (e.$$typeof || t.$$typeof) ? !0 : LDe(t, r) && n.equals(e[r], t[r], r, r, e, t, n);
}
const QDe = "[object ArrayBuffer]", eIe = "[object Arguments]", tIe = "[object Boolean]", nIe = "[object DataView]", rIe = "[object Date]", iIe = "[object Error]", oIe = "[object Map]", sIe = "[object Number]", aIe = "[object Object]", lIe = "[object RegExp]", cIe = "[object Set]", uIe = "[object String]", dIe = {
  "[object Int8Array]": !0,
  "[object Uint8Array]": !0,
  "[object Uint8ClampedArray]": !0,
  "[object Int16Array]": !0,
  "[object Uint16Array]": !0,
  "[object Int32Array]": !0,
  "[object Uint32Array]": !0,
  "[object Float16Array]": !0,
  "[object Float32Array]": !0,
  "[object Float64Array]": !0,
  "[object BigInt64Array]": !0,
  "[object BigUint64Array]": !0
}, fIe = "[object URL]", hIe = Object.prototype.toString;
function pIe({ areArrayBuffersEqual: e, areArraysEqual: t, areDataViewsEqual: n, areDatesEqual: r, areErrorsEqual: i, areFunctionsEqual: o, areMapsEqual: s, areNumbersEqual: a, areObjectsEqual: c, arePrimitiveWrappersEqual: u, areRegExpsEqual: f, areSetsEqual: h, areTypedArraysEqual: m, areUrlsEqual: g, unknownTagComparators: b }) {
  return function(w, S, _) {
    if (w === S)
      return !0;
    if (w == null || S == null)
      return !1;
    const M = typeof w;
    if (M !== typeof S)
      return !1;
    if (M !== "object")
      return M === "number" ? a(w, S, _) : M === "function" ? o(w, S, _) : !1;
    const N = w.constructor;
    if (N !== S.constructor)
      return !1;
    if (N === Object)
      return c(w, S, _);
    if (Array.isArray(w))
      return t(w, S, _);
    if (N === Date)
      return r(w, S, _);
    if (N === RegExp)
      return f(w, S, _);
    if (N === Map)
      return s(w, S, _);
    if (N === Set)
      return h(w, S, _);
    const D = hIe.call(w);
    if (D === rIe)
      return r(w, S, _);
    if (D === lIe)
      return f(w, S, _);
    if (D === oIe)
      return s(w, S, _);
    if (D === cIe)
      return h(w, S, _);
    if (D === aIe)
      return typeof w.then != "function" && typeof S.then != "function" && c(w, S, _);
    if (D === fIe)
      return g(w, S, _);
    if (D === iIe)
      return i(w, S, _);
    if (D === eIe)
      return c(w, S, _);
    if (dIe[D])
      return m(w, S, _);
    if (D === QDe)
      return e(w, S, _);
    if (D === nIe)
      return n(w, S, _);
    if (D === tIe || D === sIe || D === uIe)
      return u(w, S, _);
    if (b) {
      let j = b[D];
      if (!j) {
        const O = zDe(w);
        O && (j = b[O]);
      }
      if (j)
        return j(w, S, _);
    }
    return !1;
  };
}
function mIe({ circular: e, createCustomConfig: t, strict: n }) {
  let r = {
    areArrayBuffersEqual: FDe,
    areArraysEqual: n ? pm : VDe,
    areDataViewsEqual: HDe,
    areDatesEqual: WDe,
    areErrorsEqual: qDe,
    areFunctionsEqual: GDe,
    areMapsEqual: n ? bE(J5, pm) : J5,
    areNumbersEqual: KDe,
    areObjectsEqual: n ? pm : ZDe,
    arePrimitiveWrappersEqual: YDe,
    areRegExpsEqual: XDe,
    areSetsEqual: n ? bE(Q5, pm) : Q5,
    areTypedArraysEqual: n ? bE(Sx, pm) : Sx,
    areUrlsEqual: JDe,
    unknownTagComparators: void 0
  };
  if (t && (r = Object.assign({}, r, t(r))), e) {
    const i = y0(r.areArraysEqual), o = y0(r.areMapsEqual), s = y0(r.areObjectsEqual), a = y0(r.areSetsEqual);
    r = Object.assign({}, r, {
      areArraysEqual: i,
      areMapsEqual: o,
      areObjectsEqual: s,
      areSetsEqual: a
    });
  }
  return r;
}
function gIe(e) {
  return function(t, n, r, i, o, s, a) {
    return e(t, n, a);
  };
}
function yIe({ circular: e, comparator: t, createState: n, equals: r, strict: i }) {
  if (n)
    return function(a, c) {
      const { cache: u = e ? /* @__PURE__ */ new WeakMap() : void 0, meta: f } = n();
      return t(a, c, {
        cache: u,
        equals: r,
        meta: f,
        strict: i
      });
    };
  if (e)
    return function(a, c) {
      return t(a, c, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: r,
        meta: void 0,
        strict: i
      });
    };
  const o = {
    cache: void 0,
    equals: r,
    meta: void 0,
    strict: i
  };
  return function(a, c) {
    return t(a, c, o);
  };
}
const vIe = Yc();
Yc({ strict: !0 });
Yc({ circular: !0 });
Yc({
  circular: !0,
  strict: !0
});
Yc({
  createInternalComparator: () => _d
});
Yc({
  strict: !0,
  createInternalComparator: () => _d
});
Yc({
  circular: !0,
  createInternalComparator: () => _d
});
Yc({
  circular: !0,
  createInternalComparator: () => _d,
  strict: !0
});
function Yc(e = {}) {
  const { circular: t = !1, createInternalComparator: n, createState: r, strict: i = !1 } = e, o = mIe(e), s = pIe(o), a = n ? n(s) : gIe(s);
  return yIe({ circular: t, comparator: s, createState: r, equals: a, strict: i });
}
var xE = { exports: {} }, wE = {};
var e3;
function bIe() {
  if (e3) return wE;
  e3 = 1;
  var e = gd(), t = p4();
  function n(u, f) {
    return u === f && (u !== 0 || 1 / u === 1 / f) || u !== u && f !== f;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, a = e.useMemo, c = e.useDebugValue;
  return wE.useSyncExternalStoreWithSelector = function(u, f, h, m, g) {
    var b = o(null);
    if (b.current === null) {
      var x = { hasValue: !1, value: null };
      b.current = x;
    } else x = b.current;
    b = a(
      function() {
        function S(j) {
          if (!_) {
            if (_ = !0, M = j, j = m(j), g !== void 0 && x.hasValue) {
              var O = x.value;
              if (g(O, j))
                return N = O;
            }
            return N = j;
          }
          if (O = N, r(M, j)) return O;
          var L = m(j);
          return g !== void 0 && g(O, L) ? (M = j, O) : (M = j, N = L);
        }
        var _ = !1, M, N, D = h === void 0 ? null : h;
        return [
          function() {
            return S(f());
          },
          D === null ? void 0 : function() {
            return S(D());
          }
        ];
      },
      [f, h, m, g]
    );
    var w = i(u, b[0], b[1]);
    return s(
      function() {
        x.hasValue = !0, x.value = w;
      },
      [w]
    ), c(w), w;
  }, wE;
}
var t3;
function xIe() {
  return t3 || (t3 = 1, xE.exports = bIe()), xE.exports;
}
var wIe = xIe(), SIe = (...e) => (t) => {
  e.forEach((n) => {
    typeof n == "function" ? n(t) : n && (n.current = t);
  });
}, kIe = ({ contentComponent: e }) => {
  const t = fh.useSyncExternalStore(
    e.subscribe,
    e.getSnapshot,
    e.getServerSnapshot
  );
  return /* @__PURE__ */ v.jsx(v.Fragment, { children: Object.values(t) });
};
function CIe() {
  const e = /* @__PURE__ */ new Set();
  let t = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(n) {
      return e.add(n), () => {
        e.delete(n);
      };
    },
    getSnapshot() {
      return t;
    },
    getServerSnapshot() {
      return t;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(n, r) {
      t = {
        ...t,
        [n]: C4.createPortal(r.reactElement, r.element, n)
      }, e.forEach((i) => i());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(n) {
      const r = { ...t };
      delete r[n], t = r, e.forEach((i) => i());
    }
  };
}
var EIe = class extends Ne.Component {
  constructor(e) {
    var t;
    super(e), this.editorContentRef = Ne.createRef(), this.initialized = !1, this.state = {
      hasContentComponentInitialized: !!((t = e.editor) != null && t.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    var e;
    const t = this.props.editor;
    if (t && !t.isDestroyed && ((e = t.view.dom) != null && e.parentNode)) {
      if (t.contentComponent)
        return;
      const n = this.editorContentRef.current;
      n.append(...t.view.dom.parentNode.childNodes), t.setOptions({
        element: n
      }), t.contentComponent = CIe(), this.state.hasContentComponentInitialized || (this.unsubscribeToContentComponent = t.contentComponent.subscribe(() => {
        this.setState((r) => r.hasContentComponentInitialized ? r : {
          hasContentComponentInitialized: !0
        }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent();
      })), t.createNodeViews(), this.initialized = !0;
    }
  }
  componentWillUnmount() {
    var e;
    const t = this.props.editor;
    if (t) {
      this.initialized = !1, t.isDestroyed || t.view.setProps({
        nodeViews: {}
      }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent(), t.contentComponent = null;
      try {
        if (!((e = t.view.dom) != null && e.parentNode))
          return;
        const n = document.createElement("div");
        n.append(...t.view.dom.parentNode.childNodes), t.setOptions({
          element: n
        });
      } catch {
      }
    }
  }
  render() {
    const { editor: e, innerRef: t, ...n } = this.props;
    return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx("div", { ref: SIe(t, this.editorContentRef), ...n }),
      e?.contentComponent && /* @__PURE__ */ v.jsx(kIe, { contentComponent: e.contentComponent })
    ] });
  }
}, _Ie = C.forwardRef(
  (e, t) => {
    const n = Ne.useMemo(() => Math.floor(Math.random() * 4294967295).toString(), [e.editor]);
    return Ne.createElement(EIe, {
      key: n,
      innerRef: t,
      ...e
    });
  }
), qq = Ne.memo(_Ie), TIe = typeof window < "u" ? C.useLayoutEffect : C.useEffect, AIe = class {
  constructor(e) {
    this.transactionNumber = 0, this.lastTransactionNumber = 0, this.subscribers = /* @__PURE__ */ new Set(), this.editor = e, this.lastSnapshot = { editor: e, transactionNumber: 0 }, this.getSnapshot = this.getSnapshot.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.watch = this.watch.bind(this), this.subscribe = this.subscribe.bind(this);
  }
  /**
   * Get the current editor instance.
   */
  getSnapshot() {
    return this.transactionNumber === this.lastTransactionNumber ? this.lastSnapshot : (this.lastTransactionNumber = this.transactionNumber, this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber }, this.lastSnapshot);
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return { editor: null, transactionNumber: 0 };
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(e) {
    return this.subscribers.add(e), () => {
      this.subscribers.delete(e);
    };
  }
  /**
   * Watch the editor instance for changes.
   */
  watch(e) {
    if (this.editor = e, this.editor) {
      const t = () => {
        this.transactionNumber += 1, this.subscribers.forEach((r) => r());
      }, n = this.editor;
      return n.on("transaction", t), () => {
        n.off("transaction", t);
      };
    }
  }
};
function MIe(e) {
  var t;
  const [n] = C.useState(() => new AIe(e.editor)), r = wIe.useSyncExternalStoreWithSelector(
    n.subscribe,
    n.getSnapshot,
    n.getServerSnapshot,
    e.selector,
    (t = e.equalityFn) != null ? t : vIe
  );
  return TIe(() => n.watch(e.editor), [e.editor, n]), C.useDebugValue(r), r;
}
var NIe = !1, GT = typeof window > "u", RIe = GT || !!(typeof window < "u" && window.next), OIe = class Gq {
  constructor(t) {
    this.editor = null, this.subscriptions = /* @__PURE__ */ new Set(), this.isComponentMounted = !1, this.previousDeps = null, this.instanceId = "", this.options = t, this.subscriptions = /* @__PURE__ */ new Set(), this.setEditor(this.getInitialEditor()), this.scheduleDestroy(), this.getEditor = this.getEditor.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.subscribe = this.subscribe.bind(this), this.refreshEditorInstance = this.refreshEditorInstance.bind(this), this.scheduleDestroy = this.scheduleDestroy.bind(this), this.onRender = this.onRender.bind(this), this.createEditor = this.createEditor.bind(this);
  }
  setEditor(t) {
    this.editor = t, this.instanceId = Math.random().toString(36).slice(2, 9), this.subscriptions.forEach((n) => n());
  }
  getInitialEditor() {
    return this.options.current.immediatelyRender === void 0 ? GT || RIe ? null : this.createEditor() : (this.options.current.immediatelyRender, this.options.current.immediatelyRender ? this.createEditor() : null);
  }
  /**
   * Create a new editor instance. And attach event listeners.
   */
  createEditor() {
    const t = {
      ...this.options.current,
      // Always call the most recent version of the callback function by default
      onBeforeCreate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onBeforeCreate) == null ? void 0 : o.call(i, ...r);
      },
      onBlur: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onBlur) == null ? void 0 : o.call(i, ...r);
      },
      onCreate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onCreate) == null ? void 0 : o.call(i, ...r);
      },
      onDestroy: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onDestroy) == null ? void 0 : o.call(i, ...r);
      },
      onFocus: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onFocus) == null ? void 0 : o.call(i, ...r);
      },
      onSelectionUpdate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onSelectionUpdate) == null ? void 0 : o.call(i, ...r);
      },
      onTransaction: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onTransaction) == null ? void 0 : o.call(i, ...r);
      },
      onUpdate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onUpdate) == null ? void 0 : o.call(i, ...r);
      },
      onContentError: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onContentError) == null ? void 0 : o.call(i, ...r);
      },
      onDrop: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onDrop) == null ? void 0 : o.call(i, ...r);
      },
      onPaste: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onPaste) == null ? void 0 : o.call(i, ...r);
      },
      onDelete: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onDelete) == null ? void 0 : o.call(i, ...r);
      }
    };
    return new SDe(t);
  }
  /**
   * Get the current editor instance.
   */
  getEditor() {
    return this.editor;
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return null;
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(t) {
    return this.subscriptions.add(t), () => {
      this.subscriptions.delete(t);
    };
  }
  static compareOptions(t, n) {
    return Object.keys(t).every((r) => [
      "onCreate",
      "onBeforeCreate",
      "onDestroy",
      "onUpdate",
      "onTransaction",
      "onFocus",
      "onBlur",
      "onSelectionUpdate",
      "onContentError",
      "onDrop",
      "onPaste"
    ].includes(r) ? !0 : r === "extensions" && t.extensions && n.extensions ? t.extensions.length !== n.extensions.length ? !1 : t.extensions.every((i, o) => {
      var s;
      return i === ((s = n.extensions) == null ? void 0 : s[o]);
    }) : t[r] === n[r]);
  }
  /**
   * On each render, we will create, update, or destroy the editor instance.
   * @param deps The dependencies to watch for changes
   * @returns A cleanup function
   */
  onRender(t) {
    return () => (this.isComponentMounted = !0, clearTimeout(this.scheduledDestructionTimeout), this.editor && !this.editor.isDestroyed && t.length === 0 ? Gq.compareOptions(this.options.current, this.editor.options) || this.editor.setOptions({
      ...this.options.current,
      editable: this.editor.isEditable
    }) : this.refreshEditorInstance(t), () => {
      this.isComponentMounted = !1, this.scheduleDestroy();
    });
  }
  /**
   * Recreate the editor instance if the dependencies have changed.
   */
  refreshEditorInstance(t) {
    if (this.editor && !this.editor.isDestroyed) {
      if (this.previousDeps === null) {
        this.previousDeps = t;
        return;
      }
      if (this.previousDeps.length === t.length && this.previousDeps.every((r, i) => r === t[i]))
        return;
    }
    this.editor && !this.editor.isDestroyed && this.editor.destroy(), this.setEditor(this.createEditor()), this.previousDeps = t;
  }
  /**
   * Schedule the destruction of the editor instance.
   * This will only destroy the editor if it was not mounted on the next tick.
   * This is to avoid destroying the editor instance when it's actually still mounted.
   */
  scheduleDestroy() {
    const t = this.instanceId, n = this.editor;
    this.scheduledDestructionTimeout = setTimeout(() => {
      if (this.isComponentMounted && this.instanceId === t) {
        n && n.setOptions(this.options.current);
        return;
      }
      n && !n.isDestroyed && (n.destroy(), this.instanceId === t && this.setEditor(null));
    }, 1);
  }
};
function PIe(e = {}, t = []) {
  const n = C.useRef(e);
  n.current = e;
  const [r] = C.useState(() => new OIe(n)), i = fh.useSyncExternalStore(
    r.subscribe,
    r.getEditor,
    r.getServerSnapshot
  );
  return C.useDebugValue(i), C.useEffect(r.onRender(t)), MIe({
    editor: i,
    selector: ({ transactionNumber: o }) => e.shouldRerenderOnTransaction === !1 || e.shouldRerenderOnTransaction === void 0 ? null : e.immediatelyRender && o === 0 ? 0 : o + 1
  }), i;
}
var Kq = C.createContext({
  editor: null
});
Kq.Consumer;
var Zq = C.createContext({
  onDragStart: () => {
  },
  nodeViewContentChildren: void 0,
  nodeViewContentRef: () => {
  }
}), DIe = () => C.useContext(Zq), IIe = Ne.forwardRef((e, t) => {
  const { onDragStart: n } = DIe(), r = e.as || "div";
  return (
    // @ts-ignore
    /* @__PURE__ */ v.jsx(
      r,
      {
        ...e,
        ref: t,
        "data-node-view-wrapper": "",
        onDragStart: n,
        style: {
          whiteSpace: "normal",
          ...e.style
        }
      }
    )
  );
});
function n3(e) {
  return !!(typeof e == "function" && e.prototype && e.prototype.isReactComponent);
}
function r3(e) {
  return !!(typeof e == "object" && e.$$typeof && (e.$$typeof.toString() === "Symbol(react.forward_ref)" || e.$$typeof.description === "react.forward_ref"));
}
function jIe(e) {
  return !!(typeof e == "object" && e.$$typeof && (e.$$typeof.toString() === "Symbol(react.memo)" || e.$$typeof.description === "react.memo"));
}
function zIe(e) {
  if (n3(e) || r3(e))
    return !0;
  if (jIe(e)) {
    const t = e.type;
    if (t)
      return n3(t) || r3(t);
  }
  return !1;
}
function LIe() {
  try {
    if (C.version)
      return parseInt(C.version.split(".")[0], 10) >= 19;
  } catch {
  }
  return !1;
}
var BIe = class {
  /**
   * Immediately creates element and renders the provided React component.
   */
  constructor(e, { editor: t, props: n = {}, as: r = "div", className: i = "" }) {
    this.ref = null, this.destroyed = !1, this.id = Math.floor(Math.random() * 4294967295).toString(), this.component = e, this.editor = t, this.props = n, this.element = document.createElement(r), this.element.classList.add("react-renderer"), i && this.element.classList.add(...i.split(" ")), this.editor.isInitialized ? sl.flushSync(() => {
      this.render();
    }) : queueMicrotask(() => {
      this.destroyed || this.render();
    });
  }
  /**
   * Render the React component.
   */
  render() {
    var e;
    if (this.destroyed)
      return;
    const t = this.component, n = this.props, r = this.editor, i = LIe(), o = zIe(t), s = { ...n };
    s.ref && !(i || o) && delete s.ref, !s.ref && (i || o) && (s.ref = (a) => {
      this.ref = a;
    }), this.reactElement = /* @__PURE__ */ v.jsx(t, { ...s }), (e = r?.contentComponent) == null || e.setRenderer(this.id, this);
  }
  /**
   * Re-renders the React component with new props.
   */
  updateProps(e = {}) {
    this.destroyed || (this.props = {
      ...this.props,
      ...e
    }, this.render());
  }
  /**
   * Destroy the React component.
   */
  destroy() {
    var e;
    this.destroyed = !0;
    const t = this.editor;
    (e = t?.contentComponent) == null || e.removeRenderer(this.id);
    try {
      this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element);
    } catch {
    }
  }
  /**
   * Update the attributes of the element that holds the React component.
   */
  updateAttributes(e) {
    Object.keys(e).forEach((t) => {
      this.element.setAttribute(t, e[t]);
    });
  }
};
Ne.createContext({
  markViewContentRef: () => {
  }
});
var $Ie = class extends PDe {
  constructor(e, t, n) {
    if (super(e, t, n), this.selectionRafId = null, this.cachedExtensionWithSyncedStorage = null, !this.node.isLeaf) {
      this.options.contentDOMElementTag ? this.contentDOMElement = document.createElement(this.options.contentDOMElementTag) : this.contentDOMElement = document.createElement(this.node.isInline ? "span" : "div"), this.contentDOMElement.dataset.nodeViewContentReact = "", this.contentDOMElement.dataset.nodeViewWrapper = "", this.contentDOMElement.style.whiteSpace = "inherit";
      const r = this.dom.querySelector("[data-node-view-content]");
      if (!r)
        return;
      r.appendChild(this.contentDOMElement);
    }
  }
  /**
   * Returns a proxy of the extension that redirects storage access to the editor's mutable storage.
   * This preserves the original prototype chain (instanceof checks, methods like configure/extend work).
   * Cached to avoid proxy creation on every update.
   */
  get extensionWithSyncedStorage() {
    if (!this.cachedExtensionWithSyncedStorage) {
      const e = this.editor, t = this.extension;
      this.cachedExtensionWithSyncedStorage = new Proxy(t, {
        get(n, r, i) {
          var o;
          return r === "storage" ? (o = e.storage[t.name]) != null ? o : {} : Reflect.get(n, r, i);
        }
      });
    }
    return this.cachedExtensionWithSyncedStorage;
  }
  /**
   * Setup the React component.
   * Called on initialization.
   */
  mount() {
    const e = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: !1,
      extension: this.extensionWithSyncedStorage,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (c = {}) => this.updateAttributes(c),
      deleteNode: () => this.deleteNode(),
      ref: C.createRef()
    };
    if (!this.component.displayName) {
      const c = (u) => u.charAt(0).toUpperCase() + u.substring(1);
      this.component.displayName = c(this.extension.name);
    }
    const r = { onDragStart: this.onDragStart.bind(this), nodeViewContentRef: (c) => {
      c && this.contentDOMElement && c.firstChild !== this.contentDOMElement && (c.hasAttribute("data-node-view-wrapper") && c.removeAttribute("data-node-view-wrapper"), c.appendChild(this.contentDOMElement));
    } }, i = this.component, o = C.memo((c) => /* @__PURE__ */ v.jsx(Zq.Provider, { value: r, children: C.createElement(i, c) }));
    o.displayName = "ReactNodeView";
    let s = this.node.isInline ? "span" : "div";
    this.options.as && (s = this.options.as);
    const { className: a = "" } = this.options;
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.renderer = new BIe(o, {
      editor: this.editor,
      props: e,
      as: s,
      className: `node-${this.node.type.name} ${a}`.trim()
    }), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.updateElementAttributes();
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    var e;
    if (this.renderer.element.firstElementChild && !((e = this.renderer.element.firstElementChild) != null && e.hasAttribute("data-node-view-wrapper")))
      throw Error("Please use the NodeViewWrapper component for your node view.");
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    return this.node.isLeaf ? null : this.contentDOMElement;
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    this.selectionRafId && (cancelAnimationFrame(this.selectionRafId), this.selectionRafId = null), this.selectionRafId = requestAnimationFrame(() => {
      this.selectionRafId = null;
      const { from: e, to: t } = this.editor.state.selection, n = this.getPos();
      if (typeof n == "number")
        if (e <= n && t >= n + this.node.nodeSize) {
          if (this.renderer.props.selected)
            return;
          this.selectNode();
        } else {
          if (!this.renderer.props.selected)
            return;
          this.deselectNode();
        }
    });
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(e, t, n) {
    const r = (i) => {
      this.renderer.updateProps(i), typeof this.options.attrs == "function" && this.updateElementAttributes();
    };
    if (e.type !== this.node.type)
      return !1;
    if (typeof this.options.update == "function") {
      const i = this.node, o = this.decorations, s = this.innerDecorations;
      return this.node = e, this.decorations = t, this.innerDecorations = n, this.options.update({
        oldNode: i,
        oldDecorations: o,
        newNode: e,
        newDecorations: t,
        oldInnerDecorations: s,
        innerDecorations: n,
        updateProps: () => r({ node: e, decorations: t, innerDecorations: n, extension: this.extensionWithSyncedStorage })
      });
    }
    return e === this.node && this.decorations === t && this.innerDecorations === n || (this.node = e, this.decorations = t, this.innerDecorations = n, r({ node: e, decorations: t, innerDecorations: n, extension: this.extensionWithSyncedStorage })), !0;
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: !0
    }), this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: !1
    }), this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  /**
   * Destroy the React component instance.
   */
  destroy() {
    this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate), this.contentDOMElement = null, this.selectionRafId && (cancelAnimationFrame(this.selectionRafId), this.selectionRafId = null);
  }
  /**
   * Update the attributes of the top-level element that holds the React component.
   * Applying the attributes defined in the `attrs` option.
   */
  updateElementAttributes() {
    if (this.options.attrs) {
      let e = {};
      if (typeof this.options.attrs == "function") {
        const t = this.editor.extensionManager.attributes, n = Nh(this.node, t);
        e = this.options.attrs({ node: this.node, HTMLAttributes: n });
      } else
        e = this.options.attrs;
      this.renderer.updateAttributes(e);
    }
  }
};
function UIe(e, t) {
  return (n) => n.editor.contentComponent ? new $Ie(e, n, t) : {};
}
var lR = C.createContext({
  get editor() {
    throw new Error("useTiptap must be used within a <Tiptap> provider");
  }
});
lR.displayName = "TiptapContext";
var FIe = () => C.useContext(lR);
function Yq({ editor: e, instance: t, children: n }) {
  const r = e ?? t;
  if (!r)
    throw new Error("Tiptap: An editor instance is required. Pass a non-null `editor` prop.");
  const i = C.useMemo(() => ({ editor: r }), [r]), o = C.useMemo(() => ({ editor: r }), [r]);
  return /* @__PURE__ */ v.jsx(Kq.Provider, { value: o, children: /* @__PURE__ */ v.jsx(lR.Provider, { value: i, children: n }) });
}
Yq.displayName = "Tiptap";
function Xq({ ...e }) {
  const { editor: t } = FIe();
  return /* @__PURE__ */ v.jsx(qq, { editor: t, ...e });
}
Xq.displayName = "Tiptap.Content";
Object.assign(Yq, {
  /**
   * The Tiptap Content component that renders the EditorContent with the editor instance from the context.
   * @see TiptapContent
   */
  Content: Xq
});
var kx = (e, t) => {
  if (e === "slot")
    return 0;
  if (e instanceof Function)
    return e(t);
  const { children: n, ...r } = t ?? {};
  if (e === "svg")
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  return [e, r, n];
}, VIe = /^\s*>\s$/, HIe = Li.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [{ tag: "blockquote" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return /* @__PURE__ */ kx("blockquote", { ...sr(this.options.HTMLAttributes, e), children: /* @__PURE__ */ kx("slot", {}) });
  },
  parseMarkdown: (e, t) => t.createNode("blockquote", void 0, t.parseChildren(e.tokens || [])),
  renderMarkdown: (e, t) => {
    if (!e.content)
      return "";
    const n = ">", r = [];
    return e.content.forEach((i) => {
      const a = t.renderChildren([i]).split(`
`).map((c) => c.trim() === "" ? n : `${n} ${c}`);
      r.push(a.join(`
`));
    }), r.join(`
${n}
`);
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: e }) => e.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: e }) => e.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: e }) => e.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      Oh({
        find: VIe,
        type: this.type
      })
    ];
  }
}), WIe = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, qIe = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, GIe = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, KIe = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, ZIe = Ed.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (e) => e.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (e) => e.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return /* @__PURE__ */ kx("strong", { ...sr(this.options.HTMLAttributes, e), children: /* @__PURE__ */ kx("slot", {}) });
  },
  markdownTokenName: "strong",
  parseMarkdown: (e, t) => t.applyMark("bold", t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => `**${t.renderChildren(e)}**`,
  addCommands() {
    return {
      setBold: () => ({ commands: e }) => e.setMark(this.name),
      toggleBold: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetBold: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Rh({
        find: WIe,
        type: this.type
      }),
      Rh({
        find: GIe,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      pd({
        find: qIe,
        type: this.type
      }),
      pd({
        find: KIe,
        type: this.type
      })
    ];
  }
}), YIe = /(^|[^`])`([^`]+)`(?!`)$/, XIe = /(^|[^`])`([^`]+)`(?!`)/g, JIe = Ed.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [{ tag: "code" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["code", sr(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "codespan",
  parseMarkdown: (e, t) => t.applyMark("code", [{ type: "text", text: e.text || "" }]),
  renderMarkdown: (e, t) => e.content ? `\`${t.renderChildren(e.content)}\`` : "",
  addCommands() {
    return {
      setCode: () => ({ commands: e }) => e.setMark(this.name),
      toggleCode: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetCode: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Rh({
        find: YIe,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      pd({
        find: XIe,
        type: this.type
      })
    ];
  }
}), SE = 4, QIe = /^```([a-z]+)?[\s\n]$/, eje = /^~~~([a-z]+)?[\s\n]$/, tje = Li.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      enableTabIndentation: !1,
      tabSize: SE,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (e) => {
          var t;
          const { languageClassPrefix: n } = this.options;
          if (!n)
            return null;
          const o = [...((t = e.firstElementChild) == null ? void 0 : t.classList) || []].filter((s) => s.startsWith(n)).map((s) => s.replace(n, ""))[0];
          return o || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "pre",
      sr(this.options.HTMLAttributes, t),
      [
        "code",
        {
          class: e.attrs.language ? this.options.languageClassPrefix + e.attrs.language : null
        },
        0
      ]
    ];
  },
  markdownTokenName: "code",
  parseMarkdown: (e, t) => {
    var n;
    return ((n = e.raw) == null ? void 0 : n.startsWith("```")) === !1 && e.codeBlockStyle !== "indented" ? [] : t.createNode(
      "codeBlock",
      { language: e.lang || null },
      e.text ? [t.createTextNode(e.text)] : []
    );
  },
  renderMarkdown: (e, t) => {
    var n;
    let r = "";
    const i = ((n = e.attrs) == null ? void 0 : n.language) || "";
    return e.content ? r = [`\`\`\`${i}`, t.renderChildren(e.content), "```"].join(`
`) : r = `\`\`\`${i}

\`\`\``, r;
  },
  addCommands() {
    return {
      setCodeBlock: (e) => ({ commands: t }) => t.setNode(this.name, e),
      toggleCodeBlock: (e) => ({ commands: t }) => t.toggleNode(this.name, "paragraph", e)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: e, $anchor: t } = this.editor.state.selection, n = t.pos === 1;
        return !e || t.parent.type.name !== this.name ? !1 : n || !t.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // handle tab indentation
      Tab: ({ editor: e }) => {
        var t;
        if (!this.options.enableTabIndentation)
          return !1;
        const n = (t = this.options.tabSize) != null ? t : SE, { state: r } = e, { selection: i } = r, { $from: o, empty: s } = i;
        if (o.parent.type !== this.type)
          return !1;
        const a = " ".repeat(n);
        return s ? e.commands.insertContent(a) : e.commands.command(({ tr: c }) => {
          const { from: u, to: f } = i, g = r.doc.textBetween(u, f, `
`, `
`).split(`
`).map((b) => a + b).join(`
`);
          return c.replaceWith(u, f, r.schema.text(g)), !0;
        });
      },
      // handle shift+tab reverse indentation
      "Shift-Tab": ({ editor: e }) => {
        var t;
        if (!this.options.enableTabIndentation)
          return !1;
        const n = (t = this.options.tabSize) != null ? t : SE, { state: r } = e, { selection: i } = r, { $from: o, empty: s } = i;
        return o.parent.type !== this.type ? !1 : s ? e.commands.command(({ tr: a }) => {
          var c;
          const { pos: u } = o, f = o.start(), h = o.end(), g = r.doc.textBetween(f, h, `
`, `
`).split(`
`);
          let b = 0, x = 0;
          const w = u - f;
          for (let j = 0; j < g.length; j += 1) {
            if (x + g[j].length >= w) {
              b = j;
              break;
            }
            x += g[j].length + 1;
          }
          const _ = ((c = g[b].match(/^ */)) == null ? void 0 : c[0]) || "", M = Math.min(_.length, n);
          if (M === 0)
            return !0;
          let N = f;
          for (let j = 0; j < b; j += 1)
            N += g[j].length + 1;
          return a.delete(N, N + M), u - N <= M && a.setSelection(Ct.create(a.doc, N)), !0;
        }) : e.commands.command(({ tr: a }) => {
          const { from: c, to: u } = i, m = r.doc.textBetween(c, u, `
`, `
`).split(`
`).map((g) => {
            var b;
            const x = ((b = g.match(/^ */)) == null ? void 0 : b[0]) || "", w = Math.min(x.length, n);
            return g.slice(w);
          }).join(`
`);
          return a.replaceWith(c, u, r.schema.text(m)), !0;
        });
      },
      // exit node on triple enter
      Enter: ({ editor: e }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: t } = e, { selection: n } = t, { $from: r, empty: i } = n;
        if (!i || r.parent.type !== this.type)
          return !1;
        const o = r.parentOffset === r.parent.nodeSize - 2, s = r.parent.textContent.endsWith(`

`);
        return !o || !s ? !1 : e.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: e }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: t } = e, { selection: n, doc: r } = t, { $from: i, empty: o } = n;
        if (!o || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
          return !1;
        const a = i.after();
        return a === void 0 ? !1 : r.nodeAt(a) ? e.commands.command(({ tr: u }) => (u.setSelection(Lt.near(r.resolve(a))), !0)) : e.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      WT({
        find: QIe,
        type: this.type,
        getAttributes: (e) => ({
          language: e[1]
        })
      }),
      WT({
        find: eje,
        type: this.type,
        getAttributes: (e) => ({
          language: e[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Yn({
        key: new Ar("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (e, t) => {
            if (!t.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = t.clipboardData.getData("text/plain"), r = t.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, o = i?.mode;
            if (!n || !o)
              return !1;
            const { tr: s, schema: a } = e.state, c = a.text(n.replace(/\r\n?/g, `
`));
            return s.replaceSelectionWith(this.type.create({ language: o }, c)), s.selection.$from.parent.type !== this.type && s.setSelection(Ct.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.setMeta("paste", !0), e.dispatch(s), !0;
          }
        }
      })
    ];
  }
}), nje = Li.create({
  name: "doc",
  topNode: !0,
  content: "block+",
  renderMarkdown: (e, t) => e.content ? t.renderChildren(e.content, `

`) : ""
}), rje = Li.create({
  name: "hardBreak",
  markdownTokenName: "br",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["br", sr(this.options.HTMLAttributes, e)];
  },
  renderText() {
    return `
`;
  },
  renderMarkdown: () => `  
`,
  parseMarkdown: () => ({
    type: "hardBreak"
  }),
  addCommands() {
    return {
      setHardBreak: () => ({ commands: e, chain: t, state: n, editor: r }) => e.first([
        () => e.exitCode(),
        () => e.command(() => {
          const { selection: i, storedMarks: o } = n;
          if (i.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: s } = this.options, { splittableMarks: a } = r.extensionManager, c = o || i.$to.parentOffset && i.$from.marks();
          return t().insertContent({ type: this.name }).command(({ tr: u, dispatch: f }) => {
            if (f && c && s) {
              const h = c.filter((m) => a.includes(m.type.name));
              u.ensureMarks(h);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), ije = Li.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((e) => ({
      tag: `h${e}`,
      attrs: { level: e }
    }));
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [`h${this.options.levels.includes(e.attrs.level) ? e.attrs.level : this.options.levels[0]}`, sr(this.options.HTMLAttributes, t), 0];
  },
  parseMarkdown: (e, t) => t.createNode("heading", { level: e.depth || 1 }, t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => {
    var n;
    const r = (n = e.attrs) != null && n.level ? parseInt(e.attrs.level, 10) : 1, i = "#".repeat(r);
    return e.content ? `${i} ${t.renderChildren(e.content)}` : "";
  },
  addCommands() {
    return {
      setHeading: (e) => ({ commands: t }) => this.options.levels.includes(e.level) ? t.setNode(this.name, e) : !1,
      toggleHeading: (e) => ({ commands: t }) => this.options.levels.includes(e.level) ? t.toggleNode(this.name, "paragraph", e) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce(
      (e, t) => ({
        ...e,
        [`Mod-Alt-${t}`]: () => this.editor.commands.toggleHeading({ level: t })
      }),
      {}
    );
  },
  addInputRules() {
    return this.options.levels.map((e) => WT({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${e}})\\s$`),
      type: this.type,
      getAttributes: {
        level: e
      }
    }));
  }
}), oje = Li.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {},
      nextNodeType: "paragraph"
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["hr", sr(this.options.HTMLAttributes, e)];
  },
  markdownTokenName: "hr",
  parseMarkdown: (e, t) => t.createNode("horizontalRule"),
  renderMarkdown: () => "---",
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: e, state: t }) => {
        if (!CDe(t, t.schema.nodes[this.name]))
          return !1;
        const { selection: n } = t, { $to: r } = n, i = e();
        return Tq(n) ? i.insertContentAt(r.pos, {
          type: this.name
        }) : i.insertContent({ type: this.name }), i.command(({ state: o, tr: s, dispatch: a }) => {
          if (a) {
            const { $to: c } = s.selection, u = c.end();
            if (c.nodeAfter)
              c.nodeAfter.isTextblock ? s.setSelection(Ct.create(s.doc, c.pos + 1)) : c.nodeAfter.isBlock ? s.setSelection(pt.create(s.doc, c.pos)) : s.setSelection(Ct.create(s.doc, c.pos));
            else {
              const f = o.schema.nodes[this.options.nextNodeType] || c.parent.type.contentMatch.defaultType, h = f?.create();
              h && (s.insert(u, h), s.setSelection(Ct.create(s.doc, u + 1)));
            }
            s.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      kDe({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), sje = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, aje = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, lje = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, cje = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, uje = Ed.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (e) => e.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (e) => e.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["em", sr(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: e }) => e.setMark(this.name),
      toggleItalic: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetItalic: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  markdownTokenName: "em",
  parseMarkdown: (e, t) => t.applyMark("italic", t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => `*${t.renderChildren(e)}*`,
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Rh({
        find: sje,
        type: this.type
      }),
      Rh({
        find: lje,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      pd({
        find: aje,
        type: this.type
      }),
      pd({
        find: cje,
        type: this.type
      })
    ];
  }
});
const dje = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", fje = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", KT = "numeric", ZT = "ascii", YT = "alpha", Jm = "asciinumeric", Rm = "alphanumeric", XT = "domain", Jq = "emoji", hje = "scheme", pje = "slashscheme", kE = "whitespace";
function mje(e, t) {
  return e in t || (t[e] = []), t[e];
}
function Hu(e, t, n) {
  t[KT] && (t[Jm] = !0, t[Rm] = !0), t[ZT] && (t[Jm] = !0, t[YT] = !0), t[Jm] && (t[Rm] = !0), t[YT] && (t[Rm] = !0), t[Rm] && (t[XT] = !0), t[Jq] && (t[XT] = !0);
  for (const r in t) {
    const i = mje(r, n);
    i.indexOf(e) < 0 && i.push(e);
  }
}
function gje(e, t) {
  const n = {};
  for (const r in t)
    t[r].indexOf(e) >= 0 && (n[r] = !0);
  return n;
}
function Zi(e = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = e;
}
Zi.groups = {};
Zi.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(e) {
    const t = this, n = t.j[e];
    if (n)
      return n;
    for (let r = 0; r < t.jr.length; r++) {
      const i = t.jr[r][0], o = t.jr[r][1];
      if (o && i.test(e))
        return o;
    }
    return t.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(e, t = !1) {
    return t ? e in this.j : !!this.go(e);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(e, t, n, r) {
    for (let i = 0; i < e.length; i++)
      this.tt(e[i], t, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(e, t, n, r) {
    r = r || Zi.groups;
    let i;
    return t && t.j ? i = t : (i = new Zi(t), n && r && Hu(t, n, r)), this.jr.push([e, i]), i;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(e, t, n, r) {
    let i = this;
    const o = e.length;
    if (!o)
      return i;
    for (let s = 0; s < o - 1; s++)
      i = i.tt(e[s]);
    return i.tt(e[o - 1], t, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(e, t, n, r) {
    r = r || Zi.groups;
    const i = this;
    if (t && t.j)
      return i.j[e] = t, t;
    const o = t;
    let s, a = i.go(e);
    if (a ? (s = new Zi(), Object.assign(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new Zi(), o) {
      if (r)
        if (s.t && typeof s.t == "string") {
          const c = Object.assign(gje(s.t, r), n);
          Hu(o, c, r);
        } else n && Hu(o, n, r);
      s.t = o;
    }
    return i.j[e] = s, s;
  }
};
const jt = (e, t, n, r, i) => e.ta(t, n, r, i), tr = (e, t, n, r, i) => e.tr(t, n, r, i), i3 = (e, t, n, r, i) => e.ts(t, n, r, i), Ue = (e, t, n, r, i) => e.tt(t, n, r, i), Wa = "WORD", JT = "UWORD", Qq = "ASCIINUMERICAL", eG = "ALPHANUMERICAL", zg = "LOCALHOST", QT = "TLD", eA = "UTLD", ib = "SCHEME", $f = "SLASH_SCHEME", cR = "NUM", tA = "WS", uR = "NL", Qm = "OPENBRACE", eg = "CLOSEBRACE", Cx = "OPENBRACKET", Ex = "CLOSEBRACKET", _x = "OPENPAREN", Tx = "CLOSEPAREN", Ax = "OPENANGLEBRACKET", Mx = "CLOSEANGLEBRACKET", Nx = "FULLWIDTHLEFTPAREN", Rx = "FULLWIDTHRIGHTPAREN", Ox = "LEFTCORNERBRACKET", Px = "RIGHTCORNERBRACKET", Dx = "LEFTWHITECORNERBRACKET", Ix = "RIGHTWHITECORNERBRACKET", jx = "FULLWIDTHLESSTHAN", zx = "FULLWIDTHGREATERTHAN", Lx = "AMPERSAND", Bx = "APOSTROPHE", $x = "ASTERISK", ac = "AT", Ux = "BACKSLASH", Fx = "BACKTICK", Vx = "CARET", uc = "COLON", dR = "COMMA", Hx = "DOLLAR", Fs = "DOT", Wx = "EQUALS", fR = "EXCLAMATION", zo = "HYPHEN", tg = "PERCENT", qx = "PIPE", Gx = "PLUS", Kx = "POUND", ng = "QUERY", hR = "QUOTE", tG = "FULLWIDTHMIDDLEDOT", pR = "SEMI", Vs = "SLASH", rg = "TILDE", Zx = "UNDERSCORE", nG = "EMOJI", Yx = "SYM";
var rG = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: eG,
  AMPERSAND: Lx,
  APOSTROPHE: Bx,
  ASCIINUMERICAL: Qq,
  ASTERISK: $x,
  AT: ac,
  BACKSLASH: Ux,
  BACKTICK: Fx,
  CARET: Vx,
  CLOSEANGLEBRACKET: Mx,
  CLOSEBRACE: eg,
  CLOSEBRACKET: Ex,
  CLOSEPAREN: Tx,
  COLON: uc,
  COMMA: dR,
  DOLLAR: Hx,
  DOT: Fs,
  EMOJI: nG,
  EQUALS: Wx,
  EXCLAMATION: fR,
  FULLWIDTHGREATERTHAN: zx,
  FULLWIDTHLEFTPAREN: Nx,
  FULLWIDTHLESSTHAN: jx,
  FULLWIDTHMIDDLEDOT: tG,
  FULLWIDTHRIGHTPAREN: Rx,
  HYPHEN: zo,
  LEFTCORNERBRACKET: Ox,
  LEFTWHITECORNERBRACKET: Dx,
  LOCALHOST: zg,
  NL: uR,
  NUM: cR,
  OPENANGLEBRACKET: Ax,
  OPENBRACE: Qm,
  OPENBRACKET: Cx,
  OPENPAREN: _x,
  PERCENT: tg,
  PIPE: qx,
  PLUS: Gx,
  POUND: Kx,
  QUERY: ng,
  QUOTE: hR,
  RIGHTCORNERBRACKET: Px,
  RIGHTWHITECORNERBRACKET: Ix,
  SCHEME: ib,
  SEMI: pR,
  SLASH: Vs,
  SLASH_SCHEME: $f,
  SYM: Yx,
  TILDE: rg,
  TLD: QT,
  UNDERSCORE: Zx,
  UTLD: eA,
  UWORD: JT,
  WORD: Wa,
  WS: tA
});
const $a = /[a-z]/, mm = new RegExp("\\p{L}", "u"), CE = new RegExp("\\p{Emoji}", "u"), Ua = /\d/, EE = /\s/, o3 = "\r", _E = `
`, yje = "", vje = "", TE = "";
let v0 = null, b0 = null;
function bje(e = []) {
  const t = {};
  Zi.groups = t;
  const n = new Zi();
  v0 == null && (v0 = s3(dje)), b0 == null && (b0 = s3(fje)), Ue(n, "'", Bx), Ue(n, "{", Qm), Ue(n, "}", eg), Ue(n, "[", Cx), Ue(n, "]", Ex), Ue(n, "(", _x), Ue(n, ")", Tx), Ue(n, "<", Ax), Ue(n, ">", Mx), Ue(n, "", Nx), Ue(n, "", Rx), Ue(n, "", Ox), Ue(n, "", Px), Ue(n, "", Dx), Ue(n, "", Ix), Ue(n, "", jx), Ue(n, "", zx), Ue(n, "&", Lx), Ue(n, "*", $x), Ue(n, "@", ac), Ue(n, "`", Fx), Ue(n, "^", Vx), Ue(n, ":", uc), Ue(n, ",", dR), Ue(n, "$", Hx), Ue(n, ".", Fs), Ue(n, "=", Wx), Ue(n, "!", fR), Ue(n, "-", zo), Ue(n, "%", tg), Ue(n, "|", qx), Ue(n, "+", Gx), Ue(n, "#", Kx), Ue(n, "?", ng), Ue(n, '"', hR), Ue(n, "/", Vs), Ue(n, ";", pR), Ue(n, "~", rg), Ue(n, "_", Zx), Ue(n, "\\", Ux), Ue(n, "", tG);
  const r = tr(n, Ua, cR, {
    [KT]: !0
  });
  tr(r, Ua, r);
  const i = tr(r, $a, Qq, {
    [Jm]: !0
  }), o = tr(r, mm, eG, {
    [Rm]: !0
  }), s = tr(n, $a, Wa, {
    [ZT]: !0
  });
  tr(s, Ua, i), tr(s, $a, s), tr(i, Ua, i), tr(i, $a, i);
  const a = tr(n, mm, JT, {
    [YT]: !0
  });
  tr(a, $a), tr(a, Ua, o), tr(a, mm, a), tr(o, Ua, o), tr(o, $a), tr(o, mm, o);
  const c = Ue(n, _E, uR, {
    [kE]: !0
  }), u = Ue(n, o3, tA, {
    [kE]: !0
  }), f = tr(n, EE, tA, {
    [kE]: !0
  });
  Ue(n, TE, f), Ue(u, _E, c), Ue(u, TE, f), tr(u, EE, f), Ue(f, o3), Ue(f, _E), tr(f, EE, f), Ue(f, TE, f);
  const h = tr(n, CE, nG, {
    [Jq]: !0
  });
  Ue(h, "#"), tr(h, CE, h), Ue(h, yje, h);
  const m = Ue(h, vje);
  Ue(m, "#"), tr(m, CE, h);
  const g = [[$a, s], [Ua, i]], b = [[$a, null], [mm, a], [Ua, o]];
  for (let x = 0; x < v0.length; x++)
    Zl(n, v0[x], QT, Wa, g);
  for (let x = 0; x < b0.length; x++)
    Zl(n, b0[x], eA, JT, b);
  Hu(QT, {
    tld: !0,
    ascii: !0
  }, t), Hu(eA, {
    utld: !0,
    alpha: !0
  }, t), Zl(n, "file", ib, Wa, g), Zl(n, "mailto", ib, Wa, g), Zl(n, "http", $f, Wa, g), Zl(n, "https", $f, Wa, g), Zl(n, "ftp", $f, Wa, g), Zl(n, "ftps", $f, Wa, g), Hu(ib, {
    scheme: !0,
    ascii: !0
  }, t), Hu($f, {
    slashscheme: !0,
    ascii: !0
  }, t), e = e.sort((x, w) => x[0] > w[0] ? 1 : -1);
  for (let x = 0; x < e.length; x++) {
    const w = e[x][0], _ = e[x][1] ? {
      [hje]: !0
    } : {
      [pje]: !0
    };
    w.indexOf("-") >= 0 ? _[XT] = !0 : $a.test(w) ? Ua.test(w) ? _[Jm] = !0 : _[ZT] = !0 : _[KT] = !0, i3(n, w, w, _);
  }
  return i3(n, "localhost", zg, {
    ascii: !0
  }), n.jd = new Zi(Yx), {
    start: n,
    tokens: Object.assign({
      groups: t
    }, rG)
  };
}
function iG(e, t) {
  const n = xje(t.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = n.length, i = [];
  let o = 0, s = 0;
  for (; s < r; ) {
    let a = e, c = null, u = 0, f = null, h = -1, m = -1;
    for (; s < r && (c = a.go(n[s])); )
      a = c, a.accepts() ? (h = 0, m = 0, f = a) : h >= 0 && (h += n[s].length, m++), u += n[s].length, o += n[s].length, s++;
    o -= h, s -= m, u -= h, i.push({
      t: f.t,
      // token type/name
      v: t.slice(o - u, o),
      // string value
      s: o - u,
      // start index
      e: o
      // end index (excluding)
    });
  }
  return i;
}
function xje(e) {
  const t = [], n = e.length;
  let r = 0;
  for (; r < n; ) {
    let i = e.charCodeAt(r), o, s = i < 55296 || i > 56319 || r + 1 === n || (o = e.charCodeAt(r + 1)) < 56320 || o > 57343 ? e[r] : e.slice(r, r + 2);
    t.push(s), r += s.length;
  }
  return t;
}
function Zl(e, t, n, r, i) {
  let o;
  const s = t.length;
  for (let a = 0; a < s - 1; a++) {
    const c = t[a];
    e.j[c] ? o = e.j[c] : (o = new Zi(r), o.jr = i.slice(), e.j[c] = o), e = o;
  }
  return o = new Zi(n), o.jr = i.slice(), e.j[t[s - 1]] = o, o;
}
function s3(e) {
  const t = [], n = [];
  let r = 0, i = "0123456789";
  for (; r < e.length; ) {
    let o = 0;
    for (; i.indexOf(e[r + o]) >= 0; )
      o++;
    if (o > 0) {
      t.push(n.join(""));
      for (let s = parseInt(e.substring(r, r + o), 10); s > 0; s--)
        n.pop();
      r += o;
    } else
      n.push(e[r]), r++;
  }
  return t;
}
const Lg = {
  defaultProtocol: "http",
  events: null,
  format: a3,
  formatHref: a3,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function mR(e, t = null) {
  let n = Object.assign({}, Lg);
  e && (n = Object.assign(n, e instanceof mR ? e.o : e));
  const r = n.ignoreTags, i = [];
  for (let o = 0; o < r.length; o++)
    i.push(r[o].toUpperCase());
  this.o = n, t && (this.defaultRender = t), this.ignoreTags = i;
}
mR.prototype = {
  o: Lg,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(e) {
    return e;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(e) {
    return this.get("validate", e.toString(), e);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(e, t, n) {
    const r = t != null;
    let i = this.o[e];
    return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : Lg[e], typeof i == "function" && r && (i = i(t, n))) : typeof i == "function" && r && (i = i(t, n.t, n)), i);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(e, t, n) {
    let r = this.o[e];
    return typeof r == "function" && t != null && (r = r(t, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(e) {
    const t = e.render(this);
    return (this.get("render", null, e) || this.defaultRender)(t, e.t, e);
  }
};
function a3(e) {
  return e;
}
function oG(e, t) {
  this.t = "token", this.v = e, this.tk = t;
}
oG.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(e) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(e) {
    const t = this.toString(), n = e.get("truncate", t, this), r = e.get("format", t, this);
    return n && r.length > n ? r.substring(0, n) + "" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(e) {
    return e.get("formatHref", this.toHref(e.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(e = Lg.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(e),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(e) {
    return {
      type: this.t,
      value: this.toFormattedString(e),
      isLink: this.isLink,
      href: this.toFormattedHref(e),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(e) {
    return e.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(e) {
    const t = this, n = this.toHref(e.get("defaultProtocol")), r = e.get("formatHref", n, this), i = e.get("tagName", n, t), o = this.toFormattedString(e), s = {}, a = e.get("className", n, t), c = e.get("target", n, t), u = e.get("rel", n, t), f = e.getObj("attributes", n, t), h = e.getObj("events", n, t);
    return s.href = r, a && (s.class = a), c && (s.target = c), u && (s.rel = u), f && Object.assign(s, f), {
      tagName: i,
      attributes: s,
      content: o,
      eventListeners: h
    };
  }
};
function x1(e, t) {
  class n extends oG {
    constructor(i, o) {
      super(i, o), this.t = e;
    }
  }
  for (const r in t)
    n.prototype[r] = t[r];
  return n.t = e, n;
}
const l3 = x1("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), c3 = x1("text"), wje = x1("nl"), x0 = x1("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(e = Lg.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${e}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const e = this.tk;
    return e.length >= 2 && e[0].t !== zg && e[1].t === uc;
  }
}), Po = (e) => new Zi(e);
function Sje({
  groups: e
}) {
  const t = e.domain.concat([Lx, $x, ac, Ux, Fx, Vx, Hx, Wx, zo, cR, tg, qx, Gx, Kx, Vs, Yx, rg, Zx]), n = [Bx, uc, dR, Fs, fR, tg, ng, hR, pR, Ax, Mx, Qm, eg, Ex, Cx, _x, Tx, Nx, Rx, Ox, Px, Dx, Ix, jx, zx], r = [Lx, Bx, $x, Ux, Fx, Vx, Hx, Wx, zo, Qm, eg, tg, qx, Gx, Kx, ng, Vs, Yx, rg, Zx], i = Po(), o = Ue(i, rg);
  jt(o, r, o), jt(o, e.domain, o);
  const s = Po(), a = Po(), c = Po();
  jt(i, e.domain, s), jt(i, e.scheme, a), jt(i, e.slashscheme, c), jt(s, r, o), jt(s, e.domain, s);
  const u = Ue(s, ac);
  Ue(o, ac, u), Ue(a, ac, u), Ue(c, ac, u);
  const f = Ue(o, Fs);
  jt(f, r, o), jt(f, e.domain, o);
  const h = Po();
  jt(u, e.domain, h), jt(h, e.domain, h);
  const m = Ue(h, Fs);
  jt(m, e.domain, h);
  const g = Po(l3);
  jt(m, e.tld, g), jt(m, e.utld, g), Ue(u, zg, g);
  const b = Ue(h, zo);
  Ue(b, zo, b), jt(b, e.domain, h), jt(g, e.domain, h), Ue(g, Fs, m), Ue(g, zo, b);
  const x = Ue(g, uc);
  jt(x, e.numeric, l3);
  const w = Ue(s, zo), S = Ue(s, Fs);
  Ue(w, zo, w), jt(w, e.domain, s), jt(S, r, o), jt(S, e.domain, s);
  const _ = Po(x0);
  jt(S, e.tld, _), jt(S, e.utld, _), jt(_, e.domain, s), jt(_, r, o), Ue(_, Fs, S), Ue(_, zo, w), Ue(_, ac, u);
  const M = Ue(_, uc), N = Po(x0);
  jt(M, e.numeric, N);
  const D = Po(x0), j = Po();
  jt(D, t, D), jt(D, n, j), jt(j, t, D), jt(j, n, j), Ue(_, Vs, D), Ue(N, Vs, D);
  const O = Ue(a, uc), L = Ue(c, uc), U = Ue(L, Vs), B = Ue(U, Vs);
  jt(a, e.domain, s), Ue(a, Fs, S), Ue(a, zo, w), jt(c, e.domain, s), Ue(c, Fs, S), Ue(c, zo, w), jt(O, e.domain, D), Ue(O, Vs, D), Ue(O, ng, D), jt(B, e.domain, D), jt(B, t, D), Ue(B, Vs, D);
  const G = [
    [Qm, eg],
    // {}
    [Cx, Ex],
    // []
    [_x, Tx],
    // ()
    [Ax, Mx],
    // <>
    [Nx, Rx],
    // 
    [Ox, Px],
    // 
    [Dx, Ix],
    // 
    [jx, zx]
    // 
  ];
  for (let Y = 0; Y < G.length; Y++) {
    const [he, ie] = G[Y], ne = Ue(D, he);
    Ue(j, he, ne), Ue(ne, ie, D);
    const H = Po(x0);
    jt(ne, t, H);
    const Q = Po();
    jt(ne, n), jt(H, t, H), jt(H, n, Q), jt(Q, t, H), jt(Q, n, Q), Ue(H, ie, D), Ue(Q, ie, D);
  }
  return Ue(i, zg, _), Ue(i, uR, wje), {
    start: i,
    tokens: rG
  };
}
function kje(e, t, n) {
  let r = n.length, i = 0, o = [], s = [];
  for (; i < r; ) {
    let a = e, c = null, u = null, f = 0, h = null, m = -1;
    for (; i < r && !(c = a.go(n[i].t)); )
      s.push(n[i++]);
    for (; i < r && (u = c || a.go(n[i].t)); )
      c = null, a = u, a.accepts() ? (m = 0, h = a) : m >= 0 && m++, i++, f++;
    if (m < 0)
      i -= f, i < r && (s.push(n[i]), i++);
    else {
      s.length > 0 && (o.push(AE(c3, t, s)), s = []), i -= m, f -= m;
      const g = h.t, b = n.slice(i - f, i);
      o.push(AE(g, t, b));
    }
  }
  return s.length > 0 && o.push(AE(c3, t, s)), o;
}
function AE(e, t, n) {
  const r = n[0].s, i = n[n.length - 1].e, o = t.slice(r, i);
  return new e(o, n);
}
const Cje = typeof console < "u" && console && console.warn || (() => {
}), Eje = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", Vn = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function _je() {
  return Zi.groups = {}, Vn.scanner = null, Vn.parser = null, Vn.tokenQueue = [], Vn.pluginQueue = [], Vn.customSchemes = [], Vn.initialized = !1, Vn;
}
function u3(e, t = !1) {
  if (Vn.initialized && Cje(`linkifyjs: already initialized - will not register custom scheme "${e}" ${Eje}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(e))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  Vn.customSchemes.push([e, t]);
}
function Tje() {
  Vn.scanner = bje(Vn.customSchemes);
  for (let e = 0; e < Vn.tokenQueue.length; e++)
    Vn.tokenQueue[e][1]({
      scanner: Vn.scanner
    });
  Vn.parser = Sje(Vn.scanner.tokens);
  for (let e = 0; e < Vn.pluginQueue.length; e++)
    Vn.pluginQueue[e][1]({
      scanner: Vn.scanner,
      parser: Vn.parser
    });
  return Vn.initialized = !0, Vn;
}
function gR(e) {
  return Vn.initialized || Tje(), kje(Vn.parser.start, e, iG(Vn.scanner.start, e));
}
gR.scan = iG;
function sG(e, t = null, n = null) {
  if (t && typeof t == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${t}; must be a string`);
    n = t, t = null;
  }
  const r = new mR(n), i = gR(e), o = [];
  for (let s = 0; s < i.length; s++) {
    const a = i[s];
    a.isLink && (!t || a.t === t) && r.check(a) && o.push(a.toFormattedObject(r));
  }
  return o;
}
var yR = "[\0- -\u2029]", Aje = new RegExp(yR), Mje = new RegExp(`${yR}$`), Nje = new RegExp(yR, "g");
function Rje(e) {
  return e.length === 1 ? e[0].isLink : e.length === 3 && e[1].isLink ? ["()", "[]"].includes(e[0].value + e[2].value) : !1;
}
function Oje(e) {
  return new Yn({
    key: new Ar("autolink"),
    appendTransaction: (t, n, r) => {
      const i = t.some((u) => u.docChanged) && !n.doc.eq(r.doc), o = t.some((u) => u.getMeta("preventAutolink"));
      if (!i || o)
        return;
      const { tr: s } = r, a = bq(n.doc, [...t]);
      if (_q(a).forEach(({ newRange: u }) => {
        const f = CPe(r.doc, u, (g) => g.isTextblock);
        let h, m;
        if (f.length > 1)
          h = f[0], m = r.doc.textBetween(
            h.pos,
            h.pos + h.node.nodeSize,
            void 0,
            " "
          );
        else if (f.length) {
          const g = r.doc.textBetween(u.from, u.to, " ", " ");
          if (!Mje.test(g))
            return;
          h = f[0], m = r.doc.textBetween(h.pos, u.to, void 0, " ");
        }
        if (h && m) {
          const g = m.split(Aje).filter(Boolean);
          if (g.length <= 0)
            return !1;
          const b = g[g.length - 1], x = h.pos + m.lastIndexOf(b);
          if (!b)
            return !1;
          const w = gR(b).map((S) => S.toObject(e.defaultProtocol));
          if (!Rje(w))
            return !1;
          w.filter((S) => S.isLink).map((S) => ({
            ...S,
            from: x + S.start + 1,
            to: x + S.end + 1
          })).filter((S) => r.schema.marks.code ? !r.doc.rangeHasMark(S.from, S.to, r.schema.marks.code) : !0).filter((S) => e.validate(S.value)).filter((S) => e.shouldAutoLink(S.value)).forEach((S) => {
            rR(S.from, S.to, r.doc).some((_) => _.mark.type === e.type) || s.addMark(
              S.from,
              S.to,
              e.type.create({
                href: S.href
              })
            );
          });
        }
      }), !!s.steps.length)
        return s;
    }
  });
}
function Pje(e) {
  return new Yn({
    key: new Ar("handleClickLink"),
    props: {
      handleClick: (t, n, r) => {
        var i, o;
        if (r.button !== 0 || !t.editable)
          return !1;
        let s = null;
        if (r.target instanceof HTMLAnchorElement)
          s = r.target;
        else {
          const c = r.target;
          if (!c)
            return !1;
          const u = e.editor.view.dom;
          s = c.closest("a"), s && !u.contains(s) && (s = null);
        }
        if (!s)
          return !1;
        let a = !1;
        if (e.enableClickSelection && (a = e.editor.commands.extendMarkRange(e.type.name)), e.openOnClick) {
          const c = Eq(t.state, e.type.name), u = (i = s.href) != null ? i : c.href, f = (o = s.target) != null ? o : c.target;
          u && (window.open(u, f), a = !0);
        }
        return a;
      }
    }
  });
}
function Dje(e) {
  return new Yn({
    key: new Ar("handlePasteLink"),
    props: {
      handlePaste: (t, n, r) => {
        const { shouldAutoLink: i } = e, { state: o } = t, { selection: s } = o, { empty: a } = s;
        if (a)
          return !1;
        let c = "";
        r.content.forEach((f) => {
          c += f.textContent;
        });
        const u = sG(c, { defaultProtocol: e.defaultProtocol }).find(
          (f) => f.isLink && f.value === c
        );
        return !c || !u || i !== void 0 && !i(u.value) ? !1 : e.editor.commands.setMark(e.type, {
          href: u.href
        });
      }
    }
  });
}
function Ru(e, t) {
  const n = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return t && t.forEach((r) => {
    const i = typeof r == "string" ? r : r.scheme;
    i && n.push(i);
  }), !e || e.replace(Nje, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var Ije = Ed.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((e) => {
      if (typeof e == "string") {
        u3(e);
        return;
      }
      u3(e.scheme, e.optionalSlashes);
    });
  },
  onDestroy() {
    _je();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      enableClickSelection: !1,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (e, t) => !!Ru(e, t.protocols),
      validate: (e) => !!e,
      shouldAutoLink: (e) => {
        const t = /^[a-z][a-z0-9+.-]*:\/\//i.test(e), n = /^[a-z][a-z0-9+.-]*:/i.test(e);
        if (t || n && !e.includes("@"))
          return !0;
        const i = (e.includes("@") ? e.split("@").pop() : e).split(/[/?#:]/)[0];
        return !(/^\d{1,3}(\.\d{1,3}){3}$/.test(i) || !/\./.test(i));
      }
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(e) {
          return e.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (e) => {
          const t = e.getAttribute("href");
          return !t || !this.options.isAllowedUri(t, {
            defaultValidate: (n) => !!Ru(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return this.options.isAllowedUri(e.href, {
      defaultValidate: (t) => !!Ru(t, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", sr(this.options.HTMLAttributes, e), 0] : ["a", sr(this.options.HTMLAttributes, { ...e, href: "" }), 0];
  },
  markdownTokenName: "link",
  parseMarkdown: (e, t) => t.applyMark("link", t.parseInline(e.tokens || []), {
    href: e.href,
    title: e.title || null
  }),
  renderMarkdown: (e, t) => {
    var n, r, i, o;
    const s = (r = (n = e.attrs) == null ? void 0 : n.href) != null ? r : "", a = (o = (i = e.attrs) == null ? void 0 : i.title) != null ? o : "", c = t.renderChildren(e);
    return a ? `[${c}](${s} "${a}")` : `[${c}](${s})`;
  },
  addCommands() {
    return {
      setLink: (e) => ({ chain: t }) => {
        const { href: n } = e;
        return this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!Ru(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? t().setMark(this.name, e).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (e) => ({ chain: t }) => {
        const { href: n } = e || {};
        return n && !this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!Ru(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? !1 : t().toggleMark(this.name, e, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run();
      },
      unsetLink: () => ({ chain: e }) => e().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      pd({
        find: (e) => {
          const t = [];
          if (e) {
            const { protocols: n, defaultProtocol: r } = this.options, i = sG(e).filter(
              (o) => o.isLink && this.options.isAllowedUri(o.value, {
                defaultValidate: (s) => !!Ru(s, n),
                protocols: n,
                defaultProtocol: r
              })
            );
            i.length && i.forEach((o) => {
              this.options.shouldAutoLink(o.value) && t.push({
                text: o.value,
                data: {
                  href: o.href
                },
                index: o.start
              });
            });
          }
          return t;
        },
        type: this.type,
        getAttributes: (e) => {
          var t;
          return {
            href: (t = e.data) == null ? void 0 : t.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const e = [], { protocols: t, defaultProtocol: n } = this.options;
    return this.options.autolink && e.push(
      Oje({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (r) => this.options.isAllowedUri(r, {
          defaultValidate: (i) => !!Ru(i, t),
          protocols: t,
          defaultProtocol: n
        }),
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), e.push(
      Pje({
        type: this.type,
        editor: this.editor,
        openOnClick: this.options.openOnClick === "whenNotEditable" ? !0 : this.options.openOnClick,
        enableClickSelection: this.options.enableClickSelection
      })
    ), this.options.linkOnPaste && e.push(
      Dje({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type,
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), e;
  }
}), jje = Object.defineProperty, zje = (e, t) => {
  for (var n in t)
    jje(e, n, { get: t[n], enumerable: !0 });
}, Lje = "listItem", d3 = "textStyle", f3 = /^\s*([-+*])\s$/, aG = Li.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [{ tag: "ul" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["ul", sr(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (e, t) => e.type !== "list" || e.ordered ? [] : {
    type: "bulletList",
    content: e.items ? t.parseChildren(e.items) : []
  },
  renderMarkdown: (e, t) => e.content ? t.renderChildren(e.content, `
`) : "",
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: e, chain: t }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Lje, this.editor.getAttributes(d3)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let e = Oh({
      find: f3,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (e = Oh({
      find: f3,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(d3),
      editor: this.editor
    })), [e];
  }
}), lG = Li.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["li", sr(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "list_item",
  parseMarkdown: (e, t) => {
    if (e.type !== "list_item")
      return [];
    let n = [];
    if (e.tokens && e.tokens.length > 0)
      if (e.tokens.some((i) => i.type === "paragraph"))
        n = t.parseChildren(e.tokens);
      else {
        const i = e.tokens[0];
        if (i && i.type === "text" && i.tokens && i.tokens.length > 0) {
          if (n = [
            {
              type: "paragraph",
              content: t.parseInline(i.tokens)
            }
          ], e.tokens.length > 1) {
            const s = e.tokens.slice(1), a = t.parseChildren(s);
            n.push(...a);
          }
        } else
          n = t.parseChildren(e.tokens);
      }
    return n.length === 0 && (n = [
      {
        type: "paragraph",
        content: []
      }
    ]), {
      type: "listItem",
      content: n
    };
  },
  renderMarkdown: (e, t, n) => aR(
    e,
    t,
    (r) => {
      var i, o;
      return r.parentType === "bulletList" ? "- " : r.parentType === "orderedList" ? `${(((o = (i = r.meta) == null ? void 0 : i.parentAttrs) == null ? void 0 : o.start) || 1) + r.index}. ` : "- ";
    },
    n
  ),
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), Bje = {};
zje(Bje, {
  findListItemPos: () => wy,
  getNextListDepth: () => vR,
  handleBackspace: () => nA,
  handleDelete: () => rA,
  hasListBefore: () => cG,
  hasListItemAfter: () => $je,
  hasListItemBefore: () => uG,
  listItemHasSubList: () => dG,
  nextListIsDeeper: () => fG,
  nextListIsHigher: () => hG
});
var wy = (e, t) => {
  const { $from: n } = t.selection, r = Tr(e, t.schema);
  let i = null, o = n.depth, s = n.pos, a = null;
  for (; o > 0 && a === null; )
    i = n.node(o), i.type === r ? a = o : (o -= 1, s -= 1);
  return a === null ? null : { $pos: t.doc.resolve(s), depth: a };
}, vR = (e, t) => {
  const n = wy(e, t);
  if (!n)
    return !1;
  const [, r] = DPe(t, e, n.$pos.pos + 4);
  return r;
}, cG = (e, t, n) => {
  const { $anchor: r } = e.selection, i = Math.max(0, r.pos - 2), o = e.doc.resolve(i).node();
  return !(!o || !n.includes(o.type.name));
}, uG = (e, t) => {
  var n;
  const { $anchor: r } = t.selection, i = t.doc.resolve(r.pos - 2);
  return !(i.index() === 0 || ((n = i.nodeBefore) == null ? void 0 : n.type.name) !== e);
}, dG = (e, t, n) => {
  if (!n)
    return !1;
  const r = Tr(e, t.schema);
  let i = !1;
  return n.descendants((o) => {
    o.type === r && (i = !0);
  }), i;
}, nA = (e, t, n) => {
  if (e.commands.undoInputRule())
    return !0;
  if (e.state.selection.from !== e.state.selection.to)
    return !1;
  if (!Lc(e.state, t) && cG(e.state, t, n)) {
    const { $anchor: a } = e.state.selection, c = e.state.doc.resolve(a.before() - 1), u = [];
    c.node().descendants((m, g) => {
      m.type.name === t && u.push({ node: m, pos: g });
    });
    const f = u.at(-1);
    if (!f)
      return !1;
    const h = e.state.doc.resolve(c.start() + f.pos + 1);
    return e.chain().cut({ from: a.start() - 1, to: a.end() + 1 }, h.end()).joinForward().run();
  }
  if (!Lc(e.state, t) || !LPe(e.state))
    return !1;
  const r = wy(t, e.state);
  if (!r)
    return !1;
  const o = e.state.doc.resolve(r.$pos.pos - 2).node(r.depth), s = dG(t, e.state, o);
  return uG(t, e.state) && !s ? e.commands.joinItemBackward() : e.chain().liftListItem(t).run();
}, fG = (e, t) => {
  const n = vR(e, t), r = wy(e, t);
  return !r || !n ? !1 : n > r.depth;
}, hG = (e, t) => {
  const n = vR(e, t), r = wy(e, t);
  return !r || !n ? !1 : n < r.depth;
}, rA = (e, t) => {
  if (!Lc(e.state, t) || !zPe(e.state, t))
    return !1;
  const { selection: n } = e.state, { $from: r, $to: i } = n;
  return !n.empty && r.sameParent(i) ? !1 : fG(t, e.state) ? e.chain().focus(e.state.selection.from + 4).lift(t).joinBackward().run() : hG(t, e.state) ? e.chain().joinForward().joinBackward().run() : e.commands.joinItemForward();
}, $je = (e, t) => {
  var n;
  const { $anchor: r } = t.selection, i = t.doc.resolve(r.pos - r.parentOffset - 2);
  return !(i.index() === i.parent.childCount - 1 || ((n = i.nodeAfter) == null ? void 0 : n.type.name) !== e);
}, pG = pr.create({
  name: "listKeymap",
  addOptions() {
    return {
      listTypes: [
        {
          itemName: "listItem",
          wrapperNames: ["bulletList", "orderedList"]
        },
        {
          itemName: "taskItem",
          wrapperNames: ["taskList"]
        }
      ]
    };
  },
  addKeyboardShortcuts() {
    return {
      Delete: ({ editor: e }) => {
        let t = !1;
        return this.options.listTypes.forEach(({ itemName: n }) => {
          e.state.schema.nodes[n] !== void 0 && rA(e, n) && (t = !0);
        }), t;
      },
      "Mod-Delete": ({ editor: e }) => {
        let t = !1;
        return this.options.listTypes.forEach(({ itemName: n }) => {
          e.state.schema.nodes[n] !== void 0 && rA(e, n) && (t = !0);
        }), t;
      },
      Backspace: ({ editor: e }) => {
        let t = !1;
        return this.options.listTypes.forEach(({ itemName: n, wrapperNames: r }) => {
          e.state.schema.nodes[n] !== void 0 && nA(e, n, r) && (t = !0);
        }), t;
      },
      "Mod-Backspace": ({ editor: e }) => {
        let t = !1;
        return this.options.listTypes.forEach(({ itemName: n, wrapperNames: r }) => {
          e.state.schema.nodes[n] !== void 0 && nA(e, n, r) && (t = !0);
        }), t;
      }
    };
  }
}), h3 = /^(\s*)(\d+)\.\s+(.*)$/, Uje = /^\s/;
function Fje(e) {
  const t = [];
  let n = 0, r = 0;
  for (; n < e.length; ) {
    const i = e[n], o = i.match(h3);
    if (!o)
      break;
    const [, s, a, c] = o, u = s.length;
    let f = c, h = n + 1;
    const m = [i];
    for (; h < e.length; ) {
      const g = e[h];
      if (g.match(h3))
        break;
      if (g.trim() === "")
        m.push(g), f += `
`, h += 1;
      else if (g.match(Uje))
        m.push(g), f += `
${g.slice(u + 2)}`, h += 1;
      else
        break;
    }
    t.push({
      indent: u,
      number: parseInt(a, 10),
      content: f.trim(),
      raw: m.join(`
`)
    }), r = h, n = h;
  }
  return [t, r];
}
function mG(e, t, n) {
  var r;
  const i = [];
  let o = 0;
  for (; o < e.length; ) {
    const s = e[o];
    if (s.indent === t) {
      const a = s.content.split(`
`), c = ((r = a[0]) == null ? void 0 : r.trim()) || "", u = [];
      c && u.push({
        type: "paragraph",
        raw: c,
        tokens: n.inlineTokens(c)
      });
      const f = a.slice(1).join(`
`).trim();
      if (f) {
        const g = n.blockTokens(f);
        u.push(...g);
      }
      let h = o + 1;
      const m = [];
      for (; h < e.length && e[h].indent > t; )
        m.push(e[h]), h += 1;
      if (m.length > 0) {
        const g = Math.min(...m.map((x) => x.indent)), b = mG(m, g, n);
        u.push({
          type: "list",
          ordered: !0,
          start: m[0].number,
          items: b,
          raw: m.map((x) => x.raw).join(`
`)
        });
      }
      i.push({
        type: "list_item",
        raw: s.raw,
        tokens: u
      }), o = h;
    } else
      o += 1;
  }
  return i;
}
function Vje(e, t) {
  return e.map((n) => {
    if (n.type !== "list_item")
      return t.parseChildren([n])[0];
    const r = [];
    return n.tokens && n.tokens.length > 0 && n.tokens.forEach((i) => {
      if (i.type === "paragraph" || i.type === "list" || i.type === "blockquote" || i.type === "code")
        r.push(...t.parseChildren([i]));
      else if (i.type === "text" && i.tokens) {
        const o = t.parseChildren([i]);
        r.push({
          type: "paragraph",
          content: o
        });
      } else {
        const o = t.parseChildren([i]);
        o.length > 0 && r.push(...o);
      }
    }), {
      type: "listItem",
      content: r
    };
  });
}
var Hje = "listItem", p3 = "textStyle", m3 = /^(\d+)\.\s$/, gG = Li.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (e) => e.hasAttribute("start") ? parseInt(e.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: null,
        parseHTML: (e) => e.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    const { start: t, ...n } = e;
    return t === 1 ? ["ol", sr(this.options.HTMLAttributes, n), 0] : ["ol", sr(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (e, t) => {
    if (e.type !== "list" || !e.ordered)
      return [];
    const n = e.start || 1, r = e.items ? Vje(e.items, t) : [];
    return n !== 1 ? {
      type: "orderedList",
      attrs: { start: n },
      content: r
    } : {
      type: "orderedList",
      content: r
    };
  },
  renderMarkdown: (e, t) => e.content ? t.renderChildren(e.content, `
`) : "",
  markdownTokenizer: {
    name: "orderedList",
    level: "block",
    start: (e) => {
      const t = e.match(/^(\s*)(\d+)\.\s+/), n = t?.index;
      return n !== void 0 ? n : -1;
    },
    tokenize: (e, t, n) => {
      var r;
      const i = e.split(`
`), [o, s] = Fje(i);
      if (o.length === 0)
        return;
      const a = mG(o, 0, n);
      return a.length === 0 ? void 0 : {
        type: "list",
        ordered: !0,
        start: ((r = o[0]) == null ? void 0 : r.number) || 1,
        items: a,
        raw: i.slice(0, s).join(`
`)
      };
    }
  },
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: e, chain: t }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Hje, this.editor.getAttributes(p3)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let e = Oh({
      find: m3,
      type: this.type,
      getAttributes: (t) => ({ start: +t[1] }),
      joinPredicate: (t, n) => n.childCount + n.attrs.start === +t[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (e = Oh({
      find: m3,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (t) => ({ start: +t[1], ...this.editor.getAttributes(p3) }),
      joinPredicate: (t, n) => n.childCount + n.attrs.start === +t[1],
      editor: this.editor
    })), [e];
  }
}), Wje = /^\s*(\[([( |x])?\])\s$/, qje = Li.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList",
      a11y: void 0
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (e) => {
          const t = e.getAttribute("data-checked");
          return t === "" || t === "true";
        },
        renderHTML: (e) => ({
          "data-checked": e.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "li",
      sr(this.options.HTMLAttributes, t, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: e.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  parseMarkdown: (e, t) => {
    const n = [];
    if (e.tokens && e.tokens.length > 0 ? n.push(t.createNode("paragraph", {}, t.parseInline(e.tokens))) : e.text ? n.push(t.createNode("paragraph", {}, [t.createNode("text", { text: e.text })])) : n.push(t.createNode("paragraph", {}, [])), e.nestedTokens && e.nestedTokens.length > 0) {
      const r = t.parseChildren(e.nestedTokens);
      n.push(...r);
    }
    return t.createNode("taskItem", { checked: e.checked || !1 }, n);
  },
  renderMarkdown: (e, t) => {
    var n;
    const i = `- [${(n = e.attrs) != null && n.checked ? "x" : " "}] `;
    return aR(e, t, i);
  },
  addKeyboardShortcuts() {
    const e = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...e,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : e;
  },
  addNodeView() {
    return ({ node: e, HTMLAttributes: t, getPos: n, editor: r }) => {
      const i = document.createElement("li"), o = document.createElement("label"), s = document.createElement("span"), a = document.createElement("input"), c = document.createElement("div"), u = (h) => {
        var m, g;
        a.ariaLabel = ((g = (m = this.options.a11y) == null ? void 0 : m.checkboxLabel) == null ? void 0 : g.call(m, h, a.checked)) || `Task item checkbox for ${h.textContent || "empty task item"}`;
      };
      u(e), o.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (h) => h.preventDefault()), a.addEventListener("change", (h) => {
        if (!r.isEditable && !this.options.onReadOnlyChecked) {
          a.checked = !a.checked;
          return;
        }
        const { checked: m } = h.target;
        r.isEditable && typeof n == "function" && r.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: g }) => {
          const b = n();
          if (typeof b != "number")
            return !1;
          const x = g.doc.nodeAt(b);
          return g.setNodeMarkup(b, void 0, {
            ...x?.attrs,
            checked: m
          }), !0;
        }).run(), !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(e, m) || (a.checked = !a.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([h, m]) => {
        i.setAttribute(h, m);
      }), i.dataset.checked = e.attrs.checked, a.checked = e.attrs.checked, o.append(a, s), i.append(o, c), Object.entries(t).forEach(([h, m]) => {
        i.setAttribute(h, m);
      });
      let f = new Set(Object.keys(t));
      return {
        dom: i,
        contentDOM: c,
        update: (h) => {
          if (h.type !== this.type)
            return !1;
          i.dataset.checked = h.attrs.checked, a.checked = h.attrs.checked, u(h);
          const m = r.extensionManager.attributes, g = Nh(h, m), b = new Set(Object.keys(g)), x = this.options.HTMLAttributes;
          return f.forEach((w) => {
            b.has(w) || (w in x ? i.setAttribute(w, x[w]) : i.removeAttribute(w));
          }), Object.entries(g).forEach(([w, S]) => {
            S == null ? w in x ? i.setAttribute(w, x[w]) : i.removeAttribute(w) : i.setAttribute(w, S);
          }), f = b, !0;
        }
      };
    };
  },
  addInputRules() {
    return [
      Oh({
        find: Wje,
        type: this.type,
        getAttributes: (e) => ({
          checked: e[e.length - 1] === "x"
        })
      })
    ];
  }
}), Gje = Li.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["ul", sr(this.options.HTMLAttributes, e, { "data-type": this.name }), 0];
  },
  parseMarkdown: (e, t) => t.createNode("taskList", {}, t.parseChildren(e.items || [])),
  renderMarkdown: (e, t) => e.content ? t.renderChildren(e.content, `
`) : "",
  markdownTokenizer: {
    name: "taskList",
    level: "block",
    start(e) {
      var t;
      const n = (t = e.match(/^\s*[-+*]\s+\[([ xX])\]\s+/)) == null ? void 0 : t.index;
      return n !== void 0 ? n : -1;
    },
    tokenize(e, t, n) {
      const r = (o) => {
        const s = qT(
          o,
          {
            itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
            extractItemData: (a) => ({
              indentLevel: a[1].length,
              mainContent: a[4],
              checked: a[3].toLowerCase() === "x"
            }),
            createToken: (a, c) => ({
              type: "taskItem",
              raw: "",
              mainContent: a.mainContent,
              indentLevel: a.indentLevel,
              checked: a.checked,
              text: a.mainContent,
              tokens: n.inlineTokens(a.mainContent),
              nestedTokens: c
            }),
            // Allow recursive nesting
            customNestedParser: r
          },
          n
        );
        return s ? [
          {
            type: "taskList",
            raw: s.raw,
            items: s.items
          }
        ] : n.blockTokens(o);
      }, i = qT(
        e,
        {
          itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
          extractItemData: (o) => ({
            indentLevel: o[1].length,
            mainContent: o[4],
            checked: o[3].toLowerCase() === "x"
          }),
          createToken: (o, s) => ({
            type: "taskItem",
            raw: "",
            mainContent: o.mainContent,
            indentLevel: o.indentLevel,
            checked: o.checked,
            text: o.mainContent,
            tokens: n.inlineTokens(o.mainContent),
            nestedTokens: s
          }),
          // Use the recursive parser for nested content
          customNestedParser: r
        },
        n
      );
      if (i)
        return {
          type: "taskList",
          raw: i.raw,
          items: i.items
        };
    }
  },
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: e }) => e.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
pr.create({
  name: "listKit",
  addExtensions() {
    const e = [];
    return this.options.bulletList !== !1 && e.push(aG.configure(this.options.bulletList)), this.options.listItem !== !1 && e.push(lG.configure(this.options.listItem)), this.options.listKeymap !== !1 && e.push(pG.configure(this.options.listKeymap)), this.options.orderedList !== !1 && e.push(gG.configure(this.options.orderedList)), this.options.taskItem !== !1 && e.push(qje.configure(this.options.taskItem)), this.options.taskList !== !1 && e.push(Gje.configure(this.options.taskList)), e;
  }
});
var g3 = "&nbsp;", Kje = "", Zje = Li.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["p", sr(this.options.HTMLAttributes, e), 0];
  },
  parseMarkdown: (e, t) => {
    const n = e.tokens || [];
    if (n.length === 1 && n[0].type === "image")
      return t.parseChildren([n[0]]);
    const r = t.parseInline(n);
    return r.length === 1 && r[0].type === "text" && (r[0].text === g3 || r[0].text === Kje) ? t.createNode("paragraph", void 0, []) : t.createNode("paragraph", void 0, r);
  },
  renderMarkdown: (e, t) => {
    if (!e)
      return "";
    const n = Array.isArray(e.content) ? e.content : [];
    return n.length === 0 ? g3 : t.renderChildren(n);
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: e }) => e.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), Yje = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, Xje = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, Jje = Ed.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (e) => e.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["s", sr(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "del",
  parseMarkdown: (e, t) => t.applyMark("strike", t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => `~~${t.renderChildren(e)}~~`,
  addCommands() {
    return {
      setStrike: () => ({ commands: e }) => e.setMark(this.name),
      toggleStrike: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetStrike: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Rh({
        find: Yje,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      pd({
        find: Xje,
        type: this.type
      })
    ];
  }
}), Qje = Li.create({
  name: "text",
  group: "inline",
  parseMarkdown: (e) => ({
    type: "text",
    text: e.text || ""
  }),
  renderMarkdown: (e) => e.text || ""
}), eze = Ed.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (e) => e.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["u", sr(this.options.HTMLAttributes, e), 0];
  },
  parseMarkdown(e, t) {
    return t.applyMark(this.name || "underline", t.parseInline(e.tokens || []));
  },
  renderMarkdown(e, t) {
    return `++${t.renderChildren(e)}++`;
  },
  markdownTokenizer: {
    name: "underline",
    level: "inline",
    start(e) {
      return e.indexOf("++");
    },
    tokenize(e, t, n) {
      const i = /^(\+\+)([\s\S]+?)(\+\+)/.exec(e);
      if (!i)
        return;
      const o = i[2].trim();
      return {
        type: "underline",
        raw: i[0],
        text: o,
        tokens: n.inlineTokens(o)
      };
    }
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: e }) => e.setMark(this.name),
      toggleUnderline: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetUnderline: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
function tze(e = {}) {
  return new Yn({
    view(t) {
      return new nze(t, e);
    }
  });
}
class nze {
  constructor(t, n) {
    var r;
    this.editorView = t, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let o = (s) => {
        this[i](s);
      };
      return t.dom.addEventListener(i, o), { name: i, handler: o };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: t, handler: n }) => this.editorView.dom.removeEventListener(t, n));
  }
  update(t, n) {
    this.cursorPos != null && n.doc != t.state.doc && (this.cursorPos > t.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(t) {
    t != this.cursorPos && (this.cursorPos = t, t == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let t = this.editorView.state.doc.resolve(this.cursorPos), n = !t.parent.inlineContent, r, i = this.editorView.dom, o = i.getBoundingClientRect(), s = o.width / i.offsetWidth, a = o.height / i.offsetHeight;
    if (n) {
      let h = t.nodeBefore, m = t.nodeAfter;
      if (h || m) {
        let g = this.editorView.nodeDOM(this.cursorPos - (h ? h.nodeSize : 0));
        if (g) {
          let b = g.getBoundingClientRect(), x = h ? b.bottom : b.top;
          h && m && (x = (x + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let w = this.width / 2 * a;
          r = { left: b.left, right: b.right, top: x - w, bottom: x + w };
        }
      }
    }
    if (!r) {
      let h = this.editorView.coordsAtPos(this.cursorPos), m = this.width / 2 * s;
      r = { left: h.left - m, right: h.left + m, top: h.top, bottom: h.bottom };
    }
    let c = this.editorView.dom.offsetParent;
    this.element || (this.element = c.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let u, f;
    if (!c || c == document.body && getComputedStyle(c).position == "static")
      u = -pageXOffset, f = -pageYOffset;
    else {
      let h = c.getBoundingClientRect(), m = h.width / c.offsetWidth, g = h.height / c.offsetHeight;
      u = h.left - c.scrollLeft * m, f = h.top - c.scrollTop * g;
    }
    this.element.style.left = (r.left - u) / s + "px", this.element.style.top = (r.top - f) / a + "px", this.element.style.width = (r.right - r.left) / s + "px", this.element.style.height = (r.bottom - r.top) / a + "px";
  }
  scheduleRemoval(t) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), t);
  }
  dragover(t) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: t.clientX, top: t.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), i = r && r.type.spec.disableDropCursor, o = typeof i == "function" ? i(this.editorView, n, t) : i;
    if (n && !o) {
      let s = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = uW(this.editorView.state.doc, s, this.editorView.dragging.slice);
        a != null && (s = a);
      }
      this.setCursor(s), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(t) {
    this.editorView.dom.contains(t.relatedTarget) || this.setCursor(null);
  }
}
class ir extends Lt {
  /**
  Create a gap cursor.
  */
  constructor(t) {
    super(t, t);
  }
  map(t, n) {
    let r = t.resolve(n.map(this.head));
    return ir.valid(r) ? new ir(r) : Lt.near(r);
  }
  content() {
    return et.empty;
  }
  eq(t) {
    return t instanceof ir && t.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new ir(t.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new bR(this.anchor);
  }
  /**
  @internal
  */
  static valid(t) {
    let n = t.parent;
    if (n.isTextblock || !rze(t) || !ize(t))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = n.contentMatchAt(t.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(t, n, r = !1) {
    e: for (; ; ) {
      if (!r && ir.valid(t))
        return t;
      let i = t.pos, o = null;
      for (let s = t.depth; ; s--) {
        let a = t.node(s);
        if (n > 0 ? t.indexAfter(s) < a.childCount : t.index(s) > 0) {
          o = a.child(n > 0 ? t.indexAfter(s) : t.index(s) - 1);
          break;
        } else if (s == 0)
          return null;
        i += n;
        let c = t.doc.resolve(i);
        if (ir.valid(c))
          return c;
      }
      for (; ; ) {
        let s = n > 0 ? o.firstChild : o.lastChild;
        if (!s) {
          if (o.isAtom && !o.isText && !pt.isSelectable(o)) {
            t = t.doc.resolve(i + o.nodeSize * n), r = !1;
            continue e;
          }
          break;
        }
        o = s, i += n;
        let a = t.doc.resolve(i);
        if (ir.valid(a))
          return a;
      }
      return null;
    }
  }
}
ir.prototype.visible = !1;
ir.findFrom = ir.findGapCursorFrom;
Lt.jsonID("gapcursor", ir);
class bR {
  constructor(t) {
    this.pos = t;
  }
  map(t) {
    return new bR(t.map(this.pos));
  }
  resolve(t) {
    let n = t.resolve(this.pos);
    return ir.valid(n) ? new ir(n) : Lt.near(n);
  }
}
function yG(e) {
  return e.isAtom || e.spec.isolating || e.spec.createGapCursor;
}
function rze(e) {
  for (let t = e.depth; t >= 0; t--) {
    let n = e.index(t), r = e.node(t);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || yG(i.type))
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function ize(e) {
  for (let t = e.depth; t >= 0; t--) {
    let n = e.indexAfter(t), r = e.node(t);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || yG(i.type))
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function oze() {
  return new Yn({
    props: {
      decorations: cze,
      createSelectionBetween(e, t, n) {
        return t.pos == n.pos && ir.valid(n) ? new ir(n) : null;
      },
      handleClick: aze,
      handleKeyDown: sze,
      handleDOMEvents: { beforeinput: lze }
    }
  });
}
const sze = dq({
  ArrowLeft: w0("horiz", -1),
  ArrowRight: w0("horiz", 1),
  ArrowUp: w0("vert", -1),
  ArrowDown: w0("vert", 1)
});
function w0(e, t) {
  const n = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
  return function(r, i, o) {
    let s = r.selection, a = t > 0 ? s.$to : s.$from, c = s.empty;
    if (s instanceof Ct) {
      if (!o.endOfTextblock(n) || a.depth == 0)
        return !1;
      c = !1, a = r.doc.resolve(t > 0 ? a.after() : a.before());
    }
    let u = ir.findGapCursorFrom(a, t, c);
    return u ? (i && i(r.tr.setSelection(new ir(u))), !0) : !1;
  };
}
function aze(e, t, n) {
  if (!e || !e.editable)
    return !1;
  let r = e.state.doc.resolve(t);
  if (!ir.valid(r))
    return !1;
  let i = e.posAtCoords({ left: n.clientX, top: n.clientY });
  return i && i.inside > -1 && pt.isSelectable(e.state.doc.nodeAt(i.inside)) ? !1 : (e.dispatch(e.state.tr.setSelection(new ir(r))), !0);
}
function lze(e, t) {
  if (t.inputType != "insertCompositionText" || !(e.state.selection instanceof ir))
    return !1;
  let { $from: n } = e.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(e.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = $e.empty;
  for (let s = r.length - 1; s >= 0; s--)
    i = $e.from(r[s].createAndFill(null, i));
  let o = e.state.tr.replace(n.pos, n.pos, new et(i, 0, 0));
  return o.setSelection(Ct.near(o.doc.resolve(n.pos + 1))), e.dispatch(o), !1;
}
function cze(e) {
  if (!(e.selection instanceof ir))
    return null;
  let t = document.createElement("div");
  return t.className = "ProseMirror-gapcursor", Gn.create(e.doc, [xi.widget(e.selection.head, t, { key: "gapcursor" })]);
}
var Xx = 200, Gr = function() {
};
Gr.prototype.append = function(t) {
  return t.length ? (t = Gr.from(t), !this.length && t || t.length < Xx && this.leafAppend(t) || this.length < Xx && t.leafPrepend(this) || this.appendInner(t)) : this;
};
Gr.prototype.prepend = function(t) {
  return t.length ? Gr.from(t).append(this) : this;
};
Gr.prototype.appendInner = function(t) {
  return new uze(this, t);
};
Gr.prototype.slice = function(t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = this.length), t >= n ? Gr.empty : this.sliceInner(Math.max(0, t), Math.min(this.length, n));
};
Gr.prototype.get = function(t) {
  if (!(t < 0 || t >= this.length))
    return this.getInner(t);
};
Gr.prototype.forEach = function(t, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(t, n, r, 0) : this.forEachInvertedInner(t, n, r, 0);
};
Gr.prototype.map = function(t, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(o, s) {
    return i.push(t(o, s));
  }, n, r), i;
};
Gr.from = function(t) {
  return t instanceof Gr ? t : t && t.length ? new vG(t) : Gr.empty;
};
var vG = /* @__PURE__ */ (function(e) {
  function t(r) {
    e.call(this), this.values = r;
  }
  e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return t.prototype.flatten = function() {
    return this.values;
  }, t.prototype.sliceInner = function(i, o) {
    return i == 0 && o == this.length ? this : new t(this.values.slice(i, o));
  }, t.prototype.getInner = function(i) {
    return this.values[i];
  }, t.prototype.forEachInner = function(i, o, s, a) {
    for (var c = o; c < s; c++)
      if (i(this.values[c], a + c) === !1)
        return !1;
  }, t.prototype.forEachInvertedInner = function(i, o, s, a) {
    for (var c = o - 1; c >= s; c--)
      if (i(this.values[c], a + c) === !1)
        return !1;
  }, t.prototype.leafAppend = function(i) {
    if (this.length + i.length <= Xx)
      return new t(this.values.concat(i.flatten()));
  }, t.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= Xx)
      return new t(i.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(t.prototype, n), t;
})(Gr);
Gr.empty = new vG([]);
var uze = /* @__PURE__ */ (function(e) {
  function t(n, r) {
    e.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, t.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, t.prototype.forEachInner = function(r, i, o, s) {
    var a = this.left.length;
    if (i < a && this.left.forEachInner(r, i, Math.min(o, a), s) === !1 || o > a && this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, o) - a, s + a) === !1)
      return !1;
  }, t.prototype.forEachInvertedInner = function(r, i, o, s) {
    var a = this.left.length;
    if (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(o, a) - a, s + a) === !1 || o < a && this.left.forEachInvertedInner(r, Math.min(i, a), o, s) === !1)
      return !1;
  }, t.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var o = this.left.length;
    return i <= o ? this.left.slice(r, i) : r >= o ? this.right.slice(r - o, i - o) : this.left.slice(r, o).append(this.right.slice(0, i - o));
  }, t.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new t(this.left, i);
  }, t.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new t(i, this.right);
  }, t.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new t(this.left, new t(this.right, r)) : new t(this, r);
  }, t;
})(Gr);
const dze = 500;
class ds {
  constructor(t, n) {
    this.items = t, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(t, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, o;
    n && (i = this.remapping(r, this.items.length), o = i.maps.length);
    let s = t.tr, a, c, u = [], f = [];
    return this.items.forEach((h, m) => {
      if (!h.step) {
        i || (i = this.remapping(r, m + 1), o = i.maps.length), o--, f.push(h);
        return;
      }
      if (i) {
        f.push(new Hs(h.map));
        let g = h.step.map(i.slice(o)), b;
        g && s.maybeStep(g).doc && (b = s.mapping.maps[s.mapping.maps.length - 1], u.push(new Hs(b, void 0, void 0, u.length + f.length))), o--, b && i.appendMap(b, o);
      } else
        s.maybeStep(h.step);
      if (h.selection)
        return a = i ? h.selection.map(i.slice(o)) : h.selection, c = new ds(this.items.slice(0, r).append(f.reverse().concat(u)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: c, transform: s, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(t, n, r, i) {
    let o = [], s = this.eventCount, a = this.items, c = !i && a.length ? a.get(a.length - 1) : null;
    for (let f = 0; f < t.steps.length; f++) {
      let h = t.steps[f].invert(t.docs[f]), m = new Hs(t.mapping.maps[f], h, n), g;
      (g = c && c.merge(m)) && (m = g, f ? o.pop() : a = a.slice(0, a.length - 1)), o.push(m), n && (s++, n = void 0), i || (c = m);
    }
    let u = s - r.depth;
    return u > hze && (a = fze(a, u), s -= u), new ds(a.append(o), s);
  }
  remapping(t, n) {
    let r = new Ng();
    return this.items.forEach((i, o) => {
      let s = i.mirrorOffset != null && o - i.mirrorOffset >= t ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, s);
    }, t, n), r;
  }
  addMaps(t) {
    return this.eventCount == 0 ? this : new ds(this.items.append(t.map((n) => new Hs(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(t, n) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - n), o = t.mapping, s = t.steps.length, a = this.eventCount;
    this.items.forEach((m) => {
      m.selection && a--;
    }, i);
    let c = n;
    this.items.forEach((m) => {
      let g = o.getMirror(--c);
      if (g == null)
        return;
      s = Math.min(s, g);
      let b = o.maps[g];
      if (m.step) {
        let x = t.steps[g].invert(t.docs[g]), w = m.selection && m.selection.map(o.slice(c + 1, g));
        w && a++, r.push(new Hs(b, x, w));
      } else
        r.push(new Hs(b));
    }, i);
    let u = [];
    for (let m = n; m < s; m++)
      u.push(new Hs(o.maps[m]));
    let f = this.items.slice(0, i).append(u).append(r), h = new ds(f, a);
    return h.emptyItemCount() > dze && (h = h.compress(this.items.length - r.length)), h;
  }
  emptyItemCount() {
    let t = 0;
    return this.items.forEach((n) => {
      n.step || t++;
    }), t;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(t = this.items.length) {
    let n = this.remapping(0, t), r = n.maps.length, i = [], o = 0;
    return this.items.forEach((s, a) => {
      if (a >= t)
        i.push(s), s.selection && o++;
      else if (s.step) {
        let c = s.step.map(n.slice(r)), u = c && c.getMap();
        if (r--, u && n.appendMap(u, r), c) {
          let f = s.selection && s.selection.map(n.slice(r));
          f && o++;
          let h = new Hs(u.invert(), c, f), m, g = i.length - 1;
          (m = i.length && i[g].merge(h)) ? i[g] = m : i.push(h);
        }
      } else s.map && r--;
    }, this.items.length, 0), new ds(Gr.from(i.reverse()), o);
  }
}
ds.empty = new ds(Gr.empty, 0);
function fze(e, t) {
  let n;
  return e.forEach((r, i) => {
    if (r.selection && t-- == 0)
      return n = i, !1;
  }), e.slice(n);
}
class Hs {
  constructor(t, n, r, i) {
    this.map = t, this.step = n, this.selection = r, this.mirrorOffset = i;
  }
  merge(t) {
    if (this.step && t.step && !t.selection) {
      let n = t.step.merge(this.step);
      if (n)
        return new Hs(n.getMap().invert(), n, this.selection);
    }
  }
}
class lc {
  constructor(t, n, r, i, o) {
    this.done = t, this.undone = n, this.prevRanges = r, this.prevTime = i, this.prevComposition = o;
  }
}
const hze = 20;
function pze(e, t, n, r) {
  let i = n.getMeta(Ju), o;
  if (i)
    return i.historyState;
  n.getMeta(yze) && (e = new lc(e.done, e.undone, null, 0, -1));
  let s = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return e;
  if (s && s.getMeta(Ju))
    return s.getMeta(Ju).redo ? new lc(e.done.addTransform(n, void 0, r, ob(t)), e.undone, y3(n.mapping.maps), e.prevTime, e.prevComposition) : new lc(e.done, e.undone.addTransform(n, void 0, r, ob(t)), null, e.prevTime, e.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(s && s.getMeta("addToHistory") === !1)) {
    let a = n.getMeta("composition"), c = e.prevTime == 0 || !s && e.prevComposition != a && (e.prevTime < (n.time || 0) - r.newGroupDelay || !mze(n, e.prevRanges)), u = s ? ME(e.prevRanges, n.mapping) : y3(n.mapping.maps);
    return new lc(e.done.addTransform(n, c ? t.selection.getBookmark() : void 0, r, ob(t)), ds.empty, u, n.time, a ?? e.prevComposition);
  } else return (o = n.getMeta("rebased")) ? new lc(e.done.rebased(n, o), e.undone.rebased(n, o), ME(e.prevRanges, n.mapping), e.prevTime, e.prevComposition) : new lc(e.done.addMaps(n.mapping.maps), e.undone.addMaps(n.mapping.maps), ME(e.prevRanges, n.mapping), e.prevTime, e.prevComposition);
}
function mze(e, t) {
  if (!t)
    return !1;
  if (!e.docChanged)
    return !0;
  let n = !1;
  return e.mapping.maps[0].forEach((r, i) => {
    for (let o = 0; o < t.length; o += 2)
      r <= t[o + 1] && i >= t[o] && (n = !0);
  }), n;
}
function y3(e) {
  let t = [];
  for (let n = e.length - 1; n >= 0 && t.length == 0; n--)
    e[n].forEach((r, i, o, s) => t.push(o, s));
  return t;
}
function ME(e, t) {
  if (!e)
    return null;
  let n = [];
  for (let r = 0; r < e.length; r += 2) {
    let i = t.map(e[r], 1), o = t.map(e[r + 1], -1);
    i <= o && n.push(i, o);
  }
  return n;
}
function gze(e, t, n) {
  let r = ob(t), i = Ju.get(t).spec.config, o = (n ? e.undone : e.done).popEvent(t, r);
  if (!o)
    return null;
  let s = o.selection.resolve(o.transform.doc), a = (n ? e.done : e.undone).addTransform(o.transform, t.selection.getBookmark(), i, r), c = new lc(n ? a : o.remaining, n ? o.remaining : a, null, 0, -1);
  return o.transform.setSelection(s).setMeta(Ju, { redo: n, historyState: c });
}
let NE = !1, v3 = null;
function ob(e) {
  let t = e.plugins;
  if (v3 != t) {
    NE = !1, v3 = t;
    for (let n = 0; n < t.length; n++)
      if (t[n].spec.historyPreserveItems) {
        NE = !0;
        break;
      }
  }
  return NE;
}
const Ju = new Ar("history"), yze = new Ar("closeHistory");
function vze(e = {}) {
  return e = {
    depth: e.depth || 100,
    newGroupDelay: e.newGroupDelay || 500
  }, new Yn({
    key: Ju,
    state: {
      init() {
        return new lc(ds.empty, ds.empty, null, 0, -1);
      },
      apply(t, n, r) {
        return pze(n, r, t, e);
      }
    },
    config: e,
    props: {
      handleDOMEvents: {
        beforeinput(t, n) {
          let r = n.inputType, i = r == "historyUndo" ? xG : r == "historyRedo" ? wG : null;
          return !i || !t.editable ? !1 : (n.preventDefault(), i(t.state, t.dispatch));
        }
      }
    }
  });
}
function bG(e, t) {
  return (n, r) => {
    let i = Ju.getState(n);
    if (!i || (e ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let o = gze(i, n, e);
      o && r(t ? o.scrollIntoView() : o);
    }
    return !0;
  };
}
const xG = bG(!1, !0), wG = bG(!0, !0);
pr.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (e) => e.length,
      wordCounter: (e) => e.split(" ").filter((t) => t !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (e) => {
      const t = e?.node || this.editor.state.doc;
      if ((e?.mode || this.options.mode) === "textSize") {
        const r = t.textBetween(0, t.content.size, void 0, " ");
        return this.options.textCounter(r);
      }
      return t.nodeSize;
    }, this.storage.words = (e) => {
      const t = e?.node || this.editor.state.doc, n = t.textBetween(0, t.content.size, " ", " ");
      return this.options.wordCounter(n);
    };
  },
  addProseMirrorPlugins() {
    let e = !1;
    return [
      new Yn({
        key: new Ar("characterCount"),
        appendTransaction: (t, n, r) => {
          if (e)
            return;
          const i = this.options.limit;
          if (i == null || i === 0) {
            e = !0;
            return;
          }
          const o = this.storage.characters({ node: r.doc });
          if (o > i) {
            const s = o - i, a = 0, c = s;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${i} characters. Content was automatically trimmed.`
            );
            const u = r.tr.deleteRange(a, c);
            return e = !0, u;
          }
          e = !0;
        },
        filterTransaction: (t, n) => {
          const r = this.options.limit;
          if (!t.docChanged || r === 0 || r === null || r === void 0)
            return !0;
          const i = this.storage.characters({ node: n.doc }), o = this.storage.characters({ node: t.doc });
          if (o <= r || i > r && o > r && o <= i)
            return !0;
          if (i > r && o > r && o > i || !t.getMeta("paste"))
            return !1;
          const a = t.selection.$head.pos, c = o - r, u = a - c, f = a;
          return t.deleteRange(u, f), !(this.storage.characters({ node: t.doc }) > r);
        }
      })
    ];
  }
});
var bze = pr.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [tze(this.options)];
  }
});
pr.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Yn({
        key: new Ar("focus"),
        props: {
          decorations: ({ doc: e, selection: t }) => {
            const { isEditable: n, isFocused: r } = this.editor, { anchor: i } = t, o = [];
            if (!n || !r)
              return Gn.create(e, []);
            let s = 0;
            this.options.mode === "deepest" && e.descendants((c, u) => {
              if (c.isText)
                return;
              if (!(i >= u && i <= u + c.nodeSize - 1))
                return !1;
              s += 1;
            });
            let a = 0;
            return e.descendants((c, u) => {
              if (c.isText || !(i >= u && i <= u + c.nodeSize - 1))
                return !1;
              if (a += 1, this.options.mode === "deepest" && s - a > 0 || this.options.mode === "shallowest" && a > 1)
                return this.options.mode === "deepest";
              o.push(
                xi.node(u, u + c.nodeSize, {
                  class: this.options.className
                })
              );
            }), Gn.create(e, o);
          }
        }
      })
    ];
  }
});
var xze = pr.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [oze()];
  },
  extendNodeSchema(e) {
    var t;
    const n = {
      name: e.name,
      options: e.options,
      storage: e.storage
    };
    return {
      allowGapCursor: (t = gn(ht(e, "allowGapCursor", n))) != null ? t : null
    };
  }
}), b3 = "placeholder";
function wze(e) {
  return e.replace(/\s+/g, "-").replace(/[^a-zA-Z0-9-]/g, "").replace(/^[0-9-]+/, "").replace(/^-+/, "").toLowerCase();
}
var Sze = pr.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      dataAttribute: b3,
      placeholder: "Write something ",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    const e = this.options.dataAttribute ? `data-${wze(this.options.dataAttribute)}` : `data-${b3}`;
    return [
      new Yn({
        key: new Ar("placeholder"),
        props: {
          decorations: ({ doc: t, selection: n }) => {
            const r = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: i } = n, o = [];
            if (!r)
              return null;
            const s = this.editor.isEmpty;
            return t.descendants((a, c) => {
              const u = i >= c && i <= c + a.nodeSize, f = !a.isLeaf && y1(a);
              if ((u || !this.options.showOnlyCurrent) && f) {
                const h = [this.options.emptyNodeClass];
                s && h.push(this.options.emptyEditorClass);
                const m = xi.node(c, c + a.nodeSize, {
                  class: h.join(" "),
                  [e]: typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: a,
                    pos: c,
                    hasAnchor: u
                  }) : this.options.placeholder
                });
                o.push(m);
              }
              return this.options.includeChildren;
            }), Gn.create(t, o);
          }
        }
      })
    ];
  }
});
pr.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor: e, options: t } = this;
    return [
      new Yn({
        key: new Ar("selection"),
        props: {
          decorations(n) {
            return n.selection.empty || e.isFocused || !e.isEditable || Tq(n.selection) || e.view.dragging ? null : Gn.create(n.doc, [
              xi.inline(n.selection.from, n.selection.to, {
                class: t.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function x3({ types: e, node: t }) {
  return t && Array.isArray(e) && e.includes(t.type) || t?.type === e;
}
var kze = pr.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: void 0,
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    var e;
    const t = new Ar(this.name), n = this.options.node || ((e = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : e.name) || "paragraph", r = Object.entries(this.editor.schema.nodes).map(([, i]) => i).filter((i) => (this.options.notAfter || []).concat(n).includes(i.name));
    return [
      new Yn({
        key: t,
        appendTransaction: (i, o, s) => {
          const { doc: a, tr: c, schema: u } = s, f = t.getState(s), h = a.content.size, m = u.nodes[n];
          if (f)
            return c.insert(h, m.create());
        },
        state: {
          init: (i, o) => {
            const s = o.tr.doc.lastChild;
            return !x3({ node: s, types: r });
          },
          apply: (i, o) => {
            if (!i.docChanged || i.getMeta("__uniqueIDTransaction"))
              return o;
            const s = i.doc.lastChild;
            return !x3({ node: s, types: r });
          }
        }
      })
    ];
  }
}), Cze = pr.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: e, dispatch: t }) => xG(e, t),
      redo: () => ({ state: e, dispatch: t }) => wG(e, t)
    };
  },
  addProseMirrorPlugins() {
    return [vze(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
}), Eze = pr.create({
  name: "starterKit",
  addExtensions() {
    var e, t, n, r;
    const i = [];
    return this.options.bold !== !1 && i.push(ZIe.configure(this.options.bold)), this.options.blockquote !== !1 && i.push(HIe.configure(this.options.blockquote)), this.options.bulletList !== !1 && i.push(aG.configure(this.options.bulletList)), this.options.code !== !1 && i.push(JIe.configure(this.options.code)), this.options.codeBlock !== !1 && i.push(tje.configure(this.options.codeBlock)), this.options.document !== !1 && i.push(nje.configure(this.options.document)), this.options.dropcursor !== !1 && i.push(bze.configure(this.options.dropcursor)), this.options.gapcursor !== !1 && i.push(xze.configure(this.options.gapcursor)), this.options.hardBreak !== !1 && i.push(rje.configure(this.options.hardBreak)), this.options.heading !== !1 && i.push(ije.configure(this.options.heading)), this.options.undoRedo !== !1 && i.push(Cze.configure(this.options.undoRedo)), this.options.horizontalRule !== !1 && i.push(oje.configure(this.options.horizontalRule)), this.options.italic !== !1 && i.push(uje.configure(this.options.italic)), this.options.listItem !== !1 && i.push(lG.configure(this.options.listItem)), this.options.listKeymap !== !1 && i.push(pG.configure((e = this.options) == null ? void 0 : e.listKeymap)), this.options.link !== !1 && i.push(Ije.configure((t = this.options) == null ? void 0 : t.link)), this.options.orderedList !== !1 && i.push(gG.configure(this.options.orderedList)), this.options.paragraph !== !1 && i.push(Zje.configure(this.options.paragraph)), this.options.strike !== !1 && i.push(Jje.configure(this.options.strike)), this.options.text !== !1 && i.push(Qje.configure(this.options.text)), this.options.underline !== !1 && i.push(eze.configure((n = this.options) == null ? void 0 : n.underline)), this.options.trailingNode !== !1 && i.push(kze.configure((r = this.options) == null ? void 0 : r.trailingNode)), i;
  }
}), _ze = Eze, Tze = Sze;
function Aze(e) {
  var t;
  const { char: n, allowSpaces: r, allowToIncludeChar: i, allowedPrefixes: o, startOfLine: s, $position: a } = e, c = r && !i, u = EDe(n), f = new RegExp(`\\s${u}$`), h = s ? "^" : "", m = i ? "" : u, g = c ? new RegExp(`${h}${u}.*?(?=\\s${m}|$)`, "gm") : new RegExp(`${h}(?:^)?${u}[^\\s${m}]*`, "gm"), b = ((t = a.nodeBefore) == null ? void 0 : t.isText) && a.nodeBefore.text;
  if (!b)
    return null;
  const x = a.pos - b.length, w = Array.from(b.matchAll(g)).pop();
  if (!w || w.input === void 0 || w.index === void 0)
    return null;
  const S = w.input.slice(Math.max(0, w.index - 1), w.index), _ = new RegExp(`^[${o?.join("")}\0]?$`).test(S);
  if (o !== null && !_)
    return null;
  const M = x + w.index;
  let N = M + w[0].length;
  return c && f.test(b.slice(N - 1, N + 1)) && (w[0] += " ", N += 1), M < a.pos && N >= a.pos ? {
    range: {
      from: M,
      to: N
    },
    query: w[0].slice(n.length),
    text: w[0]
  } : null;
}
var Mze = new Ar("suggestion");
function Nze({
  pluginKey: e = Mze,
  editor: t,
  char: n = "@",
  allowSpaces: r = !1,
  allowToIncludeChar: i = !1,
  allowedPrefixes: o = [" "],
  startOfLine: s = !1,
  decorationTag: a = "span",
  decorationClass: c = "suggestion",
  decorationContent: u = "",
  decorationEmptyClass: f = "is-empty",
  command: h = () => null,
  items: m = () => [],
  render: g = () => ({}),
  allow: b = () => !0,
  findSuggestionMatch: x = Aze,
  shouldShow: w
}) {
  let S;
  const _ = g?.(), M = () => {
    const O = t.state.selection.$anchor.pos, L = t.view.coordsAtPos(O), { top: U, right: B, bottom: G, left: Y } = L;
    try {
      return new DOMRect(Y, U, B - Y, G - U);
    } catch {
      return null;
    }
  }, N = (O, L) => L ? () => {
    const U = e.getState(t.state), B = U?.decorationId, G = O.dom.querySelector(`[data-decoration-id="${B}"]`);
    return G?.getBoundingClientRect() || null;
  } : M;
  function D(O, L) {
    var U;
    try {
      const G = e.getState(O.state), Y = G?.decorationId ? O.dom.querySelector(`[data-decoration-id="${G.decorationId}"]`) : null, he = {
        // @ts-ignore editor is available in closure
        editor: t,
        range: G?.range || { from: 0, to: 0 },
        query: G?.query || null,
        text: G?.text || null,
        items: [],
        command: (ie) => h({ editor: t, range: G?.range || { from: 0, to: 0 }, props: ie }),
        decorationNode: Y,
        clientRect: N(O, Y)
      };
      (U = _?.onExit) == null || U.call(_, he);
    } catch {
    }
    const B = O.state.tr.setMeta(L, { exit: !0 });
    O.dispatch(B);
  }
  const j = new Yn({
    key: e,
    view() {
      return {
        update: async (O, L) => {
          var U, B, G, Y, he, ie, ne;
          const H = (U = this.key) == null ? void 0 : U.getState(L), Q = (B = this.key) == null ? void 0 : B.getState(O.state), X = H.active && Q.active && H.range.from !== Q.range.from, Se = !H.active && Q.active, W = H.active && !Q.active, Z = !Se && !W && H.query !== Q.query, pe = Se || X && Z, F = Z || X, ee = W || X && Z;
          if (!pe && !F && !ee)
            return;
          const ge = ee && !pe ? H : Q, re = O.dom.querySelector(`[data-decoration-id="${ge.decorationId}"]`);
          S = {
            editor: t,
            range: ge.range,
            query: ge.query,
            text: ge.text,
            items: [],
            command: (J) => h({
              editor: t,
              range: ge.range,
              props: J
            }),
            decorationNode: re,
            clientRect: N(O, re)
          }, pe && ((G = _?.onBeforeStart) == null || G.call(_, S)), F && ((Y = _?.onBeforeUpdate) == null || Y.call(_, S)), (F || pe) && (S.items = await m({
            editor: t,
            query: ge.query
          })), ee && ((he = _?.onExit) == null || he.call(_, S)), F && ((ie = _?.onUpdate) == null || ie.call(_, S)), pe && ((ne = _?.onStart) == null || ne.call(_, S));
        },
        destroy: () => {
          var O;
          S && ((O = _?.onExit) == null || O.call(_, S));
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        return {
          active: !1,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: !1
        };
      },
      // Apply changes to the plugin state from a view transaction.
      apply(O, L, U, B) {
        const { isEditable: G } = t, { composing: Y } = t.view, { selection: he } = O, { empty: ie, from: ne } = he, H = { ...L }, Q = O.getMeta(e);
        if (Q && Q.exit)
          return H.active = !1, H.decorationId = null, H.range = { from: 0, to: 0 }, H.query = null, H.text = null, H;
        if (H.composing = Y, G && (ie || t.view.composing)) {
          (ne < L.range.from || ne > L.range.to) && !Y && !L.composing && (H.active = !1);
          const X = x({
            char: n,
            allowSpaces: r,
            allowToIncludeChar: i,
            allowedPrefixes: o,
            startOfLine: s,
            $position: he.$from
          }), Se = `id_${Math.floor(Math.random() * 4294967295)}`;
          X && b({
            editor: t,
            state: B,
            range: X.range,
            isActive: L.active
          }) && (!w || w({
            editor: t,
            range: X.range,
            query: X.query,
            text: X.text,
            transaction: O
          })) ? (H.active = !0, H.decorationId = L.decorationId ? L.decorationId : Se, H.range = X.range, H.query = X.query, H.text = X.text) : H.active = !1;
        } else
          H.active = !1;
        return H.active || (H.decorationId = null, H.range = { from: 0, to: 0 }, H.query = null, H.text = null), H;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(O, L) {
        var U, B, G, Y;
        const { active: he, range: ie } = j.getState(O.state);
        if (!he)
          return !1;
        if (L.key === "Escape" || L.key === "Esc") {
          const H = j.getState(O.state), Q = (U = S?.decorationNode) != null ? U : null, X = Q ?? (H?.decorationId ? O.dom.querySelector(`[data-decoration-id="${H.decorationId}"]`) : null);
          if (((B = _?.onKeyDown) == null ? void 0 : B.call(_, { view: O, event: L, range: H.range })) || !1)
            return !0;
          const W = {
            editor: t,
            range: H.range,
            query: H.query,
            text: H.text,
            items: [],
            command: (Z) => h({ editor: t, range: H.range, props: Z }),
            decorationNode: X,
            // If we have a cached decoration node, use it for the clientRect
            // to avoid another DOM lookup. If not, leave clientRect null and
            // let consumer decide if they want to query.
            clientRect: X ? () => X.getBoundingClientRect() || null : null
          };
          return (G = _?.onExit) == null || G.call(_, W), D(O, e), !0;
        }
        return ((Y = _?.onKeyDown) == null ? void 0 : Y.call(_, { view: O, event: L, range: ie })) || !1;
      },
      // Setup decorator on the currently active suggestion.
      decorations(O) {
        const { active: L, range: U, decorationId: B, query: G } = j.getState(O);
        if (!L)
          return null;
        const Y = !G?.length, he = [c];
        return Y && he.push(f), Gn.create(O.doc, [
          xi.inline(U.from, U.to, {
            nodeName: a,
            class: he.join(" "),
            "data-decoration-id": B,
            "data-decoration-content": u
          })
        ]);
      }
    }
  });
  return j;
}
var Rze = Nze;
function Oze() {
  return /* @__PURE__ */ v.jsxs("svg", { className: "animate-spin h-4 w-4 text-muted-foreground", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ v.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4", fill: "none" }),
    /* @__PURE__ */ v.jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" })
  ] });
}
function S0({
  items: e,
  selectedIndex: t,
  onSelect: n,
  onHover: r,
  loading: i = !1
}) {
  const [o, s] = C.useState(""), a = C.useMemo(() => {
    const u = (Array.isArray(e) ? e : Object.values(e)).flatMap(
      (h) => Object.values(h)
    );
    if (!o.trim()) return u;
    const f = o.trim().toLowerCase();
    return u.filter(
      (h) => h.name.toLowerCase().includes(f) || h.description?.toLowerCase().includes(f) || h.serverName.toLowerCase().includes(f)
    );
  }, [e, o]);
  return /* @__PURE__ */ v.jsxs("div", { className: "bg-popover rounded-lg shadow-lg divide-y max-h-96 overflow-auto w-96 mb-2 border focus:border-accent", children: [
    /* @__PURE__ */ v.jsx("div", { className: "px-4 py-2 sticky top-0 bg-popover z-10 border-b", children: /* @__PURE__ */ v.jsx(
      "input",
      {
        type: "text",
        className: "w-full px-2 py-1 rounded border text-sm bg-background outline-none focus:ring-2 focus:ring-accent focus:border-accent",
        placeholder: "Search tools... (name / description / mcp)",
        value: o,
        onChange: (c) => s(c.target.value)
      }
    ) }),
    i ? /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 px-4 py-3", children: [
      /* @__PURE__ */ v.jsx(Oze, {}),
      /* @__PURE__ */ v.jsx("div", { className: "text-sm text-muted-foreground", children: "Loading tools..." })
    ] }) : a.length === 0 ? /* @__PURE__ */ v.jsx("div", { className: "px-4 py-3 text-sm text-muted-foreground", children: "No results" }) : a.map((c, u) => /* @__PURE__ */ v.jsxs(
      "div",
      {
        role: "option",
        "aria-selected": u === t,
        onMouseDown: (f) => {
          f.preventDefault(), n(c);
        },
        onMouseEnter: () => r(u),
        className: `flex items-center gap-3 px-4 py-3 cursor-pointer transition-colors select-none ${u === t ? "bg-accent/15 text-accent-foreground" : "hover:bg-accent/50"}`,
        children: [
          /* @__PURE__ */ v.jsx("div", { className: "shrink-0 w-8 h-8 rounded-full bg-slate-100 dark:bg-neutral-800 flex items-center justify-center text-sm font-semibold text-slate-700", children: c.name ? c.name.charAt(0).toUpperCase() : "?" }),
          /* @__PURE__ */ v.jsxs("div", { className: "min-w-0 flex-1", children: [
            /* @__PURE__ */ v.jsxs(Yi, { children: [
              /* @__PURE__ */ v.jsx(hM, { asChild: !0, children: /* @__PURE__ */ v.jsx("span", { className: "font-medium text-sm truncate hover:underline decoration-dotted cursor-help", children: c.name }) }),
              /* @__PURE__ */ v.jsxs(ww, { side: "right", align: "start", className: "z-1000 bg-white/95 backdrop-blur text-neutral-900 max-w-xs text-xs shadow-2xl border border-neutral-200 rounded-xl px-5 py-4", children: [
                /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3 mb-2", children: [
                  /* @__PURE__ */ v.jsx("div", { className: "w-9 h-9 rounded-full bg-linear-to-tr from-accent to-muted flex items-center justify-center text-lg font-bold text-white shadow", children: c.name ? c.name.charAt(0).toUpperCase() : "?" }),
                  /* @__PURE__ */ v.jsxs("div", { children: [
                    /* @__PURE__ */ v.jsx("div", { className: "font-semibold text-base text-neutral-800", children: c.name }),
                    /* @__PURE__ */ v.jsxs("div", { className: "text-[11px] text-neutral-500 mt-0.5", children: [
                      "MCP: ",
                      /* @__PURE__ */ v.jsx("span", { className: "font-medium text-neutral-700", children: c.serverName })
                    ] })
                  ] })
                ] }),
                c.description && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
                  /* @__PURE__ */ v.jsx("div", { className: "border-t border-neutral-200 my-2" }),
                  /* @__PURE__ */ v.jsx("div", { className: "text-sm text-neutral-700 leading-relaxed", children: c.description })
                ] })
              ] })
            ] }),
            c.description && /* @__PURE__ */ v.jsx("div", { className: "text-xs text-muted-foreground truncate mt-0.5", children: c.description }),
            /* @__PURE__ */ v.jsxs("div", { className: "text-[11px] text-muted-foreground truncate mt-0.5", children: [
              "MCP: ",
              /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: c.serverName })
            ] })
          ] }),
          /* @__PURE__ */ v.jsxs("div", { className: "ml-auto flex items-center gap-2", children: [
            /* @__PURE__ */ v.jsx("span", { className: "text-[11px] px-2 py-0.5 rounded bg-muted text-muted-foreground", children: c.serverName }),
            /* @__PURE__ */ v.jsx("div", { className: "text-xs text-neutral-400", children: "Select" })
          ] })
        ]
      },
      `${c.serverId}-${c.id || c.name}-${u}`
    ))
  ] });
}
function Pze(e) {
  return {
    items: async ({ query: t }) => {
      try {
        const n = e?.mcpServerList?.value || [], r = e?.allowedMcpServers?.value || {}, i = n.reduce((a, c) => {
          const u = c.name, f = c.id, h = r[f]?.tools || [];
          a[u] || (a[u] = []);
          const m = c.toolInfo.filter((g) => h.includes(g.name)).map((g) => ({
            ...g,
            serverId: c.id,
            serverName: c.name
          }));
          return m.length > 0 && a[u].push(...m), a;
        }, {});
        if (!t) return i;
        const o = String(t).toLowerCase();
        return Object.fromEntries(
          Object.entries(i).map(([a, c]) => [
            a,
            c.filter((u) => u.name.toLowerCase().includes(o))
          ]).filter(([, a]) => a.length > 0)
        );
      } catch {
        return [];
      }
    },
    render: () => {
      let t = null, n = null, r = {}, i = 0, o = null;
      const s = () => Object.values(r).flat();
      return {
        onStart: (a) => {
          o = a.command, r = a.items || {}, i = 0, t = document.createElement("div"), t.style.position = "absolute", t.style.zIndex = "9999", t.style.left = "0px", t.style.top = "0px", document.body.appendChild(t);
          const c = () => {
            if (!t || !a.clientRect) return;
            const u = a.clientRect();
            if (u) {
              t.style.left = `${u.left + window.scrollX}px`;
              const f = t.offsetHeight || 40;
              t.style.top = `${u.top + window.scrollY - f}px`, t.style.width = `${u.width}px`;
            }
          };
          n = a4.createRoot(t), n.render(
            /* @__PURE__ */ v.jsx(
              S0,
              {
                items: a.items,
                selectedIndex: 0,
                onSelect: (u) => {
                  console.log("Selected mention item:", u), a.command(u);
                },
                onHover: (u) => {
                  i = u;
                }
              }
            )
          ), requestAnimationFrame(c);
        },
        onUpdate: (a) => {
          o = a.command, r = a.items || {};
          const c = s();
          i = Math.min(i, Math.max(c.length - 1, 0)), n && n.render(
            /* @__PURE__ */ v.jsx(
              S0,
              {
                items: r,
                selectedIndex: i,
                onSelect: (u) => a.command(u),
                onHover: (u) => {
                  i = u;
                }
              }
            )
          ), t && a.clientRect && requestAnimationFrame(() => {
            if (!t) return;
            const f = a.clientRect();
            if (f) {
              const h = t.offsetHeight || 40;
              t.style.left = `${f.left + window.scrollX}px`, t.style.top = `${f.top + window.scrollY - h}px`, t.style.width = `${f.width}px`;
            }
          });
        },
        onKeyDown: (a) => {
          const c = a.event;
          if (c.key === "ArrowDown") {
            c.preventDefault(), c.stopPropagation();
            const u = s();
            return i = Math.min(i + 1, Math.max(u.length - 1, 0)), n && n.render(
              /* @__PURE__ */ v.jsx(
                S0,
                {
                  items: r,
                  selectedIndex: i,
                  onSelect: (f) => {
                    o && o(f);
                  },
                  onHover: (f) => {
                    i = f;
                  }
                }
              )
            ), !0;
          }
          if (c.key === "ArrowUp")
            return c.preventDefault(), c.stopPropagation(), i = Math.max(i - 1, 0), n && n.render(
              /* @__PURE__ */ v.jsx(
                S0,
                {
                  items: r,
                  selectedIndex: i,
                  onSelect: (u) => {
                    o && o(u);
                  },
                  onHover: (u) => {
                    i = u;
                  }
                }
              )
            ), !0;
          if (c.key === "Enter" || c.key === "Tab") {
            const u = s()[i];
            if (u && o)
              return c.preventDefault(), c.stopPropagation(), o(u), !0;
          }
          return !1;
        },
        onExit: () => {
          if (n && t) {
            n.unmount();
            try {
              t.remove();
            } catch {
            }
            n = null, t = null;
          }
          if (t) {
            try {
              t.remove();
            } catch {
            }
            t = null;
          }
        }
      };
    }
  };
}
const Dze = Li.create({
  name: "mention",
  inline: !0,
  group: "inline",
  atom: !0,
  addOptions() {
    return {
      chatbotServerStore: void 0
    };
  },
  addAttributes() {
    return {
      id: { default: null },
      label: { default: null },
      description: { default: null },
      serverId: { default: null },
      serverName: { default: null }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span[data-mention]"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "span",
      sr(t, { "data-mention": "", "data-id": e.attrs.id, class: "mention-node" }),
      `@${e.attrs.label}`
    ];
  },
  addCommands() {
    return {
      insertMention: (e) => ({ chain: t }) => {
        try {
          return t().focus().insertContent({ type: this.name, attrs: e }).run();
        } catch {
          return !1;
        }
      }
    };
  },
  addProseMirrorPlugins() {
    const e = this.editor, t = Pze(this.options.chatbotServerStore), n = Object.assign({ editor: e, char: "@", startOfLine: !1 }, t);
    return n.command = ({ editor: r, range: i, props: o }) => {
      try {
        const s = o.label || o.name || o.id || "unknown";
        setTimeout(() => {
          r.chain().focus().setTextSelection(i.from).deleteRange(i).insertContent([{
            type: "mention",
            attrs: {
              id: o.id || o.name,
              label: s,
              description: o.description,
              serverId: o.serverId,
              serverName: o.serverName
            }
          }, { type: "text", text: " " }]).run();
        }, 0);
        const a = new CustomEvent("tiptap-mention-inserted", { detail: { ...o, label: s } });
        window.dispatchEvent(a);
      } catch (s) {
        console.error("Error inserting mention:", s);
      }
    }, [Rze(n)];
  }
}), Ize = (e) => {
  const { node: t, deleteNode: n, editor: r } = e, { id: i, name: o, classUri: s, versionId: a } = t.attrs, [c, u] = C.useState(!1), f = (S) => {
    S.preventDefault(), S.stopPropagation(), n(), setTimeout(() => {
      try {
        r?.commands?.focus();
      } catch {
      }
    }, 0);
  }, h = (S) => {
    S.preventDefault(), S.stopPropagation();
    const _ = new CustomEvent("entity-isolate", {
      detail: { id: i, name: o, classUri: s, versionId: a }
    });
    window.dispatchEvent(_), Vt.success(`Isolated ${o}`);
  }, m = (S) => {
    S.preventDefault(), S.stopPropagation();
    const _ = new CustomEvent("entity-reset-visibility", {
      detail: { id: i, name: o }
    });
    window.dispatchEvent(_), Vt.success("Reset visibility");
  }, g = (S) => {
    S.preventDefault(), S.stopPropagation();
    const _ = [
      `Name: ${o}`,
      i ? `Element ID: ${i}` : null,
      a ? `Version ID: ${a}` : null,
      s ? `Class: ${s}` : null
    ].filter(Boolean).join(`
`);
    navigator.clipboard.writeText(_).then(() => {
      Vt.success("Copied entity info");
    }).catch(() => {
      Vt.error("Failed to copy");
    });
  }, b = (S) => {
    S.preventDefault(), S.stopPropagation();
    const _ = new CustomEvent("entity-zoom-select", {
      detail: { id: i, name: o, classUri: s, versionId: a }
    });
    window.dispatchEvent(_);
  }, x = () => {
    u(!0);
    const S = new CustomEvent("entity-hover", {
      detail: { id: i, name: o, classUri: s, versionId: a, hover: !0 }
    });
    window.dispatchEvent(S);
  }, w = () => {
    u(!1);
    const S = new CustomEvent("entity-hover", {
      detail: { id: i, name: o, classUri: s, versionId: a, hover: !1 }
    });
    window.dispatchEvent(S);
  };
  return /* @__PURE__ */ v.jsx(IIe, { className: "inline select-none", contentEditable: !1, children: /* @__PURE__ */ v.jsxs(
    "span",
    {
      className: "mt-1 inline-flex items-center gap-1 mx-0.5 px-2 py-0.5 rounded-md bg-emerald-600/20 border border-emerald-600/30 cursor-default transition-colors hover:bg-emerald-600/30",
      onMouseEnter: x,
      onMouseLeave: w,
      onDoubleClick: b,
      children: [
        /* @__PURE__ */ v.jsx("span", { className: "select-none", children: o || "Entity" }),
        /* @__PURE__ */ v.jsxs("div", { className: "inline-flex items-center gap-0.5", children: [
          c && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
            /* @__PURE__ */ v.jsx(
              "button",
              {
                className: "inline-flex items-center justify-center bg-transparent border-none cursor-pointer p-0.5 m-0 text-emerald-600/80 transition-all rounded-sm hover:bg-emerald-600/20 hover:text-emerald-600",
                onClick: h,
                onMouseDown: (S) => S.preventDefault(),
                title: "Isolate",
                children: /* @__PURE__ */ v.jsx(uA, { className: "h-3 w-3" })
              }
            ),
            /* @__PURE__ */ v.jsx(
              "button",
              {
                className: "inline-flex items-center justify-center bg-transparent border-none cursor-pointer p-0.5 m-0 text-emerald-600/80 transition-all rounded-sm hover:bg-emerald-600/20 hover:text-emerald-600",
                onClick: m,
                onMouseDown: (S) => S.preventDefault(),
                title: "Reset visibility",
                children: /* @__PURE__ */ v.jsx(fA, { className: "h-3 w-3" })
              }
            ),
            /* @__PURE__ */ v.jsx(
              "button",
              {
                className: "inline-flex items-center justify-center bg-transparent border-none cursor-pointer p-0.5 m-0 text-emerald-600/80 transition-all rounded-sm hover:bg-emerald-600/20 hover:text-emerald-600",
                onClick: g,
                onMouseDown: (S) => S.preventDefault(),
                title: "Copy info",
                children: /* @__PURE__ */ v.jsx(Ac, { className: "h-3 w-3" })
              }
            )
          ] }),
          /* @__PURE__ */ v.jsx(
            "button",
            {
              className: "inline-flex items-center justify-center bg-transparent border-none cursor-pointer p-0.5 m-0 text-emerald-600/60 transition-all rounded-sm hover:bg-red-500/10 hover:text-red-500",
              onClick: f,
              onMouseDown: (S) => S.preventDefault(),
              title: "Remove entity",
              children: /* @__PURE__ */ v.jsx(Hg, { className: "h-3 w-3" })
            }
          )
        ] })
      ]
    }
  ) });
}, jze = Li.create({
  name: "entity",
  inline: !0,
  group: "inline",
  atom: !0,
  draggable: !1,
  addAttributes() {
    return {
      id: { default: null },
      name: { default: null },
      classUri: { default: null },
      versionId: { default: null }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span[data-entity]"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "span",
      sr(t, {
        "data-entity": "",
        "data-id": e.attrs.id,
        "data-class-uri": e.attrs.classUri,
        "data-version-id": e.attrs.versionId,
        class: "entity-node"
      }),
      e.attrs.name ? String(e.attrs.name) : "Entity"
    ];
  },
  addNodeView() {
    return UIe(Ize);
  },
  renderText({ node: e }) {
    const t = e?.attrs?.name ? String(e.attrs.name) : "Entity", n = e?.attrs?.id ? String(e.attrs.id) : "", r = e?.attrs?.versionId ? String(e.attrs.versionId) : "";
    return n && r ? `[Name: ${t}, Element Id: ${n}: VersionId: ${r}]` : n ? `[${t}:${n}]` : r ? `[Name: ${t}, VersionId:${r}]` : `[${t}]`;
  }
});
async function zze() {
  const e = await Vc(), t = await fetch(`${fs}/chat/tools`, { headers: e });
  if (!t.ok) return { ok: !1, tools: [] };
  const n = await t.json().catch(() => null);
  return Array.isArray(n) ? { ok: !0, tools: n } : n && Array.isArray(n?.tools) ? {
    ok: !!(n?.ok ?? !0),
    tools: n.tools
  } : { ok: !1, tools: [] };
}
function Lze(e) {
  const {
    localValue: t,
    history: n,
    historyIndex: r,
    setHistoryIndex: i,
    setLocalValue: o,
    onChange: s,
    doSendAndClear: a,
    mention: c
  } = e;
  return (u) => {
    if ((u.ctrlKey || u.metaKey) && (u.key === "c" || u.key === "v" || u.key === "x" || u.key === "a")) {
      u.stopPropagation();
      return;
    }
    if ((u.ctrlKey || u.metaKey) && u.key === "End") {
      u.preventDefault(), a();
      return;
    }
    if (u.ctrlKey && u.key === "Enter" && (u.preventDefault(), a()), u.key === "ArrowUp") {
      if (t.trim() === "" && n.length === 0) return;
      if (t.trim() === "" || r !== null) {
        u.preventDefault();
        const h = r === null ? n.length - 1 : Math.max(0, r - 1);
        i(h);
        const m = n[h];
        m !== void 0 && (o(m), s && s(m));
      }
      return;
    }
    try {
      if (c.handleKeyDown(u), u.defaultPrevented) return;
    } catch {
    }
    if (u.key === "ArrowDown") {
      if (r === null) return;
      u.preventDefault();
      const h = r + 1;
      if (h >= n.length)
        i(null), o(""), s && s("");
      else {
        i(h);
        const m = n[h];
        m !== void 0 && (o(m), s && s(m));
      }
      return;
    }
  };
}
function Bze(e) {
  if (!isFinite(e) || e <= 0) return "0 B";
  const t = ["B", "KB", "MB", "GB", "TB"], n = Math.min(t.length - 1, Math.floor(Math.log(e) / Math.log(1024))), r = e / Math.pow(1024, n);
  return `${n === 0 ? Math.round(r) : r.toFixed(2)} ${t[n]}`;
}
async function $ze(e) {
  if (!e) throw new Error("No file provided");
  try {
    const t = await vMe(e);
    if (!t) throw new Error("No metadata returned from S3 upload");
    return {
      fileName: e.name,
      mimeType: e.type || t.mimeType || "application/octet-stream",
      s3Key: t.s3Key || t.key || t.keyName || "",
      size: e.size,
      url: t.url || t.s3Url || t.location || void 0,
      status: "uploaded",
      ...t
    };
  } catch (t) {
    return console.error("S3 upload failed:", t), {
      fileName: e.name,
      mimeType: e.type || "application/octet-stream",
      s3Key: "",
      size: e.size,
      status: "error",
      error: t?.message || String(t)
    };
  }
}
function Uze({
  number: e,
  className: t
}) {
  const n = F6(0), r = Hre(n, Math.round);
  return C.useEffect(() => lie(n, e, { duration: 1 }).stop, [e]), /* @__PURE__ */ v.jsx(nh.span, { className: lt(t), children: r });
}
const Fze = 2500, Vze = (e) => {
  const {
    tools: t,
    onClickAllChecked: n,
    isAuthorizing: r,
    authorizationUrl: i,
    error: o,
    checked: s,
    onToolClick: a
  } = e, [c, u] = C.useState(!1), [f, h] = C.useState(""), [m, g] = C.useState(!1), b = C.useRef(null), x = !!i, w = C.useMemo(() => t.filter(
    (N) => N.name.toLowerCase().includes(f.toLowerCase())
  ), [t, f]), S = C.useCallback(() => {
    b.current !== null && (window.clearInterval(b.current), b.current = null), g(!1);
  }, []), _ = C.useCallback(() => {
    b.current === null && (b.current = window.setInterval(() => {
      $_(`${Ys}/list`);
    }, Fze), g(!0));
  }, []);
  C.useEffect(() => {
    (!r || o) && S();
  }, [o, r, S]), C.useEffect(() => S, [S]);
  const M = C.useCallback(
    () => MN(() => u(!0)).ifOk(() => (x && (window.open(i, "_blank", "noopener,noreferrer"), _()), $_(`${Ys}/list`))).ifFail(Ab).watch(() => u(!1)),
    [i, x, _]
  );
  return r ? /* @__PURE__ */ v.jsxs(
    Z9,
    {
      className: "transition-colors border-none",
      children: [
        c ? /* @__PURE__ */ v.jsx(dA, { className: "animate-spin" }) : /* @__PURE__ */ v.jsx(ub, {}),
        /* @__PURE__ */ v.jsx(Y9, { children: "Authorization Required" }),
        /* @__PURE__ */ v.jsx(X9, { children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2", children: [
          /* @__PURE__ */ v.jsx("span", { children: m ? "Waiting for authorization to complete." : "Pending authorization to access this MCP server." }),
          /* @__PURE__ */ v.jsx(
            qt,
            {
              variant: "outline",
              size: "sm",
              onClick: M,
              disabled: !x || c,
              className: "cursor-pointer",
              children: "Authorize"
            }
          )
        ] }) })
      ]
    }
  ) : /* @__PURE__ */ v.jsxs("div", { children: [
    /* @__PURE__ */ v.jsxs(
      the,
      {
        className: "text-muted-foreground flex items-center gap-2",
        onClick: (N) => {
          N.preventDefault(), n(!s);
        },
        children: [
          /* @__PURE__ */ v.jsx(
            "input",
            {
              autoFocus: !0,
              placeholder: "Search tools...",
              value: f,
              onKeyDown: (N) => {
                N.stopPropagation();
              },
              onChange: (N) => h(N.target.value),
              onClick: (N) => {
                N.stopPropagation();
              },
              className: "placeholder:text-muted-foreground flex w-full text-xs   outline-hidden disabled:cursor-not-allowed disabled:opacity-50"
            }
          ),
          /* @__PURE__ */ v.jsx("div", { className: "flex-1" }),
          /* @__PURE__ */ v.jsx(IH, { checked: s })
        ]
      }
    ),
    /* @__PURE__ */ v.jsx(Db, {}),
    /* @__PURE__ */ v.jsx("div", { className: "max-h-96 overflow-y-auto", children: w.length === 0 ? /* @__PURE__ */ v.jsx("div", { className: "text-sm text-muted-foreground w-full h-full flex items-center justify-center py-6", children: "No results found" }) : w.map((N) => /* @__PURE__ */ v.jsxs(
      hs,
      {
        className: "flex items-center gap-2 cursor-pointer mb-1",
        onClick: (D) => {
          D.preventDefault(), a(N.name, !N.checked);
        },
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "mx-1 flex-1 min-w-0", children: [
            /* @__PURE__ */ v.jsx("p", { className: "font-medium text-xs mb-1 truncate", children: N.name }),
            /* @__PURE__ */ v.jsx("p", { className: "text-xs text-muted-foreground truncate", children: N.description })
          ] }),
          /* @__PURE__ */ v.jsx(AH, { checked: N.checked, className: "ml-auto" })
        ]
      },
      N.name
    )) })
  ] });
}, Hze = () => {
  const {
    chatbotServerStore: { allowedMcpServers: e, mcpServerList: t }
  } = la(), n = C.useMemo(() => t.value.length === 0 ? [] : [...t.value].sort(
    (i, o) => (i.status === "connected" ? -1 : 1) - (o.status === "connected" ? -1 : 1)
  ).map((i) => {
    const o = e.value?.[i.id]?.tools ?? [];
    return {
      id: i.id,
      serverName: i.name,
      checked: o.length > 0,
      tools: (i.toolInfo || []).map((s) => ({
        name: s.name,
        checked: o.includes(s.name),
        description: s.description
      })),
      error: i.error,
      status: i.status,
      authorizationUrl: i.authorizationUrl
    };
  }), [t.value, e.value]), r = C.useCallback(
    (i, o) => {
      const a = {
        ...e.value || {},
        [i]: {
          tools: o
        }
      };
      e.value = a, localStorage.setItem(vh.ALLOWED_MCP_SERVERS, JSON.stringify(a));
    },
    [e]
  );
  return /* @__PURE__ */ v.jsxs(Qfe, { className: "max-h-96 overflow-y-auto", children: [
    n.map((i) => /* @__PURE__ */ v.jsxs(nhe, { children: [
      /* @__PURE__ */ v.jsxs(
        rhe,
        {
          className: "flex items-center gap-2 font-semibold cursor-pointer",
          onClick: (o) => {
            o.preventDefault(), r(
              i.id,
              i.checked ? [] : i.tools.map((s) => s.name)
            );
          },
          children: [
            /* @__PURE__ */ v.jsx("div", { className: "flex items-center justify-center p-1 rounded bg-input/40 border", children: /* @__PURE__ */ v.jsx(bh, { className: "fill-foreground size-2.5" }) }),
            /* @__PURE__ */ v.jsx("span", { className: lt("truncate", !i.checked && "opacity-30"), children: i.serverName }),
            i.error ? /* @__PURE__ */ v.jsx(
              "span",
              {
                className: lt("text-xs text-destructive ml-1 p-1 rounded"),
                children: "error"
              }
            ) : null,
            /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-2 ml-auto", children: i.status === "authorizing" ? /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-1", children: /* @__PURE__ */ v.jsx(ub, { className: "size-3 text-muted-foreground" }) }) : /* @__PURE__ */ v.jsx(v.Fragment, { children: i.tools.filter((o) => o.checked).length > 0 ? /* @__PURE__ */ v.jsx("span", { className: "w-5 h-5 items-center justify-start flex text-[8px] text-muted-foreground font-semibold ", children: /* @__PURE__ */ v.jsx(
              Vh,
              {
                variant: "outline",
                className: "h-5 min-w-5 rounded-full px-1 font-mono tabular-nums",
                children: i.tools.filter((o) => o.checked).length
              }
            ) }) : null }) })
          ]
        }
      ),
      /* @__PURE__ */ v.jsx(Jfe, { children: /* @__PURE__ */ v.jsx(ihe, { className: "w-80 relative", children: /* @__PURE__ */ v.jsx(
        Vze,
        {
          tools: i.tools,
          isAuthorizing: i.status === "authorizing",
          authorizationUrl: i.authorizationUrl,
          error: i.error,
          checked: i.checked,
          serverId: i.id,
          onClickAllChecked: (o) => {
            r(
              i.id,
              o ? i.tools.map((s) => s.name) : []
            );
          },
          onToolClick: (o, s) => {
            const a = i.tools.filter((c) => c.checked).map((c) => c.name);
            r(
              i.id,
              s ? a.concat(o) : a.filter((c) => c !== o)
            );
          }
        }
      ) }) })
    ] }, i.id)),
    t.value.length !== 0 && /* @__PURE__ */ v.jsx("div", { className: "py-1 w-full", children: /* @__PURE__ */ v.jsx(Db, {}) }),
    /* @__PURE__ */ v.jsxs("div", { className: "text-sm text-muted-foreground w-full h-full flex flex-col items-center justify-center py-6", children: [
      t.value.length !== 0 ? /* @__PURE__ */ v.jsx("div", { children: "Welcome to additional MCP servers!" }) : /* @__PURE__ */ v.jsx("div", { children: "No MCP servers detected." }),
      /* @__PURE__ */ v.jsx(Ow, { to: "/chat-bot/mcp/create", children: /* @__PURE__ */ v.jsxs(
        qt,
        {
          variant: "ghost",
          className: "mt-2 text-primary flex items-center gap-1",
          children: [
            "Add a server ",
            /* @__PURE__ */ v.jsx(Vg, { className: "size-4" })
          ]
        }
      ) })
    ] })
  ] });
};
function Wze({
  align: e,
  side: t,
  mentions: n,
  className: r
}) {
  const [i, o] = C.useState(!1), { data: s, isLoading: a } = W9(), {
    chatbotServerStore: { allowedMcpServers: c, mcpServerList: u }
  } = la(), f = C.useMemo(() => n?.find((g) => g.type === "agent"), [n]);
  let h = C.useMemo(() => {
    if (n?.length)
      return n.map((x) => x.name);
    const g = u.value.map((x) => x.id);
    return [...Object.values(
      D9(c?.value ?? {}).filter(
        (x, w) => g.includes(String(w))
      )
    ).map((x) => x.tools ?? []).flat()];
  }, [
    n,
    u.value,
    c.value,
    s
  ]);
  const m = C.useMemo(() => /* @__PURE__ */ v.jsxs(
    qt,
    {
      variant: "ghost",
      size: "sm",
      className: lt(
        "gap-0.5 bg-background/50 border rounded-full data-[state=open]:bg-input! hover:bg-input! cursor-pointer",
        !h.length && !a && "text-muted-foreground bg-transparent border-transparent",
        a && "bg-input/60",
        i && "bg-input!",
        r
      ),
      children: [
        /* @__PURE__ */ v.jsx("span", { className: h ? "" : "text-muted-foreground", children: f ? "Agent" : n?.length ?? !1 ? "Mention" : "Tools" }),
        (!f && h.length > 0 || a) && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
          /* @__PURE__ */ v.jsx("div", { className: "h-4 hidden sm:block mx-1", children: /* @__PURE__ */ v.jsx(Mb, { orientation: "vertical" }) }),
          /* @__PURE__ */ v.jsx("div", { className: "min-w-5 flex justify-center", children: a ? /* @__PURE__ */ v.jsx(dA, { className: "animate-spin size-3.5" }) : (n?.length ?? 0) > 0 ? /* @__PURE__ */ v.jsx(x4, { className: "size-3.5" }) : /* @__PURE__ */ v.jsx(
            Uze,
            {
              number: h.length,
              className: "text-xs"
            }
          ) })
        ] })
      ]
    }
  ), [
    h.length,
    a,
    i,
    r,
    f,
    n?.length
  ]);
  return /* @__PURE__ */ v.jsxs(od, { open: i, onOpenChange: o, children: [
    /* @__PURE__ */ v.jsx(sd, { asChild: !0, children: /* @__PURE__ */ v.jsx("div", { children: /* @__PURE__ */ v.jsxs(Yi, { children: [
      /* @__PURE__ */ v.jsx(go, { asChild: !0, children: m }),
      /* @__PURE__ */ v.jsxs(
        Vo,
        {
          align: e,
          side: t,
          className: "p-4 text-xs bg-card border border-border",
          children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ v.jsx(db, { className: "size-3.5" }),
              /* @__PURE__ */ v.jsx("span", { className: "text-sm", children: "Tools Setup" })
            ] }),
            /* @__PURE__ */ v.jsx("p", { className: "text-muted-foreground mt-4 whitespace-pre-wrap", children: `"Select tools that the chatbot can use.
The chatbot will use selected tools based on its own judgment.

You can also force the use of specific tools through @mention.",` })
          ]
        }
      )
    ] }) }) }),
    /* @__PURE__ */ v.jsx(ad, { className: "md:w-72", align: e, side: t, children: /* @__PURE__ */ v.jsxs("div", { className: "py-2", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "py-1", children: [
        /* @__PURE__ */ v.jsx("span", { className: "px-3 text-sm font-medium", children: "MCP Servers" }),
        /* @__PURE__ */ v.jsx(Db, {})
      ] }),
      /* @__PURE__ */ v.jsx(Hze, {}),
      /* @__PURE__ */ v.jsx(Db, {})
    ] }) })
  ] });
}
const SG = window.SpeechRecognition || window.webkitSpeechRecognition, kG = !!SG, qze = (e) => () => {
  const { isListening: t, recognitionRef: n, setIsListening: r, onTranscript: i, language: o = "en-US" } = e;
  if (!kG) {
    alert("Speech recognition is not supported. Please use Chrome or Edge.");
    return;
  }
  if (t) {
    n.current && (n.current.stop(), n.current = null), r(!1);
    return;
  }
  let s = "";
  const a = new SG();
  a.continuous = !0, a.interimResults = !0, a.lang = o, a.onresult = (c) => {
    s = "";
    for (let u = 0; u < c.results.length; u++) {
      const f = c.results[u][0].transcript;
      c.results[u].isFinal && (s += f + " ");
    }
    s && i && (i(s), s = "");
  }, a.onend = () => {
    r(!1), n.current = null;
  }, a.onerror = (c) => {
    c.error === "not-allowed" || c.error === "permission-denied" ? alert("Please allow microphone access in your browser.") : c.error !== "aborted" && console.error("Speech recognition error:", c.error), r(!1);
  };
  try {
    a.start(), n.current = a, r(!0);
  } catch (c) {
    console.error("Failed to start speech recognition", c), r(!1);
  }
}, Gze = (e) => async () => {
  const {
    localValue: t,
    isAIThinking: n,
    isListening: r,
    recognitionRef: i,
    editor: o,
    setHistory: s,
    setHistoryIndex: a,
    setLocalValue: c,
    setIsListening: u,
    setFiles: f,
    startedTypingRef: h,
    onChange: m,
    onSend: g
  } = e, b = (t || "").trim();
  if (n || !b) return;
  if (r && i.current)
    try {
      i.current.stop(), i.current = null, u(!1);
    } catch (w) {
      console.error("Error stopping speech recognition:", w);
    }
  const x = [];
  if (o && o.state && o.state.doc)
    try {
      o.state.doc.descendants((w) => (w && w.type && w.type.name === "mention" && w.attrs && x.push({
        type: "mcpTool",
        name: w.attrs.id ?? w.attrs.label ?? "",
        label: w.attrs.label ?? w.attrs.id ?? "",
        description: w.attrs.description ?? "",
        serverId: w.attrs.serverId ?? "",
        serverName: w.attrs.serverName ?? ""
      }), !0));
    } catch (w) {
      console.error("Error collecting mentions:", w);
    }
  try {
    if (b && s((w) => w[w.length - 1] === b ? w : [...w, b].slice(-10)), a(null), c(""), m && m(""), f([]), o && o.view)
      try {
        o.commands.setContent(""), setTimeout(() => {
          if (o && o.view)
            try {
              o.commands.focus();
            } catch {
            }
        }, 100);
      } catch (w) {
        console.error("Error clearing editor:", w);
      }
    h.current = !1, await g(b, x);
  } catch (w) {
    throw console.error("PromptInput: send error", w), w;
  }
};
var ig = /* @__PURE__ */ ((e) => (e.View3D = "Show in 3D View", e.ViewGraph = "Show in Graph View", e.ViewInspection = "Show in Inspection", e))(ig || {}), sb = /* @__PURE__ */ ((e) => (e.Hierarchy = "Hierarchy", e.System = "System", e.GraphRelationship = "GraphRelationship", e.GraphComputation = "GraphComputation", e.MakeAsRootProject = "MakeAsRootProject", e.HandleRelationship = "HandleRelationship", e.HandleComposite = "HandleComposite", e.InspectionRelationship = "InspectionRelationship", e.PropertyReferenceEntity = "PropertyReferenceEntity", e.ImportedModelBachedGroup = "ImportedModelBachedGroup", e.ImportedModelFloorPlan = "ImportedModelFloorPlan", e.ImportedModelPdfViewer = "ImportedModelPdfViewer", e.ImportedModel3D = "ImportedModel3D", e.MakeAsRootBachedGroup = "MakeAsRootBachedGroup", e.HandlePromptUserInputChatbot = "HandlePromptUserInputChatbot", e.HandleRelationshipCreationSource = "HandleRelationshipCreationSource", e.HandleRelationshipCreationTarget = "HandleRelationshipCreationTarget", e))(sb || {});
function w3(e) {
  const {
    value: t = "",
    onChange: n,
    onSend: r,
    opStop: i,
    onFilesChange: o,
    files: s,
    onStartTyping: a,
    onUseNextSuggestionChange: c
  } = e, u = C.useRef(n), f = C.useRef(null), h = C.useRef("");
  C.useEffect(() => {
    u.current = n;
  }, [n]), C.useEffect(() => () => {
    f.current && (window.clearTimeout(f.current), f.current = null);
  }, []), v4();
  const {
    chatbotStore: { isAIThinking: m },
    chatbotThreadStore: { addThreadMention: g, removeThreadMention: b },
    chatbotServerStore: x
  } = la(), { setNodeRef: w, isOver: S } = CNe({
    id: sb.HandlePromptUserInputChatbot
  }), _ = PIe({
    extensions: [
      _ze,
      Tze.configure({
        placeholder: "Ask any thing"
      }),
      Dze.configure({ chatbotServerStore: x }),
      jze
    ],
    content: t ?? "",
    editable: !m.value,
    editorProps: {
      attributes: {
        class: "min-h-16 max-h-40 overflow-y-auto dark:bg-neutral-700 bg-neutral-200 resize-none border-0 focus-visible:ring-0 px-3 text-neutral-800 placeholder:text-neutral-600 dark:text-white dark:placeholder:text-gray-400"
      }
    },
    // Auto-focus on creation
    autofocus: "end"
  }), M = C.useRef(null), [N, D] = C.useState(!1), [j, O] = C.useState([]), [L, U] = C.useState(null), [B, G] = C.useState(s ?? []), [Y, he] = C.useState(t), ie = C.useRef(!1), ne = C.useRef(!1), [H, Q] = C.useState(() => {
    try {
      const ee = localStorage.getItem(vh.AI_USE_NEXT_SUGGESTION);
      return ee ? JSON.parse(ee) : !1;
    } catch {
      return !1;
    }
  }), X = C.useRef({});
  C.useEffect(() => {
    try {
      localStorage.setItem(
        "useNextSuggestion",
        JSON.stringify(H)
      );
    } catch {
    }
    c && c(H);
  }, [H, c]), C.useEffect(() => {
    const ee = (ge) => {
      const re = ge?.detail;
      if (re)
        try {
          g({
            type: "mcpTool",
            name: re.name,
            label: re.label ? re.label : re.name,
            description: re.description,
            serverId: re.serverId,
            serverName: re.serverName
          });
        } catch {
        }
    };
    return window.addEventListener(
      "tiptap-mention-inserted",
      ee
    ), () => window.removeEventListener(
      "tiptap-mention-inserted",
      ee
    );
  }, [g]), C.useEffect(() => {
    if (Array.isArray(s))
      try {
        const ee = JSON.stringify(B || []), ge = JSON.stringify(s || []);
        ee !== ge && G(s || []);
      } catch {
        G(s || []);
      }
  }, [s]), C.useEffect(() => {
    he(t ?? "");
  }, [t]), C.useEffect(() => {
    if (_)
      try {
        const ee = _.getText(), ge = t ?? "";
        if (ee !== ge) {
          if (ne.current && Math.abs(ee.length - ge.length) < 5)
            return;
          ne.current = !1, _.commands.setContent(ge), _.commands.focus("end");
        }
      } catch {
      }
  }, [_, t]);
  const Se = (ee) => {
    G(ee), o && o(ee);
  };
  C.useEffect(() => {
    if (_ && _.view)
      try {
        _.commands.focus();
      } catch {
      }
  }, [_]), C.useEffect(() => {
    if (!_) return;
    const ee = _.view?.dom ?? null;
    if (!ee) return;
    const ge = 240;
    let re = null;
    const J = () => {
      try {
        ee.style.height = "auto";
        const be = ee.scrollHeight || ee.offsetHeight;
        be > ge ? (ee.style.height = `${ge}px`, ee.style.overflowY = "auto") : (ee.style.height = `${Math.max(48, be)}px`, ee.style.overflowY = "hidden");
      } catch {
      }
    }, xe = () => {
      try {
        re && window.cancelAnimationFrame(re), re = window.requestAnimationFrame(() => {
          re = null, J();
        });
      } catch {
        J();
      }
    };
    return _.on("update", xe), xe(), () => {
      try {
        _.off("update", xe);
      } catch {
      }
      try {
        re && window.cancelAnimationFrame(re);
      } catch {
      }
      try {
        ee && (ee.style.overflowY = "", ee.style.height = "");
      } catch {
      }
    };
  }, [_]), C.useEffect(() => {
    if (!m.value && _ && _.view)
      try {
        _.commands.focus();
      } catch {
      }
  }, [m.value, _]), C.useEffect(() => {
    if (_)
      try {
        _.setEditable(!m.value);
      } catch {
      }
  }, [_, m.value]);
  const W = {
    handleKeyDown: (ee) => {
    }
  };
  C.useEffect(() => {
    if (!_) return;
    const ee = () => {
      ne.current = !0;
      const ge = _.getText();
      he(ge), h.current = ge, u.current && (f.current && window.clearTimeout(f.current), f.current = window.setTimeout(() => {
        try {
          u.current?.(h.current);
        } catch {
        }
      }, 400)), !ie.current && ge.trim().length > 0 && (ie.current = !0, a && a());
      const re = [];
      _.state.doc.descendants((Ae) => (Ae.type && Ae.type.name === "mention" && re.push(Ae.attrs.label ?? Ae.attrs.id ?? ""), !0));
      const J = X.current || {}, xe = new Set(re);
      Object.values(J).forEach((Ae) => {
        if (!xe.has(Ae)) {
          try {
            b(Ae);
          } catch {
          }
          (async () => {
            try {
              const nt = await zze(), Ge = new CustomEvent("mention-tools-fetched", {
                detail: nt
              });
              window.dispatchEvent(Ge);
            } catch {
            }
          })();
        }
      });
      const be = {};
      re.forEach((Ae, nt) => {
        be[String(nt)] = Ae;
      }), X.current = be;
    };
    return _.on("update", ee), () => {
      _.off("update", ee);
    };
  }, [_, n, a, b]);
  const Z = async () => {
    ne.current = !1, await Gze({
      localValue: Y,
      isAIThinking: m.value,
      isListening: N,
      recognitionRef: M,
      editor: _,
      setHistory: O,
      setHistoryIndex: U,
      setLocalValue: he,
      setIsListening: D,
      setFiles: G,
      startedTypingRef: ie,
      onChange: n,
      onSend: r
    })();
  }, pe = qze({
    isListening: N,
    recognitionRef: M,
    setIsListening: D,
    onTranscript: (ee) => {
      if (_ && _.commands)
        try {
          _.commands.focus(), _.commands.insertContent(ee);
        } catch (ge) {
          console.error("Error inserting speech text:", ge);
        }
      he((ge) => {
        const re = ge + ee;
        return h.current = re, u.current && (f.current && window.clearTimeout(f.current), f.current = window.setTimeout(() => {
          try {
            u.current?.(h.current);
          } catch {
          }
        }, 400)), re;
      });
    },
    language: "en-US"
    // change to "vi-VN" if you want Vietnamese
  }), F = (ee) => {
    const ge = B.filter((re, J) => J !== ee);
    G(ge);
  };
  return C.useEffect(() => {
    const ee = document.createElement("style");
    return ee.innerHTML = `
      .ProseMirror, .ProseMirror * {
        user-select: text !important;
        -webkit-user-select: text !important;
      }
      .ProseMirror p.is-editor-empty:first-child::before {
        content: attr(data-placeholder);
        float: left;
        color: #6b7280;
        pointer-events: none;
        height: 0;
      }
    `, document.head.appendChild(ee), () => {
      document.head.removeChild(ee);
    };
  }, []), C.useEffect(() => {
    if (!_) return;
    const ee = _.view?.dom;
    if (!ee) return;
    const ge = (re) => {
    };
    return ee.addEventListener("paste", ge), () => {
      ee.removeEventListener("paste", ge);
    };
  }, [_]), C.useEffect(() => {
    if (!_) return;
    const ee = (ge) => {
      const re = ge?.detail;
      if (re && _.isEditable)
        try {
          const J = (() => {
            try {
              return new URLSearchParams(window.location.search).get("version_id");
            } catch {
              return null;
            }
          })(), xe = re.position, be = _.view, Ae = xe && be?.posAtCoords ? be.posAtCoords({ left: xe.x, top: xe.y }) : null, nt = Ae && typeof Ae.pos == "number" ? Ae.pos : _.state.selection.from, Ge = re.entities || (re.id && re.name ? [{ id: re.id, name: re.name, classUri: re.classUri, versionId: re.versionId }] : []);
          if (Ge.length === 0) return;
          const rt = [];
          Ge.forEach((Tt, vn) => {
            rt.push({
              type: "entity",
              attrs: {
                id: Tt.id,
                name: Tt.name,
                classUri: Tt.classUri ?? null,
                versionId: Tt.versionId ?? J ?? null
              }
            }), rt.push({ type: "text", text: " " });
          }), _.chain().focus().insertContentAt(nt, rt).run();
        } catch {
        }
    };
    return window.addEventListener(sb.HandlePromptUserInputChatbot, ee), () => window.removeEventListener(sb.HandlePromptUserInputChatbot, ee);
  }, [_]), /* @__PURE__ */ v.jsxs(
    "div",
    {
      ref: w,
      className: `w-full border-t dark:bg-neutral-700 bg-neutral-200 backdrop-blur-md shadow-xl dark:border-0 p-2 flex flex-col gap-2 transition-all ${S ? "ring-4 ring-blue-500 ring-inset bg-blue-50 dark:bg-blue-950/30" : ""}`,
      children: [
        /* @__PURE__ */ v.jsxs("div", { className: "flex-1 flex flex-col", children: [
          B.length > 0 && /* @__PURE__ */ v.jsx("div", { className: "flex mt-1 w-full flex-wrap gap-2 max-h-32 overflow-y-auto wrap-break-word p-2", children: B.map((ee, ge) => /* @__PURE__ */ v.jsxs(
            Vh,
            {
              variant: "outline",
              className: "flex items-center justify-between gap-2 text-sm py-1 bg-background/50 dark:bg-neutral-800 rounded-md px-2 border",
              children: [
                /* @__PURE__ */ v.jsxs("div", { className: "truncate flex items-baseline gap-2", children: [
                  /* @__PURE__ */ v.jsx("div", { className: "font-medium", children: ee.name }),
                  ee.size && /* @__PURE__ */ v.jsx("div", { className: "text-xs text-neutral-500", children: Bze(ee.size) })
                ] }),
                /* @__PURE__ */ v.jsx(
                  "button",
                  {
                    onClick: () => F(ge),
                    title: "Remove",
                    className: "cursor-pointer text-neutral-400 hover:text-red-500 p-1",
                    children: /* @__PURE__ */ v.jsx(Hg, { className: "h-4 w-4" })
                  }
                )
              ]
            },
            ge
          )) }),
          /* @__PURE__ */ v.jsx("div", { className: "relative", children: ((ge) => !!ge && typeof ge.state == "object" && typeof ge.commands == "object")(_) ? /* @__PURE__ */ v.jsx(
            qq,
            {
              editor: _,
              tabIndex: 0,
              onCopy: (ge) => {
                ge.stopPropagation();
              },
              onCut: (ge) => {
                ge.stopPropagation();
              },
              onPaste: (ge) => {
                ge.stopPropagation();
              },
              onKeyDown: (ge) => {
                const re = ge.key?.toLowerCase();
                if ((ge.ctrlKey || ge.metaKey) && (re === "c" || re === "x" || re === "v" || re === "a")) {
                  ge.stopPropagation();
                  return;
                }
                try {
                  W.handleKeyDown(ge);
                } catch {
                }
                const xe = Lze({
                  localValue: Y,
                  history: j,
                  historyIndex: L,
                  setHistoryIndex: U,
                  setLocalValue: he,
                  onChange: n,
                  doSendAndClear: Z,
                  mention: { handleKeyDown: W.handleKeyDown }
                });
                try {
                  xe(ge);
                } catch {
                }
              },
              "data-chatbot-text": "chatbot-input"
            }
          ) : null })
        ] }),
        /* @__PURE__ */ v.jsxs("div", { className: "flex flex-row items-center gap-2", children: [
          /* @__PURE__ */ v.jsx(
            Wze,
            {
              className: "mx-1",
              align: "start",
              side: "top",
              mentions: []
            }
          ),
          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-row items-center gap-2 ml-auto", children: [
            /* @__PURE__ */ v.jsx(
              _Ne,
              {
                files: B,
                onFilesChange: Se,
                isAIThinking: m.value
              }
            ),
            /* @__PURE__ */ v.jsx(
              qt,
              {
                size: "icon",
                variant: "ghost",
                onClick: pe,
                type: "button",
                disabled: !kG || m.value,
                "aria-pressed": N,
                title: N ? "Stop voice" : "Start voice",
                className: N ? "cursor-pointer  bg-neutral-200 dark:bg-neutral-800 text-red-500 dark:text-red-400" : "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
                children: N ? /* @__PURE__ */ v.jsx(nX, { className: "h-5 w-5" }) : /* @__PURE__ */ v.jsx(iX, { className: "h-5 w-5" })
              }
            ),
            /* @__PURE__ */ v.jsxs(od, { children: [
              /* @__PURE__ */ v.jsx(sd, { asChild: !0, children: /* @__PURE__ */ v.jsx(
                qt,
                {
                  size: "icon",
                  variant: "ghost",
                  disabled: m.value,
                  title: "Using next suggestion",
                  className: "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
                  children: /* @__PURE__ */ v.jsx(XY, { className: "h-5 w-5" })
                }
              ) }),
              /* @__PURE__ */ v.jsx(ad, { align: "end", side: "top", className: "w-72", children: /* @__PURE__ */ v.jsxs(
                hs,
                {
                  onSelect: (ee) => ee.preventDefault(),
                  className: "flex items-center justify-between gap-3 cursor-pointer px-3 py-2",
                  children: [
                    /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
                      /* @__PURE__ */ v.jsx(FY, { className: "h-4 w-4 text-amber-500 shrink-0" }),
                      /* @__PURE__ */ v.jsx("span", { className: "text-sm font-medium whitespace-nowrap", children: "Using next suggestion" })
                    ] }),
                    /* @__PURE__ */ v.jsx(
                      IH,
                      {
                        checked: H,
                        onCheckedChange: (ee) => Q(ee),
                        className: "shrink-0"
                      }
                    )
                  ]
                }
              ) })
            ] }),
            m.value ? /* @__PURE__ */ v.jsx(
              qt,
              {
                size: "icon",
                className: "cursor-pointer rounded-full bg-red-900 text-white hover:bg-blue-600 transition-colors shadow-md dark:bg-red-900 dark:hover:bg-neutral-800",
                onClick: i,
                disabled: !m.value,
                title: "Stop thinking",
                children: /* @__PURE__ */ v.jsx(aX, { className: "h-5 w-5" })
              }
            ) : /* @__PURE__ */ v.jsx(
              qt,
              {
                size: "icon",
                className: "cursor-pointer rounded-full bg-blue-500 text-white hover:bg-blue-600 transition-colors shadow-md dark:bg-green-500 dark:hover:bg-neutral-800",
                onClick: Z,
                disabled: m.value || !(Y || "").trim(),
                title: "Send (Ctrl+End)",
                children: /* @__PURE__ */ v.jsx(vX, { className: "h-5 w-5" })
              }
            )
          ] })
        ] })
      ]
    }
  );
}
function S3() {
  return /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-muted-foreground text-xs px-6 py-2 mt-1", children: [
    /* @__PURE__ */ v.jsx(cA, { className: "h-4 w-4 text-blue-400 dark:text-[#1abcfe] animate-pulse" }),
    /* @__PURE__ */ v.jsx("span", { className: "animate-pulse", children: "Thinking" })
  ] });
}
const Kze = ({
  error: e
}) => {
  const [t, n] = C.useState(!1), r = e?.message ?? "Unknown error", i = r.length > 200 ? r.slice(0, 200) + "" : r;
  return /* @__PURE__ */ v.jsx("div", { className: "w-full mx-auto max-w-2xl px-4 mt-6", children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-3 bg-stone-50 dark:bg-stone-800/30 border border-stone-200 dark:border-stone-700 rounded-xl p-4 shadow-sm", children: [
    /* @__PURE__ */ v.jsx("div", { className: "flex-shrink-0 mt-1", children: /* @__PURE__ */ v.jsx(DX, { className: "h-6 w-6 text-amber-500" }) }),
    /* @__PURE__ */ v.jsxs("div", { className: "flex-1 min-w-0", children: [
      /* @__PURE__ */ v.jsx("div", { className: "font-semibold text-stone-800 dark:text-stone-200 mb-1", children: "Oops! Something went wrong" }),
      /* @__PURE__ */ v.jsx("div", { className: "whitespace-pre-wrap break-words text-stone-700 dark:text-stone-300 text-sm leading-relaxed", children: t ? r : i }),
      r.length > 200 && /* @__PURE__ */ v.jsx(
        "button",
        {
          className: "mt-2 text-xs text-blue-600 dark:text-blue-400 underline hover:opacity-80",
          onClick: () => n((o) => !o),
          children: t ? "Show less" : "Show more"
        }
      ),
      /* @__PURE__ */ v.jsx("div", { className: "mt-3 text-xs text-stone-500 dark:text-stone-400", children: "Try refreshing the page or checking your connection. If the problem keeps happening, please contact support." })
    ] })
  ] }) });
}, Zze = (e, t) => {
  t(e ?? ""), setTimeout(() => {
    const n = document.querySelector(
      'div[data-chatbot-text="chatbot-input"]'
    );
    if (n && n.focus)
      try {
        n.focus();
      } catch {
      }
  }, 100);
}, w1 = C.createContext(null);
w1.displayName = "PanelGroupContext";
const or = {
  group: "data-panel-group",
  groupDirection: "data-panel-group-direction",
  groupId: "data-panel-group-id",
  panel: "data-panel",
  panelCollapsible: "data-panel-collapsible",
  panelId: "data-panel-id",
  panelSize: "data-panel-size",
  resizeHandle: "data-resize-handle",
  resizeHandleActive: "data-resize-handle-active",
  resizeHandleEnabled: "data-panel-resize-handle-enabled",
  resizeHandleId: "data-panel-resize-handle-id",
  resizeHandleState: "data-resize-handle-state"
}, xR = 10, Qu = C.useLayoutEffect, k3 = nw.useId, Yze = typeof k3 == "function" ? k3 : () => null;
let Xze = 0;
function wR(e = null) {
  const t = Yze(), n = C.useRef(e || t || null);
  return n.current === null && (n.current = "" + Xze++), e ?? n.current;
}
function CG({
  children: e,
  className: t = "",
  collapsedSize: n,
  collapsible: r,
  defaultSize: i,
  forwardedRef: o,
  id: s,
  maxSize: a,
  minSize: c,
  onCollapse: u,
  onExpand: f,
  onResize: h,
  order: m,
  style: g,
  tagName: b = "div",
  ...x
}) {
  const w = C.useContext(w1);
  if (w === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    collapsePanel: S,
    expandPanel: _,
    getPanelSize: M,
    getPanelStyle: N,
    groupId: D,
    isPanelCollapsed: j,
    reevaluatePanelConstraints: O,
    registerPanel: L,
    resizePanel: U,
    unregisterPanel: B
  } = w, G = wR(s), Y = C.useRef({
    callbacks: {
      onCollapse: u,
      onExpand: f,
      onResize: h
    },
    constraints: {
      collapsedSize: n,
      collapsible: r,
      defaultSize: i,
      maxSize: a,
      minSize: c
    },
    id: G,
    idIsFromProps: s !== void 0,
    order: m
  });
  C.useRef({
    didLogMissingDefaultSizeWarning: !1
  }), Qu(() => {
    const {
      callbacks: ie,
      constraints: ne
    } = Y.current, H = {
      ...ne
    };
    Y.current.id = G, Y.current.idIsFromProps = s !== void 0, Y.current.order = m, ie.onCollapse = u, ie.onExpand = f, ie.onResize = h, ne.collapsedSize = n, ne.collapsible = r, ne.defaultSize = i, ne.maxSize = a, ne.minSize = c, (H.collapsedSize !== ne.collapsedSize || H.collapsible !== ne.collapsible || H.maxSize !== ne.maxSize || H.minSize !== ne.minSize) && O(Y.current, H);
  }), Qu(() => {
    const ie = Y.current;
    return L(ie), () => {
      B(ie);
    };
  }, [m, G, L, B]), C.useImperativeHandle(o, () => ({
    collapse: () => {
      S(Y.current);
    },
    expand: (ie) => {
      _(Y.current, ie);
    },
    getId() {
      return G;
    },
    getSize() {
      return M(Y.current);
    },
    isCollapsed() {
      return j(Y.current);
    },
    isExpanded() {
      return !j(Y.current);
    },
    resize: (ie) => {
      U(Y.current, ie);
    }
  }), [S, _, M, j, G, U]);
  const he = N(Y.current, i);
  return C.createElement(b, {
    ...x,
    children: e,
    className: t,
    id: G,
    style: {
      ...he,
      ...g
    },
    // CSS selectors
    [or.groupId]: D,
    [or.panel]: "",
    [or.panelCollapsible]: r || void 0,
    [or.panelId]: G,
    [or.panelSize]: parseFloat("" + he.flexGrow).toFixed(1)
  });
}
const EG = C.forwardRef((e, t) => C.createElement(CG, {
  ...e,
  forwardedRef: t
}));
CG.displayName = "Panel";
EG.displayName = "forwardRef(Panel)";
let iA = null, ab = -1, dc = null;
function Jze(e, t, n) {
  const r = (t & NG) !== 0, i = (t & RG) !== 0, o = (t & OG) !== 0, s = (t & PG) !== 0;
  if (t) {
    if (r)
      return o ? "se-resize" : s ? "ne-resize" : "e-resize";
    if (i)
      return o ? "sw-resize" : s ? "nw-resize" : "w-resize";
    if (o)
      return "s-resize";
    if (s)
      return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function Qze() {
  dc !== null && (document.head.removeChild(dc), iA = null, dc = null, ab = -1);
}
function RE(e, t, n) {
  var r, i;
  const o = Jze(e, t);
  if (iA !== o) {
    if (iA = o, dc === null && (dc = document.createElement("style"), document.head.appendChild(dc)), ab >= 0) {
      var s;
      (s = dc.sheet) === null || s === void 0 || s.removeRule(ab);
    }
    ab = (r = (i = dc.sheet) === null || i === void 0 ? void 0 : i.insertRule(`*{cursor: ${o} !important;}`)) !== null && r !== void 0 ? r : -1;
  }
}
function _G(e) {
  return e.type === "keydown";
}
function TG(e) {
  return e.type.startsWith("pointer");
}
function AG(e) {
  return e.type.startsWith("mouse");
}
function S1(e) {
  if (TG(e)) {
    if (e.isPrimary)
      return {
        x: e.clientX,
        y: e.clientY
      };
  } else if (AG(e))
    return {
      x: e.clientX,
      y: e.clientY
    };
  return {
    x: 1 / 0,
    y: 1 / 0
  };
}
function eLe() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
function tLe(e, t, n) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function nLe(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: _3(e),
    b: _3(t)
  };
  let r;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), r = e;
  zt(r, "Stacking order can only be calculated for elements with a common ancestor");
  const i = {
    a: E3(C3(n.a)),
    b: E3(C3(n.b))
  };
  if (i.a === i.b) {
    const o = r.childNodes, s = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let a = o.length;
    for (; a--; ) {
      const c = o[a];
      if (c === s.a) return 1;
      if (c === s.b) return -1;
    }
  }
  return Math.sign(i.a - i.b);
}
const rLe = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function iLe(e) {
  var t;
  const n = getComputedStyle((t = MG(e)) !== null && t !== void 0 ? t : e).display;
  return n === "flex" || n === "inline-flex";
}
function oLe(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || iLe(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || rLe.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function C3(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (zt(n, "Missing node"), oLe(n)) return n;
  }
  return null;
}
function E3(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function _3(e) {
  const t = [];
  for (; e; )
    t.push(e), e = MG(e);
  return t;
}
function MG(e) {
  const {
    parentNode: t
  } = e;
  return t && t instanceof ShadowRoot ? t.host : t;
}
const NG = 1, RG = 2, OG = 4, PG = 8, sLe = eLe() === "coarse";
let gs = [], dh = !1, fc = /* @__PURE__ */ new Map(), k1 = /* @__PURE__ */ new Map();
const Bg = /* @__PURE__ */ new Set();
function aLe(e, t, n, r, i) {
  var o;
  const {
    ownerDocument: s
  } = t, a = {
    direction: n,
    element: t,
    hitAreaMargins: r,
    setResizeHandlerState: i
  }, c = (o = fc.get(s)) !== null && o !== void 0 ? o : 0;
  return fc.set(s, c + 1), Bg.add(a), Jx(), function() {
    var f;
    k1.delete(e), Bg.delete(a);
    const h = (f = fc.get(s)) !== null && f !== void 0 ? f : 1;
    if (fc.set(s, h - 1), Jx(), h === 1 && fc.delete(s), gs.includes(a)) {
      const m = gs.indexOf(a);
      m >= 0 && gs.splice(m, 1), C1(), i("up", !0, null);
    }
  };
}
function lLe(e) {
  const {
    target: t
  } = e, {
    x: n,
    y: r
  } = S1(e);
  dh = !0, SR({
    target: t,
    x: n,
    y: r
  }), Jx(), gs.length > 0 && (Qx("down", e), C1(), e.preventDefault(), DG(t) || e.stopImmediatePropagation());
}
function OE(e) {
  const {
    x: t,
    y: n
  } = S1(e);
  if (dh && // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
  e.type !== "pointerleave" && e.buttons === 0 && (dh = !1, Qx("up", e)), !dh) {
    const {
      target: r
    } = e;
    SR({
      target: r,
      x: t,
      y: n
    });
  }
  Qx("move", e), C1(), gs.length > 0 && e.preventDefault();
}
function PE(e) {
  const {
    target: t
  } = e, {
    x: n,
    y: r
  } = S1(e);
  k1.clear(), dh = !1, gs.length > 0 && (e.preventDefault(), DG(t) || e.stopImmediatePropagation()), Qx("up", e), SR({
    target: t,
    x: n,
    y: r
  }), C1(), Jx();
}
function DG(e) {
  let t = e;
  for (; t; ) {
    if (t.hasAttribute(or.resizeHandle))
      return !0;
    t = t.parentElement;
  }
  return !1;
}
function SR({
  target: e,
  x: t,
  y: n
}) {
  gs.splice(0);
  let r = null;
  (e instanceof HTMLElement || e instanceof SVGElement) && (r = e), Bg.forEach((i) => {
    const {
      element: o,
      hitAreaMargins: s
    } = i, a = o.getBoundingClientRect(), {
      bottom: c,
      left: u,
      right: f,
      top: h
    } = a, m = sLe ? s.coarse : s.fine;
    if (t >= u - m && t <= f + m && n >= h - m && n <= c + m) {
      if (r !== null && document.contains(r) && o !== r && !o.contains(r) && !r.contains(o) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      nLe(r, o) > 0) {
        let b = r, x = !1;
        for (; b && !b.contains(o); ) {
          if (tLe(b.getBoundingClientRect(), a)) {
            x = !0;
            break;
          }
          b = b.parentElement;
        }
        if (x)
          return;
      }
      gs.push(i);
    }
  });
}
function DE(e, t) {
  k1.set(e, t);
}
function C1() {
  let e = !1, t = !1;
  gs.forEach((r) => {
    const {
      direction: i
    } = r;
    i === "horizontal" ? e = !0 : t = !0;
  });
  let n = 0;
  k1.forEach((r) => {
    n |= r;
  }), e && t ? RE("intersection", n) : e ? RE("horizontal", n) : t ? RE("vertical", n) : Qze();
}
let IE;
function Jx() {
  var e;
  (e = IE) === null || e === void 0 || e.abort(), IE = new AbortController();
  const t = {
    capture: !0,
    signal: IE.signal
  };
  Bg.size && (dh ? (gs.length > 0 && fc.forEach((n, r) => {
    const {
      body: i
    } = r;
    n > 0 && (i.addEventListener("contextmenu", PE, t), i.addEventListener("pointerleave", OE, t), i.addEventListener("pointermove", OE, t));
  }), fc.forEach((n, r) => {
    const {
      body: i
    } = r;
    i.addEventListener("pointerup", PE, t), i.addEventListener("pointercancel", PE, t);
  })) : fc.forEach((n, r) => {
    const {
      body: i
    } = r;
    n > 0 && (i.addEventListener("pointerdown", lLe, t), i.addEventListener("pointermove", OE, t));
  }));
}
function Qx(e, t) {
  Bg.forEach((n) => {
    const {
      setResizeHandlerState: r
    } = n, i = gs.includes(n);
    r(e, i, t);
  });
}
function cLe() {
  const [e, t] = C.useState(0);
  return C.useCallback(() => t((n) => n + 1), []);
}
function zt(e, t) {
  if (!e)
    throw console.error(t), Error(t);
}
function md(e, t, n = xR) {
  return e.toFixed(n) === t.toFixed(n) ? 0 : e > t ? 1 : -1;
}
function Ka(e, t, n = xR) {
  return md(e, t, n) === 0;
}
function fo(e, t, n) {
  return md(e, t, n) === 0;
}
function uLe(e, t, n) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++) {
    const i = e[r], o = t[r];
    if (!fo(i, o, n))
      return !1;
  }
  return !0;
}
function eh({
  panelConstraints: e,
  panelIndex: t,
  size: n
}) {
  const r = e[t];
  zt(r != null, `Panel constraints not found for index ${t}`);
  let {
    collapsedSize: i = 0,
    collapsible: o,
    maxSize: s = 100,
    minSize: a = 0
  } = r;
  if (md(n, a) < 0)
    if (o) {
      const c = (i + a) / 2;
      md(n, c) < 0 ? n = i : n = a;
    } else
      n = a;
  return n = Math.min(s, n), n = parseFloat(n.toFixed(xR)), n;
}
function Om({
  delta: e,
  initialLayout: t,
  panelConstraints: n,
  pivotIndices: r,
  prevLayout: i,
  trigger: o
}) {
  if (fo(e, 0))
    return t;
  const s = [...t], [a, c] = r;
  zt(a != null, "Invalid first pivot index"), zt(c != null, "Invalid second pivot index");
  let u = 0;
  if (o === "keyboard") {
    {
      const h = e < 0 ? c : a, m = n[h];
      zt(m, `Panel constraints not found for index ${h}`);
      const {
        collapsedSize: g = 0,
        collapsible: b,
        minSize: x = 0
      } = m;
      if (b) {
        const w = t[h];
        if (zt(w != null, `Previous layout not found for panel index ${h}`), fo(w, g)) {
          const S = x - w;
          md(S, Math.abs(e)) > 0 && (e = e < 0 ? 0 - S : S);
        }
      }
    }
    {
      const h = e < 0 ? a : c, m = n[h];
      zt(m, `No panel constraints found for index ${h}`);
      const {
        collapsedSize: g = 0,
        collapsible: b,
        minSize: x = 0
      } = m;
      if (b) {
        const w = t[h];
        if (zt(w != null, `Previous layout not found for panel index ${h}`), fo(w, x)) {
          const S = w - g;
          md(S, Math.abs(e)) > 0 && (e = e < 0 ? 0 - S : S);
        }
      }
    }
  }
  {
    const h = e < 0 ? 1 : -1;
    let m = e < 0 ? c : a, g = 0;
    for (; ; ) {
      const x = t[m];
      zt(x != null, `Previous layout not found for panel index ${m}`);
      const S = eh({
        panelConstraints: n,
        panelIndex: m,
        size: 100
      }) - x;
      if (g += S, m += h, m < 0 || m >= n.length)
        break;
    }
    const b = Math.min(Math.abs(e), Math.abs(g));
    e = e < 0 ? 0 - b : b;
  }
  {
    let m = e < 0 ? a : c;
    for (; m >= 0 && m < n.length; ) {
      const g = Math.abs(e) - Math.abs(u), b = t[m];
      zt(b != null, `Previous layout not found for panel index ${m}`);
      const x = b - g, w = eh({
        panelConstraints: n,
        panelIndex: m,
        size: x
      });
      if (!fo(b, w) && (u += b - w, s[m] = w, u.toFixed(3).localeCompare(Math.abs(e).toFixed(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? m-- : m++;
    }
  }
  if (uLe(i, s))
    return i;
  {
    const h = e < 0 ? c : a, m = t[h];
    zt(m != null, `Previous layout not found for panel index ${h}`);
    const g = m + u, b = eh({
      panelConstraints: n,
      panelIndex: h,
      size: g
    });
    if (s[h] = b, !fo(b, g)) {
      let x = g - b, S = e < 0 ? c : a;
      for (; S >= 0 && S < n.length; ) {
        const _ = s[S];
        zt(_ != null, `Previous layout not found for panel index ${S}`);
        const M = _ + x, N = eh({
          panelConstraints: n,
          panelIndex: S,
          size: M
        });
        if (fo(_, N) || (x -= N - _, s[S] = N), fo(x, 0))
          break;
        e > 0 ? S-- : S++;
      }
    }
  }
  const f = s.reduce((h, m) => m + h, 0);
  return fo(f, 100) ? s : i;
}
function dLe({
  layout: e,
  panelsArray: t,
  pivotIndices: n
}) {
  let r = 0, i = 100, o = 0, s = 0;
  const a = n[0];
  zt(a != null, "No pivot index found"), t.forEach((h, m) => {
    const {
      constraints: g
    } = h, {
      maxSize: b = 100,
      minSize: x = 0
    } = g;
    m === a ? (r = x, i = b) : (o += x, s += b);
  });
  const c = Math.min(i, 100 - o), u = Math.max(r, 100 - s), f = e[a];
  return {
    valueMax: c,
    valueMin: u,
    valueNow: f
  };
}
function $g(e, t = document) {
  return Array.from(t.querySelectorAll(`[${or.resizeHandleId}][data-panel-group-id="${e}"]`));
}
function IG(e, t, n = document) {
  const i = $g(e, n).findIndex((o) => o.getAttribute(or.resizeHandleId) === t);
  return i ?? null;
}
function jG(e, t, n) {
  const r = IG(e, t, n);
  return r != null ? [r, r + 1] : [-1, -1];
}
function fLe(e) {
  return e instanceof HTMLElement ? !0 : typeof e == "object" && e !== null && "tagName" in e && "getAttribute" in e;
}
function zG(e, t = document) {
  if (fLe(t) && t.dataset.panelGroupId == e)
    return t;
  const n = t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return n || null;
}
function E1(e, t = document) {
  const n = t.querySelector(`[${or.resizeHandleId}="${e}"]`);
  return n || null;
}
function hLe(e, t, n, r = document) {
  var i, o, s, a;
  const c = E1(t, r), u = $g(e, r), f = c ? u.indexOf(c) : -1, h = (i = (o = n[f]) === null || o === void 0 ? void 0 : o.id) !== null && i !== void 0 ? i : null, m = (s = (a = n[f + 1]) === null || a === void 0 ? void 0 : a.id) !== null && s !== void 0 ? s : null;
  return [h, m];
}
function pLe({
  committedValuesRef: e,
  eagerValuesRef: t,
  groupId: n,
  layout: r,
  panelDataArray: i,
  panelGroupElement: o,
  setLayout: s
}) {
  C.useRef({
    didWarnAboutMissingResizeHandle: !1
  }), Qu(() => {
    if (!o)
      return;
    const a = $g(n, o);
    for (let c = 0; c < i.length - 1; c++) {
      const {
        valueMax: u,
        valueMin: f,
        valueNow: h
      } = dLe({
        layout: r,
        panelsArray: i,
        pivotIndices: [c, c + 1]
      }), m = a[c];
      if (m != null) {
        const g = i[c];
        zt(g, `No panel data found for index "${c}"`), m.setAttribute("aria-controls", g.id), m.setAttribute("aria-valuemax", "" + Math.round(u)), m.setAttribute("aria-valuemin", "" + Math.round(f)), m.setAttribute("aria-valuenow", h != null ? "" + Math.round(h) : "");
      }
    }
    return () => {
      a.forEach((c, u) => {
        c.removeAttribute("aria-controls"), c.removeAttribute("aria-valuemax"), c.removeAttribute("aria-valuemin"), c.removeAttribute("aria-valuenow");
      });
    };
  }, [n, r, i, o]), C.useEffect(() => {
    if (!o)
      return;
    const a = t.current;
    zt(a, "Eager values not found");
    const {
      panelDataArray: c
    } = a, u = zG(n, o);
    zt(u != null, `No group found for id "${n}"`);
    const f = $g(n, o);
    zt(f, `No resize handles found for group id "${n}"`);
    const h = f.map((m) => {
      const g = m.getAttribute(or.resizeHandleId);
      zt(g, "Resize handle element has no handle id attribute");
      const [b, x] = hLe(n, g, c, o);
      if (b == null || x == null)
        return () => {
        };
      const w = (S) => {
        if (!S.defaultPrevented)
          switch (S.key) {
            case "Enter": {
              S.preventDefault();
              const _ = c.findIndex((M) => M.id === b);
              if (_ >= 0) {
                const M = c[_];
                zt(M, `No panel data found for index ${_}`);
                const N = r[_], {
                  collapsedSize: D = 0,
                  collapsible: j,
                  minSize: O = 0
                } = M.constraints;
                if (N != null && j) {
                  const L = Om({
                    delta: fo(N, D) ? O - D : D - N,
                    initialLayout: r,
                    panelConstraints: c.map((U) => U.constraints),
                    pivotIndices: jG(n, g, o),
                    prevLayout: r,
                    trigger: "keyboard"
                  });
                  r !== L && s(L);
                }
              }
              break;
            }
          }
      };
      return m.addEventListener("keydown", w), () => {
        m.removeEventListener("keydown", w);
      };
    });
    return () => {
      h.forEach((m) => m());
    };
  }, [o, e, t, n, r, i, s]);
}
function T3(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function LG(e, t) {
  const n = e === "horizontal", {
    x: r,
    y: i
  } = S1(t);
  return n ? r : i;
}
function mLe(e, t, n, r, i) {
  const o = n === "horizontal", s = E1(t, i);
  zt(s, `No resize handle element found for id "${t}"`);
  const a = s.getAttribute(or.groupId);
  zt(a, "Resize handle element has no group id attribute");
  let {
    initialCursorPosition: c
  } = r;
  const u = LG(n, e), f = zG(a, i);
  zt(f, `No group element found for id "${a}"`);
  const h = f.getBoundingClientRect(), m = o ? h.width : h.height;
  return (u - c) / m * 100;
}
function gLe(e, t, n, r, i, o) {
  if (_G(e)) {
    const s = n === "horizontal";
    let a = 0;
    e.shiftKey ? a = 100 : i != null ? a = i : a = 10;
    let c = 0;
    switch (e.key) {
      case "ArrowDown":
        c = s ? 0 : a;
        break;
      case "ArrowLeft":
        c = s ? -a : 0;
        break;
      case "ArrowRight":
        c = s ? a : 0;
        break;
      case "ArrowUp":
        c = s ? 0 : -a;
        break;
      case "End":
        c = 100;
        break;
      case "Home":
        c = -100;
        break;
    }
    return c;
  } else
    return r == null ? 0 : mLe(e, t, n, r, o);
}
function yLe({
  panelDataArray: e
}) {
  const t = Array(e.length), n = e.map((o) => o.constraints);
  let r = 0, i = 100;
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    zt(s, `Panel constraints not found for index ${o}`);
    const {
      defaultSize: a
    } = s;
    a != null && (r++, t[o] = a, i -= a);
  }
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    zt(s, `Panel constraints not found for index ${o}`);
    const {
      defaultSize: a
    } = s;
    if (a != null)
      continue;
    const c = e.length - r, u = i / c;
    r++, t[o] = u, i -= u;
  }
  return t;
}
function Nf(e, t, n) {
  t.forEach((r, i) => {
    const o = e[i];
    zt(o, `Panel data not found for index ${i}`);
    const {
      callbacks: s,
      constraints: a,
      id: c
    } = o, {
      collapsedSize: u = 0,
      collapsible: f
    } = a, h = n[c];
    if (h == null || r !== h) {
      n[c] = r;
      const {
        onCollapse: m,
        onExpand: g,
        onResize: b
      } = s;
      b && b(r, h), f && (m || g) && (g && (h == null || Ka(h, u)) && !Ka(r, u) && g(), m && (h == null || !Ka(h, u)) && Ka(r, u) && m());
    }
  });
}
function k0(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n])
      return !1;
  return !0;
}
function vLe({
  defaultSize: e,
  dragState: t,
  layout: n,
  panelData: r,
  panelIndex: i,
  precision: o = 3
}) {
  const s = n[i];
  let a;
  return s == null ? a = e != null ? e.toFixed(o) : "1" : r.length === 1 ? a = "1" : a = s.toFixed(o), {
    flexBasis: 0,
    flexGrow: a,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: t !== null ? "none" : void 0
  };
}
function bLe(e, t = 10) {
  let n = null;
  return (...i) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...i);
    }, t);
  };
}
function A3(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, n) => {
        localStorage.setItem(t, n);
      };
    else
      throw new Error("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function BG(e) {
  return `react-resizable-panels:${e}`;
}
function $G(e) {
  return e.map((t) => {
    const {
      constraints: n,
      id: r,
      idIsFromProps: i,
      order: o
    } = t;
    return i ? r : o ? `${o}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((t, n) => t.localeCompare(n)).join(",");
}
function UG(e, t) {
  try {
    const n = BG(e), r = t.getItem(n);
    if (r) {
      const i = JSON.parse(r);
      if (typeof i == "object" && i != null)
        return i;
    }
  } catch {
  }
  return null;
}
function xLe(e, t, n) {
  var r, i;
  const o = (r = UG(e, n)) !== null && r !== void 0 ? r : {}, s = $G(t);
  return (i = o[s]) !== null && i !== void 0 ? i : null;
}
function wLe(e, t, n, r, i) {
  var o;
  const s = BG(e), a = $G(t), c = (o = UG(e, i)) !== null && o !== void 0 ? o : {};
  c[a] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: r
  };
  try {
    i.setItem(s, JSON.stringify(c));
  } catch (u) {
    console.error(u);
  }
}
function M3({
  layout: e,
  panelConstraints: t
}) {
  const n = [...e], r = n.reduce((o, s) => o + s, 0);
  if (n.length !== t.length)
    throw Error(`Invalid ${t.length} panel layout: ${n.map((o) => `${o}%`).join(", ")}`);
  if (!fo(r, 100) && n.length > 0)
    for (let o = 0; o < t.length; o++) {
      const s = n[o];
      zt(s != null, `No layout data found for index ${o}`);
      const a = 100 / r * s;
      n[o] = a;
    }
  let i = 0;
  for (let o = 0; o < t.length; o++) {
    const s = n[o];
    zt(s != null, `No layout data found for index ${o}`);
    const a = eh({
      panelConstraints: t,
      panelIndex: o,
      size: s
    });
    s != a && (i += s - a, n[o] = a);
  }
  if (!fo(i, 0))
    for (let o = 0; o < t.length; o++) {
      const s = n[o];
      zt(s != null, `No layout data found for index ${o}`);
      const a = s + i, c = eh({
        panelConstraints: t,
        panelIndex: o,
        size: a
      });
      if (s !== c && (i -= c - s, n[o] = c, fo(i, 0)))
        break;
    }
  return n;
}
const SLe = 100, Pm = {
  getItem: (e) => (A3(Pm), Pm.getItem(e)),
  setItem: (e, t) => {
    A3(Pm), Pm.setItem(e, t);
  }
}, N3 = {};
function FG({
  autoSaveId: e = null,
  children: t,
  className: n = "",
  direction: r,
  forwardedRef: i,
  id: o = null,
  onLayout: s = null,
  keyboardResizeBy: a = null,
  storage: c = Pm,
  style: u,
  tagName: f = "div",
  ...h
}) {
  const m = wR(o), g = C.useRef(null), [b, x] = C.useState(null), [w, S] = C.useState([]), _ = cLe(), M = C.useRef({}), N = C.useRef(/* @__PURE__ */ new Map()), D = C.useRef(0), j = C.useRef({
    autoSaveId: e,
    direction: r,
    dragState: b,
    id: m,
    keyboardResizeBy: a,
    onLayout: s,
    storage: c
  }), O = C.useRef({
    layout: w,
    panelDataArray: [],
    panelDataArrayChanged: !1
  });
  C.useRef({
    didLogIdAndOrderWarning: !1,
    didLogPanelConstraintsWarning: !1,
    prevPanelIds: []
  }), C.useImperativeHandle(i, () => ({
    getId: () => j.current.id,
    getLayout: () => {
      const {
        layout: F
      } = O.current;
      return F;
    },
    setLayout: (F) => {
      const {
        onLayout: ee
      } = j.current, {
        layout: ge,
        panelDataArray: re
      } = O.current, J = M3({
        layout: F,
        panelConstraints: re.map((xe) => xe.constraints)
      });
      T3(ge, J) || (S(J), O.current.layout = J, ee && ee(J), Nf(re, J, M.current));
    }
  }), []), Qu(() => {
    j.current.autoSaveId = e, j.current.direction = r, j.current.dragState = b, j.current.id = m, j.current.onLayout = s, j.current.storage = c;
  }), pLe({
    committedValuesRef: j,
    eagerValuesRef: O,
    groupId: m,
    layout: w,
    panelDataArray: O.current.panelDataArray,
    setLayout: S,
    panelGroupElement: g.current
  }), C.useEffect(() => {
    const {
      panelDataArray: F
    } = O.current;
    if (e) {
      if (w.length === 0 || w.length !== F.length)
        return;
      let ee = N3[e];
      ee == null && (ee = bLe(wLe, SLe), N3[e] = ee);
      const ge = [...F], re = new Map(N.current);
      ee(e, ge, re, w, c);
    }
  }, [e, w, c]), C.useEffect(() => {
  });
  const L = C.useCallback((F) => {
    const {
      onLayout: ee
    } = j.current, {
      layout: ge,
      panelDataArray: re
    } = O.current;
    if (F.constraints.collapsible) {
      const J = re.map((nt) => nt.constraints), {
        collapsedSize: xe = 0,
        panelSize: be,
        pivotIndices: Ae
      } = Ou(re, F, ge);
      if (zt(be != null, `Panel size not found for panel "${F.id}"`), !Ka(be, xe)) {
        N.current.set(F.id, be);
        const Ge = Uf(re, F) === re.length - 1 ? be - xe : xe - be, rt = Om({
          delta: Ge,
          initialLayout: ge,
          panelConstraints: J,
          pivotIndices: Ae,
          prevLayout: ge,
          trigger: "imperative-api"
        });
        k0(ge, rt) || (S(rt), O.current.layout = rt, ee && ee(rt), Nf(re, rt, M.current));
      }
    }
  }, []), U = C.useCallback((F, ee) => {
    const {
      onLayout: ge
    } = j.current, {
      layout: re,
      panelDataArray: J
    } = O.current;
    if (F.constraints.collapsible) {
      const xe = J.map((Tt) => Tt.constraints), {
        collapsedSize: be = 0,
        panelSize: Ae = 0,
        minSize: nt = 0,
        pivotIndices: Ge
      } = Ou(J, F, re), rt = ee ?? nt;
      if (Ka(Ae, be)) {
        const Tt = N.current.get(F.id), vn = Tt != null && Tt >= rt ? Tt : rt, Wt = Uf(J, F) === J.length - 1 ? Ae - vn : vn - Ae, wt = Om({
          delta: Wt,
          initialLayout: re,
          panelConstraints: xe,
          pivotIndices: Ge,
          prevLayout: re,
          trigger: "imperative-api"
        });
        k0(re, wt) || (S(wt), O.current.layout = wt, ge && ge(wt), Nf(J, wt, M.current));
      }
    }
  }, []), B = C.useCallback((F) => {
    const {
      layout: ee,
      panelDataArray: ge
    } = O.current, {
      panelSize: re
    } = Ou(ge, F, ee);
    return zt(re != null, `Panel size not found for panel "${F.id}"`), re;
  }, []), G = C.useCallback((F, ee) => {
    const {
      panelDataArray: ge
    } = O.current, re = Uf(ge, F);
    return vLe({
      defaultSize: ee,
      dragState: b,
      layout: w,
      panelData: ge,
      panelIndex: re
    });
  }, [b, w]), Y = C.useCallback((F) => {
    const {
      layout: ee,
      panelDataArray: ge
    } = O.current, {
      collapsedSize: re = 0,
      collapsible: J,
      panelSize: xe
    } = Ou(ge, F, ee);
    return zt(xe != null, `Panel size not found for panel "${F.id}"`), J === !0 && Ka(xe, re);
  }, []), he = C.useCallback((F) => {
    const {
      layout: ee,
      panelDataArray: ge
    } = O.current, {
      collapsedSize: re = 0,
      collapsible: J,
      panelSize: xe
    } = Ou(ge, F, ee);
    return zt(xe != null, `Panel size not found for panel "${F.id}"`), !J || md(xe, re) > 0;
  }, []), ie = C.useCallback((F) => {
    const {
      panelDataArray: ee
    } = O.current;
    ee.push(F), ee.sort((ge, re) => {
      const J = ge.order, xe = re.order;
      return J == null && xe == null ? 0 : J == null ? -1 : xe == null ? 1 : J - xe;
    }), O.current.panelDataArrayChanged = !0, _();
  }, [_]);
  Qu(() => {
    if (O.current.panelDataArrayChanged) {
      O.current.panelDataArrayChanged = !1;
      const {
        autoSaveId: F,
        onLayout: ee,
        storage: ge
      } = j.current, {
        layout: re,
        panelDataArray: J
      } = O.current;
      let xe = null;
      if (F) {
        const Ae = xLe(F, J, ge);
        Ae && (N.current = new Map(Object.entries(Ae.expandToSizes)), xe = Ae.layout);
      }
      xe == null && (xe = yLe({
        panelDataArray: J
      }));
      const be = M3({
        layout: xe,
        panelConstraints: J.map((Ae) => Ae.constraints)
      });
      T3(re, be) || (S(be), O.current.layout = be, ee && ee(be), Nf(J, be, M.current));
    }
  }), Qu(() => {
    const F = O.current;
    return () => {
      F.layout = [];
    };
  }, []);
  const ne = C.useCallback((F) => {
    let ee = !1;
    const ge = g.current;
    return ge && window.getComputedStyle(ge, null).getPropertyValue("direction") === "rtl" && (ee = !0), function(J) {
      J.preventDefault();
      const xe = g.current;
      if (!xe)
        return () => null;
      const {
        direction: be,
        dragState: Ae,
        id: nt,
        keyboardResizeBy: Ge,
        onLayout: rt
      } = j.current, {
        layout: Tt,
        panelDataArray: vn
      } = O.current, {
        initialLayout: kt
      } = Ae ?? {}, Wt = jG(nt, F, xe);
      let wt = gLe(J, F, be, Ae, Ge, xe);
      const Yt = be === "horizontal";
      Yt && ee && (wt = -wt);
      const Mn = vn.map((In) => In.constraints), Rt = Om({
        delta: wt,
        initialLayout: kt ?? Tt,
        panelConstraints: Mn,
        pivotIndices: Wt,
        prevLayout: Tt,
        trigger: _G(J) ? "keyboard" : "mouse-or-touch"
      }), ln = !k0(Tt, Rt);
      (TG(J) || AG(J)) && D.current != wt && (D.current = wt, !ln && wt !== 0 ? Yt ? DE(F, wt < 0 ? NG : RG) : DE(F, wt < 0 ? OG : PG) : DE(F, 0)), ln && (S(Rt), O.current.layout = Rt, rt && rt(Rt), Nf(vn, Rt, M.current));
    };
  }, []), H = C.useCallback((F, ee) => {
    const {
      onLayout: ge
    } = j.current, {
      layout: re,
      panelDataArray: J
    } = O.current, xe = J.map((Tt) => Tt.constraints), {
      panelSize: be,
      pivotIndices: Ae
    } = Ou(J, F, re);
    zt(be != null, `Panel size not found for panel "${F.id}"`);
    const Ge = Uf(J, F) === J.length - 1 ? be - ee : ee - be, rt = Om({
      delta: Ge,
      initialLayout: re,
      panelConstraints: xe,
      pivotIndices: Ae,
      prevLayout: re,
      trigger: "imperative-api"
    });
    k0(re, rt) || (S(rt), O.current.layout = rt, ge && ge(rt), Nf(J, rt, M.current));
  }, []), Q = C.useCallback((F, ee) => {
    const {
      layout: ge,
      panelDataArray: re
    } = O.current, {
      collapsedSize: J = 0,
      collapsible: xe
    } = ee, {
      collapsedSize: be = 0,
      collapsible: Ae,
      maxSize: nt = 100,
      minSize: Ge = 0
    } = F.constraints, {
      panelSize: rt
    } = Ou(re, F, ge);
    rt != null && (xe && Ae && Ka(rt, J) ? Ka(J, be) || H(F, be) : rt < Ge ? H(F, Ge) : rt > nt && H(F, nt));
  }, [H]), X = C.useCallback((F, ee) => {
    const {
      direction: ge
    } = j.current, {
      layout: re
    } = O.current;
    if (!g.current)
      return;
    const J = E1(F, g.current);
    zt(J, `Drag handle element not found for id "${F}"`);
    const xe = LG(ge, ee);
    x({
      dragHandleId: F,
      dragHandleRect: J.getBoundingClientRect(),
      initialCursorPosition: xe,
      initialLayout: re
    });
  }, []), Se = C.useCallback(() => {
    x(null);
  }, []), W = C.useCallback((F) => {
    const {
      panelDataArray: ee
    } = O.current, ge = Uf(ee, F);
    ge >= 0 && (ee.splice(ge, 1), delete M.current[F.id], O.current.panelDataArrayChanged = !0, _());
  }, [_]), Z = C.useMemo(() => ({
    collapsePanel: L,
    direction: r,
    dragState: b,
    expandPanel: U,
    getPanelSize: B,
    getPanelStyle: G,
    groupId: m,
    isPanelCollapsed: Y,
    isPanelExpanded: he,
    reevaluatePanelConstraints: Q,
    registerPanel: ie,
    registerResizeHandle: ne,
    resizePanel: H,
    startDragging: X,
    stopDragging: Se,
    unregisterPanel: W,
    panelGroupElement: g.current
  }), [L, b, r, U, B, G, m, Y, he, Q, ie, ne, H, X, Se, W]), pe = {
    display: "flex",
    flexDirection: r === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return C.createElement(w1.Provider, {
    value: Z
  }, C.createElement(f, {
    ...h,
    children: t,
    className: n,
    id: o,
    ref: g,
    style: {
      ...pe,
      ...u
    },
    // CSS selectors
    [or.group]: "",
    [or.groupDirection]: r,
    [or.groupId]: m
  }));
}
const VG = C.forwardRef((e, t) => C.createElement(FG, {
  ...e,
  forwardedRef: t
}));
FG.displayName = "PanelGroup";
VG.displayName = "forwardRef(PanelGroup)";
function Uf(e, t) {
  return e.findIndex((n) => n === t || n.id === t.id);
}
function Ou(e, t, n) {
  const r = Uf(e, t), o = r === e.length - 1 ? [r - 1, r] : [r, r + 1], s = n[r];
  return {
    ...t.constraints,
    panelSize: s,
    pivotIndices: o
  };
}
function kLe({
  disabled: e,
  handleId: t,
  resizeHandler: n,
  panelGroupElement: r
}) {
  C.useEffect(() => {
    if (e || n == null || r == null)
      return;
    const i = E1(t, r);
    if (i == null)
      return;
    const o = (s) => {
      if (!s.defaultPrevented)
        switch (s.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            s.preventDefault(), n(s);
            break;
          }
          case "F6": {
            s.preventDefault();
            const a = i.getAttribute(or.groupId);
            zt(a, `No group element found for id "${a}"`);
            const c = $g(a, r), u = IG(a, t, r);
            zt(u !== null, `No resize element found for id "${t}"`);
            const f = s.shiftKey ? u > 0 ? u - 1 : c.length - 1 : u + 1 < c.length ? u + 1 : 0;
            c[f].focus();
            break;
          }
        }
    };
    return i.addEventListener("keydown", o), () => {
      i.removeEventListener("keydown", o);
    };
  }, [r, e, t, n]);
}
function HG({
  children: e = null,
  className: t = "",
  disabled: n = !1,
  hitAreaMargins: r,
  id: i,
  onBlur: o,
  onClick: s,
  onDragging: a,
  onFocus: c,
  onPointerDown: u,
  onPointerUp: f,
  style: h = {},
  tabIndex: m = 0,
  tagName: g = "div",
  ...b
}) {
  var x, w;
  const S = C.useRef(null), _ = C.useRef({
    onClick: s,
    onDragging: a,
    onPointerDown: u,
    onPointerUp: f
  });
  C.useEffect(() => {
    _.current.onClick = s, _.current.onDragging = a, _.current.onPointerDown = u, _.current.onPointerUp = f;
  });
  const M = C.useContext(w1);
  if (M === null)
    throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
  const {
    direction: N,
    groupId: D,
    registerResizeHandle: j,
    startDragging: O,
    stopDragging: L,
    panelGroupElement: U
  } = M, B = wR(i), [G, Y] = C.useState("inactive"), [he, ie] = C.useState(!1), [ne, H] = C.useState(null), Q = C.useRef({
    state: G
  });
  Qu(() => {
    Q.current.state = G;
  }), C.useEffect(() => {
    if (n)
      H(null);
    else {
      const Z = j(B);
      H(() => Z);
    }
  }, [n, B, j]);
  const X = (x = r?.coarse) !== null && x !== void 0 ? x : 15, Se = (w = r?.fine) !== null && w !== void 0 ? w : 5;
  C.useEffect(() => {
    if (n || ne == null)
      return;
    const Z = S.current;
    zt(Z, "Element ref not attached");
    let pe = !1;
    return aLe(B, Z, N, {
      coarse: X,
      fine: Se
    }, (ee, ge, re) => {
      if (!ge) {
        Y("inactive");
        return;
      }
      switch (ee) {
        case "down": {
          Y("drag"), pe = !1, zt(re, 'Expected event to be defined for "down" action'), O(B, re);
          const {
            onDragging: J,
            onPointerDown: xe
          } = _.current;
          J?.(!0), xe?.();
          break;
        }
        case "move": {
          const {
            state: J
          } = Q.current;
          pe = !0, J !== "drag" && Y("hover"), zt(re, 'Expected event to be defined for "move" action'), ne(re);
          break;
        }
        case "up": {
          Y("hover"), L();
          const {
            onClick: J,
            onDragging: xe,
            onPointerUp: be
          } = _.current;
          xe?.(!1), be?.(), pe || J?.();
          break;
        }
      }
    });
  }, [X, N, n, Se, j, B, ne, O, L]), kLe({
    disabled: n,
    handleId: B,
    resizeHandler: ne,
    panelGroupElement: U
  });
  const W = {
    touchAction: "none",
    userSelect: "none"
  };
  return C.createElement(g, {
    ...b,
    children: e,
    className: t,
    id: i,
    onBlur: () => {
      ie(!1), o?.();
    },
    onFocus: () => {
      ie(!0), c?.();
    },
    ref: S,
    role: "separator",
    style: {
      ...W,
      ...h
    },
    tabIndex: m,
    // CSS selectors
    [or.groupDirection]: N,
    [or.groupId]: D,
    [or.resizeHandle]: "",
    [or.resizeHandleActive]: G === "drag" ? "pointer" : he ? "keyboard" : void 0,
    [or.resizeHandleEnabled]: !n,
    [or.resizeHandleId]: B,
    [or.resizeHandleState]: G
  });
}
HG.displayName = "PanelResizeHandle";
function CLe({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    VG,
    {
      "data-slot": "resizable-panel-group",
      className: lt(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        e
      ),
      ...t
    }
  );
}
function R3({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(EG, { "data-slot": "resizable-panel", ...e });
}
function ELe({
  withHandle: e,
  className: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsx(
    HG,
    {
      "data-slot": "resizable-handle",
      className: lt(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:translate-x-0 data-[panel-group-direction=vertical]:after:-translate-y-1/2 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        t
      ),
      ...n,
      children: e && /* @__PURE__ */ v.jsx("div", { className: "bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border", children: /* @__PURE__ */ v.jsx(jY, { className: "size-2.5" }) })
    }
  );
}
async function _Le(e) {
  const { filesToSend: t, parts: n, messages: r, setMessages: i, sendMessage: o, metadata: s } = e;
  if (!t || t.length === 0) return;
  const a = t.map((b) => ({
    fileName: b.name,
    mimeType: b.type || "application/octet-stream",
    size: b.size,
    s3Key: "",
    url: void 0,
    status: "uploading"
  })), c = `temp-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`, u = {
    id: c,
    role: "user",
    parts: n,
    metadata: { ...s || {}, attachments: a }
  };
  let f = Array.isArray(r) ? [...r] : [];
  f.push(u);
  try {
    i(f);
  } catch {
  }
  const h = t.map(async (b, x) => {
    const w = await $ze(b);
    f = (f || []).map((S) => {
      if (S.id !== c) return S;
      const _ = Array.isArray(S.metadata?.attachments) ? [...S.metadata.attachments] : [];
      return _[x] = w, { ...S, metadata: { ...S.metadata, attachments: _ } };
    });
    try {
      i(f);
    } catch {
    }
    return w;
  }), m = await Promise.all(h), g = (f || []).filter((b) => b.id !== c);
  try {
    i(g);
  } catch {
  }
  try {
    await o({
      role: "user",
      parts: n,
      metadata: { ...s || {}, attachments: m }
    });
  } catch (b) {
    const x = {
      id: u.id,
      role: u.role,
      parts: u.parts,
      metadata: { ...u.metadata, attachments: m }
    };
    try {
      i([...g || [], x]);
    } catch {
    }
    console.error("sendMessage failed:", b);
  }
}
const TLe = ({
  onClose: e,
  threadId: t
}) => {
  const {
    chatbotStore: {
      allowedAppDefaultToolkit: n,
      toolChoice: r,
      isNewThread: i,
      currentThreadId: o,
      threadMessages: s,
      isLoadingThread: a,
      isAIThinking: c,
      storeThreads: u,
      useNextSuggestion: f,
      isStopStream: h
    },
    chatbotStore: m,
    chatbotServerStore: { allowedMcpServers: g },
    chatbotThreadStore: { threadMentions: b }
  } = la(), [x, w] = C.useState(""), [S, _] = C.useState([]), [M, N] = C.useState(!1), [D, j] = C.useState(!0), O = new URLSearchParams(window.location.search), L = O.get("project_id") || "unknown", U = O.get("version_id") || "unknown", B = async (gt) => {
    try {
      localStorage.setItem("ai-name", gt);
    } catch {
    }
  }, G = o.value || t, Y = !i.value && !ld(G), he = 10, {
    messages: ie,
    pagination: ne,
    loadMore: H
  } = rme(G, 50, Y), Q = C.useMemo(() => {
    const gt = s.value[G] || [];
    return gt.length > 0 ? gt : Y && ie.length > 0 ? ie : [];
  }, [s.value, G, Y, ie]), X = C.useMemo(
    () => Xpe(G),
    [G]
  );
  ime(f);
  const {
    saveMessages: Se
  } = ome({
    threadId: G,
    enabled: !0,
    maxInMemory: he
  }), {
    messages: W,
    status: Z,
    sendMessage: pe,
    setMessages: F,
    stop: ee,
    error: ge,
    regenerate: re,
    addToolOutput: J
    //IMPORTANT for manual tool approvals
  } = Dxe({
    id: G,
    sendAutomaticallyWhen: Axe,
    transport: new mV({
      api: `${fs}/ai-chat`,
      fetch: async (gt, ke) => {
        const De = await Vc();
        return fetch(gt, {
          ...ke,
          headers: {
            ...De,
            ...ke?.headers
          }
        });
      },
      prepareSendMessagesRequest: ({
        messages: gt,
        body: ke,
        id: De,
        trigger: He,
        messageId: tt
      }) => {
        const xt = xxe(gt), Et = Array.isArray(gt) && gt.length ? gt[gt.length - 1] : void 0;
        if (!Et)
          return { body: ke ?? {} };
        const hn = localStorage.getItem("ai-name") || R9, Bt = {
          provider: hn.startsWith("gpt") ? "openai" : "azure",
          model: hn
        };
        return { body: {
          id: o.value || De,
          chatModel: Bt,
          toolChoice: r.value || "auto",
          allowedAppDefaultToolkit: n.value,
          allowedMcpServers: g.value,
          mentions: b.value[G] || [],
          message: Et,
          // server expects single message
          messages: xt,
          // Add converted ModelMessages for backend
          trigger: He,
          // 'submit-message' | 'regenerate-message'
          messageId: tt,
          // ID of message to regenerate (for regenerate-message trigger)
          projectId: L,
          versionId: U,
          usingNextSuggestion: f.value
        } };
      }
    }),
    messages: Q,
    generateId: P9,
    experimental_throttle: 100,
    onFinish: (gt) => {
    },
    onToolCall: (gt) => {
    },
    onData: (gt) => {
    },
    onError: (gt) => {
      console.log(" onError:", gt), X.onError(gt);
    }
  }), xe = C.useCallback(
    async (gt) => {
      await J(gt);
    },
    [J]
  ), be = W, Ae = F, nt = C.useRef(G), Ge = C.useRef(be), rt = Z === "streaming" || Z === "submitted";
  c.value = rt;
  const Tt = C.useCallback(
    () => {
      ee(), h.value = !0;
    },
    [ee, be, Ae]
  );
  C.useEffect(() => {
    Q.length > 0 && be.length === 0 && Ae(Q);
  }, [G, Q, be.length, Ae]);
  const { scrollAreaRef: vn, containerRef: kt, topSentinelRef: Wt, scrollToBottom: wt } = Jpe(
    be.length > 0 ? be : Q,
    a.value,
    Y ? H : void 0,
    Y ? ne.hasMore : !1
  ), Yt = () => {
    if (ld(G)) {
      const gt = Wpe(G);
      o.value = gt, i.value = !0;
    }
  }, Mn = C.useCallback(
    async (gt, ke) => {
      const De = (gt ?? x ?? "").trim();
      if (!(!De || rt))
        try {
          c.value = !0, ke && ke.length > 0 && (b.value = {
            ...b.value,
            [G]: ke
          });
          const He = [...S];
          _([]), w(""), N(!1);
          const tt = De ? [{ type: "text", text: De }] : [{ type: "text", text: "" }];
          if (He.length > 0 ? await _Le({
            filesToSend: He,
            parts: tt,
            messages: be,
            setMessages: Ae,
            sendMessage: pe
          }) : await pe({
            role: "user",
            parts: tt,
            metadata: {
              mentions: ke
            }
          }), i.value && !rt) {
            const xt = await HM();
            try {
              xt.ok && (u.value = [...xt.threads]);
            } catch (Et) {
              console.error("Error fetching threads:", Et);
            }
          }
          rt || (c.value = !1), i.value = !1, setTimeout(() => wt(!0), 100);
        } catch (He) {
          c.value = !1, console.error("sendMessage error:", He);
        }
    },
    [
      x,
      S,
      rt,
      pe,
      wt,
      _,
      N,
      X
    ]
  ), Rt = C.useMemo(() => {
    const gt = (He) => He.filter((tt) => tt.role !== "system"), ke = gt(be), De = gt(Q || []);
    return ke.length > 0 ? ke : De;
  }, [be, Q]);
  C.useEffect(() => {
    const gt = he * 2, ke = (De, He) => {
      if (De.length <= He) return De;
      let tt = De.slice(-He);
      const xt = tt[0];
      if (xt && xt.role === "user" && xt.parts?.some((Bt) => Bt.type === "tool-result"))
        for (let Bt = De.length - He - 1; Bt >= 0; Bt--) {
          const on = De[Bt];
          if (on && on.role === "assistant" && on.parts?.some((Ve) => Ve.type === "tool-call")) {
            tt = De.slice(Bt);
            break;
          }
        }
      const Et = tt[tt.length - 1];
      if (Et && Et.role === "assistant") {
        const hn = Et.parts?.filter(
          (Bt) => Bt.type === "tool-call" && !Bt.result
        );
        if (hn && hn.length > 0)
          return De;
      }
      return tt;
    };
    if (be.length > gt) {
      const De = ke(be, he);
      De.length !== be.length && Ae(De);
    } else if (Z !== "streaming" && Z !== "submitted" && be.length > he) {
      const De = ke(be, he);
      De.length !== be.length && Ae(De);
    }
  }, [be, Z, Ae, he]), C.useEffect(() => {
    be !== Ge.current && (Ge.current = be, nt.current = G);
  }, [be, G]), C.useEffect(() => {
    if (nt.current === G && be.length > 0 && G) {
      const ke = s.value[G] || [], De = new Map(
        ke.map((Et) => [Et.id, Et.createdAt])
      );
      let He = be;
      if (be.length > 10) {
        He = be.slice(-10);
        const Et = He[0];
        if (Et && Et.role === "user" && Et.parts?.some((Bt) => Bt.type === "tool-result"))
          for (let Bt = be.indexOf(Et) - 1; Bt >= 0; Bt--) {
            const on = be[Bt];
            if (on && on.role === "assistant" && on.parts?.some((Ve) => Ve.type === "tool-call")) {
              He = be.slice(Bt);
              break;
            }
          }
      }
      const tt = He.map((Et) => ({
        id: Et.id,
        threadId: G,
        role: Et.role,
        parts: Et.parts,
        metadata: Et.metadata,
        createdAt: De.get(Et.id) || /* @__PURE__ */ new Date()
      })), xt = s.value;
      JSON.stringify(xt[G]) !== JSON.stringify(tt) && (s.value = {
        ...xt,
        [G]: tt
      }), Z !== "streaming" && Se(be).catch((Et) => {
        console.error("Failed to save messages to IndexedDB:", Et);
      });
    }
  }, [be, G, Z, s, Se]), C.useEffect(() => {
    be.length > 0 && wt(!0);
  }, [be.length, wt]), C.useEffect(() => () => {
    m.cleanup(), Ae([]), _([]), w("");
  }, [m]);
  const ln = () => {
    j(!D);
  }, { handleThreadSelect: In, handleNewThread: Nn } = Zpe({
    threadId: t,
    setMessages: Ae,
    stop: Tt,
    setHideError: N
  });
  return /* @__PURE__ */ v.jsxs("div", { className: "relative h-full w-full flex flex-col overflow-hidden", children: [
    /* @__PURE__ */ v.jsx(
      Ipe,
      {
        onClose: e,
        setApiKeyByName: B,
        onToggleSidebar: ln,
        isSidebarOpen: D
      }
    ),
    /* @__PURE__ */ v.jsxs(CLe, { direction: "horizontal", className: "flex-1 min-h-0", children: [
      /* @__PURE__ */ v.jsx(
        R3,
        {
          defaultSize: 25,
          minSize: 21,
          maxSize: 26,
          collapsible: !0,
          collapsedSize: 0,
          className: D ? "z-1000 overflow-auto-y" : "hidden",
          children: /* @__PURE__ */ v.jsx(
            Kpe,
            {
              isOpen: D,
              onThreadSelect: In,
              onNewThread: Nn
            }
          )
        }
      ),
      D && /* @__PURE__ */ v.jsx(ELe, { withHandle: !0 }),
      /* @__PURE__ */ v.jsx(R3, { defaultSize: 80, minSize: 50, children: /* @__PURE__ */ v.jsxs("div", { className: "h-full flex flex-col gap-2 overflow-y-auto overflow-hidden", children: [
        a.value ? /* @__PURE__ */ v.jsx($F, { message: "Loading thread..." }) : /* @__PURE__ */ v.jsxs(C.Fragment, { children: [
          /* @__PURE__ */ v.jsx(
            "div",
            {
              ref: kt,
              className: "flex-1 overflow-hidden",
              "data-chatbot-text": "data-chatbot",
              tabIndex: 0,
              children: /* @__PURE__ */ v.jsx(
                yA,
                {
                  ref: vn,
                  className: "h-full pr-2 chat-scroll-area",
                  children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-3 py-2 min-h-full justify-end overflow-x-auto wrap-break-word", children: [
                    Y && ne.hasMore && /* @__PURE__ */ v.jsx(
                      "div",
                      {
                        ref: Wt,
                        className: "h-4 flex items-center justify-center",
                        children: ne.isLoadingMore && /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Loading..." })
                      }
                    ),
                    /* @__PURE__ */ v.jsx(ZA, { initial: !1, children: Rt.map((gt, ke) => {
                      const De = Rt[ke - 1] ?? gt;
                      return /* @__PURE__ */ v.jsx(
                        iNe,
                        {
                          threadId: t,
                          messageIndex: ke,
                          message: gt,
                          prevMessage: De,
                          isLoading: rt,
                          isLastMessage: ke === Rt.length - 1,
                          status: Z,
                          setMessages: Ae,
                          sendMessage: pe,
                          regenerate: re,
                          addToolResult: xe,
                          onReuseMessage: (He) => Zze(He, w)
                        },
                        gt.id
                      );
                    }) }),
                    Rt.length > 0 && (Z === "streaming" || Z === "submitted") && /* @__PURE__ */ v.jsx(S3, {}),
                    !M && ge && /* @__PURE__ */ v.jsx(Kze, { error: ge }),
                    /* @__PURE__ */ v.jsx("div", { className: "min-w-0 min-h-52" })
                  ] })
                }
              )
            }
          ),
          Rt.length !== 0 && /* @__PURE__ */ v.jsx(
            w3,
            {
              value: x,
              onChange: w,
              onSend: Mn,
              onFilesChange: _,
              files: S,
              mcpServers: [],
              opStop: Tt,
              onToggleMcpServer: () => {
              },
              onStartTyping: Yt,
              onUseNextSuggestionChange: (gt) => {
                f.value = gt;
              }
            }
          )
        ] }),
        Rt.length === 0 && /* @__PURE__ */ v.jsxs(C.Fragment, { children: [
          /* @__PURE__ */ v.jsx(lNe, {}),
          (Z === "streaming" || Z === "submitted") && /* @__PURE__ */ v.jsx("div", { className: "flex justify-center py-4", children: /* @__PURE__ */ v.jsx(S3, {}) }),
          /* @__PURE__ */ v.jsx(
            w3,
            {
              value: x,
              onChange: w,
              onSend: Mn,
              onFilesChange: _,
              files: S,
              mcpServers: [],
              onToggleMcpServer: () => {
              },
              opStop: Tt,
              onStartTyping: Yt,
              onUseNextSuggestionChange: (gt) => {
                f.value = gt;
              }
            }
          )
        ] })
      ] }) })
    ] })
  ] });
};
var gm = { exports: {} }, jE = {}, zE = { exports: {} }, LE, O3;
function ALe() {
  if (O3) return LE;
  O3 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return LE = e, LE;
}
var BE, P3;
function MLe() {
  if (P3) return BE;
  P3 = 1;
  var e = /* @__PURE__ */ ALe();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, BE = function() {
    function r(s, a, c, u, f, h) {
      if (h !== e) {
        var m = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw m.name = "Invariant Violation", m;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var o = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, BE;
}
var D3;
function WG() {
  return D3 || (D3 = 1, zE.exports = /* @__PURE__ */ MLe()()), zE.exports;
}
function qG(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (n = qG(e[t])) && (r && (r += " "), r += n);
  else for (t in e) e[t] && (r && (r += " "), r += t);
  return r;
}
function I3() {
  for (var e, t, n = 0, r = ""; n < arguments.length; ) (e = arguments[n++]) && (t = qG(e)) && (r && (r += " "), r += t);
  return r;
}
const NLe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: I3,
  default: I3
}, Symbol.toStringTag, { value: "Module" })), RLe = /* @__PURE__ */ wZ(NLe);
var fr = {}, Yl = {}, j3;
function _1() {
  if (j3) return Yl;
  j3 = 1, Object.defineProperty(Yl, "__esModule", {
    value: !0
  }), Yl.dontSetMe = i, Yl.findInArray = e, Yl.int = r, Yl.isFunction = t, Yl.isNum = n;
  function e(o, s) {
    for (let a = 0, c = o.length; a < c; a++)
      if (s.apply(s, [o[a], a, o])) return o[a];
  }
  function t(o) {
    return typeof o == "function" || Object.prototype.toString.call(o) === "[object Function]";
  }
  function n(o) {
    return typeof o == "number" && !isNaN(o);
  }
  function r(o) {
    return parseInt(o, 10);
  }
  function i(o, s, a) {
    if (o[s])
      return new Error("Invalid prop ".concat(s, " passed to ").concat(a, " - do not set this, set it on the child."));
  }
  return Yl;
}
var Xl = {}, z3;
function OLe() {
  if (z3) return Xl;
  z3 = 1, Object.defineProperty(Xl, "__esModule", {
    value: !0
  }), Xl.browserPrefixToKey = n, Xl.browserPrefixToStyle = r, Xl.default = void 0, Xl.getPrefix = t;
  const e = ["Moz", "Webkit", "O", "ms"];
  function t() {
    var o;
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
    if (typeof window > "u") return "";
    const a = (o = window.document) === null || o === void 0 || (o = o.documentElement) === null || o === void 0 ? void 0 : o.style;
    if (!a || s in a) return "";
    for (let c = 0; c < e.length; c++)
      if (n(s, e[c]) in a) return e[c];
    return "";
  }
  function n(o, s) {
    return s ? "".concat(s).concat(i(o)) : o;
  }
  function r(o, s) {
    return s ? "-".concat(s.toLowerCase(), "-").concat(o) : o;
  }
  function i(o) {
    let s = "", a = !0;
    for (let c = 0; c < o.length; c++)
      a ? (s += o[c].toUpperCase(), a = !1) : o[c] === "-" ? a = !0 : s += o[c];
    return s;
  }
  return Xl.default = t(), Xl;
}
var L3;
function kR() {
  if (L3) return fr;
  L3 = 1, Object.defineProperty(fr, "__esModule", {
    value: !0
  }), fr.addClassName = D, fr.addEvent = a, fr.addUserSelectStyles = M, fr.createCSSTransform = b, fr.createSVGTransform = x, fr.getTouch = S, fr.getTouchIdentifier = _, fr.getTranslation = w, fr.innerHeight = h, fr.innerWidth = m, fr.matchesSelector = o, fr.matchesSelectorAndParentsTo = s, fr.offsetXYFromParent = g, fr.outerHeight = u, fr.outerWidth = f, fr.removeClassName = j, fr.removeEvent = c, fr.removeUserSelectStyles = N;
  var e = _1(), t = r(OLe());
  function n(O) {
    if (typeof WeakMap != "function") return null;
    var L = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap();
    return (n = function(B) {
      return B ? U : L;
    })(O);
  }
  function r(O, L) {
    if (O && O.__esModule)
      return O;
    if (O === null || typeof O != "object" && typeof O != "function")
      return { default: O };
    var U = n(L);
    if (U && U.has(O))
      return U.get(O);
    var B = {}, G = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var Y in O)
      if (Y !== "default" && Object.prototype.hasOwnProperty.call(O, Y)) {
        var he = G ? Object.getOwnPropertyDescriptor(O, Y) : null;
        he && (he.get || he.set) ? Object.defineProperty(B, Y, he) : B[Y] = O[Y];
      }
    return B.default = O, U && U.set(O, B), B;
  }
  let i = "";
  function o(O, L) {
    return i || (i = (0, e.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(U) {
      return (0, e.isFunction)(O[U]);
    })), (0, e.isFunction)(O[i]) ? O[i](L) : !1;
  }
  function s(O, L, U) {
    let B = O;
    do {
      if (o(B, L)) return !0;
      if (B === U) return !1;
      B = B.parentNode;
    } while (B);
    return !1;
  }
  function a(O, L, U, B) {
    if (!O) return;
    const G = {
      capture: !0,
      ...B
    };
    O.addEventListener ? O.addEventListener(L, U, G) : O.attachEvent ? O.attachEvent("on" + L, U) : O["on" + L] = U;
  }
  function c(O, L, U, B) {
    if (!O) return;
    const G = {
      capture: !0,
      ...B
    };
    O.removeEventListener ? O.removeEventListener(L, U, G) : O.detachEvent ? O.detachEvent("on" + L, U) : O["on" + L] = null;
  }
  function u(O) {
    let L = O.clientHeight;
    const U = O.ownerDocument.defaultView.getComputedStyle(O);
    return L += (0, e.int)(U.borderTopWidth), L += (0, e.int)(U.borderBottomWidth), L;
  }
  function f(O) {
    let L = O.clientWidth;
    const U = O.ownerDocument.defaultView.getComputedStyle(O);
    return L += (0, e.int)(U.borderLeftWidth), L += (0, e.int)(U.borderRightWidth), L;
  }
  function h(O) {
    let L = O.clientHeight;
    const U = O.ownerDocument.defaultView.getComputedStyle(O);
    return L -= (0, e.int)(U.paddingTop), L -= (0, e.int)(U.paddingBottom), L;
  }
  function m(O) {
    let L = O.clientWidth;
    const U = O.ownerDocument.defaultView.getComputedStyle(O);
    return L -= (0, e.int)(U.paddingLeft), L -= (0, e.int)(U.paddingRight), L;
  }
  function g(O, L, U) {
    const G = L === L.ownerDocument.body ? {
      left: 0,
      top: 0
    } : L.getBoundingClientRect(), Y = (O.clientX + L.scrollLeft - G.left) / U, he = (O.clientY + L.scrollTop - G.top) / U;
    return {
      x: Y,
      y: he
    };
  }
  function b(O, L) {
    const U = w(O, L, "px");
    return {
      [(0, t.browserPrefixToKey)("transform", t.default)]: U
    };
  }
  function x(O, L) {
    return w(O, L, "");
  }
  function w(O, L, U) {
    let {
      x: B,
      y: G
    } = O, Y = "translate(".concat(B).concat(U, ",").concat(G).concat(U, ")");
    if (L) {
      const he = "".concat(typeof L.x == "string" ? L.x : L.x + U), ie = "".concat(typeof L.y == "string" ? L.y : L.y + U);
      Y = "translate(".concat(he, ", ").concat(ie, ")") + Y;
    }
    return Y;
  }
  function S(O, L) {
    return O.targetTouches && (0, e.findInArray)(O.targetTouches, (U) => L === U.identifier) || O.changedTouches && (0, e.findInArray)(O.changedTouches, (U) => L === U.identifier);
  }
  function _(O) {
    if (O.targetTouches && O.targetTouches[0]) return O.targetTouches[0].identifier;
    if (O.changedTouches && O.changedTouches[0]) return O.changedTouches[0].identifier;
  }
  function M(O) {
    if (!O) return;
    let L = O.getElementById("react-draggable-style-el");
    L || (L = O.createElement("style"), L.type = "text/css", L.id = "react-draggable-style-el", L.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, L.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, O.getElementsByTagName("head")[0].appendChild(L)), O.body && D(O.body, "react-draggable-transparent-selection");
  }
  function N(O) {
    if (O)
      try {
        if (O.body && j(O.body, "react-draggable-transparent-selection"), O.selection)
          O.selection.empty();
        else {
          const L = (O.defaultView || window).getSelection();
          L && L.type !== "Caret" && L.removeAllRanges();
        }
      } catch {
      }
  }
  function D(O, L) {
    O.classList ? O.classList.add(L) : O.className.match(new RegExp("(?:^|\\s)".concat(L, "(?!\\S)"))) || (O.className += " ".concat(L));
  }
  function j(O, L) {
    O.classList ? O.classList.remove(L) : O.className = O.className.replace(new RegExp("(?:^|\\s)".concat(L, "(?!\\S)"), "g"), "");
  }
  return fr;
}
var js = {}, B3;
function GG() {
  if (B3) return js;
  B3 = 1, Object.defineProperty(js, "__esModule", {
    value: !0
  }), js.canDragX = i, js.canDragY = o, js.createCoreData = a, js.createDraggableData = c, js.getBoundPosition = n, js.getControlPosition = s, js.snapToGrid = r;
  var e = _1(), t = kR();
  function n(h, m, g) {
    if (!h.props.bounds) return [m, g];
    let {
      bounds: b
    } = h.props;
    b = typeof b == "string" ? b : u(b);
    const x = f(h);
    if (typeof b == "string") {
      const {
        ownerDocument: w
      } = x, S = w.defaultView;
      let _;
      if (b === "parent" ? _ = x.parentNode : _ = w.querySelector(b), !(_ instanceof S.HTMLElement))
        throw new Error('Bounds selector "' + b + '" could not find an element.');
      const M = _, N = S.getComputedStyle(x), D = S.getComputedStyle(M);
      b = {
        left: -x.offsetLeft + (0, e.int)(D.paddingLeft) + (0, e.int)(N.marginLeft),
        top: -x.offsetTop + (0, e.int)(D.paddingTop) + (0, e.int)(N.marginTop),
        right: (0, t.innerWidth)(M) - (0, t.outerWidth)(x) - x.offsetLeft + (0, e.int)(D.paddingRight) - (0, e.int)(N.marginRight),
        bottom: (0, t.innerHeight)(M) - (0, t.outerHeight)(x) - x.offsetTop + (0, e.int)(D.paddingBottom) - (0, e.int)(N.marginBottom)
      };
    }
    return (0, e.isNum)(b.right) && (m = Math.min(m, b.right)), (0, e.isNum)(b.bottom) && (g = Math.min(g, b.bottom)), (0, e.isNum)(b.left) && (m = Math.max(m, b.left)), (0, e.isNum)(b.top) && (g = Math.max(g, b.top)), [m, g];
  }
  function r(h, m, g) {
    const b = Math.round(m / h[0]) * h[0], x = Math.round(g / h[1]) * h[1];
    return [b, x];
  }
  function i(h) {
    return h.props.axis === "both" || h.props.axis === "x";
  }
  function o(h) {
    return h.props.axis === "both" || h.props.axis === "y";
  }
  function s(h, m, g) {
    const b = typeof m == "number" ? (0, t.getTouch)(h, m) : null;
    if (typeof m == "number" && !b) return null;
    const x = f(g), w = g.props.offsetParent || x.offsetParent || x.ownerDocument.body;
    return (0, t.offsetXYFromParent)(b || h, w, g.props.scale);
  }
  function a(h, m, g) {
    const b = !(0, e.isNum)(h.lastX), x = f(h);
    return b ? {
      node: x,
      deltaX: 0,
      deltaY: 0,
      lastX: m,
      lastY: g,
      x: m,
      y: g
    } : {
      node: x,
      deltaX: m - h.lastX,
      deltaY: g - h.lastY,
      lastX: h.lastX,
      lastY: h.lastY,
      x: m,
      y: g
    };
  }
  function c(h, m) {
    const g = h.props.scale;
    return {
      node: m.node,
      x: h.state.x + m.deltaX / g,
      y: h.state.y + m.deltaY / g,
      deltaX: m.deltaX / g,
      deltaY: m.deltaY / g,
      lastX: h.state.x,
      lastY: h.state.y
    };
  }
  function u(h) {
    return {
      left: h.left,
      top: h.top,
      right: h.right,
      bottom: h.bottom
    };
  }
  function f(h) {
    const m = h.findDOMNode();
    if (!m)
      throw new Error("<DraggableCore>: Unmounted during event!");
    return m;
  }
  return js;
}
var ym = {}, C0 = {}, $3;
function KG() {
  if ($3) return C0;
  $3 = 1, Object.defineProperty(C0, "__esModule", {
    value: !0
  }), C0.default = e;
  function e() {
  }
  return C0;
}
var U3;
function PLe() {
  if (U3) return ym;
  U3 = 1, Object.defineProperty(ym, "__esModule", {
    value: !0
  }), ym.default = void 0;
  var e = u(gd()), t = a(/* @__PURE__ */ WG()), n = a(rw()), r = kR(), i = GG(), o = _1(), s = a(KG());
  function a(w) {
    return w && w.__esModule ? w : { default: w };
  }
  function c(w) {
    if (typeof WeakMap != "function") return null;
    var S = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap();
    return (c = function(M) {
      return M ? _ : S;
    })(w);
  }
  function u(w, S) {
    if (w && w.__esModule)
      return w;
    if (w === null || typeof w != "object" && typeof w != "function")
      return { default: w };
    var _ = c(S);
    if (_ && _.has(w))
      return _.get(w);
    var M = {}, N = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var D in w)
      if (D !== "default" && Object.prototype.hasOwnProperty.call(w, D)) {
        var j = N ? Object.getOwnPropertyDescriptor(w, D) : null;
        j && (j.get || j.set) ? Object.defineProperty(M, D, j) : M[D] = w[D];
      }
    return M.default = w, _ && _.set(w, M), M;
  }
  function f(w, S, _) {
    return S = h(S), S in w ? Object.defineProperty(w, S, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : w[S] = _, w;
  }
  function h(w) {
    var S = m(w, "string");
    return typeof S == "symbol" ? S : String(S);
  }
  function m(w, S) {
    if (typeof w != "object" || w === null) return w;
    var _ = w[Symbol.toPrimitive];
    if (_ !== void 0) {
      var M = _.call(w, S);
      if (typeof M != "object") return M;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (S === "string" ? String : Number)(w);
  }
  const g = {
    touch: {
      start: "touchstart",
      move: "touchmove",
      stop: "touchend"
    },
    mouse: {
      start: "mousedown",
      move: "mousemove",
      stop: "mouseup"
    }
  };
  let b = g.mouse, x = class extends e.Component {
    constructor() {
      super(...arguments), f(this, "dragging", !1), f(this, "lastX", NaN), f(this, "lastY", NaN), f(this, "touchIdentifier", null), f(this, "mounted", !1), f(this, "handleDragStart", (S) => {
        if (this.props.onMouseDown(S), !this.props.allowAnyClick && typeof S.button == "number" && S.button !== 0) return !1;
        const _ = this.findDOMNode();
        if (!_ || !_.ownerDocument || !_.ownerDocument.body)
          throw new Error("<DraggableCore> not mounted on DragStart!");
        const {
          ownerDocument: M
        } = _;
        if (this.props.disabled || !(S.target instanceof M.defaultView.Node) || this.props.handle && !(0, r.matchesSelectorAndParentsTo)(S.target, this.props.handle, _) || this.props.cancel && (0, r.matchesSelectorAndParentsTo)(S.target, this.props.cancel, _))
          return;
        S.type === "touchstart" && S.preventDefault();
        const N = (0, r.getTouchIdentifier)(S);
        this.touchIdentifier = N;
        const D = (0, i.getControlPosition)(S, N, this);
        if (D == null) return;
        const {
          x: j,
          y: O
        } = D, L = (0, i.createCoreData)(this, j, O);
        (0, s.default)("DraggableCore: handleDragStart: %j", L), (0, s.default)("calling", this.props.onStart), !(this.props.onStart(S, L) === !1 || this.mounted === !1) && (this.props.enableUserSelectHack && (0, r.addUserSelectStyles)(M), this.dragging = !0, this.lastX = j, this.lastY = O, (0, r.addEvent)(M, b.move, this.handleDrag), (0, r.addEvent)(M, b.stop, this.handleDragStop));
      }), f(this, "handleDrag", (S) => {
        const _ = (0, i.getControlPosition)(S, this.touchIdentifier, this);
        if (_ == null) return;
        let {
          x: M,
          y: N
        } = _;
        if (Array.isArray(this.props.grid)) {
          let O = M - this.lastX, L = N - this.lastY;
          if ([O, L] = (0, i.snapToGrid)(this.props.grid, O, L), !O && !L) return;
          M = this.lastX + O, N = this.lastY + L;
        }
        const D = (0, i.createCoreData)(this, M, N);
        if ((0, s.default)("DraggableCore: handleDrag: %j", D), this.props.onDrag(S, D) === !1 || this.mounted === !1) {
          try {
            this.handleDragStop(new MouseEvent("mouseup"));
          } catch {
            const L = document.createEvent("MouseEvents");
            L.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), this.handleDragStop(L);
          }
          return;
        }
        this.lastX = M, this.lastY = N;
      }), f(this, "handleDragStop", (S) => {
        if (!this.dragging) return;
        const _ = (0, i.getControlPosition)(S, this.touchIdentifier, this);
        if (_ == null) return;
        let {
          x: M,
          y: N
        } = _;
        if (Array.isArray(this.props.grid)) {
          let L = M - this.lastX || 0, U = N - this.lastY || 0;
          [L, U] = (0, i.snapToGrid)(this.props.grid, L, U), M = this.lastX + L, N = this.lastY + U;
        }
        const D = (0, i.createCoreData)(this, M, N);
        if (this.props.onStop(S, D) === !1 || this.mounted === !1) return !1;
        const O = this.findDOMNode();
        O && this.props.enableUserSelectHack && (0, r.removeUserSelectStyles)(O.ownerDocument), (0, s.default)("DraggableCore: handleDragStop: %j", D), this.dragging = !1, this.lastX = NaN, this.lastY = NaN, O && ((0, s.default)("DraggableCore: Removing handlers"), (0, r.removeEvent)(O.ownerDocument, b.move, this.handleDrag), (0, r.removeEvent)(O.ownerDocument, b.stop, this.handleDragStop));
      }), f(this, "onMouseDown", (S) => (b = g.mouse, this.handleDragStart(S))), f(this, "onMouseUp", (S) => (b = g.mouse, this.handleDragStop(S))), f(this, "onTouchStart", (S) => (b = g.touch, this.handleDragStart(S))), f(this, "onTouchEnd", (S) => (b = g.touch, this.handleDragStop(S)));
    }
    componentDidMount() {
      this.mounted = !0;
      const S = this.findDOMNode();
      S && (0, r.addEvent)(S, g.touch.start, this.onTouchStart, {
        passive: !1
      });
    }
    componentWillUnmount() {
      this.mounted = !1;
      const S = this.findDOMNode();
      if (S) {
        const {
          ownerDocument: _
        } = S;
        (0, r.removeEvent)(_, g.mouse.move, this.handleDrag), (0, r.removeEvent)(_, g.touch.move, this.handleDrag), (0, r.removeEvent)(_, g.mouse.stop, this.handleDragStop), (0, r.removeEvent)(_, g.touch.stop, this.handleDragStop), (0, r.removeEvent)(S, g.touch.start, this.onTouchStart, {
          passive: !1
        }), this.props.enableUserSelectHack && (0, r.removeUserSelectStyles)(_);
      }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() {
      var S, _;
      return (S = this.props) !== null && S !== void 0 && S.nodeRef ? (_ = this.props) === null || _ === void 0 || (_ = _.nodeRef) === null || _ === void 0 ? void 0 : _.current : n.default.findDOMNode(this);
    }
    render() {
      return /* @__PURE__ */ e.cloneElement(e.Children.only(this.props.children), {
        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        // onTouchStart is added on `componentDidMount` so they can be added with
        // {passive: false}, which allows it to cancel. See
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        onTouchEnd: this.onTouchEnd
      });
    }
  };
  return ym.default = x, f(x, "displayName", "DraggableCore"), f(x, "propTypes", {
    /**
     * `allowAnyClick` allows dragging using any mouse button.
     * By default, we only accept the left button.
     *
     * Defaults to `false`.
     */
    allowAnyClick: t.default.bool,
    children: t.default.node.isRequired,
    /**
     * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
     * with the exception of `onMouseDown`, will not fire.
     */
    disabled: t.default.bool,
    /**
     * By default, we add 'user-select:none' attributes to the document body
     * to prevent ugly text selection during drag. If this is causing problems
     * for your app, set this to `false`.
     */
    enableUserSelectHack: t.default.bool,
    /**
     * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
     * instead of using the parent node.
     */
    offsetParent: function(w, S) {
      if (w[S] && w[S].nodeType !== 1)
        throw new Error("Draggable's offsetParent must be a DOM Node.");
    },
    /**
     * `grid` specifies the x and y that dragging should snap to.
     */
    grid: t.default.arrayOf(t.default.number),
    /**
     * `handle` specifies a selector to be used as the handle that initiates drag.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable handle=".handle">
     *              <div>
     *                  <div className="handle">Click me to drag</div>
     *                  <div>This is some other content</div>
     *              </div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    handle: t.default.string,
    /**
     * `cancel` specifies a selector to be used to prevent drag initialization.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *           return(
     *               <Draggable cancel=".cancel">
     *                   <div>
     *                     <div className="cancel">You can't drag from here</div>
     *                     <div>Dragging here works fine</div>
     *                   </div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    cancel: t.default.string,
    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
     * Unfortunately, in order for <Draggable> to work properly, we need raw access
     * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
     * as in this example:
     *
     * function MyComponent() {
     *   const nodeRef = React.useRef(null);
     *   return (
     *     <Draggable nodeRef={nodeRef}>
     *       <div ref={nodeRef}>Example Target</div>
     *     </Draggable>
     *   );
     * }
     *
     * This can be used for arbitrarily nested components, so long as the ref ends up
     * pointing to the actual child DOM node and not a custom component.
     */
    nodeRef: t.default.object,
    /**
     * Called when dragging starts.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onStart: t.default.func,
    /**
     * Called while dragging.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onDrag: t.default.func,
    /**
     * Called when dragging stops.
     * If this function returns the boolean false, the drag will remain active.
     */
    onStop: t.default.func,
    /**
     * A workaround option which can be passed if onMouseDown needs to be accessed,
     * since it'll always be blocked (as there is internal use of onMouseDown)
     */
    onMouseDown: t.default.func,
    /**
     * `scale`, if set, applies scaling while dragging an element
     */
    scale: t.default.number,
    /**
     * These properties should be defined on the child, not here.
     */
    className: o.dontSetMe,
    style: o.dontSetMe,
    transform: o.dontSetMe
  }), f(x, "defaultProps", {
    allowAnyClick: !1,
    // by default only accept left click
    disabled: !1,
    enableUserSelectHack: !0,
    onStart: function() {
    },
    onDrag: function() {
    },
    onStop: function() {
    },
    onMouseDown: function() {
    },
    scale: 1
  }), ym;
}
var F3;
function DLe() {
  return F3 || (F3 = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "DraggableCore", {
      enumerable: !0,
      get: function() {
        return c.default;
      }
    }), e.default = void 0;
    var t = m(gd()), n = f(/* @__PURE__ */ WG()), r = f(rw()), i = f(RLe), o = kR(), s = GG(), a = _1(), c = f(PLe()), u = f(KG());
    function f(_) {
      return _ && _.__esModule ? _ : { default: _ };
    }
    function h(_) {
      if (typeof WeakMap != "function") return null;
      var M = /* @__PURE__ */ new WeakMap(), N = /* @__PURE__ */ new WeakMap();
      return (h = function(D) {
        return D ? N : M;
      })(_);
    }
    function m(_, M) {
      if (_ && _.__esModule)
        return _;
      if (_ === null || typeof _ != "object" && typeof _ != "function")
        return { default: _ };
      var N = h(M);
      if (N && N.has(_))
        return N.get(_);
      var D = {}, j = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var O in _)
        if (O !== "default" && Object.prototype.hasOwnProperty.call(_, O)) {
          var L = j ? Object.getOwnPropertyDescriptor(_, O) : null;
          L && (L.get || L.set) ? Object.defineProperty(D, O, L) : D[O] = _[O];
        }
      return D.default = _, N && N.set(_, D), D;
    }
    function g() {
      return g = Object.assign ? Object.assign.bind() : function(_) {
        for (var M = 1; M < arguments.length; M++) {
          var N = arguments[M];
          for (var D in N)
            Object.prototype.hasOwnProperty.call(N, D) && (_[D] = N[D]);
        }
        return _;
      }, g.apply(this, arguments);
    }
    function b(_, M, N) {
      return M = x(M), M in _ ? Object.defineProperty(_, M, { value: N, enumerable: !0, configurable: !0, writable: !0 }) : _[M] = N, _;
    }
    function x(_) {
      var M = w(_, "string");
      return typeof M == "symbol" ? M : String(M);
    }
    function w(_, M) {
      if (typeof _ != "object" || _ === null) return _;
      var N = _[Symbol.toPrimitive];
      if (N !== void 0) {
        var D = N.call(_, M);
        if (typeof D != "object") return D;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (M === "string" ? String : Number)(_);
    }
    class S extends t.Component {
      // React 16.3+
      // Arity (props, state)
      static getDerivedStateFromProps(M, N) {
        let {
          position: D
        } = M, {
          prevPropsPosition: j
        } = N;
        return D && (!j || D.x !== j.x || D.y !== j.y) ? ((0, u.default)("Draggable: getDerivedStateFromProps %j", {
          position: D,
          prevPropsPosition: j
        }), {
          x: D.x,
          y: D.y,
          prevPropsPosition: {
            ...D
          }
        }) : null;
      }
      constructor(M) {
        super(M), b(this, "onDragStart", (N, D) => {
          if ((0, u.default)("Draggable: onDragStart: %j", D), this.props.onStart(N, (0, s.createDraggableData)(this, D)) === !1) return !1;
          this.setState({
            dragging: !0,
            dragged: !0
          });
        }), b(this, "onDrag", (N, D) => {
          if (!this.state.dragging) return !1;
          (0, u.default)("Draggable: onDrag: %j", D);
          const j = (0, s.createDraggableData)(this, D), O = {
            x: j.x,
            y: j.y,
            slackX: 0,
            slackY: 0
          };
          if (this.props.bounds) {
            const {
              x: U,
              y: B
            } = O;
            O.x += this.state.slackX, O.y += this.state.slackY;
            const [G, Y] = (0, s.getBoundPosition)(this, O.x, O.y);
            O.x = G, O.y = Y, O.slackX = this.state.slackX + (U - O.x), O.slackY = this.state.slackY + (B - O.y), j.x = O.x, j.y = O.y, j.deltaX = O.x - this.state.x, j.deltaY = O.y - this.state.y;
          }
          if (this.props.onDrag(N, j) === !1) return !1;
          this.setState(O);
        }), b(this, "onDragStop", (N, D) => {
          if (!this.state.dragging || this.props.onStop(N, (0, s.createDraggableData)(this, D)) === !1) return !1;
          (0, u.default)("Draggable: onDragStop: %j", D);
          const O = {
            dragging: !1,
            slackX: 0,
            slackY: 0
          };
          if (!!this.props.position) {
            const {
              x: U,
              y: B
            } = this.props.position;
            O.x = U, O.y = B;
          }
          this.setState(O);
        }), this.state = {
          // Whether or not we are currently dragging.
          dragging: !1,
          // Whether or not we have been dragged before.
          dragged: !1,
          // Current transform x and y.
          x: M.position ? M.position.x : M.defaultPosition.x,
          y: M.position ? M.position.y : M.defaultPosition.y,
          prevPropsPosition: {
            ...M.position
          },
          // Used for compensating for out-of-bounds drags
          slackX: 0,
          slackY: 0,
          // Can only determine if SVG after mounting
          isElementSVG: !1
        }, M.position && !(M.onDrag || M.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
      }
      componentDidMount() {
        typeof window.SVGElement < "u" && this.findDOMNode() instanceof window.SVGElement && this.setState({
          isElementSVG: !0
        });
      }
      componentWillUnmount() {
        this.setState({
          dragging: !1
        });
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        var M, N;
        return (M = (N = this.props) === null || N === void 0 || (N = N.nodeRef) === null || N === void 0 ? void 0 : N.current) !== null && M !== void 0 ? M : r.default.findDOMNode(this);
      }
      render() {
        const {
          axis: M,
          bounds: N,
          children: D,
          defaultPosition: j,
          defaultClassName: O,
          defaultClassNameDragging: L,
          defaultClassNameDragged: U,
          position: B,
          positionOffset: G,
          scale: Y,
          ...he
        } = this.props;
        let ie = {}, ne = null;
        const Q = !!!B || this.state.dragging, X = B || j, Se = {
          // Set left if horizontal drag is enabled
          x: (0, s.canDragX)(this) && Q ? this.state.x : X.x,
          // Set top if vertical drag is enabled
          y: (0, s.canDragY)(this) && Q ? this.state.y : X.y
        };
        this.state.isElementSVG ? ne = (0, o.createSVGTransform)(Se, G) : ie = (0, o.createCSSTransform)(Se, G);
        const W = (0, i.default)(D.props.className || "", O, {
          [L]: this.state.dragging,
          [U]: this.state.dragged
        });
        return /* @__PURE__ */ t.createElement(c.default, g({}, he, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), /* @__PURE__ */ t.cloneElement(t.Children.only(D), {
          className: W,
          style: {
            ...D.props.style,
            ...ie
          },
          transform: ne
        }));
      }
    }
    e.default = S, b(S, "displayName", "Draggable"), b(S, "propTypes", {
      // Accepts all props <DraggableCore> accepts.
      ...c.default.propTypes,
      /**
       * `axis` determines which axis the draggable can move.
       *
       *  Note that all callbacks will still return data as normal. This only
       *  controls flushing to the DOM.
       *
       * 'both' allows movement horizontally and vertically.
       * 'x' limits movement to horizontal axis.
       * 'y' limits movement to vertical axis.
       * 'none' limits all movement.
       *
       * Defaults to 'both'.
       */
      axis: n.default.oneOf(["both", "x", "y", "none"]),
      /**
       * `bounds` determines the range of movement available to the element.
       * Available values are:
       *
       * 'parent' restricts movement within the Draggable's parent node.
       *
       * Alternatively, pass an object with the following properties, all of which are optional:
       *
       * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
       *
       * All values are in px.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable bounds={{right: 300, bottom: 300}}>
       *              <div>Content</div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      bounds: n.default.oneOfType([n.default.shape({
        left: n.default.number,
        right: n.default.number,
        top: n.default.number,
        bottom: n.default.number
      }), n.default.string, n.default.oneOf([!1])]),
      defaultClassName: n.default.string,
      defaultClassNameDragging: n.default.string,
      defaultClassNameDragged: n.default.string,
      /**
       * `defaultPosition` specifies the x and y that the dragged item should start at
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable defaultPosition={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      defaultPosition: n.default.shape({
        x: n.default.number,
        y: n.default.number
      }),
      positionOffset: n.default.shape({
        x: n.default.oneOfType([n.default.number, n.default.string]),
        y: n.default.oneOfType([n.default.number, n.default.string])
      }),
      /**
       * `position`, if present, defines the current position of the element.
       *
       *  This is similar to how form elements in React work - if no `position` is supplied, the component
       *  is uncontrolled.
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable position={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      position: n.default.shape({
        x: n.default.number,
        y: n.default.number
      }),
      /**
       * These properties should be defined on the child, not here.
       */
      className: a.dontSetMe,
      style: a.dontSetMe,
      transform: a.dontSetMe
    }), b(S, "defaultProps", {
      ...c.default.defaultProps,
      axis: "both",
      bounds: !1,
      defaultClassName: "react-draggable",
      defaultClassNameDragging: "react-draggable-dragging",
      defaultClassNameDragged: "react-draggable-dragged",
      defaultPosition: {
        x: 0,
        y: 0
      },
      scale: 1
    });
  })(jE)), jE;
}
var V3;
function ILe() {
  if (V3) return gm.exports;
  V3 = 1;
  const {
    default: e,
    DraggableCore: t
  } = DLe();
  return gm.exports = e, gm.exports.default = e, gm.exports.DraggableCore = t, gm.exports;
}
var jLe = ILe();
const zLe = /* @__PURE__ */ Bc(jLe);
var xr = function() {
  return xr = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, xr.apply(this, arguments);
}, H3 = {
  width: "100%",
  height: "10px",
  top: "0px",
  left: "0px",
  cursor: "row-resize"
}, W3 = {
  width: "10px",
  height: "100%",
  top: "0px",
  left: "0px",
  cursor: "col-resize"
}, E0 = {
  width: "20px",
  height: "20px",
  position: "absolute",
  zIndex: 1
}, LLe = {
  top: xr(xr({}, H3), { top: "-5px" }),
  right: xr(xr({}, W3), { left: void 0, right: "-5px" }),
  bottom: xr(xr({}, H3), { top: void 0, bottom: "-5px" }),
  left: xr(xr({}, W3), { left: "-5px" }),
  topRight: xr(xr({}, E0), { right: "-10px", top: "-10px", cursor: "ne-resize" }),
  bottomRight: xr(xr({}, E0), { right: "-10px", bottom: "-10px", cursor: "se-resize" }),
  bottomLeft: xr(xr({}, E0), { left: "-10px", bottom: "-10px", cursor: "sw-resize" }),
  topLeft: xr(xr({}, E0), { left: "-10px", top: "-10px", cursor: "nw-resize" })
}, BLe = C.memo(function(e) {
  var t = e.onResizeStart, n = e.direction, r = e.children, i = e.replaceStyles, o = e.className, s = C.useCallback(function(u) {
    t(u, n);
  }, [t, n]), a = C.useCallback(function(u) {
    t(u, n);
  }, [t, n]), c = C.useMemo(function() {
    return xr(xr({ position: "absolute", userSelect: "none" }, LLe[n]), i ?? {});
  }, [i, n]);
  return v.jsx("div", { className: o || void 0, style: c, onMouseDown: s, onTouchStart: a, children: r });
}), $Le = /* @__PURE__ */ (function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
})(), Ws = function() {
  return Ws = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, Ws.apply(this, arguments);
}, ULe = {
  width: "auto",
  height: "auto"
}, _0 = function(e, t, n) {
  return Math.max(Math.min(e, n), t);
}, q3 = function(e, t, n) {
  var r = Math.round(e / t);
  return r * t + n * (r - 1);
}, Rf = function(e, t) {
  return new RegExp(e, "i").test(t);
}, T0 = function(e) {
  return !!(e.touches && e.touches.length);
}, FLe = function(e) {
  return !!((e.clientX || e.clientX === 0) && (e.clientY || e.clientY === 0));
}, G3 = function(e, t, n) {
  n === void 0 && (n = 0);
  var r = t.reduce(function(o, s, a) {
    return Math.abs(s - e) < Math.abs(t[o] - e) ? a : o;
  }, 0), i = Math.abs(t[r] - e);
  return n === 0 || i < n ? t[r] : e;
}, $E = function(e) {
  return e = e.toString(), e === "auto" || e.endsWith("px") || e.endsWith("%") || e.endsWith("vh") || e.endsWith("vw") || e.endsWith("vmax") || e.endsWith("vmin") ? e : "".concat(e, "px");
}, A0 = function(e, t, n, r) {
  if (e && typeof e == "string") {
    if (e.endsWith("px"))
      return Number(e.replace("px", ""));
    if (e.endsWith("%")) {
      var i = Number(e.replace("%", "")) / 100;
      return t * i;
    }
    if (e.endsWith("vw")) {
      var i = Number(e.replace("vw", "")) / 100;
      return n * i;
    }
    if (e.endsWith("vh")) {
      var i = Number(e.replace("vh", "")) / 100;
      return r * i;
    }
  }
  return e;
}, VLe = function(e, t, n, r, i, o, s) {
  return r = A0(r, e.width, t, n), i = A0(i, e.height, t, n), o = A0(o, e.width, t, n), s = A0(s, e.height, t, n), {
    maxWidth: typeof r > "u" ? void 0 : Number(r),
    maxHeight: typeof i > "u" ? void 0 : Number(i),
    minWidth: typeof o > "u" ? void 0 : Number(o),
    minHeight: typeof s > "u" ? void 0 : Number(s)
  };
}, HLe = function(e) {
  return Array.isArray(e) ? e : [e, e];
}, WLe = [
  "as",
  "ref",
  "style",
  "className",
  "grid",
  "gridGap",
  "snap",
  "bounds",
  "boundsByDirection",
  "size",
  "defaultSize",
  "minWidth",
  "minHeight",
  "maxWidth",
  "maxHeight",
  "lockAspectRatio",
  "lockAspectRatioExtraWidth",
  "lockAspectRatioExtraHeight",
  "enable",
  "handleStyles",
  "handleClasses",
  "handleWrapperStyle",
  "handleWrapperClass",
  "children",
  "onResizeStart",
  "onResize",
  "onResizeStop",
  "handleComponent",
  "scale",
  "resizeRatio",
  "snapGap"
], K3 = "__resizable_base__", qLe = (
  /** @class */
  (function(e) {
    $Le(t, e);
    function t(n) {
      var r, i, o, s, a = e.call(this, n) || this;
      return a.ratio = 1, a.resizable = null, a.parentLeft = 0, a.parentTop = 0, a.resizableLeft = 0, a.resizableRight = 0, a.resizableTop = 0, a.resizableBottom = 0, a.targetLeft = 0, a.targetTop = 0, a.delta = {
        width: 0,
        height: 0
      }, a.appendBase = function() {
        if (!a.resizable || !a.window)
          return null;
        var c = a.parentNode;
        if (!c)
          return null;
        var u = a.window.document.createElement("div");
        return u.style.width = "100%", u.style.height = "100%", u.style.position = "absolute", u.style.transform = "scale(0, 0)", u.style.left = "0", u.style.flex = "0 0 100%", u.classList ? u.classList.add(K3) : u.className += K3, c.appendChild(u), u;
      }, a.removeBase = function(c) {
        var u = a.parentNode;
        u && u.removeChild(c);
      }, a.state = {
        isResizing: !1,
        width: (i = (r = a.propsSize) === null || r === void 0 ? void 0 : r.width) !== null && i !== void 0 ? i : "auto",
        height: (s = (o = a.propsSize) === null || o === void 0 ? void 0 : o.height) !== null && s !== void 0 ? s : "auto",
        direction: "right",
        original: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        backgroundStyle: {
          height: "100%",
          width: "100%",
          backgroundColor: "rgba(0,0,0,0)",
          cursor: "auto",
          opacity: 0,
          position: "fixed",
          zIndex: 9999,
          top: "0",
          left: "0",
          bottom: "0",
          right: "0"
        },
        flexBasis: void 0
      }, a.onResizeStart = a.onResizeStart.bind(a), a.onMouseMove = a.onMouseMove.bind(a), a.onMouseUp = a.onMouseUp.bind(a), a;
    }
    return Object.defineProperty(t.prototype, "parentNode", {
      get: function() {
        return this.resizable ? this.resizable.parentNode : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "window", {
      get: function() {
        return !this.resizable || !this.resizable.ownerDocument ? null : this.resizable.ownerDocument.defaultView;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "propsSize", {
      get: function() {
        return this.props.size || this.props.defaultSize || ULe;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "size", {
      get: function() {
        var n = 0, r = 0;
        if (this.resizable && this.window) {
          var i = this.resizable.offsetWidth, o = this.resizable.offsetHeight, s = this.resizable.style.position;
          s !== "relative" && (this.resizable.style.position = "relative"), n = this.resizable.style.width !== "auto" ? this.resizable.offsetWidth : i, r = this.resizable.style.height !== "auto" ? this.resizable.offsetHeight : o, this.resizable.style.position = s;
        }
        return { width: n, height: r };
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "sizeStyle", {
      get: function() {
        var n = this, r = this.props.size, i = function(a) {
          var c;
          if (typeof n.state[a] > "u" || n.state[a] === "auto")
            return "auto";
          if (n.propsSize && n.propsSize[a] && (!((c = n.propsSize[a]) === null || c === void 0) && c.toString().endsWith("%"))) {
            if (n.state[a].toString().endsWith("%"))
              return n.state[a].toString();
            var u = n.getParentSize(), f = Number(n.state[a].toString().replace("px", "")), h = f / u[a] * 100;
            return "".concat(h, "%");
          }
          return $E(n.state[a]);
        }, o = r && typeof r.width < "u" && !this.state.isResizing ? $E(r.width) : i("width"), s = r && typeof r.height < "u" && !this.state.isResizing ? $E(r.height) : i("height");
        return { width: o, height: s };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.getParentSize = function() {
      if (!this.parentNode)
        return this.window ? { width: this.window.innerWidth, height: this.window.innerHeight } : { width: 0, height: 0 };
      var n = this.appendBase();
      if (!n)
        return { width: 0, height: 0 };
      var r = !1, i = this.parentNode.style.flexWrap;
      i !== "wrap" && (r = !0, this.parentNode.style.flexWrap = "wrap"), n.style.position = "relative", n.style.minWidth = "100%", n.style.minHeight = "100%";
      var o = {
        width: n.offsetWidth,
        height: n.offsetHeight
      };
      return r && (this.parentNode.style.flexWrap = i), this.removeBase(n), o;
    }, t.prototype.bindEvents = function() {
      this.window && (this.window.addEventListener("mouseup", this.onMouseUp), this.window.addEventListener("mousemove", this.onMouseMove), this.window.addEventListener("mouseleave", this.onMouseUp), this.window.addEventListener("touchmove", this.onMouseMove, {
        capture: !0,
        passive: !1
      }), this.window.addEventListener("touchend", this.onMouseUp));
    }, t.prototype.unbindEvents = function() {
      this.window && (this.window.removeEventListener("mouseup", this.onMouseUp), this.window.removeEventListener("mousemove", this.onMouseMove), this.window.removeEventListener("mouseleave", this.onMouseUp), this.window.removeEventListener("touchmove", this.onMouseMove, !0), this.window.removeEventListener("touchend", this.onMouseUp));
    }, t.prototype.componentDidMount = function() {
      if (!(!this.resizable || !this.window)) {
        var n = this.window.getComputedStyle(this.resizable);
        this.setState({
          width: this.state.width || this.size.width,
          height: this.state.height || this.size.height,
          flexBasis: n.flexBasis !== "auto" ? n.flexBasis : void 0
        });
      }
    }, t.prototype.componentWillUnmount = function() {
      this.window && this.unbindEvents();
    }, t.prototype.createSizeForCssProperty = function(n, r) {
      var i = this.propsSize && this.propsSize[r];
      return this.state[r] === "auto" && this.state.original[r] === n && (typeof i > "u" || i === "auto") ? "auto" : n;
    }, t.prototype.calculateNewMaxFromBoundary = function(n, r) {
      var i = this.props.boundsByDirection, o = this.state.direction, s = i && Rf("left", o), a = i && Rf("top", o), c, u;
      if (this.props.bounds === "parent") {
        var f = this.parentNode;
        f && (c = s ? this.resizableRight - this.parentLeft : f.offsetWidth + (this.parentLeft - this.resizableLeft), u = a ? this.resizableBottom - this.parentTop : f.offsetHeight + (this.parentTop - this.resizableTop));
      } else this.props.bounds === "window" ? this.window && (c = s ? this.resizableRight : this.window.innerWidth - this.resizableLeft, u = a ? this.resizableBottom : this.window.innerHeight - this.resizableTop) : this.props.bounds && (c = s ? this.resizableRight - this.targetLeft : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft), u = a ? this.resizableBottom - this.targetTop : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop));
      return c && Number.isFinite(c) && (n = n && n < c ? n : c), u && Number.isFinite(u) && (r = r && r < u ? r : u), { maxWidth: n, maxHeight: r };
    }, t.prototype.calculateNewSizeFromDirection = function(n, r) {
      var i = this.props.scale || 1, o = HLe(this.props.resizeRatio || 1), s = o[0], a = o[1], c = this.state, u = c.direction, f = c.original, h = this.props, m = h.lockAspectRatio, g = h.lockAspectRatioExtraHeight, b = h.lockAspectRatioExtraWidth, x = f.width, w = f.height, S = g || 0, _ = b || 0;
      return Rf("right", u) && (x = f.width + (n - f.x) * s / i, m && (w = (x - _) / this.ratio + S)), Rf("left", u) && (x = f.width - (n - f.x) * s / i, m && (w = (x - _) / this.ratio + S)), Rf("bottom", u) && (w = f.height + (r - f.y) * a / i, m && (x = (w - S) * this.ratio + _)), Rf("top", u) && (w = f.height - (r - f.y) * a / i, m && (x = (w - S) * this.ratio + _)), { newWidth: x, newHeight: w };
    }, t.prototype.calculateNewSizeFromAspectRatio = function(n, r, i, o) {
      var s = this.props, a = s.lockAspectRatio, c = s.lockAspectRatioExtraHeight, u = s.lockAspectRatioExtraWidth, f = typeof o.width > "u" ? 10 : o.width, h = typeof i.width > "u" || i.width < 0 ? n : i.width, m = typeof o.height > "u" ? 10 : o.height, g = typeof i.height > "u" || i.height < 0 ? r : i.height, b = c || 0, x = u || 0;
      if (a) {
        var w = (m - b) * this.ratio + x, S = (g - b) * this.ratio + x, _ = (f - x) / this.ratio + b, M = (h - x) / this.ratio + b, N = Math.max(f, w), D = Math.min(h, S), j = Math.max(m, _), O = Math.min(g, M);
        n = _0(n, N, D), r = _0(r, j, O);
      } else
        n = _0(n, f, h), r = _0(r, m, g);
      return { newWidth: n, newHeight: r };
    }, t.prototype.setBoundingClientRect = function() {
      var n = 1 / (this.props.scale || 1);
      if (this.props.bounds === "parent") {
        var r = this.parentNode;
        if (r) {
          var i = r.getBoundingClientRect();
          this.parentLeft = i.left * n, this.parentTop = i.top * n;
        }
      }
      if (this.props.bounds && typeof this.props.bounds != "string") {
        var o = this.props.bounds.getBoundingClientRect();
        this.targetLeft = o.left * n, this.targetTop = o.top * n;
      }
      if (this.resizable) {
        var s = this.resizable.getBoundingClientRect(), a = s.left, c = s.top, u = s.right, f = s.bottom;
        this.resizableLeft = a * n, this.resizableRight = u * n, this.resizableTop = c * n, this.resizableBottom = f * n;
      }
    }, t.prototype.onResizeStart = function(n, r) {
      if (!(!this.resizable || !this.window)) {
        var i = 0, o = 0;
        if (n.nativeEvent && FLe(n.nativeEvent) ? (i = n.nativeEvent.clientX, o = n.nativeEvent.clientY) : n.nativeEvent && T0(n.nativeEvent) && (i = n.nativeEvent.touches[0].clientX, o = n.nativeEvent.touches[0].clientY), this.props.onResizeStart && this.resizable) {
          var s = this.props.onResizeStart(n, r, this.resizable);
          if (s === !1)
            return;
        }
        this.props.size && (typeof this.props.size.height < "u" && this.props.size.height !== this.state.height && this.setState({ height: this.props.size.height }), typeof this.props.size.width < "u" && this.props.size.width !== this.state.width && this.setState({ width: this.props.size.width })), this.ratio = typeof this.props.lockAspectRatio == "number" ? this.props.lockAspectRatio : this.size.width / this.size.height;
        var a, c = this.window.getComputedStyle(this.resizable);
        if (c.flexBasis !== "auto") {
          var u = this.parentNode;
          if (u) {
            var f = this.window.getComputedStyle(u).flexDirection;
            this.flexDir = f.startsWith("row") ? "row" : "column", a = c.flexBasis;
          }
        }
        this.setBoundingClientRect(), this.bindEvents();
        var h = {
          original: {
            x: i,
            y: o,
            width: this.size.width,
            height: this.size.height
          },
          isResizing: !0,
          backgroundStyle: Ws(Ws({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(n.target).cursor || "auto" }),
          direction: r,
          flexBasis: a
        };
        this.setState(h);
      }
    }, t.prototype.onMouseMove = function(n) {
      var r = this;
      if (!(!this.state.isResizing || !this.resizable || !this.window)) {
        if (this.window.TouchEvent && T0(n))
          try {
            n.preventDefault(), n.stopPropagation();
          } catch {
          }
        var i = this.props, o = i.maxWidth, s = i.maxHeight, a = i.minWidth, c = i.minHeight, u = T0(n) ? n.touches[0].clientX : n.clientX, f = T0(n) ? n.touches[0].clientY : n.clientY, h = this.state, m = h.direction, g = h.original, b = h.width, x = h.height, w = this.getParentSize(), S = VLe(w, this.window.innerWidth, this.window.innerHeight, o, s, a, c);
        o = S.maxWidth, s = S.maxHeight, a = S.minWidth, c = S.minHeight;
        var _ = this.calculateNewSizeFromDirection(u, f), M = _.newHeight, N = _.newWidth, D = this.calculateNewMaxFromBoundary(o, s);
        this.props.snap && this.props.snap.x && (N = G3(N, this.props.snap.x, this.props.snapGap)), this.props.snap && this.props.snap.y && (M = G3(M, this.props.snap.y, this.props.snapGap));
        var j = this.calculateNewSizeFromAspectRatio(N, M, { width: D.maxWidth, height: D.maxHeight }, { width: a, height: c });
        if (N = j.newWidth, M = j.newHeight, this.props.grid) {
          var O = q3(N, this.props.grid[0], this.props.gridGap ? this.props.gridGap[0] : 0), L = q3(M, this.props.grid[1], this.props.gridGap ? this.props.gridGap[1] : 0), U = this.props.snapGap || 0, B = U === 0 || Math.abs(O - N) <= U ? O : N, G = U === 0 || Math.abs(L - M) <= U ? L : M;
          N = B, M = G;
        }
        var Y = {
          width: N - g.width,
          height: M - g.height
        };
        if (this.delta = Y, b && typeof b == "string") {
          if (b.endsWith("%")) {
            var he = N / w.width * 100;
            N = "".concat(he, "%");
          } else if (b.endsWith("vw")) {
            var ie = N / this.window.innerWidth * 100;
            N = "".concat(ie, "vw");
          } else if (b.endsWith("vh")) {
            var ne = N / this.window.innerHeight * 100;
            N = "".concat(ne, "vh");
          }
        }
        if (x && typeof x == "string") {
          if (x.endsWith("%")) {
            var he = M / w.height * 100;
            M = "".concat(he, "%");
          } else if (x.endsWith("vw")) {
            var ie = M / this.window.innerWidth * 100;
            M = "".concat(ie, "vw");
          } else if (x.endsWith("vh")) {
            var ne = M / this.window.innerHeight * 100;
            M = "".concat(ne, "vh");
          }
        }
        var H = {
          width: this.createSizeForCssProperty(N, "width"),
          height: this.createSizeForCssProperty(M, "height")
        };
        this.flexDir === "row" ? H.flexBasis = H.width : this.flexDir === "column" && (H.flexBasis = H.height);
        var Q = this.state.width !== H.width, X = this.state.height !== H.height, Se = this.state.flexBasis !== H.flexBasis, W = Q || X || Se;
        W && sl.flushSync(function() {
          r.setState(H);
        }), this.props.onResize && W && this.props.onResize(n, m, this.resizable, Y);
      }
    }, t.prototype.onMouseUp = function(n) {
      var r, i, o = this.state, s = o.isResizing, a = o.direction;
      o.original, !(!s || !this.resizable) && (this.props.onResizeStop && this.props.onResizeStop(n, a, this.resizable, this.delta), this.props.size && this.setState({ width: (r = this.props.size.width) !== null && r !== void 0 ? r : "auto", height: (i = this.props.size.height) !== null && i !== void 0 ? i : "auto" }), this.unbindEvents(), this.setState({
        isResizing: !1,
        backgroundStyle: Ws(Ws({}, this.state.backgroundStyle), { cursor: "auto" })
      }));
    }, t.prototype.updateSize = function(n) {
      var r, i;
      this.setState({ width: (r = n.width) !== null && r !== void 0 ? r : "auto", height: (i = n.height) !== null && i !== void 0 ? i : "auto" });
    }, t.prototype.renderResizer = function() {
      var n = this, r = this.props, i = r.enable, o = r.handleStyles, s = r.handleClasses, a = r.handleWrapperStyle, c = r.handleWrapperClass, u = r.handleComponent;
      if (!i)
        return null;
      var f = Object.keys(i).map(function(h) {
        return i[h] !== !1 ? v.jsx(BLe, { direction: h, onResizeStart: n.onResizeStart, replaceStyles: o && o[h], className: s && s[h], children: u && u[h] ? u[h] : null }, h) : null;
      });
      return v.jsx("div", { className: c, style: a, children: f });
    }, t.prototype.render = function() {
      var n = this, r = Object.keys(this.props).reduce(function(s, a) {
        return WLe.indexOf(a) !== -1 || (s[a] = n.props[a]), s;
      }, {}), i = Ws(Ws(Ws({ position: "relative", userSelect: this.state.isResizing ? "none" : "auto" }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: "border-box", flexShrink: 0 });
      this.state.flexBasis && (i.flexBasis = this.state.flexBasis);
      var o = this.props.as || "div";
      return v.jsxs(o, Ws({ style: i, className: this.props.className }, r, {
        // `ref` is after `extendsProps` to ensure this one wins over a version
        // passed in
        ref: function(s) {
          s && (n.resizable = s);
        },
        children: [this.state.isResizing && v.jsx("div", { style: this.state.backgroundStyle }), this.props.children, this.renderResizer()]
      }));
    }, t.defaultProps = {
      as: "div",
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      enable: {
        top: !0,
        right: !0,
        bottom: !0,
        left: !0,
        topRight: !0,
        bottomRight: !0,
        bottomLeft: !0,
        topLeft: !0
      },
      style: {},
      grid: [1, 1],
      gridGap: [0, 0],
      lockAspectRatio: !1,
      lockAspectRatioExtraWidth: 0,
      lockAspectRatioExtraHeight: 0,
      scale: 1,
      resizeRatio: 1,
      snapGap: 0
    }, t;
  })(C.PureComponent)
);
var oA = function(e, t) {
  return oA = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r) r.hasOwnProperty(i) && (n[i] = r[i]);
  }, oA(e, t);
};
function GLe(e, t) {
  oA(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Or = function() {
  return Or = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, Or.apply(this, arguments);
};
function KLe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
var ZLe = {
  width: "auto",
  height: "auto",
  display: "inline-block",
  position: "absolute",
  top: 0,
  left: 0
}, YLe = function(e) {
  return {
    bottom: e,
    bottomLeft: e,
    bottomRight: e,
    left: e,
    right: e,
    top: e,
    topLeft: e,
    topRight: e
  };
}, XLe = (
  /** @class */
  (function(e) {
    GLe(t, e);
    function t(n) {
      var r = e.call(this, n) || this;
      return r.resizingPosition = { x: 0, y: 0 }, r.offsetFromParent = { left: 0, top: 0 }, r.resizableElement = { current: null }, r.originalPosition = { x: 0, y: 0 }, r.state = {
        resizing: !1,
        bounds: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        },
        maxWidth: n.maxWidth,
        maxHeight: n.maxHeight
      }, r.onResizeStart = r.onResizeStart.bind(r), r.onResize = r.onResize.bind(r), r.onResizeStop = r.onResizeStop.bind(r), r.onDragStart = r.onDragStart.bind(r), r.onDrag = r.onDrag.bind(r), r.onDragStop = r.onDragStop.bind(r), r.getMaxSizesFromProps = r.getMaxSizesFromProps.bind(r), r;
    }
    return t.prototype.componentDidMount = function() {
      this.updateOffsetFromParent();
      var n = this.offsetFromParent, r = n.left, i = n.top, o = this.getDraggablePosition(), s = o.x, a = o.y;
      this.draggable.setState({
        x: s - r,
        y: a - i
      }), this.forceUpdate();
    }, t.prototype.getDraggablePosition = function() {
      var n = this.draggable.state, r = n.x, i = n.y;
      return { x: r, y: i };
    }, t.prototype.getParent = function() {
      return this.resizable && this.resizable.parentNode;
    }, t.prototype.getParentSize = function() {
      return this.resizable.getParentSize();
    }, t.prototype.getMaxSizesFromProps = function() {
      var n = typeof this.props.maxWidth > "u" ? Number.MAX_SAFE_INTEGER : this.props.maxWidth, r = typeof this.props.maxHeight > "u" ? Number.MAX_SAFE_INTEGER : this.props.maxHeight;
      return { maxWidth: n, maxHeight: r };
    }, t.prototype.getSelfElement = function() {
      return this.resizable && this.resizable.resizable;
    }, t.prototype.getOffsetHeight = function(n) {
      var r = this.props.scale;
      switch (this.props.bounds) {
        case "window":
          return window.innerHeight / r;
        case "body":
          return document.body.offsetHeight / r;
        default:
          return n.offsetHeight;
      }
    }, t.prototype.getOffsetWidth = function(n) {
      var r = this.props.scale;
      switch (this.props.bounds) {
        case "window":
          return window.innerWidth / r;
        case "body":
          return document.body.offsetWidth / r;
        default:
          return n.offsetWidth;
      }
    }, t.prototype.onDragStart = function(n, r) {
      this.props.onDragStart && this.props.onDragStart(n, r);
      var i = this.getDraggablePosition();
      if (this.originalPosition = i, !!this.props.bounds) {
        var o = this.getParent(), s = this.props.scale, a;
        if (this.props.bounds === "parent")
          a = o;
        else if (this.props.bounds === "body") {
          var c = o.getBoundingClientRect(), u = c.left, f = c.top, h = document.body.getBoundingClientRect(), m = -(u - o.offsetLeft * s - h.left) / s, g = -(f - o.offsetTop * s - h.top) / s, b = (document.body.offsetWidth - this.resizable.size.width * s) / s + m, x = (document.body.offsetHeight - this.resizable.size.height * s) / s + g;
          return this.setState({ bounds: { top: g, right: b, bottom: x, left: m } });
        } else if (this.props.bounds === "window") {
          if (!this.resizable)
            return;
          var w = o.getBoundingClientRect(), S = w.left, _ = w.top, M = -(S - o.offsetLeft * s) / s, N = -(_ - o.offsetTop * s) / s, b = (window.innerWidth - this.resizable.size.width * s) / s + M, x = (window.innerHeight - this.resizable.size.height * s) / s + N;
          return this.setState({ bounds: { top: N, right: b, bottom: x, left: M } });
        } else typeof this.props.bounds == "string" ? a = document.querySelector(this.props.bounds) : this.props.bounds instanceof HTMLElement && (a = this.props.bounds);
        if (!(!(a instanceof HTMLElement) || !(o instanceof HTMLElement))) {
          var D = a.getBoundingClientRect(), j = D.left, O = D.top, L = o.getBoundingClientRect(), U = L.left, B = L.top, G = (j - U) / s, Y = O - B;
          if (this.resizable) {
            this.updateOffsetFromParent();
            var he = this.offsetFromParent;
            this.setState({
              bounds: {
                top: Y - he.top,
                right: G + (a.offsetWidth - this.resizable.size.width) - he.left / s,
                bottom: Y + (a.offsetHeight - this.resizable.size.height) - he.top,
                left: G - he.left / s
              }
            });
          }
        }
      }
    }, t.prototype.onDrag = function(n, r) {
      if (this.props.onDrag) {
        var i = this.offsetFromParent, o = i.left, s = i.top;
        if (!this.props.dragAxis || this.props.dragAxis === "both")
          return this.props.onDrag(n, Or(Or({}, r), { x: r.x + o, y: r.y + s }));
        if (this.props.dragAxis === "x")
          return this.props.onDrag(n, Or(Or({}, r), { x: r.x + o, y: this.originalPosition.y + s, deltaY: 0 }));
        if (this.props.dragAxis === "y")
          return this.props.onDrag(n, Or(Or({}, r), { x: this.originalPosition.x + o, y: r.y + s, deltaX: 0 }));
      }
    }, t.prototype.onDragStop = function(n, r) {
      if (this.props.onDragStop) {
        var i = this.offsetFromParent, o = i.left, s = i.top;
        if (!this.props.dragAxis || this.props.dragAxis === "both")
          return this.props.onDragStop(n, Or(Or({}, r), { x: r.x + o, y: r.y + s }));
        if (this.props.dragAxis === "x")
          return this.props.onDragStop(n, Or(Or({}, r), { x: r.x + o, y: this.originalPosition.y + s, deltaY: 0 }));
        if (this.props.dragAxis === "y")
          return this.props.onDragStop(n, Or(Or({}, r), { x: this.originalPosition.x + o, y: r.y + s, deltaX: 0 }));
      }
    }, t.prototype.onResizeStart = function(n, r, i) {
      n.stopPropagation(), this.setState({
        resizing: !0
      });
      var o = this.props.scale, s = this.offsetFromParent, a = this.getDraggablePosition();
      if (this.resizingPosition = { x: a.x + s.left, y: a.y + s.top }, this.originalPosition = a, this.props.bounds) {
        var c = this.getParent(), u = void 0;
        this.props.bounds === "parent" ? u = c : this.props.bounds === "body" ? u = document.body : this.props.bounds === "window" ? u = window : typeof this.props.bounds == "string" ? u = document.querySelector(this.props.bounds) : this.props.bounds instanceof HTMLElement && (u = this.props.bounds);
        var f = this.getSelfElement();
        if (f instanceof Element && (u instanceof HTMLElement || u === window) && c instanceof HTMLElement) {
          var h = this.getMaxSizesFromProps(), m = h.maxWidth, g = h.maxHeight, b = this.getParentSize();
          if (m && typeof m == "string")
            if (m.endsWith("%")) {
              var x = Number(m.replace("%", "")) / 100;
              m = b.width * x;
            } else m.endsWith("px") && (m = Number(m.replace("px", "")));
          if (g && typeof g == "string")
            if (g.endsWith("%")) {
              var x = Number(g.replace("%", "")) / 100;
              g = b.height * x;
            } else g.endsWith("px") && (g = Number(g.replace("px", "")));
          var w = f.getBoundingClientRect(), S = w.left, _ = w.top, M = this.props.bounds === "window" ? { left: 0, top: 0 } : u.getBoundingClientRect(), N = M.left, D = M.top, j = this.getOffsetWidth(u), O = this.getOffsetHeight(u), L = r.toLowerCase().endsWith("left"), U = r.toLowerCase().endsWith("right"), B = r.startsWith("top"), G = r.startsWith("bottom");
          if ((L || B) && this.resizable) {
            var Y = (S - N) / o + this.resizable.size.width;
            this.setState({ maxWidth: Y > Number(m) ? m : Y });
          }
          if (U || this.props.lockAspectRatio && !L && !B) {
            var Y = j + (N - S) / o;
            this.setState({ maxWidth: Y > Number(m) ? m : Y });
          }
          if ((B || L) && this.resizable) {
            var Y = (_ - D) / o + this.resizable.size.height;
            this.setState({
              maxHeight: Y > Number(g) ? g : Y
            });
          }
          if (G || this.props.lockAspectRatio && !B && !L) {
            var Y = O + (D - _) / o;
            this.setState({
              maxHeight: Y > Number(g) ? g : Y
            });
          }
        }
      } else
        this.setState({
          maxWidth: this.props.maxWidth,
          maxHeight: this.props.maxHeight
        });
      this.props.onResizeStart && this.props.onResizeStart(n, r, i);
    }, t.prototype.onResize = function(n, r, i, o) {
      var s = this, a = { x: this.originalPosition.x, y: this.originalPosition.y }, c = -o.width, u = -o.height, f = ["top", "left", "topLeft", "bottomLeft", "topRight"];
      f.includes(r) && (r === "bottomLeft" ? a.x += c : (r === "topRight" || (a.x += c), a.y += u));
      var h = this.draggable.state;
      (a.x !== h.x || a.y !== h.y) && sl.flushSync(function() {
        s.draggable.setState(a);
      }), this.updateOffsetFromParent();
      var m = this.offsetFromParent, g = this.getDraggablePosition().x + m.left, b = this.getDraggablePosition().y + m.top;
      this.resizingPosition = { x: g, y: b }, this.props.onResize && this.props.onResize(n, r, i, o, {
        x: g,
        y: b
      });
    }, t.prototype.onResizeStop = function(n, r, i, o) {
      this.setState({
        resizing: !1
      });
      var s = this.getMaxSizesFromProps(), a = s.maxWidth, c = s.maxHeight;
      this.setState({ maxWidth: a, maxHeight: c }), this.props.onResizeStop && this.props.onResizeStop(n, r, i, o, this.resizingPosition);
    }, t.prototype.updateSize = function(n) {
      this.resizable && this.resizable.updateSize({ width: n.width, height: n.height });
    }, t.prototype.updatePosition = function(n) {
      this.draggable.setState(n);
    }, t.prototype.updateOffsetFromParent = function() {
      var n = this.props.scale, r = this.getParent(), i = this.getSelfElement();
      if (!r || i === null)
        return {
          top: 0,
          left: 0
        };
      var o = r.getBoundingClientRect(), s = o.left, a = o.top, c = i.getBoundingClientRect(), u = this.getDraggablePosition(), f = r.scrollLeft, h = r.scrollTop;
      this.offsetFromParent = {
        left: c.left - s + f - u.x * n,
        top: c.top - a + h - u.y * n
      };
    }, t.prototype.render = function() {
      var n = this, r = this.props, i = r.disableDragging, o = r.style, s = r.dragHandleClassName, a = r.position, c = r.onMouseDown, u = r.onMouseUp, f = r.dragAxis, h = r.dragGrid, m = r.bounds, g = r.enableUserSelectHack, b = r.cancel, x = r.children;
      r.onResizeStart, r.onResize, r.onResizeStop, r.onDragStart, r.onDrag, r.onDragStop;
      var w = r.resizeHandleStyles, S = r.resizeHandleClasses, _ = r.resizeHandleComponent, M = r.enableResizing, N = r.resizeGrid, D = r.resizeHandleWrapperClass, j = r.resizeHandleWrapperStyle, O = r.scale, L = r.allowAnyClick, U = r.dragPositionOffset, B = KLe(r, ["disableDragging", "style", "dragHandleClassName", "position", "onMouseDown", "onMouseUp", "dragAxis", "dragGrid", "bounds", "enableUserSelectHack", "cancel", "children", "onResizeStart", "onResize", "onResizeStop", "onDragStart", "onDrag", "onDragStop", "resizeHandleStyles", "resizeHandleClasses", "resizeHandleComponent", "enableResizing", "resizeGrid", "resizeHandleWrapperClass", "resizeHandleWrapperStyle", "scale", "allowAnyClick", "dragPositionOffset"]), G = this.props.default ? Or({}, this.props.default) : void 0;
      delete B.default;
      var Y = i || s ? { cursor: "auto" } : { cursor: "move" }, he = Or(Or(Or({}, ZLe), Y), o), ie = this.offsetFromParent, ne = ie.left, H = ie.top, Q;
      a && (Q = {
        x: a.x - ne,
        y: a.y - H
      });
      var X = this.state.resizing ? void 0 : Q, Se = this.state.resizing ? "both" : f;
      return C.createElement(
        zLe,
        {
          ref: function(W) {
            W && (n.draggable = W);
          },
          handle: s ? ".".concat(s) : void 0,
          defaultPosition: G,
          onMouseDown: c,
          // @ts-expect-error
          onMouseUp: u,
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop,
          axis: Se,
          disabled: i,
          grid: h,
          bounds: m ? this.state.bounds : void 0,
          position: X,
          enableUserSelectHack: g,
          cancel: b,
          scale: O,
          allowAnyClick: L,
          nodeRef: this.resizableElement,
          positionOffset: U
        },
        C.createElement(qLe, Or({}, B, { ref: function(W) {
          W && (n.resizable = W, n.resizableElement.current = W.resizable);
        }, defaultSize: G, size: this.props.size, enable: typeof M == "boolean" ? YLe(M) : M, onResizeStart: this.onResizeStart, onResize: this.onResize, onResizeStop: this.onResizeStop, style: he, minWidth: this.props.minWidth, minHeight: this.props.minHeight, maxWidth: this.state.resizing ? this.state.maxWidth : this.props.maxWidth, maxHeight: this.state.resizing ? this.state.maxHeight : this.props.maxHeight, grid: N, handleWrapperClass: D, handleWrapperStyle: j, lockAspectRatio: this.props.lockAspectRatio, lockAspectRatioExtraWidth: this.props.lockAspectRatioExtraWidth, lockAspectRatioExtraHeight: this.props.lockAspectRatioExtraHeight, handleStyles: w, handleClasses: S, handleComponent: _, scale: this.props.scale }), x)
      );
    }, t.defaultProps = {
      maxWidth: Number.MAX_SAFE_INTEGER,
      maxHeight: Number.MAX_SAFE_INTEGER,
      scale: 1,
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      onDragStart: function() {
      },
      onDrag: function() {
      },
      onDragStop: function() {
      }
    }, t;
  })(C.PureComponent)
);
function JLe() {
  return `temp-${BF()}`;
}
const QLe = () => {
  v4();
  const [e, t] = C.useState(!1), [n, r] = C.useState(!1), {
    chatbotStore: { chatbotReady: i, ChatbotConfig: o, ChatbotThreadConfig: s, isLoadingThread: a },
    chatbotStore: c,
    chatbotThreadStore: { threadMentions: u }
  } = la();
  if (!c.currentThreadId.value) {
    const f = JLe();
    c.currentThreadId.value = f;
  }
  return C.useEffect(() => {
    o();
  }, []), C.useEffect(() => {
    let f = !1;
    return e && i.value && !n && (a.value = !0, s().then(() => {
      f || r(!0);
    }).catch((h) => {
      f || console.error("Failed to configure thread:", h);
    }).finally(() => {
      f || (a.value = !1);
    })), () => {
      f = !0;
    };
  }, [e, i.value, n, s]), /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
    /* @__PURE__ */ v.jsx(
      XLe,
      {
        default: {
          x: window.innerWidth - 1450,
          y: 50,
          width: 800,
          height: window.innerHeight - 150
        },
        minWidth: 500,
        minHeight: 400,
        maxWidth: window.innerWidth - 100,
        maxHeight: window.innerHeight - 100,
        bounds: "window",
        dragHandleClassName: "chatbot-drag-handle",
        className: "z-50 b-0 r-0",
        style: {
          position: "absolute",
          opacity: e ? 1 : 0,
          visibility: e ? "visible" : "hidden",
          pointerEvents: e ? "auto" : "none"
        },
        children: /* @__PURE__ */ v.jsx("div", { className: "w-full h-full rounded-2xl shadow-xl border backdrop-blur-md flex flex-col bg-background overflow-hidden z-[1000]", children: /* @__PURE__ */ v.jsx(
          TLe,
          {
            onClose: () => {
              t(!1), u.value = {};
            },
            threadId: c.currentThreadId.value || ""
          }
        ) })
      }
    ),
    !e && /* @__PURE__ */ v.jsx(
      "button",
      {
        onClick: () => t(!0),
        className: "fixed bottom-4 right-4 z-50 cursor-pointer p-3 rounded-full border-2 shadow-sm bg-background hover:bg-core-navy-60 hover:shadow-2xl transition-all",
        children: /* @__PURE__ */ v.jsx(cA, { className: "h-6 w-6" })
      }
    )
  ] });
}, e5e = C.memo(QLe);
var Ff = /* @__PURE__ */ ((e) => (e.Visualization = "visualization", e.WebSearch = "webSearch", e.Http = "http", e.Code = "code", e.FileSearch = "fileSearch", e))(Ff || {});
class t5e {
  /**
   *
   */
  constructor(t) {
    this.appStore = t;
  }
  /**
   * Indicates whether the chatbot server is available and ready to use
   */
  chatbotReady = Qe(!1);
  /**
   * 
   */
  threadReady = Qe(!1);
  /**
   * Define loading state for thread operations
   */
  isLoadingThread = Qe(!1);
  /**
   *
   */
  threadList = Qe([]);
  /**
   *
   */
  agentList = Qe([]);
  /**
   *
   */
  workflowToolList = Qe([]);
  /**
   *
   */
  currentThreadId = Qe(null);
  /**
   *
   */
  toolChoice = Qe("auto");
  /**
   *
   */
  allowedMcpServers = Qe(void 0);
  /**
   *
   */
  allowedAppDefaultToolkit = Qe([
    Ff.Visualization,
    Ff.WebSearch,
    Ff.Http,
    Ff.Code,
    Ff.FileSearch
  ]);
  /**
   *
   */
  generatingTitleThreadIds = Qe([]);
  /**
   *
   */
  archiveList = Qe([]);
  /**
   * 
   */
  threadMessages = Qe({});
  /**
   * 
   */
  isNewThread = Qe(!1);
  /**
   * Define state of AI is thinking and answering
   */
  isAIThinking = Qe(!1);
  /**
   * Flag for using next suggestion
   */
  useNextSuggestion = Qe(!1);
  /**
   *
   */
  toolPresets = Qe([]);
  /**
   *
   */
  chatModel = Qe(void 0);
  /**
   *
   */
  openShortcutsPopup = Qe(!1);
  /**
   *
   */
  openChatPreferences = Qe(!1);
  /**
   *
   */
  mcpCustomizationPopup = Qe(void 0);
  /**
   *
   */
  temporaryChat = Qe({
    isOpen: !1,
    instructions: "",
    chatModel: void 0
  });
  /**
   *
   */
  pendingThreadMention = Qe(void 0);
  /**
   * Store threads that are currently generating titles
   */
  storeThreads = Qe([]);
  /**
  * stop stream for chatbot
  */
  isStopStream = Qe(!1);
  /**
   * AbortController to cancel pending fetch requests
   */
  abortController = null;
  /**
   * Track active timeouts for cleanup
   */
  activeTimeouts = /* @__PURE__ */ new Set();
  /**
   * Timeout for retry ChatbotConfig
   */
  retryConfigTimeout = null;
  /**
   * Track number of connection attempts
   */
  connectionAttempts = 0;
  /**
   * Maximum connection attempts before giving up
   */
  MAX_CONNECTION_ATTEMPTS = 5;
  /**
   * Cleanup all active operations (for unmount scenarios)
   */
  cleanup = () => {
    this.abortController && (this.abortController.abort(), this.abortController = null), this.retryConfigTimeout && (clearTimeout(this.retryConfigTimeout), this.retryConfigTimeout = null), this.activeTimeouts.forEach((t) => {
      clearTimeout(t);
    }), this.activeTimeouts.clear();
  };
  /**
   * Checks the readiness of the chatbot server and updates the status variable.
   *
   * This method performs a health check to the chatbot server (using checkChatbotServer),
   * updates the chatbotReady variable based on the result, and logs the current status to the console.
   * If the server is not available, some chatbot features will be disabled.
   * If failed, it will retry after 5 seconds automatically.
   */
  ChatbotConfig = async () => {
    console.log("chatbot loading...");
    try {
      if (this.chatbotReady.value = await this.checkChatbotServer(), this.chatbotReady.value)
        console.log(" Chatbot is Ready! "), this.connectionAttempts = 0, this.retryConfigTimeout && (clearTimeout(this.retryConfigTimeout), this.retryConfigTimeout = null);
      else {
        if (this.connectionAttempts >= this.MAX_CONNECTION_ATTEMPTS) {
          console.error(` Chatbot connection failed after ${this.MAX_CONNECTION_ATTEMPTS} attempts. Giving up.`), Vt.error(`Unable to connect to chatbot server after ${this.MAX_CONNECTION_ATTEMPTS} attempts.`);
          return;
        }
        this.connectionAttempts++, console.log(` Chatbot is not available. Retrying ${this.connectionAttempts}/${this.MAX_CONNECTION_ATTEMPTS}...`), Vt.info(` Chatbot server unavailable. Reconnecting (${this.connectionAttempts}/${this.MAX_CONNECTION_ATTEMPTS})...`), this.retryConfigTimeout = setTimeout(() => {
          this.ChatbotConfig();
        }, 5e3), this.activeTimeouts.add(this.retryConfigTimeout);
      }
    } catch (t) {
      if (this.chatbotReady.value = !1, this.connectionAttempts >= this.MAX_CONNECTION_ATTEMPTS) {
        console.error(` Chatbot connection failed after ${this.MAX_CONNECTION_ATTEMPTS} attempts. Giving up.`), Vt.error(`Failed to initialize chatbot after ${this.MAX_CONNECTION_ATTEMPTS} attempts.`);
        return;
      }
      this.connectionAttempts++, Vt.info(`Reconnecting ${this.connectionAttempts}/${this.MAX_CONNECTION_ATTEMPTS}...`), console.error("Chatbot config error:", t), this.retryConfigTimeout = setTimeout(() => {
        this.ChatbotConfig();
      }, 5e3), this.activeTimeouts.add(this.retryConfigTimeout);
    }
  };
  /**
   * 
   */
  ChatbotThreadConfig = async () => {
    if (!this.chatbotReady.value) {
      console.warn("Chatbot is not ready. Cannot configure thread.");
      return;
    }
    const t = this.currentThreadId.value;
    if (!t) {
      console.warn("No threadId set. Cannot configure thread.");
      return;
    }
    if (ld(t)) {
      this.threadMessages.value = { [t]: [] }, this.threadReady.value = !0, this.isNewThread.value = !0;
      return;
    }
    const n = 3;
    let r = 0;
    for (; r < n; ) {
      try {
        console.log(` Thread Check Attempt ${r + 1}...`);
        const i = await Sj(t);
        if (i) {
          this.threadMessages.value = { [t]: i.messages || [] }, this.currentThreadId.value = i.id, this.threadReady.value = !0, this.isNewThread.value = !i.messages?.length, console.log(" Thread Ready!");
          return;
        } else
          this.threadMessages.value = { [t]: [] }, this.isNewThread.value = !0, console.warn(`Thread ${t} not found.`);
        r++;
      } catch (i) {
        this.threadMessages.value = { [t]: [] }, this.isNewThread.value = !0, this.threadReady.value = !0, r === n - 1 && Vt.error("Failed to load thread. Using empty thread."), console.error("Thread config error:", i), r++;
      }
      if (r < n) {
        const i = setTimeout(() => {
          this.activeTimeouts.delete(i);
        }, 2e3);
        this.activeTimeouts.add(i), await new Promise((o) => setTimeout(o, 2e3));
      }
    }
  };
  /**
   * Load all threads for the user
   */
  loadThreadList = async () => {
    try {
      const t = await HM();
      return this.threadList.value = t || [], t;
    } catch (t) {
      return console.error("Failed to load thread list:", t), Vt.error("Failed to load conversation history."), this.threadList.value = [], [];
    }
  };
  /**
   * Create a new thread (only when first message is sent)
   */
  createThread = async (t) => {
    try {
      const n = await zpe(t);
      return n && (this.threadList.value = [n, ...this.threadList.value], this.currentThreadId.value = n.id, this.isNewThread.value = !0), n;
    } catch (n) {
      throw console.error("Failed to create new thread:", n), Vt.error("Failed to create new conversation. Please try again."), n;
    }
  };
  /**
   * Set temporary thread as current
   */
  setTempThread = (t) => {
    this.currentThreadId.value = t, this.isNewThread.value = !0, this.threadMessages.value = { [t]: [] }, this.threadReady.value = !0;
  };
  /**
   * Fetch messages for a specific thread and update the store
   */
  fetchMessagesForThread = async (t) => {
    try {
      if (ld(t)) {
        this.threadMessages.value = {
          ...this.threadMessages.value,
          [t]: this.threadMessages.value[t] || []
        }, this.isLoadingThread.value = !1;
        return;
      }
      const n = await Sj(t);
      this.threadMessages.value = {
        ...this.threadMessages.value,
        [t]: n.messages || []
      }, this.currentThreadId.value = t, this.threadReady.value = !0, this.isLoadingThread.value = !1, this.isNewThread.value = !1;
    } catch (n) {
      throw console.error("Failed to fetch messages for thread:", t, n), Vt.error("Failed to load messages. Please try again."), this.threadMessages.value = {
        ...this.threadMessages.value,
        [t]: []
      }, n;
    }
  };
  /**
   * Health check for chatbot server (single attempt only, retry logic is in ChatbotConfig)
   */
  checkChatbotServer = async () => {
    if (!R_) return !1;
    let n = null;
    try {
      this.abortController?.abort();
      const r = new AbortController();
      this.abortController = r, n = setTimeout(() => {
        r.abort();
      }, 2e3), this.activeTimeouts.add(n);
      const i = await fetch(`${R_}`, {
        signal: r.signal,
        cache: "no-store"
      });
      if (!i.ok) throw new Error(`Server returned ${i.status}`);
      return !0;
    } catch (r) {
      return r instanceof Error && r.name === "AbortError" || console.error(" Chatbot Health Check Failed:", r), !1;
    } finally {
      n && (clearTimeout(n), this.activeTimeouts.delete(n));
    }
  };
  /**
   * 
   */
  // public onUpdateBrickClasses = (brickClasses : Record<string, IBrickClass>) => {
  //   // No-op for now
  // }
  dispose = () => {
    this.cleanup(), this.threadMessages.value = {}, this.threadList.value = [], this.storeThreads.value = [], this.agentList.value = [], this.workflowToolList.value = [], this.currentThreadId.value = null, this.toolChoice.value = "auto", this.allowedMcpServers.value = void 0, this.allowedAppDefaultToolkit.value = [], this.generatingTitleThreadIds.value = [], this.archiveList.value = [], this.toolPresets.value = [], this.chatModel.value = void 0, this.openShortcutsPopup.value = !1, this.openChatPreferences.value = !1, this.mcpCustomizationPopup.value = void 0, this.temporaryChat.value = {
      isOpen: !1,
      instructions: "",
      chatModel: void 0
    }, this.pendingThreadMention.value = void 0, this.chatbotReady.value = !1, this.threadReady.value = !1, this.isNewThread.value = !1, this.isLoadingThread.value = !1, this.isAIThinking.value = !1, this.useNextSuggestion.value = !1, this.connectionAttempts = 0, this.isStopStream.value = !1, console.log(" ChatbotStore disposed and memory cleaned up");
  };
}
var Ug, ZG;
function n5e(e) {
  return e.children;
}
Ug = { __e: function(e, t, n, r) {
  for (var i, o, s; t = t.__; ) if ((i = t.__c) && !i.__) try {
    if ((o = i.constructor) && o.getDerivedStateFromError != null && (i.setState(o.getDerivedStateFromError(e)), s = i.__d), i.componentDidCatch != null && (i.componentDidCatch(e, r || {}), s = i.__d), s) return i.__E = i;
  } catch (a) {
    e = a;
  }
  throw e;
} }, ZG = function(e) {
  return e != null && e.constructor === void 0;
}, typeof Promise == "function" && Promise.prototype.then.bind(Promise.resolve());
var sA, po, UE, Z3, Y3 = 0, YG = [], Pr = Ug, X3 = Pr.__b, J3 = Pr.__r, Q3 = Pr.diffed, e4 = Pr.__c, t4 = Pr.unmount, n4 = Pr.__;
function r5e(e, t) {
  Pr.__h && Pr.__h(po, e, Y3 || t), Y3 = 0;
  var n = po.__H || (po.__H = { __: [], __h: [] });
  return e >= n.__.length && n.__.push({}), n.__[e];
}
function XG(e, t) {
  var n = r5e(sA++, 7);
  return s5e(n.__H, t) && (n.__ = e(), n.__H = t, n.__h = e), n.__;
}
function i5e() {
  for (var e; e = YG.shift(); ) if (e.__P && e.__H) try {
    e.__H.__h.forEach(lb), e.__H.__h.forEach(aA), e.__H.__h = [];
  } catch (t) {
    e.__H.__h = [], Pr.__e(t, e.__v);
  }
}
Pr.__b = function(e) {
  po = null, X3 && X3(e);
}, Pr.__ = function(e, t) {
  e && t.__k && t.__k.__m && (e.__m = t.__k.__m), n4 && n4(e, t);
}, Pr.__r = function(e) {
  J3 && J3(e), sA = 0;
  var t = (po = e.__c).__H;
  t && (UE === po ? (t.__h = [], po.__h = [], t.__.forEach(function(n) {
    n.__N && (n.__ = n.__N), n.u = n.__N = void 0;
  })) : (t.__h.forEach(lb), t.__h.forEach(aA), t.__h = [], sA = 0)), UE = po;
}, Pr.diffed = function(e) {
  Q3 && Q3(e);
  var t = e.__c;
  t && t.__H && (t.__H.__h.length && (YG.push(t) !== 1 && Z3 === Pr.requestAnimationFrame || ((Z3 = Pr.requestAnimationFrame) || o5e)(i5e)), t.__H.__.forEach(function(n) {
    n.u && (n.__H = n.u), n.u = void 0;
  })), UE = po = null;
}, Pr.__c = function(e, t) {
  t.some(function(n) {
    try {
      n.__h.forEach(lb), n.__h = n.__h.filter(function(r) {
        return !r.__ || aA(r);
      });
    } catch (r) {
      t.some(function(i) {
        i.__h && (i.__h = []);
      }), t = [], Pr.__e(r, n.__v);
    }
  }), e4 && e4(e, t);
}, Pr.unmount = function(e) {
  t4 && t4(e);
  var t, n = e.__c;
  n && n.__H && (n.__H.__.forEach(function(r) {
    try {
      lb(r);
    } catch (i) {
      t = i;
    }
  }), n.__H = void 0, t && Pr.__e(t, n.__v));
};
var r4 = typeof requestAnimationFrame == "function";
function o5e(e) {
  var t, n = function() {
    clearTimeout(r), r4 && cancelAnimationFrame(t), setTimeout(e);
  }, r = setTimeout(n, 35);
  r4 && (t = requestAnimationFrame(n));
}
function lb(e) {
  var t = po, n = e.__c;
  typeof n == "function" && (e.__c = void 0, n()), po = t;
}
function aA(e) {
  var t = po;
  e.__c = e.__(), po = t;
}
function s5e(e, t) {
  return !e || e.length !== t.length || t.some(function(n, r) {
    return n !== e[r];
  });
}
var JG, FE, a5e = typeof window < "u" && !!window.__PREACT_SIGNALS_DEVTOOLS__, QG = [];
vd(function() {
  JG = this.N;
})();
function np(e, t) {
  Ug[e] = t.bind(null, Ug[e] || function() {
  });
}
function ew(e) {
  FE && FE(), FE = e && e.S();
}
function eK(e) {
  var t = this, n = e.data, r = c5e(n);
  r.value = n;
  var i = XG(function() {
    for (var a = t, c = t.__v; c = c.__; ) if (c.__c) {
      c.__c.__$f |= 4;
      break;
    }
    var u = IP(function() {
      var g = r.value.value;
      return g === 0 ? 0 : g === !0 ? "" : g || "";
    }), f = IP(function() {
      return !Array.isArray(u.value) && !ZG(u.value);
    }), h = vd(function() {
      if (this.N = tK, f.value) {
        var g = u.value;
        a.__v && a.__v.__e && a.__v.__e.nodeType === 3 && (a.__v.__e.data = g);
      }
    }), m = t.__$u.d;
    return t.__$u.d = function() {
      h(), m.call(this);
    }, [f, u];
  }, []), o = i[0], s = i[1];
  return o.value ? s.peek() : s.value;
}
eK.displayName = "ReactiveTextNode";
Object.defineProperties(Kr.prototype, { constructor: { configurable: !0, value: void 0 }, type: { configurable: !0, value: eK }, props: { configurable: !0, get: function() {
  return { data: this };
} }, __b: { configurable: !0, value: 1 } });
np("__b", function(e, t) {
  if (typeof t.type == "string") {
    var n, r = t.props;
    for (var i in r) if (i !== "children") {
      var o = r[i];
      o instanceof Kr && (n || (t.__np = n = {}), n[i] = o, r[i] = o.peek());
    }
  }
  e(t);
});
np("__r", function(e, t) {
  if (t.type !== n5e) {
    ew();
    var n, r = t.__c;
    r && (r.__$f &= -2, (n = r.__$u) === void 0 && (r.__$u = n = (function(i, o) {
      var s;
      return vd(function() {
        s = this;
      }, { name: o }), s.c = i, s;
    })(function() {
      var i;
      a5e && ((i = n.y) == null || i.call(n)), r.__$f |= 1, r.setState({});
    }, typeof t.type == "function" ? t.type.displayName || t.type.name : ""))), ew(n);
  }
  e(t);
});
np("__e", function(e, t, n, r) {
  ew(), e(t, n, r);
});
np("diffed", function(e, t) {
  ew();
  var n;
  if (typeof t.type == "string" && (n = t.__e)) {
    var r = t.__np, i = t.props;
    if (r) {
      var o = n.U;
      if (o) for (var s in o) {
        var a = o[s];
        a !== void 0 && !(s in r) && (a.d(), o[s] = void 0);
      }
      else
        o = {}, n.U = o;
      for (var c in r) {
        var u = o[c], f = r[c];
        u === void 0 ? (u = l5e(n, c, f, i), o[c] = u) : u.o(f, i);
      }
    }
  }
  e(t);
});
function l5e(e, t, n, r) {
  var i = t in e && e.ownerSVGElement === void 0, o = Qe(n);
  return { o: function(s, a) {
    o.value = s, r = a;
  }, d: vd(function() {
    this.N = tK;
    var s = o.value.value;
    r[t] !== s && (r[t] = s, i ? e[t] = s : s != null && (s !== !1 || t[4] === "-") ? e.setAttribute(t, s) : e.removeAttribute(t));
  }) };
}
np("unmount", function(e, t) {
  if (typeof t.type == "string") {
    var n = t.__e;
    if (n) {
      var r = n.U;
      if (r) {
        n.U = void 0;
        for (var i in r) {
          var o = r[i];
          o && o.d();
        }
      }
    }
  } else {
    var s = t.__c;
    if (s) {
      var a = s.__$u;
      a && (s.__$u = void 0, a.d());
    }
  }
  e(t);
});
np("__h", function(e, t, n, r) {
  (r < 3 || r === 9) && (t.__$f |= 2), e(t, n, r);
});
function c5e(e, t) {
  return XG(function() {
    return Qe(e, t);
  }, []);
}
var u5e = function(e) {
  queueMicrotask(function() {
    queueMicrotask(e);
  });
};
function d5e() {
  OZ(function() {
    for (var e; e = QG.shift(); ) JG.call(e);
  });
}
function tK() {
  QG.push(this) === 1 && (Ug.requestAnimationFrame || u5e)(d5e);
}
class f5e {
  constructor(t) {
    this.appStore = t;
  }
  // store mentions per thread id
  threadMentions = Qe({});
  /**
   * Append a mention to a specific thread (or current thread via appStore.chatbotStore.currentThreadId)
   */
  addThreadMention = (t, n) => {
    const r = n ?? this.appStore?.chatbotStore.currentThreadId.value;
    if (!r) return;
    const i = this.threadMentions.value[r] ?? [];
    this.threadMentions.value = { ...this.threadMentions.value, [r]: [...i, t] };
  };
  /**
   * Remove the first mention matching `name` from the specified thread (or current thread).
   */
  removeThreadMention = (t, n) => {
    const r = n ?? this.appStore?.chatbotStore.currentThreadId.value;
    if (!r) return;
    const i = this.threadMentions.value[r] ?? [], o = i.findIndex((a) => a.name === t);
    if (o === -1) return;
    const s = [...i.slice(0, o), ...i.slice(o + 1)];
    this.threadMentions.value = { ...this.threadMentions.value, [r]: s };
  };
  dispose = () => {
    this.threadMentions.value = {};
  };
}
class h5e {
  worker = null;
  ready = Qe(!1);
  loading = Qe(!1);
  // Queue for requests made before worker is ready
  pendingRequests = [];
  // Callbacks for handling responses
  onServersLoaded;
  onServerRefreshed;
  onError;
  constructor() {
    this.initWorker();
  }
  /**
   * Initialize the worker
   */
  initWorker() {
    try {
      this.worker = new Worker(
        new URL(
          /* @vite-ignore */
          "/assets/mcp-loader.worker-DdkqmoSV.js",
          import.meta.url
        ),
        { type: "module" }
      ), this.worker.addEventListener("message", this.handleMessage), this.worker.addEventListener("error", this.handleError), console.log(" MCP Worker initialized");
    } catch (t) {
      console.error(" Failed to initialize MCP worker:", t), this.onError?.(t instanceof Error ? t.message : String(t));
    }
  }
  /**
   * Handle messages from worker
   */
  handleMessage = (t) => {
    const { type: n, payload: r, error: i } = t.data;
    switch (n) {
      case "READY":
        this.ready.value = !0, console.log(" MCP Worker ready"), this.processPendingRequests();
        break;
      case "MCP_SERVERS_LOADED":
        this.loading.value = !1, this.onServersLoaded?.(r);
        break;
      case "MCP_SERVER_REFRESHED":
        this.loading.value = !1, this.onServerRefreshed?.(r);
        break;
      case "ERROR":
        this.loading.value = !1, console.error("Worker error:", i), this.onError?.(i || "Unknown worker error");
        break;
      default:
        console.warn("Unknown worker response type:", n);
    }
  };
  /**
   * Handle worker errors
   */
  handleError = (t) => {
    console.error("MCP Worker error:", t.message), this.loading.value = !1, this.onError?.(t.message);
  };
  /**
   * Process queued requests after worker is ready
   */
  processPendingRequests() {
    if (!(!this.ready.value || !this.worker))
      for (; this.pendingRequests.length > 0; ) {
        const t = this.pendingRequests.shift();
        t && this.worker.postMessage(t);
      }
  }
  /**
   * Send message to worker (or queue if not ready)
   */
  sendMessage(t) {
    if (!this.worker) {
      console.error("Worker not initialized");
      return;
    }
    this.ready.value ? this.worker.postMessage(t) : this.pendingRequests.push(t);
  }
  /**
   * Load MCP servers in background
   */
  loadServers(t, n, r) {
    this.loading.value = !0, this.onServersLoaded = n, this.onError = r, this.sendMessage({
      type: "LOAD_MCP_SERVERS",
      payload: t
    });
  }
  /**
   * Refresh a specific MCP server
   */
  refreshServer(t, n, r) {
    this.loading.value = !0, this.onServerRefreshed = n, this.onError = r, this.sendMessage({
      type: "REFRESH_MCP_SERVER",
      payload: { serverId: t }
    });
  }
  /**
   * Get loading state
   */
  isLoading() {
    return this.loading.value;
  }
  /**
   * Check if worker is ready
   */
  isReady() {
    return this.ready.value;
  }
  /**
   * Cleanup worker
   */
  dispose() {
    this.worker && (this.worker.removeEventListener("message", this.handleMessage), this.worker.removeEventListener("error", this.handleError), this.worker.terminate(), this.worker = null), this.ready.value = !1, this.loading.value = !1, this.pendingRequests = [], console.log(" MCP Worker disposed");
  }
}
class p5e {
  constructor(t) {
    this.appStore = t, this.mcpWorker = new h5e();
  }
  mcpWorker;
  /**
   * store mcp-server list
   */
  mcpServerList = Qe([]);
  /**
   * 
   */
  allowedMcpServers = Qe(
    this.loadAllowedMcpServersFromStorage()
  );
  /**
   * Load allowedMcpServers t localStorage
   */
  loadAllowedMcpServersFromStorage() {
    try {
      const t = localStorage.getItem(vh.ALLOWED_MCP_SERVERS);
      if (t)
        return JSON.parse(t);
    } catch (t) {
      console.error("Failed to load allowedMcpServers from localStorage:", t);
    }
    return {};
  }
  /**
   * Load MCP servers using worker (non-blocking)
   */
  loadMcpServersInBackground = (t) => {
    this.mcpWorker.loadServers(
      t,
      (n) => {
        const r = new Set(n.map((s) => String(s.id)));
        this.mcpServerList.value = n;
        const i = this.allowedMcpServers.value || {}, o = Object.fromEntries(
          Object.entries(i).filter(([s]) => r.has(s))
        );
        this.allowedMcpServers.value = o, localStorage.setItem(vh.ALLOWED_MCP_SERVERS, JSON.stringify(o)), console.log(" MCP servers loaded in background:", n.length);
      },
      (n) => {
        console.error(" Failed to load MCP servers:", n);
      }
    );
  };
  /**
   * Refresh a specific MCP server using worker
   */
  refreshMcpServerInBackground = (t) => {
    this.mcpWorker.refreshServer(
      t,
      (n) => {
        console.log(" MCP server refreshed:", n), this.loadMcpServersInBackground();
      },
      (n) => {
        console.error(" Failed to refresh MCP server:", n);
      }
    );
  };
  /**
   * Check if worker is loading
   */
  isWorkerLoading = () => this.mcpWorker.isLoading();
  dispose = () => {
    this.mcpServerList.value = [], this.allowedMcpServers.value = {}, this.mcpWorker.dispose();
  };
}
var si = /* @__PURE__ */ ((e) => (e.AggregationFunction = "aggregationFunction", e.AmbientTemperatureOfMeasurement = "ambientTemperatureOfMeasurement", e.HasAmbientTemperature = "hasAmbientTemperature", e.HasQuantity = "hasQuantity", e.HasQUDTReference = "hasQUDTReference", e.ConnectedTo = "connectedTo", e.HasInputSubstance = "hasInputSubstance", e.HasOutputSubstance = "hasOutputSubstance", e.HasSubstance = "hasSubstance", e.Feeds = "feeds", e.IsFedBy = "isFedBy", e.IsLocationOf = "isLocationOf", e.HasLocation = "hasLocation", e.HasPart = "hasPart", e.IsPartOf = "isPartOf", e.HasPoint = "hasPoint", e.IsPointOf = "isPointOf", e.HasControl = "controls", e.IsControlledBy = "isControlledBy", e.Monitors = "monitors", e.IsMonitoredBy = "isMonitoredBy", e.Meters = "meters", e.IsMeteredBy = "isMeteredBy", e.Own = "own", e.IsOwnedBy = "isOwnedBy", e.HasTag = "hasTag", e.IsTagOf = "isTagOf", e.HasAssociatedTag = "hasAssociatedTag", e.IsAssociatedWith = "isAssociatedWith", e.AliasOf = "aliasOf", e.HasSubmeter = "hasSubmeter", e.IsSubmeterOf = "isSubmeterOf", e.HasUnit = "hasUnit", e.IsUnitOf = "isUnitOf", e.IsReplacedBy = "isReplacedBy", e.NoneInvert = "NoneInvert", e))(si || {});
class m5e {
  brickClasses = Qe({});
}
class g5e {
  creatingEntity = Qe(null);
  createEntity(t) {
    return {
      id: P9(),
      name: t.name ?? "Entity",
      classUri: t.classUri,
      tags: [],
      relationships: [],
      metadata: {},
      visible: !0
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  generateDefaultEntity(t) {
    t.metadata || (t.metadata = {}), t.relationships || (t.relationships = []), typeof t.visible != "boolean" && (t.visible = !0);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  onCreateEntityPoint = async (t, n) => this.createEntity(t);
}
const y5e = /* @__PURE__ */ new Set([
  si.Feeds,
  si.HasControl,
  si.Monitors,
  si.Meters
]), v5e = /* @__PURE__ */ new Set([
  si.IsFedBy,
  si.IsControlledBy,
  si.IsMonitoredBy,
  si.IsMeteredBy
]);
si.ConnectedTo;
si.ConnectedTo;
class b5e {
  entities = Qe({});
  allTags = Qe([]);
  brickClassManager = new m5e();
  eventManager = new g5e();
  raycastModel = {
    creatingEntity: Qe(null)
  };
  constructor(t) {
  }
  dispose() {
  }
}
class i4 {
  static set(t, n) {
    window.localStorage.setItem(t, JSON.stringify(n));
  }
  static get(t) {
    const n = localStorage.getItem(t);
    return n ? JSON.parse(n) : null;
  }
  static remove(t) {
    window.localStorage.removeItem(t);
  }
  static clear() {
    window.localStorage.clear();
  }
}
const o4 = {
  northPoleAtOrigin: !0,
  latitude: 0,
  longitude: 0,
  heading: 0,
  altitude: 0
}, s4 = new Set(
  [...y5e, ...v5e].filter(
    (e) => e !== si.IsLocationOf && e !== si.HasLocation && e !== si.NoneInvert
  )
), VE = {
  [ig.View3D]: /* @__PURE__ */ new Set([
    si.Feeds,
    si.IsFedBy,
    si.ConnectedTo
  ]),
  [ig.ViewGraph]: s4,
  [ig.ViewInspection]: s4
};
class tw {
  /**
   *
   */
  constructor(t) {
    this.editor = t;
    const n = i4.get(tw.storageKey);
    n && (this.settingRelationship.value = this.fromJsonVisibilitySettings(n)), vd(() => {
      i4.set(
        tw.storageKey,
        this.toJsonVisibilitySettings()
      );
    });
  }
  static storageKey = "twin-editor-settings";
  /**
   *
   */
  showPivot = Qe(!0);
  /**
   *
   */
  showGis = Qe(!1);
  /**
   *
   */
  showAtmosphereClouds = Qe(!1);
  /**
   *
   */
  showGisSettings = Qe(!1);
  /**
   *
   */
  gisInteractionEnabled = Qe(!1);
  /**
   * Live camera distance from world origin in meters
   */
  cameraDistanceMeters = Qe(0);
  /**
   * Function to navigate camera to globe origin (set by scene builder)
   */
  navigateToGlobeOrigin = null;
  /**
   *
   */
  showHierarchyPanel = Qe(!0);
  /**
   *
   */
  showInspectionPanel = Qe(!0);
  /**
   *
   */
  showSearchPanel = Qe(!1);
  /**
   *
   */
  showGeneralSetting = Qe(!1);
  /**
   *
   */
  showKeyboardPanel = Qe(!1);
  /**
   *
   */
  showFloorPlanPanel = Qe(!1);
  /**
   *
   */
  showWireFrameModel = Qe(!1);
  /**
   *
   */
  showRelationship3D = Qe(!1);
  /**
   *
   */
  showZone3D = Qe(!1);
  /**
   *
   */
  showComment = Qe(!1);
  /**
   *
   */
  showZoneIcon = Qe(!1);
  /**
   * If true, apply clipping planes to zones/assets as well as imported models
   */
  clipZones = Qe(!1);
  /**
   *
   */
  openLibraryPanel = Qe(!1);
  /**
   *
   */
  openSaveFileDialog = Qe(!1);
  /**
   *
   */
  gisControls = Qe(o4);
  /**
   *
   */
  hasChangeGisControl = Qe(!1);
  /**
   *
   */
  configViewerType = Qe("Digital Twin");
  /**
   *
   */
  configDataPoint = Qe(null);
  /**
   *
   */
  viewpointControl = Qe({
    Rotate: !0,
    Pan: !0,
    Zoom: !0
  });
  /**
   *
   */
  loadTileSet = Qe(!1);
  /**
   *
   */
  promptNanoAI = Qe(null);
  /**
   *
   */
  settingRelationship = Qe(VE);
  /**
   *
   */
  dispose = () => {
    this.showPivot.value = !0, this.showGis.value = !1, this.loadTileSet.value = !1, this.promptNanoAI.value = null, this.showAtmosphereClouds.value = !1, this.showGisSettings.value = !1, this.gisInteractionEnabled.value = !1, this.showHierarchyPanel.value = !0, this.showInspectionPanel.value = !0, this.showFloorPlanPanel.value = !1, this.showSearchPanel.value = !1, this.showGeneralSetting.value = !1, this.showKeyboardPanel.value = !1, this.showWireFrameModel.value = !1, this.showRelationship3D.value = !1, this.showZone3D.value = !1, this.showZoneIcon.value = !1, this.showComment.value = !1, this.clipZones.value = !1, this.openLibraryPanel.value = !1, this.openSaveFileDialog.value = !1, this.configViewerType.value = "Digital Twin", this.configDataPoint.value = null, this.gisControls.value = o4, this.hasChangeGisControl.value = !1, this.viewpointControl.value = {
      Rotate: !0,
      Pan: !0,
      Zoom: !0
    }, this.settingRelationship.value = VE;
  };
  onSaveFileSuccess;
  /**
   *
   * @returns
   */
  toJsonVisibilitySettings = () => {
    const t = {};
    for (const n in this.settingRelationship.value) {
      const r = this.settingRelationship.value[n];
      t[n] = Array.from(r);
    }
    return t;
  };
  /**
   *
   * @returns
   */
  fromJsonVisibilitySettings = (t) => {
    const n = VE, r = new Set(
      Object.values(ig)
    );
    for (const i of r) {
      const o = t[i];
      n[i] = o ? new Set(Array.from(o)) : /* @__PURE__ */ new Set();
    }
    return n;
  };
}
class x5e {
  /**
   *
   */
  constructor(t) {
    this.appStore = t;
  }
  /**
   *
   */
  models = new b5e(this);
  /**
   *
   */
  setting = new tw(this);
  /**
   *
   */
  dispose = () => {
    this.setting.dispose(), this.models.dispose();
  };
}
class w5e {
  /**
   * appReady boolean detect app ready
   */
  appReady = Qe(!1);
  /**
   *
   */
  appError = Qe("");
  /**
   *
   */
  chatbotStore = new t5e(this);
  /**
   *
   */
  chatbotThreadStore = new f5e(this);
  /**
   * To manage mcp-server state
   */
  chatbotServerStore = new p5e(this);
  /**
   * Reactive signal to track real-time server status during runtime
   */
  isServerOnline = Qe(!0);
  /**
   * Store to manage editor and viewer state
   */
  editorViewerStore = new x5e(this);
  dispose = () => {
    this.chatbotStore.dispose(), this.chatbotServerStore.dispose(), this.chatbotThreadStore.dispose(), this.editorViewerStore.dispose();
  };
}
let Fa = null, Va = null;
const S5e = {
  init(e) {
    if (!e.apiHost) {
      console.error("ChatbotEmbed: apiHost is required");
      return;
    }
    const t = e.containerId || "chatbot-root";
    let n = document.getElementById(t);
    return n || (n = document.createElement("div"), n.id = t, document.body.appendChild(n)), window.__CHATBOT_CONFIG__ = e, Vle(e.apiHost), Va || (Va = new w5e()), Fa || (Fa = AZ.createRoot(n)), Fa.render(
      Ne.createElement(
        Ne.StrictMode,
        null,
        Ne.createElement(
          nce,
          { appStore: Va, children: Ne.createElement(e5e) }
        )
      )
    ), {
      destroy: () => {
        Fa && (Fa.unmount(), Fa = null), Va && (Va.dispose(), Va = null), n && n.parentNode && n.parentNode.removeChild(n);
      }
    };
  },
  destroy() {
    Fa && (Fa.unmount(), Fa = null), Va && (Va.dispose(), Va = null);
  }
};
typeof window < "u" && (window.ChatbotEmbed = S5e);
export {
  q9 as C,
  LMe as J,
  dA as L,
  Ne as R,
  G9 as a,
  Oce as b,
  Pce as c,
  K9 as d,
  E5e as e,
  bc as f,
  _5e as g,
  Bc as h,
  xZ as i,
  v as j,
  WG as k,
  vIe as l,
  lt as m,
  S5e as n,
  C as r
};
