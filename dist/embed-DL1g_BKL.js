function DK(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in e)) {
          const o = Object.getOwnPropertyDescriptor(r, i);
          o && Object.defineProperty(e, i, o.get ? o : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var PK = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Dc(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function jK(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      var i = !1;
      try {
        i = this instanceof r;
      } catch {
      }
      return i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var sk = { exports: {} }, At = {};
var oD;
function IK() {
  if (oD) return At;
  oD = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), i = /* @__PURE__ */ Symbol.for("react.profiler"), o = /* @__PURE__ */ Symbol.for("react.consumer"), s = /* @__PURE__ */ Symbol.for("react.context"), a = /* @__PURE__ */ Symbol.for("react.forward_ref"), c = /* @__PURE__ */ Symbol.for("react.suspense"), u = /* @__PURE__ */ Symbol.for("react.memo"), f = /* @__PURE__ */ Symbol.for("react.lazy"), h = /* @__PURE__ */ Symbol.for("react.activity"), m = Symbol.iterator;
  function g(Z) {
    return Z === null || typeof Z != "object" ? null : (Z = m && Z[m] || Z["@@iterator"], typeof Z == "function" ? Z : null);
  }
  var b = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, x = Object.assign, w = {};
  function S(Z, pe, F) {
    this.props = Z, this.context = pe, this.refs = w, this.updater = F || b;
  }
  S.prototype.isReactComponent = {}, S.prototype.setState = function(Z, pe) {
    if (typeof Z != "object" && typeof Z != "function" && Z != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, Z, pe, "setState");
  }, S.prototype.forceUpdate = function(Z) {
    this.updater.enqueueForceUpdate(this, Z, "forceUpdate");
  };
  function _() {
  }
  _.prototype = S.prototype;
  function M(Z, pe, F) {
    this.props = Z, this.context = pe, this.refs = w, this.updater = F || b;
  }
  var N = M.prototype = new _();
  N.constructor = M, x(N, S.prototype), N.isPureReactComponent = !0;
  var P = Array.isArray;
  function I() {
  }
  var O = { H: null, A: null, T: null, S: null }, L = Object.prototype.hasOwnProperty;
  function U(Z, pe, F) {
    var ee = F.ref;
    return {
      $$typeof: e,
      type: Z,
      key: pe,
      ref: ee !== void 0 ? ee : null,
      props: F
    };
  }
  function B(Z, pe) {
    return U(Z.type, pe, Z.props);
  }
  function G(Z) {
    return typeof Z == "object" && Z !== null && Z.$$typeof === e;
  }
  function Y(Z) {
    var pe = { "=": "=0", ":": "=2" };
    return "$" + Z.replace(/[=:]/g, function(F) {
      return pe[F];
    });
  }
  var he = /\/+/g;
  function ie(Z, pe) {
    return typeof Z == "object" && Z !== null && Z.key != null ? Y("" + Z.key) : pe.toString(36);
  }
  function ne(Z) {
    switch (Z.status) {
      case "fulfilled":
        return Z.value;
      case "rejected":
        throw Z.reason;
      default:
        switch (typeof Z.status == "string" ? Z.then(I, I) : (Z.status = "pending", Z.then(
          function(pe) {
            Z.status === "pending" && (Z.status = "fulfilled", Z.value = pe);
          },
          function(pe) {
            Z.status === "pending" && (Z.status = "rejected", Z.reason = pe);
          }
        )), Z.status) {
          case "fulfilled":
            return Z.value;
          case "rejected":
            throw Z.reason;
        }
    }
    throw Z;
  }
  function H(Z, pe, F, ee, ge) {
    var re = typeof Z;
    (re === "undefined" || re === "boolean") && (Z = null);
    var J = !1;
    if (Z === null) J = !0;
    else
      switch (re) {
        case "bigint":
        case "string":
        case "number":
          J = !0;
          break;
        case "object":
          switch (Z.$$typeof) {
            case e:
            case t:
              J = !0;
              break;
            case f:
              return J = Z._init, H(
                J(Z._payload),
                pe,
                F,
                ee,
                ge
              );
          }
      }
    if (J)
      return ge = ge(Z), J = ee === "" ? "." + ie(Z, 0) : ee, P(ge) ? (F = "", J != null && (F = J.replace(he, "$&/") + "/"), H(ge, pe, F, "", function(Ae) {
        return Ae;
      })) : ge != null && (G(ge) && (ge = B(
        ge,
        F + (ge.key == null || Z && Z.key === ge.key ? "" : ("" + ge.key).replace(
          he,
          "$&/"
        ) + "/") + J
      )), pe.push(ge)), 1;
    J = 0;
    var xe = ee === "" ? "." : ee + ":";
    if (P(Z))
      for (var be = 0; be < Z.length; be++)
        ee = Z[be], re = xe + ie(ee, be), J += H(
          ee,
          pe,
          F,
          re,
          ge
        );
    else if (be = g(Z), typeof be == "function")
      for (Z = be.call(Z), be = 0; !(ee = Z.next()).done; )
        ee = ee.value, re = xe + ie(ee, be++), J += H(
          ee,
          pe,
          F,
          re,
          ge
        );
    else if (re === "object") {
      if (typeof Z.then == "function")
        return H(
          ne(Z),
          pe,
          F,
          ee,
          ge
        );
      throw pe = String(Z), Error(
        "Objects are not valid as a React child (found: " + (pe === "[object Object]" ? "object with keys {" + Object.keys(Z).join(", ") + "}" : pe) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return J;
  }
  function Q(Z, pe, F) {
    if (Z == null) return Z;
    var ee = [], ge = 0;
    return H(Z, ee, "", "", function(re) {
      return pe.call(F, re, ge++);
    }), ee;
  }
  function X(Z) {
    if (Z._status === -1) {
      var pe = Z._result;
      pe = pe(), pe.then(
        function(F) {
          (Z._status === 0 || Z._status === -1) && (Z._status = 1, Z._result = F);
        },
        function(F) {
          (Z._status === 0 || Z._status === -1) && (Z._status = 2, Z._result = F);
        }
      ), Z._status === -1 && (Z._status = 0, Z._result = pe);
    }
    if (Z._status === 1) return Z._result.default;
    throw Z._result;
  }
  var Se = typeof reportError == "function" ? reportError : function(Z) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var pe = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof Z == "object" && Z !== null && typeof Z.message == "string" ? String(Z.message) : String(Z),
        error: Z
      });
      if (!window.dispatchEvent(pe)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", Z);
      return;
    }
    console.error(Z);
  }, W = {
    map: Q,
    forEach: function(Z, pe, F) {
      Q(
        Z,
        function() {
          pe.apply(this, arguments);
        },
        F
      );
    },
    count: function(Z) {
      var pe = 0;
      return Q(Z, function() {
        pe++;
      }), pe;
    },
    toArray: function(Z) {
      return Q(Z, function(pe) {
        return pe;
      }) || [];
    },
    only: function(Z) {
      if (!G(Z))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return Z;
    }
  };
  return At.Activity = h, At.Children = W, At.Component = S, At.Fragment = n, At.Profiler = i, At.PureComponent = M, At.StrictMode = r, At.Suspense = c, At.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = O, At.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(Z) {
      return O.H.useMemoCache(Z);
    }
  }, At.cache = function(Z) {
    return function() {
      return Z.apply(null, arguments);
    };
  }, At.cacheSignal = function() {
    return null;
  }, At.cloneElement = function(Z, pe, F) {
    if (Z == null)
      throw Error(
        "The argument must be a React element, but you passed " + Z + "."
      );
    var ee = x({}, Z.props), ge = Z.key;
    if (pe != null)
      for (re in pe.key !== void 0 && (ge = "" + pe.key), pe)
        !L.call(pe, re) || re === "key" || re === "__self" || re === "__source" || re === "ref" && pe.ref === void 0 || (ee[re] = pe[re]);
    var re = arguments.length - 2;
    if (re === 1) ee.children = F;
    else if (1 < re) {
      for (var J = Array(re), xe = 0; xe < re; xe++)
        J[xe] = arguments[xe + 2];
      ee.children = J;
    }
    return U(Z.type, ge, ee);
  }, At.createContext = function(Z) {
    return Z = {
      $$typeof: s,
      _currentValue: Z,
      _currentValue2: Z,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, Z.Provider = Z, Z.Consumer = {
      $$typeof: o,
      _context: Z
    }, Z;
  }, At.createElement = function(Z, pe, F) {
    var ee, ge = {}, re = null;
    if (pe != null)
      for (ee in pe.key !== void 0 && (re = "" + pe.key), pe)
        L.call(pe, ee) && ee !== "key" && ee !== "__self" && ee !== "__source" && (ge[ee] = pe[ee]);
    var J = arguments.length - 2;
    if (J === 1) ge.children = F;
    else if (1 < J) {
      for (var xe = Array(J), be = 0; be < J; be++)
        xe[be] = arguments[be + 2];
      ge.children = xe;
    }
    if (Z && Z.defaultProps)
      for (ee in J = Z.defaultProps, J)
        ge[ee] === void 0 && (ge[ee] = J[ee]);
    return U(Z, re, ge);
  }, At.createRef = function() {
    return { current: null };
  }, At.forwardRef = function(Z) {
    return { $$typeof: a, render: Z };
  }, At.isValidElement = G, At.lazy = function(Z) {
    return {
      $$typeof: f,
      _payload: { _status: -1, _result: Z },
      _init: X
    };
  }, At.memo = function(Z, pe) {
    return {
      $$typeof: u,
      type: Z,
      compare: pe === void 0 ? null : pe
    };
  }, At.startTransition = function(Z) {
    var pe = O.T, F = {};
    O.T = F;
    try {
      var ee = Z(), ge = O.S;
      ge !== null && ge(F, ee), typeof ee == "object" && ee !== null && typeof ee.then == "function" && ee.then(I, Se);
    } catch (re) {
      Se(re);
    } finally {
      pe !== null && F.types !== null && (pe.types = F.types), O.T = pe;
    }
  }, At.unstable_useCacheRefresh = function() {
    return O.H.useCacheRefresh();
  }, At.use = function(Z) {
    return O.H.use(Z);
  }, At.useActionState = function(Z, pe, F) {
    return O.H.useActionState(Z, pe, F);
  }, At.useCallback = function(Z, pe) {
    return O.H.useCallback(Z, pe);
  }, At.useContext = function(Z) {
    return O.H.useContext(Z);
  }, At.useDebugValue = function() {
  }, At.useDeferredValue = function(Z, pe) {
    return O.H.useDeferredValue(Z, pe);
  }, At.useEffect = function(Z, pe) {
    return O.H.useEffect(Z, pe);
  }, At.useEffectEvent = function(Z) {
    return O.H.useEffectEvent(Z);
  }, At.useId = function() {
    return O.H.useId();
  }, At.useImperativeHandle = function(Z, pe, F) {
    return O.H.useImperativeHandle(Z, pe, F);
  }, At.useInsertionEffect = function(Z, pe) {
    return O.H.useInsertionEffect(Z, pe);
  }, At.useLayoutEffect = function(Z, pe) {
    return O.H.useLayoutEffect(Z, pe);
  }, At.useMemo = function(Z, pe) {
    return O.H.useMemo(Z, pe);
  }, At.useOptimistic = function(Z, pe) {
    return O.H.useOptimistic(Z, pe);
  }, At.useReducer = function(Z, pe, F) {
    return O.H.useReducer(Z, pe, F);
  }, At.useRef = function(Z) {
    return O.H.useRef(Z);
  }, At.useState = function(Z) {
    return O.H.useState(Z);
  }, At.useSyncExternalStore = function(Z, pe, F) {
    return O.H.useSyncExternalStore(
      Z,
      pe,
      F
    );
  }, At.useTransition = function() {
    return O.H.useTransition();
  }, At.version = "19.2.4", At;
}
var sD;
function cd() {
  return sD || (sD = 1, sk.exports = IK()), sk.exports;
}
var C = cd();
const Ne = /* @__PURE__ */ Dc(C), Fx = /* @__PURE__ */ DK({
  __proto__: null,
  default: Ne
}, [C]);
var ak = { exports: {} }, Wp = {}, lk = { exports: {} }, ck = {};
var aD;
function zK() {
  return aD || (aD = 1, (function(e) {
    function t(H, Q) {
      var X = H.length;
      H.push(Q);
      e: for (; 0 < X; ) {
        var Se = X - 1 >>> 1, W = H[Se];
        if (0 < i(W, Q))
          H[Se] = Q, H[X] = W, X = Se;
        else break e;
      }
    }
    function n(H) {
      return H.length === 0 ? null : H[0];
    }
    function r(H) {
      if (H.length === 0) return null;
      var Q = H[0], X = H.pop();
      if (X !== Q) {
        H[0] = X;
        e: for (var Se = 0, W = H.length, Z = W >>> 1; Se < Z; ) {
          var pe = 2 * (Se + 1) - 1, F = H[pe], ee = pe + 1, ge = H[ee];
          if (0 > i(F, X))
            ee < W && 0 > i(ge, F) ? (H[Se] = ge, H[ee] = X, Se = ee) : (H[Se] = F, H[pe] = X, Se = pe);
          else if (ee < W && 0 > i(ge, X))
            H[Se] = ge, H[ee] = X, Se = ee;
          else break e;
        }
      }
      return Q;
    }
    function i(H, Q) {
      var X = H.sortIndex - Q.sortIndex;
      return X !== 0 ? X : H.id - Q.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      e.unstable_now = function() {
        return o.now();
      };
    } else {
      var s = Date, a = s.now();
      e.unstable_now = function() {
        return s.now() - a;
      };
    }
    var c = [], u = [], f = 1, h = null, m = 3, g = !1, b = !1, x = !1, w = !1, S = typeof setTimeout == "function" ? setTimeout : null, _ = typeof clearTimeout == "function" ? clearTimeout : null, M = typeof setImmediate < "u" ? setImmediate : null;
    function N(H) {
      for (var Q = n(u); Q !== null; ) {
        if (Q.callback === null) r(u);
        else if (Q.startTime <= H)
          r(u), Q.sortIndex = Q.expirationTime, t(c, Q);
        else break;
        Q = n(u);
      }
    }
    function P(H) {
      if (x = !1, N(H), !b)
        if (n(c) !== null)
          b = !0, I || (I = !0, Y());
        else {
          var Q = n(u);
          Q !== null && ne(P, Q.startTime - H);
        }
    }
    var I = !1, O = -1, L = 5, U = -1;
    function B() {
      return w ? !0 : !(e.unstable_now() - U < L);
    }
    function G() {
      if (w = !1, I) {
        var H = e.unstable_now();
        U = H;
        var Q = !0;
        try {
          e: {
            b = !1, x && (x = !1, _(O), O = -1), g = !0;
            var X = m;
            try {
              t: {
                for (N(H), h = n(c); h !== null && !(h.expirationTime > H && B()); ) {
                  var Se = h.callback;
                  if (typeof Se == "function") {
                    h.callback = null, m = h.priorityLevel;
                    var W = Se(
                      h.expirationTime <= H
                    );
                    if (H = e.unstable_now(), typeof W == "function") {
                      h.callback = W, N(H), Q = !0;
                      break t;
                    }
                    h === n(c) && r(c), N(H);
                  } else r(c);
                  h = n(c);
                }
                if (h !== null) Q = !0;
                else {
                  var Z = n(u);
                  Z !== null && ne(
                    P,
                    Z.startTime - H
                  ), Q = !1;
                }
              }
              break e;
            } finally {
              h = null, m = X, g = !1;
            }
            Q = void 0;
          }
        } finally {
          Q ? Y() : I = !1;
        }
      }
    }
    var Y;
    if (typeof M == "function")
      Y = function() {
        M(G);
      };
    else if (typeof MessageChannel < "u") {
      var he = new MessageChannel(), ie = he.port2;
      he.port1.onmessage = G, Y = function() {
        ie.postMessage(null);
      };
    } else
      Y = function() {
        S(G, 0);
      };
    function ne(H, Q) {
      O = S(function() {
        H(e.unstable_now());
      }, Q);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(H) {
      H.callback = null;
    }, e.unstable_forceFrameRate = function(H) {
      0 > H || 125 < H ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : L = 0 < H ? Math.floor(1e3 / H) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return m;
    }, e.unstable_next = function(H) {
      switch (m) {
        case 1:
        case 2:
        case 3:
          var Q = 3;
          break;
        default:
          Q = m;
      }
      var X = m;
      m = Q;
      try {
        return H();
      } finally {
        m = X;
      }
    }, e.unstable_requestPaint = function() {
      w = !0;
    }, e.unstable_runWithPriority = function(H, Q) {
      switch (H) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          H = 3;
      }
      var X = m;
      m = H;
      try {
        return Q();
      } finally {
        m = X;
      }
    }, e.unstable_scheduleCallback = function(H, Q, X) {
      var Se = e.unstable_now();
      switch (typeof X == "object" && X !== null ? (X = X.delay, X = typeof X == "number" && 0 < X ? Se + X : Se) : X = Se, H) {
        case 1:
          var W = -1;
          break;
        case 2:
          W = 250;
          break;
        case 5:
          W = 1073741823;
          break;
        case 4:
          W = 1e4;
          break;
        default:
          W = 5e3;
      }
      return W = X + W, H = {
        id: f++,
        callback: Q,
        priorityLevel: H,
        startTime: X,
        expirationTime: W,
        sortIndex: -1
      }, X > Se ? (H.sortIndex = X, t(u, H), n(c) === null && H === n(u) && (x ? (_(O), O = -1) : x = !0, ne(P, X - Se))) : (H.sortIndex = W, t(c, H), b || g || (b = !0, I || (I = !0, Y()))), H;
    }, e.unstable_shouldYield = B, e.unstable_wrapCallback = function(H) {
      var Q = m;
      return function() {
        var X = m;
        m = Q;
        try {
          return H.apply(this, arguments);
        } finally {
          m = X;
        }
      };
    };
  })(ck)), ck;
}
var lD;
function LK() {
  return lD || (lD = 1, lk.exports = zK()), lk.exports;
}
var uk = { exports: {} }, ui = {};
var cD;
function BK() {
  if (cD) return ui;
  cD = 1;
  var e = cd();
  function t(c) {
    var u = "https://react.dev/errors/" + c;
    if (1 < arguments.length) {
      u += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var f = 2; f < arguments.length; f++)
        u += "&args[]=" + encodeURIComponent(arguments[f]);
    }
    return "Minified React error #" + c + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var r = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, i = /* @__PURE__ */ Symbol.for("react.portal");
  function o(c, u, f) {
    var h = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: i,
      key: h == null ? null : "" + h,
      children: c,
      containerInfo: u,
      implementation: f
    };
  }
  var s = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function a(c, u) {
    if (c === "font") return "";
    if (typeof u == "string")
      return u === "use-credentials" ? u : "";
  }
  return ui.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, ui.createPortal = function(c, u) {
    var f = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11)
      throw Error(t(299));
    return o(c, u, null, f);
  }, ui.flushSync = function(c) {
    var u = s.T, f = r.p;
    try {
      if (s.T = null, r.p = 2, c) return c();
    } finally {
      s.T = u, r.p = f, r.d.f();
    }
  }, ui.preconnect = function(c, u) {
    typeof c == "string" && (u ? (u = u.crossOrigin, u = typeof u == "string" ? u === "use-credentials" ? u : "" : void 0) : u = null, r.d.C(c, u));
  }, ui.prefetchDNS = function(c) {
    typeof c == "string" && r.d.D(c);
  }, ui.preinit = function(c, u) {
    if (typeof c == "string" && u && typeof u.as == "string") {
      var f = u.as, h = a(f, u.crossOrigin), m = typeof u.integrity == "string" ? u.integrity : void 0, g = typeof u.fetchPriority == "string" ? u.fetchPriority : void 0;
      f === "style" ? r.d.S(
        c,
        typeof u.precedence == "string" ? u.precedence : void 0,
        {
          crossOrigin: h,
          integrity: m,
          fetchPriority: g
        }
      ) : f === "script" && r.d.X(c, {
        crossOrigin: h,
        integrity: m,
        fetchPriority: g,
        nonce: typeof u.nonce == "string" ? u.nonce : void 0
      });
    }
  }, ui.preinitModule = function(c, u) {
    if (typeof c == "string")
      if (typeof u == "object" && u !== null) {
        if (u.as == null || u.as === "script") {
          var f = a(
            u.as,
            u.crossOrigin
          );
          r.d.M(c, {
            crossOrigin: f,
            integrity: typeof u.integrity == "string" ? u.integrity : void 0,
            nonce: typeof u.nonce == "string" ? u.nonce : void 0
          });
        }
      } else u == null && r.d.M(c);
  }, ui.preload = function(c, u) {
    if (typeof c == "string" && typeof u == "object" && u !== null && typeof u.as == "string") {
      var f = u.as, h = a(f, u.crossOrigin);
      r.d.L(c, f, {
        crossOrigin: h,
        integrity: typeof u.integrity == "string" ? u.integrity : void 0,
        nonce: typeof u.nonce == "string" ? u.nonce : void 0,
        type: typeof u.type == "string" ? u.type : void 0,
        fetchPriority: typeof u.fetchPriority == "string" ? u.fetchPriority : void 0,
        referrerPolicy: typeof u.referrerPolicy == "string" ? u.referrerPolicy : void 0,
        imageSrcSet: typeof u.imageSrcSet == "string" ? u.imageSrcSet : void 0,
        imageSizes: typeof u.imageSizes == "string" ? u.imageSizes : void 0,
        media: typeof u.media == "string" ? u.media : void 0
      });
    }
  }, ui.preloadModule = function(c, u) {
    if (typeof c == "string")
      if (u) {
        var f = a(u.as, u.crossOrigin);
        r.d.m(c, {
          as: typeof u.as == "string" && u.as !== "script" ? u.as : void 0,
          crossOrigin: f,
          integrity: typeof u.integrity == "string" ? u.integrity : void 0
        });
      } else r.d.m(c);
  }, ui.requestFormReset = function(c) {
    r.d.r(c);
  }, ui.unstable_batchedUpdates = function(c, u) {
    return c(u);
  }, ui.useFormState = function(c, u, f) {
    return s.H.useFormState(c, u, f);
  }, ui.useFormStatus = function() {
    return s.H.useHostTransitionStatus();
  }, ui.version = "19.2.4", ui;
}
var uD;
function Vx() {
  if (uD) return uk.exports;
  uD = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), uk.exports = BK(), uk.exports;
}
var dD;
function $K() {
  if (dD) return Wp;
  dD = 1;
  var e = LK(), t = cd(), n = Vx();
  function r(l) {
    var d = "https://react.dev/errors/" + l;
    if (1 < arguments.length) {
      d += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var p = 2; p < arguments.length; p++)
        d += "&args[]=" + encodeURIComponent(arguments[p]);
    }
    return "Minified React error #" + l + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function i(l) {
    return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11);
  }
  function o(l) {
    var d = l, p = l;
    if (l.alternate) for (; d.return; ) d = d.return;
    else {
      l = d;
      do
        d = l, (d.flags & 4098) !== 0 && (p = d.return), l = d.return;
      while (l);
    }
    return d.tag === 3 ? p : null;
  }
  function s(l) {
    if (l.tag === 13) {
      var d = l.memoizedState;
      if (d === null && (l = l.alternate, l !== null && (d = l.memoizedState)), d !== null) return d.dehydrated;
    }
    return null;
  }
  function a(l) {
    if (l.tag === 31) {
      var d = l.memoizedState;
      if (d === null && (l = l.alternate, l !== null && (d = l.memoizedState)), d !== null) return d.dehydrated;
    }
    return null;
  }
  function c(l) {
    if (o(l) !== l)
      throw Error(r(188));
  }
  function u(l) {
    var d = l.alternate;
    if (!d) {
      if (d = o(l), d === null) throw Error(r(188));
      return d !== l ? null : l;
    }
    for (var p = l, y = d; ; ) {
      var E = p.return;
      if (E === null) break;
      var T = E.alternate;
      if (T === null) {
        if (y = E.return, y !== null) {
          p = y;
          continue;
        }
        break;
      }
      if (E.child === T.child) {
        for (T = E.child; T; ) {
          if (T === p) return c(E), l;
          if (T === y) return c(E), d;
          T = T.sibling;
        }
        throw Error(r(188));
      }
      if (p.return !== y.return) p = E, y = T;
      else {
        for (var j = !1, V = E.child; V; ) {
          if (V === p) {
            j = !0, p = E, y = T;
            break;
          }
          if (V === y) {
            j = !0, y = E, p = T;
            break;
          }
          V = V.sibling;
        }
        if (!j) {
          for (V = T.child; V; ) {
            if (V === p) {
              j = !0, p = T, y = E;
              break;
            }
            if (V === y) {
              j = !0, y = T, p = E;
              break;
            }
            V = V.sibling;
          }
          if (!j) throw Error(r(189));
        }
      }
      if (p.alternate !== y) throw Error(r(190));
    }
    if (p.tag !== 3) throw Error(r(188));
    return p.stateNode.current === p ? l : d;
  }
  function f(l) {
    var d = l.tag;
    if (d === 5 || d === 26 || d === 27 || d === 6) return l;
    for (l = l.child; l !== null; ) {
      if (d = f(l), d !== null) return d;
      l = l.sibling;
    }
    return null;
  }
  var h = Object.assign, m = /* @__PURE__ */ Symbol.for("react.element"), g = /* @__PURE__ */ Symbol.for("react.transitional.element"), b = /* @__PURE__ */ Symbol.for("react.portal"), x = /* @__PURE__ */ Symbol.for("react.fragment"), w = /* @__PURE__ */ Symbol.for("react.strict_mode"), S = /* @__PURE__ */ Symbol.for("react.profiler"), _ = /* @__PURE__ */ Symbol.for("react.consumer"), M = /* @__PURE__ */ Symbol.for("react.context"), N = /* @__PURE__ */ Symbol.for("react.forward_ref"), P = /* @__PURE__ */ Symbol.for("react.suspense"), I = /* @__PURE__ */ Symbol.for("react.suspense_list"), O = /* @__PURE__ */ Symbol.for("react.memo"), L = /* @__PURE__ */ Symbol.for("react.lazy"), U = /* @__PURE__ */ Symbol.for("react.activity"), B = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel"), G = Symbol.iterator;
  function Y(l) {
    return l === null || typeof l != "object" ? null : (l = G && l[G] || l["@@iterator"], typeof l == "function" ? l : null);
  }
  var he = /* @__PURE__ */ Symbol.for("react.client.reference");
  function ie(l) {
    if (l == null) return null;
    if (typeof l == "function")
      return l.$$typeof === he ? null : l.displayName || l.name || null;
    if (typeof l == "string") return l;
    switch (l) {
      case x:
        return "Fragment";
      case S:
        return "Profiler";
      case w:
        return "StrictMode";
      case P:
        return "Suspense";
      case I:
        return "SuspenseList";
      case U:
        return "Activity";
    }
    if (typeof l == "object")
      switch (l.$$typeof) {
        case b:
          return "Portal";
        case M:
          return l.displayName || "Context";
        case _:
          return (l._context.displayName || "Context") + ".Consumer";
        case N:
          var d = l.render;
          return l = l.displayName, l || (l = d.displayName || d.name || "", l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"), l;
        case O:
          return d = l.displayName || null, d !== null ? d : ie(l.type) || "Memo";
        case L:
          d = l._payload, l = l._init;
          try {
            return ie(l(d));
          } catch {
          }
      }
    return null;
  }
  var ne = Array.isArray, H = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Q = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, X = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Se = [], W = -1;
  function Z(l) {
    return { current: l };
  }
  function pe(l) {
    0 > W || (l.current = Se[W], Se[W] = null, W--);
  }
  function F(l, d) {
    W++, Se[W] = l.current, l.current = d;
  }
  var ee = Z(null), ge = Z(null), re = Z(null), J = Z(null);
  function xe(l, d) {
    switch (F(re, d), F(ge, l), F(ee, null), d.nodeType) {
      case 9:
      case 11:
        l = (l = d.documentElement) && (l = l.namespaceURI) ? AO(l) : 0;
        break;
      default:
        if (l = d.tagName, d = d.namespaceURI)
          d = AO(d), l = MO(d, l);
        else
          switch (l) {
            case "svg":
              l = 1;
              break;
            case "math":
              l = 2;
              break;
            default:
              l = 0;
          }
    }
    pe(ee), F(ee, l);
  }
  function be() {
    pe(ee), pe(ge), pe(re);
  }
  function Ae(l) {
    l.memoizedState !== null && F(J, l);
    var d = ee.current, p = MO(d, l.type);
    d !== p && (F(ge, l), F(ee, p));
  }
  function tt(l) {
    ge.current === l && (pe(ee), pe(ge)), J.current === l && (pe(J), Up._currentValue = X);
  }
  var Ge, nt;
  function _t(l) {
    if (Ge === void 0)
      try {
        throw Error();
      } catch (p) {
        var d = p.stack.trim().match(/\n( *(at )?)/);
        Ge = d && d[1] || "", nt = -1 < p.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < p.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + Ge + l + nt;
  }
  var yn = !1;
  function St(l, d) {
    if (!l || yn) return "";
    yn = !0;
    var p = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var y = {
        DetermineComponentFrameRoot: function() {
          try {
            if (d) {
              var Ie = function() {
                throw Error();
              };
              if (Object.defineProperty(Ie.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(Ie, []);
                } catch (Me) {
                  var Te = Me;
                }
                Reflect.construct(l, [], Ie);
              } else {
                try {
                  Ie.call();
                } catch (Me) {
                  Te = Me;
                }
                l.call(Ie.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (Me) {
                Te = Me;
              }
              (Ie = l()) && typeof Ie.catch == "function" && Ie.catch(function() {
              });
            }
          } catch (Me) {
            if (Me && Te && typeof Me.stack == "string")
              return [Me.stack, Te.stack];
          }
          return [null, null];
        }
      };
      y.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var E = Object.getOwnPropertyDescriptor(
        y.DetermineComponentFrameRoot,
        "name"
      );
      E && E.configurable && Object.defineProperty(
        y.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var T = y.DetermineComponentFrameRoot(), j = T[0], V = T[1];
      if (j && V) {
        var te = j.split(`
`), Ee = V.split(`
`);
        for (E = y = 0; y < te.length && !te[y].includes("DetermineComponentFrameRoot"); )
          y++;
        for (; E < Ee.length && !Ee[E].includes(
          "DetermineComponentFrameRoot"
        ); )
          E++;
        if (y === te.length || E === Ee.length)
          for (y = te.length - 1, E = Ee.length - 1; 1 <= y && 0 <= E && te[y] !== Ee[E]; )
            E--;
        for (; 1 <= y && 0 <= E; y--, E--)
          if (te[y] !== Ee[E]) {
            if (y !== 1 || E !== 1)
              do
                if (y--, E--, 0 > E || te[y] !== Ee[E]) {
                  var Oe = `
` + te[y].replace(" at new ", " at ");
                  return l.displayName && Oe.includes("<anonymous>") && (Oe = Oe.replace("<anonymous>", l.displayName)), Oe;
                }
              while (1 <= y && 0 <= E);
            break;
          }
      }
    } finally {
      yn = !1, Error.prepareStackTrace = p;
    }
    return (p = l ? l.displayName || l.name : "") ? _t(p) : "";
  }
  function Vt(l, d) {
    switch (l.tag) {
      case 26:
      case 27:
      case 5:
        return _t(l.type);
      case 16:
        return _t("Lazy");
      case 13:
        return l.child !== d && d !== null ? _t("Suspense Fallback") : _t("Suspense");
      case 19:
        return _t("SuspenseList");
      case 0:
      case 15:
        return St(l.type, !1);
      case 11:
        return St(l.type.render, !1);
      case 1:
        return St(l.type, !0);
      case 31:
        return _t("Activity");
      default:
        return "";
    }
  }
  function xt(l) {
    try {
      var d = "", p = null;
      do
        d += Vt(l, p), p = l, l = l.return;
      while (l);
      return d;
    } catch (y) {
      return `
Error generating stack: ` + y.message + `
` + y.stack;
    }
  }
  var Kt = Object.prototype.hasOwnProperty, An = e.unstable_scheduleCallback, Nt = e.unstable_cancelCallback, sn = e.unstable_shouldYield, Pn = e.unstable_requestPaint, Mn = e.unstable_now, mt = e.unstable_getCurrentPriorityLevel, ke = e.unstable_ImmediatePriority, Pe = e.unstable_UserBlockingPriority, He = e.unstable_NormalPriority, et = e.unstable_LowPriority, bt = e.unstable_IdlePriority, Ct = e.log, fn = e.unstable_setDisableYieldValue, Lt = null, nn = null;
  function jn(l) {
    if (typeof Ct == "function" && fn(l), nn && typeof nn.setStrictMode == "function")
      try {
        nn.setStrictMode(Lt, l);
      } catch {
      }
  }
  var Ve = Math.clz32 ? Math.clz32 : yd, Ii = Math.log, Ar = Math.LN2;
  function yd(l) {
    return l >>>= 0, l === 0 ? 32 : 31 - (Ii(l) / Ar | 0) | 0;
  }
  var Ke = 256, sl = 262144, Wc = 4194304;
  function Ko(l) {
    var d = l & 42;
    if (d !== 0) return d;
    switch (l & -l) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return l & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return l & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return l;
    }
  }
  function qc(l, d, p) {
    var y = l.pendingLanes;
    if (y === 0) return 0;
    var E = 0, T = l.suspendedLanes, j = l.pingedLanes;
    l = l.warmLanes;
    var V = y & 134217727;
    return V !== 0 ? (y = V & ~T, y !== 0 ? E = Ko(y) : (j &= V, j !== 0 ? E = Ko(j) : p || (p = V & ~l, p !== 0 && (E = Ko(p))))) : (V = y & ~T, V !== 0 ? E = Ko(V) : j !== 0 ? E = Ko(j) : p || (p = y & ~l, p !== 0 && (E = Ko(p)))), E === 0 ? 0 : d !== 0 && d !== E && (d & T) === 0 && (T = E & -E, p = d & -d, T >= p || T === 32 && (p & 4194048) !== 0) ? d : E;
  }
  function oa(l, d) {
    return (l.pendingLanes & ~(l.suspendedLanes & ~l.pingedLanes) & d) === 0;
  }
  function h1(l, d) {
    switch (l) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return d + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return d + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function uy() {
    var l = Wc;
    return Wc <<= 1, (Wc & 62914560) === 0 && (Wc = 4194304), l;
  }
  function ys(l) {
    for (var d = [], p = 0; 31 > p; p++) d.push(l);
    return d;
  }
  function yo(l, d) {
    l.pendingLanes |= d, d !== 268435456 && (l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0);
  }
  function Wh(l, d, p, y, E, T) {
    var j = l.pendingLanes;
    l.pendingLanes = p, l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0, l.expiredLanes &= p, l.entangledLanes &= p, l.errorRecoveryDisabledLanes &= p, l.shellSuspendCounter = 0;
    var V = l.entanglements, te = l.expirationTimes, Ee = l.hiddenUpdates;
    for (p = j & ~p; 0 < p; ) {
      var Oe = 31 - Ve(p), Ie = 1 << Oe;
      V[Oe] = 0, te[Oe] = -1;
      var Te = Ee[Oe];
      if (Te !== null)
        for (Ee[Oe] = null, Oe = 0; Oe < Te.length; Oe++) {
          var Me = Te[Oe];
          Me !== null && (Me.lane &= -536870913);
        }
      p &= ~Ie;
    }
    y !== 0 && Gc(l, y, 0), T !== 0 && E === 0 && l.tag !== 0 && (l.suspendedLanes |= T & ~(j & ~d));
  }
  function Gc(l, d, p) {
    l.pendingLanes |= d, l.suspendedLanes &= ~d;
    var y = 31 - Ve(d);
    l.entangledLanes |= d, l.entanglements[y] = l.entanglements[y] | 1073741824 | p & 261930;
  }
  function kn(l, d) {
    var p = l.entangledLanes |= d;
    for (l = l.entanglements; p; ) {
      var y = 31 - Ve(p), E = 1 << y;
      E & d | l[y] & d && (l[y] |= d), p &= ~E;
    }
  }
  function sr(l, d) {
    var p = d & -d;
    return p = (p & 42) !== 0 ? 1 : qh(p), (p & (l.suspendedLanes | d)) !== 0 ? 0 : p;
  }
  function qh(l) {
    switch (l) {
      case 2:
        l = 1;
        break;
      case 8:
        l = 4;
        break;
      case 32:
        l = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        l = 128;
        break;
      case 268435456:
        l = 134217728;
        break;
      default:
        l = 0;
    }
    return l;
  }
  function al(l) {
    return l &= -l, 2 < l ? 8 < l ? (l & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function Kc() {
    var l = Q.p;
    return l !== 0 ? l : (l = window.event, l === void 0 ? 32 : JO(l.type));
  }
  function Zc(l, d) {
    var p = Q.p;
    try {
      return Q.p = l, d();
    } finally {
      Q.p = p;
    }
  }
  var vs = Math.random().toString(36).slice(2), Nn = "__reactFiber$" + vs, ar = "__reactProps$" + vs, wi = "__reactContainer$" + vs, ll = "__reactEvents$" + vs, p1 = "__reactListeners$" + vs, bs = "__reactHandles$" + vs, Gh = "__reactResources$" + vs, Xi = "__reactMarker$" + vs;
  function vd(l) {
    delete l[Nn], delete l[ar], delete l[ll], delete l[p1], delete l[bs];
  }
  function xs(l) {
    var d = l[Nn];
    if (d) return d;
    for (var p = l.parentNode; p; ) {
      if (d = p[wi] || p[Nn]) {
        if (p = d.alternate, d.child !== null || p !== null && p.child !== null)
          for (l = IO(l); l !== null; ) {
            if (p = l[Nn]) return p;
            l = IO(l);
          }
        return d;
      }
      l = p, p = l.parentNode;
    }
    return null;
  }
  function vn(l) {
    if (l = l[Nn] || l[wi]) {
      var d = l.tag;
      if (d === 5 || d === 6 || d === 13 || d === 31 || d === 26 || d === 27 || d === 3)
        return l;
    }
    return null;
  }
  function Ji(l) {
    var d = l.tag;
    if (d === 5 || d === 26 || d === 27 || d === 6) return l.stateNode;
    throw Error(r(33));
  }
  function si(l) {
    var d = l[Gh];
    return d || (d = l[Gh] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), d;
  }
  function lr(l) {
    l[Xi] = !0;
  }
  var sa = /* @__PURE__ */ new Set(), Yc = {};
  function Zo(l, d) {
    ws(l, d), ws(l + "Capture", d);
  }
  function ws(l, d) {
    for (Yc[l] = d, l = 0; l < d.length; l++)
      sa.add(d[l]);
  }
  var aa = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), Kh = {}, Xc = {};
  function dy(l) {
    return Kt.call(Xc, l) ? !0 : Kt.call(Kh, l) ? !1 : aa.test(l) ? Xc[l] = !0 : (Kh[l] = !0, !1);
  }
  function Pt(l, d, p) {
    if (dy(d))
      if (p === null) l.removeAttribute(d);
      else {
        switch (typeof p) {
          case "undefined":
          case "function":
          case "symbol":
            l.removeAttribute(d);
            return;
          case "boolean":
            var y = d.toLowerCase().slice(0, 5);
            if (y !== "data-" && y !== "aria-") {
              l.removeAttribute(d);
              return;
            }
        }
        l.setAttribute(d, "" + p);
      }
  }
  function Jc(l, d, p) {
    if (p === null) l.removeAttribute(d);
    else {
      switch (typeof p) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          l.removeAttribute(d);
          return;
      }
      l.setAttribute(d, "" + p);
    }
  }
  function vo(l, d, p, y) {
    if (y === null) l.removeAttribute(p);
    else {
      switch (typeof y) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          l.removeAttribute(p);
          return;
      }
      l.setAttributeNS(d, p, "" + y);
    }
  }
  function qr(l) {
    switch (typeof l) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return l;
      case "object":
        return l;
      default:
        return "";
    }
  }
  function cl(l) {
    var d = l.type;
    return (l = l.nodeName) && l.toLowerCase() === "input" && (d === "checkbox" || d === "radio");
  }
  function fy(l, d, p) {
    var y = Object.getOwnPropertyDescriptor(
      l.constructor.prototype,
      d
    );
    if (!l.hasOwnProperty(d) && typeof y < "u" && typeof y.get == "function" && typeof y.set == "function") {
      var E = y.get, T = y.set;
      return Object.defineProperty(l, d, {
        configurable: !0,
        get: function() {
          return E.call(this);
        },
        set: function(j) {
          p = "" + j, T.call(this, j);
        }
      }), Object.defineProperty(l, d, {
        enumerable: y.enumerable
      }), {
        getValue: function() {
          return p;
        },
        setValue: function(j) {
          p = "" + j;
        },
        stopTracking: function() {
          l._valueTracker = null, delete l[d];
        }
      };
    }
  }
  function bd(l) {
    if (!l._valueTracker) {
      var d = cl(l) ? "checked" : "value";
      l._valueTracker = fy(
        l,
        d,
        "" + l[d]
      );
    }
  }
  function Zh(l) {
    if (!l) return !1;
    var d = l._valueTracker;
    if (!d) return !0;
    var p = d.getValue(), y = "";
    return l && (y = cl(l) ? l.checked ? "true" : "false" : l.value), l = y, l !== p ? (d.setValue(l), !0) : !1;
  }
  function an(l) {
    if (l = l || (typeof document < "u" ? document : void 0), typeof l > "u") return null;
    try {
      return l.activeElement || l.body;
    } catch {
      return l.body;
    }
  }
  var Qc = /[\n"\\]/g;
  function jr(l) {
    return l.replace(
      Qc,
      function(d) {
        return "\\" + d.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Ss(l, d, p, y, E, T, j, V) {
    l.name = "", j != null && typeof j != "function" && typeof j != "symbol" && typeof j != "boolean" ? l.type = j : l.removeAttribute("type"), d != null ? j === "number" ? (d === 0 && l.value === "" || l.value != d) && (l.value = "" + qr(d)) : l.value !== "" + qr(d) && (l.value = "" + qr(d)) : j !== "submit" && j !== "reset" || l.removeAttribute("value"), d != null ? eu(l, j, qr(d)) : p != null ? eu(l, j, qr(p)) : y != null && l.removeAttribute("value"), E == null && T != null && (l.defaultChecked = !!T), E != null && (l.checked = E && typeof E != "function" && typeof E != "symbol"), V != null && typeof V != "function" && typeof V != "symbol" && typeof V != "boolean" ? l.name = "" + qr(V) : l.removeAttribute("name");
  }
  function xd(l, d, p, y, E, T, j, V) {
    if (T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" && (l.type = T), d != null || p != null) {
      if (!(T !== "submit" && T !== "reset" || d != null)) {
        bd(l);
        return;
      }
      p = p != null ? "" + qr(p) : "", d = d != null ? "" + qr(d) : p, V || d === l.value || (l.value = d), l.defaultValue = d;
    }
    y = y ?? E, y = typeof y != "function" && typeof y != "symbol" && !!y, l.checked = V ? l.checked : !!y, l.defaultChecked = !!y, j != null && typeof j != "function" && typeof j != "symbol" && typeof j != "boolean" && (l.name = j), bd(l);
  }
  function eu(l, d, p) {
    d === "number" && an(l.ownerDocument) === l || l.defaultValue === "" + p || (l.defaultValue = "" + p);
  }
  function Yo(l, d, p, y) {
    if (l = l.options, d) {
      d = {};
      for (var E = 0; E < p.length; E++)
        d["$" + p[E]] = !0;
      for (p = 0; p < l.length; p++)
        E = d.hasOwnProperty("$" + l[p].value), l[p].selected !== E && (l[p].selected = E), E && y && (l[p].defaultSelected = !0);
    } else {
      for (p = "" + qr(p), d = null, E = 0; E < l.length; E++) {
        if (l[E].value === p) {
          l[E].selected = !0, y && (l[E].defaultSelected = !0);
          return;
        }
        d !== null || l[E].disabled || (d = l[E]);
      }
      d !== null && (d.selected = !0);
    }
  }
  function Yh(l, d, p) {
    if (d != null && (d = "" + qr(d), d !== l.value && (l.value = d), p == null)) {
      l.defaultValue !== d && (l.defaultValue = d);
      return;
    }
    l.defaultValue = p != null ? "" + qr(p) : "";
  }
  function tu(l, d, p, y) {
    if (d == null) {
      if (y != null) {
        if (p != null) throw Error(r(92));
        if (ne(y)) {
          if (1 < y.length) throw Error(r(93));
          y = y[0];
        }
        p = y;
      }
      p == null && (p = ""), d = p;
    }
    p = qr(d), l.defaultValue = p, y = l.textContent, y === p && y !== "" && y !== null && (l.value = y), bd(l);
  }
  function la(l, d) {
    if (d) {
      var p = l.firstChild;
      if (p && p === l.lastChild && p.nodeType === 3) {
        p.nodeValue = d;
        return;
      }
    }
    l.textContent = d;
  }
  var m1 = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function Jt(l, d, p) {
    var y = d.indexOf("--") === 0;
    p == null || typeof p == "boolean" || p === "" ? y ? l.setProperty(d, "") : d === "float" ? l.cssFloat = "" : l[d] = "" : y ? l.setProperty(d, p) : typeof p != "number" || p === 0 || m1.has(d) ? d === "float" ? l.cssFloat = p : l[d] = ("" + p).trim() : l[d] = p + "px";
  }
  function Xh(l, d, p) {
    if (d != null && typeof d != "object")
      throw Error(r(62));
    if (l = l.style, p != null) {
      for (var y in p)
        !p.hasOwnProperty(y) || d != null && d.hasOwnProperty(y) || (y.indexOf("--") === 0 ? l.setProperty(y, "") : y === "float" ? l.cssFloat = "" : l[y] = "");
      for (var E in d)
        y = d[E], d.hasOwnProperty(E) && p[E] !== y && Jt(l, E, y);
    } else
      for (var T in d)
        d.hasOwnProperty(T) && Jt(l, T, d[T]);
  }
  function Jh(l) {
    if (l.indexOf("-") === -1) return !1;
    switch (l) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var g1 = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), Si = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Xo(l) {
    return Si.test("" + l) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : l;
  }
  function zi() {
  }
  var bo = null;
  function wd(l) {
    return l = l.target || l.srcElement || window, l.correspondingUseElement && (l = l.correspondingUseElement), l.nodeType === 3 ? l.parentNode : l;
  }
  var ca = null, In = null;
  function Qi(l) {
    var d = vn(l);
    if (d && (l = d.stateNode)) {
      var p = l[ar] || null;
      e: switch (l = d.stateNode, d.type) {
        case "input":
          if (Ss(
            l,
            p.value,
            p.defaultValue,
            p.defaultValue,
            p.checked,
            p.defaultChecked,
            p.type,
            p.name
          ), d = p.name, p.type === "radio" && d != null) {
            for (p = l; p.parentNode; ) p = p.parentNode;
            for (p = p.querySelectorAll(
              'input[name="' + jr(
                "" + d
              ) + '"][type="radio"]'
            ), d = 0; d < p.length; d++) {
              var y = p[d];
              if (y !== l && y.form === l.form) {
                var E = y[ar] || null;
                if (!E) throw Error(r(90));
                Ss(
                  y,
                  E.value,
                  E.defaultValue,
                  E.defaultValue,
                  E.checked,
                  E.defaultChecked,
                  E.type,
                  E.name
                );
              }
            }
            for (d = 0; d < p.length; d++)
              y = p[d], y.form === l.form && Zh(y);
          }
          break e;
        case "textarea":
          Yh(l, p.value, p.defaultValue);
          break e;
        case "select":
          d = p.value, d != null && Yo(l, !!p.multiple, d, !1);
      }
    }
  }
  var ua = !1;
  function ul(l, d, p) {
    if (ua) return l(d, p);
    ua = !0;
    try {
      var y = l(d);
      return y;
    } finally {
      if (ua = !1, (ca !== null || In !== null) && (tv(), ca && (d = ca, l = In, In = ca = null, Qi(d), l)))
        for (d = 0; d < l.length; d++) Qi(l[d]);
    }
  }
  function da(l, d) {
    var p = l.stateNode;
    if (p === null) return null;
    var y = p[ar] || null;
    if (y === null) return null;
    p = y[d];
    e: switch (d) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (y = !y.disabled) || (l = l.type, y = !(l === "button" || l === "input" || l === "select" || l === "textarea")), l = !y;
        break e;
      default:
        l = !1;
    }
    if (l) return null;
    if (p && typeof p != "function")
      throw Error(
        r(231, d, typeof p)
      );
    return p;
  }
  var Ir = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Qh = !1;
  if (Ir)
    try {
      var ai = {};
      Object.defineProperty(ai, "passive", {
        get: function() {
          Qh = !0;
        }
      }), window.addEventListener("test", ai, ai), window.removeEventListener("test", ai, ai);
    } catch {
      Qh = !1;
    }
  var xo = null, Sd = null, dl = null;
  function fl() {
    if (dl) return dl;
    var l, d = Sd, p = d.length, y, E = "value" in xo ? xo.value : xo.textContent, T = E.length;
    for (l = 0; l < p && d[l] === E[l]; l++) ;
    var j = p - l;
    for (y = 1; y <= j && d[p - y] === E[T - y]; y++) ;
    return dl = E.slice(l, 1 < y ? 1 - y : void 0);
  }
  function hl(l) {
    var d = l.keyCode;
    return "charCode" in l ? (l = l.charCode, l === 0 && d === 13 && (l = 13)) : l = d, l === 10 && (l = 13), 32 <= l || l === 13 ? l : 0;
  }
  function nu() {
    return !0;
  }
  function hy() {
    return !1;
  }
  function pr(l) {
    function d(p, y, E, T, j) {
      this._reactName = p, this._targetInst = E, this.type = y, this.nativeEvent = T, this.target = j, this.currentTarget = null;
      for (var V in l)
        l.hasOwnProperty(V) && (p = l[V], this[V] = p ? p(T) : T[V]);
      return this.isDefaultPrevented = (T.defaultPrevented != null ? T.defaultPrevented : T.returnValue === !1) ? nu : hy, this.isPropagationStopped = hy, this;
    }
    return h(d.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var p = this.nativeEvent;
        p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1), this.isDefaultPrevented = nu);
      },
      stopPropagation: function() {
        var p = this.nativeEvent;
        p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0), this.isPropagationStopped = nu);
      },
      persist: function() {
      },
      isPersistent: nu
    }), d;
  }
  var fa = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(l) {
      return l.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, kd = pr(fa), ks = h({}, fa, { view: 0, detail: 0 }), Cd = pr(ks), ru, ep, iu, Ed = h({}, ks, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: ha,
    button: 0,
    buttons: 0,
    relatedTarget: function(l) {
      return l.relatedTarget === void 0 ? l.fromElement === l.srcElement ? l.toElement : l.fromElement : l.relatedTarget;
    },
    movementX: function(l) {
      return "movementX" in l ? l.movementX : (l !== iu && (iu && l.type === "mousemove" ? (ru = l.screenX - iu.screenX, ep = l.screenY - iu.screenY) : ep = ru = 0, iu = l), ru);
    },
    movementY: function(l) {
      return "movementY" in l ? l.movementY : ep;
    }
  }), _d = pr(Ed), tp = h({}, Ed, { dataTransfer: 0 }), py = pr(tp), Td = h({}, ks, { relatedTarget: 0 }), pl = pr(Td), Ad = h({}, fa, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), my = pr(Ad), y1 = h({}, fa, {
    clipboardData: function(l) {
      return "clipboardData" in l ? l.clipboardData : window.clipboardData;
    }
  }), ml = pr(y1), np = h({}, fa, { data: 0 }), Md = pr(np), rp = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, ip = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, zr = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function ou(l) {
    var d = this.nativeEvent;
    return d.getModifierState ? d.getModifierState(l) : (l = zr[l]) ? !!d[l] : !1;
  }
  function ha() {
    return ou;
  }
  var gy = h({}, ks, {
    key: function(l) {
      if (l.key) {
        var d = rp[l.key] || l.key;
        if (d !== "Unidentified") return d;
      }
      return l.type === "keypress" ? (l = hl(l), l === 13 ? "Enter" : String.fromCharCode(l)) : l.type === "keydown" || l.type === "keyup" ? ip[l.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: ha,
    charCode: function(l) {
      return l.type === "keypress" ? hl(l) : 0;
    },
    keyCode: function(l) {
      return l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
    },
    which: function(l) {
      return l.type === "keypress" ? hl(l) : l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
    }
  }), Nd = pr(gy), yy = h({}, Ed, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), op = pr(yy), Rd = h({}, ks, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: ha
  }), sp = pr(Rd), pa = h({}, fa, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), ap = pr(pa), lp = h({}, Ed, {
    deltaX: function(l) {
      return "deltaX" in l ? l.deltaX : "wheelDeltaX" in l ? -l.wheelDeltaX : 0;
    },
    deltaY: function(l) {
      return "deltaY" in l ? l.deltaY : "wheelDeltaY" in l ? -l.wheelDeltaY : "wheelDelta" in l ? -l.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Od = pr(lp), cp = h({}, fa, {
    newState: 0,
    oldState: 0
  }), vy = pr(cp), v1 = [9, 13, 27, 32], su = Ir && "CompositionEvent" in window, Cs = null;
  Ir && "documentMode" in document && (Cs = document.documentMode);
  var b1 = Ir && "TextEvent" in window && !Cs, Dd = Ir && (!su || Cs && 8 < Cs && 11 >= Cs), Pd = " ", by = !1;
  function up(l, d) {
    switch (l) {
      case "keyup":
        return v1.indexOf(d.keyCode) !== -1;
      case "keydown":
        return d.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function xy(l) {
    return l = l.detail, typeof l == "object" && "data" in l ? l.data : null;
  }
  var ma = !1;
  function wy(l, d) {
    switch (l) {
      case "compositionend":
        return xy(d);
      case "keypress":
        return d.which !== 32 ? null : (by = !0, Pd);
      case "textInput":
        return l = d.data, l === Pd && by ? null : l;
      default:
        return null;
    }
  }
  function x1(l, d) {
    if (ma)
      return l === "compositionend" || !su && up(l, d) ? (l = fl(), dl = Sd = xo = null, ma = !1, l) : null;
    switch (l) {
      case "paste":
        return null;
      case "keypress":
        if (!(d.ctrlKey || d.altKey || d.metaKey) || d.ctrlKey && d.altKey) {
          if (d.char && 1 < d.char.length)
            return d.char;
          if (d.which) return String.fromCharCode(d.which);
        }
        return null;
      case "compositionend":
        return Dd && d.locale !== "ko" ? null : d.data;
      default:
        return null;
    }
  }
  var Sy = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function jd(l) {
    var d = l && l.nodeName && l.nodeName.toLowerCase();
    return d === "input" ? !!Sy[l.type] : d === "textarea";
  }
  function dp(l, d, p, y) {
    ca ? In ? In.push(y) : In = [y] : ca = y, d = lv(d, "onChange"), 0 < d.length && (p = new kd(
      "onChange",
      "change",
      null,
      p,
      y
    ), l.push({ event: p, listeners: d }));
  }
  var gl = null, au = null;
  function w1(l) {
    SO(l, 0);
  }
  function Id(l) {
    var d = Ji(l);
    if (Zh(d)) return l;
  }
  function lu(l, d) {
    if (l === "change") return d;
  }
  var wo = !1;
  if (Ir) {
    var zn;
    if (Ir) {
      var yl = "oninput" in document;
      if (!yl) {
        var ga = document.createElement("div");
        ga.setAttribute("oninput", "return;"), yl = typeof ga.oninput == "function";
      }
      zn = yl;
    } else zn = !1;
    wo = zn && (!document.documentMode || 9 < document.documentMode);
  }
  function ky() {
    gl && (gl.detachEvent("onpropertychange", zd), au = gl = null);
  }
  function zd(l) {
    if (l.propertyName === "value" && Id(au)) {
      var d = [];
      dp(
        d,
        au,
        l,
        wd(l)
      ), ul(w1, d);
    }
  }
  function Cy(l, d, p) {
    l === "focusin" ? (ky(), gl = d, au = p, gl.attachEvent("onpropertychange", zd)) : l === "focusout" && ky();
  }
  function ya(l) {
    if (l === "selectionchange" || l === "keyup" || l === "keydown")
      return Id(au);
  }
  function fp(l, d) {
    if (l === "click") return Id(d);
  }
  function vl(l, d) {
    if (l === "input" || l === "change")
      return Id(d);
  }
  function Es(l, d) {
    return l === d && (l !== 0 || 1 / l === 1 / d) || l !== l && d !== d;
  }
  var li = typeof Object.is == "function" ? Object.is : Es;
  function k(l, d) {
    if (li(l, d)) return !0;
    if (typeof l != "object" || l === null || typeof d != "object" || d === null)
      return !1;
    var p = Object.keys(l), y = Object.keys(d);
    if (p.length !== y.length) return !1;
    for (y = 0; y < p.length; y++) {
      var E = p[y];
      if (!Kt.call(d, E) || !li(l[E], d[E]))
        return !1;
    }
    return !0;
  }
  function A(l) {
    for (; l && l.firstChild; ) l = l.firstChild;
    return l;
  }
  function R(l, d) {
    var p = A(l);
    l = 0;
    for (var y; p; ) {
      if (p.nodeType === 3) {
        if (y = l + p.textContent.length, l <= d && y >= d)
          return { node: p, offset: d - l };
        l = y;
      }
      e: {
        for (; p; ) {
          if (p.nextSibling) {
            p = p.nextSibling;
            break e;
          }
          p = p.parentNode;
        }
        p = void 0;
      }
      p = A(p);
    }
  }
  function D(l, d) {
    return l && d ? l === d ? !0 : l && l.nodeType === 3 ? !1 : d && d.nodeType === 3 ? D(l, d.parentNode) : "contains" in l ? l.contains(d) : l.compareDocumentPosition ? !!(l.compareDocumentPosition(d) & 16) : !1 : !1;
  }
  function z(l) {
    l = l != null && l.ownerDocument != null && l.ownerDocument.defaultView != null ? l.ownerDocument.defaultView : window;
    for (var d = an(l.document); d instanceof l.HTMLIFrameElement; ) {
      try {
        var p = typeof d.contentWindow.location.href == "string";
      } catch {
        p = !1;
      }
      if (p) l = d.contentWindow;
      else break;
      d = an(l.document);
    }
    return d;
  }
  function $(l) {
    var d = l && l.nodeName && l.nodeName.toLowerCase();
    return d && (d === "input" && (l.type === "text" || l.type === "search" || l.type === "tel" || l.type === "url" || l.type === "password") || d === "textarea" || l.contentEditable === "true");
  }
  var q = Ir && "documentMode" in document && 11 >= document.documentMode, K = null, se = null, ye = null, ae = !1;
  function oe(l, d, p) {
    var y = p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
    ae || K == null || K !== an(y) || (y = K, "selectionStart" in y && $(y) ? y = { start: y.selectionStart, end: y.selectionEnd } : (y = (y.ownerDocument && y.ownerDocument.defaultView || window).getSelection(), y = {
      anchorNode: y.anchorNode,
      anchorOffset: y.anchorOffset,
      focusNode: y.focusNode,
      focusOffset: y.focusOffset
    }), ye && k(ye, y) || (ye = y, y = lv(se, "onSelect"), 0 < y.length && (d = new kd(
      "onSelect",
      "select",
      null,
      d,
      p
    ), l.push({ event: d, listeners: y }), d.target = K)));
  }
  function ue(l, d) {
    var p = {};
    return p[l.toLowerCase()] = d.toLowerCase(), p["Webkit" + l] = "webkit" + d, p["Moz" + l] = "moz" + d, p;
  }
  var fe = {
    animationend: ue("Animation", "AnimationEnd"),
    animationiteration: ue("Animation", "AnimationIteration"),
    animationstart: ue("Animation", "AnimationStart"),
    transitionrun: ue("Transition", "TransitionRun"),
    transitionstart: ue("Transition", "TransitionStart"),
    transitioncancel: ue("Transition", "TransitionCancel"),
    transitionend: ue("Transition", "TransitionEnd")
  }, le = {}, ce = {};
  Ir && (ce = document.createElement("div").style, "AnimationEvent" in window || (delete fe.animationend.animation, delete fe.animationiteration.animation, delete fe.animationstart.animation), "TransitionEvent" in window || delete fe.transitionend.transition);
  function we(l) {
    if (le[l]) return le[l];
    if (!fe[l]) return l;
    var d = fe[l], p;
    for (p in d)
      if (d.hasOwnProperty(p) && p in ce)
        return le[l] = d[p];
    return l;
  }
  var _e = we("animationend"), ve = we("animationiteration"), Re = we("animationstart"), ze = we("transitionrun"), We = we("transitionstart"), qe = we("transitioncancel"), Le = we("transitionend"), Xe = /* @__PURE__ */ new Map(), Ze = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Ze.push("scrollEnd");
  function Be(l, d) {
    Xe.set(l, d), Zo(d, [l]);
  }
  var Je = typeof reportError == "function" ? reportError : function(l) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var d = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof l == "object" && l !== null && typeof l.message == "string" ? String(l.message) : String(l),
        error: l
      });
      if (!window.dispatchEvent(d)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", l);
      return;
    }
    console.error(l);
  }, wt = [], Bt = 0, dt = 0;
  function Tt() {
    for (var l = Bt, d = dt = Bt = 0; d < l; ) {
      var p = wt[d];
      wt[d++] = null;
      var y = wt[d];
      wt[d++] = null;
      var E = wt[d];
      wt[d++] = null;
      var T = wt[d];
      if (wt[d++] = null, y !== null && E !== null) {
        var j = y.pending;
        j === null ? E.next = E : (E.next = j.next, j.next = E), y.pending = E;
      }
      T !== 0 && _s(p, E, T);
    }
  }
  function bn(l, d, p, y) {
    wt[Bt++] = l, wt[Bt++] = d, wt[Bt++] = p, wt[Bt++] = y, dt |= y, l.lanes |= y, l = l.alternate, l !== null && (l.lanes |= y);
  }
  function ci(l, d, p, y) {
    return bn(l, d, p, y), bl(l);
  }
  function un(l, d) {
    return bn(l, null, null, d), bl(l);
  }
  function _s(l, d, p) {
    l.lanes |= p;
    var y = l.alternate;
    y !== null && (y.lanes |= p);
    for (var E = !1, T = l.return; T !== null; )
      T.childLanes |= p, y = T.alternate, y !== null && (y.childLanes |= p), T.tag === 22 && (l = T.stateNode, l === null || l._visibility & 1 || (E = !0)), l = T, T = T.return;
    return l.tag === 3 ? (T = l.stateNode, E && d !== null && (E = 31 - Ve(p), l = T.hiddenUpdates, y = l[E], y === null ? l[E] = [d] : y.push(d), d.lane = p | 536870912), T) : null;
  }
  function bl(l) {
    if (50 < Pp)
      throw Pp = 0, NS = null, Error(r(185));
    for (var d = l.return; d !== null; )
      l = d, d = l.return;
    return l.tag === 3 ? l.stateNode : null;
  }
  var Ld = {};
  function gG(l, d, p, y) {
    this.tag = l, this.key = p, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = d, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = y, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function eo(l, d, p, y) {
    return new gG(l, d, p, y);
  }
  function S1(l) {
    return l = l.prototype, !(!l || !l.isReactComponent);
  }
  function va(l, d) {
    var p = l.alternate;
    return p === null ? (p = eo(
      l.tag,
      d,
      l.key,
      l.mode
    ), p.elementType = l.elementType, p.type = l.type, p.stateNode = l.stateNode, p.alternate = l, l.alternate = p) : (p.pendingProps = d, p.type = l.type, p.flags = 0, p.subtreeFlags = 0, p.deletions = null), p.flags = l.flags & 65011712, p.childLanes = l.childLanes, p.lanes = l.lanes, p.child = l.child, p.memoizedProps = l.memoizedProps, p.memoizedState = l.memoizedState, p.updateQueue = l.updateQueue, d = l.dependencies, p.dependencies = d === null ? null : { lanes: d.lanes, firstContext: d.firstContext }, p.sibling = l.sibling, p.index = l.index, p.ref = l.ref, p.refCleanup = l.refCleanup, p;
  }
  function iR(l, d) {
    l.flags &= 65011714;
    var p = l.alternate;
    return p === null ? (l.childLanes = 0, l.lanes = d, l.child = null, l.subtreeFlags = 0, l.memoizedProps = null, l.memoizedState = null, l.updateQueue = null, l.dependencies = null, l.stateNode = null) : (l.childLanes = p.childLanes, l.lanes = p.lanes, l.child = p.child, l.subtreeFlags = 0, l.deletions = null, l.memoizedProps = p.memoizedProps, l.memoizedState = p.memoizedState, l.updateQueue = p.updateQueue, l.type = p.type, d = p.dependencies, l.dependencies = d === null ? null : {
      lanes: d.lanes,
      firstContext: d.firstContext
    }), l;
  }
  function Ey(l, d, p, y, E, T) {
    var j = 0;
    if (y = l, typeof l == "function") S1(l) && (j = 1);
    else if (typeof l == "string")
      j = wK(
        l,
        p,
        ee.current
      ) ? 26 : l === "html" || l === "head" || l === "body" ? 27 : 5;
    else
      e: switch (l) {
        case U:
          return l = eo(31, p, d, E), l.elementType = U, l.lanes = T, l;
        case x:
          return cu(p.children, E, T, d);
        case w:
          j = 8, E |= 24;
          break;
        case S:
          return l = eo(12, p, d, E | 2), l.elementType = S, l.lanes = T, l;
        case P:
          return l = eo(13, p, d, E), l.elementType = P, l.lanes = T, l;
        case I:
          return l = eo(19, p, d, E), l.elementType = I, l.lanes = T, l;
        default:
          if (typeof l == "object" && l !== null)
            switch (l.$$typeof) {
              case M:
                j = 10;
                break e;
              case _:
                j = 9;
                break e;
              case N:
                j = 11;
                break e;
              case O:
                j = 14;
                break e;
              case L:
                j = 16, y = null;
                break e;
            }
          j = 29, p = Error(
            r(130, l === null ? "null" : typeof l, "")
          ), y = null;
      }
    return d = eo(j, p, d, E), d.elementType = l, d.type = y, d.lanes = T, d;
  }
  function cu(l, d, p, y) {
    return l = eo(7, l, y, d), l.lanes = p, l;
  }
  function k1(l, d, p) {
    return l = eo(6, l, null, d), l.lanes = p, l;
  }
  function oR(l) {
    var d = eo(18, null, null, 0);
    return d.stateNode = l, d;
  }
  function C1(l, d, p) {
    return d = eo(
      4,
      l.children !== null ? l.children : [],
      l.key,
      d
    ), d.lanes = p, d.stateNode = {
      containerInfo: l.containerInfo,
      pendingChildren: null,
      implementation: l.implementation
    }, d;
  }
  var sR = /* @__PURE__ */ new WeakMap();
  function So(l, d) {
    if (typeof l == "object" && l !== null) {
      var p = sR.get(l);
      return p !== void 0 ? p : (d = {
        value: l,
        source: d,
        stack: xt(d)
      }, sR.set(l, d), d);
    }
    return {
      value: l,
      source: d,
      stack: xt(d)
    };
  }
  var Bd = [], $d = 0, _y = null, hp = 0, ko = [], Co = 0, xl = null, Ts = 1, As = "";
  function ba(l, d) {
    Bd[$d++] = hp, Bd[$d++] = _y, _y = l, hp = d;
  }
  function aR(l, d, p) {
    ko[Co++] = Ts, ko[Co++] = As, ko[Co++] = xl, xl = l;
    var y = Ts;
    l = As;
    var E = 32 - Ve(y) - 1;
    y &= ~(1 << E), p += 1;
    var T = 32 - Ve(d) + E;
    if (30 < T) {
      var j = E - E % 5;
      T = (y & (1 << j) - 1).toString(32), y >>= j, E -= j, Ts = 1 << 32 - Ve(d) + E | p << E | y, As = T + l;
    } else
      Ts = 1 << T | p << E | y, As = l;
  }
  function E1(l) {
    l.return !== null && (ba(l, 1), aR(l, 1, 0));
  }
  function _1(l) {
    for (; l === _y; )
      _y = Bd[--$d], Bd[$d] = null, hp = Bd[--$d], Bd[$d] = null;
    for (; l === xl; )
      xl = ko[--Co], ko[Co] = null, As = ko[--Co], ko[Co] = null, Ts = ko[--Co], ko[Co] = null;
  }
  function lR(l, d) {
    ko[Co++] = Ts, ko[Co++] = As, ko[Co++] = xl, Ts = d.id, As = d.overflow, xl = l;
  }
  var Gr = null, Ln = null, Qt = !1, wl = null, Eo = !1, T1 = Error(r(519));
  function Sl(l) {
    var d = Error(
      r(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    throw pp(So(d, l)), T1;
  }
  function cR(l) {
    var d = l.stateNode, p = l.type, y = l.memoizedProps;
    switch (d[Nn] = l, d[ar] = y, p) {
      case "dialog":
        qt("cancel", d), qt("close", d);
        break;
      case "iframe":
      case "object":
      case "embed":
        qt("load", d);
        break;
      case "video":
      case "audio":
        for (p = 0; p < Ip.length; p++)
          qt(Ip[p], d);
        break;
      case "source":
        qt("error", d);
        break;
      case "img":
      case "image":
      case "link":
        qt("error", d), qt("load", d);
        break;
      case "details":
        qt("toggle", d);
        break;
      case "input":
        qt("invalid", d), xd(
          d,
          y.value,
          y.defaultValue,
          y.checked,
          y.defaultChecked,
          y.type,
          y.name,
          !0
        );
        break;
      case "select":
        qt("invalid", d);
        break;
      case "textarea":
        qt("invalid", d), tu(d, y.value, y.defaultValue, y.children);
    }
    p = y.children, typeof p != "string" && typeof p != "number" && typeof p != "bigint" || d.textContent === "" + p || y.suppressHydrationWarning === !0 || _O(d.textContent, p) ? (y.popover != null && (qt("beforetoggle", d), qt("toggle", d)), y.onScroll != null && qt("scroll", d), y.onScrollEnd != null && qt("scrollend", d), y.onClick != null && (d.onclick = zi), d = !0) : d = !1, d || Sl(l, !0);
  }
  function uR(l) {
    for (Gr = l.return; Gr; )
      switch (Gr.tag) {
        case 5:
        case 31:
        case 13:
          Eo = !1;
          return;
        case 27:
        case 3:
          Eo = !0;
          return;
        default:
          Gr = Gr.return;
      }
  }
  function Ud(l) {
    if (l !== Gr) return !1;
    if (!Qt) return uR(l), Qt = !0, !1;
    var d = l.tag, p;
    if ((p = d !== 3 && d !== 27) && ((p = d === 5) && (p = l.type, p = !(p !== "form" && p !== "button") || WS(l.type, l.memoizedProps)), p = !p), p && Ln && Sl(l), uR(l), d === 13) {
      if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(317));
      Ln = jO(l);
    } else if (d === 31) {
      if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(317));
      Ln = jO(l);
    } else
      d === 27 ? (d = Ln, Il(l.type) ? (l = YS, YS = null, Ln = l) : Ln = d) : Ln = Gr ? To(l.stateNode.nextSibling) : null;
    return !0;
  }
  function uu() {
    Ln = Gr = null, Qt = !1;
  }
  function A1() {
    var l = wl;
    return l !== null && (Ui === null ? Ui = l : Ui.push.apply(
      Ui,
      l
    ), wl = null), l;
  }
  function pp(l) {
    wl === null ? wl = [l] : wl.push(l);
  }
  var M1 = Z(null), du = null, xa = null;
  function kl(l, d, p) {
    F(M1, d._currentValue), d._currentValue = p;
  }
  function wa(l) {
    l._currentValue = M1.current, pe(M1);
  }
  function N1(l, d, p) {
    for (; l !== null; ) {
      var y = l.alternate;
      if ((l.childLanes & d) !== d ? (l.childLanes |= d, y !== null && (y.childLanes |= d)) : y !== null && (y.childLanes & d) !== d && (y.childLanes |= d), l === p) break;
      l = l.return;
    }
  }
  function R1(l, d, p, y) {
    var E = l.child;
    for (E !== null && (E.return = l); E !== null; ) {
      var T = E.dependencies;
      if (T !== null) {
        var j = E.child;
        T = T.firstContext;
        e: for (; T !== null; ) {
          var V = T;
          T = E;
          for (var te = 0; te < d.length; te++)
            if (V.context === d[te]) {
              T.lanes |= p, V = T.alternate, V !== null && (V.lanes |= p), N1(
                T.return,
                p,
                l
              ), y || (j = null);
              break e;
            }
          T = V.next;
        }
      } else if (E.tag === 18) {
        if (j = E.return, j === null) throw Error(r(341));
        j.lanes |= p, T = j.alternate, T !== null && (T.lanes |= p), N1(j, p, l), j = null;
      } else j = E.child;
      if (j !== null) j.return = E;
      else
        for (j = E; j !== null; ) {
          if (j === l) {
            j = null;
            break;
          }
          if (E = j.sibling, E !== null) {
            E.return = j.return, j = E;
            break;
          }
          j = j.return;
        }
      E = j;
    }
  }
  function Fd(l, d, p, y) {
    l = null;
    for (var E = d, T = !1; E !== null; ) {
      if (!T) {
        if ((E.flags & 524288) !== 0) T = !0;
        else if ((E.flags & 262144) !== 0) break;
      }
      if (E.tag === 10) {
        var j = E.alternate;
        if (j === null) throw Error(r(387));
        if (j = j.memoizedProps, j !== null) {
          var V = E.type;
          li(E.pendingProps.value, j.value) || (l !== null ? l.push(V) : l = [V]);
        }
      } else if (E === J.current) {
        if (j = E.alternate, j === null) throw Error(r(387));
        j.memoizedState.memoizedState !== E.memoizedState.memoizedState && (l !== null ? l.push(Up) : l = [Up]);
      }
      E = E.return;
    }
    l !== null && R1(
      d,
      l,
      p,
      y
    ), d.flags |= 262144;
  }
  function Ty(l) {
    for (l = l.firstContext; l !== null; ) {
      if (!li(
        l.context._currentValue,
        l.memoizedValue
      ))
        return !0;
      l = l.next;
    }
    return !1;
  }
  function fu(l) {
    du = l, xa = null, l = l.dependencies, l !== null && (l.firstContext = null);
  }
  function Kr(l) {
    return dR(du, l);
  }
  function Ay(l, d) {
    return du === null && fu(l), dR(l, d);
  }
  function dR(l, d) {
    var p = d._currentValue;
    if (d = { context: d, memoizedValue: p, next: null }, xa === null) {
      if (l === null) throw Error(r(308));
      xa = d, l.dependencies = { lanes: 0, firstContext: d }, l.flags |= 524288;
    } else xa = xa.next = d;
    return p;
  }
  var yG = typeof AbortController < "u" ? AbortController : function() {
    var l = [], d = this.signal = {
      aborted: !1,
      addEventListener: function(p, y) {
        l.push(y);
      }
    };
    this.abort = function() {
      d.aborted = !0, l.forEach(function(p) {
        return p();
      });
    };
  }, vG = e.unstable_scheduleCallback, bG = e.unstable_NormalPriority, mr = {
    $$typeof: M,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function O1() {
    return {
      controller: new yG(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function mp(l) {
    l.refCount--, l.refCount === 0 && vG(bG, function() {
      l.controller.abort();
    });
  }
  var gp = null, D1 = 0, Vd = 0, Hd = null;
  function xG(l, d) {
    if (gp === null) {
      var p = gp = [];
      D1 = 0, Vd = IS(), Hd = {
        status: "pending",
        value: void 0,
        then: function(y) {
          p.push(y);
        }
      };
    }
    return D1++, d.then(fR, fR), d;
  }
  function fR() {
    if (--D1 === 0 && gp !== null) {
      Hd !== null && (Hd.status = "fulfilled");
      var l = gp;
      gp = null, Vd = 0, Hd = null;
      for (var d = 0; d < l.length; d++) (0, l[d])();
    }
  }
  function wG(l, d) {
    var p = [], y = {
      status: "pending",
      value: null,
      reason: null,
      then: function(E) {
        p.push(E);
      }
    };
    return l.then(
      function() {
        y.status = "fulfilled", y.value = d;
        for (var E = 0; E < p.length; E++) (0, p[E])(d);
      },
      function(E) {
        for (y.status = "rejected", y.reason = E, E = 0; E < p.length; E++)
          (0, p[E])(void 0);
      }
    ), y;
  }
  var hR = H.S;
  H.S = function(l, d) {
    Y2 = Mn(), typeof d == "object" && d !== null && typeof d.then == "function" && xG(l, d), hR !== null && hR(l, d);
  };
  var hu = Z(null);
  function P1() {
    var l = hu.current;
    return l !== null ? l : Cn.pooledCache;
  }
  function My(l, d) {
    d === null ? F(hu, hu.current) : F(hu, d.pool);
  }
  function pR() {
    var l = P1();
    return l === null ? null : { parent: mr._currentValue, pool: l };
  }
  var Wd = Error(r(460)), j1 = Error(r(474)), Ny = Error(r(542)), Ry = { then: function() {
  } };
  function mR(l) {
    return l = l.status, l === "fulfilled" || l === "rejected";
  }
  function gR(l, d, p) {
    switch (p = l[p], p === void 0 ? l.push(d) : p !== d && (d.then(zi, zi), d = p), d.status) {
      case "fulfilled":
        return d.value;
      case "rejected":
        throw l = d.reason, vR(l), l;
      default:
        if (typeof d.status == "string") d.then(zi, zi);
        else {
          if (l = Cn, l !== null && 100 < l.shellSuspendCounter)
            throw Error(r(482));
          l = d, l.status = "pending", l.then(
            function(y) {
              if (d.status === "pending") {
                var E = d;
                E.status = "fulfilled", E.value = y;
              }
            },
            function(y) {
              if (d.status === "pending") {
                var E = d;
                E.status = "rejected", E.reason = y;
              }
            }
          );
        }
        switch (d.status) {
          case "fulfilled":
            return d.value;
          case "rejected":
            throw l = d.reason, vR(l), l;
        }
        throw mu = d, Wd;
    }
  }
  function pu(l) {
    try {
      var d = l._init;
      return d(l._payload);
    } catch (p) {
      throw p !== null && typeof p == "object" && typeof p.then == "function" ? (mu = p, Wd) : p;
    }
  }
  var mu = null;
  function yR() {
    if (mu === null) throw Error(r(459));
    var l = mu;
    return mu = null, l;
  }
  function vR(l) {
    if (l === Wd || l === Ny)
      throw Error(r(483));
  }
  var qd = null, yp = 0;
  function Oy(l) {
    var d = yp;
    return yp += 1, qd === null && (qd = []), gR(qd, l, d);
  }
  function vp(l, d) {
    d = d.props.ref, l.ref = d !== void 0 ? d : null;
  }
  function Dy(l, d) {
    throw d.$$typeof === m ? Error(r(525)) : (l = Object.prototype.toString.call(d), Error(
      r(
        31,
        l === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : l
      )
    ));
  }
  function bR(l) {
    function d(me, de) {
      if (l) {
        var Ce = me.deletions;
        Ce === null ? (me.deletions = [de], me.flags |= 16) : Ce.push(de);
      }
    }
    function p(me, de) {
      if (!l) return null;
      for (; de !== null; )
        d(me, de), de = de.sibling;
      return null;
    }
    function y(me) {
      for (var de = /* @__PURE__ */ new Map(); me !== null; )
        me.key !== null ? de.set(me.key, me) : de.set(me.index, me), me = me.sibling;
      return de;
    }
    function E(me, de) {
      return me = va(me, de), me.index = 0, me.sibling = null, me;
    }
    function T(me, de, Ce) {
      return me.index = Ce, l ? (Ce = me.alternate, Ce !== null ? (Ce = Ce.index, Ce < de ? (me.flags |= 67108866, de) : Ce) : (me.flags |= 67108866, de)) : (me.flags |= 1048576, de);
    }
    function j(me) {
      return l && me.alternate === null && (me.flags |= 67108866), me;
    }
    function V(me, de, Ce, je) {
      return de === null || de.tag !== 6 ? (de = k1(Ce, me.mode, je), de.return = me, de) : (de = E(de, Ce), de.return = me, de);
    }
    function te(me, de, Ce, je) {
      var pt = Ce.type;
      return pt === x ? Oe(
        me,
        de,
        Ce.props.children,
        je,
        Ce.key
      ) : de !== null && (de.elementType === pt || typeof pt == "object" && pt !== null && pt.$$typeof === L && pu(pt) === de.type) ? (de = E(de, Ce.props), vp(de, Ce), de.return = me, de) : (de = Ey(
        Ce.type,
        Ce.key,
        Ce.props,
        null,
        me.mode,
        je
      ), vp(de, Ce), de.return = me, de);
    }
    function Ee(me, de, Ce, je) {
      return de === null || de.tag !== 4 || de.stateNode.containerInfo !== Ce.containerInfo || de.stateNode.implementation !== Ce.implementation ? (de = C1(Ce, me.mode, je), de.return = me, de) : (de = E(de, Ce.children || []), de.return = me, de);
    }
    function Oe(me, de, Ce, je, pt) {
      return de === null || de.tag !== 7 ? (de = cu(
        Ce,
        me.mode,
        je,
        pt
      ), de.return = me, de) : (de = E(de, Ce), de.return = me, de);
    }
    function Ie(me, de, Ce) {
      if (typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint")
        return de = k1(
          "" + de,
          me.mode,
          Ce
        ), de.return = me, de;
      if (typeof de == "object" && de !== null) {
        switch (de.$$typeof) {
          case g:
            return Ce = Ey(
              de.type,
              de.key,
              de.props,
              null,
              me.mode,
              Ce
            ), vp(Ce, de), Ce.return = me, Ce;
          case b:
            return de = C1(
              de,
              me.mode,
              Ce
            ), de.return = me, de;
          case L:
            return de = pu(de), Ie(me, de, Ce);
        }
        if (ne(de) || Y(de))
          return de = cu(
            de,
            me.mode,
            Ce,
            null
          ), de.return = me, de;
        if (typeof de.then == "function")
          return Ie(me, Oy(de), Ce);
        if (de.$$typeof === M)
          return Ie(
            me,
            Ay(me, de),
            Ce
          );
        Dy(me, de);
      }
      return null;
    }
    function Te(me, de, Ce, je) {
      var pt = de !== null ? de.key : null;
      if (typeof Ce == "string" && Ce !== "" || typeof Ce == "number" || typeof Ce == "bigint")
        return pt !== null ? null : V(me, de, "" + Ce, je);
      if (typeof Ce == "object" && Ce !== null) {
        switch (Ce.$$typeof) {
          case g:
            return Ce.key === pt ? te(me, de, Ce, je) : null;
          case b:
            return Ce.key === pt ? Ee(me, de, Ce, je) : null;
          case L:
            return Ce = pu(Ce), Te(me, de, Ce, je);
        }
        if (ne(Ce) || Y(Ce))
          return pt !== null ? null : Oe(me, de, Ce, je, null);
        if (typeof Ce.then == "function")
          return Te(
            me,
            de,
            Oy(Ce),
            je
          );
        if (Ce.$$typeof === M)
          return Te(
            me,
            de,
            Ay(me, Ce),
            je
          );
        Dy(me, Ce);
      }
      return null;
    }
    function Me(me, de, Ce, je, pt) {
      if (typeof je == "string" && je !== "" || typeof je == "number" || typeof je == "bigint")
        return me = me.get(Ce) || null, V(de, me, "" + je, pt);
      if (typeof je == "object" && je !== null) {
        switch (je.$$typeof) {
          case g:
            return me = me.get(
              je.key === null ? Ce : je.key
            ) || null, te(de, me, je, pt);
          case b:
            return me = me.get(
              je.key === null ? Ce : je.key
            ) || null, Ee(de, me, je, pt);
          case L:
            return je = pu(je), Me(
              me,
              de,
              Ce,
              je,
              pt
            );
        }
        if (ne(je) || Y(je))
          return me = me.get(Ce) || null, Oe(de, me, je, pt, null);
        if (typeof je.then == "function")
          return Me(
            me,
            de,
            Ce,
            Oy(je),
            pt
          );
        if (je.$$typeof === M)
          return Me(
            me,
            de,
            Ce,
            Ay(de, je),
            pt
          );
        Dy(de, je);
      }
      return null;
    }
    function rt(me, de, Ce, je) {
      for (var pt = null, rn = null, lt = de, Ot = de = 0, Yt = null; lt !== null && Ot < Ce.length; Ot++) {
        lt.index > Ot ? (Yt = lt, lt = null) : Yt = lt.sibling;
        var on = Te(
          me,
          lt,
          Ce[Ot],
          je
        );
        if (on === null) {
          lt === null && (lt = Yt);
          break;
        }
        l && lt && on.alternate === null && d(me, lt), de = T(on, de, Ot), rn === null ? pt = on : rn.sibling = on, rn = on, lt = Yt;
      }
      if (Ot === Ce.length)
        return p(me, lt), Qt && ba(me, Ot), pt;
      if (lt === null) {
        for (; Ot < Ce.length; Ot++)
          lt = Ie(me, Ce[Ot], je), lt !== null && (de = T(
            lt,
            de,
            Ot
          ), rn === null ? pt = lt : rn.sibling = lt, rn = lt);
        return Qt && ba(me, Ot), pt;
      }
      for (lt = y(lt); Ot < Ce.length; Ot++)
        Yt = Me(
          lt,
          me,
          Ot,
          Ce[Ot],
          je
        ), Yt !== null && (l && Yt.alternate !== null && lt.delete(
          Yt.key === null ? Ot : Yt.key
        ), de = T(
          Yt,
          de,
          Ot
        ), rn === null ? pt = Yt : rn.sibling = Yt, rn = Yt);
      return l && lt.forEach(function(Ul) {
        return d(me, Ul);
      }), Qt && ba(me, Ot), pt;
    }
    function vt(me, de, Ce, je) {
      if (Ce == null) throw Error(r(151));
      for (var pt = null, rn = null, lt = de, Ot = de = 0, Yt = null, on = Ce.next(); lt !== null && !on.done; Ot++, on = Ce.next()) {
        lt.index > Ot ? (Yt = lt, lt = null) : Yt = lt.sibling;
        var Ul = Te(me, lt, on.value, je);
        if (Ul === null) {
          lt === null && (lt = Yt);
          break;
        }
        l && lt && Ul.alternate === null && d(me, lt), de = T(Ul, de, Ot), rn === null ? pt = Ul : rn.sibling = Ul, rn = Ul, lt = Yt;
      }
      if (on.done)
        return p(me, lt), Qt && ba(me, Ot), pt;
      if (lt === null) {
        for (; !on.done; Ot++, on = Ce.next())
          on = Ie(me, on.value, je), on !== null && (de = T(on, de, Ot), rn === null ? pt = on : rn.sibling = on, rn = on);
        return Qt && ba(me, Ot), pt;
      }
      for (lt = y(lt); !on.done; Ot++, on = Ce.next())
        on = Me(lt, me, Ot, on.value, je), on !== null && (l && on.alternate !== null && lt.delete(on.key === null ? Ot : on.key), de = T(on, de, Ot), rn === null ? pt = on : rn.sibling = on, rn = on);
      return l && lt.forEach(function(OK) {
        return d(me, OK);
      }), Qt && ba(me, Ot), pt;
    }
    function Sn(me, de, Ce, je) {
      if (typeof Ce == "object" && Ce !== null && Ce.type === x && Ce.key === null && (Ce = Ce.props.children), typeof Ce == "object" && Ce !== null) {
        switch (Ce.$$typeof) {
          case g:
            e: {
              for (var pt = Ce.key; de !== null; ) {
                if (de.key === pt) {
                  if (pt = Ce.type, pt === x) {
                    if (de.tag === 7) {
                      p(
                        me,
                        de.sibling
                      ), je = E(
                        de,
                        Ce.props.children
                      ), je.return = me, me = je;
                      break e;
                    }
                  } else if (de.elementType === pt || typeof pt == "object" && pt !== null && pt.$$typeof === L && pu(pt) === de.type) {
                    p(
                      me,
                      de.sibling
                    ), je = E(de, Ce.props), vp(je, Ce), je.return = me, me = je;
                    break e;
                  }
                  p(me, de);
                  break;
                } else d(me, de);
                de = de.sibling;
              }
              Ce.type === x ? (je = cu(
                Ce.props.children,
                me.mode,
                je,
                Ce.key
              ), je.return = me, me = je) : (je = Ey(
                Ce.type,
                Ce.key,
                Ce.props,
                null,
                me.mode,
                je
              ), vp(je, Ce), je.return = me, me = je);
            }
            return j(me);
          case b:
            e: {
              for (pt = Ce.key; de !== null; ) {
                if (de.key === pt)
                  if (de.tag === 4 && de.stateNode.containerInfo === Ce.containerInfo && de.stateNode.implementation === Ce.implementation) {
                    p(
                      me,
                      de.sibling
                    ), je = E(de, Ce.children || []), je.return = me, me = je;
                    break e;
                  } else {
                    p(me, de);
                    break;
                  }
                else d(me, de);
                de = de.sibling;
              }
              je = C1(Ce, me.mode, je), je.return = me, me = je;
            }
            return j(me);
          case L:
            return Ce = pu(Ce), Sn(
              me,
              de,
              Ce,
              je
            );
        }
        if (ne(Ce))
          return rt(
            me,
            de,
            Ce,
            je
          );
        if (Y(Ce)) {
          if (pt = Y(Ce), typeof pt != "function") throw Error(r(150));
          return Ce = pt.call(Ce), vt(
            me,
            de,
            Ce,
            je
          );
        }
        if (typeof Ce.then == "function")
          return Sn(
            me,
            de,
            Oy(Ce),
            je
          );
        if (Ce.$$typeof === M)
          return Sn(
            me,
            de,
            Ay(me, Ce),
            je
          );
        Dy(me, Ce);
      }
      return typeof Ce == "string" && Ce !== "" || typeof Ce == "number" || typeof Ce == "bigint" ? (Ce = "" + Ce, de !== null && de.tag === 6 ? (p(me, de.sibling), je = E(de, Ce), je.return = me, me = je) : (p(me, de), je = k1(Ce, me.mode, je), je.return = me, me = je), j(me)) : p(me, de);
    }
    return function(me, de, Ce, je) {
      try {
        yp = 0;
        var pt = Sn(
          me,
          de,
          Ce,
          je
        );
        return qd = null, pt;
      } catch (lt) {
        if (lt === Wd || lt === Ny) throw lt;
        var rn = eo(29, lt, null, me.mode);
        return rn.lanes = je, rn.return = me, rn;
      }
    };
  }
  var gu = bR(!0), xR = bR(!1), Cl = !1;
  function I1(l) {
    l.updateQueue = {
      baseState: l.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function z1(l, d) {
    l = l.updateQueue, d.updateQueue === l && (d.updateQueue = {
      baseState: l.baseState,
      firstBaseUpdate: l.firstBaseUpdate,
      lastBaseUpdate: l.lastBaseUpdate,
      shared: l.shared,
      callbacks: null
    });
  }
  function El(l) {
    return { lane: l, tag: 0, payload: null, callback: null, next: null };
  }
  function _l(l, d, p) {
    var y = l.updateQueue;
    if (y === null) return null;
    if (y = y.shared, (ln & 2) !== 0) {
      var E = y.pending;
      return E === null ? d.next = d : (d.next = E.next, E.next = d), y.pending = d, d = bl(l), _s(l, null, p), d;
    }
    return bn(l, y, d, p), bl(l);
  }
  function bp(l, d, p) {
    if (d = d.updateQueue, d !== null && (d = d.shared, (p & 4194048) !== 0)) {
      var y = d.lanes;
      y &= l.pendingLanes, p |= y, d.lanes = p, kn(l, p);
    }
  }
  function L1(l, d) {
    var p = l.updateQueue, y = l.alternate;
    if (y !== null && (y = y.updateQueue, p === y)) {
      var E = null, T = null;
      if (p = p.firstBaseUpdate, p !== null) {
        do {
          var j = {
            lane: p.lane,
            tag: p.tag,
            payload: p.payload,
            callback: null,
            next: null
          };
          T === null ? E = T = j : T = T.next = j, p = p.next;
        } while (p !== null);
        T === null ? E = T = d : T = T.next = d;
      } else E = T = d;
      p = {
        baseState: y.baseState,
        firstBaseUpdate: E,
        lastBaseUpdate: T,
        shared: y.shared,
        callbacks: y.callbacks
      }, l.updateQueue = p;
      return;
    }
    l = p.lastBaseUpdate, l === null ? p.firstBaseUpdate = d : l.next = d, p.lastBaseUpdate = d;
  }
  var B1 = !1;
  function xp() {
    if (B1) {
      var l = Hd;
      if (l !== null) throw l;
    }
  }
  function wp(l, d, p, y) {
    B1 = !1;
    var E = l.updateQueue;
    Cl = !1;
    var T = E.firstBaseUpdate, j = E.lastBaseUpdate, V = E.shared.pending;
    if (V !== null) {
      E.shared.pending = null;
      var te = V, Ee = te.next;
      te.next = null, j === null ? T = Ee : j.next = Ee, j = te;
      var Oe = l.alternate;
      Oe !== null && (Oe = Oe.updateQueue, V = Oe.lastBaseUpdate, V !== j && (V === null ? Oe.firstBaseUpdate = Ee : V.next = Ee, Oe.lastBaseUpdate = te));
    }
    if (T !== null) {
      var Ie = E.baseState;
      j = 0, Oe = Ee = te = null, V = T;
      do {
        var Te = V.lane & -536870913, Me = Te !== V.lane;
        if (Me ? (Zt & Te) === Te : (y & Te) === Te) {
          Te !== 0 && Te === Vd && (B1 = !0), Oe !== null && (Oe = Oe.next = {
            lane: 0,
            tag: V.tag,
            payload: V.payload,
            callback: null,
            next: null
          });
          e: {
            var rt = l, vt = V;
            Te = d;
            var Sn = p;
            switch (vt.tag) {
              case 1:
                if (rt = vt.payload, typeof rt == "function") {
                  Ie = rt.call(Sn, Ie, Te);
                  break e;
                }
                Ie = rt;
                break e;
              case 3:
                rt.flags = rt.flags & -65537 | 128;
              case 0:
                if (rt = vt.payload, Te = typeof rt == "function" ? rt.call(Sn, Ie, Te) : rt, Te == null) break e;
                Ie = h({}, Ie, Te);
                break e;
              case 2:
                Cl = !0;
            }
          }
          Te = V.callback, Te !== null && (l.flags |= 64, Me && (l.flags |= 8192), Me = E.callbacks, Me === null ? E.callbacks = [Te] : Me.push(Te));
        } else
          Me = {
            lane: Te,
            tag: V.tag,
            payload: V.payload,
            callback: V.callback,
            next: null
          }, Oe === null ? (Ee = Oe = Me, te = Ie) : Oe = Oe.next = Me, j |= Te;
        if (V = V.next, V === null) {
          if (V = E.shared.pending, V === null)
            break;
          Me = V, V = Me.next, Me.next = null, E.lastBaseUpdate = Me, E.shared.pending = null;
        }
      } while (!0);
      Oe === null && (te = Ie), E.baseState = te, E.firstBaseUpdate = Ee, E.lastBaseUpdate = Oe, T === null && (E.shared.lanes = 0), Rl |= j, l.lanes = j, l.memoizedState = Ie;
    }
  }
  function wR(l, d) {
    if (typeof l != "function")
      throw Error(r(191, l));
    l.call(d);
  }
  function SR(l, d) {
    var p = l.callbacks;
    if (p !== null)
      for (l.callbacks = null, l = 0; l < p.length; l++)
        wR(p[l], d);
  }
  var Gd = Z(null), Py = Z(0);
  function kR(l, d) {
    l = Na, F(Py, l), F(Gd, d), Na = l | d.baseLanes;
  }
  function $1() {
    F(Py, Na), F(Gd, Gd.current);
  }
  function U1() {
    Na = Py.current, pe(Gd), pe(Py);
  }
  var to = Z(null), _o = null;
  function Tl(l) {
    var d = l.alternate;
    F(cr, cr.current & 1), F(to, l), _o === null && (d === null || Gd.current !== null || d.memoizedState !== null) && (_o = l);
  }
  function F1(l) {
    F(cr, cr.current), F(to, l), _o === null && (_o = l);
  }
  function CR(l) {
    l.tag === 22 ? (F(cr, cr.current), F(to, l), _o === null && (_o = l)) : Al();
  }
  function Al() {
    F(cr, cr.current), F(to, to.current);
  }
  function no(l) {
    pe(to), _o === l && (_o = null), pe(cr);
  }
  var cr = Z(0);
  function jy(l) {
    for (var d = l; d !== null; ) {
      if (d.tag === 13) {
        var p = d.memoizedState;
        if (p !== null && (p = p.dehydrated, p === null || KS(p) || ZS(p)))
          return d;
      } else if (d.tag === 19 && (d.memoizedProps.revealOrder === "forwards" || d.memoizedProps.revealOrder === "backwards" || d.memoizedProps.revealOrder === "unstable_legacy-backwards" || d.memoizedProps.revealOrder === "together")) {
        if ((d.flags & 128) !== 0) return d;
      } else if (d.child !== null) {
        d.child.return = d, d = d.child;
        continue;
      }
      if (d === l) break;
      for (; d.sibling === null; ) {
        if (d.return === null || d.return === l) return null;
        d = d.return;
      }
      d.sibling.return = d.return, d = d.sibling;
    }
    return null;
  }
  var Sa = 0, Rt = null, xn = null, gr = null, Iy = !1, Kd = !1, yu = !1, zy = 0, Sp = 0, Zd = null, SG = 0;
  function Jn() {
    throw Error(r(321));
  }
  function V1(l, d) {
    if (d === null) return !1;
    for (var p = 0; p < d.length && p < l.length; p++)
      if (!li(l[p], d[p])) return !1;
    return !0;
  }
  function H1(l, d, p, y, E, T) {
    return Sa = T, Rt = d, d.memoizedState = null, d.updateQueue = null, d.lanes = 0, H.H = l === null || l.memoizedState === null ? a2 : oS, yu = !1, T = p(y, E), yu = !1, Kd && (T = _R(
      d,
      p,
      y,
      E
    )), ER(l), T;
  }
  function ER(l) {
    H.H = Ep;
    var d = xn !== null && xn.next !== null;
    if (Sa = 0, gr = xn = Rt = null, Iy = !1, Sp = 0, Zd = null, d) throw Error(r(300));
    l === null || yr || (l = l.dependencies, l !== null && Ty(l) && (yr = !0));
  }
  function _R(l, d, p, y) {
    Rt = l;
    var E = 0;
    do {
      if (Kd && (Zd = null), Sp = 0, Kd = !1, 25 <= E) throw Error(r(301));
      if (E += 1, gr = xn = null, l.updateQueue != null) {
        var T = l.updateQueue;
        T.lastEffect = null, T.events = null, T.stores = null, T.memoCache != null && (T.memoCache.index = 0);
      }
      H.H = l2, T = d(p, y);
    } while (Kd);
    return T;
  }
  function kG() {
    var l = H.H, d = l.useState()[0];
    return d = typeof d.then == "function" ? kp(d) : d, l = l.useState()[0], (xn !== null ? xn.memoizedState : null) !== l && (Rt.flags |= 1024), d;
  }
  function W1() {
    var l = zy !== 0;
    return zy = 0, l;
  }
  function q1(l, d, p) {
    d.updateQueue = l.updateQueue, d.flags &= -2053, l.lanes &= ~p;
  }
  function G1(l) {
    if (Iy) {
      for (l = l.memoizedState; l !== null; ) {
        var d = l.queue;
        d !== null && (d.pending = null), l = l.next;
      }
      Iy = !1;
    }
    Sa = 0, gr = xn = Rt = null, Kd = !1, Sp = zy = 0, Zd = null;
  }
  function ki() {
    var l = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return gr === null ? Rt.memoizedState = gr = l : gr = gr.next = l, gr;
  }
  function ur() {
    if (xn === null) {
      var l = Rt.alternate;
      l = l !== null ? l.memoizedState : null;
    } else l = xn.next;
    var d = gr === null ? Rt.memoizedState : gr.next;
    if (d !== null)
      gr = d, xn = l;
    else {
      if (l === null)
        throw Rt.alternate === null ? Error(r(467)) : Error(r(310));
      xn = l, l = {
        memoizedState: xn.memoizedState,
        baseState: xn.baseState,
        baseQueue: xn.baseQueue,
        queue: xn.queue,
        next: null
      }, gr === null ? Rt.memoizedState = gr = l : gr = gr.next = l;
    }
    return gr;
  }
  function Ly() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function kp(l) {
    var d = Sp;
    return Sp += 1, Zd === null && (Zd = []), l = gR(Zd, l, d), d = Rt, (gr === null ? d.memoizedState : gr.next) === null && (d = d.alternate, H.H = d === null || d.memoizedState === null ? a2 : oS), l;
  }
  function By(l) {
    if (l !== null && typeof l == "object") {
      if (typeof l.then == "function") return kp(l);
      if (l.$$typeof === M) return Kr(l);
    }
    throw Error(r(438, String(l)));
  }
  function K1(l) {
    var d = null, p = Rt.updateQueue;
    if (p !== null && (d = p.memoCache), d == null) {
      var y = Rt.alternate;
      y !== null && (y = y.updateQueue, y !== null && (y = y.memoCache, y != null && (d = {
        data: y.data.map(function(E) {
          return E.slice();
        }),
        index: 0
      })));
    }
    if (d == null && (d = { data: [], index: 0 }), p === null && (p = Ly(), Rt.updateQueue = p), p.memoCache = d, p = d.data[d.index], p === void 0)
      for (p = d.data[d.index] = Array(l), y = 0; y < l; y++)
        p[y] = B;
    return d.index++, p;
  }
  function ka(l, d) {
    return typeof d == "function" ? d(l) : d;
  }
  function $y(l) {
    var d = ur();
    return Z1(d, xn, l);
  }
  function Z1(l, d, p) {
    var y = l.queue;
    if (y === null) throw Error(r(311));
    y.lastRenderedReducer = p;
    var E = l.baseQueue, T = y.pending;
    if (T !== null) {
      if (E !== null) {
        var j = E.next;
        E.next = T.next, T.next = j;
      }
      d.baseQueue = E = T, y.pending = null;
    }
    if (T = l.baseState, E === null) l.memoizedState = T;
    else {
      d = E.next;
      var V = j = null, te = null, Ee = d, Oe = !1;
      do {
        var Ie = Ee.lane & -536870913;
        if (Ie !== Ee.lane ? (Zt & Ie) === Ie : (Sa & Ie) === Ie) {
          var Te = Ee.revertLane;
          if (Te === 0)
            te !== null && (te = te.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: Ee.action,
              hasEagerState: Ee.hasEagerState,
              eagerState: Ee.eagerState,
              next: null
            }), Ie === Vd && (Oe = !0);
          else if ((Sa & Te) === Te) {
            Ee = Ee.next, Te === Vd && (Oe = !0);
            continue;
          } else
            Ie = {
              lane: 0,
              revertLane: Ee.revertLane,
              gesture: null,
              action: Ee.action,
              hasEagerState: Ee.hasEagerState,
              eagerState: Ee.eagerState,
              next: null
            }, te === null ? (V = te = Ie, j = T) : te = te.next = Ie, Rt.lanes |= Te, Rl |= Te;
          Ie = Ee.action, yu && p(T, Ie), T = Ee.hasEagerState ? Ee.eagerState : p(T, Ie);
        } else
          Te = {
            lane: Ie,
            revertLane: Ee.revertLane,
            gesture: Ee.gesture,
            action: Ee.action,
            hasEagerState: Ee.hasEagerState,
            eagerState: Ee.eagerState,
            next: null
          }, te === null ? (V = te = Te, j = T) : te = te.next = Te, Rt.lanes |= Ie, Rl |= Ie;
        Ee = Ee.next;
      } while (Ee !== null && Ee !== d);
      if (te === null ? j = T : te.next = V, !li(T, l.memoizedState) && (yr = !0, Oe && (p = Hd, p !== null)))
        throw p;
      l.memoizedState = T, l.baseState = j, l.baseQueue = te, y.lastRenderedState = T;
    }
    return E === null && (y.lanes = 0), [l.memoizedState, y.dispatch];
  }
  function Y1(l) {
    var d = ur(), p = d.queue;
    if (p === null) throw Error(r(311));
    p.lastRenderedReducer = l;
    var y = p.dispatch, E = p.pending, T = d.memoizedState;
    if (E !== null) {
      p.pending = null;
      var j = E = E.next;
      do
        T = l(T, j.action), j = j.next;
      while (j !== E);
      li(T, d.memoizedState) || (yr = !0), d.memoizedState = T, d.baseQueue === null && (d.baseState = T), p.lastRenderedState = T;
    }
    return [T, y];
  }
  function TR(l, d, p) {
    var y = Rt, E = ur(), T = Qt;
    if (T) {
      if (p === void 0) throw Error(r(407));
      p = p();
    } else p = d();
    var j = !li(
      (xn || E).memoizedState,
      p
    );
    if (j && (E.memoizedState = p, yr = !0), E = E.queue, Q1(NR.bind(null, y, E, l), [
      l
    ]), E.getSnapshot !== d || j || gr !== null && gr.memoizedState.tag & 1) {
      if (y.flags |= 2048, Yd(
        9,
        { destroy: void 0 },
        MR.bind(
          null,
          y,
          E,
          p,
          d
        ),
        null
      ), Cn === null) throw Error(r(349));
      T || (Sa & 127) !== 0 || AR(y, d, p);
    }
    return p;
  }
  function AR(l, d, p) {
    l.flags |= 16384, l = { getSnapshot: d, value: p }, d = Rt.updateQueue, d === null ? (d = Ly(), Rt.updateQueue = d, d.stores = [l]) : (p = d.stores, p === null ? d.stores = [l] : p.push(l));
  }
  function MR(l, d, p, y) {
    d.value = p, d.getSnapshot = y, RR(d) && OR(l);
  }
  function NR(l, d, p) {
    return p(function() {
      RR(d) && OR(l);
    });
  }
  function RR(l) {
    var d = l.getSnapshot;
    l = l.value;
    try {
      var p = d();
      return !li(l, p);
    } catch {
      return !0;
    }
  }
  function OR(l) {
    var d = un(l, 2);
    d !== null && Fi(d, l, 2);
  }
  function X1(l) {
    var d = ki();
    if (typeof l == "function") {
      var p = l;
      if (l = p(), yu) {
        jn(!0);
        try {
          p();
        } finally {
          jn(!1);
        }
      }
    }
    return d.memoizedState = d.baseState = l, d.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: ka,
      lastRenderedState: l
    }, d;
  }
  function DR(l, d, p, y) {
    return l.baseState = p, Z1(
      l,
      xn,
      typeof y == "function" ? y : ka
    );
  }
  function CG(l, d, p, y, E) {
    if (Vy(l)) throw Error(r(485));
    if (l = d.action, l !== null) {
      var T = {
        payload: E,
        action: l,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(j) {
          T.listeners.push(j);
        }
      };
      H.T !== null ? p(!0) : T.isTransition = !1, y(T), p = d.pending, p === null ? (T.next = d.pending = T, PR(d, T)) : (T.next = p.next, d.pending = p.next = T);
    }
  }
  function PR(l, d) {
    var p = d.action, y = d.payload, E = l.state;
    if (d.isTransition) {
      var T = H.T, j = {};
      H.T = j;
      try {
        var V = p(E, y), te = H.S;
        te !== null && te(j, V), jR(l, d, V);
      } catch (Ee) {
        J1(l, d, Ee);
      } finally {
        T !== null && j.types !== null && (T.types = j.types), H.T = T;
      }
    } else
      try {
        T = p(E, y), jR(l, d, T);
      } catch (Ee) {
        J1(l, d, Ee);
      }
  }
  function jR(l, d, p) {
    p !== null && typeof p == "object" && typeof p.then == "function" ? p.then(
      function(y) {
        IR(l, d, y);
      },
      function(y) {
        return J1(l, d, y);
      }
    ) : IR(l, d, p);
  }
  function IR(l, d, p) {
    d.status = "fulfilled", d.value = p, zR(d), l.state = p, d = l.pending, d !== null && (p = d.next, p === d ? l.pending = null : (p = p.next, d.next = p, PR(l, p)));
  }
  function J1(l, d, p) {
    var y = l.pending;
    if (l.pending = null, y !== null) {
      y = y.next;
      do
        d.status = "rejected", d.reason = p, zR(d), d = d.next;
      while (d !== y);
    }
    l.action = null;
  }
  function zR(l) {
    l = l.listeners;
    for (var d = 0; d < l.length; d++) (0, l[d])();
  }
  function LR(l, d) {
    return d;
  }
  function BR(l, d) {
    if (Qt) {
      var p = Cn.formState;
      if (p !== null) {
        e: {
          var y = Rt;
          if (Qt) {
            if (Ln) {
              t: {
                for (var E = Ln, T = Eo; E.nodeType !== 8; ) {
                  if (!T) {
                    E = null;
                    break t;
                  }
                  if (E = To(
                    E.nextSibling
                  ), E === null) {
                    E = null;
                    break t;
                  }
                }
                T = E.data, E = T === "F!" || T === "F" ? E : null;
              }
              if (E) {
                Ln = To(
                  E.nextSibling
                ), y = E.data === "F!";
                break e;
              }
            }
            Sl(y);
          }
          y = !1;
        }
        y && (d = p[0]);
      }
    }
    return p = ki(), p.memoizedState = p.baseState = d, y = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: LR,
      lastRenderedState: d
    }, p.queue = y, p = i2.bind(
      null,
      Rt,
      y
    ), y.dispatch = p, y = X1(!1), T = iS.bind(
      null,
      Rt,
      !1,
      y.queue
    ), y = ki(), E = {
      state: d,
      dispatch: null,
      action: l,
      pending: null
    }, y.queue = E, p = CG.bind(
      null,
      Rt,
      E,
      T,
      p
    ), E.dispatch = p, y.memoizedState = l, [d, p, !1];
  }
  function $R(l) {
    var d = ur();
    return UR(d, xn, l);
  }
  function UR(l, d, p) {
    if (d = Z1(
      l,
      d,
      LR
    )[0], l = $y(ka)[0], typeof d == "object" && d !== null && typeof d.then == "function")
      try {
        var y = kp(d);
      } catch (j) {
        throw j === Wd ? Ny : j;
      }
    else y = d;
    d = ur();
    var E = d.queue, T = E.dispatch;
    return p !== d.memoizedState && (Rt.flags |= 2048, Yd(
      9,
      { destroy: void 0 },
      EG.bind(null, E, p),
      null
    )), [y, T, l];
  }
  function EG(l, d) {
    l.action = d;
  }
  function FR(l) {
    var d = ur(), p = xn;
    if (p !== null)
      return UR(d, p, l);
    ur(), d = d.memoizedState, p = ur();
    var y = p.queue.dispatch;
    return p.memoizedState = l, [d, y, !1];
  }
  function Yd(l, d, p, y) {
    return l = { tag: l, create: p, deps: y, inst: d, next: null }, d = Rt.updateQueue, d === null && (d = Ly(), Rt.updateQueue = d), p = d.lastEffect, p === null ? d.lastEffect = l.next = l : (y = p.next, p.next = l, l.next = y, d.lastEffect = l), l;
  }
  function VR() {
    return ur().memoizedState;
  }
  function Uy(l, d, p, y) {
    var E = ki();
    Rt.flags |= l, E.memoizedState = Yd(
      1 | d,
      { destroy: void 0 },
      p,
      y === void 0 ? null : y
    );
  }
  function Fy(l, d, p, y) {
    var E = ur();
    y = y === void 0 ? null : y;
    var T = E.memoizedState.inst;
    xn !== null && y !== null && V1(y, xn.memoizedState.deps) ? E.memoizedState = Yd(d, T, p, y) : (Rt.flags |= l, E.memoizedState = Yd(
      1 | d,
      T,
      p,
      y
    ));
  }
  function HR(l, d) {
    Uy(8390656, 8, l, d);
  }
  function Q1(l, d) {
    Fy(2048, 8, l, d);
  }
  function _G(l) {
    Rt.flags |= 4;
    var d = Rt.updateQueue;
    if (d === null)
      d = Ly(), Rt.updateQueue = d, d.events = [l];
    else {
      var p = d.events;
      p === null ? d.events = [l] : p.push(l);
    }
  }
  function WR(l) {
    var d = ur().memoizedState;
    return _G({ ref: d, nextImpl: l }), function() {
      if ((ln & 2) !== 0) throw Error(r(440));
      return d.impl.apply(void 0, arguments);
    };
  }
  function qR(l, d) {
    return Fy(4, 2, l, d);
  }
  function GR(l, d) {
    return Fy(4, 4, l, d);
  }
  function KR(l, d) {
    if (typeof d == "function") {
      l = l();
      var p = d(l);
      return function() {
        typeof p == "function" ? p() : d(null);
      };
    }
    if (d != null)
      return l = l(), d.current = l, function() {
        d.current = null;
      };
  }
  function ZR(l, d, p) {
    p = p != null ? p.concat([l]) : null, Fy(4, 4, KR.bind(null, d, l), p);
  }
  function eS() {
  }
  function YR(l, d) {
    var p = ur();
    d = d === void 0 ? null : d;
    var y = p.memoizedState;
    return d !== null && V1(d, y[1]) ? y[0] : (p.memoizedState = [l, d], l);
  }
  function XR(l, d) {
    var p = ur();
    d = d === void 0 ? null : d;
    var y = p.memoizedState;
    if (d !== null && V1(d, y[1]))
      return y[0];
    if (y = l(), yu) {
      jn(!0);
      try {
        l();
      } finally {
        jn(!1);
      }
    }
    return p.memoizedState = [y, d], y;
  }
  function tS(l, d, p) {
    return p === void 0 || (Sa & 1073741824) !== 0 && (Zt & 261930) === 0 ? l.memoizedState = d : (l.memoizedState = p, l = J2(), Rt.lanes |= l, Rl |= l, p);
  }
  function JR(l, d, p, y) {
    return li(p, d) ? p : Gd.current !== null ? (l = tS(l, p, y), li(l, d) || (yr = !0), l) : (Sa & 42) === 0 || (Sa & 1073741824) !== 0 && (Zt & 261930) === 0 ? (yr = !0, l.memoizedState = p) : (l = J2(), Rt.lanes |= l, Rl |= l, d);
  }
  function QR(l, d, p, y, E) {
    var T = Q.p;
    Q.p = T !== 0 && 8 > T ? T : 8;
    var j = H.T, V = {};
    H.T = V, iS(l, !1, d, p);
    try {
      var te = E(), Ee = H.S;
      if (Ee !== null && Ee(V, te), te !== null && typeof te == "object" && typeof te.then == "function") {
        var Oe = wG(
          te,
          y
        );
        Cp(
          l,
          d,
          Oe,
          oo(l)
        );
      } else
        Cp(
          l,
          d,
          y,
          oo(l)
        );
    } catch (Ie) {
      Cp(
        l,
        d,
        { then: function() {
        }, status: "rejected", reason: Ie },
        oo()
      );
    } finally {
      Q.p = T, j !== null && V.types !== null && (j.types = V.types), H.T = j;
    }
  }
  function TG() {
  }
  function nS(l, d, p, y) {
    if (l.tag !== 5) throw Error(r(476));
    var E = e2(l).queue;
    QR(
      l,
      E,
      d,
      X,
      p === null ? TG : function() {
        return t2(l), p(y);
      }
    );
  }
  function e2(l) {
    var d = l.memoizedState;
    if (d !== null) return d;
    d = {
      memoizedState: X,
      baseState: X,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ka,
        lastRenderedState: X
      },
      next: null
    };
    var p = {};
    return d.next = {
      memoizedState: p,
      baseState: p,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ka,
        lastRenderedState: p
      },
      next: null
    }, l.memoizedState = d, l = l.alternate, l !== null && (l.memoizedState = d), d;
  }
  function t2(l) {
    var d = e2(l);
    d.next === null && (d = l.alternate.memoizedState), Cp(
      l,
      d.next.queue,
      {},
      oo()
    );
  }
  function rS() {
    return Kr(Up);
  }
  function n2() {
    return ur().memoizedState;
  }
  function r2() {
    return ur().memoizedState;
  }
  function AG(l) {
    for (var d = l.return; d !== null; ) {
      switch (d.tag) {
        case 24:
        case 3:
          var p = oo();
          l = El(p);
          var y = _l(d, l, p);
          y !== null && (Fi(y, d, p), bp(y, d, p)), d = { cache: O1() }, l.payload = d;
          return;
      }
      d = d.return;
    }
  }
  function MG(l, d, p) {
    var y = oo();
    p = {
      lane: y,
      revertLane: 0,
      gesture: null,
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Vy(l) ? o2(d, p) : (p = ci(l, d, p, y), p !== null && (Fi(p, l, y), s2(p, d, y)));
  }
  function i2(l, d, p) {
    var y = oo();
    Cp(l, d, p, y);
  }
  function Cp(l, d, p, y) {
    var E = {
      lane: y,
      revertLane: 0,
      gesture: null,
      action: p,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Vy(l)) o2(d, E);
    else {
      var T = l.alternate;
      if (l.lanes === 0 && (T === null || T.lanes === 0) && (T = d.lastRenderedReducer, T !== null))
        try {
          var j = d.lastRenderedState, V = T(j, p);
          if (E.hasEagerState = !0, E.eagerState = V, li(V, j))
            return bn(l, d, E, 0), Cn === null && Tt(), !1;
        } catch {
        }
      if (p = ci(l, d, E, y), p !== null)
        return Fi(p, l, y), s2(p, d, y), !0;
    }
    return !1;
  }
  function iS(l, d, p, y) {
    if (y = {
      lane: 2,
      revertLane: IS(),
      gesture: null,
      action: y,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Vy(l)) {
      if (d) throw Error(r(479));
    } else
      d = ci(
        l,
        p,
        y,
        2
      ), d !== null && Fi(d, l, 2);
  }
  function Vy(l) {
    var d = l.alternate;
    return l === Rt || d !== null && d === Rt;
  }
  function o2(l, d) {
    Kd = Iy = !0;
    var p = l.pending;
    p === null ? d.next = d : (d.next = p.next, p.next = d), l.pending = d;
  }
  function s2(l, d, p) {
    if ((p & 4194048) !== 0) {
      var y = d.lanes;
      y &= l.pendingLanes, p |= y, d.lanes = p, kn(l, p);
    }
  }
  var Ep = {
    readContext: Kr,
    use: By,
    useCallback: Jn,
    useContext: Jn,
    useEffect: Jn,
    useImperativeHandle: Jn,
    useLayoutEffect: Jn,
    useInsertionEffect: Jn,
    useMemo: Jn,
    useReducer: Jn,
    useRef: Jn,
    useState: Jn,
    useDebugValue: Jn,
    useDeferredValue: Jn,
    useTransition: Jn,
    useSyncExternalStore: Jn,
    useId: Jn,
    useHostTransitionStatus: Jn,
    useFormState: Jn,
    useActionState: Jn,
    useOptimistic: Jn,
    useMemoCache: Jn,
    useCacheRefresh: Jn
  };
  Ep.useEffectEvent = Jn;
  var a2 = {
    readContext: Kr,
    use: By,
    useCallback: function(l, d) {
      return ki().memoizedState = [
        l,
        d === void 0 ? null : d
      ], l;
    },
    useContext: Kr,
    useEffect: HR,
    useImperativeHandle: function(l, d, p) {
      p = p != null ? p.concat([l]) : null, Uy(
        4194308,
        4,
        KR.bind(null, d, l),
        p
      );
    },
    useLayoutEffect: function(l, d) {
      return Uy(4194308, 4, l, d);
    },
    useInsertionEffect: function(l, d) {
      Uy(4, 2, l, d);
    },
    useMemo: function(l, d) {
      var p = ki();
      d = d === void 0 ? null : d;
      var y = l();
      if (yu) {
        jn(!0);
        try {
          l();
        } finally {
          jn(!1);
        }
      }
      return p.memoizedState = [y, d], y;
    },
    useReducer: function(l, d, p) {
      var y = ki();
      if (p !== void 0) {
        var E = p(d);
        if (yu) {
          jn(!0);
          try {
            p(d);
          } finally {
            jn(!1);
          }
        }
      } else E = d;
      return y.memoizedState = y.baseState = E, l = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: l,
        lastRenderedState: E
      }, y.queue = l, l = l.dispatch = MG.bind(
        null,
        Rt,
        l
      ), [y.memoizedState, l];
    },
    useRef: function(l) {
      var d = ki();
      return l = { current: l }, d.memoizedState = l;
    },
    useState: function(l) {
      l = X1(l);
      var d = l.queue, p = i2.bind(null, Rt, d);
      return d.dispatch = p, [l.memoizedState, p];
    },
    useDebugValue: eS,
    useDeferredValue: function(l, d) {
      var p = ki();
      return tS(p, l, d);
    },
    useTransition: function() {
      var l = X1(!1);
      return l = QR.bind(
        null,
        Rt,
        l.queue,
        !0,
        !1
      ), ki().memoizedState = l, [!1, l];
    },
    useSyncExternalStore: function(l, d, p) {
      var y = Rt, E = ki();
      if (Qt) {
        if (p === void 0)
          throw Error(r(407));
        p = p();
      } else {
        if (p = d(), Cn === null)
          throw Error(r(349));
        (Zt & 127) !== 0 || AR(y, d, p);
      }
      E.memoizedState = p;
      var T = { value: p, getSnapshot: d };
      return E.queue = T, HR(NR.bind(null, y, T, l), [
        l
      ]), y.flags |= 2048, Yd(
        9,
        { destroy: void 0 },
        MR.bind(
          null,
          y,
          T,
          p,
          d
        ),
        null
      ), p;
    },
    useId: function() {
      var l = ki(), d = Cn.identifierPrefix;
      if (Qt) {
        var p = As, y = Ts;
        p = (y & ~(1 << 32 - Ve(y) - 1)).toString(32) + p, d = "_" + d + "R_" + p, p = zy++, 0 < p && (d += "H" + p.toString(32)), d += "_";
      } else
        p = SG++, d = "_" + d + "r_" + p.toString(32) + "_";
      return l.memoizedState = d;
    },
    useHostTransitionStatus: rS,
    useFormState: BR,
    useActionState: BR,
    useOptimistic: function(l) {
      var d = ki();
      d.memoizedState = d.baseState = l;
      var p = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return d.queue = p, d = iS.bind(
        null,
        Rt,
        !0,
        p
      ), p.dispatch = d, [l, d];
    },
    useMemoCache: K1,
    useCacheRefresh: function() {
      return ki().memoizedState = AG.bind(
        null,
        Rt
      );
    },
    useEffectEvent: function(l) {
      var d = ki(), p = { impl: l };
      return d.memoizedState = p, function() {
        if ((ln & 2) !== 0)
          throw Error(r(440));
        return p.impl.apply(void 0, arguments);
      };
    }
  }, oS = {
    readContext: Kr,
    use: By,
    useCallback: YR,
    useContext: Kr,
    useEffect: Q1,
    useImperativeHandle: ZR,
    useInsertionEffect: qR,
    useLayoutEffect: GR,
    useMemo: XR,
    useReducer: $y,
    useRef: VR,
    useState: function() {
      return $y(ka);
    },
    useDebugValue: eS,
    useDeferredValue: function(l, d) {
      var p = ur();
      return JR(
        p,
        xn.memoizedState,
        l,
        d
      );
    },
    useTransition: function() {
      var l = $y(ka)[0], d = ur().memoizedState;
      return [
        typeof l == "boolean" ? l : kp(l),
        d
      ];
    },
    useSyncExternalStore: TR,
    useId: n2,
    useHostTransitionStatus: rS,
    useFormState: $R,
    useActionState: $R,
    useOptimistic: function(l, d) {
      var p = ur();
      return DR(p, xn, l, d);
    },
    useMemoCache: K1,
    useCacheRefresh: r2
  };
  oS.useEffectEvent = WR;
  var l2 = {
    readContext: Kr,
    use: By,
    useCallback: YR,
    useContext: Kr,
    useEffect: Q1,
    useImperativeHandle: ZR,
    useInsertionEffect: qR,
    useLayoutEffect: GR,
    useMemo: XR,
    useReducer: Y1,
    useRef: VR,
    useState: function() {
      return Y1(ka);
    },
    useDebugValue: eS,
    useDeferredValue: function(l, d) {
      var p = ur();
      return xn === null ? tS(p, l, d) : JR(
        p,
        xn.memoizedState,
        l,
        d
      );
    },
    useTransition: function() {
      var l = Y1(ka)[0], d = ur().memoizedState;
      return [
        typeof l == "boolean" ? l : kp(l),
        d
      ];
    },
    useSyncExternalStore: TR,
    useId: n2,
    useHostTransitionStatus: rS,
    useFormState: FR,
    useActionState: FR,
    useOptimistic: function(l, d) {
      var p = ur();
      return xn !== null ? DR(p, xn, l, d) : (p.baseState = l, [l, p.queue.dispatch]);
    },
    useMemoCache: K1,
    useCacheRefresh: r2
  };
  l2.useEffectEvent = WR;
  function sS(l, d, p, y) {
    d = l.memoizedState, p = p(y, d), p = p == null ? d : h({}, d, p), l.memoizedState = p, l.lanes === 0 && (l.updateQueue.baseState = p);
  }
  var aS = {
    enqueueSetState: function(l, d, p) {
      l = l._reactInternals;
      var y = oo(), E = El(y);
      E.payload = d, p != null && (E.callback = p), d = _l(l, E, y), d !== null && (Fi(d, l, y), bp(d, l, y));
    },
    enqueueReplaceState: function(l, d, p) {
      l = l._reactInternals;
      var y = oo(), E = El(y);
      E.tag = 1, E.payload = d, p != null && (E.callback = p), d = _l(l, E, y), d !== null && (Fi(d, l, y), bp(d, l, y));
    },
    enqueueForceUpdate: function(l, d) {
      l = l._reactInternals;
      var p = oo(), y = El(p);
      y.tag = 2, d != null && (y.callback = d), d = _l(l, y, p), d !== null && (Fi(d, l, p), bp(d, l, p));
    }
  };
  function c2(l, d, p, y, E, T, j) {
    return l = l.stateNode, typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(y, T, j) : d.prototype && d.prototype.isPureReactComponent ? !k(p, y) || !k(E, T) : !0;
  }
  function u2(l, d, p, y) {
    l = d.state, typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(p, y), typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(p, y), d.state !== l && aS.enqueueReplaceState(d, d.state, null);
  }
  function vu(l, d) {
    var p = d;
    if ("ref" in d) {
      p = {};
      for (var y in d)
        y !== "ref" && (p[y] = d[y]);
    }
    if (l = l.defaultProps) {
      p === d && (p = h({}, p));
      for (var E in l)
        p[E] === void 0 && (p[E] = l[E]);
    }
    return p;
  }
  function d2(l) {
    Je(l);
  }
  function f2(l) {
    console.error(l);
  }
  function h2(l) {
    Je(l);
  }
  function Hy(l, d) {
    try {
      var p = l.onUncaughtError;
      p(d.value, { componentStack: d.stack });
    } catch (y) {
      setTimeout(function() {
        throw y;
      });
    }
  }
  function p2(l, d, p) {
    try {
      var y = l.onCaughtError;
      y(p.value, {
        componentStack: p.stack,
        errorBoundary: d.tag === 1 ? d.stateNode : null
      });
    } catch (E) {
      setTimeout(function() {
        throw E;
      });
    }
  }
  function lS(l, d, p) {
    return p = El(p), p.tag = 3, p.payload = { element: null }, p.callback = function() {
      Hy(l, d);
    }, p;
  }
  function m2(l) {
    return l = El(l), l.tag = 3, l;
  }
  function g2(l, d, p, y) {
    var E = p.type.getDerivedStateFromError;
    if (typeof E == "function") {
      var T = y.value;
      l.payload = function() {
        return E(T);
      }, l.callback = function() {
        p2(d, p, y);
      };
    }
    var j = p.stateNode;
    j !== null && typeof j.componentDidCatch == "function" && (l.callback = function() {
      p2(d, p, y), typeof E != "function" && (Ol === null ? Ol = /* @__PURE__ */ new Set([this]) : Ol.add(this));
      var V = y.stack;
      this.componentDidCatch(y.value, {
        componentStack: V !== null ? V : ""
      });
    });
  }
  function NG(l, d, p, y, E) {
    if (p.flags |= 32768, y !== null && typeof y == "object" && typeof y.then == "function") {
      if (d = p.alternate, d !== null && Fd(
        d,
        p,
        E,
        !0
      ), p = to.current, p !== null) {
        switch (p.tag) {
          case 31:
          case 13:
            return _o === null ? nv() : p.alternate === null && Qn === 0 && (Qn = 3), p.flags &= -257, p.flags |= 65536, p.lanes = E, y === Ry ? p.flags |= 16384 : (d = p.updateQueue, d === null ? p.updateQueue = /* @__PURE__ */ new Set([y]) : d.add(y), DS(l, y, E)), !1;
          case 22:
            return p.flags |= 65536, y === Ry ? p.flags |= 16384 : (d = p.updateQueue, d === null ? (d = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([y])
            }, p.updateQueue = d) : (p = d.retryQueue, p === null ? d.retryQueue = /* @__PURE__ */ new Set([y]) : p.add(y)), DS(l, y, E)), !1;
        }
        throw Error(r(435, p.tag));
      }
      return DS(l, y, E), nv(), !1;
    }
    if (Qt)
      return d = to.current, d !== null ? ((d.flags & 65536) === 0 && (d.flags |= 256), d.flags |= 65536, d.lanes = E, y !== T1 && (l = Error(r(422), { cause: y }), pp(So(l, p)))) : (y !== T1 && (d = Error(r(423), {
        cause: y
      }), pp(
        So(d, p)
      )), l = l.current.alternate, l.flags |= 65536, E &= -E, l.lanes |= E, y = So(y, p), E = lS(
        l.stateNode,
        y,
        E
      ), L1(l, E), Qn !== 4 && (Qn = 2)), !1;
    var T = Error(r(520), { cause: y });
    if (T = So(T, p), Dp === null ? Dp = [T] : Dp.push(T), Qn !== 4 && (Qn = 2), d === null) return !0;
    y = So(y, p), p = d;
    do {
      switch (p.tag) {
        case 3:
          return p.flags |= 65536, l = E & -E, p.lanes |= l, l = lS(p.stateNode, y, l), L1(p, l), !1;
        case 1:
          if (d = p.type, T = p.stateNode, (p.flags & 128) === 0 && (typeof d.getDerivedStateFromError == "function" || T !== null && typeof T.componentDidCatch == "function" && (Ol === null || !Ol.has(T))))
            return p.flags |= 65536, E &= -E, p.lanes |= E, E = m2(E), g2(
              E,
              l,
              p,
              y
            ), L1(p, E), !1;
      }
      p = p.return;
    } while (p !== null);
    return !1;
  }
  var cS = Error(r(461)), yr = !1;
  function Zr(l, d, p, y) {
    d.child = l === null ? xR(d, null, p, y) : gu(
      d,
      l.child,
      p,
      y
    );
  }
  function y2(l, d, p, y, E) {
    p = p.render;
    var T = d.ref;
    if ("ref" in y) {
      var j = {};
      for (var V in y)
        V !== "ref" && (j[V] = y[V]);
    } else j = y;
    return fu(d), y = H1(
      l,
      d,
      p,
      j,
      T,
      E
    ), V = W1(), l !== null && !yr ? (q1(l, d, E), Ca(l, d, E)) : (Qt && V && E1(d), d.flags |= 1, Zr(l, d, y, E), d.child);
  }
  function v2(l, d, p, y, E) {
    if (l === null) {
      var T = p.type;
      return typeof T == "function" && !S1(T) && T.defaultProps === void 0 && p.compare === null ? (d.tag = 15, d.type = T, b2(
        l,
        d,
        T,
        y,
        E
      )) : (l = Ey(
        p.type,
        null,
        y,
        d,
        d.mode,
        E
      ), l.ref = d.ref, l.return = d, d.child = l);
    }
    if (T = l.child, !yS(l, E)) {
      var j = T.memoizedProps;
      if (p = p.compare, p = p !== null ? p : k, p(j, y) && l.ref === d.ref)
        return Ca(l, d, E);
    }
    return d.flags |= 1, l = va(T, y), l.ref = d.ref, l.return = d, d.child = l;
  }
  function b2(l, d, p, y, E) {
    if (l !== null) {
      var T = l.memoizedProps;
      if (k(T, y) && l.ref === d.ref)
        if (yr = !1, d.pendingProps = y = T, yS(l, E))
          (l.flags & 131072) !== 0 && (yr = !0);
        else
          return d.lanes = l.lanes, Ca(l, d, E);
    }
    return uS(
      l,
      d,
      p,
      y,
      E
    );
  }
  function x2(l, d, p, y) {
    var E = y.children, T = l !== null ? l.memoizedState : null;
    if (l === null && d.stateNode === null && (d.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), y.mode === "hidden") {
      if ((d.flags & 128) !== 0) {
        if (T = T !== null ? T.baseLanes | p : p, l !== null) {
          for (y = d.child = l.child, E = 0; y !== null; )
            E = E | y.lanes | y.childLanes, y = y.sibling;
          y = E & ~T;
        } else y = 0, d.child = null;
        return w2(
          l,
          d,
          T,
          p,
          y
        );
      }
      if ((p & 536870912) !== 0)
        d.memoizedState = { baseLanes: 0, cachePool: null }, l !== null && My(
          d,
          T !== null ? T.cachePool : null
        ), T !== null ? kR(d, T) : $1(), CR(d);
      else
        return y = d.lanes = 536870912, w2(
          l,
          d,
          T !== null ? T.baseLanes | p : p,
          p,
          y
        );
    } else
      T !== null ? (My(d, T.cachePool), kR(d, T), Al(), d.memoizedState = null) : (l !== null && My(d, null), $1(), Al());
    return Zr(l, d, E, p), d.child;
  }
  function _p(l, d) {
    return l !== null && l.tag === 22 || d.stateNode !== null || (d.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), d.sibling;
  }
  function w2(l, d, p, y, E) {
    var T = P1();
    return T = T === null ? null : { parent: mr._currentValue, pool: T }, d.memoizedState = {
      baseLanes: p,
      cachePool: T
    }, l !== null && My(d, null), $1(), CR(d), l !== null && Fd(l, d, y, !0), d.childLanes = E, null;
  }
  function Wy(l, d) {
    return d = Gy(
      { mode: d.mode, children: d.children },
      l.mode
    ), d.ref = l.ref, l.child = d, d.return = l, d;
  }
  function S2(l, d, p) {
    return gu(d, l.child, null, p), l = Wy(d, d.pendingProps), l.flags |= 2, no(d), d.memoizedState = null, l;
  }
  function RG(l, d, p) {
    var y = d.pendingProps, E = (d.flags & 128) !== 0;
    if (d.flags &= -129, l === null) {
      if (Qt) {
        if (y.mode === "hidden")
          return l = Wy(d, y), d.lanes = 536870912, _p(null, l);
        if (F1(d), (l = Ln) ? (l = PO(
          l,
          Eo
        ), l = l !== null && l.data === "&" ? l : null, l !== null && (d.memoizedState = {
          dehydrated: l,
          treeContext: xl !== null ? { id: Ts, overflow: As } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, p = oR(l), p.return = d, d.child = p, Gr = d, Ln = null)) : l = null, l === null) throw Sl(d);
        return d.lanes = 536870912, null;
      }
      return Wy(d, y);
    }
    var T = l.memoizedState;
    if (T !== null) {
      var j = T.dehydrated;
      if (F1(d), E)
        if (d.flags & 256)
          d.flags &= -257, d = S2(
            l,
            d,
            p
          );
        else if (d.memoizedState !== null)
          d.child = l.child, d.flags |= 128, d = null;
        else throw Error(r(558));
      else if (yr || Fd(l, d, p, !1), E = (p & l.childLanes) !== 0, yr || E) {
        if (y = Cn, y !== null && (j = sr(y, p), j !== 0 && j !== T.retryLane))
          throw T.retryLane = j, un(l, j), Fi(y, l, j), cS;
        nv(), d = S2(
          l,
          d,
          p
        );
      } else
        l = T.treeContext, Ln = To(j.nextSibling), Gr = d, Qt = !0, wl = null, Eo = !1, l !== null && lR(d, l), d = Wy(d, y), d.flags |= 4096;
      return d;
    }
    return l = va(l.child, {
      mode: y.mode,
      children: y.children
    }), l.ref = d.ref, d.child = l, l.return = d, l;
  }
  function qy(l, d) {
    var p = d.ref;
    if (p === null)
      l !== null && l.ref !== null && (d.flags |= 4194816);
    else {
      if (typeof p != "function" && typeof p != "object")
        throw Error(r(284));
      (l === null || l.ref !== p) && (d.flags |= 4194816);
    }
  }
  function uS(l, d, p, y, E) {
    return fu(d), p = H1(
      l,
      d,
      p,
      y,
      void 0,
      E
    ), y = W1(), l !== null && !yr ? (q1(l, d, E), Ca(l, d, E)) : (Qt && y && E1(d), d.flags |= 1, Zr(l, d, p, E), d.child);
  }
  function k2(l, d, p, y, E, T) {
    return fu(d), d.updateQueue = null, p = _R(
      d,
      y,
      p,
      E
    ), ER(l), y = W1(), l !== null && !yr ? (q1(l, d, T), Ca(l, d, T)) : (Qt && y && E1(d), d.flags |= 1, Zr(l, d, p, T), d.child);
  }
  function C2(l, d, p, y, E) {
    if (fu(d), d.stateNode === null) {
      var T = Ld, j = p.contextType;
      typeof j == "object" && j !== null && (T = Kr(j)), T = new p(y, T), d.memoizedState = T.state !== null && T.state !== void 0 ? T.state : null, T.updater = aS, d.stateNode = T, T._reactInternals = d, T = d.stateNode, T.props = y, T.state = d.memoizedState, T.refs = {}, I1(d), j = p.contextType, T.context = typeof j == "object" && j !== null ? Kr(j) : Ld, T.state = d.memoizedState, j = p.getDerivedStateFromProps, typeof j == "function" && (sS(
        d,
        p,
        j,
        y
      ), T.state = d.memoizedState), typeof p.getDerivedStateFromProps == "function" || typeof T.getSnapshotBeforeUpdate == "function" || typeof T.UNSAFE_componentWillMount != "function" && typeof T.componentWillMount != "function" || (j = T.state, typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount(), j !== T.state && aS.enqueueReplaceState(T, T.state, null), wp(d, y, T, E), xp(), T.state = d.memoizedState), typeof T.componentDidMount == "function" && (d.flags |= 4194308), y = !0;
    } else if (l === null) {
      T = d.stateNode;
      var V = d.memoizedProps, te = vu(p, V);
      T.props = te;
      var Ee = T.context, Oe = p.contextType;
      j = Ld, typeof Oe == "object" && Oe !== null && (j = Kr(Oe));
      var Ie = p.getDerivedStateFromProps;
      Oe = typeof Ie == "function" || typeof T.getSnapshotBeforeUpdate == "function", V = d.pendingProps !== V, Oe || typeof T.UNSAFE_componentWillReceiveProps != "function" && typeof T.componentWillReceiveProps != "function" || (V || Ee !== j) && u2(
        d,
        T,
        y,
        j
      ), Cl = !1;
      var Te = d.memoizedState;
      T.state = Te, wp(d, y, T, E), xp(), Ee = d.memoizedState, V || Te !== Ee || Cl ? (typeof Ie == "function" && (sS(
        d,
        p,
        Ie,
        y
      ), Ee = d.memoizedState), (te = Cl || c2(
        d,
        p,
        te,
        y,
        Te,
        Ee,
        j
      )) ? (Oe || typeof T.UNSAFE_componentWillMount != "function" && typeof T.componentWillMount != "function" || (typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount()), typeof T.componentDidMount == "function" && (d.flags |= 4194308)) : (typeof T.componentDidMount == "function" && (d.flags |= 4194308), d.memoizedProps = y, d.memoizedState = Ee), T.props = y, T.state = Ee, T.context = j, y = te) : (typeof T.componentDidMount == "function" && (d.flags |= 4194308), y = !1);
    } else {
      T = d.stateNode, z1(l, d), j = d.memoizedProps, Oe = vu(p, j), T.props = Oe, Ie = d.pendingProps, Te = T.context, Ee = p.contextType, te = Ld, typeof Ee == "object" && Ee !== null && (te = Kr(Ee)), V = p.getDerivedStateFromProps, (Ee = typeof V == "function" || typeof T.getSnapshotBeforeUpdate == "function") || typeof T.UNSAFE_componentWillReceiveProps != "function" && typeof T.componentWillReceiveProps != "function" || (j !== Ie || Te !== te) && u2(
        d,
        T,
        y,
        te
      ), Cl = !1, Te = d.memoizedState, T.state = Te, wp(d, y, T, E), xp();
      var Me = d.memoizedState;
      j !== Ie || Te !== Me || Cl || l !== null && l.dependencies !== null && Ty(l.dependencies) ? (typeof V == "function" && (sS(
        d,
        p,
        V,
        y
      ), Me = d.memoizedState), (Oe = Cl || c2(
        d,
        p,
        Oe,
        y,
        Te,
        Me,
        te
      ) || l !== null && l.dependencies !== null && Ty(l.dependencies)) ? (Ee || typeof T.UNSAFE_componentWillUpdate != "function" && typeof T.componentWillUpdate != "function" || (typeof T.componentWillUpdate == "function" && T.componentWillUpdate(y, Me, te), typeof T.UNSAFE_componentWillUpdate == "function" && T.UNSAFE_componentWillUpdate(
        y,
        Me,
        te
      )), typeof T.componentDidUpdate == "function" && (d.flags |= 4), typeof T.getSnapshotBeforeUpdate == "function" && (d.flags |= 1024)) : (typeof T.componentDidUpdate != "function" || j === l.memoizedProps && Te === l.memoizedState || (d.flags |= 4), typeof T.getSnapshotBeforeUpdate != "function" || j === l.memoizedProps && Te === l.memoizedState || (d.flags |= 1024), d.memoizedProps = y, d.memoizedState = Me), T.props = y, T.state = Me, T.context = te, y = Oe) : (typeof T.componentDidUpdate != "function" || j === l.memoizedProps && Te === l.memoizedState || (d.flags |= 4), typeof T.getSnapshotBeforeUpdate != "function" || j === l.memoizedProps && Te === l.memoizedState || (d.flags |= 1024), y = !1);
    }
    return T = y, qy(l, d), y = (d.flags & 128) !== 0, T || y ? (T = d.stateNode, p = y && typeof p.getDerivedStateFromError != "function" ? null : T.render(), d.flags |= 1, l !== null && y ? (d.child = gu(
      d,
      l.child,
      null,
      E
    ), d.child = gu(
      d,
      null,
      p,
      E
    )) : Zr(l, d, p, E), d.memoizedState = T.state, l = d.child) : l = Ca(
      l,
      d,
      E
    ), l;
  }
  function E2(l, d, p, y) {
    return uu(), d.flags |= 256, Zr(l, d, p, y), d.child;
  }
  var dS = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function fS(l) {
    return { baseLanes: l, cachePool: pR() };
  }
  function hS(l, d, p) {
    return l = l !== null ? l.childLanes & ~p : 0, d && (l |= io), l;
  }
  function _2(l, d, p) {
    var y = d.pendingProps, E = !1, T = (d.flags & 128) !== 0, j;
    if ((j = T) || (j = l !== null && l.memoizedState === null ? !1 : (cr.current & 2) !== 0), j && (E = !0, d.flags &= -129), j = (d.flags & 32) !== 0, d.flags &= -33, l === null) {
      if (Qt) {
        if (E ? Tl(d) : Al(), (l = Ln) ? (l = PO(
          l,
          Eo
        ), l = l !== null && l.data !== "&" ? l : null, l !== null && (d.memoizedState = {
          dehydrated: l,
          treeContext: xl !== null ? { id: Ts, overflow: As } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, p = oR(l), p.return = d, d.child = p, Gr = d, Ln = null)) : l = null, l === null) throw Sl(d);
        return ZS(l) ? d.lanes = 32 : d.lanes = 536870912, null;
      }
      var V = y.children;
      return y = y.fallback, E ? (Al(), E = d.mode, V = Gy(
        { mode: "hidden", children: V },
        E
      ), y = cu(
        y,
        E,
        p,
        null
      ), V.return = d, y.return = d, V.sibling = y, d.child = V, y = d.child, y.memoizedState = fS(p), y.childLanes = hS(
        l,
        j,
        p
      ), d.memoizedState = dS, _p(null, y)) : (Tl(d), pS(d, V));
    }
    var te = l.memoizedState;
    if (te !== null && (V = te.dehydrated, V !== null)) {
      if (T)
        d.flags & 256 ? (Tl(d), d.flags &= -257, d = mS(
          l,
          d,
          p
        )) : d.memoizedState !== null ? (Al(), d.child = l.child, d.flags |= 128, d = null) : (Al(), V = y.fallback, E = d.mode, y = Gy(
          { mode: "visible", children: y.children },
          E
        ), V = cu(
          V,
          E,
          p,
          null
        ), V.flags |= 2, y.return = d, V.return = d, y.sibling = V, d.child = y, gu(
          d,
          l.child,
          null,
          p
        ), y = d.child, y.memoizedState = fS(p), y.childLanes = hS(
          l,
          j,
          p
        ), d.memoizedState = dS, d = _p(null, y));
      else if (Tl(d), ZS(V)) {
        if (j = V.nextSibling && V.nextSibling.dataset, j) var Ee = j.dgst;
        j = Ee, y = Error(r(419)), y.stack = "", y.digest = j, pp({ value: y, source: null, stack: null }), d = mS(
          l,
          d,
          p
        );
      } else if (yr || Fd(l, d, p, !1), j = (p & l.childLanes) !== 0, yr || j) {
        if (j = Cn, j !== null && (y = sr(j, p), y !== 0 && y !== te.retryLane))
          throw te.retryLane = y, un(l, y), Fi(j, l, y), cS;
        KS(V) || nv(), d = mS(
          l,
          d,
          p
        );
      } else
        KS(V) ? (d.flags |= 192, d.child = l.child, d = null) : (l = te.treeContext, Ln = To(
          V.nextSibling
        ), Gr = d, Qt = !0, wl = null, Eo = !1, l !== null && lR(d, l), d = pS(
          d,
          y.children
        ), d.flags |= 4096);
      return d;
    }
    return E ? (Al(), V = y.fallback, E = d.mode, te = l.child, Ee = te.sibling, y = va(te, {
      mode: "hidden",
      children: y.children
    }), y.subtreeFlags = te.subtreeFlags & 65011712, Ee !== null ? V = va(
      Ee,
      V
    ) : (V = cu(
      V,
      E,
      p,
      null
    ), V.flags |= 2), V.return = d, y.return = d, y.sibling = V, d.child = y, _p(null, y), y = d.child, V = l.child.memoizedState, V === null ? V = fS(p) : (E = V.cachePool, E !== null ? (te = mr._currentValue, E = E.parent !== te ? { parent: te, pool: te } : E) : E = pR(), V = {
      baseLanes: V.baseLanes | p,
      cachePool: E
    }), y.memoizedState = V, y.childLanes = hS(
      l,
      j,
      p
    ), d.memoizedState = dS, _p(l.child, y)) : (Tl(d), p = l.child, l = p.sibling, p = va(p, {
      mode: "visible",
      children: y.children
    }), p.return = d, p.sibling = null, l !== null && (j = d.deletions, j === null ? (d.deletions = [l], d.flags |= 16) : j.push(l)), d.child = p, d.memoizedState = null, p);
  }
  function pS(l, d) {
    return d = Gy(
      { mode: "visible", children: d },
      l.mode
    ), d.return = l, l.child = d;
  }
  function Gy(l, d) {
    return l = eo(22, l, null, d), l.lanes = 0, l;
  }
  function mS(l, d, p) {
    return gu(d, l.child, null, p), l = pS(
      d,
      d.pendingProps.children
    ), l.flags |= 2, d.memoizedState = null, l;
  }
  function T2(l, d, p) {
    l.lanes |= d;
    var y = l.alternate;
    y !== null && (y.lanes |= d), N1(l.return, d, p);
  }
  function gS(l, d, p, y, E, T) {
    var j = l.memoizedState;
    j === null ? l.memoizedState = {
      isBackwards: d,
      rendering: null,
      renderingStartTime: 0,
      last: y,
      tail: p,
      tailMode: E,
      treeForkCount: T
    } : (j.isBackwards = d, j.rendering = null, j.renderingStartTime = 0, j.last = y, j.tail = p, j.tailMode = E, j.treeForkCount = T);
  }
  function A2(l, d, p) {
    var y = d.pendingProps, E = y.revealOrder, T = y.tail;
    y = y.children;
    var j = cr.current, V = (j & 2) !== 0;
    if (V ? (j = j & 1 | 2, d.flags |= 128) : j &= 1, F(cr, j), Zr(l, d, y, p), y = Qt ? hp : 0, !V && l !== null && (l.flags & 128) !== 0)
      e: for (l = d.child; l !== null; ) {
        if (l.tag === 13)
          l.memoizedState !== null && T2(l, p, d);
        else if (l.tag === 19)
          T2(l, p, d);
        else if (l.child !== null) {
          l.child.return = l, l = l.child;
          continue;
        }
        if (l === d) break e;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === d)
            break e;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    switch (E) {
      case "forwards":
        for (p = d.child, E = null; p !== null; )
          l = p.alternate, l !== null && jy(l) === null && (E = p), p = p.sibling;
        p = E, p === null ? (E = d.child, d.child = null) : (E = p.sibling, p.sibling = null), gS(
          d,
          !1,
          E,
          p,
          T,
          y
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (p = null, E = d.child, d.child = null; E !== null; ) {
          if (l = E.alternate, l !== null && jy(l) === null) {
            d.child = E;
            break;
          }
          l = E.sibling, E.sibling = p, p = E, E = l;
        }
        gS(
          d,
          !0,
          p,
          null,
          T,
          y
        );
        break;
      case "together":
        gS(
          d,
          !1,
          null,
          null,
          void 0,
          y
        );
        break;
      default:
        d.memoizedState = null;
    }
    return d.child;
  }
  function Ca(l, d, p) {
    if (l !== null && (d.dependencies = l.dependencies), Rl |= d.lanes, (p & d.childLanes) === 0)
      if (l !== null) {
        if (Fd(
          l,
          d,
          p,
          !1
        ), (p & d.childLanes) === 0)
          return null;
      } else return null;
    if (l !== null && d.child !== l.child)
      throw Error(r(153));
    if (d.child !== null) {
      for (l = d.child, p = va(l, l.pendingProps), d.child = p, p.return = d; l.sibling !== null; )
        l = l.sibling, p = p.sibling = va(l, l.pendingProps), p.return = d;
      p.sibling = null;
    }
    return d.child;
  }
  function yS(l, d) {
    return (l.lanes & d) !== 0 ? !0 : (l = l.dependencies, !!(l !== null && Ty(l)));
  }
  function OG(l, d, p) {
    switch (d.tag) {
      case 3:
        xe(d, d.stateNode.containerInfo), kl(d, mr, l.memoizedState.cache), uu();
        break;
      case 27:
      case 5:
        Ae(d);
        break;
      case 4:
        xe(d, d.stateNode.containerInfo);
        break;
      case 10:
        kl(
          d,
          d.type,
          d.memoizedProps.value
        );
        break;
      case 31:
        if (d.memoizedState !== null)
          return d.flags |= 128, F1(d), null;
        break;
      case 13:
        var y = d.memoizedState;
        if (y !== null)
          return y.dehydrated !== null ? (Tl(d), d.flags |= 128, null) : (p & d.child.childLanes) !== 0 ? _2(l, d, p) : (Tl(d), l = Ca(
            l,
            d,
            p
          ), l !== null ? l.sibling : null);
        Tl(d);
        break;
      case 19:
        var E = (l.flags & 128) !== 0;
        if (y = (p & d.childLanes) !== 0, y || (Fd(
          l,
          d,
          p,
          !1
        ), y = (p & d.childLanes) !== 0), E) {
          if (y)
            return A2(
              l,
              d,
              p
            );
          d.flags |= 128;
        }
        if (E = d.memoizedState, E !== null && (E.rendering = null, E.tail = null, E.lastEffect = null), F(cr, cr.current), y) break;
        return null;
      case 22:
        return d.lanes = 0, x2(
          l,
          d,
          p,
          d.pendingProps
        );
      case 24:
        kl(d, mr, l.memoizedState.cache);
    }
    return Ca(l, d, p);
  }
  function M2(l, d, p) {
    if (l !== null)
      if (l.memoizedProps !== d.pendingProps)
        yr = !0;
      else {
        if (!yS(l, p) && (d.flags & 128) === 0)
          return yr = !1, OG(
            l,
            d,
            p
          );
        yr = (l.flags & 131072) !== 0;
      }
    else
      yr = !1, Qt && (d.flags & 1048576) !== 0 && aR(d, hp, d.index);
    switch (d.lanes = 0, d.tag) {
      case 16:
        e: {
          var y = d.pendingProps;
          if (l = pu(d.elementType), d.type = l, typeof l == "function")
            S1(l) ? (y = vu(l, y), d.tag = 1, d = C2(
              null,
              d,
              l,
              y,
              p
            )) : (d.tag = 0, d = uS(
              null,
              d,
              l,
              y,
              p
            ));
          else {
            if (l != null) {
              var E = l.$$typeof;
              if (E === N) {
                d.tag = 11, d = y2(
                  null,
                  d,
                  l,
                  y,
                  p
                );
                break e;
              } else if (E === O) {
                d.tag = 14, d = v2(
                  null,
                  d,
                  l,
                  y,
                  p
                );
                break e;
              }
            }
            throw d = ie(l) || l, Error(r(306, d, ""));
          }
        }
        return d;
      case 0:
        return uS(
          l,
          d,
          d.type,
          d.pendingProps,
          p
        );
      case 1:
        return y = d.type, E = vu(
          y,
          d.pendingProps
        ), C2(
          l,
          d,
          y,
          E,
          p
        );
      case 3:
        e: {
          if (xe(
            d,
            d.stateNode.containerInfo
          ), l === null) throw Error(r(387));
          y = d.pendingProps;
          var T = d.memoizedState;
          E = T.element, z1(l, d), wp(d, y, null, p);
          var j = d.memoizedState;
          if (y = j.cache, kl(d, mr, y), y !== T.cache && R1(
            d,
            [mr],
            p,
            !0
          ), xp(), y = j.element, T.isDehydrated)
            if (T = {
              element: y,
              isDehydrated: !1,
              cache: j.cache
            }, d.updateQueue.baseState = T, d.memoizedState = T, d.flags & 256) {
              d = E2(
                l,
                d,
                y,
                p
              );
              break e;
            } else if (y !== E) {
              E = So(
                Error(r(424)),
                d
              ), pp(E), d = E2(
                l,
                d,
                y,
                p
              );
              break e;
            } else
              for (l = d.stateNode.containerInfo, l.nodeType === 9 ? l = l.body : l = l.nodeName === "HTML" ? l.ownerDocument.body : l, Ln = To(l.firstChild), Gr = d, Qt = !0, wl = null, Eo = !0, p = xR(
                d,
                null,
                y,
                p
              ), d.child = p; p; )
                p.flags = p.flags & -3 | 4096, p = p.sibling;
          else {
            if (uu(), y === E) {
              d = Ca(
                l,
                d,
                p
              );
              break e;
            }
            Zr(l, d, y, p);
          }
          d = d.child;
        }
        return d;
      case 26:
        return qy(l, d), l === null ? (p = $O(
          d.type,
          null,
          d.pendingProps,
          null
        )) ? d.memoizedState = p : Qt || (p = d.type, l = d.pendingProps, y = cv(
          re.current
        ).createElement(p), y[Nn] = d, y[ar] = l, Yr(y, p, l), lr(y), d.stateNode = y) : d.memoizedState = $O(
          d.type,
          l.memoizedProps,
          d.pendingProps,
          l.memoizedState
        ), null;
      case 27:
        return Ae(d), l === null && Qt && (y = d.stateNode = zO(
          d.type,
          d.pendingProps,
          re.current
        ), Gr = d, Eo = !0, E = Ln, Il(d.type) ? (YS = E, Ln = To(y.firstChild)) : Ln = E), Zr(
          l,
          d,
          d.pendingProps.children,
          p
        ), qy(l, d), l === null && (d.flags |= 4194304), d.child;
      case 5:
        return l === null && Qt && ((E = y = Ln) && (y = lK(
          y,
          d.type,
          d.pendingProps,
          Eo
        ), y !== null ? (d.stateNode = y, Gr = d, Ln = To(y.firstChild), Eo = !1, E = !0) : E = !1), E || Sl(d)), Ae(d), E = d.type, T = d.pendingProps, j = l !== null ? l.memoizedProps : null, y = T.children, WS(E, T) ? y = null : j !== null && WS(E, j) && (d.flags |= 32), d.memoizedState !== null && (E = H1(
          l,
          d,
          kG,
          null,
          null,
          p
        ), Up._currentValue = E), qy(l, d), Zr(l, d, y, p), d.child;
      case 6:
        return l === null && Qt && ((l = p = Ln) && (p = cK(
          p,
          d.pendingProps,
          Eo
        ), p !== null ? (d.stateNode = p, Gr = d, Ln = null, l = !0) : l = !1), l || Sl(d)), null;
      case 13:
        return _2(l, d, p);
      case 4:
        return xe(
          d,
          d.stateNode.containerInfo
        ), y = d.pendingProps, l === null ? d.child = gu(
          d,
          null,
          y,
          p
        ) : Zr(l, d, y, p), d.child;
      case 11:
        return y2(
          l,
          d,
          d.type,
          d.pendingProps,
          p
        );
      case 7:
        return Zr(
          l,
          d,
          d.pendingProps,
          p
        ), d.child;
      case 8:
        return Zr(
          l,
          d,
          d.pendingProps.children,
          p
        ), d.child;
      case 12:
        return Zr(
          l,
          d,
          d.pendingProps.children,
          p
        ), d.child;
      case 10:
        return y = d.pendingProps, kl(d, d.type, y.value), Zr(l, d, y.children, p), d.child;
      case 9:
        return E = d.type._context, y = d.pendingProps.children, fu(d), E = Kr(E), y = y(E), d.flags |= 1, Zr(l, d, y, p), d.child;
      case 14:
        return v2(
          l,
          d,
          d.type,
          d.pendingProps,
          p
        );
      case 15:
        return b2(
          l,
          d,
          d.type,
          d.pendingProps,
          p
        );
      case 19:
        return A2(l, d, p);
      case 31:
        return RG(l, d, p);
      case 22:
        return x2(
          l,
          d,
          p,
          d.pendingProps
        );
      case 24:
        return fu(d), y = Kr(mr), l === null ? (E = P1(), E === null && (E = Cn, T = O1(), E.pooledCache = T, T.refCount++, T !== null && (E.pooledCacheLanes |= p), E = T), d.memoizedState = { parent: y, cache: E }, I1(d), kl(d, mr, E)) : ((l.lanes & p) !== 0 && (z1(l, d), wp(d, null, null, p), xp()), E = l.memoizedState, T = d.memoizedState, E.parent !== y ? (E = { parent: y, cache: y }, d.memoizedState = E, d.lanes === 0 && (d.memoizedState = d.updateQueue.baseState = E), kl(d, mr, y)) : (y = T.cache, kl(d, mr, y), y !== E.cache && R1(
          d,
          [mr],
          p,
          !0
        ))), Zr(
          l,
          d,
          d.pendingProps.children,
          p
        ), d.child;
      case 29:
        throw d.pendingProps;
    }
    throw Error(r(156, d.tag));
  }
  function Ea(l) {
    l.flags |= 4;
  }
  function vS(l, d, p, y, E) {
    if ((d = (l.mode & 32) !== 0) && (d = !1), d) {
      if (l.flags |= 16777216, (E & 335544128) === E)
        if (l.stateNode.complete) l.flags |= 8192;
        else if (nO()) l.flags |= 8192;
        else
          throw mu = Ry, j1;
    } else l.flags &= -16777217;
  }
  function N2(l, d) {
    if (d.type !== "stylesheet" || (d.state.loading & 4) !== 0)
      l.flags &= -16777217;
    else if (l.flags |= 16777216, !WO(d))
      if (nO()) l.flags |= 8192;
      else
        throw mu = Ry, j1;
  }
  function Ky(l, d) {
    d !== null && (l.flags |= 4), l.flags & 16384 && (d = l.tag !== 22 ? uy() : 536870912, l.lanes |= d, ef |= d);
  }
  function Tp(l, d) {
    if (!Qt)
      switch (l.tailMode) {
        case "hidden":
          d = l.tail;
          for (var p = null; d !== null; )
            d.alternate !== null && (p = d), d = d.sibling;
          p === null ? l.tail = null : p.sibling = null;
          break;
        case "collapsed":
          p = l.tail;
          for (var y = null; p !== null; )
            p.alternate !== null && (y = p), p = p.sibling;
          y === null ? d || l.tail === null ? l.tail = null : l.tail.sibling = null : y.sibling = null;
      }
  }
  function Bn(l) {
    var d = l.alternate !== null && l.alternate.child === l.child, p = 0, y = 0;
    if (d)
      for (var E = l.child; E !== null; )
        p |= E.lanes | E.childLanes, y |= E.subtreeFlags & 65011712, y |= E.flags & 65011712, E.return = l, E = E.sibling;
    else
      for (E = l.child; E !== null; )
        p |= E.lanes | E.childLanes, y |= E.subtreeFlags, y |= E.flags, E.return = l, E = E.sibling;
    return l.subtreeFlags |= y, l.childLanes = p, d;
  }
  function DG(l, d, p) {
    var y = d.pendingProps;
    switch (_1(d), d.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Bn(d), null;
      case 1:
        return Bn(d), null;
      case 3:
        return p = d.stateNode, y = null, l !== null && (y = l.memoizedState.cache), d.memoizedState.cache !== y && (d.flags |= 2048), wa(mr), be(), p.pendingContext && (p.context = p.pendingContext, p.pendingContext = null), (l === null || l.child === null) && (Ud(d) ? Ea(d) : l === null || l.memoizedState.isDehydrated && (d.flags & 256) === 0 || (d.flags |= 1024, A1())), Bn(d), null;
      case 26:
        var E = d.type, T = d.memoizedState;
        return l === null ? (Ea(d), T !== null ? (Bn(d), N2(d, T)) : (Bn(d), vS(
          d,
          E,
          null,
          y,
          p
        ))) : T ? T !== l.memoizedState ? (Ea(d), Bn(d), N2(d, T)) : (Bn(d), d.flags &= -16777217) : (l = l.memoizedProps, l !== y && Ea(d), Bn(d), vS(
          d,
          E,
          l,
          y,
          p
        )), null;
      case 27:
        if (tt(d), p = re.current, E = d.type, l !== null && d.stateNode != null)
          l.memoizedProps !== y && Ea(d);
        else {
          if (!y) {
            if (d.stateNode === null)
              throw Error(r(166));
            return Bn(d), null;
          }
          l = ee.current, Ud(d) ? cR(d) : (l = zO(E, y, p), d.stateNode = l, Ea(d));
        }
        return Bn(d), null;
      case 5:
        if (tt(d), E = d.type, l !== null && d.stateNode != null)
          l.memoizedProps !== y && Ea(d);
        else {
          if (!y) {
            if (d.stateNode === null)
              throw Error(r(166));
            return Bn(d), null;
          }
          if (T = ee.current, Ud(d))
            cR(d);
          else {
            var j = cv(
              re.current
            );
            switch (T) {
              case 1:
                T = j.createElementNS(
                  "http://www.w3.org/2000/svg",
                  E
                );
                break;
              case 2:
                T = j.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  E
                );
                break;
              default:
                switch (E) {
                  case "svg":
                    T = j.createElementNS(
                      "http://www.w3.org/2000/svg",
                      E
                    );
                    break;
                  case "math":
                    T = j.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      E
                    );
                    break;
                  case "script":
                    T = j.createElement("div"), T.innerHTML = "<script><\/script>", T = T.removeChild(
                      T.firstChild
                    );
                    break;
                  case "select":
                    T = typeof y.is == "string" ? j.createElement("select", {
                      is: y.is
                    }) : j.createElement("select"), y.multiple ? T.multiple = !0 : y.size && (T.size = y.size);
                    break;
                  default:
                    T = typeof y.is == "string" ? j.createElement(E, { is: y.is }) : j.createElement(E);
                }
            }
            T[Nn] = d, T[ar] = y;
            e: for (j = d.child; j !== null; ) {
              if (j.tag === 5 || j.tag === 6)
                T.appendChild(j.stateNode);
              else if (j.tag !== 4 && j.tag !== 27 && j.child !== null) {
                j.child.return = j, j = j.child;
                continue;
              }
              if (j === d) break e;
              for (; j.sibling === null; ) {
                if (j.return === null || j.return === d)
                  break e;
                j = j.return;
              }
              j.sibling.return = j.return, j = j.sibling;
            }
            d.stateNode = T;
            e: switch (Yr(T, E, y), E) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                y = !!y.autoFocus;
                break e;
              case "img":
                y = !0;
                break e;
              default:
                y = !1;
            }
            y && Ea(d);
          }
        }
        return Bn(d), vS(
          d,
          d.type,
          l === null ? null : l.memoizedProps,
          d.pendingProps,
          p
        ), null;
      case 6:
        if (l && d.stateNode != null)
          l.memoizedProps !== y && Ea(d);
        else {
          if (typeof y != "string" && d.stateNode === null)
            throw Error(r(166));
          if (l = re.current, Ud(d)) {
            if (l = d.stateNode, p = d.memoizedProps, y = null, E = Gr, E !== null)
              switch (E.tag) {
                case 27:
                case 5:
                  y = E.memoizedProps;
              }
            l[Nn] = d, l = !!(l.nodeValue === p || y !== null && y.suppressHydrationWarning === !0 || _O(l.nodeValue, p)), l || Sl(d, !0);
          } else
            l = cv(l).createTextNode(
              y
            ), l[Nn] = d, d.stateNode = l;
        }
        return Bn(d), null;
      case 31:
        if (p = d.memoizedState, l === null || l.memoizedState !== null) {
          if (y = Ud(d), p !== null) {
            if (l === null) {
              if (!y) throw Error(r(318));
              if (l = d.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(557));
              l[Nn] = d;
            } else
              uu(), (d.flags & 128) === 0 && (d.memoizedState = null), d.flags |= 4;
            Bn(d), l = !1;
          } else
            p = A1(), l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = p), l = !0;
          if (!l)
            return d.flags & 256 ? (no(d), d) : (no(d), null);
          if ((d.flags & 128) !== 0)
            throw Error(r(558));
        }
        return Bn(d), null;
      case 13:
        if (y = d.memoizedState, l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) {
          if (E = Ud(d), y !== null && y.dehydrated !== null) {
            if (l === null) {
              if (!E) throw Error(r(318));
              if (E = d.memoizedState, E = E !== null ? E.dehydrated : null, !E) throw Error(r(317));
              E[Nn] = d;
            } else
              uu(), (d.flags & 128) === 0 && (d.memoizedState = null), d.flags |= 4;
            Bn(d), E = !1;
          } else
            E = A1(), l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = E), E = !0;
          if (!E)
            return d.flags & 256 ? (no(d), d) : (no(d), null);
        }
        return no(d), (d.flags & 128) !== 0 ? (d.lanes = p, d) : (p = y !== null, l = l !== null && l.memoizedState !== null, p && (y = d.child, E = null, y.alternate !== null && y.alternate.memoizedState !== null && y.alternate.memoizedState.cachePool !== null && (E = y.alternate.memoizedState.cachePool.pool), T = null, y.memoizedState !== null && y.memoizedState.cachePool !== null && (T = y.memoizedState.cachePool.pool), T !== E && (y.flags |= 2048)), p !== l && p && (d.child.flags |= 8192), Ky(d, d.updateQueue), Bn(d), null);
      case 4:
        return be(), l === null && $S(d.stateNode.containerInfo), Bn(d), null;
      case 10:
        return wa(d.type), Bn(d), null;
      case 19:
        if (pe(cr), y = d.memoizedState, y === null) return Bn(d), null;
        if (E = (d.flags & 128) !== 0, T = y.rendering, T === null)
          if (E) Tp(y, !1);
          else {
            if (Qn !== 0 || l !== null && (l.flags & 128) !== 0)
              for (l = d.child; l !== null; ) {
                if (T = jy(l), T !== null) {
                  for (d.flags |= 128, Tp(y, !1), l = T.updateQueue, d.updateQueue = l, Ky(d, l), d.subtreeFlags = 0, l = p, p = d.child; p !== null; )
                    iR(p, l), p = p.sibling;
                  return F(
                    cr,
                    cr.current & 1 | 2
                  ), Qt && ba(d, y.treeForkCount), d.child;
                }
                l = l.sibling;
              }
            y.tail !== null && Mn() > Qy && (d.flags |= 128, E = !0, Tp(y, !1), d.lanes = 4194304);
          }
        else {
          if (!E)
            if (l = jy(T), l !== null) {
              if (d.flags |= 128, E = !0, l = l.updateQueue, d.updateQueue = l, Ky(d, l), Tp(y, !0), y.tail === null && y.tailMode === "hidden" && !T.alternate && !Qt)
                return Bn(d), null;
            } else
              2 * Mn() - y.renderingStartTime > Qy && p !== 536870912 && (d.flags |= 128, E = !0, Tp(y, !1), d.lanes = 4194304);
          y.isBackwards ? (T.sibling = d.child, d.child = T) : (l = y.last, l !== null ? l.sibling = T : d.child = T, y.last = T);
        }
        return y.tail !== null ? (l = y.tail, y.rendering = l, y.tail = l.sibling, y.renderingStartTime = Mn(), l.sibling = null, p = cr.current, F(
          cr,
          E ? p & 1 | 2 : p & 1
        ), Qt && ba(d, y.treeForkCount), l) : (Bn(d), null);
      case 22:
      case 23:
        return no(d), U1(), y = d.memoizedState !== null, l !== null ? l.memoizedState !== null !== y && (d.flags |= 8192) : y && (d.flags |= 8192), y ? (p & 536870912) !== 0 && (d.flags & 128) === 0 && (Bn(d), d.subtreeFlags & 6 && (d.flags |= 8192)) : Bn(d), p = d.updateQueue, p !== null && Ky(d, p.retryQueue), p = null, l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (p = l.memoizedState.cachePool.pool), y = null, d.memoizedState !== null && d.memoizedState.cachePool !== null && (y = d.memoizedState.cachePool.pool), y !== p && (d.flags |= 2048), l !== null && pe(hu), null;
      case 24:
        return p = null, l !== null && (p = l.memoizedState.cache), d.memoizedState.cache !== p && (d.flags |= 2048), wa(mr), Bn(d), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(r(156, d.tag));
  }
  function PG(l, d) {
    switch (_1(d), d.tag) {
      case 1:
        return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
      case 3:
        return wa(mr), be(), l = d.flags, (l & 65536) !== 0 && (l & 128) === 0 ? (d.flags = l & -65537 | 128, d) : null;
      case 26:
      case 27:
      case 5:
        return tt(d), null;
      case 31:
        if (d.memoizedState !== null) {
          if (no(d), d.alternate === null)
            throw Error(r(340));
          uu();
        }
        return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
      case 13:
        if (no(d), l = d.memoizedState, l !== null && l.dehydrated !== null) {
          if (d.alternate === null)
            throw Error(r(340));
          uu();
        }
        return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
      case 19:
        return pe(cr), null;
      case 4:
        return be(), null;
      case 10:
        return wa(d.type), null;
      case 22:
      case 23:
        return no(d), U1(), l !== null && pe(hu), l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null;
      case 24:
        return wa(mr), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function R2(l, d) {
    switch (_1(d), d.tag) {
      case 3:
        wa(mr), be();
        break;
      case 26:
      case 27:
      case 5:
        tt(d);
        break;
      case 4:
        be();
        break;
      case 31:
        d.memoizedState !== null && no(d);
        break;
      case 13:
        no(d);
        break;
      case 19:
        pe(cr);
        break;
      case 10:
        wa(d.type);
        break;
      case 22:
      case 23:
        no(d), U1(), l !== null && pe(hu);
        break;
      case 24:
        wa(mr);
    }
  }
  function Ap(l, d) {
    try {
      var p = d.updateQueue, y = p !== null ? p.lastEffect : null;
      if (y !== null) {
        var E = y.next;
        p = E;
        do {
          if ((p.tag & l) === l) {
            y = void 0;
            var T = p.create, j = p.inst;
            y = T(), j.destroy = y;
          }
          p = p.next;
        } while (p !== E);
      }
    } catch (V) {
      pn(d, d.return, V);
    }
  }
  function Ml(l, d, p) {
    try {
      var y = d.updateQueue, E = y !== null ? y.lastEffect : null;
      if (E !== null) {
        var T = E.next;
        y = T;
        do {
          if ((y.tag & l) === l) {
            var j = y.inst, V = j.destroy;
            if (V !== void 0) {
              j.destroy = void 0, E = d;
              var te = p, Ee = V;
              try {
                Ee();
              } catch (Oe) {
                pn(
                  E,
                  te,
                  Oe
                );
              }
            }
          }
          y = y.next;
        } while (y !== T);
      }
    } catch (Oe) {
      pn(d, d.return, Oe);
    }
  }
  function O2(l) {
    var d = l.updateQueue;
    if (d !== null) {
      var p = l.stateNode;
      try {
        SR(d, p);
      } catch (y) {
        pn(l, l.return, y);
      }
    }
  }
  function D2(l, d, p) {
    p.props = vu(
      l.type,
      l.memoizedProps
    ), p.state = l.memoizedState;
    try {
      p.componentWillUnmount();
    } catch (y) {
      pn(l, d, y);
    }
  }
  function Mp(l, d) {
    try {
      var p = l.ref;
      if (p !== null) {
        switch (l.tag) {
          case 26:
          case 27:
          case 5:
            var y = l.stateNode;
            break;
          case 30:
            y = l.stateNode;
            break;
          default:
            y = l.stateNode;
        }
        typeof p == "function" ? l.refCleanup = p(y) : p.current = y;
      }
    } catch (E) {
      pn(l, d, E);
    }
  }
  function Ms(l, d) {
    var p = l.ref, y = l.refCleanup;
    if (p !== null)
      if (typeof y == "function")
        try {
          y();
        } catch (E) {
          pn(l, d, E);
        } finally {
          l.refCleanup = null, l = l.alternate, l != null && (l.refCleanup = null);
        }
      else if (typeof p == "function")
        try {
          p(null);
        } catch (E) {
          pn(l, d, E);
        }
      else p.current = null;
  }
  function P2(l) {
    var d = l.type, p = l.memoizedProps, y = l.stateNode;
    try {
      e: switch (d) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          p.autoFocus && y.focus();
          break e;
        case "img":
          p.src ? y.src = p.src : p.srcSet && (y.srcset = p.srcSet);
      }
    } catch (E) {
      pn(l, l.return, E);
    }
  }
  function bS(l, d, p) {
    try {
      var y = l.stateNode;
      nK(y, l.type, p, d), y[ar] = d;
    } catch (E) {
      pn(l, l.return, E);
    }
  }
  function j2(l) {
    return l.tag === 5 || l.tag === 3 || l.tag === 26 || l.tag === 27 && Il(l.type) || l.tag === 4;
  }
  function xS(l) {
    e: for (; ; ) {
      for (; l.sibling === null; ) {
        if (l.return === null || j2(l.return)) return null;
        l = l.return;
      }
      for (l.sibling.return = l.return, l = l.sibling; l.tag !== 5 && l.tag !== 6 && l.tag !== 18; ) {
        if (l.tag === 27 && Il(l.type) || l.flags & 2 || l.child === null || l.tag === 4) continue e;
        l.child.return = l, l = l.child;
      }
      if (!(l.flags & 2)) return l.stateNode;
    }
  }
  function wS(l, d, p) {
    var y = l.tag;
    if (y === 5 || y === 6)
      l = l.stateNode, d ? (p.nodeType === 9 ? p.body : p.nodeName === "HTML" ? p.ownerDocument.body : p).insertBefore(l, d) : (d = p.nodeType === 9 ? p.body : p.nodeName === "HTML" ? p.ownerDocument.body : p, d.appendChild(l), p = p._reactRootContainer, p != null || d.onclick !== null || (d.onclick = zi));
    else if (y !== 4 && (y === 27 && Il(l.type) && (p = l.stateNode, d = null), l = l.child, l !== null))
      for (wS(l, d, p), l = l.sibling; l !== null; )
        wS(l, d, p), l = l.sibling;
  }
  function Zy(l, d, p) {
    var y = l.tag;
    if (y === 5 || y === 6)
      l = l.stateNode, d ? p.insertBefore(l, d) : p.appendChild(l);
    else if (y !== 4 && (y === 27 && Il(l.type) && (p = l.stateNode), l = l.child, l !== null))
      for (Zy(l, d, p), l = l.sibling; l !== null; )
        Zy(l, d, p), l = l.sibling;
  }
  function I2(l) {
    var d = l.stateNode, p = l.memoizedProps;
    try {
      for (var y = l.type, E = d.attributes; E.length; )
        d.removeAttributeNode(E[0]);
      Yr(d, y, p), d[Nn] = l, d[ar] = p;
    } catch (T) {
      pn(l, l.return, T);
    }
  }
  var _a = !1, vr = !1, SS = !1, z2 = typeof WeakSet == "function" ? WeakSet : Set, Lr = null;
  function jG(l, d) {
    if (l = l.containerInfo, VS = gv, l = z(l), $(l)) {
      if ("selectionStart" in l)
        var p = {
          start: l.selectionStart,
          end: l.selectionEnd
        };
      else
        e: {
          p = (p = l.ownerDocument) && p.defaultView || window;
          var y = p.getSelection && p.getSelection();
          if (y && y.rangeCount !== 0) {
            p = y.anchorNode;
            var E = y.anchorOffset, T = y.focusNode;
            y = y.focusOffset;
            try {
              p.nodeType, T.nodeType;
            } catch {
              p = null;
              break e;
            }
            var j = 0, V = -1, te = -1, Ee = 0, Oe = 0, Ie = l, Te = null;
            t: for (; ; ) {
              for (var Me; Ie !== p || E !== 0 && Ie.nodeType !== 3 || (V = j + E), Ie !== T || y !== 0 && Ie.nodeType !== 3 || (te = j + y), Ie.nodeType === 3 && (j += Ie.nodeValue.length), (Me = Ie.firstChild) !== null; )
                Te = Ie, Ie = Me;
              for (; ; ) {
                if (Ie === l) break t;
                if (Te === p && ++Ee === E && (V = j), Te === T && ++Oe === y && (te = j), (Me = Ie.nextSibling) !== null) break;
                Ie = Te, Te = Ie.parentNode;
              }
              Ie = Me;
            }
            p = V === -1 || te === -1 ? null : { start: V, end: te };
          } else p = null;
        }
      p = p || { start: 0, end: 0 };
    } else p = null;
    for (HS = { focusedElem: l, selectionRange: p }, gv = !1, Lr = d; Lr !== null; )
      if (d = Lr, l = d.child, (d.subtreeFlags & 1028) !== 0 && l !== null)
        l.return = d, Lr = l;
      else
        for (; Lr !== null; ) {
          switch (d = Lr, T = d.alternate, l = d.flags, d.tag) {
            case 0:
              if ((l & 4) !== 0 && (l = d.updateQueue, l = l !== null ? l.events : null, l !== null))
                for (p = 0; p < l.length; p++)
                  E = l[p], E.ref.impl = E.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((l & 1024) !== 0 && T !== null) {
                l = void 0, p = d, E = T.memoizedProps, T = T.memoizedState, y = p.stateNode;
                try {
                  var rt = vu(
                    p.type,
                    E
                  );
                  l = y.getSnapshotBeforeUpdate(
                    rt,
                    T
                  ), y.__reactInternalSnapshotBeforeUpdate = l;
                } catch (vt) {
                  pn(
                    p,
                    p.return,
                    vt
                  );
                }
              }
              break;
            case 3:
              if ((l & 1024) !== 0) {
                if (l = d.stateNode.containerInfo, p = l.nodeType, p === 9)
                  GS(l);
                else if (p === 1)
                  switch (l.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      GS(l);
                      break;
                    default:
                      l.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((l & 1024) !== 0) throw Error(r(163));
          }
          if (l = d.sibling, l !== null) {
            l.return = d.return, Lr = l;
            break;
          }
          Lr = d.return;
        }
  }
  function L2(l, d, p) {
    var y = p.flags;
    switch (p.tag) {
      case 0:
      case 11:
      case 15:
        Aa(l, p), y & 4 && Ap(5, p);
        break;
      case 1:
        if (Aa(l, p), y & 4)
          if (l = p.stateNode, d === null)
            try {
              l.componentDidMount();
            } catch (j) {
              pn(p, p.return, j);
            }
          else {
            var E = vu(
              p.type,
              d.memoizedProps
            );
            d = d.memoizedState;
            try {
              l.componentDidUpdate(
                E,
                d,
                l.__reactInternalSnapshotBeforeUpdate
              );
            } catch (j) {
              pn(
                p,
                p.return,
                j
              );
            }
          }
        y & 64 && O2(p), y & 512 && Mp(p, p.return);
        break;
      case 3:
        if (Aa(l, p), y & 64 && (l = p.updateQueue, l !== null)) {
          if (d = null, p.child !== null)
            switch (p.child.tag) {
              case 27:
              case 5:
                d = p.child.stateNode;
                break;
              case 1:
                d = p.child.stateNode;
            }
          try {
            SR(l, d);
          } catch (j) {
            pn(p, p.return, j);
          }
        }
        break;
      case 27:
        d === null && y & 4 && I2(p);
      case 26:
      case 5:
        Aa(l, p), d === null && y & 4 && P2(p), y & 512 && Mp(p, p.return);
        break;
      case 12:
        Aa(l, p);
        break;
      case 31:
        Aa(l, p), y & 4 && U2(l, p);
        break;
      case 13:
        Aa(l, p), y & 4 && F2(l, p), y & 64 && (l = p.memoizedState, l !== null && (l = l.dehydrated, l !== null && (p = HG.bind(
          null,
          p
        ), uK(l, p))));
        break;
      case 22:
        if (y = p.memoizedState !== null || _a, !y) {
          d = d !== null && d.memoizedState !== null || vr, E = _a;
          var T = vr;
          _a = y, (vr = d) && !T ? Ma(
            l,
            p,
            (p.subtreeFlags & 8772) !== 0
          ) : Aa(l, p), _a = E, vr = T;
        }
        break;
      case 30:
        break;
      default:
        Aa(l, p);
    }
  }
  function B2(l) {
    var d = l.alternate;
    d !== null && (l.alternate = null, B2(d)), l.child = null, l.deletions = null, l.sibling = null, l.tag === 5 && (d = l.stateNode, d !== null && vd(d)), l.stateNode = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
  }
  var Wn = null, Li = !1;
  function Ta(l, d, p) {
    for (p = p.child; p !== null; )
      $2(l, d, p), p = p.sibling;
  }
  function $2(l, d, p) {
    if (nn && typeof nn.onCommitFiberUnmount == "function")
      try {
        nn.onCommitFiberUnmount(Lt, p);
      } catch {
      }
    switch (p.tag) {
      case 26:
        vr || Ms(p, d), Ta(
          l,
          d,
          p
        ), p.memoizedState ? p.memoizedState.count-- : p.stateNode && (p = p.stateNode, p.parentNode.removeChild(p));
        break;
      case 27:
        vr || Ms(p, d);
        var y = Wn, E = Li;
        Il(p.type) && (Wn = p.stateNode, Li = !1), Ta(
          l,
          d,
          p
        ), Lp(p.stateNode), Wn = y, Li = E;
        break;
      case 5:
        vr || Ms(p, d);
      case 6:
        if (y = Wn, E = Li, Wn = null, Ta(
          l,
          d,
          p
        ), Wn = y, Li = E, Wn !== null)
          if (Li)
            try {
              (Wn.nodeType === 9 ? Wn.body : Wn.nodeName === "HTML" ? Wn.ownerDocument.body : Wn).removeChild(p.stateNode);
            } catch (T) {
              pn(
                p,
                d,
                T
              );
            }
          else
            try {
              Wn.removeChild(p.stateNode);
            } catch (T) {
              pn(
                p,
                d,
                T
              );
            }
        break;
      case 18:
        Wn !== null && (Li ? (l = Wn, OO(
          l.nodeType === 9 ? l.body : l.nodeName === "HTML" ? l.ownerDocument.body : l,
          p.stateNode
        ), cf(l)) : OO(Wn, p.stateNode));
        break;
      case 4:
        y = Wn, E = Li, Wn = p.stateNode.containerInfo, Li = !0, Ta(
          l,
          d,
          p
        ), Wn = y, Li = E;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Ml(2, p, d), vr || Ml(4, p, d), Ta(
          l,
          d,
          p
        );
        break;
      case 1:
        vr || (Ms(p, d), y = p.stateNode, typeof y.componentWillUnmount == "function" && D2(
          p,
          d,
          y
        )), Ta(
          l,
          d,
          p
        );
        break;
      case 21:
        Ta(
          l,
          d,
          p
        );
        break;
      case 22:
        vr = (y = vr) || p.memoizedState !== null, Ta(
          l,
          d,
          p
        ), vr = y;
        break;
      default:
        Ta(
          l,
          d,
          p
        );
    }
  }
  function U2(l, d) {
    if (d.memoizedState === null && (l = d.alternate, l !== null && (l = l.memoizedState, l !== null))) {
      l = l.dehydrated;
      try {
        cf(l);
      } catch (p) {
        pn(d, d.return, p);
      }
    }
  }
  function F2(l, d) {
    if (d.memoizedState === null && (l = d.alternate, l !== null && (l = l.memoizedState, l !== null && (l = l.dehydrated, l !== null))))
      try {
        cf(l);
      } catch (p) {
        pn(d, d.return, p);
      }
  }
  function IG(l) {
    switch (l.tag) {
      case 31:
      case 13:
      case 19:
        var d = l.stateNode;
        return d === null && (d = l.stateNode = new z2()), d;
      case 22:
        return l = l.stateNode, d = l._retryCache, d === null && (d = l._retryCache = new z2()), d;
      default:
        throw Error(r(435, l.tag));
    }
  }
  function Yy(l, d) {
    var p = IG(l);
    d.forEach(function(y) {
      if (!p.has(y)) {
        p.add(y);
        var E = WG.bind(null, l, y);
        y.then(E, E);
      }
    });
  }
  function Bi(l, d) {
    var p = d.deletions;
    if (p !== null)
      for (var y = 0; y < p.length; y++) {
        var E = p[y], T = l, j = d, V = j;
        e: for (; V !== null; ) {
          switch (V.tag) {
            case 27:
              if (Il(V.type)) {
                Wn = V.stateNode, Li = !1;
                break e;
              }
              break;
            case 5:
              Wn = V.stateNode, Li = !1;
              break e;
            case 3:
            case 4:
              Wn = V.stateNode.containerInfo, Li = !0;
              break e;
          }
          V = V.return;
        }
        if (Wn === null) throw Error(r(160));
        $2(T, j, E), Wn = null, Li = !1, T = E.alternate, T !== null && (T.return = null), E.return = null;
      }
    if (d.subtreeFlags & 13886)
      for (d = d.child; d !== null; )
        V2(d, l), d = d.sibling;
  }
  var Jo = null;
  function V2(l, d) {
    var p = l.alternate, y = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Bi(d, l), $i(l), y & 4 && (Ml(3, l, l.return), Ap(3, l), Ml(5, l, l.return));
        break;
      case 1:
        Bi(d, l), $i(l), y & 512 && (vr || p === null || Ms(p, p.return)), y & 64 && _a && (l = l.updateQueue, l !== null && (y = l.callbacks, y !== null && (p = l.shared.hiddenCallbacks, l.shared.hiddenCallbacks = p === null ? y : p.concat(y))));
        break;
      case 26:
        var E = Jo;
        if (Bi(d, l), $i(l), y & 512 && (vr || p === null || Ms(p, p.return)), y & 4) {
          var T = p !== null ? p.memoizedState : null;
          if (y = l.memoizedState, p === null)
            if (y === null)
              if (l.stateNode === null) {
                e: {
                  y = l.type, p = l.memoizedProps, E = E.ownerDocument || E;
                  t: switch (y) {
                    case "title":
                      T = E.getElementsByTagName("title")[0], (!T || T[Xi] || T[Nn] || T.namespaceURI === "http://www.w3.org/2000/svg" || T.hasAttribute("itemprop")) && (T = E.createElement(y), E.head.insertBefore(
                        T,
                        E.querySelector("head > title")
                      )), Yr(T, y, p), T[Nn] = l, lr(T), y = T;
                      break e;
                    case "link":
                      var j = VO(
                        "link",
                        "href",
                        E
                      ).get(y + (p.href || ""));
                      if (j) {
                        for (var V = 0; V < j.length; V++)
                          if (T = j[V], T.getAttribute("href") === (p.href == null || p.href === "" ? null : p.href) && T.getAttribute("rel") === (p.rel == null ? null : p.rel) && T.getAttribute("title") === (p.title == null ? null : p.title) && T.getAttribute("crossorigin") === (p.crossOrigin == null ? null : p.crossOrigin)) {
                            j.splice(V, 1);
                            break t;
                          }
                      }
                      T = E.createElement(y), Yr(T, y, p), E.head.appendChild(T);
                      break;
                    case "meta":
                      if (j = VO(
                        "meta",
                        "content",
                        E
                      ).get(y + (p.content || ""))) {
                        for (V = 0; V < j.length; V++)
                          if (T = j[V], T.getAttribute("content") === (p.content == null ? null : "" + p.content) && T.getAttribute("name") === (p.name == null ? null : p.name) && T.getAttribute("property") === (p.property == null ? null : p.property) && T.getAttribute("http-equiv") === (p.httpEquiv == null ? null : p.httpEquiv) && T.getAttribute("charset") === (p.charSet == null ? null : p.charSet)) {
                            j.splice(V, 1);
                            break t;
                          }
                      }
                      T = E.createElement(y), Yr(T, y, p), E.head.appendChild(T);
                      break;
                    default:
                      throw Error(r(468, y));
                  }
                  T[Nn] = l, lr(T), y = T;
                }
                l.stateNode = y;
              } else
                HO(
                  E,
                  l.type,
                  l.stateNode
                );
            else
              l.stateNode = FO(
                E,
                y,
                l.memoizedProps
              );
          else
            T !== y ? (T === null ? p.stateNode !== null && (p = p.stateNode, p.parentNode.removeChild(p)) : T.count--, y === null ? HO(
              E,
              l.type,
              l.stateNode
            ) : FO(
              E,
              y,
              l.memoizedProps
            )) : y === null && l.stateNode !== null && bS(
              l,
              l.memoizedProps,
              p.memoizedProps
            );
        }
        break;
      case 27:
        Bi(d, l), $i(l), y & 512 && (vr || p === null || Ms(p, p.return)), p !== null && y & 4 && bS(
          l,
          l.memoizedProps,
          p.memoizedProps
        );
        break;
      case 5:
        if (Bi(d, l), $i(l), y & 512 && (vr || p === null || Ms(p, p.return)), l.flags & 32) {
          E = l.stateNode;
          try {
            la(E, "");
          } catch (rt) {
            pn(l, l.return, rt);
          }
        }
        y & 4 && l.stateNode != null && (E = l.memoizedProps, bS(
          l,
          E,
          p !== null ? p.memoizedProps : E
        )), y & 1024 && (SS = !0);
        break;
      case 6:
        if (Bi(d, l), $i(l), y & 4) {
          if (l.stateNode === null)
            throw Error(r(162));
          y = l.memoizedProps, p = l.stateNode;
          try {
            p.nodeValue = y;
          } catch (rt) {
            pn(l, l.return, rt);
          }
        }
        break;
      case 3:
        if (fv = null, E = Jo, Jo = uv(d.containerInfo), Bi(d, l), Jo = E, $i(l), y & 4 && p !== null && p.memoizedState.isDehydrated)
          try {
            cf(d.containerInfo);
          } catch (rt) {
            pn(l, l.return, rt);
          }
        SS && (SS = !1, H2(l));
        break;
      case 4:
        y = Jo, Jo = uv(
          l.stateNode.containerInfo
        ), Bi(d, l), $i(l), Jo = y;
        break;
      case 12:
        Bi(d, l), $i(l);
        break;
      case 31:
        Bi(d, l), $i(l), y & 4 && (y = l.updateQueue, y !== null && (l.updateQueue = null, Yy(l, y)));
        break;
      case 13:
        Bi(d, l), $i(l), l.child.flags & 8192 && l.memoizedState !== null != (p !== null && p.memoizedState !== null) && (Jy = Mn()), y & 4 && (y = l.updateQueue, y !== null && (l.updateQueue = null, Yy(l, y)));
        break;
      case 22:
        E = l.memoizedState !== null;
        var te = p !== null && p.memoizedState !== null, Ee = _a, Oe = vr;
        if (_a = Ee || E, vr = Oe || te, Bi(d, l), vr = Oe, _a = Ee, $i(l), y & 8192)
          e: for (d = l.stateNode, d._visibility = E ? d._visibility & -2 : d._visibility | 1, E && (p === null || te || _a || vr || bu(l)), p = null, d = l; ; ) {
            if (d.tag === 5 || d.tag === 26) {
              if (p === null) {
                te = p = d;
                try {
                  if (T = te.stateNode, E)
                    j = T.style, typeof j.setProperty == "function" ? j.setProperty("display", "none", "important") : j.display = "none";
                  else {
                    V = te.stateNode;
                    var Ie = te.memoizedProps.style, Te = Ie != null && Ie.hasOwnProperty("display") ? Ie.display : null;
                    V.style.display = Te == null || typeof Te == "boolean" ? "" : ("" + Te).trim();
                  }
                } catch (rt) {
                  pn(te, te.return, rt);
                }
              }
            } else if (d.tag === 6) {
              if (p === null) {
                te = d;
                try {
                  te.stateNode.nodeValue = E ? "" : te.memoizedProps;
                } catch (rt) {
                  pn(te, te.return, rt);
                }
              }
            } else if (d.tag === 18) {
              if (p === null) {
                te = d;
                try {
                  var Me = te.stateNode;
                  E ? DO(Me, !0) : DO(te.stateNode, !1);
                } catch (rt) {
                  pn(te, te.return, rt);
                }
              }
            } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === l) && d.child !== null) {
              d.child.return = d, d = d.child;
              continue;
            }
            if (d === l) break e;
            for (; d.sibling === null; ) {
              if (d.return === null || d.return === l) break e;
              p === d && (p = null), d = d.return;
            }
            p === d && (p = null), d.sibling.return = d.return, d = d.sibling;
          }
        y & 4 && (y = l.updateQueue, y !== null && (p = y.retryQueue, p !== null && (y.retryQueue = null, Yy(l, p))));
        break;
      case 19:
        Bi(d, l), $i(l), y & 4 && (y = l.updateQueue, y !== null && (l.updateQueue = null, Yy(l, y)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Bi(d, l), $i(l);
    }
  }
  function $i(l) {
    var d = l.flags;
    if (d & 2) {
      try {
        for (var p, y = l.return; y !== null; ) {
          if (j2(y)) {
            p = y;
            break;
          }
          y = y.return;
        }
        if (p == null) throw Error(r(160));
        switch (p.tag) {
          case 27:
            var E = p.stateNode, T = xS(l);
            Zy(l, T, E);
            break;
          case 5:
            var j = p.stateNode;
            p.flags & 32 && (la(j, ""), p.flags &= -33);
            var V = xS(l);
            Zy(l, V, j);
            break;
          case 3:
          case 4:
            var te = p.stateNode.containerInfo, Ee = xS(l);
            wS(
              l,
              Ee,
              te
            );
            break;
          default:
            throw Error(r(161));
        }
      } catch (Oe) {
        pn(l, l.return, Oe);
      }
      l.flags &= -3;
    }
    d & 4096 && (l.flags &= -4097);
  }
  function H2(l) {
    if (l.subtreeFlags & 1024)
      for (l = l.child; l !== null; ) {
        var d = l;
        H2(d), d.tag === 5 && d.flags & 1024 && d.stateNode.reset(), l = l.sibling;
      }
  }
  function Aa(l, d) {
    if (d.subtreeFlags & 8772)
      for (d = d.child; d !== null; )
        L2(l, d.alternate, d), d = d.sibling;
  }
  function bu(l) {
    for (l = l.child; l !== null; ) {
      var d = l;
      switch (d.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ml(4, d, d.return), bu(d);
          break;
        case 1:
          Ms(d, d.return);
          var p = d.stateNode;
          typeof p.componentWillUnmount == "function" && D2(
            d,
            d.return,
            p
          ), bu(d);
          break;
        case 27:
          Lp(d.stateNode);
        case 26:
        case 5:
          Ms(d, d.return), bu(d);
          break;
        case 22:
          d.memoizedState === null && bu(d);
          break;
        case 30:
          bu(d);
          break;
        default:
          bu(d);
      }
      l = l.sibling;
    }
  }
  function Ma(l, d, p) {
    for (p = p && (d.subtreeFlags & 8772) !== 0, d = d.child; d !== null; ) {
      var y = d.alternate, E = l, T = d, j = T.flags;
      switch (T.tag) {
        case 0:
        case 11:
        case 15:
          Ma(
            E,
            T,
            p
          ), Ap(4, T);
          break;
        case 1:
          if (Ma(
            E,
            T,
            p
          ), y = T, E = y.stateNode, typeof E.componentDidMount == "function")
            try {
              E.componentDidMount();
            } catch (Ee) {
              pn(y, y.return, Ee);
            }
          if (y = T, E = y.updateQueue, E !== null) {
            var V = y.stateNode;
            try {
              var te = E.shared.hiddenCallbacks;
              if (te !== null)
                for (E.shared.hiddenCallbacks = null, E = 0; E < te.length; E++)
                  wR(te[E], V);
            } catch (Ee) {
              pn(y, y.return, Ee);
            }
          }
          p && j & 64 && O2(T), Mp(T, T.return);
          break;
        case 27:
          I2(T);
        case 26:
        case 5:
          Ma(
            E,
            T,
            p
          ), p && y === null && j & 4 && P2(T), Mp(T, T.return);
          break;
        case 12:
          Ma(
            E,
            T,
            p
          );
          break;
        case 31:
          Ma(
            E,
            T,
            p
          ), p && j & 4 && U2(E, T);
          break;
        case 13:
          Ma(
            E,
            T,
            p
          ), p && j & 4 && F2(E, T);
          break;
        case 22:
          T.memoizedState === null && Ma(
            E,
            T,
            p
          ), Mp(T, T.return);
          break;
        case 30:
          break;
        default:
          Ma(
            E,
            T,
            p
          );
      }
      d = d.sibling;
    }
  }
  function kS(l, d) {
    var p = null;
    l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (p = l.memoizedState.cachePool.pool), l = null, d.memoizedState !== null && d.memoizedState.cachePool !== null && (l = d.memoizedState.cachePool.pool), l !== p && (l != null && l.refCount++, p != null && mp(p));
  }
  function CS(l, d) {
    l = null, d.alternate !== null && (l = d.alternate.memoizedState.cache), d = d.memoizedState.cache, d !== l && (d.refCount++, l != null && mp(l));
  }
  function Qo(l, d, p, y) {
    if (d.subtreeFlags & 10256)
      for (d = d.child; d !== null; )
        W2(
          l,
          d,
          p,
          y
        ), d = d.sibling;
  }
  function W2(l, d, p, y) {
    var E = d.flags;
    switch (d.tag) {
      case 0:
      case 11:
      case 15:
        Qo(
          l,
          d,
          p,
          y
        ), E & 2048 && Ap(9, d);
        break;
      case 1:
        Qo(
          l,
          d,
          p,
          y
        );
        break;
      case 3:
        Qo(
          l,
          d,
          p,
          y
        ), E & 2048 && (l = null, d.alternate !== null && (l = d.alternate.memoizedState.cache), d = d.memoizedState.cache, d !== l && (d.refCount++, l != null && mp(l)));
        break;
      case 12:
        if (E & 2048) {
          Qo(
            l,
            d,
            p,
            y
          ), l = d.stateNode;
          try {
            var T = d.memoizedProps, j = T.id, V = T.onPostCommit;
            typeof V == "function" && V(
              j,
              d.alternate === null ? "mount" : "update",
              l.passiveEffectDuration,
              -0
            );
          } catch (te) {
            pn(d, d.return, te);
          }
        } else
          Qo(
            l,
            d,
            p,
            y
          );
        break;
      case 31:
        Qo(
          l,
          d,
          p,
          y
        );
        break;
      case 13:
        Qo(
          l,
          d,
          p,
          y
        );
        break;
      case 23:
        break;
      case 22:
        T = d.stateNode, j = d.alternate, d.memoizedState !== null ? T._visibility & 2 ? Qo(
          l,
          d,
          p,
          y
        ) : Np(l, d) : T._visibility & 2 ? Qo(
          l,
          d,
          p,
          y
        ) : (T._visibility |= 2, Xd(
          l,
          d,
          p,
          y,
          (d.subtreeFlags & 10256) !== 0 || !1
        )), E & 2048 && kS(j, d);
        break;
      case 24:
        Qo(
          l,
          d,
          p,
          y
        ), E & 2048 && CS(d.alternate, d);
        break;
      default:
        Qo(
          l,
          d,
          p,
          y
        );
    }
  }
  function Xd(l, d, p, y, E) {
    for (E = E && ((d.subtreeFlags & 10256) !== 0 || !1), d = d.child; d !== null; ) {
      var T = l, j = d, V = p, te = y, Ee = j.flags;
      switch (j.tag) {
        case 0:
        case 11:
        case 15:
          Xd(
            T,
            j,
            V,
            te,
            E
          ), Ap(8, j);
          break;
        case 23:
          break;
        case 22:
          var Oe = j.stateNode;
          j.memoizedState !== null ? Oe._visibility & 2 ? Xd(
            T,
            j,
            V,
            te,
            E
          ) : Np(
            T,
            j
          ) : (Oe._visibility |= 2, Xd(
            T,
            j,
            V,
            te,
            E
          )), E && Ee & 2048 && kS(
            j.alternate,
            j
          );
          break;
        case 24:
          Xd(
            T,
            j,
            V,
            te,
            E
          ), E && Ee & 2048 && CS(j.alternate, j);
          break;
        default:
          Xd(
            T,
            j,
            V,
            te,
            E
          );
      }
      d = d.sibling;
    }
  }
  function Np(l, d) {
    if (d.subtreeFlags & 10256)
      for (d = d.child; d !== null; ) {
        var p = l, y = d, E = y.flags;
        switch (y.tag) {
          case 22:
            Np(p, y), E & 2048 && kS(
              y.alternate,
              y
            );
            break;
          case 24:
            Np(p, y), E & 2048 && CS(y.alternate, y);
            break;
          default:
            Np(p, y);
        }
        d = d.sibling;
      }
  }
  var Rp = 8192;
  function Jd(l, d, p) {
    if (l.subtreeFlags & Rp)
      for (l = l.child; l !== null; )
        q2(
          l,
          d,
          p
        ), l = l.sibling;
  }
  function q2(l, d, p) {
    switch (l.tag) {
      case 26:
        Jd(
          l,
          d,
          p
        ), l.flags & Rp && l.memoizedState !== null && SK(
          p,
          Jo,
          l.memoizedState,
          l.memoizedProps
        );
        break;
      case 5:
        Jd(
          l,
          d,
          p
        );
        break;
      case 3:
      case 4:
        var y = Jo;
        Jo = uv(l.stateNode.containerInfo), Jd(
          l,
          d,
          p
        ), Jo = y;
        break;
      case 22:
        l.memoizedState === null && (y = l.alternate, y !== null && y.memoizedState !== null ? (y = Rp, Rp = 16777216, Jd(
          l,
          d,
          p
        ), Rp = y) : Jd(
          l,
          d,
          p
        ));
        break;
      default:
        Jd(
          l,
          d,
          p
        );
    }
  }
  function G2(l) {
    var d = l.alternate;
    if (d !== null && (l = d.child, l !== null)) {
      d.child = null;
      do
        d = l.sibling, l.sibling = null, l = d;
      while (l !== null);
    }
  }
  function Op(l) {
    var d = l.deletions;
    if ((l.flags & 16) !== 0) {
      if (d !== null)
        for (var p = 0; p < d.length; p++) {
          var y = d[p];
          Lr = y, Z2(
            y,
            l
          );
        }
      G2(l);
    }
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; )
        K2(l), l = l.sibling;
  }
  function K2(l) {
    switch (l.tag) {
      case 0:
      case 11:
      case 15:
        Op(l), l.flags & 2048 && Ml(9, l, l.return);
        break;
      case 3:
        Op(l);
        break;
      case 12:
        Op(l);
        break;
      case 22:
        var d = l.stateNode;
        l.memoizedState !== null && d._visibility & 2 && (l.return === null || l.return.tag !== 13) ? (d._visibility &= -3, Xy(l)) : Op(l);
        break;
      default:
        Op(l);
    }
  }
  function Xy(l) {
    var d = l.deletions;
    if ((l.flags & 16) !== 0) {
      if (d !== null)
        for (var p = 0; p < d.length; p++) {
          var y = d[p];
          Lr = y, Z2(
            y,
            l
          );
        }
      G2(l);
    }
    for (l = l.child; l !== null; ) {
      switch (d = l, d.tag) {
        case 0:
        case 11:
        case 15:
          Ml(8, d, d.return), Xy(d);
          break;
        case 22:
          p = d.stateNode, p._visibility & 2 && (p._visibility &= -3, Xy(d));
          break;
        default:
          Xy(d);
      }
      l = l.sibling;
    }
  }
  function Z2(l, d) {
    for (; Lr !== null; ) {
      var p = Lr;
      switch (p.tag) {
        case 0:
        case 11:
        case 15:
          Ml(8, p, d);
          break;
        case 23:
        case 22:
          if (p.memoizedState !== null && p.memoizedState.cachePool !== null) {
            var y = p.memoizedState.cachePool.pool;
            y != null && y.refCount++;
          }
          break;
        case 24:
          mp(p.memoizedState.cache);
      }
      if (y = p.child, y !== null) y.return = p, Lr = y;
      else
        e: for (p = l; Lr !== null; ) {
          y = Lr;
          var E = y.sibling, T = y.return;
          if (B2(y), y === p) {
            Lr = null;
            break e;
          }
          if (E !== null) {
            E.return = T, Lr = E;
            break e;
          }
          Lr = T;
        }
    }
  }
  var zG = {
    getCacheForType: function(l) {
      var d = Kr(mr), p = d.data.get(l);
      return p === void 0 && (p = l(), d.data.set(l, p)), p;
    },
    cacheSignal: function() {
      return Kr(mr).controller.signal;
    }
  }, LG = typeof WeakMap == "function" ? WeakMap : Map, ln = 0, Cn = null, Wt = null, Zt = 0, hn = 0, ro = null, Nl = !1, Qd = !1, ES = !1, Na = 0, Qn = 0, Rl = 0, xu = 0, _S = 0, io = 0, ef = 0, Dp = null, Ui = null, TS = !1, Jy = 0, Y2 = 0, Qy = 1 / 0, ev = null, Ol = null, Mr = 0, Dl = null, tf = null, Ra = 0, AS = 0, MS = null, X2 = null, Pp = 0, NS = null;
  function oo() {
    return (ln & 2) !== 0 && Zt !== 0 ? Zt & -Zt : H.T !== null ? IS() : Kc();
  }
  function J2() {
    if (io === 0)
      if ((Zt & 536870912) === 0 || Qt) {
        var l = sl;
        sl <<= 1, (sl & 3932160) === 0 && (sl = 262144), io = l;
      } else io = 536870912;
    return l = to.current, l !== null && (l.flags |= 32), io;
  }
  function Fi(l, d, p) {
    (l === Cn && (hn === 2 || hn === 9) || l.cancelPendingCommit !== null) && (nf(l, 0), Pl(
      l,
      Zt,
      io,
      !1
    )), yo(l, p), ((ln & 2) === 0 || l !== Cn) && (l === Cn && ((ln & 2) === 0 && (xu |= p), Qn === 4 && Pl(
      l,
      Zt,
      io,
      !1
    )), Ns(l));
  }
  function Q2(l, d, p) {
    if ((ln & 6) !== 0) throw Error(r(327));
    var y = !p && (d & 127) === 0 && (d & l.expiredLanes) === 0 || oa(l, d), E = y ? UG(l, d) : OS(l, d, !0), T = y;
    do {
      if (E === 0) {
        Qd && !y && Pl(l, d, 0, !1);
        break;
      } else {
        if (p = l.current.alternate, T && !BG(p)) {
          E = OS(l, d, !1), T = !1;
          continue;
        }
        if (E === 2) {
          if (T = d, l.errorRecoveryDisabledLanes & T)
            var j = 0;
          else
            j = l.pendingLanes & -536870913, j = j !== 0 ? j : j & 536870912 ? 536870912 : 0;
          if (j !== 0) {
            d = j;
            e: {
              var V = l;
              E = Dp;
              var te = V.current.memoizedState.isDehydrated;
              if (te && (nf(V, j).flags |= 256), j = OS(
                V,
                j,
                !1
              ), j !== 2) {
                if (ES && !te) {
                  V.errorRecoveryDisabledLanes |= T, xu |= T, E = 4;
                  break e;
                }
                T = Ui, Ui = E, T !== null && (Ui === null ? Ui = T : Ui.push.apply(
                  Ui,
                  T
                ));
              }
              E = j;
            }
            if (T = !1, E !== 2) continue;
          }
        }
        if (E === 1) {
          nf(l, 0), Pl(l, d, 0, !0);
          break;
        }
        e: {
          switch (y = l, T = E, T) {
            case 0:
            case 1:
              throw Error(r(345));
            case 4:
              if ((d & 4194048) !== d) break;
            case 6:
              Pl(
                y,
                d,
                io,
                !Nl
              );
              break e;
            case 2:
              Ui = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r(329));
          }
          if ((d & 62914560) === d && (E = Jy + 300 - Mn(), 10 < E)) {
            if (Pl(
              y,
              d,
              io,
              !Nl
            ), qc(y, 0, !0) !== 0) break e;
            Ra = d, y.timeoutHandle = NO(
              eO.bind(
                null,
                y,
                p,
                Ui,
                ev,
                TS,
                d,
                io,
                xu,
                ef,
                Nl,
                T,
                "Throttled",
                -0,
                0
              ),
              E
            );
            break e;
          }
          eO(
            y,
            p,
            Ui,
            ev,
            TS,
            d,
            io,
            xu,
            ef,
            Nl,
            T,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Ns(l);
  }
  function eO(l, d, p, y, E, T, j, V, te, Ee, Oe, Ie, Te, Me) {
    if (l.timeoutHandle = -1, Ie = d.subtreeFlags, Ie & 8192 || (Ie & 16785408) === 16785408) {
      Ie = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: zi
      }, q2(
        d,
        T,
        Ie
      );
      var rt = (T & 62914560) === T ? Jy - Mn() : (T & 4194048) === T ? Y2 - Mn() : 0;
      if (rt = kK(
        Ie,
        rt
      ), rt !== null) {
        Ra = T, l.cancelPendingCommit = rt(
          lO.bind(
            null,
            l,
            d,
            T,
            p,
            y,
            E,
            j,
            V,
            te,
            Oe,
            Ie,
            null,
            Te,
            Me
          )
        ), Pl(l, T, j, !Ee);
        return;
      }
    }
    lO(
      l,
      d,
      T,
      p,
      y,
      E,
      j,
      V,
      te
    );
  }
  function BG(l) {
    for (var d = l; ; ) {
      var p = d.tag;
      if ((p === 0 || p === 11 || p === 15) && d.flags & 16384 && (p = d.updateQueue, p !== null && (p = p.stores, p !== null)))
        for (var y = 0; y < p.length; y++) {
          var E = p[y], T = E.getSnapshot;
          E = E.value;
          try {
            if (!li(T(), E)) return !1;
          } catch {
            return !1;
          }
        }
      if (p = d.child, d.subtreeFlags & 16384 && p !== null)
        p.return = d, d = p;
      else {
        if (d === l) break;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === l) return !0;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
    }
    return !0;
  }
  function Pl(l, d, p, y) {
    d &= ~_S, d &= ~xu, l.suspendedLanes |= d, l.pingedLanes &= ~d, y && (l.warmLanes |= d), y = l.expirationTimes;
    for (var E = d; 0 < E; ) {
      var T = 31 - Ve(E), j = 1 << T;
      y[T] = -1, E &= ~j;
    }
    p !== 0 && Gc(l, p, d);
  }
  function tv() {
    return (ln & 6) === 0 ? (jp(0), !1) : !0;
  }
  function RS() {
    if (Wt !== null) {
      if (hn === 0)
        var l = Wt.return;
      else
        l = Wt, xa = du = null, G1(l), qd = null, yp = 0, l = Wt;
      for (; l !== null; )
        R2(l.alternate, l), l = l.return;
      Wt = null;
    }
  }
  function nf(l, d) {
    var p = l.timeoutHandle;
    p !== -1 && (l.timeoutHandle = -1, oK(p)), p = l.cancelPendingCommit, p !== null && (l.cancelPendingCommit = null, p()), Ra = 0, RS(), Cn = l, Wt = p = va(l.current, null), Zt = d, hn = 0, ro = null, Nl = !1, Qd = oa(l, d), ES = !1, ef = io = _S = xu = Rl = Qn = 0, Ui = Dp = null, TS = !1, (d & 8) !== 0 && (d |= d & 32);
    var y = l.entangledLanes;
    if (y !== 0)
      for (l = l.entanglements, y &= d; 0 < y; ) {
        var E = 31 - Ve(y), T = 1 << E;
        d |= l[E], y &= ~T;
      }
    return Na = d, Tt(), p;
  }
  function tO(l, d) {
    Rt = null, H.H = Ep, d === Wd || d === Ny ? (d = yR(), hn = 3) : d === j1 ? (d = yR(), hn = 4) : hn = d === cS ? 8 : d !== null && typeof d == "object" && typeof d.then == "function" ? 6 : 1, ro = d, Wt === null && (Qn = 1, Hy(
      l,
      So(d, l.current)
    ));
  }
  function nO() {
    var l = to.current;
    return l === null ? !0 : (Zt & 4194048) === Zt ? _o === null : (Zt & 62914560) === Zt || (Zt & 536870912) !== 0 ? l === _o : !1;
  }
  function rO() {
    var l = H.H;
    return H.H = Ep, l === null ? Ep : l;
  }
  function iO() {
    var l = H.A;
    return H.A = zG, l;
  }
  function nv() {
    Qn = 4, Nl || (Zt & 4194048) !== Zt && to.current !== null || (Qd = !0), (Rl & 134217727) === 0 && (xu & 134217727) === 0 || Cn === null || Pl(
      Cn,
      Zt,
      io,
      !1
    );
  }
  function OS(l, d, p) {
    var y = ln;
    ln |= 2;
    var E = rO(), T = iO();
    (Cn !== l || Zt !== d) && (ev = null, nf(l, d)), d = !1;
    var j = Qn;
    e: do
      try {
        if (hn !== 0 && Wt !== null) {
          var V = Wt, te = ro;
          switch (hn) {
            case 8:
              RS(), j = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              to.current === null && (d = !0);
              var Ee = hn;
              if (hn = 0, ro = null, rf(l, V, te, Ee), p && Qd) {
                j = 0;
                break e;
              }
              break;
            default:
              Ee = hn, hn = 0, ro = null, rf(l, V, te, Ee);
          }
        }
        $G(), j = Qn;
        break;
      } catch (Oe) {
        tO(l, Oe);
      }
    while (!0);
    return d && l.shellSuspendCounter++, xa = du = null, ln = y, H.H = E, H.A = T, Wt === null && (Cn = null, Zt = 0, Tt()), j;
  }
  function $G() {
    for (; Wt !== null; ) oO(Wt);
  }
  function UG(l, d) {
    var p = ln;
    ln |= 2;
    var y = rO(), E = iO();
    Cn !== l || Zt !== d ? (ev = null, Qy = Mn() + 500, nf(l, d)) : Qd = oa(
      l,
      d
    );
    e: do
      try {
        if (hn !== 0 && Wt !== null) {
          d = Wt;
          var T = ro;
          t: switch (hn) {
            case 1:
              hn = 0, ro = null, rf(l, d, T, 1);
              break;
            case 2:
            case 9:
              if (mR(T)) {
                hn = 0, ro = null, sO(d);
                break;
              }
              d = function() {
                hn !== 2 && hn !== 9 || Cn !== l || (hn = 7), Ns(l);
              }, T.then(d, d);
              break e;
            case 3:
              hn = 7;
              break e;
            case 4:
              hn = 5;
              break e;
            case 7:
              mR(T) ? (hn = 0, ro = null, sO(d)) : (hn = 0, ro = null, rf(l, d, T, 7));
              break;
            case 5:
              var j = null;
              switch (Wt.tag) {
                case 26:
                  j = Wt.memoizedState;
                case 5:
                case 27:
                  var V = Wt;
                  if (j ? WO(j) : V.stateNode.complete) {
                    hn = 0, ro = null;
                    var te = V.sibling;
                    if (te !== null) Wt = te;
                    else {
                      var Ee = V.return;
                      Ee !== null ? (Wt = Ee, rv(Ee)) : Wt = null;
                    }
                    break t;
                  }
              }
              hn = 0, ro = null, rf(l, d, T, 5);
              break;
            case 6:
              hn = 0, ro = null, rf(l, d, T, 6);
              break;
            case 8:
              RS(), Qn = 6;
              break e;
            default:
              throw Error(r(462));
          }
        }
        FG();
        break;
      } catch (Oe) {
        tO(l, Oe);
      }
    while (!0);
    return xa = du = null, H.H = y, H.A = E, ln = p, Wt !== null ? 0 : (Cn = null, Zt = 0, Tt(), Qn);
  }
  function FG() {
    for (; Wt !== null && !sn(); )
      oO(Wt);
  }
  function oO(l) {
    var d = M2(l.alternate, l, Na);
    l.memoizedProps = l.pendingProps, d === null ? rv(l) : Wt = d;
  }
  function sO(l) {
    var d = l, p = d.alternate;
    switch (d.tag) {
      case 15:
      case 0:
        d = k2(
          p,
          d,
          d.pendingProps,
          d.type,
          void 0,
          Zt
        );
        break;
      case 11:
        d = k2(
          p,
          d,
          d.pendingProps,
          d.type.render,
          d.ref,
          Zt
        );
        break;
      case 5:
        G1(d);
      default:
        R2(p, d), d = Wt = iR(d, Na), d = M2(p, d, Na);
    }
    l.memoizedProps = l.pendingProps, d === null ? rv(l) : Wt = d;
  }
  function rf(l, d, p, y) {
    xa = du = null, G1(d), qd = null, yp = 0;
    var E = d.return;
    try {
      if (NG(
        l,
        E,
        d,
        p,
        Zt
      )) {
        Qn = 1, Hy(
          l,
          So(p, l.current)
        ), Wt = null;
        return;
      }
    } catch (T) {
      if (E !== null) throw Wt = E, T;
      Qn = 1, Hy(
        l,
        So(p, l.current)
      ), Wt = null;
      return;
    }
    d.flags & 32768 ? (Qt || y === 1 ? l = !0 : Qd || (Zt & 536870912) !== 0 ? l = !1 : (Nl = l = !0, (y === 2 || y === 9 || y === 3 || y === 6) && (y = to.current, y !== null && y.tag === 13 && (y.flags |= 16384))), aO(d, l)) : rv(d);
  }
  function rv(l) {
    var d = l;
    do {
      if ((d.flags & 32768) !== 0) {
        aO(
          d,
          Nl
        );
        return;
      }
      l = d.return;
      var p = DG(
        d.alternate,
        d,
        Na
      );
      if (p !== null) {
        Wt = p;
        return;
      }
      if (d = d.sibling, d !== null) {
        Wt = d;
        return;
      }
      Wt = d = l;
    } while (d !== null);
    Qn === 0 && (Qn = 5);
  }
  function aO(l, d) {
    do {
      var p = PG(l.alternate, l);
      if (p !== null) {
        p.flags &= 32767, Wt = p;
        return;
      }
      if (p = l.return, p !== null && (p.flags |= 32768, p.subtreeFlags = 0, p.deletions = null), !d && (l = l.sibling, l !== null)) {
        Wt = l;
        return;
      }
      Wt = l = p;
    } while (l !== null);
    Qn = 6, Wt = null;
  }
  function lO(l, d, p, y, E, T, j, V, te) {
    l.cancelPendingCommit = null;
    do
      iv();
    while (Mr !== 0);
    if ((ln & 6) !== 0) throw Error(r(327));
    if (d !== null) {
      if (d === l.current) throw Error(r(177));
      if (T = d.lanes | d.childLanes, T |= dt, Wh(
        l,
        p,
        T,
        j,
        V,
        te
      ), l === Cn && (Wt = Cn = null, Zt = 0), tf = d, Dl = l, Ra = p, AS = T, MS = E, X2 = y, (d.subtreeFlags & 10256) !== 0 || (d.flags & 10256) !== 0 ? (l.callbackNode = null, l.callbackPriority = 0, qG(He, function() {
        return hO(), null;
      })) : (l.callbackNode = null, l.callbackPriority = 0), y = (d.flags & 13878) !== 0, (d.subtreeFlags & 13878) !== 0 || y) {
        y = H.T, H.T = null, E = Q.p, Q.p = 2, j = ln, ln |= 4;
        try {
          jG(l, d, p);
        } finally {
          ln = j, Q.p = E, H.T = y;
        }
      }
      Mr = 1, cO(), uO(), dO();
    }
  }
  function cO() {
    if (Mr === 1) {
      Mr = 0;
      var l = Dl, d = tf, p = (d.flags & 13878) !== 0;
      if ((d.subtreeFlags & 13878) !== 0 || p) {
        p = H.T, H.T = null;
        var y = Q.p;
        Q.p = 2;
        var E = ln;
        ln |= 4;
        try {
          V2(d, l);
          var T = HS, j = z(l.containerInfo), V = T.focusedElem, te = T.selectionRange;
          if (j !== V && V && V.ownerDocument && D(
            V.ownerDocument.documentElement,
            V
          )) {
            if (te !== null && $(V)) {
              var Ee = te.start, Oe = te.end;
              if (Oe === void 0 && (Oe = Ee), "selectionStart" in V)
                V.selectionStart = Ee, V.selectionEnd = Math.min(
                  Oe,
                  V.value.length
                );
              else {
                var Ie = V.ownerDocument || document, Te = Ie && Ie.defaultView || window;
                if (Te.getSelection) {
                  var Me = Te.getSelection(), rt = V.textContent.length, vt = Math.min(te.start, rt), Sn = te.end === void 0 ? vt : Math.min(te.end, rt);
                  !Me.extend && vt > Sn && (j = Sn, Sn = vt, vt = j);
                  var me = R(
                    V,
                    vt
                  ), de = R(
                    V,
                    Sn
                  );
                  if (me && de && (Me.rangeCount !== 1 || Me.anchorNode !== me.node || Me.anchorOffset !== me.offset || Me.focusNode !== de.node || Me.focusOffset !== de.offset)) {
                    var Ce = Ie.createRange();
                    Ce.setStart(me.node, me.offset), Me.removeAllRanges(), vt > Sn ? (Me.addRange(Ce), Me.extend(de.node, de.offset)) : (Ce.setEnd(de.node, de.offset), Me.addRange(Ce));
                  }
                }
              }
            }
            for (Ie = [], Me = V; Me = Me.parentNode; )
              Me.nodeType === 1 && Ie.push({
                element: Me,
                left: Me.scrollLeft,
                top: Me.scrollTop
              });
            for (typeof V.focus == "function" && V.focus(), V = 0; V < Ie.length; V++) {
              var je = Ie[V];
              je.element.scrollLeft = je.left, je.element.scrollTop = je.top;
            }
          }
          gv = !!VS, HS = VS = null;
        } finally {
          ln = E, Q.p = y, H.T = p;
        }
      }
      l.current = d, Mr = 2;
    }
  }
  function uO() {
    if (Mr === 2) {
      Mr = 0;
      var l = Dl, d = tf, p = (d.flags & 8772) !== 0;
      if ((d.subtreeFlags & 8772) !== 0 || p) {
        p = H.T, H.T = null;
        var y = Q.p;
        Q.p = 2;
        var E = ln;
        ln |= 4;
        try {
          L2(l, d.alternate, d);
        } finally {
          ln = E, Q.p = y, H.T = p;
        }
      }
      Mr = 3;
    }
  }
  function dO() {
    if (Mr === 4 || Mr === 3) {
      Mr = 0, Pn();
      var l = Dl, d = tf, p = Ra, y = X2;
      (d.subtreeFlags & 10256) !== 0 || (d.flags & 10256) !== 0 ? Mr = 5 : (Mr = 0, tf = Dl = null, fO(l, l.pendingLanes));
      var E = l.pendingLanes;
      if (E === 0 && (Ol = null), al(p), d = d.stateNode, nn && typeof nn.onCommitFiberRoot == "function")
        try {
          nn.onCommitFiberRoot(
            Lt,
            d,
            void 0,
            (d.current.flags & 128) === 128
          );
        } catch {
        }
      if (y !== null) {
        d = H.T, E = Q.p, Q.p = 2, H.T = null;
        try {
          for (var T = l.onRecoverableError, j = 0; j < y.length; j++) {
            var V = y[j];
            T(V.value, {
              componentStack: V.stack
            });
          }
        } finally {
          H.T = d, Q.p = E;
        }
      }
      (Ra & 3) !== 0 && iv(), Ns(l), E = l.pendingLanes, (p & 261930) !== 0 && (E & 42) !== 0 ? l === NS ? Pp++ : (Pp = 0, NS = l) : Pp = 0, jp(0);
    }
  }
  function fO(l, d) {
    (l.pooledCacheLanes &= d) === 0 && (d = l.pooledCache, d != null && (l.pooledCache = null, mp(d)));
  }
  function iv() {
    return cO(), uO(), dO(), hO();
  }
  function hO() {
    if (Mr !== 5) return !1;
    var l = Dl, d = AS;
    AS = 0;
    var p = al(Ra), y = H.T, E = Q.p;
    try {
      Q.p = 32 > p ? 32 : p, H.T = null, p = MS, MS = null;
      var T = Dl, j = Ra;
      if (Mr = 0, tf = Dl = null, Ra = 0, (ln & 6) !== 0) throw Error(r(331));
      var V = ln;
      if (ln |= 4, K2(T.current), W2(
        T,
        T.current,
        j,
        p
      ), ln = V, jp(0, !1), nn && typeof nn.onPostCommitFiberRoot == "function")
        try {
          nn.onPostCommitFiberRoot(Lt, T);
        } catch {
        }
      return !0;
    } finally {
      Q.p = E, H.T = y, fO(l, d);
    }
  }
  function pO(l, d, p) {
    d = So(p, d), d = lS(l.stateNode, d, 2), l = _l(l, d, 2), l !== null && (yo(l, 2), Ns(l));
  }
  function pn(l, d, p) {
    if (l.tag === 3)
      pO(l, l, p);
    else
      for (; d !== null; ) {
        if (d.tag === 3) {
          pO(
            d,
            l,
            p
          );
          break;
        } else if (d.tag === 1) {
          var y = d.stateNode;
          if (typeof d.type.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && (Ol === null || !Ol.has(y))) {
            l = So(p, l), p = m2(2), y = _l(d, p, 2), y !== null && (g2(
              p,
              y,
              d,
              l
            ), yo(y, 2), Ns(y));
            break;
          }
        }
        d = d.return;
      }
  }
  function DS(l, d, p) {
    var y = l.pingCache;
    if (y === null) {
      y = l.pingCache = new LG();
      var E = /* @__PURE__ */ new Set();
      y.set(d, E);
    } else
      E = y.get(d), E === void 0 && (E = /* @__PURE__ */ new Set(), y.set(d, E));
    E.has(p) || (ES = !0, E.add(p), l = VG.bind(null, l, d, p), d.then(l, l));
  }
  function VG(l, d, p) {
    var y = l.pingCache;
    y !== null && y.delete(d), l.pingedLanes |= l.suspendedLanes & p, l.warmLanes &= ~p, Cn === l && (Zt & p) === p && (Qn === 4 || Qn === 3 && (Zt & 62914560) === Zt && 300 > Mn() - Jy ? (ln & 2) === 0 && nf(l, 0) : _S |= p, ef === Zt && (ef = 0)), Ns(l);
  }
  function mO(l, d) {
    d === 0 && (d = uy()), l = un(l, d), l !== null && (yo(l, d), Ns(l));
  }
  function HG(l) {
    var d = l.memoizedState, p = 0;
    d !== null && (p = d.retryLane), mO(l, p);
  }
  function WG(l, d) {
    var p = 0;
    switch (l.tag) {
      case 31:
      case 13:
        var y = l.stateNode, E = l.memoizedState;
        E !== null && (p = E.retryLane);
        break;
      case 19:
        y = l.stateNode;
        break;
      case 22:
        y = l.stateNode._retryCache;
        break;
      default:
        throw Error(r(314));
    }
    y !== null && y.delete(d), mO(l, p);
  }
  function qG(l, d) {
    return An(l, d);
  }
  var ov = null, of = null, PS = !1, sv = !1, jS = !1, jl = 0;
  function Ns(l) {
    l !== of && l.next === null && (of === null ? ov = of = l : of = of.next = l), sv = !0, PS || (PS = !0, KG());
  }
  function jp(l, d) {
    if (!jS && sv) {
      jS = !0;
      do
        for (var p = !1, y = ov; y !== null; ) {
          if (l !== 0) {
            var E = y.pendingLanes;
            if (E === 0) var T = 0;
            else {
              var j = y.suspendedLanes, V = y.pingedLanes;
              T = (1 << 31 - Ve(42 | l) + 1) - 1, T &= E & ~(j & ~V), T = T & 201326741 ? T & 201326741 | 1 : T ? T | 2 : 0;
            }
            T !== 0 && (p = !0, bO(y, T));
          } else
            T = Zt, T = qc(
              y,
              y === Cn ? T : 0,
              y.cancelPendingCommit !== null || y.timeoutHandle !== -1
            ), (T & 3) === 0 || oa(y, T) || (p = !0, bO(y, T));
          y = y.next;
        }
      while (p);
      jS = !1;
    }
  }
  function GG() {
    gO();
  }
  function gO() {
    sv = PS = !1;
    var l = 0;
    jl !== 0 && iK() && (l = jl);
    for (var d = Mn(), p = null, y = ov; y !== null; ) {
      var E = y.next, T = yO(y, d);
      T === 0 ? (y.next = null, p === null ? ov = E : p.next = E, E === null && (of = p)) : (p = y, (l !== 0 || (T & 3) !== 0) && (sv = !0)), y = E;
    }
    Mr !== 0 && Mr !== 5 || jp(l), jl !== 0 && (jl = 0);
  }
  function yO(l, d) {
    for (var p = l.suspendedLanes, y = l.pingedLanes, E = l.expirationTimes, T = l.pendingLanes & -62914561; 0 < T; ) {
      var j = 31 - Ve(T), V = 1 << j, te = E[j];
      te === -1 ? ((V & p) === 0 || (V & y) !== 0) && (E[j] = h1(V, d)) : te <= d && (l.expiredLanes |= V), T &= ~V;
    }
    if (d = Cn, p = Zt, p = qc(
      l,
      l === d ? p : 0,
      l.cancelPendingCommit !== null || l.timeoutHandle !== -1
    ), y = l.callbackNode, p === 0 || l === d && (hn === 2 || hn === 9) || l.cancelPendingCommit !== null)
      return y !== null && y !== null && Nt(y), l.callbackNode = null, l.callbackPriority = 0;
    if ((p & 3) === 0 || oa(l, p)) {
      if (d = p & -p, d === l.callbackPriority) return d;
      switch (y !== null && Nt(y), al(p)) {
        case 2:
        case 8:
          p = Pe;
          break;
        case 32:
          p = He;
          break;
        case 268435456:
          p = bt;
          break;
        default:
          p = He;
      }
      return y = vO.bind(null, l), p = An(p, y), l.callbackPriority = d, l.callbackNode = p, d;
    }
    return y !== null && y !== null && Nt(y), l.callbackPriority = 2, l.callbackNode = null, 2;
  }
  function vO(l, d) {
    if (Mr !== 0 && Mr !== 5)
      return l.callbackNode = null, l.callbackPriority = 0, null;
    var p = l.callbackNode;
    if (iv() && l.callbackNode !== p)
      return null;
    var y = Zt;
    return y = qc(
      l,
      l === Cn ? y : 0,
      l.cancelPendingCommit !== null || l.timeoutHandle !== -1
    ), y === 0 ? null : (Q2(l, y, d), yO(l, Mn()), l.callbackNode != null && l.callbackNode === p ? vO.bind(null, l) : null);
  }
  function bO(l, d) {
    if (iv()) return null;
    Q2(l, d, !0);
  }
  function KG() {
    sK(function() {
      (ln & 6) !== 0 ? An(
        ke,
        GG
      ) : gO();
    });
  }
  function IS() {
    if (jl === 0) {
      var l = Vd;
      l === 0 && (l = Ke, Ke <<= 1, (Ke & 261888) === 0 && (Ke = 256)), jl = l;
    }
    return jl;
  }
  function xO(l) {
    return l == null || typeof l == "symbol" || typeof l == "boolean" ? null : typeof l == "function" ? l : Xo("" + l);
  }
  function wO(l, d) {
    var p = d.ownerDocument.createElement("input");
    return p.name = d.name, p.value = d.value, l.id && p.setAttribute("form", l.id), d.parentNode.insertBefore(p, d), l = new FormData(l), p.parentNode.removeChild(p), l;
  }
  function ZG(l, d, p, y, E) {
    if (d === "submit" && p && p.stateNode === E) {
      var T = xO(
        (E[ar] || null).action
      ), j = y.submitter;
      j && (d = (d = j[ar] || null) ? xO(d.formAction) : j.getAttribute("formAction"), d !== null && (T = d, j = null));
      var V = new kd(
        "action",
        "action",
        null,
        y,
        E
      );
      l.push({
        event: V,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (y.defaultPrevented) {
                if (jl !== 0) {
                  var te = j ? wO(E, j) : new FormData(E);
                  nS(
                    p,
                    {
                      pending: !0,
                      data: te,
                      method: E.method,
                      action: T
                    },
                    null,
                    te
                  );
                }
              } else
                typeof T == "function" && (V.preventDefault(), te = j ? wO(E, j) : new FormData(E), nS(
                  p,
                  {
                    pending: !0,
                    data: te,
                    method: E.method,
                    action: T
                  },
                  T,
                  te
                ));
            },
            currentTarget: E
          }
        ]
      });
    }
  }
  for (var zS = 0; zS < Ze.length; zS++) {
    var LS = Ze[zS], YG = LS.toLowerCase(), XG = LS[0].toUpperCase() + LS.slice(1);
    Be(
      YG,
      "on" + XG
    );
  }
  Be(_e, "onAnimationEnd"), Be(ve, "onAnimationIteration"), Be(Re, "onAnimationStart"), Be("dblclick", "onDoubleClick"), Be("focusin", "onFocus"), Be("focusout", "onBlur"), Be(ze, "onTransitionRun"), Be(We, "onTransitionStart"), Be(qe, "onTransitionCancel"), Be(Le, "onTransitionEnd"), ws("onMouseEnter", ["mouseout", "mouseover"]), ws("onMouseLeave", ["mouseout", "mouseover"]), ws("onPointerEnter", ["pointerout", "pointerover"]), ws("onPointerLeave", ["pointerout", "pointerover"]), Zo(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Zo(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Zo("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Zo(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Zo(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Zo(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Ip = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), JG = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Ip)
  );
  function SO(l, d) {
    d = (d & 4) !== 0;
    for (var p = 0; p < l.length; p++) {
      var y = l[p], E = y.event;
      y = y.listeners;
      e: {
        var T = void 0;
        if (d)
          for (var j = y.length - 1; 0 <= j; j--) {
            var V = y[j], te = V.instance, Ee = V.currentTarget;
            if (V = V.listener, te !== T && E.isPropagationStopped())
              break e;
            T = V, E.currentTarget = Ee;
            try {
              T(E);
            } catch (Oe) {
              Je(Oe);
            }
            E.currentTarget = null, T = te;
          }
        else
          for (j = 0; j < y.length; j++) {
            if (V = y[j], te = V.instance, Ee = V.currentTarget, V = V.listener, te !== T && E.isPropagationStopped())
              break e;
            T = V, E.currentTarget = Ee;
            try {
              T(E);
            } catch (Oe) {
              Je(Oe);
            }
            E.currentTarget = null, T = te;
          }
      }
    }
  }
  function qt(l, d) {
    var p = d[ll];
    p === void 0 && (p = d[ll] = /* @__PURE__ */ new Set());
    var y = l + "__bubble";
    p.has(y) || (kO(d, l, 2, !1), p.add(y));
  }
  function BS(l, d, p) {
    var y = 0;
    d && (y |= 4), kO(
      p,
      l,
      y,
      d
    );
  }
  var av = "_reactListening" + Math.random().toString(36).slice(2);
  function $S(l) {
    if (!l[av]) {
      l[av] = !0, sa.forEach(function(p) {
        p !== "selectionchange" && (JG.has(p) || BS(p, !1, l), BS(p, !0, l));
      });
      var d = l.nodeType === 9 ? l : l.ownerDocument;
      d === null || d[av] || (d[av] = !0, BS("selectionchange", !1, d));
    }
  }
  function kO(l, d, p, y) {
    switch (JO(d)) {
      case 2:
        var E = _K;
        break;
      case 8:
        E = TK;
        break;
      default:
        E = tk;
    }
    p = E.bind(
      null,
      d,
      p,
      l
    ), E = void 0, !Qh || d !== "touchstart" && d !== "touchmove" && d !== "wheel" || (E = !0), y ? E !== void 0 ? l.addEventListener(d, p, {
      capture: !0,
      passive: E
    }) : l.addEventListener(d, p, !0) : E !== void 0 ? l.addEventListener(d, p, {
      passive: E
    }) : l.addEventListener(d, p, !1);
  }
  function US(l, d, p, y, E) {
    var T = y;
    if ((d & 1) === 0 && (d & 2) === 0 && y !== null)
      e: for (; ; ) {
        if (y === null) return;
        var j = y.tag;
        if (j === 3 || j === 4) {
          var V = y.stateNode.containerInfo;
          if (V === E) break;
          if (j === 4)
            for (j = y.return; j !== null; ) {
              var te = j.tag;
              if ((te === 3 || te === 4) && j.stateNode.containerInfo === E)
                return;
              j = j.return;
            }
          for (; V !== null; ) {
            if (j = xs(V), j === null) return;
            if (te = j.tag, te === 5 || te === 6 || te === 26 || te === 27) {
              y = T = j;
              continue e;
            }
            V = V.parentNode;
          }
        }
        y = y.return;
      }
    ul(function() {
      var Ee = T, Oe = wd(p), Ie = [];
      e: {
        var Te = Xe.get(l);
        if (Te !== void 0) {
          var Me = kd, rt = l;
          switch (l) {
            case "keypress":
              if (hl(p) === 0) break e;
            case "keydown":
            case "keyup":
              Me = Nd;
              break;
            case "focusin":
              rt = "focus", Me = pl;
              break;
            case "focusout":
              rt = "blur", Me = pl;
              break;
            case "beforeblur":
            case "afterblur":
              Me = pl;
              break;
            case "click":
              if (p.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Me = _d;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Me = py;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Me = sp;
              break;
            case _e:
            case ve:
            case Re:
              Me = my;
              break;
            case Le:
              Me = ap;
              break;
            case "scroll":
            case "scrollend":
              Me = Cd;
              break;
            case "wheel":
              Me = Od;
              break;
            case "copy":
            case "cut":
            case "paste":
              Me = ml;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Me = op;
              break;
            case "toggle":
            case "beforetoggle":
              Me = vy;
          }
          var vt = (d & 4) !== 0, Sn = !vt && (l === "scroll" || l === "scrollend"), me = vt ? Te !== null ? Te + "Capture" : null : Te;
          vt = [];
          for (var de = Ee, Ce; de !== null; ) {
            var je = de;
            if (Ce = je.stateNode, je = je.tag, je !== 5 && je !== 26 && je !== 27 || Ce === null || me === null || (je = da(de, me), je != null && vt.push(
              zp(de, je, Ce)
            )), Sn) break;
            de = de.return;
          }
          0 < vt.length && (Te = new Me(
            Te,
            rt,
            null,
            p,
            Oe
          ), Ie.push({ event: Te, listeners: vt }));
        }
      }
      if ((d & 7) === 0) {
        e: {
          if (Te = l === "mouseover" || l === "pointerover", Me = l === "mouseout" || l === "pointerout", Te && p !== bo && (rt = p.relatedTarget || p.fromElement) && (xs(rt) || rt[wi]))
            break e;
          if ((Me || Te) && (Te = Oe.window === Oe ? Oe : (Te = Oe.ownerDocument) ? Te.defaultView || Te.parentWindow : window, Me ? (rt = p.relatedTarget || p.toElement, Me = Ee, rt = rt ? xs(rt) : null, rt !== null && (Sn = o(rt), vt = rt.tag, rt !== Sn || vt !== 5 && vt !== 27 && vt !== 6) && (rt = null)) : (Me = null, rt = Ee), Me !== rt)) {
            if (vt = _d, je = "onMouseLeave", me = "onMouseEnter", de = "mouse", (l === "pointerout" || l === "pointerover") && (vt = op, je = "onPointerLeave", me = "onPointerEnter", de = "pointer"), Sn = Me == null ? Te : Ji(Me), Ce = rt == null ? Te : Ji(rt), Te = new vt(
              je,
              de + "leave",
              Me,
              p,
              Oe
            ), Te.target = Sn, Te.relatedTarget = Ce, je = null, xs(Oe) === Ee && (vt = new vt(
              me,
              de + "enter",
              rt,
              p,
              Oe
            ), vt.target = Ce, vt.relatedTarget = Sn, je = vt), Sn = je, Me && rt)
              t: {
                for (vt = QG, me = Me, de = rt, Ce = 0, je = me; je; je = vt(je))
                  Ce++;
                je = 0;
                for (var pt = de; pt; pt = vt(pt))
                  je++;
                for (; 0 < Ce - je; )
                  me = vt(me), Ce--;
                for (; 0 < je - Ce; )
                  de = vt(de), je--;
                for (; Ce--; ) {
                  if (me === de || de !== null && me === de.alternate) {
                    vt = me;
                    break t;
                  }
                  me = vt(me), de = vt(de);
                }
                vt = null;
              }
            else vt = null;
            Me !== null && CO(
              Ie,
              Te,
              Me,
              vt,
              !1
            ), rt !== null && Sn !== null && CO(
              Ie,
              Sn,
              rt,
              vt,
              !0
            );
          }
        }
        e: {
          if (Te = Ee ? Ji(Ee) : window, Me = Te.nodeName && Te.nodeName.toLowerCase(), Me === "select" || Me === "input" && Te.type === "file")
            var rn = lu;
          else if (jd(Te))
            if (wo)
              rn = vl;
            else {
              rn = ya;
              var lt = Cy;
            }
          else
            Me = Te.nodeName, !Me || Me.toLowerCase() !== "input" || Te.type !== "checkbox" && Te.type !== "radio" ? Ee && Jh(Ee.elementType) && (rn = lu) : rn = fp;
          if (rn && (rn = rn(l, Ee))) {
            dp(
              Ie,
              rn,
              p,
              Oe
            );
            break e;
          }
          lt && lt(l, Te, Ee), l === "focusout" && Ee && Te.type === "number" && Ee.memoizedProps.value != null && eu(Te, "number", Te.value);
        }
        switch (lt = Ee ? Ji(Ee) : window, l) {
          case "focusin":
            (jd(lt) || lt.contentEditable === "true") && (K = lt, se = Ee, ye = null);
            break;
          case "focusout":
            ye = se = K = null;
            break;
          case "mousedown":
            ae = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            ae = !1, oe(Ie, p, Oe);
            break;
          case "selectionchange":
            if (q) break;
          case "keydown":
          case "keyup":
            oe(Ie, p, Oe);
        }
        var Ot;
        if (su)
          e: {
            switch (l) {
              case "compositionstart":
                var Yt = "onCompositionStart";
                break e;
              case "compositionend":
                Yt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Yt = "onCompositionUpdate";
                break e;
            }
            Yt = void 0;
          }
        else
          ma ? up(l, p) && (Yt = "onCompositionEnd") : l === "keydown" && p.keyCode === 229 && (Yt = "onCompositionStart");
        Yt && (Dd && p.locale !== "ko" && (ma || Yt !== "onCompositionStart" ? Yt === "onCompositionEnd" && ma && (Ot = fl()) : (xo = Oe, Sd = "value" in xo ? xo.value : xo.textContent, ma = !0)), lt = lv(Ee, Yt), 0 < lt.length && (Yt = new Md(
          Yt,
          l,
          null,
          p,
          Oe
        ), Ie.push({ event: Yt, listeners: lt }), Ot ? Yt.data = Ot : (Ot = xy(p), Ot !== null && (Yt.data = Ot)))), (Ot = b1 ? wy(l, p) : x1(l, p)) && (Yt = lv(Ee, "onBeforeInput"), 0 < Yt.length && (lt = new Md(
          "onBeforeInput",
          "beforeinput",
          null,
          p,
          Oe
        ), Ie.push({
          event: lt,
          listeners: Yt
        }), lt.data = Ot)), ZG(
          Ie,
          l,
          Ee,
          p,
          Oe
        );
      }
      SO(Ie, d);
    });
  }
  function zp(l, d, p) {
    return {
      instance: l,
      listener: d,
      currentTarget: p
    };
  }
  function lv(l, d) {
    for (var p = d + "Capture", y = []; l !== null; ) {
      var E = l, T = E.stateNode;
      if (E = E.tag, E !== 5 && E !== 26 && E !== 27 || T === null || (E = da(l, p), E != null && y.unshift(
        zp(l, E, T)
      ), E = da(l, d), E != null && y.push(
        zp(l, E, T)
      )), l.tag === 3) return y;
      l = l.return;
    }
    return [];
  }
  function QG(l) {
    if (l === null) return null;
    do
      l = l.return;
    while (l && l.tag !== 5 && l.tag !== 27);
    return l || null;
  }
  function CO(l, d, p, y, E) {
    for (var T = d._reactName, j = []; p !== null && p !== y; ) {
      var V = p, te = V.alternate, Ee = V.stateNode;
      if (V = V.tag, te !== null && te === y) break;
      V !== 5 && V !== 26 && V !== 27 || Ee === null || (te = Ee, E ? (Ee = da(p, T), Ee != null && j.unshift(
        zp(p, Ee, te)
      )) : E || (Ee = da(p, T), Ee != null && j.push(
        zp(p, Ee, te)
      ))), p = p.return;
    }
    j.length !== 0 && l.push({ event: d, listeners: j });
  }
  var eK = /\r\n?/g, tK = /\u0000|\uFFFD/g;
  function EO(l) {
    return (typeof l == "string" ? l : "" + l).replace(eK, `
`).replace(tK, "");
  }
  function _O(l, d) {
    return d = EO(d), EO(l) === d;
  }
  function wn(l, d, p, y, E, T) {
    switch (p) {
      case "children":
        typeof y == "string" ? d === "body" || d === "textarea" && y === "" || la(l, y) : (typeof y == "number" || typeof y == "bigint") && d !== "body" && la(l, "" + y);
        break;
      case "className":
        Jc(l, "class", y);
        break;
      case "tabIndex":
        Jc(l, "tabindex", y);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Jc(l, p, y);
        break;
      case "style":
        Xh(l, y, T);
        break;
      case "data":
        if (d !== "object") {
          Jc(l, "data", y);
          break;
        }
      case "src":
      case "href":
        if (y === "" && (d !== "a" || p !== "href")) {
          l.removeAttribute(p);
          break;
        }
        if (y == null || typeof y == "function" || typeof y == "symbol" || typeof y == "boolean") {
          l.removeAttribute(p);
          break;
        }
        y = Xo("" + y), l.setAttribute(p, y);
        break;
      case "action":
      case "formAction":
        if (typeof y == "function") {
          l.setAttribute(
            p,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof T == "function" && (p === "formAction" ? (d !== "input" && wn(l, d, "name", E.name, E, null), wn(
            l,
            d,
            "formEncType",
            E.formEncType,
            E,
            null
          ), wn(
            l,
            d,
            "formMethod",
            E.formMethod,
            E,
            null
          ), wn(
            l,
            d,
            "formTarget",
            E.formTarget,
            E,
            null
          )) : (wn(l, d, "encType", E.encType, E, null), wn(l, d, "method", E.method, E, null), wn(l, d, "target", E.target, E, null)));
        if (y == null || typeof y == "symbol" || typeof y == "boolean") {
          l.removeAttribute(p);
          break;
        }
        y = Xo("" + y), l.setAttribute(p, y);
        break;
      case "onClick":
        y != null && (l.onclick = zi);
        break;
      case "onScroll":
        y != null && qt("scroll", l);
        break;
      case "onScrollEnd":
        y != null && qt("scrollend", l);
        break;
      case "dangerouslySetInnerHTML":
        if (y != null) {
          if (typeof y != "object" || !("__html" in y))
            throw Error(r(61));
          if (p = y.__html, p != null) {
            if (E.children != null) throw Error(r(60));
            l.innerHTML = p;
          }
        }
        break;
      case "multiple":
        l.multiple = y && typeof y != "function" && typeof y != "symbol";
        break;
      case "muted":
        l.muted = y && typeof y != "function" && typeof y != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (y == null || typeof y == "function" || typeof y == "boolean" || typeof y == "symbol") {
          l.removeAttribute("xlink:href");
          break;
        }
        p = Xo("" + y), l.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          p
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        y != null && typeof y != "function" && typeof y != "symbol" ? l.setAttribute(p, "" + y) : l.removeAttribute(p);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        y && typeof y != "function" && typeof y != "symbol" ? l.setAttribute(p, "") : l.removeAttribute(p);
        break;
      case "capture":
      case "download":
        y === !0 ? l.setAttribute(p, "") : y !== !1 && y != null && typeof y != "function" && typeof y != "symbol" ? l.setAttribute(p, y) : l.removeAttribute(p);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        y != null && typeof y != "function" && typeof y != "symbol" && !isNaN(y) && 1 <= y ? l.setAttribute(p, y) : l.removeAttribute(p);
        break;
      case "rowSpan":
      case "start":
        y == null || typeof y == "function" || typeof y == "symbol" || isNaN(y) ? l.removeAttribute(p) : l.setAttribute(p, y);
        break;
      case "popover":
        qt("beforetoggle", l), qt("toggle", l), Pt(l, "popover", y);
        break;
      case "xlinkActuate":
        vo(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          y
        );
        break;
      case "xlinkArcrole":
        vo(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          y
        );
        break;
      case "xlinkRole":
        vo(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          y
        );
        break;
      case "xlinkShow":
        vo(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          y
        );
        break;
      case "xlinkTitle":
        vo(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          y
        );
        break;
      case "xlinkType":
        vo(
          l,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          y
        );
        break;
      case "xmlBase":
        vo(
          l,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          y
        );
        break;
      case "xmlLang":
        vo(
          l,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          y
        );
        break;
      case "xmlSpace":
        vo(
          l,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          y
        );
        break;
      case "is":
        Pt(l, "is", y);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < p.length) || p[0] !== "o" && p[0] !== "O" || p[1] !== "n" && p[1] !== "N") && (p = g1.get(p) || p, Pt(l, p, y));
    }
  }
  function FS(l, d, p, y, E, T) {
    switch (p) {
      case "style":
        Xh(l, y, T);
        break;
      case "dangerouslySetInnerHTML":
        if (y != null) {
          if (typeof y != "object" || !("__html" in y))
            throw Error(r(61));
          if (p = y.__html, p != null) {
            if (E.children != null) throw Error(r(60));
            l.innerHTML = p;
          }
        }
        break;
      case "children":
        typeof y == "string" ? la(l, y) : (typeof y == "number" || typeof y == "bigint") && la(l, "" + y);
        break;
      case "onScroll":
        y != null && qt("scroll", l);
        break;
      case "onScrollEnd":
        y != null && qt("scrollend", l);
        break;
      case "onClick":
        y != null && (l.onclick = zi);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!Yc.hasOwnProperty(p))
          e: {
            if (p[0] === "o" && p[1] === "n" && (E = p.endsWith("Capture"), d = p.slice(2, E ? p.length - 7 : void 0), T = l[ar] || null, T = T != null ? T[p] : null, typeof T == "function" && l.removeEventListener(d, T, E), typeof y == "function")) {
              typeof T != "function" && T !== null && (p in l ? l[p] = null : l.hasAttribute(p) && l.removeAttribute(p)), l.addEventListener(d, y, E);
              break e;
            }
            p in l ? l[p] = y : y === !0 ? l.setAttribute(p, "") : Pt(l, p, y);
          }
    }
  }
  function Yr(l, d, p) {
    switch (d) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        qt("error", l), qt("load", l);
        var y = !1, E = !1, T;
        for (T in p)
          if (p.hasOwnProperty(T)) {
            var j = p[T];
            if (j != null)
              switch (T) {
                case "src":
                  y = !0;
                  break;
                case "srcSet":
                  E = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, d));
                default:
                  wn(l, d, T, j, p, null);
              }
          }
        E && wn(l, d, "srcSet", p.srcSet, p, null), y && wn(l, d, "src", p.src, p, null);
        return;
      case "input":
        qt("invalid", l);
        var V = T = j = E = null, te = null, Ee = null;
        for (y in p)
          if (p.hasOwnProperty(y)) {
            var Oe = p[y];
            if (Oe != null)
              switch (y) {
                case "name":
                  E = Oe;
                  break;
                case "type":
                  j = Oe;
                  break;
                case "checked":
                  te = Oe;
                  break;
                case "defaultChecked":
                  Ee = Oe;
                  break;
                case "value":
                  T = Oe;
                  break;
                case "defaultValue":
                  V = Oe;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Oe != null)
                    throw Error(r(137, d));
                  break;
                default:
                  wn(l, d, y, Oe, p, null);
              }
          }
        xd(
          l,
          T,
          V,
          te,
          Ee,
          j,
          E,
          !1
        );
        return;
      case "select":
        qt("invalid", l), y = j = T = null;
        for (E in p)
          if (p.hasOwnProperty(E) && (V = p[E], V != null))
            switch (E) {
              case "value":
                T = V;
                break;
              case "defaultValue":
                j = V;
                break;
              case "multiple":
                y = V;
              default:
                wn(l, d, E, V, p, null);
            }
        d = T, p = j, l.multiple = !!y, d != null ? Yo(l, !!y, d, !1) : p != null && Yo(l, !!y, p, !0);
        return;
      case "textarea":
        qt("invalid", l), T = E = y = null;
        for (j in p)
          if (p.hasOwnProperty(j) && (V = p[j], V != null))
            switch (j) {
              case "value":
                y = V;
                break;
              case "defaultValue":
                E = V;
                break;
              case "children":
                T = V;
                break;
              case "dangerouslySetInnerHTML":
                if (V != null) throw Error(r(91));
                break;
              default:
                wn(l, d, j, V, p, null);
            }
        tu(l, y, E, T);
        return;
      case "option":
        for (te in p)
          p.hasOwnProperty(te) && (y = p[te], y != null) && (te === "selected" ? l.selected = y && typeof y != "function" && typeof y != "symbol" : wn(l, d, te, y, p, null));
        return;
      case "dialog":
        qt("beforetoggle", l), qt("toggle", l), qt("cancel", l), qt("close", l);
        break;
      case "iframe":
      case "object":
        qt("load", l);
        break;
      case "video":
      case "audio":
        for (y = 0; y < Ip.length; y++)
          qt(Ip[y], l);
        break;
      case "image":
        qt("error", l), qt("load", l);
        break;
      case "details":
        qt("toggle", l);
        break;
      case "embed":
      case "source":
      case "link":
        qt("error", l), qt("load", l);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (Ee in p)
          if (p.hasOwnProperty(Ee) && (y = p[Ee], y != null))
            switch (Ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, d));
              default:
                wn(l, d, Ee, y, p, null);
            }
        return;
      default:
        if (Jh(d)) {
          for (Oe in p)
            p.hasOwnProperty(Oe) && (y = p[Oe], y !== void 0 && FS(
              l,
              d,
              Oe,
              y,
              p,
              void 0
            ));
          return;
        }
    }
    for (V in p)
      p.hasOwnProperty(V) && (y = p[V], y != null && wn(l, d, V, y, p, null));
  }
  function nK(l, d, p, y) {
    switch (d) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var E = null, T = null, j = null, V = null, te = null, Ee = null, Oe = null;
        for (Me in p) {
          var Ie = p[Me];
          if (p.hasOwnProperty(Me) && Ie != null)
            switch (Me) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                te = Ie;
              default:
                y.hasOwnProperty(Me) || wn(l, d, Me, null, y, Ie);
            }
        }
        for (var Te in y) {
          var Me = y[Te];
          if (Ie = p[Te], y.hasOwnProperty(Te) && (Me != null || Ie != null))
            switch (Te) {
              case "type":
                T = Me;
                break;
              case "name":
                E = Me;
                break;
              case "checked":
                Ee = Me;
                break;
              case "defaultChecked":
                Oe = Me;
                break;
              case "value":
                j = Me;
                break;
              case "defaultValue":
                V = Me;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (Me != null)
                  throw Error(r(137, d));
                break;
              default:
                Me !== Ie && wn(
                  l,
                  d,
                  Te,
                  Me,
                  y,
                  Ie
                );
            }
        }
        Ss(
          l,
          j,
          V,
          te,
          Ee,
          Oe,
          T,
          E
        );
        return;
      case "select":
        Me = j = V = Te = null;
        for (T in p)
          if (te = p[T], p.hasOwnProperty(T) && te != null)
            switch (T) {
              case "value":
                break;
              case "multiple":
                Me = te;
              default:
                y.hasOwnProperty(T) || wn(
                  l,
                  d,
                  T,
                  null,
                  y,
                  te
                );
            }
        for (E in y)
          if (T = y[E], te = p[E], y.hasOwnProperty(E) && (T != null || te != null))
            switch (E) {
              case "value":
                Te = T;
                break;
              case "defaultValue":
                V = T;
                break;
              case "multiple":
                j = T;
              default:
                T !== te && wn(
                  l,
                  d,
                  E,
                  T,
                  y,
                  te
                );
            }
        d = V, p = j, y = Me, Te != null ? Yo(l, !!p, Te, !1) : !!y != !!p && (d != null ? Yo(l, !!p, d, !0) : Yo(l, !!p, p ? [] : "", !1));
        return;
      case "textarea":
        Me = Te = null;
        for (V in p)
          if (E = p[V], p.hasOwnProperty(V) && E != null && !y.hasOwnProperty(V))
            switch (V) {
              case "value":
                break;
              case "children":
                break;
              default:
                wn(l, d, V, null, y, E);
            }
        for (j in y)
          if (E = y[j], T = p[j], y.hasOwnProperty(j) && (E != null || T != null))
            switch (j) {
              case "value":
                Te = E;
                break;
              case "defaultValue":
                Me = E;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (E != null) throw Error(r(91));
                break;
              default:
                E !== T && wn(l, d, j, E, y, T);
            }
        Yh(l, Te, Me);
        return;
      case "option":
        for (var rt in p)
          Te = p[rt], p.hasOwnProperty(rt) && Te != null && !y.hasOwnProperty(rt) && (rt === "selected" ? l.selected = !1 : wn(
            l,
            d,
            rt,
            null,
            y,
            Te
          ));
        for (te in y)
          Te = y[te], Me = p[te], y.hasOwnProperty(te) && Te !== Me && (Te != null || Me != null) && (te === "selected" ? l.selected = Te && typeof Te != "function" && typeof Te != "symbol" : wn(
            l,
            d,
            te,
            Te,
            y,
            Me
          ));
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var vt in p)
          Te = p[vt], p.hasOwnProperty(vt) && Te != null && !y.hasOwnProperty(vt) && wn(l, d, vt, null, y, Te);
        for (Ee in y)
          if (Te = y[Ee], Me = p[Ee], y.hasOwnProperty(Ee) && Te !== Me && (Te != null || Me != null))
            switch (Ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (Te != null)
                  throw Error(r(137, d));
                break;
              default:
                wn(
                  l,
                  d,
                  Ee,
                  Te,
                  y,
                  Me
                );
            }
        return;
      default:
        if (Jh(d)) {
          for (var Sn in p)
            Te = p[Sn], p.hasOwnProperty(Sn) && Te !== void 0 && !y.hasOwnProperty(Sn) && FS(
              l,
              d,
              Sn,
              void 0,
              y,
              Te
            );
          for (Oe in y)
            Te = y[Oe], Me = p[Oe], !y.hasOwnProperty(Oe) || Te === Me || Te === void 0 && Me === void 0 || FS(
              l,
              d,
              Oe,
              Te,
              y,
              Me
            );
          return;
        }
    }
    for (var me in p)
      Te = p[me], p.hasOwnProperty(me) && Te != null && !y.hasOwnProperty(me) && wn(l, d, me, null, y, Te);
    for (Ie in y)
      Te = y[Ie], Me = p[Ie], !y.hasOwnProperty(Ie) || Te === Me || Te == null && Me == null || wn(l, d, Ie, Te, y, Me);
  }
  function TO(l) {
    switch (l) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function rK() {
    if (typeof performance.getEntriesByType == "function") {
      for (var l = 0, d = 0, p = performance.getEntriesByType("resource"), y = 0; y < p.length; y++) {
        var E = p[y], T = E.transferSize, j = E.initiatorType, V = E.duration;
        if (T && V && TO(j)) {
          for (j = 0, V = E.responseEnd, y += 1; y < p.length; y++) {
            var te = p[y], Ee = te.startTime;
            if (Ee > V) break;
            var Oe = te.transferSize, Ie = te.initiatorType;
            Oe && TO(Ie) && (te = te.responseEnd, j += Oe * (te < V ? 1 : (V - Ee) / (te - Ee)));
          }
          if (--y, d += 8 * (T + j) / (E.duration / 1e3), l++, 10 < l) break;
        }
      }
      if (0 < l) return d / l / 1e6;
    }
    return navigator.connection && (l = navigator.connection.downlink, typeof l == "number") ? l : 5;
  }
  var VS = null, HS = null;
  function cv(l) {
    return l.nodeType === 9 ? l : l.ownerDocument;
  }
  function AO(l) {
    switch (l) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function MO(l, d) {
    if (l === 0)
      switch (d) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return l === 1 && d === "foreignObject" ? 0 : l;
  }
  function WS(l, d) {
    return l === "textarea" || l === "noscript" || typeof d.children == "string" || typeof d.children == "number" || typeof d.children == "bigint" || typeof d.dangerouslySetInnerHTML == "object" && d.dangerouslySetInnerHTML !== null && d.dangerouslySetInnerHTML.__html != null;
  }
  var qS = null;
  function iK() {
    var l = window.event;
    return l && l.type === "popstate" ? l === qS ? !1 : (qS = l, !0) : (qS = null, !1);
  }
  var NO = typeof setTimeout == "function" ? setTimeout : void 0, oK = typeof clearTimeout == "function" ? clearTimeout : void 0, RO = typeof Promise == "function" ? Promise : void 0, sK = typeof queueMicrotask == "function" ? queueMicrotask : typeof RO < "u" ? function(l) {
    return RO.resolve(null).then(l).catch(aK);
  } : NO;
  function aK(l) {
    setTimeout(function() {
      throw l;
    });
  }
  function Il(l) {
    return l === "head";
  }
  function OO(l, d) {
    var p = d, y = 0;
    do {
      var E = p.nextSibling;
      if (l.removeChild(p), E && E.nodeType === 8)
        if (p = E.data, p === "/$" || p === "/&") {
          if (y === 0) {
            l.removeChild(E), cf(d);
            return;
          }
          y--;
        } else if (p === "$" || p === "$?" || p === "$~" || p === "$!" || p === "&")
          y++;
        else if (p === "html")
          Lp(l.ownerDocument.documentElement);
        else if (p === "head") {
          p = l.ownerDocument.head, Lp(p);
          for (var T = p.firstChild; T; ) {
            var j = T.nextSibling, V = T.nodeName;
            T[Xi] || V === "SCRIPT" || V === "STYLE" || V === "LINK" && T.rel.toLowerCase() === "stylesheet" || p.removeChild(T), T = j;
          }
        } else
          p === "body" && Lp(l.ownerDocument.body);
      p = E;
    } while (p);
    cf(d);
  }
  function DO(l, d) {
    var p = l;
    l = 0;
    do {
      var y = p.nextSibling;
      if (p.nodeType === 1 ? d ? (p._stashedDisplay = p.style.display, p.style.display = "none") : (p.style.display = p._stashedDisplay || "", p.getAttribute("style") === "" && p.removeAttribute("style")) : p.nodeType === 3 && (d ? (p._stashedText = p.nodeValue, p.nodeValue = "") : p.nodeValue = p._stashedText || ""), y && y.nodeType === 8)
        if (p = y.data, p === "/$") {
          if (l === 0) break;
          l--;
        } else
          p !== "$" && p !== "$?" && p !== "$~" && p !== "$!" || l++;
      p = y;
    } while (p);
  }
  function GS(l) {
    var d = l.firstChild;
    for (d && d.nodeType === 10 && (d = d.nextSibling); d; ) {
      var p = d;
      switch (d = d.nextSibling, p.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          GS(p), vd(p);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (p.rel.toLowerCase() === "stylesheet") continue;
      }
      l.removeChild(p);
    }
  }
  function lK(l, d, p, y) {
    for (; l.nodeType === 1; ) {
      var E = p;
      if (l.nodeName.toLowerCase() !== d.toLowerCase()) {
        if (!y && (l.nodeName !== "INPUT" || l.type !== "hidden"))
          break;
      } else if (y) {
        if (!l[Xi])
          switch (d) {
            case "meta":
              if (!l.hasAttribute("itemprop")) break;
              return l;
            case "link":
              if (T = l.getAttribute("rel"), T === "stylesheet" && l.hasAttribute("data-precedence"))
                break;
              if (T !== E.rel || l.getAttribute("href") !== (E.href == null || E.href === "" ? null : E.href) || l.getAttribute("crossorigin") !== (E.crossOrigin == null ? null : E.crossOrigin) || l.getAttribute("title") !== (E.title == null ? null : E.title))
                break;
              return l;
            case "style":
              if (l.hasAttribute("data-precedence")) break;
              return l;
            case "script":
              if (T = l.getAttribute("src"), (T !== (E.src == null ? null : E.src) || l.getAttribute("type") !== (E.type == null ? null : E.type) || l.getAttribute("crossorigin") !== (E.crossOrigin == null ? null : E.crossOrigin)) && T && l.hasAttribute("async") && !l.hasAttribute("itemprop"))
                break;
              return l;
            default:
              return l;
          }
      } else if (d === "input" && l.type === "hidden") {
        var T = E.name == null ? null : "" + E.name;
        if (E.type === "hidden" && l.getAttribute("name") === T)
          return l;
      } else return l;
      if (l = To(l.nextSibling), l === null) break;
    }
    return null;
  }
  function cK(l, d, p) {
    if (d === "") return null;
    for (; l.nodeType !== 3; )
      if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !p || (l = To(l.nextSibling), l === null)) return null;
    return l;
  }
  function PO(l, d) {
    for (; l.nodeType !== 8; )
      if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !d || (l = To(l.nextSibling), l === null)) return null;
    return l;
  }
  function KS(l) {
    return l.data === "$?" || l.data === "$~";
  }
  function ZS(l) {
    return l.data === "$!" || l.data === "$?" && l.ownerDocument.readyState !== "loading";
  }
  function uK(l, d) {
    var p = l.ownerDocument;
    if (l.data === "$~") l._reactRetry = d;
    else if (l.data !== "$?" || p.readyState !== "loading")
      d();
    else {
      var y = function() {
        d(), p.removeEventListener("DOMContentLoaded", y);
      };
      p.addEventListener("DOMContentLoaded", y), l._reactRetry = y;
    }
  }
  function To(l) {
    for (; l != null; l = l.nextSibling) {
      var d = l.nodeType;
      if (d === 1 || d === 3) break;
      if (d === 8) {
        if (d = l.data, d === "$" || d === "$!" || d === "$?" || d === "$~" || d === "&" || d === "F!" || d === "F")
          break;
        if (d === "/$" || d === "/&") return null;
      }
    }
    return l;
  }
  var YS = null;
  function jO(l) {
    l = l.nextSibling;
    for (var d = 0; l; ) {
      if (l.nodeType === 8) {
        var p = l.data;
        if (p === "/$" || p === "/&") {
          if (d === 0)
            return To(l.nextSibling);
          d--;
        } else
          p !== "$" && p !== "$!" && p !== "$?" && p !== "$~" && p !== "&" || d++;
      }
      l = l.nextSibling;
    }
    return null;
  }
  function IO(l) {
    l = l.previousSibling;
    for (var d = 0; l; ) {
      if (l.nodeType === 8) {
        var p = l.data;
        if (p === "$" || p === "$!" || p === "$?" || p === "$~" || p === "&") {
          if (d === 0) return l;
          d--;
        } else p !== "/$" && p !== "/&" || d++;
      }
      l = l.previousSibling;
    }
    return null;
  }
  function zO(l, d, p) {
    switch (d = cv(p), l) {
      case "html":
        if (l = d.documentElement, !l) throw Error(r(452));
        return l;
      case "head":
        if (l = d.head, !l) throw Error(r(453));
        return l;
      case "body":
        if (l = d.body, !l) throw Error(r(454));
        return l;
      default:
        throw Error(r(451));
    }
  }
  function Lp(l) {
    for (var d = l.attributes; d.length; )
      l.removeAttributeNode(d[0]);
    vd(l);
  }
  var Ao = /* @__PURE__ */ new Map(), LO = /* @__PURE__ */ new Set();
  function uv(l) {
    return typeof l.getRootNode == "function" ? l.getRootNode() : l.nodeType === 9 ? l : l.ownerDocument;
  }
  var Oa = Q.d;
  Q.d = {
    f: dK,
    r: fK,
    D: hK,
    C: pK,
    L: mK,
    m: gK,
    X: vK,
    S: yK,
    M: bK
  };
  function dK() {
    var l = Oa.f(), d = tv();
    return l || d;
  }
  function fK(l) {
    var d = vn(l);
    d !== null && d.tag === 5 && d.type === "form" ? t2(d) : Oa.r(l);
  }
  var sf = typeof document > "u" ? null : document;
  function BO(l, d, p) {
    var y = sf;
    if (y && typeof d == "string" && d) {
      var E = jr(d);
      E = 'link[rel="' + l + '"][href="' + E + '"]', typeof p == "string" && (E += '[crossorigin="' + p + '"]'), LO.has(E) || (LO.add(E), l = { rel: l, crossOrigin: p, href: d }, y.querySelector(E) === null && (d = y.createElement("link"), Yr(d, "link", l), lr(d), y.head.appendChild(d)));
    }
  }
  function hK(l) {
    Oa.D(l), BO("dns-prefetch", l, null);
  }
  function pK(l, d) {
    Oa.C(l, d), BO("preconnect", l, d);
  }
  function mK(l, d, p) {
    Oa.L(l, d, p);
    var y = sf;
    if (y && l && d) {
      var E = 'link[rel="preload"][as="' + jr(d) + '"]';
      d === "image" && p && p.imageSrcSet ? (E += '[imagesrcset="' + jr(
        p.imageSrcSet
      ) + '"]', typeof p.imageSizes == "string" && (E += '[imagesizes="' + jr(
        p.imageSizes
      ) + '"]')) : E += '[href="' + jr(l) + '"]';
      var T = E;
      switch (d) {
        case "style":
          T = af(l);
          break;
        case "script":
          T = lf(l);
      }
      Ao.has(T) || (l = h(
        {
          rel: "preload",
          href: d === "image" && p && p.imageSrcSet ? void 0 : l,
          as: d
        },
        p
      ), Ao.set(T, l), y.querySelector(E) !== null || d === "style" && y.querySelector(Bp(T)) || d === "script" && y.querySelector($p(T)) || (d = y.createElement("link"), Yr(d, "link", l), lr(d), y.head.appendChild(d)));
    }
  }
  function gK(l, d) {
    Oa.m(l, d);
    var p = sf;
    if (p && l) {
      var y = d && typeof d.as == "string" ? d.as : "script", E = 'link[rel="modulepreload"][as="' + jr(y) + '"][href="' + jr(l) + '"]', T = E;
      switch (y) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          T = lf(l);
      }
      if (!Ao.has(T) && (l = h({ rel: "modulepreload", href: l }, d), Ao.set(T, l), p.querySelector(E) === null)) {
        switch (y) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (p.querySelector($p(T)))
              return;
        }
        y = p.createElement("link"), Yr(y, "link", l), lr(y), p.head.appendChild(y);
      }
    }
  }
  function yK(l, d, p) {
    Oa.S(l, d, p);
    var y = sf;
    if (y && l) {
      var E = si(y).hoistableStyles, T = af(l);
      d = d || "default";
      var j = E.get(T);
      if (!j) {
        var V = { loading: 0, preload: null };
        if (j = y.querySelector(
          Bp(T)
        ))
          V.loading = 5;
        else {
          l = h(
            { rel: "stylesheet", href: l, "data-precedence": d },
            p
          ), (p = Ao.get(T)) && XS(l, p);
          var te = j = y.createElement("link");
          lr(te), Yr(te, "link", l), te._p = new Promise(function(Ee, Oe) {
            te.onload = Ee, te.onerror = Oe;
          }), te.addEventListener("load", function() {
            V.loading |= 1;
          }), te.addEventListener("error", function() {
            V.loading |= 2;
          }), V.loading |= 4, dv(j, d, y);
        }
        j = {
          type: "stylesheet",
          instance: j,
          count: 1,
          state: V
        }, E.set(T, j);
      }
    }
  }
  function vK(l, d) {
    Oa.X(l, d);
    var p = sf;
    if (p && l) {
      var y = si(p).hoistableScripts, E = lf(l), T = y.get(E);
      T || (T = p.querySelector($p(E)), T || (l = h({ src: l, async: !0 }, d), (d = Ao.get(E)) && JS(l, d), T = p.createElement("script"), lr(T), Yr(T, "link", l), p.head.appendChild(T)), T = {
        type: "script",
        instance: T,
        count: 1,
        state: null
      }, y.set(E, T));
    }
  }
  function bK(l, d) {
    Oa.M(l, d);
    var p = sf;
    if (p && l) {
      var y = si(p).hoistableScripts, E = lf(l), T = y.get(E);
      T || (T = p.querySelector($p(E)), T || (l = h({ src: l, async: !0, type: "module" }, d), (d = Ao.get(E)) && JS(l, d), T = p.createElement("script"), lr(T), Yr(T, "link", l), p.head.appendChild(T)), T = {
        type: "script",
        instance: T,
        count: 1,
        state: null
      }, y.set(E, T));
    }
  }
  function $O(l, d, p, y) {
    var E = (E = re.current) ? uv(E) : null;
    if (!E) throw Error(r(446));
    switch (l) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof p.precedence == "string" && typeof p.href == "string" ? (d = af(p.href), p = si(
          E
        ).hoistableStyles, y = p.get(d), y || (y = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, p.set(d, y)), y) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (p.rel === "stylesheet" && typeof p.href == "string" && typeof p.precedence == "string") {
          l = af(p.href);
          var T = si(
            E
          ).hoistableStyles, j = T.get(l);
          if (j || (E = E.ownerDocument || E, j = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, T.set(l, j), (T = E.querySelector(
            Bp(l)
          )) && !T._p && (j.instance = T, j.state.loading = 5), Ao.has(l) || (p = {
            rel: "preload",
            as: "style",
            href: p.href,
            crossOrigin: p.crossOrigin,
            integrity: p.integrity,
            media: p.media,
            hrefLang: p.hrefLang,
            referrerPolicy: p.referrerPolicy
          }, Ao.set(l, p), T || xK(
            E,
            l,
            p,
            j.state
          ))), d && y === null)
            throw Error(r(528, ""));
          return j;
        }
        if (d && y !== null)
          throw Error(r(529, ""));
        return null;
      case "script":
        return d = p.async, p = p.src, typeof p == "string" && d && typeof d != "function" && typeof d != "symbol" ? (d = lf(p), p = si(
          E
        ).hoistableScripts, y = p.get(d), y || (y = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, p.set(d, y)), y) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(r(444, l));
    }
  }
  function af(l) {
    return 'href="' + jr(l) + '"';
  }
  function Bp(l) {
    return 'link[rel="stylesheet"][' + l + "]";
  }
  function UO(l) {
    return h({}, l, {
      "data-precedence": l.precedence,
      precedence: null
    });
  }
  function xK(l, d, p, y) {
    l.querySelector('link[rel="preload"][as="style"][' + d + "]") ? y.loading = 1 : (d = l.createElement("link"), y.preload = d, d.addEventListener("load", function() {
      return y.loading |= 1;
    }), d.addEventListener("error", function() {
      return y.loading |= 2;
    }), Yr(d, "link", p), lr(d), l.head.appendChild(d));
  }
  function lf(l) {
    return '[src="' + jr(l) + '"]';
  }
  function $p(l) {
    return "script[async]" + l;
  }
  function FO(l, d, p) {
    if (d.count++, d.instance === null)
      switch (d.type) {
        case "style":
          var y = l.querySelector(
            'style[data-href~="' + jr(p.href) + '"]'
          );
          if (y)
            return d.instance = y, lr(y), y;
          var E = h({}, p, {
            "data-href": p.href,
            "data-precedence": p.precedence,
            href: null,
            precedence: null
          });
          return y = (l.ownerDocument || l).createElement(
            "style"
          ), lr(y), Yr(y, "style", E), dv(y, p.precedence, l), d.instance = y;
        case "stylesheet":
          E = af(p.href);
          var T = l.querySelector(
            Bp(E)
          );
          if (T)
            return d.state.loading |= 4, d.instance = T, lr(T), T;
          y = UO(p), (E = Ao.get(E)) && XS(y, E), T = (l.ownerDocument || l).createElement("link"), lr(T);
          var j = T;
          return j._p = new Promise(function(V, te) {
            j.onload = V, j.onerror = te;
          }), Yr(T, "link", y), d.state.loading |= 4, dv(T, p.precedence, l), d.instance = T;
        case "script":
          return T = lf(p.src), (E = l.querySelector(
            $p(T)
          )) ? (d.instance = E, lr(E), E) : (y = p, (E = Ao.get(T)) && (y = h({}, p), JS(y, E)), l = l.ownerDocument || l, E = l.createElement("script"), lr(E), Yr(E, "link", y), l.head.appendChild(E), d.instance = E);
        case "void":
          return null;
        default:
          throw Error(r(443, d.type));
      }
    else
      d.type === "stylesheet" && (d.state.loading & 4) === 0 && (y = d.instance, d.state.loading |= 4, dv(y, p.precedence, l));
    return d.instance;
  }
  function dv(l, d, p) {
    for (var y = p.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), E = y.length ? y[y.length - 1] : null, T = E, j = 0; j < y.length; j++) {
      var V = y[j];
      if (V.dataset.precedence === d) T = V;
      else if (T !== E) break;
    }
    T ? T.parentNode.insertBefore(l, T.nextSibling) : (d = p.nodeType === 9 ? p.head : p, d.insertBefore(l, d.firstChild));
  }
  function XS(l, d) {
    l.crossOrigin == null && (l.crossOrigin = d.crossOrigin), l.referrerPolicy == null && (l.referrerPolicy = d.referrerPolicy), l.title == null && (l.title = d.title);
  }
  function JS(l, d) {
    l.crossOrigin == null && (l.crossOrigin = d.crossOrigin), l.referrerPolicy == null && (l.referrerPolicy = d.referrerPolicy), l.integrity == null && (l.integrity = d.integrity);
  }
  var fv = null;
  function VO(l, d, p) {
    if (fv === null) {
      var y = /* @__PURE__ */ new Map(), E = fv = /* @__PURE__ */ new Map();
      E.set(p, y);
    } else
      E = fv, y = E.get(p), y || (y = /* @__PURE__ */ new Map(), E.set(p, y));
    if (y.has(l)) return y;
    for (y.set(l, null), p = p.getElementsByTagName(l), E = 0; E < p.length; E++) {
      var T = p[E];
      if (!(T[Xi] || T[Nn] || l === "link" && T.getAttribute("rel") === "stylesheet") && T.namespaceURI !== "http://www.w3.org/2000/svg") {
        var j = T.getAttribute(d) || "";
        j = l + j;
        var V = y.get(j);
        V ? V.push(T) : y.set(j, [T]);
      }
    }
    return y;
  }
  function HO(l, d, p) {
    l = l.ownerDocument || l, l.head.insertBefore(
      p,
      d === "title" ? l.querySelector("head > title") : null
    );
  }
  function wK(l, d, p) {
    if (p === 1 || d.itemProp != null) return !1;
    switch (l) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof d.precedence != "string" || typeof d.href != "string" || d.href === "")
          break;
        return !0;
      case "link":
        if (typeof d.rel != "string" || typeof d.href != "string" || d.href === "" || d.onLoad || d.onError)
          break;
        return d.rel === "stylesheet" ? (l = d.disabled, typeof d.precedence == "string" && l == null) : !0;
      case "script":
        if (d.async && typeof d.async != "function" && typeof d.async != "symbol" && !d.onLoad && !d.onError && d.src && typeof d.src == "string")
          return !0;
    }
    return !1;
  }
  function WO(l) {
    return !(l.type === "stylesheet" && (l.state.loading & 3) === 0);
  }
  function SK(l, d, p, y) {
    if (p.type === "stylesheet" && (typeof y.media != "string" || matchMedia(y.media).matches !== !1) && (p.state.loading & 4) === 0) {
      if (p.instance === null) {
        var E = af(y.href), T = d.querySelector(
          Bp(E)
        );
        if (T) {
          d = T._p, d !== null && typeof d == "object" && typeof d.then == "function" && (l.count++, l = hv.bind(l), d.then(l, l)), p.state.loading |= 4, p.instance = T, lr(T);
          return;
        }
        T = d.ownerDocument || d, y = UO(y), (E = Ao.get(E)) && XS(y, E), T = T.createElement("link"), lr(T);
        var j = T;
        j._p = new Promise(function(V, te) {
          j.onload = V, j.onerror = te;
        }), Yr(T, "link", y), p.instance = T;
      }
      l.stylesheets === null && (l.stylesheets = /* @__PURE__ */ new Map()), l.stylesheets.set(p, d), (d = p.state.preload) && (p.state.loading & 3) === 0 && (l.count++, p = hv.bind(l), d.addEventListener("load", p), d.addEventListener("error", p));
    }
  }
  var QS = 0;
  function kK(l, d) {
    return l.stylesheets && l.count === 0 && mv(l, l.stylesheets), 0 < l.count || 0 < l.imgCount ? function(p) {
      var y = setTimeout(function() {
        if (l.stylesheets && mv(l, l.stylesheets), l.unsuspend) {
          var T = l.unsuspend;
          l.unsuspend = null, T();
        }
      }, 6e4 + d);
      0 < l.imgBytes && QS === 0 && (QS = 62500 * rK());
      var E = setTimeout(
        function() {
          if (l.waitingForImages = !1, l.count === 0 && (l.stylesheets && mv(l, l.stylesheets), l.unsuspend)) {
            var T = l.unsuspend;
            l.unsuspend = null, T();
          }
        },
        (l.imgBytes > QS ? 50 : 800) + d
      );
      return l.unsuspend = p, function() {
        l.unsuspend = null, clearTimeout(y), clearTimeout(E);
      };
    } : null;
  }
  function hv() {
    if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
      if (this.stylesheets) mv(this, this.stylesheets);
      else if (this.unsuspend) {
        var l = this.unsuspend;
        this.unsuspend = null, l();
      }
    }
  }
  var pv = null;
  function mv(l, d) {
    l.stylesheets = null, l.unsuspend !== null && (l.count++, pv = /* @__PURE__ */ new Map(), d.forEach(CK, l), pv = null, hv.call(l));
  }
  function CK(l, d) {
    if (!(d.state.loading & 4)) {
      var p = pv.get(l);
      if (p) var y = p.get(null);
      else {
        p = /* @__PURE__ */ new Map(), pv.set(l, p);
        for (var E = l.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), T = 0; T < E.length; T++) {
          var j = E[T];
          (j.nodeName === "LINK" || j.getAttribute("media") !== "not all") && (p.set(j.dataset.precedence, j), y = j);
        }
        y && p.set(null, y);
      }
      E = d.instance, j = E.getAttribute("data-precedence"), T = p.get(j) || y, T === y && p.set(null, E), p.set(j, E), this.count++, y = hv.bind(this), E.addEventListener("load", y), E.addEventListener("error", y), T ? T.parentNode.insertBefore(E, T.nextSibling) : (l = l.nodeType === 9 ? l.head : l, l.insertBefore(E, l.firstChild)), d.state.loading |= 4;
    }
  }
  var Up = {
    $$typeof: M,
    Provider: null,
    Consumer: null,
    _currentValue: X,
    _currentValue2: X,
    _threadCount: 0
  };
  function EK(l, d, p, y, E, T, j, V, te) {
    this.tag = 1, this.containerInfo = l, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = ys(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ys(0), this.hiddenUpdates = ys(null), this.identifierPrefix = y, this.onUncaughtError = E, this.onCaughtError = T, this.onRecoverableError = j, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = te, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function qO(l, d, p, y, E, T, j, V, te, Ee, Oe, Ie) {
    return l = new EK(
      l,
      d,
      p,
      j,
      te,
      Ee,
      Oe,
      Ie,
      V
    ), d = 1, T === !0 && (d |= 24), T = eo(3, null, null, d), l.current = T, T.stateNode = l, d = O1(), d.refCount++, l.pooledCache = d, d.refCount++, T.memoizedState = {
      element: y,
      isDehydrated: p,
      cache: d
    }, I1(T), l;
  }
  function GO(l) {
    return l ? (l = Ld, l) : Ld;
  }
  function KO(l, d, p, y, E, T) {
    E = GO(E), y.context === null ? y.context = E : y.pendingContext = E, y = El(d), y.payload = { element: p }, T = T === void 0 ? null : T, T !== null && (y.callback = T), p = _l(l, y, d), p !== null && (Fi(p, l, d), bp(p, l, d));
  }
  function ZO(l, d) {
    if (l = l.memoizedState, l !== null && l.dehydrated !== null) {
      var p = l.retryLane;
      l.retryLane = p !== 0 && p < d ? p : d;
    }
  }
  function ek(l, d) {
    ZO(l, d), (l = l.alternate) && ZO(l, d);
  }
  function YO(l) {
    if (l.tag === 13 || l.tag === 31) {
      var d = un(l, 67108864);
      d !== null && Fi(d, l, 67108864), ek(l, 67108864);
    }
  }
  function XO(l) {
    if (l.tag === 13 || l.tag === 31) {
      var d = oo();
      d = qh(d);
      var p = un(l, d);
      p !== null && Fi(p, l, d), ek(l, d);
    }
  }
  var gv = !0;
  function _K(l, d, p, y) {
    var E = H.T;
    H.T = null;
    var T = Q.p;
    try {
      Q.p = 2, tk(l, d, p, y);
    } finally {
      Q.p = T, H.T = E;
    }
  }
  function TK(l, d, p, y) {
    var E = H.T;
    H.T = null;
    var T = Q.p;
    try {
      Q.p = 8, tk(l, d, p, y);
    } finally {
      Q.p = T, H.T = E;
    }
  }
  function tk(l, d, p, y) {
    if (gv) {
      var E = nk(y);
      if (E === null)
        US(
          l,
          d,
          y,
          yv,
          p
        ), QO(l, y);
      else if (MK(
        E,
        l,
        d,
        p,
        y
      ))
        y.stopPropagation();
      else if (QO(l, y), d & 4 && -1 < AK.indexOf(l)) {
        for (; E !== null; ) {
          var T = vn(E);
          if (T !== null)
            switch (T.tag) {
              case 3:
                if (T = T.stateNode, T.current.memoizedState.isDehydrated) {
                  var j = Ko(T.pendingLanes);
                  if (j !== 0) {
                    var V = T;
                    for (V.pendingLanes |= 2, V.entangledLanes |= 2; j; ) {
                      var te = 1 << 31 - Ve(j);
                      V.entanglements[1] |= te, j &= ~te;
                    }
                    Ns(T), (ln & 6) === 0 && (Qy = Mn() + 500, jp(0));
                  }
                }
                break;
              case 31:
              case 13:
                V = un(T, 2), V !== null && Fi(V, T, 2), tv(), ek(T, 2);
            }
          if (T = nk(y), T === null && US(
            l,
            d,
            y,
            yv,
            p
          ), T === E) break;
          E = T;
        }
        E !== null && y.stopPropagation();
      } else
        US(
          l,
          d,
          y,
          null,
          p
        );
    }
  }
  function nk(l) {
    return l = wd(l), rk(l);
  }
  var yv = null;
  function rk(l) {
    if (yv = null, l = xs(l), l !== null) {
      var d = o(l);
      if (d === null) l = null;
      else {
        var p = d.tag;
        if (p === 13) {
          if (l = s(d), l !== null) return l;
          l = null;
        } else if (p === 31) {
          if (l = a(d), l !== null) return l;
          l = null;
        } else if (p === 3) {
          if (d.stateNode.current.memoizedState.isDehydrated)
            return d.tag === 3 ? d.stateNode.containerInfo : null;
          l = null;
        } else d !== l && (l = null);
      }
    }
    return yv = l, null;
  }
  function JO(l) {
    switch (l) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (mt()) {
          case ke:
            return 2;
          case Pe:
            return 8;
          case He:
          case et:
            return 32;
          case bt:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var ik = !1, zl = null, Ll = null, Bl = null, Fp = /* @__PURE__ */ new Map(), Vp = /* @__PURE__ */ new Map(), $l = [], AK = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function QO(l, d) {
    switch (l) {
      case "focusin":
      case "focusout":
        zl = null;
        break;
      case "dragenter":
      case "dragleave":
        Ll = null;
        break;
      case "mouseover":
      case "mouseout":
        Bl = null;
        break;
      case "pointerover":
      case "pointerout":
        Fp.delete(d.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Vp.delete(d.pointerId);
    }
  }
  function Hp(l, d, p, y, E, T) {
    return l === null || l.nativeEvent !== T ? (l = {
      blockedOn: d,
      domEventName: p,
      eventSystemFlags: y,
      nativeEvent: T,
      targetContainers: [E]
    }, d !== null && (d = vn(d), d !== null && YO(d)), l) : (l.eventSystemFlags |= y, d = l.targetContainers, E !== null && d.indexOf(E) === -1 && d.push(E), l);
  }
  function MK(l, d, p, y, E) {
    switch (d) {
      case "focusin":
        return zl = Hp(
          zl,
          l,
          d,
          p,
          y,
          E
        ), !0;
      case "dragenter":
        return Ll = Hp(
          Ll,
          l,
          d,
          p,
          y,
          E
        ), !0;
      case "mouseover":
        return Bl = Hp(
          Bl,
          l,
          d,
          p,
          y,
          E
        ), !0;
      case "pointerover":
        var T = E.pointerId;
        return Fp.set(
          T,
          Hp(
            Fp.get(T) || null,
            l,
            d,
            p,
            y,
            E
          )
        ), !0;
      case "gotpointercapture":
        return T = E.pointerId, Vp.set(
          T,
          Hp(
            Vp.get(T) || null,
            l,
            d,
            p,
            y,
            E
          )
        ), !0;
    }
    return !1;
  }
  function eD(l) {
    var d = xs(l.target);
    if (d !== null) {
      var p = o(d);
      if (p !== null) {
        if (d = p.tag, d === 13) {
          if (d = s(p), d !== null) {
            l.blockedOn = d, Zc(l.priority, function() {
              XO(p);
            });
            return;
          }
        } else if (d === 31) {
          if (d = a(p), d !== null) {
            l.blockedOn = d, Zc(l.priority, function() {
              XO(p);
            });
            return;
          }
        } else if (d === 3 && p.stateNode.current.memoizedState.isDehydrated) {
          l.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
          return;
        }
      }
    }
    l.blockedOn = null;
  }
  function vv(l) {
    if (l.blockedOn !== null) return !1;
    for (var d = l.targetContainers; 0 < d.length; ) {
      var p = nk(l.nativeEvent);
      if (p === null) {
        p = l.nativeEvent;
        var y = new p.constructor(
          p.type,
          p
        );
        bo = y, p.target.dispatchEvent(y), bo = null;
      } else
        return d = vn(p), d !== null && YO(d), l.blockedOn = p, !1;
      d.shift();
    }
    return !0;
  }
  function tD(l, d, p) {
    vv(l) && p.delete(d);
  }
  function NK() {
    ik = !1, zl !== null && vv(zl) && (zl = null), Ll !== null && vv(Ll) && (Ll = null), Bl !== null && vv(Bl) && (Bl = null), Fp.forEach(tD), Vp.forEach(tD);
  }
  function bv(l, d) {
    l.blockedOn === d && (l.blockedOn = null, ik || (ik = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      NK
    )));
  }
  var xv = null;
  function nD(l) {
    xv !== l && (xv = l, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        xv === l && (xv = null);
        for (var d = 0; d < l.length; d += 3) {
          var p = l[d], y = l[d + 1], E = l[d + 2];
          if (typeof y != "function") {
            if (rk(y || p) === null)
              continue;
            break;
          }
          var T = vn(p);
          T !== null && (l.splice(d, 3), d -= 3, nS(
            T,
            {
              pending: !0,
              data: E,
              method: p.method,
              action: y
            },
            y,
            E
          ));
        }
      }
    ));
  }
  function cf(l) {
    function d(te) {
      return bv(te, l);
    }
    zl !== null && bv(zl, l), Ll !== null && bv(Ll, l), Bl !== null && bv(Bl, l), Fp.forEach(d), Vp.forEach(d);
    for (var p = 0; p < $l.length; p++) {
      var y = $l[p];
      y.blockedOn === l && (y.blockedOn = null);
    }
    for (; 0 < $l.length && (p = $l[0], p.blockedOn === null); )
      eD(p), p.blockedOn === null && $l.shift();
    if (p = (l.ownerDocument || l).$$reactFormReplay, p != null)
      for (y = 0; y < p.length; y += 3) {
        var E = p[y], T = p[y + 1], j = E[ar] || null;
        if (typeof T == "function")
          j || nD(p);
        else if (j) {
          var V = null;
          if (T && T.hasAttribute("formAction")) {
            if (E = T, j = T[ar] || null)
              V = j.formAction;
            else if (rk(E) !== null) continue;
          } else V = j.action;
          typeof V == "function" ? p[y + 1] = V : (p.splice(y, 3), y -= 3), nD(p);
        }
      }
  }
  function rD() {
    function l(T) {
      T.canIntercept && T.info === "react-transition" && T.intercept({
        handler: function() {
          return new Promise(function(j) {
            return E = j;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function d() {
      E !== null && (E(), E = null), y || setTimeout(p, 20);
    }
    function p() {
      if (!y && !navigation.transition) {
        var T = navigation.currentEntry;
        T && T.url != null && navigation.navigate(T.url, {
          state: T.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if (typeof navigation == "object") {
      var y = !1, E = null;
      return navigation.addEventListener("navigate", l), navigation.addEventListener("navigatesuccess", d), navigation.addEventListener("navigateerror", d), setTimeout(p, 100), function() {
        y = !0, navigation.removeEventListener("navigate", l), navigation.removeEventListener("navigatesuccess", d), navigation.removeEventListener("navigateerror", d), E !== null && (E(), E = null);
      };
    }
  }
  function ok(l) {
    this._internalRoot = l;
  }
  wv.prototype.render = ok.prototype.render = function(l) {
    var d = this._internalRoot;
    if (d === null) throw Error(r(409));
    var p = d.current, y = oo();
    KO(p, y, l, d, null, null);
  }, wv.prototype.unmount = ok.prototype.unmount = function() {
    var l = this._internalRoot;
    if (l !== null) {
      this._internalRoot = null;
      var d = l.containerInfo;
      KO(l.current, 2, null, l, null, null), tv(), d[wi] = null;
    }
  };
  function wv(l) {
    this._internalRoot = l;
  }
  wv.prototype.unstable_scheduleHydration = function(l) {
    if (l) {
      var d = Kc();
      l = { blockedOn: null, target: l, priority: d };
      for (var p = 0; p < $l.length && d !== 0 && d < $l[p].priority; p++) ;
      $l.splice(p, 0, l), p === 0 && eD(l);
    }
  };
  var iD = t.version;
  if (iD !== "19.2.4")
    throw Error(
      r(
        527,
        iD,
        "19.2.4"
      )
    );
  Q.findDOMNode = function(l) {
    var d = l._reactInternals;
    if (d === void 0)
      throw typeof l.render == "function" ? Error(r(188)) : (l = Object.keys(l).join(","), Error(r(268, l)));
    return l = u(d), l = l !== null ? f(l) : null, l = l === null ? null : l.stateNode, l;
  };
  var RK = {
    bundleType: 0,
    version: "19.2.4",
    rendererPackageName: "react-dom",
    currentDispatcherRef: H,
    reconcilerVersion: "19.2.4"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Sv = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Sv.isDisabled && Sv.supportsFiber)
      try {
        Lt = Sv.inject(
          RK
        ), nn = Sv;
      } catch {
      }
  }
  return Wp.createRoot = function(l, d) {
    if (!i(l)) throw Error(r(299));
    var p = !1, y = "", E = d2, T = f2, j = h2;
    return d != null && (d.unstable_strictMode === !0 && (p = !0), d.identifierPrefix !== void 0 && (y = d.identifierPrefix), d.onUncaughtError !== void 0 && (E = d.onUncaughtError), d.onCaughtError !== void 0 && (T = d.onCaughtError), d.onRecoverableError !== void 0 && (j = d.onRecoverableError)), d = qO(
      l,
      1,
      !1,
      null,
      null,
      p,
      y,
      null,
      E,
      T,
      j,
      rD
    ), l[wi] = d.current, $S(l), new ok(d);
  }, Wp.hydrateRoot = function(l, d, p) {
    if (!i(l)) throw Error(r(299));
    var y = !1, E = "", T = d2, j = f2, V = h2, te = null;
    return p != null && (p.unstable_strictMode === !0 && (y = !0), p.identifierPrefix !== void 0 && (E = p.identifierPrefix), p.onUncaughtError !== void 0 && (T = p.onUncaughtError), p.onCaughtError !== void 0 && (j = p.onCaughtError), p.onRecoverableError !== void 0 && (V = p.onRecoverableError), p.formState !== void 0 && (te = p.formState)), d = qO(
      l,
      1,
      !0,
      d,
      p ?? null,
      y,
      E,
      te,
      T,
      j,
      V,
      rD
    ), d.context = GO(null), p = d.current, y = oo(), y = qh(y), E = El(y), E.callback = null, _l(p, E, y), p = y, d.current.lanes = p, yo(d, p), Ns(d), l[wi] = d.current, $S(l), new wv(d);
  }, Wp.version = "19.2.4", Wp;
}
var fD;
function UK() {
  if (fD) return ak.exports;
  fD = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), ak.exports = $K(), ak.exports;
}
var A3 = UK();
const FK = /* @__PURE__ */ Dc(A3);
var dk = { exports: {} }, qp = {};
var hD;
function VK() {
  if (hD) return qp;
  hD = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.fragment");
  function n(r, i, o) {
    var s = null;
    if (o !== void 0 && (s = "" + o), i.key !== void 0 && (s = "" + i.key), "key" in i) {
      o = {};
      for (var a in i)
        a !== "key" && (o[a] = i[a]);
    } else o = i;
    return i = o.ref, {
      $$typeof: e,
      type: r,
      key: s,
      ref: i !== void 0 ? i : null,
      props: o
    };
  }
  return qp.Fragment = t, qp.jsx = n, qp.jsxs = n, qp;
}
var pD;
function HK() {
  return pD || (pD = 1, dk.exports = VK()), dk.exports;
}
var v = HK(), WK = /* @__PURE__ */ Symbol.for("preact-signals");
function FT() {
  if (Hf > 1)
    Hf--;
  else {
    for (var e, t = !1; Sm !== void 0; ) {
      var n = Sm;
      for (Sm = void 0, TE++; n !== void 0; ) {
        var r = n.o;
        if (n.o = void 0, n.f &= -3, !(8 & n.f) && R3(n)) try {
          n.c();
        } catch (i) {
          t || (e = i, t = !0);
        }
        n = r;
      }
    }
    if (TE = 0, Hf--, t) throw e;
  }
}
var dn = void 0;
function M3(e) {
  var t = dn;
  dn = void 0;
  try {
    return e();
  } finally {
    dn = t;
  }
}
var Sm = void 0, Hf = 0, TE = 0, Y0 = 0;
function N3(e) {
  if (dn !== void 0) {
    var t = e.n;
    if (t === void 0 || t.t !== dn)
      return t = { i: 0, S: e, p: dn.s, n: void 0, t: dn, e: void 0, x: void 0, r: t }, dn.s !== void 0 && (dn.s.n = t), dn.s = t, e.n = t, 32 & dn.f && e.S(t), t;
    if (t.i === -1)
      return t.i = 0, t.n !== void 0 && (t.n.p = t.p, t.p !== void 0 && (t.p.n = t.n), t.p = dn.s, t.n = void 0, dn.s.n = t, dn.s = t), t;
  }
}
function yi(e, t) {
  this.v = e, this.i = 0, this.n = void 0, this.t = void 0, this.W = t?.watched, this.Z = t?.unwatched, this.name = t?.name;
}
yi.prototype.brand = WK;
yi.prototype.h = function() {
  return !0;
};
yi.prototype.S = function(e) {
  var t = this, n = this.t;
  n !== e && e.e === void 0 && (e.x = n, this.t = e, n !== void 0 ? n.e = e : M3(function() {
    var r;
    (r = t.W) == null || r.call(t);
  }));
};
yi.prototype.U = function(e) {
  var t = this;
  if (this.t !== void 0) {
    var n = e.e, r = e.x;
    n !== void 0 && (n.x = r, e.e = void 0), r !== void 0 && (r.e = n, e.x = void 0), e === this.t && (this.t = r, r === void 0 && M3(function() {
      var i;
      (i = t.Z) == null || i.call(t);
    }));
  }
};
yi.prototype.subscribe = function(e) {
  var t = this;
  return j3(function() {
    var n = t.value, r = dn;
    dn = void 0;
    try {
      e(n);
    } finally {
      dn = r;
    }
  }, { name: "sub" });
};
yi.prototype.valueOf = function() {
  return this.value;
};
yi.prototype.toString = function() {
  return this.value + "";
};
yi.prototype.toJSON = function() {
  return this.value;
};
yi.prototype.peek = function() {
  var e = dn;
  dn = void 0;
  try {
    return this.value;
  } finally {
    dn = e;
  }
};
Object.defineProperty(yi.prototype, "value", { get: function() {
  var e = N3(this);
  return e !== void 0 && (e.i = this.i), this.v;
}, set: function(e) {
  if (e !== this.v) {
    if (TE > 100) throw new Error("Cycle detected");
    this.v = e, this.i++, Y0++, Hf++;
    try {
      for (var t = this.t; t !== void 0; t = t.x) t.t.N();
    } finally {
      FT();
    }
  }
} });
function mD(e, t) {
  return new yi(e, t);
}
function R3(e) {
  for (var t = e.s; t !== void 0; t = t.n) if (t.S.i !== t.i || !t.S.h() || t.S.i !== t.i) return !0;
  return !1;
}
function O3(e) {
  for (var t = e.s; t !== void 0; t = t.n) {
    var n = t.S.n;
    if (n !== void 0 && (t.r = n), t.S.n = t, t.i = -1, t.n === void 0) {
      e.s = t;
      break;
    }
  }
}
function D3(e) {
  for (var t = e.s, n = void 0; t !== void 0; ) {
    var r = t.p;
    t.i === -1 ? (t.S.U(t), r !== void 0 && (r.n = t.n), t.n !== void 0 && (t.n.p = r)) : n = t, t.S.n = t.r, t.r !== void 0 && (t.r = void 0), t = r;
  }
  e.s = n;
}
function Sh(e, t) {
  yi.call(this, void 0), this.x = e, this.s = void 0, this.g = Y0 - 1, this.f = 4, this.W = t?.watched, this.Z = t?.unwatched, this.name = t?.name;
}
Sh.prototype = new yi();
Sh.prototype.h = function() {
  if (this.f &= -3, 1 & this.f) return !1;
  if ((36 & this.f) == 32 || (this.f &= -5, this.g === Y0)) return !0;
  if (this.g = Y0, this.f |= 1, this.i > 0 && !R3(this))
    return this.f &= -2, !0;
  var e = dn;
  try {
    O3(this), dn = this;
    var t = this.x();
    (16 & this.f || this.v !== t || this.i === 0) && (this.v = t, this.f &= -17, this.i++);
  } catch (n) {
    this.v = n, this.f |= 16, this.i++;
  }
  return dn = e, D3(this), this.f &= -2, !0;
};
Sh.prototype.S = function(e) {
  if (this.t === void 0) {
    this.f |= 36;
    for (var t = this.s; t !== void 0; t = t.n) t.S.S(t);
  }
  yi.prototype.S.call(this, e);
};
Sh.prototype.U = function(e) {
  if (this.t !== void 0 && (yi.prototype.U.call(this, e), this.t === void 0)) {
    this.f &= -33;
    for (var t = this.s; t !== void 0; t = t.n) t.S.U(t);
  }
};
Sh.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var e = this.t; e !== void 0; e = e.x) e.t.N();
  }
};
Object.defineProperty(Sh.prototype, "value", { get: function() {
  if (1 & this.f) throw new Error("Cycle detected");
  var e = N3(this);
  if (this.h(), e !== void 0 && (e.i = this.i), 16 & this.f) throw this.v;
  return this.v;
} });
function P3(e) {
  var t = e.u;
  if (e.u = void 0, typeof t == "function") {
    Hf++;
    var n = dn;
    dn = void 0;
    try {
      t();
    } catch (r) {
      throw e.f &= -2, e.f |= 8, VT(e), r;
    } finally {
      dn = n, FT();
    }
  }
}
function VT(e) {
  for (var t = e.s; t !== void 0; t = t.n) t.S.U(t);
  e.x = void 0, e.s = void 0, P3(e);
}
function qK(e) {
  if (dn !== this) throw new Error("Out-of-order effect");
  D3(this), dn = e, this.f &= -2, 8 & this.f && VT(this), FT();
}
function kh(e, t) {
  this.x = e, this.u = void 0, this.s = void 0, this.o = void 0, this.f = 32, this.name = t?.name;
}
kh.prototype.c = function() {
  var e = this.S();
  try {
    if (8 & this.f || this.x === void 0) return;
    var t = this.x();
    typeof t == "function" && (this.u = t);
  } finally {
    e();
  }
};
kh.prototype.S = function() {
  if (1 & this.f) throw new Error("Cycle detected");
  this.f |= 1, this.f &= -9, P3(this), O3(this), Hf++;
  var e = dn;
  return dn = this, qK.bind(this, e);
};
kh.prototype.N = function() {
  2 & this.f || (this.f |= 2, this.o = Sm, Sm = this);
};
kh.prototype.d = function() {
  this.f |= 8, 1 & this.f || VT(this);
};
kh.prototype.dispose = function() {
  this.d();
};
function j3(e, t) {
  var n = new kh(e, t);
  try {
    n.c();
  } catch (i) {
    throw n.d(), i;
  }
  var r = n.d.bind(n);
  return r[Symbol.dispose] = r, r;
}
var fk = { exports: {} }, hk = {};
var gD;
function GK() {
  if (gD) return hk;
  gD = 1;
  var e = cd();
  function t(h, m) {
    return h === m && (h !== 0 || 1 / h === 1 / m) || h !== h && m !== m;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, s = e.useDebugValue;
  function a(h, m) {
    var g = m(), b = r({ inst: { value: g, getSnapshot: m } }), x = b[0].inst, w = b[1];
    return o(
      function() {
        x.value = g, x.getSnapshot = m, c(x) && w({ inst: x });
      },
      [h, g, m]
    ), i(
      function() {
        return c(x) && w({ inst: x }), h(function() {
          c(x) && w({ inst: x });
        });
      },
      [h]
    ), s(g), g;
  }
  function c(h) {
    var m = h.getSnapshot;
    h = h.value;
    try {
      var g = m();
      return !n(h, g);
    } catch {
      return !0;
    }
  }
  function u(h, m) {
    return m();
  }
  var f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? u : a;
  return hk.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : f, hk;
}
var yD;
function I3() {
  return yD || (yD = 1, fk.exports = GK()), fk.exports;
}
var nh = I3(), KK = C.version.split(".").map(Number)[0], ZK = /* @__PURE__ */ Symbol.for(KK >= 19 ? "react.transitional.element" : "react.element"), YK = typeof window < "u" && !!window.__PREACT_SIGNALS_DEVTOOLS__, Ru, z3 = Symbol.dispose || /* @__PURE__ */ Symbol.for("Symbol.dispose");
function pk(e, t) {
  var n = t.effect.S();
  return Ru = t, XK.bind(t, e, n);
}
function XK(e, t) {
  t(), Ru = e;
}
var vD, AE, bD = function() {
}, JK = ((vD = { o: 0, effect: { s: void 0, c: function() {
}, S: function() {
  return bD;
}, d: function() {
} }, subscribe: function() {
  return bD;
}, getSnapshot: function() {
  return 0;
}, S: function() {
}, f: function() {
} })[z3] = function() {
}, vD), QK = Promise.prototype.then.bind(Promise.resolve());
function eZ() {
  AE || (AE = QK(L3));
}
function L3() {
  var e;
  AE = void 0, (e = Ru) == null || e.f();
}
var tZ = typeof window < "u" ? C.useLayoutEffect : C.useEffect;
function B3(e, t) {
  e === void 0 && (e = 0), eZ();
  var n = C.useRef();
  n.current == null && (typeof window > "u" ? n.current = JK : n.current = (function(i, o) {
    var s, a, c, u, f = 0, h = j3(function() {
      a = this;
    }, { name: "Component" });
    return a.c = function() {
      if (f = f + 1 | 0, YK) {
        var m;
        (m = a.y) == null || m.call(a);
      }
      u && u();
    }, (s = { o: i, effect: a, subscribe: function(m) {
      return u = m, function() {
        f = f + 1 | 0, u = void 0, h();
      };
    }, getSnapshot: function() {
      return f;
    }, S: function() {
      if (Ru != null) {
        var m = Ru.o, g = this.o;
        m == 0 && g == 0 || m == 0 && g == 1 ? (Ru.f(), c = pk(void 0, this)) : m == 1 && g == 0 || m == 2 && g == 0 || (c = pk(Ru, this));
      } else c = pk(void 0, this);
    }, f: function() {
      var m = c;
      c = void 0, m?.();
    } })[z3] = function() {
      this.f();
    }, s;
  })(e));
  var r = n.current;
  return nh.useSyncExternalStore(r.subscribe, r.getSnapshot, r.getSnapshot), r.S(), e === 0 && tZ(L3), r;
}
Object.defineProperties(yi.prototype, { $$typeof: { configurable: !0, value: ZK }, type: { configurable: !0, value: function(e) {
  var t = e.data, n = B3(1);
  try {
    return t.value;
  } finally {
    n.f();
  }
} }, props: { configurable: !0, get: function() {
  return { data: this };
} }, ref: { configurable: !0, value: null } });
function $3(e, t) {
  return B3(e);
}
const U3 = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim();
const nZ = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const rZ = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, r) => r ? r.toUpperCase() : n.toLowerCase()
);
const xD = (e) => {
  const t = rZ(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
};
var iZ = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
const oZ = (e) => {
  for (const t in e)
    if (t.startsWith("aria-") || t === "role" || t === "title")
      return !0;
  return !1;
};
const sZ = C.forwardRef(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: i = "",
    children: o,
    iconNode: s,
    ...a
  }, c) => C.createElement(
    "svg",
    {
      ref: c,
      ...iZ,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: r ? Number(n) * 24 / Number(t) : n,
      className: U3("lucide", i),
      ...!o && !oZ(a) && { "aria-hidden": "true" },
      ...a
    },
    [
      ...s.map(([u, f]) => C.createElement(u, f)),
      ...Array.isArray(o) ? o : [o]
    ]
  )
);
const ut = (e, t) => {
  const n = C.forwardRef(
    ({ className: r, ...i }, o) => C.createElement(sZ, {
      ref: o,
      iconNode: t,
      className: U3(
        `lucide-${nZ(xD(e))}`,
        `lucide-${e}`,
        r
      ),
      ...i
    })
  );
  return n.displayName = xD(e), n;
};
const aZ = [
  ["path", { d: "m3 16 4 4 4-4", key: "1co6wj" }],
  ["path", { d: "M7 20V4", key: "1yoxec" }],
  ["path", { d: "m21 8-4-4-4 4", key: "1c9v7m" }],
  ["path", { d: "M17 4v16", key: "7dpous" }]
], lZ = ut("arrow-down-up", aZ);
const cZ = [
  ["path", { d: "M7 7h10v10", key: "1tivn9" }],
  ["path", { d: "M7 17 17 7", key: "1vkiza" }]
], uZ = ut("arrow-up-right", cZ);
const dZ = [
  ["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }],
  ["path", { d: "M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8", key: "7n84p3" }]
], F3 = ut("at-sign", dZ);
const fZ = [
  [
    "path",
    {
      d: "M17 3a2 2 0 0 1 2 2v15a1 1 0 0 1-1.496.868l-4.512-2.578a2 2 0 0 0-1.984 0l-4.512 2.578A1 1 0 0 1 5 20V5a2 2 0 0 1 2-2z",
      key: "oz39mx"
    }
  ],
  ["path", { d: "m9 10 2 2 4-4", key: "1gnqz4" }]
], hZ = ut("bookmark-check", fZ);
const pZ = [
  [
    "path",
    {
      d: "M17 3a2 2 0 0 1 2 2v15a1 1 0 0 1-1.496.868l-4.512-2.578a2 2 0 0 0-1.984 0l-4.512 2.578A1 1 0 0 1 5 20V5a2 2 0 0 1 2-2z",
      key: "oz39mx"
    }
  ]
], V3 = ut("bookmark", pZ);
const mZ = [
  ["path", { d: "M12 6V2H8", key: "1155em" }],
  ["path", { d: "M15 11v2", key: "i11awn" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "M20 12h2", key: "1q8mjw" }],
  [
    "path",
    {
      d: "M20 16a2 2 0 0 1-2 2H8.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 4 20.286V8a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2z",
      key: "11gyqh"
    }
  ],
  ["path", { d: "M9 11v2", key: "1ueba0" }]
], HT = ut("bot-message-square", mZ);
const gZ = [
  ["path", { d: "M12 8V4H8", key: "hb8ula" }],
  ["rect", { width: "16", height: "12", x: "4", y: "8", rx: "2", key: "enze0r" }],
  ["path", { d: "M2 14h2", key: "vft8re" }],
  ["path", { d: "M20 14h2", key: "4cs60a" }],
  ["path", { d: "M15 13v2", key: "1xurst" }],
  ["path", { d: "M9 13v2", key: "rq6x2g" }]
], yZ = ut("bot", gZ);
const vZ = [
  [
    "path",
    {
      d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",
      key: "hh9hay"
    }
  ],
  ["path", { d: "m3.3 7 8.7 5 8.7-5", key: "g66t2b" }],
  ["path", { d: "M12 22V12", key: "d0xqtd" }]
], bZ = ut("box", vZ);
const xZ = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], wc = ut("check", xZ);
const wZ = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], Mg = ut("chevron-down", wZ);
const SZ = [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]], kZ = ut("chevron-left", SZ);
const CZ = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]], Ng = ut("chevron-right", CZ);
const EZ = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], _Z = ut("chevron-up", EZ);
const TZ = [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
], AZ = ut("circle-check-big", TZ);
const MZ = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "10", x2: "10", y1: "15", y2: "9", key: "c1nkhi" }],
  ["line", { x1: "14", x2: "14", y1: "15", y2: "9", key: "h65svq" }]
], NZ = ut("circle-pause", MZ);
const RZ = [
  ["path", { d: "M12 13v8", key: "1l5pq0" }],
  ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242", key: "1pljnt" }],
  ["path", { d: "m8 17 4-4 4 4", key: "1quai1" }]
], OZ = ut("cloud-upload", RZ);
const DZ = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
], Sc = ut("copy", DZ);
const PZ = [
  ["path", { d: "M12 15V3", key: "m9g1x1" }],
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["path", { d: "m7 10 5 5 5-5", key: "brsn70" }]
], ME = ut("download", PZ);
const jZ = [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }],
  ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }]
], IZ = ut("ellipsis-vertical", jZ);
const zZ = [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
], LZ = ut("external-link", zZ);
const BZ = [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], WT = ut("eye", BZ);
const $Z = [
  [
    "path",
    { d: "M12 6a2 2 0 0 1 3.414-1.414l6 6a2 2 0 0 1 0 2.828l-6 6A2 2 0 0 1 12 18z", key: "b19h5q" }
  ],
  [
    "path",
    { d: "M2 6a2 2 0 0 1 3.414-1.414l6 6a2 2 0 0 1 0 2.828l-6 6A2 2 0 0 1 2 18z", key: "h7h5ge" }
  ]
], UZ = ut("fast-forward", $Z);
const FZ = [
  [
    "path",
    {
      d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",
      key: "1oefj6"
    }
  ],
  ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }],
  ["path", { d: "M8 13h2", key: "yr2amv" }],
  ["path", { d: "M14 13h2", key: "un5t4a" }],
  ["path", { d: "M8 17h2", key: "2yhykz" }],
  ["path", { d: "M14 17h2", key: "10kma7" }]
], VZ = ut("file-spreadsheet", FZ);
const HZ = [
  [
    "path",
    {
      d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",
      key: "1oefj6"
    }
  ],
  ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
], WZ = ut("file-text", HZ);
const qZ = [
  [
    "path",
    {
      d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",
      key: "1oefj6"
    }
  ],
  ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }]
], GZ = ut("file", qZ);
const KZ = [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
], ZZ = ut("grip-vertical", KZ);
const YZ = [
  ["line", { x1: "4", x2: "20", y1: "9", y2: "9", key: "4lhtct" }],
  ["line", { x1: "4", x2: "20", y1: "15", y2: "15", key: "vyu0kd" }],
  ["line", { x1: "10", x2: "8", y1: "3", y2: "21", key: "1ggp8o" }],
  ["line", { x1: "16", x2: "14", y1: "3", y2: "21", key: "weycgp" }]
], XZ = ut("hash", YZ);
const JZ = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
], QZ = ut("image", JZ);
const eY = [
  [
    "path",
    {
      d: "M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5",
      key: "1gvzjb"
    }
  ],
  ["path", { d: "M9 18h6", key: "x1upvd" }],
  ["path", { d: "M10 22h4", key: "ceow96" }]
], tY = ut("lightbulb", eY);
const nY = [
  ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }],
  ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]
], rY = ut("link", nY);
const iY = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]], Zs = ut("loader-circle", iY);
const oY = [
  ["path", { d: "M12 2v4", key: "3427ic" }],
  ["path", { d: "m16.2 7.8 2.9-2.9", key: "r700ao" }],
  ["path", { d: "M18 12h4", key: "wj9ykh" }],
  ["path", { d: "m16.2 16.2 2.9 2.9", key: "1bxg5t" }],
  ["path", { d: "M12 18v4", key: "jadmvz" }],
  ["path", { d: "m4.9 19.1 2.9-2.9", key: "bwix9q" }],
  ["path", { d: "M2 12h4", key: "j09sii" }],
  ["path", { d: "m4.9 4.9 2.9 2.9", key: "giyufr" }]
], qT = ut("loader", oY);
const sY = [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "m21 3-7 7", key: "1l2asr" }],
  ["path", { d: "m3 21 7-7", key: "tjx5ai" }],
  ["path", { d: "M9 21H3v-6", key: "wtvkvv" }]
], wD = ut("maximize-2", sY);
const aY = [
  ["path", { d: "M4 5h16", key: "1tepv9" }],
  ["path", { d: "M4 12h16", key: "1lakjw" }],
  ["path", { d: "M4 19h16", key: "1djgab" }]
], lY = ut("menu", aY);
const cY = [
  [
    "path",
    {
      d: "M2.992 16.342a2 2 0 0 1 .094 1.167l-1.065 3.29a1 1 0 0 0 1.236 1.168l3.413-.998a2 2 0 0 1 1.099.092 10 10 0 1 0-4.777-4.719",
      key: "1sd12s"
    }
  ]
], uY = ut("message-circle", cY);
const dY = [
  [
    "path",
    {
      d: "M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z",
      key: "18887p"
    }
  ],
  ["path", { d: "M7 11h10", key: "1twpyw" }],
  ["path", { d: "M7 15h6", key: "d9of3u" }],
  ["path", { d: "M7 7h8", key: "af5zfr" }]
], fY = ut("message-square-text", dY);
const hY = [
  [
    "path",
    {
      d: "M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z",
      key: "18887p"
    }
  ]
], SD = ut("message-square", hY);
const pY = [
  ["path", { d: "M12 19v3", key: "npa21l" }],
  ["path", { d: "M15 9.34V5a3 3 0 0 0-5.68-1.33", key: "1gzdoj" }],
  ["path", { d: "M16.95 16.95A7 7 0 0 1 5 12v-2", key: "cqa7eg" }],
  ["path", { d: "M18.89 13.23A7 7 0 0 0 19 12v-2", key: "16hl24" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }],
  ["path", { d: "M9 9v3a3 3 0 0 0 5.12 2.12", key: "r2i35w" }]
], mY = ut("mic-off", pY);
const gY = [
  ["path", { d: "M12 19v3", key: "npa21l" }],
  ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
  ["rect", { x: "9", y: "2", width: "6", height: "13", rx: "3", key: "s6n7sd" }]
], yY = ut("mic", gY);
const vY = [
  ["path", { d: "m14 10 7-7", key: "oa77jy" }],
  ["path", { d: "M20 10h-6V4", key: "mjg0md" }],
  ["path", { d: "m3 21 7-7", key: "tjx5ai" }],
  ["path", { d: "M4 14h6v6", key: "rmj7iw" }]
], kD = ut("minimize-2", vY);
const bY = [
  ["rect", { x: "14", y: "3", width: "5", height: "18", rx: "1", key: "kaeet6" }],
  ["rect", { x: "5", y: "3", width: "5", height: "18", rx: "1", key: "1wsw3u" }]
], xY = ut("pause", bY);
const wY = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
], SY = ut("plus", wY);
const kY = [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
], CY = ut("refresh-cw", kY);
const EY = [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
], GT = ut("rotate-ccw", EY);
const _Y = [
  ["path", { d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8", key: "1p45f6" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }]
], TY = ut("rotate-cw", _Y);
const AY = [
  ["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }],
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]
], MY = ut("search", AY);
const NY = [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
], RY = ut("send", NY);
const OY = [
  ["rect", { width: "20", height: "8", x: "2", y: "2", rx: "2", ry: "2", key: "ngkwjq" }],
  ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2", ry: "2", key: "iecqi9" }],
  ["line", { x1: "6", x2: "6.01", y1: "6", y2: "6", key: "16zg32" }],
  ["line", { x1: "6", x2: "6.01", y1: "18", y2: "18", key: "nzw8ys" }]
], CD = ut("server", OY);
const DY = [
  [
    "path",
    {
      d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
      key: "1i5ecw"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], H3 = ut("settings", DY);
const PY = [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ],
  ["path", { d: "M12 8v4", key: "1got3b" }],
  ["path", { d: "M12 16h.01", key: "1drbdi" }]
], X0 = ut("shield-alert", PY);
const jY = [
  ["circle", { cx: "8", cy: "21", r: "1", key: "jimo8o" }],
  ["circle", { cx: "19", cy: "21", r: "1", key: "13723u" }],
  [
    "path",
    {
      d: "M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",
      key: "9zh506"
    }
  ]
], IY = ut("shopping-cart", jY);
const zY = [
  [
    "path",
    {
      d: "M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z",
      key: "1s2grr"
    }
  ],
  ["path", { d: "M20 2v4", key: "1rf3ol" }],
  ["path", { d: "M22 4h-4", key: "gwowj6" }],
  ["circle", { cx: "4", cy: "20", r: "2", key: "6kqj1y" }]
], LY = ut("sparkles", zY);
const BY = [
  ["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }],
  [
    "path",
    {
      d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
      key: "ohrbg2"
    }
  ]
], $Y = ut("square-pen", BY);
const UY = [
  ["path", { d: "M15 21v-5a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v5", key: "slp6dd" }],
  [
    "path",
    {
      d: "M17.774 10.31a1.12 1.12 0 0 0-1.549 0 2.5 2.5 0 0 1-3.451 0 1.12 1.12 0 0 0-1.548 0 2.5 2.5 0 0 1-3.452 0 1.12 1.12 0 0 0-1.549 0 2.5 2.5 0 0 1-3.77-3.248l2.889-4.184A2 2 0 0 1 7 2h10a2 2 0 0 1 1.653.873l2.895 4.192a2.5 2.5 0 0 1-3.774 3.244",
      key: "o0xfot"
    }
  ],
  ["path", { d: "M4 10.95V19a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8.05", key: "wn3emo" }]
], FY = ut("store", UY);
const VY = [
  ["polyline", { points: "14.5 17.5 3 6 3 3 6 3 17.5 14.5", key: "1hfsw2" }],
  ["line", { x1: "13", x2: "19", y1: "19", y2: "13", key: "1vrmhu" }],
  ["line", { x1: "16", x2: "20", y1: "16", y2: "20", key: "1bron3" }],
  ["line", { x1: "19", x2: "21", y1: "21", y2: "19", key: "13pww6" }],
  ["polyline", { points: "14.5 6.5 18 3 21 3 21 6 17.5 9.5", key: "hbey2j" }],
  ["line", { x1: "5", x2: "9", y1: "14", y2: "18", key: "1hf58s" }],
  ["line", { x1: "7", x2: "4", y1: "17", y2: "20", key: "pidxm4" }],
  ["line", { x1: "3", x2: "5", y1: "19", y2: "21", key: "1pehsh" }]
], HY = ut("swords", VY);
const WY = [
  ["path", { d: "M10 11v6", key: "nco0om" }],
  ["path", { d: "M14 11v6", key: "outv1u" }],
  ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6", key: "miytrc" }],
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2", key: "e791ji" }]
], W3 = ut("trash-2", WY);
const qY = [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
], GY = ut("triangle-alert", qY);
const KY = [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["path", { d: "M16 3.128a4 4 0 0 1 0 7.744", key: "16gr8j" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
], ZY = ut("users", KY);
const YY = [
  ["rect", { width: "8", height: "8", x: "3", y: "3", rx: "2", key: "by2w9f" }],
  ["path", { d: "M7 11v4a2 2 0 0 0 2 2h4", key: "xkn7yn" }],
  ["rect", { width: "8", height: "8", x: "13", y: "13", rx: "2", key: "1cgmvn" }]
], XY = ut("workflow", YY);
const JY = [
  [
    "path",
    {
      d: "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.106-3.105c.32-.322.863-.22.983.218a6 6 0 0 1-8.259 7.057l-7.91 7.91a1 1 0 0 1-2.999-3l7.91-7.91a6 6 0 0 1 7.057-8.259c.438.12.54.662.219.984z",
      key: "1ngwbx"
    }
  ]
], J0 = ut("wrench", JY);
const QY = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
], Rg = ut("x", QY);
var tl = Vx();
const q3 = /* @__PURE__ */ Dc(tl);
function ED(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function Og(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const o = ED(i, t);
      return !n && typeof o == "function" && (n = !0), o;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const o = r[i];
          typeof o == "function" ? o() : ED(e[i], null);
        }
      };
  };
}
function Ft(...e) {
  return C.useCallback(Og(...e), e);
}
// @__NO_SIDE_EFFECTS__
function rh(e) {
  const t = /* @__PURE__ */ eX(e), n = C.forwardRef((r, i) => {
    const { children: o, ...s } = r, a = C.Children.toArray(o), c = a.find(nX);
    if (c) {
      const u = c.props.children, f = a.map((h) => h === c ? C.Children.count(u) > 1 ? C.Children.only(null) : C.isValidElement(u) ? u.props.children : null : h);
      return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: C.isValidElement(u) ? C.cloneElement(u, void 0, f) : null });
    }
    return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: o });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function eX(e) {
  const t = C.forwardRef((n, r) => {
    const { children: i, ...o } = n;
    if (C.isValidElement(i)) {
      const s = iX(i), a = rX(o, i.props);
      return i.type !== C.Fragment && (a.ref = r ? Og(r, s) : s), C.cloneElement(i, a);
    }
    return C.Children.count(i) > 1 ? C.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var G3 = /* @__PURE__ */ Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function tX(e) {
  const t = ({ children: n }) => /* @__PURE__ */ v.jsx(v.Fragment, { children: n });
  return t.displayName = `${e}.Slottable`, t.__radixId = G3, t;
}
function nX(e) {
  return C.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === G3;
}
function rX(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...a) => {
      const c = o(...a);
      return i(...a), c;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function iX(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var oX = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Et = oX.reduce((e, t) => {
  const n = /* @__PURE__ */ rh(`Primitive.${t}`), r = C.forwardRef((i, o) => {
    const { asChild: s, ...a } = i, c = s ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ v.jsx(c, { ...a, ref: o });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function K3(e, t) {
  e && tl.flushSync(() => e.dispatchEvent(t));
}
var Er = globalThis?.document ? C.useLayoutEffect : () => {
};
function sX(e, t) {
  return C.useReducer((n, r) => t[n][r] ?? n, e);
}
var Di = (e) => {
  const { present: t, children: n } = e, r = aX(t), i = typeof n == "function" ? n({ present: r.isPresent }) : C.Children.only(n), o = Ft(r.ref, lX(i));
  return typeof n == "function" || r.isPresent ? C.cloneElement(i, { ref: o }) : null;
};
Di.displayName = "Presence";
function aX(e) {
  const [t, n] = C.useState(), r = C.useRef(null), i = C.useRef(e), o = C.useRef("none"), s = e ? "mounted" : "unmounted", [a, c] = sX(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return C.useEffect(() => {
    const u = kv(r.current);
    o.current = a === "mounted" ? u : "none";
  }, [a]), Er(() => {
    const u = r.current, f = i.current;
    if (f !== e) {
      const m = o.current, g = kv(u);
      e ? c("MOUNT") : g === "none" || u?.display === "none" ? c("UNMOUNT") : c(f && m !== g ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, c]), Er(() => {
    if (t) {
      let u;
      const f = t.ownerDocument.defaultView ?? window, h = (g) => {
        const x = kv(r.current).includes(CSS.escape(g.animationName));
        if (g.target === t && x && (c("ANIMATION_END"), !i.current)) {
          const w = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", u = f.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = w);
          });
        }
      }, m = (g) => {
        g.target === t && (o.current = kv(r.current));
      };
      return t.addEventListener("animationstart", m), t.addEventListener("animationcancel", h), t.addEventListener("animationend", h), () => {
        f.clearTimeout(u), t.removeEventListener("animationstart", m), t.removeEventListener("animationcancel", h), t.removeEventListener("animationend", h);
      };
    } else
      c("ANIMATION_END");
  }, [t, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: C.useCallback((u) => {
      r.current = u ? getComputedStyle(u) : null, n(u);
    }, [])
  };
}
function kv(e) {
  return e?.animationName || "none";
}
function lX(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function cX(e, t) {
  const n = C.createContext(t), r = (o) => {
    const { children: s, ...a } = o, c = C.useMemo(() => a, Object.values(a));
    return /* @__PURE__ */ v.jsx(n.Provider, { value: c, children: s });
  };
  r.displayName = e + "Provider";
  function i(o) {
    const s = C.useContext(n);
    if (s) return s;
    if (t !== void 0) return t;
    throw new Error(`\`${o}\` must be used within \`${e}\``);
  }
  return [r, i];
}
function ps(e, t = []) {
  let n = [];
  function r(o, s) {
    const a = C.createContext(s), c = n.length;
    n = [...n, s];
    const u = (h) => {
      const { scope: m, children: g, ...b } = h, x = m?.[e]?.[c] || a, w = C.useMemo(() => b, Object.values(b));
      return /* @__PURE__ */ v.jsx(x.Provider, { value: w, children: g });
    };
    u.displayName = o + "Provider";
    function f(h, m) {
      const g = m?.[e]?.[c] || a, b = C.useContext(g);
      if (b) return b;
      if (s !== void 0) return s;
      throw new Error(`\`${h}\` must be used within \`${o}\``);
    }
    return [u, f];
  }
  const i = () => {
    const o = n.map((s) => C.createContext(s));
    return function(a) {
      const c = a?.[e] || o;
      return C.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: c } }),
        [a, c]
      );
    };
  };
  return i.scopeName = e, [r, uX(i, ...t)];
}
function uX(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(o) {
      const s = r.reduce((a, { useScope: c, scopeName: u }) => {
        const h = c(o)[`__scope${u}`];
        return { ...a, ...h };
      }, {});
      return C.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Dr(e) {
  const t = C.useRef(e);
  return C.useEffect(() => {
    t.current = e;
  }), C.useMemo(() => (...n) => t.current?.(...n), []);
}
var dX = C.createContext(void 0);
function Hx(e) {
  const t = C.useContext(dX);
  return e || t || "ltr";
}
function NE(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function Ye(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e?.(i), n === !1 || !i.defaultPrevented)
      return t?.(i);
  };
}
function fX(e, t) {
  return C.useReducer((n, r) => t[n][r] ?? n, e);
}
var KT = "ScrollArea", [Z3] = ps(KT), [hX, qo] = Z3(KT), Y3 = C.forwardRef(
  (e, t) => {
    const {
      __scopeScrollArea: n,
      type: r = "hover",
      dir: i,
      scrollHideDelay: o = 600,
      ...s
    } = e, [a, c] = C.useState(null), [u, f] = C.useState(null), [h, m] = C.useState(null), [g, b] = C.useState(null), [x, w] = C.useState(null), [S, _] = C.useState(0), [M, N] = C.useState(0), [P, I] = C.useState(!1), [O, L] = C.useState(!1), U = Ft(t, (G) => c(G)), B = Hx(i);
    return /* @__PURE__ */ v.jsx(
      hX,
      {
        scope: n,
        type: r,
        dir: B,
        scrollHideDelay: o,
        scrollArea: a,
        viewport: u,
        onViewportChange: f,
        content: h,
        onContentChange: m,
        scrollbarX: g,
        onScrollbarXChange: b,
        scrollbarXEnabled: P,
        onScrollbarXEnabledChange: I,
        scrollbarY: x,
        onScrollbarYChange: w,
        scrollbarYEnabled: O,
        onScrollbarYEnabledChange: L,
        onCornerWidthChange: _,
        onCornerHeightChange: N,
        children: /* @__PURE__ */ v.jsx(
          Et.div,
          {
            dir: B,
            ...s,
            ref: U,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": S + "px",
              "--radix-scroll-area-corner-height": M + "px",
              ...e.style
            }
          }
        )
      }
    );
  }
);
Y3.displayName = KT;
var X3 = "ScrollAreaViewport", J3 = C.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, children: r, nonce: i, ...o } = e, s = qo(X3, n), a = C.useRef(null), c = Ft(t, a, s.onViewportChange);
    return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: i
        }
      ),
      /* @__PURE__ */ v.jsx(
        Et.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...o,
          ref: c,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: s.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: s.scrollbarYEnabled ? "scroll" : "hidden",
            ...e.style
          },
          children: /* @__PURE__ */ v.jsx("div", { ref: s.onContentChange, style: { minWidth: "100%", display: "table" }, children: r })
        }
      )
    ] });
  }
);
J3.displayName = X3;
var ta = "ScrollAreaScrollbar", Q3 = C.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, i = qo(ta, e.__scopeScrollArea), { onScrollbarXEnabledChange: o, onScrollbarYEnabledChange: s } = i, a = e.orientation === "horizontal";
    return C.useEffect(() => (a ? o(!0) : s(!0), () => {
      a ? o(!1) : s(!1);
    }), [a, o, s]), i.type === "hover" ? /* @__PURE__ */ v.jsx(pX, { ...r, ref: t, forceMount: n }) : i.type === "scroll" ? /* @__PURE__ */ v.jsx(mX, { ...r, ref: t, forceMount: n }) : i.type === "auto" ? /* @__PURE__ */ v.jsx(e4, { ...r, ref: t, forceMount: n }) : i.type === "always" ? /* @__PURE__ */ v.jsx(ZT, { ...r, ref: t }) : null;
  }
);
Q3.displayName = ta;
var pX = C.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, i = qo(ta, e.__scopeScrollArea), [o, s] = C.useState(!1);
  return C.useEffect(() => {
    const a = i.scrollArea;
    let c = 0;
    if (a) {
      const u = () => {
        window.clearTimeout(c), s(!0);
      }, f = () => {
        c = window.setTimeout(() => s(!1), i.scrollHideDelay);
      };
      return a.addEventListener("pointerenter", u), a.addEventListener("pointerleave", f), () => {
        window.clearTimeout(c), a.removeEventListener("pointerenter", u), a.removeEventListener("pointerleave", f);
      };
    }
  }, [i.scrollArea, i.scrollHideDelay]), /* @__PURE__ */ v.jsx(Di, { present: n || o, children: /* @__PURE__ */ v.jsx(
    e4,
    {
      "data-state": o ? "visible" : "hidden",
      ...r,
      ref: t
    }
  ) });
}), mX = C.forwardRef((e, t) => {
  const { forceMount: n, ...r } = e, i = qo(ta, e.__scopeScrollArea), o = e.orientation === "horizontal", s = qx(() => c("SCROLL_END"), 100), [a, c] = fX("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return C.useEffect(() => {
    if (a === "idle") {
      const u = window.setTimeout(() => c("HIDE"), i.scrollHideDelay);
      return () => window.clearTimeout(u);
    }
  }, [a, i.scrollHideDelay, c]), C.useEffect(() => {
    const u = i.viewport, f = o ? "scrollLeft" : "scrollTop";
    if (u) {
      let h = u[f];
      const m = () => {
        const g = u[f];
        h !== g && (c("SCROLL"), s()), h = g;
      };
      return u.addEventListener("scroll", m), () => u.removeEventListener("scroll", m);
    }
  }, [i.viewport, o, c, s]), /* @__PURE__ */ v.jsx(Di, { present: n || a !== "hidden", children: /* @__PURE__ */ v.jsx(
    ZT,
    {
      "data-state": a === "hidden" ? "hidden" : "visible",
      ...r,
      ref: t,
      onPointerEnter: Ye(e.onPointerEnter, () => c("POINTER_ENTER")),
      onPointerLeave: Ye(e.onPointerLeave, () => c("POINTER_LEAVE"))
    }
  ) });
}), e4 = C.forwardRef((e, t) => {
  const n = qo(ta, e.__scopeScrollArea), { forceMount: r, ...i } = e, [o, s] = C.useState(!1), a = e.orientation === "horizontal", c = qx(() => {
    if (n.viewport) {
      const u = n.viewport.offsetWidth < n.viewport.scrollWidth, f = n.viewport.offsetHeight < n.viewport.scrollHeight;
      s(a ? u : f);
    }
  }, 10);
  return ih(n.viewport, c), ih(n.content, c), /* @__PURE__ */ v.jsx(Di, { present: r || o, children: /* @__PURE__ */ v.jsx(
    ZT,
    {
      "data-state": o ? "visible" : "hidden",
      ...i,
      ref: t
    }
  ) });
}), ZT = C.forwardRef((e, t) => {
  const { orientation: n = "vertical", ...r } = e, i = qo(ta, e.__scopeScrollArea), o = C.useRef(null), s = C.useRef(0), [a, c] = C.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), u = o4(a.viewport, a.content), f = {
    ...r,
    sizes: a,
    onSizesChange: c,
    hasThumb: u > 0 && u < 1,
    onThumbChange: (m) => o.current = m,
    onThumbPointerUp: () => s.current = 0,
    onThumbPointerDown: (m) => s.current = m
  };
  function h(m, g) {
    return wX(m, s.current, a, g);
  }
  return n === "horizontal" ? /* @__PURE__ */ v.jsx(
    gX,
    {
      ...f,
      ref: t,
      onThumbPositionChange: () => {
        if (i.viewport && o.current) {
          const m = i.viewport.scrollLeft, g = _D(m, a, i.dir);
          o.current.style.transform = `translate3d(${g}px, 0, 0)`;
        }
      },
      onWheelScroll: (m) => {
        i.viewport && (i.viewport.scrollLeft = m);
      },
      onDragScroll: (m) => {
        i.viewport && (i.viewport.scrollLeft = h(m, i.dir));
      }
    }
  ) : n === "vertical" ? /* @__PURE__ */ v.jsx(
    yX,
    {
      ...f,
      ref: t,
      onThumbPositionChange: () => {
        if (i.viewport && o.current) {
          const m = i.viewport.scrollTop, g = _D(m, a);
          o.current.style.transform = `translate3d(0, ${g}px, 0)`;
        }
      },
      onWheelScroll: (m) => {
        i.viewport && (i.viewport.scrollTop = m);
      },
      onDragScroll: (m) => {
        i.viewport && (i.viewport.scrollTop = h(m));
      }
    }
  ) : null;
}), gX = C.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: r, ...i } = e, o = qo(ta, e.__scopeScrollArea), [s, a] = C.useState(), c = C.useRef(null), u = Ft(t, c, o.onScrollbarXChange);
  return C.useEffect(() => {
    c.current && a(getComputedStyle(c.current));
  }, [c]), /* @__PURE__ */ v.jsx(
    n4,
    {
      "data-orientation": "horizontal",
      ...i,
      ref: u,
      sizes: n,
      style: {
        bottom: 0,
        left: o.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: o.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": Wx(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (f) => e.onThumbPointerDown(f.x),
      onDragScroll: (f) => e.onDragScroll(f.x),
      onWheelScroll: (f, h) => {
        if (o.viewport) {
          const m = o.viewport.scrollLeft + f.deltaX;
          e.onWheelScroll(m), a4(m, h) && f.preventDefault();
        }
      },
      onResize: () => {
        c.current && o.viewport && s && r({
          content: o.viewport.scrollWidth,
          viewport: o.viewport.offsetWidth,
          scrollbar: {
            size: c.current.clientWidth,
            paddingStart: eb(s.paddingLeft),
            paddingEnd: eb(s.paddingRight)
          }
        });
      }
    }
  );
}), yX = C.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: r, ...i } = e, o = qo(ta, e.__scopeScrollArea), [s, a] = C.useState(), c = C.useRef(null), u = Ft(t, c, o.onScrollbarYChange);
  return C.useEffect(() => {
    c.current && a(getComputedStyle(c.current));
  }, [c]), /* @__PURE__ */ v.jsx(
    n4,
    {
      "data-orientation": "vertical",
      ...i,
      ref: u,
      sizes: n,
      style: {
        top: 0,
        right: o.dir === "ltr" ? 0 : void 0,
        left: o.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": Wx(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (f) => e.onThumbPointerDown(f.y),
      onDragScroll: (f) => e.onDragScroll(f.y),
      onWheelScroll: (f, h) => {
        if (o.viewport) {
          const m = o.viewport.scrollTop + f.deltaY;
          e.onWheelScroll(m), a4(m, h) && f.preventDefault();
        }
      },
      onResize: () => {
        c.current && o.viewport && s && r({
          content: o.viewport.scrollHeight,
          viewport: o.viewport.offsetHeight,
          scrollbar: {
            size: c.current.clientHeight,
            paddingStart: eb(s.paddingTop),
            paddingEnd: eb(s.paddingBottom)
          }
        });
      }
    }
  );
}), [vX, t4] = Z3(ta), n4 = C.forwardRef((e, t) => {
  const {
    __scopeScrollArea: n,
    sizes: r,
    hasThumb: i,
    onThumbChange: o,
    onThumbPointerUp: s,
    onThumbPointerDown: a,
    onThumbPositionChange: c,
    onDragScroll: u,
    onWheelScroll: f,
    onResize: h,
    ...m
  } = e, g = qo(ta, n), [b, x] = C.useState(null), w = Ft(t, (U) => x(U)), S = C.useRef(null), _ = C.useRef(""), M = g.viewport, N = r.content - r.viewport, P = Dr(f), I = Dr(c), O = qx(h, 10);
  function L(U) {
    if (S.current) {
      const B = U.clientX - S.current.left, G = U.clientY - S.current.top;
      u({ x: B, y: G });
    }
  }
  return C.useEffect(() => {
    const U = (B) => {
      const G = B.target;
      b?.contains(G) && P(B, N);
    };
    return document.addEventListener("wheel", U, { passive: !1 }), () => document.removeEventListener("wheel", U, { passive: !1 });
  }, [M, b, N, P]), C.useEffect(I, [r, I]), ih(b, O), ih(g.content, O), /* @__PURE__ */ v.jsx(
    vX,
    {
      scope: n,
      scrollbar: b,
      hasThumb: i,
      onThumbChange: Dr(o),
      onThumbPointerUp: Dr(s),
      onThumbPositionChange: I,
      onThumbPointerDown: Dr(a),
      children: /* @__PURE__ */ v.jsx(
        Et.div,
        {
          ...m,
          ref: w,
          style: { position: "absolute", ...m.style },
          onPointerDown: Ye(e.onPointerDown, (U) => {
            U.button === 0 && (U.target.setPointerCapture(U.pointerId), S.current = b.getBoundingClientRect(), _.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", g.viewport && (g.viewport.style.scrollBehavior = "auto"), L(U));
          }),
          onPointerMove: Ye(e.onPointerMove, L),
          onPointerUp: Ye(e.onPointerUp, (U) => {
            const B = U.target;
            B.hasPointerCapture(U.pointerId) && B.releasePointerCapture(U.pointerId), document.body.style.webkitUserSelect = _.current, g.viewport && (g.viewport.style.scrollBehavior = ""), S.current = null;
          })
        }
      )
    }
  );
}), Q0 = "ScrollAreaThumb", r4 = C.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, i = t4(Q0, e.__scopeScrollArea);
    return /* @__PURE__ */ v.jsx(Di, { present: n || i.hasThumb, children: /* @__PURE__ */ v.jsx(bX, { ref: t, ...r }) });
  }
), bX = C.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, style: r, ...i } = e, o = qo(Q0, n), s = t4(Q0, n), { onThumbPositionChange: a } = s, c = Ft(
      t,
      (h) => s.onThumbChange(h)
    ), u = C.useRef(void 0), f = qx(() => {
      u.current && (u.current(), u.current = void 0);
    }, 100);
    return C.useEffect(() => {
      const h = o.viewport;
      if (h) {
        const m = () => {
          if (f(), !u.current) {
            const g = SX(h, a);
            u.current = g, a();
          }
        };
        return a(), h.addEventListener("scroll", m), () => h.removeEventListener("scroll", m);
      }
    }, [o.viewport, f, a]), /* @__PURE__ */ v.jsx(
      Et.div,
      {
        "data-state": s.hasThumb ? "visible" : "hidden",
        ...i,
        ref: c,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...r
        },
        onPointerDownCapture: Ye(e.onPointerDownCapture, (h) => {
          const g = h.target.getBoundingClientRect(), b = h.clientX - g.left, x = h.clientY - g.top;
          s.onThumbPointerDown({ x: b, y: x });
        }),
        onPointerUp: Ye(e.onPointerUp, s.onThumbPointerUp)
      }
    );
  }
);
r4.displayName = Q0;
var YT = "ScrollAreaCorner", i4 = C.forwardRef(
  (e, t) => {
    const n = qo(YT, e.__scopeScrollArea), r = !!(n.scrollbarX && n.scrollbarY);
    return n.type !== "scroll" && r ? /* @__PURE__ */ v.jsx(xX, { ...e, ref: t }) : null;
  }
);
i4.displayName = YT;
var xX = C.forwardRef((e, t) => {
  const { __scopeScrollArea: n, ...r } = e, i = qo(YT, n), [o, s] = C.useState(0), [a, c] = C.useState(0), u = !!(o && a);
  return ih(i.scrollbarX, () => {
    const f = i.scrollbarX?.offsetHeight || 0;
    i.onCornerHeightChange(f), c(f);
  }), ih(i.scrollbarY, () => {
    const f = i.scrollbarY?.offsetWidth || 0;
    i.onCornerWidthChange(f), s(f);
  }), u ? /* @__PURE__ */ v.jsx(
    Et.div,
    {
      ...r,
      ref: t,
      style: {
        width: o,
        height: a,
        position: "absolute",
        right: i.dir === "ltr" ? 0 : void 0,
        left: i.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...e.style
      }
    }
  ) : null;
});
function eb(e) {
  return e ? parseInt(e, 10) : 0;
}
function o4(e, t) {
  const n = e / t;
  return isNaN(n) ? 0 : n;
}
function Wx(e) {
  const t = o4(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, r = (e.scrollbar.size - n) * t;
  return Math.max(r, 18);
}
function wX(e, t, n, r = "ltr") {
  const i = Wx(n), o = i / 2, s = t || o, a = i - s, c = n.scrollbar.paddingStart + s, u = n.scrollbar.size - n.scrollbar.paddingEnd - a, f = n.content - n.viewport, h = r === "ltr" ? [0, f] : [f * -1, 0];
  return s4([c, u], h)(e);
}
function _D(e, t, n = "ltr") {
  const r = Wx(t), i = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, o = t.scrollbar.size - i, s = t.content - t.viewport, a = o - r, c = n === "ltr" ? [0, s] : [s * -1, 0], u = NE(e, c);
  return s4([0, s], [0, a])(u);
}
function s4(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function a4(e, t) {
  return e > 0 && e < t;
}
var SX = (e, t = () => {
}) => {
  let n = { left: e.scrollLeft, top: e.scrollTop }, r = 0;
  return (function i() {
    const o = { left: e.scrollLeft, top: e.scrollTop }, s = n.left !== o.left, a = n.top !== o.top;
    (s || a) && t(), n = o, r = window.requestAnimationFrame(i);
  })(), () => window.cancelAnimationFrame(r);
};
function qx(e, t) {
  const n = Dr(e), r = C.useRef(0);
  return C.useEffect(() => () => window.clearTimeout(r.current), []), C.useCallback(() => {
    window.clearTimeout(r.current), r.current = window.setTimeout(n, t);
  }, [n, t]);
}
function ih(e, t) {
  const n = Dr(t);
  Er(() => {
    let r = 0;
    if (e) {
      const i = new ResizeObserver(() => {
        cancelAnimationFrame(r), r = window.requestAnimationFrame(n);
      });
      return i.observe(e), () => {
        window.cancelAnimationFrame(r), i.unobserve(e);
      };
    }
  }, [e, n]);
}
var kX = Y3, CX = J3, EX = i4;
function l4(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = l4(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function hc() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = l4(e)) && (r && (r += " "), r += t);
  return r;
}
const _X = (e, t) => {
  const n = new Array(e.length + t.length);
  for (let r = 0; r < e.length; r++)
    n[r] = e[r];
  for (let r = 0; r < t.length; r++)
    n[e.length + r] = t[r];
  return n;
}, TX = (e, t) => ({
  classGroupId: e,
  validator: t
}), c4 = (e = /* @__PURE__ */ new Map(), t = null, n) => ({
  nextPart: e,
  validators: t,
  classGroupId: n
}), tb = "-", TD = [], AX = "arbitrary..", MX = (e) => {
  const t = RX(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: r
  } = e;
  return {
    getClassGroupId: (s) => {
      if (s.startsWith("[") && s.endsWith("]"))
        return NX(s);
      const a = s.split(tb), c = a[0] === "" && a.length > 1 ? 1 : 0;
      return u4(a, c, t);
    },
    getConflictingClassGroupIds: (s, a) => {
      if (a) {
        const c = r[s], u = n[s];
        return c ? u ? _X(u, c) : c : u || TD;
      }
      return n[s] || TD;
    }
  };
}, u4 = (e, t, n) => {
  if (e.length - t === 0)
    return n.classGroupId;
  const i = e[t], o = n.nextPart.get(i);
  if (o) {
    const u = u4(e, t + 1, o);
    if (u) return u;
  }
  const s = n.validators;
  if (s === null)
    return;
  const a = t === 0 ? e.join(tb) : e.slice(t).join(tb), c = s.length;
  for (let u = 0; u < c; u++) {
    const f = s[u];
    if (f.validator(a))
      return f.classGroupId;
  }
}, NX = (e) => e.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const t = e.slice(1, -1), n = t.indexOf(":"), r = t.slice(0, n);
  return r ? AX + r : void 0;
})(), RX = (e) => {
  const {
    theme: t,
    classGroups: n
  } = e;
  return OX(n, t);
}, OX = (e, t) => {
  const n = c4();
  for (const r in e) {
    const i = e[r];
    XT(i, n, r, t);
  }
  return n;
}, XT = (e, t, n, r) => {
  const i = e.length;
  for (let o = 0; o < i; o++) {
    const s = e[o];
    DX(s, t, n, r);
  }
}, DX = (e, t, n, r) => {
  if (typeof e == "string") {
    PX(e, t, n);
    return;
  }
  if (typeof e == "function") {
    jX(e, t, n, r);
    return;
  }
  IX(e, t, n, r);
}, PX = (e, t, n) => {
  const r = e === "" ? t : d4(t, e);
  r.classGroupId = n;
}, jX = (e, t, n, r) => {
  if (zX(e)) {
    XT(e(r), t, n, r);
    return;
  }
  t.validators === null && (t.validators = []), t.validators.push(TX(n, e));
}, IX = (e, t, n, r) => {
  const i = Object.entries(e), o = i.length;
  for (let s = 0; s < o; s++) {
    const [a, c] = i[s];
    XT(c, d4(t, a), n, r);
  }
}, d4 = (e, t) => {
  let n = e;
  const r = t.split(tb), i = r.length;
  for (let o = 0; o < i; o++) {
    const s = r[o];
    let a = n.nextPart.get(s);
    a || (a = c4(), n.nextPart.set(s, a)), n = a;
  }
  return n;
}, zX = (e) => "isThemeGetter" in e && e.isThemeGetter === !0, LX = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  const i = (o, s) => {
    n[o] = s, t++, t > e && (t = 0, r = n, n = /* @__PURE__ */ Object.create(null));
  };
  return {
    get(o) {
      let s = n[o];
      if (s !== void 0)
        return s;
      if ((s = r[o]) !== void 0)
        return i(o, s), s;
    },
    set(o, s) {
      o in n ? n[o] = s : i(o, s);
    }
  };
}, RE = "!", AD = ":", BX = [], MD = (e, t, n, r, i) => ({
  modifiers: e,
  hasImportantModifier: t,
  baseClassName: n,
  maybePostfixModifierPosition: r,
  isExternal: i
}), $X = (e) => {
  const {
    prefix: t,
    experimentalParseClassName: n
  } = e;
  let r = (i) => {
    const o = [];
    let s = 0, a = 0, c = 0, u;
    const f = i.length;
    for (let x = 0; x < f; x++) {
      const w = i[x];
      if (s === 0 && a === 0) {
        if (w === AD) {
          o.push(i.slice(c, x)), c = x + 1;
          continue;
        }
        if (w === "/") {
          u = x;
          continue;
        }
      }
      w === "[" ? s++ : w === "]" ? s-- : w === "(" ? a++ : w === ")" && a--;
    }
    const h = o.length === 0 ? i : i.slice(c);
    let m = h, g = !1;
    h.endsWith(RE) ? (m = h.slice(0, -1), g = !0) : (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      h.startsWith(RE) && (m = h.slice(1), g = !0)
    );
    const b = u && u > c ? u - c : void 0;
    return MD(o, g, m, b);
  };
  if (t) {
    const i = t + AD, o = r;
    r = (s) => s.startsWith(i) ? o(s.slice(i.length)) : MD(BX, !1, s, void 0, !0);
  }
  if (n) {
    const i = r;
    r = (o) => n({
      className: o,
      parseClassName: i
    });
  }
  return r;
}, UX = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.orderSensitiveModifiers.forEach((n, r) => {
    t.set(n, 1e6 + r);
  }), (n) => {
    const r = [];
    let i = [];
    for (let o = 0; o < n.length; o++) {
      const s = n[o], a = s[0] === "[", c = t.has(s);
      a || c ? (i.length > 0 && (i.sort(), r.push(...i), i = []), r.push(s)) : i.push(s);
    }
    return i.length > 0 && (i.sort(), r.push(...i)), r;
  };
}, FX = (e) => ({
  cache: LX(e.cacheSize),
  parseClassName: $X(e),
  sortModifiers: UX(e),
  ...MX(e)
}), VX = /\s+/, HX = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: r,
    getConflictingClassGroupIds: i,
    sortModifiers: o
  } = t, s = [], a = e.trim().split(VX);
  let c = "";
  for (let u = a.length - 1; u >= 0; u -= 1) {
    const f = a[u], {
      isExternal: h,
      modifiers: m,
      hasImportantModifier: g,
      baseClassName: b,
      maybePostfixModifierPosition: x
    } = n(f);
    if (h) {
      c = f + (c.length > 0 ? " " + c : c);
      continue;
    }
    let w = !!x, S = r(w ? b.substring(0, x) : b);
    if (!S) {
      if (!w) {
        c = f + (c.length > 0 ? " " + c : c);
        continue;
      }
      if (S = r(b), !S) {
        c = f + (c.length > 0 ? " " + c : c);
        continue;
      }
      w = !1;
    }
    const _ = m.length === 0 ? "" : m.length === 1 ? m[0] : o(m).join(":"), M = g ? _ + RE : _, N = M + S;
    if (s.indexOf(N) > -1)
      continue;
    s.push(N);
    const P = i(S, w);
    for (let I = 0; I < P.length; ++I) {
      const O = P[I];
      s.push(M + O);
    }
    c = f + (c.length > 0 ? " " + c : c);
  }
  return c;
}, WX = (...e) => {
  let t = 0, n, r, i = "";
  for (; t < e.length; )
    (n = e[t++]) && (r = f4(n)) && (i && (i += " "), i += r);
  return i;
}, f4 = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let r = 0; r < e.length; r++)
    e[r] && (t = f4(e[r])) && (n && (n += " "), n += t);
  return n;
}, qX = (e, ...t) => {
  let n, r, i, o;
  const s = (c) => {
    const u = t.reduce((f, h) => h(f), e());
    return n = FX(u), r = n.cache.get, i = n.cache.set, o = a, a(c);
  }, a = (c) => {
    const u = r(c);
    if (u)
      return u;
    const f = HX(c, n);
    return i(c, f), f;
  };
  return o = s, (...c) => o(WX(...c));
}, GX = [], Nr = (e) => {
  const t = (n) => n[e] || GX;
  return t.isThemeGetter = !0, t;
}, h4 = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, p4 = /^\((?:(\w[\w-]*):)?(.+)\)$/i, KX = /^\d+\/\d+$/, ZX = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, YX = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, XX = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, JX = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, QX = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, uf = (e) => KX.test(e), $t = (e) => !!e && !Number.isNaN(Number(e)), Fl = (e) => !!e && Number.isInteger(Number(e)), mk = (e) => e.endsWith("%") && $t(e.slice(0, -1)), Da = (e) => ZX.test(e), eJ = () => !0, tJ = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  YX.test(e) && !XX.test(e)
), m4 = () => !1, nJ = (e) => JX.test(e), rJ = (e) => QX.test(e), iJ = (e) => !it(e) && !ot(e), oJ = (e) => Ch(e, v4, m4), it = (e) => h4.test(e), wu = (e) => Ch(e, b4, tJ), gk = (e) => Ch(e, uJ, $t), ND = (e) => Ch(e, g4, m4), sJ = (e) => Ch(e, y4, rJ), Cv = (e) => Ch(e, x4, nJ), ot = (e) => p4.test(e), Gp = (e) => Eh(e, b4), aJ = (e) => Eh(e, dJ), RD = (e) => Eh(e, g4), lJ = (e) => Eh(e, v4), cJ = (e) => Eh(e, y4), Ev = (e) => Eh(e, x4, !0), Ch = (e, t, n) => {
  const r = h4.exec(e);
  return r ? r[1] ? t(r[1]) : n(r[2]) : !1;
}, Eh = (e, t, n = !1) => {
  const r = p4.exec(e);
  return r ? r[1] ? t(r[1]) : n : !1;
}, g4 = (e) => e === "position" || e === "percentage", y4 = (e) => e === "image" || e === "url", v4 = (e) => e === "length" || e === "size" || e === "bg-size", b4 = (e) => e === "length", uJ = (e) => e === "number", dJ = (e) => e === "family-name", x4 = (e) => e === "shadow", fJ = () => {
  const e = Nr("color"), t = Nr("font"), n = Nr("text"), r = Nr("font-weight"), i = Nr("tracking"), o = Nr("leading"), s = Nr("breakpoint"), a = Nr("container"), c = Nr("spacing"), u = Nr("radius"), f = Nr("shadow"), h = Nr("inset-shadow"), m = Nr("text-shadow"), g = Nr("drop-shadow"), b = Nr("blur"), x = Nr("perspective"), w = Nr("aspect"), S = Nr("ease"), _ = Nr("animate"), M = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], N = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], P = () => [...N(), ot, it], I = () => ["auto", "hidden", "clip", "visible", "scroll"], O = () => ["auto", "contain", "none"], L = () => [ot, it, c], U = () => [uf, "full", "auto", ...L()], B = () => [Fl, "none", "subgrid", ot, it], G = () => ["auto", {
    span: ["full", Fl, ot, it]
  }, Fl, ot, it], Y = () => [Fl, "auto", ot, it], he = () => ["auto", "min", "max", "fr", ot, it], ie = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], ne = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], H = () => ["auto", ...L()], Q = () => [uf, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...L()], X = () => [e, ot, it], Se = () => [...N(), RD, ND, {
    position: [ot, it]
  }], W = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], Z = () => ["auto", "cover", "contain", lJ, oJ, {
    size: [ot, it]
  }], pe = () => [mk, Gp, wu], F = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    u,
    ot,
    it
  ], ee = () => ["", $t, Gp, wu], ge = () => ["solid", "dashed", "dotted", "double"], re = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], J = () => [$t, mk, RD, ND], xe = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    b,
    ot,
    it
  ], be = () => ["none", $t, ot, it], Ae = () => ["none", $t, ot, it], tt = () => [$t, ot, it], Ge = () => [uf, "full", ...L()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [Da],
      breakpoint: [Da],
      color: [eJ],
      container: [Da],
      "drop-shadow": [Da],
      ease: ["in", "out", "in-out"],
      font: [iJ],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [Da],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [Da],
      shadow: [Da],
      spacing: ["px", $t],
      text: [Da],
      "text-shadow": [Da],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", uf, it, ot, w]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [$t, it, ot, a]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": M()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": M()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: P()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: I()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": I()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": I()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: O()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": O()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": O()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: U()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": U()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": U()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: U()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: U()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: U()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: U()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: U()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: U()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [Fl, "auto", ot, it]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [uf, "full", "auto", a, ...L()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [$t, uf, "auto", "initial", "none", it]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", $t, ot, it]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", $t, ot, it]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [Fl, "first", "last", "none", ot, it]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": B()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: G()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": Y()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": Y()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": B()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: G()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": Y()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": Y()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": he()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": he()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: L()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": L()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": L()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...ie(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...ne(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...ne()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ie()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...ne(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...ne(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": ie()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...ne(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...ne()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: L()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: L()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: L()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: L()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: L()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: L()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: L()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: L()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: L()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: H()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: H()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: H()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: H()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: H()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: H()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: H()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: H()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: H()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": L()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": L()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: Q()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [a, "screen", ...Q()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          a,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...Q()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          a,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [s]
          },
          ...Q()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...Q()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...Q()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...Q()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", n, Gp, wu]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [r, ot, gk]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", mk, it]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [aJ, it, t]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [i, ot, it]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [$t, "none", ot, gk]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          o,
          ...L()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ot, it]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", ot, it]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: X()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: X()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...ge(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [$t, "from-font", "auto", ot, wu]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: X()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [$t, "auto", ot, it]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: L()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ot, it]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ot, it]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: Se()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: W()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: Z()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, Fl, ot, it],
          radial: ["", ot, it],
          conic: [Fl, ot, it]
        }, cJ, sJ]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: X()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: pe()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: pe()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: pe()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: X()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: X()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: X()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: F()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": F()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": F()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": F()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": F()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": F()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": F()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": F()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": F()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": F()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": F()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": F()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": F()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": F()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": F()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: ee()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": ee()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": ee()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": ee()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": ee()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": ee()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": ee()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": ee()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": ee()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": ee()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": ee()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...ge(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...ge(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: X()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": X()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": X()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": X()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": X()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": X()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": X()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": X()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": X()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: X()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...ge(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [$t, ot, it]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", $t, Gp, wu]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: X()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          f,
          Ev,
          Cv
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: X()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", h, Ev, Cv]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": X()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: ee()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: X()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [$t, wu]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": X()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": ee()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": X()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", m, Ev, Cv]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": X()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [$t, ot, it]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...re(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": re()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [$t]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": J()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": J()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": X()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": X()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": J()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": J()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": X()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": X()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": J()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": J()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": X()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": X()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": J()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": J()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": X()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": X()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": J()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": J()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": X()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": X()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": J()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": J()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": X()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": X()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": J()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": J()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": X()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": X()
      }],
      "mask-image-radial": [{
        "mask-radial": [ot, it]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": J()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": J()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": X()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": X()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": N()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [$t]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": J()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": J()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": X()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": X()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: Se()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: W()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: Z()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", ot, it]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          ot,
          it
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: xe()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [$t, ot, it]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [$t, ot, it]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          g,
          Ev,
          Cv
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": X()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", $t, ot, it]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [$t, ot, it]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", $t, ot, it]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [$t, ot, it]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", $t, ot, it]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          ot,
          it
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": xe()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [$t, ot, it]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [$t, ot, it]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", $t, ot, it]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [$t, ot, it]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", $t, ot, it]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [$t, ot, it]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [$t, ot, it]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", $t, ot, it]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": L()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": L()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": L()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", ot, it]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [$t, "initial", ot, it]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", S, ot, it]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [$t, ot, it]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", _, ot, it]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [x, ot, it]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": P()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: be()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": be()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": be()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": be()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: Ae()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": Ae()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": Ae()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": Ae()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: tt()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": tt()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": tt()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [ot, it, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: P()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: Ge()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": Ge()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": Ge()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": Ge()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: X()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: X()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ot, it]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": L()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": L()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": L()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": L()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": L()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": L()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": L()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": L()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": L()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": L()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": L()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": L()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": L()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": L()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": L()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": L()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": L()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": L()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ot, it]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...X()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [$t, Gp, wu, gk]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...X()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, hJ = /* @__PURE__ */ qX(fJ);
function at(...e) {
  return hJ(hc(e));
}
function JT({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsxs(
    kX,
    {
      "data-slot": "scroll-area",
      className: at("relative", e),
      ...n,
      children: [
        /* @__PURE__ */ v.jsx(
          CX,
          {
            "data-slot": "scroll-area-viewport",
            className: "focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1",
            children: t
          }
        ),
        /* @__PURE__ */ v.jsx(pJ, {}),
        /* @__PURE__ */ v.jsx(EX, {})
      ]
    }
  );
}
function pJ({
  className: e,
  orientation: t = "vertical",
  ...n
}) {
  return /* @__PURE__ */ v.jsx(
    Q3,
    {
      "data-slot": "scroll-area-scrollbar",
      orientation: t,
      className: at(
        "flex touch-none p-px transition-colors select-none",
        t === "vertical" && "h-full w-2.5 border-l border-l-transparent",
        t === "horizontal" && "h-2.5 flex-col border-t border-t-transparent",
        e
      ),
      ...n,
      children: /* @__PURE__ */ v.jsx(
        r4,
        {
          "data-slot": "scroll-area-thumb",
          className: "bg-border relative flex-1 rounded-full"
        }
      )
    }
  );
}
const QT = C.createContext({});
function Dg(e) {
  const t = C.useRef(null);
  return t.current === null && (t.current = e()), t.current;
}
const w4 = typeof window < "u", eA = w4 ? C.useLayoutEffect : C.useEffect, Gx = /* @__PURE__ */ C.createContext(null);
function tA(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function Pg(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
const Ys = (e, t, n) => n > t ? t : n < e ? e : n;
let nA = () => {
};
const Za = {}, S4 = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
function k4(e) {
  return typeof e == "object" && e !== null;
}
const C4 = (e) => /^0[^.\s]+$/u.test(e);
// @__NO_SIDE_EFFECTS__
function rA(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const $o = /* @__NO_SIDE_EFFECTS__ */ (e) => e, mJ = (e, t) => (n) => t(e(n)), jg = (...e) => e.reduce(mJ), oh = /* @__NO_SIDE_EFFECTS__ */ (e, t, n) => {
  const r = t - e;
  return r === 0 ? 1 : (n - e) / r;
};
class iA {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return tA(this.subscriptions, t), () => Pg(this.subscriptions, t);
  }
  notify(t, n, r) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](t, n, r);
      else
        for (let o = 0; o < i; o++) {
          const s = this.subscriptions[o];
          s && s(t, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const qs = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, Lo = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3;
function E4(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const gJ = (e, t, n) => {
  const r = t - e;
  return ((n - e) % r + r) % r + e;
}, _4 = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, yJ = 1e-7, vJ = 12;
function bJ(e, t, n, r, i) {
  let o, s, a = 0;
  do
    s = t + (n - t) / 2, o = _4(s, r, i) - e, o > 0 ? n = s : t = s;
  while (Math.abs(o) > yJ && ++a < vJ);
  return s;
}
function Ig(e, t, n, r) {
  if (e === t && n === r)
    return $o;
  const i = (o) => bJ(o, 0, 1, e, n);
  return (o) => o === 0 || o === 1 ? o : _4(i(o), t, r);
}
const T4 = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, A4 = (e) => (t) => 1 - e(1 - t), M4 = /* @__PURE__ */ Ig(0.33, 1.53, 0.69, 0.99), oA = /* @__PURE__ */ A4(M4), N4 = /* @__PURE__ */ T4(oA), R4 = (e) => (e *= 2) < 1 ? 0.5 * oA(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), sA = (e) => 1 - Math.sin(Math.acos(e)), O4 = A4(sA), D4 = T4(sA), xJ = /* @__PURE__ */ Ig(0.42, 0, 1, 1), wJ = /* @__PURE__ */ Ig(0, 0, 0.58, 1), P4 = /* @__PURE__ */ Ig(0.42, 0, 0.58, 1), j4 = (e) => Array.isArray(e) && typeof e[0] != "number";
function I4(e, t) {
  return j4(e) ? e[gJ(0, e.length, t)] : e;
}
const z4 = (e) => Array.isArray(e) && typeof e[0] == "number", SJ = {
  linear: $o,
  easeIn: xJ,
  easeInOut: P4,
  easeOut: wJ,
  circIn: sA,
  circInOut: D4,
  circOut: O4,
  backIn: oA,
  backInOut: N4,
  backOut: M4,
  anticipate: R4
}, kJ = (e) => typeof e == "string", OD = (e) => {
  if (z4(e)) {
    nA(e.length === 4);
    const [t, n, r, i] = e;
    return Ig(t, n, r, i);
  } else if (kJ(e))
    return SJ[e];
  return e;
}, _v = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function CJ(e, t) {
  let n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), i = !1, o = !1;
  const s = /* @__PURE__ */ new WeakSet();
  let a = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function c(f) {
    s.has(f) && (u.schedule(f), e()), f(a);
  }
  const u = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (f, h = !1, m = !1) => {
      const b = m && i ? n : r;
      return h && s.add(f), b.has(f) || b.add(f), f;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (f) => {
      r.delete(f), s.delete(f);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (f) => {
      if (a = f, i) {
        o = !0;
        return;
      }
      i = !0, [n, r] = [r, n], n.forEach(c), n.clear(), i = !1, o && (o = !1, u.process(f));
    }
  };
  return u;
}
const EJ = 40;
function L4(e, t) {
  let n = !1, r = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, o = () => n = !0, s = _v.reduce((M, N) => (M[N] = CJ(o), M), {}), { setup: a, read: c, resolveKeyframes: u, preUpdate: f, update: h, preRender: m, render: g, postRender: b } = s, x = () => {
    const M = Za.useManualTiming ? i.timestamp : performance.now();
    n = !1, Za.useManualTiming || (i.delta = r ? 1e3 / 60 : Math.max(Math.min(M - i.timestamp, EJ), 1)), i.timestamp = M, i.isProcessing = !0, a.process(i), c.process(i), u.process(i), f.process(i), h.process(i), m.process(i), g.process(i), b.process(i), i.isProcessing = !1, n && t && (r = !1, e(x));
  }, w = () => {
    n = !0, r = !0, i.isProcessing || e(x);
  };
  return { schedule: _v.reduce((M, N) => {
    const P = s[N];
    return M[N] = (I, O = !1, L = !1) => (n || w(), P.schedule(I, O, L)), M;
  }, {}), cancel: (M) => {
    for (let N = 0; N < _v.length; N++)
      s[_v[N]].cancel(M);
  }, state: i, steps: s };
}
const { schedule: _n, cancel: Ya, state: Qr, steps: yk } = /* @__PURE__ */ L4(typeof requestAnimationFrame < "u" ? requestAnimationFrame : $o, !0);
let y0;
function _J() {
  y0 = void 0;
}
const Mi = {
  now: () => (y0 === void 0 && Mi.set(Qr.isProcessing || Za.useManualTiming ? Qr.timestamp : performance.now()), y0),
  set: (e) => {
    y0 = e, queueMicrotask(_J);
  }
}, B4 = (e) => (t) => typeof t == "string" && t.startsWith(e), $4 = /* @__PURE__ */ B4("--"), TJ = /* @__PURE__ */ B4("var(--"), aA = (e) => TJ(e) ? AJ.test(e.split("/*")[0].trim()) : !1, AJ = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
function DD(e) {
  return typeof e != "string" ? !1 : e.split("/*")[0].includes("var(--");
}
const _h = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, qm = {
  ..._h,
  transform: (e) => Ys(0, 1, e)
}, Tv = {
  ..._h,
  default: 1
}, km = (e) => Math.round(e * 1e5) / 1e5, lA = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function MJ(e) {
  return e == null;
}
const NJ = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, cA = (e, t) => (n) => !!(typeof n == "string" && NJ.test(n) && n.startsWith(e) || t && !MJ(n) && Object.prototype.hasOwnProperty.call(n, t)), U4 = (e, t, n) => (r) => {
  if (typeof r != "string")
    return r;
  const [i, o, s, a] = r.match(lA);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(o),
    [n]: parseFloat(s),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, RJ = (e) => Ys(0, 255, e), vk = {
  ..._h,
  transform: (e) => Math.round(RJ(e))
}, Ou = {
  test: /* @__PURE__ */ cA("rgb", "red"),
  parse: /* @__PURE__ */ U4("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + vk.transform(e) + ", " + vk.transform(t) + ", " + vk.transform(n) + ", " + km(qm.transform(r)) + ")"
};
function OJ(e) {
  let t = "", n = "", r = "", i = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const OE = {
  test: /* @__PURE__ */ cA("#"),
  parse: OJ,
  transform: Ou.transform
}, zg = /* @__NO_SIDE_EFFECTS__ */ (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), Gl = /* @__PURE__ */ zg("deg"), Gs = /* @__PURE__ */ zg("%"), st = /* @__PURE__ */ zg("px"), DJ = /* @__PURE__ */ zg("vh"), PJ = /* @__PURE__ */ zg("vw"), PD = {
  ...Gs,
  parse: (e) => Gs.parse(e) / 100,
  transform: (e) => Gs.transform(e * 100)
}, Of = {
  test: /* @__PURE__ */ cA("hsl", "hue"),
  parse: /* @__PURE__ */ U4("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + Gs.transform(km(t)) + ", " + Gs.transform(km(n)) + ", " + km(qm.transform(r)) + ")"
}, Sr = {
  test: (e) => Ou.test(e) || OE.test(e) || Of.test(e),
  parse: (e) => Ou.test(e) ? Ou.parse(e) : Of.test(e) ? Of.parse(e) : OE.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? Ou.transform(e) : Of.transform(e),
  getAnimatableNone: (e) => {
    const t = Sr.parse(e);
    return t.alpha = 0, Sr.transform(t);
  }
}, jJ = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function IJ(e) {
  return isNaN(e) && typeof e == "string" && (e.match(lA)?.length || 0) + (e.match(jJ)?.length || 0) > 0;
}
const F4 = "number", V4 = "color", zJ = "var", LJ = "var(", jD = "${}", BJ = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Gm(e) {
  const t = e.toString(), n = [], r = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let o = 0;
  const a = t.replace(BJ, (c) => (Sr.test(c) ? (r.color.push(o), i.push(V4), n.push(Sr.parse(c))) : c.startsWith(LJ) ? (r.var.push(o), i.push(zJ), n.push(c)) : (r.number.push(o), i.push(F4), n.push(parseFloat(c))), ++o, jD)).split(jD);
  return { values: n, split: a, indexes: r, types: i };
}
function H4(e) {
  return Gm(e).values;
}
function W4(e) {
  const { split: t, types: n } = Gm(e), r = t.length;
  return (i) => {
    let o = "";
    for (let s = 0; s < r; s++)
      if (o += t[s], i[s] !== void 0) {
        const a = n[s];
        a === F4 ? o += km(i[s]) : a === V4 ? o += Sr.transform(i[s]) : o += i[s];
      }
    return o;
  };
}
const $J = (e) => typeof e == "number" ? 0 : Sr.test(e) ? Sr.getAnimatableNone(e) : e;
function UJ(e) {
  const t = H4(e);
  return W4(e)(t.map($J));
}
const kc = {
  test: IJ,
  parse: H4,
  createTransformer: W4,
  getAnimatableNone: UJ
};
function bk(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function FJ({ hue: e, saturation: t, lightness: n, alpha: r }) {
  e /= 360, t /= 100, n /= 100;
  let i = 0, o = 0, s = 0;
  if (!t)
    i = o = s = n;
  else {
    const a = n < 0.5 ? n * (1 + t) : n + t - n * t, c = 2 * n - a;
    i = bk(c, a, e + 1 / 3), o = bk(c, a, e), s = bk(c, a, e - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(o * 255),
    blue: Math.round(s * 255),
    alpha: r
  };
}
function nb(e, t) {
  return (n) => n > 0 ? t : e;
}
const Gn = (e, t, n) => e + (t - e) * n, xk = (e, t, n) => {
  const r = e * e, i = n * (t * t - r) + r;
  return i < 0 ? 0 : Math.sqrt(i);
}, VJ = [OE, Ou, Of], HJ = (e) => VJ.find((t) => t.test(e));
function ID(e) {
  const t = HJ(e);
  if (!t)
    return !1;
  let n = t.parse(e);
  return t === Of && (n = FJ(n)), n;
}
const zD = (e, t) => {
  const n = ID(e), r = ID(t);
  if (!n || !r)
    return nb(e, t);
  const i = { ...n };
  return (o) => (i.red = xk(n.red, r.red, o), i.green = xk(n.green, r.green, o), i.blue = xk(n.blue, r.blue, o), i.alpha = Gn(n.alpha, r.alpha, o), Ou.transform(i));
}, DE = /* @__PURE__ */ new Set(["none", "hidden"]);
function WJ(e, t) {
  return DE.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function qJ(e, t) {
  return (n) => Gn(e, t, n);
}
function uA(e) {
  return typeof e == "number" ? qJ : typeof e == "string" ? aA(e) ? nb : Sr.test(e) ? zD : ZJ : Array.isArray(e) ? q4 : typeof e == "object" ? Sr.test(e) ? zD : GJ : nb;
}
function q4(e, t) {
  const n = [...e], r = n.length, i = e.map((o, s) => uA(o)(o, t[s]));
  return (o) => {
    for (let s = 0; s < r; s++)
      n[s] = i[s](o);
    return n;
  };
}
function GJ(e, t) {
  const n = { ...e, ...t }, r = {};
  for (const i in n)
    e[i] !== void 0 && t[i] !== void 0 && (r[i] = uA(e[i])(e[i], t[i]));
  return (i) => {
    for (const o in r)
      n[o] = r[o](i);
    return n;
  };
}
function KJ(e, t) {
  const n = [], r = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < t.values.length; i++) {
    const o = t.types[i], s = e.indexes[o][r[o]], a = e.values[s] ?? 0;
    n[i] = a, r[o]++;
  }
  return n;
}
const ZJ = (e, t) => {
  const n = kc.createTransformer(t), r = Gm(e), i = Gm(t);
  return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? DE.has(e) && !i.values.length || DE.has(t) && !r.values.length ? WJ(e, t) : jg(q4(KJ(r, i), i.values), n) : nb(e, t);
};
function G4(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? Gn(e, t, n) : uA(e)(e, t);
}
const YJ = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: (n = !0) => _n.update(t, n),
    stop: () => Ya(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Qr.isProcessing ? Qr.timestamp : Mi.now()
  };
}, K4 = (e, t, n = 10) => {
  let r = "";
  const i = Math.max(Math.round(t / n), 2);
  for (let o = 0; o < i; o++)
    r += Math.round(e(o / (i - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
}, rb = 2e4;
function dA(e) {
  let t = 0;
  const n = 50;
  let r = e.next(t);
  for (; !r.done && t < rb; )
    t += n, r = e.next(t);
  return t >= rb ? 1 / 0 : t;
}
function Z4(e, t = 100, n) {
  const r = n({ ...e, keyframes: [0, t] }), i = Math.min(dA(r), rb);
  return {
    type: "keyframes",
    ease: (o) => r.next(i * o).value / t,
    duration: /* @__PURE__ */ Lo(i)
  };
}
const XJ = 5;
function Y4(e, t, n) {
  const r = Math.max(t - XJ, 0);
  return E4(n - e(r), t - r);
}
const tr = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, wk = 1e-3;
function JJ({ duration: e = tr.duration, bounce: t = tr.bounce, velocity: n = tr.velocity, mass: r = tr.mass }) {
  let i, o, s = 1 - t;
  s = Ys(tr.minDamping, tr.maxDamping, s), e = Ys(tr.minDuration, tr.maxDuration, /* @__PURE__ */ Lo(e)), s < 1 ? (i = (u) => {
    const f = u * s, h = f * e, m = f - n, g = PE(u, s), b = Math.exp(-h);
    return wk - m / g * b;
  }, o = (u) => {
    const h = u * s * e, m = h * n + n, g = Math.pow(s, 2) * Math.pow(u, 2) * e, b = Math.exp(-h), x = PE(Math.pow(u, 2), s);
    return (-i(u) + wk > 0 ? -1 : 1) * ((m - g) * b) / x;
  }) : (i = (u) => {
    const f = Math.exp(-u * e), h = (u - n) * e + 1;
    return -wk + f * h;
  }, o = (u) => {
    const f = Math.exp(-u * e), h = (n - u) * (e * e);
    return f * h;
  });
  const a = 5 / e, c = eQ(i, o, a);
  if (e = /* @__PURE__ */ qs(e), isNaN(c))
    return {
      stiffness: tr.stiffness,
      damping: tr.damping,
      duration: e
    };
  {
    const u = Math.pow(c, 2) * r;
    return {
      stiffness: u,
      damping: s * 2 * Math.sqrt(r * u),
      duration: e
    };
  }
}
const QJ = 12;
function eQ(e, t, n) {
  let r = n;
  for (let i = 1; i < QJ; i++)
    r = r - e(r) / t(r);
  return r;
}
function PE(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const tQ = ["duration", "bounce"], nQ = ["stiffness", "damping", "mass"];
function LD(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function rQ(e) {
  let t = {
    velocity: tr.velocity,
    stiffness: tr.stiffness,
    damping: tr.damping,
    mass: tr.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!LD(e, nQ) && LD(e, tQ))
    if (e.visualDuration) {
      const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, o = 2 * Ys(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i);
      t = {
        ...t,
        mass: tr.mass,
        stiffness: i,
        damping: o
      };
    } else {
      const n = JJ(e);
      t = {
        ...t,
        ...n,
        mass: tr.mass
      }, t.isResolvedFromDuration = !0;
    }
  return t;
}
function Km(e = tr.visualDuration, t = tr.bounce) {
  const n = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: t
  } : e;
  let { restSpeed: r, restDelta: i } = n;
  const o = n.keyframes[0], s = n.keyframes[n.keyframes.length - 1], a = { done: !1, value: o }, { stiffness: c, damping: u, mass: f, duration: h, velocity: m, isResolvedFromDuration: g } = rQ({
    ...n,
    velocity: -/* @__PURE__ */ Lo(n.velocity || 0)
  }), b = m || 0, x = u / (2 * Math.sqrt(c * f)), w = s - o, S = /* @__PURE__ */ Lo(Math.sqrt(c / f)), _ = Math.abs(w) < 5;
  r || (r = _ ? tr.restSpeed.granular : tr.restSpeed.default), i || (i = _ ? tr.restDelta.granular : tr.restDelta.default);
  let M;
  if (x < 1) {
    const P = PE(S, x);
    M = (I) => {
      const O = Math.exp(-x * S * I);
      return s - O * ((b + x * S * w) / P * Math.sin(P * I) + w * Math.cos(P * I));
    };
  } else if (x === 1)
    M = (P) => s - Math.exp(-S * P) * (w + (b + S * w) * P);
  else {
    const P = S * Math.sqrt(x * x - 1);
    M = (I) => {
      const O = Math.exp(-x * S * I), L = Math.min(P * I, 300);
      return s - O * ((b + x * S * w) * Math.sinh(L) + P * w * Math.cosh(L)) / P;
    };
  }
  const N = {
    calculatedDuration: g && h || null,
    next: (P) => {
      const I = M(P);
      if (g)
        a.done = P >= h;
      else {
        let O = P === 0 ? b : 0;
        x < 1 && (O = P === 0 ? /* @__PURE__ */ qs(b) : Y4(M, P, I));
        const L = Math.abs(O) <= r, U = Math.abs(s - I) <= i;
        a.done = L && U;
      }
      return a.value = a.done ? s : I, a;
    },
    toString: () => {
      const P = Math.min(dA(N), rb), I = K4((O) => N.next(P * O).value, P, 30);
      return P + "ms " + I;
    },
    toTransition: () => {
    }
  };
  return N;
}
Km.applyToOptions = (e) => {
  const t = Z4(e, 100, Km);
  return e.ease = t.ease, e.duration = /* @__PURE__ */ qs(t.duration), e.type = "keyframes", e;
};
function jE({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: s, min: a, max: c, restDelta: u = 0.5, restSpeed: f }) {
  const h = e[0], m = {
    done: !1,
    value: h
  }, g = (L) => a !== void 0 && L < a || c !== void 0 && L > c, b = (L) => a === void 0 ? c : c === void 0 || Math.abs(a - L) < Math.abs(c - L) ? a : c;
  let x = n * t;
  const w = h + x, S = s === void 0 ? w : s(w);
  S !== w && (x = S - h);
  const _ = (L) => -x * Math.exp(-L / r), M = (L) => S + _(L), N = (L) => {
    const U = _(L), B = M(L);
    m.done = Math.abs(U) <= u, m.value = m.done ? S : B;
  };
  let P, I;
  const O = (L) => {
    g(m.value) && (P = L, I = Km({
      keyframes: [m.value, b(m.value)],
      velocity: Y4(M, L, m.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: o,
      restDelta: u,
      restSpeed: f
    }));
  };
  return O(0), {
    calculatedDuration: null,
    next: (L) => {
      let U = !1;
      return !I && P === void 0 && (U = !0, N(L), O(L)), P !== void 0 && L >= P ? I.next(L - P) : (!U && N(L), m);
    }
  };
}
function iQ(e, t, n) {
  const r = [], i = n || Za.mix || G4, o = e.length - 1;
  for (let s = 0; s < o; s++) {
    let a = i(e[s], e[s + 1]);
    if (t) {
      const c = Array.isArray(t) ? t[s] || $o : t;
      a = jg(c, a);
    }
    r.push(a);
  }
  return r;
}
function X4(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const o = e.length;
  if (nA(o === t.length), o === 1)
    return () => t[0];
  if (o === 2 && t[0] === t[1])
    return () => t[1];
  const s = e[0] === e[1];
  e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const a = iQ(t, r, i), c = a.length, u = (f) => {
    if (s && f < e[0])
      return t[0];
    let h = 0;
    if (c > 1)
      for (; h < e.length - 2 && !(f < e[h + 1]); h++)
        ;
    const m = /* @__PURE__ */ oh(e[h], e[h + 1], f);
    return a[h](m);
  };
  return n ? (f) => u(Ys(e[0], e[o - 1], f)) : u;
}
function J4(e, t) {
  const n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    const i = /* @__PURE__ */ oh(0, t, r);
    e.push(Gn(n, 1, i));
  }
}
function Q4(e) {
  const t = [0];
  return J4(t, e.length - 1), t;
}
function oQ(e, t) {
  return e.map((n) => n * t);
}
function sQ(e, t) {
  return e.map(() => t || P4).splice(0, e.length - 1);
}
function Cm({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) {
  const i = j4(r) ? r.map(OD) : OD(r), o = {
    done: !1,
    value: t[0]
  }, s = oQ(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : Q4(t),
    e
  ), a = X4(s, t, {
    ease: Array.isArray(i) ? i : sQ(t, i)
  });
  return {
    calculatedDuration: e,
    next: (c) => (o.value = a(c), o.done = c >= e, o)
  };
}
const aQ = (e) => e !== null;
function fA(e, { repeat: t, repeatType: n = "loop" }, r, i = 1) {
  const o = e.filter(aQ), a = i < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : o.length - 1;
  return !a || r === void 0 ? o[a] : r;
}
const lQ = {
  decay: jE,
  inertia: jE,
  tween: Cm,
  keyframes: Cm,
  spring: Km
};
function eB(e) {
  typeof e.type == "string" && (e.type = lQ[e.type]);
}
class hA {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
}
const cQ = (e) => e / 100;
class pA extends hA {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      const { motionValue: n } = this.options;
      n && n.updatedAt !== Mi.now() && this.tick(Mi.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.());
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    eB(t);
    const { type: n = Cm, repeat: r = 0, repeatDelay: i = 0, repeatType: o, velocity: s = 0 } = t;
    let { keyframes: a } = t;
    const c = n || Cm;
    c !== Cm && typeof a[0] != "number" && (this.mixKeyframes = jg(cQ, G4(a[0], a[1])), a = [0, 100]);
    const u = c({ ...t, keyframes: a });
    o === "mirror" && (this.mirroredGenerator = c({
      ...t,
      keyframes: [...a].reverse(),
      velocity: -s
    })), u.calculatedDuration === null && (u.calculatedDuration = dA(u));
    const { calculatedDuration: f } = u;
    this.calculatedDuration = f, this.resolvedDuration = f + i, this.totalDuration = this.resolvedDuration * (r + 1) - i, this.generator = u;
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(t, n = !1) {
    const { generator: r, totalDuration: i, mixKeyframes: o, mirroredGenerator: s, resolvedDuration: a, calculatedDuration: c } = this;
    if (this.startTime === null)
      return r.next(0);
    const { delay: u = 0, keyframes: f, repeat: h, repeatType: m, repeatDelay: g, type: b, onUpdate: x, finalKeyframe: w } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - i / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
    const S = this.currentTime - u * (this.playbackSpeed >= 0 ? 1 : -1), _ = this.playbackSpeed >= 0 ? S < 0 : S > i;
    this.currentTime = Math.max(S, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = i);
    let M = this.currentTime, N = r;
    if (h) {
      const L = Math.min(this.currentTime, i) / a;
      let U = Math.floor(L), B = L % 1;
      !B && L >= 1 && (B = 1), B === 1 && U--, U = Math.min(U, h + 1), U % 2 && (m === "reverse" ? (B = 1 - B, g && (B -= g / a)) : m === "mirror" && (N = s)), M = Ys(0, 1, B) * a;
    }
    const P = _ ? { done: !1, value: f[0] } : N.next(M);
    o && (P.value = o(P.value));
    let { done: I } = P;
    !_ && c !== null && (I = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0);
    const O = this.holdTime === null && (this.state === "finished" || this.state === "running" && I);
    return O && b !== jE && (P.value = fA(f, this.options, w, this.speed)), x && x(P.value), O && this.finish(), P;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return /* @__PURE__ */ Lo(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ Lo(t);
  }
  get time() {
    return /* @__PURE__ */ Lo(this.currentTime);
  }
  set time(t) {
    t = /* @__PURE__ */ qs(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), this.driver?.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(Mi.now());
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = /* @__PURE__ */ Lo(this.currentTime));
  }
  play() {
    if (this.isStopped)
      return;
    const { driver: t = YJ, startTime: n } = this.options;
    this.driver || (this.driver = t((i) => this.tick(i))), this.options.onPlay?.();
    const r = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = r) : this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime || (this.startTime = n ?? r), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(Mi.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.();
  }
  cancel() {
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), t.observe(this);
  }
}
function uQ(e) {
  for (let t = 1; t < e.length; t++)
    e[t] ?? (e[t] = e[t - 1]);
}
const Du = (e) => e * 180 / Math.PI, IE = (e) => {
  const t = Du(Math.atan2(e[1], e[0]));
  return zE(t);
}, dQ = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
  rotate: IE,
  rotateZ: IE,
  skewX: (e) => Du(Math.atan(e[1])),
  skewY: (e) => Du(Math.atan(e[2])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2
}, zE = (e) => (e = e % 360, e < 0 && (e += 360), e), BD = IE, $D = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]), UD = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]), fQ = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: $D,
  scaleY: UD,
  scale: (e) => ($D(e) + UD(e)) / 2,
  rotateX: (e) => zE(Du(Math.atan2(e[6], e[5]))),
  rotateY: (e) => zE(Du(Math.atan2(-e[2], e[0]))),
  rotateZ: BD,
  rotate: BD,
  skewX: (e) => Du(Math.atan(e[4])),
  skewY: (e) => Du(Math.atan(e[1])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2
};
function LE(e) {
  return e.includes("scale") ? 1 : 0;
}
function BE(e, t) {
  if (!e || e === "none")
    return LE(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let r, i;
  if (n)
    r = fQ, i = n;
  else {
    const a = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    r = dQ, i = a;
  }
  if (!i)
    return LE(t);
  const o = r[t], s = i[1].split(",").map(pQ);
  return typeof o == "function" ? o(s) : s[o];
}
const hQ = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return BE(n, t);
};
function pQ(e) {
  return parseFloat(e.trim());
}
const Th = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Ah = new Set(Th), FD = (e) => e === _h || e === st, mQ = /* @__PURE__ */ new Set(["x", "y", "z"]), gQ = Th.filter((e) => !mQ.has(e));
function yQ(e) {
  const t = [];
  return gQ.forEach((n) => {
    const r = e.getValue(n);
    r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const lc = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: (e, { transform: t }) => BE(t, "x"),
  y: (e, { transform: t }) => BE(t, "y")
};
lc.translateX = lc.x;
lc.translateY = lc.y;
const Bu = /* @__PURE__ */ new Set();
let $E = !1, UE = !1, FE = !1;
function tB() {
  if (UE) {
    const e = Array.from(Bu).filter((r) => r.needsMeasurement), t = new Set(e.map((r) => r.element)), n = /* @__PURE__ */ new Map();
    t.forEach((r) => {
      const i = yQ(r);
      i.length && (n.set(r, i), r.render());
    }), e.forEach((r) => r.measureInitialState()), t.forEach((r) => {
      r.render();
      const i = n.get(r);
      i && i.forEach(([o, s]) => {
        r.getValue(o)?.set(s);
      });
    }), e.forEach((r) => r.measureEndState()), e.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  UE = !1, $E = !1, Bu.forEach((e) => e.complete(FE)), Bu.clear();
}
function nB() {
  Bu.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (UE = !0);
  });
}
function vQ() {
  FE = !0, nB(), tB(), FE = !1;
}
class mA {
  constructor(t, n, r, i, o, s = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = o, this.isAsync = s;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (Bu.add(this), $E || ($E = !0, _n.read(nB), _n.resolveKeyframes(tB))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this;
    if (t[0] === null) {
      const o = i?.get(), s = t[t.length - 1];
      if (o !== void 0)
        t[0] = o;
      else if (r && n) {
        const a = r.readValue(n, s);
        a != null && (t[0] = a);
      }
      t[0] === void 0 && (t[0] = s), i && o === void 0 && i.set(t[0]);
    }
    uQ(t);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(t = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), Bu.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (Bu.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const bQ = (e) => e.startsWith("--");
function xQ(e, t, n) {
  bQ(t) ? e.style.setProperty(t, n) : e.style[t] = n;
}
const wQ = /* @__PURE__ */ rA(() => window.ScrollTimeline !== void 0), SQ = {};
function kQ(e, t) {
  const n = /* @__PURE__ */ rA(e);
  return () => SQ[t] ?? n();
}
const rB = /* @__PURE__ */ kQ(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), sm = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, VD = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ sm([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ sm([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ sm([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ sm([0.33, 1.53, 0.69, 0.99])
};
function iB(e, t) {
  if (e)
    return typeof e == "function" ? rB() ? K4(e, t) : "ease-out" : z4(e) ? sm(e) : Array.isArray(e) ? e.map((n) => iB(n, t) || VD.easeOut) : VD[e];
}
function CQ(e, t, n, { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: s = "loop", ease: a = "easeOut", times: c } = {}, u = void 0) {
  const f = {
    [t]: n
  };
  c && (f.offset = c);
  const h = iB(a, i);
  Array.isArray(h) && (f.easing = h);
  const m = {
    delay: r,
    duration: i,
    easing: Array.isArray(h) ? "linear" : h,
    fill: "both",
    iterations: o + 1,
    direction: s === "reverse" ? "alternate" : "normal"
  };
  return u && (m.pseudoElement = u), e.animate(f, m);
}
function gA(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
function EQ({ type: e, ...t }) {
  return gA(e) && rB() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
class _Q extends hA {
  constructor(t) {
    if (super(), this.finishedTime = null, this.isStopped = !1, this.manualStartTime = null, !t)
      return;
    const { element: n, name: r, keyframes: i, pseudoElement: o, allowFlatten: s = !1, finalKeyframe: a, onComplete: c } = t;
    this.isPseudoElement = !!o, this.allowFlatten = s, this.options = t, nA(typeof t.type != "string");
    const u = EQ(t);
    this.animation = CQ(n, r, i, u, o), u.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !o) {
        const f = fA(i, this.options, a, this.speed);
        this.updateMotionValue ? this.updateMotionValue(f) : xQ(n, r, f), this.animation.cancel();
      }
      c?.(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.manualStartTime = null, this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    const t = this.options?.element;
    !this.isPseudoElement && t?.isConnected && this.animation.commitStyles?.();
  }
  get duration() {
    const t = this.animation.effect?.getComputedTiming?.().duration || 0;
    return /* @__PURE__ */ Lo(Number(t));
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ Lo(t);
  }
  get time() {
    return /* @__PURE__ */ Lo(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    this.manualStartTime = null, this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ qs(t);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), this.animation.playbackRate = t;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return this.manualStartTime ?? Number(this.animation.startTime);
  }
  set startTime(t) {
    this.manualStartTime = this.animation.startTime = t;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: t, observe: n }) {
    return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, t && wQ() ? (this.animation.timeline = t, $o) : n(this);
  }
}
const oB = {
  anticipate: R4,
  backInOut: N4,
  circInOut: D4
};
function TQ(e) {
  return e in oB;
}
function AQ(e) {
  typeof e.ease == "string" && TQ(e.ease) && (e.ease = oB[e.ease]);
}
const Sk = 10;
class MQ extends _Q {
  constructor(t) {
    AQ(t), eB(t), super(t), t.startTime !== void 0 && (this.startTime = t.startTime), this.options = t;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read committed styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: r, onComplete: i, element: o, ...s } = this.options;
    if (!n)
      return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const a = new pA({
      ...s,
      autoplay: !1
    }), c = Math.max(Sk, Mi.now() - this.startTime), u = Ys(0, Sk, c - Sk);
    n.setWithVelocity(a.sample(Math.max(0, c - u)).value, a.sample(c).value, u), a.stop();
  }
}
const HD = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(kc.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function NQ(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function RQ(e, t, n, r) {
  const i = e[0];
  if (i === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const o = e[e.length - 1], s = HD(i, t), a = HD(o, t);
  return !s || !a ? !1 : NQ(e) || (n === "spring" || gA(n)) && r;
}
function VE(e) {
  e.duration = 0, e.type = "keyframes";
}
const OQ = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), DQ = /* @__PURE__ */ rA(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function PQ(e) {
  const { motionValue: t, name: n, repeatDelay: r, repeatType: i, damping: o, type: s } = e;
  if (!(t?.owner?.current instanceof HTMLElement))
    return !1;
  const { onUpdate: c, transformTemplate: u } = t.owner.getProps();
  return DQ() && n && OQ.has(n) && (n !== "transform" || !u) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !c && !r && i !== "mirror" && o !== 0 && s !== "inertia";
}
const jQ = 40;
class IQ extends hA {
  constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: o = 0, repeatType: s = "loop", keyframes: a, name: c, motionValue: u, element: f, ...h }) {
    super(), this.stop = () => {
      this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel();
    }, this.createdAt = Mi.now();
    const m = {
      autoplay: t,
      delay: n,
      type: r,
      repeat: i,
      repeatDelay: o,
      repeatType: s,
      name: c,
      motionValue: u,
      element: f,
      ...h
    }, g = f?.KeyframeResolver || mA;
    this.keyframeResolver = new g(a, (b, x, w) => this.onKeyframesResolved(b, x, m, !w), c, u, f), this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(t, n, r, i) {
    this.keyframeResolver = void 0;
    const { name: o, type: s, velocity: a, delay: c, isHandoff: u, onUpdate: f } = r;
    this.resolvedAt = Mi.now(), RQ(t, o, s, a) || ((Za.instantAnimations || !c) && f?.(fA(t, r, n)), t[0] = t[t.length - 1], VE(r), r.repeat = 0);
    const m = {
      startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > jQ ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...r,
      keyframes: t
    }, g = !u && PQ(m), b = m.motionValue?.owner?.current, x = g ? new MQ({
      ...m,
      element: b
    }) : new pA(m);
    x.finished.then(() => {
      this.notifyFinished();
    }).catch($o), this.pendingTimeline && (this.stopTimeline = x.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = x;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    return this._animation || (this.keyframeResolver?.resume(), vQ()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();
  }
}
class zQ {
  constructor(t) {
    this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((t) => t.finished));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(t) {
    return this.animations[0][t];
  }
  setAll(t, n) {
    for (let r = 0; r < this.animations.length; r++)
      this.animations[r][t] = n;
  }
  attachTimeline(t) {
    const n = this.animations.map((r) => r.attachTimeline(t));
    return () => {
      n.forEach((r, i) => {
        r && r(), this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(t) {
    this.setAll("time", t);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(t) {
    this.setAll("speed", t);
  }
  get state() {
    return this.getAll("state");
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    return WD(this.animations, "duration");
  }
  get iterationDuration() {
    return WD(this.animations, "iterationDuration");
  }
  runAll(t) {
    this.animations.forEach((n) => n[t]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function WD(e, t) {
  let n = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r][t];
    i !== null && i > n && (n = i);
  }
  return n;
}
class LQ extends zQ {
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
}
function sB(e, t, n, r = 0, i = 1) {
  const o = Array.from(e).sort((u, f) => u.sortNodePosition(f)).indexOf(t), s = e.size, a = (s - 1) * r;
  return typeof n == "function" ? n(o, s) : i === 1 ? o * r : a - o * r;
}
const BQ = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function $Q(e) {
  const t = BQ.exec(e);
  if (!t)
    return [,];
  const [, n, r, i] = t;
  return [`--${n ?? r}`, i];
}
function aB(e, t, n = 1) {
  const [r, i] = $Q(e);
  if (!r)
    return;
  const o = window.getComputedStyle(t).getPropertyValue(r);
  if (o) {
    const s = o.trim();
    return S4(s) ? parseFloat(s) : s;
  }
  return aA(i) ? aB(i, t, n + 1) : i;
}
const UQ = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, FQ = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), VQ = {
  type: "keyframes",
  duration: 0.8
}, HQ = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, WQ = (e, { keyframes: t }) => t.length > 2 ? VQ : Ah.has(e) ? e.startsWith("scale") ? FQ(t[1]) : UQ : HQ, qQ = (e) => e !== null;
function GQ(e, { repeat: t, repeatType: n = "loop" }, r) {
  const i = e.filter(qQ), o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
  return i[o];
}
function yA(e, t) {
  return e?.[t] ?? e?.default ?? e;
}
function KQ({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: c, elapsed: u, ...f }) {
  return !!Object.keys(f).length;
}
const vA = (e, t, n, r = {}, i, o) => (s) => {
  const a = yA(r, e) || {}, c = a.delay || r.delay || 0;
  let { elapsed: u = 0 } = r;
  u = u - /* @__PURE__ */ qs(c);
  const f = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...a,
    delay: -u,
    onUpdate: (m) => {
      t.set(m), a.onUpdate && a.onUpdate(m);
    },
    onComplete: () => {
      s(), a.onComplete && a.onComplete();
    },
    name: e,
    motionValue: t,
    element: o ? void 0 : i
  };
  KQ(a) || Object.assign(f, WQ(e, f)), f.duration && (f.duration = /* @__PURE__ */ qs(f.duration)), f.repeatDelay && (f.repeatDelay = /* @__PURE__ */ qs(f.repeatDelay)), f.from !== void 0 && (f.keyframes[0] = f.from);
  let h = !1;
  if ((f.type === !1 || f.duration === 0 && !f.repeatDelay) && (VE(f), f.delay === 0 && (h = !0)), (Za.instantAnimations || Za.skipAnimations || i?.shouldSkipAnimations) && (h = !0, VE(f), f.delay = 0), f.allowFlatten = !a.type && !a.ease, h && !o && t.get() !== void 0) {
    const m = GQ(f.keyframes, a);
    if (m !== void 0) {
      _n.update(() => {
        f.onUpdate(m), f.onComplete();
      });
      return;
    }
  }
  return a.isSync ? new pA(f) : new IQ(f);
};
function qD(e) {
  const t = [{}, {}];
  return e?.values.forEach((n, r) => {
    t[0][r] = n.get(), t[1][r] = n.getVelocity();
  }), t;
}
function bA(e, t, n, r) {
  if (typeof t == "function") {
    const [i, o] = qD(r);
    t = t(n !== void 0 ? n : e.custom, i, o);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [i, o] = qD(r);
    t = t(n !== void 0 ? n : e.custom, i, o);
  }
  return t;
}
function Wf(e, t, n) {
  const r = e.getProps();
  return bA(r, t, n !== void 0 ? n : r.custom, e);
}
const lB = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...Th
]), GD = 30, ZQ = (e) => !isNaN(parseFloat(e)), Em = {
  current: void 0
};
class YQ {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(t, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r) => {
      const i = Mi.now();
      if (this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents))
        for (const o of this.dependents)
          o.dirty();
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = Mi.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = ZQ(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new iA());
    const r = this.events[t].add(n);
    return t === "change" ? () => {
      r(), _n.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t) {
    this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t);
  }
  setWithVelocity(t, n, r) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return Em.current && Em.current.push(this), this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = Mi.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > GD)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, GD);
    return E4(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Cc(e, t) {
  return new YQ(e, t);
}
const HE = (e) => Array.isArray(e);
function XQ(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Cc(n));
}
function JQ(e) {
  return HE(e) ? e[e.length - 1] || 0 : e;
}
function QQ(e, t) {
  const n = Wf(e, t);
  let { transitionEnd: r = {}, transition: i = {}, ...o } = n || {};
  o = { ...o, ...r };
  for (const s in o) {
    const a = JQ(o[s]);
    XQ(e, s, a);
  }
}
const Fr = (e) => !!(e && e.getVelocity);
function eee(e) {
  return !!(Fr(e) && e.add);
}
function WE(e, t) {
  const n = e.getValue("willChange");
  if (eee(n))
    return n.add(t);
  if (!n && Za.WillChange) {
    const r = new Za.WillChange("auto");
    e.addValue("willChange", r), r.add(t);
  }
}
function xA(e) {
  return e.replace(/([A-Z])/g, (t) => `-${t.toLowerCase()}`);
}
const tee = "framerAppearId", cB = "data-" + xA(tee);
function uB(e) {
  return e.props[cB];
}
function nee({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, r;
}
function wA(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  let { transition: o = e.getDefaultTransition(), transitionEnd: s, ...a } = t;
  const c = o?.reduceMotion;
  r && (o = r);
  const u = [], f = i && e.animationState && e.animationState.getState()[i];
  for (const h in a) {
    const m = e.getValue(h, e.latestValues[h] ?? null), g = a[h];
    if (g === void 0 || f && nee(f, h))
      continue;
    const b = {
      delay: n,
      ...yA(o || {}, h)
    }, x = m.get();
    if (x !== void 0 && !m.isAnimating && !Array.isArray(g) && g === x && !b.velocity)
      continue;
    let w = !1;
    if (window.MotionHandoffAnimation) {
      const M = uB(e);
      if (M) {
        const N = window.MotionHandoffAnimation(M, h, _n);
        N !== null && (b.startTime = N, w = !0);
      }
    }
    WE(e, h);
    const S = c ?? e.shouldReduceMotion;
    m.start(vA(h, m, g, S && lB.has(h) ? { type: !1 } : b, e, w));
    const _ = m.animation;
    _ && u.push(_);
  }
  return s && Promise.all(u).then(() => {
    _n.update(() => {
      s && QQ(e, s);
    });
  }), u;
}
function qE(e, t, n = {}) {
  const r = Wf(e, t, n.type === "exit" ? e.presenceContext?.custom : void 0);
  let { transition: i = e.getDefaultTransition() || {} } = r || {};
  n.transitionOverride && (i = n.transitionOverride);
  const o = r ? () => Promise.all(wA(e, r, n)) : () => Promise.resolve(), s = e.variantChildren && e.variantChildren.size ? (c = 0) => {
    const { delayChildren: u = 0, staggerChildren: f, staggerDirection: h } = i;
    return ree(e, t, c, u, f, h, n);
  } : () => Promise.resolve(), { when: a } = i;
  if (a) {
    const [c, u] = a === "beforeChildren" ? [o, s] : [s, o];
    return c().then(() => u());
  } else
    return Promise.all([o(), s(n.delay)]);
}
function ree(e, t, n = 0, r = 0, i = 0, o = 1, s) {
  const a = [];
  for (const c of e.variantChildren)
    c.notify("AnimationStart", t), a.push(qE(c, t, {
      ...s,
      delay: n + (typeof r == "function" ? 0 : r) + sB(e.variantChildren, c, r, i, o)
    }).then(() => c.notify("AnimationComplete", t)));
  return Promise.all(a);
}
function iee(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let r;
  if (Array.isArray(t)) {
    const i = t.map((o) => qE(e, o, n));
    r = Promise.all(i);
  } else if (typeof t == "string")
    r = qE(e, t, n);
  else {
    const i = typeof t == "function" ? Wf(e, t, n.custom) : t;
    r = Promise.all(wA(e, i, n));
  }
  return r.then(() => {
    e.notify("AnimationComplete", t);
  });
}
const oee = {
  test: (e) => e === "auto",
  parse: (e) => e
}, dB = (e) => (t) => t.test(e), fB = [_h, st, Gs, Gl, PJ, DJ, oee], KD = (e) => fB.find(dB(e));
function see(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || C4(e) : !0;
}
const aee = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function lee(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [r] = n.match(lA) || [];
  if (!r)
    return e;
  const i = n.replace(r, "");
  let o = aee.has(t) ? 1 : 0;
  return r !== n && (o *= 100), t + "(" + o + i + ")";
}
const cee = /\b([a-z-]*)\(.*?\)/gu, GE = {
  ...kc,
  getAnimatableNone: (e) => {
    const t = e.match(cee);
    return t ? t.map(lee).join(" ") : e;
  }
}, ZD = {
  ..._h,
  transform: Math.round
}, uee = {
  rotate: Gl,
  rotateX: Gl,
  rotateY: Gl,
  rotateZ: Gl,
  scale: Tv,
  scaleX: Tv,
  scaleY: Tv,
  scaleZ: Tv,
  skew: Gl,
  skewX: Gl,
  skewY: Gl,
  distance: st,
  translateX: st,
  translateY: st,
  translateZ: st,
  x: st,
  y: st,
  z: st,
  perspective: st,
  transformPerspective: st,
  opacity: qm,
  originX: PD,
  originY: PD,
  originZ: st
}, SA = {
  // Border props
  borderWidth: st,
  borderTopWidth: st,
  borderRightWidth: st,
  borderBottomWidth: st,
  borderLeftWidth: st,
  borderRadius: st,
  borderTopLeftRadius: st,
  borderTopRightRadius: st,
  borderBottomRightRadius: st,
  borderBottomLeftRadius: st,
  // Positioning props
  width: st,
  maxWidth: st,
  height: st,
  maxHeight: st,
  top: st,
  right: st,
  bottom: st,
  left: st,
  inset: st,
  insetBlock: st,
  insetBlockStart: st,
  insetBlockEnd: st,
  insetInline: st,
  insetInlineStart: st,
  insetInlineEnd: st,
  // Spacing props
  padding: st,
  paddingTop: st,
  paddingRight: st,
  paddingBottom: st,
  paddingLeft: st,
  paddingBlock: st,
  paddingBlockStart: st,
  paddingBlockEnd: st,
  paddingInline: st,
  paddingInlineStart: st,
  paddingInlineEnd: st,
  margin: st,
  marginTop: st,
  marginRight: st,
  marginBottom: st,
  marginLeft: st,
  marginBlock: st,
  marginBlockStart: st,
  marginBlockEnd: st,
  marginInline: st,
  marginInlineStart: st,
  marginInlineEnd: st,
  // Typography
  fontSize: st,
  // Misc
  backgroundPositionX: st,
  backgroundPositionY: st,
  ...uee,
  zIndex: ZD,
  // SVG
  fillOpacity: qm,
  strokeOpacity: qm,
  numOctaves: ZD
}, dee = {
  ...SA,
  // Color props
  color: Sr,
  backgroundColor: Sr,
  outlineColor: Sr,
  fill: Sr,
  stroke: Sr,
  // Border props
  borderColor: Sr,
  borderTopColor: Sr,
  borderRightColor: Sr,
  borderBottomColor: Sr,
  borderLeftColor: Sr,
  filter: GE,
  WebkitFilter: GE
}, hB = (e) => dee[e];
function pB(e, t) {
  let n = hB(e);
  return n !== GE && (n = kc), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const fee = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function hee(e, t, n) {
  let r = 0, i;
  for (; r < e.length && !i; ) {
    const o = e[r];
    typeof o == "string" && !fee.has(o) && Gm(o).values.length && (i = e[r]), r++;
  }
  if (i && n)
    for (const o of t)
      e[o] = pB(n, i);
}
class pee extends mA {
  constructor(t, n, r, i, o) {
    super(t, n, r, i, o, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: r } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let f = 0; f < t.length; f++) {
      let h = t[f];
      if (typeof h == "string" && (h = h.trim(), aA(h))) {
        const m = aB(h, n.current);
        m !== void 0 && (t[f] = m), f === t.length - 1 && (this.finalKeyframe = h);
      }
    }
    if (this.resolveNoneKeyframes(), !lB.has(r) || t.length !== 2)
      return;
    const [i, o] = t, s = KD(i), a = KD(o), c = DD(i), u = DD(o);
    if (c !== u && lc[r]) {
      this.needsMeasurement = !0;
      return;
    }
    if (s !== a)
      if (FD(s) && FD(a))
        for (let f = 0; f < t.length; f++) {
          const h = t[f];
          typeof h == "string" && (t[f] = parseFloat(h));
        }
      else lc[r] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, r = [];
    for (let i = 0; i < t.length; i++)
      (t[i] === null || see(t[i])) && r.push(i);
    r.length && hee(t, r, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: r } = this;
    if (!t || !t.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = lc[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const i = n[n.length - 1];
    i !== void 0 && t.getValue(r, i).jump(i, !1);
  }
  measureEndState() {
    const { element: t, name: n, unresolvedKeyframes: r } = this;
    if (!t || !t.current)
      return;
    const i = t.getValue(n);
    i && i.jump(this.measuredOrigin, !1);
    const o = r.length - 1, s = r[o];
    r[o] = lc[n](t.measureViewportBox(), window.getComputedStyle(t.current)), s !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = s), this.removedTransforms?.length && this.removedTransforms.forEach(([a, c]) => {
      t.getValue(a).set(c);
    }), this.resolveNoneKeyframes();
  }
}
function kA(e, t, n) {
  if (e == null)
    return [];
  if (e instanceof EventTarget)
    return [e];
  if (typeof e == "string") {
    let r = document;
    t && (r = t.current);
    const i = n?.[e] ?? r.querySelectorAll(e);
    return i ? Array.from(i) : [];
  }
  return Array.from(e).filter((r) => r != null);
}
const mB = (e, t) => t && typeof e == "number" ? t.transform(e) : e;
function KE(e) {
  return k4(e) && "offsetHeight" in e;
}
const { schedule: CA } = /* @__PURE__ */ L4(queueMicrotask, !1), rs = {
  x: !1,
  y: !1
};
function gB() {
  return rs.x || rs.y;
}
function mee(e) {
  return e === "x" || e === "y" ? rs[e] ? null : (rs[e] = !0, () => {
    rs[e] = !1;
  }) : rs.x || rs.y ? null : (rs.x = rs.y = !0, () => {
    rs.x = rs.y = !1;
  });
}
function yB(e, t) {
  const n = kA(e), r = new AbortController(), i = {
    passive: !0,
    ...t,
    signal: r.signal
  };
  return [n, i, () => r.abort()];
}
function YD(e) {
  return !(e.pointerType === "touch" || gB());
}
function gee(e, t, n = {}) {
  const [r, i, o] = yB(e, n), s = (a) => {
    if (!YD(a))
      return;
    const { target: c } = a, u = t(c, a);
    if (typeof u != "function" || !c)
      return;
    const f = (h) => {
      YD(h) && (u(h), c.removeEventListener("pointerleave", f));
    };
    c.addEventListener("pointerleave", f, i);
  };
  return r.forEach((a) => {
    a.addEventListener("pointerenter", s, i);
  }), o;
}
const vB = (e, t) => t ? e === t ? !0 : vB(e, t.parentElement) : !1, EA = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, yee = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function vee(e) {
  return yee.has(e.tagName) || e.isContentEditable === !0;
}
const bee = /* @__PURE__ */ new Set(["INPUT", "SELECT", "TEXTAREA"]);
function xee(e) {
  return bee.has(e.tagName) || e.isContentEditable === !0;
}
const v0 = /* @__PURE__ */ new WeakSet();
function XD(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function kk(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const wee = (e, t) => {
  const n = e.currentTarget;
  if (!n)
    return;
  const r = XD(() => {
    if (v0.has(n))
      return;
    kk(n, "down");
    const i = XD(() => {
      kk(n, "up");
    }), o = () => kk(n, "cancel");
    n.addEventListener("keyup", i, t), n.addEventListener("blur", o, t);
  });
  n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t);
};
function JD(e) {
  return EA(e) && !gB();
}
function See(e, t, n = {}) {
  const [r, i, o] = yB(e, n), s = (a) => {
    const c = a.currentTarget;
    if (!JD(a))
      return;
    v0.add(c);
    const u = t(c, a), f = (g, b) => {
      window.removeEventListener("pointerup", h), window.removeEventListener("pointercancel", m), v0.has(c) && v0.delete(c), JD(g) && typeof u == "function" && u(g, { success: b });
    }, h = (g) => {
      f(g, c === window || c === document || n.useGlobalTarget || vB(c, g.target));
    }, m = (g) => {
      f(g, !1);
    };
    window.addEventListener("pointerup", h, i), window.addEventListener("pointercancel", m, i);
  };
  return r.forEach((a) => {
    (n.useGlobalTarget ? window : a).addEventListener("pointerdown", s, i), KE(a) && (a.addEventListener("focus", (u) => wee(u, i)), !vee(a) && !a.hasAttribute("tabindex") && (a.tabIndex = 0));
  }), o;
}
function Kx(e) {
  return k4(e) && "ownerSVGElement" in e;
}
const b0 = /* @__PURE__ */ new WeakMap();
let x0;
const bB = (e, t, n) => (r, i) => i && i[0] ? i[0][e + "Size"] : Kx(r) && "getBBox" in r ? r.getBBox()[t] : r[n], kee = /* @__PURE__ */ bB("inline", "width", "offsetWidth"), Cee = /* @__PURE__ */ bB("block", "height", "offsetHeight");
function Eee({ target: e, borderBoxSize: t }) {
  b0.get(e)?.forEach((n) => {
    n(e, {
      get width() {
        return kee(e, t);
      },
      get height() {
        return Cee(e, t);
      }
    });
  });
}
function _ee(e) {
  e.forEach(Eee);
}
function Tee() {
  typeof ResizeObserver > "u" || (x0 = new ResizeObserver(_ee));
}
function Aee(e, t) {
  x0 || Tee();
  const n = kA(e);
  return n.forEach((r) => {
    let i = b0.get(r);
    i || (i = /* @__PURE__ */ new Set(), b0.set(r, i)), i.add(t), x0?.observe(r);
  }), () => {
    n.forEach((r) => {
      const i = b0.get(r);
      i?.delete(t), i?.size || x0?.unobserve(r);
    });
  };
}
const w0 = /* @__PURE__ */ new Set();
let Df;
function Mee() {
  Df = () => {
    const e = {
      get width() {
        return window.innerWidth;
      },
      get height() {
        return window.innerHeight;
      }
    };
    w0.forEach((t) => t(e));
  }, window.addEventListener("resize", Df);
}
function Nee(e) {
  return w0.add(e), Df || Mee(), () => {
    w0.delete(e), !w0.size && typeof Df == "function" && (window.removeEventListener("resize", Df), Df = void 0);
  };
}
function QD(e, t) {
  return typeof e == "function" ? Nee(e) : Aee(e, t);
}
function xB(e) {
  return Kx(e) && e.tagName === "svg";
}
function Ree(...e) {
  const t = !Array.isArray(e[0]), n = t ? 0 : -1, r = e[0 + n], i = e[1 + n], o = e[2 + n], s = e[3 + n], a = X4(i, o, s);
  return t ? a(r) : a;
}
const Oee = [...fB, Sr, kc], Dee = (e) => Oee.find(dB(e)), eP = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Pf = () => ({
  x: eP(),
  y: eP()
}), tP = () => ({ min: 0, max: 0 }), xr = () => ({
  x: tP(),
  y: tP()
}), ZE = { current: null }, wB = { current: !1 }, Pee = typeof window < "u";
function jee() {
  if (wB.current = !0, !!Pee)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => ZE.current = e.matches;
      e.addEventListener("change", t), t();
    } else
      ZE.current = !1;
}
const Zm = /* @__PURE__ */ new WeakMap();
function Zx(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function Ym(e) {
  return typeof e == "string" || Array.isArray(e);
}
const _A = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], TA = ["initial", ..._A];
function Yx(e) {
  return Zx(e.animate) || TA.some((t) => Ym(e[t]));
}
function SB(e) {
  return !!(Yx(e) || e.variants);
}
function Iee(e, t, n) {
  for (const r in t) {
    const i = t[r], o = n[r];
    if (Fr(i))
      e.addValue(r, i);
    else if (Fr(o))
      e.addValue(r, Cc(i, { owner: e }));
    else if (o !== i)
      if (e.hasValue(r)) {
        const s = e.getValue(r);
        s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i);
      } else {
        const s = e.getStaticValue(r);
        e.addValue(r, Cc(s !== void 0 ? s : i, { owner: e }));
      }
  }
  for (const r in n)
    t[r] === void 0 && e.removeValue(r);
  return t;
}
const nP = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
let ib = {};
function kB(e) {
  ib = e;
}
function zee() {
  return ib;
}
class CB {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, r) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: i, skipAnimations: o, blockInitialAnimation: s, visualState: a }, c = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.shouldSkipAnimations = !1, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = mA, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const g = Mi.now();
      this.renderScheduledAt < g && (this.renderScheduledAt = g, _n.render(this.render, !1, !0));
    };
    const { latestValues: u, renderState: f } = a;
    this.latestValues = u, this.baseTarget = { ...u }, this.initialValues = n.initial ? { ...u } : {}, this.renderState = f, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.skipAnimationsConfig = o, this.options = c, this.blockInitialAnimation = !!s, this.isControllingVariants = Yx(n), this.isVariantNode = SB(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: h, ...m } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const g in m) {
      const b = m[g];
      u[g] !== void 0 && Fr(b) && b.set(u[g]);
    }
  }
  mount(t) {
    this.current = t, Zm.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), this.reducedMotionConfig === "never" ? this.shouldReduceMotion = !1 : this.reducedMotionConfig === "always" ? this.shouldReduceMotion = !0 : (wB.current || jee(), this.shouldReduceMotion = ZE.current), this.shouldSkipAnimations = this.skipAnimationsConfig ?? !1, this.parent?.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), Ya(this.notifyUpdate), Ya(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features) {
      const n = this.features[t];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  addChild(t) {
    this.children.add(t), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(t);
  }
  removeChild(t) {
    this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t);
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const r = Ah.has(t);
    r && this.onBindTransform && this.onBindTransform();
    const i = n.on("change", (s) => {
      this.latestValues[t] = s, this.props.onUpdate && _n.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let o;
    typeof window < "u" && window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      i(), o && o(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in ib) {
      const n = ib[t];
      if (!n)
        continue;
      const { isEnabled: r, Feature: i } = n;
      if (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)), this.features[t]) {
        const o = this.features[t];
        o.isMounted ? o.update() : (o.mount(), o.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : xr();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < nP.length; r++) {
      const i = nP[r];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const o = "on" + i, s = t[o];
      s && (this.propEventSubscriptions[i] = this.on(i, s));
    }
    this.prevMotionValues = Iee(this, this.scrapeMotionValuesFromProps(t, this.prevProps || {}, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const r = this.values.get(t);
    n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let r = this.values.get(t);
    return r === void 0 && n !== void 0 && (r = Cc(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return r != null && (typeof r == "string" && (S4(r) || C4(r)) ? r = parseFloat(r) : !Dee(r) && kc.test(n) && (r = pB(t, n)), this.setBaseTarget(t, Fr(r) ? r.get() : r)), Fr(r) ? r.get() : r;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    const { initial: n } = this.props;
    let r;
    if (typeof n == "string" || typeof n == "object") {
      const o = bA(this.props, n, this.presenceContext?.custom);
      o && (r = o[t]);
    }
    if (n && r !== void 0)
      return r;
    const i = this.getBaseTargetFromProps(this.props, t);
    return i !== void 0 && !Fr(i) ? i : this.initialValues[t] !== void 0 && r === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new iA()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
  scheduleRenderMicrotask() {
    CA.render(this.render);
  }
}
class EB extends CB {
  constructor() {
    super(...arguments), this.KeyframeResolver = pee;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    const r = t.style;
    return r ? r[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    Fr(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
class Pc {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
function _B({ top: e, left: t, right: n, bottom: r }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: r }
  };
}
function Lee({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function Bee(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function Ck(e) {
  return e === void 0 || e === 1;
}
function YE({ scale: e, scaleX: t, scaleY: n }) {
  return !Ck(e) || !Ck(t) || !Ck(n);
}
function Tu(e) {
  return YE(e) || TB(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function TB(e) {
  return rP(e.x) || rP(e.y);
}
function rP(e) {
  return e && e !== "0%";
}
function ob(e, t, n) {
  const r = e - n, i = t * r;
  return n + i;
}
function iP(e, t, n, r, i) {
  return i !== void 0 && (e = ob(e, i, r)), ob(e, n, r) + t;
}
function XE(e, t = 0, n = 1, r, i) {
  e.min = iP(e.min, t, n, r, i), e.max = iP(e.max, t, n, r, i);
}
function AB(e, { x: t, y: n }) {
  XE(e.x, t.translate, t.scale, t.originPoint), XE(e.y, n.translate, n.scale, n.originPoint);
}
const oP = 0.999999999999, sP = 1.0000000000001;
function $ee(e, t, n, r = !1) {
  const i = n.length;
  if (!i)
    return;
  t.x = t.y = 1;
  let o, s;
  for (let a = 0; a < i; a++) {
    o = n[a], s = o.projectionDelta;
    const { visualElement: c } = o.options;
    c && c.props.style && c.props.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && If(e, {
      x: -o.scroll.offset.x,
      y: -o.scroll.offset.y
    }), s && (t.x *= s.x.scale, t.y *= s.y.scale, AB(e, s)), r && Tu(o.latestValues) && If(e, o.latestValues));
  }
  t.x < sP && t.x > oP && (t.x = 1), t.y < sP && t.y > oP && (t.y = 1);
}
function jf(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function aP(e, t, n, r, i = 0.5) {
  const o = Gn(e.min, e.max, i);
  XE(e, t, n, o, r);
}
function If(e, t) {
  aP(e.x, t.x, t.scaleX, t.scale, t.originX), aP(e.y, t.y, t.scaleY, t.scale, t.originY);
}
function MB(e, t) {
  return _B(Bee(e.getBoundingClientRect(), t));
}
function Uee(e, t, n) {
  const r = MB(e, n), { scroll: i } = t;
  return i && (jf(r.x, i.offset.x), jf(r.y, i.offset.y)), r;
}
const Fee = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, Vee = Th.length;
function Hee(e, t, n) {
  let r = "", i = !0;
  for (let o = 0; o < Vee; o++) {
    const s = Th[o], a = e[s];
    if (a === void 0)
      continue;
    let c = !0;
    if (typeof a == "number")
      c = a === (s.startsWith("scale") ? 1 : 0);
    else {
      const u = parseFloat(a);
      c = s.startsWith("scale") ? u === 1 : u === 0;
    }
    if (!c || n) {
      const u = mB(a, SA[s]);
      if (!c) {
        i = !1;
        const f = Fee[s] || s;
        r += `${f}(${u}) `;
      }
      n && (t[s] = u);
    }
  }
  return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r;
}
function AA(e, t, n) {
  const { style: r, vars: i, transformOrigin: o } = e;
  let s = !1, a = !1;
  for (const c in t) {
    const u = t[c];
    if (Ah.has(c)) {
      s = !0;
      continue;
    } else if ($4(c)) {
      i[c] = u;
      continue;
    } else {
      const f = mB(u, SA[c]);
      c.startsWith("origin") ? (a = !0, o[c] = f) : r[c] = f;
    }
  }
  if (t.transform || (s || n ? r.transform = Hee(t, e.transform, n) : r.transform && (r.transform = "none")), a) {
    const { originX: c = "50%", originY: u = "50%", originZ: f = 0 } = o;
    r.transformOrigin = `${c} ${u} ${f}`;
  }
}
function NB(e, { style: t, vars: n }, r, i) {
  const o = e.style;
  let s;
  for (s in t)
    o[s] = t[s];
  i?.applyProjectionStyles(o, r);
  for (s in n)
    o.setProperty(s, n[s]);
}
function lP(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const Kp = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (st.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = lP(e, t.target.x), r = lP(e, t.target.y);
    return `${n}% ${r}%`;
  }
}, Wee = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const r = e, i = kc.parse(e);
    if (i.length > 5)
      return r;
    const o = kc.createTransformer(e), s = typeof i[0] != "number" ? 1 : 0, a = n.x.scale * t.x, c = n.y.scale * t.y;
    i[0 + s] /= a, i[1 + s] /= c;
    const u = Gn(a, c, 0.5);
    return typeof i[2 + s] == "number" && (i[2 + s] /= u), typeof i[3 + s] == "number" && (i[3 + s] /= u), o(i);
  }
}, JE = {
  borderRadius: {
    ...Kp,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Kp,
  borderTopRightRadius: Kp,
  borderBottomLeftRadius: Kp,
  borderBottomRightRadius: Kp,
  boxShadow: Wee
};
function RB(e, { layout: t, layoutId: n }) {
  return Ah.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!JE[e] || e === "opacity");
}
function MA(e, t, n) {
  const r = e.style, i = t?.style, o = {};
  if (!r)
    return o;
  for (const s in r)
    (Fr(r[s]) || i && Fr(i[s]) || RB(s, e) || n?.getValue(s)?.liveStyle !== void 0) && (o[s] = r[s]);
  return o;
}
function qee(e) {
  return window.getComputedStyle(e);
}
class OB extends EB {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = NB;
  }
  readValueFromInstance(t, n) {
    if (Ah.has(n))
      return this.projection?.isProjecting ? LE(n) : hQ(t, n);
    {
      const r = qee(t), i = ($4(n) ? r.getPropertyValue(n) : r[n]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return MB(t, n);
  }
  build(t, n, r) {
    AA(t, n, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return MA(t, n, r);
  }
}
function Gee(e, t) {
  return e in t;
}
class Kee extends CB {
  constructor() {
    super(...arguments), this.type = "object";
  }
  readValueFromInstance(t, n) {
    if (Gee(n, t)) {
      const r = t[n];
      if (typeof r == "string" || typeof r == "number")
        return r;
    }
  }
  getBaseTargetFromProps() {
  }
  removeValueFromRenderState(t, n) {
    delete n.output[t];
  }
  measureInstanceViewportBox() {
    return xr();
  }
  build(t, n) {
    Object.assign(t.output, n);
  }
  renderInstance(t, { output: n }) {
    Object.assign(t, n);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
const Zee = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, Yee = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Xee(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1;
  const o = i ? Zee : Yee;
  e[o.offset] = `${-r}`, e[o.array] = `${t} ${n}`;
}
const Jee = [
  "offsetDistance",
  "offsetPath",
  "offsetRotate",
  "offsetAnchor"
];
function DB(e, {
  attrX: t,
  attrY: n,
  attrScale: r,
  pathLength: i,
  pathSpacing: o = 1,
  pathOffset: s = 0,
  // This is object creation, which we try to avoid per-frame.
  ...a
}, c, u, f) {
  if (AA(e, a, u), c) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: h, style: m } = e;
  h.transform && (m.transform = h.transform, delete h.transform), (m.transform || h.transformOrigin) && (m.transformOrigin = h.transformOrigin ?? "50% 50%", delete h.transformOrigin), m.transform && (m.transformBox = f?.transformBox ?? "fill-box", delete h.transformBox);
  for (const g of Jee)
    h[g] !== void 0 && (m[g] = h[g], delete h[g]);
  t !== void 0 && (h.x = t), n !== void 0 && (h.y = n), r !== void 0 && (h.scale = r), i !== void 0 && Xee(h, i, o, s, !1);
}
const PB = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]), jB = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function Qee(e, t, n, r) {
  NB(e, t, void 0, r);
  for (const i in t.attrs)
    e.setAttribute(PB.has(i) ? i : xA(i), t.attrs[i]);
}
function IB(e, t, n) {
  const r = MA(e, t, n);
  for (const i in e)
    if (Fr(e[i]) || Fr(t[i])) {
      const o = Th.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      r[o] = e[i];
    }
  return r;
}
class zB extends EB {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = xr;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (Ah.has(n)) {
      const r = hB(n);
      return r && r.default || 0;
    }
    return n = PB.has(n) ? n : xA(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, r) {
    return IB(t, n, r);
  }
  build(t, n, r) {
    DB(t, n, this.isSVGTag, r.transformTemplate, r.style);
  }
  renderInstance(t, n, r, i) {
    Qee(t, n, r, i);
  }
  mount(t) {
    this.isSVGTag = jB(t.tagName), super.mount(t);
  }
}
const ete = TA.length;
function LB(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const n = e.parent ? LB(e.parent) || {} : {};
    return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
  }
  const t = {};
  for (let n = 0; n < ete; n++) {
    const r = TA[n], i = e.props[r];
    (Ym(i) || i === !1) && (t[r] = i);
  }
  return t;
}
function BB(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const tte = [..._A].reverse(), nte = _A.length;
function rte(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: r }) => iee(e, n, r)));
}
function ite(e) {
  let t = rte(e), n = cP(), r = !0;
  const i = (c) => (u, f) => {
    const h = Wf(e, f, c === "exit" ? e.presenceContext?.custom : void 0);
    if (h) {
      const { transition: m, transitionEnd: g, ...b } = h;
      u = { ...u, ...b, ...g };
    }
    return u;
  };
  function o(c) {
    t = c(e);
  }
  function s(c) {
    const { props: u } = e, f = LB(e.parent) || {}, h = [], m = /* @__PURE__ */ new Set();
    let g = {}, b = 1 / 0;
    for (let w = 0; w < nte; w++) {
      const S = tte[w], _ = n[S], M = u[S] !== void 0 ? u[S] : f[S], N = Ym(M), P = S === c ? _.isActive : null;
      P === !1 && (b = w);
      let I = M === f[S] && M !== u[S] && N;
      if (I && r && e.manuallyAnimateOnMount && (I = !1), _.protectedKeys = { ...g }, // If it isn't active and hasn't *just* been set as inactive
      !_.isActive && P === null || // If we didn't and don't have any defined prop for this animation type
      !M && !_.prevProp || // Or if the prop doesn't define an animation
      Zx(M) || typeof M == "boolean")
        continue;
      const O = ote(_.prevProp, M);
      let L = O || // If we're making this variant active, we want to always make it active
      S === c && _.isActive && !I && N || // If we removed a higher-priority variant (i is in reverse order)
      w > b && N, U = !1;
      const B = Array.isArray(M) ? M : [M];
      let G = B.reduce(i(S), {});
      P === !1 && (G = {});
      const { prevResolvedValues: Y = {} } = _, he = {
        ...Y,
        ...G
      }, ie = (Q) => {
        L = !0, m.has(Q) && (U = !0, m.delete(Q)), _.needsAnimating[Q] = !0;
        const X = e.getValue(Q);
        X && (X.liveStyle = !1);
      };
      for (const Q in he) {
        const X = G[Q], Se = Y[Q];
        if (g.hasOwnProperty(Q))
          continue;
        let W = !1;
        HE(X) && HE(Se) ? W = !BB(X, Se) : W = X !== Se, W ? X != null ? ie(Q) : m.add(Q) : X !== void 0 && m.has(Q) ? ie(Q) : _.protectedKeys[Q] = !0;
      }
      _.prevProp = M, _.prevResolvedValues = G, _.isActive && (g = { ...g, ...G }), r && e.blockInitialAnimation && (L = !1);
      const ne = I && O;
      L && (!ne || U) && h.push(...B.map((Q) => {
        const X = { type: S };
        if (typeof Q == "string" && r && !ne && e.manuallyAnimateOnMount && e.parent) {
          const { parent: Se } = e, W = Wf(Se, Q);
          if (Se.enteringChildren && W) {
            const { delayChildren: Z } = W.transition || {};
            X.delay = sB(Se.enteringChildren, e, Z);
          }
        }
        return {
          animation: Q,
          options: X
        };
      }));
    }
    if (m.size) {
      const w = {};
      if (typeof u.initial != "boolean") {
        const S = Wf(e, Array.isArray(u.initial) ? u.initial[0] : u.initial);
        S && S.transition && (w.transition = S.transition);
      }
      m.forEach((S) => {
        const _ = e.getBaseTarget(S), M = e.getValue(S);
        M && (M.liveStyle = !0), w[S] = _ ?? null;
      }), h.push({ animation: w });
    }
    let x = !!h.length;
    return r && (u.initial === !1 || u.initial === u.animate) && !e.manuallyAnimateOnMount && (x = !1), r = !1, x ? t(h) : Promise.resolve();
  }
  function a(c, u) {
    if (n[c].isActive === u)
      return Promise.resolve();
    e.variantChildren?.forEach((h) => h.animationState?.setActive(c, u)), n[c].isActive = u;
    const f = s(c);
    for (const h in n)
      n[h].protectedKeys = {};
    return f;
  }
  return {
    animateChanges: s,
    setActive: a,
    setAnimateFunction: o,
    getState: () => n,
    reset: () => {
      n = cP();
    }
  };
}
function ote(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !BB(t, e) : !1;
}
function Su(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function cP() {
  return {
    animate: Su(!0),
    whileInView: Su(),
    whileHover: Su(),
    whileTap: Su(),
    whileDrag: Su(),
    whileFocus: Su(),
    exit: Su()
  };
}
function uP(e, t) {
  e.min = t.min, e.max = t.max;
}
function es(e, t) {
  uP(e.x, t.x), uP(e.y, t.y);
}
function dP(e, t) {
  e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin;
}
const $B = 1e-4, ste = 1 - $B, ate = 1 + $B, UB = 0.01, lte = 0 - UB, cte = 0 + UB;
function Ni(e) {
  return e.max - e.min;
}
function ute(e, t, n) {
  return Math.abs(e - t) <= n;
}
function fP(e, t, n, r = 0.5) {
  e.origin = r, e.originPoint = Gn(t.min, t.max, e.origin), e.scale = Ni(n) / Ni(t), e.translate = Gn(n.min, n.max, e.origin) - e.originPoint, (e.scale >= ste && e.scale <= ate || isNaN(e.scale)) && (e.scale = 1), (e.translate >= lte && e.translate <= cte || isNaN(e.translate)) && (e.translate = 0);
}
function _m(e, t, n, r) {
  fP(e.x, t.x, n.x, r ? r.originX : void 0), fP(e.y, t.y, n.y, r ? r.originY : void 0);
}
function hP(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + Ni(t);
}
function dte(e, t, n) {
  hP(e.x, t.x, n.x), hP(e.y, t.y, n.y);
}
function pP(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + Ni(t);
}
function sb(e, t, n) {
  pP(e.x, t.x, n.x), pP(e.y, t.y, n.y);
}
function mP(e, t, n, r, i) {
  return e -= t, e = ob(e, 1 / n, r), i !== void 0 && (e = ob(e, 1 / i, r)), e;
}
function fte(e, t = 0, n = 1, r = 0.5, i, o = e, s = e) {
  if (Gs.test(t) && (t = parseFloat(t), t = Gn(s.min, s.max, t / 100) - s.min), typeof t != "number")
    return;
  let a = Gn(o.min, o.max, r);
  e === o && (a -= t), e.min = mP(e.min, t, n, a, i), e.max = mP(e.max, t, n, a, i);
}
function gP(e, t, [n, r, i], o, s) {
  fte(e, t[n], t[r], t[i], t.scale, o, s);
}
const hte = ["x", "scaleX", "originX"], pte = ["y", "scaleY", "originY"];
function yP(e, t, n, r) {
  gP(e.x, t, hte, n ? n.x : void 0, r ? r.x : void 0), gP(e.y, t, pte, n ? n.y : void 0, r ? r.y : void 0);
}
function vP(e) {
  return e.translate === 0 && e.scale === 1;
}
function FB(e) {
  return vP(e.x) && vP(e.y);
}
function bP(e, t) {
  return e.min === t.min && e.max === t.max;
}
function mte(e, t) {
  return bP(e.x, t.x) && bP(e.y, t.y);
}
function xP(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function VB(e, t) {
  return xP(e.x, t.x) && xP(e.y, t.y);
}
function wP(e) {
  return Ni(e.x) / Ni(e.y);
}
function SP(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
function Oo(e) {
  return [e("x"), e("y")];
}
function gte(e, t, n) {
  let r = "";
  const i = e.x.translate / t.x, o = e.y.translate / t.y, s = n?.z || 0;
  if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { transformPerspective: u, rotate: f, rotateX: h, rotateY: m, skewX: g, skewY: b } = n;
    u && (r = `perspective(${u}px) ${r}`), f && (r += `rotate(${f}deg) `), h && (r += `rotateX(${h}deg) `), m && (r += `rotateY(${m}deg) `), g && (r += `skewX(${g}deg) `), b && (r += `skewY(${b}deg) `);
  }
  const a = e.x.scale * t.x, c = e.y.scale * t.y;
  return (a !== 1 || c !== 1) && (r += `scale(${a}, ${c})`), r || "none";
}
const HB = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], yte = HB.length, kP = (e) => typeof e == "string" ? parseFloat(e) : e, CP = (e) => typeof e == "number" || st.test(e);
function vte(e, t, n, r, i, o) {
  i ? (e.opacity = Gn(0, n.opacity ?? 1, bte(r)), e.opacityExit = Gn(t.opacity ?? 1, 0, xte(r))) : o && (e.opacity = Gn(t.opacity ?? 1, n.opacity ?? 1, r));
  for (let s = 0; s < yte; s++) {
    const a = `border${HB[s]}Radius`;
    let c = EP(t, a), u = EP(n, a);
    if (c === void 0 && u === void 0)
      continue;
    c || (c = 0), u || (u = 0), c === 0 || u === 0 || CP(c) === CP(u) ? (e[a] = Math.max(Gn(kP(c), kP(u), r), 0), (Gs.test(u) || Gs.test(c)) && (e[a] += "%")) : e[a] = u;
  }
  (t.rotate || n.rotate) && (e.rotate = Gn(t.rotate || 0, n.rotate || 0, r));
}
function EP(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const bte = /* @__PURE__ */ WB(0, 0.5, O4), xte = /* @__PURE__ */ WB(0.5, 0.95, $o);
function WB(e, t, n) {
  return (r) => r < e ? 0 : r > t ? 1 : n(/* @__PURE__ */ oh(e, t, r));
}
function qB(e, t, n) {
  const r = Fr(e) ? e : Cc(e);
  return r.start(vA("", r, t, n)), r.animation;
}
function Xm(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n);
}
const wte = (e, t) => e.depth - t.depth;
class Ste {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    tA(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    Pg(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(wte), this.isDirty = !1, this.children.forEach(t);
  }
}
function kte(e, t) {
  const n = Mi.now(), r = ({ timestamp: i }) => {
    const o = i - n;
    o >= t && (Ya(r), e(o - t));
  };
  return _n.setup(r, !0), () => Ya(r);
}
function S0(e) {
  return Fr(e) ? e.get() : e;
}
class Cte {
  constructor() {
    this.members = [];
  }
  add(t) {
    tA(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (Pg(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((i) => t === i);
    if (n === 0)
      return !1;
    let r;
    for (let i = n; i >= 0; i--) {
      const o = this.members[i];
      if (o.isPresent !== !1) {
        r = o;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(t, n) {
    const r = this.lead;
    if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) {
      r.instance && r.scheduleRender(), t.scheduleRender();
      const i = r.options.layoutDependency, o = t.options.layoutDependency;
      i !== void 0 && o !== void 0 && i === o || (t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0));
      const { crossfade: a } = t.options;
      a === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: r } = t;
      n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
const k0 = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
}, Ek = ["", "X", "Y", "Z"], Ete = 1e3;
let _te = 0;
function _k(e, t, n, r) {
  const { latestValues: i } = t;
  i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0));
}
function GB(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: t } = e.options;
  if (!t)
    return;
  const n = uB(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: i, layoutId: o } = e.options;
    window.MotionCancelOptimisedAnimation(n, "transform", _n, !(i || o));
  }
  const { parent: r } = e;
  r && !r.hasCheckedOptimisedAppear && GB(r);
}
function KB({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) {
  return class {
    constructor(s = {}, a = t?.()) {
      this.id = _te++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(Mte), this.nodes.forEach(Dte), this.nodes.forEach(Pte), this.nodes.forEach(Nte);
      }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = s, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let c = 0; c < this.path.length; c++)
        this.path[c].shouldResetTransform = !0;
      this.root === this && (this.nodes = new Ste());
    }
    addEventListener(s, a) {
      return this.eventHandlers.has(s) || this.eventHandlers.set(s, new iA()), this.eventHandlers.get(s).add(a);
    }
    notifyListeners(s, ...a) {
      const c = this.eventHandlers.get(s);
      c && c.notify(...a);
    }
    hasListeners(s) {
      return this.eventHandlers.has(s);
    }
    /**
     * Lifecycles
     */
    mount(s) {
      if (this.instance)
        return;
      this.isSVG = Kx(s) && !xB(s), this.instance = s;
      const { layoutId: a, layout: c, visualElement: u } = this.options;
      if (u && !u.current && u.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (c || a) && (this.isLayoutDirty = !0), e) {
        let f, h = 0;
        const m = () => this.root.updateBlockedByResize = !1;
        _n.read(() => {
          h = window.innerWidth;
        }), e(s, () => {
          const g = window.innerWidth;
          g !== h && (h = g, this.root.updateBlockedByResize = !0, f && f(), f = kte(m, 250), k0.hasAnimatedSinceResize && (k0.hasAnimatedSinceResize = !1, this.nodes.forEach(AP)));
        });
      }
      a && this.root.registerSharedNode(a, this), this.options.animate !== !1 && u && (a || c) && this.addEventListener("didUpdate", ({ delta: f, hasLayoutChanged: h, hasRelativeLayoutChanged: m, layout: g }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const b = this.options.transition || u.getDefaultTransition() || Bte, { onLayoutAnimationStart: x, onLayoutAnimationComplete: w } = u.getProps(), S = !this.targetLayout || !VB(this.targetLayout, g), _ = !h && m;
        if (this.options.layoutRoot || this.resumeFrom || _ || h && (S || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const M = {
            ...yA(b, "layout"),
            onPlay: x,
            onComplete: w
          };
          (u.shouldReduceMotion || this.options.layoutRoot) && (M.delay = 0, M.type = !1), this.startAnimation(M), this.setAnimationOrigin(f, _);
        } else
          h || AP(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = g;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const s = this.getStack();
      s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), Ya(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(jte), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: s } = this.options;
      return s && s.getProps().transformTemplate;
    }
    willUpdate(s = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && GB(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let f = 0; f < this.path.length; f++) {
        const h = this.path[f];
        h.shouldResetTransform = !0, h.updateScroll("snapshot"), h.options.layoutRoot && h.willUpdate(!1);
      }
      const { layoutId: a, layout: c } = this.options;
      if (a === void 0 && !c)
        return;
      const u = this.getTransformTemplate();
      this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(_P);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(TP);
        return;
      }
      this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(Ote), this.nodes.forEach(Tte), this.nodes.forEach(Ate)) : this.nodes.forEach(TP), this.clearAllSnapshots();
      const a = Mi.now();
      Qr.delta = Ys(0, 1e3 / 60, a - Qr.timestamp), Qr.timestamp = a, Qr.isProcessing = !0, yk.update.process(Qr), yk.preRender.process(Qr), yk.render.process(Qr), Qr.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, CA.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(Rte), this.sharedNodes.forEach(Ite);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, _n.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      _n.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !Ni(this.snapshot.measuredBox.x) && !Ni(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let c = 0; c < this.path.length; c++)
          this.path[c].updateScroll();
      const s = this.layout;
      this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = xr(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0);
    }
    updateScroll(s = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a && this.instance) {
        const c = r(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: s,
          isRoot: c,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : c
        };
      }
    }
    resetTransform() {
      if (!i)
        return;
      const s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !FB(this.projectionDelta), c = this.getTransformTemplate(), u = c ? c(this.latestValues, "") : void 0, f = u !== this.prevTransformTemplateValue;
      s && this.instance && (a || Tu(this.latestValues) || f) && (i(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(s = !0) {
      const a = this.measurePageBox();
      let c = this.removeElementScroll(a);
      return s && (c = this.removeTransform(c)), $te(c), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: c,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: s } = this.options;
      if (!s)
        return xr();
      const a = s.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(Ute))) {
        const { scroll: u } = this.root;
        u && (jf(a.x, u.offset.x), jf(a.y, u.offset.y));
      }
      return a;
    }
    removeElementScroll(s) {
      const a = xr();
      if (es(a, s), this.scroll?.wasRoot)
        return a;
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c], { scroll: f, options: h } = u;
        u !== this.root && f && h.layoutScroll && (f.wasRoot && es(a, s), jf(a.x, f.offset.x), jf(a.y, f.offset.y));
      }
      return a;
    }
    applyTransform(s, a = !1) {
      const c = xr();
      es(c, s);
      for (let u = 0; u < this.path.length; u++) {
        const f = this.path[u];
        !a && f.options.layoutScroll && f.scroll && f !== f.root && If(c, {
          x: -f.scroll.offset.x,
          y: -f.scroll.offset.y
        }), Tu(f.latestValues) && If(c, f.latestValues);
      }
      return Tu(this.latestValues) && If(c, this.latestValues), c;
    }
    removeTransform(s) {
      const a = xr();
      es(a, s);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        if (!u.instance || !Tu(u.latestValues))
          continue;
        YE(u.latestValues) && u.updateSnapshot();
        const f = xr(), h = u.measurePageBox();
        es(f, h), yP(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, f);
      }
      return Tu(this.latestValues) && yP(a, this.latestValues), a;
    }
    setTargetDelta(s) {
      this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(s) {
      this.options = {
        ...this.options,
        ...s,
        crossfade: s.crossfade !== void 0 ? s.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Qr.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(s = !1) {
      const a = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty);
      const c = !!this.resumingFrom || this !== a;
      if (!(s || c && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: f, layoutId: h } = this.options;
      if (!this.layout || !(f || h))
        return;
      this.resolvedRelativeTargetAt = Qr.timestamp;
      const m = this.getClosestProjectingParent();
      m && this.linkedParentVersion !== m.layoutVersion && !m.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (m && m.layout ? this.createRelativeTarget(m, this.layout.layoutBox, m.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = xr(), this.targetWithTransforms = xr()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), dte(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : es(this.target, this.layout.layoutBox), AB(this.target, this.targetDelta)) : es(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, m && !!m.resumingFrom == !!this.resumingFrom && !m.options.layoutScroll && m.target && this.animationProgress !== 1 ? this.createRelativeTarget(m, this.target, m.target) : this.relativeParent = this.relativeTarget = void 0));
    }
    getClosestProjectingParent() {
      if (!(!this.parent || YE(this.parent.latestValues) || TB(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    createRelativeTarget(s, a, c) {
      this.relativeParent = s, this.linkedParentVersion = s.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = xr(), this.relativeTargetOrigin = xr(), sb(this.relativeTargetOrigin, a, c), es(this.relativeTarget, this.relativeTargetOrigin);
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      const s = this.getLead(), a = !!this.resumingFrom || this !== s;
      let c = !0;
      if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (c = !1), a && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === Qr.timestamp && (c = !1), c)
        return;
      const { layout: u, layoutId: f } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || f))
        return;
      es(this.layoutCorrected, this.layout.layoutBox);
      const h = this.treeScale.x, m = this.treeScale.y;
      $ee(this.layoutCorrected, this.treeScale, this.path, a), s.layout && !s.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (s.target = s.layout.layoutBox, s.targetWithTransforms = xr());
      const { target: g } = s;
      if (!g) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (dP(this.prevProjectionDelta.x, this.projectionDelta.x), dP(this.prevProjectionDelta.y, this.projectionDelta.y)), _m(this.projectionDelta, this.layoutCorrected, g, this.latestValues), (this.treeScale.x !== h || this.treeScale.y !== m || !SP(this.projectionDelta.x, this.prevProjectionDelta.x) || !SP(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", g));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(s = !0) {
      if (this.options.visualElement?.scheduleRender(), s) {
        const a = this.getStack();
        a && a.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = Pf(), this.projectionDelta = Pf(), this.projectionDeltaWithTransform = Pf();
    }
    setAnimationOrigin(s, a = !1) {
      const c = this.snapshot, u = c ? c.latestValues : {}, f = { ...this.latestValues }, h = Pf();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const m = xr(), g = c ? c.source : void 0, b = this.layout ? this.layout.source : void 0, x = g !== b, w = this.getStack(), S = !w || w.members.length <= 1, _ = !!(x && !S && this.options.crossfade === !0 && !this.path.some(Lte));
      this.animationProgress = 0;
      let M;
      this.mixTargetDelta = (N) => {
        const P = N / 1e3;
        MP(h.x, s.x, P), MP(h.y, s.y, P), this.setTargetDelta(h), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (sb(m, this.layout.layoutBox, this.relativeParent.layout.layoutBox), zte(this.relativeTarget, this.relativeTargetOrigin, m, P), M && mte(this.relativeTarget, M) && (this.isProjectionDirty = !1), M || (M = xr()), es(M, this.relativeTarget)), x && (this.animationValues = f, vte(f, u, this.latestValues, P, _, S)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = P;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(s) {
      this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (Ya(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = _n.update(() => {
        k0.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = Cc(0)), this.currentAnimation = qB(this.motionValue, [0, 1e3], {
          ...s,
          velocity: 0,
          isSync: !0,
          onUpdate: (a) => {
            this.mixTargetDelta(a), s.onUpdate && s.onUpdate(a);
          },
          onStop: () => {
          },
          onComplete: () => {
            s.onComplete && s.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const s = this.getStack();
      s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Ete), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const s = this.getLead();
      let { targetWithTransforms: a, target: c, layout: u, latestValues: f } = s;
      if (!(!a || !c || !u)) {
        if (this !== s && this.layout && u && ZB(this.options.animationType, this.layout.layoutBox, u.layoutBox)) {
          c = this.target || xr();
          const h = Ni(this.layout.layoutBox.x);
          c.x.min = s.target.x.min, c.x.max = c.x.min + h;
          const m = Ni(this.layout.layoutBox.y);
          c.y.min = s.target.y.min, c.y.max = c.y.min + m;
        }
        es(a, c), If(a, f), _m(this.projectionDeltaWithTransform, this.layoutCorrected, a, f);
      }
    }
    registerSharedNode(s, a) {
      this.sharedNodes.has(s) || this.sharedNodes.set(s, new Cte()), this.sharedNodes.get(s).add(a);
      const u = a.options.initialPromotionConfig;
      a.promote({
        transition: u ? u.transition : void 0,
        preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const s = this.getStack();
      return s ? s.lead === this : !0;
    }
    getLead() {
      const { layoutId: s } = this.options;
      return s ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId: s } = this.options;
      return s ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId: s } = this.options;
      if (s)
        return this.root.sharedNodes.get(s);
    }
    promote({ needsReset: s, transition: a, preserveFollowOpacity: c } = {}) {
      const u = this.getStack();
      u && u.promote(this, c), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const s = this.getStack();
      return s ? s.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: s } = this.options;
      if (!s)
        return;
      let a = !1;
      const { latestValues: c } = s;
      if ((c.z || c.rotate || c.rotateX || c.rotateY || c.rotateZ || c.skewX || c.skewY) && (a = !0), !a)
        return;
      const u = {};
      c.z && _k("z", s, u, this.animationValues);
      for (let f = 0; f < Ek.length; f++)
        _k(`rotate${Ek[f]}`, s, u, this.animationValues), _k(`skew${Ek[f]}`, s, u, this.animationValues);
      s.render();
      for (const f in u)
        s.setStaticValue(f, u[f]), this.animationValues && (this.animationValues[f] = u[f]);
      s.scheduleRender();
    }
    applyProjectionStyles(s, a) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        s.visibility = "hidden";
        return;
      }
      const c = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = !1, s.visibility = "", s.opacity = "", s.pointerEvents = S0(a?.pointerEvents) || "", s.transform = c ? c(this.latestValues, "") : "none";
        return;
      }
      const u = this.getLead();
      if (!this.projectionDelta || !this.layout || !u.target) {
        this.options.layoutId && (s.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, s.pointerEvents = S0(a?.pointerEvents) || ""), this.hasProjected && !Tu(this.latestValues) && (s.transform = c ? c({}, "") : "none", this.hasProjected = !1);
        return;
      }
      s.visibility = "";
      const f = u.animationValues || u.latestValues;
      this.applyTransformsToTarget();
      let h = gte(this.projectionDeltaWithTransform, this.treeScale, f);
      c && (h = c(f, h)), s.transform = h;
      const { x: m, y: g } = this.projectionDelta;
      s.transformOrigin = `${m.origin * 100}% ${g.origin * 100}% 0`, u.animationValues ? s.opacity = u === this ? f.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : f.opacityExit : s.opacity = u === this ? f.opacity !== void 0 ? f.opacity : "" : f.opacityExit !== void 0 ? f.opacityExit : 0;
      for (const b in JE) {
        if (f[b] === void 0)
          continue;
        const { correct: x, applyTo: w, isCSSVariable: S } = JE[b], _ = h === "none" ? f[b] : x(f[b], u);
        if (w) {
          const M = w.length;
          for (let N = 0; N < M; N++)
            s[w[N]] = _;
        } else
          S ? this.options.visualElement.renderState.vars[b] = _ : s[b] = _;
      }
      this.options.layoutId && (s.pointerEvents = u === this ? S0(a?.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((s) => s.currentAnimation?.stop()), this.root.nodes.forEach(_P), this.root.sharedNodes.clear();
    }
  };
}
function Tte(e) {
  e.updateLayout();
}
function Ate(e) {
  const t = e.resumeFrom?.snapshot || e.snapshot;
  if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: r } = e.layout, { animationType: i } = e.options, o = t.source !== e.layout.source;
    i === "size" ? Oo((f) => {
      const h = o ? t.measuredBox[f] : t.layoutBox[f], m = Ni(h);
      h.min = n[f].min, h.max = h.min + m;
    }) : ZB(i, t.layoutBox, n) && Oo((f) => {
      const h = o ? t.measuredBox[f] : t.layoutBox[f], m = Ni(n[f]);
      h.max = h.min + m, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[f].max = e.relativeTarget[f].min + m);
    });
    const s = Pf();
    _m(s, n, t.layoutBox);
    const a = Pf();
    o ? _m(a, e.applyTransform(r, !0), t.measuredBox) : _m(a, n, t.layoutBox);
    const c = !FB(s);
    let u = !1;
    if (!e.resumeFrom) {
      const f = e.getClosestProjectingParent();
      if (f && !f.resumeFrom) {
        const { snapshot: h, layout: m } = f;
        if (h && m) {
          const g = xr();
          sb(g, t.layoutBox, h.layoutBox);
          const b = xr();
          sb(b, n, m.layoutBox), VB(g, b) || (u = !0), f.options.layoutRoot && (e.relativeTarget = b, e.relativeTargetOrigin = g, e.relativeParent = f);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: n,
      snapshot: t,
      delta: a,
      layoutDelta: s,
      hasLayoutChanged: c,
      hasRelativeLayoutChanged: u
    });
  } else if (e.isLead()) {
    const { onExitComplete: n } = e.options;
    n && n();
  }
  e.options.transition = void 0;
}
function Mte(e) {
  e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function Nte(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function Rte(e) {
  e.clearSnapshot();
}
function _P(e) {
  e.clearMeasurements();
}
function TP(e) {
  e.isLayoutDirty = !1;
}
function Ote(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function AP(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function Dte(e) {
  e.resolveTargetDelta();
}
function Pte(e) {
  e.calcProjection();
}
function jte(e) {
  e.resetSkewAndRotation();
}
function Ite(e) {
  e.removeLeadSnapshot();
}
function MP(e, t, n) {
  e.translate = Gn(t.translate, 0, n), e.scale = Gn(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function NP(e, t, n, r) {
  e.min = Gn(t.min, n.min, r), e.max = Gn(t.max, n.max, r);
}
function zte(e, t, n, r) {
  NP(e.x, t.x, n.x, r), NP(e.y, t.y, n.y, r);
}
function Lte(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const Bte = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, RP = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), OP = RP("applewebkit/") && !RP("chrome/") ? Math.round : $o;
function DP(e) {
  e.min = OP(e.min), e.max = OP(e.max);
}
function $te(e) {
  DP(e.x), DP(e.y);
}
function ZB(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !ute(wP(t), wP(n), 0.2);
}
function Ute(e) {
  return e !== e.root && e.scroll?.wasRoot;
}
const Fte = KB({
  attachResizeListener: (e, t) => Xm(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body?.scrollLeft || 0,
    y: document.documentElement.scrollTop || document.body?.scrollTop || 0
  }),
  checkIsScrollRoot: () => !0
}), Tk = {
  current: void 0
}, YB = KB({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!Tk.current) {
      const e = new Fte({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), Tk.current = e;
    }
    return Tk.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), Xx = C.createContext({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
});
function PP(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function Vte(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const o = PP(i, t);
      return !n && typeof o == "function" && (n = !0), o;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const o = r[i];
          typeof o == "function" ? o() : PP(e[i], null);
        }
      };
  };
}
function Hte(...e) {
  return C.useCallback(Vte(...e), e);
}
class Wte extends C.Component {
  getSnapshotBeforeUpdate(t) {
    const n = this.props.childRef.current;
    if (n && t.isPresent && !this.props.isPresent) {
      const r = n.offsetParent, i = KE(r) && r.offsetWidth || 0, o = KE(r) && r.offsetHeight || 0, s = this.props.sizeRef.current;
      s.height = n.offsetHeight || 0, s.width = n.offsetWidth || 0, s.top = n.offsetTop, s.left = n.offsetLeft, s.right = i - s.width - s.left, s.bottom = o - s.height - s.top;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function qte({ children: e, isPresent: t, anchorX: n, anchorY: r, root: i }) {
  const o = C.useId(), s = C.useRef(null), a = C.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }), { nonce: c } = C.useContext(Xx), u = e.props?.ref ?? e?.ref, f = Hte(s, u);
  return C.useInsertionEffect(() => {
    const { width: h, height: m, top: g, left: b, right: x, bottom: w } = a.current;
    if (t || !s.current || !h || !m)
      return;
    const S = n === "left" ? `left: ${b}` : `right: ${x}`, _ = r === "bottom" ? `bottom: ${w}` : `top: ${g}`;
    s.current.dataset.motionPopId = o;
    const M = document.createElement("style");
    c && (M.nonce = c);
    const N = i ?? document.head;
    return N.appendChild(M), M.sheet && M.sheet.insertRule(`
          [data-motion-pop-id="${o}"] {
            position: absolute !important;
            width: ${h}px !important;
            height: ${m}px !important;
            ${S}px !important;
            ${_}px !important;
          }
        `), () => {
      N.contains(M) && N.removeChild(M);
    };
  }, [t]), v.jsx(Wte, { isPresent: t, childRef: s, sizeRef: a, children: C.cloneElement(e, { ref: f }) });
}
const Gte = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s, anchorX: a, anchorY: c, root: u }) => {
  const f = Dg(Kte), h = C.useId();
  let m = !0, g = C.useMemo(() => (m = !1, {
    id: h,
    initial: t,
    isPresent: n,
    custom: i,
    onExitComplete: (b) => {
      f.set(b, !0);
      for (const x of f.values())
        if (!x)
          return;
      r && r();
    },
    register: (b) => (f.set(b, !1), () => f.delete(b))
  }), [n, f, r]);
  return o && m && (g = { ...g }), C.useMemo(() => {
    f.forEach((b, x) => f.set(x, !1));
  }, [n]), C.useEffect(() => {
    !n && !f.size && r && r();
  }, [n]), s === "popLayout" && (e = v.jsx(qte, { isPresent: n, anchorX: a, anchorY: c, root: u, children: e })), v.jsx(Gx.Provider, { value: g, children: e });
};
function Kte() {
  return /* @__PURE__ */ new Map();
}
function XB(e = !0) {
  const t = C.useContext(Gx);
  if (t === null)
    return [!0, null];
  const { isPresent: n, onExitComplete: r, register: i } = t, o = C.useId();
  C.useEffect(() => {
    if (e)
      return i(o);
  }, [e]);
  const s = C.useCallback(() => e && r && r(o), [o, r, e]);
  return !n && r ? [!1, s] : [!0];
}
const Av = (e) => e.key || "";
function jP(e) {
  const t = [];
  return C.Children.forEach(e, (n) => {
    C.isValidElement(n) && t.push(n);
  }), t;
}
const NA = ({ children: e, custom: t, initial: n = !0, onExitComplete: r, presenceAffectsLayout: i = !0, mode: o = "sync", propagate: s = !1, anchorX: a = "left", anchorY: c = "top", root: u }) => {
  const [f, h] = XB(s), m = C.useMemo(() => jP(e), [e]), g = s && !f ? [] : m.map(Av), b = C.useRef(!0), x = C.useRef(m), w = Dg(() => /* @__PURE__ */ new Map()), S = C.useRef(/* @__PURE__ */ new Set()), [_, M] = C.useState(m), [N, P] = C.useState(m);
  eA(() => {
    b.current = !1, x.current = m;
    for (let L = 0; L < N.length; L++) {
      const U = Av(N[L]);
      g.includes(U) ? (w.delete(U), S.current.delete(U)) : w.get(U) !== !0 && w.set(U, !1);
    }
  }, [N, g.length, g.join("-")]);
  const I = [];
  if (m !== _) {
    let L = [...m];
    for (let U = 0; U < N.length; U++) {
      const B = N[U], G = Av(B);
      g.includes(G) || (L.splice(U, 0, B), I.push(B));
    }
    return o === "wait" && I.length && (L = I), P(jP(L)), M(m), null;
  }
  const { forceRender: O } = C.useContext(QT);
  return v.jsx(v.Fragment, { children: N.map((L) => {
    const U = Av(L), B = s && !f ? !1 : m === N || g.includes(U), G = () => {
      if (S.current.has(U))
        return;
      if (S.current.add(U), w.has(U))
        w.set(U, !0);
      else
        return;
      let Y = !0;
      w.forEach((he) => {
        he || (Y = !1);
      }), Y && (O?.(), P(x.current), s && h?.(), r && r());
    };
    return v.jsx(Gte, { isPresent: B, initial: !b.current || n ? void 0 : !1, custom: t, presenceAffectsLayout: i, mode: o, root: u, onExitComplete: B ? void 0 : G, anchorX: a, anchorY: c, children: L }, U);
  }) });
}, JB = C.createContext({ strict: !1 }), IP = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
let zP = !1;
function Zte() {
  if (zP)
    return;
  const e = {};
  for (const t in IP)
    e[t] = {
      isEnabled: (n) => IP[t].some((r) => !!n[r])
    };
  kB(e), zP = !0;
}
function QB() {
  return Zte(), zee();
}
function Yte(e) {
  const t = QB();
  for (const n in e)
    t[n] = {
      ...t[n],
      ...e[n]
    };
  kB(t);
}
const Xte = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function ab(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || Xte.has(e);
}
let e6 = (e) => !ab(e);
function Jte(e) {
  typeof e == "function" && (e6 = (t) => t.startsWith("on") ? !ab(t) : e(t));
}
try {
  Jte(require("@emotion/is-prop-valid").default);
} catch {
}
function Qte(e, t, n) {
  const r = {};
  for (const i in e)
    i === "values" && typeof e.values == "object" || (e6(i) || n === !0 && ab(i) || !t && !ab(i) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]);
  return r;
}
const Jx = /* @__PURE__ */ C.createContext({});
function ene(e, t) {
  if (Yx(e)) {
    const { initial: n, animate: r } = e;
    return {
      initial: n === !1 || Ym(n) ? n : void 0,
      animate: Ym(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function tne(e) {
  const { initial: t, animate: n } = ene(e, C.useContext(Jx));
  return C.useMemo(() => ({ initial: t, animate: n }), [LP(t), LP(n)]);
}
function LP(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const RA = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function t6(e, t, n) {
  for (const r in t)
    !Fr(t[r]) && !RB(r, n) && (e[r] = t[r]);
}
function nne({ transformTemplate: e }, t) {
  return C.useMemo(() => {
    const n = RA();
    return AA(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function rne(e, t) {
  const n = e.style || {}, r = {};
  return t6(r, n, e), Object.assign(r, nne(e, t)), r;
}
function ine(e, t) {
  const n = {}, r = rne(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n;
}
const n6 = () => ({
  ...RA(),
  attrs: {}
});
function one(e, t, n, r) {
  const i = C.useMemo(() => {
    const o = n6();
    return DB(o, t, jB(r), e.transformTemplate, e.style), {
      ...o.attrs,
      style: { ...o.style }
    };
  }, [t]);
  if (e.style) {
    const o = {};
    t6(o, e.style, e), i.style = { ...o, ...i.style };
  }
  return i;
}
const sne = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function OA(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(sne.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(e))
    )
  );
}
function ane(e, t, n, { latestValues: r }, i, o = !1, s) {
  const c = (s ?? OA(e) ? one : ine)(t, r, i, e), u = Qte(t, typeof e == "string", o), f = e !== C.Fragment ? { ...u, ...c, ref: n } : {}, { children: h } = t, m = C.useMemo(() => Fr(h) ? h.get() : h, [h]);
  return C.createElement(e, {
    ...f,
    children: m
  });
}
function lne({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, i) {
  return {
    latestValues: cne(n, r, i, e),
    renderState: t()
  };
}
function cne(e, t, n, r) {
  const i = {}, o = r(e, {});
  for (const m in o)
    i[m] = S0(o[m]);
  let { initial: s, animate: a } = e;
  const c = Yx(e), u = SB(e);
  t && u && !c && e.inherit !== !1 && (s === void 0 && (s = t.initial), a === void 0 && (a = t.animate));
  let f = n ? n.initial === !1 : !1;
  f = f || s === !1;
  const h = f ? a : s;
  if (h && typeof h != "boolean" && !Zx(h)) {
    const m = Array.isArray(h) ? h : [h];
    for (let g = 0; g < m.length; g++) {
      const b = bA(e, m[g]);
      if (b) {
        const { transitionEnd: x, transition: w, ...S } = b;
        for (const _ in S) {
          let M = S[_];
          if (Array.isArray(M)) {
            const N = f ? M.length - 1 : 0;
            M = M[N];
          }
          M !== null && (i[_] = M);
        }
        for (const _ in x)
          i[_] = x[_];
      }
    }
  }
  return i;
}
const r6 = (e) => (t, n) => {
  const r = C.useContext(Jx), i = C.useContext(Gx), o = () => lne(e, t, r, i);
  return n ? o() : Dg(o);
}, une = /* @__PURE__ */ r6({
  scrapeMotionValuesFromProps: MA,
  createRenderState: RA
}), dne = /* @__PURE__ */ r6({
  scrapeMotionValuesFromProps: IB,
  createRenderState: n6
}), fne = /* @__PURE__ */ Symbol.for("motionComponentSymbol");
function hne(e, t, n) {
  const r = C.useRef(n);
  C.useInsertionEffect(() => {
    r.current = n;
  });
  const i = C.useRef(null);
  return C.useCallback((o) => {
    o && e.onMount?.(o), t && (o ? t.mount(o) : t.unmount());
    const s = r.current;
    if (typeof s == "function")
      if (o) {
        const a = s(o);
        typeof a == "function" && (i.current = a);
      } else i.current ? (i.current(), i.current = null) : s(o);
    else s && (s.current = o);
  }, [t]);
}
const i6 = C.createContext({});
function Sf(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function pne(e, t, n, r, i, o) {
  const { visualElement: s } = C.useContext(Jx), a = C.useContext(JB), c = C.useContext(Gx), u = C.useContext(Xx), f = u.reducedMotion, h = u.skipAnimations, m = C.useRef(null), g = C.useRef(!1);
  r = r || a.renderer, !m.current && r && (m.current = r(e, {
    visualState: t,
    parent: s,
    props: n,
    presenceContext: c,
    blockInitialAnimation: c ? c.initial === !1 : !1,
    reducedMotionConfig: f,
    skipAnimations: h,
    isSVG: o
  }), g.current && m.current && (m.current.manuallyAnimateOnMount = !0));
  const b = m.current, x = C.useContext(i6);
  b && !b.projection && i && (b.type === "html" || b.type === "svg") && mne(m.current, n, i, x);
  const w = C.useRef(!1);
  C.useInsertionEffect(() => {
    b && w.current && b.update(n, c);
  });
  const S = n[cB], _ = C.useRef(!!S && !window.MotionHandoffIsComplete?.(S) && window.MotionHasOptimisedAnimation?.(S));
  return eA(() => {
    g.current = !0, b && (w.current = !0, window.MotionIsMounted = !0, b.updateFeatures(), b.scheduleRenderMicrotask(), _.current && b.animationState && b.animationState.animateChanges());
  }), C.useEffect(() => {
    b && (!_.current && b.animationState && b.animationState.animateChanges(), _.current && (queueMicrotask(() => {
      window.MotionHandoffMarkAsComplete?.(S);
    }), _.current = !1), b.enteringChildren = void 0);
  }), b;
}
function mne(e, t, n, r) {
  const { layoutId: i, layout: o, drag: s, dragConstraints: a, layoutScroll: c, layoutRoot: u, layoutCrossfade: f } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : o6(e.parent)), e.projection.setOptions({
    layoutId: i,
    layout: o,
    alwaysMeasureLayout: !!s || a && Sf(a),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof o == "string" ? o : "both",
    initialPromotionConfig: r,
    crossfade: f,
    layoutScroll: c,
    layoutRoot: u
  });
}
function o6(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : o6(e.parent);
}
function Ak(e, { forwardMotionProps: t = !1, type: n } = {}, r, i) {
  r && Yte(r);
  const o = n ? n === "svg" : OA(e), s = o ? dne : une;
  function a(u, f) {
    let h;
    const m = {
      ...C.useContext(Xx),
      ...u,
      layoutId: gne(u)
    }, { isStatic: g } = m, b = tne(u), x = s(u, g);
    if (!g && w4) {
      yne();
      const w = vne(m);
      h = w.MeasureLayout, b.visualElement = pne(e, x, m, i, w.ProjectionNode, o);
    }
    return v.jsxs(Jx.Provider, { value: b, children: [h && b.visualElement ? v.jsx(h, { visualElement: b.visualElement, ...m }) : null, ane(e, u, hne(x, b.visualElement, f), x, g, t, o)] });
  }
  a.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`;
  const c = C.forwardRef(a);
  return c[fne] = e, c;
}
function gne({ layoutId: e }) {
  const t = C.useContext(QT).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function yne(e, t) {
  C.useContext(JB).strict;
}
function vne(e) {
  const t = QB(), { drag: n, layout: r } = t;
  if (!n && !r)
    return {};
  const i = { ...n, ...r };
  return {
    MeasureLayout: n?.isEnabled(e) || r?.isEnabled(e) ? i.MeasureLayout : void 0,
    ProjectionNode: i.ProjectionNode
  };
}
function bne(e, t) {
  if (typeof Proxy > "u")
    return Ak;
  const n = /* @__PURE__ */ new Map(), r = (o, s) => Ak(o, s, e, t), i = (o, s) => r(o, s);
  return new Proxy(i, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (o, s) => s === "create" ? r : (n.has(s) || n.set(s, Ak(s, void 0, e, t)), n.get(s))
  });
}
const xne = (e, t) => t.isSVG ?? OA(e) ? new zB(t) : new OB(t, {
  allowProjection: e !== C.Fragment
});
class wne extends Pc {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = ite(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    Zx(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    this.node.animationState.reset(), this.unmountControls?.();
  }
}
let Sne = 0;
class kne extends Pc {
  constructor() {
    super(...arguments), this.id = Sne++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === r)
      return;
    const i = this.node.animationState.setActive("exit", !t);
    n && !t && i.then(() => {
      n(this.id);
    });
  }
  mount() {
    const { register: t, onExitComplete: n } = this.node.presenceContext || {};
    n && n(this.id), t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const Cne = {
  animation: {
    Feature: wne
  },
  exit: {
    Feature: kne
  }
};
function Lg(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
const Ene = (e) => (t) => EA(t) && e(t, Lg(t));
function Tm(e, t, n, r) {
  return Xm(e, t, Ene(n), r);
}
const s6 = ({ current: e }) => e ? e.ownerDocument.defaultView : null, BP = (e, t) => Math.abs(e - t);
function _ne(e, t) {
  const n = BP(e.x, t.x), r = BP(e.y, t.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
const $P = /* @__PURE__ */ new Set(["auto", "scroll"]);
class a6 {
  constructor(t, n, { transformPagePoint: r, contextWindow: i = window, dragSnapToOrigin: o = !1, distanceThreshold: s = 3, element: a } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.scrollPositions = /* @__PURE__ */ new Map(), this.removeScrollListeners = null, this.onElementScroll = (g) => {
      this.handleScroll(g.target);
    }, this.onWindowScroll = () => {
      this.handleScroll(window);
    }, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const g = Nk(this.lastMoveEventInfo, this.history), b = this.startEvent !== null, x = _ne(g.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!b && !x)
        return;
      const { point: w } = g, { timestamp: S } = Qr;
      this.history.push({ ...w, timestamp: S });
      const { onStart: _, onMove: M } = this.handlers;
      b || (_ && _(this.lastMoveEvent, g), this.startEvent = this.lastMoveEvent), M && M(this.lastMoveEvent, g);
    }, this.handlePointerMove = (g, b) => {
      this.lastMoveEvent = g, this.lastMoveEventInfo = Mk(b, this.transformPagePoint), _n.update(this.updatePoint, !0);
    }, this.handlePointerUp = (g, b) => {
      this.end();
      const { onEnd: x, onSessionEnd: w, resumeAnimation: S } = this.handlers;
      if ((this.dragSnapToOrigin || !this.startEvent) && S && S(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const _ = Nk(g.type === "pointercancel" ? this.lastMoveEventInfo : Mk(b, this.transformPagePoint), this.history);
      this.startEvent && x && x(g, _), w && w(g, _);
    }, !EA(t))
      return;
    this.dragSnapToOrigin = o, this.handlers = n, this.transformPagePoint = r, this.distanceThreshold = s, this.contextWindow = i || window;
    const c = Lg(t), u = Mk(c, this.transformPagePoint), { point: f } = u, { timestamp: h } = Qr;
    this.history = [{ ...f, timestamp: h }];
    const { onSessionStart: m } = n;
    m && m(t, Nk(u, this.history)), this.removeListeners = jg(Tm(this.contextWindow, "pointermove", this.handlePointerMove), Tm(this.contextWindow, "pointerup", this.handlePointerUp), Tm(this.contextWindow, "pointercancel", this.handlePointerUp)), a && this.startScrollTracking(a);
  }
  /**
   * Start tracking scroll on ancestors and window.
   */
  startScrollTracking(t) {
    let n = t.parentElement;
    for (; n; ) {
      const r = getComputedStyle(n);
      ($P.has(r.overflowX) || $P.has(r.overflowY)) && this.scrollPositions.set(n, {
        x: n.scrollLeft,
        y: n.scrollTop
      }), n = n.parentElement;
    }
    this.scrollPositions.set(window, {
      x: window.scrollX,
      y: window.scrollY
    }), window.addEventListener("scroll", this.onElementScroll, {
      capture: !0,
      passive: !0
    }), window.addEventListener("scroll", this.onWindowScroll, {
      passive: !0
    }), this.removeScrollListeners = () => {
      window.removeEventListener("scroll", this.onElementScroll, {
        capture: !0
      }), window.removeEventListener("scroll", this.onWindowScroll);
    };
  }
  /**
   * Handle scroll compensation during drag.
   *
   * For element scroll: adjusts history origin since pageX/pageY doesn't change.
   * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.
   */
  handleScroll(t) {
    const n = this.scrollPositions.get(t);
    if (!n)
      return;
    const r = t === window, i = r ? { x: window.scrollX, y: window.scrollY } : {
      x: t.scrollLeft,
      y: t.scrollTop
    }, o = { x: i.x - n.x, y: i.y - n.y };
    o.x === 0 && o.y === 0 || (r ? this.lastMoveEventInfo && (this.lastMoveEventInfo.point.x += o.x, this.lastMoveEventInfo.point.y += o.y) : this.history.length > 0 && (this.history[0].x -= o.x, this.history[0].y -= o.y), this.scrollPositions.set(t, i), _n.update(this.updatePoint, !0));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), this.removeScrollListeners && this.removeScrollListeners(), this.scrollPositions.clear(), Ya(this.updatePoint);
  }
}
function Mk(e, t) {
  return t ? { point: t(e.point) } : e;
}
function UP(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function Nk({ point: e }, t) {
  return {
    point: e,
    delta: UP(e, l6(t)),
    offset: UP(e, Tne(t)),
    velocity: Ane(t, 0.1)
  };
}
function Tne(e) {
  return e[0];
}
function l6(e) {
  return e[e.length - 1];
}
function Ane(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, r = null;
  const i = l6(e);
  for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > /* @__PURE__ */ qs(t))); )
    n--;
  if (!r)
    return { x: 0, y: 0 };
  const o = /* @__PURE__ */ Lo(i.timestamp - r.timestamp);
  if (o === 0)
    return { x: 0, y: 0 };
  const s = {
    x: (i.x - r.x) / o,
    y: (i.y - r.y) / o
  };
  return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s;
}
function Mne(e, { min: t, max: n }, r) {
  return t !== void 0 && e < t ? e = r ? Gn(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? Gn(n, e, r.max) : Math.min(e, n)), e;
}
function FP(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function Nne(e, { top: t, left: n, bottom: r, right: i }) {
  return {
    x: FP(e.x, n, i),
    y: FP(e.y, t, r)
  };
}
function VP(e, t) {
  let n = t.min - e.min, r = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r };
}
function Rne(e, t) {
  return {
    x: VP(e.x, t.x),
    y: VP(e.y, t.y)
  };
}
function One(e, t) {
  let n = 0.5;
  const r = Ni(e), i = Ni(t);
  return i > r ? n = /* @__PURE__ */ oh(t.min, t.max - r, e.min) : r > i && (n = /* @__PURE__ */ oh(e.min, e.max - i, t.min)), Ys(0, 1, n);
}
function Dne(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const QE = 0.35;
function Pne(e = QE) {
  return e === !1 ? e = 0 : e === !0 && (e = QE), {
    x: HP(e, "left", "right"),
    y: HP(e, "top", "bottom")
  };
}
function HP(e, t, n) {
  return {
    min: WP(e, t),
    max: WP(e, n)
  };
}
function WP(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const jne = /* @__PURE__ */ new WeakMap();
class Ine {
  constructor(t) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = xr(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1, distanceThreshold: r } = {}) {
    const { presenceContext: i } = this.visualElement;
    if (i && i.isPresent === !1)
      return;
    const o = (h) => {
      n ? (this.stopAnimation(), this.snapToCursor(Lg(h).point)) : this.pauseAnimation();
    }, s = (h, m) => {
      this.stopAnimation();
      const { drag: g, dragPropagation: b, onDragStart: x } = this.getProps();
      if (g && !b && (this.openDragLock && this.openDragLock(), this.openDragLock = mee(g), !this.openDragLock))
        return;
      this.latestPointerEvent = h, this.latestPanInfo = m, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Oo((S) => {
        let _ = this.getAxisMotionValue(S).get() || 0;
        if (Gs.test(_)) {
          const { projection: M } = this.visualElement;
          if (M && M.layout) {
            const N = M.layout.layoutBox[S];
            N && (_ = Ni(N) * (parseFloat(_) / 100));
          }
        }
        this.originPoint[S] = _;
      }), x && _n.update(() => x(h, m), !1, !0), WE(this.visualElement, "transform");
      const { animationState: w } = this.visualElement;
      w && w.setActive("whileDrag", !0);
    }, a = (h, m) => {
      this.latestPointerEvent = h, this.latestPanInfo = m;
      const { dragPropagation: g, dragDirectionLock: b, onDirectionLock: x, onDrag: w } = this.getProps();
      if (!g && !this.openDragLock)
        return;
      const { offset: S } = m;
      if (b && this.currentDirection === null) {
        this.currentDirection = Lne(S), this.currentDirection !== null && x && x(this.currentDirection);
        return;
      }
      this.updateAxis("x", m.point, S), this.updateAxis("y", m.point, S), this.visualElement.render(), w && _n.update(() => w(h, m), !1, !0);
    }, c = (h, m) => {
      this.latestPointerEvent = h, this.latestPanInfo = m, this.stop(h, m), this.latestPointerEvent = null, this.latestPanInfo = null;
    }, u = () => Oo((h) => this.getAnimationState(h) === "paused" && this.getAxisMotionValue(h).animation?.play()), { dragSnapToOrigin: f } = this.getProps();
    this.panSession = new a6(t, {
      onSessionStart: o,
      onStart: s,
      onMove: a,
      onSessionEnd: c,
      resumeAnimation: u
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: f,
      distanceThreshold: r,
      contextWindow: s6(this.visualElement),
      element: this.visualElement.current
    });
  }
  /**
   * @internal
   */
  stop(t, n) {
    const r = t || this.latestPointerEvent, i = n || this.latestPanInfo, o = this.isDragging;
    if (this.cancel(), !o || !i || !r)
      return;
    const { velocity: s } = i;
    this.startAnimation(s);
    const { onDragEnd: a } = this.getProps();
    a && _n.postRender(() => a(r, i));
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.endPanSession();
    const { dragPropagation: r } = this.getProps();
    !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1);
  }
  /**
   * Clean up the pan session without modifying other drag state.
   * This is used during unmount to ensure event listeners are removed
   * without affecting projection animations or drag locks.
   * @internal
   */
  endPanSession() {
    this.panSession && this.panSession.end(), this.panSession = void 0;
  }
  updateAxis(t, n, r) {
    const { drag: i } = this.getProps();
    if (!r || !Mv(t, i, this.currentDirection))
      return;
    const o = this.getAxisMotionValue(t);
    let s = this.originPoint[t] + r[t];
    this.constraints && this.constraints[t] && (s = Mne(s, this.constraints[t], this.elastic[t])), o.set(s);
  }
  resolveConstraints() {
    const { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, i = this.constraints;
    t && Sf(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = Nne(r.layoutBox, t) : this.constraints = !1, this.elastic = Pne(n), i !== this.constraints && !Sf(t) && r && this.constraints && !this.hasMutatedConstraints && Oo((o) => {
      this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = Dne(r.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !Sf(t))
      return !1;
    const r = t.current, { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const o = Uee(r, i.root, this.visualElement.getTransformPagePoint());
    let s = Rne(i.layout.layoutBox, o);
    if (n) {
      const a = n(Lee(s));
      this.hasMutatedConstraints = !!a, a && (s = _B(a));
    }
    return s;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: o, dragSnapToOrigin: s, onDragTransitionEnd: a } = this.getProps(), c = this.constraints || {}, u = Oo((f) => {
      if (!Mv(f, n, this.currentDirection))
        return;
      let h = c && c[f] || {};
      s && (h = { min: 0, max: 0 });
      const m = i ? 200 : 1e6, g = i ? 40 : 1e7, b = {
        type: "inertia",
        velocity: r ? t[f] : 0,
        bounceStiffness: m,
        bounceDamping: g,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...o,
        ...h
      };
      return this.startAxisValueAnimation(f, b);
    });
    return Promise.all(u).then(a);
  }
  startAxisValueAnimation(t, n) {
    const r = this.getAxisMotionValue(t);
    return WE(this.visualElement, t), r.start(vA(t, r, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    Oo((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    Oo((t) => this.getAxisMotionValue(t).animation?.pause());
  }
  getAnimationState(t) {
    return this.getAxisMotionValue(t).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), i = r[n];
    return i || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    Oo((n) => {
      const { drag: r } = this.getProps();
      if (!Mv(n, r, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, o = this.getAxisMotionValue(n);
      if (i && i.layout) {
        const { min: s, max: a } = i.layout.layoutBox[n], c = o.get() || 0;
        o.set(t[n] - Gn(s, a, 0.5) + c);
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement;
    if (!Sf(n) || !r || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    Oo((s) => {
      const a = this.getAxisMotionValue(s);
      if (a && this.constraints !== !1) {
        const c = a.get();
        i[s] = One({ min: c, max: c }, this.constraints[s]);
      }
    });
    const { transformTemplate: o } = this.visualElement.getProps();
    this.visualElement.current.style.transform = o ? o({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.constraints = !1, this.resolveConstraints(), Oo((s) => {
      if (!Mv(s, t, null))
        return;
      const a = this.getAxisMotionValue(s), { min: c, max: u } = this.constraints[s];
      a.set(Gn(c, u, i[s]));
    }), this.visualElement.render();
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    jne.set(this.visualElement, this);
    const t = this.visualElement.current, n = Tm(t, "pointerdown", (u) => {
      const { drag: f, dragListener: h = !0 } = this.getProps(), m = u.target, g = m !== t && xee(m);
      f && h && !g && this.start(u);
    });
    let r;
    const i = () => {
      const { dragConstraints: u } = this.getProps();
      Sf(u) && u.current && (this.constraints = this.resolveRefConstraints(), r || (r = zne(t, u.current, () => this.scalePositionWithinConstraints())));
    }, { projection: o } = this.visualElement, s = o.addEventListener("measure", i);
    o && !o.layout && (o.root && o.root.updateScroll(), o.updateLayout()), _n.read(i);
    const a = Xm(window, "resize", () => this.scalePositionWithinConstraints()), c = o.addEventListener("didUpdate", (({ delta: u, hasLayoutChanged: f }) => {
      this.isDragging && f && (Oo((h) => {
        const m = this.getAxisMotionValue(h);
        m && (this.originPoint[h] += u[h].translate, m.set(m.get() + u[h].translate));
      }), this.visualElement.render());
    }));
    return () => {
      a(), n(), s(), c && c(), r && r();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: o = !1, dragElastic: s = QE, dragMomentum: a = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: i,
      dragConstraints: o,
      dragElastic: s,
      dragMomentum: a
    };
  }
}
function qP(e) {
  let t = !0;
  return () => {
    if (t) {
      t = !1;
      return;
    }
    e();
  };
}
function zne(e, t, n) {
  const r = QD(e, qP(n)), i = QD(t, qP(n));
  return () => {
    r(), i();
  };
}
function Mv(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function Lne(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class Bne extends Pc {
  constructor(t) {
    super(t), this.removeGroupControls = $o, this.removeListeners = $o, this.controls = new Ine(t);
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || $o;
  }
  update() {
    const { dragControls: t } = this.node.getProps(), { dragControls: n } = this.node.prevProps || {};
    t !== n && (this.removeGroupControls(), t && (this.removeGroupControls = t.subscribe(this.controls)));
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners(), this.controls.isDragging || this.controls.endPanSession();
  }
}
const Rk = (e) => (t, n) => {
  e && _n.update(() => e(t, n), !1, !0);
};
class $ne extends Pc {
  constructor() {
    super(...arguments), this.removePointerDownListener = $o;
  }
  onPointerDown(t) {
    this.session = new a6(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: s6(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps();
    return {
      onSessionStart: Rk(t),
      onStart: Rk(n),
      onMove: Rk(r),
      onEnd: (o, s) => {
        delete this.session, i && _n.postRender(() => i(o, s));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Tm(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
let Ok = !1;
class Une extends C.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: o } = t;
    o && (n.group && n.group.add(o), r && r.register && i && r.register(o), Ok && o.root.didUpdate(), o.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), o.setOptions({
      ...o.options,
      layoutDependency: this.props.layoutDependency,
      onExitComplete: () => this.safeToRemove()
    })), k0.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: r, drag: i, isPresent: o } = this.props, { projection: s } = r;
    return s && (s.isPresent = o, t.layoutDependency !== n && s.setOptions({
      ...s.options,
      layoutDependency: n
    }), Ok = !0, i || t.layoutDependency !== n || n === void 0 || t.isPresent !== o ? s.willUpdate() : this.safeToRemove(), t.isPresent !== o && (o ? s.promote() : s.relegate() || _n.postRender(() => {
      const a = s.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), CA.postRender(() => {
      !t.currentAnimation && t.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = t;
    Ok = !0, i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function c6(e) {
  const [t, n] = XB(), r = C.useContext(QT);
  return v.jsx(Une, { ...e, layoutGroup: r, switchLayoutGroup: C.useContext(i6), isPresent: t, safeToRemove: n });
}
const Fne = {
  pan: {
    Feature: $ne
  },
  drag: {
    Feature: Bne,
    ProjectionNode: YB,
    MeasureLayout: c6
  }
};
function GP(e, t, n) {
  const { props: r } = e;
  e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const i = "onHover" + n, o = r[i];
  o && _n.postRender(() => o(t, Lg(t)));
}
class Vne extends Pc {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = gee(t, (n, r) => (GP(this.node, r, "Start"), (i) => GP(this.node, i, "End"))));
  }
  unmount() {
  }
}
class Hne extends Pc {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = jg(Xm(this.node.current, "focus", () => this.onFocus()), Xm(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function KP(e, t, n) {
  const { props: r } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled)
    return;
  e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const i = "onTap" + (n === "End" ? "" : n), o = r[i];
  o && _n.postRender(() => o(t, Lg(t)));
}
class Wne extends Pc {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = See(t, (n, r) => (KP(this.node, r, "Start"), (i, { success: o }) => KP(this.node, i, o ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const e_ = /* @__PURE__ */ new WeakMap(), Dk = /* @__PURE__ */ new WeakMap(), qne = (e) => {
  const t = e_.get(e.target);
  t && t(e);
}, Gne = (e) => {
  e.forEach(qne);
};
function Kne({ root: e, ...t }) {
  const n = e || document;
  Dk.has(n) || Dk.set(n, {});
  const r = Dk.get(n), i = JSON.stringify(t);
  return r[i] || (r[i] = new IntersectionObserver(Gne, { root: e, ...t })), r[i];
}
function Zne(e, t, n) {
  const r = Kne(t);
  return e_.set(e, n), r.observe(e), () => {
    e_.delete(e), r.unobserve(e);
  };
}
const Yne = {
  some: 0,
  all: 1
};
class Xne extends Pc {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: o } = t, s = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof i == "number" ? i : Yne[i]
    }, a = (c) => {
      const { isIntersecting: u } = c;
      if (this.isInView === u || (this.isInView = u, o && !u && this.hasEnteredView))
        return;
      u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u);
      const { onViewportEnter: f, onViewportLeave: h } = this.node.getProps(), m = u ? f : h;
      m && m(c);
    };
    return Zne(this.node.current, s, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(Jne(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function Jne({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const Qne = {
  inView: {
    Feature: Xne
  },
  tap: {
    Feature: Wne
  },
  focus: {
    Feature: Hne
  },
  hover: {
    Feature: Vne
  }
}, ere = {
  layout: {
    ProjectionNode: YB,
    MeasureLayout: c6
  }
}, tre = {
  ...Cne,
  ...Qne,
  ...Fne,
  ...ere
}, qf = /* @__PURE__ */ bne(tre, xne);
function u6(e) {
  const t = Dg(() => Cc(e)), { isStatic: n } = C.useContext(Xx);
  if (n) {
    const [, r] = C.useState(e);
    C.useEffect(() => t.on("change", r), []);
  }
  return t;
}
function d6(e, t) {
  const n = u6(t()), r = () => n.set(t());
  return r(), eA(() => {
    const i = () => _n.preRender(r, !1, !0), o = e.map((s) => s.on("change", i));
    return () => {
      o.forEach((s) => s()), Ya(r);
    };
  }), n;
}
function nre(e) {
  Em.current = [], e();
  const t = d6(Em.current, e);
  return Em.current = void 0, t;
}
function rre(e, t, n, r) {
  if (typeof e == "function")
    return nre(e);
  const o = typeof t == "function" ? t : Ree(t, n, r);
  return Array.isArray(e) ? ZP(e, o) : ZP([e], ([s]) => o(s));
}
function ZP(e, t) {
  const n = Dg(() => []);
  return d6(e, () => {
    n.length = 0;
    const r = e.length;
    for (let i = 0; i < r; i++)
      n[i] = e[i].get();
    return t(n);
  });
}
function DA(e) {
  return typeof e == "object" && !Array.isArray(e);
}
function f6(e, t, n, r) {
  return e == null ? [] : typeof e == "string" && DA(t) ? kA(e, n, r) : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e.filter((i) => i != null) : [e];
}
function ire(e, t, n) {
  return e * (t + 1);
}
function YP(e, t, n, r) {
  return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : t.startsWith("<") ? Math.max(0, n + parseFloat(t.slice(1))) : r.get(t) ?? e;
}
function ore(e, t, n) {
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    i.at > t && i.at < n && (Pg(e, i), r--);
  }
}
function sre(e, t, n, r, i, o) {
  ore(e, i, o);
  for (let s = 0; s < t.length; s++)
    e.push({
      value: t[s],
      at: Gn(i, o, r[s]),
      easing: I4(n, s)
    });
}
function are(e, t) {
  for (let n = 0; n < e.length; n++)
    e[n] = e[n] / (t + 1);
}
function lre(e, t) {
  return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at;
}
const cre = "easeInOut";
function ure(e, { defaultTransition: t = {}, ...n } = {}, r, i) {
  const o = t.duration || 0.3, s = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), c = {}, u = /* @__PURE__ */ new Map();
  let f = 0, h = 0, m = 0;
  for (let g = 0; g < e.length; g++) {
    const b = e[g];
    if (typeof b == "string") {
      u.set(b, h);
      continue;
    } else if (!Array.isArray(b)) {
      u.set(b.name, YP(h, b.at, f, u));
      continue;
    }
    let [x, w, S = {}] = b;
    S.at !== void 0 && (h = YP(h, S.at, f, u));
    let _ = 0;
    const M = (N, P, I, O = 0, L = 0) => {
      const U = dre(N), { delay: B = 0, times: G = Q4(U), type: Y = t.type || "keyframes", repeat: he, repeatType: ie, repeatDelay: ne = 0, ...H } = P;
      let { ease: Q = t.ease || "easeOut", duration: X } = P;
      const Se = typeof B == "function" ? B(O, L) : B, W = U.length, Z = gA(Y) ? Y : i?.[Y || "keyframes"];
      if (W <= 2 && Z) {
        let ge = 100;
        if (W === 2 && pre(U)) {
          const xe = U[1] - U[0];
          ge = Math.abs(xe);
        }
        const re = {
          ...t,
          ...H
        };
        X !== void 0 && (re.duration = /* @__PURE__ */ qs(X));
        const J = Z4(re, ge, Z);
        Q = J.ease, X = J.duration;
      }
      X ?? (X = o);
      const pe = h + Se;
      G.length === 1 && G[0] === 0 && (G[1] = 1);
      const F = G.length - U.length;
      if (F > 0 && J4(G, F), U.length === 1 && U.unshift(null), he) {
        X = ire(X, he);
        const ge = [...U], re = [...G];
        Q = Array.isArray(Q) ? [...Q] : [Q];
        const J = [...Q];
        for (let xe = 0; xe < he; xe++) {
          U.push(...ge);
          for (let be = 0; be < ge.length; be++)
            G.push(re[be] + (xe + 1)), Q.push(be === 0 ? "linear" : I4(J, be - 1));
        }
        are(G, he);
      }
      const ee = pe + X;
      sre(I, U, Q, G, pe, ee), _ = Math.max(Se + X, _), m = Math.max(ee, m);
    };
    if (Fr(x)) {
      const N = XP(x, a);
      M(w, S, JP("default", N));
    } else {
      const N = f6(x, w, r, c), P = N.length;
      for (let I = 0; I < P; I++) {
        w = w, S = S;
        const O = N[I], L = XP(O, a);
        for (const U in w)
          M(w[U], fre(S, U), JP(U, L), I, P);
      }
    }
    f = h, h += _;
  }
  return a.forEach((g, b) => {
    for (const x in g) {
      const w = g[x];
      w.sort(lre);
      const S = [], _ = [], M = [];
      for (let O = 0; O < w.length; O++) {
        const { at: L, value: U, easing: B } = w[O];
        S.push(U), _.push(/* @__PURE__ */ oh(0, m, L)), M.push(B || "easeOut");
      }
      _[0] !== 0 && (_.unshift(0), S.unshift(S[0]), M.unshift(cre)), _[_.length - 1] !== 1 && (_.push(1), S.push(null)), s.has(b) || s.set(b, {
        keyframes: {},
        transition: {}
      });
      const N = s.get(b);
      N.keyframes[x] = S;
      const { type: P, ...I } = t;
      N.transition[x] = {
        ...I,
        duration: m,
        ease: M,
        times: _,
        ...n
      };
    }
  }), s;
}
function XP(e, t) {
  return !t.has(e) && t.set(e, {}), t.get(e);
}
function JP(e, t) {
  return t[e] || (t[e] = []), t[e];
}
function dre(e) {
  return Array.isArray(e) ? e : [e];
}
function fre(e, t) {
  return e && e[t] ? {
    ...e,
    ...e[t]
  } : { ...e };
}
const hre = (e) => typeof e == "number", pre = (e) => e.every(hre);
function mre(e) {
  const t = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, n = Kx(e) && !xB(e) ? new zB(t) : new OB(t);
  n.mount(e), Zm.set(e, n);
}
function gre(e) {
  const t = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  }, n = new Kee(t);
  n.mount(e), Zm.set(e, n);
}
function yre(e, t) {
  return Fr(e) || typeof e == "number" || typeof e == "string" && !DA(t);
}
function h6(e, t, n, r) {
  const i = [];
  if (yre(e, t))
    i.push(qB(e, DA(t) && t.default || t, n && (n.default || n)));
  else {
    if (e == null)
      return i;
    const o = f6(e, t, r), s = o.length;
    for (let a = 0; a < s; a++) {
      const c = o[a], u = c instanceof Element ? mre : gre;
      Zm.has(c) || u(c);
      const f = Zm.get(c), h = { ...n };
      "delay" in h && typeof h.delay == "function" && (h.delay = h.delay(a, s)), i.push(...wA(f, { ...t, transition: h }, {}));
    }
  }
  return i;
}
function vre(e, t, n) {
  const r = [], i = e.map((s) => {
    if (Array.isArray(s) && typeof s[0] == "function") {
      const a = s[0], c = Cc(0);
      return c.on("change", a), s.length === 1 ? [c, [0, 1]] : s.length === 2 ? [c, [0, 1], s[1]] : [c, s[1], s[2]];
    }
    return s;
  });
  return ure(i, t, n, { spring: Km }).forEach(({ keyframes: s, transition: a }, c) => {
    r.push(...h6(c, s, a));
  }), r;
}
function bre(e) {
  return Array.isArray(e) && e.some(Array.isArray);
}
function xre(e = {}) {
  const { scope: t, reduceMotion: n } = e;
  function r(i, o, s) {
    let a = [], c;
    if (bre(i))
      a = vre(i, n !== void 0 ? { reduceMotion: n, ...o } : o, t);
    else {
      const { onComplete: f, ...h } = s || {};
      typeof f == "function" && (c = f), a = h6(i, o, n !== void 0 ? { reduceMotion: n, ...h } : h, t);
    }
    const u = new LQ(a);
    return c && u.finished.then(c), t && (t.animations.push(u), u.finished.then(() => {
      Pg(t.animations, u);
    })), u;
  }
  return r;
}
const wre = xre();
var Sre = /* @__PURE__ */ Symbol.for("react.lazy"), lb = Fx[" use ".trim().toString()];
function kre(e) {
  return typeof e == "object" && e !== null && "then" in e;
}
function p6(e) {
  return e != null && typeof e == "object" && "$$typeof" in e && e.$$typeof === Sre && "_payload" in e && kre(e._payload);
}
// @__NO_SIDE_EFFECTS__
function m6(e) {
  const t = /* @__PURE__ */ Cre(e), n = C.forwardRef((r, i) => {
    let { children: o, ...s } = r;
    p6(o) && typeof lb == "function" && (o = lb(o._payload));
    const a = C.Children.toArray(o), c = a.find(_re);
    if (c) {
      const u = c.props.children, f = a.map((h) => h === c ? C.Children.count(u) > 1 ? C.Children.only(null) : C.isValidElement(u) ? u.props.children : null : h);
      return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: C.isValidElement(u) ? C.cloneElement(u, void 0, f) : null });
    }
    return /* @__PURE__ */ v.jsx(t, { ...s, ref: i, children: o });
  });
  return n.displayName = `${e}.Slot`, n;
}
var g6 = /* @__PURE__ */ m6("Slot");
// @__NO_SIDE_EFFECTS__
function Cre(e) {
  const t = C.forwardRef((n, r) => {
    let { children: i, ...o } = n;
    if (p6(i) && typeof lb == "function" && (i = lb(i._payload)), C.isValidElement(i)) {
      const s = Are(i), a = Tre(o, i.props);
      return i.type !== C.Fragment && (a.ref = r ? Og(r, s) : s), C.cloneElement(i, a);
    }
    return C.Children.count(i) > 1 ? C.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var Ere = /* @__PURE__ */ Symbol("radix.slottable");
function _re(e) {
  return C.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Ere;
}
function Tre(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], o = t[r];
    /^on[A-Z]/.test(r) ? i && o ? n[r] = (...a) => {
      const c = o(...a);
      return i(...a), c;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...o } : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function Are(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
const QP = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, ej = hc, PA = (e, t) => (n) => {
  var r;
  if (t?.variants == null) return ej(e, n?.class, n?.className);
  const { variants: i, defaultVariants: o } = t, s = Object.keys(i).map((u) => {
    const f = n?.[u], h = o?.[u];
    if (f === null) return null;
    const m = QP(f) || QP(h);
    return i[u][m];
  }), a = n && Object.entries(n).reduce((u, f) => {
    let [h, m] = f;
    return m === void 0 || (u[h] = m), u;
  }, {}), c = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((u, f) => {
    let { class: h, className: m, ...g } = f;
    return Object.entries(g).every((b) => {
      let [x, w] = b;
      return Array.isArray(w) ? w.includes({
        ...o,
        ...a
      }[x]) : {
        ...o,
        ...a
      }[x] === w;
    }) ? [
      ...u,
      h,
      m
    ] : u;
  }, []);
  return ej(e, s, c, n?.class, n?.className);
};
function Mre({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    Zs,
    {
      role: "status",
      "aria-label": "Loading",
      className: at("size-4 animate-spin", e),
      ...t
    }
  );
}
const Nre = PA(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
function Ht({
  className: e,
  variant: t,
  size: n,
  asChild: r = !1,
  isLoading: i = !1,
  ...o
}) {
  const s = r ? g6 : "button";
  return /* @__PURE__ */ v.jsxs(
    s,
    {
      "data-slot": "button",
      className: at(Nre({ variant: t, size: n, className: e })),
      ...o,
      children: [
        o.children,
        " ",
        i && /* @__PURE__ */ v.jsx(Mre, {})
      ]
    }
  );
}
function Rre(e, t = globalThis?.document) {
  const n = Dr(e);
  C.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var Ore = "DismissableLayer", t_ = "dismissableLayer.update", Dre = "dismissableLayer.pointerDownOutside", Pre = "dismissableLayer.focusOutside", tj, y6 = C.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Bg = C.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: o,
      onInteractOutside: s,
      onDismiss: a,
      ...c
    } = e, u = C.useContext(y6), [f, h] = C.useState(null), m = f?.ownerDocument ?? globalThis?.document, [, g] = C.useState({}), b = Ft(t, (O) => h(O)), x = Array.from(u.layers), [w] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), S = x.indexOf(w), _ = f ? x.indexOf(f) : -1, M = u.layersWithOutsidePointerEventsDisabled.size > 0, N = _ >= S, P = zre((O) => {
      const L = O.target, U = [...u.branches].some((B) => B.contains(L));
      !N || U || (i?.(O), s?.(O), O.defaultPrevented || a?.());
    }, m), I = Lre((O) => {
      const L = O.target;
      [...u.branches].some((B) => B.contains(L)) || (o?.(O), s?.(O), O.defaultPrevented || a?.());
    }, m);
    return Rre((O) => {
      _ === u.layers.size - 1 && (r?.(O), !O.defaultPrevented && a && (O.preventDefault(), a()));
    }, m), C.useEffect(() => {
      if (f)
        return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (tj = m.body.style.pointerEvents, m.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(f)), u.layers.add(f), nj(), () => {
          n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (m.body.style.pointerEvents = tj);
        };
    }, [f, m, n, u]), C.useEffect(() => () => {
      f && (u.layers.delete(f), u.layersWithOutsidePointerEventsDisabled.delete(f), nj());
    }, [f, u]), C.useEffect(() => {
      const O = () => g({});
      return document.addEventListener(t_, O), () => document.removeEventListener(t_, O);
    }, []), /* @__PURE__ */ v.jsx(
      Et.div,
      {
        ...c,
        ref: b,
        style: {
          pointerEvents: M ? N ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Ye(e.onFocusCapture, I.onFocusCapture),
        onBlurCapture: Ye(e.onBlurCapture, I.onBlurCapture),
        onPointerDownCapture: Ye(
          e.onPointerDownCapture,
          P.onPointerDownCapture
        )
      }
    );
  }
);
Bg.displayName = Ore;
var jre = "DismissableLayerBranch", Ire = C.forwardRef((e, t) => {
  const n = C.useContext(y6), r = C.useRef(null), i = Ft(t, r);
  return C.useEffect(() => {
    const o = r.current;
    if (o)
      return n.branches.add(o), () => {
        n.branches.delete(o);
      };
  }, [n.branches]), /* @__PURE__ */ v.jsx(Et.div, { ...e, ref: i });
});
Ire.displayName = jre;
function zre(e, t = globalThis?.document) {
  const n = Dr(e), r = C.useRef(!1), i = C.useRef(() => {
  });
  return C.useEffect(() => {
    const o = (a) => {
      if (a.target && !r.current) {
        let c = function() {
          v6(
            Dre,
            n,
            u,
            { discrete: !0 }
          );
        };
        const u = { originalEvent: a };
        a.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = c, t.addEventListener("click", i.current, { once: !0 })) : c();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      t.addEventListener("pointerdown", o);
    }, 0);
    return () => {
      window.clearTimeout(s), t.removeEventListener("pointerdown", o), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function Lre(e, t = globalThis?.document) {
  const n = Dr(e), r = C.useRef(!1);
  return C.useEffect(() => {
    const i = (o) => {
      o.target && !r.current && v6(Pre, n, { originalEvent: o }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function nj() {
  const e = new CustomEvent(t_);
  document.dispatchEvent(e);
}
function v6(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? K3(i, o) : i.dispatchEvent(o);
}
var Bre = Fx[" useId ".trim().toString()] || (() => {
}), $re = 0;
function Uo(e) {
  const [t, n] = C.useState(Bre());
  return Er(() => {
    n((r) => r ?? String($re++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
const Ure = ["top", "right", "bottom", "left"], Ec = Math.min, co = Math.max, cb = Math.round, Nv = Math.floor, Ks = (e) => ({
  x: e,
  y: e
}), Fre = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Vre = {
  start: "end",
  end: "start"
};
function n_(e, t, n) {
  return co(e, Ec(t, n));
}
function Xa(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Ja(e) {
  return e.split("-")[0];
}
function Mh(e) {
  return e.split("-")[1];
}
function jA(e) {
  return e === "x" ? "y" : "x";
}
function IA(e) {
  return e === "y" ? "height" : "width";
}
const Hre = /* @__PURE__ */ new Set(["top", "bottom"]);
function Hs(e) {
  return Hre.has(Ja(e)) ? "y" : "x";
}
function zA(e) {
  return jA(Hs(e));
}
function Wre(e, t, n) {
  n === void 0 && (n = !1);
  const r = Mh(e), i = zA(e), o = IA(i);
  let s = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (s = ub(s)), [s, ub(s)];
}
function qre(e) {
  const t = ub(e);
  return [r_(e), t, r_(t)];
}
function r_(e) {
  return e.replace(/start|end/g, (t) => Vre[t]);
}
const rj = ["left", "right"], ij = ["right", "left"], Gre = ["top", "bottom"], Kre = ["bottom", "top"];
function Zre(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? ij : rj : t ? rj : ij;
    case "left":
    case "right":
      return t ? Gre : Kre;
    default:
      return [];
  }
}
function Yre(e, t, n, r) {
  const i = Mh(e);
  let o = Zre(Ja(e), n === "start", r);
  return i && (o = o.map((s) => s + "-" + i), t && (o = o.concat(o.map(r_)))), o;
}
function ub(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Fre[t]);
}
function Xre(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function b6(e) {
  return typeof e != "number" ? Xre(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function db(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
function oj(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const o = Hs(t), s = zA(t), a = IA(s), c = Ja(t), u = o === "y", f = r.x + r.width / 2 - i.width / 2, h = r.y + r.height / 2 - i.height / 2, m = r[a] / 2 - i[a] / 2;
  let g;
  switch (c) {
    case "top":
      g = {
        x: f,
        y: r.y - i.height
      };
      break;
    case "bottom":
      g = {
        x: f,
        y: r.y + r.height
      };
      break;
    case "right":
      g = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      g = {
        x: r.x - i.width,
        y: h
      };
      break;
    default:
      g = {
        x: r.x,
        y: r.y
      };
  }
  switch (Mh(t)) {
    case "start":
      g[s] -= m * (n && u ? -1 : 1);
      break;
    case "end":
      g[s] += m * (n && u ? -1 : 1);
      break;
  }
  return g;
}
async function Jre(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: o,
    rects: s,
    elements: a,
    strategy: c
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: h = "floating",
    altBoundary: m = !1,
    padding: g = 0
  } = Xa(t, e), b = b6(g), w = a[m ? h === "floating" ? "reference" : "floating" : h], S = db(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(w))) == null || n ? w : w.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: f,
    strategy: c
  })), _ = h === "floating" ? {
    x: r,
    y: i,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, M = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), N = await (o.isElement == null ? void 0 : o.isElement(M)) ? await (o.getScale == null ? void 0 : o.getScale(M)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, P = db(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: _,
    offsetParent: M,
    strategy: c
  }) : _);
  return {
    top: (S.top - P.top + b.top) / N.y,
    bottom: (P.bottom - S.bottom + b.bottom) / N.y,
    left: (S.left - P.left + b.left) / N.x,
    right: (P.right - S.right + b.right) / N.x
  };
}
const Qre = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: o = [],
    platform: s
  } = n, a = o.filter(Boolean), c = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let u = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: f,
    y: h
  } = oj(u, r, c), m = r, g = {}, b = 0;
  for (let w = 0; w < a.length; w++) {
    var x;
    const {
      name: S,
      fn: _
    } = a[w], {
      x: M,
      y: N,
      data: P,
      reset: I
    } = await _({
      x: f,
      y: h,
      initialPlacement: r,
      placement: m,
      strategy: i,
      middlewareData: g,
      rects: u,
      platform: {
        ...s,
        detectOverflow: (x = s.detectOverflow) != null ? x : Jre
      },
      elements: {
        reference: e,
        floating: t
      }
    });
    f = M ?? f, h = N ?? h, g = {
      ...g,
      [S]: {
        ...g[S],
        ...P
      }
    }, I && b <= 50 && (b++, typeof I == "object" && (I.placement && (m = I.placement), I.rects && (u = I.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : I.rects), {
      x: f,
      y: h
    } = oj(u, m, c)), w = -1);
  }
  return {
    x: f,
    y: h,
    placement: m,
    strategy: i,
    middlewareData: g
  };
}, eie = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: o,
      platform: s,
      elements: a,
      middlewareData: c
    } = t, {
      element: u,
      padding: f = 0
    } = Xa(e, t) || {};
    if (u == null)
      return {};
    const h = b6(f), m = {
      x: n,
      y: r
    }, g = zA(i), b = IA(g), x = await s.getDimensions(u), w = g === "y", S = w ? "top" : "left", _ = w ? "bottom" : "right", M = w ? "clientHeight" : "clientWidth", N = o.reference[b] + o.reference[g] - m[g] - o.floating[b], P = m[g] - o.reference[g], I = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));
    let O = I ? I[M] : 0;
    (!O || !await (s.isElement == null ? void 0 : s.isElement(I))) && (O = a.floating[M] || o.floating[b]);
    const L = N / 2 - P / 2, U = O / 2 - x[b] / 2 - 1, B = Ec(h[S], U), G = Ec(h[_], U), Y = B, he = O - x[b] - G, ie = O / 2 - x[b] / 2 + L, ne = n_(Y, ie, he), H = !c.arrow && Mh(i) != null && ie !== ne && o.reference[b] / 2 - (ie < Y ? B : G) - x[b] / 2 < 0, Q = H ? ie < Y ? ie - Y : ie - he : 0;
    return {
      [g]: m[g] + Q,
      data: {
        [g]: ne,
        centerOffset: ie - ne - Q,
        ...H && {
          alignmentOffset: Q
        }
      },
      reset: H
    };
  }
}), tie = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        middlewareData: o,
        rects: s,
        initialPlacement: a,
        platform: c,
        elements: u
      } = t, {
        mainAxis: f = !0,
        crossAxis: h = !0,
        fallbackPlacements: m,
        fallbackStrategy: g = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: x = !0,
        ...w
      } = Xa(e, t);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const S = Ja(i), _ = Hs(a), M = Ja(a) === a, N = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)), P = m || (M || !x ? [ub(a)] : qre(a)), I = b !== "none";
      !m && I && P.push(...Yre(a, x, b, N));
      const O = [a, ...P], L = await c.detectOverflow(t, w), U = [];
      let B = ((r = o.flip) == null ? void 0 : r.overflows) || [];
      if (f && U.push(L[S]), h) {
        const ie = Wre(i, s, N);
        U.push(L[ie[0]], L[ie[1]]);
      }
      if (B = [...B, {
        placement: i,
        overflows: U
      }], !U.every((ie) => ie <= 0)) {
        var G, Y;
        const ie = (((G = o.flip) == null ? void 0 : G.index) || 0) + 1, ne = O[ie];
        if (ne && (!(h === "alignment" ? _ !== Hs(ne) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        B.every((X) => Hs(X.placement) === _ ? X.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ie,
              overflows: B
            },
            reset: {
              placement: ne
            }
          };
        let H = (Y = B.filter((Q) => Q.overflows[0] <= 0).sort((Q, X) => Q.overflows[1] - X.overflows[1])[0]) == null ? void 0 : Y.placement;
        if (!H)
          switch (g) {
            case "bestFit": {
              var he;
              const Q = (he = B.filter((X) => {
                if (I) {
                  const Se = Hs(X.placement);
                  return Se === _ || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Se === "y";
                }
                return !0;
              }).map((X) => [X.placement, X.overflows.filter((Se) => Se > 0).reduce((Se, W) => Se + W, 0)]).sort((X, Se) => X[1] - Se[1])[0]) == null ? void 0 : he[0];
              Q && (H = Q);
              break;
            }
            case "initialPlacement":
              H = a;
              break;
          }
        if (i !== H)
          return {
            reset: {
              placement: H
            }
          };
      }
      return {};
    }
  };
};
function sj(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function aj(e) {
  return Ure.some((t) => e[t] >= 0);
}
const nie = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n,
        platform: r
      } = t, {
        strategy: i = "referenceHidden",
        ...o
      } = Xa(e, t);
      switch (i) {
        case "referenceHidden": {
          const s = await r.detectOverflow(t, {
            ...o,
            elementContext: "reference"
          }), a = sj(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: a,
              referenceHidden: aj(a)
            }
          };
        }
        case "escaped": {
          const s = await r.detectOverflow(t, {
            ...o,
            altBoundary: !0
          }), a = sj(s, n.floating);
          return {
            data: {
              escapedOffsets: a,
              escaped: aj(a)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, x6 = /* @__PURE__ */ new Set(["left", "top"]);
async function rie(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), s = Ja(n), a = Mh(n), c = Hs(n) === "y", u = x6.has(s) ? -1 : 1, f = o && c ? -1 : 1, h = Xa(t, e);
  let {
    mainAxis: m,
    crossAxis: g,
    alignmentAxis: b
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return a && typeof b == "number" && (g = a === "end" ? b * -1 : b), c ? {
    x: g * f,
    y: m * u
  } : {
    x: m * u,
    y: g * f
  };
}
const iie = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: o,
        placement: s,
        middlewareData: a
      } = t, c = await rie(t, e);
      return s === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
        x: i + c.x,
        y: o + c.y,
        data: {
          ...c,
          placement: s
        }
      };
    }
  };
}, oie = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i,
        platform: o
      } = t, {
        mainAxis: s = !0,
        crossAxis: a = !1,
        limiter: c = {
          fn: (S) => {
            let {
              x: _,
              y: M
            } = S;
            return {
              x: _,
              y: M
            };
          }
        },
        ...u
      } = Xa(e, t), f = {
        x: n,
        y: r
      }, h = await o.detectOverflow(t, u), m = Hs(Ja(i)), g = jA(m);
      let b = f[g], x = f[m];
      if (s) {
        const S = g === "y" ? "top" : "left", _ = g === "y" ? "bottom" : "right", M = b + h[S], N = b - h[_];
        b = n_(M, b, N);
      }
      if (a) {
        const S = m === "y" ? "top" : "left", _ = m === "y" ? "bottom" : "right", M = x + h[S], N = x - h[_];
        x = n_(M, x, N);
      }
      const w = c.fn({
        ...t,
        [g]: b,
        [m]: x
      });
      return {
        ...w,
        data: {
          x: w.x - n,
          y: w.y - r,
          enabled: {
            [g]: s,
            [m]: a
          }
        }
      };
    }
  };
}, sie = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: i,
        rects: o,
        middlewareData: s
      } = t, {
        offset: a = 0,
        mainAxis: c = !0,
        crossAxis: u = !0
      } = Xa(e, t), f = {
        x: n,
        y: r
      }, h = Hs(i), m = jA(h);
      let g = f[m], b = f[h];
      const x = Xa(a, t), w = typeof x == "number" ? {
        mainAxis: x,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...x
      };
      if (c) {
        const M = m === "y" ? "height" : "width", N = o.reference[m] - o.floating[M] + w.mainAxis, P = o.reference[m] + o.reference[M] - w.mainAxis;
        g < N ? g = N : g > P && (g = P);
      }
      if (u) {
        var S, _;
        const M = m === "y" ? "width" : "height", N = x6.has(Ja(i)), P = o.reference[h] - o.floating[M] + (N && ((S = s.offset) == null ? void 0 : S[h]) || 0) + (N ? 0 : w.crossAxis), I = o.reference[h] + o.reference[M] + (N ? 0 : ((_ = s.offset) == null ? void 0 : _[h]) || 0) - (N ? w.crossAxis : 0);
        b < P ? b = P : b > I && (b = I);
      }
      return {
        [m]: g,
        [h]: b
      };
    }
  };
}, aie = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        rects: o,
        platform: s,
        elements: a
      } = t, {
        apply: c = () => {
        },
        ...u
      } = Xa(e, t), f = await s.detectOverflow(t, u), h = Ja(i), m = Mh(i), g = Hs(i) === "y", {
        width: b,
        height: x
      } = o.floating;
      let w, S;
      h === "top" || h === "bottom" ? (w = h, S = m === (await (s.isRTL == null ? void 0 : s.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (S = h, w = m === "end" ? "top" : "bottom");
      const _ = x - f.top - f.bottom, M = b - f.left - f.right, N = Ec(x - f[w], _), P = Ec(b - f[S], M), I = !t.middlewareData.shift;
      let O = N, L = P;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (L = M), (r = t.middlewareData.shift) != null && r.enabled.y && (O = _), I && !m) {
        const B = co(f.left, 0), G = co(f.right, 0), Y = co(f.top, 0), he = co(f.bottom, 0);
        g ? L = b - 2 * (B !== 0 || G !== 0 ? B + G : co(f.left, f.right)) : O = x - 2 * (Y !== 0 || he !== 0 ? Y + he : co(f.top, f.bottom));
      }
      await c({
        ...t,
        availableWidth: L,
        availableHeight: O
      });
      const U = await s.getDimensions(a.floating);
      return b !== U.width || x !== U.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Qx() {
  return typeof window < "u";
}
function Nh(e) {
  return w6(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function ho(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function na(e) {
  var t;
  return (t = (w6(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function w6(e) {
  return Qx() ? e instanceof Node || e instanceof ho(e).Node : !1;
}
function fs(e) {
  return Qx() ? e instanceof Element || e instanceof ho(e).Element : !1;
}
function Xs(e) {
  return Qx() ? e instanceof HTMLElement || e instanceof ho(e).HTMLElement : !1;
}
function lj(e) {
  return !Qx() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof ho(e).ShadowRoot;
}
const lie = /* @__PURE__ */ new Set(["inline", "contents"]);
function $g(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = hs(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !lie.has(i);
}
const cie = /* @__PURE__ */ new Set(["table", "td", "th"]);
function uie(e) {
  return cie.has(Nh(e));
}
const die = [":popover-open", ":modal"];
function ew(e) {
  return die.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const fie = ["transform", "translate", "scale", "rotate", "perspective"], hie = ["transform", "translate", "scale", "rotate", "perspective", "filter"], pie = ["paint", "layout", "strict", "content"];
function LA(e) {
  const t = BA(), n = fs(e) ? hs(e) : e;
  return fie.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || hie.some((r) => (n.willChange || "").includes(r)) || pie.some((r) => (n.contain || "").includes(r));
}
function mie(e) {
  let t = _c(e);
  for (; Xs(t) && !sh(t); ) {
    if (LA(t))
      return t;
    if (ew(t))
      return null;
    t = _c(t);
  }
  return null;
}
function BA() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const gie = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function sh(e) {
  return gie.has(Nh(e));
}
function hs(e) {
  return ho(e).getComputedStyle(e);
}
function tw(e) {
  return fs(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function _c(e) {
  if (Nh(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    lj(e) && e.host || // Fallback.
    na(e)
  );
  return lj(t) ? t.host : t;
}
function S6(e) {
  const t = _c(e);
  return sh(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Xs(t) && $g(t) ? t : S6(t);
}
function Jm(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = S6(e), o = i === ((r = e.ownerDocument) == null ? void 0 : r.body), s = ho(i);
  if (o) {
    const a = i_(s);
    return t.concat(s, s.visualViewport || [], $g(i) ? i : [], a && n ? Jm(a) : []);
  }
  return t.concat(i, Jm(i, [], n));
}
function i_(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function k6(e) {
  const t = hs(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = Xs(e), o = i ? e.offsetWidth : n, s = i ? e.offsetHeight : r, a = cb(n) !== o || cb(r) !== s;
  return a && (n = o, r = s), {
    width: n,
    height: r,
    $: a
  };
}
function $A(e) {
  return fs(e) ? e : e.contextElement;
}
function Gf(e) {
  const t = $A(e);
  if (!Xs(t))
    return Ks(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: o
  } = k6(t);
  let s = (o ? cb(n.width) : n.width) / r, a = (o ? cb(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const yie = /* @__PURE__ */ Ks(0);
function C6(e) {
  const t = ho(e);
  return !BA() || !t.visualViewport ? yie : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function vie(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== ho(e) ? !1 : t;
}
function Ku(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), o = $A(e);
  let s = Ks(1);
  t && (r ? fs(r) && (s = Gf(r)) : s = Gf(e));
  const a = vie(o, n, r) ? C6(o) : Ks(0);
  let c = (i.left + a.x) / s.x, u = (i.top + a.y) / s.y, f = i.width / s.x, h = i.height / s.y;
  if (o) {
    const m = ho(o), g = r && fs(r) ? ho(r) : r;
    let b = m, x = i_(b);
    for (; x && r && g !== b; ) {
      const w = Gf(x), S = x.getBoundingClientRect(), _ = hs(x), M = S.left + (x.clientLeft + parseFloat(_.paddingLeft)) * w.x, N = S.top + (x.clientTop + parseFloat(_.paddingTop)) * w.y;
      c *= w.x, u *= w.y, f *= w.x, h *= w.y, c += M, u += N, b = ho(x), x = i_(b);
    }
  }
  return db({
    width: f,
    height: h,
    x: c,
    y: u
  });
}
function nw(e, t) {
  const n = tw(e).scrollLeft;
  return t ? t.left + n : Ku(na(e)).left + n;
}
function E6(e, t) {
  const n = e.getBoundingClientRect(), r = n.left + t.scrollLeft - nw(e, n), i = n.top + t.scrollTop;
  return {
    x: r,
    y: i
  };
}
function bie(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const o = i === "fixed", s = na(r), a = t ? ew(t.floating) : !1;
  if (r === s || a && o)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = Ks(1);
  const f = Ks(0), h = Xs(r);
  if ((h || !h && !o) && ((Nh(r) !== "body" || $g(s)) && (c = tw(r)), Xs(r))) {
    const g = Ku(r);
    u = Gf(r), f.x = g.x + r.clientLeft, f.y = g.y + r.clientTop;
  }
  const m = s && !h && !o ? E6(s, c) : Ks(0);
  return {
    width: n.width * u.x,
    height: n.height * u.y,
    x: n.x * u.x - c.scrollLeft * u.x + f.x + m.x,
    y: n.y * u.y - c.scrollTop * u.y + f.y + m.y
  };
}
function xie(e) {
  return Array.from(e.getClientRects());
}
function wie(e) {
  const t = na(e), n = tw(e), r = e.ownerDocument.body, i = co(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = co(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + nw(e);
  const a = -n.scrollTop;
  return hs(r).direction === "rtl" && (s += co(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: o,
    x: s,
    y: a
  };
}
const cj = 25;
function Sie(e, t) {
  const n = ho(e), r = na(e), i = n.visualViewport;
  let o = r.clientWidth, s = r.clientHeight, a = 0, c = 0;
  if (i) {
    o = i.width, s = i.height;
    const f = BA();
    (!f || f && t === "fixed") && (a = i.offsetLeft, c = i.offsetTop);
  }
  const u = nw(r);
  if (u <= 0) {
    const f = r.ownerDocument, h = f.body, m = getComputedStyle(h), g = f.compatMode === "CSS1Compat" && parseFloat(m.marginLeft) + parseFloat(m.marginRight) || 0, b = Math.abs(r.clientWidth - h.clientWidth - g);
    b <= cj && (o -= b);
  } else u <= cj && (o += u);
  return {
    width: o,
    height: s,
    x: a,
    y: c
  };
}
const kie = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Cie(e, t) {
  const n = Ku(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = Xs(e) ? Gf(e) : Ks(1), s = e.clientWidth * o.x, a = e.clientHeight * o.y, c = i * o.x, u = r * o.y;
  return {
    width: s,
    height: a,
    x: c,
    y: u
  };
}
function uj(e, t, n) {
  let r;
  if (t === "viewport")
    r = Sie(e, n);
  else if (t === "document")
    r = wie(na(e));
  else if (fs(t))
    r = Cie(t, n);
  else {
    const i = C6(e);
    r = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return db(r);
}
function _6(e, t) {
  const n = _c(e);
  return n === t || !fs(n) || sh(n) ? !1 : hs(n).position === "fixed" || _6(n, t);
}
function Eie(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Jm(e, [], !1).filter((a) => fs(a) && Nh(a) !== "body"), i = null;
  const o = hs(e).position === "fixed";
  let s = o ? _c(e) : e;
  for (; fs(s) && !sh(s); ) {
    const a = hs(s), c = LA(s);
    !c && a.position === "fixed" && (i = null), (o ? !c && !i : !c && a.position === "static" && !!i && kie.has(i.position) || $g(s) && !c && _6(e, s)) ? r = r.filter((f) => f !== s) : i = a, s = _c(s);
  }
  return t.set(e, r), r;
}
function _ie(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const s = [...n === "clippingAncestors" ? ew(t) ? [] : Eie(t, this._c) : [].concat(n), r], a = s[0], c = s.reduce((u, f) => {
    const h = uj(t, f, i);
    return u.top = co(h.top, u.top), u.right = Ec(h.right, u.right), u.bottom = Ec(h.bottom, u.bottom), u.left = co(h.left, u.left), u;
  }, uj(t, a, i));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function Tie(e) {
  const {
    width: t,
    height: n
  } = k6(e);
  return {
    width: t,
    height: n
  };
}
function Aie(e, t, n) {
  const r = Xs(t), i = na(t), o = n === "fixed", s = Ku(e, !0, o, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = Ks(0);
  function u() {
    c.x = nw(i);
  }
  if (r || !r && !o)
    if ((Nh(t) !== "body" || $g(i)) && (a = tw(t)), r) {
      const g = Ku(t, !0, o, t);
      c.x = g.x + t.clientLeft, c.y = g.y + t.clientTop;
    } else i && u();
  o && !r && i && u();
  const f = i && !r && !o ? E6(i, a) : Ks(0), h = s.left + a.scrollLeft - c.x - f.x, m = s.top + a.scrollTop - c.y - f.y;
  return {
    x: h,
    y: m,
    width: s.width,
    height: s.height
  };
}
function Pk(e) {
  return hs(e).position === "static";
}
function dj(e, t) {
  if (!Xs(e) || hs(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return na(e) === n && (n = n.ownerDocument.body), n;
}
function T6(e, t) {
  const n = ho(e);
  if (ew(e))
    return n;
  if (!Xs(e)) {
    let i = _c(e);
    for (; i && !sh(i); ) {
      if (fs(i) && !Pk(i))
        return i;
      i = _c(i);
    }
    return n;
  }
  let r = dj(e, t);
  for (; r && uie(r) && Pk(r); )
    r = dj(r, t);
  return r && sh(r) && Pk(r) && !LA(r) ? n : r || mie(e) || n;
}
const Mie = async function(e) {
  const t = this.getOffsetParent || T6, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: Aie(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function Nie(e) {
  return hs(e).direction === "rtl";
}
const Rie = {
  convertOffsetParentRelativeRectToViewportRelativeRect: bie,
  getDocumentElement: na,
  getClippingRect: _ie,
  getOffsetParent: T6,
  getElementRects: Mie,
  getClientRects: xie,
  getDimensions: Tie,
  getScale: Gf,
  isElement: fs,
  isRTL: Nie
};
function A6(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function Oie(e, t) {
  let n = null, r;
  const i = na(e);
  function o() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
  }
  function s(a, c) {
    a === void 0 && (a = !1), c === void 0 && (c = 1), o();
    const u = e.getBoundingClientRect(), {
      left: f,
      top: h,
      width: m,
      height: g
    } = u;
    if (a || t(), !m || !g)
      return;
    const b = Nv(h), x = Nv(i.clientWidth - (f + m)), w = Nv(i.clientHeight - (h + g)), S = Nv(f), M = {
      rootMargin: -b + "px " + -x + "px " + -w + "px " + -S + "px",
      threshold: co(0, Ec(1, c)) || 1
    };
    let N = !0;
    function P(I) {
      const O = I[0].intersectionRatio;
      if (O !== c) {
        if (!N)
          return s();
        O ? s(!1, O) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      O === 1 && !A6(u, e.getBoundingClientRect()) && s(), N = !1;
    }
    try {
      n = new IntersectionObserver(P, {
        ...M,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(P, M);
    }
    n.observe(e);
  }
  return s(!0), o;
}
function Die(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, u = $A(e), f = i || o ? [...u ? Jm(u) : [], ...Jm(t)] : [];
  f.forEach((S) => {
    i && S.addEventListener("scroll", n, {
      passive: !0
    }), o && S.addEventListener("resize", n);
  });
  const h = u && a ? Oie(u, n) : null;
  let m = -1, g = null;
  s && (g = new ResizeObserver((S) => {
    let [_] = S;
    _ && _.target === u && g && (g.unobserve(t), cancelAnimationFrame(m), m = requestAnimationFrame(() => {
      var M;
      (M = g) == null || M.observe(t);
    })), n();
  }), u && !c && g.observe(u), g.observe(t));
  let b, x = c ? Ku(e) : null;
  c && w();
  function w() {
    const S = Ku(e);
    x && !A6(x, S) && n(), x = S, b = requestAnimationFrame(w);
  }
  return n(), () => {
    var S;
    f.forEach((_) => {
      i && _.removeEventListener("scroll", n), o && _.removeEventListener("resize", n);
    }), h?.(), (S = g) == null || S.disconnect(), g = null, c && cancelAnimationFrame(b);
  };
}
const Pie = iie, jie = oie, Iie = tie, zie = aie, Lie = nie, fj = eie, Bie = sie, $ie = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: Rie,
    ...n
  }, o = {
    ...i.platform,
    _c: r
  };
  return Qre(e, t, {
    ...i,
    platform: o
  });
};
var Uie = typeof document < "u", Fie = function() {
}, C0 = Uie ? C.useLayoutEffect : Fie;
function fb(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!fb(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const o = i[r];
      if (!(o === "_owner" && e.$$typeof) && !fb(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function M6(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function hj(e, t) {
  const n = M6(e);
  return Math.round(t * n) / n;
}
function jk(e) {
  const t = C.useRef(e);
  return C0(() => {
    t.current = e;
  }), t;
}
function Vie(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: o,
      floating: s
    } = {},
    transform: a = !0,
    whileElementsMounted: c,
    open: u
  } = e, [f, h] = C.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [m, g] = C.useState(r);
  fb(m, r) || g(r);
  const [b, x] = C.useState(null), [w, S] = C.useState(null), _ = C.useCallback((X) => {
    X !== I.current && (I.current = X, x(X));
  }, []), M = C.useCallback((X) => {
    X !== O.current && (O.current = X, S(X));
  }, []), N = o || b, P = s || w, I = C.useRef(null), O = C.useRef(null), L = C.useRef(f), U = c != null, B = jk(c), G = jk(i), Y = jk(u), he = C.useCallback(() => {
    if (!I.current || !O.current)
      return;
    const X = {
      placement: t,
      strategy: n,
      middleware: m
    };
    G.current && (X.platform = G.current), $ie(I.current, O.current, X).then((Se) => {
      const W = {
        ...Se,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: Y.current !== !1
      };
      ie.current && !fb(L.current, W) && (L.current = W, tl.flushSync(() => {
        h(W);
      }));
    });
  }, [m, t, n, G, Y]);
  C0(() => {
    u === !1 && L.current.isPositioned && (L.current.isPositioned = !1, h((X) => ({
      ...X,
      isPositioned: !1
    })));
  }, [u]);
  const ie = C.useRef(!1);
  C0(() => (ie.current = !0, () => {
    ie.current = !1;
  }), []), C0(() => {
    if (N && (I.current = N), P && (O.current = P), N && P) {
      if (B.current)
        return B.current(N, P, he);
      he();
    }
  }, [N, P, he, B, U]);
  const ne = C.useMemo(() => ({
    reference: I,
    floating: O,
    setReference: _,
    setFloating: M
  }), [_, M]), H = C.useMemo(() => ({
    reference: N,
    floating: P
  }), [N, P]), Q = C.useMemo(() => {
    const X = {
      position: n,
      left: 0,
      top: 0
    };
    if (!H.floating)
      return X;
    const Se = hj(H.floating, f.x), W = hj(H.floating, f.y);
    return a ? {
      ...X,
      transform: "translate(" + Se + "px, " + W + "px)",
      ...M6(H.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: Se,
      top: W
    };
  }, [n, a, H.floating, f.x, f.y]);
  return C.useMemo(() => ({
    ...f,
    update: he,
    refs: ne,
    elements: H,
    floatingStyles: Q
  }), [f, he, ne, H, Q]);
}
const Hie = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: i
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? fj({
        element: r.current,
        padding: i
      }).fn(n) : {} : r ? fj({
        element: r,
        padding: i
      }).fn(n) : {};
    }
  };
}, Wie = (e, t) => ({
  ...Pie(e),
  options: [e, t]
}), qie = (e, t) => ({
  ...jie(e),
  options: [e, t]
}), Gie = (e, t) => ({
  ...Bie(e),
  options: [e, t]
}), Kie = (e, t) => ({
  ...Iie(e),
  options: [e, t]
}), Zie = (e, t) => ({
  ...zie(e),
  options: [e, t]
}), Yie = (e, t) => ({
  ...Lie(e),
  options: [e, t]
}), Xie = (e, t) => ({
  ...Hie(e),
  options: [e, t]
});
var Jie = "Arrow", N6 = C.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: i = 5, ...o } = e;
  return /* @__PURE__ */ v.jsx(
    Et.svg,
    {
      ...o,
      ref: t,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ v.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
N6.displayName = Jie;
var Qie = N6;
function UA(e) {
  const [t, n] = C.useState(void 0);
  return Er(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const o = i[0];
        let s, a;
        if ("borderBoxSize" in o) {
          const c = o.borderBoxSize, u = Array.isArray(c) ? c[0] : c;
          s = u.inlineSize, a = u.blockSize;
        } else
          s = e.offsetWidth, a = e.offsetHeight;
        n({ width: s, height: a });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var FA = "Popper", [R6, Rh] = ps(FA), [eoe, O6] = R6(FA), D6 = (e) => {
  const { __scopePopper: t, children: n } = e, [r, i] = C.useState(null);
  return /* @__PURE__ */ v.jsx(eoe, { scope: t, anchor: r, onAnchorChange: i, children: n });
};
D6.displayName = FA;
var P6 = "PopperAnchor", j6 = C.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...i } = e, o = O6(P6, n), s = C.useRef(null), a = Ft(t, s), c = C.useRef(null);
    return C.useEffect(() => {
      const u = c.current;
      c.current = r?.current || s.current, u !== c.current && o.onAnchorChange(c.current);
    }), r ? null : /* @__PURE__ */ v.jsx(Et.div, { ...i, ref: a });
  }
);
j6.displayName = P6;
var VA = "PopperContent", [toe, noe] = R6(VA), I6 = C.forwardRef(
  (e, t) => {
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: i = 0,
      align: o = "center",
      alignOffset: s = 0,
      arrowPadding: a = 0,
      avoidCollisions: c = !0,
      collisionBoundary: u = [],
      collisionPadding: f = 0,
      sticky: h = "partial",
      hideWhenDetached: m = !1,
      updatePositionStrategy: g = "optimized",
      onPlaced: b,
      ...x
    } = e, w = O6(VA, n), [S, _] = C.useState(null), M = Ft(t, (J) => _(J)), [N, P] = C.useState(null), I = UA(N), O = I?.width ?? 0, L = I?.height ?? 0, U = r + (o !== "center" ? "-" + o : ""), B = typeof f == "number" ? f : { top: 0, right: 0, bottom: 0, left: 0, ...f }, G = Array.isArray(u) ? u : [u], Y = G.length > 0, he = {
      padding: B,
      boundary: G.filter(ioe),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: Y
    }, { refs: ie, floatingStyles: ne, placement: H, isPositioned: Q, middlewareData: X } = Vie({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: U,
      whileElementsMounted: (...J) => Die(...J, {
        animationFrame: g === "always"
      }),
      elements: {
        reference: w.anchor
      },
      middleware: [
        Wie({ mainAxis: i + L, alignmentAxis: s }),
        c && qie({
          mainAxis: !0,
          crossAxis: !1,
          limiter: h === "partial" ? Gie() : void 0,
          ...he
        }),
        c && Kie({ ...he }),
        Zie({
          ...he,
          apply: ({ elements: J, rects: xe, availableWidth: be, availableHeight: Ae }) => {
            const { width: tt, height: Ge } = xe.reference, nt = J.floating.style;
            nt.setProperty("--radix-popper-available-width", `${be}px`), nt.setProperty("--radix-popper-available-height", `${Ae}px`), nt.setProperty("--radix-popper-anchor-width", `${tt}px`), nt.setProperty("--radix-popper-anchor-height", `${Ge}px`);
          }
        }),
        N && Xie({ element: N, padding: a }),
        ooe({ arrowWidth: O, arrowHeight: L }),
        m && Yie({ strategy: "referenceHidden", ...he })
      ]
    }), [Se, W] = B6(H), Z = Dr(b);
    Er(() => {
      Q && Z?.();
    }, [Q, Z]);
    const pe = X.arrow?.x, F = X.arrow?.y, ee = X.arrow?.centerOffset !== 0, [ge, re] = C.useState();
    return Er(() => {
      S && re(window.getComputedStyle(S).zIndex);
    }, [S]), /* @__PURE__ */ v.jsx(
      "div",
      {
        ref: ie.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...ne,
          transform: Q ? ne.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: ge,
          "--radix-popper-transform-origin": [
            X.transformOrigin?.x,
            X.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...X.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ v.jsx(
          toe,
          {
            scope: n,
            placedSide: Se,
            onArrowChange: P,
            arrowX: pe,
            arrowY: F,
            shouldHideArrow: ee,
            children: /* @__PURE__ */ v.jsx(
              Et.div,
              {
                "data-side": Se,
                "data-align": W,
                ...x,
                ref: M,
                style: {
                  ...x.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: Q ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
I6.displayName = VA;
var z6 = "PopperArrow", roe = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, L6 = C.forwardRef(function(t, n) {
  const { __scopePopper: r, ...i } = t, o = noe(z6, r), s = roe[o.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ v.jsx(
      "span",
      {
        ref: o.onArrowChange,
        style: {
          position: "absolute",
          left: o.arrowX,
          top: o.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[o.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[o.placedSide],
          visibility: o.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ v.jsx(
          Qie,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
L6.displayName = z6;
function ioe(e) {
  return e !== null;
}
var ooe = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    const { placement: n, rects: r, middlewareData: i } = t, s = i.arrow?.centerOffset !== 0, a = s ? 0 : e.arrowWidth, c = s ? 0 : e.arrowHeight, [u, f] = B6(n), h = { start: "0%", center: "50%", end: "100%" }[f], m = (i.arrow?.x ?? 0) + a / 2, g = (i.arrow?.y ?? 0) + c / 2;
    let b = "", x = "";
    return u === "bottom" ? (b = s ? h : `${m}px`, x = `${-c}px`) : u === "top" ? (b = s ? h : `${m}px`, x = `${r.floating.height + c}px`) : u === "right" ? (b = `${-c}px`, x = s ? h : `${g}px`) : u === "left" && (b = `${r.floating.width + c}px`, x = s ? h : `${g}px`), { data: { x: b, y: x } };
  }
});
function B6(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var rw = D6, HA = j6, WA = I6, qA = L6, soe = "Portal", Ug = C.forwardRef((e, t) => {
  const { container: n, ...r } = e, [i, o] = C.useState(!1);
  Er(() => o(!0), []);
  const s = n || i && globalThis?.document?.body;
  return s ? q3.createPortal(/* @__PURE__ */ v.jsx(Et.div, { ...r, ref: t }), s) : null;
});
Ug.displayName = soe;
var aoe = Fx[" useInsertionEffect ".trim().toString()] || Er;
function Qa({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: r
}) {
  const [i, o, s] = loe({
    defaultProp: t,
    onChange: n
  }), a = e !== void 0, c = a ? e : i;
  {
    const f = C.useRef(e !== void 0);
    C.useEffect(() => {
      const h = f.current;
      h !== a && console.warn(
        `${r} is changing from ${h ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), f.current = a;
    }, [a, r]);
  }
  const u = C.useCallback(
    (f) => {
      if (a) {
        const h = coe(f) ? f(e) : f;
        h !== e && s.current?.(h);
      } else
        o(f);
    },
    [a, e, o, s]
  );
  return [c, u];
}
function loe({
  defaultProp: e,
  onChange: t
}) {
  const [n, r] = C.useState(e), i = C.useRef(n), o = C.useRef(t);
  return aoe(() => {
    o.current = t;
  }, [t]), C.useEffect(() => {
    i.current !== n && (o.current?.(n), i.current = n);
  }, [n, i]), [n, r, o];
}
function coe(e) {
  return typeof e == "function";
}
var $6 = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), uoe = "VisuallyHidden", U6 = C.forwardRef(
  (e, t) => /* @__PURE__ */ v.jsx(
    Et.span,
    {
      ...e,
      ref: t,
      style: { ...$6, ...e.style }
    }
  )
);
U6.displayName = uoe;
var doe = U6, [iw] = ps("Tooltip", [
  Rh
]), ow = Rh(), F6 = "TooltipProvider", foe = 700, o_ = "tooltip.open", [hoe, GA] = iw(F6), V6 = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: n = foe,
    skipDelayDuration: r = 300,
    disableHoverableContent: i = !1,
    children: o
  } = e, s = C.useRef(!0), a = C.useRef(!1), c = C.useRef(0);
  return C.useEffect(() => {
    const u = c.current;
    return () => window.clearTimeout(u);
  }, []), /* @__PURE__ */ v.jsx(
    hoe,
    {
      scope: t,
      isOpenDelayedRef: s,
      delayDuration: n,
      onOpen: C.useCallback(() => {
        window.clearTimeout(c.current), s.current = !1;
      }, []),
      onClose: C.useCallback(() => {
        window.clearTimeout(c.current), c.current = window.setTimeout(
          () => s.current = !0,
          r
        );
      }, [r]),
      isPointerInTransitRef: a,
      onPointerInTransitChange: C.useCallback((u) => {
        a.current = u;
      }, []),
      disableHoverableContent: i,
      children: o
    }
  );
};
V6.displayName = F6;
var Qm = "Tooltip", [poe, Fg] = iw(Qm), H6 = (e) => {
  const {
    __scopeTooltip: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    disableHoverableContent: s,
    delayDuration: a
  } = e, c = GA(Qm, e.__scopeTooltip), u = ow(t), [f, h] = C.useState(null), m = Uo(), g = C.useRef(0), b = s ?? c.disableHoverableContent, x = a ?? c.delayDuration, w = C.useRef(!1), [S, _] = Qa({
    prop: r,
    defaultProp: i ?? !1,
    onChange: (O) => {
      O ? (c.onOpen(), document.dispatchEvent(new CustomEvent(o_))) : c.onClose(), o?.(O);
    },
    caller: Qm
  }), M = C.useMemo(() => S ? w.current ? "delayed-open" : "instant-open" : "closed", [S]), N = C.useCallback(() => {
    window.clearTimeout(g.current), g.current = 0, w.current = !1, _(!0);
  }, [_]), P = C.useCallback(() => {
    window.clearTimeout(g.current), g.current = 0, _(!1);
  }, [_]), I = C.useCallback(() => {
    window.clearTimeout(g.current), g.current = window.setTimeout(() => {
      w.current = !0, _(!0), g.current = 0;
    }, x);
  }, [x, _]);
  return C.useEffect(() => () => {
    g.current && (window.clearTimeout(g.current), g.current = 0);
  }, []), /* @__PURE__ */ v.jsx(rw, { ...u, children: /* @__PURE__ */ v.jsx(
    poe,
    {
      scope: t,
      contentId: m,
      open: S,
      stateAttribute: M,
      trigger: f,
      onTriggerChange: h,
      onTriggerEnter: C.useCallback(() => {
        c.isOpenDelayedRef.current ? I() : N();
      }, [c.isOpenDelayedRef, I, N]),
      onTriggerLeave: C.useCallback(() => {
        b ? P() : (window.clearTimeout(g.current), g.current = 0);
      }, [P, b]),
      onOpen: N,
      onClose: P,
      disableHoverableContent: b,
      children: n
    }
  ) });
};
H6.displayName = Qm;
var s_ = "TooltipTrigger", KA = C.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = Fg(s_, n), o = GA(s_, n), s = ow(n), a = C.useRef(null), c = Ft(t, a, i.onTriggerChange), u = C.useRef(!1), f = C.useRef(!1), h = C.useCallback(() => u.current = !1, []);
    return C.useEffect(() => () => document.removeEventListener("pointerup", h), [h]), /* @__PURE__ */ v.jsx(HA, { asChild: !0, ...s, children: /* @__PURE__ */ v.jsx(
      Et.button,
      {
        "aria-describedby": i.open ? i.contentId : void 0,
        "data-state": i.stateAttribute,
        ...r,
        ref: c,
        onPointerMove: Ye(e.onPointerMove, (m) => {
          m.pointerType !== "touch" && !f.current && !o.isPointerInTransitRef.current && (i.onTriggerEnter(), f.current = !0);
        }),
        onPointerLeave: Ye(e.onPointerLeave, () => {
          i.onTriggerLeave(), f.current = !1;
        }),
        onPointerDown: Ye(e.onPointerDown, () => {
          i.open && i.onClose(), u.current = !0, document.addEventListener("pointerup", h, { once: !0 });
        }),
        onFocus: Ye(e.onFocus, () => {
          u.current || i.onOpen();
        }),
        onBlur: Ye(e.onBlur, i.onClose),
        onClick: Ye(e.onClick, i.onClose)
      }
    ) });
  }
);
KA.displayName = s_;
var ZA = "TooltipPortal", [moe, goe] = iw(ZA, {
  forceMount: void 0
}), W6 = (e) => {
  const { __scopeTooltip: t, forceMount: n, children: r, container: i } = e, o = Fg(ZA, t);
  return /* @__PURE__ */ v.jsx(moe, { scope: t, forceMount: n, children: /* @__PURE__ */ v.jsx(Di, { present: n || o.open, children: /* @__PURE__ */ v.jsx(Ug, { asChild: !0, container: i, children: r }) }) });
};
W6.displayName = ZA;
var ah = "TooltipContent", sw = C.forwardRef(
  (e, t) => {
    const n = goe(ah, e.__scopeTooltip), { forceMount: r = n.forceMount, side: i = "top", ...o } = e, s = Fg(ah, e.__scopeTooltip);
    return /* @__PURE__ */ v.jsx(Di, { present: r || s.open, children: s.disableHoverableContent ? /* @__PURE__ */ v.jsx(q6, { side: i, ...o, ref: t }) : /* @__PURE__ */ v.jsx(yoe, { side: i, ...o, ref: t }) });
  }
), yoe = C.forwardRef((e, t) => {
  const n = Fg(ah, e.__scopeTooltip), r = GA(ah, e.__scopeTooltip), i = C.useRef(null), o = Ft(t, i), [s, a] = C.useState(null), { trigger: c, onClose: u } = n, f = i.current, { onPointerInTransitChange: h } = r, m = C.useCallback(() => {
    a(null), h(!1);
  }, [h]), g = C.useCallback(
    (b, x) => {
      const w = b.currentTarget, S = { x: b.clientX, y: b.clientY }, _ = woe(S, w.getBoundingClientRect()), M = Soe(S, _), N = koe(x.getBoundingClientRect()), P = Eoe([...M, ...N]);
      a(P), h(!0);
    },
    [h]
  );
  return C.useEffect(() => () => m(), [m]), C.useEffect(() => {
    if (c && f) {
      const b = (w) => g(w, f), x = (w) => g(w, c);
      return c.addEventListener("pointerleave", b), f.addEventListener("pointerleave", x), () => {
        c.removeEventListener("pointerleave", b), f.removeEventListener("pointerleave", x);
      };
    }
  }, [c, f, g, m]), C.useEffect(() => {
    if (s) {
      const b = (x) => {
        const w = x.target, S = { x: x.clientX, y: x.clientY }, _ = c?.contains(w) || f?.contains(w), M = !Coe(S, s);
        _ ? m() : M && (m(), u());
      };
      return document.addEventListener("pointermove", b), () => document.removeEventListener("pointermove", b);
    }
  }, [c, f, s, u, m]), /* @__PURE__ */ v.jsx(q6, { ...e, ref: o });
}), [voe, boe] = iw(Qm, { isInside: !1 }), xoe = /* @__PURE__ */ tX("TooltipContent"), q6 = C.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": i,
      onEscapeKeyDown: o,
      onPointerDownOutside: s,
      ...a
    } = e, c = Fg(ah, n), u = ow(n), { onClose: f } = c;
    return C.useEffect(() => (document.addEventListener(o_, f), () => document.removeEventListener(o_, f)), [f]), C.useEffect(() => {
      if (c.trigger) {
        const h = (m) => {
          m.target?.contains(c.trigger) && f();
        };
        return window.addEventListener("scroll", h, { capture: !0 }), () => window.removeEventListener("scroll", h, { capture: !0 });
      }
    }, [c.trigger, f]), /* @__PURE__ */ v.jsx(
      Bg,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: o,
        onPointerDownOutside: s,
        onFocusOutside: (h) => h.preventDefault(),
        onDismiss: f,
        children: /* @__PURE__ */ v.jsxs(
          WA,
          {
            "data-state": c.stateAttribute,
            ...u,
            ...a,
            ref: t,
            style: {
              ...a.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ v.jsx(xoe, { children: r }),
              /* @__PURE__ */ v.jsx(voe, { scope: n, isInside: !0, children: /* @__PURE__ */ v.jsx(doe, { id: c.contentId, role: "tooltip", children: i || r }) })
            ]
          }
        )
      }
    );
  }
);
sw.displayName = ah;
var G6 = "TooltipArrow", K6 = C.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...r } = e, i = ow(n);
    return boe(
      G6,
      n
    ).isInside ? null : /* @__PURE__ */ v.jsx(qA, { ...i, ...r, ref: t });
  }
);
K6.displayName = G6;
function woe(e, t) {
  const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), i = Math.abs(t.right - e.x), o = Math.abs(t.left - e.x);
  switch (Math.min(n, r, i, o)) {
    case o:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function Soe(e, t, n = 5) {
  const r = [];
  switch (t) {
    case "top":
      r.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      r.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      r.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return r;
}
function koe(e) {
  const { top: t, right: n, bottom: r, left: i } = e;
  return [
    { x: i, y: t },
    { x: n, y: t },
    { x: n, y: r },
    { x: i, y: r }
  ];
}
function Coe(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const a = t[o], c = t[s], u = a.x, f = a.y, h = c.x, m = c.y;
    f > r != m > r && n < (h - u) * (r - f) / (m - f) + u && (i = !i);
  }
  return i;
}
function Eoe(e) {
  const t = e.slice();
  return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), _oe(t);
}
function _oe(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    for (; t.length >= 2; ) {
      const o = t[t.length - 1], s = t[t.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) t.pop();
      else break;
    }
    t.push(i);
  }
  t.pop();
  const n = [];
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1], s = n[n.length - 2];
      if ((o.x - s.x) * (i.y - s.y) >= (o.y - s.y) * (i.x - s.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var Toe = V6, Aoe = H6, Moe = KA, Noe = W6, Roe = sw, Ooe = K6;
function Oh({
  delayDuration: e = 0,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Toe,
    {
      "data-slot": "tooltip-provider",
      delayDuration: e,
      ...t
    }
  );
}
function Gi({ ...e }) {
  return /* @__PURE__ */ v.jsx(Oh, { children: /* @__PURE__ */ v.jsx(Aoe, { "data-slot": "tooltip", ...e }) });
}
function fo({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Moe, { "data-slot": "tooltip-trigger", ...e });
}
function Bo({
  className: e,
  sideOffset: t = 0,
  hasArrow: n = !1,
  children: r,
  ...i
}) {
  return /* @__PURE__ */ v.jsx(Noe, { children: /* @__PURE__ */ v.jsxs(
    Roe,
    {
      "data-slot": "tooltip-content",
      sideOffset: t,
      className: at(
        "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
        e
      ),
      ...i,
      children: [
        r,
        /* @__PURE__ */ v.jsx(
          Ooe,
          {
            className: "bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] opacity-0 bg-transparent"
          }
        )
      ]
    }
  ) });
}
const Doe = PA(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function Dh({
  className: e,
  variant: t,
  asChild: n = !1,
  ...r
}) {
  const i = n ? g6 : "span";
  return /* @__PURE__ */ v.jsx(
    i,
    {
      "data-slot": "badge",
      className: at(Doe({ variant: t }), e),
      ...r
    }
  );
}
var Ik = "focusScope.autoFocusOnMount", zk = "focusScope.autoFocusOnUnmount", pj = { bubbles: !1, cancelable: !0 }, Poe = "FocusScope", aw = C.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: o,
    ...s
  } = e, [a, c] = C.useState(null), u = Dr(i), f = Dr(o), h = C.useRef(null), m = Ft(t, (x) => c(x)), g = C.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  C.useEffect(() => {
    if (r) {
      let x = function(M) {
        if (g.paused || !a) return;
        const N = M.target;
        a.contains(N) ? h.current = N : Kl(h.current, { select: !0 });
      }, w = function(M) {
        if (g.paused || !a) return;
        const N = M.relatedTarget;
        N !== null && (a.contains(N) || Kl(h.current, { select: !0 }));
      }, S = function(M) {
        if (document.activeElement === document.body)
          for (const P of M)
            P.removedNodes.length > 0 && Kl(a);
      };
      document.addEventListener("focusin", x), document.addEventListener("focusout", w);
      const _ = new MutationObserver(S);
      return a && _.observe(a, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", x), document.removeEventListener("focusout", w), _.disconnect();
      };
    }
  }, [r, a, g.paused]), C.useEffect(() => {
    if (a) {
      gj.add(g);
      const x = document.activeElement;
      if (!a.contains(x)) {
        const S = new CustomEvent(Ik, pj);
        a.addEventListener(Ik, u), a.dispatchEvent(S), S.defaultPrevented || (joe($oe(Z6(a)), { select: !0 }), document.activeElement === x && Kl(a));
      }
      return () => {
        a.removeEventListener(Ik, u), setTimeout(() => {
          const S = new CustomEvent(zk, pj);
          a.addEventListener(zk, f), a.dispatchEvent(S), S.defaultPrevented || Kl(x ?? document.body, { select: !0 }), a.removeEventListener(zk, f), gj.remove(g);
        }, 0);
      };
    }
  }, [a, u, f, g]);
  const b = C.useCallback(
    (x) => {
      if (!n && !r || g.paused) return;
      const w = x.key === "Tab" && !x.altKey && !x.ctrlKey && !x.metaKey, S = document.activeElement;
      if (w && S) {
        const _ = x.currentTarget, [M, N] = Ioe(_);
        M && N ? !x.shiftKey && S === N ? (x.preventDefault(), n && Kl(M, { select: !0 })) : x.shiftKey && S === M && (x.preventDefault(), n && Kl(N, { select: !0 })) : S === _ && x.preventDefault();
      }
    },
    [n, r, g.paused]
  );
  return /* @__PURE__ */ v.jsx(Et.div, { tabIndex: -1, ...s, ref: m, onKeyDown: b });
});
aw.displayName = Poe;
function joe(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Kl(r, { select: t }), document.activeElement !== n) return;
}
function Ioe(e) {
  const t = Z6(e), n = mj(t, e), r = mj(t.reverse(), e);
  return [n, r];
}
function Z6(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function mj(e, t) {
  for (const n of e)
    if (!zoe(n, { upTo: t })) return n;
}
function zoe(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function Loe(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Kl(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && Loe(e) && t && e.select();
  }
}
var gj = Boe();
function Boe() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && n?.pause(), e = yj(e, t), e.unshift(t);
    },
    remove(t) {
      e = yj(e, t), e[0]?.resume();
    }
  };
}
function yj(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function $oe(e) {
  return e.filter((t) => t.tagName !== "A");
}
var Lk = 0;
function YA() {
  C.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? vj()), document.body.insertAdjacentElement("beforeend", e[1] ?? vj()), Lk++, () => {
      Lk === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), Lk--;
    };
  }, []);
}
function vj() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Fs = function() {
  return Fs = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, Fs.apply(this, arguments);
};
function Y6(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function Uoe(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, o; r < i; r++)
    (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]);
  return e.concat(o || Array.prototype.slice.call(t));
}
var E0 = "right-scroll-bar-position", _0 = "width-before-scroll-bar", Foe = "with-scroll-bars-hidden", Voe = "--removed-body-scroll-bar-size";
function Bk(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function Hoe(e, t) {
  var n = C.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var Woe = typeof window < "u" ? C.useLayoutEffect : C.useEffect, bj = /* @__PURE__ */ new WeakMap();
function qoe(e, t) {
  var n = Hoe(null, function(r) {
    return e.forEach(function(i) {
      return Bk(i, r);
    });
  });
  return Woe(function() {
    var r = bj.get(n);
    if (r) {
      var i = new Set(r), o = new Set(e), s = n.current;
      i.forEach(function(a) {
        o.has(a) || Bk(a, null);
      }), o.forEach(function(a) {
        i.has(a) || Bk(a, s);
      });
    }
    bj.set(n, e);
  }, [e]), n;
}
function Goe(e) {
  return e;
}
function Koe(e, t) {
  t === void 0 && (t = Goe);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(o) {
      var s = t(o, r);
      return n.push(s), function() {
        n = n.filter(function(a) {
          return a !== s;
        });
      };
    },
    assignSyncMedium: function(o) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(o);
      }
      n = {
        push: function(a) {
          return o(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(o) {
      r = !0;
      var s = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(o), s = n;
      }
      var c = function() {
        var f = s;
        s = [], f.forEach(o);
      }, u = function() {
        return Promise.resolve().then(c);
      };
      u(), n = {
        push: function(f) {
          s.push(f), u();
        },
        filter: function(f) {
          return s = s.filter(f), n;
        }
      };
    }
  };
  return i;
}
function Zoe(e) {
  e === void 0 && (e = {});
  var t = Koe(null);
  return t.options = Fs({ async: !0, ssr: !1 }, e), t;
}
var X6 = function(e) {
  var t = e.sideCar, n = Y6(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return C.createElement(r, Fs({}, n));
};
X6.isSideCarExport = !0;
function Yoe(e, t) {
  return e.useMedium(t), X6;
}
var J6 = Zoe(), $k = function() {
}, lw = C.forwardRef(function(e, t) {
  var n = C.useRef(null), r = C.useState({
    onScrollCapture: $k,
    onWheelCapture: $k,
    onTouchMoveCapture: $k
  }), i = r[0], o = r[1], s = e.forwardProps, a = e.children, c = e.className, u = e.removeScrollBar, f = e.enabled, h = e.shards, m = e.sideCar, g = e.noRelative, b = e.noIsolation, x = e.inert, w = e.allowPinchZoom, S = e.as, _ = S === void 0 ? "div" : S, M = e.gapMode, N = Y6(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), P = m, I = qoe([n, t]), O = Fs(Fs({}, N), i);
  return C.createElement(
    C.Fragment,
    null,
    f && C.createElement(P, { sideCar: J6, removeScrollBar: u, shards: h, noRelative: g, noIsolation: b, inert: x, setCallbacks: o, allowPinchZoom: !!w, lockRef: n, gapMode: M }),
    s ? C.cloneElement(C.Children.only(a), Fs(Fs({}, O), { ref: I })) : C.createElement(_, Fs({}, O, { className: c, ref: I }), a)
  );
});
lw.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
lw.classNames = {
  fullWidth: _0,
  zeroRight: E0
};
var Xoe = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Joe() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = Xoe();
  return t && e.setAttribute("nonce", t), e;
}
function Qoe(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function ese(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var tse = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = Joe()) && (Qoe(t, n), ese(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, nse = function() {
  var e = tse();
  return function(t, n) {
    C.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, Q6 = function() {
  var e = nse(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, rse = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Uk = function(e) {
  return parseInt(e || "", 10) || 0;
}, ise = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [Uk(n), Uk(r), Uk(i)];
}, ose = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return rse;
  var t = ise(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, sse = Q6(), Kf = "data-scroll-locked", ase = function(e, t, n, r) {
  var i = e.left, o = e.top, s = e.right, a = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(Foe, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(Kf, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(o, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(E0, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(_0, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(E0, " .").concat(E0, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(_0, " .").concat(_0, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Kf, `] {
    `).concat(Voe, ": ").concat(a, `px;
  }
`);
}, xj = function() {
  var e = parseInt(document.body.getAttribute(Kf) || "0", 10);
  return isFinite(e) ? e : 0;
}, lse = function() {
  C.useEffect(function() {
    return document.body.setAttribute(Kf, (xj() + 1).toString()), function() {
      var e = xj() - 1;
      e <= 0 ? document.body.removeAttribute(Kf) : document.body.setAttribute(Kf, e.toString());
    };
  }, []);
}, cse = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r;
  lse();
  var o = C.useMemo(function() {
    return ose(i);
  }, [i]);
  return C.createElement(sse, { styles: ase(o, !t, i, n ? "" : "!important") });
}, a_ = !1;
if (typeof window < "u")
  try {
    var Rv = Object.defineProperty({}, "passive", {
      get: function() {
        return a_ = !0, !0;
      }
    });
    window.addEventListener("test", Rv, Rv), window.removeEventListener("test", Rv, Rv);
  } catch {
    a_ = !1;
  }
var df = a_ ? { passive: !1 } : !1, use = function(e) {
  return e.tagName === "TEXTAREA";
}, e$ = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !use(e) && n[t] === "visible")
  );
}, dse = function(e) {
  return e$(e, "overflowY");
}, fse = function(e) {
  return e$(e, "overflowX");
}, wj = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = t$(e, r);
    if (i) {
      var o = n$(e, r), s = o[1], a = o[2];
      if (s > a)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, hse = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, pse = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, t$ = function(e, t) {
  return e === "v" ? dse(t) : fse(t);
}, n$ = function(e, t) {
  return e === "v" ? hse(t) : pse(t);
}, mse = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, gse = function(e, t, n, r, i) {
  var o = mse(e, window.getComputedStyle(t).direction), s = o * r, a = n.target, c = t.contains(a), u = !1, f = s > 0, h = 0, m = 0;
  do {
    if (!a)
      break;
    var g = n$(e, a), b = g[0], x = g[1], w = g[2], S = x - w - o * b;
    (b || S) && t$(e, a) && (h += S, m += b);
    var _ = a.parentNode;
    a = _ && _.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? _.host : _;
  } while (
    // portaled content
    !c && a !== document.body || // self content
    c && (t.contains(a) || t === a)
  );
  return (f && Math.abs(h) < 1 || !f && Math.abs(m) < 1) && (u = !0), u;
}, Ov = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, Sj = function(e) {
  return [e.deltaX, e.deltaY];
}, kj = function(e) {
  return e && "current" in e ? e.current : e;
}, yse = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, vse = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, bse = 0, ff = [];
function xse(e) {
  var t = C.useRef([]), n = C.useRef([0, 0]), r = C.useRef(), i = C.useState(bse++)[0], o = C.useState(Q6)[0], s = C.useRef(e);
  C.useEffect(function() {
    s.current = e;
  }, [e]), C.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var x = Uoe([e.lockRef.current], (e.shards || []).map(kj), !0).filter(Boolean);
      return x.forEach(function(w) {
        return w.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), x.forEach(function(w) {
          return w.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var a = C.useCallback(function(x, w) {
    if ("touches" in x && x.touches.length === 2 || x.type === "wheel" && x.ctrlKey)
      return !s.current.allowPinchZoom;
    var S = Ov(x), _ = n.current, M = "deltaX" in x ? x.deltaX : _[0] - S[0], N = "deltaY" in x ? x.deltaY : _[1] - S[1], P, I = x.target, O = Math.abs(M) > Math.abs(N) ? "h" : "v";
    if ("touches" in x && O === "h" && I.type === "range")
      return !1;
    var L = window.getSelection(), U = L && L.anchorNode, B = U ? U === I || U.contains(I) : !1;
    if (B)
      return !1;
    var G = wj(O, I);
    if (!G)
      return !0;
    if (G ? P = O : (P = O === "v" ? "h" : "v", G = wj(O, I)), !G)
      return !1;
    if (!r.current && "changedTouches" in x && (M || N) && (r.current = P), !P)
      return !0;
    var Y = r.current || P;
    return gse(Y, w, x, Y === "h" ? M : N);
  }, []), c = C.useCallback(function(x) {
    var w = x;
    if (!(!ff.length || ff[ff.length - 1] !== o)) {
      var S = "deltaY" in w ? Sj(w) : Ov(w), _ = t.current.filter(function(P) {
        return P.name === w.type && (P.target === w.target || w.target === P.shadowParent) && yse(P.delta, S);
      })[0];
      if (_ && _.should) {
        w.cancelable && w.preventDefault();
        return;
      }
      if (!_) {
        var M = (s.current.shards || []).map(kj).filter(Boolean).filter(function(P) {
          return P.contains(w.target);
        }), N = M.length > 0 ? a(w, M[0]) : !s.current.noIsolation;
        N && w.cancelable && w.preventDefault();
      }
    }
  }, []), u = C.useCallback(function(x, w, S, _) {
    var M = { name: x, delta: w, target: S, should: _, shadowParent: wse(S) };
    t.current.push(M), setTimeout(function() {
      t.current = t.current.filter(function(N) {
        return N !== M;
      });
    }, 1);
  }, []), f = C.useCallback(function(x) {
    n.current = Ov(x), r.current = void 0;
  }, []), h = C.useCallback(function(x) {
    u(x.type, Sj(x), x.target, a(x, e.lockRef.current));
  }, []), m = C.useCallback(function(x) {
    u(x.type, Ov(x), x.target, a(x, e.lockRef.current));
  }, []);
  C.useEffect(function() {
    return ff.push(o), e.setCallbacks({
      onScrollCapture: h,
      onWheelCapture: h,
      onTouchMoveCapture: m
    }), document.addEventListener("wheel", c, df), document.addEventListener("touchmove", c, df), document.addEventListener("touchstart", f, df), function() {
      ff = ff.filter(function(x) {
        return x !== o;
      }), document.removeEventListener("wheel", c, df), document.removeEventListener("touchmove", c, df), document.removeEventListener("touchstart", f, df);
    };
  }, []);
  var g = e.removeScrollBar, b = e.inert;
  return C.createElement(
    C.Fragment,
    null,
    b ? C.createElement(o, { styles: vse(i) }) : null,
    g ? C.createElement(cse, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function wse(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const Sse = Yoe(J6, xse);
var cw = C.forwardRef(function(e, t) {
  return C.createElement(lw, Fs({}, e, { ref: t, sideCar: Sse }));
});
cw.classNames = lw.classNames;
var kse = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, hf = /* @__PURE__ */ new WeakMap(), Dv = /* @__PURE__ */ new WeakMap(), Pv = {}, Fk = 0, r$ = function(e) {
  return e && (e.host || r$(e.parentNode));
}, Cse = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = r$(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, Ese = function(e, t, n, r) {
  var i = Cse(t, Array.isArray(e) ? e : [e]);
  Pv[n] || (Pv[n] = /* @__PURE__ */ new WeakMap());
  var o = Pv[n], s = [], a = /* @__PURE__ */ new Set(), c = new Set(i), u = function(h) {
    !h || a.has(h) || (a.add(h), u(h.parentNode));
  };
  i.forEach(u);
  var f = function(h) {
    !h || c.has(h) || Array.prototype.forEach.call(h.children, function(m) {
      if (a.has(m))
        f(m);
      else
        try {
          var g = m.getAttribute(r), b = g !== null && g !== "false", x = (hf.get(m) || 0) + 1, w = (o.get(m) || 0) + 1;
          hf.set(m, x), o.set(m, w), s.push(m), x === 1 && b && Dv.set(m, !0), w === 1 && m.setAttribute(n, "true"), b || m.setAttribute(r, "true");
        } catch (S) {
          console.error("aria-hidden: cannot operate on ", m, S);
        }
    });
  };
  return f(t), a.clear(), Fk++, function() {
    s.forEach(function(h) {
      var m = hf.get(h) - 1, g = o.get(h) - 1;
      hf.set(h, m), o.set(h, g), m || (Dv.has(h) || h.removeAttribute(r), Dv.delete(h)), g || h.removeAttribute(n);
    }), Fk--, Fk || (hf = /* @__PURE__ */ new WeakMap(), hf = /* @__PURE__ */ new WeakMap(), Dv = /* @__PURE__ */ new WeakMap(), Pv = {});
  };
}, XA = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = kse(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live], script"))), Ese(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, uw = "Dialog", [i$] = ps(uw), [_se, ms] = i$(uw), o$ = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    modal: s = !0
  } = e, a = C.useRef(null), c = C.useRef(null), [u, f] = Qa({
    prop: r,
    defaultProp: i ?? !1,
    onChange: o,
    caller: uw
  });
  return /* @__PURE__ */ v.jsx(
    _se,
    {
      scope: t,
      triggerRef: a,
      contentRef: c,
      contentId: Uo(),
      titleId: Uo(),
      descriptionId: Uo(),
      open: u,
      onOpenChange: f,
      onOpenToggle: C.useCallback(() => f((h) => !h), [f]),
      modal: s,
      children: n
    }
  );
};
o$.displayName = uw;
var s$ = "DialogTrigger", a$ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = ms(s$, n), o = Ft(t, i.triggerRef);
    return /* @__PURE__ */ v.jsx(
      Et.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": eM(i.open),
        ...r,
        ref: o,
        onClick: Ye(e.onClick, i.onOpenToggle)
      }
    );
  }
);
a$.displayName = s$;
var JA = "DialogPortal", [Tse, l$] = i$(JA, {
  forceMount: void 0
}), c$ = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: i } = e, o = ms(JA, t);
  return /* @__PURE__ */ v.jsx(Tse, { scope: t, forceMount: n, children: C.Children.map(r, (s) => /* @__PURE__ */ v.jsx(Di, { present: n || o.open, children: /* @__PURE__ */ v.jsx(Ug, { asChild: !0, container: i, children: s }) })) });
};
c$.displayName = JA;
var hb = "DialogOverlay", u$ = C.forwardRef(
  (e, t) => {
    const n = l$(hb, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = ms(hb, e.__scopeDialog);
    return o.modal ? /* @__PURE__ */ v.jsx(Di, { present: r || o.open, children: /* @__PURE__ */ v.jsx(Mse, { ...i, ref: t }) }) : null;
  }
);
u$.displayName = hb;
var Ase = /* @__PURE__ */ rh("DialogOverlay.RemoveScroll"), Mse = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = ms(hb, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ v.jsx(cw, { as: Ase, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ v.jsx(
        Et.div,
        {
          "data-state": eM(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), Zu = "DialogContent", d$ = C.forwardRef(
  (e, t) => {
    const n = l$(Zu, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = ms(Zu, e.__scopeDialog);
    return /* @__PURE__ */ v.jsx(Di, { present: r || o.open, children: o.modal ? /* @__PURE__ */ v.jsx(Nse, { ...i, ref: t }) : /* @__PURE__ */ v.jsx(Rse, { ...i, ref: t }) });
  }
);
d$.displayName = Zu;
var Nse = C.forwardRef(
  (e, t) => {
    const n = ms(Zu, e.__scopeDialog), r = C.useRef(null), i = Ft(t, n.contentRef, r);
    return C.useEffect(() => {
      const o = r.current;
      if (o) return XA(o);
    }, []), /* @__PURE__ */ v.jsx(
      f$,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ye(e.onCloseAutoFocus, (o) => {
          o.preventDefault(), n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: Ye(e.onPointerDownOutside, (o) => {
          const s = o.detail.originalEvent, a = s.button === 0 && s.ctrlKey === !0;
          (s.button === 2 || a) && o.preventDefault();
        }),
        onFocusOutside: Ye(
          e.onFocusOutside,
          (o) => o.preventDefault()
        )
      }
    );
  }
), Rse = C.forwardRef(
  (e, t) => {
    const n = ms(Zu, e.__scopeDialog), r = C.useRef(!1), i = C.useRef(!1);
    return /* @__PURE__ */ v.jsx(
      f$,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (o) => {
          e.onCloseAutoFocus?.(o), o.defaultPrevented || (r.current || n.triggerRef.current?.focus(), o.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (o) => {
          e.onInteractOutside?.(o), o.defaultPrevented || (r.current = !0, o.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const s = o.target;
          n.triggerRef.current?.contains(s) && o.preventDefault(), o.detail.originalEvent.type === "focusin" && i.current && o.preventDefault();
        }
      }
    );
  }
), f$ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, ...s } = e, a = ms(Zu, n), c = C.useRef(null), u = Ft(t, c);
    return YA(), /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(
        aw,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: o,
          children: /* @__PURE__ */ v.jsx(
            Bg,
            {
              role: "dialog",
              id: a.contentId,
              "aria-describedby": a.descriptionId,
              "aria-labelledby": a.titleId,
              "data-state": eM(a.open),
              ...s,
              ref: u,
              onDismiss: () => a.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
        /* @__PURE__ */ v.jsx(Ose, { titleId: a.titleId }),
        /* @__PURE__ */ v.jsx(Pse, { contentRef: c, descriptionId: a.descriptionId })
      ] })
    ] });
  }
), QA = "DialogTitle", h$ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = ms(QA, n);
    return /* @__PURE__ */ v.jsx(Et.h2, { id: i.titleId, ...r, ref: t });
  }
);
h$.displayName = QA;
var p$ = "DialogDescription", m$ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = ms(p$, n);
    return /* @__PURE__ */ v.jsx(Et.p, { id: i.descriptionId, ...r, ref: t });
  }
);
m$.displayName = p$;
var g$ = "DialogClose", y$ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = ms(g$, n);
    return /* @__PURE__ */ v.jsx(
      Et.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Ye(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
y$.displayName = g$;
function eM(e) {
  return e ? "open" : "closed";
}
var v$ = "DialogTitleWarning", [gLe, b$] = cX(v$, {
  contentName: Zu,
  titleName: QA,
  docsSlug: "dialog"
}), Ose = ({ titleId: e }) => {
  const t = b$(v$), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return C.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, Dse = "DialogDescriptionWarning", Pse = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${b$(Dse).contentName}}.`;
  return C.useEffect(() => {
    const i = e.current?.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, jse = o$, Ise = a$, zse = c$, Lse = u$, Bse = d$, $se = h$, Use = m$, Fse = y$;
function Ph({ ...e }) {
  return /* @__PURE__ */ v.jsx(jse, { "data-slot": "dialog", ...e });
}
function x$({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Ise, { "data-slot": "dialog-trigger", ...e });
}
function w$({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(zse, { "data-slot": "dialog-portal", ...e });
}
function Vse({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Lse,
    {
      "data-slot": "dialog-overlay",
      className: at(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        e
      ),
      ...t
    }
  );
}
function jh({
  className: e,
  children: t,
  showCloseButton: n = !0,
  ...r
}) {
  return /* @__PURE__ */ v.jsxs(w$, { "data-slot": "dialog-portal", children: [
    /* @__PURE__ */ v.jsx(Vse, {}),
    /* @__PURE__ */ v.jsxs(
      Bse,
      {
        "data-slot": "dialog-content",
        className: at(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-[1000] grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          e
        ),
        ...r,
        onCloseAutoFocus: (i) => {
          i.preventDefault(), document.body.style.pointerEvents = "";
        },
        children: [
          t,
          n && /* @__PURE__ */ v.jsxs(
            Fse,
            {
              "data-slot": "dialog-close",
              className: "ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
              children: [
                /* @__PURE__ */ v.jsx(Rg, {}),
                /* @__PURE__ */ v.jsx("span", { className: "sr-only", children: "Close" })
              ]
            }
          )
        ]
      }
    )
  ] });
}
function Vg({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "dialog-header",
      className: at("flex flex-col gap-2 text-center sm:text-left", e),
      ...t
    }
  );
}
function S$({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "dialog-footer",
      className: at(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        e
      ),
      ...t
    }
  );
}
function Ih({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    $se,
    {
      "data-slot": "dialog-title",
      className: at("text-lg leading-none font-semibold", e),
      ...t
    }
  );
}
function k$({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Use,
    {
      "data-slot": "dialog-description",
      className: at("text-muted-foreground text-sm", e),
      ...t
    }
  );
}
var Hse = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Hg = Hse.reduce((e, t) => {
  const n = /* @__PURE__ */ m6(`Primitive.${t}`), r = C.forwardRef((i, o) => {
    const { asChild: s, ...a } = i, c = s ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ v.jsx(c, { ...a, ref: o });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Wse = "Label", C$ = C.forwardRef((e, t) => /* @__PURE__ */ v.jsx(
  Hg.label,
  {
    ...e,
    ref: t,
    onMouseDown: (n) => {
      n.target.closest("button, input, select, textarea") || (e.onMouseDown?.(n), !n.defaultPrevented && n.detail > 1 && n.preventDefault());
    }
  }
));
C$.displayName = Wse;
var qse = C$;
function Gse({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    qse,
    {
      "data-slot": "label",
      className: at(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        e
      ),
      ...t
    }
  );
}
const Kse = { "gpt-4.1": "openai/gpt-4.1", "gpt-4.1-mini": "openai/gpt-4.1-mini", "gpt-4o-mini": "openai/gpt-4o-mini", "gpt-4o": "openai/gpt-4o", "gpt-5": "openai/gpt-5", "gpt-5.1": "openai/gpt-5.1", "gpt-5-mini": "openai/gpt-5-mini", "gpt-5-nano": "openai/gpt-5-nano", "gpt-oss-120b": "openai/gpt-oss-120b", "gpt-2.5-flash": "openai/gpt-2.5-flash" }, Zse = { "gemini-2.5-flash-lite": "google/gemini-2.5-flash-lite", "gemini-2.5-flash": "google/gemini-2.5-flash", "gemini-2.5-pro": "google/gemini-2.5-pro", "gemini-2.0-flash": "google/gemini-2.0-flash" }, Yse = { "claude-sonnet-4.5": "anthropic/claude-sonnet-4.5", "claude-sonnet-4": "anthropic/claude-sonnet-4", "claude-3.7-sonnet": "anthropic/claude-3.7-sonnet" }, Xse = { "grok-4-fast-reasoning": "xai/grok-4-fast-reasoning", "grok-4-fast-non-reasoning": "xai/grok-4-fast-non-reasoning" }, Jse = { "llama-4-maverick": "meta/llama-4-maverick" }, Qse = { "deepseek-v3.1": "deepseek/deepseek-v3.1" }, eae = { "gemma3-1b": "ollama/gemma3:1b", "gemma3-4b": "ollama/gemma3:4b", "gemma3-12b": "ollama/gemma3:12b" }, tae = { "gpt-oss-20b-free": "openai/gpt-oss-20b:free", "qwen3-8b-free": "qwen/qwen3-8b:free", "qwen3-14b-free": "qwen/qwen3-14b:free", "qwen3-coder-free": "qwen/qwen3-coder:free", "deepseek-r1-free": "deepseek/deepseek-r1-0528:free", "deepseek-v3-free": "deepseek/deepseek-chat-v3-0324:free", "gemini-2.0-flash-exp-free": "google/gemini-2.0-flash-exp:free" }, nae = {
  openai: Kse,
  google: Zse,
  anthropic: Yse,
  xai: Xse,
  meta: Jse,
  deepseek: Qse,
  ollama: eae,
  openRouter: tae
};
function rae(e) {
  if (typeof document > "u") return;
  let t = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
  n.type = "text/css", t.appendChild(n), n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e));
}
Array(12).fill(0);
let l_ = 1;
class iae {
  constructor() {
    this.subscribe = (t) => (this.subscribers.push(t), () => {
      const n = this.subscribers.indexOf(t);
      this.subscribers.splice(n, 1);
    }), this.publish = (t) => {
      this.subscribers.forEach((n) => n(t));
    }, this.addToast = (t) => {
      this.publish(t), this.toasts = [
        ...this.toasts,
        t
      ];
    }, this.create = (t) => {
      var n;
      const { message: r, ...i } = t, o = typeof t?.id == "number" || ((n = t.id) == null ? void 0 : n.length) > 0 ? t.id : l_++, s = this.toasts.find((c) => c.id === o), a = t.dismissible === void 0 ? !0 : t.dismissible;
      return this.dismissedToasts.has(o) && this.dismissedToasts.delete(o), s ? this.toasts = this.toasts.map((c) => c.id === o ? (this.publish({
        ...c,
        ...t,
        id: o,
        title: r
      }), {
        ...c,
        ...t,
        id: o,
        dismissible: a,
        title: r
      }) : c) : this.addToast({
        title: r,
        ...i,
        dismissible: a,
        id: o
      }), o;
    }, this.dismiss = (t) => (t ? (this.dismissedToasts.add(t), requestAnimationFrame(() => this.subscribers.forEach((n) => n({
      id: t,
      dismiss: !0
    })))) : this.toasts.forEach((n) => {
      this.subscribers.forEach((r) => r({
        id: n.id,
        dismiss: !0
      }));
    }), t), this.message = (t, n) => this.create({
      ...n,
      message: t
    }), this.error = (t, n) => this.create({
      ...n,
      message: t,
      type: "error"
    }), this.success = (t, n) => this.create({
      ...n,
      type: "success",
      message: t
    }), this.info = (t, n) => this.create({
      ...n,
      type: "info",
      message: t
    }), this.warning = (t, n) => this.create({
      ...n,
      type: "warning",
      message: t
    }), this.loading = (t, n) => this.create({
      ...n,
      type: "loading",
      message: t
    }), this.promise = (t, n) => {
      if (!n)
        return;
      let r;
      n.loading !== void 0 && (r = this.create({
        ...n,
        promise: t,
        type: "loading",
        message: n.loading,
        description: typeof n.description != "function" ? n.description : void 0
      }));
      const i = Promise.resolve(t instanceof Function ? t() : t);
      let o = r !== void 0, s;
      const a = i.then(async (u) => {
        if (s = [
          "resolve",
          u
        ], Ne.isValidElement(u))
          o = !1, this.create({
            id: r,
            type: "default",
            message: u
          });
        else if (sae(u) && !u.ok) {
          o = !1;
          const h = typeof n.error == "function" ? await n.error(`HTTP error! status: ${u.status}`) : n.error, m = typeof n.description == "function" ? await n.description(`HTTP error! status: ${u.status}`) : n.description, b = typeof h == "object" && !Ne.isValidElement(h) ? h : {
            message: h
          };
          this.create({
            id: r,
            type: "error",
            description: m,
            ...b
          });
        } else if (u instanceof Error) {
          o = !1;
          const h = typeof n.error == "function" ? await n.error(u) : n.error, m = typeof n.description == "function" ? await n.description(u) : n.description, b = typeof h == "object" && !Ne.isValidElement(h) ? h : {
            message: h
          };
          this.create({
            id: r,
            type: "error",
            description: m,
            ...b
          });
        } else if (n.success !== void 0) {
          o = !1;
          const h = typeof n.success == "function" ? await n.success(u) : n.success, m = typeof n.description == "function" ? await n.description(u) : n.description, b = typeof h == "object" && !Ne.isValidElement(h) ? h : {
            message: h
          };
          this.create({
            id: r,
            type: "success",
            description: m,
            ...b
          });
        }
      }).catch(async (u) => {
        if (s = [
          "reject",
          u
        ], n.error !== void 0) {
          o = !1;
          const f = typeof n.error == "function" ? await n.error(u) : n.error, h = typeof n.description == "function" ? await n.description(u) : n.description, g = typeof f == "object" && !Ne.isValidElement(f) ? f : {
            message: f
          };
          this.create({
            id: r,
            type: "error",
            description: h,
            ...g
          });
        }
      }).finally(() => {
        o && (this.dismiss(r), r = void 0), n.finally == null || n.finally.call(n);
      }), c = () => new Promise((u, f) => a.then(() => s[0] === "reject" ? f(s[1]) : u(s[1])).catch(f));
      return typeof r != "string" && typeof r != "number" ? {
        unwrap: c
      } : Object.assign(r, {
        unwrap: c
      });
    }, this.custom = (t, n) => {
      const r = n?.id || l_++;
      return this.create({
        jsx: t(r),
        id: r,
        ...n
      }), r;
    }, this.getActiveToasts = () => this.toasts.filter((t) => !this.dismissedToasts.has(t.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
}
const Po = new iae(), oae = (e, t) => {
  const n = t?.id || l_++;
  return Po.addToast({
    title: e,
    ...t,
    id: n
  }), n;
}, sae = (e) => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", aae = oae, lae = () => Po.toasts, cae = () => Po.getActiveToasts(), cn = Object.assign(aae, {
  success: Po.success,
  info: Po.info,
  warning: Po.warning,
  error: Po.error,
  custom: Po.custom,
  message: Po.message,
  promise: Po.promise,
  dismiss: Po.dismiss,
  loading: Po.loading
}, {
  getHistory: lae,
  getToasts: cae
});
rae("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}");
function tM(e) {
  const t = e + "CollectionProvider", [n, r] = ps(t), [i, o] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s = (x) => {
    const { scope: w, children: S } = x, _ = Ne.useRef(null), M = Ne.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ v.jsx(i, { scope: w, itemMap: M, collectionRef: _, children: S });
  };
  s.displayName = t;
  const a = e + "CollectionSlot", c = /* @__PURE__ */ rh(a), u = Ne.forwardRef(
    (x, w) => {
      const { scope: S, children: _ } = x, M = o(a, S), N = Ft(w, M.collectionRef);
      return /* @__PURE__ */ v.jsx(c, { ref: N, children: _ });
    }
  );
  u.displayName = a;
  const f = e + "CollectionItemSlot", h = "data-radix-collection-item", m = /* @__PURE__ */ rh(f), g = Ne.forwardRef(
    (x, w) => {
      const { scope: S, children: _, ...M } = x, N = Ne.useRef(null), P = Ft(w, N), I = o(f, S);
      return Ne.useEffect(() => (I.itemMap.set(N, { ref: N, ...M }), () => {
        I.itemMap.delete(N);
      })), /* @__PURE__ */ v.jsx(m, { [h]: "", ref: P, children: _ });
    }
  );
  g.displayName = f;
  function b(x) {
    const w = o(e + "CollectionConsumer", x);
    return Ne.useCallback(() => {
      const _ = w.collectionRef.current;
      if (!_) return [];
      const M = Array.from(_.querySelectorAll(`[${h}]`));
      return Array.from(w.itemMap.values()).sort(
        (I, O) => M.indexOf(I.ref.current) - M.indexOf(O.ref.current)
      );
    }, [w.collectionRef, w.itemMap]);
  }
  return [
    { Provider: s, Slot: u, ItemSlot: g },
    b,
    r
  ];
}
function nM(e) {
  const t = C.useRef({ value: e, previous: e });
  return C.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var uae = [" ", "Enter", "ArrowUp", "ArrowDown"], dae = [" ", "Enter"], Yu = "Select", [dw, fw, fae] = tM(Yu), [zh] = ps(Yu, [
  fae,
  Rh
]), hw = Rh(), [hae, jc] = zh(Yu), [pae, mae] = zh(Yu), E$ = (e) => {
  const {
    __scopeSelect: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: o,
    value: s,
    defaultValue: a,
    onValueChange: c,
    dir: u,
    name: f,
    autoComplete: h,
    disabled: m,
    required: g,
    form: b
  } = e, x = hw(t), [w, S] = C.useState(null), [_, M] = C.useState(null), [N, P] = C.useState(!1), I = Hx(u), [O, L] = Qa({
    prop: r,
    defaultProp: i ?? !1,
    onChange: o,
    caller: Yu
  }), [U, B] = Qa({
    prop: s,
    defaultProp: a,
    onChange: c,
    caller: Yu
  }), G = C.useRef(null), Y = w ? b || !!w.closest("form") : !0, [he, ie] = C.useState(/* @__PURE__ */ new Set()), ne = Array.from(he).map((H) => H.props.value).join(";");
  return /* @__PURE__ */ v.jsx(rw, { ...x, children: /* @__PURE__ */ v.jsxs(
    hae,
    {
      required: g,
      scope: t,
      trigger: w,
      onTriggerChange: S,
      valueNode: _,
      onValueNodeChange: M,
      valueNodeHasChildren: N,
      onValueNodeHasChildrenChange: P,
      contentId: Uo(),
      value: U,
      onValueChange: B,
      open: O,
      onOpenChange: L,
      dir: I,
      triggerPointerDownPosRef: G,
      disabled: m,
      children: [
        /* @__PURE__ */ v.jsx(dw.Provider, { scope: t, children: /* @__PURE__ */ v.jsx(
          pae,
          {
            scope: e.__scopeSelect,
            onNativeOptionAdd: C.useCallback((H) => {
              ie((Q) => new Set(Q).add(H));
            }, []),
            onNativeOptionRemove: C.useCallback((H) => {
              ie((Q) => {
                const X = new Set(Q);
                return X.delete(H), X;
              });
            }, []),
            children: n
          }
        ) }),
        Y ? /* @__PURE__ */ v.jsxs(
          Z$,
          {
            "aria-hidden": !0,
            required: g,
            tabIndex: -1,
            name: f,
            autoComplete: h,
            value: U,
            onChange: (H) => B(H.target.value),
            disabled: m,
            form: b,
            children: [
              U === void 0 ? /* @__PURE__ */ v.jsx("option", { value: "" }) : null,
              Array.from(he)
            ]
          },
          ne
        ) : null
      ]
    }
  ) });
};
E$.displayName = Yu;
var _$ = "SelectTrigger", T$ = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, disabled: r = !1, ...i } = e, o = hw(n), s = jc(_$, n), a = s.disabled || r, c = Ft(t, s.onTriggerChange), u = fw(n), f = C.useRef("touch"), [h, m, g] = X$((x) => {
      const w = u().filter((M) => !M.disabled), S = w.find((M) => M.value === s.value), _ = J$(w, x, S);
      _ !== void 0 && s.onValueChange(_.value);
    }), b = (x) => {
      a || (s.onOpenChange(!0), g()), x && (s.triggerPointerDownPosRef.current = {
        x: Math.round(x.pageX),
        y: Math.round(x.pageY)
      });
    };
    return /* @__PURE__ */ v.jsx(HA, { asChild: !0, ...o, children: /* @__PURE__ */ v.jsx(
      Et.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": s.contentId,
        "aria-expanded": s.open,
        "aria-required": s.required,
        "aria-autocomplete": "none",
        dir: s.dir,
        "data-state": s.open ? "open" : "closed",
        disabled: a,
        "data-disabled": a ? "" : void 0,
        "data-placeholder": Y$(s.value) ? "" : void 0,
        ...i,
        ref: c,
        onClick: Ye(i.onClick, (x) => {
          x.currentTarget.focus(), f.current !== "mouse" && b(x);
        }),
        onPointerDown: Ye(i.onPointerDown, (x) => {
          f.current = x.pointerType;
          const w = x.target;
          w.hasPointerCapture(x.pointerId) && w.releasePointerCapture(x.pointerId), x.button === 0 && x.ctrlKey === !1 && x.pointerType === "mouse" && (b(x), x.preventDefault());
        }),
        onKeyDown: Ye(i.onKeyDown, (x) => {
          const w = h.current !== "";
          !(x.ctrlKey || x.altKey || x.metaKey) && x.key.length === 1 && m(x.key), !(w && x.key === " ") && uae.includes(x.key) && (b(), x.preventDefault());
        })
      }
    ) });
  }
);
T$.displayName = _$;
var A$ = "SelectValue", M$ = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: r, style: i, children: o, placeholder: s = "", ...a } = e, c = jc(A$, n), { onValueNodeHasChildrenChange: u } = c, f = o !== void 0, h = Ft(t, c.onValueNodeChange);
    return Er(() => {
      u(f);
    }, [u, f]), /* @__PURE__ */ v.jsx(
      Et.span,
      {
        ...a,
        ref: h,
        style: { pointerEvents: "none" },
        children: Y$(c.value) ? /* @__PURE__ */ v.jsx(v.Fragment, { children: s }) : o
      }
    );
  }
);
M$.displayName = A$;
var gae = "SelectIcon", N$ = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, children: r, ...i } = e;
    return /* @__PURE__ */ v.jsx(Et.span, { "aria-hidden": !0, ...i, ref: t, children: r || "" });
  }
);
N$.displayName = gae;
var yae = "SelectPortal", R$ = (e) => /* @__PURE__ */ v.jsx(Ug, { asChild: !0, ...e });
R$.displayName = yae;
var Xu = "SelectContent", O$ = C.forwardRef(
  (e, t) => {
    const n = jc(Xu, e.__scopeSelect), [r, i] = C.useState();
    if (Er(() => {
      i(new DocumentFragment());
    }, []), !n.open) {
      const o = r;
      return o ? tl.createPortal(
        /* @__PURE__ */ v.jsx(D$, { scope: e.__scopeSelect, children: /* @__PURE__ */ v.jsx(dw.Slot, { scope: e.__scopeSelect, children: /* @__PURE__ */ v.jsx("div", { children: e.children }) }) }),
        o
      ) : null;
    }
    return /* @__PURE__ */ v.jsx(P$, { ...e, ref: t });
  }
);
O$.displayName = Xu;
var is = 10, [D$, Ic] = zh(Xu), vae = "SelectContentImpl", bae = /* @__PURE__ */ rh("SelectContent.RemoveScroll"), P$ = C.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      position: r = "item-aligned",
      onCloseAutoFocus: i,
      onEscapeKeyDown: o,
      onPointerDownOutside: s,
      //
      // PopperContent props
      side: a,
      sideOffset: c,
      align: u,
      alignOffset: f,
      arrowPadding: h,
      collisionBoundary: m,
      collisionPadding: g,
      sticky: b,
      hideWhenDetached: x,
      avoidCollisions: w,
      //
      ...S
    } = e, _ = jc(Xu, n), [M, N] = C.useState(null), [P, I] = C.useState(null), O = Ft(t, (J) => N(J)), [L, U] = C.useState(null), [B, G] = C.useState(
      null
    ), Y = fw(n), [he, ie] = C.useState(!1), ne = C.useRef(!1);
    C.useEffect(() => {
      if (M) return XA(M);
    }, [M]), YA();
    const H = C.useCallback(
      (J) => {
        const [xe, ...be] = Y().map((Ge) => Ge.ref.current), [Ae] = be.slice(-1), tt = document.activeElement;
        for (const Ge of J)
          if (Ge === tt || (Ge?.scrollIntoView({ block: "nearest" }), Ge === xe && P && (P.scrollTop = 0), Ge === Ae && P && (P.scrollTop = P.scrollHeight), Ge?.focus(), document.activeElement !== tt)) return;
      },
      [Y, P]
    ), Q = C.useCallback(
      () => H([L, M]),
      [H, L, M]
    );
    C.useEffect(() => {
      he && Q();
    }, [he, Q]);
    const { onOpenChange: X, triggerPointerDownPosRef: Se } = _;
    C.useEffect(() => {
      if (M) {
        let J = { x: 0, y: 0 };
        const xe = (Ae) => {
          J = {
            x: Math.abs(Math.round(Ae.pageX) - (Se.current?.x ?? 0)),
            y: Math.abs(Math.round(Ae.pageY) - (Se.current?.y ?? 0))
          };
        }, be = (Ae) => {
          J.x <= 10 && J.y <= 10 ? Ae.preventDefault() : M.contains(Ae.target) || X(!1), document.removeEventListener("pointermove", xe), Se.current = null;
        };
        return Se.current !== null && (document.addEventListener("pointermove", xe), document.addEventListener("pointerup", be, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", xe), document.removeEventListener("pointerup", be, { capture: !0 });
        };
      }
    }, [M, X, Se]), C.useEffect(() => {
      const J = () => X(!1);
      return window.addEventListener("blur", J), window.addEventListener("resize", J), () => {
        window.removeEventListener("blur", J), window.removeEventListener("resize", J);
      };
    }, [X]);
    const [W, Z] = X$((J) => {
      const xe = Y().filter((tt) => !tt.disabled), be = xe.find((tt) => tt.ref.current === document.activeElement), Ae = J$(xe, J, be);
      Ae && setTimeout(() => Ae.ref.current.focus());
    }), pe = C.useCallback(
      (J, xe, be) => {
        const Ae = !ne.current && !be;
        (_.value !== void 0 && _.value === xe || Ae) && (U(J), Ae && (ne.current = !0));
      },
      [_.value]
    ), F = C.useCallback(() => M?.focus(), [M]), ee = C.useCallback(
      (J, xe, be) => {
        const Ae = !ne.current && !be;
        (_.value !== void 0 && _.value === xe || Ae) && G(J);
      },
      [_.value]
    ), ge = r === "popper" ? c_ : j$, re = ge === c_ ? {
      side: a,
      sideOffset: c,
      align: u,
      alignOffset: f,
      arrowPadding: h,
      collisionBoundary: m,
      collisionPadding: g,
      sticky: b,
      hideWhenDetached: x,
      avoidCollisions: w
    } : {};
    return /* @__PURE__ */ v.jsx(
      D$,
      {
        scope: n,
        content: M,
        viewport: P,
        onViewportChange: I,
        itemRefCallback: pe,
        selectedItem: L,
        onItemLeave: F,
        itemTextRefCallback: ee,
        focusSelectedItem: Q,
        selectedItemText: B,
        position: r,
        isPositioned: he,
        searchRef: W,
        children: /* @__PURE__ */ v.jsx(cw, { as: bae, allowPinchZoom: !0, children: /* @__PURE__ */ v.jsx(
          aw,
          {
            asChild: !0,
            trapped: _.open,
            onMountAutoFocus: (J) => {
              J.preventDefault();
            },
            onUnmountAutoFocus: Ye(i, (J) => {
              _.trigger?.focus({ preventScroll: !0 }), J.preventDefault();
            }),
            children: /* @__PURE__ */ v.jsx(
              Bg,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: o,
                onPointerDownOutside: s,
                onFocusOutside: (J) => J.preventDefault(),
                onDismiss: () => _.onOpenChange(!1),
                children: /* @__PURE__ */ v.jsx(
                  ge,
                  {
                    role: "listbox",
                    id: _.contentId,
                    "data-state": _.open ? "open" : "closed",
                    dir: _.dir,
                    onContextMenu: (J) => J.preventDefault(),
                    ...S,
                    ...re,
                    onPlaced: () => ie(!0),
                    ref: O,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...S.style
                    },
                    onKeyDown: Ye(S.onKeyDown, (J) => {
                      const xe = J.ctrlKey || J.altKey || J.metaKey;
                      if (J.key === "Tab" && J.preventDefault(), !xe && J.key.length === 1 && Z(J.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(J.key)) {
                        let Ae = Y().filter((tt) => !tt.disabled).map((tt) => tt.ref.current);
                        if (["ArrowUp", "End"].includes(J.key) && (Ae = Ae.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(J.key)) {
                          const tt = J.target, Ge = Ae.indexOf(tt);
                          Ae = Ae.slice(Ge + 1);
                        }
                        setTimeout(() => H(Ae)), J.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
P$.displayName = vae;
var xae = "SelectItemAlignedPosition", j$ = C.forwardRef((e, t) => {
  const { __scopeSelect: n, onPlaced: r, ...i } = e, o = jc(Xu, n), s = Ic(Xu, n), [a, c] = C.useState(null), [u, f] = C.useState(null), h = Ft(t, (O) => f(O)), m = fw(n), g = C.useRef(!1), b = C.useRef(!0), { viewport: x, selectedItem: w, selectedItemText: S, focusSelectedItem: _ } = s, M = C.useCallback(() => {
    if (o.trigger && o.valueNode && a && u && x && w && S) {
      const O = o.trigger.getBoundingClientRect(), L = u.getBoundingClientRect(), U = o.valueNode.getBoundingClientRect(), B = S.getBoundingClientRect();
      if (o.dir !== "rtl") {
        const tt = B.left - L.left, Ge = U.left - tt, nt = O.left - Ge, _t = O.width + nt, yn = Math.max(_t, L.width), St = window.innerWidth - is, Vt = NE(Ge, [
          is,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(is, St - yn)
        ]);
        a.style.minWidth = _t + "px", a.style.left = Vt + "px";
      } else {
        const tt = L.right - B.right, Ge = window.innerWidth - U.right - tt, nt = window.innerWidth - O.right - Ge, _t = O.width + nt, yn = Math.max(_t, L.width), St = window.innerWidth - is, Vt = NE(Ge, [
          is,
          Math.max(is, St - yn)
        ]);
        a.style.minWidth = _t + "px", a.style.right = Vt + "px";
      }
      const G = m(), Y = window.innerHeight - is * 2, he = x.scrollHeight, ie = window.getComputedStyle(u), ne = parseInt(ie.borderTopWidth, 10), H = parseInt(ie.paddingTop, 10), Q = parseInt(ie.borderBottomWidth, 10), X = parseInt(ie.paddingBottom, 10), Se = ne + H + he + X + Q, W = Math.min(w.offsetHeight * 5, Se), Z = window.getComputedStyle(x), pe = parseInt(Z.paddingTop, 10), F = parseInt(Z.paddingBottom, 10), ee = O.top + O.height / 2 - is, ge = Y - ee, re = w.offsetHeight / 2, J = w.offsetTop + re, xe = ne + H + J, be = Se - xe;
      if (xe <= ee) {
        const tt = G.length > 0 && w === G[G.length - 1].ref.current;
        a.style.bottom = "0px";
        const Ge = u.clientHeight - x.offsetTop - x.offsetHeight, nt = Math.max(
          ge,
          re + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (tt ? F : 0) + Ge + Q
        ), _t = xe + nt;
        a.style.height = _t + "px";
      } else {
        const tt = G.length > 0 && w === G[0].ref.current;
        a.style.top = "0px";
        const nt = Math.max(
          ee,
          ne + x.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (tt ? pe : 0) + re
        ) + be;
        a.style.height = nt + "px", x.scrollTop = xe - ee + x.offsetTop;
      }
      a.style.margin = `${is}px 0`, a.style.minHeight = W + "px", a.style.maxHeight = Y + "px", r?.(), requestAnimationFrame(() => g.current = !0);
    }
  }, [
    m,
    o.trigger,
    o.valueNode,
    a,
    u,
    x,
    w,
    S,
    o.dir,
    r
  ]);
  Er(() => M(), [M]);
  const [N, P] = C.useState();
  Er(() => {
    u && P(window.getComputedStyle(u).zIndex);
  }, [u]);
  const I = C.useCallback(
    (O) => {
      O && b.current === !0 && (M(), _?.(), b.current = !1);
    },
    [M, _]
  );
  return /* @__PURE__ */ v.jsx(
    Sae,
    {
      scope: n,
      contentWrapper: a,
      shouldExpandOnScrollRef: g,
      onScrollButtonChange: I,
      children: /* @__PURE__ */ v.jsx(
        "div",
        {
          ref: c,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: N
          },
          children: /* @__PURE__ */ v.jsx(
            Et.div,
            {
              ...i,
              ref: h,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...i.style
              }
            }
          )
        }
      )
    }
  );
});
j$.displayName = xae;
var wae = "SelectPopperPosition", c_ = C.forwardRef((e, t) => {
  const {
    __scopeSelect: n,
    align: r = "start",
    collisionPadding: i = is,
    ...o
  } = e, s = hw(n);
  return /* @__PURE__ */ v.jsx(
    WA,
    {
      ...s,
      ...o,
      ref: t,
      align: r,
      collisionPadding: i,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...o.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
c_.displayName = wae;
var [Sae, rM] = zh(Xu, {}), u_ = "SelectViewport", I$ = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, nonce: r, ...i } = e, o = Ic(u_, n), s = rM(u_, n), a = Ft(t, o.onViewportChange), c = C.useRef(0);
    return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: r
        }
      ),
      /* @__PURE__ */ v.jsx(dw.Slot, { scope: n, children: /* @__PURE__ */ v.jsx(
        Et.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...i,
          ref: a,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...i.style
          },
          onScroll: Ye(i.onScroll, (u) => {
            const f = u.currentTarget, { contentWrapper: h, shouldExpandOnScrollRef: m } = s;
            if (m?.current && h) {
              const g = Math.abs(c.current - f.scrollTop);
              if (g > 0) {
                const b = window.innerHeight - is * 2, x = parseFloat(h.style.minHeight), w = parseFloat(h.style.height), S = Math.max(x, w);
                if (S < b) {
                  const _ = S + g, M = Math.min(b, _), N = _ - M;
                  h.style.height = M + "px", h.style.bottom === "0px" && (f.scrollTop = N > 0 ? N : 0, h.style.justifyContent = "flex-end");
                }
              }
            }
            c.current = f.scrollTop;
          })
        }
      ) })
    ] });
  }
);
I$.displayName = u_;
var z$ = "SelectGroup", [kae, Cae] = zh(z$), L$ = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, i = Uo();
    return /* @__PURE__ */ v.jsx(kae, { scope: n, id: i, children: /* @__PURE__ */ v.jsx(Et.div, { role: "group", "aria-labelledby": i, ...r, ref: t }) });
  }
);
L$.displayName = z$;
var B$ = "SelectLabel", $$ = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, i = Cae(B$, n);
    return /* @__PURE__ */ v.jsx(Et.div, { id: i.id, ...r, ref: t });
  }
);
$$.displayName = B$;
var pb = "SelectItem", [Eae, U$] = zh(pb), F$ = C.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      value: r,
      disabled: i = !1,
      textValue: o,
      ...s
    } = e, a = jc(pb, n), c = Ic(pb, n), u = a.value === r, [f, h] = C.useState(o ?? ""), [m, g] = C.useState(!1), b = Ft(
      t,
      (_) => c.itemRefCallback?.(_, r, i)
    ), x = Uo(), w = C.useRef("touch"), S = () => {
      i || (a.onValueChange(r), a.onOpenChange(!1));
    };
    if (r === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ v.jsx(
      Eae,
      {
        scope: n,
        value: r,
        disabled: i,
        textId: x,
        isSelected: u,
        onItemTextChange: C.useCallback((_) => {
          h((M) => M || (_?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ v.jsx(
          dw.ItemSlot,
          {
            scope: n,
            value: r,
            disabled: i,
            textValue: f,
            children: /* @__PURE__ */ v.jsx(
              Et.div,
              {
                role: "option",
                "aria-labelledby": x,
                "data-highlighted": m ? "" : void 0,
                "aria-selected": u && m,
                "data-state": u ? "checked" : "unchecked",
                "aria-disabled": i || void 0,
                "data-disabled": i ? "" : void 0,
                tabIndex: i ? void 0 : -1,
                ...s,
                ref: b,
                onFocus: Ye(s.onFocus, () => g(!0)),
                onBlur: Ye(s.onBlur, () => g(!1)),
                onClick: Ye(s.onClick, () => {
                  w.current !== "mouse" && S();
                }),
                onPointerUp: Ye(s.onPointerUp, () => {
                  w.current === "mouse" && S();
                }),
                onPointerDown: Ye(s.onPointerDown, (_) => {
                  w.current = _.pointerType;
                }),
                onPointerMove: Ye(s.onPointerMove, (_) => {
                  w.current = _.pointerType, i ? c.onItemLeave?.() : w.current === "mouse" && _.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: Ye(s.onPointerLeave, (_) => {
                  _.currentTarget === document.activeElement && c.onItemLeave?.();
                }),
                onKeyDown: Ye(s.onKeyDown, (_) => {
                  c.searchRef?.current !== "" && _.key === " " || (dae.includes(_.key) && S(), _.key === " " && _.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
F$.displayName = pb;
var am = "SelectItemText", V$ = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: r, style: i, ...o } = e, s = jc(am, n), a = Ic(am, n), c = U$(am, n), u = mae(am, n), [f, h] = C.useState(null), m = Ft(
      t,
      (S) => h(S),
      c.onItemTextChange,
      (S) => a.itemTextRefCallback?.(S, c.value, c.disabled)
    ), g = f?.textContent, b = C.useMemo(
      () => /* @__PURE__ */ v.jsx("option", { value: c.value, disabled: c.disabled, children: g }, c.value),
      [c.disabled, c.value, g]
    ), { onNativeOptionAdd: x, onNativeOptionRemove: w } = u;
    return Er(() => (x(b), () => w(b)), [x, w, b]), /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx(Et.span, { id: c.textId, ...o, ref: m }),
      c.isSelected && s.valueNode && !s.valueNodeHasChildren ? tl.createPortal(o.children, s.valueNode) : null
    ] });
  }
);
V$.displayName = am;
var H$ = "SelectItemIndicator", W$ = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return U$(H$, n).isSelected ? /* @__PURE__ */ v.jsx(Et.span, { "aria-hidden": !0, ...r, ref: t }) : null;
  }
);
W$.displayName = H$;
var d_ = "SelectScrollUpButton", q$ = C.forwardRef((e, t) => {
  const n = Ic(d_, e.__scopeSelect), r = rM(d_, e.__scopeSelect), [i, o] = C.useState(!1), s = Ft(t, r.onScrollButtonChange);
  return Er(() => {
    if (n.viewport && n.isPositioned) {
      let a = function() {
        const u = c.scrollTop > 0;
        o(u);
      };
      const c = n.viewport;
      return a(), c.addEventListener("scroll", a), () => c.removeEventListener("scroll", a);
    }
  }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ v.jsx(
    K$,
    {
      ...e,
      ref: s,
      onAutoScroll: () => {
        const { viewport: a, selectedItem: c } = n;
        a && c && (a.scrollTop = a.scrollTop - c.offsetHeight);
      }
    }
  ) : null;
});
q$.displayName = d_;
var f_ = "SelectScrollDownButton", G$ = C.forwardRef((e, t) => {
  const n = Ic(f_, e.__scopeSelect), r = rM(f_, e.__scopeSelect), [i, o] = C.useState(!1), s = Ft(t, r.onScrollButtonChange);
  return Er(() => {
    if (n.viewport && n.isPositioned) {
      let a = function() {
        const u = c.scrollHeight - c.clientHeight, f = Math.ceil(c.scrollTop) < u;
        o(f);
      };
      const c = n.viewport;
      return a(), c.addEventListener("scroll", a), () => c.removeEventListener("scroll", a);
    }
  }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ v.jsx(
    K$,
    {
      ...e,
      ref: s,
      onAutoScroll: () => {
        const { viewport: a, selectedItem: c } = n;
        a && c && (a.scrollTop = a.scrollTop + c.offsetHeight);
      }
    }
  ) : null;
});
G$.displayName = f_;
var K$ = C.forwardRef((e, t) => {
  const { __scopeSelect: n, onAutoScroll: r, ...i } = e, o = Ic("SelectScrollButton", n), s = C.useRef(null), a = fw(n), c = C.useCallback(() => {
    s.current !== null && (window.clearInterval(s.current), s.current = null);
  }, []);
  return C.useEffect(() => () => c(), [c]), Er(() => {
    a().find((f) => f.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [a]), /* @__PURE__ */ v.jsx(
    Et.div,
    {
      "aria-hidden": !0,
      ...i,
      ref: t,
      style: { flexShrink: 0, ...i.style },
      onPointerDown: Ye(i.onPointerDown, () => {
        s.current === null && (s.current = window.setInterval(r, 50));
      }),
      onPointerMove: Ye(i.onPointerMove, () => {
        o.onItemLeave?.(), s.current === null && (s.current = window.setInterval(r, 50));
      }),
      onPointerLeave: Ye(i.onPointerLeave, () => {
        c();
      })
    }
  );
}), _ae = "SelectSeparator", Tae = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return /* @__PURE__ */ v.jsx(Et.div, { "aria-hidden": !0, ...r, ref: t });
  }
);
Tae.displayName = _ae;
var h_ = "SelectArrow", Aae = C.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...r } = e, i = hw(n), o = jc(h_, n), s = Ic(h_, n);
    return o.open && s.position === "popper" ? /* @__PURE__ */ v.jsx(qA, { ...i, ...r, ref: t }) : null;
  }
);
Aae.displayName = h_;
var Mae = "SelectBubbleInput", Z$ = C.forwardRef(
  ({ __scopeSelect: e, value: t, ...n }, r) => {
    const i = C.useRef(null), o = Ft(r, i), s = nM(t);
    return C.useEffect(() => {
      const a = i.current;
      if (!a) return;
      const c = window.HTMLSelectElement.prototype, f = Object.getOwnPropertyDescriptor(
        c,
        "value"
      ).set;
      if (s !== t && f) {
        const h = new Event("change", { bubbles: !0 });
        f.call(a, t), a.dispatchEvent(h);
      }
    }, [s, t]), /* @__PURE__ */ v.jsx(
      Et.select,
      {
        ...n,
        style: { ...$6, ...n.style },
        ref: o,
        defaultValue: t
      }
    );
  }
);
Z$.displayName = Mae;
function Y$(e) {
  return e === "" || e === void 0;
}
function X$(e) {
  const t = Dr(e), n = C.useRef(""), r = C.useRef(0), i = C.useCallback(
    (s) => {
      const a = n.current + s;
      t(a), (function c(u) {
        n.current = u, window.clearTimeout(r.current), u !== "" && (r.current = window.setTimeout(() => c(""), 1e3));
      })(a);
    },
    [t]
  ), o = C.useCallback(() => {
    n.current = "", window.clearTimeout(r.current);
  }, []);
  return C.useEffect(() => () => window.clearTimeout(r.current), []), [n, i, o];
}
function J$(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let s = Nae(e, Math.max(o, 0));
  i.length === 1 && (s = s.filter((u) => u !== n));
  const c = s.find(
    (u) => u.textValue.toLowerCase().startsWith(i.toLowerCase())
  );
  return c !== n ? c : void 0;
}
function Nae(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var Rae = E$, Oae = T$, Dae = M$, Pae = N$, jae = R$, Iae = O$, zae = I$, Lae = L$, Bae = $$, $ae = F$, Uae = V$, Fae = W$, Vae = q$, Hae = G$;
function Wae({ ...e }) {
  return /* @__PURE__ */ v.jsx(Rae, { "data-slot": "select", ...e });
}
function qae({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Lae, { "data-slot": "select-group", ...e });
}
function Gae({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(Dae, { "data-slot": "select-value", ...e });
}
function Kae({
  className: e,
  size: t = "default",
  children: n,
  ...r
}) {
  return /* @__PURE__ */ v.jsxs(
    Oae,
    {
      "data-slot": "select-trigger",
      "data-size": t,
      className: at(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ v.jsx(Pae, { asChild: !0, children: /* @__PURE__ */ v.jsx(Mg, { className: "size-4 opacity-50" }) })
      ]
    }
  );
}
function Zae({
  className: e,
  children: t,
  position: n = "popper",
  ...r
}) {
  return /* @__PURE__ */ v.jsx(jae, { children: /* @__PURE__ */ v.jsxs(
    Iae,
    {
      "data-slot": "select-content",
      className: at(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
        n === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        e
      ),
      position: n,
      ...r,
      children: [
        /* @__PURE__ */ v.jsx(Jae, {}),
        /* @__PURE__ */ v.jsx(
          zae,
          {
            className: at(
              "p-1",
              n === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
            ),
            children: t
          }
        ),
        /* @__PURE__ */ v.jsx(Qae, {})
      ]
    }
  ) });
}
function Yae({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Bae,
    {
      "data-slot": "select-label",
      className: at("text-muted-foreground px-2 py-1.5 text-xs", e),
      ...t
    }
  );
}
function Xae({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsxs(
    $ae,
    {
      "data-slot": "select-item",
      className: at(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        e
      ),
      ...n,
      children: [
        /* @__PURE__ */ v.jsx("span", { className: "absolute right-2 flex size-3.5 items-center justify-center", children: /* @__PURE__ */ v.jsx(Fae, { children: /* @__PURE__ */ v.jsx(wc, { className: "size-4" }) }) }),
        /* @__PURE__ */ v.jsx(Uae, { children: t })
      ]
    }
  );
}
function Jae({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Vae,
    {
      "data-slot": "select-scroll-up-button",
      className: at("flex cursor-default items-center justify-center py-1", e),
      ...t,
      children: /* @__PURE__ */ v.jsx(_Z, { className: "size-4" })
    }
  );
}
function Qae({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    Hae,
    {
      "data-slot": "select-scroll-down-button",
      className: at("flex cursor-default items-center justify-center py-1", e),
      ...t,
      children: /* @__PURE__ */ v.jsx(Mg, { className: "size-4" })
    }
  );
}
const Q$ = "gpt-4.1", mb = {
  ALLOWED_MCP_SERVERS: "allowed-mcp-servers",
  AI_USE_NEXT_SUGGESTION: "ai-use-next-suggestion"
}, ele = ({
  open: e,
  onOpenChange: t,
  setApiKeyByName: n
}) => {
  const [r, i] = C.useState(localStorage.getItem("ai-name") || Q$), [o, s] = C.useState([]);
  C.useEffect(() => {
    const c = [];
    Object.entries(nae).forEach(([u, f]) => {
      c.push({ provider: u, models: Object.keys(f) });
    }), s(c);
  }, []);
  const a = async () => {
    try {
      cn.success("Settings saved successfully"), n && await n(r), t(!1);
    } catch (c) {
      cn.error(c?.message || "Failed to save setting");
    }
  };
  return /* @__PURE__ */ v.jsx(Ph, { open: e, onOpenChange: t, children: /* @__PURE__ */ v.jsxs(jh, { className: "max-w-sm", children: [
    /* @__PURE__ */ v.jsxs(Vg, { children: [
      /* @__PURE__ */ v.jsx(Ih, { children: "Settings" }),
      /* @__PURE__ */ v.jsx(k$, { className: "text-xs text-muted-foreground italic", children: "Configure your chatbot connection and identity. Your API key is kept locally and never shared." })
    ] }),
    /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 py-1", children: [
      /* @__PURE__ */ v.jsx(Gse, { htmlFor: "openai-name", children: "Model name" }),
      /* @__PURE__ */ v.jsxs(Wae, { value: r, onValueChange: i, children: [
        /* @__PURE__ */ v.jsx(Kae, { id: "openai-name", className: "w-full", children: /* @__PURE__ */ v.jsx(Gae, { placeholder: "Select a model" }) }),
        /* @__PURE__ */ v.jsx(
          Zae,
          {
            position: "popper",
            className: "z-[9999] max-h-[30vh] overflow-y-auto",
            children: o.map((c) => /* @__PURE__ */ v.jsxs(qae, { children: [
              /* @__PURE__ */ v.jsx(Yae, { children: c.provider }),
              c.models.map((u) => /* @__PURE__ */ v.jsx(Xae, { value: u, children: u }, u))
            ] }, c.provider))
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ v.jsx(S$, { children: /* @__PURE__ */ v.jsx(Ht, { onClick: a, type: "button", children: "Save" }) })
  ] }) });
};
function lh({ className: e }) {
  return /* @__PURE__ */ v.jsxs(
    "svg",
    {
      "aria-hidden": "true",
      viewBox: "0 0 24 24",
      version: "1.1",
      className: e,
      "data-view-component": "true",
      children: [
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "currentColor",
            d: "M15.688 2.343a2.588 2.588 0 00-3.61 0l-9.626 9.44a.863.863 0 01-1.203 0 .823.823 0 010-1.18l9.626-9.44a4.313 4.313 0 016.016 0 4.116 4.116 0 011.204 3.54 4.3 4.3 0 013.609 1.18l.05.05a4.115 4.115 0 010 5.9l-8.706 8.537a.274.274 0 000 .393l1.788 1.754a.823.823 0 010 1.18.863.863 0 01-1.203 0l-1.788-1.753a1.92 1.92 0 010-2.754l8.706-8.538a2.47 2.47 0 000-3.54l-.05-.049a2.588 2.588 0 00-3.607-.003l-7.172 7.034-.002.002-.098.097a.863.863 0 01-1.204 0 .823.823 0 010-1.18l7.273-7.133a2.47 2.47 0 00-.003-3.537z"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "currentColor",
            d: "M14.485 4.703a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a4.115 4.115 0 000 5.9 4.314 4.314 0 006.016 0l7.12-6.982a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a2.588 2.588 0 01-3.61 0 2.47 2.47 0 010-3.54l7.12-6.982z"
          }
        )
      ]
    }
  );
}
function e9(e) {
  const t = e.trim().replace(/\/$/, "");
  return t ? /\/api\/v1$/.test(t) ? t : `${t}/api/v1` : "http://localhost:5000/api/v1";
}
function tle() {
  return "http://localhost:5000";
}
let Wa = e9(tle()), Ws = `${Wa}/mcp`, Wg = `${Wa}/thread`;
function nle(e) {
  Wa = e9(e), Ws = `${Wa}/mcp`, Wg = `${Wa}/thread`;
}
function rle(e) {
  const t = e.trim();
  if (!(t.startsWith("{") && t.endsWith("}") || t.startsWith("[") && t.endsWith("]"))) return { success: !1, data: e };
  try {
    return { success: !0, data: JSON.parse(e) };
  } catch {
    return { success: !1, data: e };
  }
}
function ile(e) {
  try {
    navigator.clipboard?.writeText(e);
  } catch {
  }
}
const Ju = C.memo(function({
  data: t,
  name: n,
  initialExpandDepth: r = 2,
  framed: i = !1,
  expandAll: o = !1
}) {
  const s = C.useMemo(() => {
    if (typeof t == "string") {
      const c = rle(t);
      return c.success ? c.data : t;
    }
    return t;
  }, [t]), a = C.useMemo(() => {
    try {
      return typeof s == "string" ? s : JSON.stringify(s, null, 2);
    } catch {
      return String(s);
    }
  }, [s]);
  return /* @__PURE__ */ v.jsxs(
    "div",
    {
      className: hc(
        "text-sm transition-all duration-300 w-full",
        i && "rounded-lg border bg-card overflow-hidden"
      ),
      children: [
        i && /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 px-3 py-2 border-b bg-muted/40", children: [
          /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground font-medium", children: n ?? "JSON" }),
          /* @__PURE__ */ v.jsx("div", { className: "flex-1" }),
          /* @__PURE__ */ v.jsx(
            "button",
            {
              className: "text-xs px-2 py-1 rounded border bg-background hover:bg-secondary",
              onClick: () => ile(a),
              title: "Copy JSON",
              children: "Copy"
            }
          )
        ] }),
        /* @__PURE__ */ v.jsx("div", { className: hc(i ? "px-3 py-3" : ""), children: /* @__PURE__ */ v.jsx(
          ole,
          {
            data: s,
            name: n,
            depth: 0,
            initialExpandDepth: r,
            expandAll: o
          }
        ) })
      ]
    }
  );
}), ole = C.memo(function e({
  data: t,
  name: n,
  depth: r,
  initialExpandDepth: i,
  expandAll: o = !1
}) {
  const a = ((m) => m === null ? "null" : Array.isArray(m) ? "array" : typeof m == "object" ? "object" : typeof m == "string" ? "string" : typeof m == "number" ? "number" : typeof m == "boolean" ? "boolean" : "undefined")(t), [c, u] = C.useState(
    a === "string" ? !!o : o ? !0 : r < i
  );
  C.useEffect(() => {
    u(
      a === "string" ? !!o : o ? !0 : r < i
    );
  }, [a, o, i, r, t]);
  const f = {
    key: "text-muted-foreground",
    string: "text-emerald-400",
    number: "text-sky-400",
    boolean: "text-amber-400",
    null: "text-fuchsia-400",
    undefined: "text-zinc-400",
    punct: "text-muted-foreground"
  }, h = n ? /* @__PURE__ */ v.jsxs("span", { className: hc("mr-1", f.key), children: [
    n,
    ":"
  ] }) : null;
  if (a === "object" || a === "array") {
    const m = a === "array", g = m ? t : Object.entries(t), b = g.length === 0, x = m ? "[" : "{", w = m ? "]" : "}";
    return b ? /* @__PURE__ */ v.jsxs("div", { className: "flex items-center", children: [
      h,
      /* @__PURE__ */ v.jsx("span", { className: f.punct, children: m ? "[]" : "{}" })
    ] }) : /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
      /* @__PURE__ */ v.jsxs(
        "div",
        {
          className: "flex items-center gap-1 rounded cursor-pointer hover:bg-input/30 px-1 -mx-1",
          onClick: () => u((S) => !S),
          title: c ? "Collapse" : "Expand",
          children: [
            h,
            c ? /* @__PURE__ */ v.jsx("span", { className: f.punct, children: x }) : /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
              /* @__PURE__ */ v.jsx("span", { className: f.punct, children: m ? "[  ]" : "{  }" }),
              /* @__PURE__ */ v.jsxs("span", { className: "ml-1 text-muted-foreground", children: [
                g.length,
                " ",
                g.length === 1 ? "item" : "items"
              ] })
            ] })
          ]
        }
      ),
      c && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
        /* @__PURE__ */ v.jsx("div", { className: "pl-3 ml-3 border-l border-border/60", children: m ? g.map((S, _) => /* @__PURE__ */ v.jsx("div", { className: "my-1", children: /* @__PURE__ */ v.jsx(
          e,
          {
            data: S,
            name: String(_),
            depth: r + 1,
            initialExpandDepth: i,
            expandAll: o
          }
        ) }, _)) : g.map(([S, _]) => /* @__PURE__ */ v.jsx("div", { className: "my-1", children: /* @__PURE__ */ v.jsx(
          e,
          {
            data: _,
            name: S,
            depth: r + 1,
            initialExpandDepth: i,
            expandAll: o
          }
        ) }, S)) }),
        /* @__PURE__ */ v.jsx("span", { className: hc("mt-0.5", f.punct), children: w })
      ] })
    ] });
  }
  if (a === "string") {
    const m = t, g = 120;
    return m.length > g ? /* @__PURE__ */ v.jsx(
      sle,
      {
        label: h,
        value: m,
        styles: f,
        max: g,
        initialOpen: o
      }
    ) : /* @__PURE__ */ v.jsxs("div", { className: "flex items-start", children: [
      h,
      /* @__PURE__ */ v.jsxs(
        "pre",
        {
          className: hc(
            f.string,
            "whitespace-pre-wrap break-words"
          ),
          children: [
            '"',
            m,
            '"'
          ]
        }
      )
    ] });
  }
  return /* @__PURE__ */ v.jsxs("div", { className: "flex items-start", children: [
    h,
    a === "number" && /* @__PURE__ */ v.jsx("span", { className: f.number, children: String(t) }),
    a === "boolean" && /* @__PURE__ */ v.jsx("span", { className: f.boolean, children: String(t) }),
    a === "null" && /* @__PURE__ */ v.jsx("span", { className: f.null, children: "null" }),
    a === "undefined" && /* @__PURE__ */ v.jsx("span", { className: f.undefined, children: "undefined" })
  ] });
});
function sle({
  label: e,
  value: t,
  styles: n,
  max: r,
  initialOpen: i = !1
}) {
  const [o, s] = C.useState(i);
  return /* @__PURE__ */ v.jsxs("div", { className: "flex items-start", children: [
    e,
    /* @__PURE__ */ v.jsx(
      "pre",
      {
        className: hc(
          n.string,
          "whitespace-pre-wrap wrap-break-word cursor-pointer hover:text-green-400"
        ),
        onClick: () => s((a) => !a),
        title: o ? "Collapse" : "Expand",
        children: o ? `"${t}"` : `"${t.slice(0, r)}..."`
      }
    )
  ] });
}
const ale = {
  "Content-Type": "application/json"
};
let lle = null;
function cle() {
  if (typeof window > "u") return null;
  const e = window.__CHATBOT_CONFIG__;
  return !e || typeof e != "object" ? null : e;
}
async function ule() {
  const e = cle();
  try {
    const t = e?.getAuthToken;
    if (typeof t == "function") {
      const n = await t();
      if (typeof n == "string" && n.trim()) return n.trim();
    }
  } catch {
  }
  if (typeof e?.authToken == "string" && e.authToken.trim())
    return e.authToken.trim();
  try {
    const n = await window?.Clerk?.session?.getToken?.();
    if (typeof n == "string" && n.trim()) return n.trim();
  } catch {
  }
  try {
    const t = localStorage.getItem("access_token") ?? localStorage.getItem("token") ?? localStorage.getItem("jwt") ?? "";
    return t && t.trim() ? t.trim() : null;
  } catch {
    return null;
  }
}
async function zc() {
  const e = await ule();
  return {
    ...ale,
    ...e ? { Authorization: `Bearer ${e}` } : {}
  };
}
const dle = async (e, t) => {
  const n = await zc(), r = await fetch(e, {
    redirect: "follow",
    cache: "no-store",
    ...t,
    headers: {
      ...n,
      ...t?.headers
    }
  });
  if (!r.ok) {
    let i;
    try {
      i = await r.json();
    } catch {
      i = { message: `Request failed with status ${r.status}` };
    }
    const o = new Error(
      i.message || "An error occurred while fetching the data."
    );
    throw Object.assign(o, { info: i, status: r.status }), o;
  }
  return r.json();
}, ch = (e) => typeof e == "string", fle = (e) => Object(e) === e, hle = (e) => {
  try {
    if (typeof e == "string") {
      const t = e.trim();
      return JSON.parse(t), !0;
    } else if (fle(e))
      return !0;
    return !1;
  } catch {
    return !1;
  }
}, yLe = () => {
  let e;
  const t = (n, r = 200) => (clearTimeout(e), e = setTimeout(() => n(), r), e);
  return t.clear = () => {
    clearTimeout(e);
  }, t;
};
function ple() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e) => {
    const t = Math.random() * 16 | 0;
    return (e === "x" ? t : t & 3 | 8).toString(16);
  });
}
function mle(e) {
  return e == null ? "unknown error" : typeof e == "string" ? e : e instanceof Error ? e.message : JSON.stringify(e);
}
function t9(e) {
  return {
    map: (t) => Object.fromEntries(
      Object.entries(e).map(([n, r]) => [n, t(r, n)])
    ),
    filter: (t) => Object.fromEntries(
      Object.entries(e).filter(([n, r]) => t(r, n))
    ),
    forEach: (t) => {
      Object.entries(e).forEach(([n, r]) => t(r, n));
    },
    some: (t) => Object.entries(e).some(([n, r]) => t(r, n)),
    every: (t) => Object.entries(e).every(([n, r]) => t(r, n)),
    find(t) {
      return Object.entries(e).find(([n, r]) => t(r, n))?.[1];
    },
    getByPath(t) {
      let n = e;
      return t.find((r) => (n = n?.[r], !n)), n;
    },
    setByPath(t, n) {
      return t.reduce((r, i, o) => o == t.length - 1 ? (r[i] = n, r) : (r[i] ??= {}, r[i]), e), e;
    }
  };
}
function vLe(e, t) {
  let n = e, r = 1;
  for (; t.includes(n); ) {
    const i = e.replace(/\d+$/, "");
    if (e !== i) {
      const s = parseInt(e.match(/\d+$/)?.[0] || "0");
      n = i + (s + r);
    } else
      n = i + r;
    r++;
  }
  return n;
}
function Cj(e) {
  return e ? e.startsWith("user_") ? e.replace("user_", "") : e : null;
}
const gb = (e, t) => (cn.error(`${e?.name || "Error"}`, {
  description: /* @__PURE__ */ v.jsx("div", { className: "my-4 max-h-[340px] overflow-y-auto", children: /* @__PURE__ */ v.jsx(Ju, { data: mle(e) }) }),
  id: t
}), e), gle = C.createContext(null);
function ra() {
  const e = C.useContext(gle);
  if (!e)
    throw new Error("useAppStore must be used within an AppProvider");
  return e;
}
const n9 = 0, r9 = 1, i9 = 2, Ej = 3;
var _j = Object.prototype.hasOwnProperty;
function p_(e, t) {
  var n, r;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((r = e.length) === t.length)
        for (; r-- && p_(e[r], t[r]); ) ;
      return r === -1;
    }
    if (!n || typeof e == "object") {
      r = 0;
      for (n in e)
        if (_j.call(e, n) && ++r && !_j.call(t, n) || !(n in t) || !p_(e[n], t[n])) return !1;
      return Object.keys(t).length === r;
    }
  }
  return e !== e && t !== t;
}
const Ua = /* @__PURE__ */ new WeakMap(), Va = () => {
}, hi = (
  /*#__NOINLINE__*/
  Va()
), m_ = Object, Xt = (e) => e === hi, Vs = (e) => typeof e == "function", Tc = (e, t) => ({
  ...e,
  ...t
}), o9 = (e) => Vs(e.then), Vk = {}, jv = {}, iM = "undefined", qg = typeof window != iM, g_ = typeof document != iM, yle = qg && "Deno" in window, vle = () => qg && typeof window.requestAnimationFrame != iM, s9 = (e, t) => {
  const n = Ua.get(e);
  return [
    // Getter
    () => !Xt(t) && e.get(t) || Vk,
    // Setter
    (r) => {
      if (!Xt(t)) {
        const i = e.get(t);
        t in jv || (jv[t] = i), n[5](t, Tc(i, r), i || Vk);
      }
    },
    // Subscriber
    n[6],
    // Get server cache snapshot
    () => !Xt(t) && t in jv ? jv[t] : !Xt(t) && e.get(t) || Vk
  ];
};
let y_ = !0;
const ble = () => y_, [v_, b_] = qg && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  Va,
  Va
], xle = () => {
  const e = g_ && document.visibilityState;
  return Xt(e) || e !== "hidden";
}, wle = (e) => (g_ && document.addEventListener("visibilitychange", e), v_("focus", e), () => {
  g_ && document.removeEventListener("visibilitychange", e), b_("focus", e);
}), Sle = (e) => {
  const t = () => {
    y_ = !0, e();
  }, n = () => {
    y_ = !1;
  };
  return v_("online", t), v_("offline", n), () => {
    b_("online", t), b_("offline", n);
  };
}, kle = {
  isOnline: ble,
  isVisible: xle
}, Cle = {
  initFocus: wle,
  initReconnect: Sle
}, Tj = !Ne.useId, Zf = !qg || yle, Ele = (e) => vle() ? window.requestAnimationFrame(e) : setTimeout(e, 1), Hk = Zf ? C.useEffect : C.useLayoutEffect, Wk = typeof navigator < "u" && navigator.connection, Aj = !Zf && Wk && ([
  "slow-2g",
  "2g"
].includes(Wk.effectiveType) || Wk.saveData), Iv = /* @__PURE__ */ new WeakMap(), _le = (e) => m_.prototype.toString.call(e), qk = (e, t) => e === `[object ${t}]`;
let Tle = 0;
const x_ = (e) => {
  const t = typeof e, n = _le(e), r = qk(n, "Date"), i = qk(n, "RegExp"), o = qk(n, "Object");
  let s, a;
  if (m_(e) === e && !r && !i) {
    if (s = Iv.get(e), s) return s;
    if (s = ++Tle + "~", Iv.set(e, s), Array.isArray(e)) {
      for (s = "@", a = 0; a < e.length; a++)
        s += x_(e[a]) + ",";
      Iv.set(e, s);
    }
    if (o) {
      s = "#";
      const c = m_.keys(e).sort();
      for (; !Xt(a = c.pop()); )
        Xt(e[a]) || (s += a + ":" + x_(e[a]) + ",");
      Iv.set(e, s);
    }
  } else
    s = r ? e.toJSON() : t == "symbol" ? e.toString() : t == "string" ? JSON.stringify(e) : "" + e;
  return s;
}, oM = (e) => {
  if (Vs(e))
    try {
      e = e();
    } catch {
      e = "";
    }
  const t = e;
  return e = typeof e == "string" ? e : (Array.isArray(e) ? e.length : e) ? x_(e) : "", [
    e,
    t
  ];
};
let Ale = 0;
const w_ = () => ++Ale;
async function a9(...e) {
  const [t, n, r, i] = e, o = Tc({
    populateCache: !0,
    throwOnError: !0
  }, typeof i == "boolean" ? {
    revalidate: i
  } : i || {});
  let s = o.populateCache;
  const a = o.rollbackOnError;
  let c = o.optimisticData;
  const u = (m) => typeof a == "function" ? a(m) : a !== !1, f = o.throwOnError;
  if (Vs(n)) {
    const m = n, g = [], b = t.keys();
    for (const x of b)
      // Skip the special useSWRInfinite and useSWRSubscription keys.
      !/^\$(inf|sub)\$/.test(x) && m(t.get(x)._k) && g.push(x);
    return Promise.all(g.map(h));
  }
  return h(n);
  async function h(m) {
    const [g] = oM(m);
    if (!g) return;
    const [b, x] = s9(t, g), [w, S, _, M] = Ua.get(t), N = () => {
      const ie = w[g];
      return (Vs(o.revalidate) ? o.revalidate(b().data, m) : o.revalidate !== !1) && (delete _[g], delete M[g], ie && ie[0]) ? ie[0](i9).then(() => b().data) : b().data;
    };
    if (e.length < 3)
      return N();
    let P = r, I, O = !1;
    const L = w_();
    S[g] = [
      L,
      0
    ];
    const U = !Xt(c), B = b(), G = B.data, Y = B._c, he = Xt(Y) ? G : Y;
    if (U && (c = Vs(c) ? c(he, G) : c, x({
      data: c,
      _c: he
    })), Vs(P))
      try {
        P = P(he);
      } catch (ie) {
        I = ie, O = !0;
      }
    if (P && o9(P))
      if (P = await P.catch((ie) => {
        I = ie, O = !0;
      }), L !== S[g][0]) {
        if (O) throw I;
        return P;
      } else O && U && u(I) && (s = !0, x({
        data: he,
        _c: hi
      }));
    if (s && !O)
      if (Vs(s)) {
        const ie = s(P, he);
        x({
          data: ie,
          error: hi,
          _c: hi
        });
      } else
        x({
          data: P,
          error: hi,
          _c: hi
        });
    if (S[g][1] = w_(), Promise.resolve(N()).then(() => {
      x({
        _c: hi
      });
    }), O) {
      if (f) throw I;
      return;
    }
    return P;
  }
}
const Mj = (e, t) => {
  for (const n in e)
    e[n][0] && e[n][0](t);
}, Mle = (e, t) => {
  if (!Ua.has(e)) {
    const n = Tc(Cle, t), r = /* @__PURE__ */ Object.create(null), i = a9.bind(hi, e);
    let o = Va;
    const s = /* @__PURE__ */ Object.create(null), a = (f, h) => {
      const m = s[f] || [];
      return s[f] = m, m.push(h), () => m.splice(m.indexOf(h), 1);
    }, c = (f, h, m) => {
      e.set(f, h);
      const g = s[f];
      if (g)
        for (const b of g)
          b(h, m);
    }, u = () => {
      if (!Ua.has(e) && (Ua.set(e, [
        r,
        /* @__PURE__ */ Object.create(null),
        /* @__PURE__ */ Object.create(null),
        /* @__PURE__ */ Object.create(null),
        i,
        c,
        a
      ]), !Zf)) {
        const f = n.initFocus(setTimeout.bind(hi, Mj.bind(hi, r, n9))), h = n.initReconnect(setTimeout.bind(hi, Mj.bind(hi, r, r9)));
        o = () => {
          f && f(), h && h(), Ua.delete(e);
        };
      }
    };
    return u(), [
      e,
      i,
      u,
      o
    ];
  }
  return [
    e,
    Ua.get(e)[4]
  ];
}, Nle = (e, t, n, r, i) => {
  const o = n.errorRetryCount, s = i.retryCount, a = ~~((Math.random() + 0.5) * (1 << (s < 8 ? s : 8))) * n.errorRetryInterval;
  !Xt(o) && s > o || setTimeout(r, a, i);
}, Rle = p_, [l9, S_] = Mle(/* @__PURE__ */ new Map()), Ole = Tc(
  {
    // events
    onLoadingSlow: Va,
    onSuccess: Va,
    onError: Va,
    onErrorRetry: Nle,
    onDiscarded: Va,
    // switches
    revalidateOnFocus: !0,
    revalidateOnReconnect: !0,
    revalidateIfStale: !0,
    shouldRetryOnError: !0,
    // timeouts
    errorRetryInterval: Aj ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: Aj ? 5e3 : 3e3,
    // providers
    compare: Rle,
    isPaused: () => !1,
    cache: l9,
    mutate: S_,
    fallback: {}
  },
  // use web preset by default
  kle
), Dle = (e, t) => {
  const n = Tc(e, t);
  if (t) {
    const { use: r, fallback: i } = e, { use: o, fallback: s } = t;
    r && o && (n.use = r.concat(o)), i && s && (n.fallback = Tc(i, s));
  }
  return n;
}, Ple = C.createContext({}), jle = "$inf$", c9 = qg && window.__SWR_DEVTOOLS_USE__, Ile = c9 ? window.__SWR_DEVTOOLS_USE__ : [], zle = () => {
  c9 && (window.__SWR_DEVTOOLS_REACT__ = Ne);
}, Lle = (e) => Vs(e[1]) ? [
  e[0],
  e[1],
  e[2] || {}
] : [
  e[0],
  null,
  (e[1] === null ? e[2] : e[1]) || {}
], u9 = () => {
  const e = C.useContext(Ple);
  return C.useMemo(() => Tc(Ole, e), [
    e
  ]);
}, Ble = (e) => (t, n, r) => e(t, n && ((...o) => {
  const [s] = oM(t), [, , , a] = Ua.get(l9);
  if (s.startsWith(jle))
    return n(...o);
  const c = a[s];
  return Xt(c) ? n(...o) : (delete a[s], c);
}), r), $le = Ile.concat(Ble), Ule = (e) => function(...n) {
  const r = u9(), [i, o, s] = Lle(n), a = Dle(r, s);
  let c = e;
  const { use: u } = a, f = (u || []).concat($le);
  for (let h = f.length; h--; )
    c = f[h](c);
  return c(i, o || a.fetcher || null, a);
}, Fle = (e, t, n) => {
  const r = t[e] || (t[e] = []);
  return r.push(n), () => {
    const i = r.indexOf(n);
    i >= 0 && (r[i] = r[r.length - 1], r.pop());
  };
};
zle();
const Gk = Ne.use || // This extra generic is to avoid TypeScript mixing up the generic and JSX sytax
// and emitting an error.
// We assume that this is only for the `use(thenable)` case, not `use(context)`.
// https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45
((e) => {
  switch (e.status) {
    case "pending":
      throw e;
    case "fulfilled":
      return e.value;
    case "rejected":
      throw e.reason;
    default:
      throw e.status = "pending", e.then((t) => {
        e.status = "fulfilled", e.value = t;
      }, (t) => {
        e.status = "rejected", e.reason = t;
      }), e;
  }
}), Kk = {
  dedupe: !0
}, Nj = Promise.resolve(hi), Vle = () => Va, Hle = (e, t, n) => {
  const { cache: r, compare: i, suspense: o, fallbackData: s, revalidateOnMount: a, revalidateIfStale: c, refreshInterval: u, refreshWhenHidden: f, refreshWhenOffline: h, keepPreviousData: m, strictServerPrefetchWarning: g } = n, [b, x, w, S] = Ua.get(r), [_, M] = oM(e), N = C.useRef(!1), P = C.useRef(!1), I = C.useRef(_), O = C.useRef(t), L = C.useRef(n), U = () => L.current, B = () => U().isVisible() && U().isOnline(), [G, Y, he, ie] = s9(r, _), ne = C.useRef({}).current, H = Xt(s) ? Xt(n.fallback) ? hi : n.fallback[_] : s, Q = (St, Vt) => {
    for (const xt in ne) {
      const Kt = xt;
      if (Kt === "data") {
        if (!i(St[Kt], Vt[Kt]) && (!Xt(St[Kt]) || !i(re, Vt[Kt])))
          return !1;
      } else if (Vt[Kt] !== St[Kt])
        return !1;
    }
    return !0;
  }, X = !N.current, Se = C.useMemo(() => {
    const St = G(), Vt = ie(), xt = (sn) => {
      const Pn = Tc(sn);
      return delete Pn._k, (() => {
        if (!_ || !t || U().isPaused()) return !1;
        if (X && !Xt(a)) return a;
        const mt = Xt(H) ? Pn.data : H;
        return Xt(mt) || c;
      })() ? {
        isValidating: !0,
        isLoading: !0,
        ...Pn
      } : Pn;
    }, Kt = xt(St), An = St === Vt ? Kt : xt(Vt);
    let Nt = Kt;
    return [
      () => {
        const sn = xt(G());
        return Q(sn, Nt) ? (Nt.data = sn.data, Nt.isLoading = sn.isLoading, Nt.isValidating = sn.isValidating, Nt.error = sn.error, Nt) : (Nt = sn, sn);
      },
      () => An
    ];
  }, [
    r,
    _
  ]), W = nh.useSyncExternalStore(C.useCallback(
    (St) => he(_, (Vt, xt) => {
      Q(xt, Vt) || St();
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      r,
      _
    ]
  ), Se[0], Se[1]), Z = b[_] && b[_].length > 0, pe = W.data, F = Xt(pe) ? H && o9(H) ? Gk(H) : H : pe, ee = W.error, ge = C.useRef(F), re = m ? Xt(pe) ? Xt(ge.current) ? F : ge.current : pe : F, J = _ && Xt(F), xe = C.useRef(null);
  !Zf && // getServerSnapshot is only called during hydration
  // eslint-disable-next-line react-hooks/rules-of-hooks
  nh.useSyncExternalStore(Vle, () => (xe.current = !1, xe), () => (xe.current = !0, xe));
  const be = xe.current;
  g && be && !o && J && console.warn(`Missing pre-initiated data for serialized key "${_}" during server-side rendering. Data fetching should be initiated on the server and provided to SWR via fallback data. You can set "strictServerPrefetchWarning: false" to disable this warning.`);
  const Ae = !_ || !t || U().isPaused() || Z && !Xt(ee) ? !1 : X && !Xt(a) ? a : o ? Xt(F) ? !1 : c : Xt(F) || c, tt = Xt(W.isValidating) ? Ae : W.isValidating, Ge = Xt(W.isLoading) ? Ae : W.isLoading, nt = C.useCallback(
    async (St) => {
      const Vt = O.current;
      if (!_ || !Vt || P.current || U().isPaused())
        return !1;
      let xt, Kt, An = !0;
      const Nt = St || {}, sn = !w[_] || !Nt.dedupe, Pn = () => Tj ? !P.current && _ === I.current && N.current : _ === I.current, Mn = {
        isValidating: !1,
        isLoading: !1
      }, mt = () => {
        Y(Mn);
      }, ke = () => {
        const He = w[_];
        He && He[1] === Kt && delete w[_];
      }, Pe = {
        isValidating: !0
      };
      Xt(G().data) && (Pe.isLoading = !0);
      try {
        if (sn && (Y(Pe), n.loadingTimeout && Xt(G().data) && setTimeout(() => {
          An && Pn() && U().onLoadingSlow(_, n);
        }, n.loadingTimeout), w[_] = [
          Vt(M),
          w_()
        ]), [xt, Kt] = w[_], xt = await xt, sn && setTimeout(ke, n.dedupingInterval), !w[_] || w[_][1] !== Kt)
          return sn && Pn() && U().onDiscarded(_), !1;
        Mn.error = hi;
        const He = x[_];
        if (!Xt(He) && // case 1
        (Kt <= He[0] || // case 2
        Kt <= He[1] || // case 3
        He[1] === 0))
          return mt(), sn && Pn() && U().onDiscarded(_), !1;
        const et = G().data;
        Mn.data = i(et, xt) ? et : xt, sn && Pn() && U().onSuccess(xt, _, n);
      } catch (He) {
        ke();
        const et = U(), { shouldRetryOnError: bt } = et;
        et.isPaused() || (Mn.error = He, sn && Pn() && (et.onError(He, _, et), (bt === !0 || Vs(bt) && bt(He)) && (!U().revalidateOnFocus || !U().revalidateOnReconnect || B()) && et.onErrorRetry(He, _, et, (Ct) => {
          const fn = b[_];
          fn && fn[0] && fn[0](Ej, Ct);
        }, {
          retryCount: (Nt.retryCount || 0) + 1,
          dedupe: !0
        })));
      }
      return An = !1, mt(), !0;
    },
    // `setState` is immutable, and `eventsCallback`, `fnArg`, and
    // `keyValidating` are depending on `key`, so we can exclude them from
    // the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // `useSWR('key', () => fetch('/api/'), { suspense: true })`
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      _,
      r
    ]
  ), _t = C.useCallback(
    // Use callback to make sure `keyRef.current` returns latest result every time
    (...St) => a9(r, I.current, ...St),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (Hk(() => {
    O.current = t, L.current = n, Xt(pe) || (ge.current = pe);
  }), Hk(() => {
    if (!_) return;
    const St = nt.bind(hi, Kk);
    let Vt = 0;
    U().revalidateOnFocus && (Vt = Date.now() + U().focusThrottleInterval);
    const Kt = Fle(_, b, (An, Nt = {}) => {
      if (An == n9) {
        const sn = Date.now();
        U().revalidateOnFocus && sn > Vt && B() && (Vt = sn + U().focusThrottleInterval, St());
      } else if (An == r9)
        U().revalidateOnReconnect && B() && St();
      else {
        if (An == i9)
          return nt();
        if (An == Ej)
          return nt(Nt);
      }
    });
    return P.current = !1, I.current = _, N.current = !0, Y({
      _k: M
    }), Ae && (w[_] || (Xt(F) || Zf ? St() : Ele(St))), () => {
      P.current = !0, Kt();
    };
  }, [
    _
  ]), Hk(() => {
    let St;
    function Vt() {
      const Kt = Vs(u) ? u(G().data) : u;
      Kt && St !== -1 && (St = setTimeout(xt, Kt));
    }
    function xt() {
      !G().error && (f || U().isVisible()) && (h || U().isOnline()) ? nt(Kk).then(Vt) : Vt();
    }
    return Vt(), () => {
      St && (clearTimeout(St), St = -1);
    };
  }, [
    u,
    f,
    h,
    _
  ]), C.useDebugValue(re), o) {
    if (!Tj && Zf && J)
      throw new Error("Fallback data is required when using Suspense in SSR.");
    J && (O.current = t, L.current = n, P.current = !1);
    const St = S[_], Vt = !Xt(St) && J ? _t(St) : Nj;
    if (Gk(Vt), !Xt(ee) && J)
      throw ee;
    const xt = J ? nt(Kk) : Nj;
    !Xt(re) && J && (xt.status = "fulfilled", xt.value = !0), Gk(xt);
  }
  return {
    mutate: _t,
    get data() {
      return ne.data = !0, re;
    },
    get error() {
      return ne.error = !0, ee;
    },
    get isValidating() {
      return ne.isValidating = !0, tt;
    },
    get isLoading() {
      return ne.isLoading = !0, Ge;
    }
  };
}, Wle = Ule(Hle);
function d9(e) {
  const t = ra(), n = async (i, o) => {
    const s = await dle(i, o);
    return Array.isArray(s) ? s : s && Array.isArray(s.servers) ? s.servers : [];
  }, r = Wle(`${Ws}/list`, n, {
    revalidateOnFocus: !1,
    errorRetryCount: 0,
    focusThrottleInterval: 1e3 * 60 * 5,
    // ensure returned data is an array for consumers
    fallbackData: [],
    onError: gb,
    onSuccess: (i) => {
      if (!Array.isArray(i)) {
        t.chatbotServerStore.mcpServerList.value = [];
        return;
      }
      const o = new Set(i.map((s) => String(s.id)));
      t.chatbotServerStore.mcpServerList.value = i, t.chatbotServerStore.allowedMcpServers.value = t9(t.chatbotServerStore.allowedMcpServers.value || {}).filter(
        (s, a) => o.has(String(a))
      );
    },
    ...e
  });
  return C.useEffect(() => {
    (async () => {
      try {
        const i = await zc();
        t.chatbotServerStore.loadMcpServersInBackground({
          token: null,
          baseUrl: "",
          headers: i
          // Pass full headers including auth
        });
      } catch (i) {
        console.warn("Failed to get auth headers for worker:", i), t.chatbotServerStore.loadMcpServersInBackground();
      }
    })();
  }, [t.chatbotServerStore]), r;
}
function f9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card",
      className: at(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        e
      ),
      ...t
    }
  );
}
function h9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-header",
      className: at(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        e
      ),
      ...t
    }
  );
}
function qle({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-title",
      className: at("leading-none font-semibold", e),
      ...t
    }
  );
}
function Gle({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-description",
      className: at("text-muted-foreground text-sm", e),
      ...t
    }
  );
}
function p9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "card-content",
      className: at("px-6", e),
      ...t
    }
  );
}
function sM({ className: e, type: t, ...n }) {
  return /* @__PURE__ */ v.jsx(
    "input",
    {
      type: t,
      "data-slot": "input",
      className: at(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-sm border bg-transparent px-3 py-1 text-xs shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50",
        "focus:border-input focus-visible:border-input",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        e
      ),
      ...n
    }
  );
}
var Kle = "Separator", Rj = "horizontal", Zle = ["horizontal", "vertical"], aM = C.forwardRef((e, t) => {
  const { decorative: n, orientation: r = Rj, ...i } = e, o = Yle(r) ? r : Rj, a = n ? { role: "none" } : { "aria-orientation": o === "vertical" ? o : void 0, role: "separator" };
  return /* @__PURE__ */ v.jsx(
    Hg.div,
    {
      "data-orientation": o,
      ...a,
      ...i,
      ref: t
    }
  );
});
aM.displayName = Kle;
function Yle(e) {
  return Zle.includes(e);
}
var Xle = aM;
function yb({
  className: e,
  orientation: t = "horizontal",
  decorative: n = !0,
  ...r
}) {
  return /* @__PURE__ */ v.jsx(
    Xle,
    {
      "data-slot": "separator",
      decorative: n,
      orientation: t,
      className: at(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        e
      ),
      ...r
    }
  );
}
const Jle = (e) => {
  if (!e) return !0;
  const t = e.properties || e;
  return Object.keys(t).length === 0;
}, Qle = ({
  tool: e,
  children: t,
  serverId: n,
  onUpdate: r
}) => /* @__PURE__ */ v.jsxs(Ph, { children: [
  /* @__PURE__ */ v.jsx(x$, { asChild: !0, children: t }),
  /* @__PURE__ */ v.jsx(w$, { children: /* @__PURE__ */ v.jsx(jh, { className: "sm:max-w-[800px] fixed p-10 overflow-hidden", children: /* @__PURE__ */ v.jsx(
    ece,
    {
      onUpdate: r,
      tool: e,
      serverId: n
    }
  ) }) })
] });
function ece({
  tool: e,
  title: t
  // serverId,
  // onUpdate,
}) {
  return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col overflow-y-auto h-[70vh]", children: [
    /* @__PURE__ */ v.jsxs("div", { className: "space-y-6 pb-4", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3", children: [
        /* @__PURE__ */ v.jsx("div", { className: "shrink-0 w-8 h-8 rounded-lg bg-primary/10 flex items-center justify-center", children: /* @__PURE__ */ v.jsx(
          "svg",
          {
            className: "w-4 h-4 text-primary",
            fill: "none",
            strokeWidth: "2",
            stroke: "currentColor",
            viewBox: "0 0 24 24",
            children: /* @__PURE__ */ v.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M11.42 15.17L17.25 21A2.652 2.652 0 0021 17.25l-5.877-5.877M11.42 15.17l2.496-3.03c.317-.384.74-.626 1.208-.766M11.42 15.17l-4.655 5.653a2.548 2.548 0 11-3.586-3.586l6.837-5.63m5.108-.233c.55-.164 1.163-.188 1.743-.14a4.5 4.5 0 004.486-6.336l-3.276 3.277a3.004 3.004 0 01-2.25-2.25l3.276-3.276a4.5 4.5 0 00-6.336 4.486c.091 1.076-.071 2.264-.904 2.95l-.102.085m-1.745 1.437L5.909 7.5H4.5L2.25 3.75l1.5-1.5L7.5 4.5v1.409l4.26 4.26m-1.745 1.437l1.745-1.437m6.615 8.206L15.75 15.75M4.867 19.125h.008v.008h-.008v-.008z" })
          }
        ) }),
        /* @__PURE__ */ v.jsx(Ih, { className: "text-xl font-normal tracking-tight", children: t || e.name })
      ] }),
      /* @__PURE__ */ v.jsx("div", { className: "space-y-2", children: /* @__PURE__ */ v.jsx(k$, { className: "text-sm leading-relaxed text-foreground/90 whitespace-pre-wrap", children: e.description }) })
    ] }),
    /* @__PURE__ */ v.jsx(yb, { className: "my-6" }),
    /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-2 mb-3", children: /* @__PURE__ */ v.jsx("h5", { className: "text-sm font-normal text-foreground/90", children: "Input Schema" }) }),
    e.inputSchema ? /* @__PURE__ */ v.jsx("div", { className: "overflow-y-auto max-h-[40vh] space-y-3", children: Jle(e.inputSchema) ? /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground", children: "No schema properties available" }) : /* @__PURE__ */ v.jsx(Ju, { data: e.inputSchema?.properties || e.inputSchema }) }) : /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground", children: "No schema properties available" }),
    /* @__PURE__ */ v.jsx("div", { className: "absolute left-0 right-0 bottom-0 h-12 bg-linear-to-t from-background to-transparent pointer-events-none z-10" })
  ] });
}
const tce = C.memo(
  ({ tools: e, serverId: t, searchQuery: n = "" }) => {
    const r = C.useMemo(() => {
      if (!n.trim()) return e;
      const i = n.toLowerCase();
      return e.filter(
        (o) => o.name.toLowerCase().includes(i) || o.description?.toLowerCase().includes(i)
      );
    }, [e, n]);
    return /* @__PURE__ */ v.jsx("div", { className: "space-y-2 pr-2", children: r.length > 0 ? r.map((i) => /* @__PURE__ */ v.jsxs(
      "div",
      {
        className: "flex items-start gap-2 bg-secondary rounded-md p-2 hover:bg-input transition-colors",
        children: [
          /* @__PURE__ */ v.jsx(Qle, { tool: i, serverId: t, children: /* @__PURE__ */ v.jsxs("div", { className: "flex-1 min-w-0 cursor-pointer", children: [
            /* @__PURE__ */ v.jsx("p", { className: "font-medium text-sm mb-1 truncate", children: i.name }),
            /* @__PURE__ */ v.jsx("p", { className: "text-xs text-muted-foreground line-clamp-1", children: i.description })
          ] }) }),
          /* @__PURE__ */ v.jsx("div", { className: "flex items-center px-1 justify-center self-stretch", children: /* @__PURE__ */ v.jsx(Ng, { size: 16 }) })
        ]
      },
      i.name
    )) : /* @__PURE__ */ v.jsxs("div", { className: "text-center py-6 text-sm text-muted-foreground", children: [
      'No tools found matching "',
      n,
      '"'
    ] }) });
  }
), nce = PA(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive: "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function m9({
  className: e,
  variant: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "alert",
      role: "alert",
      className: at(nce({ variant: t }), e),
      ...n
    }
  );
}
function g9({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "alert-title",
      className: at(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        e
      ),
      ...t
    }
  );
}
function y9({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "alert-description",
      className: at(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        e
      ),
      ...t
    }
  );
}
const v9 = C.memo(({ error: e }) => /* @__PURE__ */ v.jsx("div", { className: "px-6 pb-2", children: /* @__PURE__ */ v.jsxs(m9, { variant: "destructive", className: "border-destructive", children: [
  /* @__PURE__ */ v.jsx(g9, { children: "Error" }),
  /* @__PURE__ */ v.jsx(y9, { className: "whitespace-pre-wrap wrap-break-word", children: e })
] }) }));
v9.displayName = "ErrorAlert";
function rce({ className: e }) {
  return /* @__PURE__ */ v.jsx(
    "svg",
    {
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      className: e,
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      "aria-hidden": "true",
      children: /* @__PURE__ */ v.jsx(
        "path",
        {
          d: "M15.6729 3.91287C16.8918 2.69392 18.8682 2.69392 20.0871 3.91287C21.3061 5.13182 21.3061 7.10813 20.0871 8.32708L14.1499 14.2643C13.3849 15.0293 12.3925 15.5255 11.3215 15.6785L9.14142 15.9899C8.82983 16.0344 8.51546 15.9297 8.29289 15.7071C8.07033 15.4845 7.96554 15.1701 8.01005 14.8586L8.32149 12.6785C8.47449 11.6075 8.97072 10.615 9.7357 9.85006L15.6729 3.91287ZM18.6729 5.32708C18.235 4.88918 17.525 4.88918 17.0871 5.32708L11.1499 11.2643C10.6909 11.7233 10.3932 12.3187 10.3014 12.9613L10.1785 13.8215L11.0386 13.6986C11.6812 13.6068 12.2767 13.3091 12.7357 12.8501L18.6729 6.91287C19.1108 6.47497 19.1108 5.76499 18.6729 5.32708ZM11 3.99929C11.0004 4.55157 10.5531 4.99963 10.0008 5.00007C9.00227 5.00084 8.29769 5.00827 7.74651 5.06064C7.20685 5.11191 6.88488 5.20117 6.63803 5.32695C6.07354 5.61457 5.6146 6.07351 5.32698 6.63799C5.19279 6.90135 5.10062 7.24904 5.05118 7.8542C5.00078 8.47105 5 9.26336 5 10.4V13.6C5 14.7366 5.00078 15.5289 5.05118 16.1457C5.10062 16.7509 5.19279 17.0986 5.32698 17.3619C5.6146 17.9264 6.07354 18.3854 6.63803 18.673C6.90138 18.8072 7.24907 18.8993 7.85424 18.9488C8.47108 18.9992 9.26339 19 10.4 19H13.6C14.7366 19 15.5289 18.9992 16.1458 18.9488C16.7509 18.8993 17.0986 18.8072 17.362 18.673C17.9265 18.3854 18.3854 17.9264 18.673 17.3619C18.7988 17.1151 18.8881 16.7931 18.9393 16.2535C18.9917 15.7023 18.9991 14.9977 18.9999 13.9992C19.0003 13.4469 19.4484 12.9995 20.0007 13C20.553 13.0004 21.0003 13.4485 20.9999 14.0007C20.9991 14.9789 20.9932 15.7808 20.9304 16.4426C20.8664 17.116 20.7385 17.7136 20.455 18.2699C19.9757 19.2107 19.2108 19.9756 18.27 20.455C17.6777 20.7568 17.0375 20.8826 16.3086 20.9421C15.6008 21 14.7266 21 13.6428 21H10.3572C9.27339 21 8.39925 21 7.69138 20.9421C6.96253 20.8826 6.32234 20.7568 5.73005 20.455C4.78924 19.9756 4.02433 19.2107 3.54497 18.2699C3.24318 17.6776 3.11737 17.0374 3.05782 16.3086C2.99998 15.6007 2.99999 14.7266 3 13.6428V10.3572C2.99999 9.27337 2.99998 8.39922 3.05782 7.69134C3.11737 6.96249 3.24318 6.3223 3.54497 5.73001C4.02433 4.7892 4.78924 4.0243 5.73005 3.54493C6.28633 3.26149 6.88399 3.13358 7.55735 3.06961C8.21919 3.00673 9.02103 3.00083 9.99922 3.00007C10.5515 2.99964 10.9996 3.447 11 3.99929Z",
          fill: "currentColor"
        }
      )
    }
  );
}
function ri(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function el(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function k_({
  pathname: e = "/",
  search: t = "",
  hash: n = ""
}) {
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e;
}
function lM(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && (t.hash = e.substring(n), e = e.substring(0, n));
    let r = e.indexOf("?");
    r >= 0 && (t.search = e.substring(r), e = e.substring(0, r)), e && (t.pathname = e);
  }
  return t;
}
function b9(e, t, n = "/") {
  return ice(e, t, n, !1);
}
function ice(e, t, n, r) {
  let i = typeof t == "string" ? lM(t) : t, o = Ac(i.pathname || "/", n);
  if (o == null)
    return null;
  let s = x9(e);
  oce(s);
  let a = null;
  for (let c = 0; a == null && c < s.length; ++c) {
    let u = gce(o);
    a = pce(
      s[c],
      u,
      r
    );
  }
  return a;
}
function x9(e, t = [], n = [], r = "", i = !1) {
  let o = (s, a, c = i, u) => {
    let f = {
      relativePath: u === void 0 ? s.path || "" : u,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: a,
      route: s
    };
    if (f.relativePath.startsWith("/")) {
      if (!f.relativePath.startsWith(r) && c)
        return;
      ri(
        f.relativePath.startsWith(r),
        `Absolute route path "${f.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      ), f.relativePath = f.relativePath.slice(r.length);
    }
    let h = qa([r, f.relativePath]), m = n.concat(f);
    s.children && s.children.length > 0 && (ri(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      s.index !== !0,
      `Index routes must not have child routes. Please remove all child routes from route path "${h}".`
    ), x9(
      s.children,
      t,
      m,
      h,
      c
    )), !(s.path == null && !s.index) && t.push({
      path: h,
      score: fce(h, s.index),
      routesMeta: m
    });
  };
  return e.forEach((s, a) => {
    if (s.path === "" || !s.path?.includes("?"))
      o(s, a);
    else
      for (let c of w9(s.path))
        o(s, a, !0, c);
  }), t;
}
function w9(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, "");
  if (r.length === 0)
    return i ? [o, ""] : [o];
  let s = w9(r.join("/")), a = [];
  return a.push(
    ...s.map(
      (c) => c === "" ? o : [o, c].join("/")
    )
  ), i && a.push(...s), a.map(
    (c) => e.startsWith("/") && c === "" ? "/" : c
  );
}
function oce(e) {
  e.sort(
    (t, n) => t.score !== n.score ? n.score - t.score : hce(
      t.routesMeta.map((r) => r.childrenIndex),
      n.routesMeta.map((r) => r.childrenIndex)
    )
  );
}
var sce = /^:[\w-]+$/, ace = 3, lce = 2, cce = 1, uce = 10, dce = -2, Oj = (e) => e === "*";
function fce(e, t) {
  let n = e.split("/"), r = n.length;
  return n.some(Oj) && (r += dce), t && (r += lce), n.filter((i) => !Oj(i)).reduce(
    (i, o) => i + (sce.test(o) ? ace : o === "" ? cce : uce),
    r
  );
}
function hce(e, t) {
  return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function pce(e, t, n = !1) {
  let { routesMeta: r } = e, i = {}, o = "/", s = [];
  for (let a = 0; a < r.length; ++a) {
    let c = r[a], u = a === r.length - 1, f = o === "/" ? t : t.slice(o.length) || "/", h = vb(
      { path: c.relativePath, caseSensitive: c.caseSensitive, end: u },
      f
    ), m = c.route;
    if (!h && u && n && !r[r.length - 1].route.index && (h = vb(
      {
        path: c.relativePath,
        caseSensitive: c.caseSensitive,
        end: !1
      },
      f
    )), !h)
      return null;
    Object.assign(i, h.params), s.push({
      // TODO: Can this as be avoided?
      params: i,
      pathname: qa([o, h.pathname]),
      pathnameBase: xce(
        qa([o, h.pathnameBase])
      ),
      route: m
    }), h.pathnameBase !== "/" && (o = qa([o, h.pathnameBase]));
  }
  return s;
}
function vb(e, t) {
  typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 });
  let [n, r] = mce(
    e.path,
    e.caseSensitive,
    e.end
  ), i = t.match(n);
  if (!i) return null;
  let o = i[0], s = o.replace(/(.)\/+$/, "$1"), a = i.slice(1);
  return {
    params: r.reduce(
      (u, { paramName: f, isOptional: h }, m) => {
        if (f === "*") {
          let b = a[m] || "";
          s = o.slice(0, o.length - b.length).replace(/(.)\/+$/, "$1");
        }
        const g = a[m];
        return h && !g ? u[f] = void 0 : u[f] = (g || "").replace(/%2F/g, "/"), u;
      },
      {}
    ),
    pathname: o,
    pathnameBase: s,
    pattern: e
  };
}
function mce(e, t = !1, n = !0) {
  el(
    e === "*" || !e.endsWith("*") || e.endsWith("/*"),
    `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`
  );
  let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (s, a, c) => (r.push({ paramName: a, isOptional: c != null }), c ? "/?([^\\/]+)?" : "/([^\\/]+)")
  ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  return e.endsWith("*") ? (r.push({ paramName: "*" }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r];
}
function gce(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return el(
      !1,
      `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`
    ), e;
  }
}
function Ac(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/";
}
var yce = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
function vce(e, t = "/") {
  let {
    pathname: n,
    search: r = "",
    hash: i = ""
  } = typeof e == "string" ? lM(e) : e, o;
  return n ? (n = n.replace(/\/\/+/g, "/"), n.startsWith("/") ? o = Dj(n.substring(1), "/") : o = Dj(n, t)) : o = t, {
    pathname: o,
    search: wce(r),
    hash: Sce(i)
  };
}
function Dj(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((i) => {
    i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
  }), n.length > 1 ? n.join("/") : "/";
}
function Zk(e, t, n, r) {
  return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(
    r
  )}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function bce(e) {
  return e.filter(
    (t, n) => n === 0 || t.route.path && t.route.path.length > 0
  );
}
function S9(e) {
  let t = bce(e);
  return t.map(
    (n, r) => r === t.length - 1 ? n.pathname : n.pathnameBase
  );
}
function k9(e, t, n, r = !1) {
  let i;
  typeof e == "string" ? i = lM(e) : (i = { ...e }, ri(
    !i.pathname || !i.pathname.includes("?"),
    Zk("?", "pathname", "search", i)
  ), ri(
    !i.pathname || !i.pathname.includes("#"),
    Zk("#", "pathname", "hash", i)
  ), ri(
    !i.search || !i.search.includes("#"),
    Zk("#", "search", "hash", i)
  ));
  let o = e === "" || i.pathname === "", s = o ? "/" : i.pathname, a;
  if (s == null)
    a = n;
  else {
    let h = t.length - 1;
    if (!r && s.startsWith("..")) {
      let m = s.split("/");
      for (; m[0] === ".."; )
        m.shift(), h -= 1;
      i.pathname = m.join("/");
    }
    a = h >= 0 ? t[h] : "/";
  }
  let c = vce(i, a), u = s && s !== "/" && s.endsWith("/"), f = (o || s === ".") && n.endsWith("/");
  return !c.pathname.endsWith("/") && (u || f) && (c.pathname += "/"), c;
}
var qa = (e) => e.join("/").replace(/\/\/+/g, "/"), xce = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), wce = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, Sce = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, kce = class {
  constructor(e, t, n, r = !1) {
    this.status = e, this.statusText = t || "", this.internal = r, n instanceof Error ? (this.data = n.toString(), this.error = n) : this.data = n;
  }
};
function Cce(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
function Ece(e) {
  return e.map((t) => t.route.path).filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/";
}
var C9 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
function E9(e, t) {
  let n = e;
  if (typeof n != "string" || !yce.test(n))
    return {
      absoluteURL: void 0,
      isExternal: !1,
      to: n
    };
  let r = n, i = !1;
  if (C9)
    try {
      let o = new URL(window.location.href), s = n.startsWith("//") ? new URL(o.protocol + n) : new URL(n), a = Ac(s.pathname, t);
      s.origin === o.origin && a != null ? n = a + s.search + s.hash : i = !0;
    } catch {
      el(
        !1,
        `<Link to="${n}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
      );
    }
  return {
    absoluteURL: r,
    isExternal: i,
    to: n
  };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var _9 = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
new Set(
  _9
);
var _ce = [
  "GET",
  ..._9
];
new Set(_ce);
var Lh = C.createContext(null);
Lh.displayName = "DataRouter";
var pw = C.createContext(null);
pw.displayName = "DataRouterState";
var Tce = C.createContext(!1), T9 = C.createContext({
  isTransitioning: !1
});
T9.displayName = "ViewTransition";
var Ace = C.createContext(
  /* @__PURE__ */ new Map()
);
Ace.displayName = "Fetchers";
var Mce = C.createContext(null);
Mce.displayName = "Await";
var gs = C.createContext(
  null
);
gs.displayName = "Navigation";
var cM = C.createContext(
  null
);
cM.displayName = "Location";
var nl = C.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
nl.displayName = "Route";
var uM = C.createContext(null);
uM.displayName = "RouteError";
var A9 = "REACT_ROUTER_ERROR", Nce = "REDIRECT", Rce = "ROUTE_ERROR_RESPONSE";
function Oce(e) {
  if (e.startsWith(`${A9}:${Nce}:{`))
    try {
      let t = JSON.parse(e.slice(28));
      if (typeof t == "object" && t && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.location == "string" && typeof t.reloadDocument == "boolean" && typeof t.replace == "boolean")
        return t;
    } catch {
    }
}
function Dce(e) {
  if (e.startsWith(
    `${A9}:${Rce}:{`
  ))
    try {
      let t = JSON.parse(e.slice(40));
      if (typeof t == "object" && t && typeof t.status == "number" && typeof t.statusText == "string")
        return new kce(
          t.status,
          t.statusText,
          t.data
        );
    } catch {
    }
}
function Pce(e, { relative: t } = {}) {
  ri(
    mw(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: n, navigator: r } = C.useContext(gs), { hash: i, pathname: o, search: s } = Gg(e, { relative: t }), a = o;
  return n !== "/" && (a = o === "/" ? n : qa([n, o])), r.createHref({ pathname: a, search: s, hash: i });
}
function mw() {
  return C.useContext(cM) != null;
}
function ud() {
  return ri(
    mw(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ), C.useContext(cM).location;
}
var M9 = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function N9(e) {
  C.useContext(gs).static || C.useLayoutEffect(e);
}
function R9() {
  let { isDataRoute: e } = C.useContext(nl);
  return e ? Gce() : jce();
}
function jce() {
  ri(
    mw(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let e = C.useContext(Lh), { basename: t, navigator: n } = C.useContext(gs), { matches: r } = C.useContext(nl), { pathname: i } = ud(), o = JSON.stringify(S9(r)), s = C.useRef(!1);
  return N9(() => {
    s.current = !0;
  }), C.useCallback(
    (c, u = {}) => {
      if (el(s.current, M9), !s.current) return;
      if (typeof c == "number") {
        n.go(c);
        return;
      }
      let f = k9(
        c,
        JSON.parse(o),
        i,
        u.relative === "path"
      );
      e == null && t !== "/" && (f.pathname = f.pathname === "/" ? t : qa([t, f.pathname])), (u.replace ? n.replace : n.push)(
        f,
        u.state,
        u
      );
    },
    [
      t,
      n,
      o,
      i,
      e
    ]
  );
}
C.createContext(null);
function Gg(e, { relative: t } = {}) {
  let { matches: n } = C.useContext(nl), { pathname: r } = ud(), i = JSON.stringify(S9(n));
  return C.useMemo(
    () => k9(
      e,
      JSON.parse(i),
      r,
      t === "path"
    ),
    [e, i, r, t]
  );
}
function Ice(e, t, n, r, i) {
  ri(
    mw(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: o } = C.useContext(gs), { matches: s } = C.useContext(nl), a = s[s.length - 1], c = a ? a.params : {}, u = a ? a.pathname : "/", f = a ? a.pathnameBase : "/", h = a && a.route;
  {
    let _ = h && h.path || "";
    D9(
      u,
      !h || _.endsWith("*") || _.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${_}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${_}"> to <Route path="${_ === "/" ? "*" : `${_}/*`}">.`
    );
  }
  let m = ud(), g;
  g = m;
  let b = g.pathname || "/", x = b;
  if (f !== "/") {
    let _ = f.replace(/^\//, "").split("/");
    x = "/" + b.replace(/^\//, "").split("/").slice(_.length).join("/");
  }
  let w = b9(e, { pathname: x });
  return el(
    h || w != null,
    `No routes matched location "${g.pathname}${g.search}${g.hash}" `
  ), el(
    w == null || w[w.length - 1].route.element !== void 0 || w[w.length - 1].route.Component !== void 0 || w[w.length - 1].route.lazy !== void 0,
    `Matched leaf route at location "${g.pathname}${g.search}${g.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
  ), Uce(
    w && w.map(
      (_) => Object.assign({}, _, {
        params: Object.assign({}, c, _.params),
        pathname: qa([
          f,
          // Re-encode pathnames that were decoded inside matchRoutes.
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          o.encodeLocation ? o.encodeLocation(
            _.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : _.pathname
        ]),
        pathnameBase: _.pathnameBase === "/" ? f : qa([
          f,
          // Re-encode pathnames that were decoded inside matchRoutes
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          o.encodeLocation ? o.encodeLocation(
            _.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : _.pathnameBase
        ])
      })
    ),
    s,
    n,
    r,
    i
  );
}
function zce() {
  let e = qce(), t = Cce(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, r = "rgba(200,200,200, 0.5)", i = { padding: "0.5rem", backgroundColor: r }, o = { padding: "2px 4px", backgroundColor: r }, s = null;
  return console.error(
    "Error handled by React Router default ErrorBoundary:",
    e
  ), s = /* @__PURE__ */ C.createElement(C.Fragment, null, /* @__PURE__ */ C.createElement("p", null, " Hey developer "), /* @__PURE__ */ C.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ C.createElement("code", { style: o }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ C.createElement("code", { style: o }, "errorElement"), " prop on your route.")), /* @__PURE__ */ C.createElement(C.Fragment, null, /* @__PURE__ */ C.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ C.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? /* @__PURE__ */ C.createElement("pre", { style: i }, n) : null, s);
}
var Lce = /* @__PURE__ */ C.createElement(zce, null), O9 = class extends C.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    this.props.onError ? this.props.onError(e, t) : console.error(
      "React Router caught the following error during render",
      e
    );
  }
  render() {
    let e = this.state.error;
    if (this.context && typeof e == "object" && e && "digest" in e && typeof e.digest == "string") {
      const n = Dce(e.digest);
      n && (e = n);
    }
    let t = e !== void 0 ? /* @__PURE__ */ C.createElement(nl.Provider, { value: this.props.routeContext }, /* @__PURE__ */ C.createElement(
      uM.Provider,
      {
        value: e,
        children: this.props.component
      }
    )) : this.props.children;
    return this.context ? /* @__PURE__ */ C.createElement(Bce, { error: e }, t) : t;
  }
};
O9.contextType = Tce;
var Yk = /* @__PURE__ */ new WeakMap();
function Bce({
  children: e,
  error: t
}) {
  let { basename: n } = C.useContext(gs);
  if (typeof t == "object" && t && "digest" in t && typeof t.digest == "string") {
    let r = Oce(t.digest);
    if (r) {
      let i = Yk.get(t);
      if (i) throw i;
      let o = E9(r.location, n);
      if (C9 && !Yk.get(t))
        if (o.isExternal || r.reloadDocument)
          window.location.href = o.absoluteURL || o.to;
        else {
          const s = Promise.resolve().then(
            () => window.__reactRouterDataRouter.navigate(o.to, {
              replace: r.replace
            })
          );
          throw Yk.set(t, s), s;
        }
      return /* @__PURE__ */ C.createElement(
        "meta",
        {
          httpEquiv: "refresh",
          content: `0;url=${o.absoluteURL || o.to}`
        }
      );
    }
  }
  return e;
}
function $ce({ routeContext: e, match: t, children: n }) {
  let r = C.useContext(Lh);
  return r && r.static && r.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ C.createElement(nl.Provider, { value: e }, n);
}
function Uce(e, t = [], n = null, r = null, i = null) {
  if (e == null) {
    if (!n)
      return null;
    if (n.errors)
      e = n.matches;
    else if (t.length === 0 && !n.initialized && n.matches.length > 0)
      e = n.matches;
    else
      return null;
  }
  let o = e, s = n?.errors;
  if (s != null) {
    let f = o.findIndex(
      (h) => h.route.id && s?.[h.route.id] !== void 0
    );
    ri(
      f >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        s
      ).join(",")}`
    ), o = o.slice(
      0,
      Math.min(o.length, f + 1)
    );
  }
  let a = !1, c = -1;
  if (n)
    for (let f = 0; f < o.length; f++) {
      let h = o[f];
      if ((h.route.HydrateFallback || h.route.hydrateFallbackElement) && (c = f), h.route.id) {
        let { loaderData: m, errors: g } = n, b = h.route.loader && !m.hasOwnProperty(h.route.id) && (!g || g[h.route.id] === void 0);
        if (h.route.lazy || b) {
          a = !0, c >= 0 ? o = o.slice(0, c + 1) : o = [o[0]];
          break;
        }
      }
    }
  let u = n && r ? (f, h) => {
    r(f, {
      location: n.location,
      params: n.matches?.[0]?.params ?? {},
      unstable_pattern: Ece(n.matches),
      errorInfo: h
    });
  } : void 0;
  return o.reduceRight(
    (f, h, m) => {
      let g, b = !1, x = null, w = null;
      n && (g = s && h.route.id ? s[h.route.id] : void 0, x = h.route.errorElement || Lce, a && (c < 0 && m === 0 ? (D9(
        "route-fallback",
        !1,
        "No `HydrateFallback` element provided to render during initial hydration"
      ), b = !0, w = null) : c === m && (b = !0, w = h.route.hydrateFallbackElement || null)));
      let S = t.concat(o.slice(0, m + 1)), _ = () => {
        let M;
        return g ? M = x : b ? M = w : h.route.Component ? M = /* @__PURE__ */ C.createElement(h.route.Component, null) : h.route.element ? M = h.route.element : M = f, /* @__PURE__ */ C.createElement(
          $ce,
          {
            match: h,
            routeContext: {
              outlet: f,
              matches: S,
              isDataRoute: n != null
            },
            children: M
          }
        );
      };
      return n && (h.route.ErrorBoundary || h.route.errorElement || m === 0) ? /* @__PURE__ */ C.createElement(
        O9,
        {
          location: n.location,
          revalidation: n.revalidation,
          component: x,
          error: g,
          children: _(),
          routeContext: { outlet: null, matches: S, isDataRoute: !0 },
          onError: u
        }
      ) : _();
    },
    null
  );
}
function dM(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function Fce(e) {
  let t = C.useContext(Lh);
  return ri(t, dM(e)), t;
}
function Vce(e) {
  let t = C.useContext(pw);
  return ri(t, dM(e)), t;
}
function Hce(e) {
  let t = C.useContext(nl);
  return ri(t, dM(e)), t;
}
function fM(e) {
  let t = Hce(e), n = t.matches[t.matches.length - 1];
  return ri(
    n.route.id,
    `${e} can only be used on routes that contain a unique "id"`
  ), n.route.id;
}
function Wce() {
  return fM(
    "useRouteId"
    /* UseRouteId */
  );
}
function qce() {
  let e = C.useContext(uM), t = Vce(
    "useRouteError"
    /* UseRouteError */
  ), n = fM(
    "useRouteError"
    /* UseRouteError */
  );
  return e !== void 0 ? e : t.errors?.[n];
}
function Gce() {
  let { router: e } = Fce(
    "useNavigate"
    /* UseNavigateStable */
  ), t = fM(
    "useNavigate"
    /* UseNavigateStable */
  ), n = C.useRef(!1);
  return N9(() => {
    n.current = !0;
  }), C.useCallback(
    async (i, o = {}) => {
      el(n.current, M9), n.current && (typeof i == "number" ? await e.navigate(i) : await e.navigate(i, { fromRouteId: t, ...o }));
    },
    [e, t]
  );
}
var Pj = {};
function D9(e, t, n) {
  !t && !Pj[e] && (Pj[e] = !0, el(!1, n));
}
C.memo(Kce);
function Kce({
  routes: e,
  future: t,
  state: n,
  onError: r
}) {
  return Ice(e, void 0, n, r, t);
}
var T0 = "get", A0 = "application/x-www-form-urlencoded";
function gw(e) {
  return typeof HTMLElement < "u" && e instanceof HTMLElement;
}
function Zce(e) {
  return gw(e) && e.tagName.toLowerCase() === "button";
}
function Yce(e) {
  return gw(e) && e.tagName.toLowerCase() === "form";
}
function Xce(e) {
  return gw(e) && e.tagName.toLowerCase() === "input";
}
function Jce(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function Qce(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !Jce(e);
}
var zv = null;
function eue() {
  if (zv === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), zv = !1;
    } catch {
      zv = !0;
    }
  return zv;
}
var tue = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function Xk(e) {
  return e != null && !tue.has(e) ? (el(
    !1,
    `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${A0}"`
  ), null) : e;
}
function nue(e, t) {
  let n, r, i, o, s;
  if (Yce(e)) {
    let a = e.getAttribute("action");
    r = a ? Ac(a, t) : null, n = e.getAttribute("method") || T0, i = Xk(e.getAttribute("enctype")) || A0, o = new FormData(e);
  } else if (Zce(e) || Xce(e) && (e.type === "submit" || e.type === "image")) {
    let a = e.form;
    if (a == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let c = e.getAttribute("formaction") || a.getAttribute("action");
    if (r = c ? Ac(c, t) : null, n = e.getAttribute("formmethod") || a.getAttribute("method") || T0, i = Xk(e.getAttribute("formenctype")) || Xk(a.getAttribute("enctype")) || A0, o = new FormData(a, e), !eue()) {
      let { name: u, type: f, value: h } = e;
      if (f === "image") {
        let m = u ? `${u}.` : "";
        o.append(`${m}x`, "0"), o.append(`${m}y`, "0");
      } else u && o.append(u, h);
    }
  } else {
    if (gw(e))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    n = T0, r = null, i = A0, s = e;
  }
  return o && i === "text/plain" && (s = o, o = void 0), { action: r, method: n.toLowerCase(), encType: i, formData: o, body: s };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function hM(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function rue(e, t, n, r) {
  let i = typeof e == "string" ? new URL(
    e,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window > "u" ? "server://singlefetch/" : window.location.origin
  ) : e;
  return n ? i.pathname.endsWith("/") ? i.pathname = `${i.pathname}_.${r}` : i.pathname = `${i.pathname}.${r}` : i.pathname === "/" ? i.pathname = `_root.${r}` : t && Ac(i.pathname, t) === "/" ? i.pathname = `${t.replace(/\/$/, "")}/_root.${r}` : i.pathname = `${i.pathname.replace(/\/$/, "")}.${r}`, i;
}
async function iue(e, t) {
  if (e.id in t)
    return t[e.id];
  try {
    let n = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e.module
    );
    return t[e.id] = n, n;
  } catch (n) {
    return console.error(
      `Error loading route module \`${e.module}\`, reloading page...`
    ), console.error(n), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
    });
  }
}
function oue(e) {
  return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string";
}
async function sue(e, t, n) {
  let r = await Promise.all(
    e.map(async (i) => {
      let o = t.routes[i.route.id];
      if (o) {
        let s = await iue(o, n);
        return s.links ? s.links() : [];
      }
      return [];
    })
  );
  return uue(
    r.flat(1).filter(oue).filter((i) => i.rel === "stylesheet" || i.rel === "preload").map(
      (i) => i.rel === "stylesheet" ? { ...i, rel: "prefetch", as: "style" } : { ...i, rel: "prefetch" }
    )
  );
}
function jj(e, t, n, r, i, o) {
  let s = (c, u) => n[u] ? c.route.id !== n[u].route.id : !0, a = (c, u) => (
    // param change, /users/123 -> /users/456
    n[u].pathname !== c.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    n[u].route.path?.endsWith("*") && n[u].params["*"] !== c.params["*"]
  );
  return o === "assets" ? t.filter(
    (c, u) => s(c, u) || a(c, u)
  ) : o === "data" ? t.filter((c, u) => {
    let f = r.routes[c.route.id];
    if (!f || !f.hasLoader)
      return !1;
    if (s(c, u) || a(c, u))
      return !0;
    if (c.route.shouldRevalidate) {
      let h = c.route.shouldRevalidate({
        currentUrl: new URL(
          i.pathname + i.search + i.hash,
          window.origin
        ),
        currentParams: n[0]?.params || {},
        nextUrl: new URL(e, window.origin),
        nextParams: c.params,
        defaultShouldRevalidate: !0
      });
      if (typeof h == "boolean")
        return h;
    }
    return !0;
  }) : [];
}
function aue(e, t, { includeHydrateFallback: n } = {}) {
  return lue(
    e.map((r) => {
      let i = t.routes[r.route.id];
      if (!i) return [];
      let o = [i.module];
      return i.clientActionModule && (o = o.concat(i.clientActionModule)), i.clientLoaderModule && (o = o.concat(i.clientLoaderModule)), n && i.hydrateFallbackModule && (o = o.concat(i.hydrateFallbackModule)), i.imports && (o = o.concat(i.imports)), o;
    }).flat(1)
  );
}
function lue(e) {
  return [...new Set(e)];
}
function cue(e) {
  let t = {}, n = Object.keys(e).sort();
  for (let r of n)
    t[r] = e[r];
  return t;
}
function uue(e, t) {
  let n = /* @__PURE__ */ new Set();
  return new Set(t), e.reduce((r, i) => {
    let o = JSON.stringify(cue(i));
    return n.has(o) || (n.add(o), r.push({ key: o, link: i })), r;
  }, []);
}
function P9() {
  let e = C.useContext(Lh);
  return hM(
    e,
    "You must render this element inside a <DataRouterContext.Provider> element"
  ), e;
}
function due() {
  let e = C.useContext(pw);
  return hM(
    e,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  ), e;
}
var pM = C.createContext(void 0);
pM.displayName = "FrameworkContext";
function j9() {
  let e = C.useContext(pM);
  return hM(
    e,
    "You must render this element inside a <HydratedRouter> element"
  ), e;
}
function fue(e, t) {
  let n = C.useContext(pM), [r, i] = C.useState(!1), [o, s] = C.useState(!1), { onFocus: a, onBlur: c, onMouseEnter: u, onMouseLeave: f, onTouchStart: h } = t, m = C.useRef(null);
  C.useEffect(() => {
    if (e === "render" && s(!0), e === "viewport") {
      let x = (S) => {
        S.forEach((_) => {
          s(_.isIntersecting);
        });
      }, w = new IntersectionObserver(x, { threshold: 0.5 });
      return m.current && w.observe(m.current), () => {
        w.disconnect();
      };
    }
  }, [e]), C.useEffect(() => {
    if (r) {
      let x = setTimeout(() => {
        s(!0);
      }, 100);
      return () => {
        clearTimeout(x);
      };
    }
  }, [r]);
  let g = () => {
    i(!0);
  }, b = () => {
    i(!1), s(!1);
  };
  return n ? e !== "intent" ? [o, m, {}] : [
    o,
    m,
    {
      onFocus: Zp(a, g),
      onBlur: Zp(c, b),
      onMouseEnter: Zp(u, g),
      onMouseLeave: Zp(f, b),
      onTouchStart: Zp(h, g)
    }
  ] : [!1, m, {}];
}
function Zp(e, t) {
  return (n) => {
    e && e(n), n.defaultPrevented || t(n);
  };
}
function hue({ page: e, ...t }) {
  let { router: n } = P9(), r = C.useMemo(
    () => b9(n.routes, e, n.basename),
    [n.routes, e, n.basename]
  );
  return r ? /* @__PURE__ */ C.createElement(mue, { page: e, matches: r, ...t }) : null;
}
function pue(e) {
  let { manifest: t, routeModules: n } = j9(), [r, i] = C.useState([]);
  return C.useEffect(() => {
    let o = !1;
    return sue(e, t, n).then(
      (s) => {
        o || i(s);
      }
    ), () => {
      o = !0;
    };
  }, [e, t, n]), r;
}
function mue({
  page: e,
  matches: t,
  ...n
}) {
  let r = ud(), { future: i, manifest: o, routeModules: s } = j9(), { basename: a } = P9(), { loaderData: c, matches: u } = due(), f = C.useMemo(
    () => jj(
      e,
      t,
      u,
      o,
      r,
      "data"
    ),
    [e, t, u, o, r]
  ), h = C.useMemo(
    () => jj(
      e,
      t,
      u,
      o,
      r,
      "assets"
    ),
    [e, t, u, o, r]
  ), m = C.useMemo(() => {
    if (e === r.pathname + r.search + r.hash)
      return [];
    let x = /* @__PURE__ */ new Set(), w = !1;
    if (t.forEach((_) => {
      let M = o.routes[_.route.id];
      !M || !M.hasLoader || (!f.some((N) => N.route.id === _.route.id) && _.route.id in c && s[_.route.id]?.shouldRevalidate || M.hasClientLoader ? w = !0 : x.add(_.route.id));
    }), x.size === 0)
      return [];
    let S = rue(
      e,
      a,
      i.unstable_trailingSlashAwareDataRequests,
      "data"
    );
    return w && x.size > 0 && S.searchParams.set(
      "_routes",
      t.filter((_) => x.has(_.route.id)).map((_) => _.route.id).join(",")
    ), [S.pathname + S.search];
  }, [
    a,
    i.unstable_trailingSlashAwareDataRequests,
    c,
    r,
    o,
    f,
    t,
    e,
    s
  ]), g = C.useMemo(
    () => aue(h, o),
    [h, o]
  ), b = pue(h);
  return /* @__PURE__ */ C.createElement(C.Fragment, null, m.map((x) => /* @__PURE__ */ C.createElement("link", { key: x, rel: "prefetch", as: "fetch", href: x, ...n })), g.map((x) => /* @__PURE__ */ C.createElement("link", { key: x, rel: "modulepreload", href: x, ...n })), b.map(({ key: x, link: w }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ C.createElement(
      "link",
      {
        key: x,
        nonce: n.nonce,
        ...w,
        crossOrigin: w.crossOrigin ?? n.crossOrigin
      }
    )
  )));
}
function gue(...e) {
  return (t) => {
    e.forEach((n) => {
      typeof n == "function" ? n(t) : n != null && (n.current = t);
    });
  };
}
var yue = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
  yue && (window.__reactRouterVersion = // @ts-expect-error
  "7.13.0");
} catch {
}
var I9 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, yw = C.forwardRef(
  function({
    onClick: t,
    discover: n = "render",
    prefetch: r = "none",
    relative: i,
    reloadDocument: o,
    replace: s,
    state: a,
    target: c,
    to: u,
    preventScrollReset: f,
    viewTransition: h,
    unstable_defaultShouldRevalidate: m,
    ...g
  }, b) {
    let { basename: x, unstable_useTransitions: w } = C.useContext(gs), S = typeof u == "string" && I9.test(u), _ = E9(u, x);
    u = _.to;
    let M = Pce(u, { relative: i }), [N, P, I] = fue(
      r,
      g
    ), O = wue(u, {
      replace: s,
      state: a,
      target: c,
      preventScrollReset: f,
      relative: i,
      viewTransition: h,
      unstable_defaultShouldRevalidate: m,
      unstable_useTransitions: w
    });
    function L(B) {
      t && t(B), B.defaultPrevented || O(B);
    }
    let U = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ C.createElement(
        "a",
        {
          ...g,
          ...I,
          href: _.absoluteURL || M,
          onClick: _.isExternal || o ? t : L,
          ref: gue(b, P),
          target: c,
          "data-discover": !S && n === "render" ? "true" : void 0
        }
      )
    );
    return N && !S ? /* @__PURE__ */ C.createElement(C.Fragment, null, U, /* @__PURE__ */ C.createElement(hue, { page: M })) : U;
  }
);
yw.displayName = "Link";
var vue = C.forwardRef(
  function({
    "aria-current": t = "page",
    caseSensitive: n = !1,
    className: r = "",
    end: i = !1,
    style: o,
    to: s,
    viewTransition: a,
    children: c,
    ...u
  }, f) {
    let h = Gg(s, { relative: u.relative }), m = ud(), g = C.useContext(pw), { navigator: b, basename: x } = C.useContext(gs), w = g != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    _ue(h) && a === !0, S = b.encodeLocation ? b.encodeLocation(h).pathname : h.pathname, _ = m.pathname, M = g && g.navigation && g.navigation.location ? g.navigation.location.pathname : null;
    n || (_ = _.toLowerCase(), M = M ? M.toLowerCase() : null, S = S.toLowerCase()), M && x && (M = Ac(M, x) || M);
    const N = S !== "/" && S.endsWith("/") ? S.length - 1 : S.length;
    let P = _ === S || !i && _.startsWith(S) && _.charAt(N) === "/", I = M != null && (M === S || !i && M.startsWith(S) && M.charAt(S.length) === "/"), O = {
      isActive: P,
      isPending: I,
      isTransitioning: w
    }, L = P ? t : void 0, U;
    typeof r == "function" ? U = r(O) : U = [
      r,
      P ? "active" : null,
      I ? "pending" : null,
      w ? "transitioning" : null
    ].filter(Boolean).join(" ");
    let B = typeof o == "function" ? o(O) : o;
    return /* @__PURE__ */ C.createElement(
      yw,
      {
        ...u,
        "aria-current": L,
        className: U,
        ref: f,
        style: B,
        to: s,
        viewTransition: a
      },
      typeof c == "function" ? c(O) : c
    );
  }
);
vue.displayName = "NavLink";
var bue = C.forwardRef(
  ({
    discover: e = "render",
    fetcherKey: t,
    navigate: n,
    reloadDocument: r,
    replace: i,
    state: o,
    method: s = T0,
    action: a,
    onSubmit: c,
    relative: u,
    preventScrollReset: f,
    viewTransition: h,
    unstable_defaultShouldRevalidate: m,
    ...g
  }, b) => {
    let { unstable_useTransitions: x } = C.useContext(gs), w = Cue(), S = Eue(a, { relative: u }), _ = s.toLowerCase() === "get" ? "get" : "post", M = typeof a == "string" && I9.test(a), N = (P) => {
      if (c && c(P), P.defaultPrevented) return;
      P.preventDefault();
      let I = P.nativeEvent.submitter, O = I?.getAttribute("formmethod") || s, L = () => w(I || P.currentTarget, {
        fetcherKey: t,
        method: O,
        navigate: n,
        replace: i,
        state: o,
        relative: u,
        preventScrollReset: f,
        viewTransition: h,
        unstable_defaultShouldRevalidate: m
      });
      x && n !== !1 ? C.startTransition(() => L()) : L();
    };
    return /* @__PURE__ */ C.createElement(
      "form",
      {
        ref: b,
        method: _,
        action: S,
        onSubmit: r ? c : N,
        ...g,
        "data-discover": !M && e === "render" ? "true" : void 0
      }
    );
  }
);
bue.displayName = "Form";
function xue(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function z9(e) {
  let t = C.useContext(Lh);
  return ri(t, xue(e)), t;
}
function wue(e, {
  target: t,
  replace: n,
  state: r,
  preventScrollReset: i,
  relative: o,
  viewTransition: s,
  unstable_defaultShouldRevalidate: a,
  unstable_useTransitions: c
} = {}) {
  let u = R9(), f = ud(), h = Gg(e, { relative: o });
  return C.useCallback(
    (m) => {
      if (Qce(m, t)) {
        m.preventDefault();
        let g = n !== void 0 ? n : k_(f) === k_(h), b = () => u(e, {
          replace: g,
          state: r,
          preventScrollReset: i,
          relative: o,
          viewTransition: s,
          unstable_defaultShouldRevalidate: a
        });
        c ? C.startTransition(() => b()) : b();
      }
    },
    [
      f,
      u,
      h,
      n,
      r,
      t,
      e,
      i,
      o,
      s,
      a,
      c
    ]
  );
}
var Sue = 0, kue = () => `__${String(++Sue)}__`;
function Cue() {
  let { router: e } = z9(
    "useSubmit"
    /* UseSubmit */
  ), { basename: t } = C.useContext(gs), n = Wce(), r = e.fetch, i = e.navigate;
  return C.useCallback(
    async (o, s = {}) => {
      let { action: a, method: c, encType: u, formData: f, body: h } = nue(
        o,
        t
      );
      if (s.navigate === !1) {
        let m = s.fetcherKey || kue();
        await r(m, n, s.action || a, {
          unstable_defaultShouldRevalidate: s.unstable_defaultShouldRevalidate,
          preventScrollReset: s.preventScrollReset,
          formData: f,
          body: h,
          formMethod: s.method || c,
          formEncType: s.encType || u,
          flushSync: s.flushSync
        });
      } else
        await i(s.action || a, {
          unstable_defaultShouldRevalidate: s.unstable_defaultShouldRevalidate,
          preventScrollReset: s.preventScrollReset,
          formData: f,
          body: h,
          formMethod: s.method || c,
          formEncType: s.encType || u,
          replace: s.replace,
          state: s.state,
          fromRouteId: n,
          flushSync: s.flushSync,
          viewTransition: s.viewTransition
        });
    },
    [r, i, t, n]
  );
}
function Eue(e, { relative: t } = {}) {
  let { basename: n } = C.useContext(gs), r = C.useContext(nl);
  ri(r, "useFormAction must be used inside a RouteContext");
  let [i] = r.matches.slice(-1), o = { ...Gg(e || ".", { relative: t }) }, s = ud();
  if (e == null) {
    o.search = s.search;
    let a = new URLSearchParams(o.search), c = a.getAll("index");
    if (c.some((f) => f === "")) {
      a.delete("index"), c.filter((h) => h).forEach((h) => a.append("index", h));
      let f = a.toString();
      o.search = f ? `?${f}` : "";
    }
  }
  return (!e || e === ".") && i.route.index && (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (o.pathname = o.pathname === "/" ? n : qa([n, o.pathname])), k_(o);
}
function _ue(e, { relative: t } = {}) {
  let n = C.useContext(T9);
  ri(
    n != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: r } = z9(
    "useViewTransitionState"
    /* useViewTransitionState */
  ), i = Gg(e, { relative: t });
  if (!n.isTransitioning)
    return !1;
  let o = Ac(n.currentLocation.pathname, r) || n.currentLocation.pathname, s = Ac(n.nextLocation.pathname, r) || n.nextLocation.pathname;
  return vb(i.pathname, s) != null || vb(i.pathname, o) != null;
}
function Tue({
  isOwner: e,
  isBookmarked: t = !1,
  editHref: n,
  onBookmarkToggle: r,
  onDelete: i,
  renderActions: o,
  isVisibilityChangeLoading: s = !1,
  isBookmarkToggleLoading: a = !1,
  isDeleteLoading: c = !1,
  disabled: u = !1
}) {
  const f = C.useMemo(
    () => s || a || c,
    [s, a, c]
  ), h = R9();
  return /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-0.5", children: [
    !e && r && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsxs(Gi, { children: [
        /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
          Ht,
          {
            variant: "ghost",
            size: "icon",
            className: "h-8 w-8 rounded-md text-muted-foreground hover:text-foreground hover:bg-accent/50 transition-all cursor-pointer disabled:opacity-50",
            "data-testid": "bookmark-button",
            disabled: f || u,
            onClick: (m) => {
              m.preventDefault(), m.stopPropagation(), r(t);
            },
            children: a ? /* @__PURE__ */ v.jsx(Zs, { className: "h-3.5 w-3.5 animate-spin" }) : t ? /* @__PURE__ */ v.jsx(hZ, { className: "h-3.5 w-3.5 fill-current" }) : /* @__PURE__ */ v.jsx(V3, { className: "h-3.5 w-3.5" })
          }
        ) }),
        /* @__PURE__ */ v.jsx(Bo, { side: "bottom", className: "text-xs", children: t ? "Remove bookmark" : "Add bookmark" })
      ] }),
      /* @__PURE__ */ v.jsx(yb, { orientation: "vertical", className: "h-4 mx-0.5" })
    ] }),
    e && n && /* @__PURE__ */ v.jsxs(Gi, { children: [
      /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
        Ht,
        {
          variant: "ghost",
          size: "icon",
          className: "h-8 w-8 rounded-md text-muted-foreground hover:text-foreground hover:bg-accent/50 transition-all cursor-pointer disabled:opacity-50",
          disabled: f || u,
          onClick: (m) => {
            m.preventDefault(), m.stopPropagation(), h(n);
          },
          children: /* @__PURE__ */ v.jsx(rce, { className: "h-3.5 w-3.5" })
        }
      ) }),
      /* @__PURE__ */ v.jsx(Bo, { side: "bottom", className: "text-xs", children: "Edit" })
    ] }),
    e && o && o(),
    e && i && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      n && /* @__PURE__ */ v.jsx(yb, { orientation: "vertical", className: "h-4 mx-0.5" }),
      /* @__PURE__ */ v.jsxs(Gi, { children: [
        /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
          Ht,
          {
            variant: "ghost",
            size: "icon",
            className: "h-8 w-8 rounded-md text-muted-foreground hover:text-destructive hover:bg-destructive/10 transition-all cursor-pointer disabled:opacity-50",
            disabled: f || u,
            onClick: (m) => {
              m.preventDefault(), m.stopPropagation(), i();
            },
            children: c ? /* @__PURE__ */ v.jsx(Zs, { className: "h-3.5 w-3.5 animate-spin" }) : /* @__PURE__ */ v.jsx(W3, { className: "h-3.5 w-3.5" })
          }
        ) }),
        /* @__PURE__ */ v.jsx(Bo, { side: "bottom", className: "text-xs", children: "Delete" })
      ] })
    ] })
  ] });
}
async function Aue(e) {
  const t = await zc(), n = await fetch(`${Ws}/${encodeURIComponent(e)}`, {
    method: "DELETE",
    headers: t
  });
  if (!n.ok) throw new Error(`Failed to delete MCP server (${n.status})`);
}
async function Mue(e) {
  const t = await zc(), n = await fetch(`${Ws}/${encodeURIComponent(e)}/refresh`, {
    method: "POST",
    headers: t
  });
  if (!n.ok) throw new Error(`Failed to refresh MCP server (${n.status})`);
  return n.json().catch(() => null);
}
function Nue({ className: e }) {
  return /* @__PURE__ */ v.jsxs(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      id: "Playwright--Streamline-Svg-Logos",
      height: "24",
      width: "24",
      className: e,
      children: [
        /* @__PURE__ */ v.jsx("desc", { children: "Playwright Streamline Icon: https://streamlinehq.com" }),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#2d4552",
            d: "M7.99585 13.141725c-0.87725 0.248975 -1.452775 0.685475 -1.8319 1.12165 0.363125 -0.317775 0.849525 -0.609425 1.505675 -0.795425 0.6711 -0.1902 1.243625 -0.188825 1.7167 -0.09755v-0.369925c-0.40355 -0.0369 -0.866225 -0.0075 -1.390475 0.14125Zm-1.872 -3.109775 -3.25795 0.858325s0.059375 0.083875 0.1693 0.195775l2.76235 -0.727875s-0.03915 0.5044 -0.379075 0.9556c0.643 -0.486475 0.705375 -1.281825 0.705375 -1.281825Zm2.727125 7.65675C4.26615 18.923575 1.8404825 13.61025 1.1060875 10.852425c-0.3393 -1.273 -0.487415 -2.2371 -0.5268925 -2.859275 -0.0042425 -0.0646 -0.0022825 -0.11905 0.002285 -0.16895 -0.237835 0.01435 -0.3517015 0.137975 -0.328535 0.49525 0.0394775 0.621825 0.187595 1.585875 0.526895 2.859275C1.5139075 13.936125 3.9399 19.24945 8.52475 18.0146c0.99795 -0.26885 1.747675 -0.758525 2.310475 -1.383625 -0.51875 0.468525 -1.168 0.8375 -1.98425 1.057725Zm0.861575 -10.90855v0.3263h1.79835c-0.0369 -0.115525 -0.074075 -0.219625 -0.110975 -0.3263h-1.687375Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#2d4552",
            d: "M11.9129 9.46735c0.80875 0.229675 1.2365 0.7967 1.462575 1.2985l0.90175 0.2561s-0.123 -1.756175 -1.711525 -2.2074c-1.486075 -0.422225 -2.400575 0.8257 -2.5118 0.9872 0.4323 -0.308 1.063575 -0.56015 1.859 -0.3344Zm7.178175 1.3066c-1.487425 -0.424125 -2.401575 0.8264 -2.511175 0.985625 0.432625 -0.307625 1.063575 -0.559875 1.85865 -0.3331 0.80745 0.23005 1.23485 0.796375 1.461625 1.298525l0.90305 0.25705s-0.125 -1.756525 -1.71215 -2.2081Zm-0.8959 4.6305 -7.501475 -2.097125s0.0812 0.411725 0.3928 0.94485l6.3159 1.765675c0.519975 -0.30085 0.792775 -0.6134 0.792775 -0.6134ZM12.994375 19.918475C7.054675 18.326 7.77275 10.758025 8.733875 7.171825c0.395725 -1.4779 0.802575 -2.576375 1.13995 -3.312725 -0.2013 -0.041425 -0.368025 0.0646 -0.532775 0.39965 -0.358225 0.726575 -0.8163 1.90955 -1.259625 3.5656 -0.96085 3.586125 -1.67895 11.15385 4.2605 12.746325 2.79955 0.75 4.980475 -0.3899 6.60625 -2.18005 -1.543175 1.3977 -3.513425 2.181325 -5.9538 1.52785Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#e2574c",
            d: "M9.7126 15.915175V14.388l-4.243175 1.2032s0.313525 -1.82175 2.526475 -2.4495c0.6711 -0.1902 1.2437 -0.1889 1.7167 -0.09755V6.780125h2.124575c-0.231325 -0.714825 -0.4551 -1.26515 -0.64305 -1.64755 -0.310925 -0.632925 -0.62965 -0.21335 -1.35325 0.39185 -0.50965 0.425775 -1.797675 1.33405 -3.7359 1.85635 -1.938275 0.522625 -3.50525 0.384025 -4.15906 0.2708 -0.9268825 -0.1599 -1.4116925 -0.36345 -1.3663375 0.34155 0.03947 0.621825 0.187595 1.58595 0.5268925 2.859275C1.8405325 13.609875 4.266525 18.9232 8.85135 17.68835c1.197625 -0.3227 2.04295 -0.960525 2.6289 -1.7735h-1.76765v0.000325ZM2.865625 10.89025l3.258275 -0.858325s-0.094975 1.25345 -1.31645 1.57545c-1.2218 0.321675 -1.941825 -0.717125 -1.941825 -0.717125Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#2ead33",
            d: "M21.975075 6.8525c-0.84695 0.148475 -2.878875 0.33345 -5.389975 -0.339625 -2.5118 -0.672675 -4.17835 -1.849175 -4.838625 -2.402175 -0.936 -0.783975 -1.347725 -1.328825 -1.752925 -0.5047 -0.358225 0.726875 -0.816325 1.909875 -1.259725 3.565925 -0.960775 3.586125 -1.67885 11.15385 4.260525 12.7463 5.938125 1.591125 9.09945 -5.322175 10.0603 -8.908625 0.4434 -1.655725 0.637825 -2.9095 0.691325 -3.717925 0.061 -0.915775 -0.568025 -0.64995 -1.7709 -0.439175ZM10.0418 9.81945s0.936 -1.45575 2.523525 -1.00455c1.588525 0.451225 1.711525 2.207425 1.711525 2.207425l-4.23505 -1.202875ZM13.917 16.352c-2.79235 -0.817975 -3.223 -3.04465 -3.223 -3.04465l7.501125 2.0972c0 -0.00035 -1.5141 1.755175 -4.278125 0.94745Zm2.6521 -4.57605s0.9347 -1.45475 2.521925 -1.00225c1.587175 0.4519 1.71215 2.2081 1.71215 2.2081l-4.234075 -1.20585Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#d65348",
            d: "M8.2299 14.808525 5.4695 15.590875s0.29985 -1.708225 2.33335 -2.385175l-1.563075 -5.865975 -0.135075 0.04105c-1.93825 0.5227 -3.505225 0.384025 -4.15903 0.2708 -0.9268775 -0.159825 -1.411685 -0.36345 -1.3663375 0.341625 0.0394775 0.621825 0.187595 1.585875 0.5268925 2.85925 0.7340675 2.757425 3.160075 8.07075 7.744875 6.8359l0.135075 -0.042425 -0.756275 -2.8374ZM2.8657 10.8903l3.258275 -0.858375s-0.094975 1.25345 -1.316425 1.57545c-1.221825 0.321675 -1.94185 -0.717075 -1.94185 -0.717075Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#1d8d22",
            d: "m14.04295 16.382625 -0.1263 -0.0307c-2.792325 -0.8179 -3.223 -3.044575 -3.223 -3.044575l3.86805 1.0812 2.047825 -7.86915 -0.024775 -0.006525c-2.5118 -0.672675 -4.17825 -1.849175 -4.838625 -2.402175 -0.936 -0.783975 -1.347725 -1.328825 -1.752925 -0.5047 -0.357875 0.726875 -0.815975 1.909875 -1.259375 3.565925 -0.960775 3.586125 -1.67885 11.15385 4.260525 12.74625l0.121725 0.027425 0.926875 -3.562975ZM10.0418 9.819475s0.936 -1.455775 2.523525 -1.004575c1.588525 0.451225 1.711525 2.207425 1.711525 2.207425l-4.23505 -1.20285Z",
            strokeWidth: "0.25"
          }
        ),
        /* @__PURE__ */ v.jsx(
          "path",
          {
            fill: "#c04b41",
            d: "m8.37055 14.7683 -0.740275 0.2101c0.174875 0.9859 0.483125 1.93205 0.966975 2.7679 0.0842 -0.0186 0.167725 -0.034575 0.2535 -0.058075 0.2248 -0.06065 0.43325 -0.13575 0.63395 -0.21765 -0.5406 -0.802225 -0.898225 -1.726175 -1.11415 -2.702275Zm-0.289075 -6.9439c-0.3804 1.419825 -0.720725 3.46345 -0.62705 5.51325 0.167675 -0.072775 0.3448 -0.140575 0.54155 -0.1964l0.13705 -0.030625c-0.167075 -2.189525 0.194075 -4.4207 0.600925 -5.93875 0.103125 -0.384025 0.206525 -0.741225 0.3096 -1.07435 -0.166025 0.105675 -0.3448 0.213975 -0.548425 0.32555 -0.137325 0.42385 -0.276 0.887125 -0.41365 1.401325Z",
            strokeWidth: "0.25"
          }
        )
      ]
    }
  );
}
function Rue({ className: e }) {
  return /* @__PURE__ */ v.jsx(
    "img",
    {
      className: e,
      src: "https://avatars.githubusercontent.com/u/133959746?s=48&v=4",
      alt: "PageIndex logo"
    }
  );
}
function Oue({ className: e }) {
  return /* @__PURE__ */ v.jsx("svg", { className: e, viewBox: "0 0 317.68 137.05", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ v.jsx("path", { fill: "currentColor", d: "M25.99,135.17c-2.06,0-4.14-.68-5.86-2.09-3.98-3.24-4.58-9.1-1.34-13.08l46.64-57.29c.2-.24.41-.48.63-.7,9.83-9.83,9.83-25.82,0-35.65-4.72-4.72-14.94-9.06-26.23-7.43-6.74.97-16.09,4.54-22.37,16.06-2.46,4.51-8.11,6.17-12.61,3.71C.34,36.25-1.32,30.61,1.14,26.1,8.91,11.84,21.71,2.76,37.18.53c15.58-2.25,32.08,2.73,42.03,12.68,16.96,16.96,17.07,44.48.35,61.59l-46.36,56.94c-1.84,2.26-4.52,3.43-7.22,3.43ZM186.55,127.75v-24.69c0-5.14-4.16-9.3-9.3-9.3h-54.32l60.87-76.33c3.2-4.01,2.54-9.86-1.47-13.06-4.01-3.2-9.86-2.55-13.06,1.47l-72.91,91.42c-2.23,2.79-2.66,6.61-1.11,9.83,1.55,3.22,4.81,5.26,8.38,5.26h64.33v15.4c0,5.14,4.16,9.3,9.3,9.3s9.3-4.16,9.3-9.3ZM230.44,102.08l66.95-83.6c3.21-4.01,2.56-9.86-1.44-13.07-4.01-3.21-9.86-2.56-13.07,1.44l-50.39,62.93V10.16c0-5.14-4.16-9.3-9.3-9.3s-9.3,4.16-9.3,9.3v86.11c0,3.95,2.49,7.47,6.22,8.77,1.01.35,2.05.53,3.08.53,2.77,0,5.46-1.24,7.26-3.49ZM314.93,131.23c3.64-3.62,3.67-9.5.05-13.15l-59.63-60.08c-3.62-3.64-9.5-3.67-13.15-.05-3.64,3.62-3.67,9.5-.05,13.15l59.63,60.08c1.82,1.83,4.21,2.75,6.6,2.75s4.74-.9,6.55-2.7Z" }) });
}
const bb = [
  {
    name: "24KTwin-Editor-MCP-Remote",
    label: "24K Twin Editor MCP Remote",
    config: {
      type: "http",
      url: "https://dev.24kstudio.surbana.tech/mcp-remote/mcp"
    },
    icon: Oue
  },
  {
    name: "playwright",
    label: "Playwright",
    config: {
      command: "npx",
      args: ["@playwright/mcp@latest"]
    },
    icon: Nue
  },
  {
    name: "pageindex",
    label: "PageIndex",
    config: {
      type: "http",
      url: "https://mcp.pageindex.ai/mcp"
    },
    icon: Rue
  }
];
function Due() {
  const e = (t, n) => {
    t.preventDefault(), t.stopPropagation();
    const r = new URLSearchParams();
    r.set("name", n.name), r.set("config", JSON.stringify(n.config)), window.open(`/chat-bot/mcp/create?${r.toString()}`, "_blank");
  };
  return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-4", children: [
    /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col items-center justify-center space-y-4 my-20", children: [
      /* @__PURE__ */ v.jsxs("h3", { className: "text-2xl md:text-4xl font-semibold flex items-center gap-3", children: [
        /* @__PURE__ */ v.jsx(lh, { className: "fill-foreground size-6 hidden sm:block" }),
        "Connect Your First Server"
      ] }),
      /* @__PURE__ */ v.jsx("p", { className: "text-muted-foreground max-w-md", children: "Add MCP servers to unlock powerful AI integrations" }),
      /* @__PURE__ */ v.jsx(
        yw,
        {
          to: "/chat-bot/mcp/create",
          className: "cursor-pointer",
          children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-xl font-bold overflow-hidden ", children: [
            "Add MCP Server",
            /* @__PURE__ */ v.jsx(uZ, { className: "size-6" })
          ] })
        }
      )
    ] }),
    /* @__PURE__ */ v.jsx("div", { className: "flex gap-2 flex-wrap justify-center", children: bb.map((t) => {
      const n = t.icon;
      return /* @__PURE__ */ v.jsxs(
        Ht,
        {
          variant: "secondary",
          className: "hover:-translate-y-0.5 transition-all duration-300 cursor-pointer flex items-center",
          onClick: (r) => e(r, t),
          children: [
            /* @__PURE__ */ v.jsx(n, { className: "h-6 w-6 my-auto text-primary-foreground stroke-primary-foreground" }),
            t.label
          ]
        },
        t.name
      );
    }) })
  ] });
}
const Pue = 2500, L9 = (e) => e.toLowerCase().replace(/[^a-z0-9]/g, ""), jue = new Map(
  bb.map((e) => [L9(e.name), e.icon])
), Ij = C.memo(function({
  id: t,
  config: n,
  error: r,
  status: i,
  name: o,
  toolInfo: s,
  visibility: a,
  authorizationUrl: c,
  icon: u
}) {
  const { mutate: f } = u9(), [h, m] = C.useState(!1), [g, b] = C.useState(!1), [x, w] = C.useState(""), [S, _] = C.useState(!1), M = C.useRef(null), N = C.useMemo(() => h || g || i === "loading", [h, g, i]), P = i === "authorizing", I = P && !!c, O = C.useMemo(() => r ? ch(r) ? r : JSON.stringify(r) : null, [r]), L = L9(o ?? ""), U = jue.get(L), B = u?.value?.trim(), G = u?.style?.backgroundColor, Y = !!B && (/^(data:image\/|https?:\/\/|\/)/i.test(B) || /\.(svg|png|jpe?g|webp|gif)$/i.test(B)), he = C.useCallback(async (Se) => {
    try {
      m(!0), await Mue(Se), await f(`${Ws}/list`);
    } catch (W) {
      gb(W);
    } finally {
      m(!1);
    }
  }, [f]), ie = C.useCallback(
    () => {
    },
    [t]
  ), ne = C.useCallback(async () => {
    try {
      b(!0), await Aue(t), await f(`${Ws}/list`);
    } catch (Se) {
      gb(Se);
    } finally {
      b(!1);
    }
  }, [t, f]), H = C.useCallback(() => {
    M.current !== null && (window.clearInterval(M.current), M.current = null), _(!1);
  }, []), Q = C.useCallback(() => {
    M.current === null && (M.current = window.setInterval(() => {
      f(`${Ws}/list`);
    }, Pue), _(!0));
  }, [f]);
  C.useEffect(() => {
    (!P || r) && H();
  }, [r, P, H]), C.useEffect(() => {
    if (!P) return;
    const Se = sessionStorage.getItem("mcp:auto-authorize");
    Se && String(Se) === String(t) && (sessionStorage.removeItem("mcp:auto-authorize"), Q());
  }, [t, P, Q]), C.useEffect(() => H, [H]);
  const X = C.useCallback(() => {
    c && (window.open(c, "_blank", "noopener,noreferrer"), Q()), f(`${Ws}/list`);
  }, [c, f, Q]);
  return /* @__PURE__ */ v.jsxs(
    f9,
    {
      className: "relative hover:border-foreground/20 transition-colors bg-secondary/40",
      "data-testid": "mcp-server-card",
      "data-featured": a === "public",
      children: [
        N && /* @__PURE__ */ v.jsx("div", { className: "animate-pulse z-50 absolute inset-0 bg-background/50 flex items-center justify-center w-full h-full pointer-events-auto" }),
        /* @__PURE__ */ v.jsxs(
          h9,
          {
            className: "flex items-center gap-3 mb-2",
            children: [
              N && /* @__PURE__ */ v.jsx(qT, { className: "size-4 z-20 animate-spin mr-1" }),
              /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3", children: [
                /* @__PURE__ */ v.jsx(
                  "div",
                  {
                    className: "flex h-8 w-8 items-center justify-center rounded-xl border border-border/70 bg-muted/60",
                    style: G ? { backgroundColor: G } : void 0,
                    children: Y ? /* @__PURE__ */ v.jsx(
                      "img",
                      {
                        src: B,
                        alt: `${o} logo`,
                        className: "h-4 w-4 object-contain"
                      }
                    ) : B ? /* @__PURE__ */ v.jsx("span", { className: "text-base leading-none", children: B }) : U ? /* @__PURE__ */ v.jsx(U, { className: "size-4" }) : /* @__PURE__ */ v.jsx(lh, { className: "size-4 text-muted-foreground" })
                  }
                ),
                /* @__PURE__ */ v.jsx("h4", { className: "font-bold text-xs sm:text-lg flex items-center gap-1", children: o })
              ] }),
              /* @__PURE__ */ v.jsx("div", { className: "flex-1" }),
              P && /* @__PURE__ */ v.jsxs(
                Ht,
                {
                  variant: "outline",
                  size: "sm",
                  className: "gap-2 cursor-pointer",
                  onClick: X,
                  disabled: !I,
                  children: [
                    /* @__PURE__ */ v.jsx(X0, { className: "size-3.5" }),
                    "Authorize"
                  ]
                }
              ),
              /* @__PURE__ */ v.jsx("div", { className: "h-4", children: /* @__PURE__ */ v.jsx(aM, { orientation: "vertical" }) }),
              /* @__PURE__ */ v.jsxs(Gi, { children: [
                /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
                  Ht,
                  {
                    variant: "ghost",
                    size: "icon",
                    onClick: () => he(t),
                    className: "cursor-pointer",
                    disabled: N,
                    children: h ? /* @__PURE__ */ v.jsx(Zs, { className: "size-4 animate-spin" }) : /* @__PURE__ */ v.jsx(TY, { className: "size-3.5 " })
                  }
                ) }),
                /* @__PURE__ */ v.jsx(sw, { children: "Refresh" })
              ] }),
              /* @__PURE__ */ v.jsx(
                Tue,
                {
                  type: "mcp",
                  visibility: a === "public" ? "public" : "private",
                  isOwner: !0,
                  canChangeVisibility: !0,
                  editHref: `/chat-bot/mcp/modify?id=${encodeURIComponent(t)}&name=${encodeURIComponent(o)}&config=${encodeURIComponent(JSON.stringify(n))}`,
                  onVisibilityChange: ie,
                  onDelete: ne,
                  isVisibilityChangeLoading: !1,
                  isDeleteLoading: g,
                  disabled: N,
                  renderActions: () => null
                }
              )
            ]
          },
          `header-${i}-${P}`
        ),
        P && /* @__PURE__ */ v.jsxs("div", { className: "px-6 pb-2 text-xs text-muted-foreground flex items-center gap-2", children: [
          /* @__PURE__ */ v.jsx(X0, { className: "size-3.5" }),
          S ? "Waiting for authorization to complete." : "Pending authorization."
        ] }),
        O && /* @__PURE__ */ v.jsx(v9, { error: O }),
        /* @__PURE__ */ v.jsx("div", { className: "relative hidden sm:flex w-full", children: /* @__PURE__ */ v.jsxs(p9, { className: "flex min-w-0 w-full flex-row text-sm max-h-80 overflow-hidden border-r-0", children: [
          /* @__PURE__ */ v.jsxs("div", { className: "w-1/2 min-w-0 flex flex-col pr-2 border-r border-border", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 mb-2 pt-2 pb-1 z-10", children: [
              /* @__PURE__ */ v.jsx(H3, { size: 14, className: "text-muted-foreground" }),
              /* @__PURE__ */ v.jsx("h5", { className: "text-muted-foreground text-sm font-medium", children: "Configuration Preview" })
            ] }),
            /* @__PURE__ */ v.jsx("div", { className: "flex-1 overflow-y-auto", children: /* @__PURE__ */ v.jsx(Ju, { data: n }) })
          ] }),
          /* @__PURE__ */ v.jsxs("div", { className: "w-1/2 min-w-0 flex flex-col pl-4", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 mb-2 pt-2 pb-1 z-10", children: [
              /* @__PURE__ */ v.jsx(J0, { size: 14, className: "text-muted-foreground" }),
              /* @__PURE__ */ v.jsxs("h5", { className: "text-muted-foreground text-sm font-medium", children: [
                "Available Tools ",
                s.length > 0 ? `(${s.length})` : ""
              ] })
            ] }),
            /* @__PURE__ */ v.jsxs("div", { className: "relative mb-3", children: [
              /* @__PURE__ */ v.jsx(MY, { className: "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" }),
              /* @__PURE__ */ v.jsx(
                sM,
                {
                  type: "text",
                  placeholder: "Search tools...",
                  value: x,
                  onChange: (Se) => w(Se.target.value),
                  className: "pl-9 h-8 text-sm"
                }
              )
            ] }),
            /* @__PURE__ */ v.jsx("div", { className: "flex-1 overflow-y-auto", children: s.length > 0 ? /* @__PURE__ */ v.jsx(tce, { tools: s, serverId: t, searchQuery: x }) : /* @__PURE__ */ v.jsx("div", { className: "bg-secondary/30 rounded-md p-3 text-center", children: /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground", children: "No tools available" }) }) })
          ] })
        ] }) })
      ]
    },
    `mcp-card-${t}-${i}`
  );
});
var Jk = "rovingFocusGroup.onEntryFocus", Iue = { bubbles: !1, cancelable: !0 }, Kg = "RovingFocusGroup", [C_, B9, zue] = tM(Kg), [Lue, $9] = ps(
  Kg,
  [zue]
), [Bue, $ue] = Lue(Kg), U9 = C.forwardRef(
  (e, t) => /* @__PURE__ */ v.jsx(C_.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ v.jsx(C_.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ v.jsx(Uue, { ...e, ref: t }) }) })
);
U9.displayName = Kg;
var Uue = C.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: i = !1,
    dir: o,
    currentTabStopId: s,
    defaultCurrentTabStopId: a,
    onCurrentTabStopIdChange: c,
    onEntryFocus: u,
    preventScrollOnEntryFocus: f = !1,
    ...h
  } = e, m = C.useRef(null), g = Ft(t, m), b = Hx(o), [x, w] = Qa({
    prop: s,
    defaultProp: a ?? null,
    onChange: c,
    caller: Kg
  }), [S, _] = C.useState(!1), M = Dr(u), N = B9(n), P = C.useRef(!1), [I, O] = C.useState(0);
  return C.useEffect(() => {
    const L = m.current;
    if (L)
      return L.addEventListener(Jk, M), () => L.removeEventListener(Jk, M);
  }, [M]), /* @__PURE__ */ v.jsx(
    Bue,
    {
      scope: n,
      orientation: r,
      dir: b,
      loop: i,
      currentTabStopId: x,
      onItemFocus: C.useCallback(
        (L) => w(L),
        [w]
      ),
      onItemShiftTab: C.useCallback(() => _(!0), []),
      onFocusableItemAdd: C.useCallback(
        () => O((L) => L + 1),
        []
      ),
      onFocusableItemRemove: C.useCallback(
        () => O((L) => L - 1),
        []
      ),
      children: /* @__PURE__ */ v.jsx(
        Et.div,
        {
          tabIndex: S || I === 0 ? -1 : 0,
          "data-orientation": r,
          ...h,
          ref: g,
          style: { outline: "none", ...e.style },
          onMouseDown: Ye(e.onMouseDown, () => {
            P.current = !0;
          }),
          onFocus: Ye(e.onFocus, (L) => {
            const U = !P.current;
            if (L.target === L.currentTarget && U && !S) {
              const B = new CustomEvent(Jk, Iue);
              if (L.currentTarget.dispatchEvent(B), !B.defaultPrevented) {
                const G = N().filter((H) => H.focusable), Y = G.find((H) => H.active), he = G.find((H) => H.id === x), ne = [Y, he, ...G].filter(
                  Boolean
                ).map((H) => H.ref.current);
                H9(ne, f);
              }
            }
            P.current = !1;
          }),
          onBlur: Ye(e.onBlur, () => _(!1))
        }
      )
    }
  );
}), F9 = "RovingFocusGroupItem", V9 = C.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: i = !1,
      tabStopId: o,
      children: s,
      ...a
    } = e, c = Uo(), u = o || c, f = $ue(F9, n), h = f.currentTabStopId === u, m = B9(n), { onFocusableItemAdd: g, onFocusableItemRemove: b, currentTabStopId: x } = f;
    return C.useEffect(() => {
      if (r)
        return g(), () => b();
    }, [r, g, b]), /* @__PURE__ */ v.jsx(
      C_.ItemSlot,
      {
        scope: n,
        id: u,
        focusable: r,
        active: i,
        children: /* @__PURE__ */ v.jsx(
          Et.span,
          {
            tabIndex: h ? 0 : -1,
            "data-orientation": f.orientation,
            ...a,
            ref: t,
            onMouseDown: Ye(e.onMouseDown, (w) => {
              r ? f.onItemFocus(u) : w.preventDefault();
            }),
            onFocus: Ye(e.onFocus, () => f.onItemFocus(u)),
            onKeyDown: Ye(e.onKeyDown, (w) => {
              if (w.key === "Tab" && w.shiftKey) {
                f.onItemShiftTab();
                return;
              }
              if (w.target !== w.currentTarget) return;
              const S = Hue(w, f.orientation, f.dir);
              if (S !== void 0) {
                if (w.metaKey || w.ctrlKey || w.altKey || w.shiftKey) return;
                w.preventDefault();
                let M = m().filter((N) => N.focusable).map((N) => N.ref.current);
                if (S === "last") M.reverse();
                else if (S === "prev" || S === "next") {
                  S === "prev" && M.reverse();
                  const N = M.indexOf(w.currentTarget);
                  M = f.loop ? Wue(M, N + 1) : M.slice(N + 1);
                }
                setTimeout(() => H9(M));
              }
            }),
            children: typeof s == "function" ? s({ isCurrentTabStop: h, hasTabStop: x != null }) : s
          }
        )
      }
    );
  }
);
V9.displayName = F9;
var Fue = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Vue(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function Hue(e, t, n) {
  const r = Vue(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return Fue[r];
}
function H9(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function Wue(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var que = U9, Gue = V9, E_ = ["Enter", " "], Kue = ["ArrowDown", "PageUp", "Home"], W9 = ["ArrowUp", "PageDown", "End"], Zue = [...Kue, ...W9], Yue = {
  ltr: [...E_, "ArrowRight"],
  rtl: [...E_, "ArrowLeft"]
}, Xue = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, Zg = "Menu", [eg, Jue, Que] = tM(Zg), [dd, q9] = ps(Zg, [
  Que,
  Rh,
  $9
]), Yg = Rh(), G9 = $9(), [K9, Lc] = dd(Zg), [ede, Xg] = dd(Zg), Z9 = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: i, onOpenChange: o, modal: s = !0 } = e, a = Yg(t), [c, u] = C.useState(null), f = C.useRef(!1), h = Dr(o), m = Hx(i);
  return C.useEffect(() => {
    const g = () => {
      f.current = !0, document.addEventListener("pointerdown", b, { capture: !0, once: !0 }), document.addEventListener("pointermove", b, { capture: !0, once: !0 });
    }, b = () => f.current = !1;
    return document.addEventListener("keydown", g, { capture: !0 }), () => {
      document.removeEventListener("keydown", g, { capture: !0 }), document.removeEventListener("pointerdown", b, { capture: !0 }), document.removeEventListener("pointermove", b, { capture: !0 });
    };
  }, []), /* @__PURE__ */ v.jsx(rw, { ...a, children: /* @__PURE__ */ v.jsx(
    K9,
    {
      scope: t,
      open: n,
      onOpenChange: h,
      content: c,
      onContentChange: u,
      children: /* @__PURE__ */ v.jsx(
        ede,
        {
          scope: t,
          onClose: C.useCallback(() => h(!1), [h]),
          isUsingKeyboardRef: f,
          dir: m,
          modal: s,
          children: r
        }
      )
    }
  ) });
};
Z9.displayName = Zg;
var tde = "MenuAnchor", mM = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = Yg(n);
    return /* @__PURE__ */ v.jsx(HA, { ...i, ...r, ref: t });
  }
);
mM.displayName = tde;
var gM = "MenuPortal", [nde, Y9] = dd(gM, {
  forceMount: void 0
}), X9 = (e) => {
  const { __scopeMenu: t, forceMount: n, children: r, container: i } = e, o = Lc(gM, t);
  return /* @__PURE__ */ v.jsx(nde, { scope: t, forceMount: n, children: /* @__PURE__ */ v.jsx(Di, { present: n || o.open, children: /* @__PURE__ */ v.jsx(Ug, { asChild: !0, container: i, children: r }) }) });
};
X9.displayName = gM;
var Fo = "MenuContent", [rde, yM] = dd(Fo), J9 = C.forwardRef(
  (e, t) => {
    const n = Y9(Fo, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = Lc(Fo, e.__scopeMenu), s = Xg(Fo, e.__scopeMenu);
    return /* @__PURE__ */ v.jsx(eg.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ v.jsx(Di, { present: r || o.open, children: /* @__PURE__ */ v.jsx(eg.Slot, { scope: e.__scopeMenu, children: s.modal ? /* @__PURE__ */ v.jsx(ide, { ...i, ref: t }) : /* @__PURE__ */ v.jsx(ode, { ...i, ref: t }) }) }) });
  }
), ide = C.forwardRef(
  (e, t) => {
    const n = Lc(Fo, e.__scopeMenu), r = C.useRef(null), i = Ft(t, r);
    return C.useEffect(() => {
      const o = r.current;
      if (o) return XA(o);
    }, []), /* @__PURE__ */ v.jsx(
      vM,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Ye(
          e.onFocusOutside,
          (o) => o.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), ode = C.forwardRef((e, t) => {
  const n = Lc(Fo, e.__scopeMenu);
  return /* @__PURE__ */ v.jsx(
    vM,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), sde = /* @__PURE__ */ rh("MenuContent.ScrollLock"), vM = C.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: i,
      onOpenAutoFocus: o,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: a,
      onEntryFocus: c,
      onEscapeKeyDown: u,
      onPointerDownOutside: f,
      onFocusOutside: h,
      onInteractOutside: m,
      onDismiss: g,
      disableOutsideScroll: b,
      ...x
    } = e, w = Lc(Fo, n), S = Xg(Fo, n), _ = Yg(n), M = G9(n), N = Jue(n), [P, I] = C.useState(null), O = C.useRef(null), L = Ft(t, O, w.onContentChange), U = C.useRef(0), B = C.useRef(""), G = C.useRef(0), Y = C.useRef(null), he = C.useRef("right"), ie = C.useRef(0), ne = b ? cw : C.Fragment, H = b ? { as: sde, allowPinchZoom: !0 } : void 0, Q = (Se) => {
      const W = B.current + Se, Z = N().filter((J) => !J.disabled), pe = document.activeElement, F = Z.find((J) => J.ref.current === pe)?.textValue, ee = Z.map((J) => J.textValue), ge = vde(ee, W, F), re = Z.find((J) => J.textValue === ge)?.ref.current;
      (function J(xe) {
        B.current = xe, window.clearTimeout(U.current), xe !== "" && (U.current = window.setTimeout(() => J(""), 1e3));
      })(W), re && setTimeout(() => re.focus());
    };
    C.useEffect(() => () => window.clearTimeout(U.current), []), YA();
    const X = C.useCallback((Se) => he.current === Y.current?.side && xde(Se, Y.current?.area), []);
    return /* @__PURE__ */ v.jsx(
      rde,
      {
        scope: n,
        searchRef: B,
        onItemEnter: C.useCallback(
          (Se) => {
            X(Se) && Se.preventDefault();
          },
          [X]
        ),
        onItemLeave: C.useCallback(
          (Se) => {
            X(Se) || (O.current?.focus(), I(null));
          },
          [X]
        ),
        onTriggerLeave: C.useCallback(
          (Se) => {
            X(Se) && Se.preventDefault();
          },
          [X]
        ),
        pointerGraceTimerRef: G,
        onPointerGraceIntentChange: C.useCallback((Se) => {
          Y.current = Se;
        }, []),
        children: /* @__PURE__ */ v.jsx(ne, { ...H, children: /* @__PURE__ */ v.jsx(
          aw,
          {
            asChild: !0,
            trapped: i,
            onMountAutoFocus: Ye(o, (Se) => {
              Se.preventDefault(), O.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: s,
            children: /* @__PURE__ */ v.jsx(
              Bg,
              {
                asChild: !0,
                disableOutsidePointerEvents: a,
                onEscapeKeyDown: u,
                onPointerDownOutside: f,
                onFocusOutside: h,
                onInteractOutside: m,
                onDismiss: g,
                children: /* @__PURE__ */ v.jsx(
                  que,
                  {
                    asChild: !0,
                    ...M,
                    dir: S.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: P,
                    onCurrentTabStopIdChange: I,
                    onEntryFocus: Ye(c, (Se) => {
                      S.isUsingKeyboardRef.current || Se.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ v.jsx(
                      WA,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": mU(w.open),
                        "data-radix-menu-content": "",
                        dir: S.dir,
                        ..._,
                        ...x,
                        ref: L,
                        style: { outline: "none", ...x.style },
                        onKeyDown: Ye(x.onKeyDown, (Se) => {
                          const Z = Se.target.closest("[data-radix-menu-content]") === Se.currentTarget, pe = Se.ctrlKey || Se.altKey || Se.metaKey, F = Se.key.length === 1;
                          Z && (Se.key === "Tab" && Se.preventDefault(), !pe && F && Q(Se.key));
                          const ee = O.current;
                          if (Se.target !== ee || !Zue.includes(Se.key)) return;
                          Se.preventDefault();
                          const re = N().filter((J) => !J.disabled).map((J) => J.ref.current);
                          W9.includes(Se.key) && re.reverse(), gde(re);
                        }),
                        onBlur: Ye(e.onBlur, (Se) => {
                          Se.currentTarget.contains(Se.target) || (window.clearTimeout(U.current), B.current = "");
                        }),
                        onPointerMove: Ye(
                          e.onPointerMove,
                          tg((Se) => {
                            const W = Se.target, Z = ie.current !== Se.clientX;
                            if (Se.currentTarget.contains(W) && Z) {
                              const pe = Se.clientX > ie.current ? "right" : "left";
                              he.current = pe, ie.current = Se.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
J9.displayName = Fo;
var ade = "MenuGroup", bM = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ v.jsx(Et.div, { role: "group", ...r, ref: t });
  }
);
bM.displayName = ade;
var lde = "MenuLabel", Q9 = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ v.jsx(Et.div, { ...r, ref: t });
  }
);
Q9.displayName = lde;
var xb = "MenuItem", zj = "menu.itemSelect", vw = C.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...i } = e, o = C.useRef(null), s = Xg(xb, e.__scopeMenu), a = yM(xb, e.__scopeMenu), c = Ft(t, o), u = C.useRef(!1), f = () => {
      const h = o.current;
      if (!n && h) {
        const m = new CustomEvent(zj, { bubbles: !0, cancelable: !0 });
        h.addEventListener(zj, (g) => r?.(g), { once: !0 }), K3(h, m), m.defaultPrevented ? u.current = !1 : s.onClose();
      }
    };
    return /* @__PURE__ */ v.jsx(
      eU,
      {
        ...i,
        ref: c,
        disabled: n,
        onClick: Ye(e.onClick, f),
        onPointerDown: (h) => {
          e.onPointerDown?.(h), u.current = !0;
        },
        onPointerUp: Ye(e.onPointerUp, (h) => {
          u.current || h.currentTarget?.click();
        }),
        onKeyDown: Ye(e.onKeyDown, (h) => {
          const m = a.searchRef.current !== "";
          n || m && h.key === " " || E_.includes(h.key) && (h.currentTarget.click(), h.preventDefault());
        })
      }
    );
  }
);
vw.displayName = xb;
var eU = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: i, ...o } = e, s = yM(xb, n), a = G9(n), c = C.useRef(null), u = Ft(t, c), [f, h] = C.useState(!1), [m, g] = C.useState("");
    return C.useEffect(() => {
      const b = c.current;
      b && g((b.textContent ?? "").trim());
    }, [o.children]), /* @__PURE__ */ v.jsx(
      eg.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: i ?? m,
        children: /* @__PURE__ */ v.jsx(Gue, { asChild: !0, ...a, focusable: !r, children: /* @__PURE__ */ v.jsx(
          Et.div,
          {
            role: "menuitem",
            "data-highlighted": f ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...o,
            ref: u,
            onPointerMove: Ye(
              e.onPointerMove,
              tg((b) => {
                r ? s.onItemLeave(b) : (s.onItemEnter(b), b.defaultPrevented || b.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Ye(
              e.onPointerLeave,
              tg((b) => s.onItemLeave(b))
            ),
            onFocus: Ye(e.onFocus, () => h(!0)),
            onBlur: Ye(e.onBlur, () => h(!1))
          }
        ) })
      }
    );
  }
), cde = "MenuCheckboxItem", tU = C.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...i } = e;
    return /* @__PURE__ */ v.jsx(sU, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ v.jsx(
      vw,
      {
        role: "menuitemcheckbox",
        "aria-checked": wb(n) ? "mixed" : n,
        ...i,
        ref: t,
        "data-state": SM(n),
        onSelect: Ye(
          i.onSelect,
          () => r?.(wb(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
tU.displayName = cde;
var nU = "MenuRadioGroup", [ude, dde] = dd(
  nU,
  { value: void 0, onValueChange: () => {
  } }
), rU = C.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...i } = e, o = Dr(r);
    return /* @__PURE__ */ v.jsx(ude, { scope: e.__scopeMenu, value: n, onValueChange: o, children: /* @__PURE__ */ v.jsx(bM, { ...i, ref: t }) });
  }
);
rU.displayName = nU;
var iU = "MenuRadioItem", oU = C.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, i = dde(iU, e.__scopeMenu), o = n === i.value;
    return /* @__PURE__ */ v.jsx(sU, { scope: e.__scopeMenu, checked: o, children: /* @__PURE__ */ v.jsx(
      vw,
      {
        role: "menuitemradio",
        "aria-checked": o,
        ...r,
        ref: t,
        "data-state": SM(o),
        onSelect: Ye(
          r.onSelect,
          () => i.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
oU.displayName = iU;
var xM = "MenuItemIndicator", [sU, fde] = dd(
  xM,
  { checked: !1 }
), aU = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...i } = e, o = fde(xM, n);
    return /* @__PURE__ */ v.jsx(
      Di,
      {
        present: r || wb(o.checked) || o.checked === !0,
        children: /* @__PURE__ */ v.jsx(
          Et.span,
          {
            ...i,
            ref: t,
            "data-state": SM(o.checked)
          }
        )
      }
    );
  }
);
aU.displayName = xM;
var hde = "MenuSeparator", lU = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ v.jsx(
      Et.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
lU.displayName = hde;
var pde = "MenuArrow", cU = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = Yg(n);
    return /* @__PURE__ */ v.jsx(qA, { ...i, ...r, ref: t });
  }
);
cU.displayName = pde;
var wM = "MenuSub", [mde, uU] = dd(wM), dU = (e) => {
  const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: i } = e, o = Lc(wM, t), s = Yg(t), [a, c] = C.useState(null), [u, f] = C.useState(null), h = Dr(i);
  return C.useEffect(() => (o.open === !1 && h(!1), () => h(!1)), [o.open, h]), /* @__PURE__ */ v.jsx(rw, { ...s, children: /* @__PURE__ */ v.jsx(
    K9,
    {
      scope: t,
      open: r,
      onOpenChange: h,
      content: u,
      onContentChange: f,
      children: /* @__PURE__ */ v.jsx(
        mde,
        {
          scope: t,
          contentId: Uo(),
          triggerId: Uo(),
          trigger: a,
          onTriggerChange: c,
          children: n
        }
      )
    }
  ) });
};
dU.displayName = wM;
var lm = "MenuSubTrigger", fU = C.forwardRef(
  (e, t) => {
    const n = Lc(lm, e.__scopeMenu), r = Xg(lm, e.__scopeMenu), i = uU(lm, e.__scopeMenu), o = yM(lm, e.__scopeMenu), s = C.useRef(null), { pointerGraceTimerRef: a, onPointerGraceIntentChange: c } = o, u = { __scopeMenu: e.__scopeMenu }, f = C.useCallback(() => {
      s.current && window.clearTimeout(s.current), s.current = null;
    }, []);
    return C.useEffect(() => f, [f]), C.useEffect(() => {
      const h = a.current;
      return () => {
        window.clearTimeout(h), c(null);
      };
    }, [a, c]), /* @__PURE__ */ v.jsx(mM, { asChild: !0, ...u, children: /* @__PURE__ */ v.jsx(
      eU,
      {
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": i.contentId,
        "data-state": mU(n.open),
        ...e,
        ref: Og(t, i.onTriggerChange),
        onClick: (h) => {
          e.onClick?.(h), !(e.disabled || h.defaultPrevented) && (h.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Ye(
          e.onPointerMove,
          tg((h) => {
            o.onItemEnter(h), !h.defaultPrevented && !e.disabled && !n.open && !s.current && (o.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => {
              n.onOpenChange(!0), f();
            }, 100));
          })
        ),
        onPointerLeave: Ye(
          e.onPointerLeave,
          tg((h) => {
            f();
            const m = n.content?.getBoundingClientRect();
            if (m) {
              const g = n.content?.dataset.side, b = g === "right", x = b ? -5 : 5, w = m[b ? "left" : "right"], S = m[b ? "right" : "left"];
              o.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: h.clientX + x, y: h.clientY },
                  { x: w, y: m.top },
                  { x: S, y: m.top },
                  { x: S, y: m.bottom },
                  { x: w, y: m.bottom }
                ],
                side: g
              }), window.clearTimeout(a.current), a.current = window.setTimeout(
                () => o.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (o.onTriggerLeave(h), h.defaultPrevented) return;
              o.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Ye(e.onKeyDown, (h) => {
          const m = o.searchRef.current !== "";
          e.disabled || m && h.key === " " || Yue[r.dir].includes(h.key) && (n.onOpenChange(!0), n.content?.focus(), h.preventDefault());
        })
      }
    ) });
  }
);
fU.displayName = lm;
var hU = "MenuSubContent", pU = C.forwardRef(
  (e, t) => {
    const n = Y9(Fo, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = Lc(Fo, e.__scopeMenu), s = Xg(Fo, e.__scopeMenu), a = uU(hU, e.__scopeMenu), c = C.useRef(null), u = Ft(t, c);
    return /* @__PURE__ */ v.jsx(eg.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ v.jsx(Di, { present: r || o.open, children: /* @__PURE__ */ v.jsx(eg.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ v.jsx(
      vM,
      {
        id: a.contentId,
        "aria-labelledby": a.triggerId,
        ...i,
        ref: u,
        align: "start",
        side: s.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (f) => {
          s.isUsingKeyboardRef.current && c.current?.focus(), f.preventDefault();
        },
        onCloseAutoFocus: (f) => f.preventDefault(),
        onFocusOutside: Ye(e.onFocusOutside, (f) => {
          f.target !== a.trigger && o.onOpenChange(!1);
        }),
        onEscapeKeyDown: Ye(e.onEscapeKeyDown, (f) => {
          s.onClose(), f.preventDefault();
        }),
        onKeyDown: Ye(e.onKeyDown, (f) => {
          const h = f.currentTarget.contains(f.target), m = Xue[s.dir].includes(f.key);
          h && m && (o.onOpenChange(!1), a.trigger?.focus(), f.preventDefault());
        })
      }
    ) }) }) });
  }
);
pU.displayName = hU;
function mU(e) {
  return e ? "open" : "closed";
}
function wb(e) {
  return e === "indeterminate";
}
function SM(e) {
  return wb(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function gde(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function yde(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function vde(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let s = yde(e, Math.max(o, 0));
  i.length === 1 && (s = s.filter((u) => u !== n));
  const c = s.find(
    (u) => u.toLowerCase().startsWith(i.toLowerCase())
  );
  return c !== n ? c : void 0;
}
function bde(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const a = t[o], c = t[s], u = a.x, f = a.y, h = c.x, m = c.y;
    f > r != m > r && n < (h - u) * (r - f) / (m - f) + u && (i = !i);
  }
  return i;
}
function xde(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return bde(n, t);
}
function tg(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var wde = Z9, Sde = mM, kde = X9, Cde = J9, Ede = bM, _de = Q9, Tde = vw, Ade = tU, Mde = rU, Nde = oU, Rde = aU, Ode = lU, Dde = cU, Pde = dU, jde = fU, Ide = pU, bw = "DropdownMenu", [zde] = ps(
  bw,
  [q9]
), vi = q9(), [Lde, gU] = zde(bw), yU = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: i,
    defaultOpen: o,
    onOpenChange: s,
    modal: a = !0
  } = e, c = vi(t), u = C.useRef(null), [f, h] = Qa({
    prop: i,
    defaultProp: o ?? !1,
    onChange: s,
    caller: bw
  });
  return /* @__PURE__ */ v.jsx(
    Lde,
    {
      scope: t,
      triggerId: Uo(),
      triggerRef: u,
      contentId: Uo(),
      open: f,
      onOpenChange: h,
      onOpenToggle: C.useCallback(() => h((m) => !m), [h]),
      modal: a,
      children: /* @__PURE__ */ v.jsx(wde, { ...c, open: f, onOpenChange: h, dir: r, modal: a, children: n })
    }
  );
};
yU.displayName = bw;
var vU = "DropdownMenuTrigger", bU = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...i } = e, o = gU(vU, n), s = vi(n);
    return /* @__PURE__ */ v.jsx(Sde, { asChild: !0, ...s, children: /* @__PURE__ */ v.jsx(
      Et.button,
      {
        type: "button",
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": o.open,
        "aria-controls": o.open ? o.contentId : void 0,
        "data-state": o.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...i,
        ref: Og(t, o.triggerRef),
        onPointerDown: Ye(e.onPointerDown, (a) => {
          !r && a.button === 0 && a.ctrlKey === !1 && (o.onOpenToggle(), o.open || a.preventDefault());
        }),
        onKeyDown: Ye(e.onKeyDown, (a) => {
          r || (["Enter", " "].includes(a.key) && o.onOpenToggle(), a.key === "ArrowDown" && o.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault());
        })
      }
    ) });
  }
);
bU.displayName = vU;
var Bde = "DropdownMenuPortal", xU = (e) => {
  const { __scopeDropdownMenu: t, ...n } = e, r = vi(t);
  return /* @__PURE__ */ v.jsx(kde, { ...r, ...n });
};
xU.displayName = Bde;
var wU = "DropdownMenuContent", SU = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = gU(wU, n), o = vi(n), s = C.useRef(!1);
    return /* @__PURE__ */ v.jsx(
      Cde,
      {
        id: i.contentId,
        "aria-labelledby": i.triggerId,
        ...o,
        ...r,
        ref: t,
        onCloseAutoFocus: Ye(e.onCloseAutoFocus, (a) => {
          s.current || i.triggerRef.current?.focus(), s.current = !1, a.preventDefault();
        }),
        onInteractOutside: Ye(e.onInteractOutside, (a) => {
          const c = a.detail.originalEvent, u = c.button === 0 && c.ctrlKey === !0, f = c.button === 2 || u;
          (!i.modal || f) && (s.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
SU.displayName = wU;
var $de = "DropdownMenuGroup", kU = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
    return /* @__PURE__ */ v.jsx(Ede, { ...i, ...r, ref: t });
  }
);
kU.displayName = $de;
var Ude = "DropdownMenuLabel", CU = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
    return /* @__PURE__ */ v.jsx(_de, { ...i, ...r, ref: t });
  }
);
CU.displayName = Ude;
var Fde = "DropdownMenuItem", EU = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
    return /* @__PURE__ */ v.jsx(Tde, { ...i, ...r, ref: t });
  }
);
EU.displayName = Fde;
var Vde = "DropdownMenuCheckboxItem", _U = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(Ade, { ...i, ...r, ref: t });
});
_U.displayName = Vde;
var Hde = "DropdownMenuRadioGroup", Wde = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(Mde, { ...i, ...r, ref: t });
});
Wde.displayName = Hde;
var qde = "DropdownMenuRadioItem", Gde = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(Nde, { ...i, ...r, ref: t });
});
Gde.displayName = qde;
var Kde = "DropdownMenuItemIndicator", TU = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(Rde, { ...i, ...r, ref: t });
});
TU.displayName = Kde;
var Zde = "DropdownMenuSeparator", AU = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(Ode, { ...i, ...r, ref: t });
});
AU.displayName = Zde;
var Yde = "DropdownMenuArrow", Xde = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
    return /* @__PURE__ */ v.jsx(Dde, { ...i, ...r, ref: t });
  }
);
Xde.displayName = Yde;
var Jde = (e) => {
  const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: i, defaultOpen: o } = e, s = vi(t), [a, c] = Qa({
    prop: r,
    defaultProp: o ?? !1,
    onChange: i,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ v.jsx(Pde, { ...s, open: a, onOpenChange: c, children: n });
}, Qde = "DropdownMenuSubTrigger", MU = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(jde, { ...i, ...r, ref: t });
});
MU.displayName = Qde;
var efe = "DropdownMenuSubContent", NU = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = vi(n);
  return /* @__PURE__ */ v.jsx(
    Ide,
    {
      ...i,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
NU.displayName = efe;
var tfe = yU, nfe = bU, RU = xU, rfe = SU, ife = kU, ofe = CU, sfe = EU, afe = _U, lfe = TU, OU = AU, cfe = Jde, ufe = MU, dfe = NU;
function Qu({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(tfe, { "data-slot": "dropdown-menu", ...e });
}
function ffe({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(RU, { "data-slot": "dropdown-menu-portal", ...e });
}
function ed({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(
    nfe,
    {
      "data-slot": "dropdown-menu-trigger",
      ...e
    }
  );
}
function td({
  className: e,
  sideOffset: t = 4,
  ...n
}) {
  return /* @__PURE__ */ v.jsx(RU, { children: /* @__PURE__ */ v.jsx(
    rfe,
    {
      "data-slot": "dropdown-menu-content",
      sideOffset: t,
      className: at(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
        e
      ),
      ...n,
      onCloseAutoFocus: (r) => {
        r.preventDefault(), document.body.style.pointerEvents = "";
      }
    }
  ) });
}
function hfe({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(ife, { "data-slot": "dropdown-menu-group", ...e });
}
function ls({
  className: e,
  inset: t,
  variant: n = "default",
  ...r
}) {
  return /* @__PURE__ */ v.jsx(
    sfe,
    {
      "data-slot": "dropdown-menu-item",
      "data-inset": t,
      "data-variant": n,
      className: at(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...r
    }
  );
}
function pfe({
  className: e,
  children: t,
  checked: n,
  ...r
}) {
  return /* @__PURE__ */ v.jsxs(
    afe,
    {
      "data-slot": "dropdown-menu-checkbox-item",
      className: at(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      checked: n,
      ...r,
      children: [
        /* @__PURE__ */ v.jsx("span", { className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center", children: /* @__PURE__ */ v.jsx(lfe, { children: /* @__PURE__ */ v.jsx(wc, { className: "size-4" }) }) }),
        t
      ]
    }
  );
}
function mfe({
  className: e,
  inset: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsx(
    ofe,
    {
      "data-slot": "dropdown-menu-label",
      "data-inset": t,
      className: at("px-2 py-1.5 text-sm font-medium data-[inset]:pl-8", e),
      ...n
    }
  );
}
function Sb({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    OU,
    {
      "data-slot": "dropdown-menu-separator",
      className: at("bg-border -mx-1 my-1 h-px", e),
      ...t
    }
  );
}
function gfe({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(cfe, { "data-slot": "dropdown-menu-sub", ...e });
}
function yfe({
  className: e,
  inset: t,
  children: n,
  ...r
}) {
  return /* @__PURE__ */ v.jsxs(
    ufe,
    {
      "data-slot": "dropdown-menu-sub-trigger",
      "data-inset": t,
      className: at(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        e
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ v.jsx(Ng, { className: "ml-auto size-4" })
      ]
    }
  );
}
function vfe({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    dfe,
    {
      "data-slot": "dropdown-menu-sub-content",
      className: at(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        e
      ),
      ...t
    }
  );
}
var bfe = class DU extends Error {
  static kind = "ClerkError";
  clerkError = !0;
  code;
  longMessage;
  docsUrl;
  cause;
  get name() {
    return this.constructor.name;
  }
  constructor(t) {
    super(new.target.formatMessage(new.target.kind, t.message, t.code, t.docsUrl), { cause: t.cause }), Object.setPrototypeOf(this, DU.prototype), this.code = t.code, this.docsUrl = t.docsUrl, this.longMessage = t.longMessage, this.cause = t.cause;
  }
  toString() {
    return `[${this.name}]
Message:${this.message}`;
  }
  static formatMessage(t, n, r, i) {
    const o = "Clerk:", s = new RegExp(o.replace(" ", "\\s*"), "i");
    return n = n.replace(s, ""), n = `${o} ${n.trim()}

(code="${r}")

`, i && (n += `

Docs: ${i}`), n;
  }
};
const xfe = Object.freeze({
  InvalidProxyUrlErrorMessage: "The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})",
  InvalidPublishableKeyErrorMessage: "The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})",
  MissingPublishableKeyErrorMessage: "Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.",
  MissingSecretKeyErrorMessage: "Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.",
  MissingClerkProvider: "{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider"
});
function PU({ packageName: e, customMessages: t }) {
  let n = e;
  function r(o, s) {
    if (!s) return `${n}: ${o}`;
    let a = o;
    const c = o.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);
    for (const u of c) {
      const f = (s[u[1]] || "").toString();
      a = a.replace(`{{${u[1]}}}`, f);
    }
    return `${n}: ${a}`;
  }
  const i = {
    ...xfe,
    ...t
  };
  return {
    setPackageName({ packageName: o }) {
      return typeof o == "string" && (n = o), this;
    },
    setMessages({ customMessages: o }) {
      return Object.assign(i, o || {}), this;
    },
    throwInvalidPublishableKeyError(o) {
      throw new Error(r(i.InvalidPublishableKeyErrorMessage, o));
    },
    throwInvalidProxyUrl(o) {
      throw new Error(r(i.InvalidProxyUrlErrorMessage, o));
    },
    throwMissingPublishableKeyError() {
      throw new Error(r(i.MissingPublishableKeyErrorMessage));
    },
    throwMissingSecretKeyError() {
      throw new Error(r(i.MissingSecretKeyErrorMessage));
    },
    throwMissingClerkProviderError(o) {
      throw new Error(r(i.MissingClerkProvider, o));
    },
    throw(o) {
      throw new Error(r(o));
    }
  };
}
var __ = class jU extends bfe {
  static kind = "ClerkRuntimeError";
  /**
  * @deprecated Use `clerkError` property instead. This property is maintained for backward compatibility.
  */
  clerkRuntimeError = !0;
  constructor(t, n) {
    super({
      ...n,
      message: t
    }), Object.setPrototypeOf(this, jU.prototype);
  }
};
const wfe = [
  ".lcl.dev",
  ".stg.dev",
  ".lclstage.dev",
  ".stgstage.dev",
  ".dev.lclclerk.com",
  ".stg.lclclerk.com",
  ".accounts.lclclerk.com",
  "accountsstage.dev",
  "accounts.dev"
], IU = (e) => typeof atob < "u" && typeof atob == "function" ? atob(e) : typeof global < "u" && global.Buffer ? new global.Buffer(e, "base64").toString() : e, zU = "pk_live_", Sfe = "pk_test_";
function LU(e) {
  if (!e.endsWith("$")) return !1;
  const t = e.slice(0, -1);
  return t.includes("$") ? !1 : t.includes(".");
}
function Lj(e, t = {}) {
  if (e = e || "", !e || !Bj(e)) {
    if (t.fatal && !e) throw new Error("Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys");
    if (t.fatal && !Bj(e)) throw new Error("Publishable key not valid.");
    return null;
  }
  const n = e.startsWith(zU) ? "production" : "development";
  let r;
  try {
    r = IU(e.split("_")[2]);
  } catch {
    if (t.fatal) throw new Error("Publishable key not valid: Failed to decode key.");
    return null;
  }
  if (!LU(r)) {
    if (t.fatal) throw new Error("Publishable key not valid: Decoded key has invalid format.");
    return null;
  }
  let i = r.slice(0, -1);
  return t.proxyUrl ? i = t.proxyUrl : n !== "development" && t.domain && t.isSatellite && (i = `clerk.${t.domain}`), {
    instanceType: n,
    frontendApi: i
  };
}
function Bj(e = "") {
  try {
    if (!(e.startsWith(zU) || e.startsWith(Sfe))) return !1;
    const t = e.split("_");
    if (t.length !== 3) return !1;
    const n = t[2];
    return n ? LU(IU(n)) : !1;
  } catch {
    return !1;
  }
}
function kfe() {
  const e = /* @__PURE__ */ new Map();
  return { isDevOrStagingUrl: (t) => {
    if (!t) return !1;
    const n = typeof t == "string" ? t : t.hostname;
    let r = e.get(n);
    return r === void 0 && (r = wfe.some((i) => n.endsWith(i)), e.set(n, r)), r;
  } };
}
const Cfe = "METHOD_CALLED", Efe = 0.1;
function _fe(e, t) {
  return {
    event: Cfe,
    eventSamplingRate: Efe,
    payload: {
      method: e,
      ...t
    }
  };
}
var $j = Object.prototype.hasOwnProperty;
function Uj(e, t, n) {
  for (n of e.keys())
    if (Am(n, t)) return n;
}
function Am(e, t) {
  var n, r, i;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((r = e.length) === t.length)
        for (; r-- && Am(e[r], t[r]); ) ;
      return r === -1;
    }
    if (n === Set) {
      if (e.size !== t.size)
        return !1;
      for (r of e)
        if (i = r, i && typeof i == "object" && (i = Uj(t, i), !i) || !t.has(i)) return !1;
      return !0;
    }
    if (n === Map) {
      if (e.size !== t.size)
        return !1;
      for (r of e)
        if (i = r[0], i && typeof i == "object" && (i = Uj(t, i), !i) || !Am(r[1], t.get(i)))
          return !1;
      return !0;
    }
    if (n === ArrayBuffer)
      e = new Uint8Array(e), t = new Uint8Array(t);
    else if (n === DataView) {
      if ((r = e.byteLength) === t.byteLength)
        for (; r-- && e.getInt8(r) === t.getInt8(r); ) ;
      return r === -1;
    }
    if (ArrayBuffer.isView(e)) {
      if ((r = e.byteLength) === t.byteLength)
        for (; r-- && e[r] === t[r]; ) ;
      return r === -1;
    }
    if (!n || typeof e == "object") {
      r = 0;
      for (n in e)
        if ($j.call(e, n) && ++r && !$j.call(t, n) || !(n in t) || !Am(e[n], t[n])) return !1;
      return Object.keys(t).length === r;
    }
  }
  return e !== e && t !== t;
}
function Tfe(e, t) {
  if (!e) throw typeof t == "string" ? new Error(t) : /* @__PURE__ */ new Error(`${t.displayName} not found`);
}
const rl = (e, t) => {
  const { assertCtxFn: n = Tfe } = {}, r = Ne.createContext(void 0);
  return r.displayName = e, [
    r,
    () => {
      const s = Ne.useContext(r);
      return n(s, `${e} not found`), s.value;
    },
    () => {
      const s = Ne.useContext(r);
      return s ? s.value : {};
    }
  ];
}, [Afe, BU] = rl("ClerkInstanceContext"), [bLe, Mfe] = rl("UserContext");
rl("ClientContext");
rl("SessionContext");
Ne.createContext({});
rl("CheckoutContext");
rl("OrganizationContext");
function $U(e) {
  if (!Ne.useContext(Afe)) {
    if (typeof e == "function") {
      e();
      return;
    }
    throw new Error(`${e} can only be used within the <ClerkProvider /> component.

Possible fixes:
1. Ensure that the <ClerkProvider /> is correctly wrapping your application where this component is used.
2. Check for multiple versions of the \`@clerk/shared\` package in your project. Use a tool like \`npm ls @clerk/shared\` to identify multiple versions, and update your dependencies to only rely on one.

Learn more: https://clerk.com/docs/components/clerk-provider`.trim());
  }
}
typeof window < "u" ? Ne.useLayoutEffect : Ne.useEffect;
const Fj = "useUser";
function UU() {
  $U(Fj);
  const e = Mfe();
  return BU().telemetry?.record(_fe(Fj)), e === void 0 ? {
    isLoaded: !1,
    isSignedIn: void 0,
    user: void 0
  } : e === null ? {
    isLoaded: !0,
    isSignedIn: !1,
    user: null
  } : {
    isLoaded: !0,
    isSignedIn: !0,
    user: e
  };
}
const Vj = Am, Nfe = (e) => {
  const t = C.useRef(e);
  return C.useEffect(() => {
    t.current = e;
  }, [e]), t.current;
}, so = (e, t, n) => {
  const r = !!n, i = C.useRef(n);
  C.useEffect(() => {
    i.current = n;
  }, [n]), C.useEffect(() => {
    if (!r || !e) return () => {
    };
    const o = (...s) => {
      i.current && i.current(...s);
    };
    return e.on(t, o), () => {
      e.off(t, o);
    };
  }, [
    r,
    t,
    e,
    i
  ]);
}, FU = Ne.createContext(null);
FU.displayName = "ElementsContext";
const Rfe = (e, t) => {
  if (!e) throw new Error(`Could not find Elements context; You need to wrap the part of your app that ${t} in an <Elements> provider.`);
  return e;
}, kb = (e) => e !== null && typeof e == "object", Ofe = (e, t, n) => kb(e) ? Object.keys(e).reduce((r, i) => {
  const o = !kb(t) || !VU(e[i], t[i]);
  return n.includes(i) ? (o && console.warn(`Unsupported prop change: options.${i} is not a mutable property.`), r) : o ? {
    ...r || {},
    [i]: e[i]
  } : r;
}, null) : null, Hj = "[object Object]", VU = (e, t) => {
  if (!kb(e) || !kb(t)) return e === t;
  const n = Array.isArray(e);
  if (n !== Array.isArray(t)) return !1;
  const r = Object.prototype.toString.call(e) === Hj;
  if (r !== (Object.prototype.toString.call(t) === Hj)) return !1;
  if (!r && !n) return e === t;
  const i = Object.keys(e), o = Object.keys(t);
  if (i.length !== o.length) return !1;
  const s = {};
  for (let h = 0; h < i.length; h += 1) s[i[h]] = !0;
  for (let h = 0; h < o.length; h += 1) s[o[h]] = !0;
  const a = Object.keys(s);
  if (a.length !== i.length) return !1;
  const c = e, u = t, f = (h) => VU(c[h], u[h]);
  return a.every(f);
}, Wj = (e) => Rfe(Ne.useContext(FU), e), Dfe = (e) => e.charAt(0).toUpperCase() + e.slice(1), Pfe = (e, t) => {
  const n = `${Dfe(e)}Element`, o = t ? (s) => {
    Wj(`mounts <${n}>`);
    const { id: a, className: c } = s;
    return /* @__PURE__ */ Ne.createElement("div", {
      id: a,
      className: c
    });
  } : ({ id: s, className: a, fallback: c, options: u = {}, onBlur: f, onFocus: h, onReady: m, onChange: g, onEscape: b, onClick: x, onLoadError: w, onLoaderStart: S, onNetworksChange: _, onConfirm: M, onCancel: N, onShippingAddressChange: P, onShippingRateChange: I }) => {
    const O = Wj(`mounts <${n}>`), L = "elements" in O ? O.elements : null, [U, B] = Ne.useState(null), G = Ne.useRef(null), Y = Ne.useRef(null), [he, ie] = C.useState(!1);
    so(U, "blur", f), so(U, "focus", h), so(U, "escape", b), so(U, "click", x), so(U, "loaderror", w), so(U, "loaderstart", S), so(U, "networkschange", _), so(U, "confirm", M), so(U, "cancel", N), so(U, "shippingaddresschange", P), so(U, "shippingratechange", I), so(U, "change", g);
    let ne;
    m && (ne = () => {
      ie(!0), m(U);
    }), so(U, "ready", ne), Ne.useLayoutEffect(() => {
      if (G.current === null && Y.current !== null && L) {
        let Q = null;
        L && (Q = L.create(e, u)), G.current = Q, B(Q), Q && Q.mount(Y.current);
      }
    }, [L, u]);
    const H = Nfe(u);
    return Ne.useEffect(() => {
      if (!G.current) return;
      const Q = Ofe(u, H, ["paymentRequest"]);
      Q && "update" in G.current && G.current.update(Q);
    }, [u, H]), Ne.useLayoutEffect(() => () => {
      if (G.current && typeof G.current.destroy == "function") try {
        G.current.destroy(), G.current = null;
      } catch {
      }
    }, []), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, !he && c, /* @__PURE__ */ Ne.createElement("div", {
      id: s,
      style: {
        height: he ? "unset" : "0px",
        visibility: he ? "visible" : "hidden"
      },
      className: a,
      ref: Y
    }));
  };
  return o.displayName = n, o.__elementType = e, o;
};
Pfe("payment", typeof window > "u");
rl("PaymentElementContext");
rl("StripeUtilsContext");
var $u = PU({ packageName: "@clerk/clerk-react" });
function jfe(e) {
  $u.setMessages(e).setPackageName(e);
}
rl("AuthContext");
var Ife = BU, zfe = (e) => `You've passed multiple children components to <${e}/>. You can only pass a single child component or text.`, Qk = "Unsupported usage of isSatellite, domain or proxyUrl. The usage of isSatellite, domain or proxyUrl as function is not supported in non-browser environments.", Lfe = "<UserProfile.Page /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.", Bfe = "<UserProfile.Link /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.", $fe = "<OrganizationProfile.Page /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.", Ufe = "<OrganizationProfile.Link /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.", Ffe = (e) => `<${e} /> can only accept <${e}.Page /> and <${e}.Link /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.`, Vfe = (e) => `Missing props. <${e}.Page /> component requires the following props: url, label, labelIcon, alongside with children to be rendered inside the page.`, Hfe = (e) => `Missing props. <${e}.Link /> component requires the following props: url, label and labelIcon.`, Wfe = "<UserButton /> can only accept <UserButton.UserProfilePage />, <UserButton.UserProfileLink /> and <UserButton.MenuItems /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.", qfe = "<UserButton.MenuItems /> component can only accept <UserButton.Action /> and <UserButton.Link /> as its children. Any other provided component will be ignored. Additionally, please ensure that the component is rendered in a client component.", Gfe = "<UserButton.MenuItems /> component needs to be a direct child of `<UserButton />`.", Kfe = "<UserButton.Action /> component needs to be a direct child of `<UserButton.MenuItems />`.", Zfe = "<UserButton.Link /> component needs to be a direct child of `<UserButton.MenuItems />`.", Yfe = "Missing props. <UserButton.Link /> component requires the following props: href, label and labelIcon.", Xfe = "Missing props. <UserButton.Action /> component requires the following props: label.", Jfe = (e) => {
  $U(() => {
    $u.throwMissingClerkProviderError({ source: e });
  });
}, Dn = (e, t) => {
  const r = (typeof t == "string" ? t : t?.component) || e.displayName || e.name || "Component";
  e.displayName = r;
  const i = typeof t == "string" ? void 0 : t, o = (s) => {
    Jfe(r || "withClerk");
    const a = Ife();
    return !a.loaded && !i?.renderWhileLoading ? null : /* @__PURE__ */ Ne.createElement(
      e,
      {
        ...s,
        component: r,
        clerk: a
      }
    );
  };
  return o.displayName = `withClerk(${r})`, o;
};
const Qfe = () => {
  try {
    return !1;
  } catch {
  }
  return !1;
}, ehe = () => {
  try {
    return !1;
  } catch {
  }
  return !1;
}, the = () => {
  try {
    return !0;
  } catch {
  }
  return !1;
}, qj = /* @__PURE__ */ new Set(), kM = (e, t, n) => {
  const r = ehe() || the(), i = e;
  qj.has(i) || r || (qj.add(i), console.warn(`Clerk - DEPRECATION WARNING: "${e}" is deprecated and will be removed in the next major release.
${t}`));
};
Dn(({ clerk: e, ...t }) => {
  const { client: n, session: r } = e, i = n.signedInSessions ? n.signedInSessions.length > 0 : (
    // Compat for clerk-js<5.54.0 (which was released with the `signedInSessions` property)
    n.activeSessions && n.activeSessions.length > 0
  );
  return Ne.useEffect(() => {
    r === null && i ? e.redirectToAfterSignOut() : e.redirectToSignIn(t);
  }, []), null;
}, "RedirectToSignIn");
Dn(({ clerk: e, ...t }) => (Ne.useEffect(() => {
  e.redirectToSignUp(t);
}, []), null), "RedirectToSignUp");
Dn(({ clerk: e, ...t }) => (Ne.useEffect(() => {
  e.redirectToTasks(t);
}, []), null), "RedirectToTasks");
Dn(({ clerk: e }) => (Ne.useEffect(() => {
  kM("RedirectToUserProfile", "Use the `redirectToUserProfile()` method instead."), e.redirectToUserProfile();
}, []), null), "RedirectToUserProfile");
Dn(({ clerk: e }) => (Ne.useEffect(() => {
  kM("RedirectToOrganizationProfile", "Use the `redirectToOrganizationProfile()` method instead."), e.redirectToOrganizationProfile();
}, []), null), "RedirectToOrganizationProfile");
Dn(({ clerk: e }) => (Ne.useEffect(() => {
  kM("RedirectToCreateOrganization", "Use the `redirectToCreateOrganization()` method instead."), e.redirectToCreateOrganization();
}, []), null), "RedirectToCreateOrganization");
Dn(
  ({ clerk: e, ...t }) => (Ne.useEffect(() => {
    e.handleRedirectCallback(t);
  }, []), null),
  "AuthenticateWithRedirectCallback"
);
function eC(e, t, n) {
  if (typeof e == "function") return e(t);
  if (typeof e < "u") return e;
  if (typeof n < "u") return n;
}
const Ti = (e) => {
  Qfe() && console.error(`Clerk: ${e}`);
}, Gj = (e, ...t) => {
  const n = { ...e };
  for (const r of t) delete n[r];
  return n;
};
var xw = (e) => (t) => {
  try {
    return Ne.Children.only(e);
  } catch {
    return $u.throw(zfe(t));
  }
}, ww = (e, t) => (e || (e = t), typeof e == "string" && (e = /* @__PURE__ */ Ne.createElement("button", null, e)), e), Sw = (e) => (...t) => {
  if (e && typeof e == "function")
    return e(...t);
};
function nhe(e) {
  return typeof e == "function";
}
var Mm = (e) => {
  const [t, n] = C.useState(/* @__PURE__ */ new Map());
  return e.map((r) => ({
    id: r.id,
    mount: (i) => n((o) => new Map(o).set(String(r.id), i)),
    unmount: () => n((i) => {
      const o = new Map(i);
      return o.set(String(r.id), null), o;
    }),
    portal: () => {
      const i = t.get(String(r.id));
      return i ? tl.createPortal(r.component, i) : null;
    }
  }));
}, _i = (e, t) => !!e && Ne.isValidElement(e) && e?.type === t, HU = (e, t) => GU(
  {
    children: e,
    reorderItemsLabels: ["account", "security", "billing", "apiKeys"],
    LinkComponent: Qg,
    PageComponent: Jg,
    MenuItemsComponent: Cw,
    componentName: "UserProfile"
  },
  t
), WU = (e, t) => GU(
  {
    children: e,
    reorderItemsLabels: ["general", "members", "billing", "apiKeys"],
    LinkComponent: _w,
    PageComponent: Ew,
    componentName: "OrganizationProfile"
  },
  t
), qU = (e) => {
  const t = [], n = [
    _w,
    Ew,
    Cw,
    Jg,
    Qg
  ];
  return Ne.Children.forEach(e, (r) => {
    n.some((i) => _i(r, i)) || t.push(r);
  }), t;
}, GU = (e, t) => {
  const { children: n, LinkComponent: r, PageComponent: i, MenuItemsComponent: o, reorderItemsLabels: s, componentName: a } = e, { allowForAnyChildren: c = !1 } = t || {}, u = [];
  Ne.Children.forEach(n, (_) => {
    if (!_i(_, i) && !_i(_, r) && !_i(_, o)) {
      _ && !c && Ti(Ffe(a));
      return;
    }
    const { props: M } = _, { children: N, label: P, url: I, labelIcon: O } = M;
    if (_i(_, i))
      if (Kj(M, s))
        u.push({ label: P });
      else if (tC(M))
        u.push({ label: P, labelIcon: O, children: N, url: I });
      else {
        Ti(Vfe(a));
        return;
      }
    if (_i(_, r))
      if (nC(M))
        u.push({ label: P, labelIcon: O, url: I });
      else {
        Ti(Hfe(a));
        return;
      }
  });
  const f = [], h = [], m = [];
  u.forEach((_, M) => {
    if (tC(_)) {
      f.push({ component: _.children, id: M }), h.push({ component: _.labelIcon, id: M });
      return;
    }
    nC(_) && m.push({ component: _.labelIcon, id: M });
  });
  const g = Mm(f), b = Mm(h), x = Mm(m), w = [], S = [];
  return u.forEach((_, M) => {
    if (Kj(_, s)) {
      w.push({ label: _.label });
      return;
    }
    if (tC(_)) {
      const {
        portal: N,
        mount: P,
        unmount: I
      } = g.find((B) => B.id === M), {
        portal: O,
        mount: L,
        unmount: U
      } = b.find((B) => B.id === M);
      w.push({ label: _.label, url: _.url, mount: P, unmount: I, mountIcon: L, unmountIcon: U }), S.push(N), S.push(O);
      return;
    }
    if (nC(_)) {
      const {
        portal: N,
        mount: P,
        unmount: I
      } = x.find((O) => O.id === M);
      w.push({ label: _.label, url: _.url, mountIcon: P, unmountIcon: I }), S.push(N);
      return;
    }
  }), { customPages: w, customPagesPortals: S };
}, Kj = (e, t) => {
  const { children: n, label: r, url: i, labelIcon: o } = e;
  return !n && !i && !o && t.some((s) => s === r);
}, tC = (e) => {
  const { children: t, label: n, url: r, labelIcon: i } = e;
  return !!t && !!r && !!i && !!n;
}, nC = (e) => {
  const { children: t, label: n, url: r, labelIcon: i } = e;
  return !t && !!r && !!i && !!n;
}, rhe = (e, t) => {
  var n;
  return ihe({
    children: e,
    reorderItemsLabels: ["manageAccount", "signOut"],
    MenuItemsComponent: Cw,
    MenuActionComponent: ZU,
    MenuLinkComponent: YU,
    UserProfileLinkComponent: Qg,
    UserProfilePageComponent: Jg,
    allowForAnyChildren: (n = t?.allowForAnyChildren) != null ? n : !1
  });
}, ihe = ({
  children: e,
  MenuItemsComponent: t,
  MenuActionComponent: n,
  MenuLinkComponent: r,
  UserProfileLinkComponent: i,
  UserProfilePageComponent: o,
  reorderItemsLabels: s,
  allowForAnyChildren: a = !1
}) => {
  const c = [], u = [], f = [];
  Ne.Children.forEach(e, (x) => {
    if (!_i(x, t) && !_i(x, i) && !_i(x, o)) {
      x && !a && Ti(Wfe);
      return;
    }
    if (_i(x, i) || _i(x, o))
      return;
    const { props: w } = x;
    Ne.Children.forEach(w.children, (S) => {
      if (!_i(S, n) && !_i(S, r)) {
        S && Ti(qfe);
        return;
      }
      const { props: _ } = S, { label: M, labelIcon: N, href: P, onClick: I, open: O } = _;
      if (_i(S, n))
        if (Zj(_, s))
          c.push({ label: M });
        else if (rC(_)) {
          const L = {
            label: M,
            labelIcon: N
          };
          if (I !== void 0)
            c.push({
              ...L,
              onClick: I
            });
          else if (O !== void 0)
            c.push({
              ...L,
              open: O.startsWith("/") ? O : `/${O}`
            });
          else {
            Ti("Custom menu item must have either onClick or open property");
            return;
          }
        } else {
          Ti(Xfe);
          return;
        }
      if (_i(S, r))
        if (iC(_))
          c.push({ label: M, labelIcon: N, href: P });
        else {
          Ti(Yfe);
          return;
        }
    });
  });
  const h = [], m = [];
  c.forEach((x, w) => {
    rC(x) && h.push({ component: x.labelIcon, id: w }), iC(x) && m.push({ component: x.labelIcon, id: w });
  });
  const g = Mm(h), b = Mm(m);
  return c.forEach((x, w) => {
    if (Zj(x, s) && u.push({
      label: x.label
    }), rC(x)) {
      const {
        portal: S,
        mount: _,
        unmount: M
      } = g.find((P) => P.id === w), N = {
        label: x.label,
        mountIcon: _,
        unmountIcon: M
      };
      "onClick" in x ? N.onClick = x.onClick : "open" in x && (N.open = x.open), u.push(N), f.push(S);
    }
    if (iC(x)) {
      const {
        portal: S,
        mount: _,
        unmount: M
      } = b.find((N) => N.id === w);
      u.push({
        label: x.label,
        href: x.href,
        mountIcon: _,
        unmountIcon: M
      }), f.push(S);
    }
  }), { customMenuItems: u, customMenuItemsPortals: f };
}, Zj = (e, t) => {
  const { children: n, label: r, onClick: i, labelIcon: o } = e;
  return !n && !i && !o && t.some((s) => s === r);
}, rC = (e) => {
  const { label: t, labelIcon: n, onClick: r, open: i } = e;
  return !!n && !!t && (typeof r == "function" || typeof i == "string");
}, iC = (e) => {
  const { label: t, href: n, labelIcon: r } = e;
  return !!n && !!r && !!t;
}, ohe = (e) => {
  const t = e?.isReady;
  return (n) => new Promise((r, i) => {
    const { root: o = document?.body, selector: s, timeout: a = 0 } = n;
    if (!o) {
      i(new Error("No root element provided"));
      return;
    }
    let c = o;
    if (s && (c = o?.querySelector(s)), t(c, s)) {
      r();
      return;
    }
    const u = new MutationObserver((f) => {
      for (const h of f)
        if (!c && s && (c = o?.querySelector(s)), (e.childList && h.type === "childList" || e.attributes && h.type === "attributes") && t(c, s)) {
          u.disconnect(), r();
          return;
        }
    });
    u.observe(o, e), a > 0 && setTimeout(() => {
      u.disconnect(), i(new Error(`Timeout waiting for ${s}`));
    }, a);
  });
}, she = ohe({
  childList: !0,
  subtree: !0,
  isReady: (e, t) => {
    var n;
    return !!e?.childElementCount && ((n = e?.matches) == null ? void 0 : n.call(e, t)) && e.childElementCount > 0;
  }
});
function Pi(e, t) {
  const n = C.useRef(), [r, i] = C.useState("rendering");
  return C.useEffect(() => {
    if (!e)
      throw new Error("Clerk: no component name provided, unable to detect mount.");
    if (typeof window < "u" && !n.current) {
      const o = `[data-clerk-component="${e}"]`, s = t?.selector;
      n.current = she({
        selector: s ? (
          // Allows for `[data-clerk-component="xxxx"][data-some-attribute="123"] .my-class`
          o + s
        ) : o
      }).then(() => {
        i("rendered");
      }).catch(() => {
        i("error");
      });
    }
  }, [e, t?.selector]), r;
}
var Lv = (e) => "mount" in e, Yj = (e) => "open" in e, Xj = (e) => e?.map(({ mountIcon: t, unmountIcon: n, ...r }) => r), oi = class extends Ne.PureComponent {
  constructor() {
    super(...arguments), this.rootRef = Ne.createRef();
  }
  componentDidUpdate(e) {
    var t, n, r, i;
    if (!Lv(e) || !Lv(this.props))
      return;
    const o = Gj(e.props, "customPages", "customMenuItems", "children"), s = Gj(this.props.props, "customPages", "customMenuItems", "children"), a = ((t = o.customPages) == null ? void 0 : t.length) !== ((n = s.customPages) == null ? void 0 : n.length), c = ((r = o.customMenuItems) == null ? void 0 : r.length) !== ((i = s.customMenuItems) == null ? void 0 : i.length), u = Xj(e.props.customMenuItems), f = Xj(this.props.props.customMenuItems);
    (!Vj(o, s) || !Vj(u, f) || a || c) && this.rootRef.current && this.props.updateProps({ node: this.rootRef.current, props: this.props.props });
  }
  componentDidMount() {
    this.rootRef.current && (Lv(this.props) && this.props.mount(this.rootRef.current, this.props.props), Yj(this.props) && this.props.open(this.props.props));
  }
  componentWillUnmount() {
    this.rootRef.current && (Lv(this.props) && this.props.unmount(this.rootRef.current), Yj(this.props) && this.props.close());
  }
  render() {
    const { hideRootHtmlElement: e = !1 } = this.props, t = {
      ref: this.rootRef,
      ...this.props.rootProps,
      ...this.props.component && { "data-clerk-component": this.props.component }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, !e && /* @__PURE__ */ Ne.createElement("div", { ...t }), this.props.children);
  }
}, kw = (e) => {
  var t, n;
  return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, (t = e?.customPagesPortals) == null ? void 0 : t.map((r, i) => C.createElement(r, { key: i })), (n = e?.customMenuItemsPortals) == null ? void 0 : n.map((r, i) => C.createElement(r, { key: i })));
};
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountSignIn,
        unmount: e.unmountSignIn,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "SignIn", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountSignUp,
        unmount: e.unmountSignUp,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "SignUp", renderWhileLoading: !0 }
);
function Jg({ children: e }) {
  return Ti(Lfe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function Qg({ children: e }) {
  return Ti(Bfe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
var ahe = Dn(
  ({
    clerk: e,
    component: t,
    fallback: n,
    ...r
  }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    }, { customPages: a, customPagesPortals: c } = HU(r.children);
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountUserProfile,
        unmount: e.unmountUserProfile,
        updateProps: e.__unstable__updateProps,
        props: { ...r, customPages: a },
        rootProps: s
      },
      /* @__PURE__ */ Ne.createElement(kw, { customPagesPortals: c })
    ));
  },
  { component: "UserProfile", renderWhileLoading: !0 }
);
Object.assign(ahe, {
  Page: Jg,
  Link: Qg
});
var KU = C.createContext({
  mount: () => {
  },
  unmount: () => {
  },
  updateProps: () => {
  }
}), lhe = Dn(
  ({
    clerk: e,
    component: t,
    fallback: n,
    ...r
  }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    }, { customPages: a, customPagesPortals: c } = HU(r.children, {
      allowForAnyChildren: !!r.__experimental_asProvider
    }), u = { ...r.userProfileProps, customPages: a }, { customMenuItems: f, customMenuItemsPortals: h } = rhe(r.children, {
      allowForAnyChildren: !!r.__experimental_asProvider
    }), m = qU(r.children), g = {
      mount: e.mountUserButton,
      unmount: e.unmountUserButton,
      updateProps: e.__unstable__updateProps,
      props: { ...r, userProfileProps: u, customMenuItems: f }
    }, b = {
      customPagesPortals: c,
      customMenuItemsPortals: h
    };
    return /* @__PURE__ */ Ne.createElement(KU.Provider, { value: g }, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        ...g,
        hideRootHtmlElement: !!r.__experimental_asProvider,
        rootProps: s
      },
      r.__experimental_asProvider ? m : null,
      /* @__PURE__ */ Ne.createElement(kw, { ...b })
    ));
  },
  { component: "UserButton", renderWhileLoading: !0 }
);
function Cw({ children: e }) {
  return Ti(Gfe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function ZU({ children: e }) {
  return Ti(Kfe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function YU({ children: e }) {
  return Ti(Zfe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function che(e) {
  const t = C.useContext(KU), n = {
    ...t,
    props: {
      ...t.props,
      ...e
    }
  };
  return /* @__PURE__ */ Ne.createElement(oi, { ...n });
}
Object.assign(lhe, {
  UserProfilePage: Jg,
  UserProfileLink: Qg,
  MenuItems: Cw,
  Action: ZU,
  Link: YU,
  __experimental_Outlet: che
});
function Ew({ children: e }) {
  return Ti($fe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
function _w({ children: e }) {
  return Ti(Ufe), /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, e);
}
var uhe = Dn(
  ({
    clerk: e,
    component: t,
    fallback: n,
    ...r
  }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    }, { customPages: a, customPagesPortals: c } = WU(r.children);
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountOrganizationProfile,
        unmount: e.unmountOrganizationProfile,
        updateProps: e.__unstable__updateProps,
        props: { ...r, customPages: a },
        rootProps: s
      },
      /* @__PURE__ */ Ne.createElement(kw, { customPagesPortals: c })
    ));
  },
  { component: "OrganizationProfile", renderWhileLoading: !0 }
);
Object.assign(uhe, {
  Page: Ew,
  Link: _w
});
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountCreateOrganization,
        unmount: e.unmountCreateOrganization,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "CreateOrganization", renderWhileLoading: !0 }
);
var XU = C.createContext({
  mount: () => {
  },
  unmount: () => {
  },
  updateProps: () => {
  }
}), dhe = Dn(
  ({
    clerk: e,
    component: t,
    fallback: n,
    ...r
  }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    }, { customPages: a, customPagesPortals: c } = WU(r.children, {
      allowForAnyChildren: !!r.__experimental_asProvider
    }), u = { ...r.organizationProfileProps, customPages: a }, f = qU(r.children), h = {
      mount: e.mountOrganizationSwitcher,
      unmount: e.unmountOrganizationSwitcher,
      updateProps: e.__unstable__updateProps,
      props: { ...r, organizationProfileProps: u },
      rootProps: s,
      component: t
    };
    return e.__experimental_prefetchOrganizationSwitcher(), /* @__PURE__ */ Ne.createElement(XU.Provider, { value: h }, /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        ...h,
        hideRootHtmlElement: !!r.__experimental_asProvider
      },
      r.__experimental_asProvider ? f : null,
      /* @__PURE__ */ Ne.createElement(kw, { customPagesPortals: c })
    )));
  },
  { component: "OrganizationSwitcher", renderWhileLoading: !0 }
);
function fhe(e) {
  const t = C.useContext(XU), n = {
    ...t,
    props: {
      ...t.props,
      ...e
    }
  };
  return /* @__PURE__ */ Ne.createElement(oi, { ...n });
}
Object.assign(dhe, {
  OrganizationProfilePage: Ew,
  OrganizationProfileLink: _w,
  __experimental_Outlet: fhe
});
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountOrganizationList,
        unmount: e.unmountOrganizationList,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "OrganizationList", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        open: e.openGoogleOneTap,
        close: e.closeGoogleOneTap,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "GoogleOneTap", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountWaitlist,
        unmount: e.unmountWaitlist,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "Waitlist", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t, {
      // This attribute is added to the PricingTable root element after we've successfully fetched the plans asynchronously.
      selector: '[data-component-status="ready"]'
    }) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountPricingTable,
        unmount: e.unmountPricingTable,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "PricingTable", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountAPIKeys,
        unmount: e.unmountAPIKeys,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "ApiKeys", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountUserAvatar,
        unmount: e.unmountUserAvatar,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "UserAvatar", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountTaskChooseOrganization,
        unmount: e.unmountTaskChooseOrganization,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "TaskChooseOrganization", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, component: t, fallback: n, ...r }) => {
    const o = Pi(t) === "rendering" || !e.loaded, s = {
      ...o && n && { style: { display: "none" } }
    };
    return /* @__PURE__ */ Ne.createElement(Ne.Fragment, null, o && n, e.loaded && /* @__PURE__ */ Ne.createElement(
      oi,
      {
        component: t,
        mount: e.mountTaskResetPassword,
        unmount: e.unmountTaskResetPassword,
        updateProps: e.__unstable__updateProps,
        props: r,
        rootProps: s
      }
    ));
  },
  { component: "TaskResetPassword", renderWhileLoading: !0 }
);
var JU = (e) => {
  throw TypeError(e);
}, CM = (e, t, n) => t.has(e) || JU("Cannot " + n), $n = (e, t, n) => (CM(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Zl = (e, t, n) => t.has(e) ? JU("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), ku = (e, t, n, r) => (CM(e, t, "write to private field"), t.set(e, n), n), oC = (e, t, n) => (CM(e, t, "access private method"), n);
const hhe = {
  initialDelay: 125,
  maxDelayBetweenRetries: 0,
  factor: 2,
  shouldRetry: (e, t) => t < 5,
  retryImmediately: !1,
  jitter: !0
}, phe = 100, QU = async (e) => new Promise((t) => setTimeout(t, e)), e8 = (e, t) => t ? e * (1 + Math.random()) : e, mhe = (e) => {
  let t = 0;
  const n = () => {
    const r = e.initialDelay, i = e.factor;
    let o = r * Math.pow(i, t);
    return o = e8(o, e.jitter), Math.min(e.maxDelayBetweenRetries || o, o);
  };
  return async () => {
    await QU(n()), t++;
  };
}, ghe = async (e, t = {}) => {
  let n = 0;
  const { shouldRetry: r, initialDelay: i, maxDelayBetweenRetries: o, factor: s, retryImmediately: a, jitter: c, onBeforeRetry: u } = {
    ...hhe,
    ...t
  }, f = mhe({
    initialDelay: i,
    maxDelayBetweenRetries: o,
    factor: s,
    jitter: c
  });
  for (; ; ) try {
    return await e();
  } catch (h) {
    if (n++, !r(h, n)) throw h;
    u && await u(n), a && n === 1 ? await QU(e8(phe, c)) : await f();
  }
}, yhe = "loadScript cannot be called when document does not exist", vhe = "loadScript cannot be called without a src";
async function bhe(e = "", t) {
  const { async: n, defer: r, beforeLoad: i, crossOrigin: o, nonce: s } = t || {};
  return ghe(() => new Promise((c, u) => {
    e || u(new Error(vhe)), (!document || !document.body) && u(new Error(yhe));
    const f = document.createElement("script");
    o && f.setAttribute("crossorigin", o), f.async = n || !1, f.defer = r || !1, f.addEventListener("load", () => {
      f.remove(), c(f);
    }), f.addEventListener("error", (h) => {
      f.remove(), u(h.error ?? /* @__PURE__ */ new Error(`failed to load script: ${e}`));
    }), f.src = e, f.nonce = s, i?.(f), document.body.appendChild(f);
  }), { shouldRetry: (c, u) => u <= 5 });
}
function xhe(e) {
  return e ? whe(e) || t8(e) : !0;
}
function whe(e) {
  return /^http(s)?:\/\//.test(e || "");
}
function t8(e) {
  return e.startsWith("/");
}
function She(e) {
  return e ? t8(e) ? new URL(e, window.location.origin).toString() : e : "";
}
function khe(e) {
  if (!e) return "";
  let t;
  if (e.match(/^(clerk\.)+\w*$/)) t = /(clerk\.)*(?=clerk\.)/;
  else {
    if (e.match(/\.clerk.accounts/)) return e;
    t = /^(clerk\.)*/gi;
  }
  return `clerk.${e.replace(t, "")}`;
}
const Che = (e, t = "5.122.0") => {
  if (e) return e;
  const n = Ehe(t);
  return n ? n === "snapshot" ? "5.122.0" : n : _he(t);
}, Ehe = (e) => e.trim().replace(/^v/, "").match(/-(.+?)(\.|$)/)?.[1], _he = (e) => e.trim().replace(/^v/, "").split(".")[0], n8 = "failed_to_load_clerk_js", The = "failed_to_load_clerk_js_timeout", T_ = "Failed to load Clerk", { isDevOrStagingUrl: Ahe } = kfe(), r8 = PU({ packageName: "@clerk/shared" });
function Mhe(e) {
  r8.setPackageName({ packageName: e });
}
function A_() {
  if (typeof window > "u" || !window.Clerk) return !1;
  const e = window.Clerk;
  return typeof e == "object" && typeof e.load == "function";
}
function Nhe(e) {
  if (typeof window > "u" || !window.performance) return !1;
  const t = performance.getEntriesByName(e, "resource");
  if (t.length === 0) return !1;
  const n = t[t.length - 1];
  return n.transferSize === 0 && n.decodedBodySize === 0 && (n.responseEnd === 0 || n.responseEnd > 0 && n.responseStart > 0 || "responseStatus" in n && (n.responseStatus >= 400 || n.responseStatus === 0));
}
function Jj(e, t) {
  return new Promise((n, r) => {
    let i = !1;
    const o = (f, h) => {
      clearTimeout(f), clearInterval(h);
    };
    t?.addEventListener("error", () => {
      o(c, u), r(new __(T_, { code: n8 }));
    });
    const s = () => {
      i || A_() && (i = !0, o(c, u), n(null));
    }, c = setTimeout(() => {
      i || (i = !0, o(c, u), A_() ? n(null) : r(new __(T_, { code: The })));
    }, e);
    s();
    const u = setInterval(() => {
      if (i) {
        clearInterval(u);
        return;
      }
      s();
    }, 100);
  });
}
const Rhe = async (e) => {
  const t = e?.scriptLoadTimeout ?? 15e3;
  if (A_()) return null;
  if (!e?.publishableKey)
    return r8.throwMissingPublishableKeyError(), null;
  const n = Ohe(e), r = document.querySelector("script[data-clerk-js-script]");
  if (r) if (Nhe(n)) r.remove();
  else try {
    return await Jj(t, r), null;
  } catch {
    r.remove();
  }
  const i = Jj(t);
  return bhe(n, {
    async: !0,
    crossOrigin: "anonymous",
    nonce: e.nonce,
    beforeLoad: Phe(e)
  }).catch((o) => {
    throw new __(T_ + (o.message ? `, ${o.message}` : ""), {
      code: n8,
      cause: o
    });
  }), i;
}, Ohe = (e) => {
  const { clerkJSUrl: t, clerkJSVariant: n, clerkJSVersion: r, proxyUrl: i, domain: o, publishableKey: s } = e;
  if (t) return t;
  let a = "";
  i && xhe(i) ? a = She(i).replace(/http(s)?:\/\//, "") : o && !Ahe(Lj(s)?.frontendApi || "") ? a = khe(o) : a = Lj(s)?.frontendApi || "";
  const c = n ? `${n.replace(/\.+$/, "")}.` : "", u = Che(r);
  return `https://${a}/npm/@clerk/clerk-js@${u}/dist/clerk.${c}browser.js`;
}, Dhe = (e) => {
  const t = {};
  return e.publishableKey && (t["data-clerk-publishable-key"] = e.publishableKey), e.proxyUrl && (t["data-clerk-proxy-url"] = e.proxyUrl), e.domain && (t["data-clerk-domain"] = e.domain), e.nonce && (t.nonce = e.nonce), t;
}, Phe = (e) => (t) => {
  const n = Dhe(e);
  for (const r in n) t.setAttribute(r, n[r]);
};
function Cb() {
  return typeof window < "u";
}
const Qj = (e, t, n, r, i) => {
  const { notify: o } = i || {};
  let s = e.get(n);
  s || (s = [], e.set(n, s)), s.push(r), o && t.has(n) && r(t.get(n));
}, eI = (e, t, n) => (e.get(t) || []).map((r) => r(n)), tI = (e, t, n) => {
  const r = e.get(t);
  r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : e.set(t, []));
}, jhe = () => {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    on: (...i) => Qj(e, t, ...i),
    prioritizedOn: (...i) => Qj(n, t, ...i),
    emit: (i, o) => {
      t.set(i, o), eI(n, i, o), eI(e, i, o);
    },
    off: (...i) => tI(e, ...i),
    prioritizedOff: (...i) => tI(n, ...i),
    internal: { retrieveListeners: (i) => e.get(i) || [] }
  };
}, Bv = { Status: "status" }, Ihe = () => jhe();
typeof window < "u" && !window.global && (window.global = typeof global > "u" ? window : global);
Dn(
  ({ clerk: e, children: t, ...n }) => {
    const {
      // @ts-expect-error - appearance is a valid prop for SignInProps & SignInButtonPropsModal
      appearance: r,
      signUpFallbackRedirectUrl: i,
      forceRedirectUrl: o,
      fallbackRedirectUrl: s,
      signUpForceRedirectUrl: a,
      mode: c,
      initialValues: u,
      withSignUp: f,
      oauthFlow: h,
      ...m
    } = n;
    t = ww(t, "Sign in");
    const g = xw(t)("SignInButton"), b = () => {
      const S = {
        forceRedirectUrl: o,
        fallbackRedirectUrl: s,
        signUpFallbackRedirectUrl: i,
        signUpForceRedirectUrl: a,
        initialValues: u,
        withSignUp: f,
        oauthFlow: h
      };
      return c === "modal" ? e.openSignIn({ ...S, appearance: r }) : e.redirectToSignIn({
        ...S,
        signInFallbackRedirectUrl: s,
        signInForceRedirectUrl: o
      });
    }, w = { ...m, onClick: async (S) => (g && typeof g == "object" && "props" in g && await Sw(g.props.onClick)(S), b()) };
    return Ne.cloneElement(g, w);
  },
  { component: "SignInButton", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, children: t, ...n }) => {
    const { redirectUrl: r, ...i } = n;
    t = ww(t, "Sign in with Metamask");
    const o = xw(t)("SignInWithMetamaskButton"), s = async () => {
      async function u() {
        await e.authenticateWithMetamask({ redirectUrl: r || void 0 });
      }
      u();
    }, c = { ...i, onClick: async (u) => (await Sw(o.props.onClick)(u), s()) };
    return Ne.cloneElement(o, c);
  },
  { component: "SignInWithMetamask", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, children: t, ...n }) => {
    const { redirectUrl: r = "/", signOutOptions: i, ...o } = n;
    t = ww(t, "Sign out");
    const s = xw(t)("SignOutButton"), a = () => e.signOut({ redirectUrl: r, ...i }), u = { ...o, onClick: async (f) => (await Sw(s.props.onClick)(f), a()) };
    return Ne.cloneElement(s, u);
  },
  { component: "SignOutButton", renderWhileLoading: !0 }
);
Dn(
  ({ clerk: e, children: t, ...n }) => {
    const {
      // @ts-expect-error - appearance is a valid prop for SignUpProps & SignUpButtonPropsModal
      appearance: r,
      // @ts-expect-error - unsafeMetadata is a valid prop for SignUpProps & SignUpButtonPropsModal
      unsafeMetadata: i,
      fallbackRedirectUrl: o,
      forceRedirectUrl: s,
      signInFallbackRedirectUrl: a,
      signInForceRedirectUrl: c,
      mode: u,
      initialValues: f,
      oauthFlow: h,
      ...m
    } = n;
    t = ww(t, "Sign up");
    const g = xw(t)("SignUpButton"), b = () => {
      const S = {
        fallbackRedirectUrl: o,
        forceRedirectUrl: s,
        signInFallbackRedirectUrl: a,
        signInForceRedirectUrl: c,
        initialValues: f,
        oauthFlow: h
      };
      return u === "modal" ? e.openSignUp({
        ...S,
        appearance: r,
        unsafeMetadata: i
      }) : e.redirectToSignUp({
        ...S,
        signUpFallbackRedirectUrl: o,
        signUpForceRedirectUrl: s
      });
    }, w = { ...m, onClick: async (S) => (g && typeof g == "object" && "props" in g && await Sw(g.props.onClick)(S), b()) };
    return Ne.cloneElement(g, w);
  },
  { component: "SignUpButton", renderWhileLoading: !0 }
);
var zhe = () => ({
  fields: {
    identifier: null,
    password: null,
    code: null
  },
  raw: null,
  global: null
}), Lhe = () => ({
  fields: {
    firstName: null,
    lastName: null,
    emailAddress: null,
    phoneNumber: null,
    password: null,
    username: null,
    code: null,
    captcha: null,
    legalAccepted: null
  },
  raw: null,
  global: null
}), Bhe = class {
  constructor(e) {
    this.isomorphicClerk = e, this.signInSignalProxy = this.buildSignInProxy(), this.signUpSignalProxy = this.buildSignUpProxy();
  }
  signInSignal() {
    return this.signInSignalProxy;
  }
  signUpSignal() {
    return this.signUpSignalProxy;
  }
  buildSignInProxy() {
    const e = this.gateProperty.bind(this), t = () => this.client.signIn.__internal_future;
    return {
      errors: zhe(),
      fetchStatus: "idle",
      signIn: {
        status: "needs_identifier",
        availableStrategies: [],
        isTransferable: !1,
        get id() {
          return e(t, "id", void 0);
        },
        get supportedFirstFactors() {
          return e(t, "supportedFirstFactors", []);
        },
        get supportedSecondFactors() {
          return e(t, "supportedSecondFactors", []);
        },
        get secondFactorVerification() {
          return e(t, "secondFactorVerification", {
            status: null,
            error: null,
            expireAt: null,
            externalVerificationRedirectURL: null,
            nonce: null,
            attempts: null,
            message: null,
            strategy: null,
            verifiedAtClient: null,
            verifiedFromTheSameClient: () => !1,
            __internal_toSnapshot: () => {
              throw new Error("__internal_toSnapshot called before Clerk is loaded");
            },
            pathRoot: "",
            reload: () => {
              throw new Error("__internal_toSnapshot called before Clerk is loaded");
            }
          });
        },
        get identifier() {
          return e(t, "identifier", null);
        },
        get createdSessionId() {
          return e(t, "createdSessionId", null);
        },
        get userData() {
          return e(t, "userData", {});
        },
        get firstFactorVerification() {
          return e(t, "firstFactorVerification", {
            status: null,
            error: null,
            expireAt: null,
            externalVerificationRedirectURL: null,
            nonce: null,
            attempts: null,
            message: null,
            strategy: null,
            verifiedAtClient: null,
            verifiedFromTheSameClient: () => !1,
            __internal_toSnapshot: () => {
              throw new Error("__internal_toSnapshot called before Clerk is loaded");
            },
            pathRoot: "",
            reload: () => {
              throw new Error("__internal_toSnapshot called before Clerk is loaded");
            }
          });
        },
        create: this.gateMethod(t, "create"),
        password: this.gateMethod(t, "password"),
        sso: this.gateMethod(t, "sso"),
        finalize: this.gateMethod(t, "finalize"),
        emailCode: this.wrapMethods(() => t().emailCode, ["sendCode", "verifyCode"]),
        emailLink: this.wrapStruct(
          () => t().emailLink,
          ["sendLink", "waitForVerification"],
          ["verification"],
          { verification: null }
        ),
        resetPasswordEmailCode: this.wrapMethods(() => t().resetPasswordEmailCode, [
          "sendCode",
          "verifyCode",
          "submitPassword"
        ]),
        phoneCode: this.wrapMethods(() => t().phoneCode, ["sendCode", "verifyCode"]),
        mfa: this.wrapMethods(() => t().mfa, [
          "sendPhoneCode",
          "verifyPhoneCode",
          "verifyTOTP",
          "verifyBackupCode"
        ]),
        ticket: this.gateMethod(t, "ticket"),
        passkey: this.gateMethod(t, "passkey"),
        web3: this.gateMethod(t, "web3")
      }
    };
  }
  buildSignUpProxy() {
    const e = this.gateProperty.bind(this), t = this.gateMethod.bind(this), n = this.wrapMethods.bind(this), r = () => this.client.signUp.__internal_future;
    return {
      errors: Lhe(),
      fetchStatus: "idle",
      signUp: {
        get id() {
          return e(r, "id", void 0);
        },
        get requiredFields() {
          return e(r, "requiredFields", []);
        },
        get optionalFields() {
          return e(r, "optionalFields", []);
        },
        get missingFields() {
          return e(r, "missingFields", []);
        },
        get username() {
          return e(r, "username", null);
        },
        get firstName() {
          return e(r, "firstName", null);
        },
        get lastName() {
          return e(r, "lastName", null);
        },
        get emailAddress() {
          return e(r, "emailAddress", null);
        },
        get phoneNumber() {
          return e(r, "phoneNumber", null);
        },
        get web3Wallet() {
          return e(r, "web3Wallet", null);
        },
        get hasPassword() {
          return e(r, "hasPassword", !1);
        },
        get unsafeMetadata() {
          return e(r, "unsafeMetadata", {});
        },
        get createdSessionId() {
          return e(r, "createdSessionId", null);
        },
        get createdUserId() {
          return e(r, "createdUserId", null);
        },
        get abandonAt() {
          return e(r, "abandonAt", null);
        },
        get legalAcceptedAt() {
          return e(r, "legalAcceptedAt", null);
        },
        get locale() {
          return e(r, "locale", null);
        },
        get status() {
          return e(r, "status", "missing_requirements");
        },
        get unverifiedFields() {
          return e(r, "unverifiedFields", []);
        },
        get isTransferable() {
          return e(r, "isTransferable", !1);
        },
        create: t(r, "create"),
        update: t(r, "update"),
        sso: t(r, "sso"),
        password: t(r, "password"),
        ticket: t(r, "ticket"),
        web3: t(r, "web3"),
        finalize: t(r, "finalize"),
        verifications: n(() => r().verifications, [
          "sendEmailCode",
          "verifyEmailCode",
          "sendPhoneCode",
          "verifyPhoneCode"
        ])
      }
    };
  }
  __internal_effect(e) {
    throw new Error("__internal_effect called before Clerk is loaded");
  }
  __internal_computed(e) {
    throw new Error("__internal_computed called before Clerk is loaded");
  }
  get client() {
    const e = this.isomorphicClerk.client;
    if (!e)
      throw new Error("Clerk client not ready");
    return e;
  }
  gateProperty(e, t, n) {
    return !Cb() || !this.isomorphicClerk.loaded ? n : e()[t];
  }
  gateMethod(e, t) {
    return (async (...n) => {
      if (!Cb())
        return $u.throw(`Attempted to call a method (${t}) that is not supported on the server.`);
      this.isomorphicClerk.loaded || await new Promise((i) => this.isomorphicClerk.addOnLoaded(i));
      const r = e();
      return r[t].apply(r, n);
    });
  }
  wrapMethods(e, t) {
    return Object.fromEntries(t.map((n) => [n, this.gateMethod(e, n)]));
  }
  wrapStruct(e, t, n, r) {
    const i = {};
    for (const o of t)
      i[o] = this.gateMethod(e, o);
    for (const o of n)
      Object.defineProperty(i, o, {
        get: () => this.gateProperty(e, o, r[o]),
        enumerable: !0
      });
    return i;
  }
};
typeof globalThis.__BUILD_DISABLE_RHC__ > "u" && (globalThis.__BUILD_DISABLE_RHC__ = !1);
var $he = {
  name: "@clerk/clerk-react",
  version: "5.60.0",
  environment: "production"
}, M0, kf, Cf, Yl, Os, N0, Ql, cm, R0, Uhe = class i8 {
  constructor(t) {
    Zl(this, cm), this.clerkjs = null, this.preopenOneTap = null, this.preopenUserVerification = null, this.preopenEnableOrganizationsPrompt = null, this.preopenSignIn = null, this.preopenCheckout = null, this.preopenPlanDetails = null, this.preopenSubscriptionDetails = null, this.preopenSignUp = null, this.preopenUserProfile = null, this.preopenOrganizationProfile = null, this.preopenCreateOrganization = null, this.preOpenWaitlist = null, this.premountSignInNodes = /* @__PURE__ */ new Map(), this.premountSignUpNodes = /* @__PURE__ */ new Map(), this.premountUserAvatarNodes = /* @__PURE__ */ new Map(), this.premountUserProfileNodes = /* @__PURE__ */ new Map(), this.premountUserButtonNodes = /* @__PURE__ */ new Map(), this.premountOrganizationProfileNodes = /* @__PURE__ */ new Map(), this.premountCreateOrganizationNodes = /* @__PURE__ */ new Map(), this.premountOrganizationSwitcherNodes = /* @__PURE__ */ new Map(), this.premountOrganizationListNodes = /* @__PURE__ */ new Map(), this.premountMethodCalls = /* @__PURE__ */ new Map(), this.premountWaitlistNodes = /* @__PURE__ */ new Map(), this.premountPricingTableNodes = /* @__PURE__ */ new Map(), this.premountAPIKeysNodes = /* @__PURE__ */ new Map(), this.premountOAuthConsentNodes = /* @__PURE__ */ new Map(), this.premountTaskChooseOrganizationNodes = /* @__PURE__ */ new Map(), this.premountTaskResetPasswordNodes = /* @__PURE__ */ new Map(), this.premountAddListenerCalls = /* @__PURE__ */ new Map(), this.loadedListeners = [], Zl(this, M0, "loading"), Zl(this, kf), Zl(this, Cf), Zl(this, Yl), Zl(this, Os, Ihe()), Zl(this, N0), this.buildSignInUrl = (i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildSignInUrl(i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildSignInUrl", o);
    }, this.buildSignUpUrl = (i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildSignUpUrl(i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildSignUpUrl", o);
    }, this.buildAfterSignInUrl = (...i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildAfterSignInUrl(...i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildAfterSignInUrl", o);
    }, this.buildAfterSignUpUrl = (...i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildAfterSignUpUrl(...i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildAfterSignUpUrl", o);
    }, this.buildAfterSignOutUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildAfterSignOutUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildAfterSignOutUrl", i);
    }, this.buildNewSubscriptionRedirectUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildNewSubscriptionRedirectUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildNewSubscriptionRedirectUrl", i);
    }, this.buildAfterMultiSessionSingleSignOutUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildAfterMultiSessionSingleSignOutUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildAfterMultiSessionSingleSignOutUrl", i);
    }, this.buildUserProfileUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildUserProfileUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildUserProfileUrl", i);
    }, this.buildCreateOrganizationUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildCreateOrganizationUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildCreateOrganizationUrl", i);
    }, this.buildOrganizationProfileUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildOrganizationProfileUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildOrganizationProfileUrl", i);
    }, this.buildWaitlistUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildWaitlistUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildWaitlistUrl", i);
    }, this.buildTasksUrl = () => {
      const i = () => {
        var o;
        return ((o = this.clerkjs) == null ? void 0 : o.buildTasksUrl()) || "";
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("buildTasksUrl", i);
    }, this.buildUrlWithAuth = (i) => {
      const o = () => {
        var s;
        return ((s = this.clerkjs) == null ? void 0 : s.buildUrlWithAuth(i)) || "";
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("buildUrlWithAuth", o);
    }, this.handleUnauthenticated = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.handleUnauthenticated();
      };
      this.clerkjs && this.loaded ? i() : this.premountMethodCalls.set("handleUnauthenticated", i);
    }, this.on = (...i) => {
      var o;
      if ((o = this.clerkjs) != null && o.on)
        return this.clerkjs.on(...i);
      $n(this, Os).on(...i);
    }, this.off = (...i) => {
      var o;
      if ((o = this.clerkjs) != null && o.off)
        return this.clerkjs.off(...i);
      $n(this, Os).off(...i);
    }, this.addOnLoaded = (i) => {
      this.loadedListeners.push(i), this.loaded && this.emitLoaded();
    }, this.emitLoaded = () => {
      this.loadedListeners.forEach((i) => i()), this.loadedListeners = [];
    }, this.beforeLoad = (i) => {
      if (!i)
        throw new Error("Failed to hydrate latest Clerk JS");
    }, this.hydrateClerkJS = (i) => {
      var o, s;
      if (!i)
        throw new Error("Failed to hydrate latest Clerk JS");
      return this.clerkjs = i, this.premountMethodCalls.forEach((a) => a()), this.premountAddListenerCalls.forEach((a, c) => {
        a.nativeUnsubscribe = i.addListener(c);
      }), (o = $n(this, Os).internal.retrieveListeners("status")) == null || o.forEach((a) => {
        this.on("status", a, { notify: !0 });
      }), (s = $n(this, Os).internal.retrieveListeners("queryClientStatus")) == null || s.forEach((a) => {
        this.on("queryClientStatus", a, { notify: !0 });
      }), this.preopenSignIn !== null && i.openSignIn(this.preopenSignIn), this.preopenCheckout !== null && i.__internal_openCheckout(this.preopenCheckout), this.preopenPlanDetails !== null && i.__internal_openPlanDetails(this.preopenPlanDetails), this.preopenSubscriptionDetails !== null && i.__internal_openSubscriptionDetails(this.preopenSubscriptionDetails), this.preopenSignUp !== null && i.openSignUp(this.preopenSignUp), this.preopenUserProfile !== null && i.openUserProfile(this.preopenUserProfile), this.preopenUserVerification !== null && i.__internal_openReverification(this.preopenUserVerification), this.preopenOneTap !== null && i.openGoogleOneTap(this.preopenOneTap), this.preopenOrganizationProfile !== null && i.openOrganizationProfile(this.preopenOrganizationProfile), this.preopenCreateOrganization !== null && i.openCreateOrganization(this.preopenCreateOrganization), this.preOpenWaitlist !== null && i.openWaitlist(this.preOpenWaitlist), this.preopenEnableOrganizationsPrompt && i.__internal_openEnableOrganizationsPrompt(this.preopenEnableOrganizationsPrompt), this.premountSignInNodes.forEach((a, c) => {
        i.mountSignIn(c, a);
      }), this.premountSignUpNodes.forEach((a, c) => {
        i.mountSignUp(c, a);
      }), this.premountUserProfileNodes.forEach((a, c) => {
        i.mountUserProfile(c, a);
      }), this.premountUserAvatarNodes.forEach((a, c) => {
        i.mountUserAvatar(c, a);
      }), this.premountUserButtonNodes.forEach((a, c) => {
        i.mountUserButton(c, a);
      }), this.premountOrganizationListNodes.forEach((a, c) => {
        i.mountOrganizationList(c, a);
      }), this.premountWaitlistNodes.forEach((a, c) => {
        i.mountWaitlist(c, a);
      }), this.premountPricingTableNodes.forEach((a, c) => {
        i.mountPricingTable(c, a);
      }), this.premountAPIKeysNodes.forEach((a, c) => {
        i.mountAPIKeys(c, a);
      }), this.premountOAuthConsentNodes.forEach((a, c) => {
        i.__internal_mountOAuthConsent(c, a);
      }), this.premountTaskChooseOrganizationNodes.forEach((a, c) => {
        i.mountTaskChooseOrganization(c, a);
      }), this.premountTaskResetPasswordNodes.forEach((a, c) => {
        i.mountTaskResetPassword(c, a);
      }), typeof this.clerkjs.status > "u" && $n(this, Os).emit(Bv.Status, "ready"), this.emitLoaded(), this.clerkjs;
    }, this.__experimental_checkout = (...i) => {
      var o;
      return (o = this.clerkjs) == null ? void 0 : o.__experimental_checkout(...i);
    }, this.__unstable__updateProps = async (i) => {
      const o = await oC(this, cm, R0).call(this);
      if (o && "__unstable__updateProps" in o)
        return o.__unstable__updateProps(i);
    }, this.setActive = (i) => this.clerkjs ? this.clerkjs.setActive(i) : Promise.reject(), this.openSignIn = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openSignIn(i) : this.preopenSignIn = i;
    }, this.closeSignIn = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeSignIn() : this.preopenSignIn = null;
    }, this.__internal_openCheckout = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openCheckout(i) : this.preopenCheckout = i;
    }, this.__internal_closeCheckout = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closeCheckout() : this.preopenCheckout = null;
    }, this.__internal_openPlanDetails = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openPlanDetails(i) : this.preopenPlanDetails = i;
    }, this.__internal_closePlanDetails = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closePlanDetails() : this.preopenPlanDetails = null;
    }, this.__internal_openSubscriptionDetails = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openSubscriptionDetails(i) : this.preopenSubscriptionDetails = i ?? null;
    }, this.__internal_closeSubscriptionDetails = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closeSubscriptionDetails() : this.preopenSubscriptionDetails = null;
    }, this.__internal_openReverification = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openReverification(i) : this.preopenUserVerification = i;
    }, this.__internal_closeReverification = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closeReverification() : this.preopenUserVerification = null;
    }, this.__internal_openEnableOrganizationsPrompt = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_openEnableOrganizationsPrompt(i) : this.preopenEnableOrganizationsPrompt = i;
    }, this.__internal_closeEnableOrganizationsPrompt = () => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_closeEnableOrganizationsPrompt() : this.preopenEnableOrganizationsPrompt = null;
    }, this.openGoogleOneTap = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openGoogleOneTap(i) : this.preopenOneTap = i;
    }, this.closeGoogleOneTap = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeGoogleOneTap() : this.preopenOneTap = null;
    }, this.openUserProfile = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openUserProfile(i) : this.preopenUserProfile = i;
    }, this.closeUserProfile = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeUserProfile() : this.preopenUserProfile = null;
    }, this.openOrganizationProfile = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openOrganizationProfile(i) : this.preopenOrganizationProfile = i;
    }, this.closeOrganizationProfile = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeOrganizationProfile() : this.preopenOrganizationProfile = null;
    }, this.openCreateOrganization = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openCreateOrganization(i) : this.preopenCreateOrganization = i;
    }, this.closeCreateOrganization = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeCreateOrganization() : this.preopenCreateOrganization = null;
    }, this.openWaitlist = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openWaitlist(i) : this.preOpenWaitlist = i;
    }, this.closeWaitlist = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeWaitlist() : this.preOpenWaitlist = null;
    }, this.openSignUp = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.openSignUp(i) : this.preopenSignUp = i;
    }, this.closeSignUp = () => {
      this.clerkjs && this.loaded ? this.clerkjs.closeSignUp() : this.preopenSignUp = null;
    }, this.mountSignIn = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountSignIn(i, o) : this.premountSignInNodes.set(i, o);
    }, this.unmountSignIn = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountSignIn(i) : this.premountSignInNodes.delete(i);
    }, this.mountSignUp = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountSignUp(i, o) : this.premountSignUpNodes.set(i, o);
    }, this.unmountSignUp = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountSignUp(i) : this.premountSignUpNodes.delete(i);
    }, this.mountUserAvatar = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountUserAvatar(i, o) : this.premountUserAvatarNodes.set(i, o);
    }, this.unmountUserAvatar = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountUserAvatar(i) : this.premountUserAvatarNodes.delete(i);
    }, this.mountUserProfile = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountUserProfile(i, o) : this.premountUserProfileNodes.set(i, o);
    }, this.unmountUserProfile = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountUserProfile(i) : this.premountUserProfileNodes.delete(i);
    }, this.mountOrganizationProfile = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountOrganizationProfile(i, o) : this.premountOrganizationProfileNodes.set(i, o);
    }, this.unmountOrganizationProfile = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountOrganizationProfile(i) : this.premountOrganizationProfileNodes.delete(i);
    }, this.mountCreateOrganization = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountCreateOrganization(i, o) : this.premountCreateOrganizationNodes.set(i, o);
    }, this.unmountCreateOrganization = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountCreateOrganization(i) : this.premountCreateOrganizationNodes.delete(i);
    }, this.mountOrganizationSwitcher = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountOrganizationSwitcher(i, o) : this.premountOrganizationSwitcherNodes.set(i, o);
    }, this.unmountOrganizationSwitcher = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountOrganizationSwitcher(i) : this.premountOrganizationSwitcherNodes.delete(i);
    }, this.__experimental_prefetchOrganizationSwitcher = () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.__experimental_prefetchOrganizationSwitcher();
      };
      this.clerkjs && this.loaded ? i() : this.premountMethodCalls.set("__experimental_prefetchOrganizationSwitcher", i);
    }, this.mountOrganizationList = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountOrganizationList(i, o) : this.premountOrganizationListNodes.set(i, o);
    }, this.unmountOrganizationList = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountOrganizationList(i) : this.premountOrganizationListNodes.delete(i);
    }, this.mountUserButton = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountUserButton(i, o) : this.premountUserButtonNodes.set(i, o);
    }, this.unmountUserButton = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountUserButton(i) : this.premountUserButtonNodes.delete(i);
    }, this.mountWaitlist = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountWaitlist(i, o) : this.premountWaitlistNodes.set(i, o);
    }, this.unmountWaitlist = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountWaitlist(i) : this.premountWaitlistNodes.delete(i);
    }, this.mountPricingTable = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountPricingTable(i, o) : this.premountPricingTableNodes.set(i, o);
    }, this.unmountPricingTable = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountPricingTable(i) : this.premountPricingTableNodes.delete(i);
    }, this.mountAPIKeys = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountAPIKeys(i, o) : this.premountAPIKeysNodes.set(i, o);
    }, this.unmountAPIKeys = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountAPIKeys(i) : this.premountAPIKeysNodes.delete(i);
    }, this.__internal_mountOAuthConsent = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_mountOAuthConsent(i, o) : this.premountOAuthConsentNodes.set(i, o);
    }, this.__internal_unmountOAuthConsent = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.__internal_unmountOAuthConsent(i) : this.premountOAuthConsentNodes.delete(i);
    }, this.mountTaskChooseOrganization = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountTaskChooseOrganization(i, o) : this.premountTaskChooseOrganizationNodes.set(i, o);
    }, this.unmountTaskChooseOrganization = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountTaskChooseOrganization(i) : this.premountTaskChooseOrganizationNodes.delete(i);
    }, this.mountTaskResetPassword = (i, o) => {
      this.clerkjs && this.loaded ? this.clerkjs.mountTaskResetPassword(i, o) : this.premountTaskResetPasswordNodes.set(i, o);
    }, this.unmountTaskResetPassword = (i) => {
      this.clerkjs && this.loaded ? this.clerkjs.unmountTaskResetPassword(i) : this.premountTaskResetPasswordNodes.delete(i);
    }, this.addListener = (i) => {
      if (this.clerkjs)
        return this.clerkjs.addListener(i);
      {
        const o = () => {
          var s;
          const a = this.premountAddListenerCalls.get(i);
          a && ((s = a.nativeUnsubscribe) == null || s.call(a), this.premountAddListenerCalls.delete(i));
        };
        return this.premountAddListenerCalls.set(i, { unsubscribe: o, nativeUnsubscribe: void 0 }), o;
      }
    }, this.navigate = (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.navigate(i);
      };
      this.clerkjs && this.loaded ? o() : this.premountMethodCalls.set("navigate", o);
    }, this.redirectWithAuth = async (...i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.redirectWithAuth(...i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("redirectWithAuth", o);
    }, this.redirectToSignIn = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.redirectToSignIn(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("redirectToSignIn", o);
    }, this.redirectToSignUp = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.redirectToSignUp(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("redirectToSignUp", o);
    }, this.redirectToUserProfile = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToUserProfile();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToUserProfile", i);
    }, this.redirectToAfterSignUp = () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToAfterSignUp();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToAfterSignUp", i);
    }, this.redirectToAfterSignIn = () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToAfterSignIn();
      };
      this.clerkjs && this.loaded ? i() : this.premountMethodCalls.set("redirectToAfterSignIn", i);
    }, this.redirectToAfterSignOut = () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToAfterSignOut();
      };
      this.clerkjs && this.loaded ? i() : this.premountMethodCalls.set("redirectToAfterSignOut", i);
    }, this.redirectToOrganizationProfile = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToOrganizationProfile();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToOrganizationProfile", i);
    }, this.redirectToCreateOrganization = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToCreateOrganization();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToCreateOrganization", i);
    }, this.redirectToWaitlist = async () => {
      const i = () => {
        var o;
        return (o = this.clerkjs) == null ? void 0 : o.redirectToWaitlist();
      };
      if (this.clerkjs && this.loaded)
        return i();
      this.premountMethodCalls.set("redirectToWaitlist", i);
    }, this.redirectToTasks = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.redirectToTasks(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("redirectToTasks", o);
    }, this.handleRedirectCallback = async (i) => {
      var o;
      const s = () => {
        var a;
        return (a = this.clerkjs) == null ? void 0 : a.handleRedirectCallback(i);
      };
      this.clerkjs && this.loaded ? (o = s()) == null || o.catch(() => {
      }) : this.premountMethodCalls.set("handleRedirectCallback", s);
    }, this.handleGoogleOneTapCallback = async (i, o) => {
      var s;
      const a = () => {
        var c;
        return (c = this.clerkjs) == null ? void 0 : c.handleGoogleOneTapCallback(i, o);
      };
      this.clerkjs && this.loaded ? (s = a()) == null || s.catch(() => {
      }) : this.premountMethodCalls.set("handleGoogleOneTapCallback", a);
    }, this.handleEmailLinkVerification = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.handleEmailLinkVerification(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("handleEmailLinkVerification", o);
    }, this.authenticateWithMetamask = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithMetamask(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithMetamask", o);
    }, this.authenticateWithCoinbaseWallet = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithCoinbaseWallet(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithCoinbaseWallet", o);
    }, this.authenticateWithBase = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithBase(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithBase", o);
    }, this.authenticateWithOKXWallet = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithOKXWallet(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithOKXWallet", o);
    }, this.authenticateWithSolana = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithSolana(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithSolana", o);
    }, this.authenticateWithWeb3 = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.authenticateWithWeb3(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("authenticateWithWeb3", o);
    }, this.authenticateWithGoogleOneTap = async (i) => (await oC(this, cm, R0).call(this)).authenticateWithGoogleOneTap(i), this.__internal_loadStripeJs = async () => (await oC(this, cm, R0).call(this)).__internal_loadStripeJs(), this.createOrganization = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.createOrganization(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("createOrganization", o);
    }, this.getOrganization = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.getOrganization(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("getOrganization", o);
    }, this.joinWaitlist = async (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.joinWaitlist(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("joinWaitlist", o);
    }, this.signOut = async (...i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.signOut(...i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("signOut", o);
    }, this.__internal_attemptToEnableEnvironmentSetting = (i) => {
      const o = () => {
        var s;
        return (s = this.clerkjs) == null ? void 0 : s.__internal_attemptToEnableEnvironmentSetting(i);
      };
      if (this.clerkjs && this.loaded)
        return o();
      this.premountMethodCalls.set("__internal_attemptToEnableEnvironmentSetting", o);
    };
    const { Clerk: n = null, publishableKey: r } = t || {};
    ku(this, Yl, r), ku(this, Cf, t?.proxyUrl), ku(this, kf, t?.domain), this.options = t, this.Clerk = n, this.mode = Cb() ? "browser" : "server", ku(this, N0, new Bhe(this)), this.options.sdkMetadata || (this.options.sdkMetadata = $he), $n(this, Os).emit(Bv.Status, "loading"), $n(this, Os).prioritizedOn(Bv.Status, (i) => ku(this, M0, i)), $n(this, Yl) && this.loadClerkJS();
  }
  get publishableKey() {
    return $n(this, Yl);
  }
  get loaded() {
    var t;
    return ((t = this.clerkjs) == null ? void 0 : t.loaded) || !1;
  }
  get status() {
    var t;
    return this.clerkjs ? ((t = this.clerkjs) == null ? void 0 : t.status) || /**
    * Support older clerk-js versions.
    * If clerk-js is available but `.status` is missing it we need to fallback to `.loaded`.
    * Since "degraded" an "error" did not exist before,
    * map "loaded" to "ready" and "not loaded" to "loading".
    */
    (this.clerkjs.loaded ? "ready" : "loading") : $n(this, M0);
  }
  static getOrCreateInstance(t) {
    return (!Cb() || !$n(this, Ql) || t.Clerk && $n(this, Ql).Clerk !== t.Clerk || // Allow hot swapping PKs on the client
    $n(this, Ql).publishableKey !== t.publishableKey) && ku(this, Ql, new i8(t)), $n(this, Ql);
  }
  static clearInstance() {
    ku(this, Ql, null);
  }
  get domain() {
    return typeof window < "u" && window.location ? eC($n(this, kf), new URL(window.location.href), "") : typeof $n(this, kf) == "function" ? $u.throw(Qk) : $n(this, kf) || "";
  }
  get proxyUrl() {
    return typeof window < "u" && window.location ? eC($n(this, Cf), new URL(window.location.href), "") : typeof $n(this, Cf) == "function" ? $u.throw(Qk) : $n(this, Cf) || "";
  }
  /**
   * Accesses private options from the `Clerk` instance and defaults to
   * `IsomorphicClerk` options when in SSR context.
   *  @internal
   */
  __internal_getOption(t) {
    var n, r;
    return (n = this.clerkjs) != null && n.__internal_getOption ? (r = this.clerkjs) == null ? void 0 : r.__internal_getOption(t) : this.options[t];
  }
  get sdkMetadata() {
    var t;
    return ((t = this.clerkjs) == null ? void 0 : t.sdkMetadata) || this.options.sdkMetadata || void 0;
  }
  get instanceType() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.instanceType;
  }
  get frontendApi() {
    var t;
    return ((t = this.clerkjs) == null ? void 0 : t.frontendApi) || "";
  }
  get isStandardBrowser() {
    var t;
    return ((t = this.clerkjs) == null ? void 0 : t.isStandardBrowser) || this.options.standardBrowser || !1;
  }
  get __internal_queryClient() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.__internal_queryClient;
  }
  get isSatellite() {
    return typeof window < "u" && window.location ? eC(this.options.isSatellite, new URL(window.location.href), !1) : typeof this.options.isSatellite == "function" ? $u.throw(Qk) : !1;
  }
  async loadClerkJS() {
    var t;
    if (!(this.mode !== "browser" || this.loaded)) {
      typeof window < "u" && (window.__clerk_publishable_key = $n(this, Yl), window.__clerk_proxy_url = this.proxyUrl, window.__clerk_domain = this.domain);
      try {
        if (this.Clerk) {
          let n;
          nhe(this.Clerk) ? (n = new this.Clerk($n(this, Yl), {
            proxyUrl: this.proxyUrl,
            domain: this.domain
          }), this.beforeLoad(n), await n.load(this.options)) : (n = this.Clerk, n.loaded || (this.beforeLoad(n), await n.load(this.options))), global.Clerk = n;
        } else if (!__BUILD_DISABLE_RHC__) {
          if (global.Clerk || await Rhe({
            ...this.options,
            publishableKey: $n(this, Yl),
            proxyUrl: this.proxyUrl,
            domain: this.domain,
            nonce: this.options.nonce
          }), !global.Clerk)
            throw new Error("Failed to download latest ClerkJS. Contact support@clerk.com.");
          this.beforeLoad(global.Clerk), await global.Clerk.load(this.options);
        }
        return (t = global.Clerk) != null && t.loaded ? this.hydrateClerkJS(global.Clerk) : void 0;
      } catch (n) {
        const r = n;
        $n(this, Os).emit(Bv.Status, "error"), console.error(r.stack || r.message || r);
        return;
      }
    }
  }
  get version() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.version;
  }
  get client() {
    if (this.clerkjs)
      return this.clerkjs.client;
  }
  get session() {
    if (this.clerkjs)
      return this.clerkjs.session;
  }
  get user() {
    if (this.clerkjs)
      return this.clerkjs.user;
  }
  get organization() {
    if (this.clerkjs)
      return this.clerkjs.organization;
  }
  get telemetry() {
    if (this.clerkjs)
      return this.clerkjs.telemetry;
  }
  get __unstable__environment() {
    if (this.clerkjs)
      return this.clerkjs.__unstable__environment;
  }
  get isSignedIn() {
    return this.clerkjs ? this.clerkjs.isSignedIn : !1;
  }
  get billing() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.billing;
  }
  get __internal_state() {
    return this.loaded && this.clerkjs ? this.clerkjs.__internal_state : $n(this, N0);
  }
  get apiKeys() {
    var t;
    return (t = this.clerkjs) == null ? void 0 : t.apiKeys;
  }
  __unstable__setEnvironment(...t) {
    if (this.clerkjs && "__unstable__setEnvironment" in this.clerkjs)
      this.clerkjs.__unstable__setEnvironment(t);
    else
      return;
  }
};
M0 = /* @__PURE__ */ new WeakMap();
kf = /* @__PURE__ */ new WeakMap();
Cf = /* @__PURE__ */ new WeakMap();
Yl = /* @__PURE__ */ new WeakMap();
Os = /* @__PURE__ */ new WeakMap();
N0 = /* @__PURE__ */ new WeakMap();
Ql = /* @__PURE__ */ new WeakMap();
cm = /* @__PURE__ */ new WeakSet();
R0 = function() {
  return new Promise((e) => {
    this.addOnLoaded(() => e(this.clerkjs));
  });
};
Zl(Uhe, Ql);
jfe({ packageName: "@clerk/clerk-react" });
Mhe("@clerk/clerk-react");
const Fhe = ({
  message: e = "Loading...",
  size: t = "md",
  variant: n = "dots"
}) => {
  const r = {
    sm: "h-1 w-1",
    md: "h-2 w-2",
    lg: "h-3 w-3"
  }, i = {
    sm: "gap-1",
    md: "gap-1.5",
    lg: "gap-2"
  }, o = {
    sm: "text-[10px]",
    md: "text-xs",
    lg: "text-sm"
  }, s = () => /* @__PURE__ */ v.jsxs("div", { className: `flex items-center ${i[t]}`, children: [
    /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${r[t]} animate-pulse rounded-full bg-primary`,
        style: { animationDelay: "0ms", animationDuration: "1s" }
      }
    ),
    /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${r[t]} animate-pulse rounded-full bg-primary`,
        style: { animationDelay: "150ms", animationDuration: "1s" }
      }
    ),
    /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${r[t]} animate-pulse rounded-full bg-primary`,
        style: { animationDelay: "300ms", animationDuration: "1s" }
      }
    )
  ] }), a = () => {
    const h = {
      sm: "h-4 w-4",
      md: "h-6 w-6",
      lg: "h-8 w-8"
    };
    return /* @__PURE__ */ v.jsx(
      "div",
      {
        className: `${h[t]} animate-spin rounded-full border-2 border-primary border-t-transparent`
      }
    );
  }, c = () => {
    const h = {
      sm: "h-4 w-4",
      md: "h-6 w-6",
      lg: "h-8 w-8"
    };
    return /* @__PURE__ */ v.jsxs("div", { className: "relative flex items-center justify-center", children: [
      /* @__PURE__ */ v.jsx(
        "span",
        {
          className: `${h[t]} absolute animate-ping rounded-full bg-primary/40`
        }
      ),
      /* @__PURE__ */ v.jsx("span", { className: `${h[t]} relative rounded-full bg-primary` })
    ] });
  }, u = () => {
    const h = {
      sm: "h-3",
      md: "h-4",
      lg: "h-5"
    }, m = {
      sm: "w-0.5",
      md: "w-1",
      lg: "w-1.5"
    };
    return /* @__PURE__ */ v.jsx("div", { className: `flex items-end ${i[t]}`, children: [0, 1, 2, 3].map((g) => /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${m[t]} ${h[t]} animate-pulse rounded-sm bg-primary`,
        style: {
          animationDelay: `${g * 100}ms`,
          animationDuration: "0.8s"
        }
      },
      g
    )) });
  }, f = () => {
    switch (n) {
      case "spinner":
        return a();
      case "pulse":
        return c();
      case "bars":
        return u();
      default:
        return s();
    }
  };
  return /* @__PURE__ */ v.jsxs("div", { className: "inline-flex items-center gap-2", children: [
    f(),
    e && /* @__PURE__ */ v.jsx(
      "span",
      {
        className: `${o[t]} tracking-wide text-muted-foreground`,
        children: e
      }
    )
  ] });
}, Vhe = (e = /* @__PURE__ */ new Date()) => e.toLocaleTimeString("en-GB", { hour12: !1 }), Hhe = [
  "",
  "                                                   ",
  "                  24K TWIN EDITOR                  ",
  "                                                   ",
  "         Advanced Development Environment          ",
  "                                                   ",
  "                                                   ",
  "         Initializing System Components...         ",
  "                                                   ",
  ""
], Whe = [
  { lines: ["[SYSTEM] Initializing connection..."], tone: "muted", delay: 500 },
  { lines: ["[SYSTEM] Loading application modules..."], tone: "muted", delay: 850 },
  { lines: Hhe, tone: "banner", delay: 1200, timestamp: !1 },
  { lines: ["[CORE] Allocating resources..."], tone: "muted", delay: 900 },
  { lines: ["[CORE] Configuring environment..."], tone: "muted", delay: 950 },
  { lines: ["[ENGINE] Starting twin editor engine..."], tone: "normal", delay: 800 },
  { lines: ["[ENGINE] Mounting components..."], tone: "normal", delay: 850 },
  { lines: ["[UI] Rendering interface..."], tone: "normal", delay: 850 },
  { lines: ["[READY] All systems operational"], tone: "accent", delay: 850 },
  {
    lines: ["[STATUS] Twin Editor is ready for development"],
    tone: "accent",
    delay: 1100
  }
], qhe = {
  muted: "text-muted-foreground/60",
  normal: "text-foreground/85",
  accent: "text-primary font-semibold drop-shadow-[0_0_8px_hsl(var(--primary)/0.45)]",
  banner: "text-primary/70 font-semibold"
}, Ghe = () => {
  const [e, t] = C.useState([]), n = C.useRef(null), r = C.useRef(0);
  return C.useEffect(() => {
    const i = [];
    let o = 0;
    return t([]), Whe.forEach((s) => {
      o += s.delay, i.push(
        window.setTimeout(() => {
          const a = Vhe();
          t((c) => {
            const u = [...c];
            return s.tone === "banner" ? (r.current += 1, u.push({
              id: String(r.current),
              message: s.lines.join(`
`),
              timestamp: s.timestamp === !1 ? void 0 : a,
              tone: s.tone ?? "normal"
            }), u) : (s.lines.forEach((f) => {
              r.current += 1, u.push({
                id: String(r.current),
                message: f,
                timestamp: s.timestamp === !1 ? void 0 : a,
                tone: s.tone ?? "normal"
              });
            }), u);
          });
        }, o)
      );
    }), () => {
      i.forEach((s) => window.clearTimeout(s));
    };
  }, []), C.useEffect(() => {
    const i = n.current;
    i && (i.scrollTop = i.scrollHeight);
  }, [e]), /* @__PURE__ */ v.jsxs(
    "section",
    {
      className: "relative w-full text-foreground",
      style: { fontFamily: '"Titillium Web", "Titillium_Web", sans-serif' },
      children: [
        /* @__PURE__ */ v.jsx(
          "div",
          {
            ref: n,
            role: "log",
            "aria-live": "polite",
            className: "no-scrollbar max-w-full overflow-x-auto overflow-y-auto pr-2 font-mono text-[11px] leading-snug text-foreground/80",
            children: e.length ? /* @__PURE__ */ v.jsx("div", { className: "flex flex-col gap-1", children: e.map((i) => /* @__PURE__ */ v.jsxs(
              "div",
              {
                className: "flex items-start gap-2 px-2 py-1 transition-colors hover:bg-primary/10 animate-logEntry",
                children: [
                  i.timestamp ? /* @__PURE__ */ v.jsx("span", { className: "w-[64px] shrink-0 text-primary/60 tabular-nums", children: i.timestamp }) : null,
                  /* @__PURE__ */ v.jsx("span", { className: `whitespace-pre ${qhe[i.tone]}`, children: i.message })
                ]
              },
              i.id
            )) }) : /* @__PURE__ */ v.jsx("div", { className: "text-muted-foreground", children: "Awaiting telemetry..." })
          }
        ),
        /* @__PURE__ */ v.jsx("div", { className: "mt-2 flex items-center gap-2 text-[10px] uppercase tracking-[0.3em] text-muted-foreground/60", children: /* @__PURE__ */ v.jsx(Fhe, { variant: "bars", size: "sm", message: "Initializing" }) })
      ]
    }
  );
};
function Khe({ message: e }) {
  const { user: t } = UU(), {
    data: n,
    isLoading: r,
    isValidating: i
  } = d9(), { myServers: o, featuredServers: s } = C.useMemo(() => {
    if (!n) return { myServers: [], featuredServers: [] };
    const S = (N, P) => N.status === P.status ? 0 : N.status === "authorizing" ? -1 : P.status === "authorizing" ? 1 : 0, _ = n.filter((N) => N.userId === Cj(t?.id)).sort(S), M = n.filter((N) => N.userId !== Cj(t?.id) && N.visibility === "public").sort(S);
    return { myServers: _, featuredServers: M };
  }, [n]), a = C.useMemo(() => [...bb].sort(() => 0.5 - Math.random()).slice(0, 5), []), [c, u] = C.useState(!1), [f, h] = C.useState(!1), [m, g] = C.useState(!1), b = (S) => {
    const _ = new URLSearchParams();
    _.set("name", S.name), _.set("config", JSON.stringify(S.config)), window.open("/chat-bot/mcp/create?" + _.toString(), "_blank");
  }, x = (S) => {
    h(S), S && g(!1);
  }, w = (S) => {
    g(S), S && h(!1);
  };
  return C.useEffect(() => {
    if (i) {
      u(!1);
      const S = setTimeout(() => u(!0), 500);
      return () => clearTimeout(S);
    }
    u(!1);
  }, [i]), C.useEffect(() => {
    e && cn(/* @__PURE__ */ v.jsx("p", { className: "whitespace-pre-wrap break-all", children: e }), {
      id: "mcp-list-message"
    });
  }, []), /* @__PURE__ */ v.jsx(v.Fragment, { children: /* @__PURE__ */ v.jsx(JT, { className: "h-full w-full z-40 bg-gradient-to-b from-background via-background to-muted/30", children: /* @__PURE__ */ v.jsx("div", { className: "flex-1 relative w-full mx-auto", children: /* @__PURE__ */ v.jsx("div", { className: "w-full mx-auto px-4 sm:px-6 lg:px-8 py-8", children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-8", children: [
    /* @__PURE__ */ v.jsxs("header", { className: "relative z-10 rounded-2xl border border-border/60 bg-gradient-to-br from-card/90 via-card/90 to-muted/40 p-6 sm:p-8 shadow-sm backdrop-blur", children: [
      /* @__PURE__ */ v.jsx("div", { className: "pointer-events-none absolute -top-20 right-0 h-56 w-56 rounded-full bg-primary/10 blur-3xl" }),
      /* @__PURE__ */ v.jsx("div", { className: "pointer-events-none absolute -bottom-24 left-0 h-56 w-56 rounded-full bg-muted/40 blur-3xl" }),
      /* @__PURE__ */ v.jsxs("div", { className: "relative flex flex-col gap-6", children: [
        /* @__PURE__ */ v.jsxs("div", { className: "flex flex-wrap items-center gap-3 text-xs uppercase tracking-wide text-muted-foreground", children: [
          /* @__PURE__ */ v.jsx("span", { className: "rounded-full border border-border/60 bg-muted/50 px-3 py-1 font-semibold", children: "MCP Directory" }),
          /* @__PURE__ */ v.jsxs("span", { className: "rounded-full border border-border/60 bg-muted/50 px-3 py-1 font-semibold", children: [
            o.length + s.length,
            " servers"
          ] }),
          c && i && !r && /* @__PURE__ */ v.jsxs("span", { className: "inline-flex items-center gap-2 rounded-full border border-border/60 bg-muted/50 px-3 py-1 font-semibold", children: [
            "Refreshing",
            /* @__PURE__ */ v.jsx(Zs, { className: "size-3 animate-spin" })
          ] })
        ] }),
        /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col lg:flex-row lg:items-end lg:justify-between gap-6", children: [
          /* @__PURE__ */ v.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ v.jsx("h1", { className: "text-3xl md:text-4xl font-semibold flex items-center gap-3", children: "MCP Servers" }),
            /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground max-w-2xl", children: "Browse your MCP connections, manage visibility, and launch new integrations with confidence." })
          ] }),
          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-wrap items-center gap-2", children: [
            n?.length ? /* @__PURE__ */ v.jsxs(
              Qu,
              {
                open: f,
                onOpenChange: x,
                children: [
                  /* @__PURE__ */ v.jsx(ed, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
                    Ht,
                    {
                      variant: "outline",
                      className: "gap-2 border-border/60 bg-card/80 shadow-sm transition-all hover:bg-card/90 hover:shadow-md cursor-pointer",
                      children: [
                        /* @__PURE__ */ v.jsx("div", { className: "flex -space-x-2 cursor-pointer", children: a.map((S, _) => {
                          const M = S.icon;
                          return /* @__PURE__ */ v.jsx(
                            "div",
                            {
                              className: "relative rounded-full border border-border/60 bg-muted/60 p-1",
                              style: {
                                zIndex: a.length - _
                              },
                              children: /* @__PURE__ */ v.jsx(M, { className: "size-3" })
                            },
                            S.name
                          );
                        }) }),
                        "Recommended MCPs"
                      ]
                    }
                  ) }),
                  /* @__PURE__ */ v.jsx(td, { align: "end", className: "w-56 p-2 z-1000 bg-popover text-popover-foreground border-border/60 shadow-lg", children: bb.map((S) => {
                    const _ = S.icon;
                    return /* @__PURE__ */ v.jsxs(
                      ls,
                      {
                        onClick: () => b(S),
                        className: "cursor-pointer flex items-center gap-3 rounded-lg px-3 py-2.5 text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
                        children: [
                          /* @__PURE__ */ v.jsx(_, { className: "size-4" }),
                          /* @__PURE__ */ v.jsx("span", { children: S.label })
                        ]
                      },
                      S.name
                    );
                  }) })
                ]
              }
            ) : null,
            /* @__PURE__ */ v.jsxs(
              Ht,
              {
                className: "gap-2 font-semibold shadow-sm transition-all hover:shadow-md cursor-pointer",
                variant: "default",
                "data-testid": "add-mcp-server-button",
                onClick: () => window.open("/chat-bot/mcp/create", "_blank"),
                children: [
                  /* @__PURE__ */ v.jsx(lh, { className: "fill-foreground size-3.5" }),
                  "Add MCP Server"
                ]
              }
            ),
            /* @__PURE__ */ v.jsxs(
              Qu,
              {
                open: m,
                onOpenChange: w,
                children: [
                  /* @__PURE__ */ v.jsx(ed, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
                    Ht,
                    {
                      className: "gap-2 font-semibold border-border/60 bg-card/80 shadow-sm transition-all hover:bg-card/90 hover:shadow-md cursor-pointer",
                      variant: "outline",
                      "data-testid": "marketplace-button",
                      children: [
                        /* @__PURE__ */ v.jsx(FY, { className: "size-3.5" }),
                        "Marketplace"
                      ]
                    }
                  ) }),
                  /* @__PURE__ */ v.jsxs(td, { align: "end", className: "w-56 p-2 z-1000 bg-popover text-popover-foreground border-border/60 shadow-lg", children: [
                    /* @__PURE__ */ v.jsxs(
                      ls,
                      {
                        onClick: () => window.open("https://smithery.ai/", "_blank"),
                        className: "cursor-pointer flex items-center gap-3 rounded-lg px-3 py-2.5 text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
                        children: [
                          /* @__PURE__ */ v.jsx(LY, { className: "size-4 text-primary" }),
                          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
                            /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "Smithery.ai" }),
                            /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "3,700+ servers" })
                          ] })
                        ]
                      }
                    ),
                    /* @__PURE__ */ v.jsxs(
                      ls,
                      {
                        onClick: () => window.open("https://www.pulsemcp.com/servers", "_blank"),
                        className: "cursor-pointer flex items-center gap-3 rounded-lg px-3 py-2.5 text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
                        children: [
                          /* @__PURE__ */ v.jsx(ZY, { className: "size-4 text-primary" }),
                          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
                            /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "PulseMCP" }),
                            /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Community servers" })
                          ] })
                        ]
                      }
                    ),
                    /* @__PURE__ */ v.jsxs(
                      ls,
                      {
                        onClick: () => window.open("https://mcpmarket.com/", "_blank"),
                        className: "cursor-pointer flex items-center gap-3 rounded-lg px-3 py-2.5 text-foreground transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
                        children: [
                          /* @__PURE__ */ v.jsx(IY, { className: "size-4 text-primary" }),
                          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
                            /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: "MCP Market" }),
                            /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Server marketplace" })
                          ] })
                        ]
                      }
                    )
                  ] })
                ]
              }
            )
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ v.jsx("main", { className: "space-y-8", children: r ? /* @__PURE__ */ v.jsx("div", { className: "space-y-6", children: /* @__PURE__ */ v.jsx(Ghe, {}) }) : o?.length || s?.length ? /* @__PURE__ */ v.jsxs(
      "div",
      {
        className: "flex flex-col gap-8",
        "data-testid": "mcp-servers-section",
        children: [
          o?.length > 0 && /* @__PURE__ */ v.jsxs("section", { className: "rounded-2xl border border-border/60 bg-card/80 p-6 shadow-sm", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-4", children: [
              /* @__PURE__ */ v.jsxs("h2", { className: "text-lg font-semibold", children: [
                "My MCP Servers ",
                o.length > 0 ? `(${o.length})` : ""
              ] }),
              /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Private workspace" })
            ] }),
            /* @__PURE__ */ v.jsx(
              "div",
              {
                className: "mt-6 flex flex-col gap-6",
                "data-testid": "my-mcp-servers-section",
                children: o.map((S) => /* @__PURE__ */ v.jsx(Ij, { ...S, user: t }, S.id))
              }
            )
          ] }),
          s?.length > 0 && /* @__PURE__ */ v.jsxs("section", { className: "rounded-2xl border border-border/60 bg-card/80 p-6 shadow-sm", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-4", children: [
              /* @__PURE__ */ v.jsx("h2", { className: "text-lg font-semibold", children: "Featured MCP Servers" }),
              /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Curated by community" })
            ] }),
            /* @__PURE__ */ v.jsx(
              "div",
              {
                className: "mt-6 flex flex-col gap-6",
                "data-testid": "featured-mcp-servers-section",
                children: s.map((S) => /* @__PURE__ */ v.jsx(Ij, { ...S, user: t }, S.id))
              }
            )
          ] })
        ]
      }
    ) : /* @__PURE__ */ v.jsx(Due, {}) })
  ] }) }) }) }) });
}
const Zhe = ({
  onClose: e,
  title: t = "Chatbot",
  version: n = "v1",
  setApiKeyByName: r,
  onToggleSidebar: i,
  isSidebarOpen: o = !1
}) => {
  const [s, a] = C.useState(!1), [c, u] = C.useState(!1);
  return /* @__PURE__ */ v.jsxs(Oh, { delayDuration: 150, children: [
    /* @__PURE__ */ v.jsxs("div", { className: "chatbot-drag-handle bg-background h-12 px-4 flex items-center justify-between border-b rounded-t-2xl cursor-grab active:cursor-grabbing", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ v.jsx("div", { className: "h-7 w-7 inline-flex items-center justify-center rounded-lg bg-blue-100 dark:bg-[#1abcfe]/10", children: /* @__PURE__ */ v.jsx(fY, { className: "h-4 w-4 text-blue-500 dark:text-[#1abcfe]" }) }),
        /* @__PURE__ */ v.jsx("h3", { className: "text-base font-semibold leading-none text-neutral-900 dark:text-white", children: t }),
        /* @__PURE__ */ v.jsx(Dh, { variant: "outline", className: "hidden sm:inline-flex border-blue-200 text-blue-500 bg-transparent dark:border-[#1abcfe]/40 dark:text-[#1abcfe]", children: n })
      ] }),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-1", children: [
        i && /* @__PURE__ */ v.jsxs(Gi, { children: [
          /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-blue-500 cursor-pointer",
              onClick: i,
              "aria-label": o ? "Hide chat history" : "Show chat history",
              children: /* @__PURE__ */ v.jsx(lY, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ v.jsx(Bo, { children: o ? "Hide chat history" : "Show chat history" })
        ] }),
        /* @__PURE__ */ v.jsxs(Gi, { children: [
          /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-blue-500 cursor-pointer",
              "aria-label": "Open settings",
              onClick: () => a(!0),
              children: /* @__PURE__ */ v.jsx(H3, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ v.jsx(Bo, { children: "Settings" })
        ] }),
        /* @__PURE__ */ v.jsxs(Gi, { children: [
          /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-foreground cursor-pointer",
              onClick: () => u(!0),
              "aria-label": "MCP Configuration",
              children: /* @__PURE__ */ v.jsx(lh, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ v.jsx(Bo, { children: "MCP Configuration" })
        ] }),
        /* @__PURE__ */ v.jsxs(Gi, { children: [
          /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-foreground cursor-pointer",
              onClick: e,
              "aria-label": "Close",
              children: /* @__PURE__ */ v.jsx(Rg, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ v.jsx(Bo, { children: "Close" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ v.jsx(
      ele,
      {
        open: s,
        onOpenChange: a,
        setApiKeyByName: r
      }
    ),
    /* @__PURE__ */ v.jsx(Ph, { open: c, onOpenChange: u, children: /* @__PURE__ */ v.jsxs(jh, { className: "w-[90vw]! max-w-[1400px]! max-h-[85vh] overflow-hidden p-0 flex flex-col", children: [
      /* @__PURE__ */ v.jsx(Vg, { className: "px-8 pt-6 pb-4 border-b bg-linear-to-r from-background to-muted/20", children: /* @__PURE__ */ v.jsxs(Ih, { className: "flex items-center gap-3 text-xl font-bold", children: [
        /* @__PURE__ */ v.jsx("div", { className: "p-2 rounded-lg bg-primary/10", children: /* @__PURE__ */ v.jsx(lh, { className: "h-6 w-6 text-primary" }) }),
        "MCP Configuration"
      ] }) }),
      /* @__PURE__ */ v.jsx("div", { className: "overflow-y-auto px-4 flex-1", children: /* @__PURE__ */ v.jsx(Khe, {}) })
    ] }) })
  ] });
};
async function Tw() {
  throw new Error("Auth token getter not initialized. Call initAuthTokenGetter() first.");
}
async function Yhe(e) {
  if (!e) throw new Error("Missing threadId");
  const t = await Tw(), n = await fetch(`${Wg}/${e}`, { method: "DELETE", headers: t });
  if (!n.ok) {
    const r = await n.json().catch(() => ({}));
    throw new Error(r?.error || "Server error");
  }
  return await n.json();
}
async function o8() {
  const e = await Tw(), t = await fetch(`${Wg}`, { headers: e });
  if (!t.ok) {
    const n = await t.json().catch(() => ({}));
    throw new Error(n?.error || "Server error");
  }
  return await t.json();
}
async function Xhe(e, t) {
  if (!e) throw new Error("Missing threadId");
  if (!t || !t.trim()) throw new Error("Title cannot be empty");
  const n = await Tw(), r = await fetch(`${Wg}/${e}`, {
    method: "PATCH",
    headers: n,
    body: JSON.stringify({
      title: t.trim()
    })
  });
  if (!r.ok) {
    const i = await r.json().catch(() => ({}));
    throw new Error(i?.error || "Failed to update thread title");
  }
  return await r.json();
}
async function nI(e, t) {
  if (!e) throw new Error("Missing threadId");
  const n = await Tw(), r = new URLSearchParams();
  t?.limit && r.append("limit", t.limit.toString()), t?.cursor && r.append("cursor", t.cursor), t?.direction && r.append("direction", t.direction);
  const i = `${Wg}/${e}/messages${r.toString() ? `?${r.toString()}` : ""}`, o = await fetch(i, { headers: n });
  if (!o.ok) {
    const s = await o.json().catch(() => ({}));
    throw new Error(s?.error || "Failed to fetch messages");
  }
  return await o.json();
}
const Xr = [];
for (let e = 0; e < 256; ++e)
  Xr.push((e + 256).toString(16).slice(1));
function Jhe(e, t = 0) {
  return (Xr[e[t + 0]] + Xr[e[t + 1]] + Xr[e[t + 2]] + Xr[e[t + 3]] + "-" + Xr[e[t + 4]] + Xr[e[t + 5]] + "-" + Xr[e[t + 6]] + Xr[e[t + 7]] + "-" + Xr[e[t + 8]] + Xr[e[t + 9]] + "-" + Xr[e[t + 10]] + Xr[e[t + 11]] + Xr[e[t + 12]] + Xr[e[t + 13]] + Xr[e[t + 14]] + Xr[e[t + 15]]).toLowerCase();
}
let sC;
const Qhe = new Uint8Array(16);
function epe() {
  if (!sC) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    sC = crypto.getRandomValues.bind(crypto);
  }
  return sC(Qhe);
}
const tpe = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), rI = { randomUUID: tpe };
function npe(e, t, n) {
  e = e || {};
  const r = e.random ?? e.rng?.() ?? epe();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Jhe(r);
}
function s8(e, t, n) {
  return rI.randomUUID && !e ? rI.randomUUID() : npe(e);
}
function rpe() {
  return `temp-${s8()}`;
}
function ng(e) {
  return e.startsWith("temp-");
}
function ipe(e) {
  if (!ng(e))
    throw new Error(`Invalid temporary thread ID: ${e}`);
  return e.substring(5);
}
function ope({ open: e, onConfirm: t, onCancel: n }) {
  return /* @__PURE__ */ v.jsx(Ph, { open: e, onOpenChange: n, children: /* @__PURE__ */ v.jsxs(jh, { className: "max-w-md", children: [
    /* @__PURE__ */ v.jsxs(Vg, { children: [
      /* @__PURE__ */ v.jsx(Ih, { children: "Delete Conversation" }),
      /* @__PURE__ */ v.jsx("p", { className: "text-xs italic text-muted-foreground mt-1", children: "Are you sure you want to delete this conversation? This action is irreversible and you will not be able to recover the deleted messages." })
    ] }),
    /* @__PURE__ */ v.jsxs(S$, { children: [
      /* @__PURE__ */ v.jsx(Ht, { variant: "outline", onClick: n, type: "button", className: "cursor-pointer", children: "Cancel" }),
      /* @__PURE__ */ v.jsx(Ht, { variant: "destructive", onClick: t, type: "button", className: "cursor-pointer", children: "Delete Conversation" })
    ] })
  ] }) });
}
const a8 = ({
  message: e = "Loading..."
}) => /* @__PURE__ */ v.jsx("div", { className: "flex items-center justify-center h-full m-auto p-4", children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col items-center gap-3", children: [
  /* @__PURE__ */ v.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-primary" }),
  /* @__PURE__ */ v.jsx("p", { className: "text-sm text-muted-foreground", children: e })
] }) }), l8 = ({
  id: e,
  name: t,
  versionId: n,
  classUri: r,
  copyContent: i,
  onIsolate: o,
  onReset: s,
  onCopy: a,
  position: c = "absolute",
  buttonSize: u = "md"
}) => {
  const f = u === "sm" ? "w-3 h-3" : "w-3.5 h-3.5", h = c === "absolute" ? "absolute -top-7 left-0 inline-flex items-center gap-2 bg-popover border rounded-md shadow-lg px-1.5 py-1 z-50 cursor-pointer whitespace-nowrap" : "inline-flex items-center gap-1 ml-1", m = (x) => {
    if (x.preventDefault(), x.stopPropagation(), o)
      o();
    else {
      const w = new CustomEvent("entity-isolate", {
        detail: { id: e, name: t, classUri: r, versionId: n }
      });
      window.dispatchEvent(w), cn.success(`Isolated ${t}`);
    }
  }, g = (x) => {
    if (x.preventDefault(), x.stopPropagation(), s)
      s();
    else {
      const w = new CustomEvent("entity-reset-visibility", {
        detail: { id: e, name: t }
      });
      window.dispatchEvent(w), cn.success("Reset visibility");
    }
  }, b = (x) => {
    if (x.preventDefault(), x.stopPropagation(), a)
      a();
    else {
      const w = i || e;
      navigator.clipboard.writeText(w).then(() => {
        cn.success("Copied");
      }).catch(() => {
        cn.error("Failed to copy");
      });
    }
  };
  return /* @__PURE__ */ v.jsxs("span", { className: h, children: [
    /* @__PURE__ */ v.jsx(
      "button",
      {
        onClick: m,
        onMouseDown: (x) => x.preventDefault(),
        className: "p-0.5 hover:bg-blue-500/20 rounded transition-colors text-foreground",
        title: "Isolate",
        children: /* @__PURE__ */ v.jsx(WT, { className: f })
      }
    ),
    /* @__PURE__ */ v.jsx(
      "button",
      {
        onClick: g,
        onMouseDown: (x) => x.preventDefault(),
        className: "p-0.5 hover:bg-blue-500/20 rounded transition-colors text-foreground",
        title: "Reset visibility",
        children: /* @__PURE__ */ v.jsx(GT, { className: f })
      }
    ),
    /* @__PURE__ */ v.jsx(
      "button",
      {
        onClick: b,
        onMouseDown: (x) => x.preventDefault(),
        className: "p-0.5 hover:bg-blue-500/20 rounded transition-colors text-foreground",
        title: "Copy",
        children: /* @__PURE__ */ v.jsx(Sc, { className: f })
      }
    )
  ] });
}, iI = ({ entity: e, onClick: t, exists: n = !0, onlyText: r = !1 }) => {
  const [i, o] = C.useState(!1), s = () => {
    const h = [
      `Name: ${e.name}`,
      e.id ? `Element ID: ${e.id}` : null,
      e.versionId ? `Version ID: ${e.versionId}` : null,
      e.classUri ? `Class: ${e.classUri}` : null
    ].filter(Boolean).join(`
`);
    navigator.clipboard.writeText(h).then(() => {
      cn.success("Copied entity info");
    }).catch(() => {
      cn.error("Failed to copy");
    });
  }, a = () => {
    if (!n) {
      s();
      return;
    }
    if (!n) return;
    const h = new CustomEvent("entity-zoom-select", {
      detail: { id: e.id, name: e.name, classUri: e.classUri, versionId: e.versionId }
    });
    window.dispatchEvent(h), t && n && t(e);
  }, c = (h) => {
    if (h.preventDefault(), h.stopPropagation(), !e.id || !n) return;
    const m = new CustomEvent("entity-zoom-select", {
      detail: { id: e.id, name: e.name, classUri: e.classUri, versionId: e.versionId }
    });
    window.dispatchEvent(m);
  }, u = () => {
    if (o(!0), !e.id || !n) return;
    const h = new CustomEvent("entity-hover", {
      detail: { id: e.id, name: e.name, classUri: e.classUri, versionId: e.versionId, hover: !0 }
    });
    window.dispatchEvent(h);
  }, f = () => {
    if (o(!1), !e.id || !n) return;
    const h = new CustomEvent("entity-hover", {
      detail: { id: e.id, name: e.name, classUri: e.classUri, versionId: e.versionId, hover: !1 }
    });
    window.dispatchEvent(h);
  };
  return /* @__PURE__ */ v.jsx(Oh, { children: /* @__PURE__ */ v.jsxs(Gi, { delayDuration: 200, children: [
    /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
      "span",
      {
        className: "relative inline-block",
        onMouseEnter: u,
        onMouseLeave: f,
        children: [
          /* @__PURE__ */ v.jsxs(
            Dh,
            {
              variant: "default",
              className: at(
                // base
                "inline-flex items-center gap-1.5 mx-0.5 h-5 transition-all hover:text-green-500",
                //onlyText mode
                r ? at(
                  "bg-transparent border-0 shadow-none p-0 transition-colors cursor-pointer",
                  n ? "text-teal-600  hover:underline underline-offset-2" : "text-gray-400"
                ) : [
                  "cursor-pointer  mt-1 rounded-sm shadow-inner text-md font-medium",
                  n ? "bg-teal-900/90 text-white border-teal-600" : "bg-gray-600/50 text-gray-400 border-gray-500"
                ]
              ),
              onClick: a,
              onDoubleClick: c,
              children: [
                !r && /* @__PURE__ */ v.jsx(bZ, { className: "w-2 h-2 opacity-90 shrink-0" }),
                /* @__PURE__ */ v.jsx("span", { className: at("truncate max-w-40", r && "max-w-none"), children: e.name })
              ]
            }
          ),
          i && e.id && n && /* @__PURE__ */ v.jsx(
            l8,
            {
              id: e.id,
              name: e.name,
              versionId: e.versionId,
              classUri: e.classUri,
              position: "absolute",
              buttonSize: "md",
              onCopy: s
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ v.jsx(Bo, { side: "top", sideOffset: 20, className: "max-w-md bg-popover border shadow-lg", children: /* @__PURE__ */ v.jsxs("div", { className: "space-y-2 text-xs p-1", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-semibold text-muted-foreground min-w-20", children: "Name:" }),
        /* @__PURE__ */ v.jsx("span", { className: "text-foreground", children: e.name })
      ] }),
      e.id && /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-semibold text-muted-foreground min-w-20", children: "Element ID:" }),
        /* @__PURE__ */ v.jsx("code", { className: "bg-muted px-1.5 py-0.5 rounded text-xs font-mono break-all text-green-500", children: e.id })
      ] }),
      e.versionId && /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-semibold text-muted-foreground min-w-20", children: "Version ID:" }),
        /* @__PURE__ */ v.jsx("code", { className: "bg-muted px-1.5 py-0.5 rounded text-xs font-mono break-all", children: e.versionId })
      ] }),
      e.classUri && /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-semibold text-muted-foreground min-w-20", children: "Class:" }),
        /* @__PURE__ */ v.jsx("span", { className: "text-foreground", children: e.classUri })
      ] })
    ] }) })
  ] }) });
}, spe = ({ uuid: e, onClick: t, exists: n = !0, onlyText: r = !1 }) => {
  const [i, o] = C.useState(!1), s = () => {
    const f = window.getSelection();
    if (f && f.toString().length > 0)
      return;
    if (!n) {
      const m = new CustomEvent("copy-content-by-onclick", {
        detail: { id: e, name: e }
      });
      window.dispatchEvent(m);
      return;
    }
    const h = new CustomEvent("entity-zoom-select", {
      detail: { id: e, name: e }
    });
    window.dispatchEvent(h), t && t(e);
  }, a = (f) => {
    const h = window.getSelection();
    if (h && h.toString().length > 0 || (f.preventDefault(), f.stopPropagation(), !n)) return;
    const m = new CustomEvent("entity-zoom-select", {
      detail: { id: e, name: e }
    });
    window.dispatchEvent(m);
  }, c = () => {
    if (o(!0), !n) return;
    const f = new CustomEvent("entity-hover", {
      detail: { id: e, name: e, hover: !0 }
    });
    window.dispatchEvent(f);
  }, u = () => {
    if (o(!1), !n) return;
    const f = new CustomEvent("entity-hover", {
      detail: { id: e, name: e, hover: !1 }
    });
    window.dispatchEvent(f);
  };
  return /* @__PURE__ */ v.jsx(Oh, { children: /* @__PURE__ */ v.jsxs(Gi, { delayDuration: 200, children: [
    /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
      "span",
      {
        className: "relative inline-block",
        onMouseEnter: c,
        onMouseLeave: u,
        children: [
          /* @__PURE__ */ v.jsxs(
            "span",
            {
              className: at(
                "cursor-pointer inline-flex items-center gap-1 font-mono text-sm select-text rounded-sm transition-colors bg-accent px-1 mt-1",
                n ? "text-blue-600 hover:text-green-500" : "text-gray-400",
                !r && (n ? "underline decoration-dotted underline-offset-2" : "no-underline")
              ),
              onClick: s,
              onDoubleClick: a,
              children: [
                /* @__PURE__ */ v.jsx(XZ, { className: "w-3.5 h-3.5 shrink-0" }),
                /* @__PURE__ */ v.jsx("span", { className: "w-full select-text", children: e })
              ]
            }
          ),
          i && n && /* @__PURE__ */ v.jsx(
            l8,
            {
              id: e,
              name: e,
              copyContent: e
            }
          )
        ]
      }
    ) }),
    n && /* @__PURE__ */ v.jsx(Bo, { side: "top", sideOffset: 20, className: "max-w-md bg-popover border shadow-lg", children: /* @__PURE__ */ v.jsxs("div", { className: "space-y-2 text-xs p-1", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
        /* @__PURE__ */ v.jsx("span", { className: "font-medium text-muted-foreground min-w-20", children: "UUID:" }),
        /* @__PURE__ */ v.jsx("code", { className: "bg-muted px-1.5 py-0.5 rounded text-xs font-mono break-all", children: /* @__PURE__ */ v.jsx("span", { className: "text-sm text-green-500", children: e }) })
      ] }),
      /* @__PURE__ */ v.jsx("div", { className: "text-muted-foreground text-xs", children: "Double-click to zoom  Hover to highlight" })
    ] }) })
  ] }) });
}, rg = ({ text: e, onEntityClick: t, onlyText: n = !1 }) => {
  const { editorViewerStore: { models: { entities: r } } } = ra(), i = r?.value ?? {}, o = (w) => w in i, s = (w) => {
    const S = Object.values(i).find((_) => _?.name === w);
    return S ? {
      name: S.name,
      id: S.id,
      classUri: S.classUri
    } : null;
  }, a = /\[Name:\s*([^,\]]+?)(?:,\s*Element Id:\s*([^:\]]+?))?(?::\s*VersionId:\s*([^\]]+?))?\]/g, c = /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi, u = Object.values(i).map((w) => w?.name).filter(Boolean), f = (w) => w.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), h = u.sort((w, S) => S.length - w.length), m = [];
  let g;
  for (; (g = a.exec(e)) !== null; ) {
    const w = g[1]?.trim() || "Entity", S = g[2]?.trim() || void 0, _ = g[3]?.trim() || void 0;
    m.push({
      index: g.index,
      length: g[0].length,
      type: "entity",
      data: { name: w, id: S, versionId: _ }
    });
  }
  for (; (g = c.exec(e)) !== null; ) {
    const w = g[0];
    m.some(
      (_) => _.type === "entity" && g.index >= _.index && g.index < _.index + _.length
    ) || m.push({
      index: g.index,
      length: g[0].length,
      type: "uuid",
      data: { name: w, id: w }
    });
  }
  for (const w of h) {
    if (!w || w.length < 3) continue;
    const S = new RegExp(`\\b${f(w)}\\b`, "gi");
    let _;
    for (; (_ = S.exec(e)) !== null; )
      if (!m.some(
        (N) => _.index >= N.index && _.index < N.index + N.length
      )) {
        const N = s(w);
        N && m.push({
          index: _.index,
          length: _[0].length,
          type: "name",
          data: N
        });
      }
  }
  m.sort((w, S) => w.index - S.index);
  const b = [];
  let x = 0;
  for (const w of m)
    w.index > x && b.push(e.slice(x, w.index)), b.push({
      type: w.type,
      entity: w.data
    }), x = w.index + w.length;
  return x < e.length && b.push(e.slice(x)), /* @__PURE__ */ v.jsx(v.Fragment, { children: b.map((w, S) => {
    if (typeof w == "string")
      return /* @__PURE__ */ v.jsx("span", { children: w }, S);
    if (w.type === "name")
      return /* @__PURE__ */ v.jsx(
        iI,
        {
          entity: w.entity,
          onClick: n ? void 0 : t,
          exists: !0,
          onlyText: n
        },
        S
      );
    if (w.type === "uuid") {
      const M = o(w.entity.id);
      return /* @__PURE__ */ v.jsx(
        spe,
        {
          uuid: w.entity.id,
          onClick: n ? void 0 : () => t?.(w.entity),
          exists: typeof M == "boolean" ? M : !0,
          onlyText: n
        },
        S
      );
    }
    const _ = w.entity.id ? o(w.entity.id) : !0;
    return /* @__PURE__ */ v.jsx(
      iI,
      {
        entity: w.entity,
        onClick: n ? void 0 : t,
        exists: typeof _ == "boolean" ? _ : !0,
        onlyText: n
      },
      S
    );
  }) });
}, ape = ({
  isOpen: e,
  onThreadSelect: t,
  onNewThread: n,
  className: r
}) => {
  const [i, o] = C.useState(!1), [s, a] = C.useState(null), [c, u] = C.useState(!1), [f, h] = C.useState(null), [m, g] = C.useState(null), [b, x] = C.useState(""), [w, S] = C.useState(""), [_, M] = C.useState(
    /* @__PURE__ */ new Set()
  ), [N, P] = C.useState(
    /* @__PURE__ */ new Set()
  ), [I, O] = C.useState(null), L = C.useRef(null), {
    chatbotStore: {
      storeThreads: U,
      isNewThread: B,
      currentThreadId: G,
      threadMessages: Y,
      isLoadingThread: he
    }
  } = ra();
  C.useEffect(() => {
    e && ie();
  }, [e]), C.useEffect(() => {
    const re = U.value.map(
      (be) => String(be?.id ?? "")
    ), J = new Set(re.filter(Boolean)), xe = re.filter(
      (be) => !N.has(be)
    );
    if (xe.length > 0) {
      M(new Set(xe.map(String)));
      const be = setTimeout(() => {
        M(/* @__PURE__ */ new Set());
      }, 400);
      return () => clearTimeout(be);
    }
    (N.size !== J.size || !Array.from(J).every((be) => N.has(be))) && P(J);
  }, [U.value]), C.useEffect(() => {
    m && L.current && setTimeout(() => {
      L.current?.focus();
    }, 0);
  }, [m]);
  const ie = async () => {
    try {
      o(!0);
      const re = await o8(), J = U.value.filter((be) => be.isTemporary);
      let xe = [];
      re.ok ? xe = re.threads : (console.warn("API did not return an array, received:", re), xe = []), U.value = [...J, ...xe];
    } catch {
      U.value = [], cn.error("Failed to load conversation list, please try again later.");
    } finally {
      o(!1);
    }
  }, ne = (re, J) => {
    J.stopPropagation(), h(re), u(!0);
  }, H = async () => {
    if (f)
      try {
        a(f), await new Promise((re) => setTimeout(re, 300)), await Yhe(f), U.value = U.value.filter(
          (re) => re.id !== f
        ), G.value === f && (G.value = "", B.value = !0, O(null)), Y.value = { [f]: [] };
      } catch (re) {
        console.error("Failed to delete thread:", re), cn.error("Failed to delete conversation");
      } finally {
        u(!1), a(null), h(null), cn.success("Conversation deleted");
      }
  }, Q = () => {
    u(!1), h(null);
  }, X = () => {
    const re = rpe();
    O(re), n?.(re), t(re);
  }, Se = async (re) => {
    const J = U.value.find((xe) => xe.id === re);
    if (!J || !J.title) {
      cn.error("No title to copy");
      return;
    }
    try {
      await navigator.clipboard.writeText(J.title), cn.success("Title copied to clipboard");
    } catch (xe) {
      console.error("Failed to copy title:", xe), cn.error("Failed to copy title");
    }
  }, W = (re) => {
    const J = U.value.find((xe) => xe.id === re);
    if (J) {
      const xe = J.title || "";
      g(re), x(xe), S(xe);
    }
  }, Z = async (re) => {
    const J = b.trim();
    if (!J) {
      cn.error("Title cannot be empty"), pe();
      return;
    }
    if (J === w.trim()) {
      pe();
      return;
    }
    try {
      await Xhe(re, J);
      const xe = U.value.map(
        (be) => be.id === re ? { ...be, title: J } : be
      );
      U.value = xe, g(null), x(""), S(""), cn.success("Conversation renamed successfully");
    } catch (xe) {
      console.error("Failed to rename thread:", xe), cn.error("Failed to rename conversation");
    }
  }, pe = () => {
    g(null), x(""), S("");
  }, F = (re) => {
    const J = new Date(re), xe = /* @__PURE__ */ new Date(), be = new Date(xe.getFullYear(), xe.getMonth(), xe.getDate()), Ae = new Date(
      J.getFullYear(),
      J.getMonth(),
      J.getDate()
    ), tt = new Date(be);
    tt.setDate(tt.getDate() - 1);
    const Ge = be.getTime() - Ae.getTime(), nt = Math.floor(Ge / (1e3 * 60 * 60 * 24));
    return nt === 0 ? "Today" : nt === 1 ? "Yesterday" : nt < 7 ? "Last 7 days" : nt < 30 ? "Last 30 days" : "Older";
  }, ee = (re) => {
    const J = {
      Today: [],
      Yesterday: [],
      "Last 7 days": [],
      "Last 30 days": [],
      Older: []
    };
    return re.forEach((xe) => {
      const be = F(xe.updatedAt);
      J[be].push(xe);
    }), J;
  }, ge = C.useMemo(() => {
    const re = U.value;
    return window.addThreadToSidebar = re, ee(re);
  }, [U.value, B.value, i]);
  return e ? /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
    /* @__PURE__ */ v.jsx(
      ope,
      {
        open: c,
        onConfirm: H,
        onCancel: Q
      }
    ),
    /* @__PURE__ */ v.jsx(Oh, { delayDuration: 50, children: /* @__PURE__ */ v.jsxs(
      "div",
      {
        className: at(
          " h-full flex flex-col bg-background border-r border-border",
          r
        ),
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "w-full p-4 border-b border-border shrink-0", children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-2 flex-wrap", children: [
              /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ v.jsx(SD, { className: "h-5 w-5 text-blue-500" }),
                /* @__PURE__ */ v.jsx("h3", { className: "font-semibold text-foreground", children: "Conversations" })
              ] }),
              /* @__PURE__ */ v.jsxs(Gi, { children: [
                /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsx(
                  Ht,
                  {
                    variant: "ghost",
                    size: "icon",
                    className: "h-4 w-4 p-1 text-revert transition-colors hover:bg-blue-100 hover:text-blue-600 dark:hover:bg-blue-950/20 cursor-pointer",
                    onClick: X,
                    disabled: i,
                    "aria-label": "Create new conversation",
                    children: /* @__PURE__ */ v.jsx(SY, { className: "h-4 w-4" })
                  }
                ) }),
                /* @__PURE__ */ v.jsx(Bo, { children: "Create new conversation" })
              ] })
            ] }),
            /* @__PURE__ */ v.jsxs("p", { className: "text-sm text-muted-foreground mt-1", children: [
              U.value.length,
              " saved conversations"
            ] })
          ] }),
          /* @__PURE__ */ v.jsx("div", { className: "flex-1 w-full min-h-0", children: /* @__PURE__ */ v.jsx(JT, { className: "h-full w-full", children: i ? /* @__PURE__ */ v.jsx(a8, { message: "Loading conversations..." }) : U.value.length === 0 ? /* @__PURE__ */ v.jsxs("div", { className: "p-4 text-center text-muted-foreground", children: [
            /* @__PURE__ */ v.jsx(SD, { className: "h-12 w-12 mx-auto mb-2 opacity-50" }),
            /* @__PURE__ */ v.jsx("p", { children: "No conversations yet" }),
            /* @__PURE__ */ v.jsx("p", { className: "text-xs mt-1", children: "Start chatting to create your first conversation" })
          ] }) : /* @__PURE__ */ v.jsx("div", { className: "w-full px-2 py-1 ", children: Object.entries(ge).map(
            ([re, J]) => J.length === 0 ? null : /* @__PURE__ */ v.jsxs("div", { className: "mb-4 w-full ", children: [
              /* @__PURE__ */ v.jsx("h5", { className: "text-xs font-semibold text-muted-foreground px-3 py-2 uppercase tracking-wide", children: re }),
              J.map((xe) => /* @__PURE__ */ v.jsx(
                "div",
                {
                  className: at(
                    "group relative w-full p-2 rounded-lg cursor-pointer transition-all duration-300 ",
                    "hover:bg-blue-50/80 hover:shadow-sm ",
                    "dark:hover:bg-blue-950/30",
                    I === xe.id || G.value === xe.id ? "bg-blue-50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800 shadow-sm" : "border border-transparent",
                    s === xe.id && "animate-slideOutLeft opacity-0 scale-95",
                    _.has(xe.id) && "animate-slideInLeft"
                  ),
                  onClick: () => {
                    O(xe.id), t(xe.id);
                  },
                  children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-start justify-between gap-2 w-full min-w-0", children: [
                    /* @__PURE__ */ v.jsx(
                      "div",
                      {
                        className: "flex-1 min-w-0 overflow-visible p-0",
                        onDoubleClick: (be) => {
                          be.stopPropagation(), he.value || W(xe.id);
                        },
                        children: /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-2 mb-1 w-full ", children: m === xe.id ? /* @__PURE__ */ v.jsx(
                          sM,
                          {
                            ref: L,
                            type: "text",
                            value: b,
                            onChange: (be) => x(be.target.value),
                            onBlur: () => {
                              Z(xe.id);
                            },
                            onKeyDown: (be) => {
                              be.key === "Enter" ? (be.preventDefault(), Z(xe.id)) : be.key === "Escape" && (be.preventDefault(), pe());
                            },
                            onClick: (be) => be.stopPropagation(),
                            className: "h-9 text-sm font-semibold px-2 py-1 border-blue-400 focus:border-blue-500 focus:ring-blue-500 dark:border-blue-600 dark:focus:border-blue-500",
                            autoFocus: !0
                          }
                        ) : (
                          // Thread title
                          /* @__PURE__ */ v.jsx("div", { className: "text-ellipsis text-sm text-foreground break-all cursor-pointer w-full hover:bg-inherit dark:hover:bg-neutral-800/50 rounded transition-colors", children: /* @__PURE__ */ v.jsx(rg, { text: xe.title || "New conversation", onlyText: !0 }) })
                        ) })
                      }
                    ),
                    /* @__PURE__ */ v.jsxs(Qu, { children: [
                      /* @__PURE__ */ v.jsx(ed, { asChild: !0, children: /* @__PURE__ */ v.jsx(
                        Ht,
                        {
                          variant: "ghost",
                          size: "icon",
                          className: at(
                            "h-6 w-6 shrink-0 opacity-0 group-hover:opacity-100 transition-opacity",
                            "hover:bg-neutral-200 dark:hover:bg-neutral-700"
                          ),
                          onClick: (be) => be.stopPropagation(),
                          children: /* @__PURE__ */ v.jsx(IZ, { className: "h-4 w-4" })
                        }
                      ) }),
                      /* @__PURE__ */ v.jsxs(
                        td,
                        {
                          align: "end",
                          className: "w-48",
                          children: [
                            /* @__PURE__ */ v.jsxs(
                              ls,
                              {
                                onClick: (be) => {
                                  be.stopPropagation(), Se(xe.id);
                                },
                                className: "cursor-pointer",
                                children: [
                                  /* @__PURE__ */ v.jsx(Sc, { className: "h-4 w-4 mr-2" }),
                                  "Copy conversation"
                                ]
                              }
                            ),
                            /* @__PURE__ */ v.jsxs(
                              ls,
                              {
                                onClick: (be) => {
                                  be.stopPropagation(), W(xe.id);
                                },
                                className: "cursor-pointer",
                                children: [
                                  /* @__PURE__ */ v.jsx($Y, { className: "h-4 w-4 mr-2" }),
                                  "Rename"
                                ]
                              }
                            ),
                            /* @__PURE__ */ v.jsxs(
                              ls,
                              {
                                onClick: (be) => {
                                  be.stopPropagation(), ne(xe.id, be);
                                },
                                className: "cursor-pointer text-red-600 focus:text-red-600 dark:text-red-400 dark:focus:text-red-400",
                                disabled: s === xe.id,
                                children: [
                                  /* @__PURE__ */ v.jsx(W3, { className: "h-4 w-4 mr-2" }),
                                  "Delete"
                                ]
                              }
                            )
                          ]
                        }
                      )
                    ] })
                  ] })
                },
                xe.id
              ))
            ] }, re)
          ) }) }) })
        ]
      }
    ) })
  ] }) : null;
}, lpe = (e) => {
  const { setMessages: t } = e, {
    chatbotStore: {
      fetchMessagesForThread: n,
      threadMessages: r,
      setTempThread: i,
      isLoadingThread: o,
      // loadThreadList,
      isNewThread: s,
      currentThreadId: a
    },
    chatbotThreadStore: { threadMentions: c }
  } = ra();
  return {
    handleThreadSelect: async (h) => {
      if (a.value !== h)
        try {
          if (c.value = {}, e.stop?.(), a.value = h, Object.prototype.hasOwnProperty.call(
            r.value,
            h
          )) {
            s.value = ng(h), o.value = !1, t(r.value[h] || []);
            return;
          }
          t([]), o.value = !0, await n(h);
          const g = r.value[h] || [];
          t(g);
        } catch (m) {
          console.error("Failed to select thread:", m), cn.error("Failed to load conversation");
        }
    },
    handleNewThread: (h) => {
      ng(h) && (i(h), c.value = {});
    }
  };
};
class cpe {
  steps = [];
  currentThreadId = null;
  displaySteps = mD([]);
  isEnabled = mD(!0);
  // Control flag to enable/disable logging
  // Store steps history for each message
  messageStepsHistory = /* @__PURE__ */ new Map();
  currentMessageId = null;
  maxMessageHistory = 50;
  startLogging(t, n) {
    this.currentThreadId = t, this.currentMessageId = n || `msg-${Date.now()}`, this.steps = [], this.displaySteps.value = [], this.log("start", { threadId: t, messageId: this.currentMessageId });
  }
  log(t, n) {
    if (!this.isEnabled.value) return;
    if (t === "chunk") {
      this.updateDisplaySteps(t, n);
      return;
    }
    const r = {
      timestamp: Date.now(),
      type: t,
      data: n
    };
    this.steps.push(r), console.log(
      `${{
        start: "",
        planning: "",
        tool_call: "",
        tool_result: "",
        chunk: "",
        finish: "",
        error: ""
      }[t]} [AI Step - ${t.toUpperCase()}]`,
      n
    ), this.updateDisplaySteps(t, n);
  }
  updateDisplaySteps(t, n) {
    const r = [...this.displaySteps.value];
    switch (t) {
      case "start":
        this.displaySteps.value = [{
          id: `step-${Date.now()}`,
          type: "processing",
          message: "Starting AI processing...",
          timestamp: Date.now()
        }];
        break;
      case "planning":
        r.push({
          id: `step-${Date.now()}`,
          type: "processing",
          message: " Planning strategy...",
          details: n.strategy || n.message,
          timestamp: Date.now()
        }), this.displaySteps.value = r;
        break;
      case "tool_call":
        const o = {
          read_file: " Reading file",
          write_file: " Writing file",
          grep_search: " Searching code",
          semantic_search: " Semantic search",
          replace_string_in_file: " Editing file",
          run_in_terminal: " Running command",
          file_search: " Finding files",
          get_errors: " Checking errors",
          list_dir: " Listing directory"
        }[n.toolName] || ` ${n.toolName}`, s = n.args?.filePath || n.args?.query || n.args?.command || (n.args ? Object.keys(n.args).join(", ") : "");
        r.push({
          id: `step-${Date.now()}`,
          type: "tool_call",
          message: o,
          details: s ? String(s).substring(0, 60) : void 0,
          timestamp: Date.now()
        }), this.displaySteps.value = r;
        break;
      case "tool_result":
        for (let c = r.length - 1; c >= 0; c--)
          if (r[c].type === "tool_call") {
            r[c] = {
              ...r[c],
              type: "complete"
            };
            break;
          }
        this.displaySteps.value = r;
        break;
      case "chunk":
        const a = r.findIndex((c) => c.type === "processing");
        a !== -1 && (r[a] = {
          ...r[a],
          message: "Generating response...",
          details: n.content ? n.content.substring(0, 50) + "..." : void 0
        }, this.displaySteps.value = r);
        break;
      case "finish":
        r.push({
          id: `step-${Date.now()}`,
          type: "complete",
          message: "Response completed",
          details: n.usage ? `Tokens: ${n.usage.totalTokens || "N/A"}` : void 0,
          timestamp: Date.now()
        }), this.displaySteps.value = r, this.currentMessageId && (this.messageStepsHistory.set(this.currentMessageId, [...r]), this.pruneMessageHistory()), setTimeout(() => {
          this.displaySteps.value = [];
        }, 3e3);
        break;
      case "error":
        r.push({
          id: `step-${Date.now()}`,
          type: "error",
          message: "Error occurred",
          details: n.message,
          timestamp: Date.now()
        }), this.displaySteps.value = r;
        break;
    }
  }
  getSteps() {
    return this.steps;
  }
  exportSteps() {
    return {
      threadId: this.currentThreadId,
      steps: this.steps,
      duration: this.steps.length > 0 ? this.steps[this.steps.length - 1].timestamp - this.steps[0].timestamp : 0
    };
  }
  clear() {
    this.steps = [], this.currentThreadId = null, this.displaySteps.value = [];
  }
  // Methods to enable/disable the UI logger
  enable() {
    this.isEnabled.value = !0;
  }
  disable() {
    this.isEnabled.value = !1, this.displaySteps.value = [];
  }
  toggle() {
    this.isEnabled.value = !this.isEnabled.value, this.isEnabled.value || (this.displaySteps.value = []);
  }
  // Log planning/strategy step
  logPlanning(t) {
    this.log("planning", { strategy: t });
  }
  // Log with custom message
  logCustomStep(t, n) {
    const r = [...this.displaySteps.value];
    r.push({
      id: `step-${Date.now()}`,
      type: "processing",
      message: t,
      details: n,
      timestamp: Date.now()
    }), this.displaySteps.value = r;
  }
  // Get steps history for a specific message
  getMessageSteps(t) {
    return this.messageStepsHistory.get(t);
  }
  // Get all steps history
  getAllMessageSteps() {
    return this.messageStepsHistory;
  }
  // Format steps as text for display
  formatStepsAsText(t) {
    const n = this.messageStepsHistory.get(t);
    return !n || n.length === 0 ? "" : n.filter((r) => r.type !== "processing").map((r) => `${r.type === "complete" ? "" : r.type === "error" ? "" : ""} ${r.message}${r.details ? ` (${r.details})` : ""}`).join(`
`);
  }
  // Clear specific message history
  clearMessageHistory(t) {
    this.messageStepsHistory.delete(t);
  }
  // Clear all history
  clearAllHistory() {
    this.messageStepsHistory.clear();
  }
  pruneMessageHistory() {
    for (; this.messageStepsHistory.size > this.maxMessageHistory; ) {
      const t = this.messageStepsHistory.keys().next().value;
      if (!t) break;
      this.messageStepsHistory.delete(t);
    }
  }
}
const La = new cpe(), upe = (e) => {
  let t = !1;
  return {
    onStart: (n) => {
      t = !1, La.startLogging(e, n);
    },
    onToolCall: (n) => {
      t || (La.startLogging(e, n.toolCallId), t = !0), La.log("tool_call", {
        toolCallId: n.toolCallId,
        toolName: n.toolName,
        args: n.args
      });
    },
    onChunk: (n) => {
      !t && n?.delta?.content && (La.startLogging(e), t = !0), n?.delta?.content && La.log("chunk", {
        content: n.delta.content,
        role: n.delta.role
      });
    },
    onFinish: (n) => {
      La.log("finish", {
        messageId: n.id,
        finishReason: n.finishReason,
        usage: n.usage,
        toolCalls: n.toolCalls?.length || 0
      });
      const r = La.exportSteps();
      console.log(" AI Execution Summary:", r), t = !1;
    },
    onError: (n) => {
      La.log("error", {
        message: n.message,
        stack: n.stack
      }), t = !1;
    }
  };
}, dpe = (e, t, n, r) => {
  const i = C.useRef(null), o = C.useRef(null), s = C.useRef(null), a = C.useRef(null), c = C.useCallback((u = !0) => {
    requestAnimationFrame(() => {
      const f = i.current?.querySelector("[data-radix-scroll-area-viewport]");
      f && f.scrollTo({
        top: f.scrollHeight,
        behavior: u ? "smooth" : "auto"
      });
    });
  }, []);
  return C.useEffect(() => {
    if (!n || !r || !s.current) return;
    a.current && a.current.disconnect();
    const u = i.current?.querySelector("[data-radix-scroll-area-viewport]");
    return a.current = new IntersectionObserver(
      (f) => {
        f[0].isIntersecting && n();
      },
      {
        root: u,
        rootMargin: "100px",
        threshold: 0.1
      }
    ), a.current.observe(s.current), () => a.current?.disconnect();
  }, [n, r]), C.useEffect(() => {
    e.length > 0 && !t && c(!1);
  }, [e.length, t, c]), {
    scrollAreaRef: i,
    containerRef: o,
    topSentinelRef: s,
    scrollToBottom: c
  };
};
var O0 = { exports: {} }, fpe = O0.exports, oI;
function hpe() {
  return oI || (oI = 1, (function(e, t) {
    ((n, r) => {
      e.exports = r();
    })(fpe, function() {
      var n = function(k, A) {
        return (n = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? function(R, D) {
          R.__proto__ = D;
        } : function(R, D) {
          for (var z in D) Object.prototype.hasOwnProperty.call(D, z) && (R[z] = D[z]);
        }))(k, A);
      }, r = function() {
        return (r = Object.assign || function(k) {
          for (var A, R = 1, D = arguments.length; R < D; R++) for (var z in A = arguments[R]) Object.prototype.hasOwnProperty.call(A, z) && (k[z] = A[z]);
          return k;
        }).apply(this, arguments);
      };
      function i(k, A, R) {
        for (var D, z = 0, $ = A.length; z < $; z++) !D && z in A || ((D = D || Array.prototype.slice.call(A, 0, z))[z] = A[z]);
        return k.concat(D || Array.prototype.slice.call(A));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : PK, s = Object.keys, a = Array.isArray;
      function c(k, A) {
        return typeof A == "object" && s(A).forEach(function(R) {
          k[R] = A[R];
        }), k;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var u = Object.getPrototypeOf, f = {}.hasOwnProperty;
      function h(k, A) {
        return f.call(k, A);
      }
      function m(k, A) {
        typeof A == "function" && (A = A(u(k))), (typeof Reflect > "u" ? s : Reflect.ownKeys)(A).forEach(function(R) {
          b(k, R, A[R]);
        });
      }
      var g = Object.defineProperty;
      function b(k, A, R, D) {
        g(k, A, c(R && h(R, "get") && typeof R.get == "function" ? { get: R.get, set: R.set, configurable: !0 } : { value: R, configurable: !0, writable: !0 }, D));
      }
      function x(k) {
        return { from: function(A) {
          return k.prototype = Object.create(A.prototype), b(k.prototype, "constructor", k), { extend: m.bind(null, k.prototype) };
        } };
      }
      var w = Object.getOwnPropertyDescriptor, S = [].slice;
      function _(k, A, R) {
        return S.call(k, A, R);
      }
      function M(k, A) {
        return A(k);
      }
      function N(k) {
        if (!k) throw new Error("Assertion Failed");
      }
      function P(k) {
        o.setImmediate ? setImmediate(k) : setTimeout(k, 0);
      }
      function I(k, A) {
        if (typeof A == "string" && h(k, A)) return k[A];
        if (!A) return k;
        if (typeof A != "string") {
          for (var R = [], D = 0, z = A.length; D < z; ++D) {
            var $ = I(k, A[D]);
            R.push($);
          }
          return R;
        }
        var q, K = A.indexOf(".");
        return K === -1 || (q = k[A.substr(0, K)]) == null ? void 0 : I(q, A.substr(K + 1));
      }
      function O(k, A, R) {
        if (k && A !== void 0 && !("isFrozen" in Object && Object.isFrozen(k))) if (typeof A != "string" && "length" in A) {
          N(typeof R != "string" && "length" in R);
          for (var D = 0, z = A.length; D < z; ++D) O(k, A[D], R[D]);
        } else {
          var $, q, K = A.indexOf(".");
          K !== -1 ? ($ = A.substr(0, K), (K = A.substr(K + 1)) === "" ? R === void 0 ? a(k) && !isNaN(parseInt($)) ? k.splice($, 1) : delete k[$] : k[$] = R : O(q = (q = k[$]) && h(k, $) ? q : k[$] = {}, K, R)) : R === void 0 ? a(k) && !isNaN(parseInt(A)) ? k.splice(A, 1) : delete k[A] : k[A] = R;
        }
      }
      function L(k) {
        var A, R = {};
        for (A in k) h(k, A) && (R[A] = k[A]);
        return R;
      }
      var U = [].concat;
      function B(k) {
        return U.apply([], k);
      }
      var pe = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(B([8, 16, 32, 64].map(function(k) {
        return ["Int", "Uint", "Float"].map(function(A) {
          return A + k + "Array";
        });
      }))).filter(function(k) {
        return o[k];
      }), G = new Set(pe.map(function(k) {
        return o[k];
      })), Y = null;
      function he(k) {
        return Y = /* @__PURE__ */ new WeakMap(), k = (function A(R) {
          if (!R || typeof R != "object") return R;
          var D = Y.get(R);
          if (D) return D;
          if (a(R)) {
            D = [], Y.set(R, D);
            for (var z = 0, $ = R.length; z < $; ++z) D.push(A(R[z]));
          } else if (G.has(R.constructor)) D = R;
          else {
            var q, K = u(R);
            for (q in D = K === Object.prototype ? {} : Object.create(K), Y.set(R, D), R) h(R, q) && (D[q] = A(R[q]));
          }
          return D;
        })(k), Y = null, k;
      }
      var ie = {}.toString;
      function ne(k) {
        return ie.call(k).slice(8, -1);
      }
      var H = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Q = typeof H == "symbol" ? function(k) {
        var A;
        return k != null && (A = k[H]) && A.apply(k);
      } : function() {
        return null;
      };
      function X(k, A) {
        A = k.indexOf(A), 0 <= A && k.splice(A, 1);
      }
      var Se = {};
      function W(k) {
        var A, R, D, z;
        if (arguments.length === 1) {
          if (a(k)) return k.slice();
          if (this === Se && typeof k == "string") return [k];
          if (z = Q(k)) for (R = []; !(D = z.next()).done; ) R.push(D.value);
          else {
            if (k == null) return [k];
            if (typeof (A = k.length) != "number") return [k];
            for (R = new Array(A); A--; ) R[A] = k[A];
          }
        } else for (A = arguments.length, R = new Array(A); A--; ) R[A] = arguments[A];
        return R;
      }
      var Z = typeof Symbol < "u" ? function(k) {
        return k[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, pe = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], ke = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(pe), F = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function ee(k, A) {
        this.name = k, this.message = A;
      }
      function ge(k, A) {
        return k + ". Errors: " + Object.keys(A).map(function(R) {
          return A[R].toString();
        }).filter(function(R, D, z) {
          return z.indexOf(R) === D;
        }).join(`
`);
      }
      function re(k, A, R, D) {
        this.failures = A, this.failedKeys = D, this.successCount = R, this.message = ge(k, A);
      }
      function J(k, A) {
        this.name = "BulkError", this.failures = Object.keys(A).map(function(R) {
          return A[R];
        }), this.failuresByPos = A, this.message = ge(k, this.failures);
      }
      x(ee).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), x(re).from(ee), x(J).from(ee);
      var xe = ke.reduce(function(k, A) {
        return k[A] = A + "Error", k;
      }, {}), be = ee, Ae = ke.reduce(function(k, A) {
        var R = A + "Error";
        function D(z, $) {
          this.name = R, z ? typeof z == "string" ? (this.message = "".concat(z).concat($ ? `
 ` + $ : ""), this.inner = $ || null) : typeof z == "object" && (this.message = "".concat(z.name, " ").concat(z.message), this.inner = z) : (this.message = F[A] || R, this.inner = null);
        }
        return x(D).from(be), k[A] = D, k;
      }, {}), tt = (Ae.Syntax = SyntaxError, Ae.Type = TypeError, Ae.Range = RangeError, pe.reduce(function(k, A) {
        return k[A + "Error"] = Ae[A], k;
      }, {}));
      pe = ke.reduce(function(k, A) {
        return ["Syntax", "Type", "Range"].indexOf(A) === -1 && (k[A + "Error"] = Ae[A]), k;
      }, {});
      function Ge() {
      }
      function nt(k) {
        return k;
      }
      function _t(k, A) {
        return k == null || k === nt ? A : function(R) {
          return A(k(R));
        };
      }
      function yn(k, A) {
        return function() {
          k.apply(this, arguments), A.apply(this, arguments);
        };
      }
      function St(k, A) {
        return k === Ge ? A : function() {
          var R = k.apply(this, arguments), D = (R !== void 0 && (arguments[0] = R), this.onsuccess), z = this.onerror, $ = (this.onsuccess = null, this.onerror = null, A.apply(this, arguments));
          return D && (this.onsuccess = this.onsuccess ? yn(D, this.onsuccess) : D), z && (this.onerror = this.onerror ? yn(z, this.onerror) : z), $ !== void 0 ? $ : R;
        };
      }
      function Vt(k, A) {
        return k === Ge ? A : function() {
          k.apply(this, arguments);
          var R = this.onsuccess, D = this.onerror;
          this.onsuccess = this.onerror = null, A.apply(this, arguments), R && (this.onsuccess = this.onsuccess ? yn(R, this.onsuccess) : R), D && (this.onerror = this.onerror ? yn(D, this.onerror) : D);
        };
      }
      function xt(k, A) {
        return k === Ge ? A : function(z) {
          var D = k.apply(this, arguments), z = (c(z, D), this.onsuccess), $ = this.onerror, q = (this.onsuccess = null, this.onerror = null, A.apply(this, arguments));
          return z && (this.onsuccess = this.onsuccess ? yn(z, this.onsuccess) : z), $ && (this.onerror = this.onerror ? yn($, this.onerror) : $), D === void 0 ? q === void 0 ? void 0 : q : c(D, q);
        };
      }
      function Kt(k, A) {
        return k === Ge ? A : function() {
          return A.apply(this, arguments) !== !1 && k.apply(this, arguments);
        };
      }
      function An(k, A) {
        return k === Ge ? A : function() {
          var R = k.apply(this, arguments);
          if (R && typeof R.then == "function") {
            for (var D = this, z = arguments.length, $ = new Array(z); z--; ) $[z] = arguments[z];
            return R.then(function() {
              return A.apply(D, $);
            });
          }
          return A.apply(this, arguments);
        };
      }
      pe.ModifyError = re, pe.DexieError = ee, pe.BulkError = J;
      var Nt = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function sn(k) {
        Nt = k;
      }
      var Pn = {}, Mn = 100, mt = typeof Promise > "u" ? [] : (ke = Promise.resolve(), typeof crypto < "u" && crypto.subtle ? [mt = crypto.subtle.digest("SHA-512", new Uint8Array([0])), u(mt), ke] : [ke, u(ke), ke]), ke = mt[0], ga = mt[1], ga = ga && ga.then, Pe = ke && ke.constructor, He = !!mt[2], et = function(k, A) {
        Ii.push([k, A]), Ct && (queueMicrotask(uy), Ct = !1);
      }, bt = !0, Ct = !0, fn = [], Lt = [], nn = nt, jn = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Ge, pgp: !1, env: {}, finalize: Ge }, Ve = jn, Ii = [], Ar = 0, yd = [];
      function Ke(k) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var A = this._PSD = Ve;
        if (typeof k != "function") {
          if (k !== Pn) throw new TypeError("Not a function");
          this._state = arguments[1], this._value = arguments[2], this._state === !1 && Ko(this, this._value);
        } else this._state = null, this._value = null, ++A.ref, (function R(D, z) {
          try {
            z(function($) {
              if (D._state === null) {
                if ($ === D) throw new TypeError("A promise cannot be resolved with itself.");
                var q = D._lib && ys();
                $ && typeof $.then == "function" ? R(D, function(K, se) {
                  $ instanceof Ke ? $._then(K, se) : $.then(K, se);
                }) : (D._state = !0, D._value = $, qc(D)), q && yo();
              }
            }, Ko.bind(null, D));
          } catch ($) {
            Ko(D, $);
          }
        })(this, k);
      }
      var sl = { get: function() {
        var k = Ve, A = Zc;
        function R(D, z) {
          var $ = this, q = !k.global && (k !== Ve || A !== Zc), K = q && !wi(), se = new Ke(function(ye, ae) {
            oa($, new Wc(vd(D, k, q, K), vd(z, k, q, K), ye, ae, k));
          });
          return this._consoleTask && (se._consoleTask = this._consoleTask), se;
        }
        return R.prototype = Pn, R;
      }, set: function(k) {
        b(this, "then", k && k.prototype === Pn ? sl : { get: function() {
          return k;
        }, set: sl.set });
      } };
      function Wc(k, A, R, D, z) {
        this.onFulfilled = typeof k == "function" ? k : null, this.onRejected = typeof A == "function" ? A : null, this.resolve = R, this.reject = D, this.psd = z;
      }
      function Ko(k, A) {
        var R, D;
        Lt.push(A), k._state === null && (R = k._lib && ys(), A = nn(A), k._state = !1, k._value = A, D = k, fn.some(function(z) {
          return z._value === D._value;
        }) || fn.push(D), qc(k), R) && yo();
      }
      function qc(k) {
        var A = k._listeners;
        k._listeners = [];
        for (var R = 0, D = A.length; R < D; ++R) oa(k, A[R]);
        var z = k._PSD;
        --z.ref || z.finalize(), Ar === 0 && (++Ar, et(function() {
          --Ar == 0 && Wh();
        }, []));
      }
      function oa(k, A) {
        if (k._state === null) k._listeners.push(A);
        else {
          var R = k._state ? A.onFulfilled : A.onRejected;
          if (R === null) return (k._state ? A.resolve : A.reject)(k._value);
          ++A.psd.ref, ++Ar, et(h1, [R, k, A]);
        }
      }
      function h1(k, A, R) {
        try {
          var D, z = A._value;
          !A._state && Lt.length && (Lt = []), D = Nt && A._consoleTask ? A._consoleTask.run(function() {
            return k(z);
          }) : k(z), A._state || Lt.indexOf(z) !== -1 || (($) => {
            for (var q = fn.length; q; ) if (fn[--q]._value === $._value) return fn.splice(q, 1);
          })(A), R.resolve(D);
        } catch ($) {
          R.reject($);
        } finally {
          --Ar == 0 && Wh(), --R.psd.ref || R.psd.finalize();
        }
      }
      function uy() {
        Xi(jn, function() {
          ys() && yo();
        });
      }
      function ys() {
        var k = bt;
        return Ct = bt = !1, k;
      }
      function yo() {
        var k, A, R;
        do
          for (; 0 < Ii.length; ) for (k = Ii, Ii = [], R = k.length, A = 0; A < R; ++A) {
            var D = k[A];
            D[0].apply(null, D[1]);
          }
        while (0 < Ii.length);
        Ct = bt = !0;
      }
      function Wh() {
        for (var k = fn, A = (fn = [], k.forEach(function(D) {
          D._PSD.onunhandled.call(null, D._value, D);
        }), yd.slice(0)), R = A.length; R; ) A[--R]();
      }
      function Gc(k) {
        return new Ke(Pn, !1, k);
      }
      function kn(k, A) {
        var R = Ve;
        return function() {
          var D = ys(), z = Ve;
          try {
            return bs(R, !0), k.apply(this, arguments);
          } catch ($) {
            A && A($);
          } finally {
            bs(z, !1), D && yo();
          }
        };
      }
      m(Ke.prototype, { then: sl, _then: function(k, A) {
        oa(this, new Wc(null, null, k, A, Ve));
      }, catch: function(k) {
        var A, R;
        return arguments.length === 1 ? this.then(null, k) : (A = k, R = arguments[1], typeof A == "function" ? this.then(null, function(D) {
          return (D instanceof A ? R : Gc)(D);
        }) : this.then(null, function(D) {
          return (D && D.name === A ? R : Gc)(D);
        }));
      }, finally: function(k) {
        return this.then(function(A) {
          return Ke.resolve(k()).then(function() {
            return A;
          });
        }, function(A) {
          return Ke.resolve(k()).then(function() {
            return Gc(A);
          });
        });
      }, timeout: function(k, A) {
        var R = this;
        return k < 1 / 0 ? new Ke(function(D, z) {
          var $ = setTimeout(function() {
            return z(new Ae.Timeout(A));
          }, k);
          R.then(D, z).finally(clearTimeout.bind(null, $));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && b(Ke.prototype, Symbol.toStringTag, "Dexie.Promise"), jn.env = Gh(), m(Ke, { all: function() {
        var k = W.apply(null, arguments).map(ll);
        return new Ke(function(A, R) {
          k.length === 0 && A([]);
          var D = k.length;
          k.forEach(function(z, $) {
            return Ke.resolve(z).then(function(q) {
              k[$] = q, --D || A(k);
            }, R);
          });
        });
      }, resolve: function(k) {
        return k instanceof Ke ? k : k && typeof k.then == "function" ? new Ke(function(A, R) {
          k.then(A, R);
        }) : new Ke(Pn, !0, k);
      }, reject: Gc, race: function() {
        var k = W.apply(null, arguments).map(ll);
        return new Ke(function(A, R) {
          k.map(function(D) {
            return Ke.resolve(D).then(A, R);
          });
        });
      }, PSD: { get: function() {
        return Ve;
      }, set: function(k) {
        return Ve = k;
      } }, totalEchoes: { get: function() {
        return Zc;
      } }, newPSD: Nn, usePSD: Xi, scheduler: { get: function() {
        return et;
      }, set: function(k) {
        et = k;
      } }, rejectionMapper: { get: function() {
        return nn;
      }, set: function(k) {
        nn = k;
      } }, follow: function(k, A) {
        return new Ke(function(R, D) {
          return Nn(function(z, $) {
            var q = Ve;
            q.unhandleds = [], q.onunhandled = $, q.finalize = yn(function() {
              var K, se = this;
              K = function() {
                se.unhandleds.length === 0 ? z() : $(se.unhandleds[0]);
              }, yd.push(function ye() {
                K(), yd.splice(yd.indexOf(ye), 1);
              }), ++Ar, et(function() {
                --Ar == 0 && Wh();
              }, []);
            }, q.finalize), k();
          }, A, R, D);
        });
      } }), Pe && (Pe.allSettled && b(Ke, "allSettled", function() {
        var k = W.apply(null, arguments).map(ll);
        return new Ke(function(A) {
          k.length === 0 && A([]);
          var R = k.length, D = new Array(R);
          k.forEach(function(z, $) {
            return Ke.resolve(z).then(function(q) {
              return D[$] = { status: "fulfilled", value: q };
            }, function(q) {
              return D[$] = { status: "rejected", reason: q };
            }).then(function() {
              return --R || A(D);
            });
          });
        });
      }), Pe.any && typeof AggregateError < "u" && b(Ke, "any", function() {
        var k = W.apply(null, arguments).map(ll);
        return new Ke(function(A, R) {
          k.length === 0 && R(new AggregateError([]));
          var D = k.length, z = new Array(D);
          k.forEach(function($, q) {
            return Ke.resolve($).then(function(K) {
              return A(K);
            }, function(K) {
              z[q] = K, --D || R(new AggregateError(z));
            });
          });
        });
      }), Pe.withResolvers) && (Ke.withResolvers = Pe.withResolvers);
      var sr = { awaits: 0, echoes: 0, id: 0 }, qh = 0, al = [], Kc = 0, Zc = 0, vs = 0;
      function Nn(k, q, R, D) {
        var z = Ve, $ = Object.create(z), q = ($.parent = z, $.ref = 0, $.global = !1, $.id = ++vs, jn.env, $.env = He ? { Promise: Ke, PromiseProp: { value: Ke, configurable: !0, writable: !0 }, all: Ke.all, race: Ke.race, allSettled: Ke.allSettled, any: Ke.any, resolve: Ke.resolve, reject: Ke.reject } : {}, q && c($, q), ++z.ref, $.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, Xi($, k, R, D));
        return $.ref === 0 && $.finalize(), q;
      }
      function ar() {
        return sr.id || (sr.id = ++qh), ++sr.awaits, sr.echoes += Mn, sr.id;
      }
      function wi() {
        return !!sr.awaits && (--sr.awaits == 0 && (sr.id = 0), sr.echoes = sr.awaits * Mn, !0);
      }
      function ll(k) {
        return sr.echoes && k && k.constructor === Pe ? (ar(), k.then(function(A) {
          return wi(), A;
        }, function(A) {
          return wi(), vn(A);
        })) : k;
      }
      function p1() {
        var k = al[al.length - 1];
        al.pop(), bs(k, !1);
      }
      function bs(k, A) {
        var R, D, z = Ve;
        (A ? !sr.echoes || Kc++ && k === Ve : !Kc || --Kc && k === Ve) || queueMicrotask(A ? (function($) {
          ++Zc, sr.echoes && --sr.echoes != 0 || (sr.echoes = sr.awaits = sr.id = 0), al.push(Ve), bs($, !0);
        }).bind(null, k) : p1), k !== Ve && (Ve = k, z === jn && (jn.env = Gh()), He) && (R = jn.env.Promise, D = k.env, z.global || k.global) && (Object.defineProperty(o, "Promise", D.PromiseProp), R.all = D.all, R.race = D.race, R.resolve = D.resolve, R.reject = D.reject, D.allSettled && (R.allSettled = D.allSettled), D.any) && (R.any = D.any);
      }
      function Gh() {
        var k = o.Promise;
        return He ? { Promise: k, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: k.all, race: k.race, allSettled: k.allSettled, any: k.any, resolve: k.resolve, reject: k.reject } : {};
      }
      function Xi(k, A, R, D, z) {
        var $ = Ve;
        try {
          return bs(k, !0), A(R, D, z);
        } finally {
          bs($, !1);
        }
      }
      function vd(k, A, R, D) {
        return typeof k != "function" ? k : function() {
          var z = Ve;
          R && ar(), bs(A, !0);
          try {
            return k.apply(this, arguments);
          } finally {
            bs(z, !1), D && queueMicrotask(wi);
          }
        };
      }
      function xs(k) {
        Promise === Pe && sr.echoes === 0 ? Kc === 0 ? k() : enqueueNativeMicroTask(k) : setTimeout(k, 0);
      }
      ("" + ga).indexOf("[native code]") === -1 && (ar = wi = Ge);
      var vn = Ke.reject, Ji = "", si = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", lr = "String expected.", sa = [], Yc = "__dbnames", Zo = "readonly", ws = "readwrite";
      function aa(k, A) {
        return k ? A ? function() {
          return k.apply(this, arguments) && A.apply(this, arguments);
        } : k : A;
      }
      var Kh = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Xc(k) {
        return typeof k != "string" || /\./.test(k) ? function(A) {
          return A;
        } : function(A) {
          return A[k] === void 0 && k in A && delete (A = he(A))[k], A;
        };
      }
      function dy() {
        throw Ae.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Pt(k, A) {
        try {
          var R = Jc(k), D = Jc(A);
          if (R !== D) return R === "Array" ? 1 : D === "Array" ? -1 : R === "binary" ? 1 : D === "binary" ? -1 : R === "string" ? 1 : D === "string" ? -1 : R === "Date" ? 1 : D !== "Date" ? NaN : -1;
          switch (R) {
            case "number":
            case "Date":
            case "string":
              return A < k ? 1 : k < A ? -1 : 0;
            case "binary":
              for (var z = vo(k), $ = vo(A), q = z.length, K = $.length, se = q < K ? q : K, ye = 0; ye < se; ++ye) if (z[ye] !== $[ye]) return z[ye] < $[ye] ? -1 : 1;
              return q === K ? 0 : q < K ? -1 : 1;
            case "Array":
              for (var ae = k, oe = A, ue = ae.length, fe = oe.length, le = ue < fe ? ue : fe, ce = 0; ce < le; ++ce) {
                var we = Pt(ae[ce], oe[ce]);
                if (we !== 0) return we;
              }
              return ue === fe ? 0 : ue < fe ? -1 : 1;
          }
        } catch {
        }
        return NaN;
      }
      function Jc(k) {
        var A = typeof k;
        return A == "object" && (ArrayBuffer.isView(k) || (A = ne(k)) === "ArrayBuffer") ? "binary" : A;
      }
      function vo(k) {
        return k instanceof Uint8Array ? k : ArrayBuffer.isView(k) ? new Uint8Array(k.buffer, k.byteOffset, k.byteLength) : new Uint8Array(k);
      }
      function qr(k, A, R) {
        var D = k.schema.yProps;
        return D ? (A && 0 < R.numFailures && (A = A.filter(function(z, $) {
          return !R.failures[$];
        })), Promise.all(D.map(function(z) {
          return z = z.updatesTable, A ? k.db.table(z).where("k").anyOf(A).delete() : k.db.table(z).clear();
        })).then(function() {
          return R;
        })) : R;
      }
      fy.prototype.execute = function(k) {
        var A = this["@@propmod"];
        if (A.add !== void 0) {
          var R = A.add;
          if (a(R)) return i(i([], a(k) ? k : [], !0), R).sort();
          if (typeof R == "number") return (Number(k) || 0) + R;
          if (typeof R == "bigint") try {
            return BigInt(k) + R;
          } catch {
            return BigInt(0) + R;
          }
          throw new TypeError("Invalid term ".concat(R));
        }
        if (A.remove !== void 0) {
          var D = A.remove;
          if (a(D)) return a(k) ? k.filter(function(z) {
            return !D.includes(z);
          }).sort() : [];
          if (typeof D == "number") return Number(k) - D;
          if (typeof D == "bigint") try {
            return BigInt(k) - D;
          } catch {
            return BigInt(0) - D;
          }
          throw new TypeError("Invalid subtrahend ".concat(D));
        }
        return R = (R = A.replacePrefix) == null ? void 0 : R[0], R && typeof k == "string" && k.startsWith(R) ? A.replacePrefix[1] + k.substring(R.length) : k;
      };
      var cl = fy;
      function fy(k) {
        this["@@propmod"] = k;
      }
      function bd(k, A) {
        for (var R = s(A), D = R.length, z = !1, $ = 0; $ < D; ++$) {
          var q = R[$], K = A[q], se = I(k, q);
          K instanceof cl ? (O(k, q, K.execute(se)), z = !0) : se !== K && (O(k, q, K), z = !0);
        }
        return z;
      }
      an.prototype._trans = function(k, A, R) {
        var D = this._tx || Ve.trans, z = this.name, $ = Nt && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(k === "readonly" ? "read" : "write", " ").concat(this.name));
        function q(ye, ae, oe) {
          if (oe.schema[z]) return A(oe.idbtrans, oe);
          throw new Ae.NotFound("Table " + z + " not part of transaction");
        }
        var K = ys();
        try {
          var se = D && D.db._novip === this.db._novip ? D === Ve.trans ? D._promise(k, q, R) : Nn(function() {
            return D._promise(k, q, R);
          }, { trans: D, transless: Ve.transless || Ve }) : (function ye(ae, oe, ue, fe) {
            if (ae.idbdb && (ae._state.openComplete || Ve.letThrough || ae._vip)) {
              var le = ae._createTransaction(oe, ue, ae._dbSchema);
              try {
                le.create(), ae._state.PR1398_maxLoop = 3;
              } catch (ce) {
                return ce.name === xe.InvalidState && ae.isOpen() && 0 < --ae._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), ae.close({ disableAutoOpen: !1 }), ae.open().then(function() {
                  return ye(ae, oe, ue, fe);
                })) : vn(ce);
              }
              return le._promise(oe, function(ce, we) {
                return Nn(function() {
                  return Ve.trans = le, fe(ce, we, le);
                });
              }).then(function(ce) {
                if (oe === "readwrite") try {
                  le.idbtrans.commit();
                } catch {
                }
                return oe === "readonly" ? ce : le._completion.then(function() {
                  return ce;
                });
              });
            }
            if (ae._state.openComplete) return vn(new Ae.DatabaseClosed(ae._state.dbOpenError));
            if (!ae._state.isBeingOpened) {
              if (!ae._state.autoOpen) return vn(new Ae.DatabaseClosed());
              ae.open().catch(Ge);
            }
            return ae._state.dbReadyPromise.then(function() {
              return ye(ae, oe, ue, fe);
            });
          })(this.db, k, [this.name], q);
          return $ && (se._consoleTask = $, se = se.catch(function(ye) {
            return console.trace(ye), vn(ye);
          })), se;
        } finally {
          K && yo();
        }
      }, an.prototype.get = function(k, A) {
        var R = this;
        return k && k.constructor === Object ? this.where(k).first(A) : k == null ? vn(new Ae.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(D) {
          return R.core.get({ trans: D, key: k }).then(function(z) {
            return R.hook.reading.fire(z);
          });
        }).then(A);
      }, an.prototype.where = function(k) {
        if (typeof k == "string") return new this.db.WhereClause(this, k);
        if (a(k)) return new this.db.WhereClause(this, "[".concat(k.join("+"), "]"));
        var A = s(k);
        if (A.length === 1) return this.where(A[0]).equals(k[A[0]]);
        var R = this.schema.indexes.concat(this.schema.primKey).filter(function(K) {
          if (K.compound && A.every(function(ye) {
            return 0 <= K.keyPath.indexOf(ye);
          })) {
            for (var se = 0; se < A.length; ++se) if (A.indexOf(K.keyPath[se]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(K, se) {
          return K.keyPath.length - se.keyPath.length;
        })[0];
        if (R && this.db._maxKey !== Ji) return q = R.keyPath.slice(0, A.length), this.where(q).equals(q.map(function(K) {
          return k[K];
        }));
        !R && Nt && console.warn("The query ".concat(JSON.stringify(k), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(A.join("+"), "]"));
        var D = this.schema.idxByName;
        function z(K, se) {
          return Pt(K, se) === 0;
        }
        var q = A.reduce(function(ae, se) {
          var ye = ae[0], ae = ae[1], oe = D[se], ue = k[se];
          return [ye || oe, ye || !oe ? aa(ae, oe && oe.multi ? function(fe) {
            return fe = I(fe, se), a(fe) && fe.some(function(le) {
              return z(ue, le);
            });
          } : function(fe) {
            return z(ue, I(fe, se));
          }) : ae];
        }, [null, null]), $ = q[0], q = q[1];
        return $ ? this.where($.name).equals(k[$.keyPath]).filter(q) : R ? this.filter(q) : this.where(A).equals("");
      }, an.prototype.filter = function(k) {
        return this.toCollection().and(k);
      }, an.prototype.count = function(k) {
        return this.toCollection().count(k);
      }, an.prototype.offset = function(k) {
        return this.toCollection().offset(k);
      }, an.prototype.limit = function(k) {
        return this.toCollection().limit(k);
      }, an.prototype.each = function(k) {
        return this.toCollection().each(k);
      }, an.prototype.toArray = function(k) {
        return this.toCollection().toArray(k);
      }, an.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, an.prototype.orderBy = function(k) {
        return new this.db.Collection(new this.db.WhereClause(this, a(k) ? "[".concat(k.join("+"), "]") : k));
      }, an.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, an.prototype.mapToClass = function(k) {
        for (var A = this.db, R = this.name, D = ((this.schema.mappedClass = k).prototype instanceof dy && (k = ((q) => {
          var K = ae, se = q;
          if (typeof se != "function" && se !== null) throw new TypeError("Class extends value " + String(se) + " is not a constructor or null");
          function ye() {
            this.constructor = K;
          }
          function ae() {
            return q !== null && q.apply(this, arguments) || this;
          }
          return n(K, se), K.prototype = se === null ? Object.create(se) : (ye.prototype = se.prototype, new ye()), Object.defineProperty(ae.prototype, "db", { get: function() {
            return A;
          }, enumerable: !1, configurable: !0 }), ae.prototype.table = function() {
            return R;
          }, ae;
        })(k)), /* @__PURE__ */ new Set()), z = k.prototype; z; z = u(z)) Object.getOwnPropertyNames(z).forEach(function(q) {
          return D.add(q);
        });
        function $(q) {
          if (!q) return q;
          var K, se = Object.create(k.prototype);
          for (K in q) if (!D.has(K)) try {
            se[K] = q[K];
          } catch {
          }
          return se;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = $, this.hook("reading", $), k;
      }, an.prototype.defineClass = function() {
        return this.mapToClass(function(k) {
          c(this, k);
        });
      }, an.prototype.add = function(k, A) {
        var R = this, D = this.schema.primKey, z = D.auto, $ = D.keyPath, q = k;
        return $ && z && (q = Xc($)(k)), this._trans("readwrite", function(K) {
          return R.core.mutate({ trans: K, type: "add", keys: A != null ? [A] : null, values: [q] });
        }).then(function(K) {
          return K.numFailures ? Ke.reject(K.failures[0]) : K.lastResult;
        }).then(function(K) {
          if ($) try {
            O(k, $, K);
          } catch {
          }
          return K;
        });
      }, an.prototype.upsert = function(k, A) {
        var R = this, D = this.schema.primKey.keyPath;
        return this._trans("readwrite", function(z) {
          return R.core.get({ trans: z, key: k }).then(function($) {
            var q = $ ?? {};
            return bd(q, A), D && O(q, D, k), R.core.mutate({ trans: z, type: "put", values: [q], keys: [k], upsert: !0, updates: { keys: [k], changeSpecs: [A] } }).then(function(K) {
              return K.numFailures ? Ke.reject(K.failures[0]) : !!$;
            });
          });
        });
      }, an.prototype.update = function(k, A) {
        return typeof k != "object" || a(k) ? this.where(":id").equals(k).modify(A) : (k = I(k, this.schema.primKey.keyPath)) === void 0 ? vn(new Ae.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(k).modify(A);
      }, an.prototype.put = function(k, A) {
        var R = this, D = this.schema.primKey, z = D.auto, $ = D.keyPath, q = k;
        return $ && z && (q = Xc($)(k)), this._trans("readwrite", function(K) {
          return R.core.mutate({ trans: K, type: "put", values: [q], keys: A != null ? [A] : null });
        }).then(function(K) {
          return K.numFailures ? Ke.reject(K.failures[0]) : K.lastResult;
        }).then(function(K) {
          if ($) try {
            O(k, $, K);
          } catch {
          }
          return K;
        });
      }, an.prototype.delete = function(k) {
        var A = this;
        return this._trans("readwrite", function(R) {
          return A.core.mutate({ trans: R, type: "delete", keys: [k] }).then(function(D) {
            return qr(A, [k], D);
          }).then(function(D) {
            return D.numFailures ? Ke.reject(D.failures[0]) : void 0;
          });
        });
      }, an.prototype.clear = function() {
        var k = this;
        return this._trans("readwrite", function(A) {
          return k.core.mutate({ trans: A, type: "deleteRange", range: Kh }).then(function(R) {
            return qr(k, null, R);
          });
        }).then(function(A) {
          return A.numFailures ? Ke.reject(A.failures[0]) : void 0;
        });
      }, an.prototype.bulkGet = function(k) {
        var A = this;
        return this._trans("readonly", function(R) {
          return A.core.getMany({ keys: k, trans: R }).then(function(D) {
            return D.map(function(z) {
              return A.hook.reading.fire(z);
            });
          });
        });
      }, an.prototype.bulkAdd = function(k, A, R) {
        var D = this, z = Array.isArray(A) ? A : void 0, $ = (R = R || (z ? void 0 : A)) ? R.allKeys : void 0;
        return this._trans("readwrite", function(q) {
          var K = D.schema.primKey, ye = K.auto, K = K.keyPath;
          if (K && z) throw new Ae.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (z && z.length !== k.length) throw new Ae.InvalidArgument("Arguments objects and keys must have the same length");
          var se = k.length, ye = K && ye ? k.map(Xc(K)) : k;
          return D.core.mutate({ trans: q, type: "add", keys: z, values: ye, wantResults: $ }).then(function(ae) {
            var oe = ae.numFailures, ue = ae.failures;
            if (oe === 0) return $ ? ae.results : ae.lastResult;
            throw new J("".concat(D.name, ".bulkAdd(): ").concat(oe, " of ").concat(se, " operations failed"), ue);
          });
        });
      }, an.prototype.bulkPut = function(k, A, R) {
        var D = this, z = Array.isArray(A) ? A : void 0, $ = (R = R || (z ? void 0 : A)) ? R.allKeys : void 0;
        return this._trans("readwrite", function(q) {
          var K = D.schema.primKey, ye = K.auto, K = K.keyPath;
          if (K && z) throw new Ae.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (z && z.length !== k.length) throw new Ae.InvalidArgument("Arguments objects and keys must have the same length");
          var se = k.length, ye = K && ye ? k.map(Xc(K)) : k;
          return D.core.mutate({ trans: q, type: "put", keys: z, values: ye, wantResults: $ }).then(function(ae) {
            var oe = ae.numFailures, ue = ae.failures;
            if (oe === 0) return $ ? ae.results : ae.lastResult;
            throw new J("".concat(D.name, ".bulkPut(): ").concat(oe, " of ").concat(se, " operations failed"), ue);
          });
        });
      }, an.prototype.bulkUpdate = function(k) {
        var A = this, R = this.core, D = k.map(function(q) {
          return q.key;
        }), z = k.map(function(q) {
          return q.changes;
        }), $ = [];
        return this._trans("readwrite", function(q) {
          return R.getMany({ trans: q, keys: D, cache: "clone" }).then(function(K) {
            var se = [], ye = [], ae = (k.forEach(function(oe, ue) {
              var fe = oe.key, le = oe.changes, ce = K[ue];
              if (ce) {
                for (var we = 0, _e = Object.keys(le); we < _e.length; we++) {
                  var ve = _e[we], Re = le[ve];
                  if (ve === A.schema.primKey.keyPath) {
                    if (Pt(Re, fe) !== 0) throw new Ae.Constraint("Cannot update primary key in bulkUpdate()");
                  } else O(ce, ve, Re);
                }
                $.push(ue), se.push(fe), ye.push(ce);
              }
            }), se.length);
            return R.mutate({ trans: q, type: "put", keys: se, values: ye, updates: { keys: D, changeSpecs: z } }).then(function(oe) {
              var ue = oe.numFailures, fe = oe.failures;
              if (ue === 0) return ae;
              for (var le = 0, ce = Object.keys(fe); le < ce.length; le++) {
                var we, _e = ce[le], ve = $[Number(_e)];
                ve != null && (we = fe[_e], delete fe[_e], fe[ve] = we);
              }
              throw new J("".concat(A.name, ".bulkUpdate(): ").concat(ue, " of ").concat(ae, " operations failed"), fe);
            });
          });
        });
      }, an.prototype.bulkDelete = function(k) {
        var A = this, R = k.length;
        return this._trans("readwrite", function(D) {
          return A.core.mutate({ trans: D, type: "delete", keys: k }).then(function(z) {
            return qr(A, k, z);
          });
        }).then(function(D) {
          var z = D.numFailures, $ = D.failures;
          if (z === 0) return D.lastResult;
          throw new J("".concat(A.name, ".bulkDelete(): ").concat(z, " of ").concat(R, " operations failed"), $);
        });
      };
      var Zh = an;
      function an() {
      }
      function Qc(k) {
        function A(q, K) {
          if (K) {
            for (var se = arguments.length, ye = new Array(se - 1); --se; ) ye[se - 1] = arguments[se];
            return R[q].subscribe.apply(null, ye), k;
          }
          if (typeof q == "string") return R[q];
        }
        var R = {};
        A.addEventType = $;
        for (var D = 1, z = arguments.length; D < z; ++D) $(arguments[D]);
        return A;
        function $(q, K, se) {
          var ye, ae;
          if (typeof q != "object") return K = K || Kt, ae = { subscribers: [], fire: se = se || Ge, subscribe: function(oe) {
            ae.subscribers.indexOf(oe) === -1 && (ae.subscribers.push(oe), ae.fire = K(ae.fire, oe));
          }, unsubscribe: function(oe) {
            ae.subscribers = ae.subscribers.filter(function(ue) {
              return ue !== oe;
            }), ae.fire = ae.subscribers.reduce(K, se);
          } }, R[q] = A[q] = ae;
          s(ye = q).forEach(function(oe) {
            var ue = ye[oe];
            if (a(ue)) $(oe, ye[oe][0], ye[oe][1]);
            else {
              if (ue !== "asap") throw new Ae.InvalidArgument("Invalid event config");
              var fe = $(oe, nt, function() {
                for (var le = arguments.length, ce = new Array(le); le--; ) ce[le] = arguments[le];
                fe.subscribers.forEach(function(we) {
                  P(function() {
                    we.apply(null, ce);
                  });
                });
              });
            }
          });
        }
      }
      function jr(k, A) {
        return x(A).from({ prototype: k }), A;
      }
      function Ss(k, A) {
        return !(k.filter || k.algorithm || k.or) && (A ? k.justLimit : !k.replayFilter);
      }
      function xd(k, A) {
        k.filter = aa(k.filter, A);
      }
      function eu(k, A, R) {
        var D = k.replayFilter;
        k.replayFilter = D ? function() {
          return aa(D(), A());
        } : A, k.justLimit = R && !D;
      }
      function Yo(k, A) {
        if (k.isPrimKey) return A.primaryKey;
        var R = A.getIndexByKeyPath(k.index);
        if (R) return R;
        throw new Ae.Schema("KeyPath " + k.index + " on object store " + A.name + " is not indexed");
      }
      function Yh(k, A, R) {
        var D = Yo(k, A.schema);
        return A.openCursor({ trans: R, values: !k.keysOnly, reverse: k.dir === "prev", unique: !!k.unique, query: { index: D, range: k.range } });
      }
      function tu(k, A, R, D) {
        var z, $, q = k.replayFilter ? aa(k.filter, k.replayFilter()) : k.filter;
        return k.or ? (z = {}, $ = function(K, se, ye) {
          var ae, oe;
          q && !q(se, ye, function(ue) {
            return se.stop(ue);
          }, function(ue) {
            return se.fail(ue);
          }) || ((oe = "" + (ae = se.primaryKey)) == "[object ArrayBuffer]" && (oe = "" + new Uint8Array(ae)), h(z, oe)) || (z[oe] = !0, A(K, se, ye));
        }, Promise.all([k.or._iterate($, R), la(Yh(k, D, R), k.algorithm, $, !k.keysOnly && k.valueMapper)])) : la(Yh(k, D, R), aa(k.algorithm, q), A, !k.keysOnly && k.valueMapper);
      }
      function la(k, A, R, D) {
        var z = kn(D ? function($, q, K) {
          return R(D($), q, K);
        } : R);
        return k.then(function($) {
          if ($) return $.start(function() {
            var q = function() {
              return $.continue();
            };
            A && !A($, function(K) {
              return q = K;
            }, function(K) {
              $.stop(K), q = Ge;
            }, function(K) {
              $.fail(K), q = Ge;
            }) || z($.value, $, function(K) {
              return q = K;
            }), q();
          });
        });
      }
      Jt.prototype._read = function(k, A) {
        var R = this._ctx;
        return R.error ? R.table._trans(null, vn.bind(null, R.error)) : R.table._trans("readonly", k).then(A);
      }, Jt.prototype._write = function(k) {
        var A = this._ctx;
        return A.error ? A.table._trans(null, vn.bind(null, A.error)) : A.table._trans("readwrite", k, "locked");
      }, Jt.prototype._addAlgorithm = function(k) {
        var A = this._ctx;
        A.algorithm = aa(A.algorithm, k);
      }, Jt.prototype._iterate = function(k, A) {
        return tu(this._ctx, k, A, this._ctx.table.core);
      }, Jt.prototype.clone = function(k) {
        var A = Object.create(this.constructor.prototype), R = Object.create(this._ctx);
        return k && c(R, k), A._ctx = R, A;
      }, Jt.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Jt.prototype.each = function(k) {
        var A = this._ctx;
        return this._read(function(R) {
          return tu(A, k, R, A.table.core);
        });
      }, Jt.prototype.count = function(k) {
        var A = this;
        return this._read(function(R) {
          var D, z = A._ctx, $ = z.table.core;
          return Ss(z, !0) ? $.count({ trans: R, query: { index: Yo(z, $.schema), range: z.range } }).then(function(q) {
            return Math.min(q, z.limit);
          }) : (D = 0, tu(z, function() {
            return ++D, !1;
          }, R, $).then(function() {
            return D;
          }));
        }).then(k);
      }, Jt.prototype.sortBy = function(k, A) {
        var R = k.split(".").reverse(), D = R[0], z = R.length - 1;
        function $(se, ye) {
          return ye ? $(se[R[ye]], ye - 1) : se[D];
        }
        var q = this._ctx.dir === "next" ? 1 : -1;
        function K(se, ye) {
          return Pt($(se, z), $(ye, z)) * q;
        }
        return this.toArray(function(se) {
          return se.sort(K);
        }).then(A);
      }, Jt.prototype.toArray = function(k) {
        var A = this;
        return this._read(function(R) {
          var D, z, $, q = A._ctx;
          return q.dir === "next" && Ss(q, !0) && 0 < q.limit ? (D = q.valueMapper, z = Yo(q, q.table.core.schema), q.table.core.query({ trans: R, limit: q.limit, values: !0, query: { index: z, range: q.range } }).then(function(K) {
            return K = K.result, D ? K.map(D) : K;
          })) : ($ = [], tu(q, function(K) {
            return $.push(K);
          }, R, q.table.core).then(function() {
            return $;
          }));
        }, k);
      }, Jt.prototype.offset = function(k) {
        var A = this._ctx;
        return k <= 0 || (A.offset += k, Ss(A) ? eu(A, function() {
          var R = k;
          return function(D, z) {
            return R === 0 || (R === 1 ? --R : z(function() {
              D.advance(R), R = 0;
            }), !1);
          };
        }) : eu(A, function() {
          var R = k;
          return function() {
            return --R < 0;
          };
        })), this;
      }, Jt.prototype.limit = function(k) {
        return this._ctx.limit = Math.min(this._ctx.limit, k), eu(this._ctx, function() {
          var A = k;
          return function(R, D, z) {
            return --A <= 0 && D(z), 0 <= A;
          };
        }, !0), this;
      }, Jt.prototype.until = function(k, A) {
        return xd(this._ctx, function(R, D, z) {
          return !k(R.value) || (D(z), A);
        }), this;
      }, Jt.prototype.first = function(k) {
        return this.limit(1).toArray(function(A) {
          return A[0];
        }).then(k);
      }, Jt.prototype.last = function(k) {
        return this.reverse().first(k);
      }, Jt.prototype.filter = function(k) {
        var A;
        return xd(this._ctx, function(R) {
          return k(R.value);
        }), (A = this._ctx).isMatch = aa(A.isMatch, k), this;
      }, Jt.prototype.and = function(k) {
        return this.filter(k);
      }, Jt.prototype.or = function(k) {
        return new this.db.WhereClause(this._ctx.table, k, this);
      }, Jt.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Jt.prototype.desc = function() {
        return this.reverse();
      }, Jt.prototype.eachKey = function(k) {
        var A = this._ctx;
        return A.keysOnly = !A.isMatch, this.each(function(R, D) {
          k(D.key, D);
        });
      }, Jt.prototype.eachUniqueKey = function(k) {
        return this._ctx.unique = "unique", this.eachKey(k);
      }, Jt.prototype.eachPrimaryKey = function(k) {
        var A = this._ctx;
        return A.keysOnly = !A.isMatch, this.each(function(R, D) {
          k(D.primaryKey, D);
        });
      }, Jt.prototype.keys = function(k) {
        var A = this._ctx, R = (A.keysOnly = !A.isMatch, []);
        return this.each(function(D, z) {
          R.push(z.key);
        }).then(function() {
          return R;
        }).then(k);
      }, Jt.prototype.primaryKeys = function(k) {
        var A = this._ctx;
        if (A.dir === "next" && Ss(A, !0) && 0 < A.limit) return this._read(function(D) {
          var z = Yo(A, A.table.core.schema);
          return A.table.core.query({ trans: D, values: !1, limit: A.limit, query: { index: z, range: A.range } });
        }).then(function(D) {
          return D.result;
        }).then(k);
        A.keysOnly = !A.isMatch;
        var R = [];
        return this.each(function(D, z) {
          R.push(z.primaryKey);
        }).then(function() {
          return R;
        }).then(k);
      }, Jt.prototype.uniqueKeys = function(k) {
        return this._ctx.unique = "unique", this.keys(k);
      }, Jt.prototype.firstKey = function(k) {
        return this.limit(1).keys(function(A) {
          return A[0];
        }).then(k);
      }, Jt.prototype.lastKey = function(k) {
        return this.reverse().firstKey(k);
      }, Jt.prototype.distinct = function() {
        var k, A = this._ctx, A = A.index && A.table.schema.idxByName[A.index];
        return A && A.multi && (k = {}, xd(this._ctx, function(D) {
          var D = D.primaryKey.toString(), z = h(k, D);
          return k[D] = !0, !z;
        })), this;
      }, Jt.prototype.modify = function(k) {
        var A = this, R = this._ctx;
        return this._write(function(D) {
          function z(ce, we) {
            var _e = we.failures;
            ue += ce - we.numFailures;
            for (var ve = 0, Re = s(_e); ve < Re.length; ve++) {
              var ze = Re[ve];
              oe.push(_e[ze]);
            }
          }
          var $ = typeof k == "function" ? k : function(ce) {
            return bd(ce, k);
          }, q = R.table.core, ae = q.schema.primaryKey, K = ae.outbound, se = ae.extractKey, ye = 200, ae = A.db._options.modifyChunkSize, oe = (ae && (ye = typeof ae == "object" ? ae[q.name] || ae["*"] || 200 : ae), []), ue = 0, fe = [], le = k === Xh;
          return A.clone().primaryKeys().then(function(ce) {
            function we(ve) {
              var Re = Math.min(ye, ce.length - ve), ze = ce.slice(ve, ve + Re);
              return (le ? Promise.resolve([]) : q.getMany({ trans: D, keys: ze, cache: "immutable" })).then(function(We) {
                var qe = [], Le = [], Xe = K ? [] : null, Ze = le ? ze : [];
                if (!le) for (var Be = 0; Be < Re; ++Be) {
                  var Je = We[Be], wt = { value: he(Je), primKey: ce[ve + Be] };
                  $.call(wt, wt.value, wt) !== !1 && (wt.value == null ? Ze.push(ce[ve + Be]) : K || Pt(se(Je), se(wt.value)) === 0 ? (Le.push(wt.value), K && Xe.push(ce[ve + Be])) : (Ze.push(ce[ve + Be]), qe.push(wt.value)));
                }
                return Promise.resolve(0 < qe.length && q.mutate({ trans: D, type: "add", values: qe }).then(function(Bt) {
                  for (var dt in Bt.failures) Ze.splice(parseInt(dt), 1);
                  z(qe.length, Bt);
                })).then(function() {
                  return (0 < Le.length || _e && typeof k == "object") && q.mutate({ trans: D, type: "put", keys: Xe, values: Le, criteria: _e, changeSpec: typeof k != "function" && k, isAdditionalChunk: 0 < ve }).then(function(Bt) {
                    return z(Le.length, Bt);
                  });
                }).then(function() {
                  return (0 < Ze.length || _e && le) && q.mutate({ trans: D, type: "delete", keys: Ze, criteria: _e, isAdditionalChunk: 0 < ve }).then(function(Bt) {
                    return qr(R.table, Ze, Bt);
                  }).then(function(Bt) {
                    return z(Ze.length, Bt);
                  });
                }).then(function() {
                  return ce.length > ve + Re && we(ve + ye);
                });
              });
            }
            var _e = Ss(R) && R.limit === 1 / 0 && (typeof k != "function" || le) && { index: R.index, range: R.range };
            return we(0).then(function() {
              if (0 < oe.length) throw new re("Error modifying one or more objects", oe, ue, fe);
              return ce.length;
            });
          });
        });
      }, Jt.prototype.delete = function() {
        var k = this._ctx, A = k.range;
        return !Ss(k) || k.table.schema.yProps || !k.isPrimKey && A.type !== 3 ? this.modify(Xh) : this._write(function(R) {
          var D = k.table.core.schema.primaryKey, z = A;
          return k.table.core.count({ trans: R, query: { index: D, range: z } }).then(function($) {
            return k.table.core.mutate({ trans: R, type: "deleteRange", range: z }).then(function(se) {
              var K = se.failures, se = se.numFailures;
              if (se) throw new re("Could not delete some values", Object.keys(K).map(function(ye) {
                return K[ye];
              }), $ - se);
              return $ - se;
            });
          });
        });
      };
      var m1 = Jt;
      function Jt() {
      }
      var Xh = function(k, A) {
        return A.value = null;
      };
      function Jh(k, A) {
        return k < A ? -1 : k === A ? 0 : 1;
      }
      function g1(k, A) {
        return A < k ? -1 : k === A ? 0 : 1;
      }
      function Si(k, A, R) {
        return k = k instanceof ca ? new k.Collection(k) : k, k._ctx.error = new (R || TypeError)(A), k;
      }
      function Xo(k) {
        return new k.Collection(k, function() {
          return wd("");
        }).limit(0);
      }
      function zi(fe, A, R, D) {
        var z, $, q, K, se, ye, ae, oe = R.length;
        if (!R.every(function(ce) {
          return typeof ce == "string";
        })) return Si(fe, lr);
        function ue(ce) {
          z = ce === "next" ? function(_e) {
            return _e.toUpperCase();
          } : function(_e) {
            return _e.toLowerCase();
          }, $ = ce === "next" ? function(_e) {
            return _e.toLowerCase();
          } : function(_e) {
            return _e.toUpperCase();
          }, q = ce === "next" ? Jh : g1;
          var we = R.map(function(_e) {
            return { lower: $(_e), upper: z(_e) };
          }).sort(function(_e, ve) {
            return q(_e.lower, ve.lower);
          });
          K = we.map(function(_e) {
            return _e.upper;
          }), se = we.map(function(_e) {
            return _e.lower;
          }), ae = (ye = ce) === "next" ? "" : D;
        }
        ue("next");
        var fe = new fe.Collection(fe, function() {
          return bo(K[0], se[oe - 1] + D);
        }), le = (fe._ondirectionchange = function(ce) {
          ue(ce);
        }, 0);
        return fe._addAlgorithm(function(ce, we, _e) {
          var ve = ce.key;
          if (typeof ve == "string") {
            var Re = $(ve);
            if (A(Re, se, le)) return !0;
            for (var ze = null, We = le; We < oe; ++We) {
              var qe = ((Le, Xe, Ze, Be, Je, wt) => {
                for (var Bt = Math.min(Le.length, Be.length), dt = -1, Tt = 0; Tt < Bt; ++Tt) {
                  var bn = Xe[Tt];
                  if (bn !== Be[Tt]) return Je(Le[Tt], Ze[Tt]) < 0 ? Le.substr(0, Tt) + Ze[Tt] + Ze.substr(Tt + 1) : Je(Le[Tt], Be[Tt]) < 0 ? Le.substr(0, Tt) + Be[Tt] + Ze.substr(Tt + 1) : 0 <= dt ? Le.substr(0, dt) + Xe[dt] + Ze.substr(dt + 1) : null;
                  Je(Le[Tt], bn) < 0 && (dt = Tt);
                }
                return Bt < Be.length && wt === "next" ? Le + Ze.substr(Le.length) : Bt < Le.length && wt === "prev" ? Le.substr(0, Ze.length) : dt < 0 ? null : Le.substr(0, dt) + Be[dt] + Ze.substr(dt + 1);
              })(ve, Re, K[We], se[We], q, ye);
              qe === null && ze === null ? le = We + 1 : (ze === null || 0 < q(ze, qe)) && (ze = qe);
            }
            we(ze !== null ? function() {
              ce.continue(ze + ae);
            } : _e);
          }
          return !1;
        }), fe;
      }
      function bo(k, A, R, D) {
        return { type: 2, lower: k, upper: A, lowerOpen: R, upperOpen: D };
      }
      function wd(k) {
        return { type: 1, lower: k, upper: k };
      }
      Object.defineProperty(In.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), In.prototype.between = function(k, A, R, D) {
        R = R !== !1, D = D === !0;
        try {
          return 0 < this._cmp(k, A) || this._cmp(k, A) === 0 && (R || D) && (!R || !D) ? Xo(this) : new this.Collection(this, function() {
            return bo(k, A, !R, !D);
          });
        } catch {
          return Si(this, si);
        }
      }, In.prototype.equals = function(k) {
        return k == null ? Si(this, si) : new this.Collection(this, function() {
          return wd(k);
        });
      }, In.prototype.above = function(k) {
        return k == null ? Si(this, si) : new this.Collection(this, function() {
          return bo(k, void 0, !0);
        });
      }, In.prototype.aboveOrEqual = function(k) {
        return k == null ? Si(this, si) : new this.Collection(this, function() {
          return bo(k, void 0, !1);
        });
      }, In.prototype.below = function(k) {
        return k == null ? Si(this, si) : new this.Collection(this, function() {
          return bo(void 0, k, !1, !0);
        });
      }, In.prototype.belowOrEqual = function(k) {
        return k == null ? Si(this, si) : new this.Collection(this, function() {
          return bo(void 0, k);
        });
      }, In.prototype.startsWith = function(k) {
        return typeof k != "string" ? Si(this, lr) : this.between(k, k + Ji, !0, !0);
      }, In.prototype.startsWithIgnoreCase = function(k) {
        return k === "" ? this.startsWith(k) : zi(this, function(A, R) {
          return A.indexOf(R[0]) === 0;
        }, [k], Ji);
      }, In.prototype.equalsIgnoreCase = function(k) {
        return zi(this, function(A, R) {
          return A === R[0];
        }, [k], "");
      }, In.prototype.anyOfIgnoreCase = function() {
        var k = W.apply(Se, arguments);
        return k.length === 0 ? Xo(this) : zi(this, function(A, R) {
          return R.indexOf(A) !== -1;
        }, k, "");
      }, In.prototype.startsWithAnyOfIgnoreCase = function() {
        var k = W.apply(Se, arguments);
        return k.length === 0 ? Xo(this) : zi(this, function(A, R) {
          return R.some(function(D) {
            return A.indexOf(D) === 0;
          });
        }, k, Ji);
      }, In.prototype.anyOf = function() {
        var k, A, R = this, D = W.apply(Se, arguments), z = this._cmp;
        try {
          D.sort(z);
        } catch {
          return Si(this, si);
        }
        return D.length === 0 ? Xo(this) : ((k = new this.Collection(this, function() {
          return bo(D[0], D[D.length - 1]);
        }))._ondirectionchange = function($) {
          z = $ === "next" ? R._ascending : R._descending, D.sort(z);
        }, A = 0, k._addAlgorithm(function($, q, K) {
          for (var se = $.key; 0 < z(se, D[A]); ) if (++A === D.length) return q(K), !1;
          return z(se, D[A]) === 0 || (q(function() {
            $.continue(D[A]);
          }), !1);
        }), k);
      }, In.prototype.notEqual = function(k) {
        return this.inAnyRange([[-1 / 0, k], [k, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, In.prototype.noneOf = function() {
        var k = W.apply(Se, arguments);
        if (k.length === 0) return new this.Collection(this);
        try {
          k.sort(this._ascending);
        } catch {
          return Si(this, si);
        }
        var A = k.reduce(function(R, D) {
          return R ? R.concat([[R[R.length - 1][1], D]]) : [[-1 / 0, D]];
        }, null);
        return A.push([k[k.length - 1], this.db._maxKey]), this.inAnyRange(A, { includeLowers: !1, includeUppers: !1 });
      }, In.prototype.inAnyRange = function(k, _e) {
        var R = this, D = this._cmp, z = this._ascending, $ = this._descending, q = this._min, K = this._max;
        if (k.length === 0) return Xo(this);
        if (!k.every(function(ve) {
          return ve[0] !== void 0 && ve[1] !== void 0 && z(ve[0], ve[1]) <= 0;
        })) return Si(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Ae.InvalidArgument);
        var se = !_e || _e.includeLowers !== !1, ye = _e && _e.includeUppers === !0, ae, oe = z;
        function ue(ve, Re) {
          return oe(ve[0], Re[0]);
        }
        try {
          (ae = k.reduce(function(ve, Re) {
            for (var ze = 0, We = ve.length; ze < We; ++ze) {
              var qe = ve[ze];
              if (D(Re[0], qe[1]) < 0 && 0 < D(Re[1], qe[0])) {
                qe[0] = q(qe[0], Re[0]), qe[1] = K(qe[1], Re[1]);
                break;
              }
            }
            return ze === We && ve.push(Re), ve;
          }, [])).sort(ue);
        } catch {
          return Si(this, si);
        }
        var fe = 0, le = ye ? function(ve) {
          return 0 < z(ve, ae[fe][1]);
        } : function(ve) {
          return 0 <= z(ve, ae[fe][1]);
        }, ce = se ? function(ve) {
          return 0 < $(ve, ae[fe][0]);
        } : function(ve) {
          return 0 <= $(ve, ae[fe][0]);
        }, we = le, _e = new this.Collection(this, function() {
          return bo(ae[0][0], ae[ae.length - 1][1], !se, !ye);
        });
        return _e._ondirectionchange = function(ve) {
          oe = ve === "next" ? (we = le, z) : (we = ce, $), ae.sort(ue);
        }, _e._addAlgorithm(function(ve, Re, ze) {
          for (var We, qe = ve.key; we(qe); ) if (++fe === ae.length) return Re(ze), !1;
          return !le(We = qe) && !ce(We) || (R._cmp(qe, ae[fe][1]) === 0 || R._cmp(qe, ae[fe][0]) === 0 || Re(function() {
            oe === z ? ve.continue(ae[fe][0]) : ve.continue(ae[fe][1]);
          }), !1);
        }), _e;
      }, In.prototype.startsWithAnyOf = function() {
        var k = W.apply(Se, arguments);
        return k.every(function(A) {
          return typeof A == "string";
        }) ? k.length === 0 ? Xo(this) : this.inAnyRange(k.map(function(A) {
          return [A, A + Ji];
        })) : Si(this, "startsWithAnyOf() only works with strings");
      };
      var ca = In;
      function In() {
      }
      function Qi(k) {
        return kn(function(A) {
          return ua(A), k(A.target.error), !1;
        });
      }
      function ua(k) {
        k.stopPropagation && k.stopPropagation(), k.preventDefault && k.preventDefault();
      }
      var ul = "storagemutated", da = "x-storagemutated-1", Ir = Qc(null, ul), Qh = (ai.prototype._lock = function() {
        return N(!Ve.global), ++this._reculock, this._reculock !== 1 || Ve.global || (Ve.lockOwnerFor = this), this;
      }, ai.prototype._unlock = function() {
        if (N(!Ve.global), --this._reculock == 0) for (Ve.global || (Ve.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var k = this._blockedFuncs.shift();
          try {
            Xi(k[1], k[0]);
          } catch {
          }
        }
        return this;
      }, ai.prototype._locked = function() {
        return this._reculock && Ve.lockOwnerFor !== this;
      }, ai.prototype.create = function(k) {
        var A = this;
        if (this.mode) {
          var R = this.db.idbdb, D = this.db._state.dbOpenError;
          if (N(!this.idbtrans), !k && !R) switch (D && D.name) {
            case "DatabaseClosedError":
              throw new Ae.DatabaseClosed(D);
            case "MissingAPIError":
              throw new Ae.MissingAPI(D.message, D);
            default:
              throw new Ae.OpenFailed(D);
          }
          if (!this.active) throw new Ae.TransactionInactive();
          N(this._completion._state === null), (k = this.idbtrans = k || (this.db.core || R).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = kn(function(z) {
            ua(z), A._reject(k.error);
          }), k.onabort = kn(function(z) {
            ua(z), A.active && A._reject(new Ae.Abort(k.error)), A.active = !1, A.on("abort").fire(z);
          }), k.oncomplete = kn(function() {
            A.active = !1, A._resolve(), "mutatedParts" in k && Ir.storagemutated.fire(k.mutatedParts);
          });
        }
        return this;
      }, ai.prototype._promise = function(k, A, R) {
        var D, z = this;
        return k === "readwrite" && this.mode !== "readwrite" ? vn(new Ae.ReadOnly("Transaction is readonly")) : this.active ? this._locked() ? new Ke(function($, q) {
          z._blockedFuncs.push([function() {
            z._promise(k, A, R).then($, q);
          }, Ve]);
        }) : R ? Nn(function() {
          var $ = new Ke(function(q, K) {
            z._lock();
            var se = A(q, K, z);
            se && se.then && se.then(q, K);
          });
          return $.finally(function() {
            return z._unlock();
          }), $._lib = !0, $;
        }) : ((D = new Ke(function($, q) {
          var K = A($, q, z);
          K && K.then && K.then($, q);
        }))._lib = !0, D) : vn(new Ae.TransactionInactive());
      }, ai.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, ai.prototype.waitFor = function(k) {
        var A, R = this._root(), D = Ke.resolve(k), z = (R._waitingFor ? R._waitingFor = R._waitingFor.then(function() {
          return D;
        }) : (R._waitingFor = D, R._waitingQueue = [], A = R.idbtrans.objectStore(R.storeNames[0]), (function $() {
          for (++R._spinCount; R._waitingQueue.length; ) R._waitingQueue.shift()();
          R._waitingFor && (A.get(-1 / 0).onsuccess = $);
        })()), R._waitingFor);
        return new Ke(function($, q) {
          D.then(function(K) {
            return R._waitingQueue.push(kn($.bind(null, K)));
          }, function(K) {
            return R._waitingQueue.push(kn(q.bind(null, K)));
          }).finally(function() {
            R._waitingFor === z && (R._waitingFor = null);
          });
        });
      }, ai.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new Ae.Abort()));
      }, ai.prototype.table = function(k) {
        var A = this._memoizedTables || (this._memoizedTables = {});
        if (h(A, k)) return A[k];
        var R = this.schema[k];
        if (R) return (R = new this.db.Table(k, R, this)).core = this.db.core.table(k), A[k] = R;
        throw new Ae.NotFound("Table " + k + " not part of transaction");
      }, ai);
      function ai() {
      }
      function xo(k, A, R, D, z, $, q, K) {
        return { name: k, keyPath: A, unique: R, multi: D, auto: z, compound: $, src: (R && !q ? "&" : "") + (D ? "*" : "") + (z ? "++" : "") + Sd(A), type: K };
      }
      function Sd(k) {
        return typeof k == "string" ? k : k ? "[" + [].join.call(k, "+") + "]" : "";
      }
      function dl(k, A, R) {
        return { name: k, primKey: A, indexes: R, mappedClass: null, idxByName: (D = function(z) {
          return [z.name, z];
        }, R.reduce(function(z, $, q) {
          return $ = D($, q), $ && (z[$[0]] = $[1]), z;
        }, {})) };
        var D;
      }
      var fl = function(k) {
        try {
          return k.only([[]]), fl = function() {
            return [[]];
          }, [[]];
        } catch {
          return fl = function() {
            return Ji;
          }, Ji;
        }
      };
      function hl(k) {
        return k == null ? function() {
        } : typeof k == "string" ? (A = k).split(".").length === 1 ? function(R) {
          return R[A];
        } : function(R) {
          return I(R, A);
        } : function(R) {
          return I(R, k);
        };
        var A;
      }
      function nu(k) {
        return [].slice.call(k);
      }
      var hy = 0;
      function pr(k) {
        return k == null ? ":id" : typeof k == "string" ? k : "[".concat(k.join("+"), "]");
      }
      function fa(k, A, se) {
        function D(le) {
          if (le.type === 3) return null;
          if (le.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var oe = le.lower, ue = le.upper, fe = le.lowerOpen, le = le.upperOpen;
          return oe === void 0 ? ue === void 0 ? null : A.upperBound(ue, !!le) : ue === void 0 ? A.lowerBound(oe, !!fe) : A.bound(oe, ue, !!fe, !!le);
        }
        function z(ae) {
          var oe, ue = ae.name;
          return { name: ue, schema: ae, mutate: function(fe) {
            var le = fe.trans, ce = fe.type, we = fe.keys, _e = fe.values, ve = fe.range;
            return new Promise(function(Re, ze) {
              Re = kn(Re);
              var We = le.objectStore(ue), qe = We.keyPath == null, Le = ce === "put" || ce === "add";
              if (!Le && ce !== "delete" && ce !== "deleteRange") throw new Error("Invalid operation type: " + ce);
              var Xe, Ze = (we || _e || { length: 1 }).length;
              if (we && _e && we.length !== _e.length) throw new Error("Given keys array must have same length as given values array.");
              if (Ze === 0) return Re({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function Be(un) {
                ++Bt, ua(un);
              }
              var Je = [], wt = [], Bt = 0;
              if (ce === "deleteRange") {
                if (ve.type === 4) return Re({ numFailures: Bt, failures: wt, results: [], lastResult: void 0 });
                ve.type === 3 ? Je.push(Xe = We.clear()) : Je.push(Xe = We.delete(D(ve)));
              } else {
                var qe = Le ? qe ? [_e, we] : [_e, null] : [we, null], dt = qe[0], Tt = qe[1];
                if (Le) for (var bn = 0; bn < Ze; ++bn) Je.push(Xe = Tt && Tt[bn] !== void 0 ? We[ce](dt[bn], Tt[bn]) : We[ce](dt[bn])), Xe.onerror = Be;
                else for (bn = 0; bn < Ze; ++bn) Je.push(Xe = We[ce](dt[bn])), Xe.onerror = Be;
              }
              function ci(un) {
                un = un.target.result, Je.forEach(function(_s, bl) {
                  return _s.error != null && (wt[bl] = _s.error);
                }), Re({ numFailures: Bt, failures: wt, results: ce === "delete" ? we : Je.map(function(_s) {
                  return _s.result;
                }), lastResult: un });
              }
              Xe.onerror = function(un) {
                Be(un), ci(un);
              }, Xe.onsuccess = ci;
            });
          }, getMany: function(fe) {
            var le = fe.trans, ce = fe.keys;
            return new Promise(function(we, _e) {
              we = kn(we);
              for (var ve, Re = le.objectStore(ue), ze = ce.length, We = new Array(ze), qe = 0, Le = 0, Xe = function(Je) {
                Je = Je.target, We[Je._pos] = Je.result, ++Le === qe && we(We);
              }, Ze = Qi(_e), Be = 0; Be < ze; ++Be) ce[Be] != null && ((ve = Re.get(ce[Be]))._pos = Be, ve.onsuccess = Xe, ve.onerror = Ze, ++qe);
              qe === 0 && we(We);
            });
          }, get: function(fe) {
            var le = fe.trans, ce = fe.key;
            return new Promise(function(we, _e) {
              we = kn(we);
              var ve = le.objectStore(ue).get(ce);
              ve.onsuccess = function(Re) {
                return we(Re.target.result);
              }, ve.onerror = Qi(_e);
            });
          }, query: (oe = K, function(fe) {
            return new Promise(function(le, ce) {
              le = kn(le);
              var we, _e, ve, Le = fe.trans, Re = fe.values, ze = fe.limit, qe = fe.query, We = ze === 1 / 0 ? void 0 : ze, Xe = qe.index, qe = qe.range, Le = Le.objectStore(ue), Le = Xe.isPrimaryKey ? Le : Le.index(Xe.name), Xe = D(qe);
              if (ze === 0) return le({ result: [] });
              oe ? ((qe = Re ? Le.getAll(Xe, We) : Le.getAllKeys(Xe, We)).onsuccess = function(Ze) {
                return le({ result: Ze.target.result });
              }, qe.onerror = Qi(ce)) : (we = 0, _e = !Re && "openKeyCursor" in Le ? Le.openKeyCursor(Xe) : Le.openCursor(Xe), ve = [], _e.onsuccess = function(Ze) {
                var Be = _e.result;
                return !Be || (ve.push(Re ? Be.value : Be.primaryKey), ++we === ze) ? le({ result: ve }) : void Be.continue();
              }, _e.onerror = Qi(ce));
            });
          }), openCursor: function(fe) {
            var le = fe.trans, ce = fe.values, we = fe.query, _e = fe.reverse, ve = fe.unique;
            return new Promise(function(Re, ze) {
              Re = kn(Re);
              var Le = we.index, We = we.range, qe = le.objectStore(ue), qe = Le.isPrimaryKey ? qe : qe.index(Le.name), Le = _e ? ve ? "prevunique" : "prev" : ve ? "nextunique" : "next", Xe = !ce && "openKeyCursor" in qe ? qe.openKeyCursor(D(We), Le) : qe.openCursor(D(We), Le);
              Xe.onerror = Qi(ze), Xe.onsuccess = kn(function(Ze) {
                var Be, Je, wt, Bt, dt = Xe.result;
                dt ? (dt.___id = ++hy, dt.done = !1, Be = dt.continue.bind(dt), Je = (Je = dt.continuePrimaryKey) && Je.bind(dt), wt = dt.advance.bind(dt), Bt = function() {
                  throw new Error("Cursor not stopped");
                }, dt.trans = le, dt.stop = dt.continue = dt.continuePrimaryKey = dt.advance = function() {
                  throw new Error("Cursor not started");
                }, dt.fail = kn(ze), dt.next = function() {
                  var Tt = this, bn = 1;
                  return this.start(function() {
                    return bn-- ? Tt.continue() : Tt.stop();
                  }).then(function() {
                    return Tt;
                  });
                }, dt.start = function(Tt) {
                  function bn() {
                    if (Xe.result) try {
                      Tt();
                    } catch (un) {
                      dt.fail(un);
                    }
                    else dt.done = !0, dt.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, dt.stop();
                  }
                  var ci = new Promise(function(un, _s) {
                    un = kn(un), Xe.onerror = Qi(_s), dt.fail = _s, dt.stop = function(bl) {
                      dt.stop = dt.continue = dt.continuePrimaryKey = dt.advance = Bt, un(bl);
                    };
                  });
                  return Xe.onsuccess = kn(function(un) {
                    Xe.onsuccess = bn, bn();
                  }), dt.continue = Be, dt.continuePrimaryKey = Je, dt.advance = wt, bn(), ci;
                }, Re(dt)) : Re(null);
              }, ze);
            });
          }, count: function(fe) {
            var le = fe.query, ce = fe.trans, we = le.index, _e = le.range;
            return new Promise(function(ve, Re) {
              var ze = ce.objectStore(ue), ze = we.isPrimaryKey ? ze : ze.index(we.name), We = D(_e), We = We ? ze.count(We) : ze.count();
              We.onsuccess = kn(function(qe) {
                return ve(qe.target.result);
              }), We.onerror = Qi(Re);
            });
          } };
        }
        $ = se, q = nu((se = k).objectStoreNames);
        var $, se = { schema: { name: se.name, tables: q.map(function(ae) {
          return $.objectStore(ae);
        }).map(function(ae) {
          var oe = ae.keyPath, ue = ae.autoIncrement, le = a(oe), fe = {}, le = { name: ae.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: oe == null, compound: le, keyPath: oe, autoIncrement: ue, unique: !0, extractKey: hl(oe) }, indexes: nu(ae.indexNames).map(function(ce) {
            return ae.index(ce);
          }).map(function(ve) {
            var Re = ve.name, we = ve.unique, _e = ve.multiEntry, ve = ve.keyPath, Re = { name: Re, compound: a(ve), keyPath: ve, unique: we, multiEntry: _e, extractKey: hl(ve) };
            return fe[pr(ve)] = Re;
          }), getIndexByKeyPath: function(ce) {
            return fe[pr(ce)];
          } };
          return fe[":id"] = le.primaryKey, oe != null && (fe[pr(oe)] = le.primaryKey), le;
        }) }, hasGetAll: 0 < q.length && "getAll" in $.objectStore(q[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }, q = se.schema, K = se.hasGetAll, se = q.tables.map(z), ye = {};
        return se.forEach(function(ae) {
          return ye[ae.name] = ae;
        }), { stack: "dbcore", transaction: k.transaction.bind(k), table: function(ae) {
          if (ye[ae]) return ye[ae];
          throw new Error("Table '".concat(ae, "' not found"));
        }, MIN_KEY: -1 / 0, MAX_KEY: fl(A), schema: q };
      }
      function kd(k, A, R, D) {
        return R = R.IDBKeyRange, A = fa(A, R, D), { dbcore: k.dbcore.reduce(function(z, $) {
          return $ = $.create, r(r({}, z), $(z));
        }, A) };
      }
      function ks(k, A) {
        var R = A.db, R = kd(k._middlewares, R, k._deps, A);
        k.core = R.dbcore, k.tables.forEach(function(D) {
          var z = D.name;
          k.core.schema.tables.some(function($) {
            return $.name === z;
          }) && (D.core = k.core.table(z), k[z] instanceof k.Table) && (k[z].core = D.core);
        });
      }
      function Cd(k, A, R, D) {
        R.forEach(function(z) {
          var $ = D[z];
          A.forEach(function(q) {
            var K = (function se(ye, ae) {
              return w(ye, ae) || (ye = u(ye)) && se(ye, ae);
            })(q, z);
            (!K || "value" in K && K.value === void 0) && (q === k.Transaction.prototype || q instanceof k.Transaction ? b(q, z, { get: function() {
              return this.table(z);
            }, set: function(se) {
              g(this, z, { value: se, writable: !0, configurable: !0, enumerable: !0 });
            } }) : q[z] = new k.Table(z, $));
          });
        });
      }
      function ru(k, A) {
        A.forEach(function(R) {
          for (var D in R) R[D] instanceof k.Table && delete R[D];
        });
      }
      function ep(k, A) {
        return k._cfg.version - A._cfg.version;
      }
      function iu(k, A, R, D) {
        var z = k._dbSchema, $ = (R.objectStoreNames.contains("$meta") && !z.$meta && (z.$meta = dl("$meta", my("")[0], []), k._storeNames.push("$meta")), k._createTransaction("readwrite", k._storeNames, z)), q = ($.create(R), $._completion.catch(D), $._reject.bind($)), K = Ve.transless || Ve;
        Nn(function() {
          if (Ve.trans = $, Ve.transless = K, A !== 0) return ks(k, R), ye = A, ((se = $).storeNames.includes("$meta") ? se.table("$meta").get("version").then(function(ae) {
            return ae ?? ye;
          }) : Ke.resolve(ye)).then(function(we) {
            var oe = k, ue = we, fe = $, le = R, ce = [], we = oe._versions, _e = oe._dbSchema = pl(0, oe.idbdb, le);
            return (we = we.filter(function(ve) {
              return ve._cfg.version >= ue;
            })).length === 0 ? Ke.resolve() : (we.forEach(function(ve) {
              ce.push(function() {
                var Re, ze, We, qe = _e, Le = ve._cfg.dbschema, Xe = (Ad(oe, qe, le), Ad(oe, Le, le), _e = oe._dbSchema = Le, _d(qe, Le)), Ze = (Xe.add.forEach(function(Be) {
                  tp(le, Be[0], Be[1].primKey, Be[1].indexes);
                }), Xe.change.forEach(function(Be) {
                  if (Be.recreate) throw new Ae.Upgrade("Not yet support for changing primary key");
                  var Je = le.objectStore(Be.name);
                  Be.add.forEach(function(wt) {
                    return Td(Je, wt);
                  }), Be.change.forEach(function(wt) {
                    Je.deleteIndex(wt.name), Td(Je, wt);
                  }), Be.del.forEach(function(wt) {
                    return Je.deleteIndex(wt);
                  });
                }), ve._cfg.contentUpgrade);
                if (Ze && ve._cfg.version > ue) return ks(oe, le), fe._memoizedTables = {}, Re = L(Le), Xe.del.forEach(function(Be) {
                  Re[Be] = qe[Be];
                }), ru(oe, [oe.Transaction.prototype]), Cd(oe, [oe.Transaction.prototype], s(Re), Re), fe.schema = Re, (ze = Z(Ze)) && ar(), Le = Ke.follow(function() {
                  var Be;
                  (We = Ze(fe)) && ze && (Be = wi.bind(null, null), We.then(Be, Be));
                }), We && typeof We.then == "function" ? Ke.resolve(We) : Le.then(function() {
                  return We;
                });
              }), ce.push(function(Re) {
                var ze, We, qe = ve._cfg.dbschema;
                ze = qe, We = Re, [].slice.call(We.db.objectStoreNames).forEach(function(Le) {
                  return ze[Le] == null && We.db.deleteObjectStore(Le);
                }), ru(oe, [oe.Transaction.prototype]), Cd(oe, [oe.Transaction.prototype], oe._storeNames, oe._dbSchema), fe.schema = oe._dbSchema;
              }), ce.push(function(Re) {
                oe.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(oe.idbdb.version / 10) === ve._cfg.version ? (oe.idbdb.deleteObjectStore("$meta"), delete oe._dbSchema.$meta, oe._storeNames = oe._storeNames.filter(function(ze) {
                  return ze !== "$meta";
                })) : Re.objectStore("$meta").put(ve._cfg.version, "version"));
              });
            }), (function ve() {
              return ce.length ? Ke.resolve(ce.shift()(fe.idbtrans)).then(ve) : Ke.resolve();
            })().then(function() {
              py(_e, le);
            }));
          }).catch(q);
          var se, ye;
          s(z).forEach(function(ae) {
            tp(R, ae, z[ae].primKey, z[ae].indexes);
          }), ks(k, R), Ke.follow(function() {
            return k.on.populate.fire($);
          }).catch(q);
        });
      }
      function Ed(k, A) {
        py(k._dbSchema, A), A.db.version % 10 != 0 || A.objectStoreNames.contains("$meta") || A.db.createObjectStore("$meta").add(Math.ceil(A.db.version / 10 - 1), "version");
        var R = pl(0, k.idbdb, A);
        Ad(k, k._dbSchema, A);
        for (var D = 0, z = _d(R, k._dbSchema).change; D < z.length; D++) {
          var $ = ((q) => {
            if (q.change.length || q.recreate) return console.warn("Unable to patch indexes of table ".concat(q.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var K = A.objectStore(q.name);
            q.add.forEach(function(se) {
              Nt && console.debug("Dexie upgrade patch: Creating missing index ".concat(q.name, ".").concat(se.src)), Td(K, se);
            });
          })(z[D]);
          if (typeof $ == "object") return $.value;
        }
      }
      function _d(k, A) {
        var R, D = { del: [], add: [], change: [] };
        for (R in k) A[R] || D.del.push(R);
        for (R in A) {
          var z = k[R], $ = A[R];
          if (z) {
            var q = { name: R, def: $, recreate: !1, del: [], add: [], change: [] };
            if ("" + (z.primKey.keyPath || "") != "" + ($.primKey.keyPath || "") || z.primKey.auto !== $.primKey.auto) q.recreate = !0, D.change.push(q);
            else {
              var K = z.idxByName, se = $.idxByName, ye = void 0;
              for (ye in K) se[ye] || q.del.push(ye);
              for (ye in se) {
                var ae = K[ye], oe = se[ye];
                ae ? ae.src !== oe.src && q.change.push(oe) : q.add.push(oe);
              }
              (0 < q.del.length || 0 < q.add.length || 0 < q.change.length) && D.change.push(q);
            }
          } else D.add.push([R, $]);
        }
        return D;
      }
      function tp(k, A, R, D) {
        var z = k.db.createObjectStore(A, R.keyPath ? { keyPath: R.keyPath, autoIncrement: R.auto } : { autoIncrement: R.auto });
        D.forEach(function($) {
          return Td(z, $);
        });
      }
      function py(k, A) {
        s(k).forEach(function(R) {
          A.db.objectStoreNames.contains(R) || (Nt && console.debug("Dexie: Creating missing table", R), tp(A, R, k[R].primKey, k[R].indexes));
        });
      }
      function Td(k, A) {
        k.createIndex(A.name, A.keyPath, { unique: A.unique, multiEntry: A.multi });
      }
      function pl(k, A, R) {
        var D = {};
        return _(A.objectStoreNames, 0).forEach(function(z) {
          for (var $ = R.objectStore(z), q = xo(Sd(ye = $.keyPath), ye || "", !0, !1, !!$.autoIncrement, ye && typeof ye != "string", !0), K = [], se = 0; se < $.indexNames.length; ++se) {
            var ae = $.index($.indexNames[se]), ye = ae.keyPath, ae = xo(ae.name, ye, !!ae.unique, !!ae.multiEntry, !1, ye && typeof ye != "string", !1);
            K.push(ae);
          }
          D[z] = dl(z, q, K);
        }), D;
      }
      function Ad(k, A, R) {
        for (var D = R.db.objectStoreNames, z = 0; z < D.length; ++z) {
          var $ = D[z], q = R.objectStore($);
          k._hasGetAll = "getAll" in q;
          for (var K = 0; K < q.indexNames.length; ++K) {
            var se, ye = q.indexNames[K], ae = q.index(ye).keyPath, ae = typeof ae == "string" ? ae : "[" + _(ae).join("+") + "]";
            A[$] && (se = A[$].idxByName[ae]) && (se.name = ye, delete A[$].idxByName[ae], A[$].idxByName[ye] = se);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (k._hasGetAll = !1);
      }
      function my(k) {
        return k.split(",").map(function(A, R) {
          var z = A.split(":"), D = (D = z[1]) == null ? void 0 : D.trim(), z = (A = z[0].trim()).replace(/([&*]|\+\+)/g, ""), $ = /^\[/.test(z) ? z.match(/^\[(.*)\]$/)[1].split("+") : z;
          return xo(z, $ || null, /\&/.test(A), /\*/.test(A), /\+\+/.test(A), a($), R === 0, D);
        });
      }
      ml.prototype._createTableSchema = dl, ml.prototype._parseIndexSyntax = my, ml.prototype._parseStoresSpec = function(k, A) {
        var R = this;
        s(k).forEach(function(D) {
          if (k[D] !== null) {
            var z = R._parseIndexSyntax(k[D]), $ = z.shift();
            if (!$) throw new Ae.Schema("Invalid schema for table " + D + ": " + k[D]);
            if ($.unique = !0, $.multi) throw new Ae.Schema("Primary key cannot be multiEntry*");
            z.forEach(function(q) {
              if (q.auto) throw new Ae.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!q.keyPath) throw new Ae.Schema("Index must have a name and cannot be an empty string");
            }), $ = R._createTableSchema(D, $, z), A[D] = $;
          }
        });
      }, ml.prototype.stores = function(R) {
        var A = this.db, R = (this._cfg.storesSource = this._cfg.storesSource ? c(this._cfg.storesSource, R) : R, A._versions), D = {}, z = {};
        return R.forEach(function($) {
          c(D, $._cfg.storesSource), z = $._cfg.dbschema = {}, $._parseStoresSpec(D, z);
        }), A._dbSchema = z, ru(A, [A._allTables, A, A.Transaction.prototype]), Cd(A, [A._allTables, A, A.Transaction.prototype, this._cfg.tables], s(z), z), A._storeNames = s(z), this;
      }, ml.prototype.upgrade = function(k) {
        return this._cfg.contentUpgrade = An(this._cfg.contentUpgrade || Ge, k), this;
      };
      var y1 = ml;
      function ml() {
      }
      function np(k, A) {
        var R = k._dbNamesDB;
        return R || (R = k._dbNamesDB = new wo(Yc, { addons: [], indexedDB: k, IDBKeyRange: A })).version(1).stores({ dbnames: "name" }), R.table("dbnames");
      }
      function Md(k) {
        return k && typeof k.databases == "function";
      }
      function rp(k) {
        return Nn(function() {
          return Ve.letThrough = !0, k();
        });
      }
      function ip(k) {
        return !("from" in k);
      }
      var zr = function(k, A) {
        var R;
        if (!this) return R = new zr(), k && "d" in k && c(R, k), R;
        c(this, arguments.length ? { d: 1, from: k, to: 1 < arguments.length ? A : k } : { d: 0 });
      };
      function ou(k, A, R) {
        var D = Pt(A, R);
        if (!isNaN(D)) {
          if (0 < D) throw RangeError();
          if (ip(k)) return c(k, { from: A, to: R, d: 1 });
          var D = k.l, z = k.r;
          if (Pt(R, k.from) < 0) return D ? ou(D, A, R) : k.l = { from: A, to: R, d: 1, l: null, r: null }, yy(k);
          if (0 < Pt(A, k.to)) return z ? ou(z, A, R) : k.r = { from: A, to: R, d: 1, l: null, r: null }, yy(k);
          Pt(A, k.from) < 0 && (k.from = A, k.l = null, k.d = z ? z.d + 1 : 1), 0 < Pt(R, k.to) && (k.to = R, k.r = null, k.d = k.l ? k.l.d + 1 : 1), A = !k.r, D && !k.l && ha(k, D), z && A && ha(k, z);
        }
      }
      function ha(k, A) {
        ip(A) || (function R(D, z) {
          var $ = z.from, q = z.l, K = z.r;
          ou(D, $, z.to), q && R(D, q), K && R(D, K);
        })(k, A);
      }
      function gy(k, A) {
        var R = Nd(A), D = R.next();
        if (!D.done) for (var z = D.value, $ = Nd(k), q = $.next(z.from), K = q.value; !D.done && !q.done; ) {
          if (Pt(K.from, z.to) <= 0 && 0 <= Pt(K.to, z.from)) return !0;
          Pt(z.from, K.from) < 0 ? z = (D = R.next(K.from)).value : K = (q = $.next(z.from)).value;
        }
        return !1;
      }
      function Nd(k) {
        var A = ip(k) ? null : { s: 0, n: k };
        return { next: function(R) {
          for (var D = 0 < arguments.length; A; ) switch (A.s) {
            case 0:
              if (A.s = 1, D) for (; A.n.l && Pt(R, A.n.from) < 0; ) A = { up: A, n: A.n.l, s: 1 };
              else for (; A.n.l; ) A = { up: A, n: A.n.l, s: 1 };
            case 1:
              if (A.s = 2, !D || Pt(R, A.n.to) <= 0) return { value: A.n, done: !1 };
            case 2:
              if (A.n.r) {
                A.s = 3, A = { up: A, n: A.n.r, s: 0 };
                continue;
              }
            case 3:
              A = A.up;
          }
          return { done: !0 };
        } };
      }
      function yy(k) {
        var A, R, D, z = (((z = k.r) == null ? void 0 : z.d) || 0) - (((z = k.l) == null ? void 0 : z.d) || 0), z = 1 < z ? "r" : z < -1 ? "l" : "";
        z && (A = z == "r" ? "l" : "r", R = r({}, k), D = k[z], k.from = D.from, k.to = D.to, k[z] = D[z], R[z] = D[A], (k[A] = R).d = op(R)), k.d = op(k);
      }
      function op(R) {
        var A = R.r, R = R.l;
        return (A ? R ? Math.max(A.d, R.d) : A.d : R ? R.d : 0) + 1;
      }
      function Rd(k, A) {
        return s(A).forEach(function(R) {
          k[R] ? ha(k[R], A[R]) : k[R] = (function D(z) {
            var $, q, K = {};
            for ($ in z) h(z, $) && (q = z[$], K[$] = !q || typeof q != "object" || G.has(q.constructor) ? q : D(q));
            return K;
          })(A[R]);
        }), k;
      }
      function sp(k, A) {
        return k.all || A.all || Object.keys(k).some(function(R) {
          return A[R] && gy(A[R], k[R]);
        });
      }
      m(zr.prototype, ((ke = { add: function(k) {
        return ha(this, k), this;
      }, addKey: function(k) {
        return ou(this, k, k), this;
      }, addKeys: function(k) {
        var A = this;
        return k.forEach(function(R) {
          return ou(A, R, R);
        }), this;
      }, hasKey: function(k) {
        var A = Nd(this).next(k).value;
        return A && Pt(A.from, k) <= 0 && 0 <= Pt(A.to, k);
      } })[H] = function() {
        return Nd(this);
      }, ke));
      var pa = {}, ap = {}, lp = !1;
      function Od(k) {
        Rd(ap, k), lp || (lp = !0, setTimeout(function() {
          lp = !1, cp(ap, !(ap = {}));
        }, 0));
      }
      function cp(k, A) {
        A === void 0 && (A = !1);
        var R = /* @__PURE__ */ new Set();
        if (k.all) for (var D = 0, z = Object.values(pa); D < z.length; D++) vy(K = z[D], k, R, A);
        else for (var $ in k) {
          var q, K, $ = /^idb\:\/\/(.*)\/(.*)\//.exec($);
          $ && (q = $[1], $ = $[2], K = pa["idb://".concat(q, "/").concat($)]) && vy(K, k, R, A);
        }
        R.forEach(function(se) {
          return se();
        });
      }
      function vy(k, A, R, D) {
        for (var z = [], $ = 0, q = Object.entries(k.queries.query); $ < q.length; $++) {
          for (var K = q[$], se = K[0], ye = [], ae = 0, oe = K[1]; ae < oe.length; ae++) {
            var ue = oe[ae];
            sp(A, ue.obsSet) ? ue.subscribers.forEach(function(we) {
              return R.add(we);
            }) : D && ye.push(ue);
          }
          D && z.push([se, ye]);
        }
        if (D) for (var fe = 0, le = z; fe < le.length; fe++) {
          var ce = le[fe], se = ce[0], ye = ce[1];
          k.queries.query[se] = ye;
        }
      }
      function v1(k) {
        var A = k._state, R = k._deps.indexedDB;
        if (A.isBeingOpened || k.idbdb) return A.dbReadyPromise.then(function() {
          return A.dbOpenError ? vn(A.dbOpenError) : k;
        });
        A.isBeingOpened = !0, A.dbOpenError = null, A.openComplete = !1;
        var D = A.openCanceller, z = Math.round(10 * k.verno), $ = !1;
        function q() {
          if (A.openCanceller !== D) throw new Ae.DatabaseClosed("db.open() was cancelled");
        }
        function K() {
          return new Ke(function(ue, fe) {
            if (q(), !R) throw new Ae.MissingAPI();
            var le = k.name, ce = A.autoSchema || !z ? R.open(le) : R.open(le, z);
            if (!ce) throw new Ae.MissingAPI();
            ce.onerror = Qi(fe), ce.onblocked = kn(k._fireOnBlocked), ce.onupgradeneeded = kn(function(we) {
              var _e;
              ae = ce.transaction, A.autoSchema && !k._options.allowEmptyDB ? (ce.onerror = ua, ae.abort(), ce.result.close(), (_e = R.deleteDatabase(le)).onsuccess = _e.onerror = kn(function() {
                fe(new Ae.NoSuchDatabase("Database ".concat(le, " doesnt exist")));
              })) : (ae.onerror = Qi(fe), _e = we.oldVersion > Math.pow(2, 62) ? 0 : we.oldVersion, oe = _e < 1, k.idbdb = ce.result, $ && Ed(k, ae), iu(k, _e / 10, ae, fe));
            }, fe), ce.onsuccess = kn(function() {
              ae = null;
              var we, _e, ve, Re, ze, We, qe = k.idbdb = ce.result, Le = _(qe.objectStoreNames);
              if (0 < Le.length) try {
                var Xe = qe.transaction((ze = Le).length === 1 ? ze[0] : ze, "readonly");
                if (A.autoSchema) We = qe, Re = Xe, (ve = k).verno = We.version / 10, Re = ve._dbSchema = pl(0, We, Re), ve._storeNames = _(We.objectStoreNames, 0), Cd(ve, [ve._allTables], s(Re), Re);
                else if (Ad(k, k._dbSchema, Xe), _e = Xe, ((_e = _d(pl(0, (we = k).idbdb, _e), we._dbSchema)).add.length || _e.change.some(function(Ze) {
                  return Ze.add.length || Ze.change.length;
                })) && !$) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), qe.close(), z = qe.version + 1, $ = !0, ue(K());
                ks(k, Xe);
              } catch {
              }
              sa.push(k), qe.onversionchange = kn(function(Ze) {
                A.vcFired = !0, k.on("versionchange").fire(Ze);
              }), qe.onclose = kn(function() {
                k.close({ disableAutoOpen: !1 });
              }), oe && (Le = k._deps, ze = le, Md(We = Le.indexedDB) || ze === Yc || np(We, Le.IDBKeyRange).put({ name: ze }).catch(Ge)), ue();
            }, fe);
          }).catch(function(ue) {
            switch (ue?.name) {
              case "UnknownError":
                if (0 < A.PR1398_maxLoop) return A.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), K();
                break;
              case "VersionError":
                if (0 < z) return z = 0, K();
            }
            return Ke.reject(ue);
          });
        }
        var se, ye = A.dbReadyResolve, ae = null, oe = !1;
        return Ke.race([D, (typeof navigator > "u" ? Ke.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(ue) {
          function fe() {
            return indexedDB.databases().finally(ue);
          }
          se = setInterval(fe, 100), fe();
        }).finally(function() {
          return clearInterval(se);
        }) : Promise.resolve()).then(K)]).then(function() {
          return q(), A.onReadyBeingFired = [], Ke.resolve(rp(function() {
            return k.on.ready.fire(k.vip);
          })).then(function ue() {
            var fe;
            if (0 < A.onReadyBeingFired.length) return fe = A.onReadyBeingFired.reduce(An, Ge), A.onReadyBeingFired = [], Ke.resolve(rp(function() {
              return fe(k.vip);
            })).then(ue);
          });
        }).finally(function() {
          A.openCanceller === D && (A.onReadyBeingFired = null, A.isBeingOpened = !1);
        }).catch(function(ue) {
          A.dbOpenError = ue;
          try {
            ae && ae.abort();
          } catch {
          }
          return D === A.openCanceller && k._close(), vn(ue);
        }).finally(function() {
          A.openComplete = !0, ye();
        }).then(function() {
          var ue;
          return oe && (ue = {}, k.tables.forEach(function(fe) {
            fe.schema.indexes.forEach(function(le) {
              le.name && (ue["idb://".concat(k.name, "/").concat(fe.name, "/").concat(le.name)] = new zr(-1 / 0, [[[]]]));
            }), ue["idb://".concat(k.name, "/").concat(fe.name, "/")] = ue["idb://".concat(k.name, "/").concat(fe.name, "/:dels")] = new zr(-1 / 0, [[[]]]);
          }), Ir(ul).fire(ue), cp(ue, !0)), k;
        });
      }
      function su(k) {
        function A($) {
          return k.next($);
        }
        var R = z(A), D = z(function($) {
          return k.throw($);
        });
        function z($) {
          return function(K) {
            var K = $(K), se = K.value;
            return K.done ? se : se && typeof se.then == "function" ? se.then(R, D) : a(se) ? Promise.all(se).then(R, D) : R(se);
          };
        }
        return z(A)();
      }
      function Cs(k, A, R) {
        for (var D = a(k) ? k.slice() : [k], z = 0; z < R; ++z) D.push(A);
        return D;
      }
      var b1 = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(k) {
        return r(r({}, k), { table: function(D) {
          var R = k.table(D), D = R.schema, z = {}, $ = [];
          function q(ue, fe, le) {
            var ve = pr(ue), ce = z[ve] = z[ve] || [], we = ue == null ? 0 : typeof ue == "string" ? 1 : ue.length, _e = 0 < fe, ve = r(r({}, le), { name: _e ? "".concat(ve, "(virtual-from:").concat(le.name, ")") : le.name, lowLevelIndex: le, isVirtual: _e, keyTail: fe, keyLength: we, extractKey: hl(ue), unique: !_e && le.unique });
            return ce.push(ve), ve.isPrimaryKey || $.push(ve), 1 < we && q(we === 2 ? ue[0] : ue.slice(0, we - 1), fe + 1, le), ce.sort(function(Re, ze) {
              return Re.keyTail - ze.keyTail;
            }), ve;
          }
          var K = q(D.primaryKey.keyPath, 0, D.primaryKey);
          z[":id"] = [K];
          for (var se = 0, ye = D.indexes; se < ye.length; se++) {
            var ae = ye[se];
            q(ae.keyPath, 0, ae);
          }
          function oe(ue) {
            var fe, le = ue.query.index;
            return le.isVirtual ? r(r({}, ue), { query: { index: le.lowLevelIndex, range: (fe = ue.query.range, le = le.keyTail, { type: fe.type === 1 ? 2 : fe.type, lower: Cs(fe.lower, fe.lowerOpen ? k.MAX_KEY : k.MIN_KEY, le), lowerOpen: !0, upper: Cs(fe.upper, fe.upperOpen ? k.MIN_KEY : k.MAX_KEY, le), upperOpen: !0 }) } }) : ue;
          }
          return r(r({}, R), { schema: r(r({}, D), { primaryKey: K, indexes: $, getIndexByKeyPath: function(ue) {
            return (ue = z[pr(ue)]) && ue[0];
          } }), count: function(ue) {
            return R.count(oe(ue));
          }, query: function(ue) {
            return R.query(oe(ue));
          }, openCursor: function(ue) {
            var fe = ue.query.index, le = fe.keyTail, ce = fe.keyLength;
            return fe.isVirtual ? R.openCursor(oe(ue)).then(function(_e) {
              return _e && we(_e);
            }) : R.openCursor(ue);
            function we(_e) {
              return Object.create(_e, { continue: { value: function(ve) {
                ve != null ? _e.continue(Cs(ve, ue.reverse ? k.MAX_KEY : k.MIN_KEY, le)) : ue.unique ? _e.continue(_e.key.slice(0, ce).concat(ue.reverse ? k.MIN_KEY : k.MAX_KEY, le)) : _e.continue();
              } }, continuePrimaryKey: { value: function(ve, Re) {
                _e.continuePrimaryKey(Cs(ve, k.MAX_KEY, le), Re);
              } }, primaryKey: { get: function() {
                return _e.primaryKey;
              } }, key: { get: function() {
                var ve = _e.key;
                return ce === 1 ? ve[0] : ve.slice(0, ce);
              } }, value: { get: function() {
                return _e.value;
              } } });
            }
          } });
        } });
      } };
      function Dd(k, A, R, D) {
        return R = R || {}, D = D || "", s(k).forEach(function(z) {
          var $, q, K;
          h(A, z) ? ($ = k[z], q = A[z], typeof $ == "object" && typeof q == "object" && $ && q ? (K = ne($)) !== ne(q) ? R[D + z] = A[z] : K === "Object" ? Dd($, q, R, D + z + ".") : $ !== q && (R[D + z] = A[z]) : $ !== q && (R[D + z] = A[z])) : R[D + z] = void 0;
        }), s(A).forEach(function(z) {
          h(k, z) || (R[D + z] = A[z]);
        }), R;
      }
      function Pd(k, A) {
        return A.type === "delete" ? A.keys : A.keys || A.values.map(k.extractKey);
      }
      var by = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(k) {
        return r(r({}, k), { table: function(A) {
          var R = k.table(A), D = R.schema.primaryKey;
          return r(r({}, R), { mutate: function(z) {
            var $ = Ve.trans, q = $.table(A).hook, K = q.deleting, se = q.creating, ye = q.updating;
            switch (z.type) {
              case "add":
                if (se.fire === Ge) break;
                return $._promise("readwrite", function() {
                  return ae(z);
                }, !0);
              case "put":
                if (se.fire === Ge && ye.fire === Ge) break;
                return $._promise("readwrite", function() {
                  return ae(z);
                }, !0);
              case "delete":
                if (K.fire === Ge) break;
                return $._promise("readwrite", function() {
                  return ae(z);
                }, !0);
              case "deleteRange":
                if (K.fire === Ge) break;
                return $._promise("readwrite", function() {
                  return (function oe(ue, fe, le) {
                    return R.query({ trans: ue, values: !1, query: { index: D, range: fe }, limit: le }).then(function(ce) {
                      var we = ce.result;
                      return ae({ type: "delete", keys: we, trans: ue }).then(function(_e) {
                        return 0 < _e.numFailures ? Promise.reject(_e.failures[0]) : we.length < le ? { failures: [], numFailures: 0, lastResult: void 0 } : oe(ue, r(r({}, fe), { lower: we[we.length - 1], lowerOpen: !0 }), le);
                      });
                    });
                  })(z.trans, z.range, 1e4);
                }, !0);
            }
            return R.mutate(z);
            function ae(oe) {
              var ue, fe, le, ce = Ve.trans, we = oe.keys || Pd(D, oe);
              if (we) return (oe = oe.type === "add" || oe.type === "put" ? r(r({}, oe), { keys: we }) : r({}, oe)).type !== "delete" && (oe.values = i([], oe.values)), oe.keys && (oe.keys = i([], oe.keys)), ue = R, le = we, ((fe = oe).type === "add" ? Promise.resolve([]) : ue.getMany({ trans: fe.trans, keys: le, cache: "immutable" })).then(function(_e) {
                var ve = we.map(function(Re, ze) {
                  var We, qe, Le, Xe = _e[ze], Ze = { onerror: null, onsuccess: null };
                  return oe.type === "delete" ? K.fire.call(Ze, Re, Xe, ce) : oe.type === "add" || Xe === void 0 ? (We = se.fire.call(Ze, Re, oe.values[ze], ce), Re == null && We != null && (oe.keys[ze] = Re = We, D.outbound || O(oe.values[ze], D.keyPath, Re))) : (We = Dd(Xe, oe.values[ze]), (qe = ye.fire.call(Ze, We, Re, Xe, ce)) && (Le = oe.values[ze], Object.keys(qe).forEach(function(Be) {
                    h(Le, Be) ? Le[Be] = qe[Be] : O(Le, Be, qe[Be]);
                  }))), Ze;
                });
                return R.mutate(oe).then(function(Re) {
                  for (var ze = Re.failures, We = Re.results, qe = Re.numFailures, Re = Re.lastResult, Le = 0; Le < we.length; ++Le) {
                    var Xe = (We || we)[Le], Ze = ve[Le];
                    Xe == null ? Ze.onerror && Ze.onerror(ze[Le]) : Ze.onsuccess && Ze.onsuccess(oe.type === "put" && _e[Le] ? oe.values[Le] : Xe);
                  }
                  return { failures: ze, results: We, numFailures: qe, lastResult: Re };
                }).catch(function(Re) {
                  return ve.forEach(function(ze) {
                    return ze.onerror && ze.onerror(Re);
                  }), Promise.reject(Re);
                });
              });
              throw new Error("Keys missing");
            }
          } });
        } });
      } };
      function up(k, A, R) {
        try {
          if (!A || A.keys.length < k.length) return null;
          for (var D = [], z = 0, $ = 0; z < A.keys.length && $ < k.length; ++z) Pt(A.keys[z], k[$]) === 0 && (D.push(R ? he(A.values[z]) : A.values[z]), ++$);
          return D.length === k.length ? D : null;
        } catch {
          return null;
        }
      }
      var xy = { stack: "dbcore", level: -1, create: function(k) {
        return { table: function(A) {
          var R = k.table(A);
          return r(r({}, R), { getMany: function(D) {
            var z;
            return D.cache ? (z = up(D.keys, D.trans._cache, D.cache === "clone")) ? Ke.resolve(z) : R.getMany(D).then(function($) {
              return D.trans._cache = { keys: D.keys, values: D.cache === "clone" ? he($) : $ }, $;
            }) : R.getMany(D);
          }, mutate: function(D) {
            return D.type !== "add" && (D.trans._cache = null), R.mutate(D);
          } });
        } };
      } };
      function ma(k, A) {
        return k.trans.mode === "readonly" && !!k.subscr && !k.trans.explicit && k.trans.db._options.cache !== "disabled" && !A.schema.primaryKey.outbound;
      }
      function wy(k, A) {
        switch (k) {
          case "query":
            return A.values && !A.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var x1 = { stack: "dbcore", level: 0, name: "Observability", create: function(k) {
        var A = k.schema.name, R = new zr(k.MIN_KEY, k.MAX_KEY);
        return r(r({}, k), { transaction: function(D, z, $) {
          if (Ve.subscr && z !== "readonly") throw new Ae.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(Ve.querier));
          return k.transaction(D, z, $);
        }, table: function(D) {
          function z(we) {
            var ce, we = we.query;
            return [ce = we.index, new zr((ce = (we = we.range).lower) != null ? ce : k.MIN_KEY, (ce = we.upper) != null ? ce : k.MAX_KEY)];
          }
          var $ = k.table(D), q = $.schema, K = q.primaryKey, se = q.indexes, ye = K.extractKey, ae = K.outbound, oe = K.autoIncrement && se.filter(function(le) {
            return le.compound && le.keyPath.includes(K.keyPath);
          }), ue = r(r({}, $), { mutate: function(le) {
            function ce(Je) {
              return Je = "idb://".concat(A, "/").concat(D, "/").concat(Je), ze[Je] || (ze[Je] = new zr());
            }
            var we, _e, ve, Re = le.trans, ze = le.mutatedParts || (le.mutatedParts = {}), We = ce(""), qe = ce(":dels"), Le = le.type, Ze = le.type === "deleteRange" ? [le.range] : le.type === "delete" ? [le.keys] : le.values.length < 50 ? [Pd(K, le).filter(function(Je) {
              return Je;
            }), le.values] : [], Xe = Ze[0], Ze = Ze[1], Be = le.trans._cache;
            return a(Xe) ? (We.addKeys(Xe), (Le = Le === "delete" || Xe.length === Ze.length ? up(Xe, Be) : null) || qe.addKeys(Xe), (Le || Ze) && (we = ce, _e = Le, ve = Ze, q.indexes.forEach(function(Je) {
              var wt = we(Je.name || "");
              function Bt(Tt) {
                return Tt != null ? Je.extractKey(Tt) : null;
              }
              function dt(Tt) {
                Je.multiEntry && a(Tt) ? Tt.forEach(function(bn) {
                  return wt.addKey(bn);
                }) : wt.addKey(Tt);
              }
              (_e || ve).forEach(function(Tt, un) {
                var ci = _e && Bt(_e[un]), un = ve && Bt(ve[un]);
                Pt(ci, un) !== 0 && (ci != null && dt(ci), un != null) && dt(un);
              });
            }))) : Xe ? (Ze = { from: (Be = Xe.lower) != null ? Be : k.MIN_KEY, to: (Le = Xe.upper) != null ? Le : k.MAX_KEY }, qe.add(Ze), We.add(Ze)) : (We.add(R), qe.add(R), q.indexes.forEach(function(Je) {
              return ce(Je.name).add(R);
            })), $.mutate(le).then(function(Je) {
              return !Xe || le.type !== "add" && le.type !== "put" || (We.addKeys(Je.results), oe && oe.forEach(function(wt) {
                for (var Bt = le.values.map(function(ci) {
                  return wt.extractKey(ci);
                }), dt = wt.keyPath.findIndex(function(ci) {
                  return ci === K.keyPath;
                }), Tt = 0, bn = Je.results.length; Tt < bn; ++Tt) Bt[Tt][dt] = Je.results[Tt];
                ce(wt.name).addKeys(Bt);
              })), Re.mutatedParts = Rd(Re.mutatedParts || {}, ze), Je;
            });
          } }), fe = { get: function(le) {
            return [K, new zr(le.key)];
          }, getMany: function(le) {
            return [K, new zr().addKeys(le.keys)];
          }, count: z, query: z, openCursor: z };
          return s(fe).forEach(function(le) {
            ue[le] = function(ce) {
              var we = Ve.subscr, _e = !!we, ve = ma(Ve, $) && wy(le, ce) ? ce.obsSet = {} : we;
              if (_e) {
                var Re, we = function(Ze) {
                  return Ze = "idb://".concat(A, "/").concat(D, "/").concat(Ze), ve[Ze] || (ve[Ze] = new zr());
                }, ze = we(""), We = we(":dels"), _e = fe[le](ce), qe = _e[0], _e = _e[1];
                if ((le === "query" && qe.isPrimaryKey && !ce.values ? We : we(qe.name || "")).add(_e), !qe.isPrimaryKey) {
                  if (le !== "count") return Re = le === "query" && ae && ce.values && $.query(r(r({}, ce), { values: !1 })), $[le].apply(this, arguments).then(function(Ze) {
                    if (le === "query") {
                      if (ae && ce.values) return Re.then(function(Bt) {
                        return Bt = Bt.result, ze.addKeys(Bt), Ze;
                      });
                      var Be = ce.values ? Ze.result.map(ye) : Ze.result;
                      (ce.values ? ze : We).addKeys(Be);
                    } else {
                      var Je, wt;
                      if (le === "openCursor") return wt = ce.values, (Je = Ze) && Object.create(Je, { key: { get: function() {
                        return We.addKey(Je.primaryKey), Je.key;
                      } }, primaryKey: { get: function() {
                        var Bt = Je.primaryKey;
                        return We.addKey(Bt), Bt;
                      } }, value: { get: function() {
                        return wt && ze.addKey(Je.primaryKey), Je.value;
                      } } });
                    }
                    return Ze;
                  });
                  We.add(R);
                }
              }
              return $[le].apply(this, arguments);
            };
          }), ue;
        } });
      } };
      function Sy(k, A, R) {
        var D;
        return R.numFailures === 0 ? A : A.type === "deleteRange" || (D = A.keys ? A.keys.length : "values" in A && A.values ? A.values.length : 1, R.numFailures === D) ? null : (D = r({}, A), a(D.keys) && (D.keys = D.keys.filter(function(z, $) {
          return !($ in R.failures);
        })), "values" in D && a(D.values) && (D.values = D.values.filter(function(z, $) {
          return !($ in R.failures);
        })), D);
      }
      function jd(k, A) {
        return R = k, ((D = A).lower === void 0 || (D.lowerOpen ? 0 < Pt(R, D.lower) : 0 <= Pt(R, D.lower))) && (R = k, (D = A).upper === void 0 || (D.upperOpen ? Pt(R, D.upper) < 0 : Pt(R, D.upper) <= 0));
        var R, D;
      }
      function dp(k, A, R, D, z, $) {
        var q, K, se, ye, ae, oe;
        return !R || R.length === 0 || (q = A.query.index, K = q.multiEntry, se = A.query.range, ye = D.schema.primaryKey.extractKey, ae = q.extractKey, oe = (q.lowLevelIndex || q).extractKey, (D = R.reduce(function(ue, fe) {
          var le = ue, ce = [];
          if (fe.type === "add" || fe.type === "put") for (var we = new zr(), _e = fe.values.length - 1; 0 <= _e; --_e) {
            var ve, Re = fe.values[_e], ze = ye(Re);
            !we.hasKey(ze) && (ve = ae(Re), K && a(ve) ? ve.some(function(Ze) {
              return jd(Ze, se);
            }) : jd(ve, se)) && (we.addKey(ze), ce.push(Re));
          }
          switch (fe.type) {
            case "add":
              var We = new zr().addKeys(A.values ? ue.map(function(Be) {
                return ye(Be);
              }) : ue), le = ue.concat(A.values ? ce.filter(function(Be) {
                return Be = ye(Be), !We.hasKey(Be) && (We.addKey(Be), !0);
              }) : ce.map(function(Be) {
                return ye(Be);
              }).filter(function(Be) {
                return !We.hasKey(Be) && (We.addKey(Be), !0);
              }));
              break;
            case "put":
              var qe = new zr().addKeys(fe.values.map(function(Be) {
                return ye(Be);
              }));
              le = ue.filter(function(Be) {
                return !qe.hasKey(A.values ? ye(Be) : Be);
              }).concat(A.values ? ce : ce.map(function(Be) {
                return ye(Be);
              }));
              break;
            case "delete":
              var Le = new zr().addKeys(fe.keys);
              le = ue.filter(function(Be) {
                return !Le.hasKey(A.values ? ye(Be) : Be);
              });
              break;
            case "deleteRange":
              var Xe = fe.range;
              le = ue.filter(function(Be) {
                return !jd(ye(Be), Xe);
              });
          }
          return le;
        }, k)) === k) ? k : (D.sort(function(ue, fe) {
          return Pt(oe(ue), oe(fe)) || Pt(ye(ue), ye(fe));
        }), A.limit && A.limit < 1 / 0 && (D.length > A.limit ? D.length = A.limit : k.length === A.limit && D.length < A.limit && (z.dirty = !0)), $ ? Object.freeze(D) : D);
      }
      function gl(k, A) {
        return Pt(k.lower, A.lower) === 0 && Pt(k.upper, A.upper) === 0 && !!k.lowerOpen == !!A.lowerOpen && !!k.upperOpen == !!A.upperOpen;
      }
      function au(k, A) {
        return ((R, D, z, $) => {
          if (R === void 0) return D !== void 0 ? -1 : 0;
          if (D === void 0) return 1;
          if ((R = Pt(R, D)) === 0) {
            if (z && $) return 0;
            if (z) return 1;
            if ($) return -1;
          }
          return R;
        })(k.lower, A.lower, k.lowerOpen, A.lowerOpen) <= 0 && 0 <= ((R, D, z, $) => {
          if (R === void 0) return D !== void 0 ? 1 : 0;
          if (D === void 0) return -1;
          if ((R = Pt(R, D)) === 0) {
            if (z && $) return 0;
            if (z) return -1;
            if ($) return 1;
          }
          return R;
        })(k.upper, A.upper, k.upperOpen, A.upperOpen);
      }
      function w1(k, A, R, D) {
        k.subscribers.add(R), D.addEventListener("abort", function() {
          var z, $;
          k.subscribers.delete(R), k.subscribers.size === 0 && (z = k, $ = A, setTimeout(function() {
            z.subscribers.size === 0 && X($, z);
          }, 3e3));
        });
      }
      var Id = { stack: "dbcore", level: 0, name: "Cache", create: function(k) {
        var A = k.schema.name;
        return r(r({}, k), { transaction: function(R, D, z) {
          var $, q, K = k.transaction(R, D, z);
          return D === "readwrite" && (z = ($ = new AbortController()).signal, K.addEventListener("abort", (q = function(se) {
            return function() {
              if ($.abort(), D === "readwrite") {
                for (var ye = /* @__PURE__ */ new Set(), ae = 0, oe = R; ae < oe.length; ae++) {
                  var ue = oe[ae], fe = pa["idb://".concat(A, "/").concat(ue)];
                  if (fe) {
                    var le = k.table(ue), ce = fe.optimisticOps.filter(function(Je) {
                      return Je.trans === K;
                    });
                    if (K._explicit && se && K.mutatedParts) for (var we = 0, _e = Object.values(fe.queries.query); we < _e.length; we++) for (var ve = 0, Re = (qe = _e[we]).slice(); ve < Re.length; ve++) sp((Le = Re[ve]).obsSet, K.mutatedParts) && (X(qe, Le), Le.subscribers.forEach(function(Je) {
                      return ye.add(Je);
                    }));
                    else if (0 < ce.length) {
                      fe.optimisticOps = fe.optimisticOps.filter(function(Je) {
                        return Je.trans !== K;
                      });
                      for (var ze = 0, We = Object.values(fe.queries.query); ze < We.length; ze++) for (var qe, Le, Xe, Ze = 0, Be = (qe = We[ze]).slice(); Ze < Be.length; Ze++) (Le = Be[Ze]).res != null && K.mutatedParts && (se && !Le.dirty ? (Xe = Object.isFrozen(Le.res), Xe = dp(Le.res, Le.req, ce, le, Le, Xe), Le.dirty ? (X(qe, Le), Le.subscribers.forEach(function(Je) {
                        return ye.add(Je);
                      })) : Xe !== Le.res && (Le.res = Xe, Le.promise = Ke.resolve({ result: Xe }))) : (Le.dirty && X(qe, Le), Le.subscribers.forEach(function(Je) {
                        return ye.add(Je);
                      })));
                    }
                  }
                }
                ye.forEach(function(Je) {
                  return Je();
                });
              }
            };
          })(!1), { signal: z }), K.addEventListener("error", q(!1), { signal: z }), K.addEventListener("complete", q(!0), { signal: z })), K;
        }, table: function(R) {
          var D = k.table(R), z = D.schema.primaryKey;
          return r(r({}, D), { mutate: function($) {
            var q, K = Ve.trans;
            return !z.outbound && K.db._options.cache !== "disabled" && !K.explicit && K.idbtrans.mode === "readwrite" && (q = pa["idb://".concat(A, "/").concat(R)]) ? (K = D.mutate($), $.type !== "add" && $.type !== "put" || !(50 <= $.values.length || Pd(z, $).some(function(se) {
              return se == null;
            })) ? (q.optimisticOps.push($), $.mutatedParts && Od($.mutatedParts), K.then(function(se) {
              0 < se.numFailures && (X(q.optimisticOps, $), (se = Sy(0, $, se)) && q.optimisticOps.push(se), $.mutatedParts) && Od($.mutatedParts);
            }), K.catch(function() {
              X(q.optimisticOps, $), $.mutatedParts && Od($.mutatedParts);
            })) : K.then(function(se) {
              var ye = Sy(0, r(r({}, $), { values: $.values.map(function(ae, oe) {
                var ue;
                return se.failures[oe] ? ae : (O(ue = (ue = z.keyPath) != null && ue.includes(".") ? he(ae) : r({}, ae), z.keyPath, se.results[oe]), ue);
              }) }), se);
              q.optimisticOps.push(ye), queueMicrotask(function() {
                return $.mutatedParts && Od($.mutatedParts);
              });
            }), K) : D.mutate($);
          }, query: function($) {
            var q, K, se, ye, ae, oe, ue;
            return ma(Ve, D) && wy("query", $) ? (q = ((se = Ve.trans) == null ? void 0 : se.db._options.cache) === "immutable", K = (se = Ve).requery, se = se.signal, oe = ((fe, le, ce, we) => {
              var _e = pa["idb://".concat(fe, "/").concat(le)];
              if (!_e) return [];
              if (!(fe = _e.queries[ce])) return [null, !1, _e, null];
              var ve = fe[(we.query ? we.query.index.name : null) || ""];
              if (!ve) return [null, !1, _e, null];
              switch (ce) {
                case "query":
                  var Re = ve.find(function(ze) {
                    return ze.req.limit === we.limit && ze.req.values === we.values && gl(ze.req.query.range, we.query.range);
                  });
                  return Re ? [Re, !0, _e, ve] : [ve.find(function(ze) {
                    return ("limit" in ze.req ? ze.req.limit : 1 / 0) >= we.limit && (!we.values || ze.req.values) && au(ze.req.query.range, we.query.range);
                  }), !1, _e, ve];
                case "count":
                  return Re = ve.find(function(ze) {
                    return gl(ze.req.query.range, we.query.range);
                  }), [Re, !!Re, _e, ve];
              }
            })(A, R, "query", $), ue = oe[0], ye = oe[2], ae = oe[3], ue && oe[1] ? ue.obsSet = $.obsSet : (oe = D.query($).then(function(fe) {
              var le = fe.result;
              if (ue && (ue.res = le), q) {
                for (var ce = 0, we = le.length; ce < we; ++ce) Object.freeze(le[ce]);
                Object.freeze(le);
              } else fe.result = he(le);
              return fe;
            }).catch(function(fe) {
              return ae && ue && X(ae, ue), Promise.reject(fe);
            }), ue = { obsSet: $.obsSet, promise: oe, subscribers: /* @__PURE__ */ new Set(), type: "query", req: $, dirty: !1 }, ae ? ae.push(ue) : (ae = [ue], (ye = ye || (pa["idb://".concat(A, "/").concat(R)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[$.query.index.name || ""] = ae)), w1(ue, ae, K, se), ue.promise.then(function(fe) {
              return { result: dp(fe.result, $, ye?.optimisticOps, D, ue, q) };
            })) : D.query($);
          } });
        } });
      } };
      function lu(k, A) {
        return new Proxy(k, { get: function(R, D, z) {
          return D === "db" ? A : Reflect.get(R, D, z);
        } });
      }
      zn.prototype.version = function(k) {
        if (isNaN(k) || k < 0.1) throw new Ae.Type("Given version is not a positive number");
        if (k = Math.round(10 * k) / 10, this.idbdb || this._state.isBeingOpened) throw new Ae.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, k);
        var A = this._versions, R = A.filter(function(D) {
          return D._cfg.version === k;
        })[0];
        return R || (R = new this.Version(k), A.push(R), A.sort(ep), R.stores({}), this._state.autoSchema = !1), R;
      }, zn.prototype._whenReady = function(k) {
        var A = this;
        return this.idbdb && (this._state.openComplete || Ve.letThrough || this._vip) ? k() : new Ke(function(R, D) {
          if (A._state.openComplete) return D(new Ae.DatabaseClosed(A._state.dbOpenError));
          if (!A._state.isBeingOpened) {
            if (!A._state.autoOpen) return void D(new Ae.DatabaseClosed());
            A.open().catch(Ge);
          }
          A._state.dbReadyPromise.then(R, D);
        }).then(k);
      }, zn.prototype.use = function(z) {
        var A = z.stack, R = z.create, D = z.level, z = z.name, $ = (z && this.unuse({ stack: A, name: z }), this._middlewares[A] || (this._middlewares[A] = []));
        return $.push({ stack: A, create: R, level: D ?? 10, name: z }), $.sort(function(q, K) {
          return q.level - K.level;
        }), this;
      }, zn.prototype.unuse = function(k) {
        var A = k.stack, R = k.name, D = k.create;
        return A && this._middlewares[A] && (this._middlewares[A] = this._middlewares[A].filter(function(z) {
          return D ? z.create !== D : !!R && z.name !== R;
        })), this;
      }, zn.prototype.open = function() {
        var k = this;
        return Xi(jn, function() {
          return v1(k);
        });
      }, zn.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var k = this._state, A = sa.indexOf(this);
        if (0 <= A && sa.splice(A, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        k.isBeingOpened || (k.dbReadyPromise = new Ke(function(R) {
          k.dbReadyResolve = R;
        }), k.openCanceller = new Ke(function(R, D) {
          k.cancelOpen = D;
        }));
      }, zn.prototype.close = function(A) {
        var A = (A === void 0 ? { disableAutoOpen: !0 } : A).disableAutoOpen, R = this._state;
        A ? (R.isBeingOpened && R.cancelOpen(new Ae.DatabaseClosed()), this._close(), R.autoOpen = !1, R.dbOpenError = new Ae.DatabaseClosed()) : (this._close(), R.autoOpen = this._options.autoOpen || R.isBeingOpened, R.openComplete = !1, R.dbOpenError = null);
      }, zn.prototype.delete = function(k) {
        var A = this, R = (k === void 0 && (k = { disableAutoOpen: !0 }), 0 < arguments.length && typeof arguments[0] != "object"), D = this._state;
        return new Ke(function(z, $) {
          function q() {
            A.close(k);
            var K = A._deps.indexedDB.deleteDatabase(A.name);
            K.onsuccess = kn(function() {
              var se, ye, ae;
              se = A._deps, ye = A.name, Md(ae = se.indexedDB) || ye === Yc || np(ae, se.IDBKeyRange).delete(ye).catch(Ge), z();
            }), K.onerror = Qi($), K.onblocked = A._fireOnBlocked;
          }
          if (R) throw new Ae.InvalidArgument("Invalid closeOptions argument to db.delete()");
          D.isBeingOpened ? D.dbReadyPromise.then(q) : q();
        });
      }, zn.prototype.backendDB = function() {
        return this.idbdb;
      }, zn.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, zn.prototype.hasBeenClosed = function() {
        var k = this._state.dbOpenError;
        return k && k.name === "DatabaseClosed";
      }, zn.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, zn.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(zn.prototype, "tables", { get: function() {
        var k = this;
        return s(this._allTables).map(function(A) {
          return k._allTables[A];
        });
      }, enumerable: !1, configurable: !0 }), zn.prototype.transaction = function() {
        var k = (function(A, R, D) {
          var z = arguments.length;
          if (z < 2) throw new Ae.InvalidArgument("Too few arguments");
          for (var $ = new Array(z - 1); --z; ) $[z - 1] = arguments[z];
          return D = $.pop(), [A, B($), D];
        }).apply(this, arguments);
        return this._transaction.apply(this, k);
      }, zn.prototype._transaction = function(k, A, R) {
        var D, z, $ = this, q = Ve.trans, K = (q && q.db === this && k.indexOf("!") === -1 || (q = null), k.indexOf("?") !== -1);
        k = k.replace("!", "").replace("?", "");
        try {
          if (z = A.map(function(ye) {
            if (ye = ye instanceof $.Table ? ye.name : ye, typeof ye != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return ye;
          }), k == "r" || k === Zo) D = Zo;
          else {
            if (k != "rw" && k != ws) throw new Ae.InvalidArgument("Invalid transaction mode: " + k);
            D = ws;
          }
          if (q) {
            if (q.mode === Zo && D === ws) {
              if (!K) throw new Ae.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              q = null;
            }
            q && z.forEach(function(ye) {
              if (q && q.storeNames.indexOf(ye) === -1) {
                if (!K) throw new Ae.SubTransaction("Table " + ye + " not included in parent transaction.");
                q = null;
              }
            }), K && q && !q.active && (q = null);
          }
        } catch (ye) {
          return q ? q._promise(null, function(ae, oe) {
            oe(ye);
          }) : vn(ye);
        }
        var se = (function ye(ae, oe, ue, fe, le) {
          return Ke.resolve().then(function() {
            var ve = Ve.transless || Ve, ce = ae._createTransaction(oe, ue, ae._dbSchema, fe), ve = (ce.explicit = !0, { trans: ce, transless: ve });
            if (fe) ce.idbtrans = fe.idbtrans;
            else try {
              ce.create(), ce.idbtrans._explicit = !0, ae._state.PR1398_maxLoop = 3;
            } catch (Re) {
              return Re.name === xe.InvalidState && ae.isOpen() && 0 < --ae._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), ae.close({ disableAutoOpen: !1 }), ae.open().then(function() {
                return ye(ae, oe, ue, null, le);
              })) : vn(Re);
            }
            var we, _e = Z(le), ve = (_e && ar(), Ke.follow(function() {
              var Re;
              (we = le.call(ce, ce)) && (_e ? (Re = wi.bind(null, null), we.then(Re, Re)) : typeof we.next == "function" && typeof we.throw == "function" && (we = su(we)));
            }, ve));
            return (we && typeof we.then == "function" ? Ke.resolve(we).then(function(Re) {
              return ce.active ? Re : vn(new Ae.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : ve.then(function() {
              return we;
            })).then(function(Re) {
              return fe && ce._resolve(), ce._completion.then(function() {
                return Re;
              });
            }).catch(function(Re) {
              return ce._reject(Re), vn(Re);
            });
          });
        }).bind(null, this, D, z, q, R);
        return q ? q._promise(D, se, "lock") : Ve.trans ? Xi(Ve.transless, function() {
          return $._whenReady(se);
        }) : this._whenReady(se);
      }, zn.prototype.table = function(k) {
        if (h(this._allTables, k)) return this._allTables[k];
        throw new Ae.InvalidTable("Table ".concat(k, " does not exist"));
      };
      var wo = zn;
      function zn(k, A) {
        var R, D, z, $, q, K = this, se = (this._middlewares = {}, this.verno = 0, zn.dependencies), se = (this._options = A = r({ addons: zn.addons, autoOpen: !0, indexedDB: se.indexedDB, IDBKeyRange: se.IDBKeyRange, cache: "cloned" }, A), this._deps = { indexedDB: A.indexedDB, IDBKeyRange: A.IDBKeyRange }, A.addons), ye = (this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this, { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Ge, dbReadyPromise: null, cancelOpen: Ge, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: A.autoOpen }), ae = (ye.dbReadyPromise = new Ke(function(oe) {
          ye.dbReadyResolve = oe;
        }), ye.openCanceller = new Ke(function(oe, ue) {
          ye.cancelOpen = ue;
        }), this._state = ye, this.name = k, this.on = Qc(this, "populate", "blocked", "versionchange", "close", { ready: [An, Ge] }), this.once = function(oe, ue) {
          var fe = function() {
            for (var le = [], ce = 0; ce < arguments.length; ce++) le[ce] = arguments[ce];
            K.on(oe).unsubscribe(fe), ue.apply(K, le);
          };
          return K.on(oe, fe);
        }, this.on.ready.subscribe = M(this.on.ready.subscribe, function(oe) {
          return function(ue, fe) {
            zn.vip(function() {
              var le, ce = K._state;
              ce.openComplete ? (ce.dbOpenError || Ke.resolve().then(ue), fe && oe(ue)) : ce.onReadyBeingFired ? (ce.onReadyBeingFired.push(ue), fe && oe(ue)) : (oe(ue), le = K, fe || oe(function we() {
                le.on.ready.unsubscribe(ue), le.on.ready.unsubscribe(we);
              }));
            });
          };
        }), this.Collection = (R = this, jr(m1.prototype, function(we, ce) {
          this.db = R;
          var fe = Kh, le = null;
          if (ce) try {
            fe = ce();
          } catch (ve) {
            le = ve;
          }
          var ce = we._ctx, we = ce.table, _e = we.hook.reading.fire;
          this._ctx = { table: we, index: ce.index, isPrimKey: !ce.index || we.schema.primKey.keyPath && ce.index === we.schema.primKey.name, range: fe, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: le, or: ce.or, valueMapper: _e !== nt ? _e : null };
        })), this.Table = (D = this, jr(Zh.prototype, function(oe, ue, fe) {
          this.db = D, this._tx = fe, this.name = oe, this.schema = ue, this.hook = D._allTables[oe] ? D._allTables[oe].hook : Qc(null, { creating: [St, Ge], reading: [_t, nt], updating: [xt, Ge], deleting: [Vt, Ge] });
        })), this.Transaction = (z = this, jr(Qh.prototype, function(oe, ue, fe, le, ce) {
          var we = this;
          oe !== "readonly" && ue.forEach(function(_e) {
            _e = (_e = fe[_e]) == null ? void 0 : _e.yProps, _e && (ue = ue.concat(_e.map(function(ve) {
              return ve.updatesTable;
            })));
          }), this.db = z, this.mode = oe, this.storeNames = ue, this.schema = fe, this.chromeTransactionDurability = le, this.idbtrans = null, this.on = Qc(this, "complete", "error", "abort"), this.parent = ce || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Ke(function(_e, ve) {
            we._resolve = _e, we._reject = ve;
          }), this._completion.then(function() {
            we.active = !1, we.on.complete.fire();
          }, function(_e) {
            var ve = we.active;
            return we.active = !1, we.on.error.fire(_e), we.parent ? we.parent._reject(_e) : ve && we.idbtrans && we.idbtrans.abort(), vn(_e);
          });
        })), this.Version = ($ = this, jr(y1.prototype, function(oe) {
          this.db = $, this._cfg = { version: oe, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (q = this, jr(ca.prototype, function(oe, ue, fe) {
          if (this.db = q, this._ctx = { table: oe, index: ue === ":id" ? null : ue, or: fe }, this._cmp = this._ascending = Pt, this._descending = function(le, ce) {
            return Pt(ce, le);
          }, this._max = function(le, ce) {
            return 0 < Pt(le, ce) ? le : ce;
          }, this._min = function(le, ce) {
            return Pt(le, ce) < 0 ? le : ce;
          }, this._IDBKeyRange = q._deps.IDBKeyRange, !this._IDBKeyRange) throw new Ae.MissingAPI();
        })), this.on("versionchange", function(oe) {
          0 < oe.newVersion ? console.warn("Another connection wants to upgrade database '".concat(K.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(K.name, "'. Closing db now to resume the delete request.")), K.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(oe) {
          !oe.newVersion || oe.newVersion < oe.oldVersion ? console.warn("Dexie.delete('".concat(K.name, "') was blocked")) : console.warn("Upgrade '".concat(K.name, "' blocked by other connection holding version ").concat(oe.oldVersion / 10));
        }), this._maxKey = fl(A.IDBKeyRange), this._createTransaction = function(oe, ue, fe, le) {
          return new K.Transaction(oe, ue, fe, K._options.chromeTransactionDurability, le);
        }, this._fireOnBlocked = function(oe) {
          K.on("blocked").fire(oe), sa.filter(function(ue) {
            return ue.name === K.name && ue !== K && !ue._state.vcFired;
          }).map(function(ue) {
            return ue.on("versionchange").fire(oe);
          });
        }, this.use(xy), this.use(Id), this.use(x1), this.use(b1), this.use(by), new Proxy(this, { get: function(oe, ue, fe) {
          var le;
          return ue === "_vip" || (ue === "table" ? function(ce) {
            return lu(K.table(ce), ae);
          } : (le = Reflect.get(oe, ue, fe)) instanceof Zh ? lu(le, ae) : ue === "tables" ? le.map(function(ce) {
            return lu(ce, ae);
          }) : ue === "_createTransaction" ? function() {
            return lu(le.apply(this, arguments), ae);
          } : le);
        } }));
        this.vip = ae, se.forEach(function(oe) {
          return oe(K);
        });
      }
      var yl, ga = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", ky = (zd.prototype.subscribe = function(k, A, R) {
        return this._subscribe(k && typeof k != "function" ? k : { next: k, error: A, complete: R });
      }, zd.prototype[ga] = function() {
        return this;
      }, zd);
      function zd(k) {
        this._subscribe = k;
      }
      try {
        yl = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        yl = { indexedDB: null, IDBKeyRange: null };
      }
      function Cy(k) {
        var A, R = !1, D = new ky(function(z) {
          var $ = Z(k), q, K = !1, se = {}, ye = {}, ae = { get closed() {
            return K;
          }, unsubscribe: function() {
            K || (K = !0, q && q.abort(), oe && Ir.storagemutated.unsubscribe(fe));
          } }, oe = (z.start && z.start(ae), !1), ue = function() {
            return xs(le);
          }, fe = function(ce) {
            Rd(se, ce), sp(ye, se) && ue();
          }, le = function() {
            var ce, we, _e;
            !K && yl.indexedDB && (se = {}, ce = {}, q && q.abort(), q = new AbortController(), _e = ((ve) => {
              var Re = ys();
              try {
                $ && ar();
                var ze = Nn(k, ve);
                return ze = $ ? ze.finally(wi) : ze;
              } finally {
                Re && yo();
              }
            })(we = { subscr: ce, signal: q.signal, requery: ue, querier: k, trans: null }), Promise.resolve(_e).then(function(ve) {
              R = !0, A = ve, K || we.signal.aborted || (se = {}, ((Re) => {
                for (var ze in Re) if (h(Re, ze)) return;
                return 1;
              })(ye = ce) || oe || (Ir(ul, fe), oe = !0), xs(function() {
                return !K && z.next && z.next(ve);
              }));
            }, function(ve) {
              R = !1, ["DatabaseClosedError", "AbortError"].includes(ve?.name) || K || xs(function() {
                K || z.error && z.error(ve);
              });
            }));
          };
          return setTimeout(ue, 0), ae;
        });
        return D.hasValue = function() {
          return R;
        }, D.getValue = function() {
          return A;
        }, D;
      }
      var ya = wo;
      function fp(k) {
        var A = Es;
        try {
          Es = !0, Ir.storagemutated.fire(k), cp(k, !0);
        } finally {
          Es = A;
        }
      }
      m(ya, r(r({}, pe), { delete: function(k) {
        return new ya(k, { addons: [] }).delete();
      }, exists: function(k) {
        return new ya(k, { addons: [] }).open().then(function(A) {
          return A.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(k) {
        try {
          return A = ya.dependencies, R = A.indexedDB, A = A.IDBKeyRange, (Md(R) ? Promise.resolve(R.databases()).then(function(D) {
            return D.map(function(z) {
              return z.name;
            }).filter(function(z) {
              return z !== Yc;
            });
          }) : np(R, A).toCollection().primaryKeys()).then(k);
        } catch {
          return vn(new Ae.MissingAPI());
        }
        var A, R;
      }, defineClass: function() {
        return function(k) {
          c(this, k);
        };
      }, ignoreTransaction: function(k) {
        return Ve.trans ? Xi(Ve.transless, k) : k();
      }, vip: rp, async: function(k) {
        return function() {
          try {
            var A = su(k.apply(this, arguments));
            return A && typeof A.then == "function" ? A : Ke.resolve(A);
          } catch (R) {
            return vn(R);
          }
        };
      }, spawn: function(k, A, R) {
        try {
          var D = su(k.apply(R, A || []));
          return D && typeof D.then == "function" ? D : Ke.resolve(D);
        } catch (z) {
          return vn(z);
        }
      }, currentTransaction: { get: function() {
        return Ve.trans || null;
      } }, waitFor: function(k, A) {
        return k = Ke.resolve(typeof k == "function" ? ya.ignoreTransaction(k) : k).timeout(A || 6e4), Ve.trans ? Ve.trans.waitFor(k) : k;
      }, Promise: Ke, debug: { get: function() {
        return Nt;
      }, set: function(k) {
        sn(k);
      } }, derive: x, extend: c, props: m, override: M, Events: Qc, on: Ir, liveQuery: Cy, extendObservabilitySet: Rd, getByKeyPath: I, setByKeyPath: O, delByKeyPath: function(k, A) {
        typeof A == "string" ? O(k, A, void 0) : "length" in A && [].map.call(A, function(R) {
          O(k, R, void 0);
        });
      }, shallowClone: L, deepClone: he, getObjectDiff: Dd, cmp: Pt, asap: P, minKey: -1 / 0, addons: [], connections: sa, errnames: xe, dependencies: yl, cache: pa, semVer: "4.3.0", version: "4.3.0".split(".").map(function(k) {
        return parseInt(k);
      }).reduce(function(k, A, R) {
        return k + A / Math.pow(10, 2 * R);
      }) })), ya.maxKey = fl(ya.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Ir(ul, function(k) {
        Es || (k = new CustomEvent(da, { detail: k }), Es = !0, dispatchEvent(k), Es = !1);
      }), addEventListener(da, function(k) {
        k = k.detail, Es || fp(k);
      }));
      var vl, Es = !1, li = function() {
      };
      return typeof BroadcastChannel < "u" && ((li = function() {
        (vl = new BroadcastChannel(da)).onmessage = function(k) {
          return k.data && fp(k.data);
        };
      })(), typeof vl.unref == "function" && vl.unref(), Ir(ul, function(k) {
        Es || vl.postMessage(k);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(k) {
        if (!wo.disableBfCache && k.persisted) {
          Nt && console.debug("Dexie: handling persisted pagehide"), vl?.close();
          for (var A = 0, R = sa; A < R.length; A++) R[A].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(k) {
        !wo.disableBfCache && k.persisted && (Nt && console.debug("Dexie: handling persisted pageshow"), li(), fp({ all: new zr(-1 / 0, [[]]) }));
      })), Ke.rejectionMapper = function(k, A) {
        return !k || k instanceof ee || k instanceof TypeError || k instanceof SyntaxError || !k.name || !tt[k.name] ? k : (A = new tt[k.name](A || k.message, k), "stack" in k && b(A, "stack", { get: function() {
          return this.inner.stack;
        } }), A);
      }, sn(Nt), r(wo, Object.freeze({ __proto__: null, Dexie: wo, Entity: dy, PropModification: cl, RangeSet: zr, add: function(k) {
        return new cl({ add: k });
      }, cmp: Pt, default: wo, liveQuery: Cy, mergeRanges: ha, rangesOverlap: gy, remove: function(k) {
        return new cl({ remove: k });
      }, replacePrefix: function(k, A) {
        return new cl({ replacePrefix: [k, A] });
      } }), { default: wo }), wo;
    });
  })(O0)), O0.exports;
}
var ppe = hpe();
const M_ = /* @__PURE__ */ Dc(ppe), sI = /* @__PURE__ */ Symbol.for("Dexie"), cc = globalThis[sI] || (globalThis[sI] = M_);
if (M_.semVer !== cc.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${M_.semVer} and ${cc.semVer}`);
const {
  liveQuery: xLe,
  mergeRanges: wLe,
  rangesOverlap: SLe,
  RangeSet: kLe,
  cmp: CLe,
  Entity: ELe,
  PropModification: _Le,
  replacePrefix: TLe,
  add: ALe,
  remove: MLe,
  DexieYProvider: NLe
} = cc;
class mpe extends cc {
  messages;
  threads;
  constructor() {
    super("ChatbotDB"), this.version(1).stores({
      messages: "id, threadId, createdAt, [threadId+createdAt]",
      threads: "id, lastMessageAt"
    });
  }
}
const Vi = new mpe(), ss = {
  /**
   * Save messages to IndexedDB
   */
  async saveMessages(e, t) {
    const n = t.map((r) => ({
      id: r.id,
      threadId: e,
      role: r.role,
      parts: r.parts || [],
      metadata: r.metadata,
      createdAt: r.createdAt || /* @__PURE__ */ new Date()
    }));
    if (await Vi.messages.bulkPut(n), t.length > 0) {
      const r = t[t.length - 1], i = ss.extractTextFromMessage(r);
      await Vi.threads.put({
        id: e,
        lastMessageText: i,
        lastMessageAt: r.createdAt || /* @__PURE__ */ new Date(),
        messageCount: t.length
      });
    }
  },
  /**
   * Get messages from IndexedDB
   */
  async getMessages(e, t) {
    return t && t > 0 ? (await Vi.messages.where("[threadId+createdAt]").between([e, cc.minKey], [e, cc.maxKey]).reverse().limit(t).toArray()).reverse() : Vi.messages.where("threadId").equals(e).sortBy("createdAt");
  },
  /**
   * Get paginated messages (for infinite scroll)
   */
  async getMessagesPaginated(e, t, n = 20) {
    return (await Vi.messages.where("[threadId+createdAt]").between(
      [e, /* @__PURE__ */ new Date(0)],
      [e, t]
    ).reverse().limit(n).toArray()).reverse();
  },
  /**
   * Delete old messages to free up space
   */
  async pruneOldMessages(e, t = 100) {
    const r = await Vi.messages.where("threadId").equals(e).count() - t;
    if (r <= 0) return;
    const i = await Vi.messages.where("[threadId+createdAt]").between([e, cc.minKey], [e, cc.maxKey]).limit(r).primaryKeys();
    i.length > 0 && await Vi.messages.bulkDelete(i);
  },
  /**
   * Delete all messages for a thread
   */
  async deleteThread(e) {
    await Vi.messages.where("threadId").equals(e).delete(), await Vi.threads.delete(e);
  },
  /**
   * Get thread metadata
   */
  async getThreadMetadata(e) {
    return await Vi.threads.get(e);
  },
  /**
   * Get all threads metadata
   */
  async getAllThreads() {
    return await Vi.threads.orderBy("lastMessageAt").reverse().toArray();
  },
  /**
   * Extract text from message for preview
   */
  extractTextFromMessage(e) {
    if (!e.parts || e.parts.length === 0) return "";
    const t = e.parts.find((n) => n.type === "text");
    return t && typeof t.text == "string" ? t.text.substring(0, 100) : "";
  },
  /**
   * Get database size estimation
   */
  async getStorageStats() {
    const e = await Vi.messages.count(), t = await Vi.threads.count(), n = e * 3 * 1024, r = this.formatBytes(n);
    return {
      messageCount: e,
      threadCount: t,
      estimatedSize: r
    };
  },
  formatBytes(e) {
    if (e === 0) return "0 Bytes";
    const t = 1024, n = ["Bytes", "KB", "MB", "GB"], r = Math.floor(Math.log(e) / Math.log(t));
    return Math.round(e / Math.pow(t, r) * 100) / 100 + " " + n[r];
  }
}, aC = 3e4, aI = 5;
function gpe(e, t = 50, n = !0) {
  const [r, i] = C.useState([]), [o, s] = C.useState({
    nextCursor: null,
    hasMore: !0,
    isLoading: !1,
    isLoadingMore: !1,
    isFromCache: !1
  }), a = C.useRef(!1), c = C.useRef(e), u = C.useRef(
    /* @__PURE__ */ new Map()
  );
  C.useEffect(() => {
    if (c.current !== e) {
      c.current = e;
      const m = u.current.get(e);
      if (m && Date.now() - m.updatedAt < aC) {
        i(m.messages), s(m.pagination), a.current = !1;
        return;
      }
      i([]), s({
        nextCursor: null,
        hasMore: !0,
        isLoading: !1,
        isLoadingMore: !1,
        isFromCache: !1
      }), a.current = !1;
    }
  }, [e]), C.useEffect(() => {
    if (!n || o.isLoading || o.isLoadingMore || r.length === 0 && o.nextCursor === null && o.hasMore && !o.isFromCache) return;
    const g = Date.now(), b = u.current, x = [];
    if (b.forEach((w, S) => {
      g - w.updatedAt > aC && x.push(S);
    }), x.forEach((w) => b.delete(w)), b.size >= aI) {
      const S = Array.from(b.entries()).sort((_, M) => M[1].updatedAt - _[1].updatedAt).slice(0, aI);
      b.clear(), S.forEach(([_, M]) => b.set(_, M));
    }
    b.set(e, {
      messages: r,
      pagination: o,
      updatedAt: g
    });
  }, [n, e, r, o]), C.useEffect(() => {
    if (!n || r.length > 0 || a.current) return;
    const m = u.current.get(e);
    if (m && Date.now() - m.updatedAt < aC) {
      console.log(" Using in-memory cache, skipping load");
      return;
    }
    (async () => {
      const b = e;
      console.log(" Starting load initial messages..."), a.current = !0, s((x) => ({ ...x, isLoading: !0 }));
      try {
        console.time(" Load from IndexedDB");
        const x = await ss.getMessages(b, t);
        if (console.timeEnd(" Load from IndexedDB"), c.current !== b) return;
        if (x.length > 0) {
          console.log(" Using IndexedDB cache, skipping server fetch");
          const S = x.map((_) => ({
            id: _.id,
            role: _.role,
            parts: _.parts,
            metadata: _.metadata,
            createdAt: _.createdAt
          }));
          i(S), s({
            nextCursor: null,
            hasMore: x.length >= t,
            isLoading: !1,
            isLoadingMore: !1,
            isFromCache: !0
          }), a.current = !1;
          return;
        }
        console.log(" No cached messages found, fetching from server..."), console.time(" Load from Server");
        const w = await nI(b, { limit: t });
        if (console.timeEnd(" Load from Server"), c.current !== b) return;
        i(w.messages || []), s({
          nextCursor: w.nextCursor,
          hasMore: w.hasMore,
          isLoading: !1,
          isLoadingMore: !1,
          isFromCache: !1
        }), w.messages && w.messages.length > 0 && (console.time(" Save to IndexedDB"), await ss.saveMessages(b, w.messages), console.timeEnd(" Save to IndexedDB"));
      } catch (x) {
        console.error(" Failed to load messages:", x), s((w) => ({ ...w, isLoading: !1 }));
      } finally {
        a.current = !1;
      }
    })();
  }, [n, e, t, r.length]);
  const f = C.useCallback(async () => {
    if (!n || a.current || !o.hasMore || !o.nextCursor)
      return;
    const m = e;
    a.current = !0, s((g) => ({ ...g, isLoadingMore: !0 }));
    try {
      const g = r[0];
      if (g && g.createdAt) {
        console.time(" Load more from IndexedDB");
        const x = await ss.getMessagesPaginated(
          m,
          g.createdAt,
          t
        );
        if (console.timeEnd(" Load more from IndexedDB"), c.current !== m) return;
        if (x.length > 0) {
          const w = x.map((S) => ({
            id: S.id,
            role: S.role,
            parts: S.parts,
            metadata: S.metadata,
            createdAt: S.createdAt
          }));
          i((S) => {
            const _ = new Set(S.map((N) => N.id));
            return [...w.filter((N) => !_.has(N.id)), ...S];
          });
        }
      }
      console.time(" Load more from Server");
      const b = await nI(m, {
        limit: t,
        cursor: o.nextCursor,
        direction: "older"
      });
      if (console.timeEnd(" Load more from Server"), c.current !== m) return;
      i((x) => {
        const w = new Set(x.map((_) => _.id)), S = (b.messages || []).filter((_) => !w.has(_.id));
        return [...x, ...S];
      }), s((x) => ({
        ...x,
        nextCursor: b.nextCursor,
        hasMore: b.hasMore,
        isLoadingMore: !1
      })), b.messages && b.messages.length > 0 && (console.time(" Save more to IndexedDB"), await ss.saveMessages(m, b.messages), console.timeEnd(" Save more to IndexedDB"));
    } catch (g) {
      console.error(" Failed to load more messages:", g), s((b) => ({ ...b, isLoadingMore: !1 }));
    } finally {
      a.current = !1;
    }
  }, [n, e, t, o.hasMore, o.nextCursor, r]), h = C.useCallback(() => {
    i([]), s({
      nextCursor: null,
      hasMore: !0,
      isLoading: !1,
      isLoadingMore: !1,
      isFromCache: !1
    }), a.current = !1;
  }, []);
  return {
    messages: r,
    pagination: o,
    loadMore: f,
    reset: h
  };
}
function ype(e) {
  C.useEffect(() => {
    try {
      localStorage.setItem(mb.AI_USE_NEXT_SUGGESTION, JSON.stringify(e.value));
    } catch (t) {
      console.error("Error saving useNextSuggestion to localStorage:", t);
    }
  }, [e.value]), C.useEffect(() => {
    try {
      const t = localStorage.getItem(mb.AI_USE_NEXT_SUGGESTION);
      t !== null && (e.value = JSON.parse(t));
    } catch (t) {
      console.error("Error loading useNextSuggestion from localStorage:", t);
    }
  }, [e]);
}
function vpe({
  threadId: e,
  enabled: t = !0,
  maxInMemory: n = 20
}) {
  const [r, i] = C.useState(!1), [o, s] = C.useState(null), a = C.useCallback(
    async (m) => {
      if (!(!t || !e))
        try {
          i(!0), s(null), await ss.saveMessages(e, m), await ss.pruneOldMessages(e, 500);
        } catch (g) {
          console.error("Failed to save messages to IndexedDB:", g), s(g);
        } finally {
          i(!1);
        }
    },
    [e, t, n]
  ), c = C.useCallback(
    async (m) => {
      if (!t || !e) return [];
      try {
        i(!0), s(null);
        const g = m ?? n;
        return (await ss.getMessages(
          e,
          g
        )).map((x) => ({
          id: x.id,
          role: x.role,
          parts: x.parts,
          metadata: x.metadata,
          createdAt: x.createdAt
        }));
      } catch (g) {
        return console.error("Failed to load messages from IndexedDB:", g), s(g), [];
      } finally {
        i(!1);
      }
    },
    [e, t, n]
  ), u = C.useCallback(
    async (m, g = 20) => {
      if (!t || !e) return [];
      try {
        return (await ss.getMessagesPaginated(
          e,
          m,
          g
        )).map((x) => ({
          id: x.id,
          role: x.role,
          parts: x.parts,
          metadata: x.metadata,
          createdAt: x.createdAt
        }));
      } catch (b) {
        return console.error("Failed to load older messages from IndexedDB:", b), s(b), [];
      }
    },
    [e, t]
  ), f = C.useCallback(async () => {
    if (!(!t || !e))
      try {
        await ss.deleteThread(e);
      } catch (m) {
        console.error("Failed to delete thread from IndexedDB:", m), s(m);
      }
  }, [e, t]), h = C.useCallback(async () => {
    if (!t) return null;
    try {
      return await ss.getStorageStats();
    } catch (m) {
      return console.error("Failed to get storage stats:", m), null;
    }
  }, [t]);
  return {
    saveMessages: a,
    loadMessages: c,
    loadOlderMessages: u,
    deleteThread: f,
    getStorageStats: h,
    isLoading: r,
    error: o
  };
}
var c8 = "vercel.ai.error", bpe = Symbol.for(c8), lI, cI, Js = class u8 extends (cI = Error, lI = bpe, cI) {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: t,
    message: n,
    cause: r
  }) {
    super(n), this[lI] = !0, this.name = t, this.cause = r;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(t) {
    return u8.hasMarker(t, c8);
  }
  static hasMarker(t, n) {
    const r = Symbol.for(n);
    return t != null && typeof t == "object" && r in t && typeof t[r] == "boolean" && t[r] === !0;
  }
};
function EM(e) {
  return e == null ? "unknown error" : typeof e == "string" ? e : e instanceof Error ? e.message : JSON.stringify(e);
}
var d8 = "AI_InvalidArgumentError", f8 = `vercel.ai.error.${d8}`, xpe = Symbol.for(f8), uI, dI, wpe = class extends (dI = Js, uI = xpe, dI) {
  constructor({
    message: e,
    cause: t,
    argument: n
  }) {
    super({ name: d8, message: e, cause: t }), this[uI] = !0, this.argument = n;
  }
  static isInstance(e) {
    return Js.hasMarker(e, f8);
  }
}, h8 = "AI_JSONParseError", p8 = `vercel.ai.error.${h8}`, Spe = Symbol.for(p8), fI, hI, pI = class extends (hI = Js, fI = Spe, hI) {
  constructor({ text: e, cause: t }) {
    super({
      name: h8,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${EM(t)}`,
      cause: t
    }), this[fI] = !0, this.text = e;
  }
  static isInstance(e) {
    return Js.hasMarker(e, p8);
  }
}, m8 = "AI_TypeValidationError", g8 = `vercel.ai.error.${m8}`, kpe = Symbol.for(g8), mI, gI, Eb = class N_ extends (gI = Js, mI = kpe, gI) {
  constructor({ value: t, cause: n }) {
    super({
      name: m8,
      message: `Type validation failed: Value: ${JSON.stringify(t)}.
Error message: ${EM(n)}`,
      cause: n
    }), this[mI] = !0, this.value = t;
  }
  static isInstance(t) {
    return Js.hasMarker(t, g8);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: t,
    cause: n
  }) {
    return N_.isInstance(n) && n.value === t ? n : new N_({ value: t, cause: n });
  }
};
class yI extends Error {
  constructor(t, n) {
    super(t), this.name = "ParseError", this.type = n.type, this.field = n.field, this.value = n.value, this.line = n.line;
  }
}
function lC(e) {
}
function Cpe(e) {
  if (typeof e == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent: t = lC, onError: n = lC, onRetry: r = lC, onComment: i } = e;
  let o = "", s = !0, a, c = "", u = "";
  function f(x) {
    const w = s ? x.replace(/^\xEF\xBB\xBF/, "") : x, [S, _] = Epe(`${o}${w}`);
    for (const M of S)
      h(M);
    o = _, s = !1;
  }
  function h(x) {
    if (x === "") {
      g();
      return;
    }
    if (x.startsWith(":")) {
      i && i(x.slice(x.startsWith(": ") ? 2 : 1));
      return;
    }
    const w = x.indexOf(":");
    if (w !== -1) {
      const S = x.slice(0, w), _ = x[w + 1] === " " ? 2 : 1, M = x.slice(w + _);
      m(S, M, x);
      return;
    }
    m(x, "", x);
  }
  function m(x, w, S) {
    switch (x) {
      case "event":
        u = w;
        break;
      case "data":
        c = `${c}${w}
`;
        break;
      case "id":
        a = w.includes("\0") ? void 0 : w;
        break;
      case "retry":
        /^\d+$/.test(w) ? r(parseInt(w, 10)) : n(
          new yI(`Invalid \`retry\` value: "${w}"`, {
            type: "invalid-retry",
            value: w,
            line: S
          })
        );
        break;
      default:
        n(
          new yI(
            `Unknown field "${x.length > 20 ? `${x.slice(0, 20)}` : x}"`,
            { type: "unknown-field", field: x, value: w, line: S }
          )
        );
        break;
    }
  }
  function g() {
    c.length > 0 && t({
      id: a,
      event: u || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: c.endsWith(`
`) ? c.slice(0, -1) : c
    }), a = void 0, c = "", u = "";
  }
  function b(x = {}) {
    o && x.consume && h(o), s = !0, a = void 0, c = "", u = "", o = "";
  }
  return { feed: f, reset: b };
}
function Epe(e) {
  const t = [];
  let n = "", r = 0;
  for (; r < e.length; ) {
    const i = e.indexOf("\r", r), o = e.indexOf(`
`, r);
    let s = -1;
    if (i !== -1 && o !== -1 ? s = Math.min(i, o) : i !== -1 ? i === e.length - 1 ? s = -1 : s = i : o !== -1 && (s = o), s === -1) {
      n = e.slice(r);
      break;
    } else {
      const a = e.slice(r, s);
      t.push(a), r = s + 1, e[r - 1] === "\r" && e[r] === `
` && r++;
    }
  }
  return [t, n];
}
class _pe extends TransformStream {
  constructor({ onError: t, onRetry: n, onComment: r } = {}) {
    let i;
    super({
      start(o) {
        i = Cpe({
          onEvent: (s) => {
            o.enqueue(s);
          },
          onError(s) {
            t === "terminate" ? o.error(s) : typeof t == "function" && t(s);
          },
          onRetry: n,
          onComment: r
        });
      },
      transform(o) {
        i.feed(o);
      }
    });
  }
}
function De(e, t, n) {
  function r(a, c) {
    if (a._zod || Object.defineProperty(a, "_zod", {
      value: {
        def: c,
        constr: s,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), a._zod.traits.has(e))
      return;
    a._zod.traits.add(e), t(a, c);
    const u = s.prototype, f = Object.keys(u);
    for (let h = 0; h < f.length; h++) {
      const m = f[h];
      m in a || (a[m] = u[m].bind(a));
    }
  }
  const i = n?.Parent ?? Object;
  class o extends i {
  }
  Object.defineProperty(o, "name", { value: e });
  function s(a) {
    var c;
    const u = n?.Parent ? new o() : this;
    r(u, a), (c = u._zod).deferred ?? (c.deferred = []);
    for (const f of u._zod.deferred)
      f();
    return u;
  }
  return Object.defineProperty(s, "init", { value: r }), Object.defineProperty(s, Symbol.hasInstance, {
    value: (a) => n?.Parent && a instanceof n.Parent ? !0 : a?._zod?.traits?.has(e)
  }), Object.defineProperty(s, "name", { value: e }), s;
}
class Yf extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class y8 extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
}
const v8 = {};
function Mc(e) {
  return v8;
}
function b8(e) {
  const t = Object.values(e).filter((r) => typeof r == "number");
  return Object.entries(e).filter(([r, i]) => t.indexOf(+r) === -1).map(([r, i]) => i);
}
function R_(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function Aw(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function _M(e) {
  return e == null;
}
function TM(e) {
  const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function Tpe(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = t.toString();
  let i = (r.split(".")[1] || "").length;
  if (i === 0 && /\d?e-\d?/.test(r)) {
    const c = r.match(/\d?e-(\d?)/);
    c?.[1] && (i = Number.parseInt(c[1]));
  }
  const o = n > i ? n : i, s = Number.parseInt(e.toFixed(o).replace(".", "")), a = Number.parseInt(t.toFixed(o).replace(".", ""));
  return s % a / 10 ** o;
}
const vI = /* @__PURE__ */ Symbol("evaluating");
function en(e, t, n) {
  let r;
  Object.defineProperty(e, t, {
    get() {
      if (r !== vI)
        return r === void 0 && (r = vI, r = n()), r;
    },
    set(i) {
      Object.defineProperty(e, t, {
        value: i
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function fd(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function Bc(...e) {
  const t = {};
  for (const n of e) {
    const r = Object.getOwnPropertyDescriptors(n);
    Object.assign(t, r);
  }
  return Object.defineProperties({}, t);
}
function bI(e) {
  return JSON.stringify(e);
}
function Ape(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const x8 = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function ig(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const Mpe = Aw(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function uh(e) {
  if (ig(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0 || typeof t != "function")
    return !0;
  const n = t.prototype;
  return !(ig(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
function w8(e) {
  return uh(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
const Npe = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function dh(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function $c(e, t, n) {
  const r = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (r._zod.parent = e), r;
}
function ct(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function Rpe(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const Ope = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function Dpe(e, t) {
  const n = e._zod.def, r = n.checks;
  if (r && r.length > 0)
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  const o = Bc(e._zod.def, {
    get shape() {
      const s = {};
      for (const a in t) {
        if (!(a in n.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        t[a] && (s[a] = n.shape[a]);
      }
      return fd(this, "shape", s), s;
    },
    checks: []
  });
  return $c(e, o);
}
function Ppe(e, t) {
  const n = e._zod.def, r = n.checks;
  if (r && r.length > 0)
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  const o = Bc(e._zod.def, {
    get shape() {
      const s = { ...e._zod.def.shape };
      for (const a in t) {
        if (!(a in n.shape))
          throw new Error(`Unrecognized key: "${a}"`);
        t[a] && delete s[a];
      }
      return fd(this, "shape", s), s;
    },
    checks: []
  });
  return $c(e, o);
}
function jpe(e, t) {
  if (!uh(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const n = e._zod.def.checks;
  if (n && n.length > 0) {
    const o = e._zod.def.shape;
    for (const s in t)
      if (Object.getOwnPropertyDescriptor(o, s) !== void 0)
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  const i = Bc(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape, ...t };
      return fd(this, "shape", o), o;
    }
  });
  return $c(e, i);
}
function Ipe(e, t) {
  if (!uh(t))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const n = Bc(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t };
      return fd(this, "shape", r), r;
    }
  });
  return $c(e, n);
}
function zpe(e, t) {
  const n = Bc(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t._zod.def.shape };
      return fd(this, "shape", r), r;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return $c(e, n);
}
function Lpe(e, t, n) {
  const i = t._zod.def.checks;
  if (i && i.length > 0)
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  const s = Bc(t._zod.def, {
    get shape() {
      const a = t._zod.def.shape, c = { ...a };
      if (n)
        for (const u in n) {
          if (!(u in a))
            throw new Error(`Unrecognized key: "${u}"`);
          n[u] && (c[u] = e ? new e({
            type: "optional",
            innerType: a[u]
          }) : a[u]);
        }
      else
        for (const u in a)
          c[u] = e ? new e({
            type: "optional",
            innerType: a[u]
          }) : a[u];
      return fd(this, "shape", c), c;
    },
    checks: []
  });
  return $c(t, s);
}
function Bpe(e, t, n) {
  const r = Bc(t._zod.def, {
    get shape() {
      const i = t._zod.def.shape, o = { ...i };
      if (n)
        for (const s in n) {
          if (!(s in o))
            throw new Error(`Unrecognized key: "${s}"`);
          n[s] && (o[s] = new e({
            type: "nonoptional",
            innerType: i[s]
          }));
        }
      else
        for (const s in i)
          o[s] = new e({
            type: "nonoptional",
            innerType: i[s]
          });
      return fd(this, "shape", o), o;
    }
  });
  return $c(t, r);
}
function zf(e, t = 0) {
  if (e.aborted === !0)
    return !0;
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n]?.continue !== !0)
      return !0;
  return !1;
}
function Lf(e, t) {
  return t.map((n) => {
    var r;
    return (r = n).path ?? (r.path = []), n.path.unshift(e), n;
  });
}
function $v(e) {
  return typeof e == "string" ? e : e?.message;
}
function Nc(e, t, n) {
  const r = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const i = $v(e.inst?._zod.def?.error?.(e)) ?? $v(t?.error?.(e)) ?? $v(n.customError?.(e)) ?? $v(n.localeError?.(e)) ?? "Invalid input";
    r.message = i;
  }
  return delete r.inst, delete r.continue, t?.reportInput || delete r.input, r;
}
function AM(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function og(...e) {
  const [t, n, r] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: n,
    inst: r
  } : { ...t };
}
const S8 = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, R_, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, k8 = De("$ZodError", S8), C8 = De("$ZodError", S8, { Parent: Error });
function $pe(e, t = (n) => n.message) {
  const n = {}, r = [];
  for (const i of e.issues)
    i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
  return { formErrors: r, fieldErrors: n };
}
function Upe(e, t = (n) => n.message) {
  const n = { _errors: [] }, r = (i) => {
    for (const o of i.issues)
      if (o.code === "invalid_union" && o.errors.length)
        o.errors.map((s) => r({ issues: s }));
      else if (o.code === "invalid_key")
        r({ issues: o.issues });
      else if (o.code === "invalid_element")
        r({ issues: o.issues });
      else if (o.path.length === 0)
        n._errors.push(t(o));
      else {
        let s = n, a = 0;
        for (; a < o.path.length; ) {
          const c = o.path[a];
          a === o.path.length - 1 ? (s[c] = s[c] || { _errors: [] }, s[c]._errors.push(t(o))) : s[c] = s[c] || { _errors: [] }, s = s[c], a++;
        }
      }
  };
  return r(e), n;
}
const MM = (e) => (t, n, r, i) => {
  const o = r ? Object.assign(r, { async: !1 }) : { async: !1 }, s = t._zod.run({ value: n, issues: [] }, o);
  if (s instanceof Promise)
    throw new Yf();
  if (s.issues.length) {
    const a = new (i?.Err ?? e)(s.issues.map((c) => Nc(c, o, Mc())));
    throw x8(a, i?.callee), a;
  }
  return s.value;
}, NM = (e) => async (t, n, r, i) => {
  const o = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let s = t._zod.run({ value: n, issues: [] }, o);
  if (s instanceof Promise && (s = await s), s.issues.length) {
    const a = new (i?.Err ?? e)(s.issues.map((c) => Nc(c, o, Mc())));
    throw x8(a, i?.callee), a;
  }
  return s.value;
}, Mw = (e) => (t, n, r) => {
  const i = r ? { ...r, async: !1 } : { async: !1 }, o = t._zod.run({ value: n, issues: [] }, i);
  if (o instanceof Promise)
    throw new Yf();
  return o.issues.length ? {
    success: !1,
    error: new (e ?? k8)(o.issues.map((s) => Nc(s, i, Mc())))
  } : { success: !0, data: o.value };
}, Fpe = /* @__PURE__ */ Mw(C8), Nw = (e) => async (t, n, r) => {
  const i = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let o = t._zod.run({ value: n, issues: [] }, i);
  return o instanceof Promise && (o = await o), o.issues.length ? {
    success: !1,
    error: new e(o.issues.map((s) => Nc(s, i, Mc())))
  } : { success: !0, data: o.value };
}, Vpe = /* @__PURE__ */ Nw(C8), Hpe = (e) => (t, n, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return MM(e)(t, n, i);
}, Wpe = (e) => (t, n, r) => MM(e)(t, n, r), qpe = (e) => async (t, n, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return NM(e)(t, n, i);
}, Gpe = (e) => async (t, n, r) => NM(e)(t, n, r), Kpe = (e) => (t, n, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Mw(e)(t, n, i);
}, Zpe = (e) => (t, n, r) => Mw(e)(t, n, r), Ype = (e) => async (t, n, r) => {
  const i = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Nw(e)(t, n, i);
}, Xpe = (e) => async (t, n, r) => Nw(e)(t, n, r), Jpe = /^[cC][^\s-]{8,}$/, Qpe = /^[0-9a-z]+$/, eme = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, tme = /^[0-9a-vA-V]{20}$/, nme = /^[A-Za-z0-9]{27}$/, rme = /^[a-zA-Z0-9_-]{21}$/, ime = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, ome = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, xI = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, sme = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, ame = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function lme() {
  return new RegExp(ame, "u");
}
const cme = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ume = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, dme = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, fme = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, hme = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, E8 = /^[A-Za-z0-9_-]*$/, pme = /^\+[1-9]\d{6,14}$/, _8 = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", mme = /* @__PURE__ */ new RegExp(`^${_8}$`);
function T8(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function gme(e) {
  return new RegExp(`^${T8(e)}$`);
}
function yme(e) {
  const t = T8({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const r = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${_8}T(?:${r})$`);
}
const vme = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, bme = /^-?\d+$/, A8 = /^-?\d+(?:\.\d+)?$/, xme = /^(?:true|false)$/i, wme = /^null$/i, Sme = /^[^A-Z]*$/, kme = /^[^a-z]*$/, Zi = /* @__PURE__ */ De("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), M8 = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, N8 = /* @__PURE__ */ De("$ZodCheckLessThan", (e, t) => {
  Zi.init(e, t);
  const n = M8[typeof t.value];
  e._zod.onattach.push((r) => {
    const i = r._zod.bag, o = (t.inclusive ? i.maximum : i.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < o && (t.inclusive ? i.maximum = t.value : i.exclusiveMaximum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value <= t.value : r.value < t.value) || r.issues.push({
      origin: n,
      code: "too_big",
      maximum: typeof t.value == "object" ? t.value.getTime() : t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), R8 = /* @__PURE__ */ De("$ZodCheckGreaterThan", (e, t) => {
  Zi.init(e, t);
  const n = M8[typeof t.value];
  e._zod.onattach.push((r) => {
    const i = r._zod.bag, o = (t.inclusive ? i.minimum : i.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > o && (t.inclusive ? i.minimum = t.value : i.exclusiveMinimum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value >= t.value : r.value > t.value) || r.issues.push({
      origin: n,
      code: "too_small",
      minimum: typeof t.value == "object" ? t.value.getTime() : t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), Cme = /* @__PURE__ */ De("$ZodCheckMultipleOf", (e, t) => {
  Zi.init(e, t), e._zod.onattach.push((n) => {
    var r;
    (r = n._zod.bag).multipleOf ?? (r.multipleOf = t.value);
  }), e._zod.check = (n) => {
    if (typeof n.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof n.value == "bigint" ? n.value % t.value === BigInt(0) : Tpe(n.value, t.value) === 0) || n.issues.push({
      origin: typeof n.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Eme = /* @__PURE__ */ De("$ZodCheckNumberFormat", (e, t) => {
  Zi.init(e, t), t.format = t.format || "float64";
  const n = t.format?.includes("int"), r = n ? "int" : "number", [i, o] = Ope[t.format];
  e._zod.onattach.push((s) => {
    const a = s._zod.bag;
    a.format = t.format, a.minimum = i, a.maximum = o, n && (a.pattern = bme);
  }), e._zod.check = (s) => {
    const a = s.value;
    if (n) {
      if (!Number.isInteger(a)) {
        s.issues.push({
          expected: r,
          format: t.format,
          code: "invalid_type",
          continue: !1,
          input: a,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(a)) {
        a > 0 ? s.issues.push({
          input: a,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          inclusive: !0,
          continue: !t.abort
        }) : s.issues.push({
          input: a,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          inclusive: !0,
          continue: !t.abort
        });
        return;
      }
    }
    a < i && s.issues.push({
      origin: "number",
      input: a,
      code: "too_small",
      minimum: i,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), a > o && s.issues.push({
      origin: "number",
      input: a,
      code: "too_big",
      maximum: o,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    });
  };
}), _me = /* @__PURE__ */ De("$ZodCheckMaxLength", (e, t) => {
  var n;
  Zi.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const i = r.value;
    return !_M(i) && i.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const i = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < i && (r._zod.bag.maximum = t.maximum);
  }), e._zod.check = (r) => {
    const i = r.value;
    if (i.length <= t.maximum)
      return;
    const s = AM(i);
    r.issues.push({
      origin: s,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: i,
      inst: e,
      continue: !t.abort
    });
  };
}), Tme = /* @__PURE__ */ De("$ZodCheckMinLength", (e, t) => {
  var n;
  Zi.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const i = r.value;
    return !_M(i) && i.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const i = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > i && (r._zod.bag.minimum = t.minimum);
  }), e._zod.check = (r) => {
    const i = r.value;
    if (i.length >= t.minimum)
      return;
    const s = AM(i);
    r.issues.push({
      origin: s,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: i,
      inst: e,
      continue: !t.abort
    });
  };
}), Ame = /* @__PURE__ */ De("$ZodCheckLengthEquals", (e, t) => {
  var n;
  Zi.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const i = r.value;
    return !_M(i) && i.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.minimum = t.length, i.maximum = t.length, i.length = t.length;
  }), e._zod.check = (r) => {
    const i = r.value, o = i.length;
    if (o === t.length)
      return;
    const s = AM(i), a = o > t.length;
    r.issues.push({
      origin: s,
      ...a ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Rw = /* @__PURE__ */ De("$ZodCheckStringFormat", (e, t) => {
  var n, r;
  Zi.init(e, t), e._zod.onattach.push((i) => {
    const o = i._zod.bag;
    o.format = t.format, t.pattern && (o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(t.pattern));
  }), t.pattern ? (n = e._zod).check ?? (n.check = (i) => {
    t.pattern.lastIndex = 0, !t.pattern.test(i.value) && i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: i.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (r = e._zod).check ?? (r.check = () => {
  });
}), Mme = /* @__PURE__ */ De("$ZodCheckRegex", (e, t) => {
  Rw.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: n.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), Nme = /* @__PURE__ */ De("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = Sme), Rw.init(e, t);
}), Rme = /* @__PURE__ */ De("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = kme), Rw.init(e, t);
}), Ome = /* @__PURE__ */ De("$ZodCheckIncludes", (e, t) => {
  Zi.init(e, t);
  const n = dh(t.includes), r = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = r, e._zod.onattach.push((i) => {
    const o = i._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(r);
  }), e._zod.check = (i) => {
    i.value.includes(t.includes, t.position) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Dme = /* @__PURE__ */ De("$ZodCheckStartsWith", (e, t) => {
  Zi.init(e, t);
  const n = new RegExp(`^${dh(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.startsWith(t.prefix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Pme = /* @__PURE__ */ De("$ZodCheckEndsWith", (e, t) => {
  Zi.init(e, t);
  const n = new RegExp(`.*${dh(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const i = r._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.endsWith(t.suffix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), jme = /* @__PURE__ */ De("$ZodCheckOverwrite", (e, t) => {
  Zi.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
class Ime {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const r = t.split(`
`).filter((s) => s), i = Math.min(...r.map((s) => s.length - s.trimStart().length)), o = r.map((s) => s.slice(i)).map((s) => " ".repeat(this.indent * 2) + s);
    for (const s of o)
      this.content.push(s);
  }
  compile() {
    const t = Function, n = this?.args, i = [...(this?.content ?? [""]).map((o) => `  ${o}`)];
    return new t(...n, i.join(`
`));
  }
}
const zme = {
  major: 4,
  minor: 3,
  patch: 6
}, Vn = /* @__PURE__ */ De("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = zme;
  const r = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && r.unshift(e);
  for (const i of r)
    for (const o of i._zod.onattach)
      o(e);
  if (r.length === 0)
    (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const i = (s, a, c) => {
      let u = zf(s), f;
      for (const h of a) {
        if (h._zod.def.when) {
          if (!h._zod.def.when(s))
            continue;
        } else if (u)
          continue;
        const m = s.issues.length, g = h._zod.check(s);
        if (g instanceof Promise && c?.async === !1)
          throw new Yf();
        if (f || g instanceof Promise)
          f = (f ?? Promise.resolve()).then(async () => {
            await g, s.issues.length !== m && (u || (u = zf(s, m)));
          });
        else {
          if (s.issues.length === m)
            continue;
          u || (u = zf(s, m));
        }
      }
      return f ? f.then(() => s) : s;
    }, o = (s, a, c) => {
      if (zf(s))
        return s.aborted = !0, s;
      const u = i(a, r, c);
      if (u instanceof Promise) {
        if (c.async === !1)
          throw new Yf();
        return u.then((f) => e._zod.parse(f, c));
      }
      return e._zod.parse(u, c);
    };
    e._zod.run = (s, a) => {
      if (a.skipChecks)
        return e._zod.parse(s, a);
      if (a.direction === "backward") {
        const u = e._zod.parse({ value: s.value, issues: [] }, { ...a, skipChecks: !0 });
        return u instanceof Promise ? u.then((f) => o(f, s, a)) : o(u, s, a);
      }
      const c = e._zod.parse(s, a);
      if (c instanceof Promise) {
        if (a.async === !1)
          throw new Yf();
        return c.then((u) => i(u, r, a));
      }
      return i(c, r, a);
    };
  }
  en(e, "~standard", () => ({
    validate: (i) => {
      try {
        const o = Fpe(e, i);
        return o.success ? { value: o.data } : { issues: o.error?.issues };
      } catch {
        return Vpe(e, i).then((s) => s.success ? { value: s.data } : { issues: s.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), RM = /* @__PURE__ */ De("$ZodString", (e, t) => {
  Vn.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? vme(e._zod.bag), e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), Kn = /* @__PURE__ */ De("$ZodStringFormat", (e, t) => {
  Rw.init(e, t), RM.init(e, t);
}), Lme = /* @__PURE__ */ De("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = ome), Kn.init(e, t);
}), Bme = /* @__PURE__ */ De("$ZodUUID", (e, t) => {
  if (t.version) {
    const r = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (r === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = xI(r));
  } else
    t.pattern ?? (t.pattern = xI());
  Kn.init(e, t);
}), $me = /* @__PURE__ */ De("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = sme), Kn.init(e, t);
}), Ume = /* @__PURE__ */ De("$ZodURL", (e, t) => {
  Kn.init(e, t), e._zod.check = (n) => {
    try {
      const r = n.value.trim(), i = new URL(r);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(i.hostname) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: t.hostname.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(i.protocol.endsWith(":") ? i.protocol.slice(0, -1) : i.protocol) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? n.value = i.href : n.value = r;
      return;
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "url",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), Fme = /* @__PURE__ */ De("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = lme()), Kn.init(e, t);
}), Vme = /* @__PURE__ */ De("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = rme), Kn.init(e, t);
}), Hme = /* @__PURE__ */ De("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = Jpe), Kn.init(e, t);
}), Wme = /* @__PURE__ */ De("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = Qpe), Kn.init(e, t);
}), qme = /* @__PURE__ */ De("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = eme), Kn.init(e, t);
}), Gme = /* @__PURE__ */ De("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = tme), Kn.init(e, t);
}), Kme = /* @__PURE__ */ De("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = nme), Kn.init(e, t);
}), Zme = /* @__PURE__ */ De("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = yme(t)), Kn.init(e, t);
}), Yme = /* @__PURE__ */ De("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = mme), Kn.init(e, t);
}), Xme = /* @__PURE__ */ De("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = gme(t)), Kn.init(e, t);
}), Jme = /* @__PURE__ */ De("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = ime), Kn.init(e, t);
}), Qme = /* @__PURE__ */ De("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = cme), Kn.init(e, t), e._zod.bag.format = "ipv4";
}), ege = /* @__PURE__ */ De("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = ume), Kn.init(e, t), e._zod.bag.format = "ipv6", e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), tge = /* @__PURE__ */ De("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = dme), Kn.init(e, t);
}), nge = /* @__PURE__ */ De("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = fme), Kn.init(e, t), e._zod.check = (n) => {
    const r = n.value.split("/");
    try {
      if (r.length !== 2)
        throw new Error();
      const [i, o] = r;
      if (!o)
        throw new Error();
      const s = Number(o);
      if (`${s}` !== o)
        throw new Error();
      if (s < 0 || s > 128)
        throw new Error();
      new URL(`http://[${i}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function O8(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const rge = /* @__PURE__ */ De("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = hme), Kn.init(e, t), e._zod.bag.contentEncoding = "base64", e._zod.check = (n) => {
    O8(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function ige(e) {
  if (!E8.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (r) => r === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return O8(n);
}
const oge = /* @__PURE__ */ De("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = E8), Kn.init(e, t), e._zod.bag.contentEncoding = "base64url", e._zod.check = (n) => {
    ige(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), sge = /* @__PURE__ */ De("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = pme), Kn.init(e, t);
});
function age(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3)
      return !1;
    const [r] = n;
    if (!r)
      return !1;
    const i = JSON.parse(atob(r));
    return !("typ" in i && i?.typ !== "JWT" || !i.alg || t && (!("alg" in i) || i.alg !== t));
  } catch {
    return !1;
  }
}
const lge = /* @__PURE__ */ De("$ZodJWT", (e, t) => {
  Kn.init(e, t), e._zod.check = (n) => {
    age(n.value, t.alg) || n.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), D8 = /* @__PURE__ */ De("$ZodNumber", (e, t) => {
  Vn.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? A8, e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = Number(n.value);
      } catch {
      }
    const i = n.value;
    if (typeof i == "number" && !Number.isNaN(i) && Number.isFinite(i))
      return n;
    const o = typeof i == "number" ? Number.isNaN(i) ? "NaN" : Number.isFinite(i) ? void 0 : "Infinity" : void 0;
    return n.issues.push({
      expected: "number",
      code: "invalid_type",
      input: i,
      inst: e,
      ...o ? { received: o } : {}
    }), n;
  };
}), cge = /* @__PURE__ */ De("$ZodNumberFormat", (e, t) => {
  Eme.init(e, t), D8.init(e, t);
}), uge = /* @__PURE__ */ De("$ZodBoolean", (e, t) => {
  Vn.init(e, t), e._zod.pattern = xme, e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = !!n.value;
      } catch {
      }
    const i = n.value;
    return typeof i == "boolean" || n.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: i,
      inst: e
    }), n;
  };
}), dge = /* @__PURE__ */ De("$ZodNull", (e, t) => {
  Vn.init(e, t), e._zod.pattern = wme, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (n, r) => {
    const i = n.value;
    return i === null || n.issues.push({
      expected: "null",
      code: "invalid_type",
      input: i,
      inst: e
    }), n;
  };
}), fge = /* @__PURE__ */ De("$ZodUnknown", (e, t) => {
  Vn.init(e, t), e._zod.parse = (n) => n;
}), hge = /* @__PURE__ */ De("$ZodNever", (e, t) => {
  Vn.init(e, t), e._zod.parse = (n, r) => (n.issues.push({
    expected: "never",
    code: "invalid_type",
    input: n.value,
    inst: e
  }), n);
});
function wI(e, t, n) {
  e.issues.length && t.issues.push(...Lf(n, e.issues)), t.value[n] = e.value;
}
const pge = /* @__PURE__ */ De("$ZodArray", (e, t) => {
  Vn.init(e, t), e._zod.parse = (n, r) => {
    const i = n.value;
    if (!Array.isArray(i))
      return n.issues.push({
        expected: "array",
        code: "invalid_type",
        input: i,
        inst: e
      }), n;
    n.value = Array(i.length);
    const o = [];
    for (let s = 0; s < i.length; s++) {
      const a = i[s], c = t.element._zod.run({
        value: a,
        issues: []
      }, r);
      c instanceof Promise ? o.push(c.then((u) => wI(u, n, s))) : wI(c, n, s);
    }
    return o.length ? Promise.all(o).then(() => n) : n;
  };
});
function _b(e, t, n, r, i) {
  if (e.issues.length) {
    if (i && !(n in r))
      return;
    t.issues.push(...Lf(n, e.issues));
  }
  e.value === void 0 ? n in r && (t.value[n] = void 0) : t.value[n] = e.value;
}
function P8(e) {
  const t = Object.keys(e.shape);
  for (const r of t)
    if (!e.shape?.[r]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${r}": expected a Zod schema`);
  const n = Rpe(e.shape);
  return {
    ...e,
    keys: t,
    keySet: new Set(t),
    numKeys: t.length,
    optionalKeys: new Set(n)
  };
}
function j8(e, t, n, r, i, o) {
  const s = [], a = i.keySet, c = i.catchall._zod, u = c.def.type, f = c.optout === "optional";
  for (const h in t) {
    if (a.has(h))
      continue;
    if (u === "never") {
      s.push(h);
      continue;
    }
    const m = c.run({ value: t[h], issues: [] }, r);
    m instanceof Promise ? e.push(m.then((g) => _b(g, n, h, t, f))) : _b(m, n, h, t, f);
  }
  return s.length && n.issues.push({
    code: "unrecognized_keys",
    keys: s,
    input: t,
    inst: o
  }), e.length ? Promise.all(e).then(() => n) : n;
}
const mge = /* @__PURE__ */ De("$ZodObject", (e, t) => {
  if (Vn.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
    const a = t.shape;
    Object.defineProperty(t, "shape", {
      get: () => {
        const c = { ...a };
        return Object.defineProperty(t, "shape", {
          value: c
        }), c;
      }
    });
  }
  const r = Aw(() => P8(t));
  en(e._zod, "propValues", () => {
    const a = t.shape, c = {};
    for (const u in a) {
      const f = a[u]._zod;
      if (f.values) {
        c[u] ?? (c[u] = /* @__PURE__ */ new Set());
        for (const h of f.values)
          c[u].add(h);
      }
    }
    return c;
  });
  const i = ig, o = t.catchall;
  let s;
  e._zod.parse = (a, c) => {
    s ?? (s = r.value);
    const u = a.value;
    if (!i(u))
      return a.issues.push({
        expected: "object",
        code: "invalid_type",
        input: u,
        inst: e
      }), a;
    a.value = {};
    const f = [], h = s.shape;
    for (const m of s.keys) {
      const g = h[m], b = g._zod.optout === "optional", x = g._zod.run({ value: u[m], issues: [] }, c);
      x instanceof Promise ? f.push(x.then((w) => _b(w, a, m, u, b))) : _b(x, a, m, u, b);
    }
    return o ? j8(f, u, a, c, r.value, e) : f.length ? Promise.all(f).then(() => a) : a;
  };
}), gge = /* @__PURE__ */ De("$ZodObjectJIT", (e, t) => {
  mge.init(e, t);
  const n = e._zod.parse, r = Aw(() => P8(t)), i = (m) => {
    const g = new Ime(["shape", "payload", "ctx"]), b = r.value, x = (M) => {
      const N = bI(M);
      return `shape[${N}]._zod.run({ value: input[${N}], issues: [] }, ctx)`;
    };
    g.write("const input = payload.value;");
    const w = /* @__PURE__ */ Object.create(null);
    let S = 0;
    for (const M of b.keys)
      w[M] = `key_${S++}`;
    g.write("const newResult = {};");
    for (const M of b.keys) {
      const N = w[M], P = bI(M), O = m[M]?._zod?.optout === "optional";
      g.write(`const ${N} = ${x(M)};`), O ? g.write(`
        if (${N}.issues.length) {
          if (${P} in input) {
            payload.issues = payload.issues.concat(${N}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${P}, ...iss.path] : [${P}]
            })));
          }
        }
        
        if (${N}.value === undefined) {
          if (${P} in input) {
            newResult[${P}] = undefined;
          }
        } else {
          newResult[${P}] = ${N}.value;
        }
        
      `) : g.write(`
        if (${N}.issues.length) {
          payload.issues = payload.issues.concat(${N}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${P}, ...iss.path] : [${P}]
          })));
        }
        
        if (${N}.value === undefined) {
          if (${P} in input) {
            newResult[${P}] = undefined;
          }
        } else {
          newResult[${P}] = ${N}.value;
        }
        
      `);
    }
    g.write("payload.value = newResult;"), g.write("return payload;");
    const _ = g.compile();
    return (M, N) => _(m, M, N);
  };
  let o;
  const s = ig, a = !v8.jitless, u = a && Mpe.value, f = t.catchall;
  let h;
  e._zod.parse = (m, g) => {
    h ?? (h = r.value);
    const b = m.value;
    return s(b) ? a && u && g?.async === !1 && g.jitless !== !0 ? (o || (o = i(t.shape)), m = o(m, g), f ? j8([], b, m, g, h, e) : m) : n(m, g) : (m.issues.push({
      expected: "object",
      code: "invalid_type",
      input: b,
      inst: e
    }), m);
  };
});
function SI(e, t, n, r) {
  for (const o of e)
    if (o.issues.length === 0)
      return t.value = o.value, t;
  const i = e.filter((o) => !zf(o));
  return i.length === 1 ? (t.value = i[0].value, i[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: n,
    errors: e.map((o) => o.issues.map((s) => Nc(s, r, Mc())))
  }), t);
}
const I8 = /* @__PURE__ */ De("$ZodUnion", (e, t) => {
  Vn.init(e, t), en(e._zod, "optin", () => t.options.some((i) => i._zod.optin === "optional") ? "optional" : void 0), en(e._zod, "optout", () => t.options.some((i) => i._zod.optout === "optional") ? "optional" : void 0), en(e._zod, "values", () => {
    if (t.options.every((i) => i._zod.values))
      return new Set(t.options.flatMap((i) => Array.from(i._zod.values)));
  }), en(e._zod, "pattern", () => {
    if (t.options.every((i) => i._zod.pattern)) {
      const i = t.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${i.map((o) => TM(o.source)).join("|")})$`);
    }
  });
  const n = t.options.length === 1, r = t.options[0]._zod.run;
  e._zod.parse = (i, o) => {
    if (n)
      return r(i, o);
    let s = !1;
    const a = [];
    for (const c of t.options) {
      const u = c._zod.run({
        value: i.value,
        issues: []
      }, o);
      if (u instanceof Promise)
        a.push(u), s = !0;
      else {
        if (u.issues.length === 0)
          return u;
        a.push(u);
      }
    }
    return s ? Promise.all(a).then((c) => SI(c, i, e, o)) : SI(a, i, e, o);
  };
}), yge = /* @__PURE__ */ De("$ZodDiscriminatedUnion", (e, t) => {
  t.inclusive = !1, I8.init(e, t);
  const n = e._zod.parse;
  en(e._zod, "propValues", () => {
    const i = {};
    for (const o of t.options) {
      const s = o._zod.propValues;
      if (!s || Object.keys(s).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(o)}"`);
      for (const [a, c] of Object.entries(s)) {
        i[a] || (i[a] = /* @__PURE__ */ new Set());
        for (const u of c)
          i[a].add(u);
      }
    }
    return i;
  });
  const r = Aw(() => {
    const i = t.options, o = /* @__PURE__ */ new Map();
    for (const s of i) {
      const a = s._zod.propValues?.[t.discriminator];
      if (!a || a.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(s)}"`);
      for (const c of a) {
        if (o.has(c))
          throw new Error(`Duplicate discriminator value "${String(c)}"`);
        o.set(c, s);
      }
    }
    return o;
  });
  e._zod.parse = (i, o) => {
    const s = i.value;
    if (!ig(s))
      return i.issues.push({
        code: "invalid_type",
        expected: "object",
        input: s,
        inst: e
      }), i;
    const a = r.value.get(s?.[t.discriminator]);
    return a ? a._zod.run(i, o) : t.unionFallback ? n(i, o) : (i.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: t.discriminator,
      input: s,
      path: [t.discriminator],
      inst: e
    }), i);
  };
}), vge = /* @__PURE__ */ De("$ZodIntersection", (e, t) => {
  Vn.init(e, t), e._zod.parse = (n, r) => {
    const i = n.value, o = t.left._zod.run({ value: i, issues: [] }, r), s = t.right._zod.run({ value: i, issues: [] }, r);
    return o instanceof Promise || s instanceof Promise ? Promise.all([o, s]).then(([c, u]) => kI(n, c, u)) : kI(n, o, s);
  };
});
function O_(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (uh(e) && uh(t)) {
    const n = Object.keys(t), r = Object.keys(e).filter((o) => n.indexOf(o) !== -1), i = { ...e, ...t };
    for (const o of r) {
      const s = O_(e[o], t[o]);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [o, ...s.mergeErrorPath]
        };
      i[o] = s.data;
    }
    return { valid: !0, data: i };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const i = e[r], o = t[r], s = O_(i, o);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...s.mergeErrorPath]
        };
      n.push(s.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function kI(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  let i;
  for (const a of t.issues)
    if (a.code === "unrecognized_keys") {
      i ?? (i = a);
      for (const c of a.keys)
        r.has(c) || r.set(c, {}), r.get(c).l = !0;
    } else
      e.issues.push(a);
  for (const a of n.issues)
    if (a.code === "unrecognized_keys")
      for (const c of a.keys)
        r.has(c) || r.set(c, {}), r.get(c).r = !0;
    else
      e.issues.push(a);
  const o = [...r].filter(([, a]) => a.l && a.r).map(([a]) => a);
  if (o.length && i && e.issues.push({ ...i, keys: o }), zf(e))
    return e;
  const s = O_(t.value, n.value);
  if (!s.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(s.mergeErrorPath)}`);
  return e.value = s.data, e;
}
const bge = /* @__PURE__ */ De("$ZodRecord", (e, t) => {
  Vn.init(e, t), e._zod.parse = (n, r) => {
    const i = n.value;
    if (!uh(i))
      return n.issues.push({
        expected: "record",
        code: "invalid_type",
        input: i,
        inst: e
      }), n;
    const o = [], s = t.keyType._zod.values;
    if (s) {
      n.value = {};
      const a = /* @__PURE__ */ new Set();
      for (const u of s)
        if (typeof u == "string" || typeof u == "number" || typeof u == "symbol") {
          a.add(typeof u == "number" ? u.toString() : u);
          const f = t.valueType._zod.run({ value: i[u], issues: [] }, r);
          f instanceof Promise ? o.push(f.then((h) => {
            h.issues.length && n.issues.push(...Lf(u, h.issues)), n.value[u] = h.value;
          })) : (f.issues.length && n.issues.push(...Lf(u, f.issues)), n.value[u] = f.value);
        }
      let c;
      for (const u in i)
        a.has(u) || (c = c ?? [], c.push(u));
      c && c.length > 0 && n.issues.push({
        code: "unrecognized_keys",
        input: i,
        inst: e,
        keys: c
      });
    } else {
      n.value = {};
      for (const a of Reflect.ownKeys(i)) {
        if (a === "__proto__")
          continue;
        let c = t.keyType._zod.run({ value: a, issues: [] }, r);
        if (c instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (typeof a == "string" && A8.test(a) && c.issues.length) {
          const h = t.keyType._zod.run({ value: Number(a), issues: [] }, r);
          if (h instanceof Promise)
            throw new Error("Async schemas not supported in object keys currently");
          h.issues.length === 0 && (c = h);
        }
        if (c.issues.length) {
          t.mode === "loose" ? n.value[a] = i[a] : n.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: c.issues.map((h) => Nc(h, r, Mc())),
            input: a,
            path: [a],
            inst: e
          });
          continue;
        }
        const f = t.valueType._zod.run({ value: i[a], issues: [] }, r);
        f instanceof Promise ? o.push(f.then((h) => {
          h.issues.length && n.issues.push(...Lf(a, h.issues)), n.value[c.value] = h.value;
        })) : (f.issues.length && n.issues.push(...Lf(a, f.issues)), n.value[c.value] = f.value);
      }
    }
    return o.length ? Promise.all(o).then(() => n) : n;
  };
}), xge = /* @__PURE__ */ De("$ZodEnum", (e, t) => {
  Vn.init(e, t);
  const n = b8(t.entries), r = new Set(n);
  e._zod.values = r, e._zod.pattern = new RegExp(`^(${n.filter((i) => Npe.has(typeof i)).map((i) => typeof i == "string" ? dh(i) : i.toString()).join("|")})$`), e._zod.parse = (i, o) => {
    const s = i.value;
    return r.has(s) || i.issues.push({
      code: "invalid_value",
      values: n,
      input: s,
      inst: e
    }), i;
  };
}), wge = /* @__PURE__ */ De("$ZodLiteral", (e, t) => {
  if (Vn.init(e, t), t.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  const n = new Set(t.values);
  e._zod.values = n, e._zod.pattern = new RegExp(`^(${t.values.map((r) => typeof r == "string" ? dh(r) : r ? dh(r.toString()) : String(r)).join("|")})$`), e._zod.parse = (r, i) => {
    const o = r.value;
    return n.has(o) || r.issues.push({
      code: "invalid_value",
      values: t.values,
      input: o,
      inst: e
    }), r;
  };
}), Sge = /* @__PURE__ */ De("$ZodTransform", (e, t) => {
  Vn.init(e, t), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      throw new y8(e.constructor.name);
    const i = t.transform(n.value, n);
    if (r.async)
      return (i instanceof Promise ? i : Promise.resolve(i)).then((s) => (n.value = s, n));
    if (i instanceof Promise)
      throw new Yf();
    return n.value = i, n;
  };
});
function CI(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
const z8 = /* @__PURE__ */ De("$ZodOptional", (e, t) => {
  Vn.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", en(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), en(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${TM(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, r) => {
    if (t.innerType._zod.optin === "optional") {
      const i = t.innerType._zod.run(n, r);
      return i instanceof Promise ? i.then((o) => CI(o, n.value)) : CI(i, n.value);
    }
    return n.value === void 0 ? n : t.innerType._zod.run(n, r);
  };
}), kge = /* @__PURE__ */ De("$ZodExactOptional", (e, t) => {
  z8.init(e, t), en(e._zod, "values", () => t.innerType._zod.values), en(e._zod, "pattern", () => t.innerType._zod.pattern), e._zod.parse = (n, r) => t.innerType._zod.run(n, r);
}), Cge = /* @__PURE__ */ De("$ZodNullable", (e, t) => {
  Vn.init(e, t), en(e._zod, "optin", () => t.innerType._zod.optin), en(e._zod, "optout", () => t.innerType._zod.optout), en(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${TM(n.source)}|null)$`) : void 0;
  }), en(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, r) => n.value === null ? n : t.innerType._zod.run(n, r);
}), Ege = /* @__PURE__ */ De("$ZodDefault", (e, t) => {
  Vn.init(e, t), e._zod.optin = "optional", en(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    if (n.value === void 0)
      return n.value = t.defaultValue, n;
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((o) => EI(o, t)) : EI(i, t);
  };
});
function EI(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const _ge = /* @__PURE__ */ De("$ZodPrefault", (e, t) => {
  Vn.init(e, t), e._zod.optin = "optional", en(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => (r.direction === "backward" || n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, r));
}), Tge = /* @__PURE__ */ De("$ZodNonOptional", (e, t) => {
  Vn.init(e, t), en(e._zod, "values", () => {
    const n = t.innerType._zod.values;
    return n ? new Set([...n].filter((r) => r !== void 0)) : void 0;
  }), e._zod.parse = (n, r) => {
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((o) => _I(o, e)) : _I(i, e);
  };
});
function _I(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const Age = /* @__PURE__ */ De("$ZodCatch", (e, t) => {
  Vn.init(e, t), en(e._zod, "optin", () => t.innerType._zod.optin), en(e._zod, "optout", () => t.innerType._zod.optout), en(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then((o) => (n.value = o.value, o.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: o.issues.map((s) => Nc(s, r, Mc()))
      },
      input: n.value
    }), n.issues = []), n)) : (n.value = i.value, i.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: i.issues.map((o) => Nc(o, r, Mc()))
      },
      input: n.value
    }), n.issues = []), n);
  };
}), Mge = /* @__PURE__ */ De("$ZodPipe", (e, t) => {
  Vn.init(e, t), en(e._zod, "values", () => t.in._zod.values), en(e._zod, "optin", () => t.in._zod.optin), en(e._zod, "optout", () => t.out._zod.optout), en(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, r) => {
    if (r.direction === "backward") {
      const o = t.out._zod.run(n, r);
      return o instanceof Promise ? o.then((s) => Uv(s, t.in, r)) : Uv(o, t.in, r);
    }
    const i = t.in._zod.run(n, r);
    return i instanceof Promise ? i.then((o) => Uv(o, t.out, r)) : Uv(i, t.out, r);
  };
});
function Uv(e, t, n) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, n);
}
const Nge = /* @__PURE__ */ De("$ZodReadonly", (e, t) => {
  Vn.init(e, t), en(e._zod, "propValues", () => t.innerType._zod.propValues), en(e._zod, "values", () => t.innerType._zod.values), en(e._zod, "optin", () => t.innerType?._zod?.optin), en(e._zod, "optout", () => t.innerType?._zod?.optout), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(n, r);
    const i = t.innerType._zod.run(n, r);
    return i instanceof Promise ? i.then(TI) : TI(i);
  };
});
function TI(e) {
  return e.value = Object.freeze(e.value), e;
}
const Rge = /* @__PURE__ */ De("$ZodLazy", (e, t) => {
  Vn.init(e, t), en(e._zod, "innerType", () => t.getter()), en(e._zod, "pattern", () => e._zod.innerType?._zod?.pattern), en(e._zod, "propValues", () => e._zod.innerType?._zod?.propValues), en(e._zod, "optin", () => e._zod.innerType?._zod?.optin ?? void 0), en(e._zod, "optout", () => e._zod.innerType?._zod?.optout ?? void 0), e._zod.parse = (n, r) => e._zod.innerType._zod.run(n, r);
}), Oge = /* @__PURE__ */ De("$ZodCustom", (e, t) => {
  Zi.init(e, t), Vn.init(e, t), e._zod.parse = (n, r) => n, e._zod.check = (n) => {
    const r = n.value, i = t.fn(r);
    if (i instanceof Promise)
      return i.then((o) => AI(o, n, r, e));
    AI(i, n, r, e);
  };
});
function AI(e, t, n, r) {
  if (!e) {
    const i = {
      code: "custom",
      input: n,
      inst: r,
      // incorporates params.error into issue reporting
      path: [...r._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !r._zod.def.abort
      // params: inst._zod.def.params,
    };
    r._zod.def.params && (i.params = r._zod.def.params), t.issues.push(og(i));
  }
}
var MI;
class Dge {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    const r = n[0];
    return this._map.set(t, r), r && typeof r == "object" && "id" in r && this._idmap.set(r.id, t), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const n = this._map.get(t);
    return n && typeof n == "object" && "id" in n && this._idmap.delete(n.id), this._map.delete(t), this;
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const r = { ...this.get(n) ?? {} };
      delete r.id;
      const i = { ...r, ...this._map.get(t) };
      return Object.keys(i).length ? i : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function Pge() {
  return new Dge();
}
(MI = globalThis).__zod_globalRegistry ?? (MI.__zod_globalRegistry = Pge());
const um = globalThis.__zod_globalRegistry;
// @__NO_SIDE_EFFECTS__
function jge(e, t) {
  return new e({
    type: "string",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Ige(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function NI(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function zge(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Lge(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Bge(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function $ge(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Uge(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Fge(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Vge(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Hge(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Wge(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function qge(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Gge(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Kge(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Zge(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Yge(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Xge(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Jge(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Qge(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function eye(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function tye(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function nye(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function rye(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function iye(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function oye(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function sye(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function aye(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function lye(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function cye(e, t) {
  return new e({
    type: "boolean",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function uye(e, t) {
  return new e({
    type: "null",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function dye(e) {
  return new e({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function fye(e, t) {
  return new e({
    type: "never",
    ...ct(t)
  });
}
// @__NO_SIDE_EFFECTS__
function RI(e, t) {
  return new N8({
    check: "less_than",
    ...ct(t),
    value: e,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function cC(e, t) {
  return new N8({
    check: "less_than",
    ...ct(t),
    value: e,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function OI(e, t) {
  return new R8({
    check: "greater_than",
    ...ct(t),
    value: e,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function uC(e, t) {
  return new R8({
    check: "greater_than",
    ...ct(t),
    value: e,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function DI(e, t) {
  return new Cme({
    check: "multiple_of",
    ...ct(t),
    value: e
  });
}
// @__NO_SIDE_EFFECTS__
function L8(e, t) {
  return new _me({
    check: "max_length",
    ...ct(t),
    maximum: e
  });
}
// @__NO_SIDE_EFFECTS__
function Tb(e, t) {
  return new Tme({
    check: "min_length",
    ...ct(t),
    minimum: e
  });
}
// @__NO_SIDE_EFFECTS__
function B8(e, t) {
  return new Ame({
    check: "length_equals",
    ...ct(t),
    length: e
  });
}
// @__NO_SIDE_EFFECTS__
function hye(e, t) {
  return new Mme({
    check: "string_format",
    format: "regex",
    ...ct(t),
    pattern: e
  });
}
// @__NO_SIDE_EFFECTS__
function pye(e) {
  return new Nme({
    check: "string_format",
    format: "lowercase",
    ...ct(e)
  });
}
// @__NO_SIDE_EFFECTS__
function mye(e) {
  return new Rme({
    check: "string_format",
    format: "uppercase",
    ...ct(e)
  });
}
// @__NO_SIDE_EFFECTS__
function gye(e, t) {
  return new Ome({
    check: "string_format",
    format: "includes",
    ...ct(t),
    includes: e
  });
}
// @__NO_SIDE_EFFECTS__
function yye(e, t) {
  return new Dme({
    check: "string_format",
    format: "starts_with",
    ...ct(t),
    prefix: e
  });
}
// @__NO_SIDE_EFFECTS__
function vye(e, t) {
  return new Pme({
    check: "string_format",
    format: "ends_with",
    ...ct(t),
    suffix: e
  });
}
// @__NO_SIDE_EFFECTS__
function Bh(e) {
  return new jme({
    check: "overwrite",
    tx: e
  });
}
// @__NO_SIDE_EFFECTS__
function bye(e) {
  return /* @__PURE__ */ Bh((t) => t.normalize(e));
}
// @__NO_SIDE_EFFECTS__
function xye() {
  return /* @__PURE__ */ Bh((e) => e.trim());
}
// @__NO_SIDE_EFFECTS__
function wye() {
  return /* @__PURE__ */ Bh((e) => e.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function Sye() {
  return /* @__PURE__ */ Bh((e) => e.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function kye() {
  return /* @__PURE__ */ Bh((e) => Ape(e));
}
// @__NO_SIDE_EFFECTS__
function Cye(e, t, n) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...ct(n)
  });
}
// @__NO_SIDE_EFFECTS__
function Eye(e, t, n) {
  const r = ct(n);
  return r.abort ?? (r.abort = !0), new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...r
  });
}
// @__NO_SIDE_EFFECTS__
function _ye(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...ct(n)
  });
}
// @__NO_SIDE_EFFECTS__
function Tye(e) {
  const t = /* @__PURE__ */ Aye((n) => (n.addIssue = (r) => {
    if (typeof r == "string")
      n.issues.push(og(r, n.value, t._zod.def));
    else {
      const i = r;
      i.fatal && (i.continue = !1), i.code ?? (i.code = "custom"), i.input ?? (i.input = n.value), i.inst ?? (i.inst = t), i.continue ?? (i.continue = !t._zod.def.abort), n.issues.push(og(i));
    }
  }, e(n.value, n)));
  return t;
}
// @__NO_SIDE_EFFECTS__
function Aye(e, t) {
  const n = new Zi({
    check: "custom",
    ...ct(t)
  });
  return n._zod.check = e, n;
}
function Ab(e) {
  let t = e?.target ?? "draft-2020-12";
  return t === "draft-4" && (t = "draft-04"), t === "draft-7" && (t = "draft-07"), {
    processors: e.processors ?? {},
    metadataRegistry: e?.metadata ?? um,
    target: t,
    unrepresentable: e?.unrepresentable ?? "throw",
    override: e?.override ?? (() => {
    }),
    io: e?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: e?.cycles ?? "ref",
    reused: e?.reused ?? "inline",
    external: e?.external ?? void 0
  };
}
function On(e, t, n = { path: [], schemaPath: [] }) {
  var r;
  const i = e._zod.def, o = t.seen.get(e);
  if (o)
    return o.count++, n.schemaPath.includes(e) && (o.cycle = n.path), o.schema;
  const s = { schema: {}, count: 1, cycle: void 0, path: n.path };
  t.seen.set(e, s);
  const a = e._zod.toJSONSchema?.();
  if (a)
    s.schema = a;
  else {
    const f = {
      ...n,
      schemaPath: [...n.schemaPath, e],
      path: n.path
    };
    if (e._zod.processJSONSchema)
      e._zod.processJSONSchema(t, s.schema, f);
    else {
      const m = s.schema, g = t.processors[i.type];
      if (!g)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${i.type}`);
      g(e, t, m, f);
    }
    const h = e._zod.parent;
    h && (s.ref || (s.ref = h), On(h, t, f), t.seen.get(h).isParent = !0);
  }
  const c = t.metadataRegistry.get(e);
  return c && Object.assign(s.schema, c), t.io === "input" && Ei(e) && (delete s.schema.examples, delete s.schema.default), t.io === "input" && s.schema._prefault && ((r = s.schema).default ?? (r.default = s.schema._prefault)), delete s.schema._prefault, t.seen.get(e).schema;
}
function Mb(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const r = /* @__PURE__ */ new Map();
  for (const s of e.seen.entries()) {
    const a = e.metadataRegistry.get(s[0])?.id;
    if (a) {
      const c = r.get(a);
      if (c && c !== s[0])
        throw new Error(`Duplicate schema id "${a}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      r.set(a, s[0]);
    }
  }
  const i = (s) => {
    const a = e.target === "draft-2020-12" ? "$defs" : "definitions";
    if (e.external) {
      const h = e.external.registry.get(s[0])?.id, m = e.external.uri ?? ((b) => b);
      if (h)
        return { ref: m(h) };
      const g = s[1].defId ?? s[1].schema.id ?? `schema${e.counter++}`;
      return s[1].defId = g, { defId: g, ref: `${m("__shared")}#/${a}/${g}` };
    }
    if (s[1] === n)
      return { ref: "#" };
    const u = `#/${a}/`, f = s[1].schema.id ?? `__schema${e.counter++}`;
    return { defId: f, ref: u + f };
  }, o = (s) => {
    if (s[1].schema.$ref)
      return;
    const a = s[1], { ref: c, defId: u } = i(s);
    a.def = { ...a.schema }, u && (a.defId = u);
    const f = a.schema;
    for (const h in f)
      delete f[h];
    f.$ref = c;
  };
  if (e.cycles === "throw")
    for (const s of e.seen.entries()) {
      const a = s[1];
      if (a.cycle)
        throw new Error(`Cycle detected: #/${a.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (const s of e.seen.entries()) {
    const a = s[1];
    if (t === s[0]) {
      o(s);
      continue;
    }
    if (e.external) {
      const u = e.external.registry.get(s[0])?.id;
      if (t !== s[0] && u) {
        o(s);
        continue;
      }
    }
    if (e.metadataRegistry.get(s[0])?.id) {
      o(s);
      continue;
    }
    if (a.cycle) {
      o(s);
      continue;
    }
    if (a.count > 1 && e.reused === "ref") {
      o(s);
      continue;
    }
  }
}
function Nb(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const r = (s) => {
    const a = e.seen.get(s);
    if (a.ref === null)
      return;
    const c = a.def ?? a.schema, u = { ...c }, f = a.ref;
    if (a.ref = null, f) {
      r(f);
      const m = e.seen.get(f), g = m.schema;
      if (g.$ref && (e.target === "draft-07" || e.target === "draft-04" || e.target === "openapi-3.0") ? (c.allOf = c.allOf ?? [], c.allOf.push(g)) : Object.assign(c, g), Object.assign(c, u), s._zod.parent === f)
        for (const x in c)
          x === "$ref" || x === "allOf" || x in u || delete c[x];
      if (g.$ref && m.def)
        for (const x in c)
          x === "$ref" || x === "allOf" || x in m.def && JSON.stringify(c[x]) === JSON.stringify(m.def[x]) && delete c[x];
    }
    const h = s._zod.parent;
    if (h && h !== f) {
      r(h);
      const m = e.seen.get(h);
      if (m?.schema.$ref && (c.$ref = m.schema.$ref, m.def))
        for (const g in c)
          g === "$ref" || g === "allOf" || g in m.def && JSON.stringify(c[g]) === JSON.stringify(m.def[g]) && delete c[g];
    }
    e.override({
      zodSchema: s,
      jsonSchema: c,
      path: a.path ?? []
    });
  };
  for (const s of [...e.seen.entries()].reverse())
    r(s[0]);
  const i = {};
  if (e.target === "draft-2020-12" ? i.$schema = "https://json-schema.org/draft/2020-12/schema" : e.target === "draft-07" ? i.$schema = "http://json-schema.org/draft-07/schema#" : e.target === "draft-04" ? i.$schema = "http://json-schema.org/draft-04/schema#" : e.target, e.external?.uri) {
    const s = e.external.registry.get(t)?.id;
    if (!s)
      throw new Error("Schema is missing an `id` property");
    i.$id = e.external.uri(s);
  }
  Object.assign(i, n.def ?? n.schema);
  const o = e.external?.defs ?? {};
  for (const s of e.seen.entries()) {
    const a = s[1];
    a.def && a.defId && (o[a.defId] = a.def);
  }
  e.external || Object.keys(o).length > 0 && (e.target === "draft-2020-12" ? i.$defs = o : i.definitions = o);
  try {
    const s = JSON.parse(JSON.stringify(i));
    return Object.defineProperty(s, "~standard", {
      value: {
        ...t["~standard"],
        jsonSchema: {
          input: Rb(t, "input", e.processors),
          output: Rb(t, "output", e.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), s;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function Ei(e, t) {
  const n = t ?? { seen: /* @__PURE__ */ new Set() };
  if (n.seen.has(e))
    return !1;
  n.seen.add(e);
  const r = e._zod.def;
  if (r.type === "transform")
    return !0;
  if (r.type === "array")
    return Ei(r.element, n);
  if (r.type === "set")
    return Ei(r.valueType, n);
  if (r.type === "lazy")
    return Ei(r.getter(), n);
  if (r.type === "promise" || r.type === "optional" || r.type === "nonoptional" || r.type === "nullable" || r.type === "readonly" || r.type === "default" || r.type === "prefault")
    return Ei(r.innerType, n);
  if (r.type === "intersection")
    return Ei(r.left, n) || Ei(r.right, n);
  if (r.type === "record" || r.type === "map")
    return Ei(r.keyType, n) || Ei(r.valueType, n);
  if (r.type === "pipe")
    return Ei(r.in, n) || Ei(r.out, n);
  if (r.type === "object") {
    for (const i in r.shape)
      if (Ei(r.shape[i], n))
        return !0;
    return !1;
  }
  if (r.type === "union") {
    for (const i of r.options)
      if (Ei(i, n))
        return !0;
    return !1;
  }
  if (r.type === "tuple") {
    for (const i of r.items)
      if (Ei(i, n))
        return !0;
    return !!(r.rest && Ei(r.rest, n));
  }
  return !1;
}
const Mye = (e, t = {}) => (n) => {
  const r = Ab({ ...n, processors: t });
  return On(e, r), Mb(r, e), Nb(r, e);
}, Rb = (e, t, n = {}) => (r) => {
  const { libraryOptions: i, target: o } = r ?? {}, s = Ab({ ...i ?? {}, target: o, io: t, processors: n });
  return On(e, s), Mb(s, e), Nb(s, e);
}, Nye = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, $8 = (e, t, n, r) => {
  const i = n;
  i.type = "string";
  const { minimum: o, maximum: s, format: a, patterns: c, contentEncoding: u } = e._zod.bag;
  if (typeof o == "number" && (i.minLength = o), typeof s == "number" && (i.maxLength = s), a && (i.format = Nye[a] ?? a, i.format === "" && delete i.format, a === "time" && delete i.format), u && (i.contentEncoding = u), c && c.size > 0) {
    const f = [...c];
    f.length === 1 ? i.pattern = f[0].source : f.length > 1 && (i.allOf = [
      ...f.map((h) => ({
        ...t.target === "draft-07" || t.target === "draft-04" || t.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: h.source
      }))
    ]);
  }
}, U8 = (e, t, n, r) => {
  const i = n, { minimum: o, maximum: s, format: a, multipleOf: c, exclusiveMaximum: u, exclusiveMinimum: f } = e._zod.bag;
  typeof a == "string" && a.includes("int") ? i.type = "integer" : i.type = "number", typeof f == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (i.minimum = f, i.exclusiveMinimum = !0) : i.exclusiveMinimum = f), typeof o == "number" && (i.minimum = o, typeof f == "number" && t.target !== "draft-04" && (f >= o ? delete i.minimum : delete i.exclusiveMinimum)), typeof u == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (i.maximum = u, i.exclusiveMaximum = !0) : i.exclusiveMaximum = u), typeof s == "number" && (i.maximum = s, typeof u == "number" && t.target !== "draft-04" && (u <= s ? delete i.maximum : delete i.exclusiveMaximum)), typeof c == "number" && (i.multipleOf = c);
}, F8 = (e, t, n, r) => {
  n.type = "boolean";
}, Rye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("BigInt cannot be represented in JSON Schema");
}, Oye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Symbols cannot be represented in JSON Schema");
}, V8 = (e, t, n, r) => {
  t.target === "openapi-3.0" ? (n.type = "string", n.nullable = !0, n.enum = [null]) : n.type = "null";
}, Dye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Undefined cannot be represented in JSON Schema");
}, Pye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Void cannot be represented in JSON Schema");
}, H8 = (e, t, n, r) => {
  n.not = {};
}, jye = (e, t, n, r) => {
}, W8 = (e, t, n, r) => {
}, Iye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Date cannot be represented in JSON Schema");
}, q8 = (e, t, n, r) => {
  const i = e._zod.def, o = b8(i.entries);
  o.every((s) => typeof s == "number") && (n.type = "number"), o.every((s) => typeof s == "string") && (n.type = "string"), n.enum = o;
}, G8 = (e, t, n, r) => {
  const i = e._zod.def, o = [];
  for (const s of i.values)
    if (s === void 0) {
      if (t.unrepresentable === "throw")
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof s == "bigint") {
      if (t.unrepresentable === "throw")
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      o.push(Number(s));
    } else
      o.push(s);
  if (o.length !== 0) if (o.length === 1) {
    const s = o[0];
    n.type = s === null ? "null" : typeof s, t.target === "draft-04" || t.target === "openapi-3.0" ? n.enum = [s] : n.const = s;
  } else
    o.every((s) => typeof s == "number") && (n.type = "number"), o.every((s) => typeof s == "string") && (n.type = "string"), o.every((s) => typeof s == "boolean") && (n.type = "boolean"), o.every((s) => s === null) && (n.type = "null"), n.enum = o;
}, zye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("NaN cannot be represented in JSON Schema");
}, Lye = (e, t, n, r) => {
  const i = n, o = e._zod.pattern;
  if (!o)
    throw new Error("Pattern not found in template literal");
  i.type = "string", i.pattern = o.source;
}, Bye = (e, t, n, r) => {
  const i = n, o = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  }, { minimum: s, maximum: a, mime: c } = e._zod.bag;
  s !== void 0 && (o.minLength = s), a !== void 0 && (o.maxLength = a), c ? c.length === 1 ? (o.contentMediaType = c[0], Object.assign(i, o)) : (Object.assign(i, o), i.anyOf = c.map((u) => ({ contentMediaType: u }))) : Object.assign(i, o);
}, $ye = (e, t, n, r) => {
  n.type = "boolean";
}, K8 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, Uye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Function types cannot be represented in JSON Schema");
}, Z8 = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, Fye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Map cannot be represented in JSON Schema");
}, Vye = (e, t, n, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Set cannot be represented in JSON Schema");
}, Y8 = (e, t, n, r) => {
  const i = n, o = e._zod.def, { minimum: s, maximum: a } = e._zod.bag;
  typeof s == "number" && (i.minItems = s), typeof a == "number" && (i.maxItems = a), i.type = "array", i.items = On(o.element, t, { ...r, path: [...r.path, "items"] });
}, X8 = (e, t, n, r) => {
  const i = n, o = e._zod.def;
  i.type = "object", i.properties = {};
  const s = o.shape;
  for (const u in s)
    i.properties[u] = On(s[u], t, {
      ...r,
      path: [...r.path, "properties", u]
    });
  const a = new Set(Object.keys(s)), c = new Set([...a].filter((u) => {
    const f = o.shape[u]._zod;
    return t.io === "input" ? f.optin === void 0 : f.optout === void 0;
  }));
  c.size > 0 && (i.required = Array.from(c)), o.catchall?._zod.def.type === "never" ? i.additionalProperties = !1 : o.catchall ? o.catchall && (i.additionalProperties = On(o.catchall, t, {
    ...r,
    path: [...r.path, "additionalProperties"]
  })) : t.io === "output" && (i.additionalProperties = !1);
}, J8 = (e, t, n, r) => {
  const i = e._zod.def, o = i.inclusive === !1, s = i.options.map((a, c) => On(a, t, {
    ...r,
    path: [...r.path, o ? "oneOf" : "anyOf", c]
  }));
  o ? n.oneOf = s : n.anyOf = s;
}, Q8 = (e, t, n, r) => {
  const i = e._zod.def, o = On(i.left, t, {
    ...r,
    path: [...r.path, "allOf", 0]
  }), s = On(i.right, t, {
    ...r,
    path: [...r.path, "allOf", 1]
  }), a = (u) => "allOf" in u && Object.keys(u).length === 1, c = [
    ...a(o) ? o.allOf : [o],
    ...a(s) ? s.allOf : [s]
  ];
  n.allOf = c;
}, Hye = (e, t, n, r) => {
  const i = n, o = e._zod.def;
  i.type = "array";
  const s = t.target === "draft-2020-12" ? "prefixItems" : "items", a = t.target === "draft-2020-12" || t.target === "openapi-3.0" ? "items" : "additionalItems", c = o.items.map((m, g) => On(m, t, {
    ...r,
    path: [...r.path, s, g]
  })), u = o.rest ? On(o.rest, t, {
    ...r,
    path: [...r.path, a, ...t.target === "openapi-3.0" ? [o.items.length] : []]
  }) : null;
  t.target === "draft-2020-12" ? (i.prefixItems = c, u && (i.items = u)) : t.target === "openapi-3.0" ? (i.items = {
    anyOf: c
  }, u && i.items.anyOf.push(u), i.minItems = c.length, u || (i.maxItems = c.length)) : (i.items = c, u && (i.additionalItems = u));
  const { minimum: f, maximum: h } = e._zod.bag;
  typeof f == "number" && (i.minItems = f), typeof h == "number" && (i.maxItems = h);
}, eF = (e, t, n, r) => {
  const i = n, o = e._zod.def;
  i.type = "object";
  const s = o.keyType, c = s._zod.bag?.patterns;
  if (o.mode === "loose" && c && c.size > 0) {
    const f = On(o.valueType, t, {
      ...r,
      path: [...r.path, "patternProperties", "*"]
    });
    i.patternProperties = {};
    for (const h of c)
      i.patternProperties[h.source] = f;
  } else
    (t.target === "draft-07" || t.target === "draft-2020-12") && (i.propertyNames = On(o.keyType, t, {
      ...r,
      path: [...r.path, "propertyNames"]
    })), i.additionalProperties = On(o.valueType, t, {
      ...r,
      path: [...r.path, "additionalProperties"]
    });
  const u = s._zod.values;
  if (u) {
    const f = [...u].filter((h) => typeof h == "string" || typeof h == "number");
    f.length > 0 && (i.required = f);
  }
}, tF = (e, t, n, r) => {
  const i = e._zod.def, o = On(i.innerType, t, r), s = t.seen.get(e);
  t.target === "openapi-3.0" ? (s.ref = i.innerType, n.nullable = !0) : n.anyOf = [o, { type: "null" }];
}, nF = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType;
}, rF = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType, n.default = JSON.parse(JSON.stringify(i.defaultValue));
}, iF = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType, t.io === "input" && (n._prefault = JSON.parse(JSON.stringify(i.defaultValue)));
}, oF = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType;
  let s;
  try {
    s = i.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  n.default = s;
}, sF = (e, t, n, r) => {
  const i = e._zod.def, o = t.io === "input" ? i.in._zod.def.type === "transform" ? i.out : i.in : i.out;
  On(o, t, r);
  const s = t.seen.get(e);
  s.ref = o;
}, aF = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType, n.readOnly = !0;
}, Wye = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType;
}, OM = (e, t, n, r) => {
  const i = e._zod.def;
  On(i.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = i.innerType;
}, lF = (e, t, n, r) => {
  const i = e._zod.innerType;
  On(i, t, r);
  const o = t.seen.get(e);
  o.ref = i;
}, PI = {
  string: $8,
  number: U8,
  boolean: F8,
  bigint: Rye,
  symbol: Oye,
  null: V8,
  undefined: Dye,
  void: Pye,
  never: H8,
  any: jye,
  unknown: W8,
  date: Iye,
  enum: q8,
  literal: G8,
  nan: zye,
  template_literal: Lye,
  file: Bye,
  success: $ye,
  custom: K8,
  function: Uye,
  transform: Z8,
  map: Fye,
  set: Vye,
  array: Y8,
  object: X8,
  union: J8,
  intersection: Q8,
  tuple: Hye,
  record: eF,
  nullable: tF,
  nonoptional: nF,
  default: rF,
  prefault: iF,
  catch: oF,
  pipe: sF,
  readonly: aF,
  promise: Wye,
  optional: OM,
  lazy: lF
};
function qye(e, t) {
  if ("_idmap" in e) {
    const r = e, i = Ab({ ...t, processors: PI }), o = {};
    for (const c of r._idmap.entries()) {
      const [u, f] = c;
      On(f, i);
    }
    const s = {}, a = {
      registry: r,
      uri: t?.uri,
      defs: o
    };
    i.external = a;
    for (const c of r._idmap.entries()) {
      const [u, f] = c;
      Mb(i, f), s[u] = Nb(i, f);
    }
    if (Object.keys(o).length > 0) {
      const c = i.target === "draft-2020-12" ? "$defs" : "definitions";
      s.__shared = {
        [c]: o
      };
    }
    return { schemas: s };
  }
  const n = Ab({ ...t, processors: PI });
  return On(e, n), Mb(n, e), Nb(n, e);
}
const Gye = /* @__PURE__ */ De("ZodISODateTime", (e, t) => {
  Zme.init(e, t), Xn.init(e, t);
});
function Kye(e) {
  return /* @__PURE__ */ rye(Gye, e);
}
const Zye = /* @__PURE__ */ De("ZodISODate", (e, t) => {
  Yme.init(e, t), Xn.init(e, t);
});
function Yye(e) {
  return /* @__PURE__ */ iye(Zye, e);
}
const Xye = /* @__PURE__ */ De("ZodISOTime", (e, t) => {
  Xme.init(e, t), Xn.init(e, t);
});
function Jye(e) {
  return /* @__PURE__ */ oye(Xye, e);
}
const Qye = /* @__PURE__ */ De("ZodISODuration", (e, t) => {
  Jme.init(e, t), Xn.init(e, t);
});
function eve(e) {
  return /* @__PURE__ */ sye(Qye, e);
}
const tve = (e, t) => {
  k8.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (n) => Upe(e, n)
      // enumerable: false,
    },
    flatten: {
      value: (n) => $pe(e, n)
      // enumerable: false,
    },
    addIssue: {
      value: (n) => {
        e.issues.push(n), e.message = JSON.stringify(e.issues, R_, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (n) => {
        e.issues.push(...n), e.message = JSON.stringify(e.issues, R_, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, Go = De("ZodError", tve, {
  Parent: Error
}), nve = /* @__PURE__ */ MM(Go), rve = /* @__PURE__ */ NM(Go), ive = /* @__PURE__ */ Mw(Go), cF = /* @__PURE__ */ Nw(Go), ove = /* @__PURE__ */ Hpe(Go), sve = /* @__PURE__ */ Wpe(Go), ave = /* @__PURE__ */ qpe(Go), lve = /* @__PURE__ */ Gpe(Go), cve = /* @__PURE__ */ Kpe(Go), uve = /* @__PURE__ */ Zpe(Go), dve = /* @__PURE__ */ Ype(Go), fve = /* @__PURE__ */ Xpe(Go), Hn = /* @__PURE__ */ De("ZodType", (e, t) => (Vn.init(e, t), Object.assign(e["~standard"], {
  jsonSchema: {
    input: Rb(e, "input"),
    output: Rb(e, "output")
  }
}), e.toJSONSchema = Mye(e, {}), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(Bc(t, {
  checks: [
    ...t.checks ?? [],
    ...n.map((r) => typeof r == "function" ? { _zod: { check: r, def: { check: "custom" }, onattach: [] } } : r)
  ]
}), {
  parent: !0
}), e.with = e.check, e.clone = (n, r) => $c(e, n, r), e.brand = () => e, e.register = ((n, r) => (n.add(e, r), e)), e.parse = (n, r) => nve(e, n, r, { callee: e.parse }), e.safeParse = (n, r) => ive(e, n, r), e.parseAsync = async (n, r) => rve(e, n, r, { callee: e.parseAsync }), e.safeParseAsync = async (n, r) => cF(e, n, r), e.spa = e.safeParseAsync, e.encode = (n, r) => ove(e, n, r), e.decode = (n, r) => sve(e, n, r), e.encodeAsync = async (n, r) => ave(e, n, r), e.decodeAsync = async (n, r) => lve(e, n, r), e.safeEncode = (n, r) => cve(e, n, r), e.safeDecode = (n, r) => uve(e, n, r), e.safeEncodeAsync = async (n, r) => dve(e, n, r), e.safeDecodeAsync = async (n, r) => fve(e, n, r), e.refine = (n, r) => e.check(l0e(n, r)), e.superRefine = (n) => e.check(c0e(n)), e.overwrite = (n) => e.check(/* @__PURE__ */ Bh(n)), e.optional = () => zI(e), e.exactOptional = () => Kve(e), e.nullable = () => LI(e), e.nullish = () => zI(LI(e)), e.nonoptional = (n) => e0e(e, n), e.array = () => $h(e), e.or = (n) => Wo([e, n]), e.and = (n) => Fve(e, n), e.transform = (n) => BI(e, qve(n)), e.default = (n) => Xve(e, n), e.prefault = (n) => Qve(e, n), e.catch = (n) => n0e(e, n), e.pipe = (n) => BI(e, n), e.readonly = () => o0e(e), e.describe = (n) => {
  const r = e.clone();
  return um.add(r, { description: n }), r;
}, Object.defineProperty(e, "description", {
  get() {
    return um.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...n) => {
  if (n.length === 0)
    return um.get(e);
  const r = e.clone();
  return um.add(r, n[0]), r;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e.apply = (n) => n(e), e)), uF = /* @__PURE__ */ De("_ZodString", (e, t) => {
  RM.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (r, i, o) => $8(e, r, i);
  const n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...r) => e.check(/* @__PURE__ */ hye(...r)), e.includes = (...r) => e.check(/* @__PURE__ */ gye(...r)), e.startsWith = (...r) => e.check(/* @__PURE__ */ yye(...r)), e.endsWith = (...r) => e.check(/* @__PURE__ */ vye(...r)), e.min = (...r) => e.check(/* @__PURE__ */ Tb(...r)), e.max = (...r) => e.check(/* @__PURE__ */ L8(...r)), e.length = (...r) => e.check(/* @__PURE__ */ B8(...r)), e.nonempty = (...r) => e.check(/* @__PURE__ */ Tb(1, ...r)), e.lowercase = (r) => e.check(/* @__PURE__ */ pye(r)), e.uppercase = (r) => e.check(/* @__PURE__ */ mye(r)), e.trim = () => e.check(/* @__PURE__ */ xye()), e.normalize = (...r) => e.check(/* @__PURE__ */ bye(...r)), e.toLowerCase = () => e.check(/* @__PURE__ */ wye()), e.toUpperCase = () => e.check(/* @__PURE__ */ Sye()), e.slugify = () => e.check(/* @__PURE__ */ kye());
}), hve = /* @__PURE__ */ De("ZodString", (e, t) => {
  RM.init(e, t), uF.init(e, t), e.email = (n) => e.check(/* @__PURE__ */ Ige(pve, n)), e.url = (n) => e.check(/* @__PURE__ */ Uge(mve, n)), e.jwt = (n) => e.check(/* @__PURE__ */ nye(Nve, n)), e.emoji = (n) => e.check(/* @__PURE__ */ Fge(gve, n)), e.guid = (n) => e.check(/* @__PURE__ */ NI(jI, n)), e.uuid = (n) => e.check(/* @__PURE__ */ zge(Fv, n)), e.uuidv4 = (n) => e.check(/* @__PURE__ */ Lge(Fv, n)), e.uuidv6 = (n) => e.check(/* @__PURE__ */ Bge(Fv, n)), e.uuidv7 = (n) => e.check(/* @__PURE__ */ $ge(Fv, n)), e.nanoid = (n) => e.check(/* @__PURE__ */ Vge(yve, n)), e.guid = (n) => e.check(/* @__PURE__ */ NI(jI, n)), e.cuid = (n) => e.check(/* @__PURE__ */ Hge(vve, n)), e.cuid2 = (n) => e.check(/* @__PURE__ */ Wge(bve, n)), e.ulid = (n) => e.check(/* @__PURE__ */ qge(xve, n)), e.base64 = (n) => e.check(/* @__PURE__ */ Qge(Tve, n)), e.base64url = (n) => e.check(/* @__PURE__ */ eye(Ave, n)), e.xid = (n) => e.check(/* @__PURE__ */ Gge(wve, n)), e.ksuid = (n) => e.check(/* @__PURE__ */ Kge(Sve, n)), e.ipv4 = (n) => e.check(/* @__PURE__ */ Zge(kve, n)), e.ipv6 = (n) => e.check(/* @__PURE__ */ Yge(Cve, n)), e.cidrv4 = (n) => e.check(/* @__PURE__ */ Xge(Eve, n)), e.cidrv6 = (n) => e.check(/* @__PURE__ */ Jge(_ve, n)), e.e164 = (n) => e.check(/* @__PURE__ */ tye(Mve, n)), e.datetime = (n) => e.check(Kye(n)), e.date = (n) => e.check(Yye(n)), e.time = (n) => e.check(Jye(n)), e.duration = (n) => e.check(eve(n));
});
function gt(e) {
  return /* @__PURE__ */ jge(hve, e);
}
const Xn = /* @__PURE__ */ De("ZodStringFormat", (e, t) => {
  Kn.init(e, t), uF.init(e, t);
}), pve = /* @__PURE__ */ De("ZodEmail", (e, t) => {
  $me.init(e, t), Xn.init(e, t);
}), jI = /* @__PURE__ */ De("ZodGUID", (e, t) => {
  Lme.init(e, t), Xn.init(e, t);
}), Fv = /* @__PURE__ */ De("ZodUUID", (e, t) => {
  Bme.init(e, t), Xn.init(e, t);
}), mve = /* @__PURE__ */ De("ZodURL", (e, t) => {
  Ume.init(e, t), Xn.init(e, t);
}), gve = /* @__PURE__ */ De("ZodEmoji", (e, t) => {
  Fme.init(e, t), Xn.init(e, t);
}), yve = /* @__PURE__ */ De("ZodNanoID", (e, t) => {
  Vme.init(e, t), Xn.init(e, t);
}), vve = /* @__PURE__ */ De("ZodCUID", (e, t) => {
  Hme.init(e, t), Xn.init(e, t);
}), bve = /* @__PURE__ */ De("ZodCUID2", (e, t) => {
  Wme.init(e, t), Xn.init(e, t);
}), xve = /* @__PURE__ */ De("ZodULID", (e, t) => {
  qme.init(e, t), Xn.init(e, t);
}), wve = /* @__PURE__ */ De("ZodXID", (e, t) => {
  Gme.init(e, t), Xn.init(e, t);
}), Sve = /* @__PURE__ */ De("ZodKSUID", (e, t) => {
  Kme.init(e, t), Xn.init(e, t);
}), kve = /* @__PURE__ */ De("ZodIPv4", (e, t) => {
  Qme.init(e, t), Xn.init(e, t);
}), Cve = /* @__PURE__ */ De("ZodIPv6", (e, t) => {
  ege.init(e, t), Xn.init(e, t);
}), Eve = /* @__PURE__ */ De("ZodCIDRv4", (e, t) => {
  tge.init(e, t), Xn.init(e, t);
}), _ve = /* @__PURE__ */ De("ZodCIDRv6", (e, t) => {
  nge.init(e, t), Xn.init(e, t);
}), Tve = /* @__PURE__ */ De("ZodBase64", (e, t) => {
  rge.init(e, t), Xn.init(e, t);
}), Ave = /* @__PURE__ */ De("ZodBase64URL", (e, t) => {
  oge.init(e, t), Xn.init(e, t);
}), Mve = /* @__PURE__ */ De("ZodE164", (e, t) => {
  sge.init(e, t), Xn.init(e, t);
}), Nve = /* @__PURE__ */ De("ZodJWT", (e, t) => {
  lge.init(e, t), Xn.init(e, t);
}), dF = /* @__PURE__ */ De("ZodNumber", (e, t) => {
  D8.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (r, i, o) => U8(e, r, i), e.gt = (r, i) => e.check(/* @__PURE__ */ OI(r, i)), e.gte = (r, i) => e.check(/* @__PURE__ */ uC(r, i)), e.min = (r, i) => e.check(/* @__PURE__ */ uC(r, i)), e.lt = (r, i) => e.check(/* @__PURE__ */ RI(r, i)), e.lte = (r, i) => e.check(/* @__PURE__ */ cC(r, i)), e.max = (r, i) => e.check(/* @__PURE__ */ cC(r, i)), e.int = (r) => e.check(II(r)), e.safe = (r) => e.check(II(r)), e.positive = (r) => e.check(/* @__PURE__ */ OI(0, r)), e.nonnegative = (r) => e.check(/* @__PURE__ */ uC(0, r)), e.negative = (r) => e.check(/* @__PURE__ */ RI(0, r)), e.nonpositive = (r) => e.check(/* @__PURE__ */ cC(0, r)), e.multipleOf = (r, i) => e.check(/* @__PURE__ */ DI(r, i)), e.step = (r, i) => e.check(/* @__PURE__ */ DI(r, i)), e.finite = () => e;
  const n = e._zod.bag;
  e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? 0.5), e.isFinite = !0, e.format = n.format ?? null;
});
function Rve(e) {
  return /* @__PURE__ */ aye(dF, e);
}
const Ove = /* @__PURE__ */ De("ZodNumberFormat", (e, t) => {
  cge.init(e, t), dF.init(e, t);
});
function II(e) {
  return /* @__PURE__ */ lye(Ove, e);
}
const Dve = /* @__PURE__ */ De("ZodBoolean", (e, t) => {
  uge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => F8(e, n, r);
});
function Wi(e) {
  return /* @__PURE__ */ cye(Dve, e);
}
const Pve = /* @__PURE__ */ De("ZodNull", (e, t) => {
  dge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => V8(e, n, r);
});
function jve(e) {
  return /* @__PURE__ */ uye(Pve, e);
}
const Ive = /* @__PURE__ */ De("ZodUnknown", (e, t) => {
  fge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => W8();
});
function Us() {
  return /* @__PURE__ */ dye(Ive);
}
const zve = /* @__PURE__ */ De("ZodNever", (e, t) => {
  hge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => H8(e, n, r);
});
function fF(e) {
  return /* @__PURE__ */ fye(zve, e);
}
const Lve = /* @__PURE__ */ De("ZodArray", (e, t) => {
  pge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => Y8(e, n, r, i), e.element = t.element, e.min = (n, r) => e.check(/* @__PURE__ */ Tb(n, r)), e.nonempty = (n) => e.check(/* @__PURE__ */ Tb(1, n)), e.max = (n, r) => e.check(/* @__PURE__ */ L8(n, r)), e.length = (n, r) => e.check(/* @__PURE__ */ B8(n, r)), e.unwrap = () => e.element;
});
function $h(e, t) {
  return /* @__PURE__ */ Cye(Lve, e, t);
}
const hF = /* @__PURE__ */ De("ZodObject", (e, t) => {
  gge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => X8(e, n, r, i), en(e, "shape", () => t.shape), e.keyof = () => mF(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: Us() }), e.loose = () => e.clone({ ...e._zod.def, catchall: Us() }), e.strict = () => e.clone({ ...e._zod.def, catchall: fF() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => jpe(e, n), e.safeExtend = (n) => Ipe(e, n), e.merge = (n) => zpe(e, n), e.pick = (n) => Dpe(e, n), e.omit = (n) => Ppe(e, n), e.partial = (...n) => Lpe(gF, e, n[0]), e.required = (...n) => Bpe(yF, e, n[0]);
});
function ei(e, t) {
  const n = {
    type: "object",
    shape: e ?? {},
    ...ct(t)
  };
  return new hF(n);
}
function Yn(e, t) {
  return new hF({
    type: "object",
    shape: e,
    catchall: fF(),
    ...ct(t)
  });
}
const pF = /* @__PURE__ */ De("ZodUnion", (e, t) => {
  I8.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => J8(e, n, r, i), e.options = t.options;
});
function Wo(e, t) {
  return new pF({
    type: "union",
    options: e,
    ...ct(t)
  });
}
const Bve = /* @__PURE__ */ De("ZodDiscriminatedUnion", (e, t) => {
  pF.init(e, t), yge.init(e, t);
});
function $ve(e, t, n) {
  return new Bve({
    type: "union",
    options: t,
    discriminator: e,
    ...ct(n)
  });
}
const Uve = /* @__PURE__ */ De("ZodIntersection", (e, t) => {
  vge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => Q8(e, n, r, i);
});
function Fve(e, t) {
  return new Uve({
    type: "intersection",
    left: e,
    right: t
  });
}
const Vve = /* @__PURE__ */ De("ZodRecord", (e, t) => {
  bge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => eF(e, n, r, i), e.keyType = t.keyType, e.valueType = t.valueType;
});
function D_(e, t, n) {
  return new Vve({
    type: "record",
    keyType: e,
    valueType: t,
    ...ct(n)
  });
}
const P_ = /* @__PURE__ */ De("ZodEnum", (e, t) => {
  xge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (r, i, o) => q8(e, r, i), e.enum = t.entries, e.options = Object.values(t.entries);
  const n = new Set(Object.keys(t.entries));
  e.extract = (r, i) => {
    const o = {};
    for (const s of r)
      if (n.has(s))
        o[s] = t.entries[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new P_({
      ...t,
      checks: [],
      ...ct(i),
      entries: o
    });
  }, e.exclude = (r, i) => {
    const o = { ...t.entries };
    for (const s of r)
      if (n.has(s))
        delete o[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new P_({
      ...t,
      checks: [],
      ...ct(i),
      entries: o
    });
  };
});
function mF(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((r) => [r, r])) : e;
  return new P_({
    type: "enum",
    entries: n,
    ...ct(t)
  });
}
const Hve = /* @__PURE__ */ De("ZodLiteral", (e, t) => {
  wge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => G8(e, n, r), e.values = new Set(t.values), Object.defineProperty(e, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function Ut(e, t) {
  return new Hve({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...ct(t)
  });
}
const Wve = /* @__PURE__ */ De("ZodTransform", (e, t) => {
  Sge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => Z8(e, n), e._zod.parse = (n, r) => {
    if (r.direction === "backward")
      throw new y8(e.constructor.name);
    n.addIssue = (o) => {
      if (typeof o == "string")
        n.issues.push(og(o, n.value, t));
      else {
        const s = o;
        s.fatal && (s.continue = !1), s.code ?? (s.code = "custom"), s.input ?? (s.input = n.value), s.inst ?? (s.inst = e), n.issues.push(og(s));
      }
    };
    const i = t.transform(n.value, n);
    return i instanceof Promise ? i.then((o) => (n.value = o, n)) : (n.value = i, n);
  };
});
function qve(e) {
  return new Wve({
    type: "transform",
    transform: e
  });
}
const gF = /* @__PURE__ */ De("ZodOptional", (e, t) => {
  z8.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => OM(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function zI(e) {
  return new gF({
    type: "optional",
    innerType: e
  });
}
const Gve = /* @__PURE__ */ De("ZodExactOptional", (e, t) => {
  kge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => OM(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function Kve(e) {
  return new Gve({
    type: "optional",
    innerType: e
  });
}
const Zve = /* @__PURE__ */ De("ZodNullable", (e, t) => {
  Cge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => tF(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function LI(e) {
  return new Zve({
    type: "nullable",
    innerType: e
  });
}
const Yve = /* @__PURE__ */ De("ZodDefault", (e, t) => {
  Ege.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => rF(e, n, r, i), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function Xve(e, t) {
  return new Yve({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : w8(t);
    }
  });
}
const Jve = /* @__PURE__ */ De("ZodPrefault", (e, t) => {
  _ge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => iF(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function Qve(e, t) {
  return new Jve({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : w8(t);
    }
  });
}
const yF = /* @__PURE__ */ De("ZodNonOptional", (e, t) => {
  Tge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => nF(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function e0e(e, t) {
  return new yF({
    type: "nonoptional",
    innerType: e,
    ...ct(t)
  });
}
const t0e = /* @__PURE__ */ De("ZodCatch", (e, t) => {
  Age.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => oF(e, n, r, i), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function n0e(e, t) {
  return new t0e({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const r0e = /* @__PURE__ */ De("ZodPipe", (e, t) => {
  Mge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => sF(e, n, r, i), e.in = t.in, e.out = t.out;
});
function BI(e, t) {
  return new r0e({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const i0e = /* @__PURE__ */ De("ZodReadonly", (e, t) => {
  Nge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => aF(e, n, r, i), e.unwrap = () => e._zod.def.innerType;
});
function o0e(e) {
  return new i0e({
    type: "readonly",
    innerType: e
  });
}
const s0e = /* @__PURE__ */ De("ZodLazy", (e, t) => {
  Rge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => lF(e, n, r, i), e.unwrap = () => e._zod.def.getter();
});
function a0e(e) {
  return new s0e({
    type: "lazy",
    getter: e
  });
}
const DM = /* @__PURE__ */ De("ZodCustom", (e, t) => {
  Oge.init(e, t), Hn.init(e, t), e._zod.processJSONSchema = (n, r, i) => K8(e, n);
});
function vF(e, t) {
  return /* @__PURE__ */ Eye(DM, e ?? (() => !0), t);
}
function l0e(e, t = {}) {
  return /* @__PURE__ */ _ye(DM, e, t);
}
function c0e(e) {
  return /* @__PURE__ */ Tye(e);
}
function Ob(e, t = {}) {
  const n = new DM({
    type: "custom",
    check: "custom",
    fn: (r) => r instanceof e,
    abort: !0,
    ...ct(t)
  });
  return n._zod.bag.Class = e, n._zod.check = (r) => {
    r.value instanceof e || r.issues.push({
      code: "invalid_type",
      expected: e.name,
      input: r.value,
      inst: n,
      path: [...n._zod.def.path ?? []]
    });
  }, n;
}
var sg;
(function(e) {
  e.assertEqual = (i) => {
  };
  function t(i) {
  }
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (i) => {
    const o = {};
    for (const s of i)
      o[s] = s;
    return o;
  }, e.getValidEnumValues = (i) => {
    const o = e.objectKeys(i).filter((a) => typeof i[i[a]] != "number"), s = {};
    for (const a of o)
      s[a] = i[a];
    return e.objectValues(s);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(o) {
    return i[o];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const o = [];
    for (const s in i)
      Object.prototype.hasOwnProperty.call(i, s) && o.push(s);
    return o;
  }, e.find = (i, o) => {
    for (const s of i)
      if (o(s))
        return s;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && Number.isFinite(i) && Math.floor(i) === i;
  function r(i, o = " | ") {
    return i.map((s) => typeof s == "string" ? `'${s}'` : s).join(o);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (i, o) => typeof o == "bigint" ? o.toString() : o;
})(sg || (sg = {}));
var $I;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})($I || ($I = {}));
sg.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
sg.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class Db extends Error {
  get errors() {
    return this.issues;
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  format(t) {
    const n = t || function(o) {
      return o.message;
    }, r = { _errors: [] }, i = (o) => {
      for (const s of o.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(i);
        else if (s.code === "invalid_return_type")
          i(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          i(s.argumentsError);
        else if (s.path.length === 0)
          r._errors.push(n(s));
        else {
          let a = r, c = 0;
          for (; c < s.path.length; ) {
            const u = s.path[c];
            c === s.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(n(s))) : a[u] = a[u] || { _errors: [] }, a = a[u], c++;
          }
        }
    };
    return i(this), r;
  }
  static assert(t) {
    if (!(t instanceof Db))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, sg.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = /* @__PURE__ */ Object.create(null), r = [];
    for (const i of this.issues)
      if (i.path.length > 0) {
        const o = i.path[0];
        n[o] = n[o] || [], n[o].push(t(i));
      } else
        r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
Db.create = (e) => new Db(e);
var UI;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
})(UI || (UI = {}));
var Mt;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Mt || (Mt = {}));
var ey = ({
  prefix: e,
  size: t = 16,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: r = "-"
} = {}) => {
  const i = () => {
    const o = n.length, s = new Array(t);
    for (let a = 0; a < t; a++)
      s[a] = n[Math.random() * o | 0];
    return s.join("");
  };
  if (e == null)
    return i;
  if (n.includes(r))
    throw new wpe({
      argument: "separator",
      message: `The separator "${r}" must not be part of the alphabet "${n}".`
    });
  return () => `${e}${r}${i()}`;
}, u0e = ey();
function FI(e = globalThis) {
  var t, n, r;
  return e.window ? "runtime/browser" : (t = e.navigator) != null && t.userAgent ? `runtime/${e.navigator.userAgent.toLowerCase()}` : (r = (n = e.process) == null ? void 0 : n.versions) != null && r.node ? `runtime/node.js/${e.process.version.substring(0)}` : e.EdgeRuntime ? "runtime/vercel-edge" : "runtime/unknown";
}
function Au(e) {
  if (e == null)
    return {};
  const t = {};
  if (e instanceof Headers)
    e.forEach((n, r) => {
      t[r.toLowerCase()] = n;
    });
  else {
    Array.isArray(e) || (e = Object.entries(e));
    for (const [n, r] of e)
      r != null && (t[n.toLowerCase()] = r);
  }
  return t;
}
function VI(e, ...t) {
  const n = new Headers(Au(e)), r = n.get("user-agent") || "";
  return n.set(
    "user-agent",
    [r, ...t].filter(Boolean).join(" ")
  ), Object.fromEntries(n.entries());
}
var d0e = /"__proto__"\s*:/, f0e = /"constructor"\s*:/;
function HI(e) {
  const t = JSON.parse(e);
  return t === null || typeof t != "object" || d0e.test(e) === !1 && f0e.test(e) === !1 ? t : h0e(t);
}
function h0e(e) {
  let t = [e];
  for (; t.length; ) {
    const n = t;
    t = [];
    for (const r of n) {
      if (Object.prototype.hasOwnProperty.call(r, "__proto__"))
        throw new SyntaxError("Object contains forbidden prototype property");
      if (Object.prototype.hasOwnProperty.call(r, "constructor") && Object.prototype.hasOwnProperty.call(r.constructor, "prototype"))
        throw new SyntaxError("Object contains forbidden prototype property");
      for (const i in r) {
        const o = r[i];
        o && typeof o == "object" && t.push(o);
      }
    }
  }
  return e;
}
function p0e(e) {
  const { stackTraceLimit: t } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch {
    return HI(e);
  }
  try {
    return HI(e);
  } finally {
    Error.stackTraceLimit = t;
  }
}
var Pb = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function m0e(e) {
  return { [Pb]: !0, validate: e };
}
function g0e(e) {
  return typeof e == "object" && e !== null && Pb in e && e[Pb] === !0 && "validate" in e;
}
function y0e(e) {
  let t;
  return () => (t == null && (t = e()), t);
}
function v0e(e) {
  return g0e(e) ? e : typeof e == "function" ? e() : b0e(e);
}
function b0e(e) {
  return m0e(async (t) => {
    const n = await e["~standard"].validate(t);
    return n.issues == null ? { success: !0, value: n.value } : {
      success: !1,
      error: new Eb({
        value: t,
        cause: n.issues
      })
    };
  });
}
async function WI({
  value: e,
  schema: t
}) {
  const n = await PM({ value: e, schema: t });
  if (!n.success)
    throw Eb.wrap({ value: e, cause: n.error });
  return n.value;
}
async function PM({
  value: e,
  schema: t
}) {
  const n = v0e(t);
  try {
    if (n.validate == null)
      return { success: !0, value: e, rawValue: e };
    const r = await n.validate(e);
    return r.success ? { success: !0, value: r.value, rawValue: e } : {
      success: !1,
      error: Eb.wrap({ value: e, cause: r.error }),
      rawValue: e
    };
  } catch (r) {
    return {
      success: !1,
      error: Eb.wrap({ value: e, cause: r }),
      rawValue: e
    };
  }
}
async function jb({
  text: e,
  schema: t
}) {
  try {
    const n = p0e(e);
    return t == null ? { success: !0, value: n, rawValue: n } : await PM({ value: n, schema: t });
  } catch (n) {
    return {
      success: !1,
      error: pI.isInstance(n) ? n : new pI({ text: e, cause: n }),
      rawValue: void 0
    };
  }
}
function x0e({
  stream: e,
  schema: t
}) {
  return e.pipeThrough(new TextDecoderStream()).pipeThrough(new _pe()).pipeThrough(
    new TransformStream({
      async transform({ data: n }, r) {
        n !== "[DONE]" && r.enqueue(await jb({ text: n, schema: t }));
      }
    })
  );
}
async function pf(e) {
  return typeof e == "function" && (e = e()), Promise.resolve(e);
}
function D0(e) {
  if (e.type === "object") {
    e.additionalProperties = !1;
    const t = e.properties;
    if (t != null)
      for (const n in t)
        t[n] = D0(
          t[n]
        );
  }
  return e.type === "array" && e.items != null && (Array.isArray(e.items) ? e.items = e.items.map(
    (t) => D0(t)
  ) : e.items = D0(
    e.items
  )), e;
}
var w0e = (e, t) => {
  let n = 0;
  for (; n < e.length && n < t.length && e[n] === t[n]; n++)
    ;
  return [(e.length - n).toString(), ...t.slice(n)].join("/");
}, S0e = /* @__PURE__ */ Symbol(
  "Let zodToJsonSchema decide on which parser to use"
), qI = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, k0e = (e) => typeof e == "string" ? {
  ...qI,
  name: e
} : {
  ...qI,
  ...e
};
function go() {
  return {};
}
function C0e(e, t) {
  var n, r, i;
  const o = {
    type: "array"
  };
  return (n = e.type) != null && n._def && ((i = (r = e.type) == null ? void 0 : r._def) == null ? void 0 : i.typeName) !== Mt.ZodAny && (o.items = gn(e.type._def, {
    ...t,
    currentPath: [...t.currentPath, "items"]
  })), e.minLength && (o.minItems = e.minLength.value), e.maxLength && (o.maxItems = e.maxLength.value), e.exactLength && (o.minItems = e.exactLength.value, o.maxItems = e.exactLength.value), o;
}
function E0e(e) {
  const t = {
    type: "integer",
    format: "int64"
  };
  if (!e.checks) return t;
  for (const n of e.checks)
    switch (n.kind) {
      case "min":
        n.inclusive ? t.minimum = n.value : t.exclusiveMinimum = n.value;
        break;
      case "max":
        n.inclusive ? t.maximum = n.value : t.exclusiveMaximum = n.value;
        break;
      case "multipleOf":
        t.multipleOf = n.value;
        break;
    }
  return t;
}
function _0e() {
  return { type: "boolean" };
}
function bF(e, t) {
  return gn(e.type._def, t);
}
var T0e = (e, t) => gn(e.innerType._def, t);
function xF(e, t, n) {
  const r = n ?? t.dateStrategy;
  if (Array.isArray(r))
    return {
      anyOf: r.map((i, o) => xF(e, t, i))
    };
  switch (r) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return A0e(e);
  }
}
var A0e = (e) => {
  const t = {
    type: "integer",
    format: "unix-time"
  };
  for (const n of e.checks)
    switch (n.kind) {
      case "min":
        t.minimum = n.value;
        break;
      case "max":
        t.maximum = n.value;
        break;
    }
  return t;
};
function M0e(e, t) {
  return {
    ...gn(e.innerType._def, t),
    default: e.defaultValue()
  };
}
function N0e(e, t) {
  return t.effectStrategy === "input" ? gn(e.schema._def, t) : go();
}
function R0e(e) {
  return {
    type: "string",
    enum: Array.from(e.values)
  };
}
var O0e = (e) => "type" in e && e.type === "string" ? !1 : "allOf" in e;
function D0e(e, t) {
  const n = [
    gn(e.left._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "0"]
    }),
    gn(e.right._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "1"]
    })
  ].filter((i) => !!i), r = [];
  return n.forEach((i) => {
    if (O0e(i))
      r.push(...i.allOf);
    else {
      let o = i;
      if ("additionalProperties" in i && i.additionalProperties === !1) {
        const { additionalProperties: s, ...a } = i;
        o = a;
      }
      r.push(o);
    }
  }), r.length ? { allOf: r } : void 0;
}
function P0e(e) {
  const t = typeof e.value;
  return t !== "bigint" && t !== "number" && t !== "boolean" && t !== "string" ? {
    type: Array.isArray(e.value) ? "array" : "object"
  } : {
    type: t === "bigint" ? "integer" : t,
    const: e.value
  };
}
var dC = void 0, ts = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (dC === void 0 && (dC = RegExp(
    "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
    "u"
  )), dC),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function wF(e, t) {
  const n = {
    type: "string"
  };
  if (e.checks)
    for (const r of e.checks)
      switch (r.kind) {
        case "min":
          n.minLength = typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value;
          break;
        case "max":
          n.maxLength = typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value;
          break;
        case "email":
          switch (t.emailStrategy) {
            case "format:email":
              ns(n, "email", r.message, t);
              break;
            case "format:idn-email":
              ns(n, "idn-email", r.message, t);
              break;
            case "pattern:zod":
              Ci(n, ts.email, r.message, t);
              break;
          }
          break;
        case "url":
          ns(n, "uri", r.message, t);
          break;
        case "uuid":
          ns(n, "uuid", r.message, t);
          break;
        case "regex":
          Ci(n, r.regex, r.message, t);
          break;
        case "cuid":
          Ci(n, ts.cuid, r.message, t);
          break;
        case "cuid2":
          Ci(n, ts.cuid2, r.message, t);
          break;
        case "startsWith":
          Ci(
            n,
            RegExp(`^${fC(r.value, t)}`),
            r.message,
            t
          );
          break;
        case "endsWith":
          Ci(
            n,
            RegExp(`${fC(r.value, t)}$`),
            r.message,
            t
          );
          break;
        case "datetime":
          ns(n, "date-time", r.message, t);
          break;
        case "date":
          ns(n, "date", r.message, t);
          break;
        case "time":
          ns(n, "time", r.message, t);
          break;
        case "duration":
          ns(n, "duration", r.message, t);
          break;
        case "length":
          n.minLength = typeof n.minLength == "number" ? Math.max(n.minLength, r.value) : r.value, n.maxLength = typeof n.maxLength == "number" ? Math.min(n.maxLength, r.value) : r.value;
          break;
        case "includes": {
          Ci(
            n,
            RegExp(fC(r.value, t)),
            r.message,
            t
          );
          break;
        }
        case "ip": {
          r.version !== "v6" && ns(n, "ipv4", r.message, t), r.version !== "v4" && ns(n, "ipv6", r.message, t);
          break;
        }
        case "base64url":
          Ci(n, ts.base64url, r.message, t);
          break;
        case "jwt":
          Ci(n, ts.jwt, r.message, t);
          break;
        case "cidr": {
          r.version !== "v6" && Ci(n, ts.ipv4Cidr, r.message, t), r.version !== "v4" && Ci(n, ts.ipv6Cidr, r.message, t);
          break;
        }
        case "emoji":
          Ci(n, ts.emoji(), r.message, t);
          break;
        case "ulid": {
          Ci(n, ts.ulid, r.message, t);
          break;
        }
        case "base64": {
          switch (t.base64Strategy) {
            case "format:binary": {
              ns(n, "binary", r.message, t);
              break;
            }
            case "contentEncoding:base64": {
              n.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              Ci(n, ts.base64, r.message, t);
              break;
            }
          }
          break;
        }
        case "nanoid":
          Ci(n, ts.nanoid, r.message, t);
      }
  return n;
}
function fC(e, t) {
  return t.patternStrategy === "escape" ? I0e(e) : e;
}
var j0e = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function I0e(e) {
  let t = "";
  for (let n = 0; n < e.length; n++)
    j0e.has(e[n]) || (t += "\\"), t += e[n];
  return t;
}
function ns(e, t, n, r) {
  var i;
  e.format || (i = e.anyOf) != null && i.some((o) => o.format) ? (e.anyOf || (e.anyOf = []), e.format && (e.anyOf.push({
    format: e.format
  }), delete e.format), e.anyOf.push({
    format: t,
    ...n && r.errorMessages && { errorMessage: { format: n } }
  })) : e.format = t;
}
function Ci(e, t, n, r) {
  var i;
  e.pattern || (i = e.allOf) != null && i.some((o) => o.pattern) ? (e.allOf || (e.allOf = []), e.pattern && (e.allOf.push({
    pattern: e.pattern
  }), delete e.pattern), e.allOf.push({
    pattern: GI(t, r),
    ...n && r.errorMessages && { errorMessage: { pattern: n } }
  })) : e.pattern = GI(t, r);
}
function GI(e, t) {
  var n;
  if (!t.applyRegexFlags || !e.flags)
    return e.source;
  const r = {
    i: e.flags.includes("i"),
    // Case-insensitive
    m: e.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: e.flags.includes("s")
    // `.` matches newlines
  }, i = r.i ? e.source.toLowerCase() : e.source;
  let o = "", s = !1, a = !1, c = !1;
  for (let u = 0; u < i.length; u++) {
    if (s) {
      o += i[u], s = !1;
      continue;
    }
    if (r.i) {
      if (a) {
        if (i[u].match(/[a-z]/)) {
          c ? (o += i[u], o += `${i[u - 2]}-${i[u]}`.toUpperCase(), c = !1) : i[u + 1] === "-" && ((n = i[u + 2]) != null && n.match(/[a-z]/)) ? (o += i[u], c = !0) : o += `${i[u]}${i[u].toUpperCase()}`;
          continue;
        }
      } else if (i[u].match(/[a-z]/)) {
        o += `[${i[u]}${i[u].toUpperCase()}]`;
        continue;
      }
    }
    if (r.m) {
      if (i[u] === "^") {
        o += `(^|(?<=[\r
]))`;
        continue;
      } else if (i[u] === "$") {
        o += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (r.s && i[u] === ".") {
      o += a ? `${i[u]}\r
` : `[${i[u]}\r
]`;
      continue;
    }
    o += i[u], i[u] === "\\" ? s = !0 : a && i[u] === "]" ? a = !1 : !a && i[u] === "[" && (a = !0);
  }
  try {
    new RegExp(o);
  } catch {
    return console.warn(
      `Could not convert regex pattern at ${t.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    ), e.source;
  }
  return o;
}
function SF(e, t) {
  var n, r, i, o, s, a;
  const c = {
    type: "object",
    additionalProperties: (n = gn(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    })) != null ? n : t.allowedAdditionalProperties
  };
  if (((r = e.keyType) == null ? void 0 : r._def.typeName) === Mt.ZodString && ((i = e.keyType._def.checks) != null && i.length)) {
    const { type: u, ...f } = wF(e.keyType._def, t);
    return {
      ...c,
      propertyNames: f
    };
  } else {
    if (((o = e.keyType) == null ? void 0 : o._def.typeName) === Mt.ZodEnum)
      return {
        ...c,
        propertyNames: {
          enum: e.keyType._def.values
        }
      };
    if (((s = e.keyType) == null ? void 0 : s._def.typeName) === Mt.ZodBranded && e.keyType._def.type._def.typeName === Mt.ZodString && ((a = e.keyType._def.type._def.checks) != null && a.length)) {
      const { type: u, ...f } = bF(
        e.keyType._def,
        t
      );
      return {
        ...c,
        propertyNames: f
      };
    }
  }
  return c;
}
function z0e(e, t) {
  if (t.mapStrategy === "record")
    return SF(e, t);
  const n = gn(e.keyType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "0"]
  }) || go(), r = gn(e.valueType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "1"]
  }) || go();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, r],
      minItems: 2,
      maxItems: 2
    }
  };
}
function L0e(e) {
  const t = e.values, r = Object.keys(e.values).filter((o) => typeof t[t[o]] != "number").map((o) => t[o]), i = Array.from(
    new Set(r.map((o) => typeof o))
  );
  return {
    type: i.length === 1 ? i[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: r
  };
}
function B0e() {
  return { not: go() };
}
function $0e() {
  return {
    type: "null"
  };
}
var j_ = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function U0e(e, t) {
  const n = e.options instanceof Map ? Array.from(e.options.values()) : e.options;
  if (n.every(
    (r) => r._def.typeName in j_ && (!r._def.checks || !r._def.checks.length)
  )) {
    const r = n.reduce((i, o) => {
      const s = j_[o._def.typeName];
      return s && !i.includes(s) ? [...i, s] : i;
    }, []);
    return {
      type: r.length > 1 ? r : r[0]
    };
  } else if (n.every((r) => r._def.typeName === "ZodLiteral" && !r.description)) {
    const r = n.reduce(
      (i, o) => {
        const s = typeof o._def.value;
        switch (s) {
          case "string":
          case "number":
          case "boolean":
            return [...i, s];
          case "bigint":
            return [...i, "integer"];
          case "object":
            if (o._def.value === null) return [...i, "null"];
          default:
            return i;
        }
      },
      []
    );
    if (r.length === n.length) {
      const i = r.filter((o, s, a) => a.indexOf(o) === s);
      return {
        type: i.length > 1 ? i : i[0],
        enum: n.reduce(
          (o, s) => o.includes(s._def.value) ? o : [...o, s._def.value],
          []
        )
      };
    }
  } else if (n.every((r) => r._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce(
        (r, i) => [
          ...r,
          ...i._def.values.filter((o) => !r.includes(o))
        ],
        []
      )
    };
  return F0e(e, t);
}
var F0e = (e, t) => {
  const n = (e.options instanceof Map ? Array.from(e.options.values()) : e.options).map(
    (r, i) => gn(r._def, {
      ...t,
      currentPath: [...t.currentPath, "anyOf", `${i}`]
    })
  ).filter(
    (r) => !!r && (!t.strictUnions || typeof r == "object" && Object.keys(r).length > 0)
  );
  return n.length ? { anyOf: n } : void 0;
};
function V0e(e, t) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    e.innerType._def.typeName
  ) && (!e.innerType._def.checks || !e.innerType._def.checks.length))
    return {
      type: [
        j_[e.innerType._def.typeName],
        "null"
      ]
    };
  const n = gn(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "0"]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function H0e(e) {
  const t = {
    type: "number"
  };
  if (!e.checks) return t;
  for (const n of e.checks)
    switch (n.kind) {
      case "int":
        t.type = "integer";
        break;
      case "min":
        n.inclusive ? t.minimum = n.value : t.exclusiveMinimum = n.value;
        break;
      case "max":
        n.inclusive ? t.maximum = n.value : t.exclusiveMaximum = n.value;
        break;
      case "multipleOf":
        t.multipleOf = n.value;
        break;
    }
  return t;
}
function W0e(e, t) {
  const n = {
    type: "object",
    properties: {}
  }, r = [], i = e.shape();
  for (const s in i) {
    let a = i[s];
    if (a === void 0 || a._def === void 0)
      continue;
    const c = G0e(a), u = gn(a._def, {
      ...t,
      currentPath: [...t.currentPath, "properties", s],
      propertyPath: [...t.currentPath, "properties", s]
    });
    u !== void 0 && (n.properties[s] = u, c || r.push(s));
  }
  r.length && (n.required = r);
  const o = q0e(e, t);
  return o !== void 0 && (n.additionalProperties = o), n;
}
function q0e(e, t) {
  if (e.catchall._def.typeName !== "ZodNever")
    return gn(e.catchall._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    });
  switch (e.unknownKeys) {
    case "passthrough":
      return t.allowedAdditionalProperties;
    case "strict":
      return t.rejectedAdditionalProperties;
    case "strip":
      return t.removeAdditionalStrategy === "strict" ? t.allowedAdditionalProperties : t.rejectedAdditionalProperties;
  }
}
function G0e(e) {
  try {
    return e.isOptional();
  } catch {
    return !0;
  }
}
var K0e = (e, t) => {
  var n;
  if (t.currentPath.toString() === ((n = t.propertyPath) == null ? void 0 : n.toString()))
    return gn(e.innerType._def, t);
  const r = gn(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "1"]
  });
  return r ? { anyOf: [{ not: go() }, r] } : go();
}, Z0e = (e, t) => {
  if (t.pipeStrategy === "input")
    return gn(e.in._def, t);
  if (t.pipeStrategy === "output")
    return gn(e.out._def, t);
  const n = gn(e.in._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", "0"]
  }), r = gn(e.out._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", n ? "1" : "0"]
  });
  return {
    allOf: [n, r].filter((i) => i !== void 0)
  };
};
function Y0e(e, t) {
  return gn(e.type._def, t);
}
function X0e(e, t) {
  const r = {
    type: "array",
    uniqueItems: !0,
    items: gn(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "items"]
    })
  };
  return e.minSize && (r.minItems = e.minSize.value), e.maxSize && (r.maxItems = e.maxSize.value), r;
}
function J0e(e, t) {
  return e.rest ? {
    type: "array",
    minItems: e.items.length,
    items: e.items.map(
      (n, r) => gn(n._def, {
        ...t,
        currentPath: [...t.currentPath, "items", `${r}`]
      })
    ).reduce(
      (n, r) => r === void 0 ? n : [...n, r],
      []
    ),
    additionalItems: gn(e.rest._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: e.items.length,
    maxItems: e.items.length,
    items: e.items.map(
      (n, r) => gn(n._def, {
        ...t,
        currentPath: [...t.currentPath, "items", `${r}`]
      })
    ).reduce(
      (n, r) => r === void 0 ? n : [...n, r],
      []
    )
  };
}
function Q0e() {
  return {
    not: go()
  };
}
function ebe() {
  return go();
}
var tbe = (e, t) => gn(e.innerType._def, t), nbe = (e, t, n) => {
  switch (t) {
    case Mt.ZodString:
      return wF(e, n);
    case Mt.ZodNumber:
      return H0e(e);
    case Mt.ZodObject:
      return W0e(e, n);
    case Mt.ZodBigInt:
      return E0e(e);
    case Mt.ZodBoolean:
      return _0e();
    case Mt.ZodDate:
      return xF(e, n);
    case Mt.ZodUndefined:
      return Q0e();
    case Mt.ZodNull:
      return $0e();
    case Mt.ZodArray:
      return C0e(e, n);
    case Mt.ZodUnion:
    case Mt.ZodDiscriminatedUnion:
      return U0e(e, n);
    case Mt.ZodIntersection:
      return D0e(e, n);
    case Mt.ZodTuple:
      return J0e(e, n);
    case Mt.ZodRecord:
      return SF(e, n);
    case Mt.ZodLiteral:
      return P0e(e);
    case Mt.ZodEnum:
      return R0e(e);
    case Mt.ZodNativeEnum:
      return L0e(e);
    case Mt.ZodNullable:
      return V0e(e, n);
    case Mt.ZodOptional:
      return K0e(e, n);
    case Mt.ZodMap:
      return z0e(e, n);
    case Mt.ZodSet:
      return X0e(e, n);
    case Mt.ZodLazy:
      return () => e.getter()._def;
    case Mt.ZodPromise:
      return Y0e(e, n);
    case Mt.ZodNaN:
    case Mt.ZodNever:
      return B0e();
    case Mt.ZodEffects:
      return N0e(e, n);
    case Mt.ZodAny:
      return go();
    case Mt.ZodUnknown:
      return ebe();
    case Mt.ZodDefault:
      return M0e(e, n);
    case Mt.ZodBranded:
      return bF(e, n);
    case Mt.ZodReadonly:
      return tbe(e, n);
    case Mt.ZodCatch:
      return T0e(e, n);
    case Mt.ZodPipeline:
      return Z0e(e, n);
    case Mt.ZodFunction:
    case Mt.ZodVoid:
    case Mt.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((r) => {
      })();
  }
};
function gn(e, t, n = !1) {
  var r;
  const i = t.seen.get(e);
  if (t.override) {
    const c = (r = t.override) == null ? void 0 : r.call(
      t,
      e,
      t,
      i,
      n
    );
    if (c !== S0e)
      return c;
  }
  if (i && !n) {
    const c = rbe(i, t);
    if (c !== void 0)
      return c;
  }
  const o = { def: e, path: t.currentPath, jsonSchema: void 0 };
  t.seen.set(e, o);
  const s = nbe(e, e.typeName, t), a = typeof s == "function" ? gn(s(), t) : s;
  if (a && ibe(e, t, a), t.postProcess) {
    const c = t.postProcess(a, e, t);
    return o.jsonSchema = a, c;
  }
  return o.jsonSchema = a, a;
}
var rbe = (e, t) => {
  switch (t.$refStrategy) {
    case "root":
      return { $ref: e.path.join("/") };
    case "relative":
      return { $ref: w0e(t.currentPath, e.path) };
    case "none":
    case "seen":
      return e.path.length < t.currentPath.length && e.path.every((n, r) => t.currentPath[r] === n) ? (console.warn(
        `Recursive reference detected at ${t.currentPath.join(
          "/"
        )}! Defaulting to any`
      ), go()) : t.$refStrategy === "seen" ? go() : void 0;
  }
}, ibe = (e, t, n) => (e.description && (n.description = e.description), n), obe = (e) => {
  const t = k0e(e), n = t.name !== void 0 ? [...t.basePath, t.definitionPath, t.name] : t.basePath;
  return {
    ...t,
    currentPath: n,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(t.definitions).map(([r, i]) => [
        i._def,
        {
          def: i._def,
          path: [...t.basePath, t.definitionPath, r],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
}, sbe = (e, t) => {
  var n;
  const r = obe(t);
  let i = typeof t == "object" && t.definitions ? Object.entries(t.definitions).reduce(
    (u, [f, h]) => {
      var m;
      return {
        ...u,
        [f]: (m = gn(
          h._def,
          {
            ...r,
            currentPath: [...r.basePath, r.definitionPath, f]
          },
          !0
        )) != null ? m : go()
      };
    },
    {}
  ) : void 0;
  const o = typeof t == "string" ? t : t?.nameStrategy === "title" ? void 0 : t?.name, s = (n = gn(
    e._def,
    o === void 0 ? r : {
      ...r,
      currentPath: [...r.basePath, r.definitionPath, o]
    },
    !1
  )) != null ? n : go(), a = typeof t == "object" && t.name !== void 0 && t.nameStrategy === "title" ? t.name : void 0;
  a !== void 0 && (s.title = a);
  const c = o === void 0 ? i ? {
    ...s,
    [r.definitionPath]: i
  } : s : {
    $ref: [
      ...r.$refStrategy === "relative" ? [] : r.basePath,
      r.definitionPath,
      o
    ].join("/"),
    [r.definitionPath]: {
      ...i,
      [o]: s
    }
  };
  return c.$schema = "http://json-schema.org/draft-07/schema#", c;
}, abe = sbe;
function lbe(e, t) {
  var n;
  const r = (n = void 0) != null ? n : !1;
  return jM(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => abe(e, {
      $refStrategy: r ? "root" : "none"
    }),
    {
      validate: async (i) => {
        const o = await e.safeParseAsync(i);
        return o.success ? { success: !0, value: o.data } : { success: !1, error: o.error };
      }
    }
  );
}
function cbe(e, t) {
  var n;
  const r = (n = void 0) != null ? n : !1;
  return jM(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => D0(
      qye(e, {
        target: "draft-7",
        io: "input",
        reused: r ? "ref" : "inline"
      })
    ),
    {
      validate: async (i) => {
        const o = await cF(e, i);
        return o.success ? { success: !0, value: o.data } : { success: !1, error: o.error };
      }
    }
  );
}
function ube(e) {
  return "_zod" in e;
}
function kF(e, t) {
  return ube(e) ? cbe(e) : lbe(e);
}
var I_ = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function jM(e, {
  validate: t
} = {}) {
  return {
    [I_]: !0,
    _type: void 0,
    // should never be used directly
    [Pb]: !0,
    get jsonSchema() {
      return typeof e == "function" && (e = e()), e;
    },
    validate: t
  };
}
function dbe(e) {
  return typeof e == "object" && e !== null && I_ in e && e[I_] === !0 && "jsonSchema" in e && "validate" in e;
}
function fbe(e) {
  return e == null ? jM({
    properties: {},
    additionalProperties: !1
  }) : dbe(e) ? e : typeof e == "function" ? e() : kF(e);
}
var hbe = Object.defineProperty, pbe = (e, t) => {
  for (var n in t)
    hbe(e, n, { get: t[n], enumerable: !0 });
}, CF = "AI_NoObjectGeneratedError", EF = `vercel.ai.error.${CF}`, mbe = Symbol.for(EF), _F, KI = class extends Js {
  constructor({
    message: e = "No object generated.",
    cause: t,
    text: n,
    response: r,
    usage: i,
    finishReason: o
  }) {
    super({ name: CF, message: e, cause: t }), this[_F] = !0, this.text = n, this.response = r, this.usage = i, this.finishReason = o;
  }
  static isInstance(e) {
    return Js.hasMarker(e, EF);
  }
};
_F = mbe;
var TF = "AI_MessageConversionError", AF = `vercel.ai.error.${TF}`, gbe = Symbol.for(AF), MF, ybe = class extends Js {
  constructor({
    originalMessage: e,
    message: t
  }) {
    super({ name: TF, message: t }), this[MF] = !0, this.originalMessage = e;
  }
  static isInstance(e) {
    return Js.hasMarker(e, AF);
  }
};
MF = gbe;
var ZI = "5.0.126", NF = Wo([
  gt(),
  Ob(Uint8Array),
  Ob(ArrayBuffer),
  vF(
    // Buffer might not be available in some environments such as CloudFlare:
    (e) => {
      var t, n;
      return (n = (t = globalThis.Buffer) == null ? void 0 : t.isBuffer(e)) != null ? n : !1;
    },
    { message: "Must be a Buffer" }
  )
]), ag = a0e(
  () => Wo([
    jve(),
    gt(),
    Rve(),
    Wi(),
    D_(gt(), ag),
    $h(ag)
  ])
), fr = D_(
  gt(),
  D_(gt(), ag)
), RF = ei({
  type: Ut("text"),
  text: gt(),
  providerOptions: fr.optional()
}), vbe = ei({
  type: Ut("image"),
  image: Wo([NF, Ob(URL)]),
  mediaType: gt().optional(),
  providerOptions: fr.optional()
}), OF = ei({
  type: Ut("file"),
  data: Wo([NF, Ob(URL)]),
  filename: gt().optional(),
  mediaType: gt(),
  providerOptions: fr.optional()
}), bbe = ei({
  type: Ut("reasoning"),
  text: gt(),
  providerOptions: fr.optional()
}), xbe = ei({
  type: Ut("tool-call"),
  toolCallId: gt(),
  toolName: gt(),
  input: Us(),
  providerOptions: fr.optional(),
  providerExecuted: Wi().optional()
}), wbe = $ve("type", [
  ei({
    type: Ut("text"),
    value: gt()
  }),
  ei({
    type: Ut("json"),
    value: ag
  }),
  ei({
    type: Ut("error-text"),
    value: gt()
  }),
  ei({
    type: Ut("error-json"),
    value: ag
  }),
  ei({
    type: Ut("content"),
    value: $h(
      Wo([
        ei({
          type: Ut("text"),
          text: gt()
        }),
        ei({
          type: Ut("media"),
          data: gt(),
          mediaType: gt()
        })
      ])
    )
  })
]), DF = ei({
  type: Ut("tool-result"),
  toolCallId: gt(),
  toolName: gt(),
  output: wbe,
  providerOptions: fr.optional()
}), Sbe = ei(
  {
    role: Ut("system"),
    content: gt(),
    providerOptions: fr.optional()
  }
), kbe = ei({
  role: Ut("user"),
  content: Wo([
    gt(),
    $h(Wo([RF, vbe, OF]))
  ]),
  providerOptions: fr.optional()
}), Cbe = ei({
  role: Ut("assistant"),
  content: Wo([
    gt(),
    $h(
      Wo([
        RF,
        OF,
        bbe,
        xbe,
        DF
      ])
    )
  ]),
  providerOptions: fr.optional()
}), Ebe = ei({
  role: Ut("tool"),
  content: $h(DF),
  providerOptions: fr.optional()
});
Wo([
  Sbe,
  kbe,
  Cbe,
  Ebe
]);
function YI({
  output: e,
  tool: t,
  errorMode: n
}) {
  return n === "text" ? { type: "error-text", value: EM(e) } : n === "json" ? { type: "error-json", value: XI(e) } : t?.toModelOutput ? t.toModelOutput(e) : typeof e == "string" ? { type: "text", value: e } : { type: "json", value: XI(e) };
}
function XI(e) {
  return e === void 0 ? null : e;
}
ey({
  prefix: "aitxt",
  size: 24
});
(class extends TransformStream {
  constructor() {
    super({
      transform(e, t) {
        t.enqueue(`data: ${JSON.stringify(e)}

`);
      },
      flush(e) {
        e.enqueue(`data: [DONE]

`);
      }
    });
  }
});
var _be = y0e(
  () => kF(
    Wo([
      Yn({
        type: Ut("text-start"),
        id: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("text-delta"),
        id: gt(),
        delta: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("text-end"),
        id: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("error"),
        errorText: gt()
      }),
      Yn({
        type: Ut("tool-input-start"),
        toolCallId: gt(),
        toolName: gt(),
        providerExecuted: Wi().optional(),
        dynamic: Wi().optional()
      }),
      Yn({
        type: Ut("tool-input-delta"),
        toolCallId: gt(),
        inputTextDelta: gt()
      }),
      Yn({
        type: Ut("tool-input-available"),
        toolCallId: gt(),
        toolName: gt(),
        input: Us(),
        providerExecuted: Wi().optional(),
        providerMetadata: fr.optional(),
        dynamic: Wi().optional()
      }),
      Yn({
        type: Ut("tool-input-error"),
        toolCallId: gt(),
        toolName: gt(),
        input: Us(),
        providerExecuted: Wi().optional(),
        providerMetadata: fr.optional(),
        dynamic: Wi().optional(),
        errorText: gt()
      }),
      Yn({
        type: Ut("tool-output-available"),
        toolCallId: gt(),
        output: Us(),
        providerExecuted: Wi().optional(),
        dynamic: Wi().optional(),
        preliminary: Wi().optional()
      }),
      Yn({
        type: Ut("tool-output-error"),
        toolCallId: gt(),
        errorText: gt(),
        providerExecuted: Wi().optional(),
        dynamic: Wi().optional()
      }),
      Yn({
        type: Ut("reasoning-start"),
        id: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("reasoning-delta"),
        id: gt(),
        delta: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("reasoning-end"),
        id: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("source-url"),
        sourceId: gt(),
        url: gt(),
        title: gt().optional(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("source-document"),
        sourceId: gt(),
        mediaType: gt(),
        title: gt(),
        filename: gt().optional(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: Ut("file"),
        url: gt(),
        mediaType: gt(),
        providerMetadata: fr.optional()
      }),
      Yn({
        type: vF(
          (e) => typeof e == "string" && e.startsWith("data-"),
          { message: 'Type must start with "data-"' }
        ),
        id: gt().optional(),
        data: Us(),
        transient: Wi().optional()
      }),
      Yn({
        type: Ut("start-step")
      }),
      Yn({
        type: Ut("finish-step")
      }),
      Yn({
        type: Ut("start"),
        messageId: gt().optional(),
        messageMetadata: Us().optional()
      }),
      Yn({
        type: Ut("finish"),
        finishReason: mF([
          "stop",
          "length",
          "content-filter",
          "tool-calls",
          "error",
          "other",
          "unknown"
        ]).optional(),
        messageMetadata: Us().optional()
      }),
      Yn({
        type: Ut("abort")
      }),
      Yn({
        type: Ut("message-metadata"),
        messageMetadata: Us()
      })
    ])
  )
);
function Tbe(e) {
  return e.type.startsWith("data-");
}
function PF(e, t) {
  if (e === void 0 && t === void 0)
    return;
  if (e === void 0)
    return t;
  if (t === void 0)
    return e;
  const n = { ...e };
  for (const r in t)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      const i = t[r];
      if (i === void 0)
        continue;
      const o = r in e ? e[r] : void 0, s = i !== null && typeof i == "object" && !Array.isArray(i) && !(i instanceof Date) && !(i instanceof RegExp), a = o != null && typeof o == "object" && !Array.isArray(o) && !(o instanceof Date) && !(o instanceof RegExp);
      s && a ? n[r] = PF(
        o,
        i
      ) : n[r] = i;
    }
  return n;
}
function Abe(e) {
  const t = ["ROOT"];
  let n = -1, r = null;
  function i(c, u, f) {
    switch (c) {
      case '"': {
        n = u, t.pop(), t.push(f), t.push("INSIDE_STRING");
        break;
      }
      case "f":
      case "t":
      case "n": {
        n = u, r = u, t.pop(), t.push(f), t.push("INSIDE_LITERAL");
        break;
      }
      case "-": {
        t.pop(), t.push(f), t.push("INSIDE_NUMBER");
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9": {
        n = u, t.pop(), t.push(f), t.push("INSIDE_NUMBER");
        break;
      }
      case "{": {
        n = u, t.pop(), t.push(f), t.push("INSIDE_OBJECT_START");
        break;
      }
      case "[": {
        n = u, t.pop(), t.push(f), t.push("INSIDE_ARRAY_START");
        break;
      }
    }
  }
  function o(c, u) {
    switch (c) {
      case ",": {
        t.pop(), t.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        n = u, t.pop();
        break;
      }
    }
  }
  function s(c, u) {
    switch (c) {
      case ",": {
        t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        n = u, t.pop();
        break;
      }
    }
  }
  for (let c = 0; c < e.length; c++) {
    const u = e[c];
    switch (t[t.length - 1]) {
      case "ROOT":
        i(u, c, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (u) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            n = c, t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        u === '"' && (t.pop(), t.push("INSIDE_OBJECT_KEY"));
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        u === '"' && (t.pop(), t.push("INSIDE_OBJECT_AFTER_KEY"));
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        u === ":" && (t.pop(), t.push("INSIDE_OBJECT_BEFORE_VALUE"));
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        i(u, c, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        o(u, c);
        break;
      }
      case "INSIDE_STRING": {
        switch (u) {
          case '"': {
            t.pop(), n = c;
            break;
          }
          case "\\": {
            t.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default:
            n = c;
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        u === "]" ? (n = c, t.pop()) : (n = c, i(u, c, "INSIDE_ARRAY_AFTER_VALUE"));
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (u) {
          case ",": {
            t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            n = c, t.pop();
            break;
          }
          default: {
            n = c;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        i(u, c, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        t.pop(), n = c;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (u) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            n = c;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".":
            break;
          case ",": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && s(u, c), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && o(u, c);
            break;
          }
          case "}": {
            t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && o(u, c);
            break;
          }
          case "]": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && s(u, c);
            break;
          }
          default: {
            t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const h = e.substring(r, c + 1);
        !"false".startsWith(h) && !"true".startsWith(h) && !"null".startsWith(h) ? (t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" ? o(u, c) : t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && s(u, c)) : n = c;
        break;
      }
    }
  }
  let a = e.slice(0, n + 1);
  for (let c = t.length - 1; c >= 0; c--)
    switch (t[c]) {
      case "INSIDE_STRING": {
        a += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        a += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        a += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const f = e.substring(r, e.length);
        "true".startsWith(f) ? a += "true".slice(f.length) : "false".startsWith(f) ? a += "false".slice(f.length) : "null".startsWith(f) && (a += "null".slice(f.length));
      }
    }
  return a;
}
async function jF(e) {
  if (e === void 0)
    return { value: void 0, state: "undefined-input" };
  let t = await jb({ text: e });
  return t.success ? { value: t.value, state: "successful-parse" } : (t = await jb({ text: Abe(e) }), t.success ? { value: t.value, state: "repaired-parse" } : { value: void 0, state: "failed-parse" });
}
function hC(e) {
  return e.type.startsWith("data-");
}
function pC(e) {
  return e.type === "text";
}
function mC(e) {
  return e.type === "file";
}
function JI(e) {
  return e.type === "reasoning";
}
function Uu(e) {
  return e.type.startsWith("tool-");
}
function IM(e) {
  return e.type === "dynamic-tool";
}
function lg(e) {
  return Uu(e) || IM(e);
}
function cg(e) {
  return e.type.split("-").slice(1).join("-");
}
function Mbe(e) {
  return IM(e) ? e.toolName : cg(e);
}
function Nbe({
  lastMessage: e,
  messageId: t
}) {
  return {
    message: e?.role === "assistant" ? e : {
      id: t,
      metadata: void 0,
      role: "assistant",
      parts: []
    },
    activeTextParts: {},
    activeReasoningParts: {},
    partialToolCalls: {}
  };
}
function Rbe({
  stream: e,
  messageMetadataSchema: t,
  dataPartSchemas: n,
  runUpdateMessageJob: r,
  onError: i,
  onToolCall: o,
  onData: s
}) {
  return e.pipeThrough(
    new TransformStream({
      async transform(a, c) {
        await r(async ({ state: u, write: f }) => {
          var h, m, g, b;
          function x(N) {
            const I = u.message.parts.filter(Uu).find(
              (O) => O.toolCallId === N
            );
            if (I == null)
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available"
              );
            return I;
          }
          function w(N) {
            const I = u.message.parts.filter(
              (O) => O.type === "dynamic-tool"
            ).find(
              (O) => O.toolCallId === N
            );
            if (I == null)
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available"
              );
            return I;
          }
          function S(N) {
            var P;
            const I = u.message.parts.find(
              (U) => Uu(U) && U.toolCallId === N.toolCallId
            ), O = N, L = I;
            I != null ? (I.state = N.state, L.input = O.input, L.output = O.output, L.errorText = O.errorText, L.rawInput = O.rawInput, L.preliminary = O.preliminary, L.providerExecuted = (P = O.providerExecuted) != null ? P : I.providerExecuted, O.providerMetadata != null && I.state === "input-available" && (I.callProviderMetadata = O.providerMetadata)) : u.message.parts.push({
              type: `tool-${N.toolName}`,
              toolCallId: N.toolCallId,
              state: N.state,
              input: O.input,
              output: O.output,
              rawInput: O.rawInput,
              errorText: O.errorText,
              providerExecuted: O.providerExecuted,
              preliminary: O.preliminary,
              ...O.providerMetadata != null ? { callProviderMetadata: O.providerMetadata } : {}
            });
          }
          function _(N) {
            var P, I;
            const O = u.message.parts.find(
              (B) => B.type === "dynamic-tool" && B.toolCallId === N.toolCallId
            ), L = N, U = O;
            O != null ? (O.state = N.state, U.toolName = N.toolName, U.input = L.input, U.output = L.output, U.errorText = L.errorText, U.rawInput = (P = L.rawInput) != null ? P : U.rawInput, U.preliminary = L.preliminary, U.providerExecuted = (I = L.providerExecuted) != null ? I : O.providerExecuted, L.providerMetadata != null && O.state === "input-available" && (O.callProviderMetadata = L.providerMetadata)) : u.message.parts.push({
              type: "dynamic-tool",
              toolName: N.toolName,
              toolCallId: N.toolCallId,
              state: N.state,
              input: L.input,
              output: L.output,
              errorText: L.errorText,
              preliminary: L.preliminary,
              providerExecuted: L.providerExecuted,
              ...L.providerMetadata != null ? { callProviderMetadata: L.providerMetadata } : {}
            });
          }
          async function M(N) {
            if (N != null) {
              const P = u.message.metadata != null ? PF(u.message.metadata, N) : N;
              t != null && await WI({
                value: P,
                schema: t
              }), u.message.metadata = P;
            }
          }
          switch (a.type) {
            case "text-start": {
              const N = {
                type: "text",
                text: "",
                providerMetadata: a.providerMetadata,
                state: "streaming"
              };
              u.activeTextParts[a.id] = N, u.message.parts.push(N), f();
              break;
            }
            case "text-delta": {
              const N = u.activeTextParts[a.id];
              N.text += a.delta, N.providerMetadata = (h = a.providerMetadata) != null ? h : N.providerMetadata, f();
              break;
            }
            case "text-end": {
              const N = u.activeTextParts[a.id];
              N.state = "done", N.providerMetadata = (m = a.providerMetadata) != null ? m : N.providerMetadata, delete u.activeTextParts[a.id], f();
              break;
            }
            case "reasoning-start": {
              const N = {
                type: "reasoning",
                text: "",
                providerMetadata: a.providerMetadata,
                state: "streaming"
              };
              u.activeReasoningParts[a.id] = N, u.message.parts.push(N), f();
              break;
            }
            case "reasoning-delta": {
              const N = u.activeReasoningParts[a.id];
              N.text += a.delta, N.providerMetadata = (g = a.providerMetadata) != null ? g : N.providerMetadata, f();
              break;
            }
            case "reasoning-end": {
              const N = u.activeReasoningParts[a.id];
              N.providerMetadata = (b = a.providerMetadata) != null ? b : N.providerMetadata, N.state = "done", delete u.activeReasoningParts[a.id], f();
              break;
            }
            case "file": {
              u.message.parts.push({
                type: "file",
                mediaType: a.mediaType,
                url: a.url
              }), f();
              break;
            }
            case "source-url": {
              u.message.parts.push({
                type: "source-url",
                sourceId: a.sourceId,
                url: a.url,
                title: a.title,
                providerMetadata: a.providerMetadata
              }), f();
              break;
            }
            case "source-document": {
              u.message.parts.push({
                type: "source-document",
                sourceId: a.sourceId,
                mediaType: a.mediaType,
                title: a.title,
                filename: a.filename,
                providerMetadata: a.providerMetadata
              }), f();
              break;
            }
            case "tool-input-start": {
              const N = u.message.parts.filter(Uu);
              u.partialToolCalls[a.toolCallId] = {
                text: "",
                toolName: a.toolName,
                index: N.length,
                dynamic: a.dynamic
              }, a.dynamic ? _({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: a.providerExecuted
              }) : S({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: a.providerExecuted
              }), f();
              break;
            }
            case "tool-input-delta": {
              const N = u.partialToolCalls[a.toolCallId];
              N.text += a.inputTextDelta;
              const { value: P } = await jF(
                N.text
              );
              N.dynamic ? _({
                toolCallId: a.toolCallId,
                toolName: N.toolName,
                state: "input-streaming",
                input: P
              }) : S({
                toolCallId: a.toolCallId,
                toolName: N.toolName,
                state: "input-streaming",
                input: P
              }), f();
              break;
            }
            case "tool-input-available": {
              a.dynamic ? _({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "input-available",
                input: a.input,
                providerExecuted: a.providerExecuted,
                providerMetadata: a.providerMetadata
              }) : S({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "input-available",
                input: a.input,
                providerExecuted: a.providerExecuted,
                providerMetadata: a.providerMetadata
              }), f(), o && !a.providerExecuted && await o({
                toolCall: a
              });
              break;
            }
            case "tool-input-error": {
              a.dynamic ? _({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "output-error",
                input: a.input,
                errorText: a.errorText,
                providerExecuted: a.providerExecuted,
                providerMetadata: a.providerMetadata
              }) : S({
                toolCallId: a.toolCallId,
                toolName: a.toolName,
                state: "output-error",
                input: void 0,
                rawInput: a.input,
                errorText: a.errorText,
                providerExecuted: a.providerExecuted,
                providerMetadata: a.providerMetadata
              }), f();
              break;
            }
            case "tool-output-available": {
              if (a.dynamic) {
                const N = w(
                  a.toolCallId
                );
                _({
                  toolCallId: a.toolCallId,
                  toolName: N.toolName,
                  state: "output-available",
                  input: N.input,
                  output: a.output,
                  preliminary: a.preliminary
                });
              } else {
                const N = x(a.toolCallId);
                S({
                  toolCallId: a.toolCallId,
                  toolName: cg(N),
                  state: "output-available",
                  input: N.input,
                  output: a.output,
                  providerExecuted: a.providerExecuted,
                  preliminary: a.preliminary
                });
              }
              f();
              break;
            }
            case "tool-output-error": {
              if (a.dynamic) {
                const N = w(
                  a.toolCallId
                );
                _({
                  toolCallId: a.toolCallId,
                  toolName: N.toolName,
                  state: "output-error",
                  input: N.input,
                  errorText: a.errorText,
                  providerExecuted: a.providerExecuted
                });
              } else {
                const N = x(a.toolCallId);
                S({
                  toolCallId: a.toolCallId,
                  toolName: cg(N),
                  state: "output-error",
                  input: N.input,
                  rawInput: N.rawInput,
                  errorText: a.errorText,
                  providerExecuted: a.providerExecuted
                });
              }
              f();
              break;
            }
            case "start-step": {
              u.message.parts.push({ type: "step-start" });
              break;
            }
            case "finish-step": {
              u.activeTextParts = {}, u.activeReasoningParts = {};
              break;
            }
            case "start": {
              a.messageId != null && (u.message.id = a.messageId), await M(a.messageMetadata), (a.messageId != null || a.messageMetadata != null) && f();
              break;
            }
            case "finish": {
              a.finishReason != null && (u.finishReason = a.finishReason), await M(a.messageMetadata), a.messageMetadata != null && f();
              break;
            }
            case "message-metadata": {
              await M(a.messageMetadata), a.messageMetadata != null && f();
              break;
            }
            case "error": {
              i?.(new Error(a.errorText));
              break;
            }
            default:
              if (Tbe(a)) {
                n?.[a.type] != null && await WI({
                  value: a.data,
                  schema: n[a.type]
                });
                const N = a;
                if (N.transient) {
                  s?.(N);
                  break;
                }
                const P = N.id != null ? u.message.parts.find(
                  (I) => N.type === I.type && N.id === I.id
                ) : void 0;
                P != null ? P.data = N.data : u.message.parts.push(N), s?.(N), f();
              }
          }
          c.enqueue(a);
        });
      }
    })
  );
}
async function Obe({
  stream: e,
  onError: t
}) {
  const n = e.getReader();
  try {
    for (; ; ) {
      const { done: r } = await n.read();
      if (r)
        break;
    }
  } catch (r) {
    t?.(r);
  } finally {
    n.releaseLock();
  }
}
ey({
  prefix: "aitxt",
  size: 24
});
function Dbe(e, t) {
  const n = [];
  t?.ignoreIncompleteToolCalls && (e = e.map((r) => ({
    ...r,
    parts: r.parts.filter(
      (i) => !lg(i) || i.state !== "input-streaming" && i.state !== "input-available"
    )
  })));
  for (const r of e)
    switch (r.role) {
      case "system": {
        const i = r.parts.filter(
          (s) => s.type === "text"
        ), o = i.reduce((s, a) => a.providerMetadata != null ? { ...s, ...a.providerMetadata } : s, {});
        n.push({
          role: "system",
          content: i.map((s) => s.text).join(""),
          ...Object.keys(o).length > 0 ? { providerOptions: o } : {}
        });
        break;
      }
      case "user": {
        n.push({
          role: "user",
          content: r.parts.map((i) => {
            var o;
            if (pC(i))
              return {
                type: "text",
                text: i.text,
                ...i.providerMetadata != null ? { providerOptions: i.providerMetadata } : {}
              };
            if (mC(i))
              return {
                type: "file",
                mediaType: i.mediaType,
                filename: i.filename,
                data: i.url,
                ...i.providerMetadata != null ? { providerOptions: i.providerMetadata } : {}
              };
            if (hC(i))
              return (o = t?.convertDataPart) == null ? void 0 : o.call(
                t,
                i
              );
          }).filter((i) => i != null)
        });
        break;
      }
      case "assistant": {
        if (r.parts != null) {
          let i = function() {
            var s, a, c;
            if (o.length === 0)
              return;
            const u = [];
            for (const h of o)
              if (pC(h))
                u.push({
                  type: "text",
                  text: h.text,
                  ...h.providerMetadata != null ? { providerOptions: h.providerMetadata } : {}
                });
              else if (mC(h))
                u.push({
                  type: "file",
                  mediaType: h.mediaType,
                  filename: h.filename,
                  data: h.url
                });
              else if (JI(h))
                u.push({
                  type: "reasoning",
                  text: h.text,
                  providerOptions: h.providerMetadata
                });
              else if (IM(h)) {
                const m = h.toolName;
                h.state !== "input-streaming" && u.push({
                  type: "tool-call",
                  toolCallId: h.toolCallId,
                  toolName: m,
                  input: h.input,
                  ...h.callProviderMetadata != null ? { providerOptions: h.callProviderMetadata } : {}
                });
              } else if (Uu(h)) {
                const m = cg(h);
                h.state !== "input-streaming" && (u.push({
                  type: "tool-call",
                  toolCallId: h.toolCallId,
                  toolName: m,
                  input: h.state === "output-error" ? (s = h.input) != null ? s : h.rawInput : h.input,
                  providerExecuted: h.providerExecuted,
                  ...h.callProviderMetadata != null ? { providerOptions: h.callProviderMetadata } : {}
                }), h.providerExecuted === !0 && (h.state === "output-available" || h.state === "output-error") && u.push({
                  type: "tool-result",
                  toolCallId: h.toolCallId,
                  toolName: m,
                  output: YI({
                    output: h.state === "output-error" ? h.errorText : h.output,
                    tool: (a = t?.tools) == null ? void 0 : a[m],
                    errorMode: h.state === "output-error" ? "json" : "none"
                  }),
                  ...h.callProviderMetadata != null ? { providerOptions: h.callProviderMetadata } : {}
                }));
              } else if (hC(h)) {
                const m = (c = t?.convertDataPart) == null ? void 0 : c.call(
                  t,
                  h
                );
                m != null && u.push(m);
              } else {
                const m = h;
                throw new Error(`Unsupported part: ${m}`);
              }
            n.push({
              role: "assistant",
              content: u
            });
            const f = o.filter(
              (h) => Uu(h) && h.providerExecuted !== !0 || h.type === "dynamic-tool"
            );
            f.length > 0 && n.push({
              role: "tool",
              content: f.map((h) => {
                var m;
                switch (h.state) {
                  case "output-error":
                  case "output-available": {
                    const g = Mbe(h);
                    return {
                      type: "tool-result",
                      toolCallId: h.toolCallId,
                      toolName: g,
                      output: YI({
                        output: h.state === "output-error" ? h.errorText : h.output,
                        tool: (m = t?.tools) == null ? void 0 : m[g],
                        errorMode: h.state === "output-error" ? "text" : "none"
                      }),
                      ...h.callProviderMetadata != null ? { providerOptions: h.callProviderMetadata } : {}
                    };
                  }
                  default:
                    return null;
                }
              }).filter(
                (h) => h != null
              )
            }), o = [];
          }, o = [];
          for (const s of r.parts)
            pC(s) || JI(s) || mC(s) || lg(s) || hC(s) ? o.push(s) : s.type === "step-start" && i();
          i();
          break;
        }
        break;
      }
      default: {
        const i = r.role;
        throw new ybe({
          originalMessage: r,
          message: `Unsupported role: ${i}`
        });
      }
    }
  return n;
}
ey({ prefix: "aiobj", size: 24 });
var Pbe = class {
  constructor() {
    this.queue = [], this.isProcessing = !1;
  }
  async processQueue() {
    if (!this.isProcessing) {
      for (this.isProcessing = !0; this.queue.length > 0; )
        await this.queue[0](), this.queue.shift();
      this.isProcessing = !1;
    }
  }
  async run(e) {
    return new Promise((t, n) => {
      this.queue.push(async () => {
        try {
          await e(), t();
        } catch (r) {
          n(r);
        }
      }), this.processQueue();
    });
  }
};
ey({ prefix: "aiobj", size: 24 });
var jbe = {};
pbe(jbe, {
  object: () => zbe,
  text: () => Ibe
});
var Ibe = () => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: e }) {
    return { partial: e };
  },
  async parseOutput({ text: e }) {
    return e;
  }
}), zbe = ({
  schema: e
}) => {
  const t = fbe(e);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: t.jsonSchema
    },
    async parsePartial({ text: n }) {
      const r = await jF(n);
      switch (r.state) {
        case "failed-parse":
        case "undefined-input":
          return;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: r.value
          };
        default: {
          const i = r.state;
          throw new Error(`Unsupported parse state: ${i}`);
        }
      }
    },
    async parseOutput({ text: n }, r) {
      const i = await jb({ text: n });
      if (!i.success)
        throw new KI({
          message: "No object generated: could not parse the response.",
          cause: i.error,
          text: n,
          response: r.response,
          usage: r.usage,
          finishReason: r.finishReason
        });
      const o = await PM({
        value: i.value,
        schema: t
      });
      if (!o.success)
        throw new KI({
          message: "No object generated: response did not match schema.",
          cause: o.error,
          text: n,
          response: r.response,
          usage: r.usage,
          finishReason: r.finishReason
        });
      return o.value;
    }
  };
};
async function Lbe(e) {
  if (e == null)
    return [];
  if (!globalThis.FileList || !(e instanceof globalThis.FileList))
    throw new Error("FileList is not supported in the current environment");
  return Promise.all(
    Array.from(e).map(async (t) => {
      const { name: n, type: r } = t, i = await new Promise((o, s) => {
        const a = new FileReader();
        a.onload = (c) => {
          var u;
          o((u = c.target) == null ? void 0 : u.result);
        }, a.onerror = (c) => s(c), a.readAsDataURL(t);
      });
      return {
        type: "file",
        mediaType: r,
        filename: n,
        url: i
      };
    })
  );
}
var Bbe = class {
  constructor({
    api: e = "/api/chat",
    credentials: t,
    headers: n,
    body: r,
    fetch: i,
    prepareSendMessagesRequest: o,
    prepareReconnectToStreamRequest: s
  }) {
    this.api = e, this.credentials = t, this.headers = n, this.body = r, this.fetch = i, this.prepareSendMessagesRequest = o, this.prepareReconnectToStreamRequest = s;
  }
  async sendMessages({
    abortSignal: e,
    ...t
  }) {
    var n, r, i, o, s;
    const a = await pf(this.body), c = await pf(this.headers), u = await pf(this.credentials), f = {
      ...Au(c),
      ...Au(t.headers)
    }, h = await ((n = this.prepareSendMessagesRequest) == null ? void 0 : n.call(this, {
      api: this.api,
      id: t.chatId,
      messages: t.messages,
      body: { ...a, ...t.body },
      headers: f,
      credentials: u,
      requestMetadata: t.metadata,
      trigger: t.trigger,
      messageId: t.messageId
    })), m = (r = h?.api) != null ? r : this.api, g = h?.headers !== void 0 ? Au(h.headers) : f, b = h?.body !== void 0 ? h.body : {
      ...a,
      ...t.body,
      id: t.chatId,
      messages: t.messages,
      trigger: t.trigger,
      messageId: t.messageId
    }, x = (i = h?.credentials) != null ? i : u, S = await ((o = this.fetch) != null ? o : globalThis.fetch)(m, {
      method: "POST",
      headers: VI(
        {
          "Content-Type": "application/json",
          ...g
        },
        `ai-sdk/${ZI}`,
        FI()
      ),
      body: JSON.stringify(b),
      credentials: x,
      signal: e
    });
    if (!S.ok)
      throw new Error(
        (s = await S.text()) != null ? s : "Failed to fetch the chat response."
      );
    if (!S.body)
      throw new Error("The response body is empty.");
    return this.processResponseStream(S.body);
  }
  async reconnectToStream(e) {
    var t, n, r, i, o;
    const s = await pf(this.body), a = await pf(this.headers), c = await pf(this.credentials), u = {
      ...Au(a),
      ...Au(e.headers)
    }, f = await ((t = this.prepareReconnectToStreamRequest) == null ? void 0 : t.call(this, {
      api: this.api,
      id: e.chatId,
      body: { ...s, ...e.body },
      headers: u,
      credentials: c,
      requestMetadata: e.metadata
    })), h = (n = f?.api) != null ? n : `${this.api}/${e.chatId}/stream`, m = f?.headers !== void 0 ? Au(f.headers) : u, g = (r = f?.credentials) != null ? r : c, x = await ((i = this.fetch) != null ? i : globalThis.fetch)(h, {
      method: "GET",
      headers: VI(
        m,
        `ai-sdk/${ZI}`,
        FI()
      ),
      credentials: g
    });
    if (x.status === 204)
      return null;
    if (!x.ok)
      throw new Error(
        (o = await x.text()) != null ? o : "Failed to fetch the chat response."
      );
    if (!x.body)
      throw new Error("The response body is empty.");
    return this.processResponseStream(x.body);
  }
}, IF = class extends Bbe {
  constructor(e = {}) {
    super(e);
  }
  processResponseStream(e) {
    return x0e({
      stream: e,
      schema: _be
    }).pipeThrough(
      new TransformStream({
        async transform(t, n) {
          if (!t.success)
            throw t.error;
          n.enqueue(t.value);
        }
      })
    );
  }
}, $be = class {
  constructor({
    generateId: e = u0e,
    id: t = e(),
    transport: n = new IF(),
    messageMetadataSchema: r,
    dataPartSchemas: i,
    state: o,
    onError: s,
    onToolCall: a,
    onFinish: c,
    onData: u,
    sendAutomaticallyWhen: f
  }) {
    this.activeResponse = void 0, this.jobExecutor = new Pbe(), this.sendMessage = async (h, m) => {
      var g, b, x, w;
      if (h == null) {
        await this.makeRequest({
          trigger: "submit-message",
          messageId: (g = this.lastMessage) == null ? void 0 : g.id,
          ...m
        });
        return;
      }
      let S;
      if ("text" in h || "files" in h ? S = {
        parts: [
          ...Array.isArray(h.files) ? h.files : await Lbe(h.files),
          ..."text" in h && h.text != null ? [{ type: "text", text: h.text }] : []
        ]
      } : S = h, h.messageId != null) {
        const _ = this.state.messages.findIndex(
          (M) => M.id === h.messageId
        );
        if (_ === -1)
          throw new Error(`message with id ${h.messageId} not found`);
        if (this.state.messages[_].role !== "user")
          throw new Error(
            `message with id ${h.messageId} is not a user message`
          );
        this.state.messages = this.state.messages.slice(0, _ + 1), this.state.replaceMessage(_, {
          ...S,
          id: h.messageId,
          role: (b = S.role) != null ? b : "user",
          metadata: h.metadata
        });
      } else
        this.state.pushMessage({
          ...S,
          id: (x = S.id) != null ? x : this.generateId(),
          role: (w = S.role) != null ? w : "user",
          metadata: h.metadata
        });
      await this.makeRequest({
        trigger: "submit-message",
        messageId: h.messageId,
        ...m
      });
    }, this.regenerate = async ({
      messageId: h,
      ...m
    } = {}) => {
      const g = h == null ? this.state.messages.length - 1 : this.state.messages.findIndex((b) => b.id === h);
      if (g === -1)
        throw new Error(`message ${h} not found`);
      this.state.messages = this.state.messages.slice(
        0,
        // if the message is a user message, we need to include it in the request:
        this.messages[g].role === "assistant" ? g : g + 1
      ), await this.makeRequest({
        trigger: "regenerate-message",
        messageId: h,
        ...m
      });
    }, this.resumeStream = async (h = {}) => {
      await this.makeRequest({ trigger: "resume-stream", ...h });
    }, this.clearError = () => {
      this.status === "error" && (this.state.error = void 0, this.setStatus({ status: "ready" }));
    }, this.addToolOutput = async ({
      state: h = "output-available",
      tool: m,
      toolCallId: g,
      output: b,
      errorText: x
    }) => this.jobExecutor.run(async () => {
      var w, S;
      const _ = this.state.messages, M = _[_.length - 1];
      this.state.replaceMessage(_.length - 1, {
        ...M,
        parts: M.parts.map(
          (N) => lg(N) && N.toolCallId === g ? { ...N, state: h, output: b, errorText: x } : N
        )
      }), this.activeResponse && (this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(
        (N) => lg(N) && N.toolCallId === g ? {
          ...N,
          state: h,
          output: b,
          errorText: x
        } : N
      )), this.status !== "streaming" && this.status !== "submitted" && ((w = this.sendAutomaticallyWhen) != null && w.call(this, { messages: this.state.messages })) && this.makeRequest({
        trigger: "submit-message",
        messageId: (S = this.lastMessage) == null ? void 0 : S.id
      });
    }), this.addToolResult = this.addToolOutput, this.stop = async () => {
      var h;
      this.status !== "streaming" && this.status !== "submitted" || (h = this.activeResponse) != null && h.abortController && this.activeResponse.abortController.abort();
    }, this.id = t, this.transport = n, this.generateId = e, this.messageMetadataSchema = r, this.dataPartSchemas = i, this.state = o, this.onError = s, this.onToolCall = a, this.onFinish = c, this.onData = u, this.sendAutomaticallyWhen = f;
  }
  /**
   * Hook status:
   *
   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.
   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.
   * - `ready`: The full response has been received and processed; a new user message can be submitted.
   * - `error`: An error occurred during the API request, preventing successful completion.
   */
  get status() {
    return this.state.status;
  }
  setStatus({
    status: e,
    error: t
  }) {
    this.status !== e && (this.state.status = e, this.state.error = t);
  }
  get error() {
    return this.state.error;
  }
  get messages() {
    return this.state.messages;
  }
  get lastMessage() {
    return this.state.messages[this.state.messages.length - 1];
  }
  set messages(e) {
    this.state.messages = e;
  }
  async makeRequest({
    trigger: e,
    metadata: t,
    headers: n,
    body: r,
    messageId: i
  }) {
    var o, s, a, c;
    this.setStatus({ status: "submitted", error: void 0 });
    const u = this.lastMessage;
    let f = !1, h = !1, m = !1;
    try {
      const g = {
        state: Nbe({
          lastMessage: this.state.snapshot(u),
          messageId: this.generateId()
        }),
        abortController: new AbortController()
      };
      g.abortController.signal.addEventListener("abort", () => {
        f = !0;
      }), this.activeResponse = g;
      let b;
      if (e === "resume-stream") {
        const w = await this.transport.reconnectToStream({
          chatId: this.id,
          metadata: t,
          headers: n,
          body: r
        });
        if (w == null) {
          this.setStatus({ status: "ready" });
          return;
        }
        b = w;
      } else
        b = await this.transport.sendMessages({
          chatId: this.id,
          messages: this.state.messages,
          abortSignal: g.abortController.signal,
          metadata: t,
          headers: n,
          body: r,
          trigger: e,
          messageId: i
        });
      const x = (w) => (
        // serialize the job execution to avoid race conditions:
        this.jobExecutor.run(
          () => w({
            state: g.state,
            write: () => {
              var S;
              this.setStatus({ status: "streaming" }), g.state.message.id === ((S = this.lastMessage) == null ? void 0 : S.id) ? this.state.replaceMessage(
                this.state.messages.length - 1,
                g.state.message
              ) : this.state.pushMessage(g.state.message);
            }
          })
        )
      );
      await Obe({
        stream: Rbe({
          stream: b,
          onToolCall: this.onToolCall,
          onData: this.onData,
          messageMetadataSchema: this.messageMetadataSchema,
          dataPartSchemas: this.dataPartSchemas,
          runUpdateMessageJob: x,
          onError: (w) => {
            throw w;
          }
        }),
        onError: (w) => {
          throw w;
        }
      }), this.setStatus({ status: "ready" });
    } catch (g) {
      if (f || g.name === "AbortError")
        return f = !0, this.setStatus({ status: "ready" }), null;
      m = !0, g instanceof TypeError && (g.message.toLowerCase().includes("fetch") || g.message.toLowerCase().includes("network")) && (h = !0), this.onError && g instanceof Error && this.onError(g), this.setStatus({ status: "error", error: g });
    } finally {
      try {
        (s = this.onFinish) == null || s.call(this, {
          message: this.activeResponse.state.message,
          messages: this.state.messages,
          isAbort: f,
          isDisconnect: h,
          isError: m,
          finishReason: (o = this.activeResponse) == null ? void 0 : o.state.finishReason
        });
      } catch (g) {
        console.error(g);
      }
      this.activeResponse = void 0;
    }
    (a = this.sendAutomaticallyWhen) != null && a.call(this, { messages: this.state.messages }) && !m && await this.makeRequest({
      trigger: "submit-message",
      messageId: (c = this.lastMessage) == null ? void 0 : c.id,
      metadata: t,
      headers: n,
      body: r
    });
  }
};
function Ube({
  messages: e
}) {
  const t = e[e.length - 1];
  if (!t || t.role !== "assistant")
    return !1;
  const n = t.parts.reduce((i, o, s) => o.type === "step-start" ? s : i, -1), r = t.parts.slice(n + 1).filter(lg).filter((i) => !i.providerExecuted);
  return r.length > 0 && r.every(
    (i) => i.state === "output-available" || i.state === "output-error"
  );
}
var gC, QI;
function Fbe() {
  if (QI) return gC;
  QI = 1;
  function e(t, n) {
    if (typeof t != "function")
      throw new TypeError(`Expected the first argument to be a \`function\`, got \`${typeof t}\`.`);
    let r, i = 0;
    return function(...s) {
      clearTimeout(r);
      const a = Date.now(), c = a - i, u = n - c;
      u <= 0 ? (i = a, t.apply(this, s)) : r = setTimeout(() => {
        i = Date.now(), t.apply(this, s);
      }, u);
    };
  }
  return gC = e, gC;
}
var Vbe = /* @__PURE__ */ Fbe();
const Hbe = /* @__PURE__ */ Dc(Vbe);
var zF = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, Un = (e, t, n) => (zF(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Ds = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Xl = (e, t, n, r) => (zF(e, t, "write to private field"), t.set(e, n), n);
function Wbe(e, t) {
  return t != null ? Hbe(e, t) : e;
}
var No, P0, j0, dm, fm, hm, Ef, z_, L_, qbe = class {
  constructor(e = []) {
    Ds(this, No, void 0), Ds(this, P0, "ready"), Ds(this, j0, void 0), Ds(this, dm, /* @__PURE__ */ new Set()), Ds(this, fm, /* @__PURE__ */ new Set()), Ds(this, hm, /* @__PURE__ */ new Set()), this.pushMessage = (t) => {
      Xl(this, No, Un(this, No).concat(t)), Un(this, Ef).call(this);
    }, this.popMessage = () => {
      Xl(this, No, Un(this, No).slice(0, -1)), Un(this, Ef).call(this);
    }, this.replaceMessage = (t, n) => {
      Xl(this, No, [
        ...Un(this, No).slice(0, t),
        // We deep clone the message here to ensure the new React Compiler (currently in RC) detects deeply nested parts/metadata changes:
        this.snapshot(n),
        ...Un(this, No).slice(t + 1)
      ]), Un(this, Ef).call(this);
    }, this.snapshot = (t) => structuredClone(t), this["~registerMessagesCallback"] = (t, n) => {
      const r = n ? Wbe(t, n) : t;
      return Un(this, dm).add(r), () => {
        Un(this, dm).delete(r);
      };
    }, this["~registerStatusCallback"] = (t) => (Un(this, fm).add(t), () => {
      Un(this, fm).delete(t);
    }), this["~registerErrorCallback"] = (t) => (Un(this, hm).add(t), () => {
      Un(this, hm).delete(t);
    }), Ds(this, Ef, () => {
      Un(this, dm).forEach((t) => t());
    }), Ds(this, z_, () => {
      Un(this, fm).forEach((t) => t());
    }), Ds(this, L_, () => {
      Un(this, hm).forEach((t) => t());
    }), Xl(this, No, e);
  }
  get status() {
    return Un(this, P0);
  }
  set status(e) {
    Xl(this, P0, e), Un(this, z_).call(this);
  }
  get error() {
    return Un(this, j0);
  }
  set error(e) {
    Xl(this, j0, e), Un(this, L_).call(this);
  }
  get messages() {
    return Un(this, No);
  }
  set messages(e) {
    Xl(this, No, [...e]), Un(this, Ef).call(this);
  }
};
No = /* @__PURE__ */ new WeakMap();
P0 = /* @__PURE__ */ new WeakMap();
j0 = /* @__PURE__ */ new WeakMap();
dm = /* @__PURE__ */ new WeakMap();
fm = /* @__PURE__ */ new WeakMap();
hm = /* @__PURE__ */ new WeakMap();
Ef = /* @__PURE__ */ new WeakMap();
z_ = /* @__PURE__ */ new WeakMap();
L_ = /* @__PURE__ */ new WeakMap();
var _f, ez = class extends $be {
  constructor({ messages: e, ...t }) {
    const n = new qbe(e);
    super({ ...t, state: n }), Ds(this, _f, void 0), this["~registerMessagesCallback"] = (r, i) => Un(this, _f)["~registerMessagesCallback"](r, i), this["~registerStatusCallback"] = (r) => Un(this, _f)["~registerStatusCallback"](r), this["~registerErrorCallback"] = (r) => Un(this, _f)["~registerErrorCallback"](r), Xl(this, _f, n);
  }
};
_f = /* @__PURE__ */ new WeakMap();
function Gbe({
  experimental_throttle: e,
  resume: t = !1,
  ...n
} = {}) {
  const r = C.useRef(
    "chat" in n ? n.chat : new ez(n)
  );
  ("chat" in n && n.chat !== r.current || "id" in n && r.current.id !== n.id) && (r.current = "chat" in n ? n.chat : new ez(n));
  const o = C.useCallback(
    (f) => r.current["~registerMessagesCallback"](f, e),
    // `chatRef.current.id` is required to trigger re-subscription when the chat ID changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [e, r.current.id]
  ), s = C.useSyncExternalStore(
    o,
    () => r.current.messages,
    () => r.current.messages
  ), a = C.useSyncExternalStore(
    r.current["~registerStatusCallback"],
    () => r.current.status,
    () => r.current.status
  ), c = C.useSyncExternalStore(
    r.current["~registerErrorCallback"],
    () => r.current.error,
    () => r.current.error
  ), u = C.useCallback(
    (f) => {
      typeof f == "function" && (f = f(r.current.messages)), r.current.messages = f;
    },
    [r]
  );
  return C.useEffect(() => {
    t && r.current.resumeStream();
  }, [t, r]), {
    id: r.current.id,
    messages: s,
    setMessages: u,
    sendMessage: r.current.sendMessage,
    regenerate: r.current.regenerate,
    clearError: r.current.clearError,
    stop: r.current.stop,
    error: c,
    resumeStream: r.current.resumeStream,
    status: a,
    /**
     * @deprecated Use `addToolOutput` instead.
     */
    addToolResult: r.current.addToolOutput,
    addToolOutput: r.current.addToolOutput
  };
}
function Nm(e, t) {
  if (e === t) return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (Object.getPrototypeOf(e) !== Object.getPrototypeOf(t)) return !1;
    if (Array.isArray(e)) {
      if (!Array.isArray(t) || e.length !== t.length) return !1;
      for (let i = 0; i < e.length; i++)
        if (!Nm(e[i], t[i])) return !1;
      return !0;
    }
    if (e instanceof Date)
      return t instanceof Date && e.getTime() === t.getTime();
    if (e instanceof RegExp)
      return t instanceof RegExp && e.source === t.source && e.flags === t.flags;
    if (e instanceof Map) {
      if (!(t instanceof Map) || e.size !== t.size) return !1;
      for (const [i, o] of e)
        if (!t.has(i) || !Nm(o, t.get(i))) return !1;
      return !0;
    }
    if (e instanceof Set) {
      if (!(t instanceof Set) || e.size !== t.size) return !1;
      for (const i of e)
        if (!t.has(i)) return !1;
      return !0;
    }
    const n = Object.keys(e), r = Object.keys(t);
    if (n.length !== r.length) return !1;
    for (const i of n)
      if (!Object.prototype.hasOwnProperty.call(t, i) || !Nm(e[i], t[i])) return !1;
    return !0;
  }
  return Number.isNaN(e) && Number.isNaN(t);
}
function LF(e, t) {
  const n = t || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const Kbe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Zbe = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Ybe = {};
function tz(e, t) {
  return (Ybe.jsx ? Zbe : Kbe).test(e);
}
const Xbe = /[ \t\n\f\r]/g;
function Ow(e) {
  return typeof e == "object" ? e.type === "text" ? nz(e.value) : !1 : nz(e);
}
function nz(e) {
  return e.replace(Xbe, "") === "";
}
let ty = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
};
ty.prototype.normal = {};
ty.prototype.property = {};
ty.prototype.space = void 0;
function BF(e, t) {
  const n = {}, r = {};
  for (const i of e)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new ty(n, r, t);
}
function B_(e) {
  return e.toLowerCase();
}
class Yi {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
Yi.prototype.attribute = "";
Yi.prototype.booleanish = !1;
Yi.prototype.boolean = !1;
Yi.prototype.commaOrSpaceSeparated = !1;
Yi.prototype.commaSeparated = !1;
Yi.prototype.defined = !1;
Yi.prototype.mustUseProperty = !1;
Yi.prototype.number = !1;
Yi.prototype.overloadedBoolean = !1;
Yi.prototype.property = "";
Yi.prototype.spaceSeparated = !1;
Yi.prototype.space = void 0;
let Jbe = 0;
const Dt = hd(), wr = hd(), $_ = hd(), Fe = hd(), Rn = hd(), Xf = hd(), ao = hd();
function hd() {
  return 2 ** ++Jbe;
}
const U_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Dt,
  booleanish: wr,
  commaOrSpaceSeparated: ao,
  commaSeparated: Xf,
  number: Fe,
  overloadedBoolean: $_,
  spaceSeparated: Rn
}, Symbol.toStringTag, { value: "Module" })), yC = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(U_)
);
class zM extends Yi {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, i) {
    let o = -1;
    if (super(t, n), rz(this, "space", i), typeof r == "number")
      for (; ++o < yC.length; ) {
        const s = yC[o];
        rz(this, yC[o], (r & U_[s]) === U_[s]);
      }
  }
}
zM.prototype.defined = !0;
function rz(e, t, n) {
  n && (e[t] = n);
}
function Uh(e) {
  const t = {}, n = {};
  for (const [r, i] of Object.entries(e.properties)) {
    const o = new zM(
      r,
      e.transform(e.attributes || {}, r),
      i,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (o.mustUseProperty = !0), t[r] = o, n[B_(r)] = r, n[B_(o.attribute)] = r;
  }
  return new ty(t, n, e.space);
}
const $F = Uh({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: wr,
    ariaAutoComplete: null,
    ariaBusy: wr,
    ariaChecked: wr,
    ariaColCount: Fe,
    ariaColIndex: Fe,
    ariaColSpan: Fe,
    ariaControls: Rn,
    ariaCurrent: null,
    ariaDescribedBy: Rn,
    ariaDetails: null,
    ariaDisabled: wr,
    ariaDropEffect: Rn,
    ariaErrorMessage: null,
    ariaExpanded: wr,
    ariaFlowTo: Rn,
    ariaGrabbed: wr,
    ariaHasPopup: null,
    ariaHidden: wr,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Rn,
    ariaLevel: Fe,
    ariaLive: null,
    ariaModal: wr,
    ariaMultiLine: wr,
    ariaMultiSelectable: wr,
    ariaOrientation: null,
    ariaOwns: Rn,
    ariaPlaceholder: null,
    ariaPosInSet: Fe,
    ariaPressed: wr,
    ariaReadOnly: wr,
    ariaRelevant: null,
    ariaRequired: wr,
    ariaRoleDescription: Rn,
    ariaRowCount: Fe,
    ariaRowIndex: Fe,
    ariaRowSpan: Fe,
    ariaSelected: wr,
    ariaSetSize: Fe,
    ariaSort: null,
    ariaValueMax: Fe,
    ariaValueMin: Fe,
    ariaValueNow: Fe,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function UF(e, t) {
  return t in e ? e[t] : t;
}
function FF(e, t) {
  return UF(e, t.toLowerCase());
}
const Qbe = Uh({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Xf,
    acceptCharset: Rn,
    accessKey: Rn,
    action: null,
    allow: null,
    allowFullScreen: Dt,
    allowPaymentRequest: Dt,
    allowUserMedia: Dt,
    alt: null,
    as: null,
    async: Dt,
    autoCapitalize: null,
    autoComplete: Rn,
    autoFocus: Dt,
    autoPlay: Dt,
    blocking: Rn,
    capture: null,
    charSet: null,
    checked: Dt,
    cite: null,
    className: Rn,
    cols: Fe,
    colSpan: null,
    content: null,
    contentEditable: wr,
    controls: Dt,
    controlsList: Rn,
    coords: Fe | Xf,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Dt,
    defer: Dt,
    dir: null,
    dirName: null,
    disabled: Dt,
    download: $_,
    draggable: wr,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Dt,
    formTarget: null,
    headers: Rn,
    height: Fe,
    hidden: $_,
    high: Fe,
    href: null,
    hrefLang: null,
    htmlFor: Rn,
    httpEquiv: Rn,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Dt,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Dt,
    itemId: null,
    itemProp: Rn,
    itemRef: Rn,
    itemScope: Dt,
    itemType: Rn,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Dt,
    low: Fe,
    manifest: null,
    max: null,
    maxLength: Fe,
    media: null,
    method: null,
    min: null,
    minLength: Fe,
    multiple: Dt,
    muted: Dt,
    name: null,
    nonce: null,
    noModule: Dt,
    noValidate: Dt,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Dt,
    optimum: Fe,
    pattern: null,
    ping: Rn,
    placeholder: null,
    playsInline: Dt,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Dt,
    referrerPolicy: null,
    rel: Rn,
    required: Dt,
    reversed: Dt,
    rows: Fe,
    rowSpan: Fe,
    sandbox: Rn,
    scope: null,
    scoped: Dt,
    seamless: Dt,
    selected: Dt,
    shadowRootClonable: Dt,
    shadowRootDelegatesFocus: Dt,
    shadowRootMode: null,
    shape: null,
    size: Fe,
    sizes: null,
    slot: null,
    span: Fe,
    spellCheck: wr,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: Fe,
    step: null,
    style: null,
    tabIndex: Fe,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Dt,
    useMap: null,
    value: wr,
    width: Fe,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Rn,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: Fe,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: Fe,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Dt,
    // Lists. Use CSS to reduce space between items instead
    declare: Dt,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: Fe,
    // `<img>` and `<object>`
    leftMargin: Fe,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: Fe,
    // `<body>`
    marginWidth: Fe,
    // `<body>`
    noResize: Dt,
    // `<frame>`
    noHref: Dt,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Dt,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Dt,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: Fe,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: wr,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: Fe,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: Fe,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Dt,
    disableRemotePlayback: Dt,
    prefix: null,
    property: null,
    results: Fe,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: FF
}), exe = Uh({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: ao,
    accentHeight: Fe,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: Fe,
    amplitude: Fe,
    arabicForm: null,
    ascent: Fe,
    attributeName: null,
    attributeType: null,
    azimuth: Fe,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: Fe,
    by: null,
    calcMode: null,
    capHeight: Fe,
    className: Rn,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: Fe,
    diffuseConstant: Fe,
    direction: null,
    display: null,
    dur: null,
    divisor: Fe,
    dominantBaseline: null,
    download: Dt,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: Fe,
    enableBackground: null,
    end: null,
    event: null,
    exponent: Fe,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: Fe,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Xf,
    g2: Xf,
    glyphName: Xf,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: Fe,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: Fe,
    horizOriginX: Fe,
    horizOriginY: Fe,
    id: null,
    ideographic: Fe,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: Fe,
    k: Fe,
    k1: Fe,
    k2: Fe,
    k3: Fe,
    k4: Fe,
    kernelMatrix: ao,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: Fe,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: Fe,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: Fe,
    overlineThickness: Fe,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: Fe,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Rn,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: Fe,
    pointsAtY: Fe,
    pointsAtZ: Fe,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: ao,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: ao,
    rev: ao,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: ao,
    requiredFeatures: ao,
    requiredFonts: ao,
    requiredFormats: ao,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: Fe,
    specularExponent: Fe,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: Fe,
    strikethroughThickness: Fe,
    string: null,
    stroke: null,
    strokeDashArray: ao,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: Fe,
    strokeOpacity: Fe,
    strokeWidth: null,
    style: null,
    surfaceScale: Fe,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: ao,
    tabIndex: Fe,
    tableValues: null,
    target: null,
    targetX: Fe,
    targetY: Fe,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: ao,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: Fe,
    underlineThickness: Fe,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: Fe,
    values: null,
    vAlphabetic: Fe,
    vMathematical: Fe,
    vectorEffect: null,
    vHanging: Fe,
    vIdeographic: Fe,
    version: null,
    vertAdvY: Fe,
    vertOriginX: Fe,
    vertOriginY: Fe,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: Fe,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: UF
}), VF = Uh({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), HF = Uh({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: FF
}), WF = Uh({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), txe = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, nxe = /[A-Z]/g, iz = /-[a-z]/g, rxe = /^data[-\w.:]+$/i;
function qF(e, t) {
  const n = B_(t);
  let r = t, i = Yi;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && rxe.test(t)) {
    if (t.charAt(4) === "-") {
      const o = t.slice(5).replace(iz, oxe);
      r = "data" + o.charAt(0).toUpperCase() + o.slice(1);
    } else {
      const o = t.slice(4);
      if (!iz.test(o)) {
        let s = o.replace(nxe, ixe);
        s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s;
      }
    }
    i = zM;
  }
  return new i(r, t);
}
function ixe(e) {
  return "-" + e.toLowerCase();
}
function oxe(e) {
  return e.charAt(1).toUpperCase();
}
const GF = BF([$F, Qbe, VF, HF, WF], "html"), ny = BF([$F, exe, VF, HF, WF], "svg");
function KF(e) {
  return e.join(" ").trim();
}
var mf = {}, vC, oz;
function sxe() {
  if (oz) return vC;
  oz = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, i = /^:\s*/, o = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, s = /^[;\s]*/, a = /^\s+|\s+$/g, c = `
`, u = "/", f = "*", h = "", m = "comment", g = "declaration";
  function b(w, S) {
    if (typeof w != "string")
      throw new TypeError("First argument must be a string");
    if (!w) return [];
    S = S || {};
    var _ = 1, M = 1;
    function N(ie) {
      var ne = ie.match(t);
      ne && (_ += ne.length);
      var H = ie.lastIndexOf(c);
      M = ~H ? ie.length - H : M + ie.length;
    }
    function P() {
      var ie = { line: _, column: M };
      return function(ne) {
        return ne.position = new I(ie), U(), ne;
      };
    }
    function I(ie) {
      this.start = ie, this.end = { line: _, column: M }, this.source = S.source;
    }
    I.prototype.content = w;
    function O(ie) {
      var ne = new Error(
        S.source + ":" + _ + ":" + M + ": " + ie
      );
      if (ne.reason = ie, ne.filename = S.source, ne.line = _, ne.column = M, ne.source = w, !S.silent) throw ne;
    }
    function L(ie) {
      var ne = ie.exec(w);
      if (ne) {
        var H = ne[0];
        return N(H), w = w.slice(H.length), ne;
      }
    }
    function U() {
      L(n);
    }
    function B(ie) {
      var ne;
      for (ie = ie || []; ne = G(); )
        ne !== !1 && ie.push(ne);
      return ie;
    }
    function G() {
      var ie = P();
      if (!(u != w.charAt(0) || f != w.charAt(1))) {
        for (var ne = 2; h != w.charAt(ne) && (f != w.charAt(ne) || u != w.charAt(ne + 1)); )
          ++ne;
        if (ne += 2, h === w.charAt(ne - 1))
          return O("End of comment missing");
        var H = w.slice(2, ne - 2);
        return M += 2, N(H), w = w.slice(ne), M += 2, ie({
          type: m,
          comment: H
        });
      }
    }
    function Y() {
      var ie = P(), ne = L(r);
      if (ne) {
        if (G(), !L(i)) return O("property missing ':'");
        var H = L(o), Q = ie({
          type: g,
          property: x(ne[0].replace(e, h)),
          value: H ? x(H[0].replace(e, h)) : h
        });
        return L(s), Q;
      }
    }
    function he() {
      var ie = [];
      B(ie);
      for (var ne; ne = Y(); )
        ne !== !1 && (ie.push(ne), B(ie));
      return ie;
    }
    return U(), he();
  }
  function x(w) {
    return w ? w.replace(a, h) : h;
  }
  return vC = b, vC;
}
var sz;
function axe() {
  if (sz) return mf;
  sz = 1;
  var e = mf && mf.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(mf, "__esModule", { value: !0 }), mf.default = n;
  const t = e(sxe());
  function n(r, i) {
    let o = null;
    if (!r || typeof r != "string")
      return o;
    const s = (0, t.default)(r), a = typeof i == "function";
    return s.forEach((c) => {
      if (c.type !== "declaration")
        return;
      const { property: u, value: f } = c;
      a ? i(u, f, c) : f && (o = o || {}, o[u] = f);
    }), o;
  }
  return mf;
}
var Yp = {}, az;
function lxe() {
  if (az) return Yp;
  az = 1, Object.defineProperty(Yp, "__esModule", { value: !0 }), Yp.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, i = /^-(ms)-/, o = function(u) {
    return !u || n.test(u) || e.test(u);
  }, s = function(u, f) {
    return f.toUpperCase();
  }, a = function(u, f) {
    return "".concat(f, "-");
  }, c = function(u, f) {
    return f === void 0 && (f = {}), o(u) ? u : (u = u.toLowerCase(), f.reactCompat ? u = u.replace(i, a) : u = u.replace(r, a), u.replace(t, s));
  };
  return Yp.camelCase = c, Yp;
}
var Xp, lz;
function cxe() {
  if (lz) return Xp;
  lz = 1;
  var e = Xp && Xp.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  }, t = e(axe()), n = lxe();
  function r(i, o) {
    var s = {};
    return !i || typeof i != "string" || (0, t.default)(i, function(a, c) {
      a && c && (s[(0, n.camelCase)(a, o)] = c);
    }), s;
  }
  return r.default = r, Xp = r, Xp;
}
var uxe = cxe();
const dxe = /* @__PURE__ */ Dc(uxe), ZF = YF("end"), LM = YF("start");
function YF(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function fxe(e) {
  const t = LM(e), n = ZF(e);
  if (t && n)
    return { start: t, end: n };
}
function Rm(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? cz(e.position) : "start" in e || "end" in e ? cz(e) : "line" in e || "column" in e ? F_(e) : "";
}
function F_(e) {
  return uz(e && e.line) + ":" + uz(e && e.column);
}
function cz(e) {
  return F_(e && e.start) + "-" + F_(e && e.end);
}
function uz(e) {
  return e && typeof e == "number" ? e : 1;
}
class bi extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", o = {}, s = !1;
    if (n && ("line" in n && "column" in n ? o = { place: n } : "start" in n && "end" in n ? o = { place: n } : "type" in n ? o = {
      ancestors: [n],
      place: n.position
    } : o = { ...n }), typeof t == "string" ? i = t : !o.cause && t && (s = !0, i = t.message, o.cause = t), !o.ruleId && !o.source && typeof r == "string") {
      const c = r.indexOf(":");
      c === -1 ? o.ruleId = r : (o.source = r.slice(0, c), o.ruleId = r.slice(c + 1));
    }
    if (!o.place && o.ancestors && o.ancestors) {
      const c = o.ancestors[o.ancestors.length - 1];
      c && (o.place = c.position);
    }
    const a = o.place && "start" in o.place ? o.place.start : o.place;
    this.ancestors = o.ancestors || void 0, this.cause = o.cause || void 0, this.column = a ? a.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = a ? a.line : void 0, this.name = Rm(o.place) || "1:1", this.place = o.place || void 0, this.reason = this.message, this.ruleId = o.ruleId || void 0, this.source = o.source || void 0, this.stack = s && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
bi.prototype.file = "";
bi.prototype.name = "";
bi.prototype.reason = "";
bi.prototype.message = "";
bi.prototype.stack = "";
bi.prototype.column = void 0;
bi.prototype.line = void 0;
bi.prototype.ancestors = void 0;
bi.prototype.cause = void 0;
bi.prototype.fatal = void 0;
bi.prototype.place = void 0;
bi.prototype.ruleId = void 0;
bi.prototype.source = void 0;
const BM = {}.hasOwnProperty, hxe = /* @__PURE__ */ new Map(), pxe = /[A-Z]/g, mxe = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), gxe = /* @__PURE__ */ new Set(["td", "th"]), XF = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function JF(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = Cxe(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = kxe(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? ny : GF,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, o = QF(i, e, void 0);
  return o && typeof o != "string" ? o : i.create(
    e,
    i.Fragment,
    { children: o || void 0 },
    void 0
  );
}
function QF(e, t, n) {
  if (t.type === "element")
    return yxe(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return vxe(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return xxe(e, t, n);
  if (t.type === "mdxjsEsm")
    return bxe(e, t);
  if (t.type === "root")
    return wxe(e, t, n);
  if (t.type === "text")
    return Sxe(e, t);
}
function yxe(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = ny, e.schema = i), e.ancestors.push(t);
  const o = tV(e, t.tagName, !1), s = Exe(e, t);
  let a = UM(e, t);
  return mxe.has(t.tagName) && (a = a.filter(function(c) {
    return typeof c == "string" ? !Ow(c) : !0;
  })), eV(e, s, o, t), $M(s, a), e.ancestors.pop(), e.schema = r, e.create(t, o, s, n);
}
function vxe(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  ug(e, t.position);
}
function bxe(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  ug(e, t.position);
}
function xxe(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = ny, e.schema = i), e.ancestors.push(t);
  const o = t.name === null ? e.Fragment : tV(e, t.name, !0), s = _xe(e, t), a = UM(e, t);
  return eV(e, s, o, t), $M(s, a), e.ancestors.pop(), e.schema = r, e.create(t, o, s, n);
}
function wxe(e, t, n) {
  const r = {};
  return $M(r, UM(e, t)), e.create(t, e.Fragment, r, n);
}
function Sxe(e, t) {
  return t.value;
}
function eV(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function $M(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function kxe(e, t, n) {
  return r;
  function r(i, o, s, a) {
    const u = Array.isArray(s.children) ? n : t;
    return a ? u(o, s, a) : u(o, s);
  }
}
function Cxe(e, t) {
  return n;
  function n(r, i, o, s) {
    const a = Array.isArray(o.children), c = LM(r);
    return t(
      i,
      o,
      s,
      a,
      {
        columnNumber: c ? c.column - 1 : void 0,
        fileName: e,
        lineNumber: c ? c.line : void 0
      },
      void 0
    );
  }
}
function Exe(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && BM.call(t.properties, i)) {
      const o = Txe(e, i, t.properties[i]);
      if (o) {
        const [s, a] = o;
        e.tableCellAlignToStyle && s === "align" && typeof a == "string" && gxe.has(t.tagName) ? r = a : n[s] = a;
      }
    }
  if (r) {
    const o = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    o[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function _xe(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const o = r.data.estree.body[0];
        o.type;
        const s = o.expression;
        s.type;
        const a = s.properties[0];
        a.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(a.argument)
        );
      } else
        ug(e, t.position);
    else {
      const i = r.name;
      let o;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const a = r.value.data.estree.body[0];
          a.type, o = e.evaluater.evaluateExpression(a.expression);
        } else
          ug(e, t.position);
      else
        o = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      o;
    }
  return n;
}
function UM(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : hxe;
  for (; ++r < t.children.length; ) {
    const o = t.children[r];
    let s;
    if (e.passKeys) {
      const c = o.type === "element" ? o.tagName : o.type === "mdxJsxFlowElement" || o.type === "mdxJsxTextElement" ? o.name : void 0;
      if (c) {
        const u = i.get(c) || 0;
        s = c + "-" + u, i.set(c, u + 1);
      }
    }
    const a = QF(e, o, s);
    a !== void 0 && n.push(a);
  }
  return n;
}
function Txe(e, t, n) {
  const r = qF(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? LF(n) : KF(n)), r.property === "style") {
      let i = typeof n == "object" ? n : Axe(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = Mxe(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? txe[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function Axe(e, t) {
  try {
    return dxe(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), i = new bi("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw i.file = e.filePath || void 0, i.url = XF + "#cannot-parse-style-attribute", i;
  }
}
function tV(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let o = -1, s;
    for (; ++o < i.length; ) {
      const a = tz(i[o]) ? { type: "Identifier", name: i[o] } : { type: "Literal", value: i[o] };
      s = s ? {
        type: "MemberExpression",
        object: s,
        property: a,
        computed: !!(o && a.type === "Literal"),
        optional: !1
      } : a;
    }
    r = s;
  } else
    r = tz(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {string | number} */
      r.value
    );
    return BM.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  ug(e);
}
function ug(e, t) {
  const n = new bi(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = XF + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function Mxe(e) {
  const t = {};
  let n;
  for (n in e)
    BM.call(e, n) && (t[Nxe(n)] = e[n]);
  return t;
}
function Nxe(e) {
  let t = e.replace(pxe, Rxe);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function Rxe(e) {
  return "-" + e.toLowerCase();
}
const bC = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, Oxe = {};
function FM(e, t) {
  const n = Oxe, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return nV(e, r, i);
}
function nV(e, t, n) {
  if (Dxe(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return dz(e.children, t, n);
  }
  return Array.isArray(e) ? dz(e, t, n) : "";
}
function dz(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = nV(e[i], t, n);
  return r.join("");
}
function Dxe(e) {
  return !!(e && typeof e == "object");
}
const fz = document.createElement("i");
function VM(e) {
  const t = "&" + e + ";";
  fz.innerHTML = t;
  const n = fz.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function po(e, t, n, r) {
  const i = e.length;
  let o = 0, s;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    s = Array.from(r), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); o < r.length; )
      s = r.slice(o, o + 1e4), s.unshift(t, 0), e.splice(...s), o += 1e4, t += 1e4;
}
function Io(e, t) {
  return e.length > 0 ? (po(e, e.length, 0, t), e) : t;
}
const hz = {}.hasOwnProperty;
function rV(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    Pxe(t, e[n]);
  return t;
}
function Pxe(e, t) {
  let n;
  for (n in t) {
    const i = (hz.call(e, n) ? e[n] : void 0) || (e[n] = {}), o = t[n];
    let s;
    if (o)
      for (s in o) {
        hz.call(i, s) || (i[s] = []);
        const a = o[s];
        jxe(
          // @ts-expect-error Looks like a list.
          i[s],
          Array.isArray(a) ? a : a ? [a] : []
        );
      }
  }
}
function jxe(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  po(e, 0, 0, r);
}
function iV(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function us(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Ai = Uc(/[A-Za-z]/), mi = Uc(/[\dA-Za-z]/), Ixe = Uc(/[#-'*+\--9=?A-Z^-~]/);
function Ib(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const V_ = Uc(/\d/), zxe = Uc(/[\dA-Fa-f]/), Lxe = Uc(/[!-/:-@[-`{-~]/);
function yt(e) {
  return e !== null && e < -2;
}
function Tn(e) {
  return e !== null && (e < 0 || e === 32);
}
function Gt(e) {
  return e === -2 || e === -1 || e === 32;
}
const Dw = Uc(new RegExp("\\p{P}|\\p{S}", "u")), nd = Uc(/\s/);
function Uc(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Fh(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const o = e.charCodeAt(n);
    let s = "";
    if (o === 37 && mi(e.charCodeAt(n + 1)) && mi(e.charCodeAt(n + 2)))
      i = 2;
    else if (o < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (s = String.fromCharCode(o));
    else if (o > 55295 && o < 57344) {
      const a = e.charCodeAt(n + 1);
      o < 56320 && a > 56319 && a < 57344 ? (s = String.fromCharCode(o, a), i = 1) : s = "";
    } else
      s = String.fromCharCode(o);
    s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + i + 1, s = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function tn(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let o = 0;
  return s;
  function s(c) {
    return Gt(c) ? (e.enter(n), a(c)) : t(c);
  }
  function a(c) {
    return Gt(c) && o++ < i ? (e.consume(c), a) : (e.exit(n), t(c));
  }
}
const Bxe = {
  tokenize: $xe
};
function $xe(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return t;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), tn(e, t, "linePrefix");
  }
  function i(a) {
    return e.enter("paragraph"), o(a);
  }
  function o(a) {
    const c = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = c), n = c, s(a);
  }
  function s(a) {
    if (a === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(a);
      return;
    }
    return yt(a) ? (e.consume(a), e.exit("chunkText"), o) : (e.consume(a), s);
  }
}
const Uxe = {
  tokenize: Fxe
}, pz = {
  tokenize: Vxe
};
function Fxe(e) {
  const t = this, n = [];
  let r = 0, i, o, s;
  return a;
  function a(M) {
    if (r < n.length) {
      const N = n[r];
      return t.containerState = N[1], e.attempt(N[0].continuation, c, u)(M);
    }
    return u(M);
  }
  function c(M) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && _();
      const N = t.events.length;
      let P = N, I;
      for (; P--; )
        if (t.events[P][0] === "exit" && t.events[P][1].type === "chunkFlow") {
          I = t.events[P][1].end;
          break;
        }
      S(r);
      let O = N;
      for (; O < t.events.length; )
        t.events[O][1].end = {
          ...I
        }, O++;
      return po(t.events, P + 1, 0, t.events.slice(N)), t.events.length = O, u(M);
    }
    return a(M);
  }
  function u(M) {
    if (r === n.length) {
      if (!i)
        return m(M);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return b(M);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(pz, f, h)(M);
  }
  function f(M) {
    return i && _(), S(r), m(M);
  }
  function h(M) {
    return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, b(M);
  }
  function m(M) {
    return t.containerState = {}, e.attempt(pz, g, b)(M);
  }
  function g(M) {
    return r++, n.push([t.currentConstruct, t.containerState]), m(M);
  }
  function b(M) {
    if (M === null) {
      i && _(), S(0), e.consume(M);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: o
    }), x(M);
  }
  function x(M) {
    if (M === null) {
      w(e.exit("chunkFlow"), !0), S(0), e.consume(M);
      return;
    }
    return yt(M) ? (e.consume(M), w(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, a) : (e.consume(M), x);
  }
  function w(M, N) {
    const P = t.sliceStream(M);
    if (N && P.push(null), M.previous = o, o && (o.next = M), o = M, i.defineSkip(M.start), i.write(P), t.parser.lazy[M.start.line]) {
      let I = i.events.length;
      for (; I--; )
        if (
          // The token starts before the line ending
          i.events[I][1].start.offset < s && // and either is not ended yet
          (!i.events[I][1].end || // or ends after it.
          i.events[I][1].end.offset > s)
        )
          return;
      const O = t.events.length;
      let L = O, U, B;
      for (; L--; )
        if (t.events[L][0] === "exit" && t.events[L][1].type === "chunkFlow") {
          if (U) {
            B = t.events[L][1].end;
            break;
          }
          U = !0;
        }
      for (S(r), I = O; I < t.events.length; )
        t.events[I][1].end = {
          ...B
        }, I++;
      po(t.events, L + 1, 0, t.events.slice(O)), t.events.length = I;
    }
  }
  function S(M) {
    let N = n.length;
    for (; N-- > M; ) {
      const P = n[N];
      t.containerState = P[1], P[0].exit.call(t, e);
    }
    n.length = M;
  }
  function _() {
    i.write([null]), o = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function Vxe(e, t, n) {
  return tn(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function fh(e) {
  if (e === null || Tn(e) || nd(e))
    return 1;
  if (Dw(e))
    return 2;
}
function Pw(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const o = e[i].resolveAll;
    o && !r.includes(o) && (t = o(t, n), r.push(o));
  }
  return t;
}
const H_ = {
  name: "attention",
  resolveAll: Hxe,
  tokenize: Wxe
};
function Hxe(e, t) {
  let n = -1, r, i, o, s, a, c, u, f;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          c = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const h = {
            ...e[r][1].end
          }, m = {
            ...e[n][1].start
          };
          mz(h, -c), mz(m, c), s = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: {
              ...e[r][1].end
            }
          }, a = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: m
          }, o = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, i = {
            type: c > 1 ? "strong" : "emphasis",
            start: {
              ...s.start
            },
            end: {
              ...a.end
            }
          }, e[r][1].end = {
            ...s.start
          }, e[n][1].start = {
            ...a.end
          }, u = [], e[r][1].end.offset - e[r][1].start.offset && (u = Io(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])), u = Io(u, [["enter", i, t], ["enter", s, t], ["exit", s, t], ["enter", o, t]]), u = Io(u, Pw(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), u = Io(u, [["exit", o, t], ["enter", a, t], ["exit", a, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (f = 2, u = Io(u, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : f = 0, po(e, r - 1, n - r + 3, u), n = r + u.length - f - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function Wxe(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = fh(r);
  let o;
  return s;
  function s(c) {
    return o = c, e.enter("attentionSequence"), a(c);
  }
  function a(c) {
    if (c === o)
      return e.consume(c), a;
    const u = e.exit("attentionSequence"), f = fh(c), h = !f || f === 2 && i || n.includes(c), m = !i || i === 2 && f || n.includes(r);
    return u._open = !!(o === 42 ? h : h && (i || !m)), u._close = !!(o === 42 ? m : m && (f || !h)), t(c);
  }
}
function mz(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const qxe = {
  name: "autolink",
  tokenize: Gxe
};
function Gxe(e, t, n) {
  let r = 0;
  return i;
  function i(g) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), o;
  }
  function o(g) {
    return Ai(g) ? (e.consume(g), s) : g === 64 ? n(g) : u(g);
  }
  function s(g) {
    return g === 43 || g === 45 || g === 46 || mi(g) ? (r = 1, a(g)) : u(g);
  }
  function a(g) {
    return g === 58 ? (e.consume(g), r = 0, c) : (g === 43 || g === 45 || g === 46 || mi(g)) && r++ < 32 ? (e.consume(g), a) : (r = 0, u(g));
  }
  function c(g) {
    return g === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.exit("autolink"), t) : g === null || g === 32 || g === 60 || Ib(g) ? n(g) : (e.consume(g), c);
  }
  function u(g) {
    return g === 64 ? (e.consume(g), f) : Ixe(g) ? (e.consume(g), u) : n(g);
  }
  function f(g) {
    return mi(g) ? h(g) : n(g);
  }
  function h(g) {
    return g === 46 ? (e.consume(g), r = 0, f) : g === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.exit("autolink"), t) : m(g);
  }
  function m(g) {
    if ((g === 45 || mi(g)) && r++ < 63) {
      const b = g === 45 ? m : h;
      return e.consume(g), b;
    }
    return n(g);
  }
}
const ry = {
  partial: !0,
  tokenize: Kxe
};
function Kxe(e, t, n) {
  return r;
  function r(o) {
    return Gt(o) ? tn(e, i, "linePrefix")(o) : i(o);
  }
  function i(o) {
    return o === null || yt(o) ? t(o) : n(o);
  }
}
const oV = {
  continuation: {
    tokenize: Yxe
  },
  exit: Xxe,
  name: "blockQuote",
  tokenize: Zxe
};
function Zxe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    if (s === 62) {
      const a = r.containerState;
      return a.open || (e.enter("blockQuote", {
        _container: !0
      }), a.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), o;
    }
    return n(s);
  }
  function o(s) {
    return Gt(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s));
  }
}
function Yxe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return Gt(s) ? tn(e, o, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) : o(s);
  }
  function o(s) {
    return e.attempt(oV, t, n)(s);
  }
}
function Xxe(e) {
  e.exit("blockQuote");
}
const sV = {
  name: "characterEscape",
  tokenize: Jxe
};
function Jxe(e, t, n) {
  return r;
  function r(o) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(o), e.exit("escapeMarker"), i;
  }
  function i(o) {
    return Lxe(o) ? (e.enter("characterEscapeValue"), e.consume(o), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(o);
  }
}
const aV = {
  name: "characterReference",
  tokenize: Qxe
};
function Qxe(e, t, n) {
  const r = this;
  let i = 0, o, s;
  return a;
  function a(h) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), c;
  }
  function c(h) {
    return h === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(h), e.exit("characterReferenceMarkerNumeric"), u) : (e.enter("characterReferenceValue"), o = 31, s = mi, f(h));
  }
  function u(h) {
    return h === 88 || h === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(h), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), o = 6, s = zxe, f) : (e.enter("characterReferenceValue"), o = 7, s = V_, f(h));
  }
  function f(h) {
    if (h === 59 && i) {
      const m = e.exit("characterReferenceValue");
      return s === mi && !VM(r.sliceSerialize(m)) ? n(h) : (e.enter("characterReferenceMarker"), e.consume(h), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return s(h) && i++ < o ? (e.consume(h), f) : n(h);
  }
}
const gz = {
  partial: !0,
  tokenize: twe
}, yz = {
  concrete: !0,
  name: "codeFenced",
  tokenize: ewe
};
function ewe(e, t, n) {
  const r = this, i = {
    partial: !0,
    tokenize: P
  };
  let o = 0, s = 0, a;
  return c;
  function c(I) {
    return u(I);
  }
  function u(I) {
    const O = r.events[r.events.length - 1];
    return o = O && O[1].type === "linePrefix" ? O[2].sliceSerialize(O[1], !0).length : 0, a = I, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), f(I);
  }
  function f(I) {
    return I === a ? (s++, e.consume(I), f) : s < 3 ? n(I) : (e.exit("codeFencedFenceSequence"), Gt(I) ? tn(e, h, "whitespace")(I) : h(I));
  }
  function h(I) {
    return I === null || yt(I) ? (e.exit("codeFencedFence"), r.interrupt ? t(I) : e.check(gz, x, N)(I)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), m(I));
  }
  function m(I) {
    return I === null || yt(I) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), h(I)) : Gt(I) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), tn(e, g, "whitespace")(I)) : I === 96 && I === a ? n(I) : (e.consume(I), m);
  }
  function g(I) {
    return I === null || yt(I) ? h(I) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), b(I));
  }
  function b(I) {
    return I === null || yt(I) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), h(I)) : I === 96 && I === a ? n(I) : (e.consume(I), b);
  }
  function x(I) {
    return e.attempt(i, N, w)(I);
  }
  function w(I) {
    return e.enter("lineEnding"), e.consume(I), e.exit("lineEnding"), S;
  }
  function S(I) {
    return o > 0 && Gt(I) ? tn(e, _, "linePrefix", o + 1)(I) : _(I);
  }
  function _(I) {
    return I === null || yt(I) ? e.check(gz, x, N)(I) : (e.enter("codeFlowValue"), M(I));
  }
  function M(I) {
    return I === null || yt(I) ? (e.exit("codeFlowValue"), _(I)) : (e.consume(I), M);
  }
  function N(I) {
    return e.exit("codeFenced"), t(I);
  }
  function P(I, O, L) {
    let U = 0;
    return B;
    function B(ne) {
      return I.enter("lineEnding"), I.consume(ne), I.exit("lineEnding"), G;
    }
    function G(ne) {
      return I.enter("codeFencedFence"), Gt(ne) ? tn(I, Y, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(ne) : Y(ne);
    }
    function Y(ne) {
      return ne === a ? (I.enter("codeFencedFenceSequence"), he(ne)) : L(ne);
    }
    function he(ne) {
      return ne === a ? (U++, I.consume(ne), he) : U >= s ? (I.exit("codeFencedFenceSequence"), Gt(ne) ? tn(I, ie, "whitespace")(ne) : ie(ne)) : L(ne);
    }
    function ie(ne) {
      return ne === null || yt(ne) ? (I.exit("codeFencedFence"), O(ne)) : L(ne);
    }
  }
}
function twe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o);
  }
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const xC = {
  name: "codeIndented",
  tokenize: rwe
}, nwe = {
  partial: !0,
  tokenize: iwe
};
function rwe(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return e.enter("codeIndented"), tn(e, o, "linePrefix", 5)(u);
  }
  function o(u) {
    const f = r.events[r.events.length - 1];
    return f && f[1].type === "linePrefix" && f[2].sliceSerialize(f[1], !0).length >= 4 ? s(u) : n(u);
  }
  function s(u) {
    return u === null ? c(u) : yt(u) ? e.attempt(nwe, s, c)(u) : (e.enter("codeFlowValue"), a(u));
  }
  function a(u) {
    return u === null || yt(u) ? (e.exit("codeFlowValue"), s(u)) : (e.consume(u), a);
  }
  function c(u) {
    return e.exit("codeIndented"), t(u);
  }
}
function iwe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : yt(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i) : tn(e, o, "linePrefix", 5)(s);
  }
  function o(s) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(s) : yt(s) ? i(s) : n(s);
  }
}
const owe = {
  name: "codeText",
  previous: awe,
  resolve: swe,
  tokenize: lwe
};
function swe(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function awe(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function lwe(e, t, n) {
  let r = 0, i, o;
  return s;
  function s(h) {
    return e.enter("codeText"), e.enter("codeTextSequence"), a(h);
  }
  function a(h) {
    return h === 96 ? (e.consume(h), r++, a) : (e.exit("codeTextSequence"), c(h));
  }
  function c(h) {
    return h === null ? n(h) : h === 32 ? (e.enter("space"), e.consume(h), e.exit("space"), c) : h === 96 ? (o = e.enter("codeTextSequence"), i = 0, f(h)) : yt(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), c) : (e.enter("codeTextData"), u(h));
  }
  function u(h) {
    return h === null || h === 32 || h === 96 || yt(h) ? (e.exit("codeTextData"), c(h)) : (e.consume(h), u);
  }
  function f(h) {
    return h === 96 ? (e.consume(h), i++, f) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(h)) : (o.type = "codeTextData", u(h));
  }
}
class cwe {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const o = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && Jp(this.left, r), o.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), Jp(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), Jp(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        Jp(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        Jp(this.left, n.reverse());
      }
  }
}
function Jp(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function lV(e) {
  const t = {};
  let n = -1, r, i, o, s, a, c, u;
  const f = new cwe(e);
  for (; ++n < f.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = f.get(n), n && r[1].type === "chunkFlow" && f.get(n - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, o = 0, o < c.length && c[o][1].type === "lineEndingBlank" && (o += 2), o < c.length && c[o][1].type === "content"))
      for (; ++o < c.length && c[o][1].type !== "content"; )
        c[o][1].type === "chunkText" && (c[o][1]._isInFirstContentOfListItem = !0, o++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, uwe(f, n)), n = t[n], u = !0);
    else if (r[1]._container) {
      for (o = n, i = void 0; o--; )
        if (s = f.get(o), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank")
          s[0] === "enter" && (i && (f.get(i)[1].type = "lineEndingBlank"), s[1].type = "lineEnding", i = o);
        else if (!(s[1].type === "linePrefix" || s[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...f.get(i)[1].start
      }, a = f.slice(i, n), a.unshift(r), f.splice(i, n - i + 1, a));
    }
  }
  return po(e, 0, Number.POSITIVE_INFINITY, f.slice(0)), !u;
}
function uwe(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let i = t - 1;
  const o = [];
  let s = n._tokenizer;
  s || (s = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (s._contentTypeTextTrailing = !0));
  const a = s.events, c = [], u = {};
  let f, h, m = -1, g = n, b = 0, x = 0;
  const w = [x];
  for (; g; ) {
    for (; e.get(++i)[1] !== g; )
      ;
    o.push(i), g._tokenizer || (f = r.sliceStream(g), g.next || f.push(null), h && s.defineSkip(g.start), g._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(f), g._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), h = g, g = g.next;
  }
  for (g = n; ++m < a.length; )
    // Find a void token that includes a break.
    a[m][0] === "exit" && a[m - 1][0] === "enter" && a[m][1].type === a[m - 1][1].type && a[m][1].start.line !== a[m][1].end.line && (x = m + 1, w.push(x), g._tokenizer = void 0, g.previous = void 0, g = g.next);
  for (s.events = [], g ? (g._tokenizer = void 0, g.previous = void 0) : w.pop(), m = w.length; m--; ) {
    const S = a.slice(w[m], w[m + 1]), _ = o.pop();
    c.push([_, _ + S.length - 1]), e.splice(_, 2, S);
  }
  for (c.reverse(), m = -1; ++m < c.length; )
    u[b + c[m][0]] = b + c[m][1], b += c[m][1] - c[m][0] - 1;
  return u;
}
const dwe = {
  resolve: hwe,
  tokenize: pwe
}, fwe = {
  partial: !0,
  tokenize: mwe
};
function hwe(e) {
  return lV(e), e;
}
function pwe(e, t) {
  let n;
  return r;
  function r(a) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(a);
  }
  function i(a) {
    return a === null ? o(a) : yt(a) ? e.check(fwe, s, o)(a) : (e.consume(a), i);
  }
  function o(a) {
    return e.exit("chunkContent"), e.exit("content"), t(a);
  }
  function s(a) {
    return e.consume(a), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function mwe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), tn(e, o, "linePrefix");
  }
  function o(s) {
    if (s === null || yt(s))
      return n(s);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function cV(e, t, n, r, i, o, s, a, c) {
  const u = c || Number.POSITIVE_INFINITY;
  let f = 0;
  return h;
  function h(S) {
    return S === 60 ? (e.enter(r), e.enter(i), e.enter(o), e.consume(S), e.exit(o), m) : S === null || S === 32 || S === 41 || Ib(S) ? n(S) : (e.enter(r), e.enter(s), e.enter(a), e.enter("chunkString", {
      contentType: "string"
    }), x(S));
  }
  function m(S) {
    return S === 62 ? (e.enter(o), e.consume(S), e.exit(o), e.exit(i), e.exit(r), t) : (e.enter(a), e.enter("chunkString", {
      contentType: "string"
    }), g(S));
  }
  function g(S) {
    return S === 62 ? (e.exit("chunkString"), e.exit(a), m(S)) : S === null || S === 60 || yt(S) ? n(S) : (e.consume(S), S === 92 ? b : g);
  }
  function b(S) {
    return S === 60 || S === 62 || S === 92 ? (e.consume(S), g) : g(S);
  }
  function x(S) {
    return !f && (S === null || S === 41 || Tn(S)) ? (e.exit("chunkString"), e.exit(a), e.exit(s), e.exit(r), t(S)) : f < u && S === 40 ? (e.consume(S), f++, x) : S === 41 ? (e.consume(S), f--, x) : S === null || S === 32 || S === 40 || Ib(S) ? n(S) : (e.consume(S), S === 92 ? w : x);
  }
  function w(S) {
    return S === 40 || S === 41 || S === 92 ? (e.consume(S), x) : x(S);
  }
}
function uV(e, t, n, r, i, o) {
  const s = this;
  let a = 0, c;
  return u;
  function u(g) {
    return e.enter(r), e.enter(i), e.consume(g), e.exit(i), e.enter(o), f;
  }
  function f(g) {
    return a > 999 || g === null || g === 91 || g === 93 && !c || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    g === 94 && !a && "_hiddenFootnoteSupport" in s.parser.constructs ? n(g) : g === 93 ? (e.exit(o), e.enter(i), e.consume(g), e.exit(i), e.exit(r), t) : yt(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), f) : (e.enter("chunkString", {
      contentType: "string"
    }), h(g));
  }
  function h(g) {
    return g === null || g === 91 || g === 93 || yt(g) || a++ > 999 ? (e.exit("chunkString"), f(g)) : (e.consume(g), c || (c = !Gt(g)), g === 92 ? m : h);
  }
  function m(g) {
    return g === 91 || g === 92 || g === 93 ? (e.consume(g), a++, h) : h(g);
  }
}
function dV(e, t, n, r, i, o) {
  let s;
  return a;
  function a(m) {
    return m === 34 || m === 39 || m === 40 ? (e.enter(r), e.enter(i), e.consume(m), e.exit(i), s = m === 40 ? 41 : m, c) : n(m);
  }
  function c(m) {
    return m === s ? (e.enter(i), e.consume(m), e.exit(i), e.exit(r), t) : (e.enter(o), u(m));
  }
  function u(m) {
    return m === s ? (e.exit(o), c(s)) : m === null ? n(m) : yt(m) ? (e.enter("lineEnding"), e.consume(m), e.exit("lineEnding"), tn(e, u, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), f(m));
  }
  function f(m) {
    return m === s || m === null || yt(m) ? (e.exit("chunkString"), u(m)) : (e.consume(m), m === 92 ? h : f);
  }
  function h(m) {
    return m === s || m === 92 ? (e.consume(m), f) : f(m);
  }
}
function Om(e, t) {
  let n;
  return r;
  function r(i) {
    return yt(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : Gt(i) ? tn(e, r, n ? "linePrefix" : "lineSuffix")(i) : t(i);
  }
}
const gwe = {
  name: "definition",
  tokenize: vwe
}, ywe = {
  partial: !0,
  tokenize: bwe
};
function vwe(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(g) {
    return e.enter("definition"), s(g);
  }
  function s(g) {
    return uV.call(
      r,
      e,
      a,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(g);
  }
  function a(g) {
    return i = us(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), g === 58 ? (e.enter("definitionMarker"), e.consume(g), e.exit("definitionMarker"), c) : n(g);
  }
  function c(g) {
    return Tn(g) ? Om(e, u)(g) : u(g);
  }
  function u(g) {
    return cV(
      e,
      f,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(g);
  }
  function f(g) {
    return e.attempt(ywe, h, h)(g);
  }
  function h(g) {
    return Gt(g) ? tn(e, m, "whitespace")(g) : m(g);
  }
  function m(g) {
    return g === null || yt(g) ? (e.exit("definition"), r.parser.defined.push(i), t(g)) : n(g);
  }
}
function bwe(e, t, n) {
  return r;
  function r(a) {
    return Tn(a) ? Om(e, i)(a) : n(a);
  }
  function i(a) {
    return dV(e, o, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(a);
  }
  function o(a) {
    return Gt(a) ? tn(e, s, "whitespace")(a) : s(a);
  }
  function s(a) {
    return a === null || yt(a) ? t(a) : n(a);
  }
}
const xwe = {
  name: "hardBreakEscape",
  tokenize: wwe
};
function wwe(e, t, n) {
  return r;
  function r(o) {
    return e.enter("hardBreakEscape"), e.consume(o), i;
  }
  function i(o) {
    return yt(o) ? (e.exit("hardBreakEscape"), t(o)) : n(o);
  }
}
const Swe = {
  name: "headingAtx",
  resolve: kwe,
  tokenize: Cwe
};
function kwe(e, t) {
  let n = e.length - 2, r = 3, i, o;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, o = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, po(e, r, n - r + 1, [["enter", i, t], ["enter", o, t], ["exit", o, t], ["exit", i, t]])), e;
}
function Cwe(e, t, n) {
  let r = 0;
  return i;
  function i(f) {
    return e.enter("atxHeading"), o(f);
  }
  function o(f) {
    return e.enter("atxHeadingSequence"), s(f);
  }
  function s(f) {
    return f === 35 && r++ < 6 ? (e.consume(f), s) : f === null || Tn(f) ? (e.exit("atxHeadingSequence"), a(f)) : n(f);
  }
  function a(f) {
    return f === 35 ? (e.enter("atxHeadingSequence"), c(f)) : f === null || yt(f) ? (e.exit("atxHeading"), t(f)) : Gt(f) ? tn(e, a, "whitespace")(f) : (e.enter("atxHeadingText"), u(f));
  }
  function c(f) {
    return f === 35 ? (e.consume(f), c) : (e.exit("atxHeadingSequence"), a(f));
  }
  function u(f) {
    return f === null || f === 35 || Tn(f) ? (e.exit("atxHeadingText"), a(f)) : (e.consume(f), u);
  }
}
const Ewe = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], vz = ["pre", "script", "style", "textarea"], _we = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: Mwe,
  tokenize: Nwe
}, Twe = {
  partial: !0,
  tokenize: Owe
}, Awe = {
  partial: !0,
  tokenize: Rwe
};
function Mwe(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function Nwe(e, t, n) {
  const r = this;
  let i, o, s, a, c;
  return u;
  function u(F) {
    return f(F);
  }
  function f(F) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(F), h;
  }
  function h(F) {
    return F === 33 ? (e.consume(F), m) : F === 47 ? (e.consume(F), o = !0, x) : F === 63 ? (e.consume(F), i = 3, r.interrupt ? t : W) : Ai(F) ? (e.consume(F), s = String.fromCharCode(F), w) : n(F);
  }
  function m(F) {
    return F === 45 ? (e.consume(F), i = 2, g) : F === 91 ? (e.consume(F), i = 5, a = 0, b) : Ai(F) ? (e.consume(F), i = 4, r.interrupt ? t : W) : n(F);
  }
  function g(F) {
    return F === 45 ? (e.consume(F), r.interrupt ? t : W) : n(F);
  }
  function b(F) {
    const ee = "CDATA[";
    return F === ee.charCodeAt(a++) ? (e.consume(F), a === ee.length ? r.interrupt ? t : Y : b) : n(F);
  }
  function x(F) {
    return Ai(F) ? (e.consume(F), s = String.fromCharCode(F), w) : n(F);
  }
  function w(F) {
    if (F === null || F === 47 || F === 62 || Tn(F)) {
      const ee = F === 47, ge = s.toLowerCase();
      return !ee && !o && vz.includes(ge) ? (i = 1, r.interrupt ? t(F) : Y(F)) : Ewe.includes(s.toLowerCase()) ? (i = 6, ee ? (e.consume(F), S) : r.interrupt ? t(F) : Y(F)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(F) : o ? _(F) : M(F));
    }
    return F === 45 || mi(F) ? (e.consume(F), s += String.fromCharCode(F), w) : n(F);
  }
  function S(F) {
    return F === 62 ? (e.consume(F), r.interrupt ? t : Y) : n(F);
  }
  function _(F) {
    return Gt(F) ? (e.consume(F), _) : B(F);
  }
  function M(F) {
    return F === 47 ? (e.consume(F), B) : F === 58 || F === 95 || Ai(F) ? (e.consume(F), N) : Gt(F) ? (e.consume(F), M) : B(F);
  }
  function N(F) {
    return F === 45 || F === 46 || F === 58 || F === 95 || mi(F) ? (e.consume(F), N) : P(F);
  }
  function P(F) {
    return F === 61 ? (e.consume(F), I) : Gt(F) ? (e.consume(F), P) : M(F);
  }
  function I(F) {
    return F === null || F === 60 || F === 61 || F === 62 || F === 96 ? n(F) : F === 34 || F === 39 ? (e.consume(F), c = F, O) : Gt(F) ? (e.consume(F), I) : L(F);
  }
  function O(F) {
    return F === c ? (e.consume(F), c = null, U) : F === null || yt(F) ? n(F) : (e.consume(F), O);
  }
  function L(F) {
    return F === null || F === 34 || F === 39 || F === 47 || F === 60 || F === 61 || F === 62 || F === 96 || Tn(F) ? P(F) : (e.consume(F), L);
  }
  function U(F) {
    return F === 47 || F === 62 || Gt(F) ? M(F) : n(F);
  }
  function B(F) {
    return F === 62 ? (e.consume(F), G) : n(F);
  }
  function G(F) {
    return F === null || yt(F) ? Y(F) : Gt(F) ? (e.consume(F), G) : n(F);
  }
  function Y(F) {
    return F === 45 && i === 2 ? (e.consume(F), H) : F === 60 && i === 1 ? (e.consume(F), Q) : F === 62 && i === 4 ? (e.consume(F), Z) : F === 63 && i === 3 ? (e.consume(F), W) : F === 93 && i === 5 ? (e.consume(F), Se) : yt(F) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(Twe, pe, he)(F)) : F === null || yt(F) ? (e.exit("htmlFlowData"), he(F)) : (e.consume(F), Y);
  }
  function he(F) {
    return e.check(Awe, ie, pe)(F);
  }
  function ie(F) {
    return e.enter("lineEnding"), e.consume(F), e.exit("lineEnding"), ne;
  }
  function ne(F) {
    return F === null || yt(F) ? he(F) : (e.enter("htmlFlowData"), Y(F));
  }
  function H(F) {
    return F === 45 ? (e.consume(F), W) : Y(F);
  }
  function Q(F) {
    return F === 47 ? (e.consume(F), s = "", X) : Y(F);
  }
  function X(F) {
    if (F === 62) {
      const ee = s.toLowerCase();
      return vz.includes(ee) ? (e.consume(F), Z) : Y(F);
    }
    return Ai(F) && s.length < 8 ? (e.consume(F), s += String.fromCharCode(F), X) : Y(F);
  }
  function Se(F) {
    return F === 93 ? (e.consume(F), W) : Y(F);
  }
  function W(F) {
    return F === 62 ? (e.consume(F), Z) : F === 45 && i === 2 ? (e.consume(F), W) : Y(F);
  }
  function Z(F) {
    return F === null || yt(F) ? (e.exit("htmlFlowData"), pe(F)) : (e.consume(F), Z);
  }
  function pe(F) {
    return e.exit("htmlFlow"), t(F);
  }
}
function Rwe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return yt(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o) : n(s);
  }
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function Owe(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(ry, t, n);
  }
}
const Dwe = {
  name: "htmlText",
  tokenize: Pwe
};
function Pwe(e, t, n) {
  const r = this;
  let i, o, s;
  return a;
  function a(W) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(W), c;
  }
  function c(W) {
    return W === 33 ? (e.consume(W), u) : W === 47 ? (e.consume(W), P) : W === 63 ? (e.consume(W), M) : Ai(W) ? (e.consume(W), L) : n(W);
  }
  function u(W) {
    return W === 45 ? (e.consume(W), f) : W === 91 ? (e.consume(W), o = 0, b) : Ai(W) ? (e.consume(W), _) : n(W);
  }
  function f(W) {
    return W === 45 ? (e.consume(W), g) : n(W);
  }
  function h(W) {
    return W === null ? n(W) : W === 45 ? (e.consume(W), m) : yt(W) ? (s = h, Q(W)) : (e.consume(W), h);
  }
  function m(W) {
    return W === 45 ? (e.consume(W), g) : h(W);
  }
  function g(W) {
    return W === 62 ? H(W) : W === 45 ? m(W) : h(W);
  }
  function b(W) {
    const Z = "CDATA[";
    return W === Z.charCodeAt(o++) ? (e.consume(W), o === Z.length ? x : b) : n(W);
  }
  function x(W) {
    return W === null ? n(W) : W === 93 ? (e.consume(W), w) : yt(W) ? (s = x, Q(W)) : (e.consume(W), x);
  }
  function w(W) {
    return W === 93 ? (e.consume(W), S) : x(W);
  }
  function S(W) {
    return W === 62 ? H(W) : W === 93 ? (e.consume(W), S) : x(W);
  }
  function _(W) {
    return W === null || W === 62 ? H(W) : yt(W) ? (s = _, Q(W)) : (e.consume(W), _);
  }
  function M(W) {
    return W === null ? n(W) : W === 63 ? (e.consume(W), N) : yt(W) ? (s = M, Q(W)) : (e.consume(W), M);
  }
  function N(W) {
    return W === 62 ? H(W) : M(W);
  }
  function P(W) {
    return Ai(W) ? (e.consume(W), I) : n(W);
  }
  function I(W) {
    return W === 45 || mi(W) ? (e.consume(W), I) : O(W);
  }
  function O(W) {
    return yt(W) ? (s = O, Q(W)) : Gt(W) ? (e.consume(W), O) : H(W);
  }
  function L(W) {
    return W === 45 || mi(W) ? (e.consume(W), L) : W === 47 || W === 62 || Tn(W) ? U(W) : n(W);
  }
  function U(W) {
    return W === 47 ? (e.consume(W), H) : W === 58 || W === 95 || Ai(W) ? (e.consume(W), B) : yt(W) ? (s = U, Q(W)) : Gt(W) ? (e.consume(W), U) : H(W);
  }
  function B(W) {
    return W === 45 || W === 46 || W === 58 || W === 95 || mi(W) ? (e.consume(W), B) : G(W);
  }
  function G(W) {
    return W === 61 ? (e.consume(W), Y) : yt(W) ? (s = G, Q(W)) : Gt(W) ? (e.consume(W), G) : U(W);
  }
  function Y(W) {
    return W === null || W === 60 || W === 61 || W === 62 || W === 96 ? n(W) : W === 34 || W === 39 ? (e.consume(W), i = W, he) : yt(W) ? (s = Y, Q(W)) : Gt(W) ? (e.consume(W), Y) : (e.consume(W), ie);
  }
  function he(W) {
    return W === i ? (e.consume(W), i = void 0, ne) : W === null ? n(W) : yt(W) ? (s = he, Q(W)) : (e.consume(W), he);
  }
  function ie(W) {
    return W === null || W === 34 || W === 39 || W === 60 || W === 61 || W === 96 ? n(W) : W === 47 || W === 62 || Tn(W) ? U(W) : (e.consume(W), ie);
  }
  function ne(W) {
    return W === 47 || W === 62 || Tn(W) ? U(W) : n(W);
  }
  function H(W) {
    return W === 62 ? (e.consume(W), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(W);
  }
  function Q(W) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(W), e.exit("lineEnding"), X;
  }
  function X(W) {
    return Gt(W) ? tn(e, Se, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(W) : Se(W);
  }
  function Se(W) {
    return e.enter("htmlTextData"), s(W);
  }
}
const HM = {
  name: "labelEnd",
  resolveAll: Lwe,
  resolveTo: Bwe,
  tokenize: $we
}, jwe = {
  tokenize: Uwe
}, Iwe = {
  tokenize: Fwe
}, zwe = {
  tokenize: Vwe
};
function Lwe(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += i;
    }
  }
  return e.length !== n.length && po(e, 0, e.length, n), e;
}
function Bwe(e, t) {
  let n = e.length, r = 0, i, o, s, a;
  for (; n--; )
    if (i = e[n][1], o) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (s) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (o = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (s = n);
  const c = {
    type: e[o][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[o][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, u = {
    type: "label",
    start: {
      ...e[o][1].start
    },
    end: {
      ...e[s][1].end
    }
  }, f = {
    type: "labelText",
    start: {
      ...e[o + r + 2][1].end
    },
    end: {
      ...e[s - 2][1].start
    }
  };
  return a = [["enter", c, t], ["enter", u, t]], a = Io(a, e.slice(o + 1, o + r + 3)), a = Io(a, [["enter", f, t]]), a = Io(a, Pw(t.parser.constructs.insideSpan.null, e.slice(o + r + 4, s - 3), t)), a = Io(a, [["exit", f, t], e[s - 2], e[s - 1], ["exit", u, t]]), a = Io(a, e.slice(s + 1)), a = Io(a, [["exit", c, t]]), po(e, o, e.length, a), e;
}
function $we(e, t, n) {
  const r = this;
  let i = r.events.length, o, s;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      o = r.events[i][1];
      break;
    }
  return a;
  function a(m) {
    return o ? o._inactive ? h(m) : (s = r.parser.defined.includes(us(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(m), e.exit("labelMarker"), e.exit("labelEnd"), c) : n(m);
  }
  function c(m) {
    return m === 40 ? e.attempt(jwe, f, s ? f : h)(m) : m === 91 ? e.attempt(Iwe, f, s ? u : h)(m) : s ? f(m) : h(m);
  }
  function u(m) {
    return e.attempt(zwe, f, h)(m);
  }
  function f(m) {
    return t(m);
  }
  function h(m) {
    return o._balanced = !0, n(m);
  }
}
function Uwe(e, t, n) {
  return r;
  function r(h) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), i;
  }
  function i(h) {
    return Tn(h) ? Om(e, o)(h) : o(h);
  }
  function o(h) {
    return h === 41 ? f(h) : cV(e, s, a, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function s(h) {
    return Tn(h) ? Om(e, c)(h) : f(h);
  }
  function a(h) {
    return n(h);
  }
  function c(h) {
    return h === 34 || h === 39 || h === 40 ? dV(e, u, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : f(h);
  }
  function u(h) {
    return Tn(h) ? Om(e, f)(h) : f(h);
  }
  function f(h) {
    return h === 41 ? (e.enter("resourceMarker"), e.consume(h), e.exit("resourceMarker"), e.exit("resource"), t) : n(h);
  }
}
function Fwe(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return uV.call(r, e, o, s, "reference", "referenceMarker", "referenceString")(a);
  }
  function o(a) {
    return r.parser.defined.includes(us(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(a) : n(a);
  }
  function s(a) {
    return n(a);
  }
}
function Vwe(e, t, n) {
  return r;
  function r(o) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), i;
  }
  function i(o) {
    return o === 93 ? (e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), e.exit("reference"), t) : n(o);
  }
}
const Hwe = {
  name: "labelStartImage",
  resolveAll: HM.resolveAll,
  tokenize: Wwe
};
function Wwe(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(a), e.exit("labelImageMarker"), o;
  }
  function o(a) {
    return a === 91 ? (e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelImage"), s) : n(a);
  }
  function s(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a);
  }
}
const qwe = {
  name: "labelStartLink",
  resolveAll: HM.resolveAll,
  tokenize: Gwe
};
function Gwe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), o;
  }
  function o(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const wC = {
  name: "lineEnding",
  tokenize: Kwe
};
function Kwe(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), tn(e, t, "linePrefix");
  }
}
const I0 = {
  name: "thematicBreak",
  tokenize: Zwe
};
function Zwe(e, t, n) {
  let r = 0, i;
  return o;
  function o(u) {
    return e.enter("thematicBreak"), s(u);
  }
  function s(u) {
    return i = u, a(u);
  }
  function a(u) {
    return u === i ? (e.enter("thematicBreakSequence"), c(u)) : r >= 3 && (u === null || yt(u)) ? (e.exit("thematicBreak"), t(u)) : n(u);
  }
  function c(u) {
    return u === i ? (e.consume(u), r++, c) : (e.exit("thematicBreakSequence"), Gt(u) ? tn(e, a, "whitespace")(u) : a(u));
  }
}
const Hi = {
  continuation: {
    tokenize: Qwe
  },
  exit: t1e,
  name: "list",
  tokenize: Jwe
}, Ywe = {
  partial: !0,
  tokenize: n1e
}, Xwe = {
  partial: !0,
  tokenize: e1e
};
function Jwe(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, s = 0;
  return a;
  function a(g) {
    const b = r.containerState.type || (g === 42 || g === 43 || g === 45 ? "listUnordered" : "listOrdered");
    if (b === "listUnordered" ? !r.containerState.marker || g === r.containerState.marker : V_(g)) {
      if (r.containerState.type || (r.containerState.type = b, e.enter(b, {
        _container: !0
      })), b === "listUnordered")
        return e.enter("listItemPrefix"), g === 42 || g === 45 ? e.check(I0, n, u)(g) : u(g);
      if (!r.interrupt || g === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), c(g);
    }
    return n(g);
  }
  function c(g) {
    return V_(g) && ++s < 10 ? (e.consume(g), c) : (!r.interrupt || s < 2) && (r.containerState.marker ? g === r.containerState.marker : g === 41 || g === 46) ? (e.exit("listItemValue"), u(g)) : n(g);
  }
  function u(g) {
    return e.enter("listItemMarker"), e.consume(g), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || g, e.check(
      ry,
      // Cant be empty when interrupting.
      r.interrupt ? n : f,
      e.attempt(Ywe, m, h)
    );
  }
  function f(g) {
    return r.containerState.initialBlankLine = !0, o++, m(g);
  }
  function h(g) {
    return Gt(g) ? (e.enter("listItemPrefixWhitespace"), e.consume(g), e.exit("listItemPrefixWhitespace"), m) : n(g);
  }
  function m(g) {
    return r.containerState.size = o + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(g);
  }
}
function Qwe(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(ry, i, o);
  function i(a) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, tn(e, t, "listItemIndent", r.containerState.size + 1)(a);
  }
  function o(a) {
    return r.containerState.furtherBlankLines || !Gt(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(Xwe, t, s)(a));
  }
  function s(a) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, tn(e, e.attempt(Hi, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a);
  }
}
function e1e(e, t, n) {
  const r = this;
  return tn(e, i, "listItemIndent", r.containerState.size + 1);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(o) : n(o);
  }
}
function t1e(e) {
  e.exit(this.containerState.type);
}
function n1e(e, t, n) {
  const r = this;
  return tn(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return !Gt(o) && s && s[1].type === "listItemPrefixWhitespace" ? t(o) : n(o);
  }
}
const bz = {
  name: "setextUnderline",
  resolveTo: r1e,
  tokenize: i1e
};
function r1e(e, t) {
  let n = e.length, r, i, o;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !o && e[n][1].type === "definition" && (o = n);
  const s = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[i][1].type = "setextHeadingText", o ? (e.splice(i, 0, ["enter", s, t]), e.splice(o + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[o][1].end
  }) : e[r][1] = s, e.push(["exit", s, t]), e;
}
function i1e(e, t, n) {
  const r = this;
  let i;
  return o;
  function o(u) {
    let f = r.events.length, h;
    for (; f--; )
      if (r.events[f][1].type !== "lineEnding" && r.events[f][1].type !== "linePrefix" && r.events[f][1].type !== "content") {
        h = r.events[f][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (e.enter("setextHeadingLine"), i = u, s(u)) : n(u);
  }
  function s(u) {
    return e.enter("setextHeadingLineSequence"), a(u);
  }
  function a(u) {
    return u === i ? (e.consume(u), a) : (e.exit("setextHeadingLineSequence"), Gt(u) ? tn(e, c, "lineSuffix")(u) : c(u));
  }
  function c(u) {
    return u === null || yt(u) ? (e.exit("setextHeadingLine"), t(u)) : n(u);
  }
}
const o1e = {
  tokenize: s1e
};
function s1e(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    ry,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, i, tn(e, e.attempt(this.parser.constructs.flow, i, e.attempt(dwe, i)), "linePrefix"))
  );
  return n;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(o), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const a1e = {
  resolveAll: hV()
}, l1e = fV("string"), c1e = fV("text");
function fV(e) {
  return {
    resolveAll: hV(e === "text" ? u1e : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], o = n.attempt(i, s, a);
    return s;
    function s(f) {
      return u(f) ? o(f) : a(f);
    }
    function a(f) {
      if (f === null) {
        n.consume(f);
        return;
      }
      return n.enter("data"), n.consume(f), c;
    }
    function c(f) {
      return u(f) ? (n.exit("data"), o(f)) : (n.consume(f), c);
    }
    function u(f) {
      if (f === null)
        return !0;
      const h = i[f];
      let m = -1;
      if (h)
        for (; ++m < h.length; ) {
          const g = h[m];
          if (!g.previous || g.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function hV(e) {
  return t;
  function t(n, r) {
    let i = -1, o;
    for (; ++i <= n.length; )
      o === void 0 ? n[i] && n[i][1].type === "data" && (o = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== o + 2 && (n[o][1].end = n[i - 1][1].end, n.splice(o + 2, i - o - 2), i = o + 2), o = void 0);
    return e ? e(n, r) : n;
  }
}
function u1e(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let o = i.length, s = -1, a = 0, c;
      for (; o--; ) {
        const u = i[o];
        if (typeof u == "string") {
          for (s = u.length; u.charCodeAt(s - 1) === 32; )
            a++, s--;
          if (s) break;
          s = -1;
        } else if (u === -2)
          c = !0, a++;
        else if (u !== -1) {
          o++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (a = 0), a) {
        const u = {
          type: n === e.length || c || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: o ? s : r.start._bufferIndex + s,
            _index: r.start._index + o,
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...u.start
        }, r.start.offset === r.end.offset ? Object.assign(r, u) : (e.splice(n, 0, ["enter", u, t], ["exit", u, t]), n += 2);
      }
      n++;
    }
  return e;
}
const d1e = {
  42: Hi,
  43: Hi,
  45: Hi,
  48: Hi,
  49: Hi,
  50: Hi,
  51: Hi,
  52: Hi,
  53: Hi,
  54: Hi,
  55: Hi,
  56: Hi,
  57: Hi,
  62: oV
}, f1e = {
  91: gwe
}, h1e = {
  [-2]: xC,
  [-1]: xC,
  32: xC
}, p1e = {
  35: Swe,
  42: I0,
  45: [bz, I0],
  60: _we,
  61: bz,
  95: I0,
  96: yz,
  126: yz
}, m1e = {
  38: aV,
  92: sV
}, g1e = {
  [-5]: wC,
  [-4]: wC,
  [-3]: wC,
  33: Hwe,
  38: aV,
  42: H_,
  60: [qxe, Dwe],
  91: qwe,
  92: [xwe, sV],
  93: HM,
  95: H_,
  96: owe
}, y1e = {
  null: [H_, a1e]
}, v1e = {
  null: [42, 95]
}, b1e = {
  null: []
}, x1e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: v1e,
  contentInitial: f1e,
  disable: b1e,
  document: d1e,
  flow: p1e,
  flowInitial: h1e,
  insideSpan: y1e,
  string: m1e,
  text: g1e
}, Symbol.toStringTag, { value: "Module" }));
function w1e(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const i = {}, o = [];
  let s = [], a = [];
  const c = {
    attempt: O(P),
    check: O(I),
    consume: _,
    enter: M,
    exit: N,
    interrupt: O(I, {
      interrupt: !0
    })
  }, u = {
    code: null,
    containerState: {},
    defineSkip: x,
    events: [],
    now: b,
    parser: e,
    previous: null,
    sliceSerialize: m,
    sliceStream: g,
    write: h
  };
  let f = t.tokenize.call(u, c);
  return t.resolveAll && o.push(t), u;
  function h(G) {
    return s = Io(s, G), w(), s[s.length - 1] !== null ? [] : (L(t, 0), u.events = Pw(o, u.events, u), u.events);
  }
  function m(G, Y) {
    return k1e(g(G), Y);
  }
  function g(G) {
    return S1e(s, G);
  }
  function b() {
    const {
      _bufferIndex: G,
      _index: Y,
      line: he,
      column: ie,
      offset: ne
    } = r;
    return {
      _bufferIndex: G,
      _index: Y,
      line: he,
      column: ie,
      offset: ne
    };
  }
  function x(G) {
    i[G.line] = G.column, B();
  }
  function w() {
    let G;
    for (; r._index < s.length; ) {
      const Y = s[r._index];
      if (typeof Y == "string")
        for (G = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === G && r._bufferIndex < Y.length; )
          S(Y.charCodeAt(r._bufferIndex));
      else
        S(Y);
    }
  }
  function S(G) {
    f = f(G);
  }
  function _(G) {
    yt(G) ? (r.line++, r.column = 1, r.offset += G === -3 ? 2 : 1, B()) : G !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    s[r._index].length && (r._bufferIndex = -1, r._index++)), u.previous = G;
  }
  function M(G, Y) {
    const he = Y || {};
    return he.type = G, he.start = b(), u.events.push(["enter", he, u]), a.push(he), he;
  }
  function N(G) {
    const Y = a.pop();
    return Y.end = b(), u.events.push(["exit", Y, u]), Y;
  }
  function P(G, Y) {
    L(G, Y.from);
  }
  function I(G, Y) {
    Y.restore();
  }
  function O(G, Y) {
    return he;
    function he(ie, ne, H) {
      let Q, X, Se, W;
      return Array.isArray(ie) ? (
        /* c8 ignore next 1 */
        pe(ie)
      ) : "tokenize" in ie ? (
        // Looks like a construct.
        pe([
          /** @type {Construct} */
          ie
        ])
      ) : Z(ie);
      function Z(re) {
        return J;
        function J(xe) {
          const be = xe !== null && re[xe], Ae = xe !== null && re.null, tt = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(be) ? be : be ? [be] : [],
            ...Array.isArray(Ae) ? Ae : Ae ? [Ae] : []
          ];
          return pe(tt)(xe);
        }
      }
      function pe(re) {
        return Q = re, X = 0, re.length === 0 ? H : F(re[X]);
      }
      function F(re) {
        return J;
        function J(xe) {
          return W = U(), Se = re, re.partial || (u.currentConstruct = re), re.name && u.parser.constructs.disable.null.includes(re.name) ? ge() : re.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            Y ? Object.assign(Object.create(u), Y) : u,
            c,
            ee,
            ge
          )(xe);
        }
      }
      function ee(re) {
        return G(Se, W), ne;
      }
      function ge(re) {
        return W.restore(), ++X < Q.length ? F(Q[X]) : H;
      }
    }
  }
  function L(G, Y) {
    G.resolveAll && !o.includes(G) && o.push(G), G.resolve && po(u.events, Y, u.events.length - Y, G.resolve(u.events.slice(Y), u)), G.resolveTo && (u.events = G.resolveTo(u.events, u));
  }
  function U() {
    const G = b(), Y = u.previous, he = u.currentConstruct, ie = u.events.length, ne = Array.from(a);
    return {
      from: ie,
      restore: H
    };
    function H() {
      r = G, u.previous = Y, u.currentConstruct = he, u.events.length = ie, a = ne, B();
    }
  }
  function B() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function S1e(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, o = t.end._bufferIndex;
  let s;
  if (n === i)
    s = [e[n].slice(r, o)];
  else {
    if (s = e.slice(n, i), r > -1) {
      const a = s[0];
      typeof a == "string" ? s[0] = a.slice(r) : s.shift();
    }
    o > 0 && s.push(e[i].slice(0, o));
  }
  return s;
}
function k1e(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const o = e[n];
    let s;
    if (typeof o == "string")
      s = o;
    else switch (o) {
      case -5: {
        s = "\r";
        break;
      }
      case -4: {
        s = `
`;
        break;
      }
      case -3: {
        s = `\r
`;
        break;
      }
      case -2: {
        s = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && i) continue;
        s = " ";
        break;
      }
      default:
        s = String.fromCharCode(o);
    }
    i = o === -2, r.push(s);
  }
  return r.join("");
}
function C1e(e) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      rV([x1e, ...(e || {}).extensions || []])
    ),
    content: i(Bxe),
    defined: [],
    document: i(Uxe),
    flow: i(o1e),
    lazy: {},
    string: i(l1e),
    text: i(c1e)
  };
  return r;
  function i(o) {
    return s;
    function s(a) {
      return w1e(r, o, a);
    }
  }
}
function E1e(e) {
  for (; !lV(e); )
    ;
  return e;
}
const xz = /[\0\t\n\r]/g;
function _1e() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(o, s, a) {
    const c = [];
    let u, f, h, m, g;
    for (o = t + (typeof o == "string" ? o.toString() : new TextDecoder(s || void 0).decode(o)), h = 0, t = "", n && (o.charCodeAt(0) === 65279 && h++, n = void 0); h < o.length; ) {
      if (xz.lastIndex = h, u = xz.exec(o), m = u && u.index !== void 0 ? u.index : o.length, g = o.charCodeAt(m), !u) {
        t = o.slice(h);
        break;
      }
      if (g === 10 && h === m && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), h < m && (c.push(o.slice(h, m)), e += m - h), g) {
          case 0: {
            c.push(65533), e++;
            break;
          }
          case 9: {
            for (f = Math.ceil(e / 4) * 4, c.push(-2); e++ < f; ) c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      h = m + 1;
    }
    return a && (r && c.push(-5), t && c.push(t), c.push(null)), c;
  }
}
const T1e = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function A1e(e) {
  return e.replace(T1e, M1e);
}
function M1e(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), o = i === 120 || i === 88;
    return iV(n.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return VM(n) || e;
}
const pV = {}.hasOwnProperty;
function N1e(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), R1e(n)(E1e(C1e(n).document().write(_1e()(e, t, !0))));
}
function R1e(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: o(Kt),
      autolinkProtocol: U,
      autolinkEmail: U,
      atxHeading: o(yn),
      blockQuote: o(Ae),
      characterEscape: U,
      characterReference: U,
      codeFenced: o(tt),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: o(tt, s),
      codeText: o(Ge, s),
      codeTextData: U,
      data: U,
      codeFlowValue: U,
      definition: o(nt),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: o(_t),
      hardBreakEscape: o(St),
      hardBreakTrailing: o(St),
      htmlFlow: o(Vt, s),
      htmlFlowData: U,
      htmlText: o(Vt, s),
      htmlTextData: U,
      image: o(xt),
      label: s,
      link: o(Kt),
      listItem: o(Nt),
      listItemValue: m,
      listOrdered: o(An, h),
      listUnordered: o(An),
      paragraph: o(sn),
      reference: F,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: o(yn),
      strong: o(Pn),
      thematicBreak: o(mt)
    },
    exit: {
      atxHeading: c(),
      atxHeadingSequence: P,
      autolink: c(),
      autolinkEmail: be,
      autolinkProtocol: xe,
      blockQuote: c(),
      characterEscapeValue: B,
      characterReferenceMarkerHexadecimal: ge,
      characterReferenceMarkerNumeric: ge,
      characterReferenceValue: re,
      characterReference: J,
      codeFenced: c(w),
      codeFencedFence: x,
      codeFencedFenceInfo: g,
      codeFencedFenceMeta: b,
      codeFlowValue: B,
      codeIndented: c(S),
      codeText: c(ne),
      codeTextData: B,
      data: B,
      definition: c(),
      definitionDestinationString: N,
      definitionLabelString: _,
      definitionTitleString: M,
      emphasis: c(),
      hardBreakEscape: c(Y),
      hardBreakTrailing: c(Y),
      htmlFlow: c(he),
      htmlFlowData: B,
      htmlText: c(ie),
      htmlTextData: B,
      image: c(Q),
      label: Se,
      labelText: X,
      lineEnding: G,
      link: c(H),
      listItem: c(),
      listOrdered: c(),
      listUnordered: c(),
      paragraph: c(),
      referenceString: ee,
      resourceDestinationString: W,
      resourceTitleString: Z,
      resource: pe,
      setextHeading: c(L),
      setextHeadingLineSequence: O,
      setextHeadingText: I,
      strong: c(),
      thematicBreak: c()
    }
  };
  mV(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(ke) {
    let Pe = {
      type: "root",
      children: []
    };
    const He = {
      stack: [Pe],
      tokenStack: [],
      config: t,
      enter: a,
      exit: u,
      buffer: s,
      resume: f,
      data: n
    }, et = [];
    let bt = -1;
    for (; ++bt < ke.length; )
      if (ke[bt][1].type === "listOrdered" || ke[bt][1].type === "listUnordered")
        if (ke[bt][0] === "enter")
          et.push(bt);
        else {
          const Ct = et.pop();
          bt = i(ke, Ct, bt);
        }
    for (bt = -1; ++bt < ke.length; ) {
      const Ct = t[ke[bt][0]];
      pV.call(Ct, ke[bt][1].type) && Ct[ke[bt][1].type].call(Object.assign({
        sliceSerialize: ke[bt][2].sliceSerialize
      }, He), ke[bt][1]);
    }
    if (He.tokenStack.length > 0) {
      const Ct = He.tokenStack[He.tokenStack.length - 1];
      (Ct[1] || wz).call(He, void 0, Ct[0]);
    }
    for (Pe.position = {
      start: Vl(ke.length > 0 ? ke[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Vl(ke.length > 0 ? ke[ke.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, bt = -1; ++bt < t.transforms.length; )
      Pe = t.transforms[bt](Pe) || Pe;
    return Pe;
  }
  function i(ke, Pe, He) {
    let et = Pe - 1, bt = -1, Ct = !1, fn, Lt, nn, jn;
    for (; ++et <= He; ) {
      const Ve = ke[et];
      switch (Ve[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Ve[0] === "enter" ? bt++ : bt--, jn = void 0;
          break;
        }
        case "lineEndingBlank": {
          Ve[0] === "enter" && (fn && !jn && !bt && !nn && (nn = et), jn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          jn = void 0;
      }
      if (!bt && Ve[0] === "enter" && Ve[1].type === "listItemPrefix" || bt === -1 && Ve[0] === "exit" && (Ve[1].type === "listUnordered" || Ve[1].type === "listOrdered")) {
        if (fn) {
          let Ii = et;
          for (Lt = void 0; Ii--; ) {
            const Ar = ke[Ii];
            if (Ar[1].type === "lineEnding" || Ar[1].type === "lineEndingBlank") {
              if (Ar[0] === "exit") continue;
              Lt && (ke[Lt][1].type = "lineEndingBlank", Ct = !0), Ar[1].type = "lineEnding", Lt = Ii;
            } else if (!(Ar[1].type === "linePrefix" || Ar[1].type === "blockQuotePrefix" || Ar[1].type === "blockQuotePrefixWhitespace" || Ar[1].type === "blockQuoteMarker" || Ar[1].type === "listItemIndent")) break;
          }
          nn && (!Lt || nn < Lt) && (fn._spread = !0), fn.end = Object.assign({}, Lt ? ke[Lt][1].start : Ve[1].end), ke.splice(Lt || et, 0, ["exit", fn, Ve[2]]), et++, He++;
        }
        if (Ve[1].type === "listItemPrefix") {
          const Ii = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Ve[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          fn = Ii, ke.splice(et, 0, ["enter", Ii, Ve[2]]), et++, He++, nn = void 0, jn = !0;
        }
      }
    }
    return ke[Pe][1]._spread = Ct, He;
  }
  function o(ke, Pe) {
    return He;
    function He(et) {
      a.call(this, ke(et), et), Pe && Pe.call(this, et);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function a(ke, Pe, He) {
    this.stack[this.stack.length - 1].children.push(ke), this.stack.push(ke), this.tokenStack.push([Pe, He || void 0]), ke.position = {
      start: Vl(Pe.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function c(ke) {
    return Pe;
    function Pe(He) {
      ke && ke.call(this, He), u.call(this, He);
    }
  }
  function u(ke, Pe) {
    const He = this.stack.pop(), et = this.tokenStack.pop();
    if (et)
      et[0].type !== ke.type && (Pe ? Pe.call(this, ke, et[0]) : (et[1] || wz).call(this, ke, et[0]));
    else throw new Error("Cannot close `" + ke.type + "` (" + Rm({
      start: ke.start,
      end: ke.end
    }) + "): its not open");
    He.position.end = Vl(ke.end);
  }
  function f() {
    return FM(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function m(ke) {
    if (this.data.expectingFirstListItemValue) {
      const Pe = this.stack[this.stack.length - 2];
      Pe.start = Number.parseInt(this.sliceSerialize(ke), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function g() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.lang = ke;
  }
  function b() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.meta = ke;
  }
  function x() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function w() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.value = ke.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function S() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.value = ke.replace(/(\r?\n|\r)$/g, "");
  }
  function _(ke) {
    const Pe = this.resume(), He = this.stack[this.stack.length - 1];
    He.label = Pe, He.identifier = us(this.sliceSerialize(ke)).toLowerCase();
  }
  function M() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.title = ke;
  }
  function N() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.url = ke;
  }
  function P(ke) {
    const Pe = this.stack[this.stack.length - 1];
    if (!Pe.depth) {
      const He = this.sliceSerialize(ke).length;
      Pe.depth = He;
    }
  }
  function I() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function O(ke) {
    const Pe = this.stack[this.stack.length - 1];
    Pe.depth = this.sliceSerialize(ke).codePointAt(0) === 61 ? 1 : 2;
  }
  function L() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function U(ke) {
    const He = this.stack[this.stack.length - 1].children;
    let et = He[He.length - 1];
    (!et || et.type !== "text") && (et = Mn(), et.position = {
      start: Vl(ke.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, He.push(et)), this.stack.push(et);
  }
  function B(ke) {
    const Pe = this.stack.pop();
    Pe.value += this.sliceSerialize(ke), Pe.position.end = Vl(ke.end);
  }
  function G(ke) {
    const Pe = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const He = Pe.children[Pe.children.length - 1];
      He.position.end = Vl(ke.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(Pe.type) && (U.call(this, ke), B.call(this, ke));
  }
  function Y() {
    this.data.atHardBreak = !0;
  }
  function he() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.value = ke;
  }
  function ie() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.value = ke;
  }
  function ne() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.value = ke;
  }
  function H() {
    const ke = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Pe = this.data.referenceType || "shortcut";
      ke.type += "Reference", ke.referenceType = Pe, delete ke.url, delete ke.title;
    } else
      delete ke.identifier, delete ke.label;
    this.data.referenceType = void 0;
  }
  function Q() {
    const ke = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Pe = this.data.referenceType || "shortcut";
      ke.type += "Reference", ke.referenceType = Pe, delete ke.url, delete ke.title;
    } else
      delete ke.identifier, delete ke.label;
    this.data.referenceType = void 0;
  }
  function X(ke) {
    const Pe = this.sliceSerialize(ke), He = this.stack[this.stack.length - 2];
    He.label = A1e(Pe), He.identifier = us(Pe).toLowerCase();
  }
  function Se() {
    const ke = this.stack[this.stack.length - 1], Pe = this.resume(), He = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, He.type === "link") {
      const et = ke.children;
      He.children = et;
    } else
      He.alt = Pe;
  }
  function W() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.url = ke;
  }
  function Z() {
    const ke = this.resume(), Pe = this.stack[this.stack.length - 1];
    Pe.title = ke;
  }
  function pe() {
    this.data.inReference = void 0;
  }
  function F() {
    this.data.referenceType = "collapsed";
  }
  function ee(ke) {
    const Pe = this.resume(), He = this.stack[this.stack.length - 1];
    He.label = Pe, He.identifier = us(this.sliceSerialize(ke)).toLowerCase(), this.data.referenceType = "full";
  }
  function ge(ke) {
    this.data.characterReferenceType = ke.type;
  }
  function re(ke) {
    const Pe = this.sliceSerialize(ke), He = this.data.characterReferenceType;
    let et;
    He ? (et = iV(Pe, He === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : et = VM(Pe);
    const bt = this.stack[this.stack.length - 1];
    bt.value += et;
  }
  function J(ke) {
    const Pe = this.stack.pop();
    Pe.position.end = Vl(ke.end);
  }
  function xe(ke) {
    B.call(this, ke);
    const Pe = this.stack[this.stack.length - 1];
    Pe.url = this.sliceSerialize(ke);
  }
  function be(ke) {
    B.call(this, ke);
    const Pe = this.stack[this.stack.length - 1];
    Pe.url = "mailto:" + this.sliceSerialize(ke);
  }
  function Ae() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function tt() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Ge() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function nt() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function _t() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function yn() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function St() {
    return {
      type: "break"
    };
  }
  function Vt() {
    return {
      type: "html",
      value: ""
    };
  }
  function xt() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Kt() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function An(ke) {
    return {
      type: "list",
      ordered: ke.type === "listOrdered",
      start: null,
      spread: ke._spread,
      children: []
    };
  }
  function Nt(ke) {
    return {
      type: "listItem",
      spread: ke._spread,
      checked: null,
      children: []
    };
  }
  function sn() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Pn() {
    return {
      type: "strong",
      children: []
    };
  }
  function Mn() {
    return {
      type: "text",
      value: ""
    };
  }
  function mt() {
    return {
      type: "thematicBreak"
    };
  }
}
function Vl(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function mV(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? mV(e, r) : O1e(e, r);
  }
}
function O1e(e, t) {
  let n;
  for (n in t)
    if (pV.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function wz(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Rm({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Rm({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Rm({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function D1e(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return N1e(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function P1e(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function j1e(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function I1e(e, t) {
  const n = t.value ? t.value + `
` : "", r = {}, i = t.lang ? t.lang.split(/\s+/) : [];
  i.length > 0 && (r.className = ["language-" + i[0]]);
  let o = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (o.data = { meta: t.meta }), e.patch(t, o), o = e.applyData(t, o), o = { type: "element", tagName: "pre", properties: {}, children: [o] }, e.patch(t, o), o;
}
function z1e(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function L1e(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function B1e(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = Fh(r.toLowerCase()), o = e.footnoteOrder.indexOf(r);
  let s, a = e.footnoteCounts.get(r);
  a === void 0 ? (a = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = o + 1, a += 1, e.footnoteCounts.set(r, a);
  const c = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (a > 1 ? "-" + a : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  e.patch(t, c);
  const u = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [c]
  };
  return e.patch(t, u), e.applyData(t, u);
}
function $1e(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function U1e(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function gV(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), o = i[0];
  o && o.type === "text" ? o.value = "[" + o.value : i.unshift({ type: "text", value: "[" });
  const s = i[i.length - 1];
  return s && s.type === "text" ? s.value += r : i.push({ type: "text", value: r }), i;
}
function F1e(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return gV(e, t);
  const i = { src: Fh(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const o = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, o), e.applyData(t, o);
}
function V1e(e, t) {
  const n = { src: Fh(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function H1e(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function W1e(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return gV(e, t);
  const i = { href: Fh(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const o = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function q1e(e, t) {
  const n = { href: Fh(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function G1e(e, t, n) {
  const r = e.all(t), i = n ? K1e(n) : yV(t), o = {}, s = [];
  if (typeof t.checked == "boolean") {
    const f = r[0];
    let h;
    f && f.type === "element" && f.tagName === "p" ? h = f : (h = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(h)), h.children.length > 0 && h.children.unshift({ type: "text", value: " " }), h.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), o.className = ["task-list-item"];
  }
  let a = -1;
  for (; ++a < r.length; ) {
    const f = r[a];
    (i || a !== 0 || f.type !== "element" || f.tagName !== "p") && s.push({ type: "text", value: `
` }), f.type === "element" && f.tagName === "p" && !i ? s.push(...f.children) : s.push(f);
  }
  const c = r[r.length - 1];
  c && (i || c.type !== "element" || c.tagName !== "p") && s.push({ type: "text", value: `
` });
  const u = { type: "element", tagName: "li", properties: o, children: s };
  return e.patch(t, u), e.applyData(t, u);
}
function K1e(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = yV(n[r]);
  }
  return t;
}
function yV(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function Z1e(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const s = r[i];
    if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const o = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function Y1e(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function X1e(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function J1e(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Q1e(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const s = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], s), i.push(s);
  }
  if (n.length > 0) {
    const s = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, a = LM(t.children[1]), c = ZF(t.children[t.children.length - 1]);
    a && c && (s.position = { start: a, end: c }), i.push(s);
  }
  const o = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function eSe(e, t, n) {
  const r = n ? n.children : void 0, o = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, a = s ? s.length : t.children.length;
  let c = -1;
  const u = [];
  for (; ++c < a; ) {
    const h = t.children[c], m = {}, g = s ? s[c] : void 0;
    g && (m.align = g);
    let b = { type: "element", tagName: o, properties: m, children: [] };
    h && (b.children = e.all(h), e.patch(h, b), b = e.applyData(h, b)), u.push(b);
  }
  const f = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, f), e.applyData(t, f);
}
function tSe(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Sz = 9, kz = 32;
function nSe(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const o = [];
  for (; r; )
    o.push(
      Cz(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return o.push(Cz(t.slice(i), i > 0, !1)), o.join("");
}
function Cz(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let o = e.codePointAt(r);
    for (; o === Sz || o === kz; )
      r++, o = e.codePointAt(r);
  }
  if (n) {
    let o = e.codePointAt(i - 1);
    for (; o === Sz || o === kz; )
      i--, o = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function rSe(e, t) {
  const n = { type: "text", value: nSe(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function iSe(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const oSe = {
  blockquote: P1e,
  break: j1e,
  code: I1e,
  delete: z1e,
  emphasis: L1e,
  footnoteReference: B1e,
  heading: $1e,
  html: U1e,
  imageReference: F1e,
  image: V1e,
  inlineCode: H1e,
  linkReference: W1e,
  link: q1e,
  listItem: G1e,
  list: Z1e,
  paragraph: Y1e,
  // @ts-expect-error: root is different, but hard to type.
  root: X1e,
  strong: J1e,
  table: Q1e,
  tableCell: tSe,
  tableRow: eSe,
  text: rSe,
  thematicBreak: iSe,
  toml: Vv,
  yaml: Vv,
  definition: Vv,
  footnoteDefinition: Vv
};
function Vv() {
}
const vV = -1, jw = 0, Dm = 1, zb = 2, WM = 3, qM = 4, GM = 5, KM = 6, bV = 7, xV = 8, Ez = typeof self == "object" ? self : globalThis, sSe = (e, t) => {
  const n = (i, o) => (e.set(o, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [o, s] = t[i];
    switch (o) {
      case jw:
      case vV:
        return n(s, i);
      case Dm: {
        const a = n([], i);
        for (const c of s)
          a.push(r(c));
        return a;
      }
      case zb: {
        const a = n({}, i);
        for (const [c, u] of s)
          a[r(c)] = r(u);
        return a;
      }
      case WM:
        return n(new Date(s), i);
      case qM: {
        const { source: a, flags: c } = s;
        return n(new RegExp(a, c), i);
      }
      case GM: {
        const a = n(/* @__PURE__ */ new Map(), i);
        for (const [c, u] of s)
          a.set(r(c), r(u));
        return a;
      }
      case KM: {
        const a = n(/* @__PURE__ */ new Set(), i);
        for (const c of s)
          a.add(r(c));
        return a;
      }
      case bV: {
        const { name: a, message: c } = s;
        return n(new Ez[a](c), i);
      }
      case xV:
        return n(BigInt(s), i);
      case "BigInt":
        return n(Object(BigInt(s)), i);
      case "ArrayBuffer":
        return n(new Uint8Array(s).buffer, s);
      case "DataView": {
        const { buffer: a } = new Uint8Array(s);
        return n(new DataView(a), s);
      }
    }
    return n(new Ez[o](s), i);
  };
  return r;
}, _z = (e) => sSe(/* @__PURE__ */ new Map(), e)(0), gf = "", { toString: aSe } = {}, { keys: lSe } = Object, Qp = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [jw, t];
  const n = aSe.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Dm, gf];
    case "Object":
      return [zb, gf];
    case "Date":
      return [WM, gf];
    case "RegExp":
      return [qM, gf];
    case "Map":
      return [GM, gf];
    case "Set":
      return [KM, gf];
    case "DataView":
      return [Dm, n];
  }
  return n.includes("Array") ? [Dm, n] : n.includes("Error") ? [bV, n] : [zb, n];
}, Hv = ([e, t]) => e === jw && (t === "function" || t === "symbol"), cSe = (e, t, n, r) => {
  const i = (s, a) => {
    const c = r.push(s) - 1;
    return n.set(a, c), c;
  }, o = (s) => {
    if (n.has(s))
      return n.get(s);
    let [a, c] = Qp(s);
    switch (a) {
      case jw: {
        let f = s;
        switch (c) {
          case "bigint":
            a = xV, f = s.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + c);
            f = null;
            break;
          case "undefined":
            return i([vV], s);
        }
        return i([a, f], s);
      }
      case Dm: {
        if (c) {
          let m = s;
          return c === "DataView" ? m = new Uint8Array(s.buffer) : c === "ArrayBuffer" && (m = new Uint8Array(s)), i([c, [...m]], s);
        }
        const f = [], h = i([a, f], s);
        for (const m of s)
          f.push(o(m));
        return h;
      }
      case zb: {
        if (c)
          switch (c) {
            case "BigInt":
              return i([c, s.toString()], s);
            case "Boolean":
            case "Number":
            case "String":
              return i([c, s.valueOf()], s);
          }
        if (t && "toJSON" in s)
          return o(s.toJSON());
        const f = [], h = i([a, f], s);
        for (const m of lSe(s))
          (e || !Hv(Qp(s[m]))) && f.push([o(m), o(s[m])]);
        return h;
      }
      case WM:
        return i([a, s.toISOString()], s);
      case qM: {
        const { source: f, flags: h } = s;
        return i([a, { source: f, flags: h }], s);
      }
      case GM: {
        const f = [], h = i([a, f], s);
        for (const [m, g] of s)
          (e || !(Hv(Qp(m)) || Hv(Qp(g)))) && f.push([o(m), o(g)]);
        return h;
      }
      case KM: {
        const f = [], h = i([a, f], s);
        for (const m of s)
          (e || !Hv(Qp(m))) && f.push(o(m));
        return h;
      }
    }
    const { message: u } = s;
    return i([a, { name: c, message: u }], s);
  };
  return o;
}, Tz = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return cSe(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Lb = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? _z(Tz(e, t)) : structuredClone(e)
) : (e, t) => _z(Tz(e, t));
function uSe(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function dSe(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function fSe(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || uSe, r = e.options.footnoteBackLabel || dSe, i = e.options.footnoteLabel || "Footnotes", o = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, a = [];
  let c = -1;
  for (; ++c < e.footnoteOrder.length; ) {
    const u = e.footnoteById.get(
      e.footnoteOrder[c]
    );
    if (!u)
      continue;
    const f = e.all(u), h = String(u.identifier).toUpperCase(), m = Fh(h.toLowerCase());
    let g = 0;
    const b = [], x = e.footnoteCounts.get(h);
    for (; x !== void 0 && ++g <= x; ) {
      b.length > 0 && b.push({ type: "text", value: " " });
      let _ = typeof n == "string" ? n : n(c, g);
      typeof _ == "string" && (_ = { type: "text", value: _ }), b.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + m + (g > 1 ? "-" + g : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(c, g),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(_) ? _ : [_]
      });
    }
    const w = f[f.length - 1];
    if (w && w.type === "element" && w.tagName === "p") {
      const _ = w.children[w.children.length - 1];
      _ && _.type === "text" ? _.value += " " : w.children.push({ type: "text", value: " " }), w.children.push(...b);
    } else
      f.push(...b);
    const S = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + m },
      children: e.wrap(f, !0)
    };
    e.patch(u, S), a.push(S);
  }
  if (a.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: o,
          properties: {
            ...Lb(s),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(a, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Iw = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(e) {
    if (e == null)
      return gSe;
    if (typeof e == "function")
      return zw(e);
    if (typeof e == "object")
      return Array.isArray(e) ? hSe(e) : (
        // Cast because `ReadonlyArray` goes into the above but `isArray`
        // narrows to `Array`.
        pSe(
          /** @type {Props} */
          e
        )
      );
    if (typeof e == "string")
      return mSe(e);
    throw new Error("Expected function, string, or object as test");
  })
);
function hSe(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Iw(e[n]);
  return zw(r);
  function r(...i) {
    let o = -1;
    for (; ++o < t.length; )
      if (t[o].apply(this, i)) return !0;
    return !1;
  }
}
function pSe(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return zw(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let o;
    for (o in e)
      if (i[o] !== t[o]) return !1;
    return !0;
  }
}
function mSe(e) {
  return zw(t);
  function t(n) {
    return n && n.type === e;
  }
}
function zw(e) {
  return t;
  function t(n, r, i) {
    return !!(ySe(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function gSe() {
  return !0;
}
function ySe(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const wV = [], vSe = !0, W_ = !1, bSe = "skip";
function SV(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const o = Iw(i), s = r ? -1 : 1;
  a(e, void 0, [])();
  function a(c, u, f) {
    const h = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof h.type == "string") {
      const g = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(m, "name", {
        value: "node (" + (c.type + (g ? "<" + g + ">" : "")) + ")"
      });
    }
    return m;
    function m() {
      let g = wV, b, x, w;
      if ((!t || o(c, u, f[f.length - 1] || void 0)) && (g = xSe(n(c, f)), g[0] === W_))
        return g;
      if ("children" in c && c.children) {
        const S = (
          /** @type {UnistParent} */
          c
        );
        if (S.children && g[0] !== bSe)
          for (x = (r ? S.children.length : -1) + s, w = f.concat(S); x > -1 && x < S.children.length; ) {
            const _ = S.children[x];
            if (b = a(_, x, w)(), b[0] === W_)
              return b;
            x = typeof b[1] == "number" ? b[1] : x + s;
          }
      }
      return g;
    }
  }
}
function xSe(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [vSe, e] : e == null ? wV : [e];
}
function ZM(e, t, n, r) {
  let i, o, s;
  typeof t == "function" && typeof n != "function" ? (o = void 0, s = t, i = n) : (o = t, s = n, i = r), SV(e, o, a, i);
  function a(c, u) {
    const f = u[u.length - 1], h = f ? f.children.indexOf(c) : void 0;
    return s(c, h, f);
  }
}
const q_ = {}.hasOwnProperty, wSe = {};
function SSe(e, t) {
  const n = t || wSe, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), s = { ...oSe, ...n.handlers }, a = {
    all: u,
    applyData: CSe,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: o,
    footnoteOrder: [],
    handlers: s,
    one: c,
    options: n,
    patch: kSe,
    wrap: _Se
  };
  return ZM(e, function(f) {
    if (f.type === "definition" || f.type === "footnoteDefinition") {
      const h = f.type === "definition" ? r : i, m = String(f.identifier).toUpperCase();
      h.has(m) || h.set(m, f);
    }
  }), a;
  function c(f, h) {
    const m = f.type, g = a.handlers[m];
    if (q_.call(a.handlers, m) && g)
      return g(a, f, h);
    if (a.options.passThrough && a.options.passThrough.includes(m)) {
      if ("children" in f) {
        const { children: x, ...w } = f, S = Lb(w);
        return S.children = a.all(f), S;
      }
      return Lb(f);
    }
    return (a.options.unknownHandler || ESe)(a, f, h);
  }
  function u(f) {
    const h = [];
    if ("children" in f) {
      const m = f.children;
      let g = -1;
      for (; ++g < m.length; ) {
        const b = a.one(m[g], f);
        if (b) {
          if (g && m[g - 1].type === "break" && (!Array.isArray(b) && b.type === "text" && (b.value = Az(b.value)), !Array.isArray(b) && b.type === "element")) {
            const x = b.children[0];
            x && x.type === "text" && (x.value = Az(x.value));
          }
          Array.isArray(b) ? h.push(...b) : h.push(b);
        }
      }
    }
    return h;
  }
}
function kSe(e, t) {
  e.position && (t.position = fxe(e));
}
function CSe(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, o = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const s = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: s };
      }
    n.type === "element" && o && Object.assign(n.properties, Lb(o)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function ESe(e, t) {
  const n = t.data || {}, r = "value" in t && !(q_.call(n, "hProperties") || q_.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function _Se(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Az(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function Mz(e, t) {
  const n = SSe(e, t), r = n.one(e, void 0), i = fSe(n), o = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && o.children.push({ type: "text", value: `
` }, i), o;
}
function TSe(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      Mz(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      Mz(n, { file: r, ...e || t })
    );
  };
}
function Nz(e) {
  if (e)
    throw e;
}
var SC, Rz;
function ASe() {
  if (Rz) return SC;
  Rz = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = function(u) {
    return typeof Array.isArray == "function" ? Array.isArray(u) : t.call(u) === "[object Array]";
  }, o = function(u) {
    if (!u || t.call(u) !== "[object Object]")
      return !1;
    var f = e.call(u, "constructor"), h = u.constructor && u.constructor.prototype && e.call(u.constructor.prototype, "isPrototypeOf");
    if (u.constructor && !f && !h)
      return !1;
    var m;
    for (m in u)
      ;
    return typeof m > "u" || e.call(u, m);
  }, s = function(u, f) {
    n && f.name === "__proto__" ? n(u, f.name, {
      enumerable: !0,
      configurable: !0,
      value: f.newValue,
      writable: !0
    }) : u[f.name] = f.newValue;
  }, a = function(u, f) {
    if (f === "__proto__")
      if (e.call(u, f)) {
        if (r)
          return r(u, f).value;
      } else return;
    return u[f];
  };
  return SC = function c() {
    var u, f, h, m, g, b, x = arguments[0], w = 1, S = arguments.length, _ = !1;
    for (typeof x == "boolean" && (_ = x, x = arguments[1] || {}, w = 2), (x == null || typeof x != "object" && typeof x != "function") && (x = {}); w < S; ++w)
      if (u = arguments[w], u != null)
        for (f in u)
          h = a(x, f), m = a(u, f), x !== m && (_ && m && (o(m) || (g = i(m))) ? (g ? (g = !1, b = h && i(h) ? h : []) : b = h && o(h) ? h : {}, s(x, { name: f, newValue: c(_, b, m) })) : typeof m < "u" && s(x, { name: f, newValue: m }));
    return x;
  }, SC;
}
var MSe = ASe();
const kC = /* @__PURE__ */ Dc(MSe);
function G_(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function NSe() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let o = -1;
    const s = i.pop();
    if (typeof s != "function")
      throw new TypeError("Expected function as last argument, not " + s);
    a(null, ...i);
    function a(c, ...u) {
      const f = e[++o];
      let h = -1;
      if (c) {
        s(c);
        return;
      }
      for (; ++h < i.length; )
        (u[h] === null || u[h] === void 0) && (u[h] = i[h]);
      i = u, f ? RSe(f, a)(...u) : s(null, ...u);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function RSe(e, t) {
  let n;
  return r;
  function r(...s) {
    const a = e.length > s.length;
    let c;
    a && s.push(i);
    try {
      c = e.apply(this, s);
    } catch (u) {
      const f = (
        /** @type {Error} */
        u
      );
      if (a && n)
        throw f;
      return i(f);
    }
    a || (c && c.then && typeof c.then == "function" ? c.then(o, i) : c instanceof Error ? i(c) : o(c));
  }
  function i(s, ...a) {
    n || (n = !0, t(s, ...a));
  }
  function o(s) {
    i(null, s);
  }
}
const Is = { basename: OSe, dirname: DSe, extname: PSe, join: jSe, sep: "/" };
function OSe(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  iy(e);
  let n = 0, r = -1, i = e.length, o;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (o) {
          n = i + 1;
          break;
        }
      } else r < 0 && (o = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let s = -1, a = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (o) {
        n = i + 1;
        break;
      }
    } else
      s < 0 && (o = !0, s = i + 1), a > -1 && (e.codePointAt(i) === t.codePointAt(a--) ? a < 0 && (r = i) : (a = -1, r = s));
  return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r);
}
function DSe(e) {
  if (iy(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function PSe(e) {
  iy(e);
  let t = e.length, n = -1, r = 0, i = -1, o = 0, s;
  for (; t--; ) {
    const a = e.codePointAt(t);
    if (a === 47) {
      if (s) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (s = !0, n = t + 1), a === 46 ? i < 0 ? i = t : o !== 1 && (o = 1) : i > -1 && (o = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  o === 0 || // The (right-most) trimmed path component is exactly `..`.
  o === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function jSe(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    iy(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : ISe(n);
}
function ISe(e) {
  iy(e);
  const t = e.codePointAt(0) === 47;
  let n = zSe(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function zSe(e, t) {
  let n = "", r = 0, i = -1, o = 0, s = -1, a, c;
  for (; ++s <= e.length; ) {
    if (s < e.length)
      a = e.codePointAt(s);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(i === s - 1 || o === 1)) if (i !== s - 1 && o === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (c = n.lastIndexOf("/"), c !== n.length - 1) {
              c < 0 ? (n = "", r = 0) : (n = n.slice(0, c), r = n.length - 1 - n.lastIndexOf("/")), i = s, o = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = s, o = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(i + 1, s) : n = e.slice(i + 1, s), r = s - i - 1;
      i = s, o = 0;
    } else a === 46 && o > -1 ? o++ : o = -1;
  }
  return n;
}
function iy(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const LSe = { cwd: BSe };
function BSe() {
  return "/";
}
function K_(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function $Se(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!K_(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return USe(e);
}
function USe(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const CC = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class kV {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? K_(t) ? n = { path: t } : typeof t == "string" || FSe(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : LSe.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < CC.length; ) {
      const o = CC[r];
      o in n && n[o] !== void 0 && n[o] !== null && (this[o] = o === "history" ? [...n[o]] : n[o]);
    }
    let i;
    for (i in n)
      CC.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Is.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    _C(t, "basename"), EC(t, "basename"), this.path = Is.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Is.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Oz(this.basename, "dirname"), this.path = Is.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Is.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (EC(t, "extname"), Oz(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Is.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    K_(t) && (t = $Se(t)), _C(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Is.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    _C(t, "stem"), EC(t, "stem"), this.path = Is.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new bi(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function EC(e, t) {
  if (e && e.includes(Is.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Is.sep + "`"
    );
}
function _C(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Oz(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function FSe(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const VSe = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], o = function() {
      return i.apply(o, arguments);
    };
    return Object.setPrototypeOf(o, r), o;
  })
), HSe = {}.hasOwnProperty;
class YM extends VSe {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = NSe();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new YM()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(kC(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (MC("data", this.frozen), this.namespace[t] = n, this) : HSe.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (MC("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Wv(t), r = this.parser || this.Parser;
    return TC("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), TC("process", this.parser || this.Parser), AC("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(o, s) {
      const a = Wv(t), c = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(a)
      );
      r.run(c, a, function(f, h, m) {
        if (f || !h || !m)
          return u(f);
        const g = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), b = r.stringify(g, m);
        GSe(b) ? m.value = b : m.result = b, u(
          f,
          /** @type {VFileWithOutput<CompileResult>} */
          m
        );
      });
      function u(f, h) {
        f || !h ? s(f) : o ? o(h) : n(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), TC("processSync", this.parser || this.Parser), AC("processSync", this.compiler || this.Compiler), this.process(t, i), Pz("processSync", "process", n), r;
    function i(o, s) {
      n = !0, Nz(o), r = s;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    Dz(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? o(void 0, r) : new Promise(o);
    function o(s, a) {
      const c = Wv(n);
      i.run(t, c, u);
      function u(f, h, m) {
        const g = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || t
        );
        f ? a(f) : s ? s(g) : r(void 0, g, m);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, o), Pz("runSync", "run", r), i;
    function o(s, a) {
      Nz(s), i = a, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Wv(n), i = this.compiler || this.Compiler;
    return AC("stringify", i), Dz(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (MC("use", this.frozen), t != null) if (typeof t == "function")
      c(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? a(t) : s(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function o(u) {
      if (typeof u == "function")
        c(u, []);
      else if (typeof u == "object")
        if (Array.isArray(u)) {
          const [f, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            u
          );
          c(f, h);
        } else
          s(u);
      else
        throw new TypeError("Expected usable value, not `" + u + "`");
    }
    function s(u) {
      if (!("plugins" in u) && !("settings" in u))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      a(u.plugins), u.settings && (i.settings = kC(!0, i.settings, u.settings));
    }
    function a(u) {
      let f = -1;
      if (u != null) if (Array.isArray(u))
        for (; ++f < u.length; ) {
          const h = u[f];
          o(h);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + u + "`");
    }
    function c(u, f) {
      let h = -1, m = -1;
      for (; ++h < r.length; )
        if (r[h][0] === u) {
          m = h;
          break;
        }
      if (m === -1)
        r.push([u, ...f]);
      else if (f.length > 0) {
        let [g, ...b] = f;
        const x = r[m][1];
        G_(x) && G_(g) && (g = kC(!0, x, g)), r[m] = [u, g, ...b];
      }
    }
  }
}
const WSe = new YM().freeze();
function TC(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function AC(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function MC(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Dz(e) {
  if (!G_(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function Pz(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Wv(e) {
  return qSe(e) ? e : new kV(e);
}
function qSe(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function GSe(e) {
  return typeof e == "string" || KSe(e);
}
function KSe(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const ZSe = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", jz = [], Iz = { allowDangerousHtml: !0 }, YSe = /^(https?|ircs?|mailto|xmpp)$/i, XSe = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function JSe(e) {
  const t = QSe(e), n = eke(e);
  return tke(t.runSync(t.parse(n), n), e);
}
function QSe(e) {
  const t = e.rehypePlugins || jz, n = e.remarkPlugins || jz, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Iz } : Iz;
  return WSe().use(D1e).use(n).use(TSe, r).use(t);
}
function eke(e) {
  const t = e.children || "", n = new kV();
  return typeof t == "string" && (n.value = t), n;
}
function tke(e, t) {
  const n = t.allowedElements, r = t.allowElement, i = t.components, o = t.disallowedElements, s = t.skipHtml, a = t.unwrapDisallowed, c = t.urlTransform || nke;
  for (const f of XSe)
    Object.hasOwn(t, f.from) && ("" + f.from + (f.to ? "use `" + f.to + "` instead" : "remove it") + ZSe + f.id, void 0);
  return ZM(e, u), JF(e, {
    Fragment: v.Fragment,
    components: i,
    ignoreInvalidStyle: !0,
    jsx: v.jsx,
    jsxs: v.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function u(f, h, m) {
    if (f.type === "raw" && m && typeof h == "number")
      return s ? m.children.splice(h, 1) : m.children[h] = { type: "text", value: f.value }, h;
    if (f.type === "element") {
      let g;
      for (g in bC)
        if (Object.hasOwn(bC, g) && Object.hasOwn(f.properties, g)) {
          const b = f.properties[g], x = bC[g];
          (x === null || x.includes(f.tagName)) && (f.properties[g] = c(String(b || ""), g, f));
        }
    }
    if (f.type === "element") {
      let g = n ? !n.includes(f.tagName) : o ? o.includes(f.tagName) : !1;
      if (!g && r && typeof h == "number" && (g = !r(f, h, m)), g && m && typeof h == "number")
        return a && f.children ? m.children.splice(h, 1, ...f.children) : m.children.splice(h, 1), h;
    }
  }
}
function nke(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    i !== -1 && t > i || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    YSe.test(e.slice(0, t)) ? e : ""
  );
}
function Bb(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
function rke(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function ike(e, t, n) {
  const i = Iw((n || {}).ignore || []), o = oke(t);
  let s = -1;
  for (; ++s < o.length; )
    SV(e, "text", a);
  function a(u, f) {
    let h = -1, m;
    for (; ++h < f.length; ) {
      const g = f[h], b = m ? m.children : void 0;
      if (i(
        g,
        b ? b.indexOf(g) : void 0,
        m
      ))
        return;
      m = g;
    }
    if (m)
      return c(u, f);
  }
  function c(u, f) {
    const h = f[f.length - 1], m = o[s][0], g = o[s][1];
    let b = 0;
    const w = h.children.indexOf(u);
    let S = !1, _ = [];
    m.lastIndex = 0;
    let M = m.exec(u.value);
    for (; M; ) {
      const N = M.index, P = {
        index: M.index,
        input: M.input,
        stack: [...f, u]
      };
      let I = g(...M, P);
      if (typeof I == "string" && (I = I.length > 0 ? { type: "text", value: I } : void 0), I === !1 ? m.lastIndex = N + 1 : (b !== N && _.push({
        type: "text",
        value: u.value.slice(b, N)
      }), Array.isArray(I) ? _.push(...I) : I && _.push(I), b = N + M[0].length, S = !0), !m.global)
        break;
      M = m.exec(u.value);
    }
    return S ? (b < u.value.length && _.push({ type: "text", value: u.value.slice(b) }), h.children.splice(w, 1, ..._)) : _ = [u], w + _.length;
  }
}
function oke(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([ske(i[0]), ake(i[1])]);
  }
  return t;
}
function ske(e) {
  return typeof e == "string" ? new RegExp(rke(e), "g") : e;
}
function ake(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const NC = "phrasing", RC = ["autolink", "link", "image", "label"];
function lke() {
  return {
    transforms: [mke],
    enter: {
      literalAutolink: uke,
      literalAutolinkEmail: OC,
      literalAutolinkHttp: OC,
      literalAutolinkWww: OC
    },
    exit: {
      literalAutolink: pke,
      literalAutolinkEmail: hke,
      literalAutolinkHttp: dke,
      literalAutolinkWww: fke
    }
  };
}
function cke() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: NC,
        notInConstruct: RC
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: NC,
        notInConstruct: RC
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: NC,
        notInConstruct: RC
      }
    ]
  };
}
function uke(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function OC(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function dke(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function fke(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function hke(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function pke(e) {
  this.exit(e);
}
function mke(e) {
  ike(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, gke],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), yke]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function gke(e, t, n, r, i) {
  let o = "";
  if (!CV(i) || (/^w/i.test(t) && (n = t + n, t = "", o = "http://"), !vke(n)))
    return !1;
  const s = bke(n + r);
  if (!s[0]) return !1;
  const a = {
    type: "link",
    title: null,
    url: o + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [a, { type: "text", value: s[1] }] : a;
}
function yke(e, t, n, r) {
  return (
    // Not an expected previous character.
    !CV(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function vke(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function bke(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = Bb(e, "(");
  let o = Bb(e, ")");
  for (; r !== -1 && i > o; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), o++;
  return [e, n];
}
function CV(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || nd(n) || Dw(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
EV.peek = Ake;
function xke() {
  this.buffer();
}
function wke(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function Ske() {
  this.buffer();
}
function kke(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function Cke(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = us(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function Eke(e) {
  this.exit(e);
}
function _ke(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = us(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function Tke(e) {
  this.exit(e);
}
function Ake() {
  return "[";
}
function EV(e, t, n, r) {
  const i = n.createTracker(r);
  let o = i.move("[^");
  const s = n.enter("footnoteReference"), a = n.enter("reference");
  return o += i.move(
    n.safe(n.associationId(e), { after: "]", before: o })
  ), a(), s(), o += i.move("]"), o;
}
function Mke() {
  return {
    enter: {
      gfmFootnoteCallString: xke,
      gfmFootnoteCall: wke,
      gfmFootnoteDefinitionLabelString: Ske,
      gfmFootnoteDefinition: kke
    },
    exit: {
      gfmFootnoteCallString: Cke,
      gfmFootnoteCall: Eke,
      gfmFootnoteDefinitionLabelString: _ke,
      gfmFootnoteDefinition: Tke
    }
  };
}
function Nke(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: EV },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, i, o, s) {
    const a = o.createTracker(s);
    let c = a.move("[^");
    const u = o.enter("footnoteDefinition"), f = o.enter("label");
    return c += a.move(
      o.safe(o.associationId(r), { before: c, after: "]" })
    ), f(), c += a.move("]:"), r.children && r.children.length > 0 && (a.shift(4), c += a.move(
      (t ? `
` : " ") + o.indentLines(
        o.containerFlow(r, a.current()),
        t ? _V : Rke
      )
    )), u(), c;
  }
}
function Rke(e, t, n) {
  return t === 0 ? e : _V(e, t, n);
}
function _V(e, t, n) {
  return (n ? "" : "    ") + e;
}
const Oke = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
TV.peek = zke;
function Dke() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: jke },
    exit: { strikethrough: Ike }
  };
}
function Pke() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Oke
      }
    ],
    handlers: { delete: TV }
  };
}
function jke(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function Ike(e) {
  this.exit(e);
}
function TV(e, t, n, r) {
  const i = n.createTracker(r), o = n.enter("strikethrough");
  let s = i.move("~~");
  return s += n.containerPhrasing(e, {
    ...i.current(),
    before: s,
    after: "~"
  }), s += i.move("~~"), o(), s;
}
function zke() {
  return "~";
}
function Lke(e) {
  return e.length;
}
function Bke(e, t) {
  const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || Lke, o = [], s = [], a = [], c = [];
  let u = 0, f = -1;
  for (; ++f < e.length; ) {
    const x = [], w = [];
    let S = -1;
    for (e[f].length > u && (u = e[f].length); ++S < e[f].length; ) {
      const _ = $ke(e[f][S]);
      if (n.alignDelimiters !== !1) {
        const M = i(_);
        w[S] = M, (c[S] === void 0 || M > c[S]) && (c[S] = M);
      }
      x.push(_);
    }
    s[f] = x, a[f] = w;
  }
  let h = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++h < u; )
      o[h] = zz(r[h]);
  else {
    const x = zz(r);
    for (; ++h < u; )
      o[h] = x;
  }
  h = -1;
  const m = [], g = [];
  for (; ++h < u; ) {
    const x = o[h];
    let w = "", S = "";
    x === 99 ? (w = ":", S = ":") : x === 108 ? w = ":" : x === 114 && (S = ":");
    let _ = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      c[h] - w.length - S.length
    );
    const M = w + "-".repeat(_) + S;
    n.alignDelimiters !== !1 && (_ = w.length + _ + S.length, _ > c[h] && (c[h] = _), g[h] = _), m[h] = M;
  }
  s.splice(1, 0, m), a.splice(1, 0, g), f = -1;
  const b = [];
  for (; ++f < s.length; ) {
    const x = s[f], w = a[f];
    h = -1;
    const S = [];
    for (; ++h < u; ) {
      const _ = x[h] || "";
      let M = "", N = "";
      if (n.alignDelimiters !== !1) {
        const P = c[h] - (w[h] || 0), I = o[h];
        I === 114 ? M = " ".repeat(P) : I === 99 ? P % 2 ? (M = " ".repeat(P / 2 + 0.5), N = " ".repeat(P / 2 - 0.5)) : (M = " ".repeat(P / 2), N = M) : N = " ".repeat(P);
      }
      n.delimiterStart !== !1 && !h && S.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && _ === "") && (n.delimiterStart !== !1 || h) && S.push(" "), n.alignDelimiters !== !1 && S.push(M), S.push(_), n.alignDelimiters !== !1 && S.push(N), n.padding !== !1 && S.push(" "), (n.delimiterEnd !== !1 || h !== u - 1) && S.push("|");
    }
    b.push(
      n.delimiterEnd === !1 ? S.join("").replace(/ +$/, "") : S.join("")
    );
  }
  return b.join(`
`);
}
function $ke(e) {
  return e == null ? "" : String(e);
}
function zz(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
const Lz = {}.hasOwnProperty;
function Uke(e, t) {
  const n = t || {};
  function r(i, ...o) {
    let s = r.invalid;
    const a = r.handlers;
    if (i && Lz.call(i, e)) {
      const c = String(i[e]);
      s = Lz.call(a, c) ? a[c] : r.unknown;
    }
    if (s)
      return s.call(this, i, ...o);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
function Fke(e, t, n, r) {
  const i = n.enter("blockquote"), o = n.createTracker(r);
  o.move("> "), o.shift(2);
  const s = n.indentLines(
    n.containerFlow(e, o.current()),
    Vke
  );
  return i(), s;
}
function Vke(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function Hke(e, t) {
  return Bz(e, t.inConstruct, !0) && !Bz(e, t.notInConstruct, !1);
}
function Bz(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function $z(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && Hke(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function Wke(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, o = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++o > s && (s = o) : o = 1, i = r + t.length, r = n.indexOf(t, i);
  return s;
}
function qke(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function Gke(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function Kke(e, t, n, r) {
  const i = Gke(n), o = e.value || "", s = i === "`" ? "GraveAccent" : "Tilde";
  if (qke(e, n)) {
    const h = n.enter("codeIndented"), m = n.indentLines(o, Zke);
    return h(), m;
  }
  const a = n.createTracker(r), c = i.repeat(Math.max(Wke(o, i) + 1, 3)), u = n.enter("codeFenced");
  let f = a.move(c);
  if (e.lang) {
    const h = n.enter(`codeFencedLang${s}`);
    f += a.move(
      n.safe(e.lang, {
        before: f,
        after: " ",
        encode: ["`"],
        ...a.current()
      })
    ), h();
  }
  if (e.lang && e.meta) {
    const h = n.enter(`codeFencedMeta${s}`);
    f += a.move(" "), f += a.move(
      n.safe(e.meta, {
        before: f,
        after: `
`,
        encode: ["`"],
        ...a.current()
      })
    ), h();
  }
  return f += a.move(`
`), o && (f += a.move(o + `
`)), f += a.move(c), u(), f;
}
function Zke(e, t, n) {
  return (n ? "" : "    ") + e;
}
function XM(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function Yke(e, t, n, r) {
  const i = XM(n), o = i === '"' ? "Quote" : "Apostrophe", s = n.enter("definition");
  let a = n.enter("label");
  const c = n.createTracker(r);
  let u = c.move("[");
  return u += c.move(
    n.safe(n.associationId(e), {
      before: u,
      after: "]",
      ...c.current()
    })
  ), u += c.move("]: "), a(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    n.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (a = n.enter("destinationRaw"), u += c.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), a(), e.title && (a = n.enter(`title${o}`), u += c.move(" " + i), u += c.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), a()), s(), u;
}
function Xke(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function dg(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function $b(e, t, n) {
  const r = fh(e), i = fh(t);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
AV.peek = Jke;
function AV(e, t, n, r) {
  const i = Xke(n), o = n.enter("emphasis"), s = n.createTracker(r), a = s.move(i);
  let c = s.move(
    n.containerPhrasing(e, {
      after: i,
      before: a,
      ...s.current()
    })
  );
  const u = c.charCodeAt(0), f = $b(
    r.before.charCodeAt(r.before.length - 1),
    u,
    i
  );
  f.inside && (c = dg(u) + c.slice(1));
  const h = c.charCodeAt(c.length - 1), m = $b(r.after.charCodeAt(0), h, i);
  m.inside && (c = c.slice(0, -1) + dg(h));
  const g = s.move(i);
  return o(), n.attentionEncodeSurroundingInfo = {
    after: m.outside,
    before: f.outside
  }, a + c + g;
}
function Jke(e, t, n) {
  return n.options.emphasis || "*";
}
function Qke(e, t) {
  let n = !1;
  return ZM(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, W_;
  }), !!((!e.depth || e.depth < 3) && FM(e) && (t.options.setext || n));
}
function eCe(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), o = n.createTracker(r);
  if (Qke(e, n)) {
    const f = n.enter("headingSetext"), h = n.enter("phrasing"), m = n.containerPhrasing(e, {
      ...o.current(),
      before: `
`,
      after: `
`
    });
    return h(), f(), m + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size
      m.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(m.lastIndexOf("\r"), m.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(i), a = n.enter("headingAtx"), c = n.enter("phrasing");
  o.move(s + " ");
  let u = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...o.current()
  });
  return /^[\t ]/.test(u) && (u = dg(u.charCodeAt(0)) + u.slice(1)), u = u ? s + " " + u : s, n.options.closeAtx && (u += " " + s), c(), a(), u;
}
MV.peek = tCe;
function MV(e) {
  return e.value || "";
}
function tCe() {
  return "<";
}
NV.peek = nCe;
function NV(e, t, n, r) {
  const i = XM(n), o = i === '"' ? "Quote" : "Apostrophe", s = n.enter("image");
  let a = n.enter("label");
  const c = n.createTracker(r);
  let u = c.move("![");
  return u += c.move(
    n.safe(e.alt, { before: u, after: "]", ...c.current() })
  ), u += c.move("]("), a(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    n.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (a = n.enter("destinationRaw"), u += c.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), a(), e.title && (a = n.enter(`title${o}`), u += c.move(" " + i), u += c.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), a()), u += c.move(")"), s(), u;
}
function nCe() {
  return "!";
}
RV.peek = rCe;
function RV(e, t, n, r) {
  const i = e.referenceType, o = n.enter("imageReference");
  let s = n.enter("label");
  const a = n.createTracker(r);
  let c = a.move("![");
  const u = n.safe(e.alt, {
    before: c,
    after: "]",
    ...a.current()
  });
  c += a.move(u + "]["), s();
  const f = n.stack;
  n.stack = [], s = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...a.current()
  });
  return s(), n.stack = f, o(), i === "full" || !u || u !== h ? c += a.move(h + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += a.move("]"), c;
}
function rCe() {
  return "!";
}
OV.peek = iCe;
function OV(e, t, n) {
  let r = e.value || "", i = "`", o = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++o < n.unsafe.length; ) {
    const s = n.unsafe[o], a = n.compilePattern(s);
    let c;
    if (s.atBreak)
      for (; c = a.exec(r); ) {
        let u = c.index;
        r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--, r = r.slice(0, u) + " " + r.slice(c.index + 1);
      }
  }
  return i + r + i;
}
function iCe() {
  return "`";
}
function DV(e, t) {
  const n = FM(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
PV.peek = oCe;
function PV(e, t, n, r) {
  const i = XM(n), o = i === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r);
  let a, c;
  if (DV(e, n)) {
    const f = n.stack;
    n.stack = [], a = n.enter("autolink");
    let h = s.move("<");
    return h += s.move(
      n.containerPhrasing(e, {
        before: h,
        after: ">",
        ...s.current()
      })
    ), h += s.move(">"), a(), n.stack = f, h;
  }
  a = n.enter("link"), c = n.enter("label");
  let u = s.move("[");
  return u += s.move(
    n.containerPhrasing(e, {
      before: u,
      after: "](",
      ...s.current()
    })
  ), u += s.move("]("), c(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), u += s.move("<"), u += s.move(
    n.safe(e.url, { before: u, after: ">", ...s.current() })
  ), u += s.move(">")) : (c = n.enter("destinationRaw"), u += s.move(
    n.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), c(), e.title && (c = n.enter(`title${o}`), u += s.move(" " + i), u += s.move(
    n.safe(e.title, {
      before: u,
      after: i,
      ...s.current()
    })
  ), u += s.move(i), c()), u += s.move(")"), a(), u;
}
function oCe(e, t, n) {
  return DV(e, n) ? "<" : "[";
}
jV.peek = sCe;
function jV(e, t, n, r) {
  const i = e.referenceType, o = n.enter("linkReference");
  let s = n.enter("label");
  const a = n.createTracker(r);
  let c = a.move("[");
  const u = n.containerPhrasing(e, {
    before: c,
    after: "]",
    ...a.current()
  });
  c += a.move(u + "]["), s();
  const f = n.stack;
  n.stack = [], s = n.enter("reference");
  const h = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...a.current()
  });
  return s(), n.stack = f, o(), i === "full" || !u || u !== h ? c += a.move(h + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += a.move("]"), c;
}
function sCe() {
  return "[";
}
function JM(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function aCe(e) {
  const t = JM(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function lCe(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function IV(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function cCe(e, t, n, r) {
  const i = n.enter("list"), o = n.bulletCurrent;
  let s = e.ordered ? lCe(n) : JM(n);
  const a = e.ordered ? s === "." ? ")" : "." : aCe(n);
  let c = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const f = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      f && (!f.children || !f.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (c = !0), IV(n) === s && f
    ) {
      let h = -1;
      for (; ++h < e.children.length; ) {
        const m = e.children[h];
        if (m && m.type === "listItem" && m.children && m.children[0] && m.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (s = a), n.bulletCurrent = s;
  const u = n.containerFlow(e, r);
  return n.bulletLastUsed = s, n.bulletCurrent = o, i(), u;
}
function uCe(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function dCe(e, t, n, r) {
  const i = uCe(n);
  let o = n.bulletCurrent || JM(n);
  t && t.type === "list" && t.ordered && (o = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + o);
  let s = o.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const a = n.createTracker(r);
  a.move(o + " ".repeat(s - o.length)), a.shift(s);
  const c = n.enter("listItem"), u = n.indentLines(
    n.containerFlow(e, a.current()),
    f
  );
  return c(), u;
  function f(h, m, g) {
    return m ? (g ? "" : " ".repeat(s)) + h : (g ? o : o + " ".repeat(s - o.length)) + h;
  }
}
function fCe(e, t, n, r) {
  const i = n.enter("paragraph"), o = n.enter("phrasing"), s = n.containerPhrasing(e, r);
  return o(), i(), s;
}
const hCe = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Iw([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function pCe(e, t, n, r) {
  return (e.children.some(function(s) {
    return hCe(s);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function mCe(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
zV.peek = gCe;
function zV(e, t, n, r) {
  const i = mCe(n), o = n.enter("strong"), s = n.createTracker(r), a = s.move(i + i);
  let c = s.move(
    n.containerPhrasing(e, {
      after: i,
      before: a,
      ...s.current()
    })
  );
  const u = c.charCodeAt(0), f = $b(
    r.before.charCodeAt(r.before.length - 1),
    u,
    i
  );
  f.inside && (c = dg(u) + c.slice(1));
  const h = c.charCodeAt(c.length - 1), m = $b(r.after.charCodeAt(0), h, i);
  m.inside && (c = c.slice(0, -1) + dg(h));
  const g = s.move(i + i);
  return o(), n.attentionEncodeSurroundingInfo = {
    after: m.outside,
    before: f.outside
  }, a + c + g;
}
function gCe(e, t, n) {
  return n.options.strong || "*";
}
function yCe(e, t, n, r) {
  return n.safe(e.value, r);
}
function vCe(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function bCe(e, t, n) {
  const r = (IV(n) + (n.options.ruleSpaces ? " " : "")).repeat(vCe(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const LV = {
  blockquote: Fke,
  break: $z,
  code: Kke,
  definition: Yke,
  emphasis: AV,
  hardBreak: $z,
  heading: eCe,
  html: MV,
  image: NV,
  imageReference: RV,
  inlineCode: OV,
  link: PV,
  linkReference: jV,
  list: cCe,
  listItem: dCe,
  paragraph: fCe,
  root: pCe,
  strong: zV,
  text: yCe,
  thematicBreak: bCe
};
function xCe() {
  return {
    enter: {
      table: wCe,
      tableData: Uz,
      tableHeader: Uz,
      tableRow: kCe
    },
    exit: {
      codeText: CCe,
      table: SCe,
      tableData: DC,
      tableHeader: DC,
      tableRow: DC
    }
  };
}
function wCe(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function SCe(e) {
  this.exit(e), this.data.inTable = void 0;
}
function kCe(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function DC(e) {
  this.exit(e);
}
function Uz(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function CCe(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, ECe));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function ECe(e, t) {
  return t === "|" ? t : e;
}
function _Ce(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, o = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: m,
      table: s,
      tableCell: c,
      tableRow: a
    }
  };
  function s(g, b, x, w) {
    return u(f(g, x, w), g.align);
  }
  function a(g, b, x, w) {
    const S = h(g, x, w), _ = u([S]);
    return _.slice(0, _.indexOf(`
`));
  }
  function c(g, b, x, w) {
    const S = x.enter("tableCell"), _ = x.enter("phrasing"), M = x.containerPhrasing(g, {
      ...w,
      before: o,
      after: o
    });
    return _(), S(), M;
  }
  function u(g, b) {
    return Bke(g, {
      align: b,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function f(g, b, x) {
    const w = g.children;
    let S = -1;
    const _ = [], M = b.enter("table");
    for (; ++S < w.length; )
      _[S] = h(w[S], b, x);
    return M(), _;
  }
  function h(g, b, x) {
    const w = g.children;
    let S = -1;
    const _ = [], M = b.enter("tableRow");
    for (; ++S < w.length; )
      _[S] = c(w[S], g, b, x);
    return M(), _;
  }
  function m(g, b, x) {
    let w = LV.inlineCode(g, b, x);
    return x.stack.includes("tableCell") && (w = w.replace(/\|/g, "\\$&")), w;
  }
}
function TCe() {
  return {
    exit: {
      taskListCheckValueChecked: Fz,
      taskListCheckValueUnchecked: Fz,
      paragraph: MCe
    }
  };
}
function ACe() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: NCe }
  };
}
function Fz(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function MCe(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let o = -1, s;
      for (; ++o < i.length; ) {
        const a = i[o];
        if (a.type === "paragraph") {
          s = a;
          break;
        }
      }
      s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function NCe(e, t, n, r) {
  const i = e.children[0], o = typeof e.checked == "boolean" && i && i.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", a = n.createTracker(r);
  o && a.move(s);
  let c = LV.listItem(e, t, n, {
    ...r,
    ...a.current()
  });
  return o && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), c;
  function u(f) {
    return f + s;
  }
}
function RCe() {
  return [
    lke(),
    Mke(),
    Dke(),
    xCe(),
    TCe()
  ];
}
function OCe(e) {
  return {
    extensions: [
      cke(),
      Nke(e),
      Pke(),
      _Ce(e),
      ACe()
    ]
  };
}
const DCe = {
  tokenize: BCe,
  partial: !0
}, BV = {
  tokenize: $Ce,
  partial: !0
}, $V = {
  tokenize: UCe,
  partial: !0
}, UV = {
  tokenize: FCe,
  partial: !0
}, PCe = {
  tokenize: VCe,
  partial: !0
}, FV = {
  name: "wwwAutolink",
  tokenize: zCe,
  previous: HV
}, VV = {
  name: "protocolAutolink",
  tokenize: LCe,
  previous: WV
}, il = {
  name: "emailAutolink",
  tokenize: ICe,
  previous: qV
}, ia = {};
function jCe() {
  return {
    text: ia
  };
}
let Cu = 48;
for (; Cu < 123; )
  ia[Cu] = il, Cu++, Cu === 58 ? Cu = 65 : Cu === 91 && (Cu = 97);
ia[43] = il;
ia[45] = il;
ia[46] = il;
ia[95] = il;
ia[72] = [il, VV];
ia[104] = [il, VV];
ia[87] = [il, FV];
ia[119] = [il, FV];
function ICe(e, t, n) {
  const r = this;
  let i, o;
  return s;
  function s(h) {
    return !Z_(h) || !qV.call(r, r.previous) || QM(r.events) ? n(h) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), a(h));
  }
  function a(h) {
    return Z_(h) ? (e.consume(h), a) : h === 64 ? (e.consume(h), c) : n(h);
  }
  function c(h) {
    return h === 46 ? e.check(PCe, f, u)(h) : h === 45 || h === 95 || mi(h) ? (o = !0, e.consume(h), c) : f(h);
  }
  function u(h) {
    return e.consume(h), i = !0, c;
  }
  function f(h) {
    return o && i && Ai(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(h)) : n(h);
  }
}
function zCe(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s !== 87 && s !== 119 || !HV.call(r, r.previous) || QM(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(DCe, e.attempt(BV, e.attempt($V, o), n), n)(s));
  }
  function o(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function LCe(e, t, n) {
  const r = this;
  let i = "", o = !1;
  return s;
  function s(h) {
    return (h === 72 || h === 104) && WV.call(r, r.previous) && !QM(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(h), e.consume(h), a) : n(h);
  }
  function a(h) {
    if (Ai(h) && i.length < 5)
      return i += String.fromCodePoint(h), e.consume(h), a;
    if (h === 58) {
      const m = i.toLowerCase();
      if (m === "http" || m === "https")
        return e.consume(h), c;
    }
    return n(h);
  }
  function c(h) {
    return h === 47 ? (e.consume(h), o ? u : (o = !0, c)) : n(h);
  }
  function u(h) {
    return h === null || Ib(h) || Tn(h) || nd(h) || Dw(h) ? n(h) : e.attempt(BV, e.attempt($V, f), n)(h);
  }
  function f(h) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(h);
  }
}
function BCe(e, t, n) {
  let r = 0;
  return i;
  function i(s) {
    return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), i) : s === 46 && r === 3 ? (e.consume(s), o) : n(s);
  }
  function o(s) {
    return s === null ? n(s) : t(s);
  }
}
function $Ce(e, t, n) {
  let r, i, o;
  return s;
  function s(u) {
    return u === 46 || u === 95 ? e.check(UV, c, a)(u) : u === null || Tn(u) || nd(u) || u !== 45 && Dw(u) ? c(u) : (o = !0, e.consume(u), s);
  }
  function a(u) {
    return u === 95 ? r = !0 : (i = r, r = void 0), e.consume(u), s;
  }
  function c(u) {
    return i || r || !o ? n(u) : t(u);
  }
}
function UCe(e, t) {
  let n = 0, r = 0;
  return i;
  function i(s) {
    return s === 40 ? (n++, e.consume(s), i) : s === 41 && r < n ? o(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(UV, t, o)(s) : s === null || Tn(s) || nd(s) ? t(s) : (e.consume(s), i);
  }
  function o(s) {
    return s === 41 && r++, e.consume(s), i;
  }
}
function FCe(e, t, n) {
  return r;
  function r(a) {
    return a === 33 || a === 34 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 63 || a === 95 || a === 126 ? (e.consume(a), r) : a === 38 ? (e.consume(a), o) : a === 93 ? (e.consume(a), i) : (
      // `<` is an end.
      a === 60 || // So is whitespace.
      a === null || Tn(a) || nd(a) ? t(a) : n(a)
    );
  }
  function i(a) {
    return a === null || a === 40 || a === 91 || Tn(a) || nd(a) ? t(a) : r(a);
  }
  function o(a) {
    return Ai(a) ? s(a) : n(a);
  }
  function s(a) {
    return a === 59 ? (e.consume(a), r) : Ai(a) ? (e.consume(a), s) : n(a);
  }
}
function VCe(e, t, n) {
  return r;
  function r(o) {
    return e.consume(o), i;
  }
  function i(o) {
    return mi(o) ? n(o) : t(o);
  }
}
function HV(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Tn(e);
}
function WV(e) {
  return !Ai(e);
}
function qV(e) {
  return !(e === 47 || Z_(e));
}
function Z_(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || mi(e);
}
function QM(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const HCe = {
  tokenize: JCe,
  partial: !0
};
function WCe() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: ZCe,
        continuation: {
          tokenize: YCe
        },
        exit: XCe
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: KCe
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: qCe,
        resolveTo: GCe
      }
    }
  };
}
function qCe(e, t, n) {
  const r = this;
  let i = r.events.length;
  const o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s;
  for (; i--; ) {
    const c = r.events[i][1];
    if (c.type === "labelImage") {
      s = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return a;
  function a(c) {
    if (!s || !s._balanced)
      return n(c);
    const u = us(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }));
    return u.codePointAt(0) !== 94 || !o.includes(u.slice(1)) ? n(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function GCe(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const o = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, o.start),
    end: Object.assign({}, o.end)
  }, a = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", o, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", o, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...a), e;
}
function KCe(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o = 0, s;
  return a;
  function a(h) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(h) {
    return h !== 94 ? n(h) : (e.enter("gfmFootnoteCallMarker"), e.consume(h), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
  }
  function u(h) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      h === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || Tn(h)
    )
      return n(h);
    if (h === 93) {
      e.exit("chunkString");
      const m = e.exit("gfmFootnoteCallString");
      return i.includes(us(r.sliceSerialize(m))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(h), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(h);
    }
    return Tn(h) || (s = !0), o++, e.consume(h), h === 92 ? f : u;
  }
  function f(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), o++, u) : u(h);
  }
}
function ZCe(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o, s = 0, a;
  return c;
  function c(b) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
  }
  function u(b) {
    return b === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", f) : n(b);
  }
  function f(b) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      b === 93 && !a || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      b === null || b === 91 || Tn(b)
    )
      return n(b);
    if (b === 93) {
      e.exit("chunkString");
      const x = e.exit("gfmFootnoteDefinitionLabelString");
      return o = us(r.sliceSerialize(x)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), m;
    }
    return Tn(b) || (a = !0), s++, e.consume(b), b === 92 ? h : f;
  }
  function h(b) {
    return b === 91 || b === 92 || b === 93 ? (e.consume(b), s++, f) : f(b);
  }
  function m(b) {
    return b === 58 ? (e.enter("definitionMarker"), e.consume(b), e.exit("definitionMarker"), i.includes(o) || i.push(o), tn(e, g, "gfmFootnoteDefinitionWhitespace")) : n(b);
  }
  function g(b) {
    return t(b);
  }
}
function YCe(e, t, n) {
  return e.check(ry, t, e.attempt(HCe, t, n));
}
function XCe(e) {
  e.exit("gfmFootnoteDefinition");
}
function JCe(e, t, n) {
  const r = this;
  return tn(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(o) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(o) : n(o);
  }
}
function QCe(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: o,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(s, a) {
    let c = -1;
    for (; ++c < s.length; )
      if (s[c][0] === "enter" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._close) {
        let u = c;
        for (; u--; )
          if (s[u][0] === "exit" && s[u][1].type === "strikethroughSequenceTemporary" && s[u][1]._open && // If the sizes are the same:
          s[c][1].end.offset - s[c][1].start.offset === s[u][1].end.offset - s[u][1].start.offset) {
            s[c][1].type = "strikethroughSequence", s[u][1].type = "strikethroughSequence";
            const f = {
              type: "strikethrough",
              start: Object.assign({}, s[u][1].start),
              end: Object.assign({}, s[c][1].end)
            }, h = {
              type: "strikethroughText",
              start: Object.assign({}, s[u][1].end),
              end: Object.assign({}, s[c][1].start)
            }, m = [["enter", f, a], ["enter", s[u][1], a], ["exit", s[u][1], a], ["enter", h, a]], g = a.parser.constructs.insideSpan.null;
            g && po(m, m.length, 0, Pw(g, s.slice(u + 1, c), a)), po(m, m.length, 0, [["exit", h, a], ["enter", s[c][1], a], ["exit", s[c][1], a], ["exit", f, a]]), po(s, u - 1, c - u + 3, m), c = u + m.length - 2;
            break;
          }
      }
    for (c = -1; ++c < s.length; )
      s[c][1].type === "strikethroughSequenceTemporary" && (s[c][1].type = "data");
    return s;
  }
  function o(s, a, c) {
    const u = this.previous, f = this.events;
    let h = 0;
    return m;
    function m(b) {
      return u === 126 && f[f.length - 1][1].type !== "characterEscape" ? c(b) : (s.enter("strikethroughSequenceTemporary"), g(b));
    }
    function g(b) {
      const x = fh(u);
      if (b === 126)
        return h > 1 ? c(b) : (s.consume(b), h++, g);
      if (h < 2 && !n) return c(b);
      const w = s.exit("strikethroughSequenceTemporary"), S = fh(b);
      return w._open = !S || S === 2 && !!x, w._close = !x || x === 2 && !!S, a(b);
    }
  }
}
class eEe {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    tEe(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(o, s) {
      return o[0] - s[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const o of i)
        t.push(o);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function tEe(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function nEe(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const o = r.length - 1;
          r[o] = r[o] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function rEe() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: iEe,
        resolveAll: oEe
      }
    }
  };
}
function iEe(e, t, n) {
  const r = this;
  let i = 0, o = 0, s;
  return a;
  function a(B) {
    let G = r.events.length - 1;
    for (; G > -1; ) {
      const ie = r.events[G][1].type;
      if (ie === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      ie === "linePrefix") G--;
      else break;
    }
    const Y = G > -1 ? r.events[G][1].type : null, he = Y === "tableHead" || Y === "tableRow" ? I : c;
    return he === I && r.parser.lazy[r.now().line] ? n(B) : he(B);
  }
  function c(B) {
    return e.enter("tableHead"), e.enter("tableRow"), u(B);
  }
  function u(B) {
    return B === 124 || (s = !0, o += 1), f(B);
  }
  function f(B) {
    return B === null ? n(B) : yt(B) ? o > 1 ? (o = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(B), e.exit("lineEnding"), g) : n(B) : Gt(B) ? tn(e, f, "whitespace")(B) : (o += 1, s && (s = !1, i += 1), B === 124 ? (e.enter("tableCellDivider"), e.consume(B), e.exit("tableCellDivider"), s = !0, f) : (e.enter("data"), h(B)));
  }
  function h(B) {
    return B === null || B === 124 || Tn(B) ? (e.exit("data"), f(B)) : (e.consume(B), B === 92 ? m : h);
  }
  function m(B) {
    return B === 92 || B === 124 ? (e.consume(B), h) : h(B);
  }
  function g(B) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(B) : (e.enter("tableDelimiterRow"), s = !1, Gt(B) ? tn(e, b, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(B) : b(B));
  }
  function b(B) {
    return B === 45 || B === 58 ? w(B) : B === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(B), e.exit("tableCellDivider"), x) : P(B);
  }
  function x(B) {
    return Gt(B) ? tn(e, w, "whitespace")(B) : w(B);
  }
  function w(B) {
    return B === 58 ? (o += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(B), e.exit("tableDelimiterMarker"), S) : B === 45 ? (o += 1, S(B)) : B === null || yt(B) ? N(B) : P(B);
  }
  function S(B) {
    return B === 45 ? (e.enter("tableDelimiterFiller"), _(B)) : P(B);
  }
  function _(B) {
    return B === 45 ? (e.consume(B), _) : B === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(B), e.exit("tableDelimiterMarker"), M) : (e.exit("tableDelimiterFiller"), M(B));
  }
  function M(B) {
    return Gt(B) ? tn(e, N, "whitespace")(B) : N(B);
  }
  function N(B) {
    return B === 124 ? b(B) : B === null || yt(B) ? !s || i !== o ? P(B) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(B)) : P(B);
  }
  function P(B) {
    return n(B);
  }
  function I(B) {
    return e.enter("tableRow"), O(B);
  }
  function O(B) {
    return B === 124 ? (e.enter("tableCellDivider"), e.consume(B), e.exit("tableCellDivider"), O) : B === null || yt(B) ? (e.exit("tableRow"), t(B)) : Gt(B) ? tn(e, O, "whitespace")(B) : (e.enter("data"), L(B));
  }
  function L(B) {
    return B === null || B === 124 || Tn(B) ? (e.exit("data"), O(B)) : (e.consume(B), B === 92 ? U : L);
  }
  function U(B) {
    return B === 92 || B === 124 ? (e.consume(B), L) : L(B);
  }
}
function oEe(e, t) {
  let n = -1, r = !0, i = 0, o = [0, 0, 0, 0], s = [0, 0, 0, 0], a = !1, c = 0, u, f, h;
  const m = new eEe();
  for (; ++n < e.length; ) {
    const g = e[n], b = g[1];
    g[0] === "enter" ? b.type === "tableHead" ? (a = !1, c !== 0 && (Vz(m, t, c, u, f), f = void 0, c = 0), u = {
      type: "table",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, m.add(n, 0, [["enter", u, t]])) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (r = !0, h = void 0, o = [0, 0, 0, 0], s = [0, n + 1, 0, 0], a && (a = !1, f = {
      type: "tableBody",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, m.add(n, 0, [["enter", f, t]])), i = b.type === "tableDelimiterRow" ? 2 : f ? 3 : 1) : i && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (o[1] !== 0 && (s[0] = s[1], h = qv(m, t, o, i, void 0, h), o = [0, 0, 0, 0]), s[2] = n)) : b.type === "tableCellDivider" && (r ? r = !1 : (o[1] !== 0 && (s[0] = s[1], h = qv(m, t, o, i, void 0, h)), o = s, s = [o[1], n, 0, 0])) : b.type === "tableHead" ? (a = !0, c = n) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (c = n, o[1] !== 0 ? (s[0] = s[1], h = qv(m, t, o, i, n, h)) : s[1] !== 0 && (h = qv(m, t, s, i, n, h)), i = 0) : i && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (c !== 0 && Vz(m, t, c, u, f), m.consume(t.events), n = -1; ++n < t.events.length; ) {
    const g = t.events[n];
    g[0] === "enter" && g[1].type === "table" && (g[1]._align = nEe(t.events, n));
  }
  return e;
}
function qv(e, t, n, r, i, o) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", a = "tableContent";
  n[0] !== 0 && (o.end = Object.assign({}, Tf(t.events, n[0])), e.add(n[0], 0, [["exit", o, t]]));
  const c = Tf(t.events, n[1]);
  if (o = {
    type: s,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(n[1], 0, [["enter", o, t]]), n[2] !== 0) {
    const u = Tf(t.events, n[2]), f = Tf(t.events, n[3]), h = {
      type: a,
      start: Object.assign({}, u),
      end: Object.assign({}, f)
    };
    if (e.add(n[2], 0, [["enter", h, t]]), r !== 2) {
      const m = t.events[n[2]], g = t.events[n[3]];
      if (m[1].end = Object.assign({}, g[1].end), m[1].type = "chunkText", m[1].contentType = "text", n[3] > n[2] + 1) {
        const b = n[2] + 1, x = n[3] - n[2] - 1;
        e.add(b, x, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", h, t]]);
  }
  return i !== void 0 && (o.end = Object.assign({}, Tf(t.events, i)), e.add(i, 0, [["exit", o, t]]), o = void 0), o;
}
function Vz(e, t, n, r, i) {
  const o = [], s = Tf(t.events, n);
  i && (i.end = Object.assign({}, s), o.push(["exit", i, t])), r.end = Object.assign({}, s), o.push(["exit", r, t]), e.add(n + 1, 0, o);
}
function Tf(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const sEe = {
  name: "tasklistCheck",
  tokenize: lEe
};
function aEe() {
  return {
    text: {
      91: sEe
    }
  };
}
function lEe(e, t, n) {
  const r = this;
  return i;
  function i(c) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), o)
    );
  }
  function o(c) {
    return Tn(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), s) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), s) : n(c);
  }
  function s(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), a) : n(c);
  }
  function a(c) {
    return yt(c) ? t(c) : Gt(c) ? e.check({
      tokenize: cEe
    }, t, n)(c) : n(c);
  }
}
function cEe(e, t, n) {
  return tn(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function uEe(e) {
  return rV([
    jCe(),
    WCe(),
    QCe(e),
    rEe(),
    aEe()
  ]);
}
const dEe = {};
function fEe(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || dEe, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), o = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(uEe(n)), o.push(RCe()), s.push(OCe(n));
}
let kr = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
};
function hEe(e) {
  return eN(e);
}
function eN(e) {
  return Array.isArray(e) ? pEe(e) : e instanceof RegExp ? e : typeof e == "object" ? mEe(e) : e;
}
function pEe(e) {
  let t = [];
  for (let n = 0, r = e.length; n < r; n++)
    t[n] = eN(e[n]);
  return t;
}
function mEe(e) {
  let t = {};
  for (let n in e)
    t[n] = eN(e[n]);
  return t;
}
function GV(e, ...t) {
  return t.forEach((n) => {
    for (let r in n)
      e[r] = n[r];
  }), e;
}
function KV(e) {
  const t = ~e.lastIndexOf("/") || ~e.lastIndexOf("\\");
  return t === 0 ? e : ~t === e.length - 1 ? KV(e.substring(0, e.length - 1)) : e.substr(~t + 1);
}
var PC = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g, Gv = class {
  static hasCaptures(e) {
    return e === null ? !1 : (PC.lastIndex = 0, PC.test(e));
  }
  static replaceCaptures(e, t, n) {
    return e.replace(PC, (r, i, o, s) => {
      let a = n[parseInt(i || o, 10)];
      if (a) {
        let c = t.substring(a.start, a.end);
        for (; c[0] === "."; )
          c = c.substring(1);
        switch (s) {
          case "downcase":
            return c.toLowerCase();
          case "upcase":
            return c.toUpperCase();
          default:
            return c;
        }
      } else
        return r;
    });
  }
};
function ZV(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function YV(e, t) {
  if (e === null && t === null)
    return 0;
  if (!e)
    return -1;
  if (!t)
    return 1;
  let n = e.length, r = t.length;
  if (n === r) {
    for (let i = 0; i < n; i++) {
      let o = ZV(e[i], t[i]);
      if (o !== 0)
        return o;
    }
    return 0;
  }
  return n - r;
}
function Hz(e) {
  return !!(/^#[0-9a-f]{6}$/i.test(e) || /^#[0-9a-f]{8}$/i.test(e) || /^#[0-9a-f]{3}$/i.test(e) || /^#[0-9a-f]{4}$/i.test(e));
}
function XV(e) {
  return e.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var JV = class {
  constructor(e) {
    this.fn = e;
  }
  cache = /* @__PURE__ */ new Map();
  get(e) {
    if (this.cache.has(e))
      return this.cache.get(e);
    const t = this.fn(e);
    return this.cache.set(e, t), t;
  }
}, Ub = class {
  constructor(e, t, n) {
    this._colorMap = e, this._defaults = t, this._root = n;
  }
  static createFromRawTheme(e, t) {
    return this.createFromParsedTheme(vEe(e), t);
  }
  static createFromParsedTheme(e, t) {
    return xEe(e, t);
  }
  _cachedMatchRoot = new JV(
    (e) => this._root.match(e)
  );
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  getDefaults() {
    return this._defaults;
  }
  match(e) {
    if (e === null)
      return this._defaults;
    const t = e.scopeName, r = this._cachedMatchRoot.get(t).find(
      (i) => gEe(e.parent, i.parentScopes)
    );
    return r ? new QV(
      r.fontStyle,
      r.foreground,
      r.background
    ) : null;
  }
}, jC = class z0 {
  constructor(t, n) {
    this.parent = t, this.scopeName = n;
  }
  static push(t, n) {
    for (const r of n)
      t = new z0(t, r);
    return t;
  }
  static from(...t) {
    let n = null;
    for (let r = 0; r < t.length; r++)
      n = new z0(n, t[r]);
    return n;
  }
  push(t) {
    return new z0(this, t);
  }
  getSegments() {
    let t = this;
    const n = [];
    for (; t; )
      n.push(t.scopeName), t = t.parent;
    return n.reverse(), n;
  }
  toString() {
    return this.getSegments().join(" ");
  }
  extends(t) {
    return this === t ? !0 : this.parent === null ? !1 : this.parent.extends(t);
  }
  getExtensionIfDefined(t) {
    const n = [];
    let r = this;
    for (; r && r !== t; )
      n.push(r.scopeName), r = r.parent;
    return r === t ? n.reverse() : void 0;
  }
};
function gEe(e, t) {
  if (t.length === 0)
    return !0;
  for (let n = 0; n < t.length; n++) {
    let r = t[n], i = !1;
    if (r === ">") {
      if (n === t.length - 1)
        return !1;
      r = t[++n], i = !0;
    }
    for (; e && !yEe(e.scopeName, r); ) {
      if (i)
        return !1;
      e = e.parent;
    }
    if (!e)
      return !1;
    e = e.parent;
  }
  return !0;
}
function yEe(e, t) {
  return t === e || e.startsWith(t) && e[t.length] === ".";
}
var QV = class {
  constructor(e, t, n) {
    this.fontStyle = e, this.foregroundId = t, this.backgroundId = n;
  }
};
function vEe(e) {
  if (!e)
    return [];
  if (!e.settings || !Array.isArray(e.settings))
    return [];
  let t = e.settings, n = [], r = 0;
  for (let i = 0, o = t.length; i < o; i++) {
    let s = t[i];
    if (!s.settings)
      continue;
    let a;
    if (typeof s.scope == "string") {
      let h = s.scope;
      h = h.replace(/^[,]+/, ""), h = h.replace(/[,]+$/, ""), a = h.split(",");
    } else Array.isArray(s.scope) ? a = s.scope : a = [""];
    let c = -1;
    if (typeof s.settings.fontStyle == "string") {
      c = 0;
      let h = s.settings.fontStyle.split(" ");
      for (let m = 0, g = h.length; m < g; m++)
        switch (h[m]) {
          case "italic":
            c = c | 1;
            break;
          case "bold":
            c = c | 2;
            break;
          case "underline":
            c = c | 4;
            break;
          case "strikethrough":
            c = c | 8;
            break;
        }
    }
    let u = null;
    typeof s.settings.foreground == "string" && Hz(s.settings.foreground) && (u = s.settings.foreground);
    let f = null;
    typeof s.settings.background == "string" && Hz(s.settings.background) && (f = s.settings.background);
    for (let h = 0, m = a.length; h < m; h++) {
      let b = a[h].trim().split(" "), x = b[b.length - 1], w = null;
      b.length > 1 && (w = b.slice(0, b.length - 1), w.reverse()), n[r++] = new bEe(
        x,
        w,
        i,
        c,
        u,
        f
      );
    }
  }
  return n;
}
var bEe = class {
  constructor(e, t, n, r, i, o) {
    this.scope = e, this.parentScopes = t, this.index = n, this.fontStyle = r, this.foreground = i, this.background = o;
  }
}, pi = /* @__PURE__ */ ((e) => (e[e.NotSet = -1] = "NotSet", e[e.None = 0] = "None", e[e.Italic = 1] = "Italic", e[e.Bold = 2] = "Bold", e[e.Underline = 4] = "Underline", e[e.Strikethrough = 8] = "Strikethrough", e))(pi || {});
function xEe(e, t) {
  e.sort((c, u) => {
    let f = ZV(c.scope, u.scope);
    return f !== 0 || (f = YV(c.parentScopes, u.parentScopes), f !== 0) ? f : c.index - u.index;
  });
  let n = 0, r = "#000000", i = "#ffffff";
  for (; e.length >= 1 && e[0].scope === ""; ) {
    let c = e.shift();
    c.fontStyle !== -1 && (n = c.fontStyle), c.foreground !== null && (r = c.foreground), c.background !== null && (i = c.background);
  }
  let o = new wEe(t), s = new QV(n, o.getId(r), o.getId(i)), a = new kEe(new Y_(0, null, -1, 0, 0), []);
  for (let c = 0, u = e.length; c < u; c++) {
    let f = e[c];
    a.insert(0, f.scope, f.parentScopes, f.fontStyle, o.getId(f.foreground), o.getId(f.background));
  }
  return new Ub(o, s, a);
}
var wEe = class {
  _isFrozen;
  _lastColorId;
  _id2color;
  _color2id;
  constructor(e) {
    if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(e)) {
      this._isFrozen = !0;
      for (let t = 0, n = e.length; t < n; t++)
        this._color2id[e[t]] = t, this._id2color[t] = e[t];
    } else
      this._isFrozen = !1;
  }
  getId(e) {
    if (e === null)
      return 0;
    e = e.toUpperCase();
    let t = this._color2id[e];
    if (t)
      return t;
    if (this._isFrozen)
      throw new Error(`Missing color in color map - ${e}`);
    return t = ++this._lastColorId, this._color2id[e] = t, this._id2color[t] = e, t;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}, SEe = Object.freeze([]), Y_ = class e7 {
  scopeDepth;
  parentScopes;
  fontStyle;
  foreground;
  background;
  constructor(t, n, r, i, o) {
    this.scopeDepth = t, this.parentScopes = n || SEe, this.fontStyle = r, this.foreground = i, this.background = o;
  }
  clone() {
    return new e7(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
  }
  static cloneArr(t) {
    let n = [];
    for (let r = 0, i = t.length; r < i; r++)
      n[r] = t[r].clone();
    return n;
  }
  acceptOverwrite(t, n, r, i) {
    this.scopeDepth > t ? console.log("how did this happen?") : this.scopeDepth = t, n !== -1 && (this.fontStyle = n), r !== 0 && (this.foreground = r), i !== 0 && (this.background = i);
  }
}, kEe = class X_ {
  constructor(t, n = [], r = {}) {
    this._mainRule = t, this._children = r, this._rulesWithParentScopes = n;
  }
  _rulesWithParentScopes;
  static _cmpBySpecificity(t, n) {
    if (t.scopeDepth !== n.scopeDepth)
      return n.scopeDepth - t.scopeDepth;
    let r = 0, i = 0;
    for (; t.parentScopes[r] === ">" && r++, n.parentScopes[i] === ">" && i++, !(r >= t.parentScopes.length || i >= n.parentScopes.length); ) {
      const o = n.parentScopes[i].length - t.parentScopes[r].length;
      if (o !== 0)
        return o;
      r++, i++;
    }
    return n.parentScopes.length - t.parentScopes.length;
  }
  match(t) {
    if (t !== "") {
      let r = t.indexOf("."), i, o;
      if (r === -1 ? (i = t, o = "") : (i = t.substring(0, r), o = t.substring(r + 1)), this._children.hasOwnProperty(i))
        return this._children[i].match(o);
    }
    const n = this._rulesWithParentScopes.concat(this._mainRule);
    return n.sort(X_._cmpBySpecificity), n;
  }
  insert(t, n, r, i, o, s) {
    if (n === "") {
      this._doInsertHere(t, r, i, o, s);
      return;
    }
    let a = n.indexOf("."), c, u;
    a === -1 ? (c = n, u = "") : (c = n.substring(0, a), u = n.substring(a + 1));
    let f;
    this._children.hasOwnProperty(c) ? f = this._children[c] : (f = new X_(this._mainRule.clone(), Y_.cloneArr(this._rulesWithParentScopes)), this._children[c] = f), f.insert(t + 1, u, r, i, o, s);
  }
  _doInsertHere(t, n, r, i, o) {
    if (n === null) {
      this._mainRule.acceptOverwrite(t, r, i, o);
      return;
    }
    for (let s = 0, a = this._rulesWithParentScopes.length; s < a; s++) {
      let c = this._rulesWithParentScopes[s];
      if (YV(c.parentScopes, n) === 0) {
        c.acceptOverwrite(t, r, i, o);
        return;
      }
    }
    r === -1 && (r = this._mainRule.fontStyle), i === 0 && (i = this._mainRule.foreground), o === 0 && (o = this._mainRule.background), this._rulesWithParentScopes.push(new Y_(t, n, r, i, o));
  }
}, hh = class Ro {
  static toBinaryStr(t) {
    return t.toString(2).padStart(32, "0");
  }
  static print(t) {
    const n = Ro.getLanguageId(t), r = Ro.getTokenType(t), i = Ro.getFontStyle(t), o = Ro.getForeground(t), s = Ro.getBackground(t);
    console.log({
      languageId: n,
      tokenType: r,
      fontStyle: i,
      foreground: o,
      background: s
    });
  }
  static getLanguageId(t) {
    return (t & 255) >>> 0;
  }
  static getTokenType(t) {
    return (t & 768) >>> 8;
  }
  static containsBalancedBrackets(t) {
    return (t & 1024) !== 0;
  }
  static getFontStyle(t) {
    return (t & 30720) >>> 11;
  }
  static getForeground(t) {
    return (t & 16744448) >>> 15;
  }
  static getBackground(t) {
    return (t & 4278190080) >>> 24;
  }
  /**
   * Updates the fields in `metadata`.
   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.
   */
  static set(t, n, r, i, o, s, a) {
    let c = Ro.getLanguageId(t), u = Ro.getTokenType(t), f = Ro.containsBalancedBrackets(t) ? 1 : 0, h = Ro.getFontStyle(t), m = Ro.getForeground(t), g = Ro.getBackground(t);
    return n !== 0 && (c = n), r !== 8 && (u = r), i !== null && (f = i ? 1 : 0), o !== -1 && (h = o), s !== 0 && (m = s), a !== 0 && (g = a), (c << 0 | u << 8 | f << 10 | h << 11 | m << 15 | g << 24) >>> 0;
  }
};
function Fb(e, t) {
  const n = [], r = CEe(e);
  let i = r.next();
  for (; i !== null; ) {
    let c = 0;
    if (i.length === 2 && i.charAt(1) === ":") {
      switch (i.charAt(0)) {
        case "R":
          c = 1;
          break;
        case "L":
          c = -1;
          break;
        default:
          console.log(`Unknown priority ${i} in scope selector`);
      }
      i = r.next();
    }
    let u = s();
    if (n.push({ matcher: u, priority: c }), i !== ",")
      break;
    i = r.next();
  }
  return n;
  function o() {
    if (i === "-") {
      i = r.next();
      const c = o();
      return (u) => !!c && !c(u);
    }
    if (i === "(") {
      i = r.next();
      const c = a();
      return i === ")" && (i = r.next()), c;
    }
    if (Wz(i)) {
      const c = [];
      do
        c.push(i), i = r.next();
      while (Wz(i));
      return (u) => t(c, u);
    }
    return null;
  }
  function s() {
    const c = [];
    let u = o();
    for (; u; )
      c.push(u), u = o();
    return (f) => c.every((h) => h(f));
  }
  function a() {
    const c = [];
    let u = s();
    for (; u && (c.push(u), i === "|" || i === ","); ) {
      do
        i = r.next();
      while (i === "|" || i === ",");
      u = s();
    }
    return (f) => c.some((h) => h(f));
  }
}
function Wz(e) {
  return !!e && !!e.match(/[\w\.:]+/);
}
function CEe(e) {
  let t = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, n = t.exec(e);
  return {
    next: () => {
      if (!n)
        return null;
      const r = n[0];
      return n = t.exec(e), r;
    }
  };
}
function t7(e) {
  typeof e.dispose == "function" && e.dispose();
}
var fg = class {
  constructor(e) {
    this.scopeName = e;
  }
  toKey() {
    return this.scopeName;
  }
}, EEe = class {
  constructor(e, t) {
    this.scopeName = e, this.ruleName = t;
  }
  toKey() {
    return `${this.scopeName}#${this.ruleName}`;
  }
}, _Ee = class {
  _references = [];
  _seenReferenceKeys = /* @__PURE__ */ new Set();
  get references() {
    return this._references;
  }
  visitedRule = /* @__PURE__ */ new Set();
  add(e) {
    const t = e.toKey();
    this._seenReferenceKeys.has(t) || (this._seenReferenceKeys.add(t), this._references.push(e));
  }
}, TEe = class {
  constructor(e, t) {
    this.repo = e, this.initialScopeName = t, this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new fg(this.initialScopeName)];
  }
  seenFullScopeRequests = /* @__PURE__ */ new Set();
  seenPartialScopeRequests = /* @__PURE__ */ new Set();
  Q;
  processQueue() {
    const e = this.Q;
    this.Q = [];
    const t = new _Ee();
    for (const n of e)
      AEe(n, this.initialScopeName, this.repo, t);
    for (const n of t.references)
      if (n instanceof fg) {
        if (this.seenFullScopeRequests.has(n.scopeName))
          continue;
        this.seenFullScopeRequests.add(n.scopeName), this.Q.push(n);
      } else {
        if (this.seenFullScopeRequests.has(n.scopeName) || this.seenPartialScopeRequests.has(n.toKey()))
          continue;
        this.seenPartialScopeRequests.add(n.toKey()), this.Q.push(n);
      }
  }
};
function AEe(e, t, n, r) {
  const i = n.lookup(e.scopeName);
  if (!i) {
    if (e.scopeName === t)
      throw new Error(`No grammar provided for <${t}>`);
    return;
  }
  const o = n.lookup(t);
  e instanceof fg ? L0({ baseGrammar: o, selfGrammar: i }, r) : J_(
    e.ruleName,
    { baseGrammar: o, selfGrammar: i, repository: i.repository },
    r
  );
  const s = n.injections(e.scopeName);
  if (s)
    for (const a of s)
      r.add(new fg(a));
}
function J_(e, t, n) {
  if (t.repository && t.repository[e]) {
    const r = t.repository[e];
    Vb([r], t, n);
  }
}
function L0(e, t) {
  e.selfGrammar.patterns && Array.isArray(e.selfGrammar.patterns) && Vb(
    e.selfGrammar.patterns,
    { ...e, repository: e.selfGrammar.repository },
    t
  ), e.selfGrammar.injections && Vb(
    Object.values(e.selfGrammar.injections),
    { ...e, repository: e.selfGrammar.repository },
    t
  );
}
function Vb(e, t, n) {
  for (const r of e) {
    if (n.visitedRule.has(r))
      continue;
    n.visitedRule.add(r);
    const i = r.repository ? GV({}, t.repository, r.repository) : t.repository;
    Array.isArray(r.patterns) && Vb(r.patterns, { ...t, repository: i }, n);
    const o = r.include;
    if (!o)
      continue;
    const s = n7(o);
    switch (s.kind) {
      case 0:
        L0({ ...t, selfGrammar: t.baseGrammar }, n);
        break;
      case 1:
        L0(t, n);
        break;
      case 2:
        J_(s.ruleName, { ...t, repository: i }, n);
        break;
      case 3:
      case 4:
        const a = s.scopeName === t.selfGrammar.scopeName ? t.selfGrammar : s.scopeName === t.baseGrammar.scopeName ? t.baseGrammar : void 0;
        if (a) {
          const c = { baseGrammar: t.baseGrammar, selfGrammar: a, repository: i };
          s.kind === 4 ? J_(s.ruleName, c, n) : L0(c, n);
        } else
          s.kind === 4 ? n.add(new EEe(s.scopeName, s.ruleName)) : n.add(new fg(s.scopeName));
        break;
    }
  }
}
var MEe = class {
  kind = 0;
}, NEe = class {
  kind = 1;
}, REe = class {
  constructor(e) {
    this.ruleName = e;
  }
  kind = 2;
}, OEe = class {
  constructor(e) {
    this.scopeName = e;
  }
  kind = 3;
}, DEe = class {
  constructor(e, t) {
    this.scopeName = e, this.ruleName = t;
  }
  kind = 4;
};
function n7(e) {
  if (e === "$base")
    return new MEe();
  if (e === "$self")
    return new NEe();
  const t = e.indexOf("#");
  if (t === -1)
    return new OEe(e);
  if (t === 0)
    return new REe(e.substring(1));
  {
    const n = e.substring(0, t), r = e.substring(t + 1);
    return new DEe(n, r);
  }
}
var PEe = /\\(\d+)/, qz = /\\(\d+)/g, jEe = -1, r7 = -2;
var oy = class {
  $location;
  id;
  _nameIsCapturing;
  _name;
  _contentNameIsCapturing;
  _contentName;
  constructor(e, t, n, r) {
    this.$location = e, this.id = t, this._name = n || null, this._nameIsCapturing = Gv.hasCaptures(this._name), this._contentName = r || null, this._contentNameIsCapturing = Gv.hasCaptures(this._contentName);
  }
  get debugName() {
    const e = this.$location ? `${KV(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${e}`;
  }
  getName(e, t) {
    return !this._nameIsCapturing || this._name === null || e === null || t === null ? this._name : Gv.replaceCaptures(this._name, e, t);
  }
  getContentName(e, t) {
    return !this._contentNameIsCapturing || this._contentName === null ? this._contentName : Gv.replaceCaptures(this._contentName, e, t);
  }
}, IEe = class extends oy {
  retokenizeCapturedWithRuleId;
  constructor(e, t, n, r, i) {
    super(e, t, n, r), this.retokenizeCapturedWithRuleId = i;
  }
  dispose() {
  }
  collectPatterns(e, t) {
    throw new Error("Not supported!");
  }
  compile(e, t) {
    throw new Error("Not supported!");
  }
  compileAG(e, t, n, r) {
    throw new Error("Not supported!");
  }
}, zEe = class extends oy {
  _match;
  captures;
  _cachedCompiledPatterns;
  constructor(e, t, n, r, i) {
    super(e, t, n, null), this._match = new hg(r, this.id), this.captures = i, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugMatchRegExp() {
    return `${this._match.source}`;
  }
  collectPatterns(e, t) {
    t.push(this._match);
  }
  compile(e, t) {
    return this._getCachedCompiledPatterns(e).compile(e);
  }
  compileAG(e, t, n, r) {
    return this._getCachedCompiledPatterns(e).compileAG(e, n, r);
  }
  _getCachedCompiledPatterns(e) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new pg(), this.collectPatterns(e, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, Gz = class extends oy {
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(e, t, n, r, i) {
    super(e, t, n, r), this.patterns = i.patterns, this.hasMissingPatterns = i.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  collectPatterns(e, t) {
    for (const n of this.patterns)
      e.getRule(n).collectPatterns(e, t);
  }
  compile(e, t) {
    return this._getCachedCompiledPatterns(e).compile(e);
  }
  compileAG(e, t, n, r) {
    return this._getCachedCompiledPatterns(e).compileAG(e, n, r);
  }
  _getCachedCompiledPatterns(e) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new pg(), this.collectPatterns(e, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, Q_ = class extends oy {
  _begin;
  beginCaptures;
  _end;
  endHasBackReferences;
  endCaptures;
  applyEndPatternLast;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(e, t, n, r, i, o, s, a, c, u) {
    super(e, t, n, r), this._begin = new hg(i, this.id), this.beginCaptures = o, this._end = new hg(s || "", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = a, this.applyEndPatternLast = c || !1, this.patterns = u.patterns, this.hasMissingPatterns = u.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugEndRegExp() {
    return `${this._end.source}`;
  }
  getEndWithResolvedBackReferences(e, t) {
    return this._end.resolveBackReferences(e, t);
  }
  collectPatterns(e, t) {
    t.push(this._begin);
  }
  compile(e, t) {
    return this._getCachedCompiledPatterns(e, t).compile(e);
  }
  compileAG(e, t, n, r) {
    return this._getCachedCompiledPatterns(e, t).compileAG(e, n, r);
  }
  _getCachedCompiledPatterns(e, t) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new pg();
      for (const n of this.patterns)
        e.getRule(n).collectPatterns(e, this._cachedCompiledPatterns);
      this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
    }
    return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, t) : this._cachedCompiledPatterns.setSource(0, t)), this._cachedCompiledPatterns;
  }
}, Hb = class extends oy {
  _begin;
  beginCaptures;
  whileCaptures;
  _while;
  whileHasBackReferences;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  _cachedCompiledWhilePatterns;
  constructor(e, t, n, r, i, o, s, a, c) {
    super(e, t, n, r), this._begin = new hg(i, this.id), this.beginCaptures = o, this.whileCaptures = a, this._while = new hg(s, r7), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = c.patterns, this.hasMissingPatterns = c.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugWhileRegExp() {
    return `${this._while.source}`;
  }
  getWhileWithResolvedBackReferences(e, t) {
    return this._while.resolveBackReferences(e, t);
  }
  collectPatterns(e, t) {
    t.push(this._begin);
  }
  compile(e, t) {
    return this._getCachedCompiledPatterns(e).compile(e);
  }
  compileAG(e, t, n, r) {
    return this._getCachedCompiledPatterns(e).compileAG(e, n, r);
  }
  _getCachedCompiledPatterns(e) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new pg();
      for (const t of this.patterns)
        e.getRule(t).collectPatterns(e, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
  compileWhile(e, t) {
    return this._getCachedCompiledWhilePatterns(e, t).compile(e);
  }
  compileWhileAG(e, t, n, r) {
    return this._getCachedCompiledWhilePatterns(e, t).compileAG(e, n, r);
  }
  _getCachedCompiledWhilePatterns(e, t) {
    return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new pg(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, t || ""), this._cachedCompiledWhilePatterns;
  }
}, i7 = class di {
  static createCaptureRule(t, n, r, i, o) {
    return t.registerRule((s) => new IEe(n, s, r, i, o));
  }
  static getCompiledRuleId(t, n, r) {
    return t.id || n.registerRule((i) => {
      if (t.id = i, t.match)
        return new zEe(
          t.$vscodeTextmateLocation,
          t.id,
          t.name,
          t.match,
          di._compileCaptures(t.captures, n, r)
        );
      if (typeof t.begin > "u") {
        t.repository && (r = GV({}, r, t.repository));
        let o = t.patterns;
        return typeof o > "u" && t.include && (o = [{ include: t.include }]), new Gz(
          t.$vscodeTextmateLocation,
          t.id,
          t.name,
          t.contentName,
          di._compilePatterns(o, n, r)
        );
      }
      return t.while ? new Hb(
        t.$vscodeTextmateLocation,
        t.id,
        t.name,
        t.contentName,
        t.begin,
        di._compileCaptures(t.beginCaptures || t.captures, n, r),
        t.while,
        di._compileCaptures(t.whileCaptures || t.captures, n, r),
        di._compilePatterns(t.patterns, n, r)
      ) : new Q_(
        t.$vscodeTextmateLocation,
        t.id,
        t.name,
        t.contentName,
        t.begin,
        di._compileCaptures(t.beginCaptures || t.captures, n, r),
        t.end,
        di._compileCaptures(t.endCaptures || t.captures, n, r),
        t.applyEndPatternLast,
        di._compilePatterns(t.patterns, n, r)
      );
    }), t.id;
  }
  static _compileCaptures(t, n, r) {
    let i = [];
    if (t) {
      let o = 0;
      for (const s in t) {
        if (s === "$vscodeTextmateLocation")
          continue;
        const a = parseInt(s, 10);
        a > o && (o = a);
      }
      for (let s = 0; s <= o; s++)
        i[s] = null;
      for (const s in t) {
        if (s === "$vscodeTextmateLocation")
          continue;
        const a = parseInt(s, 10);
        let c = 0;
        t[s].patterns && (c = di.getCompiledRuleId(t[s], n, r)), i[a] = di.createCaptureRule(n, t[s].$vscodeTextmateLocation, t[s].name, t[s].contentName, c);
      }
    }
    return i;
  }
  static _compilePatterns(t, n, r) {
    let i = [];
    if (t)
      for (let o = 0, s = t.length; o < s; o++) {
        const a = t[o];
        let c = -1;
        if (a.include) {
          const u = n7(a.include);
          switch (u.kind) {
            case 0:
            case 1:
              c = di.getCompiledRuleId(r[a.include], n, r);
              break;
            case 2:
              let f = r[u.ruleName];
              f && (c = di.getCompiledRuleId(f, n, r));
              break;
            case 3:
            case 4:
              const h = u.scopeName, m = u.kind === 4 ? u.ruleName : null, g = n.getExternalGrammar(h, r);
              if (g)
                if (m) {
                  let b = g.repository[m];
                  b && (c = di.getCompiledRuleId(b, n, g.repository));
                } else
                  c = di.getCompiledRuleId(g.repository.$self, n, g.repository);
              break;
          }
        } else
          c = di.getCompiledRuleId(a, n, r);
        if (c !== -1) {
          const u = n.getRule(c);
          let f = !1;
          if ((u instanceof Gz || u instanceof Q_ || u instanceof Hb) && u.hasMissingPatterns && u.patterns.length === 0 && (f = !0), f)
            continue;
          i.push(c);
        }
      }
    return {
      patterns: i,
      hasMissingPatterns: (t ? t.length : 0) !== i.length
    };
  }
}, hg = class o7 {
  source;
  ruleId;
  hasAnchor;
  hasBackReferences;
  _anchorCache;
  constructor(t, n) {
    if (t && typeof t == "string") {
      const r = t.length;
      let i = 0, o = [], s = !1;
      for (let a = 0; a < r; a++)
        if (t.charAt(a) === "\\" && a + 1 < r) {
          const u = t.charAt(a + 1);
          u === "z" ? (o.push(t.substring(i, a)), o.push("$(?!\\n)(?<!\\n)"), i = a + 2) : (u === "A" || u === "G") && (s = !0), a++;
        }
      this.hasAnchor = s, i === 0 ? this.source = t : (o.push(t.substring(i, r)), this.source = o.join(""));
    } else
      this.hasAnchor = !1, this.source = t;
    this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = n, typeof this.source == "string" ? this.hasBackReferences = PEe.test(this.source) : this.hasBackReferences = !1;
  }
  clone() {
    return new o7(this.source, this.ruleId);
  }
  setSource(t) {
    this.source !== t && (this.source = t, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
  }
  resolveBackReferences(t, n) {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let r = n.map((i) => t.substring(i.start, i.end));
    return qz.lastIndex = 0, this.source.replace(qz, (i, o) => XV(r[parseInt(o, 10)] || ""));
  }
  _buildAnchorCache() {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let t = [], n = [], r = [], i = [], o, s, a, c;
    for (o = 0, s = this.source.length; o < s; o++)
      a = this.source.charAt(o), t[o] = a, n[o] = a, r[o] = a, i[o] = a, a === "\\" && o + 1 < s && (c = this.source.charAt(o + 1), c === "A" ? (t[o + 1] = "", n[o + 1] = "", r[o + 1] = "A", i[o + 1] = "A") : c === "G" ? (t[o + 1] = "", n[o + 1] = "G", r[o + 1] = "", i[o + 1] = "G") : (t[o + 1] = c, n[o + 1] = c, r[o + 1] = c, i[o + 1] = c), o++);
    return {
      A0_G0: t.join(""),
      A0_G1: n.join(""),
      A1_G0: r.join(""),
      A1_G1: i.join("")
    };
  }
  resolveAnchors(t, n) {
    return !this.hasAnchor || !this._anchorCache || typeof this.source != "string" ? this.source : t ? n ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : n ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0;
  }
}, pg = class {
  _items;
  _hasAnchors;
  _cached;
  _anchorCache;
  constructor() {
    this._items = [], this._hasAnchors = !1, this._cached = null, this._anchorCache = {
      A0_G0: null,
      A0_G1: null,
      A1_G0: null,
      A1_G1: null
    };
  }
  dispose() {
    this._disposeCaches();
  }
  _disposeCaches() {
    this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
  }
  push(e) {
    this._items.push(e), this._hasAnchors = this._hasAnchors || e.hasAnchor;
  }
  unshift(e) {
    this._items.unshift(e), this._hasAnchors = this._hasAnchors || e.hasAnchor;
  }
  length() {
    return this._items.length;
  }
  setSource(e, t) {
    this._items[e].source !== t && (this._disposeCaches(), this._items[e].setSource(t));
  }
  compile(e) {
    if (!this._cached) {
      let t = this._items.map((n) => n.source);
      this._cached = new Kz(e, t, this._items.map((n) => n.ruleId));
    }
    return this._cached;
  }
  compileAG(e, t, n) {
    return this._hasAnchors ? t ? n ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(e, t, n)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(e, t, n)), this._anchorCache.A1_G0) : n ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(e, t, n)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(e, t, n)), this._anchorCache.A0_G0) : this.compile(e);
  }
  _resolveAnchors(e, t, n) {
    let r = this._items.map((i) => i.resolveAnchors(t, n));
    return new Kz(e, r, this._items.map((i) => i.ruleId));
  }
}, Kz = class {
  constructor(e, t, n) {
    this.regExps = t, this.rules = n, this.scanner = e.createOnigScanner(t);
  }
  scanner;
  dispose() {
    typeof this.scanner.dispose == "function" && this.scanner.dispose();
  }
  toString() {
    const e = [];
    for (let t = 0, n = this.rules.length; t < n; t++)
      e.push("   - " + this.rules[t] + ": " + this.regExps[t]);
    return e.join(`
`);
  }
  findNextMatchSync(e, t, n) {
    const r = this.scanner.findNextMatchSync(e, t, n);
    return r ? {
      ruleId: this.rules[r.index],
      captureIndices: r.captureIndices
    } : null;
  }
}, IC = class {
  constructor(e, t) {
    this.languageId = e, this.tokenType = t;
  }
}, LEe = class eT {
  _defaultAttributes;
  _embeddedLanguagesMatcher;
  constructor(t, n) {
    this._defaultAttributes = new IC(
      t,
      8
      /* NotSet */
    ), this._embeddedLanguagesMatcher = new BEe(Object.entries(n || {}));
  }
  getDefaultAttributes() {
    return this._defaultAttributes;
  }
  getBasicScopeAttributes(t) {
    return t === null ? eT._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(t);
  }
  static _NULL_SCOPE_METADATA = new IC(0, 0);
  _getBasicScopeAttributes = new JV((t) => {
    const n = this._scopeToLanguage(t), r = this._toStandardTokenType(t);
    return new IC(n, r);
  });
  /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */
  _scopeToLanguage(t) {
    return this._embeddedLanguagesMatcher.match(t) || 0;
  }
  _toStandardTokenType(t) {
    const n = t.match(eT.STANDARD_TOKEN_TYPE_REGEXP);
    if (!n)
      return 8;
    switch (n[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "meta.embedded":
        return 0;
    }
    throw new Error("Unexpected match for standard token type!");
  }
  static STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/;
}, BEe = class {
  values;
  scopesRegExp;
  constructor(e) {
    if (e.length === 0)
      this.values = null, this.scopesRegExp = null;
    else {
      this.values = new Map(e);
      const t = e.map(
        ([n, r]) => XV(n)
      );
      t.sort(), t.reverse(), this.scopesRegExp = new RegExp(
        `^((${t.join(")|(")}))($|\\.)`,
        ""
      );
    }
  }
  match(e) {
    if (!this.scopesRegExp)
      return;
    const t = e.match(this.scopesRegExp);
    if (t)
      return this.values.get(t[1]);
  }
};
typeof process < "u" && process.env.VSCODE_TEXTMATE_DEBUG;
var Zz = class {
  constructor(e, t) {
    this.stack = e, this.stoppedEarly = t;
  }
};
function s7(e, t, n, r, i, o, s, a) {
  const c = t.content.length;
  let u = !1, f = -1;
  if (s) {
    const g = $Ee(
      e,
      t,
      n,
      r,
      i,
      o
    );
    i = g.stack, r = g.linePos, n = g.isFirstLine, f = g.anchorPosition;
  }
  const h = Date.now();
  for (; !u; ) {
    if (a !== 0 && Date.now() - h > a)
      return new Zz(i, !0);
    m();
  }
  return new Zz(i, !1);
  function m() {
    const g = UEe(
      e,
      t,
      n,
      r,
      i,
      f
    );
    if (!g) {
      o.produce(i, c), u = !0;
      return;
    }
    const b = g.captureIndices, x = g.matchedRuleId, w = b && b.length > 0 ? b[0].end > r : !1;
    if (x === jEe) {
      const S = i.getRule(e);
      o.produce(i, b[0].start), i = i.withContentNameScopesList(i.nameScopesList), pm(
        e,
        t,
        n,
        i,
        o,
        S.endCaptures,
        b
      ), o.produce(i, b[0].end);
      const _ = i;
      if (i = i.parent, f = _.getAnchorPos(), !w && _.getEnterPos() === r) {
        i = _, o.produce(i, c), u = !0;
        return;
      }
    } else {
      const S = e.getRule(x);
      o.produce(i, b[0].start);
      const _ = i, M = S.getName(t.content, b), N = i.contentNameScopesList.pushAttributed(
        M,
        e
      );
      if (i = i.push(
        x,
        r,
        f,
        b[0].end === c,
        null,
        N,
        N
      ), S instanceof Q_) {
        const P = S;
        pm(
          e,
          t,
          n,
          i,
          o,
          P.beginCaptures,
          b
        ), o.produce(i, b[0].end), f = b[0].end;
        const I = P.getContentName(
          t.content,
          b
        ), O = N.pushAttributed(
          I,
          e
        );
        if (i = i.withContentNameScopesList(O), P.endHasBackReferences && (i = i.withEndRule(
          P.getEndWithResolvedBackReferences(
            t.content,
            b
          )
        )), !w && _.hasSameRuleAs(i)) {
          i = i.pop(), o.produce(i, c), u = !0;
          return;
        }
      } else if (S instanceof Hb) {
        const P = S;
        pm(
          e,
          t,
          n,
          i,
          o,
          P.beginCaptures,
          b
        ), o.produce(i, b[0].end), f = b[0].end;
        const I = P.getContentName(
          t.content,
          b
        ), O = N.pushAttributed(
          I,
          e
        );
        if (i = i.withContentNameScopesList(O), P.whileHasBackReferences && (i = i.withEndRule(
          P.getWhileWithResolvedBackReferences(
            t.content,
            b
          )
        )), !w && _.hasSameRuleAs(i)) {
          i = i.pop(), o.produce(i, c), u = !0;
          return;
        }
      } else if (pm(
        e,
        t,
        n,
        i,
        o,
        S.captures,
        b
      ), o.produce(i, b[0].end), i = i.pop(), !w) {
        i = i.safePop(), o.produce(i, c), u = !0;
        return;
      }
    }
    b[0].end > r && (r = b[0].end, n = !1);
  }
}
function $Ee(e, t, n, r, i, o) {
  let s = i.beginRuleCapturedEOL ? 0 : -1;
  const a = [];
  for (let c = i; c; c = c.pop()) {
    const u = c.getRule(e);
    u instanceof Hb && a.push({
      rule: u,
      stack: c
    });
  }
  for (let c = a.pop(); c; c = a.pop()) {
    const { ruleScanner: u, findOptions: f } = HEe(c.rule, e, c.stack.endRule, n, r === s), h = u.findNextMatchSync(t, r, f);
    if (h) {
      if (h.ruleId !== r7) {
        i = c.stack.pop();
        break;
      }
      h.captureIndices && h.captureIndices.length && (o.produce(c.stack, h.captureIndices[0].start), pm(e, t, n, c.stack, o, c.rule.whileCaptures, h.captureIndices), o.produce(c.stack, h.captureIndices[0].end), s = h.captureIndices[0].end, h.captureIndices[0].end > r && (r = h.captureIndices[0].end, n = !1));
    } else {
      i = c.stack.pop();
      break;
    }
  }
  return { stack: i, linePos: r, anchorPosition: s, isFirstLine: n };
}
function UEe(e, t, n, r, i, o) {
  const s = FEe(e, t, n, r, i, o), a = e.getInjections();
  if (a.length === 0)
    return s;
  const c = VEe(a, e, t, n, r, i, o);
  if (!c)
    return s;
  if (!s)
    return c;
  const u = s.captureIndices[0].start, f = c.captureIndices[0].start;
  return f < u || c.priorityMatch && f === u ? c : s;
}
function FEe(e, t, n, r, i, o) {
  const s = i.getRule(e), { ruleScanner: a, findOptions: c } = a7(s, e, i.endRule, n, r === o), u = a.findNextMatchSync(t, r, c);
  return u ? {
    captureIndices: u.captureIndices,
    matchedRuleId: u.ruleId
  } : null;
}
function VEe(e, t, n, r, i, o, s) {
  let a = Number.MAX_VALUE, c = null, u, f = 0;
  const h = o.contentNameScopesList.getScopeNames();
  for (let m = 0, g = e.length; m < g; m++) {
    const b = e[m];
    if (!b.matcher(h))
      continue;
    const x = t.getRule(b.ruleId), { ruleScanner: w, findOptions: S } = a7(x, t, null, r, i === s), _ = w.findNextMatchSync(n, i, S);
    if (!_)
      continue;
    const M = _.captureIndices[0].start;
    if (!(M >= a) && (a = M, c = _.captureIndices, u = _.ruleId, f = b.priority, a === i))
      break;
  }
  return c ? {
    priorityMatch: f === -1,
    captureIndices: c,
    matchedRuleId: u
  } : null;
}
function a7(e, t, n, r, i) {
  return {
    ruleScanner: e.compileAG(t, n, r, i),
    findOptions: 0
    /* None */
  };
}
function HEe(e, t, n, r, i) {
  return {
    ruleScanner: e.compileWhileAG(t, n, r, i),
    findOptions: 0
    /* None */
  };
}
function pm(e, t, n, r, i, o, s) {
  if (o.length === 0)
    return;
  const a = t.content, c = Math.min(o.length, s.length), u = [], f = s[0].end;
  for (let h = 0; h < c; h++) {
    const m = o[h];
    if (m === null)
      continue;
    const g = s[h];
    if (g.length === 0)
      continue;
    if (g.start > f)
      break;
    for (; u.length > 0 && u[u.length - 1].endPos <= g.start; )
      i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
    if (u.length > 0 ? i.produceFromScopes(u[u.length - 1].scopes, g.start) : i.produce(r, g.start), m.retokenizeCapturedWithRuleId) {
      const x = m.getName(a, s), w = r.contentNameScopesList.pushAttributed(x, e), S = m.getContentName(a, s), _ = w.pushAttributed(S, e), M = r.push(m.retokenizeCapturedWithRuleId, g.start, -1, !1, null, w, _), N = e.createOnigString(a.substring(0, g.end));
      s7(
        e,
        N,
        n && g.start === 0,
        g.start,
        M,
        i,
        !1,
        /* no time limit */
        0
      ), t7(N);
      continue;
    }
    const b = m.getName(a, s);
    if (b !== null) {
      const w = (u.length > 0 ? u[u.length - 1].scopes : r.contentNameScopesList).pushAttributed(b, e);
      u.push(new WEe(w, g.end));
    }
  }
  for (; u.length > 0; )
    i.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
}
var WEe = class {
  scopes;
  endPos;
  constructor(e, t) {
    this.scopes = e, this.endPos = t;
  }
};
function qEe(e, t, n, r, i, o, s, a) {
  return new KEe(
    e,
    t,
    n,
    r,
    i,
    o,
    s,
    a
  );
}
function Yz(e, t, n, r, i) {
  const o = Fb(t, Wb), s = i7.getCompiledRuleId(n, r, i.repository);
  for (const a of o)
    e.push({
      debugSelector: t,
      matcher: a.matcher,
      ruleId: s,
      grammar: i,
      priority: a.priority
    });
}
function Wb(e, t) {
  if (t.length < e.length)
    return !1;
  let n = 0;
  return e.every((r) => {
    for (let i = n; i < t.length; i++)
      if (GEe(t[i], r))
        return n = i + 1, !0;
    return !1;
  });
}
function GEe(e, t) {
  if (!e)
    return !1;
  if (e === t)
    return !0;
  const n = t.length;
  return e.length > n && e.substr(0, n) === t && e[n] === ".";
}
var KEe = class {
  constructor(e, t, n, r, i, o, s, a) {
    if (this._rootScopeName = e, this.balancedBracketSelectors = o, this._onigLib = a, this._basicScopeAttributesProvider = new LEe(
      n,
      r
    ), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = s, this._grammar = Xz(t, null), this._injections = null, this._tokenTypeMatchers = [], i)
      for (const c of Object.keys(i)) {
        const u = Fb(c, Wb);
        for (const f of u)
          this._tokenTypeMatchers.push({
            matcher: f.matcher,
            type: i[c]
          });
      }
  }
  _rootId;
  _lastRuleId;
  _ruleId2desc;
  _includedGrammars;
  _grammarRepository;
  _grammar;
  _injections;
  _basicScopeAttributesProvider;
  _tokenTypeMatchers;
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (const e of this._ruleId2desc)
      e && e.dispose();
  }
  createOnigScanner(e) {
    return this._onigLib.createOnigScanner(e);
  }
  createOnigString(e) {
    return this._onigLib.createOnigString(e);
  }
  getMetadataForScope(e) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(e);
  }
  _collectInjections() {
    const e = {
      lookup: (i) => i === this._rootScopeName ? this._grammar : this.getExternalGrammar(i),
      injections: (i) => this._grammarRepository.injections(i)
    }, t = [], n = this._rootScopeName, r = e.lookup(n);
    if (r) {
      const i = r.injections;
      if (i)
        for (let s in i)
          Yz(
            t,
            s,
            i[s],
            this,
            r
          );
      const o = this._grammarRepository.injections(n);
      o && o.forEach((s) => {
        const a = this.getExternalGrammar(s);
        if (a) {
          const c = a.injectionSelector;
          c && Yz(
            t,
            c,
            a,
            this,
            a
          );
        }
      });
    }
    return t.sort((i, o) => i.priority - o.priority), t;
  }
  getInjections() {
    return this._injections === null && (this._injections = this._collectInjections()), this._injections;
  }
  registerRule(e) {
    const t = ++this._lastRuleId, n = e(t);
    return this._ruleId2desc[t] = n, n;
  }
  getRule(e) {
    return this._ruleId2desc[e];
  }
  getExternalGrammar(e, t) {
    if (this._includedGrammars[e])
      return this._includedGrammars[e];
    if (this._grammarRepository) {
      const n = this._grammarRepository.lookup(e);
      if (n)
        return this._includedGrammars[e] = Xz(
          n,
          t && t.$base
        ), this._includedGrammars[e];
    }
  }
  tokenizeLine(e, t, n = 0) {
    const r = this._tokenize(e, t, !1, n);
    return {
      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  tokenizeLine2(e, t, n = 0) {
    const r = this._tokenize(e, t, !0, n);
    return {
      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  _tokenize(e, t, n, r) {
    this._rootId === -1 && (this._rootId = i7.getCompiledRuleId(
      this._grammar.repository.$self,
      this,
      this._grammar.repository
    ), this.getInjections());
    let i;
    if (!t || t === tT.NULL) {
      i = !0;
      const u = this._basicScopeAttributesProvider.getDefaultAttributes(), f = this.themeProvider.getDefaults(), h = hh.set(
        0,
        u.languageId,
        u.tokenType,
        null,
        f.fontStyle,
        f.foregroundId,
        f.backgroundId
      ), m = this.getRule(this._rootId).getName(
        null,
        null
      );
      let g;
      m ? g = Pm.createRootAndLookUpScopeName(
        m,
        h,
        this
      ) : g = Pm.createRoot(
        "unknown",
        h
      ), t = new tT(
        null,
        this._rootId,
        -1,
        -1,
        !1,
        null,
        g,
        g
      );
    } else
      i = !1, t.reset();
    e = e + `
`;
    const o = this.createOnigString(e), s = o.content.length, a = new YEe(
      n,
      e,
      this._tokenTypeMatchers,
      this.balancedBracketSelectors
    ), c = s7(
      this,
      o,
      i,
      0,
      t,
      a,
      !0,
      r
    );
    return t7(o), {
      lineLength: s,
      lineTokens: a,
      ruleStack: c.stack,
      stoppedEarly: c.stoppedEarly
    };
  }
};
function Xz(e, t) {
  return e = hEe(e), e.repository = e.repository || {}, e.repository.$self = {
    $vscodeTextmateLocation: e.$vscodeTextmateLocation,
    patterns: e.patterns,
    name: e.scopeName
  }, e.repository.$base = t || e.repository.$self, e;
}
var Pm = class Ps {
  /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(t, n, r) {
    this.parent = t, this.scopePath = n, this.tokenAttributes = r;
  }
  static fromExtension(t, n) {
    let r = t, i = t?.scopePath ?? null;
    for (const o of n)
      i = jC.push(i, o.scopeNames), r = new Ps(r, i, o.encodedTokenAttributes);
    return r;
  }
  static createRoot(t, n) {
    return new Ps(null, new jC(null, t), n);
  }
  static createRootAndLookUpScopeName(t, n, r) {
    const i = r.getMetadataForScope(t), o = new jC(null, t), s = r.themeProvider.themeMatch(o), a = Ps.mergeAttributes(
      n,
      i,
      s
    );
    return new Ps(null, o, a);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(t) {
    return Ps.equals(this, t);
  }
  static equals(t, n) {
    do {
      if (t === n || !t && !n)
        return !0;
      if (!t || !n || t.scopeName !== n.scopeName || t.tokenAttributes !== n.tokenAttributes)
        return !1;
      t = t.parent, n = n.parent;
    } while (!0);
  }
  static mergeAttributes(t, n, r) {
    let i = -1, o = 0, s = 0;
    return r !== null && (i = r.fontStyle, o = r.foregroundId, s = r.backgroundId), hh.set(
      t,
      n.languageId,
      n.tokenType,
      null,
      i,
      o,
      s
    );
  }
  pushAttributed(t, n) {
    if (t === null)
      return this;
    if (t.indexOf(" ") === -1)
      return Ps._pushAttributed(this, t, n);
    const r = t.split(/ /g);
    let i = this;
    for (const o of r)
      i = Ps._pushAttributed(i, o, n);
    return i;
  }
  static _pushAttributed(t, n, r) {
    const i = r.getMetadataForScope(n), o = t.scopePath.push(n), s = r.themeProvider.themeMatch(o), a = Ps.mergeAttributes(
      t.tokenAttributes,
      i,
      s
    );
    return new Ps(t, o, a);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(t) {
    const n = [];
    let r = this;
    for (; r && r !== t; )
      n.push({
        encodedTokenAttributes: r.tokenAttributes,
        scopeNames: r.scopePath.getExtensionIfDefined(r.parent?.scopePath ?? null)
      }), r = r.parent;
    return r === t ? n.reverse() : void 0;
  }
}, tT = class Mu {
  /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(t, n, r, i, o, s, a, c) {
    this.parent = t, this.ruleId = n, this.beginRuleCapturedEOL = o, this.endRule = s, this.nameScopesList = a, this.contentNameScopesList = c, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = r, this._anchorPos = i;
  }
  _stackElementBrand = void 0;
  // TODO remove me
  static NULL = new Mu(
    null,
    0,
    0,
    0,
    !1,
    null,
    null,
    null
  );
  /**
   * The position on the current line where this state was pushed.
   * This is relevant only while tokenizing a line, to detect endless loops.
   * Its value is meaningless across lines.
   */
  _enterPos;
  /**
   * The captured anchor position when this stack element was pushed.
   * This is relevant only while tokenizing a line, to restore the anchor position when popping.
   * Its value is meaningless across lines.
   */
  _anchorPos;
  /**
   * The depth of the stack.
   */
  depth;
  equals(t) {
    return t === null ? !1 : Mu._equals(this, t);
  }
  static _equals(t, n) {
    return t === n ? !0 : this._structuralEquals(t, n) ? Pm.equals(t.contentNameScopesList, n.contentNameScopesList) : !1;
  }
  /**
   * A structural equals check. Does not take into account `scopes`.
   */
  static _structuralEquals(t, n) {
    do {
      if (t === n || !t && !n)
        return !0;
      if (!t || !n || t.depth !== n.depth || t.ruleId !== n.ruleId || t.endRule !== n.endRule)
        return !1;
      t = t.parent, n = n.parent;
    } while (!0);
  }
  clone() {
    return this;
  }
  static _reset(t) {
    for (; t; )
      t._enterPos = -1, t._anchorPos = -1, t = t.parent;
  }
  reset() {
    Mu._reset(this);
  }
  pop() {
    return this.parent;
  }
  safePop() {
    return this.parent ? this.parent : this;
  }
  push(t, n, r, i, o, s, a) {
    return new Mu(
      this,
      t,
      n,
      r,
      i,
      o,
      s,
      a
    );
  }
  getEnterPos() {
    return this._enterPos;
  }
  getAnchorPos() {
    return this._anchorPos;
  }
  getRule(t) {
    return t.getRule(this.ruleId);
  }
  toString() {
    const t = [];
    return this._writeString(t, 0), "[" + t.join(",") + "]";
  }
  _writeString(t, n) {
    return this.parent && (n = this.parent._writeString(t, n)), t[n++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`, n;
  }
  withContentNameScopesList(t) {
    return this.contentNameScopesList === t ? this : this.parent.push(
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      this.endRule,
      this.nameScopesList,
      t
    );
  }
  withEndRule(t) {
    return this.endRule === t ? this : new Mu(
      this.parent,
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      t,
      this.nameScopesList,
      this.contentNameScopesList
    );
  }
  // Used to warn of endless loops
  hasSameRuleAs(t) {
    let n = this;
    for (; n && n._enterPos === t._enterPos; ) {
      if (n.ruleId === t.ruleId)
        return !0;
      n = n.parent;
    }
    return !1;
  }
  toStateStackFrame() {
    return {
      ruleId: this.ruleId,
      beginRuleCapturedEOL: this.beginRuleCapturedEOL,
      endRule: this.endRule,
      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],
      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []
    };
  }
  static pushFrame(t, n) {
    const r = Pm.fromExtension(t?.nameScopesList ?? null, n.nameScopesList);
    return new Mu(
      t,
      n.ruleId,
      n.enterPos ?? -1,
      n.anchorPos ?? -1,
      n.beginRuleCapturedEOL,
      n.endRule,
      r,
      Pm.fromExtension(r, n.contentNameScopesList)
    );
  }
}, ZEe = class {
  balancedBracketScopes;
  unbalancedBracketScopes;
  allowAny = !1;
  constructor(e, t) {
    this.balancedBracketScopes = e.flatMap(
      (n) => n === "*" ? (this.allowAny = !0, []) : Fb(n, Wb).map((r) => r.matcher)
    ), this.unbalancedBracketScopes = t.flatMap(
      (n) => Fb(n, Wb).map((r) => r.matcher)
    );
  }
  get matchesAlways() {
    return this.allowAny && this.unbalancedBracketScopes.length === 0;
  }
  get matchesNever() {
    return this.balancedBracketScopes.length === 0 && !this.allowAny;
  }
  match(e) {
    for (const t of this.unbalancedBracketScopes)
      if (t(e))
        return !1;
    for (const t of this.balancedBracketScopes)
      if (t(e))
        return !0;
    return this.allowAny;
  }
}, YEe = class {
  constructor(e, t, n, r) {
    this.balancedBracketSelectors = r, this._emitBinaryTokens = e, this._tokenTypeOverrides = n, this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
  }
  _emitBinaryTokens;
  /**
   * defined only if `false`.
   */
  _lineText;
  /**
   * used only if `_emitBinaryTokens` is false.
   */
  _tokens;
  /**
   * used only if `_emitBinaryTokens` is true.
   */
  _binaryTokens;
  _lastTokenEndIndex;
  _tokenTypeOverrides;
  produce(e, t) {
    this.produceFromScopes(e.contentNameScopesList, t);
  }
  produceFromScopes(e, t) {
    if (this._lastTokenEndIndex >= t)
      return;
    if (this._emitBinaryTokens) {
      let r = e?.tokenAttributes ?? 0, i = !1;
      if (this.balancedBracketSelectors?.matchesAlways && (i = !0), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
        const o = e?.getScopeNames() ?? [];
        for (const s of this._tokenTypeOverrides)
          s.matcher(o) && (r = hh.set(
            r,
            0,
            s.type,
            null,
            -1,
            0,
            0
          ));
        this.balancedBracketSelectors && (i = this.balancedBracketSelectors.match(o));
      }
      if (i && (r = hh.set(
        r,
        0,
        8,
        i,
        -1,
        0,
        0
      )), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === r) {
        this._lastTokenEndIndex = t;
        return;
      }
      this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(r), this._lastTokenEndIndex = t;
      return;
    }
    const n = e?.getScopeNames() ?? [];
    this._tokens.push({
      startIndex: this._lastTokenEndIndex,
      endIndex: t,
      // value: lineText.substring(lastTokenEndIndex, endIndex),
      scopes: n
    }), this._lastTokenEndIndex = t;
  }
  getResult(e, t) {
    return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === t - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(e, t), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
  }
  getBinaryResult(e, t) {
    this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === t - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(e, t), this._binaryTokens[this._binaryTokens.length - 2] = 0);
    const n = new Uint32Array(this._binaryTokens.length);
    for (let r = 0, i = this._binaryTokens.length; r < i; r++)
      n[r] = this._binaryTokens[r];
    return n;
  }
}, XEe = class {
  constructor(e, t) {
    this._onigLib = t, this._theme = e;
  }
  _grammars = /* @__PURE__ */ new Map();
  _rawGrammars = /* @__PURE__ */ new Map();
  _injectionGrammars = /* @__PURE__ */ new Map();
  _theme;
  dispose() {
    for (const e of this._grammars.values())
      e.dispose();
  }
  setTheme(e) {
    this._theme = e;
  }
  getColorMap() {
    return this._theme.getColorMap();
  }
  /**
   * Add `grammar` to registry and return a list of referenced scope names
   */
  addGrammar(e, t) {
    this._rawGrammars.set(e.scopeName, e), t && this._injectionGrammars.set(e.scopeName, t);
  }
  /**
   * Lookup a raw grammar.
   */
  lookup(e) {
    return this._rawGrammars.get(e);
  }
  /**
   * Returns the injections for the given grammar
   */
  injections(e) {
    return this._injectionGrammars.get(e);
  }
  /**
   * Get the default theme settings
   */
  getDefaults() {
    return this._theme.getDefaults();
  }
  /**
   * Match a scope in the theme.
   */
  themeMatch(e) {
    return this._theme.match(e);
  }
  /**
   * Lookup a grammar.
   */
  grammarForScopeName(e, t, n, r, i) {
    if (!this._grammars.has(e)) {
      let o = this._rawGrammars.get(e);
      if (!o)
        return null;
      this._grammars.set(e, qEe(
        e,
        o,
        t,
        n,
        r,
        i,
        this,
        this._onigLib
      ));
    }
    return this._grammars.get(e);
  }
}, JEe = class {
  _options;
  _syncRegistry;
  _ensureGrammarCache;
  constructor(t) {
    this._options = t, this._syncRegistry = new XEe(
      Ub.createFromRawTheme(t.theme, t.colorMap),
      t.onigLib
    ), this._ensureGrammarCache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._syncRegistry.dispose();
  }
  /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */
  setTheme(t, n) {
    this._syncRegistry.setTheme(Ub.createFromRawTheme(t, n));
  }
  /**
   * Returns a lookup array for color ids.
   */
  getColorMap() {
    return this._syncRegistry.getColorMap();
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithEmbeddedLanguages(t, n, r) {
    return this.loadGrammarWithConfiguration(t, n, { embeddedLanguages: r });
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithConfiguration(t, n, r) {
    return this._loadGrammar(
      t,
      n,
      r.embeddedLanguages,
      r.tokenTypes,
      new ZEe(
        r.balancedBracketSelectors || [],
        r.unbalancedBracketSelectors || []
      )
    );
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */
  loadGrammar(t) {
    return this._loadGrammar(t, 0, null, null, null);
  }
  _loadGrammar(t, n, r, i, o) {
    const s = new TEe(this._syncRegistry, t);
    for (; s.Q.length > 0; )
      s.Q.map((a) => this._loadSingleGrammar(a.scopeName)), s.processQueue();
    return this._grammarForScopeName(
      t,
      n,
      r,
      i,
      o
    );
  }
  _loadSingleGrammar(t) {
    this._ensureGrammarCache.has(t) || (this._doLoadSingleGrammar(t), this._ensureGrammarCache.set(t, !0));
  }
  _doLoadSingleGrammar(t) {
    const n = this._options.loadGrammar(t);
    if (n) {
      const r = typeof this._options.getInjections == "function" ? this._options.getInjections(t) : void 0;
      this._syncRegistry.addGrammar(n, r);
    }
  }
  /**
   * Adds a rawGrammar.
   */
  addGrammar(t, n = [], r = 0, i = null) {
    return this._syncRegistry.addGrammar(t, n), this._grammarForScopeName(t.scopeName, r, i);
  }
  /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */
  _grammarForScopeName(t, n = 0, r = null, i = null, o = null) {
    return this._syncRegistry.grammarForScopeName(
      t,
      n,
      r,
      i,
      o
    );
  }
}, nT = tT.NULL;
const QEe = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], e_e = /["&'<>`]/g, t_e = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, n_e = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), r_e = /[|\\{}()[\]^$+*?.]/g, Jz = /* @__PURE__ */ new WeakMap();
function i_e(e, t) {
  if (e = e.replace(
    t.subset ? o_e(t.subset) : e_e,
    r
  ), t.subset || t.escapeOnly)
    return e;
  return e.replace(t_e, n).replace(n_e, r);
  function n(i, o, s) {
    return t.format(
      (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
      s.charCodeAt(o + 2),
      t
    );
  }
  function r(i, o, s) {
    return t.format(
      i.charCodeAt(0),
      s.charCodeAt(o + 1),
      t
    );
  }
}
function o_e(e) {
  let t = Jz.get(e);
  return t || (t = s_e(e), Jz.set(e, t)), t;
}
function s_e(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t.push(e[n].replace(r_e, "\\$&"));
  return new RegExp("(?:" + t.join("|") + ")", "g");
}
const a_e = /[\dA-Fa-f]/;
function l_e(e, t, n) {
  const r = "&#x" + e.toString(16).toUpperCase();
  return n && t && !a_e.test(String.fromCharCode(t)) ? r : r + ";";
}
const c_e = /\d/;
function u_e(e, t, n) {
  const r = "&#" + String(e);
  return n && t && !c_e.test(String.fromCharCode(t)) ? r : r + ";";
}
const d_e = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], zC = {
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  fnof: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  bull: "",
  hellip: "",
  prime: "",
  Prime: "",
  oline: "",
  frasl: "",
  weierp: "",
  image: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: "",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  circ: "",
  tilde: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  permil: "",
  lsaquo: "",
  rsaquo: "",
  euro: ""
}, f_e = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], l7 = {}.hasOwnProperty, rT = {};
let Kv;
for (Kv in zC)
  l7.call(zC, Kv) && (rT[zC[Kv]] = Kv);
const h_e = /[^\dA-Za-z]/;
function p_e(e, t, n, r) {
  const i = String.fromCharCode(e);
  if (l7.call(rT, i)) {
    const o = rT[i], s = "&" + o;
    return n && d_e.includes(o) && !f_e.includes(o) && (!r || t && t !== 61 && h_e.test(String.fromCharCode(t))) ? s : s + ";";
  }
  return "";
}
function m_e(e, t, n) {
  let r = l_e(e, t, n.omitOptionalSemicolons), i;
  if ((n.useNamedReferences || n.useShortestReferences) && (i = p_e(
    e,
    t,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !i) && n.useShortestReferences) {
    const o = u_e(e, t, n.omitOptionalSemicolons);
    o.length < r.length && (r = o);
  }
  return i && (!n.useShortestReferences || i.length < r.length) ? i : r;
}
function Jf(e, t) {
  return i_e(e, Object.assign({ format: m_e }, t));
}
const g_e = /^>|^->|<!--|-->|--!>|<!-$/g, y_e = [">"], v_e = ["<", ">"];
function b_e(e, t, n, r) {
  return r.settings.bogusComments ? "<?" + Jf(
    e.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: y_e
    })
  ) + ">" : "<!--" + e.value.replace(g_e, i) + "-->";
  function i(o) {
    return Jf(
      o,
      Object.assign({}, r.settings.characterReferences, {
        subset: v_e
      })
    );
  }
}
function x_e(e, t, n, r) {
  return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>";
}
const Pr = u7(1), c7 = u7(-1), w_e = [];
function u7(e) {
  return t;
  function t(n, r, i) {
    const o = n ? n.children : w_e;
    let s = (r || 0) + e, a = o[s];
    if (!i)
      for (; a && Ow(a); )
        s += e, a = o[s];
    return a;
  }
}
const S_e = {}.hasOwnProperty;
function d7(e) {
  return t;
  function t(n, r, i) {
    return S_e.call(e, n.tagName) && e[n.tagName](n, r, i);
  }
}
const tN = d7({
  body: C_e,
  caption: LC,
  colgroup: LC,
  dd: A_e,
  dt: T_e,
  head: LC,
  html: k_e,
  li: __e,
  optgroup: M_e,
  option: N_e,
  p: E_e,
  rp: Qz,
  rt: Qz,
  tbody: O_e,
  td: eL,
  tfoot: D_e,
  th: eL,
  thead: R_e,
  tr: P_e
});
function LC(e, t, n) {
  const r = Pr(n, t, !0);
  return !r || r.type !== "comment" && !(r.type === "text" && Ow(r.value.charAt(0)));
}
function k_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type !== "comment";
}
function C_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type !== "comment";
}
function E_e(e, t, n) {
  const r = Pr(n, t);
  return r ? r.type === "element" && (r.tagName === "address" || r.tagName === "article" || r.tagName === "aside" || r.tagName === "blockquote" || r.tagName === "details" || r.tagName === "div" || r.tagName === "dl" || r.tagName === "fieldset" || r.tagName === "figcaption" || r.tagName === "figure" || r.tagName === "footer" || r.tagName === "form" || r.tagName === "h1" || r.tagName === "h2" || r.tagName === "h3" || r.tagName === "h4" || r.tagName === "h5" || r.tagName === "h6" || r.tagName === "header" || r.tagName === "hgroup" || r.tagName === "hr" || r.tagName === "main" || r.tagName === "menu" || r.tagName === "nav" || r.tagName === "ol" || r.tagName === "p" || r.tagName === "pre" || r.tagName === "section" || r.tagName === "table" || r.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function __e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && r.tagName === "li";
}
function T_e(e, t, n) {
  const r = Pr(n, t);
  return !!(r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd"));
}
function A_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function Qz(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && (r.tagName === "rp" || r.tagName === "rt");
}
function M_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && r.tagName === "optgroup";
}
function N_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup");
}
function R_e(e, t, n) {
  const r = Pr(n, t);
  return !!(r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot"));
}
function O_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function D_e(e, t, n) {
  return !Pr(n, t);
}
function P_e(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && r.tagName === "tr";
}
function eL(e, t, n) {
  const r = Pr(n, t);
  return !r || r.type === "element" && (r.tagName === "td" || r.tagName === "th");
}
const j_e = d7({
  body: L_e,
  colgroup: B_e,
  head: z_e,
  html: I_e,
  tbody: $_e
});
function I_e(e) {
  const t = Pr(e, -1);
  return !t || t.type !== "comment";
}
function z_e(e) {
  const t = /* @__PURE__ */ new Set();
  for (const r of e.children)
    if (r.type === "element" && (r.tagName === "base" || r.tagName === "title")) {
      if (t.has(r.tagName)) return !1;
      t.add(r.tagName);
    }
  const n = e.children[0];
  return !n || n.type === "element";
}
function L_e(e) {
  const t = Pr(e, -1, !0);
  return !t || t.type !== "comment" && !(t.type === "text" && Ow(t.value.charAt(0))) && !(t.type === "element" && (t.tagName === "meta" || t.tagName === "link" || t.tagName === "script" || t.tagName === "style" || t.tagName === "template"));
}
function B_e(e, t, n) {
  const r = c7(n, t), i = Pr(e, -1, !0);
  return n && r && r.type === "element" && r.tagName === "colgroup" && tN(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "col");
}
function $_e(e, t, n) {
  const r = c7(n, t), i = Pr(e, -1);
  return n && r && r.type === "element" && (r.tagName === "thead" || r.tagName === "tbody") && tN(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "tr");
}
const Zv = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function U_e(e, t, n, r) {
  const i = r.schema, o = i.space === "svg" ? !1 : r.settings.omitOptionalTags;
  let s = i.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(e.tagName.toLowerCase());
  const a = [];
  let c;
  i.space === "html" && e.tagName === "svg" && (r.schema = ny);
  const u = F_e(r, e.properties), f = r.all(
    i.space === "html" && e.tagName === "template" ? e.content : e
  );
  return r.schema = i, f && (s = !1), (u || !o || !j_e(e, t, n)) && (a.push("<", e.tagName, u ? " " + u : ""), s && (i.space === "svg" || r.settings.closeSelfClosing) && (c = u.charAt(u.length - 1), (!r.settings.tightSelfClosing || c === "/" || c && c !== '"' && c !== "'") && a.push(" "), a.push("/")), a.push(">")), a.push(f), !s && (!o || !tN(e, t, n)) && a.push("</" + e.tagName + ">"), a.join("");
}
function F_e(e, t) {
  const n = [];
  let r = -1, i;
  if (t) {
    for (i in t)
      if (t[i] !== null && t[i] !== void 0) {
        const o = V_e(e, i, t[i]);
        o && n.push(o);
      }
  }
  for (; ++r < n.length; ) {
    const o = e.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : void 0;
    r !== n.length - 1 && o !== '"' && o !== "'" && (n[r] += " ");
  }
  return n.join("");
}
function V_e(e, t, n) {
  const r = qF(e.schema, t), i = e.settings.allowParseErrors && e.schema.space === "html" ? 0 : 1, o = e.settings.allowDangerousCharacters ? 0 : 1;
  let s = e.quote, a;
  if (r.overloadedBoolean && (n === r.attribute || n === "") ? n = !0 : (r.boolean || r.overloadedBoolean) && (typeof n != "string" || n === r.attribute || n === "") && (n = !!n), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const c = Jf(
    r.attribute,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: Zv.name[i][o]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (r.commaSeparated ? LF : KF)(n, {
    padLeft: !e.settings.tightCommaSeparatedLists
  }) : String(n), e.settings.collapseEmptyAttributes && !n) ? c : (e.settings.preferUnquoted && (a = Jf(
    n,
    Object.assign({}, e.settings.characterReferences, {
      attribute: !0,
      subset: Zv.unquoted[i][o]
    })
  )), a !== n && (e.settings.quoteSmart && Bb(n, s) > Bb(n, e.alternative) && (s = e.alternative), a = s + Jf(
    n,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (s === "'" ? Zv.single : Zv.double)[i][o],
      attribute: !0
    })
  ) + s), c + (a && "=" + a));
}
const H_e = ["<", "&"];
function f7(e, t, n, r) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? e.value : Jf(
    e.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: H_e
    })
  );
}
function W_e(e, t, n, r) {
  return r.settings.allowDangerousHtml ? e.value : f7(e, t, n, r);
}
function q_e(e, t, n, r) {
  return r.all(e);
}
const G_e = Uke("type", {
  invalid: K_e,
  unknown: Z_e,
  handlers: { comment: b_e, doctype: x_e, element: U_e, raw: W_e, root: q_e, text: f7 }
});
function K_e(e) {
  throw new Error("Expected node, not `" + e + "`");
}
function Z_e(e) {
  const t = (
    /** @type {Nodes} */
    e
  );
  throw new Error("Cannot compile unknown node `" + t.type + "`");
}
const Y_e = {}, X_e = {}, J_e = [];
function Q_e(e, t) {
  const n = t || Y_e, r = n.quote || '"', i = r === '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
  return {
    one: eTe,
    all: tTe,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || QEe,
      characterReferences: n.characterReferences || X_e,
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? ny : GF,
    quote: r,
    alternative: i
  }.one(
    Array.isArray(e) ? { type: "root", children: e } : e,
    void 0,
    void 0
  );
}
function eTe(e, t, n) {
  return G_e(e, t, n, this);
}
function tTe(e) {
  const t = [], n = e && e.children || J_e;
  let r = -1;
  for (; ++r < n.length; )
    t[r] = this.one(n[r], r, e);
  return t.join("");
}
function qb(e, t) {
  const n = typeof e == "string" ? {} : { ...e.colorReplacements }, r = typeof e == "string" ? e : e.name;
  for (const [i, o] of Object.entries(t?.colorReplacements || {}))
    typeof o == "string" ? n[i] = o : i === r && Object.assign(n, o);
  return n;
}
function pc(e, t) {
  return e && (t?.[e?.toLowerCase()] || e);
}
function nTe(e) {
  return Array.isArray(e) ? e : [e];
}
async function h7(e) {
  return Promise.resolve(typeof e == "function" ? e() : e).then((t) => t.default || t);
}
function nN(e) {
  return !e || ["plaintext", "txt", "text", "plain"].includes(e);
}
function p7(e) {
  return e === "ansi" || nN(e);
}
function rN(e) {
  return e === "none";
}
function m7(e) {
  return rN(e);
}
function g7(e, t) {
  if (!t)
    return e;
  e.properties ||= {}, e.properties.class ||= [], typeof e.properties.class == "string" && (e.properties.class = e.properties.class.split(/\s+/g)), Array.isArray(e.properties.class) || (e.properties.class = []);
  const n = Array.isArray(t) ? t : t.split(/\s+/g);
  for (const r of n)
    r && !e.properties.class.includes(r) && e.properties.class.push(r);
  return e;
}
function Lw(e, t = !1) {
  if (e.length === 0)
    return [["", 0]];
  const n = e.split(/(\r?\n)/g);
  let r = 0;
  const i = [];
  for (let o = 0; o < n.length; o += 2) {
    const s = t ? n[o] + (n[o + 1] || "") : n[o];
    i.push([s, r]), r += n[o].length, r += n[o + 1]?.length || 0;
  }
  return i;
}
function rTe(e) {
  const t = Lw(e, !0).map(([i]) => i);
  function n(i) {
    if (i === e.length)
      return {
        line: t.length - 1,
        character: t[t.length - 1].length
      };
    let o = i, s = 0;
    for (const a of t) {
      if (o < a.length)
        break;
      o -= a.length, s++;
    }
    return { line: s, character: o };
  }
  function r(i, o) {
    let s = 0;
    for (let a = 0; a < i; a++)
      s += t[a].length;
    return s += o, s;
  }
  return {
    lines: t,
    indexToPos: n,
    posToIndex: r
  };
}
function iTe(e, t, n) {
  const r = /* @__PURE__ */ new Set();
  for (const o of e.matchAll(/:?lang=["']([^"']+)["']/g)) {
    const s = o[1].toLowerCase().trim();
    s && r.add(s);
  }
  for (const o of e.matchAll(/(?:```|~~~)([\w-]+)/g)) {
    const s = o[1].toLowerCase().trim();
    s && r.add(s);
  }
  for (const o of e.matchAll(/\\begin\{([\w-]+)\}/g)) {
    const s = o[1].toLowerCase().trim();
    s && r.add(s);
  }
  for (const o of e.matchAll(/<script\s+(?:type|lang)=["']([^"']+)["']/gi)) {
    const s = o[1].toLowerCase().trim(), a = s.includes("/") ? s.split("/").pop() : s;
    a && r.add(a);
  }
  if (!n)
    return Array.from(r);
  const i = n.getBundledLanguages();
  return Array.from(r).filter((o) => o && i[o]);
}
const iN = "light-dark()", oTe = ["color", "background-color"];
function sTe(e, t) {
  let n = 0;
  const r = [];
  for (const i of t)
    i > n && r.push({
      ...e,
      content: e.content.slice(n, i),
      offset: e.offset + n
    }), n = i;
  return n < e.content.length && r.push({
    ...e,
    content: e.content.slice(n),
    offset: e.offset + n
  }), r;
}
function aTe(e, t) {
  const n = Array.from(t instanceof Set ? t : new Set(t)).sort((r, i) => r - i);
  return n.length ? e.map((r) => r.flatMap((i) => {
    const o = n.filter((s) => i.offset < s && s < i.offset + i.content.length).map((s) => s - i.offset).sort((s, a) => s - a);
    return o.length ? sTe(i, o) : i;
  })) : e;
}
function lTe(e, t, n, r, i = "css-vars") {
  const o = {
    content: e.content,
    explanation: e.explanation,
    offset: e.offset
  }, s = t.map((f) => Gb(e.variants[f])), a = new Set(s.flatMap((f) => Object.keys(f))), c = {}, u = (f, h) => {
    const m = h === "color" ? "" : h === "background-color" ? "-bg" : `-${h}`;
    return n + t[f] + (h === "color" ? "" : m);
  };
  return s.forEach((f, h) => {
    for (const m of a) {
      const g = f[m] || "inherit";
      if (h === 0 && r && oTe.includes(m))
        if (r === iN && s.length > 1) {
          const b = t.findIndex((_) => _ === "light"), x = t.findIndex((_) => _ === "dark");
          if (b === -1 || x === -1)
            throw new kr('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
          const w = s[b][m] || "inherit", S = s[x][m] || "inherit";
          c[m] = `light-dark(${w}, ${S})`, i === "css-vars" && (c[u(h, m)] = g);
        } else
          c[m] = g;
      else
        i === "css-vars" && (c[u(h, m)] = g);
    }
  }), o.htmlStyle = c, o;
}
function Gb(e) {
  const t = {};
  if (e.color && (t.color = e.color), e.bgColor && (t["background-color"] = e.bgColor), e.fontStyle) {
    e.fontStyle & pi.Italic && (t["font-style"] = "italic"), e.fontStyle & pi.Bold && (t["font-weight"] = "bold");
    const n = [];
    e.fontStyle & pi.Underline && n.push("underline"), e.fontStyle & pi.Strikethrough && n.push("line-through"), n.length && (t["text-decoration"] = n.join(" "));
  }
  return t;
}
function iT(e) {
  return typeof e == "string" ? e : Object.entries(e).map(([t, n]) => `${t}:${n}`).join(";");
}
const y7 = /* @__PURE__ */ new WeakMap();
function Bw(e, t) {
  y7.set(e, t);
}
function mg(e) {
  return y7.get(e);
}
class Vh {
  /**
   * Theme to Stack mapping
   */
  _stacks = {};
  lang;
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(t, n) {
    return new Vh(
      Object.fromEntries(nTe(n).map((r) => [r, nT])),
      t
    );
  }
  constructor(...t) {
    if (t.length === 2) {
      const [n, r] = t;
      this.lang = r, this._stacks = n;
    } else {
      const [n, r, i] = t;
      this.lang = r, this._stacks = { [i]: n };
    }
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(t = this.theme) {
    return this._stacks[t];
  }
  getScopes(t = this.theme) {
    return cTe(this._stacks[t]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.getScopes()
    };
  }
}
function cTe(e) {
  const t = [], n = /* @__PURE__ */ new Set();
  function r(i) {
    if (n.has(i))
      return;
    n.add(i);
    const o = i?.nameScopesList?.scopeName;
    o && t.push(o), i.parent && r(i.parent);
  }
  return r(e), t;
}
function uTe(e, t) {
  if (!(e instanceof Vh))
    throw new kr("Invalid grammar state");
  return e.getInternalStack(t);
}
function dTe() {
  const e = /* @__PURE__ */ new WeakMap();
  function t(n) {
    if (!e.has(n.meta)) {
      let r = function(s) {
        if (typeof s == "number") {
          if (s < 0 || s > n.source.length)
            throw new kr(`Invalid decoration offset: ${s}. Code length: ${n.source.length}`);
          return {
            ...i.indexToPos(s),
            offset: s
          };
        } else {
          const a = i.lines[s.line];
          if (a === void 0)
            throw new kr(`Invalid decoration position ${JSON.stringify(s)}. Lines length: ${i.lines.length}`);
          let c = s.character;
          if (c < 0 && (c = a.length + c), c < 0 || c > a.length)
            throw new kr(`Invalid decoration position ${JSON.stringify(s)}. Line ${s.line} length: ${a.length}`);
          return {
            ...s,
            character: c,
            offset: i.posToIndex(s.line, c)
          };
        }
      };
      const i = rTe(n.source), o = (n.options.decorations || []).map((s) => ({
        ...s,
        start: r(s.start),
        end: r(s.end)
      }));
      fTe(o), e.set(n.meta, {
        decorations: o,
        converter: i,
        source: n.source
      });
    }
    return e.get(n.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(n) {
      if (!this.options.decorations?.length)
        return;
      const i = t(this).decorations.flatMap((s) => [s.start.offset, s.end.offset]);
      return aTe(n, i);
    },
    code(n) {
      if (!this.options.decorations?.length)
        return;
      const r = t(this), i = Array.from(n.children).filter((f) => f.type === "element" && f.tagName === "span");
      if (i.length !== r.converter.lines.length)
        throw new kr(`Number of lines in code element (${i.length}) does not match the number of lines in the source (${r.converter.lines.length}). Failed to apply decorations.`);
      function o(f, h, m, g) {
        const b = i[f];
        let x = "", w = -1, S = -1;
        if (h === 0 && (w = 0), m === 0 && (S = 0), m === Number.POSITIVE_INFINITY && (S = b.children.length), w === -1 || S === -1)
          for (let M = 0; M < b.children.length; M++)
            x += v7(b.children[M]), w === -1 && x.length === h && (w = M + 1), S === -1 && x.length === m && (S = M + 1);
        if (w === -1)
          throw new kr(`Failed to find start index for decoration ${JSON.stringify(g.start)}`);
        if (S === -1)
          throw new kr(`Failed to find end index for decoration ${JSON.stringify(g.end)}`);
        const _ = b.children.slice(w, S);
        if (!g.alwaysWrap && _.length === b.children.length)
          a(b, g, "line");
        else if (!g.alwaysWrap && _.length === 1 && _[0].type === "element")
          a(_[0], g, "token");
        else {
          const M = {
            type: "element",
            tagName: "span",
            properties: {},
            children: _
          };
          a(M, g, "wrapper"), b.children.splice(w, _.length, M);
        }
      }
      function s(f, h) {
        i[f] = a(i[f], h, "line");
      }
      function a(f, h, m) {
        const g = h.properties || {}, b = h.transform || ((x) => x);
        return f.tagName = h.tagName || "span", f.properties = {
          ...f.properties,
          ...g,
          class: f.properties.class
        }, h.properties?.class && g7(f, h.properties.class), f = b(f, m) || f, f;
      }
      const c = [], u = r.decorations.sort((f, h) => h.start.offset - f.start.offset || f.end.offset - h.end.offset);
      for (const f of u) {
        const { start: h, end: m } = f;
        if (h.line === m.line)
          o(h.line, h.character, m.character, f);
        else if (h.line < m.line) {
          o(h.line, h.character, Number.POSITIVE_INFINITY, f);
          for (let g = h.line + 1; g < m.line; g++)
            c.unshift(() => s(g, f));
          o(m.line, 0, m.character, f);
        }
      }
      c.forEach((f) => f());
    }
  };
}
function fTe(e) {
  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    if (n.start.offset > n.end.offset)
      throw new kr(`Invalid decoration range: ${JSON.stringify(n.start)} - ${JSON.stringify(n.end)}`);
    for (let r = t + 1; r < e.length; r++) {
      const i = e[r], o = n.start.offset <= i.start.offset && i.start.offset < n.end.offset, s = n.start.offset < i.end.offset && i.end.offset <= n.end.offset, a = i.start.offset <= n.start.offset && n.start.offset < i.end.offset, c = i.start.offset < n.end.offset && n.end.offset <= i.end.offset;
      if (o || s || a || c) {
        if (o && s || a && c || a && n.start.offset === n.end.offset || s && i.start.offset === i.end.offset)
          continue;
        throw new kr(`Decorations ${JSON.stringify(n.start)} and ${JSON.stringify(i.start)} intersect.`);
      }
    }
  }
}
function v7(e) {
  return e.type === "text" ? e.value : e.type === "element" ? e.children.map(v7).join("") : "";
}
const hTe = [
  /* @__PURE__ */ dTe()
];
function Kb(e) {
  const t = pTe(e.transformers || []);
  return [
    ...t.pre,
    ...t.normal,
    ...t.post,
    ...hTe
  ];
}
function pTe(e) {
  const t = [], n = [], r = [];
  for (const i of e)
    switch (i.enforce) {
      case "pre":
        t.push(i);
        break;
      case "post":
        n.push(i);
        break;
      default:
        r.push(i);
    }
  return { pre: t, post: n, normal: r };
}
var Pu = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
], BC = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  8: "hidden",
  9: "strikethrough"
};
function mTe(e, t) {
  const n = e.indexOf("\x1B", t);
  if (n !== -1 && e[n + 1] === "[") {
    const r = e.indexOf("m", n);
    if (r !== -1)
      return {
        sequence: e.substring(n + 2, r).split(";"),
        startPosition: n,
        position: r + 1
      };
  }
  return {
    position: e.length
  };
}
function tL(e) {
  const t = e.shift();
  if (t === "2") {
    const n = e.splice(0, 3).map((r) => Number.parseInt(r));
    return n.length !== 3 || n.some((r) => Number.isNaN(r)) ? void 0 : {
      type: "rgb",
      rgb: n
    };
  } else if (t === "5") {
    const n = e.shift();
    if (n)
      return { type: "table", index: Number(n) };
  }
}
function gTe(e) {
  const t = [];
  for (; e.length > 0; ) {
    const n = e.shift();
    if (!n)
      continue;
    const r = Number.parseInt(n);
    if (!Number.isNaN(r))
      if (r === 0)
        t.push({ type: "resetAll" });
      else if (r <= 9)
        BC[r] && t.push({
          type: "setDecoration",
          value: BC[r]
        });
      else if (r <= 29) {
        const i = BC[r - 20];
        i && (t.push({
          type: "resetDecoration",
          value: i
        }), i === "dim" && t.push({
          type: "resetDecoration",
          value: "bold"
        }));
      } else if (r <= 37)
        t.push({
          type: "setForegroundColor",
          value: { type: "named", name: Pu[r - 30] }
        });
      else if (r === 38) {
        const i = tL(e);
        i && t.push({
          type: "setForegroundColor",
          value: i
        });
      } else if (r === 39)
        t.push({
          type: "resetForegroundColor"
        });
      else if (r <= 47)
        t.push({
          type: "setBackgroundColor",
          value: { type: "named", name: Pu[r - 40] }
        });
      else if (r === 48) {
        const i = tL(e);
        i && t.push({
          type: "setBackgroundColor",
          value: i
        });
      } else r === 49 ? t.push({
        type: "resetBackgroundColor"
      }) : r === 53 ? t.push({
        type: "setDecoration",
        value: "overline"
      }) : r === 55 ? t.push({
        type: "resetDecoration",
        value: "overline"
      }) : r >= 90 && r <= 97 ? t.push({
        type: "setForegroundColor",
        value: { type: "named", name: Pu[r - 90 + 8] }
      }) : r >= 100 && r <= 107 && t.push({
        type: "setBackgroundColor",
        value: { type: "named", name: Pu[r - 100 + 8] }
      });
  }
  return t;
}
function yTe() {
  let e = null, t = null, n = /* @__PURE__ */ new Set();
  return {
    parse(r) {
      const i = [];
      let o = 0;
      do {
        const s = mTe(r, o), a = s.sequence ? r.substring(o, s.startPosition) : r.substring(o);
        if (a.length > 0 && i.push({
          value: a,
          foreground: e,
          background: t,
          decorations: new Set(n)
        }), s.sequence) {
          const c = gTe(s.sequence);
          for (const u of c)
            u.type === "resetAll" ? (e = null, t = null, n.clear()) : u.type === "resetForegroundColor" ? e = null : u.type === "resetBackgroundColor" ? t = null : u.type === "resetDecoration" && n.delete(u.value);
          for (const u of c)
            u.type === "setForegroundColor" ? e = u.value : u.type === "setBackgroundColor" ? t = u.value : u.type === "setDecoration" && n.add(u.value);
        }
        o = s.position;
      } while (o < r.length);
      return i;
    }
  };
}
var vTe = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function bTe(e = vTe) {
  function t(a) {
    return e[a];
  }
  function n(a) {
    return `#${a.map((c) => Math.max(0, Math.min(c, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let r;
  function i() {
    if (r)
      return r;
    r = [];
    for (let u = 0; u < Pu.length; u++)
      r.push(t(Pu[u]));
    let a = [0, 95, 135, 175, 215, 255];
    for (let u = 0; u < 6; u++)
      for (let f = 0; f < 6; f++)
        for (let h = 0; h < 6; h++)
          r.push(n([a[u], a[f], a[h]]));
    let c = 8;
    for (let u = 0; u < 24; u++, c += 10)
      r.push(n([c, c, c]));
    return r;
  }
  function o(a) {
    return i()[a];
  }
  function s(a) {
    switch (a.type) {
      case "named":
        return t(a.name);
      case "rgb":
        return n(a.rgb);
      case "table":
        return o(a.index);
    }
  }
  return {
    value: s
  };
}
const xTe = {
  black: "#000000",
  red: "#cd3131",
  green: "#0DBC79",
  yellow: "#E5E510",
  blue: "#2472C8",
  magenta: "#BC3FBC",
  cyan: "#11A8CD",
  white: "#E5E5E5",
  brightBlack: "#666666",
  brightRed: "#F14C4C",
  brightGreen: "#23D18B",
  brightYellow: "#F5F543",
  brightBlue: "#3B8EEA",
  brightMagenta: "#D670D6",
  brightCyan: "#29B8DB",
  brightWhite: "#FFFFFF"
};
function wTe(e, t, n) {
  const r = qb(e, n), i = Lw(t), o = Object.fromEntries(
    Pu.map((c) => {
      const u = `terminal.ansi${c[0].toUpperCase()}${c.substring(1)}`, f = e.colors?.[u];
      return [c, f || xTe[c]];
    })
  ), s = bTe(o), a = yTe();
  return i.map(
    (c) => a.parse(c[0]).map((u) => {
      let f, h;
      u.decorations.has("reverse") ? (f = u.background ? s.value(u.background) : e.bg, h = u.foreground ? s.value(u.foreground) : e.fg) : (f = u.foreground ? s.value(u.foreground) : e.fg, h = u.background ? s.value(u.background) : void 0), f = pc(f, r), h = pc(h, r), u.decorations.has("dim") && (f = STe(f));
      let m = pi.None;
      return u.decorations.has("bold") && (m |= pi.Bold), u.decorations.has("italic") && (m |= pi.Italic), u.decorations.has("underline") && (m |= pi.Underline), u.decorations.has("strikethrough") && (m |= pi.Strikethrough), {
        content: u.value,
        offset: c[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color: f,
        bgColor: h,
        fontStyle: m
      };
    })
  );
}
function STe(e) {
  const t = e.match(/#([0-9a-f]{3,8})/i);
  if (t) {
    const r = t[1];
    if (r.length === 8) {
      const i = Math.round(Number.parseInt(r.slice(6, 8), 16) / 2).toString(16).padStart(2, "0");
      return `#${r.slice(0, 6)}${i}`;
    } else {
      if (r.length === 6)
        return `#${r}80`;
      if (r.length === 4) {
        const i = r[0], o = r[1], s = r[2], a = r[3], c = Math.round(Number.parseInt(`${a}${a}`, 16) / 2).toString(16).padStart(2, "0");
        return `#${i}${i}${o}${o}${s}${s}${c}`;
      } else if (r.length === 3) {
        const i = r[0], o = r[1], s = r[2];
        return `#${i}${i}${o}${o}${s}${s}80`;
      }
    }
  }
  const n = e.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  return n ? `var(${n[1]}-dim)` : e;
}
function oN(e, t, n = {}) {
  const {
    theme: r = e.getLoadedThemes()[0]
  } = n, i = e.resolveLangAlias(n.lang || "text");
  if (nN(i) || rN(r))
    return Lw(t).map((c) => [{ content: c[0], offset: c[1] }]);
  const { theme: o, colorMap: s } = e.setTheme(r);
  if (i === "ansi")
    return wTe(o, t, n);
  const a = e.getLanguage(n.lang || "text");
  if (n.grammarState) {
    if (n.grammarState.lang !== a.name)
      throw new kr(`Grammar state language "${n.grammarState.lang}" does not match highlight language "${a.name}"`);
    if (!n.grammarState.themes.includes(o.name))
      throw new kr(`Grammar state themes "${n.grammarState.themes}" do not contain highlight theme "${o.name}"`);
  }
  return CTe(t, a, o, s, n);
}
function kTe(...e) {
  if (e.length === 2)
    return mg(e[1]);
  const [t, n, r = {}] = e, {
    lang: i = "text",
    theme: o = t.getLoadedThemes()[0]
  } = r;
  if (nN(i) || rN(o))
    throw new kr("Plain language does not have grammar state");
  if (i === "ansi")
    throw new kr("ANSI language does not have grammar state");
  const { theme: s, colorMap: a } = t.setTheme(o), c = t.getLanguage(i);
  return new Vh(
    sN(n, c, s, a, r).stateStack,
    c.name,
    s.name
  );
}
function CTe(e, t, n, r, i) {
  const o = sN(e, t, n, r, i), s = new Vh(
    o.stateStack,
    t.name,
    n.name
  );
  return Bw(o.tokens, s), o.tokens;
}
function sN(e, t, n, r, i) {
  const o = qb(n, i), {
    tokenizeMaxLineLength: s = 0,
    tokenizeTimeLimit: a = 500
  } = i, c = Lw(e);
  let u = i.grammarState ? uTe(i.grammarState, n.name) ?? nT : i.grammarContextCode != null ? sN(
    i.grammarContextCode,
    t,
    n,
    r,
    {
      ...i,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : nT, f = [];
  const h = [];
  for (let m = 0, g = c.length; m < g; m++) {
    const [b, x] = c[m];
    if (b === "") {
      f = [], h.push([]);
      continue;
    }
    if (s > 0 && b.length >= s) {
      f = [], h.push([{
        content: b,
        offset: x,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let w, S, _;
    i.includeExplanation && (w = t.tokenizeLine(b, u, a), S = w.tokens, _ = 0);
    const M = t.tokenizeLine2(b, u, a), N = M.tokens.length / 2;
    for (let P = 0; P < N; P++) {
      const I = M.tokens[2 * P], O = P + 1 < N ? M.tokens[2 * P + 2] : b.length;
      if (I === O)
        continue;
      const L = M.tokens[2 * P + 1], U = pc(
        r[hh.getForeground(L)],
        o
      ), B = hh.getFontStyle(L), G = {
        content: b.substring(I, O),
        offset: x + I,
        color: U,
        fontStyle: B
      };
      if (i.includeExplanation) {
        const Y = [];
        if (i.includeExplanation !== "scopeName")
          for (const ie of n.settings) {
            let ne;
            switch (typeof ie.scope) {
              case "string":
                ne = ie.scope.split(/,/).map((H) => H.trim());
                break;
              case "object":
                ne = ie.scope;
                break;
              default:
                continue;
            }
            Y.push({
              settings: ie,
              selectors: ne.map((H) => H.split(/ /))
            });
          }
        G.explanation = [];
        let he = 0;
        for (; I + he < O; ) {
          const ie = S[_], ne = b.substring(
            ie.startIndex,
            ie.endIndex
          );
          he += ne.length, G.explanation.push({
            content: ne,
            scopes: i.includeExplanation === "scopeName" ? ETe(
              ie.scopes
            ) : _Te(
              Y,
              ie.scopes
            )
          }), _ += 1;
        }
      }
      f.push(G);
    }
    h.push(f), f = [], u = M.ruleStack;
  }
  return {
    tokens: h,
    stateStack: u
  };
}
function ETe(e) {
  return e.map((t) => ({ scopeName: t }));
}
function _Te(e, t) {
  const n = [];
  for (let r = 0, i = t.length; r < i; r++) {
    const o = t[r];
    n[r] = {
      scopeName: o,
      themeMatches: ATe(e, o, t.slice(0, r))
    };
  }
  return n;
}
function nL(e, t) {
  return e === t || t.substring(0, e.length) === e && t[e.length] === ".";
}
function TTe(e, t, n) {
  if (!nL(e[e.length - 1], t))
    return !1;
  let r = e.length - 2, i = n.length - 1;
  for (; r >= 0 && i >= 0; )
    nL(e[r], n[i]) && (r -= 1), i -= 1;
  return r === -1;
}
function ATe(e, t, n) {
  const r = [];
  for (const { selectors: i, settings: o } of e)
    for (const s of i)
      if (TTe(s, t, n)) {
        r.push(o);
        break;
      }
  return r;
}
function b7(e, t, n) {
  const r = Object.entries(n.themes).filter((c) => c[1]).map((c) => ({ color: c[0], theme: c[1] })), i = r.map((c) => {
    const u = oN(e, t, {
      ...n,
      theme: c.theme
    }), f = mg(u), h = typeof c.theme == "string" ? c.theme : c.theme.name;
    return {
      tokens: u,
      state: f,
      theme: h
    };
  }), o = MTe(
    ...i.map((c) => c.tokens)
  ), s = o[0].map(
    (c, u) => c.map((f, h) => {
      const m = {
        content: f.content,
        variants: {},
        offset: f.offset
      };
      return "includeExplanation" in n && n.includeExplanation && (m.explanation = f.explanation), o.forEach((g, b) => {
        const {
          content: x,
          explanation: w,
          offset: S,
          ..._
        } = g[u][h];
        m.variants[r[b].color] = _;
      }), m;
    })
  ), a = i[0].state ? new Vh(
    Object.fromEntries(i.map((c) => [c.theme, c.state?.getInternalStack(c.theme)])),
    i[0].state.lang
  ) : void 0;
  return a && Bw(s, a), s;
}
function MTe(...e) {
  const t = e.map(() => []), n = e.length;
  for (let r = 0; r < e[0].length; r++) {
    const i = e.map((c) => c[r]), o = t.map(() => []);
    t.forEach((c, u) => c.push(o[u]));
    const s = i.map(() => 0), a = i.map((c) => c[0]);
    for (; a.every((c) => c); ) {
      const c = Math.min(...a.map((u) => u.content.length));
      for (let u = 0; u < n; u++) {
        const f = a[u];
        f.content.length === c ? (o[u].push(f), s[u] += 1, a[u] = i[u][s[u]]) : (o[u].push({
          ...f,
          content: f.content.slice(0, c)
        }), a[u] = {
          ...f,
          content: f.content.slice(c),
          offset: f.offset + c
        });
      }
    }
  }
  return t;
}
function Zb(e, t, n) {
  let r, i, o, s, a, c;
  if ("themes" in n) {
    const {
      defaultColor: u = "light",
      cssVariablePrefix: f = "--shiki-",
      colorsRendering: h = "css-vars"
    } = n, m = Object.entries(n.themes).filter((S) => S[1]).map((S) => ({ color: S[0], theme: S[1] })).sort((S, _) => S.color === u ? -1 : _.color === u ? 1 : 0);
    if (m.length === 0)
      throw new kr("`themes` option must not be empty");
    const g = b7(
      e,
      t,
      n
    );
    if (c = mg(g), u && iN !== u && !m.find((S) => S.color === u))
      throw new kr(`\`themes\` option must contain the defaultColor key \`${u}\``);
    const b = m.map((S) => e.getTheme(S.theme)), x = m.map((S) => S.color);
    o = g.map((S) => S.map((_) => lTe(_, x, f, u, h))), c && Bw(o, c);
    const w = m.map((S) => qb(S.theme, n));
    i = rL(m, b, w, f, u, "fg", h), r = rL(m, b, w, f, u, "bg", h), s = `shiki-themes ${b.map((S) => S.name).join(" ")}`, a = u ? void 0 : [i, r].join(";");
  } else if ("theme" in n) {
    const u = qb(n.theme, n);
    o = oN(
      e,
      t,
      n
    );
    const f = e.getTheme(n.theme);
    r = pc(f.bg, u), i = pc(f.fg, u), s = f.name, c = mg(o);
  } else
    throw new kr("Invalid options, either `theme` or `themes` must be provided");
  return {
    tokens: o,
    fg: i,
    bg: r,
    themeName: s,
    rootStyle: a,
    grammarState: c
  };
}
function rL(e, t, n, r, i, o, s) {
  return e.map((a, c) => {
    const u = pc(t[c][o], n[c]) || "inherit", f = `${r + a.color}${o === "bg" ? "-bg" : ""}:${u}`;
    if (c === 0 && i) {
      if (i === iN && e.length > 1) {
        const h = e.findIndex((x) => x.color === "light"), m = e.findIndex((x) => x.color === "dark");
        if (h === -1 || m === -1)
          throw new kr('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
        const g = pc(t[h][o], n[h]) || "inherit", b = pc(t[m][o], n[m]) || "inherit";
        return `light-dark(${g}, ${b});${f}`;
      }
      return u;
    }
    return s === "css-vars" ? f : null;
  }).filter((a) => !!a).join(";");
}
function Yb(e, t, n, r = {
  meta: {},
  options: n,
  codeToHast: (i, o) => Yb(e, i, o),
  codeToTokens: (i, o) => Zb(e, i, o)
}) {
  let i = t;
  for (const b of Kb(n))
    i = b.preprocess?.call(r, i, n) || i;
  let {
    tokens: o,
    fg: s,
    bg: a,
    themeName: c,
    rootStyle: u,
    grammarState: f
  } = Zb(e, i, n);
  const {
    mergeWhitespaces: h = !0,
    mergeSameStyleTokens: m = !1
  } = n;
  h === !0 ? o = RTe(o) : h === "never" && (o = OTe(o)), m && (o = DTe(o));
  const g = {
    ...r,
    get source() {
      return i;
    }
  };
  for (const b of Kb(n))
    o = b.tokens?.call(g, o) || o;
  return NTe(
    o,
    {
      ...n,
      fg: s,
      bg: a,
      themeName: c,
      rootStyle: n.rootStyle === !1 ? !1 : n.rootStyle ?? u
    },
    g,
    f
  );
}
function NTe(e, t, n, r = mg(e)) {
  const i = Kb(t), o = [], s = {
    type: "root",
    children: []
  }, {
    structure: a = "classic",
    tabindex: c = "0"
  } = t, u = {
    class: `shiki ${t.themeName || ""}`
  };
  t.rootStyle !== !1 && (t.rootStyle != null ? u.style = t.rootStyle : u.style = `background-color:${t.bg};color:${t.fg}`), c !== !1 && c != null && (u.tabindex = c.toString());
  for (const [x, w] of Object.entries(t.meta || {}))
    x.startsWith("_") || (u[x] = w);
  let f = {
    type: "element",
    tagName: "pre",
    properties: u,
    children: [],
    data: t.data
  }, h = {
    type: "element",
    tagName: "code",
    properties: {},
    children: o
  };
  const m = [], g = {
    ...n,
    structure: a,
    addClassToHast: g7,
    get source() {
      return n.source;
    },
    get tokens() {
      return e;
    },
    get options() {
      return t;
    },
    get root() {
      return s;
    },
    get pre() {
      return f;
    },
    get code() {
      return h;
    },
    get lines() {
      return m;
    }
  };
  if (e.forEach((x, w) => {
    w && (a === "inline" ? s.children.push({ type: "element", tagName: "br", properties: {}, children: [] }) : a === "classic" && o.push({ type: "text", value: `
` }));
    let S = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    }, _ = 0;
    for (const M of x) {
      let N = {
        type: "element",
        tagName: "span",
        properties: {
          ...M.htmlAttrs
        },
        children: [{ type: "text", value: M.content }]
      };
      const P = iT(M.htmlStyle || Gb(M));
      P && (N.properties.style = P);
      for (const I of i)
        N = I?.span?.call(g, N, w + 1, _, S, M) || N;
      a === "inline" ? s.children.push(N) : a === "classic" && S.children.push(N), _ += M.content.length;
    }
    if (a === "classic") {
      for (const M of i)
        S = M?.line?.call(g, S, w + 1) || S;
      m.push(S), o.push(S);
    } else a === "inline" && m.push(S);
  }), a === "classic") {
    for (const x of i)
      h = x?.code?.call(g, h) || h;
    f.children.push(h);
    for (const x of i)
      f = x?.pre?.call(g, f) || f;
    s.children.push(f);
  } else if (a === "inline") {
    const x = [];
    let w = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    };
    for (const M of s.children)
      M.type === "element" && M.tagName === "br" ? (x.push(w), w = {
        type: "element",
        tagName: "span",
        properties: { class: "line" },
        children: []
      }) : (M.type === "element" || M.type === "text") && w.children.push(M);
    x.push(w);
    let _ = {
      type: "element",
      tagName: "code",
      properties: {},
      children: x
    };
    for (const M of i)
      _ = M?.code?.call(g, _) || _;
    s.children = [];
    for (let M = 0; M < _.children.length; M++) {
      M > 0 && s.children.push({ type: "element", tagName: "br", properties: {}, children: [] });
      const N = _.children[M];
      N.type === "element" && s.children.push(...N.children);
    }
  }
  let b = s;
  for (const x of i)
    b = x?.root?.call(g, b) || b;
  return r && Bw(b, r), b;
}
function RTe(e) {
  return e.map((t) => {
    const n = [];
    let r = "", i;
    return t.forEach((o, s) => {
      const c = !(o.fontStyle && (o.fontStyle & pi.Underline || o.fontStyle & pi.Strikethrough));
      c && o.content.match(/^\s+$/) && t[s + 1] ? (i === void 0 && (i = o.offset), r += o.content) : r ? (c ? n.push({
        ...o,
        offset: i,
        content: r + o.content
      }) : n.push(
        {
          content: r,
          offset: i
        },
        o
      ), i = void 0, r = "") : n.push(o);
    }), n;
  });
}
function OTe(e) {
  return e.map((t) => t.flatMap((n) => {
    if (n.content.match(/^\s+$/))
      return n;
    const r = n.content.match(/^(\s*)(.*?)(\s*)$/);
    if (!r)
      return n;
    const [, i, o, s] = r;
    if (!i && !s)
      return n;
    const a = [{
      ...n,
      offset: n.offset + i.length,
      content: o
    }];
    return i && a.unshift({
      content: i,
      offset: n.offset
    }), s && a.push({
      content: s,
      offset: n.offset + i.length + o.length
    }), a;
  }));
}
function DTe(e) {
  return e.map((t) => {
    const n = [];
    for (const r of t) {
      if (n.length === 0) {
        n.push({ ...r });
        continue;
      }
      const i = n[n.length - 1], o = iT(i.htmlStyle || Gb(i)), s = iT(r.htmlStyle || Gb(r)), a = i.fontStyle && (i.fontStyle & pi.Underline || i.fontStyle & pi.Strikethrough), c = r.fontStyle && (r.fontStyle & pi.Underline || r.fontStyle & pi.Strikethrough);
      !a && !c && o === s ? i.content += r.content : n.push({ ...r });
    }
    return n;
  });
}
const PTe = Q_e;
function jTe(e, t, n) {
  const r = {
    meta: {},
    options: n,
    codeToHast: (o, s) => Yb(e, o, s),
    codeToTokens: (o, s) => Zb(e, o, s)
  };
  let i = PTe(Yb(e, t, n, r));
  for (const o of Kb(n))
    i = o.postprocess?.call(r, i, n) || i;
  return i;
}
const iL = { light: "#333333", dark: "#bbbbbb" }, oL = { light: "#fffffe", dark: "#1e1e1e" }, sL = "__shiki_resolved";
function aN(e) {
  if (e?.[sL])
    return e;
  const t = {
    ...e
  };
  t.tokenColors && !t.settings && (t.settings = t.tokenColors, delete t.tokenColors), t.type ||= "dark", t.colorReplacements = { ...t.colorReplacements }, t.settings ||= [];
  let { bg: n, fg: r } = t;
  if (!n || !r) {
    const a = t.settings ? t.settings.find((c) => !c.name && !c.scope) : void 0;
    a?.settings?.foreground && (r = a.settings.foreground), a?.settings?.background && (n = a.settings.background), !r && t?.colors?.["editor.foreground"] && (r = t.colors["editor.foreground"]), !n && t?.colors?.["editor.background"] && (n = t.colors["editor.background"]), r || (r = t.type === "light" ? iL.light : iL.dark), n || (n = t.type === "light" ? oL.light : oL.dark), t.fg = r, t.bg = n;
  }
  t.settings[0] && t.settings[0].settings && !t.settings[0].scope || t.settings.unshift({
    settings: {
      foreground: t.fg,
      background: t.bg
    }
  });
  let i = 0;
  const o = /* @__PURE__ */ new Map();
  function s(a) {
    if (o.has(a))
      return o.get(a);
    i += 1;
    const c = `#${i.toString(16).padStart(8, "0").toLowerCase()}`;
    return t.colorReplacements?.[`#${c}`] ? s(a) : (o.set(a, c), c);
  }
  t.settings = t.settings.map((a) => {
    const c = a.settings?.foreground && !a.settings.foreground.startsWith("#"), u = a.settings?.background && !a.settings.background.startsWith("#");
    if (!c && !u)
      return a;
    const f = {
      ...a,
      settings: {
        ...a.settings
      }
    };
    if (c) {
      const h = s(a.settings.foreground);
      t.colorReplacements[h] = a.settings.foreground, f.settings.foreground = h;
    }
    if (u) {
      const h = s(a.settings.background);
      t.colorReplacements[h] = a.settings.background, f.settings.background = h;
    }
    return f;
  });
  for (const a of Object.keys(t.colors || {}))
    if ((a === "editor.foreground" || a === "editor.background" || a.startsWith("terminal.ansi")) && !t.colors[a]?.startsWith("#")) {
      const c = s(t.colors[a]);
      t.colorReplacements[c] = t.colors[a], t.colors[a] = c;
    }
  return Object.defineProperty(t, sL, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), t;
}
async function x7(e) {
  return Array.from(new Set((await Promise.all(
    e.filter((t) => !p7(t)).map(async (t) => await h7(t).then((n) => Array.isArray(n) ? n : [n]))
  )).flat()));
}
async function w7(e) {
  return (await Promise.all(
    e.map(
      async (n) => m7(n) ? null : aN(await h7(n))
    )
  )).filter((n) => !!n);
}
let ITe = 3;
function zTe(e, t = 3) {
  t > ITe || console.trace(`[SHIKI DEPRECATE]: ${e}`);
}
let Bf = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
};
function S7(e, t) {
  if (!t)
    return e;
  if (t[e]) {
    const n = /* @__PURE__ */ new Set([e]);
    for (; t[e]; ) {
      if (e = t[e], n.has(e))
        throw new Bf(`Circular alias \`${Array.from(n).join(" -> ")} -> ${e}\``);
      n.add(e);
    }
  }
  return e;
}
class LTe extends JEe {
  constructor(t, n, r, i = {}) {
    super(t), this._resolver = t, this._themes = n, this._langs = r, this._alias = i, this._themes.map((o) => this.loadTheme(o)), this.loadLanguages(this._langs);
  }
  _resolvedThemes = /* @__PURE__ */ new Map();
  _resolvedGrammars = /* @__PURE__ */ new Map();
  _langMap = /* @__PURE__ */ new Map();
  _langGraph = /* @__PURE__ */ new Map();
  _textmateThemeCache = /* @__PURE__ */ new WeakMap();
  _loadedThemesCache = null;
  _loadedLanguagesCache = null;
  getTheme(t) {
    return typeof t == "string" ? this._resolvedThemes.get(t) : this.loadTheme(t);
  }
  loadTheme(t) {
    const n = aN(t);
    return n.name && (this._resolvedThemes.set(n.name, n), this._loadedThemesCache = null), n;
  }
  getLoadedThemes() {
    return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]), this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(t) {
    let n = this._textmateThemeCache.get(t);
    n || (n = Ub.createFromRawTheme(t), this._textmateThemeCache.set(t, n)), this._syncRegistry.setTheme(n);
  }
  getGrammar(t) {
    return t = S7(t, this._alias), this._resolvedGrammars.get(t);
  }
  loadLanguage(t) {
    if (this.getGrammar(t.name))
      return;
    const n = new Set(
      [...this._langMap.values()].filter((o) => o.embeddedLangsLazy?.includes(t.name))
    );
    this._resolver.addLanguage(t);
    const r = {
      balancedBracketSelectors: t.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: t.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(t.scopeName, t);
    const i = this.loadGrammarWithConfiguration(t.scopeName, 1, r);
    if (i.name = t.name, this._resolvedGrammars.set(t.name, i), t.aliases && t.aliases.forEach((o) => {
      this._alias[o] = t.name;
    }), this._loadedLanguagesCache = null, n.size)
      for (const o of n)
        this._resolvedGrammars.delete(o.name), this._loadedLanguagesCache = null, this._syncRegistry?._injectionGrammars?.delete(o.scopeName), this._syncRegistry?._grammars?.delete(o.scopeName), this.loadLanguage(this._langMap.get(o.name));
  }
  dispose() {
    super.dispose(), this._resolvedThemes.clear(), this._resolvedGrammars.clear(), this._langMap.clear(), this._langGraph.clear(), this._loadedThemesCache = null;
  }
  loadLanguages(t) {
    for (const i of t)
      this.resolveEmbeddedLanguages(i);
    const n = Array.from(this._langGraph.entries()), r = n.filter(([i, o]) => !o);
    if (r.length) {
      const i = n.filter(([o, s]) => s ? (s.embeddedLanguages || s.embeddedLangs)?.some((c) => r.map(([u]) => u).includes(c)) : !1).filter((o) => !r.includes(o));
      throw new Bf(`Missing languages ${r.map(([o]) => `\`${o}\``).join(", ")}, required by ${i.map(([o]) => `\`${o}\``).join(", ")}`);
    }
    for (const [i, o] of n)
      this._resolver.addLanguage(o);
    for (const [i, o] of n)
      this.loadLanguage(o);
  }
  getLoadedLanguages() {
    return this._loadedLanguagesCache || (this._loadedLanguagesCache = [
      .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
    ]), this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(t) {
    this._langMap.set(t.name, t), this._langGraph.set(t.name, t);
    const n = t.embeddedLanguages ?? t.embeddedLangs;
    if (n)
      for (const r of n)
        this._langGraph.set(r, this._langMap.get(r));
  }
}
class BTe {
  _langs = /* @__PURE__ */ new Map();
  _scopeToLang = /* @__PURE__ */ new Map();
  _injections = /* @__PURE__ */ new Map();
  _onigLib;
  constructor(t, n) {
    this._onigLib = {
      createOnigScanner: (r) => t.createScanner(r),
      createOnigString: (r) => t.createString(r)
    }, n.forEach((r) => this.addLanguage(r));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(t) {
    return this._langs.get(t);
  }
  loadGrammar(t) {
    return this._scopeToLang.get(t);
  }
  addLanguage(t) {
    this._langs.set(t.name, t), t.aliases && t.aliases.forEach((n) => {
      this._langs.set(n, t);
    }), this._scopeToLang.set(t.scopeName, t), t.injectTo && t.injectTo.forEach((n) => {
      this._injections.get(n) || this._injections.set(n, []), this._injections.get(n).push(t.scopeName);
    });
  }
  getInjections(t) {
    const n = t.split(".");
    let r = [];
    for (let i = 1; i <= n.length; i++) {
      const o = n.slice(0, i).join(".");
      r = [...r, ...this._injections.get(o) || []];
    }
    return r;
  }
}
let em = 0;
function $Te(e) {
  em += 1, e.warnings !== !1 && em >= 10 && em % 10 === 0 && console.warn(`[Shiki] ${em} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let t = !1;
  if (!e.engine)
    throw new Bf("`engine` option is required for synchronous mode");
  const n = (e.langs || []).flat(1), r = (e.themes || []).flat(1).map(aN), i = new BTe(e.engine, n), o = new LTe(i, r, n, e.langAlias);
  let s;
  function a(M) {
    return S7(M, e.langAlias);
  }
  function c(M) {
    S();
    const N = o.getGrammar(typeof M == "string" ? M : M.name);
    if (!N)
      throw new Bf(`Language \`${M}\` not found, you may need to load it first`);
    return N;
  }
  function u(M) {
    if (M === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    S();
    const N = o.getTheme(M);
    if (!N)
      throw new Bf(`Theme \`${M}\` not found, you may need to load it first`);
    return N;
  }
  function f(M) {
    S();
    const N = u(M);
    s !== M && (o.setTheme(N), s = M);
    const P = o.getColorMap();
    return {
      theme: N,
      colorMap: P
    };
  }
  function h() {
    return S(), o.getLoadedThemes();
  }
  function m() {
    return S(), o.getLoadedLanguages();
  }
  function g(...M) {
    S(), o.loadLanguages(M.flat(1));
  }
  async function b(...M) {
    return g(await x7(M));
  }
  function x(...M) {
    S();
    for (const N of M.flat(1))
      o.loadTheme(N);
  }
  async function w(...M) {
    return S(), x(await w7(M));
  }
  function S() {
    if (t)
      throw new Bf("Shiki instance has been disposed");
  }
  function _() {
    t || (t = !0, o.dispose(), em -= 1);
  }
  return {
    setTheme: f,
    getTheme: u,
    getLanguage: c,
    getLoadedThemes: h,
    getLoadedLanguages: m,
    resolveLangAlias: a,
    loadLanguage: b,
    loadLanguageSync: g,
    loadTheme: w,
    loadThemeSync: x,
    dispose: _,
    [Symbol.dispose]: _
  };
}
async function UTe(e) {
  e.engine || zTe("`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.");
  const [
    t,
    n,
    r
  ] = await Promise.all([
    w7(e.themes || []),
    x7(e.langs || []),
    e.engine
  ]);
  return $Te({
    ...e,
    themes: t,
    langs: n,
    engine: r
  });
}
async function FTe(e) {
  const t = await UTe(e);
  return {
    getLastGrammarState: (...n) => kTe(t, ...n),
    codeToTokensBase: (n, r) => oN(t, n, r),
    codeToTokensWithThemes: (n, r) => b7(t, n, r),
    codeToTokens: (n, r) => Zb(t, n, r),
    codeToHast: (n, r) => Yb(t, n, r),
    codeToHtml: (n, r) => jTe(t, n, r),
    getBundledLanguages: () => ({}),
    getBundledThemes: () => ({}),
    ...t,
    getInternalContext: () => t
  };
}
function VTe(e) {
  const t = e.langs, n = e.themes, r = e.engine;
  async function i(o) {
    function s(h) {
      if (typeof h == "string") {
        if (h = o.langAlias?.[h] || h, p7(h))
          return [];
        const m = t[h];
        if (!m)
          throw new kr(`Language \`${h}\` is not included in this bundle. You may want to load it from external source.`);
        return m;
      }
      return h;
    }
    function a(h) {
      if (m7(h))
        return "none";
      if (typeof h == "string") {
        const m = n[h];
        if (!m)
          throw new kr(`Theme \`${h}\` is not included in this bundle. You may want to load it from external source.`);
        return m;
      }
      return h;
    }
    const c = (o.themes ?? []).map((h) => a(h)), u = (o.langs ?? []).map((h) => s(h)), f = await FTe({
      engine: o.engine ?? r(),
      ...o,
      themes: c,
      langs: u
    });
    return {
      ...f,
      loadLanguage(...h) {
        return f.loadLanguage(...h.map(s));
      },
      loadTheme(...h) {
        return f.loadTheme(...h.map(a));
      },
      getBundledLanguages() {
        return t;
      },
      getBundledThemes() {
        return n;
      }
    };
  }
  return i;
}
function HTe(e) {
  let t;
  async function n(r = {}) {
    if (t) {
      const i = await t;
      return await Promise.all([
        i.loadTheme(...r.themes || []),
        i.loadLanguage(...r.langs || [])
      ]), i;
    } else {
      t = e({
        ...r,
        themes: [],
        langs: []
      });
      const i = await t;
      return await Promise.all([
        i.loadTheme(...r.themes || []),
        i.loadLanguage(...r.langs || [])
      ]), i;
    }
  }
  return n;
}
function WTe(e, t) {
  const n = HTe(e);
  async function r(i, o) {
    const s = await n({
      langs: [o.lang],
      themes: "theme" in o ? [o.theme] : Object.values(o.themes)
    }), a = await t?.guessEmbeddedLanguages?.(i, o.lang, s);
    return a && await s.loadLanguage(...a), s;
  }
  return {
    getSingletonHighlighter(i) {
      return n(i);
    },
    async codeToHtml(i, o) {
      return (await r(i, o)).codeToHtml(i, o);
    },
    async codeToHast(i, o) {
      return (await r(i, o)).codeToHast(i, o);
    },
    async codeToTokens(i, o) {
      return (await r(i, o)).codeToTokens(i, o);
    },
    async codeToTokensBase(i, o) {
      return (await r(i, o)).codeToTokensBase(i, o);
    },
    async codeToTokensWithThemes(i, o) {
      return (await r(i, o)).codeToTokensWithThemes(i, o);
    },
    async getLastGrammarState(i, o) {
      return (await n({
        langs: [o.lang],
        themes: [o.theme]
      })).getLastGrammarState(i, o);
    }
  };
}
const qTe = [
  {
    id: "andromeeda",
    displayName: "Andromeeda",
    type: "dark",
    import: (() => import("./andromeeda-BbmzSJq1.js"))
  },
  {
    id: "aurora-x",
    displayName: "Aurora X",
    type: "dark",
    import: (() => import("./aurora-x-BwoVEUWZ.js"))
  },
  {
    id: "ayu-dark",
    displayName: "Ayu Dark",
    type: "dark",
    import: (() => import("./ayu-dark-Dsjk_2Jx.js"))
  },
  {
    id: "ayu-light",
    displayName: "Ayu Light",
    type: "light",
    import: (() => import("./ayu-light-R7pgdmWq.js"))
  },
  {
    id: "ayu-mirage",
    displayName: "Ayu Mirage",
    type: "dark",
    import: (() => import("./ayu-mirage-DraY-SDX.js"))
  },
  {
    id: "catppuccin-frappe",
    displayName: "Catppuccin Frapp",
    type: "dark",
    import: (() => import("./catppuccin-frappe-D3cH2rXe.js"))
  },
  {
    id: "catppuccin-latte",
    displayName: "Catppuccin Latte",
    type: "light",
    import: (() => import("./catppuccin-latte-C0LRGUW4.js"))
  },
  {
    id: "catppuccin-macchiato",
    displayName: "Catppuccin Macchiato",
    type: "dark",
    import: (() => import("./catppuccin-macchiato-c5wQ11TT.js"))
  },
  {
    id: "catppuccin-mocha",
    displayName: "Catppuccin Mocha",
    type: "dark",
    import: (() => import("./catppuccin-mocha-WMD6Qvya.js"))
  },
  {
    id: "dark-plus",
    displayName: "Dark Plus",
    type: "dark",
    import: (() => import("./dark-plus-pUHDTVV0.js"))
  },
  {
    id: "dracula",
    displayName: "Dracula Theme",
    type: "dark",
    import: (() => import("./dracula-BtZx2Kac.js"))
  },
  {
    id: "dracula-soft",
    displayName: "Dracula Theme Soft",
    type: "dark",
    import: (() => import("./dracula-soft-BKa-aqBv.js"))
  },
  {
    id: "everforest-dark",
    displayName: "Everforest Dark",
    type: "dark",
    import: (() => import("./everforest-dark-DMCBqXCK.js"))
  },
  {
    id: "everforest-light",
    displayName: "Everforest Light",
    type: "light",
    import: (() => import("./everforest-light-BbXl82Em.js"))
  },
  {
    id: "github-dark",
    displayName: "GitHub Dark",
    type: "dark",
    import: (() => import("./github-dark-DenFmJkN.js"))
  },
  {
    id: "github-dark-default",
    displayName: "GitHub Dark Default",
    type: "dark",
    import: (() => import("./github-dark-default-BJPUVz4H.js"))
  },
  {
    id: "github-dark-dimmed",
    displayName: "GitHub Dark Dimmed",
    type: "dark",
    import: (() => import("./github-dark-dimmed-DUshB20C.js"))
  },
  {
    id: "github-dark-high-contrast",
    displayName: "GitHub Dark High Contrast",
    type: "dark",
    import: (() => import("./github-dark-high-contrast-D3aGCnF8.js"))
  },
  {
    id: "github-light",
    displayName: "GitHub Light",
    type: "light",
    import: (() => import("./github-light-JYsPkUQd.js"))
  },
  {
    id: "github-light-default",
    displayName: "GitHub Light Default",
    type: "light",
    import: (() => import("./github-light-default-D99KPAby.js"))
  },
  {
    id: "github-light-high-contrast",
    displayName: "GitHub Light High Contrast",
    type: "light",
    import: (() => import("./github-light-high-contrast-BbmZE-Mp.js"))
  },
  {
    id: "gruvbox-dark-hard",
    displayName: "Gruvbox Dark Hard",
    type: "dark",
    import: (() => import("./gruvbox-dark-hard-C5HOtKIh.js"))
  },
  {
    id: "gruvbox-dark-medium",
    displayName: "Gruvbox Dark Medium",
    type: "dark",
    import: (() => import("./gruvbox-dark-medium-FVgwJHuz.js"))
  },
  {
    id: "gruvbox-dark-soft",
    displayName: "Gruvbox Dark Soft",
    type: "dark",
    import: (() => import("./gruvbox-dark-soft-B46F314v.js"))
  },
  {
    id: "gruvbox-light-hard",
    displayName: "Gruvbox Light Hard",
    type: "light",
    import: (() => import("./gruvbox-light-hard-CJD38wDZ.js"))
  },
  {
    id: "gruvbox-light-medium",
    displayName: "Gruvbox Light Medium",
    type: "light",
    import: (() => import("./gruvbox-light-medium-BlIhMYTA.js"))
  },
  {
    id: "gruvbox-light-soft",
    displayName: "Gruvbox Light Soft",
    type: "light",
    import: (() => import("./gruvbox-light-soft-DoPHyLVZ.js"))
  },
  {
    id: "horizon",
    displayName: "Horizon",
    type: "dark",
    import: (() => import("./horizon-CJQ10nlf.js"))
  },
  {
    id: "houston",
    displayName: "Houston",
    type: "dark",
    import: (() => import("./houston-BDYrDoDW.js"))
  },
  {
    id: "kanagawa-dragon",
    displayName: "Kanagawa Dragon",
    type: "dark",
    import: (() => import("./kanagawa-dragon-CiKur4Hl.js"))
  },
  {
    id: "kanagawa-lotus",
    displayName: "Kanagawa Lotus",
    type: "light",
    import: (() => import("./kanagawa-lotus-BKu-smKu.js"))
  },
  {
    id: "kanagawa-wave",
    displayName: "Kanagawa Wave",
    type: "dark",
    import: (() => import("./kanagawa-wave-CQwozSzG.js"))
  },
  {
    id: "laserwave",
    displayName: "LaserWave",
    type: "dark",
    import: (() => import("./laserwave-6a00oqik.js"))
  },
  {
    id: "light-plus",
    displayName: "Light Plus",
    type: "light",
    import: (() => import("./light-plus-CZuVqSLX.js"))
  },
  {
    id: "material-theme",
    displayName: "Material Theme",
    type: "dark",
    import: (() => import("./material-theme-D6KBX41T.js"))
  },
  {
    id: "material-theme-darker",
    displayName: "Material Theme Darker",
    type: "dark",
    import: (() => import("./material-theme-darker-CkRroheE.js"))
  },
  {
    id: "material-theme-lighter",
    displayName: "Material Theme Lighter",
    type: "light",
    import: (() => import("./material-theme-lighter-BUBw43Yz.js"))
  },
  {
    id: "material-theme-ocean",
    displayName: "Material Theme Ocean",
    type: "dark",
    import: (() => import("./material-theme-ocean-ClGX14Ja.js"))
  },
  {
    id: "material-theme-palenight",
    displayName: "Material Theme Palenight",
    type: "dark",
    import: (() => import("./material-theme-palenight-C1RVm8K1.js"))
  },
  {
    id: "min-dark",
    displayName: "Min Dark",
    type: "dark",
    import: (() => import("./min-dark-C7ak0t6c.js"))
  },
  {
    id: "min-light",
    displayName: "Min Light",
    type: "light",
    import: (() => import("./min-light-CKFxVcPp.js"))
  },
  {
    id: "monokai",
    displayName: "Monokai",
    type: "dark",
    import: (() => import("./monokai-C1KBYcO0.js"))
  },
  {
    id: "night-owl",
    displayName: "Night Owl",
    type: "dark",
    import: (() => import("./night-owl-Bm2rzalh.js"))
  },
  {
    id: "night-owl-light",
    displayName: "Night Owl Light",
    type: "light",
    import: (() => import("./night-owl-light-CBI5u5kw.js"))
  },
  {
    id: "nord",
    displayName: "Nord",
    type: "dark",
    import: (() => import("./nord-CC5OiUXg.js"))
  },
  {
    id: "one-dark-pro",
    displayName: "One Dark Pro",
    type: "dark",
    import: (() => import("./one-dark-pro-DTA3VF0_.js"))
  },
  {
    id: "one-light",
    displayName: "One Light",
    type: "light",
    import: (() => import("./one-light-LkMrt1Cf.js"))
  },
  {
    id: "plastic",
    displayName: "Plastic",
    type: "dark",
    import: (() => import("./plastic-CSTz3KZp.js"))
  },
  {
    id: "poimandres",
    displayName: "Poimandres",
    type: "dark",
    import: (() => import("./poimandres-C-VADXHD.js"))
  },
  {
    id: "red",
    displayName: "Red",
    type: "dark",
    import: (() => import("./red-7y8PH7HH.js"))
  },
  {
    id: "rose-pine",
    displayName: "Ros Pine",
    type: "dark",
    import: (() => import("./rose-pine-BKc3yVeu.js"))
  },
  {
    id: "rose-pine-dawn",
    displayName: "Ros Pine Dawn",
    type: "light",
    import: (() => import("./rose-pine-dawn-BulJcPZT.js"))
  },
  {
    id: "rose-pine-moon",
    displayName: "Ros Pine Moon",
    type: "dark",
    import: (() => import("./rose-pine-moon-j6jiXKV8.js"))
  },
  {
    id: "slack-dark",
    displayName: "Slack Dark",
    type: "dark",
    import: (() => import("./slack-dark-i7wN4OET.js"))
  },
  {
    id: "slack-ochin",
    displayName: "Slack Ochin",
    type: "light",
    import: (() => import("./slack-ochin-ndHf0LoP.js"))
  },
  {
    id: "snazzy-light",
    displayName: "Snazzy Light",
    type: "light",
    import: (() => import("./snazzy-light-BlSJXAu4.js"))
  },
  {
    id: "solarized-dark",
    displayName: "Solarized Dark",
    type: "dark",
    import: (() => import("./solarized-dark-UTmkh7lw.js"))
  },
  {
    id: "solarized-light",
    displayName: "Solarized Light",
    type: "light",
    import: (() => import("./solarized-light-BheCkDPT.js"))
  },
  {
    id: "synthwave-84",
    displayName: "Synthwave '84",
    type: "dark",
    import: (() => import("./synthwave-84-NU3C_KFZ.js"))
  },
  {
    id: "tokyo-night",
    displayName: "Tokyo Night",
    type: "dark",
    import: (() => import("./tokyo-night-DP4TmcQl.js"))
  },
  {
    id: "vesper",
    displayName: "Vesper",
    type: "dark",
    import: (() => import("./vesper-BckBta1U.js"))
  },
  {
    id: "vitesse-black",
    displayName: "Vitesse Black",
    type: "dark",
    import: (() => import("./vitesse-black-BoGvW84i.js"))
  },
  {
    id: "vitesse-dark",
    displayName: "Vitesse Dark",
    type: "dark",
    import: (() => import("./vitesse-dark-Cym-eLtO.js"))
  },
  {
    id: "vitesse-light",
    displayName: "Vitesse Light",
    type: "light",
    import: (() => import("./vitesse-light-CcmG315c.js"))
  }
], GTe = Object.fromEntries(qTe.map((e) => [e.id, e.import]));
class lN extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
}
function KTe() {
  return 2147483648;
}
function ZTe() {
  return typeof performance < "u" ? performance.now() : Date.now();
}
const YTe = (e, t) => e + (t - e % t) % t;
async function XTe(e) {
  let t, n;
  const r = {};
  function i(g) {
    n = g, r.HEAPU8 = new Uint8Array(g), r.HEAPU32 = new Uint32Array(g);
  }
  function o(g, b, x) {
    r.HEAPU8.copyWithin(g, b, b + x);
  }
  function s(g) {
    try {
      return t.grow(g - n.byteLength + 65535 >>> 16), i(t.buffer), 1;
    } catch {
    }
  }
  function a(g) {
    const b = r.HEAPU8.length;
    g = g >>> 0;
    const x = KTe();
    if (g > x)
      return !1;
    for (let w = 1; w <= 4; w *= 2) {
      let S = b * (1 + 0.2 / w);
      S = Math.min(S, g + 100663296);
      const _ = Math.min(x, YTe(Math.max(g, S), 65536));
      if (s(_))
        return !0;
    }
    return !1;
  }
  const c = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
  function u(g, b, x = 1024) {
    const w = b + x;
    let S = b;
    for (; g[S] && !(S >= w); ) ++S;
    if (S - b > 16 && g.buffer && c)
      return c.decode(g.subarray(b, S));
    let _ = "";
    for (; b < S; ) {
      let M = g[b++];
      if (!(M & 128)) {
        _ += String.fromCharCode(M);
        continue;
      }
      const N = g[b++] & 63;
      if ((M & 224) === 192) {
        _ += String.fromCharCode((M & 31) << 6 | N);
        continue;
      }
      const P = g[b++] & 63;
      if ((M & 240) === 224 ? M = (M & 15) << 12 | N << 6 | P : M = (M & 7) << 18 | N << 12 | P << 6 | g[b++] & 63, M < 65536)
        _ += String.fromCharCode(M);
      else {
        const I = M - 65536;
        _ += String.fromCharCode(55296 | I >> 10, 56320 | I & 1023);
      }
    }
    return _;
  }
  function f(g, b) {
    return g ? u(r.HEAPU8, g, b) : "";
  }
  const h = {
    emscripten_get_now: ZTe,
    emscripten_memcpy_big: o,
    emscripten_resize_heap: a,
    fd_write: () => 0
  };
  async function m() {
    const b = await e({
      env: h,
      wasi_snapshot_preview1: h
    });
    t = b.memory, i(t.buffer), Object.assign(r, b), r.UTF8ToString = f;
  }
  return await m(), r;
}
var JTe = Object.defineProperty, QTe = (e, t, n) => t in e ? JTe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Or = (e, t, n) => QTe(e, typeof t != "symbol" ? t + "" : t, n);
let $r = null;
function eAe(e) {
  throw new lN(e.UTF8ToString(e.getLastOnigError()));
}
class $w {
  constructor(t) {
    Or(this, "utf16Length"), Or(this, "utf8Length"), Or(this, "utf16Value"), Or(this, "utf8Value"), Or(this, "utf16OffsetToUtf8"), Or(this, "utf8OffsetToUtf16");
    const n = t.length, r = $w._utf8ByteLength(t), i = r !== n, o = i ? new Uint32Array(n + 1) : null;
    i && (o[n] = r);
    const s = i ? new Uint32Array(r + 1) : null;
    i && (s[r] = n);
    const a = new Uint8Array(r);
    let c = 0;
    for (let u = 0; u < n; u++) {
      const f = t.charCodeAt(u);
      let h = f, m = !1;
      if (f >= 55296 && f <= 56319 && u + 1 < n) {
        const g = t.charCodeAt(u + 1);
        g >= 56320 && g <= 57343 && (h = (f - 55296 << 10) + 65536 | g - 56320, m = !0);
      }
      i && (o[u] = c, m && (o[u + 1] = c), h <= 127 ? s[c + 0] = u : h <= 2047 ? (s[c + 0] = u, s[c + 1] = u) : h <= 65535 ? (s[c + 0] = u, s[c + 1] = u, s[c + 2] = u) : (s[c + 0] = u, s[c + 1] = u, s[c + 2] = u, s[c + 3] = u)), h <= 127 ? a[c++] = h : h <= 2047 ? (a[c++] = 192 | (h & 1984) >>> 6, a[c++] = 128 | (h & 63) >>> 0) : h <= 65535 ? (a[c++] = 224 | (h & 61440) >>> 12, a[c++] = 128 | (h & 4032) >>> 6, a[c++] = 128 | (h & 63) >>> 0) : (a[c++] = 240 | (h & 1835008) >>> 18, a[c++] = 128 | (h & 258048) >>> 12, a[c++] = 128 | (h & 4032) >>> 6, a[c++] = 128 | (h & 63) >>> 0), m && u++;
    }
    this.utf16Length = n, this.utf8Length = r, this.utf16Value = t, this.utf8Value = a, this.utf16OffsetToUtf8 = o, this.utf8OffsetToUtf16 = s;
  }
  static _utf8ByteLength(t) {
    let n = 0;
    for (let r = 0, i = t.length; r < i; r++) {
      const o = t.charCodeAt(r);
      let s = o, a = !1;
      if (o >= 55296 && o <= 56319 && r + 1 < i) {
        const c = t.charCodeAt(r + 1);
        c >= 56320 && c <= 57343 && (s = (o - 55296 << 10) + 65536 | c - 56320, a = !0);
      }
      s <= 127 ? n += 1 : s <= 2047 ? n += 2 : s <= 65535 ? n += 3 : n += 4, a && r++;
    }
    return n;
  }
  createString(t) {
    const n = t.omalloc(this.utf8Length);
    return t.HEAPU8.set(this.utf8Value, n), n;
  }
}
const Uw = class js {
  constructor(t) {
    if (Or(this, "id", ++js.LAST_ID), Or(this, "_onigBinding"), Or(this, "content"), Or(this, "utf16Length"), Or(this, "utf8Length"), Or(this, "utf16OffsetToUtf8"), Or(this, "utf8OffsetToUtf16"), Or(this, "ptr"), !$r)
      throw new lN("Must invoke loadWasm first.");
    this._onigBinding = $r, this.content = t;
    const n = new $w(t);
    this.utf16Length = n.utf16Length, this.utf8Length = n.utf8Length, this.utf16OffsetToUtf8 = n.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = n.utf8OffsetToUtf16, this.utf8Length < 1e4 && !js._sharedPtrInUse ? (js._sharedPtr || (js._sharedPtr = $r.omalloc(1e4)), js._sharedPtrInUse = !0, $r.HEAPU8.set(n.utf8Value, js._sharedPtr), this.ptr = js._sharedPtr) : this.ptr = n.createString($r);
  }
  convertUtf8OffsetToUtf16(t) {
    return this.utf8OffsetToUtf16 ? t < 0 ? 0 : t > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[t] : t;
  }
  convertUtf16OffsetToUtf8(t) {
    return this.utf16OffsetToUtf8 ? t < 0 ? 0 : t > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[t] : t;
  }
  dispose() {
    this.ptr === js._sharedPtr ? js._sharedPtrInUse = !1 : this._onigBinding.ofree(this.ptr);
  }
};
Or(Uw, "LAST_ID", 0);
Or(Uw, "_sharedPtr", 0);
Or(Uw, "_sharedPtrInUse", !1);
let k7 = Uw;
class tAe {
  constructor(t) {
    if (Or(this, "_onigBinding"), Or(this, "_ptr"), !$r)
      throw new lN("Must invoke loadWasm first.");
    const n = [], r = [];
    for (let a = 0, c = t.length; a < c; a++) {
      const u = new $w(t[a]);
      n[a] = u.createString($r), r[a] = u.utf8Length;
    }
    const i = $r.omalloc(4 * t.length);
    $r.HEAPU32.set(n, i / 4);
    const o = $r.omalloc(4 * t.length);
    $r.HEAPU32.set(r, o / 4);
    const s = $r.createOnigScanner(i, o, t.length);
    for (let a = 0, c = t.length; a < c; a++)
      $r.ofree(n[a]);
    $r.ofree(o), $r.ofree(i), s === 0 && eAe($r), this._onigBinding = $r, this._ptr = s;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(t, n, r) {
    let i = 0;
    if (typeof r == "number" && (i = r), typeof t == "string") {
      t = new k7(t);
      const o = this._findNextMatchSync(t, n, !1, i);
      return t.dispose(), o;
    }
    return this._findNextMatchSync(t, n, !1, i);
  }
  _findNextMatchSync(t, n, r, i) {
    const o = this._onigBinding, s = o.findNextOnigScannerMatch(this._ptr, t.id, t.ptr, t.utf8Length, t.convertUtf16OffsetToUtf8(n), i);
    if (s === 0)
      return null;
    const a = o.HEAPU32;
    let c = s / 4;
    const u = a[c++], f = a[c++], h = [];
    for (let m = 0; m < f; m++) {
      const g = t.convertUtf8OffsetToUtf16(a[c++]), b = t.convertUtf8OffsetToUtf16(a[c++]);
      h[m] = {
        start: g,
        end: b,
        length: b - g
      };
    }
    return {
      index: u,
      captureIndices: h
    };
  }
}
function nAe(e) {
  return typeof e.instantiator == "function";
}
function rAe(e) {
  return typeof e.default == "function";
}
function iAe(e) {
  return typeof e.data < "u";
}
function oAe(e) {
  return typeof Response < "u" && e instanceof Response;
}
function sAe(e) {
  return typeof ArrayBuffer < "u" && (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) || typeof Buffer < "u" && Buffer.isBuffer?.(e) || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer || typeof Uint32Array < "u" && e instanceof Uint32Array;
}
let Yv;
function aAe(e) {
  if (Yv)
    return Yv;
  async function t() {
    $r = await XTe(async (n) => {
      let r = e;
      return r = await r, typeof r == "function" && (r = await r(n)), typeof r == "function" && (r = await r(n)), nAe(r) ? r = await r.instantiator(n) : rAe(r) ? r = await r.default(n) : (iAe(r) && (r = r.data), oAe(r) ? typeof WebAssembly.instantiateStreaming == "function" ? r = await lAe(r)(n) : r = await cAe(r)(n) : sAe(r) ? r = await $C(r)(n) : r instanceof WebAssembly.Module ? r = await $C(r)(n) : "default" in r && r.default instanceof WebAssembly.Module && (r = await $C(r.default)(n))), "instance" in r && (r = r.instance), "exports" in r && (r = r.exports), r;
    });
  }
  return Yv = t(), Yv;
}
function $C(e) {
  return (t) => WebAssembly.instantiate(e, t);
}
function lAe(e) {
  return (t) => WebAssembly.instantiateStreaming(e, t);
}
function cAe(e) {
  return async (t) => {
    const n = await e.arrayBuffer();
    return WebAssembly.instantiate(n, t);
  };
}
async function uAe(e) {
  return e && await aAe(e), {
    createScanner(t) {
      return new tAe(t.map((n) => typeof n == "string" ? n : n.source));
    },
    createString(t) {
      return new k7(t);
    }
  };
}
const C7 = [
  {
    id: "angular-html",
    name: "Angular HTML",
    import: (() => import("./angular-html-DPB4Rf0C.js").then((e) => e.f))
  },
  {
    id: "angular-ts",
    name: "Angular TypeScript",
    import: (() => import("./angular-ts-CTOR2ofC.js"))
  },
  {
    id: "astro",
    name: "Astro",
    import: (() => import("./astro-CFFExE8Q.js"))
  },
  {
    id: "blade",
    name: "Blade",
    import: (() => import("./blade-D0HyNvCw.js"))
  },
  {
    id: "c",
    name: "C",
    import: (() => import("./c-eeMepfLm.js"))
  },
  {
    id: "coffee",
    name: "CoffeeScript",
    aliases: [
      "coffeescript"
    ],
    import: (() => import("./coffee-DGBR_nr_.js"))
  },
  {
    id: "cpp",
    name: "C++",
    aliases: [
      "c++"
    ],
    import: (() => import("./cpp-Cj177cuW.js"))
  },
  {
    id: "css",
    name: "CSS",
    import: (() => import("./css-CECN5uSL.js"))
  },
  {
    id: "csv",
    name: "CSV",
    import: (() => import("./csv-CmYOceLb.js"))
  },
  {
    id: "glsl",
    name: "GLSL",
    import: (() => import("./glsl-CkUcVZNK.js"))
  },
  {
    id: "graphql",
    name: "GraphQL",
    aliases: [
      "gql"
    ],
    import: (() => import("./graphql-CBu2ehBn.js"))
  },
  {
    id: "haml",
    name: "Ruby Haml",
    import: (() => import("./haml-NZLVzu_R.js"))
  },
  {
    id: "handlebars",
    name: "Handlebars",
    aliases: [
      "hbs"
    ],
    import: (() => import("./handlebars-mxStpSE7.js"))
  },
  {
    id: "html",
    name: "HTML",
    import: (() => import("./html-B50bmoVb.js"))
  },
  {
    id: "html-derivative",
    name: "HTML (Derivative)",
    import: (() => import("./html-derivative-C6bxFbFW.js"))
  },
  {
    id: "http",
    name: "HTTP",
    import: (() => import("./http-DLvAkeD-.js"))
  },
  {
    id: "hurl",
    name: "Hurl",
    import: (() => import("./hurl-CgkFN90t.js"))
  },
  {
    id: "imba",
    name: "Imba",
    import: (() => import("./imba-CimUv-Uh.js"))
  },
  {
    id: "java",
    name: "Java",
    import: (() => import("./java-DY6VlHhP.js"))
  },
  {
    id: "javascript",
    name: "JavaScript",
    aliases: [
      "js",
      "cjs",
      "mjs"
    ],
    import: (() => import("./javascript-C25yR2R2.js"))
  },
  {
    id: "jinja",
    name: "Jinja",
    import: (() => import("./jinja-CFW5uAwY.js"))
  },
  {
    id: "jison",
    name: "Jison",
    import: (() => import("./jison-DdreslRX.js"))
  },
  {
    id: "json",
    name: "JSON",
    import: (() => import("./json-DxJze_jm.js"))
  },
  {
    id: "json5",
    name: "JSON5",
    import: (() => import("./json5-BT4Fjg39.js"))
  },
  {
    id: "jsonc",
    name: "JSON with Comments",
    import: (() => import("./jsonc-CHjZD8gR.js"))
  },
  {
    id: "jsonl",
    name: "JSON Lines",
    import: (() => import("./jsonl-BGuvDmy9.js"))
  },
  {
    id: "jsx",
    name: "JSX",
    import: (() => import("./jsx-BtKADgXT.js"))
  },
  {
    id: "julia",
    name: "Julia",
    aliases: [
      "jl"
    ],
    import: (() => import("./julia-CZiKXNNP.js"))
  },
  {
    id: "less",
    name: "Less",
    import: (() => import("./less-B1GLI2Di.js"))
  },
  {
    id: "markdown",
    name: "Markdown",
    aliases: [
      "md"
    ],
    import: (() => import("./markdown-CrScaQ96.js"))
  },
  {
    id: "marko",
    name: "Marko",
    import: (() => import("./marko-Ns9BYtDO.js"))
  },
  {
    id: "mdc",
    name: "MDC",
    import: (() => import("./mdc-uaivvctV.js"))
  },
  {
    id: "mdx",
    name: "MDX",
    import: (() => import("./mdx-BOhZZUJ8.js"))
  },
  {
    id: "php",
    name: "PHP",
    import: (() => import("./php-BIzsF_5x.js"))
  },
  {
    id: "postcss",
    name: "PostCSS",
    import: (() => import("./postcss-05aHdL-n.js"))
  },
  {
    id: "pug",
    name: "Pug",
    aliases: [
      "jade"
    ],
    import: (() => import("./pug-XOw9Q1Ho.js"))
  },
  {
    id: "python",
    name: "Python",
    aliases: [
      "py"
    ],
    import: (() => import("./python-BFNSHbwJ.js"))
  },
  {
    id: "r",
    name: "R",
    import: (() => import("./r-CSmzDPi7.js"))
  },
  {
    id: "regexp",
    name: "RegExp",
    aliases: [
      "regex"
    ],
    import: (() => import("./regexp-BazyLpPg.js"))
  },
  {
    id: "sass",
    name: "Sass",
    import: (() => import("./sass-DxHp5rTx.js"))
  },
  {
    id: "scss",
    name: "SCSS",
    import: (() => import("./scss-B1FaCqwR.js"))
  },
  {
    id: "shellscript",
    name: "Shell",
    aliases: [
      "bash",
      "sh",
      "shell",
      "zsh"
    ],
    import: (() => import("./shellscript-InADTalH.js"))
  },
  {
    id: "sql",
    name: "SQL",
    import: (() => import("./sql-Cn_v3PB0.js"))
  },
  {
    id: "stylus",
    name: "Stylus",
    aliases: [
      "styl"
    ],
    import: (() => import("./stylus-CyKEU1Ej.js"))
  },
  {
    id: "svelte",
    name: "Svelte",
    import: (() => import("./svelte-CYf4HR3U.js"))
  },
  {
    id: "ts-tags",
    name: "TypeScript with Tags",
    aliases: [
      "lit"
    ],
    import: (() => import("./ts-tags-ioVe2PKw.js"))
  },
  {
    id: "tsx",
    name: "TSX",
    import: (() => import("./tsx-B8rCNbgL.js"))
  },
  {
    id: "typescript",
    name: "TypeScript",
    aliases: [
      "ts",
      "cts",
      "mts"
    ],
    import: (() => import("./typescript-RycA9KXf.js"))
  },
  {
    id: "vue",
    name: "Vue",
    import: (() => import("./vue-DXEmyXn9.js"))
  },
  {
    id: "vue-html",
    name: "Vue HTML",
    import: (() => import("./vue-html-j9xNEdu3.js"))
  },
  {
    id: "vue-vine",
    name: "Vue Vine",
    import: (() => import("./vue-vine-D41-N99t.js"))
  },
  {
    id: "wasm",
    name: "WebAssembly",
    import: (() => import("./wasm-BBXxrAl7.js"))
  },
  {
    id: "wgsl",
    name: "WGSL",
    import: (() => import("./wgsl-DY4iK1q1.js"))
  },
  {
    id: "wit",
    name: "WebAssembly Interface Types",
    import: (() => import("./wit-CQMQOlTg.js"))
  },
  {
    id: "xml",
    name: "XML",
    import: (() => import("./xml-C2J0sS9M.js"))
  },
  {
    id: "yaml",
    name: "YAML",
    aliases: [
      "yml"
    ],
    import: (() => import("./yaml-DaO7k5B1.js"))
  }
], dAe = Object.fromEntries(C7.map((e) => [e.id, e.import])), fAe = Object.fromEntries(C7.flatMap((e) => e.aliases?.map((t) => [t, e.import]) || [])), E7 = {
  ...dAe,
  ...fAe
}, hAe = /* @__PURE__ */ VTe({
  langs: E7,
  themes: GTe,
  engine: () => uAe(import("./wasm-DQxwEHae.js"))
}), {
  codeToHast: pAe
} = /* @__PURE__ */ WTe(
  hAe,
  { guessEmbeddedLanguages: iTe }
);
var _7 = (e) => typeof e == "function", $f = (e) => _7(e?.then), mAe = (e) => {
  try {
    return e instanceof Error ? e : typeof e == "string" ? new Error(e) : new Error(JSON.stringify(e));
  } catch (t) {
    return t;
  }
}, B0 = (e) => ({ isOk: !0, error: void 0, value: e }), $0 = (e) => ({ isOk: !1, error: mAe(e), value: void 0 }), gAe = (e, t) => {
  if ($f(e)) return e.then(t).then(B0, $0);
  try {
    let n = t(e);
    return $f(n) ? n.then((r) => Promise.resolve(B0(r)), (r) => Promise.resolve($0(r))) : B0(n);
  } catch (n) {
    return $0(n);
  }
}, Fw = { ok: B0, fail: $0, update: gAe }, Vw = (e) => {
  let t = (n) => Vw(Fw.update(e, n));
  return { map(n) {
    return t((r) => {
      if (r.isOk) return n(r.value);
      throw r.error;
    });
  }, flatMap(n) {
    return t((r) => {
      if (r.isOk) return n(r.value).unwrap();
      throw r.error;
    });
  }, effect(n) {
    return t((r) => {
      if (!r.isOk) throw r.error;
      let i = n(r.value);
      return $f(i) ? i.then(() => r.value) : r.value;
    });
  }, ifOk(n) {
    return t((r) => {
      if (!r.isOk) throw r.error;
      let i = n(r.value);
      return $f(i) ? i.then(() => r.value) : r.value;
    });
  }, watch(n) {
    return t((r) => {
      try {
        n({ ...r });
      } catch {
      }
      if (r.isOk) return r.value;
      throw r.error;
    });
  }, catch(n) {
    return t((r) => r.isOk ? r.value : n(r.error));
  }, ifFail(n) {
    return t((r) => r.isOk ? r.value : n(r.error));
  }, unwrap() {
    if ($f(e)) return e.then((n) => {
      if (n.isOk) return n.value;
      throw n.error;
    });
    if (e.isOk) return e.value;
    throw e.error;
  }, isOk: $f(e) ? e.then((n) => Promise.resolve(n.isOk)) : e.isOk, orElse(n) {
    return t((r) => r.isOk ? r.value : n).unwrap();
  } };
};
function T7(e) {
  let t = Vw(Fw.ok(void 0));
  try {
    return t.map(() => e);
  } catch (n) {
    return t.map(() => {
      throw n;
    });
  }
}
function yAe(e) {
  let t = Vw(Fw.ok(void 0));
  try {
    return t.map(() => e());
  } catch (n) {
    return t.map(() => {
      throw n;
    });
  }
}
function vAe() {
  return Vw(Fw.ok(void 0));
}
function bAe(...e) {
  return (t) => {
    let n = T7(t);
    return e.reduce((r, i) => r.map(i), n);
  };
}
function cN(e) {
  return e === void 0 ? vAe() : _7(e) ? yAe(e) : T7(e);
}
cN.pipe = bAe;
const uN = (e = 2e3) => {
  const [t, n] = C.useState(!1);
  return { copied: t, copy: (i) => {
    navigator.clipboard.writeText(i), n(!0), setTimeout(() => {
      n(!1);
    }, e);
  } };
};
function dN(...e) {
  return e.filter(Boolean).join(" ");
}
function xAe() {
  const [e, t] = C.useState(
    () => typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
  );
  return C.useEffect(() => {
    if (typeof window > "u" || !window.matchMedia) return;
    const n = window.matchMedia("(prefers-color-scheme: dark)"), r = () => t(n.matches ? "dark" : "light");
    return n.addEventListener?.("change", r), () => n.removeEventListener?.("change", r);
  }, []), e;
}
const wAe = Ne.lazy(async () => ({ default: (await import("./mermaid-diagram-lPaiznbl.js")).MermaidDiagram })), SAe = () => /* @__PURE__ */ v.jsxs("div", { className: "text-sm flex bg-accent/30 flex-col rounded-2xl relative my-4 overflow-hidden border", children: [
  /* @__PURE__ */ v.jsx("div", { className: "w-full flex z-20 py-2 px-4 items-center", children: /* @__PURE__ */ v.jsx("span", { className: "text-sm text-muted-foreground", children: "mermaid" }) }),
  /* @__PURE__ */ v.jsx("div", { className: "relative overflow-x-auto px-6 pb-6", children: /* @__PURE__ */ v.jsx("div", { className: "h-20 w-full flex items-center justify-center", children: /* @__PURE__ */ v.jsx("span", { className: "text-muted-foreground", children: "Loading Mermaid renderer" }) }) })
] }), kAe = C.memo(function(t) {
  const { className: n, active: r, ...i } = t;
  return /* @__PURE__ */ v.jsx(
    "button",
    {
      ...i,
      className: dN(
        "inline-flex items-center justify-center rounded-sm",
        "transition-colors focus:outline-none",
        r ? "bg-secondary text-foreground" : "hover:bg-muted text-muted-foreground",
        "h-7 w-7",
        n
      )
    }
  );
});
function U0({
  lang: e,
  code: t,
  children: n,
  className: r
}) {
  const { copied: i, copy: o } = uN();
  return /* @__PURE__ */ v.jsxs("pre", { className: dN("relative", r), children: [
    /* @__PURE__ */ v.jsx("div", { className: "p-1.5 border-b mb-4 z-20 bg-secondary", children: /* @__PURE__ */ v.jsxs("div", { className: "w-full flex z-20 py-0.5 px-4 items-center gap-2", children: [
      /* @__PURE__ */ v.jsx("span", { className: "text-xs uppercase tracking-wide text-muted-foreground", children: e }),
      /* @__PURE__ */ v.jsx(
        kAe,
        {
          onClick: () => o(t),
          title: "Copy code",
          "aria-label": "Copy",
          active: i,
          className: "ml-auto",
          children: i ? /* @__PURE__ */ v.jsx(wc, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(Sc, { className: "h-4 w-4" })
        }
      )
    ] }) }),
    /* @__PURE__ */ v.jsx("div", { className: "relative overflow-x-auto px-6 pb-6", children: n })
  ] });
}
async function CAe(e, t, n) {
  const r = typeof t == "string" && t in E7 ? t : "md";
  if (t === "json")
    return /* @__PURE__ */ v.jsx(U0, { code: e, lang: "json", children: /* @__PURE__ */ v.jsx(Ju, { data: e, initialExpandDepth: 3 }) });
  if (t === "mermaid")
    return /* @__PURE__ */ v.jsx(U0, { code: e, lang: "mermaid", children: /* @__PURE__ */ v.jsx(C.Suspense, { fallback: /* @__PURE__ */ v.jsx(SAe, {}), children: /* @__PURE__ */ v.jsx(wAe, { chart: e }) }) });
  const i = await pAe(e, { lang: r, theme: n });
  return JF(i, {
    Fragment: C.Fragment,
    jsx: v.jsx,
    jsxs: v.jsxs,
    components: {
      pre: (o) => /* @__PURE__ */ v.jsx(U0, { ...o, code: e, lang: String(t) })
    }
  });
}
function EAe({ children: e }) {
  const t = e?.props?.children ?? "", n = e?.props?.className?.split("-")?.[1] || "bash", i = xAe() === "dark" ? "dark-plus" : "github-light", [o, s] = C.useState(!0), [a, c] = C.useState(
    /* @__PURE__ */ v.jsx(U0, { className: "animate-pulse", code: t, lang: n, children: e })
  );
  return C.useLayoutEffect(() => {
    cN().map(() => CAe(t, n, i)).ifOk(c).watch(() => s(!1));
  }, [i, n, t]), /* @__PURE__ */ v.jsx(
    "div",
    {
      className: dN(
        o && "animate-pulse",
        "text-sm flex bg-secondary/40 shadow border flex-col rounded relative my-4 overflow-hidden"
      ),
      children: a
    }
  );
}
function A7({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "div",
    {
      "data-slot": "table-container",
      className: "relative w-full overflow-x-auto",
      children: /* @__PURE__ */ v.jsx(
        "table",
        {
          "data-slot": "table",
          className: at("w-full caption-bottom text-sm", e),
          ...t
        }
      )
    }
  );
}
function M7({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "thead",
    {
      "data-slot": "table-header",
      className: at("[&_tr]:border-b", e),
      ...t
    }
  );
}
function N7({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "tbody",
    {
      "data-slot": "table-body",
      className: at("[&_tr:last-child]:border-0", e),
      ...t
    }
  );
}
function F0({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "tr",
    {
      "data-slot": "table-row",
      className: at(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        e
      ),
      ...t
    }
  );
}
function R7({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "th",
    {
      "data-slot": "table-head",
      className: at(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        e
      ),
      ...t
    }
  );
}
function oT({ className: e, ...t }) {
  return /* @__PURE__ */ v.jsx(
    "td",
    {
      "data-slot": "table-cell",
      className: at(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        e
      ),
      ...t
    }
  );
}
const O7 = C.memo(({ children: e }) => /* @__PURE__ */ v.jsxs("span", { className: "fade-in animate-in duration-1000", children: [
  e,
  " "
] }));
O7.displayName = "FadeIn";
const _Ae = C.memo(({ children: e }) => ch(e) ? /* @__PURE__ */ v.jsx(rg, { text: e }) : /* @__PURE__ */ v.jsx(v.Fragment, { children: e }));
_Ae.displayName = "EntityText";
const Br = C.memo(({ children: e }) => {
  if (ch(e))
    return /* @__PURE__ */ v.jsx("span", { className: "fade-in animate-in duration-1000", children: /* @__PURE__ */ v.jsx(rg, { text: e }) });
  const t = [e].flat();
  return /* @__PURE__ */ v.jsx(v.Fragment, { children: t.map(
    (n, r) => ch(n) ? /* @__PURE__ */ v.jsx(O7, { children: /* @__PURE__ */ v.jsx(rg, { text: n }) }, r) : n
  ) });
});
Br.displayName = "WordByWordFadeIn";
const TAe = {
  table: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("div", { className: "my-1", children: /* @__PURE__ */ v.jsx(A7, { ...n, children: t }) }),
  thead: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(M7, { ...n, children: t }),
  tbody: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(N7, { ...n, children: t }),
  tr: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(F0, { ...n, children: t }),
  th: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(R7, { ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  td: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx(oT, { ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  code: ({ children: e }) => /* @__PURE__ */ v.jsx("code", { className: "text-sm rounded-md bg-accent text-primary py-1 px-2 mx-0.5", children: /* @__PURE__ */ v.jsx(Br, { children: e }) }),
  blockquote: ({ children: e }) => /* @__PURE__ */ v.jsx("div", { className: "px-4", children: /* @__PURE__ */ v.jsx("blockquote", { className: "relative bg-accent/30 p-6 rounded-2xl my-2 overflow-hidden border", children: /* @__PURE__ */ v.jsx(Br, { children: e }) }) }),
  p: ({ children: e }) => /* @__PURE__ */ v.jsx("p", { className: "leading-6 my-1 break-words", children: /* @__PURE__ */ v.jsx(Br, { children: e }) }),
  pre: ({ children: e }) => /* @__PURE__ */ v.jsx("div", { className: "px-4 py-2", children: /* @__PURE__ */ v.jsx(EAe, { children: e }) }),
  ol: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("ol", { className: "px-4 list-decimal list-outside ol-context", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  ul: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("ul", { className: "px-4 list-none ul-context", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  li: ({ node: e, children: t, ...n }) => {
    const r = C.useRef(null), [i, o] = C.useState(!1);
    return C.useEffect(() => {
      r.current?.parentElement?.tagName === "UL" && o(!0);
    }, []), /* @__PURE__ */ v.jsx("li", { ref: r, className: "py-1 break-words", ...n, children: i ? /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
      /* @__PURE__ */ v.jsx("span", { className: "text-green-500 mt-0.5", children: "" }),
      /* @__PURE__ */ v.jsx("div", { className: "flex-1", children: /* @__PURE__ */ v.jsx(Br, { children: t }) })
    ] }) : /* @__PURE__ */ v.jsx(Br, { children: t }) });
  },
  strong: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("span", { className: "font-semibold", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  a: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsxs(
    "a",
    {
      className: "text-primary hover:underline flex gap-1.5 items-center",
      target: "_blank",
      rel: "noreferrer",
      ...n,
      children: [
        /* @__PURE__ */ v.jsx(rY, { className: "size-3.5" }),
        /* @__PURE__ */ v.jsx(Br, { children: t })
      ]
    }
  ),
  h1: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h1", { className: "text-3xl font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  h2: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h2", { className: "text-2xl font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  h3: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h3", { className: "text-xl font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  h4: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h4", { className: "text-lg font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  h5: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h5", { className: "text-base font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  h6: ({ node: e, children: t, ...n }) => /* @__PURE__ */ v.jsx("h6", { className: "text-sm font-semibold mt-6 mb-2", ...n, children: /* @__PURE__ */ v.jsx(Br, { children: t }) }),
  img: ({ node: e, children: t, ...n }) => {
    const { src: r, alt: i, ...o } = n;
    return r ? (
      // eslint-disable-next-line @next/next/no-img-element
      /* @__PURE__ */ v.jsx("img", { className: "mx-auto rounded-lg", src: r, alt: i, ...o })
    ) : null;
  }
}, AAe = ({ children: e }) => /* @__PURE__ */ v.jsx("article", { className: "w-full h-full relative", children: hle(e) ? /* @__PURE__ */ v.jsx(Ju, { data: e }) : /* @__PURE__ */ v.jsx(JSe, { components: TAe, remarkPlugins: [fEe], children: e }) }), D7 = C.memo(
  AAe,
  (e, t) => e.children === t.children
), MAe = ({
  reasoningText: e,
  isThinking: t
}) => {
  const [n, r] = C.useState(!!t), [i, o] = C.useState(!!t);
  return C.useEffect(() => {
    t && !i ? (r(!0), o(!0)) : !t && i && (r(!1), o(!1));
  }, [t, i]), !e && !t ? null : /* @__PURE__ */ v.jsx("div", { className: "text-xs", children: n && /* @__PURE__ */ v.jsx("div", { className: "mt-2 pl-4 text-muted-foreground bg-muted/20 p-2 rounded-md", children: /* @__PURE__ */ v.jsx(D7, { children: e || (t ? "Reasoning..." : "No reasoning content available") }) }) });
}, NAe = C.memo(MAe), P7 = ({
  text: e,
  onReuseMessage: t,
  onRegenerate: n,
  className: r = ""
}) => {
  const [i, o] = C.useState(!1), [s, a] = C.useState(!1), [c, u] = C.useState(!1), f = async (g) => {
    g.preventDefault(), g.stopPropagation();
    try {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(e ?? ""), o(!0), cn.success("Message copied to clipboard", { duration: 2e3 }), setTimeout(() => o(!1), 3e3);
        return;
      }
      if (navigator.clipboard)
        try {
          await navigator.clipboard.writeText(e ?? ""), o(!0), setTimeout(() => o(!1), 3e3);
          return;
        } catch (x) {
          console.warn("Clipboard API failed, trying selection fallback:", x);
        }
      const b = document.createElement("textarea");
      b.value = e ?? "", b.style.position = "fixed", b.style.left = "-9999px", b.style.top = "-9999px", b.style.opacity = "0", b.setAttribute("readonly", ""), document.body.appendChild(b);
      try {
        b.select(), b.setSelectionRange(0, b.value.length);
        const x = window.getSelection();
        if (x) {
          x.removeAllRanges();
          const w = document.createRange();
          w.selectNodeContents(b), x.addRange(w), o(!0), setTimeout(() => o(!1), 3e3);
        } else
          throw new Error("Selection API not supported");
      } finally {
        document.body.removeChild(b);
      }
    } catch (b) {
      console.warn("All copy methods failed:", b), alert("Unable to copy automatically. Please select and copy the text manually.");
    }
  }, h = async (g) => {
    if (g.preventDefault(), g.stopPropagation(), t && e && !s)
      try {
        a(!0), await new Promise((b) => setTimeout(b, 300)), t(e);
      } finally {
        a(!1);
      }
  }, m = async (g) => {
    if (g.preventDefault(), g.stopPropagation(), n && !c)
      try {
        u(!0), await n(), cn.success("Regenerating response...", { duration: 2e3 });
      } catch {
        cn.error("Failed to regenerate", { duration: 2e3 });
      } finally {
        u(!1);
      }
  };
  return /* @__PURE__ */ v.jsxs("div", { className: `flex gap-1 ${r}`, "data-testid": "message-action-buttons", children: [
    n && /* @__PURE__ */ v.jsx(
      "button",
      {
        "aria-label": c ? "Regenerating..." : "Regenerate response",
        title: c ? "Regenerating..." : "Regenerate response",
        onClick: (g) => m(g),
        disabled: c,
        className: `p-1 rounded-lg transition-all cursor-pointer ${c ? "opacity-100 bg-purple-100 dark:bg-purple-900/30" : "hover:bg-muted/20 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 md:opacity-0 md:group-hover:opacity-100"}`,
        children: c ? /* @__PURE__ */ v.jsx(Zs, { className: "h-4 w-4 text-purple-500 animate-spin" }) : /* @__PURE__ */ v.jsx(CY, { className: "h-4 w-4 text-muted-foreground" })
      }
    ),
    /* @__PURE__ */ v.jsx(
      "button",
      {
        "aria-label": s ? "Loading..." : "Reuse this message",
        title: s ? "Loading..." : "Reuse this message",
        onClick: (g) => h(g),
        disabled: s,
        className: `p-1 rounded-lg transition-all cursor-pointer ${s ? "opacity-100 bg-blue-100 dark:bg-blue-900/30" : "hover:bg-muted/20 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 md:opacity-0 md:group-hover:opacity-100"}`,
        children: s ? /* @__PURE__ */ v.jsx(Zs, { className: "h-4 w-4 text-blue-500 animate-spin" }) : /* @__PURE__ */ v.jsx(GT, { className: "h-4 w-4 text-muted-foreground" })
      }
    ),
    /* @__PURE__ */ v.jsx(
      "button",
      {
        "aria-label": "Copy message",
        title: "Copy message",
        onClick: (g) => f(g),
        className: `p-1 rounded-lg transition-all cursor-pointer ${i ? "opacity-100 bg-green-100 dark:bg-green-900/30" : "hover:bg-muted/20 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 md:opacity-0 md:group-hover:opacity-100"}`,
        children: i ? /* @__PURE__ */ v.jsx(wc, { className: "h-4 w-4 text-green-500" }) : /* @__PURE__ */ v.jsx(Sc, { className: "h-4 w-4 text-muted-foreground" })
      }
    )
  ] });
};
async function RAe(e) {
  const t = await zc(), n = new FormData();
  n.append("file", e);
  const r = await fetch(`${Wa}/files/upload`, { method: "POST", headers: t, body: n });
  if (!r.ok) throw new Error(`Upload failed (${r.status})`);
  return r.json().catch(() => null);
}
async function OAe(e, t) {
  const n = await zc(), r = await fetch(`${Wa}/files/${encodeURIComponent(e)}`, { headers: n });
  if (!r.ok) throw new Error(`Download failed (${r.status})`);
  const i = await r.blob(), o = URL.createObjectURL(i);
  {
    const s = document.createElement("a");
    s.href = o, s.download = e, document.body.appendChild(s), s.click(), s.remove(), setTimeout(() => URL.revokeObjectURL(o), 1e3);
  }
}
const DAe = ({ files: e, className: t = "" }) => {
  const n = (s) => s.startsWith("image/") ? /* @__PURE__ */ v.jsx(QZ, { className: "h-4 w-4" }) : s === "application/pdf" ? /* @__PURE__ */ v.jsx(WZ, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(GZ, { className: "h-4 w-4" }), r = (s) => s.startsWith("image/"), i = async (s) => {
    try {
      if (s.s3Key) {
        OAe(s.s3Key, { forceDownload: !0 }), cn.success("Download started");
        return;
      }
      if (s.s3Url) {
        const a = document.createElement("a");
        a.href = s.s3Url, a.rel = "noopener", a.target = "_blank", a.download = s.fileName, document.body.appendChild(a), a.click(), a.remove(), cn.success("Download started");
        return;
      }
      cn.error("File not available");
    } catch (a) {
      console.error(a), cn.error("Download failed");
    }
  }, o = (s) => s < 1024 ? `${s} B` : s < 1048576 ? `${(s / 1024).toFixed(1)} KB` : `${(s / 1048576).toFixed(1)} MB`;
  return /* @__PURE__ */ v.jsx("div", { className: `flex flex-row justify-end flex-wrap gap-3 ${t} relative`, children: e.map((s, a) => {
    const c = s.status === "uploading";
    return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 items-end", children: [
      /* @__PURE__ */ v.jsxs(
        Dh,
        {
          variant: "outline",
          className: `flex items-center gap-2 w-fit px-3 py-2 rounded-lg shadow-sm transition-all duration-200 border-1 border-gray-300 dark:border-gray-600 ${c ? "opacity-80 cursor-default" : "cursor-pointer hover:bg-primary/10 hover:shadow-lg hover:border-primary/60 focus-visible:ring-2 focus-visible:ring-primary/40"}`,
          onClick: c ? void 0 : () => i(s),
          style: { userSelect: "text" },
          children: [
            n(s.mimeType),
            /* @__PURE__ */ v.jsx("span", { className: "text-sm font-medium truncate max-w-[180px]", children: s.fileName }),
            /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground ml-2", children: o(s.fileSize) }),
            c ? /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-1 ml-1 text-xs text-muted-foreground", children: [
              /* @__PURE__ */ v.jsx(Zs, { className: "h-3 w-3 animate-spin" }),
              /* @__PURE__ */ v.jsx("span", { children: "Uploading" })
            ] }) : /* @__PURE__ */ v.jsx(ME, { className: "h-3 w-3 ml-1 opacity-70 group-hover:opacity-100 transition" })
          ]
        }
      ),
      r(s.mimeType) && s.s3Url && /* @__PURE__ */ v.jsx(
        "img",
        {
          src: s.s3Url,
          alt: s.fileName,
          className: "max-w-xs max-h-64 rounded-xl border-2 border-gray-300 dark:border-gray-600 mt-1 shadow-md transition-all duration-200 hover:shadow-xl hover:border-primary/60 cursor-pointer",
          style: { objectFit: "cover" },
          onClick: () => i(s),
          title: "Click  ti nh"
        }
      )
    ] }, a);
  }) });
};
function PAe(e) {
  if (!e?.attachments || !Array.isArray(e.attachments)) return [];
  const t = [];
  for (const n of e.attachments) {
    if (!n) continue;
    const r = n.results;
    if (Array.isArray(r) && r.length > 0) {
      for (const o of r)
        o && t.push({
          fileName: o.fileName ?? o.file_name ?? o.name,
          fileSize: o.fileSize ?? o.size ?? 0,
          mimeType: o.mimeType ?? o.type ?? "application/octet-stream",
          s3Key: o.s3Key ?? o.key ?? o.keyName ?? void 0,
          s3Url: o.s3Url ?? o.url ?? o.location ?? void 0,
          status: o.status,
          ...o
        });
      continue;
    }
    const i = n;
    (i.fileName || i.mimeType || i.s3Key) && t.push({
      fileName: i.fileName ?? i.name,
      fileSize: i.fileSize ?? i.size ?? 0,
      mimeType: i.mimeType ?? i.type ?? "application/octet-stream",
      s3Key: i.s3Key ?? i.key ?? void 0,
      s3Url: i.s3Url ?? i.url ?? i.location ?? void 0,
      status: i.status,
      ...i
    });
  }
  return t;
}
const jAe = ({ mentions: e, className: t = "" }) => {
  if (!e || e.length === 0) return null;
  const n = (i) => {
    switch (i) {
      case "mcpTool":
        return /* @__PURE__ */ v.jsx(J0, { className: "h-3 w-3" });
      case "defaultTool":
        return /* @__PURE__ */ v.jsx(J0, { className: "h-3 w-3" });
      case "mcpServer":
        return /* @__PURE__ */ v.jsx(CD, { className: "h-3 w-3" });
      case "workflow":
        return /* @__PURE__ */ v.jsx(XY, { className: "h-3 w-3" });
      case "agent":
        return /* @__PURE__ */ v.jsx(yZ, { className: "h-3 w-3" });
      default:
        return /* @__PURE__ */ v.jsx(F3, { className: "h-3 w-3" });
    }
  }, r = (i) => i.label || i.name;
  return /* @__PURE__ */ v.jsx(Oh, { children: /* @__PURE__ */ v.jsx("div", { className: `flex flex-wrap gap-1 ${t}`, children: e.map((i, o) => /* @__PURE__ */ v.jsxs(Gi, { delayDuration: 200, children: [
    /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
      Dh,
      {
        variant: "outline",
        className: "flex items-center gap-1 text-xs px-2  bg-blue-50 dark:bg-blue-950 border-blue-200 dark:border-blue-800 text-blue-700 dark:text-blue-300",
        children: [
          n(i.type),
          /* @__PURE__ */ v.jsx("span", { className: "font-mono", children: r(i) })
        ]
      }
    ) }),
    /* @__PURE__ */ v.jsx(Bo, { className: "text-xs bg-card border border-border max-w-xs", children: /* @__PURE__ */ v.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
        n(i.type),
        /* @__PURE__ */ v.jsx("span", { className: "font-mono font-semibold", children: r(i) })
      ] }),
      /* @__PURE__ */ v.jsx("hr", { className: "border-border" }),
      /* @__PURE__ */ v.jsxs("div", { children: [
        /* @__PURE__ */ v.jsx("strong", { children: "Description:" }),
        " ",
        i.description || "No description"
      ] }),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-1", children: [
        /* @__PURE__ */ v.jsx(CD, { className: "h-3 w-3" }),
        /* @__PURE__ */ v.jsx("strong", { children: "Server:" }),
        " ",
        i.serverName || "Unknown"
      ] })
    ] }) })
  ] }, o)) }) });
};
function IAe(e, t = []) {
  let n = [];
  function r(o, s) {
    const a = C.createContext(s);
    a.displayName = o + "Context";
    const c = n.length;
    n = [...n, s];
    const u = (h) => {
      const { scope: m, children: g, ...b } = h, x = m?.[e]?.[c] || a, w = C.useMemo(() => b, Object.values(b));
      return /* @__PURE__ */ v.jsx(x.Provider, { value: w, children: g });
    };
    u.displayName = o + "Provider";
    function f(h, m) {
      const g = m?.[e]?.[c] || a, b = C.useContext(g);
      if (b) return b;
      if (s !== void 0) return s;
      throw new Error(`\`${h}\` must be used within \`${o}\``);
    }
    return [u, f];
  }
  const i = () => {
    const o = n.map((s) => C.createContext(s));
    return function(a) {
      const c = a?.[e] || o;
      return C.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: c } }),
        [a, c]
      );
    };
  };
  return i.scopeName = e, [r, zAe(i, ...t)];
}
function zAe(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(o) {
      const s = r.reduce((a, { useScope: c, scopeName: u }) => {
        const h = c(o)[`__scope${u}`];
        return { ...a, ...h };
      }, {});
      return C.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function LAe() {
  return nh.useSyncExternalStore(
    BAe,
    () => !0,
    () => !1
  );
}
function BAe() {
  return () => {
  };
}
var fN = "Avatar", [$Ae] = IAe(fN), [UAe, j7] = $Ae(fN), I7 = C.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, ...r } = e, [i, o] = C.useState("idle");
    return /* @__PURE__ */ v.jsx(
      UAe,
      {
        scope: n,
        imageLoadingStatus: i,
        onImageLoadingStatusChange: o,
        children: /* @__PURE__ */ v.jsx(Hg.span, { ...r, ref: t })
      }
    );
  }
);
I7.displayName = fN;
var z7 = "AvatarImage", FAe = C.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, src: r, onLoadingStatusChange: i = () => {
    }, ...o } = e, s = j7(z7, n), a = VAe(r, o), c = Dr((u) => {
      i(u), s.onImageLoadingStatusChange(u);
    });
    return Er(() => {
      a !== "idle" && c(a);
    }, [a, c]), a === "loaded" ? /* @__PURE__ */ v.jsx(Hg.img, { ...o, ref: t, src: r }) : null;
  }
);
FAe.displayName = z7;
var L7 = "AvatarFallback", B7 = C.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, delayMs: r, ...i } = e, o = j7(L7, n), [s, a] = C.useState(r === void 0);
    return C.useEffect(() => {
      if (r !== void 0) {
        const c = window.setTimeout(() => a(!0), r);
        return () => window.clearTimeout(c);
      }
    }, [r]), s && o.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ v.jsx(Hg.span, { ...i, ref: t }) : null;
  }
);
B7.displayName = L7;
function aL(e, t) {
  return e ? t ? (e.src !== t && (e.src = t), e.complete && e.naturalWidth > 0 ? "loaded" : "loading") : "error" : "idle";
}
function VAe(e, { referrerPolicy: t, crossOrigin: n }) {
  const r = LAe(), i = C.useRef(null), o = r ? (i.current || (i.current = new window.Image()), i.current) : null, [s, a] = C.useState(
    () => aL(o, e)
  );
  return Er(() => {
    a(aL(o, e));
  }, [o, e]), Er(() => {
    const c = (h) => () => {
      a(h);
    };
    if (!o) return;
    const u = c("loaded"), f = c("error");
    return o.addEventListener("load", u), o.addEventListener("error", f), t && (o.referrerPolicy = t), typeof n == "string" && (o.crossOrigin = n), () => {
      o.removeEventListener("load", u), o.removeEventListener("error", f);
    };
  }, [o, n, t]), s;
}
var HAe = I7, WAe = B7;
function lL({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    HAe,
    {
      "data-slot": "avatar",
      className: at("relative flex size-8 shrink-0 overflow-hidden rounded-full", e),
      ...t
    }
  );
}
function cL({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    WAe,
    {
      "data-slot": "avatar-fallback",
      className: at("bg-muted flex size-full items-center justify-center rounded-full", e),
      ...t
    }
  );
}
function qAe(e) {
  let t = 0;
  for (let r = 0; r < e.length; r++)
    t = e.charCodeAt(r) + ((t << 5) - t);
  return `hsl(${Math.abs(t) % 360}, 70%, 45%)`;
}
const GAe = ({
  part: e,
  isLast: t,
  message: n,
  onReuseMessage: r
}) => {
  const i = C.useRef(null), [o, s] = C.useState(!1), [a, c] = C.useState([]), { user: u } = UU();
  if (!n.parts) return null;
  const f = (() => {
    const m = n.metadata;
    if (!m?.attachments || !Array.isArray(m.attachments))
      return 0;
    let g = 0;
    for (const b of m.attachments)
      b && (Array.isArray(b.results) ? g += b.results.length : g += 1);
    return g;
  })();
  C.useEffect(() => {
    const m = n.metadata, g = PAe(m);
    c(g);
  }, [n.id, f, n.metadata?.attachments]), C.useEffect(() => {
    t && !o && (s(!0), i.current?.scrollIntoView({ behavior: "smooth" }));
  }, [t, o]);
  const h = n.metadata?.mentions;
  return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-1 w-full", ref: i, children: [
    /* @__PURE__ */ v.jsx("div", { className: "flex justify-end my-2 ", children: /* @__PURE__ */ v.jsxs("div", { className: "group flex items-start gap-2", children: [
      /* @__PURE__ */ v.jsx("div", { className: "relative flex flex-col gap-2 items-end", children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ v.jsx(
          P7,
          {
            text: e.text ?? "",
            onReuseMessage: r,
            className: "ml-2"
          }
        ),
        /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2", children: [
          /* @__PURE__ */ v.jsx("div", { className: "bg-neutral-200 dark:bg-neutral-700 px-3 py-2 rounded-md text-sm text-foreground", children: /* @__PURE__ */ v.jsx(rg, { text: e.text ?? "" }) }),
          h && h.length > 0 && /* @__PURE__ */ v.jsx(jAe, { mentions: h, className: "justify-end" })
        ] })
      ] }) }),
      /* @__PURE__ */ v.jsx("span", { className: "shrink-0 mt-1", children: u != null ? /* @__PURE__ */ v.jsx(lL, { children: /* @__PURE__ */ v.jsx(
        cL,
        {
          className: "text-xs text-primary-foreground items-center",
          title: u.emailAddresses[0]?.emailAddress ?? "",
          style: {
            backgroundColor: qAe(u.id)
          },
          children: u.emailAddresses[0]?.emailAddress.slice(0, 2).toUpperCase() ?? ""
        }
      ) }) : /* @__PURE__ */ v.jsx(lL, { children: /* @__PURE__ */ v.jsx(cL, { children: "No Avatar" }) }) })
    ] }) }),
    /* @__PURE__ */ v.jsx("div", { className: "px-10", children: a.length > 0 && /* @__PURE__ */ v.jsx(DAe, { files: a, className: "mt-1" }) })
  ] });
}, KAe = ({
  steps: e,
  defaultExpanded: t = !1
}) => {
  const [n, r] = C.useState(t), i = e.filter(
    (a) => a.type === "tool_call" || a.type === "complete" || a.type === "error" || a.type === "planning"
  );
  if (i.length === 0) return null;
  const o = i.filter((a) => a.type === "complete").length, s = i.filter((a) => a.type === "error").length;
  return /* @__PURE__ */ v.jsxs("div", { className: "mt-2 text-xs", children: [
    /* @__PURE__ */ v.jsxs(
      "button",
      {
        onClick: () => r(!n),
        className: "flex items-center gap-1.5 text-gray-500 dark:text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 transition-colors",
        children: [
          n ? /* @__PURE__ */ v.jsx(Mg, { className: "w-3.5 h-3.5" }) : /* @__PURE__ */ v.jsx(Ng, { className: "w-3.5 h-3.5" }),
          /* @__PURE__ */ v.jsxs("span", { className: "text-xs", children: [
            o > 0 && `${o} step${o > 1 ? "s" : ""}`,
            s > 0 && `  ${s} error${s > 1 ? "s" : ""}`
          ] })
        ]
      }
    ),
    /* @__PURE__ */ v.jsx(NA, { children: n && /* @__PURE__ */ v.jsx(
      qf.div,
      {
        initial: { opacity: 0, height: 0 },
        animate: { opacity: 1, height: "auto" },
        exit: { opacity: 0, height: 0 },
        transition: { duration: 0.2 },
        className: "mt-2 pl-5 space-y-1.5 overflow-hidden",
        children: i.map((a) => /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-2", children: [
          /* @__PURE__ */ v.jsx("div", { className: "mt-0.5 shrink-0", children: a.type === "complete" ? /* @__PURE__ */ v.jsx("div", { className: "w-3.5 h-3.5 rounded-full bg-green-500 flex items-center justify-center", children: /* @__PURE__ */ v.jsx(wc, { className: "w-2.5 h-2.5 text-white", strokeWidth: 3 }) }) : a.type === "error" ? /* @__PURE__ */ v.jsx("div", { className: "w-3.5 h-3.5 rounded-full bg-red-500 flex items-center justify-center", children: /* @__PURE__ */ v.jsx(Rg, { className: "w-2.5 h-2.5 text-white", strokeWidth: 3 }) }) : /* @__PURE__ */ v.jsx("div", { className: "w-3.5 h-3.5 rounded-full bg-blue-500" }) }),
          /* @__PURE__ */ v.jsxs("div", { className: "flex-1 min-w-0", children: [
            /* @__PURE__ */ v.jsx(
              "div",
              {
                className: at(
                  "text-xs",
                  a.type === "complete" && "text-gray-600 dark:text-gray-400",
                  a.type === "error" && "text-red-600 dark:text-red-400",
                  a.type !== "complete" && a.type !== "error" && "text-gray-700 dark:text-gray-300"
                ),
                children: a.message
              }
            ),
            a.details && /* @__PURE__ */ v.jsx("div", { className: "text-[10px] text-gray-400 dark:text-gray-600 mt-0.5 truncate", children: a.details })
          ] })
        ] }, a.id))
      }
    ) })
  ] });
}, ZAe = ({
  part: e,
  message: t,
  // showActions,
  // isLoading,
  showAvatar: n,
  regenerate: r,
  onReuseMessage: i
}) => {
  const o = La.getMessageSteps(t.id);
  return /* @__PURE__ */ v.jsx(v.Fragment, { children: /* @__PURE__ */ v.jsxs("div", { className: "group flex items-start gap-2", children: [
    n && /* @__PURE__ */ v.jsx("span", { className: "shrink-0 mt-1", children: /* @__PURE__ */ v.jsx(HT, { className: "h-5 w-5 text-blue-400" }) }),
    /* @__PURE__ */ v.jsxs("div", { className: "relative flex flex-col w-full", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ v.jsx("div", { className: "text-foreground text-sm max-w-[70vw] wrap-break-word", children: /* @__PURE__ */ v.jsx("div", { className: "prose prose-sm dark:prose-invert prose-p:my-0 prose-ul:my-1 prose-ol:my-1 prose-pre:my-1", children: /* @__PURE__ */ v.jsx(D7, { children: e.text }) }) }),
        /* @__PURE__ */ v.jsx(
          P7,
          {
            text: e.text ?? "",
            onReuseMessage: i,
            onRegenerate: r ? () => r({ messageId: t.id }) : void 0,
            className: "ml-2"
          }
        )
      ] }),
      o && o.length > 0 && /* @__PURE__ */ v.jsx(
        KAe,
        {
          steps: o,
          messageId: t.id,
          defaultExpanded: !1
        }
      )
    ] })
  ] }) });
}, YAe = C.memo(ZAe, (e, t) => !(e.isLoading !== t.isLoading || e.showActions !== t.showActions || e.part.text !== t.part.text));
function $7({
  data: e,
  className: t = "",
  defaultExpandAll: n = !0
}) {
  const { copied: r, copy: i } = uN(), [o, s] = C.useState(n), [a, c] = C.useState(!1);
  return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
    /* @__PURE__ */ v.jsxs("div", { className: `w-full flex flex-col ${t}`, children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex gap-2 ml-auto mb-2", children: [
        /* @__PURE__ */ v.jsx(
          Ht,
          {
            variant: "ghost",
            size: "icon",
            className: "size-3! p-4! cursor-pointer",
            onClick: () => s(!o),
            title: o ? "Collapse All" : "Expand All",
            children: o ? /* @__PURE__ */ v.jsx(kD, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(wD, { className: "h-4 w-4" })
          }
        ),
        /* @__PURE__ */ v.jsx(
          Ht,
          {
            variant: "ghost",
            size: "icon",
            className: "size-3! p-4! cursor-pointer",
            onClick: () => i(ch(e) ? e : JSON.stringify(e)),
            title: "Copy JSON",
            children: r ? /* @__PURE__ */ v.jsx(wc, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(Sc, { className: "h-4 w-4" })
          }
        ),
        /* @__PURE__ */ v.jsx(
          Ht,
          {
            variant: "ghost",
            size: "icon",
            className: "size-3! p-4! cursor-pointer",
            onClick: () => c(!0),
            title: "Open in Popup",
            children: /* @__PURE__ */ v.jsx(LZ, { className: "h-4 w-4" })
          }
        )
      ] }),
      /* @__PURE__ */ v.jsx(Ju, { data: e, expandAll: o })
    ] }),
    /* @__PURE__ */ v.jsx(Ph, { open: a, onOpenChange: c, children: /* @__PURE__ */ v.jsxs(jh, { className: "max-w-4xl max-h-[80vh] flex flex-col", children: [
      /* @__PURE__ */ v.jsx(Vg, { children: /* @__PURE__ */ v.jsxs(Ih, { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ v.jsx("span", { children: "JSON Data Viewer" }),
        /* @__PURE__ */ v.jsxs("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "ghost",
              size: "icon",
              className: "size-8! cursor-pointer",
              onClick: () => s(!o),
              title: o ? "Collapse All" : "Expand All",
              children: o ? /* @__PURE__ */ v.jsx(kD, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(wD, { className: "h-4 w-4" })
            }
          ),
          /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "ghost",
              size: "icon",
              className: "size-8! cursor-pointer",
              onClick: () => i(ch(e) ? e : JSON.stringify(e)),
              title: "Copy JSON",
              children: r ? /* @__PURE__ */ v.jsx(wc, { className: "h-4 w-4" }) : /* @__PURE__ */ v.jsx(Sc, { className: "h-4 w-4" })
            }
          )
        ] })
      ] }) }),
      /* @__PURE__ */ v.jsx("div", { className: "flex-1 overflow-auto p-4 bg-muted/20 rounded-md", children: /* @__PURE__ */ v.jsx(Ju, { data: e, expandAll: o }) })
    ] }) })
  ] });
}
function XAe({
  data: e,
  open: t,
  onOpenChange: n,
  children: r
}) {
  return /* @__PURE__ */ v.jsxs(Ph, { open: t, onOpenChange: n, children: [
    /* @__PURE__ */ v.jsx(x$, { asChild: !0, children: r || /* @__PURE__ */ v.jsx(
      Ht,
      {
        variant: "ghost",
        size: "sm",
        className: "text-muted-foreground text-xs",
        children: "JSON"
      }
    ) }),
    /* @__PURE__ */ v.jsxs(jh, { className: "max-w-[70vw] min-w-[40vw]", children: [
      /* @__PURE__ */ v.jsx(Vg, { children: /* @__PURE__ */ v.jsx(Ih, { className: "cursor-pointer", children: "JSON" }) }),
      /* @__PURE__ */ v.jsx("div", { className: "max-h-[70vh] w-full overflow-y-auto p-6 pt-0", children: /* @__PURE__ */ v.jsx($7, { data: e }) })
    ] })
  ] });
}
var Hw = "Checkbox", [JAe] = ps(Hw), [QAe, hN] = JAe(Hw);
function eMe(e) {
  const {
    __scopeCheckbox: t,
    checked: n,
    children: r,
    defaultChecked: i,
    disabled: o,
    form: s,
    name: a,
    onCheckedChange: c,
    required: u,
    value: f = "on",
    // @ts-expect-error
    internal_do_not_use_render: h
  } = e, [m, g] = Qa({
    prop: n,
    defaultProp: i ?? !1,
    onChange: c,
    caller: Hw
  }), [b, x] = C.useState(null), [w, S] = C.useState(null), _ = C.useRef(!1), M = b ? !!s || !!b.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    !0
  ), N = {
    checked: m,
    disabled: o,
    setChecked: g,
    control: b,
    setControl: x,
    name: a,
    form: s,
    value: f,
    hasConsumerStoppedPropagationRef: _,
    required: u,
    defaultChecked: mc(i) ? !1 : i,
    isFormControl: M,
    bubbleInput: w,
    setBubbleInput: S
  };
  return /* @__PURE__ */ v.jsx(
    QAe,
    {
      scope: t,
      ...N,
      children: tMe(h) ? h(N) : r
    }
  );
}
var U7 = "CheckboxTrigger", F7 = C.forwardRef(
  ({ __scopeCheckbox: e, onKeyDown: t, onClick: n, ...r }, i) => {
    const {
      control: o,
      value: s,
      disabled: a,
      checked: c,
      required: u,
      setControl: f,
      setChecked: h,
      hasConsumerStoppedPropagationRef: m,
      isFormControl: g,
      bubbleInput: b
    } = hN(U7, e), x = Ft(i, f), w = C.useRef(c);
    return C.useEffect(() => {
      const S = o?.form;
      if (S) {
        const _ = () => h(w.current);
        return S.addEventListener("reset", _), () => S.removeEventListener("reset", _);
      }
    }, [o, h]), /* @__PURE__ */ v.jsx(
      Et.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": mc(c) ? "mixed" : c,
        "aria-required": u,
        "data-state": K7(c),
        "data-disabled": a ? "" : void 0,
        disabled: a,
        value: s,
        ...r,
        ref: x,
        onKeyDown: Ye(t, (S) => {
          S.key === "Enter" && S.preventDefault();
        }),
        onClick: Ye(n, (S) => {
          h((_) => mc(_) ? !0 : !_), b && g && (m.current = S.isPropagationStopped(), m.current || S.stopPropagation());
        })
      }
    );
  }
);
F7.displayName = U7;
var V7 = C.forwardRef(
  (e, t) => {
    const {
      __scopeCheckbox: n,
      name: r,
      checked: i,
      defaultChecked: o,
      required: s,
      disabled: a,
      value: c,
      onCheckedChange: u,
      form: f,
      ...h
    } = e;
    return /* @__PURE__ */ v.jsx(
      eMe,
      {
        __scopeCheckbox: n,
        checked: i,
        defaultChecked: o,
        disabled: a,
        required: s,
        onCheckedChange: u,
        name: r,
        form: f,
        value: c,
        internal_do_not_use_render: ({ isFormControl: m }) => /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
          /* @__PURE__ */ v.jsx(
            F7,
            {
              ...h,
              ref: t,
              __scopeCheckbox: n
            }
          ),
          m && /* @__PURE__ */ v.jsx(
            G7,
            {
              __scopeCheckbox: n
            }
          )
        ] })
      }
    );
  }
);
V7.displayName = Hw;
var H7 = "CheckboxIndicator", W7 = C.forwardRef(
  (e, t) => {
    const { __scopeCheckbox: n, forceMount: r, ...i } = e, o = hN(H7, n);
    return /* @__PURE__ */ v.jsx(
      Di,
      {
        present: r || mc(o.checked) || o.checked === !0,
        children: /* @__PURE__ */ v.jsx(
          Et.span,
          {
            "data-state": K7(o.checked),
            "data-disabled": o.disabled ? "" : void 0,
            ...i,
            ref: t,
            style: { pointerEvents: "none", ...e.style }
          }
        )
      }
    );
  }
);
W7.displayName = H7;
var q7 = "CheckboxBubbleInput", G7 = C.forwardRef(
  ({ __scopeCheckbox: e, ...t }, n) => {
    const {
      control: r,
      hasConsumerStoppedPropagationRef: i,
      checked: o,
      defaultChecked: s,
      required: a,
      disabled: c,
      name: u,
      value: f,
      form: h,
      bubbleInput: m,
      setBubbleInput: g
    } = hN(q7, e), b = Ft(n, g), x = nM(o), w = UA(r);
    C.useEffect(() => {
      const _ = m;
      if (!_) return;
      const M = window.HTMLInputElement.prototype, P = Object.getOwnPropertyDescriptor(
        M,
        "checked"
      ).set, I = !i.current;
      if (x !== o && P) {
        const O = new Event("click", { bubbles: I });
        _.indeterminate = mc(o), P.call(_, mc(o) ? !1 : o), _.dispatchEvent(O);
      }
    }, [m, x, o, i]);
    const S = C.useRef(mc(o) ? !1 : o);
    return /* @__PURE__ */ v.jsx(
      Et.input,
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: s ?? S.current,
        required: a,
        disabled: c,
        name: u,
        value: f,
        form: h,
        ...t,
        tabIndex: -1,
        ref: b,
        style: {
          ...t.style,
          ...w,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
G7.displayName = q7;
function tMe(e) {
  return typeof e == "function";
}
function mc(e) {
  return e === "indeterminate";
}
function K7(e) {
  return mc(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function Z7({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    V7,
    {
      "data-slot": "checkbox",
      className: at(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        e
      ),
      ...t,
      children: /* @__PURE__ */ v.jsx(
        W7,
        {
          "data-slot": "checkbox-indicator",
          className: "flex items-center justify-center text-current transition-none",
          children: /* @__PURE__ */ v.jsx(wc, { className: "size-3.5" })
        }
      )
    }
  );
}
const nMe = async () => {
  if (typeof window > "u")
    throw new Error("XLSX can only be loaded in browser environment");
  return window.XLSX ? window.XLSX : new Promise((e, t) => {
    const n = document.createElement("script");
    n.src = "https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js", n.onload = () => {
      window.XLSX ? e(window.XLSX) : t(new Error("Failed to load XLSX library"));
    }, n.onerror = () => t(new Error("Failed to load XLSX script")), document.head.appendChild(n);
  });
};
function rMe(e) {
  const { title: t, data: n, columns: r, description: i } = e, o = 20, s = !0, [a, c] = C.useState(""), [u, f] = C.useState(null), [h, m] = C.useState(null), [g, b] = C.useState(1), [x, w] = C.useState(
    new Set(r.map((B) => B.key))
  ), S = (B, G = "string") => {
    if (B == null) return "";
    switch (G) {
      case "number":
        return typeof B == "number" ? B.toLocaleString() : B;
      case "boolean":
        return B ? "Yes" : "No";
      case "date":
        try {
          return new Date(B).toLocaleDateString();
        } catch {
          return B;
        }
      default:
        return String(B);
    }
  }, _ = (B, G) => {
    if (!G || !B) return B;
    const Y = new RegExp(`(${G})`, "gi");
    return String(B).split(Y).map(
      (ie, ne) => Y.test(ie) ? /* @__PURE__ */ v.jsx("mark", { className: "bg-yellow-200 dark:bg-yellow-800", children: ie }, ne) : ie
    );
  }, M = C.useMemo(() => {
    let B = [...n];
    return a && s && (B = B.filter(
      (G) => Object.values(G).some(
        (Y) => String(Y).toLowerCase().includes(a.toLowerCase())
      )
    )), u && h && B.sort((G, Y) => {
      const he = G[u], ie = Y[u], H = r.find((X) => X.key === u)?.type || "string";
      let Q = 0;
      switch (H) {
        case "number":
          Q = Number(he || 0) - Number(ie || 0);
          break;
        case "date":
          Q = new Date(he || 0).getTime() - new Date(ie || 0).getTime();
          break;
        case "boolean":
          Q = (he ? 1 : 0) - (ie ? 1 : 0);
          break;
        default:
          Q = String(he || "").localeCompare(
            String(ie || "")
          );
      }
      return h === "asc" ? Q : -Q;
    }), B;
  }, [n, a, u, h]), N = Math.ceil(M.length / o), P = M.slice(
    (g - 1) * o,
    g * o
  ), I = (B) => {
    u === B ? (m(
      h === "asc" ? "desc" : h === "desc" ? null : "asc"
    ), h === "desc" && f(null)) : (f(B), m("asc"));
  }, O = () => {
    const B = r.filter((ne) => x.has(ne.key)), G = [
      // Header
      B.map((ne) => ne.label).join(","),
      // Data rows
      ...M.map(
        (ne) => B.map((H) => `"${S(ne[H.key], H.type)}"`).join(",")
      )
    ].join(`
`), Y = new Blob([G], { type: "text/csv" }), he = URL.createObjectURL(Y), ie = document.createElement("a");
    ie.href = he, ie.download = `${t.replace(/\s+/g, "_")}.csv`, ie.click(), URL.revokeObjectURL(he);
  }, L = async () => {
    try {
      const B = await nMe(), G = r.filter((H) => x.has(H.key)), Y = [
        // Header row
        G.map((H) => H.label),
        // Data rows
        ...M.map(
          (H) => G.map((Q) => {
            const X = H[Q.key];
            switch (Q.type) {
              case "number":
                return typeof X == "number" ? X : Number(X) || X;
              case "date":
                return X instanceof Date ? X : new Date(X);
              case "boolean":
                return X;
              default:
                return X;
            }
          })
        )
      ], he = B.utils.book_new(), ie = B.utils.aoa_to_sheet(Y), ne = G.map((H) => {
        const Q = Math.max(
          H.label.length,
          ...M.map(
            (X) => String(S(X[H.key], H.type) || "").length
          )
        );
        return { wch: Math.min(Math.max(Q + 2, 10), 50) };
      });
      ie["!cols"] = ne, B.utils.book_append_sheet(he, ie, "Data"), B.writeFile(he, `${t.replace(/\s+/g, "_")}.xlsx`);
    } catch (B) {
      console.error("Failed to export Excel:", B), O();
    }
  }, U = r.filter(
    (B) => x.has(B.key)
  );
  return /* @__PURE__ */ v.jsx("div", { className: "px-6", children: /* @__PURE__ */ v.jsxs(f9, { className: "w-full px-0", children: [
    /* @__PURE__ */ v.jsxs(h9, { children: [
      /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col", children: [
        /* @__PURE__ */ v.jsxs(qle, { className: "w-full flex items-center gap-2 justify-between", children: [
          "Interactive Table - ",
          t,
          /* @__PURE__ */ v.jsx(XAe, { data: e })
        ] }),
        i && /* @__PURE__ */ v.jsx(Gle, { className: "mt-2 ", children: i })
      ] }),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 mt-4", children: [
        /* @__PURE__ */ v.jsx("div", { className: "flex-1", children: /* @__PURE__ */ v.jsx(
          sM,
          {
            placeholder: "Search across all columns...",
            value: a,
            onChange: (B) => {
              c(B.target.value), b(1);
            },
            className: "hover:bg-input bg-secondary/40 transition-colors border-transparent border-none! focus-visible:bg-input! ring-0!"
          }
        ) }),
        /* @__PURE__ */ v.jsxs(Qu, { children: [
          /* @__PURE__ */ v.jsx(ed, { asChild: !0, children: /* @__PURE__ */ v.jsxs(Ht, { variant: "ghost", className: "data-[state=open]:bg-accent", children: [
            /* @__PURE__ */ v.jsx(WT, { className: "size-3.5" }),
            "Columns"
          ] }) }),
          /* @__PURE__ */ v.jsx(td, { children: r.map((B) => /* @__PURE__ */ v.jsx(
            pfe,
            {
              checked: x.has(B.key),
              onClick: (G) => {
                G.stopPropagation(), G.preventDefault();
                const Y = new Set(x);
                !Y.has(B.key) ? Y.add(B.key) : Y.delete(B.key), w(Y);
              },
              children: B.label
            },
            B.key
          )) })
        ] }),
        /* @__PURE__ */ v.jsxs(Qu, { children: [
          /* @__PURE__ */ v.jsx(ed, { asChild: !0, children: /* @__PURE__ */ v.jsxs(
            Ht,
            {
              variant: "ghost",
              className: "data-[state=open]:bg-accent",
              children: [
                /* @__PURE__ */ v.jsx(ME, { className: "size-3.5" }),
                "Export"
              ]
            }
          ) }),
          /* @__PURE__ */ v.jsxs(td, { children: [
            /* @__PURE__ */ v.jsxs(ls, { onClick: O, children: [
              /* @__PURE__ */ v.jsx(ME, { className: "h-4 w-4 mr-2" }),
              "CSV"
            ] }),
            /* @__PURE__ */ v.jsxs(ls, { onClick: L, children: [
              /* @__PURE__ */ v.jsx(VZ, { className: "h-4 w-4 mr-2" }),
              "Excel"
            ] })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ v.jsxs(p9, { className: "px-0 relative", children: [
      /* @__PURE__ */ v.jsxs(A7, { children: [
        /* @__PURE__ */ v.jsx(M7, { className: "bg-secondary border-t", children: /* @__PURE__ */ v.jsx(F0, { children: U.map((B, G) => /* @__PURE__ */ v.jsx(
          R7,
          {
            className: `relative select-none ${G === 0 ? "pl-6" : G === U.length - 1 ? "pr-6" : ""} ${B.type === "number" || B.type === "date" || B.type === "boolean" ? "text-center" : ""}`,
            children: /* @__PURE__ */ v.jsxs(
              "div",
              {
                className: `flex items-center gap-2 cursor-pointer ${B.type === "number" || B.type === "date" ? "justify-center" : ""}`,
                onClick: () => I(B.key),
                children: [
                  /* @__PURE__ */ v.jsx("span", { className: "hover:text-primary", children: B.label }),
                  /* @__PURE__ */ v.jsx(
                    lZ,
                    {
                      className: `h-3 w-3 ${u === B.key ? "" : "text-muted-foreground/30"}`
                    }
                  )
                ]
              }
            )
          },
          B.key
        )) }) }),
        /* @__PURE__ */ v.jsx(N7, { className: "min-h-[24rem]", children: P.length === 0 ? /* @__PURE__ */ v.jsx(F0, { children: /* @__PURE__ */ v.jsx(
          oT,
          {
            colSpan: U.length,
            className: "text-center h-48",
            children: "No data found"
          }
        ) }) : P.map((B, G) => /* @__PURE__ */ v.jsx(F0, { className: "border-b!", children: U.map((Y, he) => /* @__PURE__ */ v.jsx(
          oT,
          {
            className: `py-3 ${he === 0 ? "pl-6" : he === U.length - 1 ? "pr-6" : ""} ${Y.type === "number" || Y.type === "date" ? "text-center" : Y.type == "boolean" ? "flex items-center justify-center" : ""}`,
            children: Y.type == "boolean" ? /* @__PURE__ */ v.jsx(v.Fragment, { children: /* @__PURE__ */ v.jsx(Z7, { checked: B[Y.key] }) }) : a && s ? _(
              S(B[Y.key], Y.type),
              a
            ) : S(B[Y.key], Y.type)
          },
          Y.key
        )) }, G)) })
      ] }),
      /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between pt-4 px-6", children: [
        /* @__PURE__ */ v.jsxs("div", { className: "text-xs text-muted-foreground", children: [
          "Total rows: ",
          n.length
        ] }),
        N > 1 && /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ v.jsxs(
            Ht,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => b((B) => Math.max(1, B - 1)),
              disabled: g === 1,
              children: [
                /* @__PURE__ */ v.jsx(kZ, { className: "h-4 w-4" }),
                "Previous"
              ]
            }
          ),
          /* @__PURE__ */ v.jsxs("span", { className: "text-sm px-2", children: [
            "Page ",
            g,
            " of ",
            N
          ] }),
          /* @__PURE__ */ v.jsxs(
            Ht,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => b((B) => Math.min(N, B + 1)),
              disabled: g === N,
              children: [
                "Next",
                /* @__PURE__ */ v.jsx(Ng, { className: "h-4 w-4" })
              ]
            }
          )
        ] })
      ] })
    ] })
  ] }) });
}
function uL(e, t) {
  const n = (o) => o && (o.data || o.columns || o.rows || o.points || o.content || o.results), r = t?.content;
  if (n(r)) return r;
  if (n(t)) return t;
  const i = e?.content;
  return n(i) ? i : e ?? {};
}
function Y7(e, t) {
  const {
    chatbotStore: { isStopStream: n }
  } = ra(), r = n.value;
  return C.useMemo(() => e === "output-error" ? {
    label: "Tool error",
    icon: /* @__PURE__ */ v.jsx(UZ, { className: "h-4 w-4 text-yellow-700" }),
    detail: t ?? "An error occurred while calling the tool."
  } : e.startsWith("output") ? {
    label: "Called tool",
    icon: /* @__PURE__ */ v.jsx(AZ, { className: "h-4 w-4 text-emerald-400" })
  } : e === "input-available" ? {
    label: "Calling tool",
    icon: /* @__PURE__ */ v.jsx(Zs, { className: "h-4 w-4 animate-spin text-muted-foreground" })
  } : r && e === "input-streaming" ? {
    label: "Tool call stopped",
    icon: /* @__PURE__ */ v.jsx(NZ, { className: "h-4 w-4 text-red-700" }),
    detail: "The tool call was stopped by the user."
  } : {
    label: "Connecting to app",
    icon: /* @__PURE__ */ v.jsx(Zs, { className: "h-4 w-4 animate-spin text-muted-foreground" })
  }, [e, t, r]);
}
const iMe = ({ toolName: e, state: t }) => {
  const n = Y7(t), [r, i] = C.useState(!0);
  return /* @__PURE__ */ v.jsxs("div", { className: "", children: [
    /* @__PURE__ */ v.jsxs(
      Ht,
      {
        type: "button",
        variant: "ghost",
        size: "sm",
        onClick: () => i((o) => !o),
        className: "flex items-center gap-2 cursor-pointer px-3 py-2",
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-sm", children: [
            n.icon,
            /* @__PURE__ */ v.jsx("span", { className: "text-sm text-muted-foreground", children: n.label })
          ] }),
          /* @__PURE__ */ v.jsx(
            Mg,
            {
              className: `h-4 w-4 text-muted-foreground transition ${r ? "rotate-180" : ""}`
            }
          )
        ]
      }
    ),
    r && /* @__PURE__ */ v.jsxs(
      "div",
      {
        title: "AI Tool - Automated Data Processing",
        className: "flex items-center gap-2 border border-accent-background p-2",
        children: [
          /* @__PURE__ */ v.jsx("span", { className: "relative flex items-center", children: /* @__PURE__ */ v.jsx(HY, { className: "w-5 h-5 opacity-90" }) }),
          /* @__PURE__ */ v.jsx("div", { className: " py-0.5 rounded bg-muted text-foreground", children: e }),
          /* @__PURE__ */ v.jsx(OU, { className: "h-4 w-px bg-border" }),
          /* @__PURE__ */ v.jsx("div", { className: "text-muted-foreground", children: t })
        ]
      }
    )
  ] });
}, dL = C.memo(iMe), nr = {
  // General tools
  MODAL: "modal",
  CONTROL_BY_NAME: "controlbyname",
  PARSE_COORDINATES_SEARCH: "parsecoordinatesfromsearch",
  PARSE_COORDINATES: "parsecoordinates",
  PYTHON_EXECUTION: "python-execution",
  JAVASCRIPT_EXECUTION: "javascript-execution",
  CREATE_MODEL: "createmodel",
  HIDDEN: "hidden",
  PREPARE_ENTITY_UPDATE: "prepareentityupdate",
  // 24KTwin-Editor-MCP-Remote tools
  ENTITY_CONNECTION: "connect_entities",
  OPEN_CREATE_MANY_RELATIONSHIPS_UI: "open_create_many_relationships_ui",
  MOVE_ENTITIES: "move_entities",
  DELETE_ENTITIES: "delete_entities",
  CREATE_ENTITIES: "create_entities",
  ABC_TOOL: "abc",
  // Example: New ABC tool
  FALLBACK: "fallback"
};
function oMe(e) {
  const t = e.match(/^_([^_]+?)(?:-(?:\d+|latest))?_(.+)$/);
  return t ? {
    serverName: t[1],
    toolName: t[2]
  } : null;
}
const sMe = {
  [nr.MODAL]: /^(tool-?open-?modal|openModal|tool_open_modal|open-modal)$/i,
  [nr.CONTROL_BY_NAME]: /^contro(lbyname|lbyName|lbyNames|Names)$/i,
  [nr.PARSE_COORDINATES_SEARCH]: /^parsecoordinatesfromsearch$/i,
  [nr.PARSE_COORDINATES]: /^parsecoordinates$/i,
  [nr.PYTHON_EXECUTION]: /^python-execution$/i,
  [nr.JAVASCRIPT_EXECUTION]: /^javascript-execution$/i,
  [nr.CREATE_MODEL]: /^(createmodel|create-?model|createModel)$/i,
  [nr.PREPARE_ENTITY_UPDATE]: /^\s*(?:tool-)?prepareentityupdate/i
}, fL = {
  // 24KTwin-Editor-MCP-Remote tools
  "24KTwin-Editor-MCP-Remote.abc": nr.ABC_TOOL,
  //  New ABC tool added here 
  "24KTwin-Editor-MCP-Remote.connect_entities": nr.ENTITY_CONNECTION,
  "24KTwin-Editor-MCP-Remote.open_create_many_relationships_ui": nr.OPEN_CREATE_MANY_RELATIONSHIPS_UI,
  "24KTwin-Editor-MCP-Remote.move_entities": nr.MOVE_ENTITIES,
  "24KTwin-Editor-MCP-Remote.delete_entities": nr.DELETE_ENTITIES,
  "24KTwin-Editor-MCP-Remote.create_entities": nr.CREATE_ENTITIES
  // Add other MCP servers here
  // 'OtherServer.same_tool_name': TOOL_CATEGORIES.OTHER_CATEGORY,
}, hL = {
  connect_entities: nr.ENTITY_CONNECTION,
  open_create_many_relationships_ui: nr.OPEN_CREATE_MANY_RELATIONSHIPS_UI,
  move_entities: nr.MOVE_ENTITIES,
  delete_entities: nr.DELETE_ENTITIES,
  create_entities: nr.CREATE_ENTITIES
}, aMe = ["webSearch", "web-search", "search", "websearch"], yf = /* @__PURE__ */ new Map();
function lMe(e) {
  const t = yf.get(e);
  if (t) return t;
  let n;
  if (aMe.includes(e))
    return n = nr.HIDDEN, yf.set(e, n), n;
  const r = oMe(e);
  if (r) {
    const i = `${r.serverName}.${r.toolName}`;
    if (fL[i])
      return n = fL[i], yf.set(e, n), n;
    if (hL[r.toolName])
      return n = hL[r.toolName], yf.set(e, n), n;
  }
  for (const [i, o] of Object.entries(sMe))
    if (o.test(e))
      return n = i, yf.set(e, n), n;
  return n = nr.FALLBACK, yf.set(e, n), n;
}
const cMe = ({
  toolName: e,
  state: t,
  parts: n,
  errorText: r
}) => {
  const [i, o] = C.useState(!1), s = Y7(t, r), a = C.useMemo(() => {
    if (n == null) return "No payload available.";
    try {
      return JSON.stringify(n, null, 2);
    } catch {
      return String(n);
    }
  }, [n]), c = C.useMemo(() => {
    if (!n && !n.input) return null;
    try {
      return JSON.stringify(n.input, null, 2);
    } catch {
      return String(n);
    }
  }, [n]), u = C.useMemo(() => {
    if (!n) return null;
    try {
      return JSON.stringify(n, null, 2);
    } catch {
      return String(n);
    }
  }, [n]), { copy: f, copied: h } = uN(), m = !c && !u, g = (b, x) => /* @__PURE__ */ v.jsxs("div", { className: "rounded-xl border border-border bg-card/20 p-3 text-xs text-foreground", children: [
    /* @__PURE__ */ v.jsx("div", { className: "flex items-center justify-between gap-2 text-[10px] uppercase tracking-[0.3em] text-muted-foreground", children: /* @__PURE__ */ v.jsx("span", { children: b }) }),
    /* @__PURE__ */ v.jsx("div", { className: "mt-2 max-h-full w-full overflow-auto whitespace-pre-wrap wrap-break-word text-sm text-foreground", children: /* @__PURE__ */ v.jsx($7, { data: x }) })
  ] });
  return /* @__PURE__ */ v.jsxs("div", { className: "space-y-2 text-xs py-2", children: [
    /* @__PURE__ */ v.jsxs(
      Ht,
      {
        type: "button",
        variant: "ghost",
        size: "sm",
        onClick: () => o((b) => !b),
        className: "flex items-center gap-2 cursor-pointer px-3 py-2",
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-sm text-muted-foreground", children: [
            s.icon,
            /* @__PURE__ */ v.jsx("span", { className: "text-sm", children: s.label })
          ] }),
          /* @__PURE__ */ v.jsx(
            Mg,
            {
              className: `h-4 w-4 text-muted-foreground transition ${i ? "rotate-180" : ""}`
            }
          )
        ]
      }
    ),
    i && /* @__PURE__ */ v.jsxs("div", { className: "space-y-4 rounded-md border border-border p-4 dark:bg-zinc-950 shadow-lg shadow-black/40", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3 text-xs font-semibold text-muted-foreground", children: [
          /* @__PURE__ */ v.jsx("div", { className: "flex h-10 w-10 items-center justify-center rounded-2xl bg-muted text-sm font-semibold uppercase text-foreground", children: e?.[0] ?? "T" }),
          /* @__PURE__ */ v.jsxs("div", { children: [
            /* @__PURE__ */ v.jsx("p", { className: "text-sm font-semibold text-foreground", children: e }),
            /* @__PURE__ */ v.jsx("p", { className: "text-[11px] text-muted-foreground", children: t })
          ] })
        ] }),
        /* @__PURE__ */ v.jsx("p", { className: "text-[11px] text-muted-foreground", children: s.detail ?? "The agent is currently handling a tool request; expand to view the payload." })
      ] }),
      m ? /* @__PURE__ */ v.jsxs("div", { className: "rounded-md border border-border bg-card/20 p-3 text-xs text-foreground", children: [
        /* @__PURE__ */ v.jsxs("div", { className: "flex items-center justify-between gap-2 text-[10px] uppercase tracking-[0.3em] text-muted-foreground", children: [
          /* @__PURE__ */ v.jsx("span", { children: "Tool payload (raw)" }),
          /* @__PURE__ */ v.jsxs(
            "button",
            {
              type: "button",
              onClick: () => f(a),
              className: "flex items-center gap-1 rounded-full border border-border px-3 py-1 text-[10px] font-semibold text-muted-foreground transition hover:border-foreground hover:text-foreground",
              children: [
                /* @__PURE__ */ v.jsx(Sc, { className: "h-3 w-3" }),
                h ? "Copied" : "Copy"
              ]
            }
          )
        ] }),
        /* @__PURE__ */ v.jsx("div", { className: "mt-2 max-h-52 overflow-auto whitespace-pre-wrap break-words text-[12px] text-foreground", children: a })
      ] }) : /* @__PURE__ */ v.jsxs("div", { className: `grid gap-3 ${c && u ? "sm:grid-cols-2" : ""}`, children: [
        c && g("Request", c),
        u && g("Response", u)
      ] })
    ] })
  ] });
}, uMe = C.memo(cMe), dMe = C.lazy(
  () => import("./pie-chart-BA-SDLP4.js").then((e) => ({ default: e.PieChart }))
), fMe = C.lazy(
  () => import("./bar-chart-BVbl4Emr.js").then((e) => ({ default: e.BarChart }))
), hMe = C.lazy(
  () => import("./line-chart-BG-HkGSG.js").then((e) => ({ default: e.LineChart }))
), pMe = ({
  part: e,
  addToolResult: t
}) => {
  const { input: n, output: r, state: i, errorText: o, toolCallId: s } = e, a = C.useMemo(() => cg(e), [e.type]), c = i.startsWith("output");
  C.useCallback(
    (m) => {
      t?.({
        tool: a,
        toolCallId: s,
        output: m
      }), console.log("Result", m);
    },
    [t, s, a]
  );
  const u = C.useMemo(() => {
    if (!(a === "createTable" || a === "CreateTable" || /table$/i.test(a))) return null;
    const g = uL(n, r), b = Array.isArray(g?.columns) ? g.columns : [], x = Array.isArray(g?.data) ? g.data : [], w = g?.title ?? "Table", S = g?.description;
    return !b.length || !x.length ? null : /* @__PURE__ */ v.jsx(
      rMe,
      {
        title: w,
        columns: b,
        data: x,
        description: S
      }
    );
  }, [a, n, r, c]), f = C.useMemo(() => {
    const m = /^(create)?bar(chart)?$/i.test(a), g = /^(create)?line(chart)?$/i.test(a), b = /^(create)?pie(chart)?$/i.test(a);
    if (!m && !g && !b) return null;
    const x = uL(n, r), w = x?.data ?? x?.rows ?? x?.points ?? [];
    if (!Array.isArray(w) || w.length === 0) return null;
    const S = x?.title ?? (m ? "Bar Chart" : g ? "Line Chart" : "Pie Chart"), _ = x?.description ?? void 0, M = x?.yAxisLabel ?? void 0;
    if (b) {
      const P = w.map((I) => ({
        label: I.label ?? I.xAxisLabel ?? "",
        value: I.value ?? 0
      }));
      return /* @__PURE__ */ v.jsx(dMe, { title: S, data: P, description: _ });
    }
    const N = "series" in w[0] ? w : w.map((P) => ({
      xAxisLabel: P.xAxisLabel,
      series: [{ seriesName: "Value", value: P.value }]
    }));
    return m ? /* @__PURE__ */ v.jsx(
      fMe,
      {
        title: S,
        data: N,
        description: _,
        yAxisLabel: M
      }
    ) : /* @__PURE__ */ v.jsx(
      hMe,
      {
        title: S,
        data: N,
        description: _,
        yAxisLabel: M
      }
    );
  }, [a, n, r, i]);
  switch (u ? "table" : f ? "chart" : lMe(a)) {
    case "table":
      return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 text-xs", children: [
        /* @__PURE__ */ v.jsx(dL, { toolName: a, state: i }),
        u
      ] });
    case "chart":
      return /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2 text-xs", children: [
        /* @__PURE__ */ v.jsx(dL, { toolName: a, state: i }),
        /* @__PURE__ */ v.jsx("div", { className: "rounded border bg-card p-3", children: /* @__PURE__ */ v.jsx(
          C.Suspense,
          {
            fallback: /* @__PURE__ */ v.jsx("div", { className: "h-44 w-full rounded-md opacity-50" }),
            children: f
          }
        ) })
      ] });
    // case TOOL_CATEGORIES.MODAL:
    //   return (
    //     <ModalOutput
    //       input={input}
    //       output={output}
    //       state={state}
    //       toolName={toolName}
    //     />
    //   );
    // case TOOL_CATEGORIES.CONTROL_BY_NAME:
    //   const controlData = getPayload(input, output);
    //   const items = Array.isArray(controlData && controlData.data && controlData.data.items)
    //   ? controlData.data.items
    //   : Array.isArray(controlData)
    //   ? controlData
    //   : [];
    //   return (
    //     items.length > 0 && (
    //       <div className="flex flex-col gap-2 text-xs">
    //         <RenderToolHeader toolName={toolName} state={state} />
    //         <div className="rounded border bg-card p-4">
    //           <ControlByNameHandler
    //             controlData={controlData}
    //             items={items}
    //           />
    //         </div>
    //       </div>
    //     )
    //   );
    // case TOOL_CATEGORIES.PARSE_COORDINATES_SEARCH:
    // case TOOL_CATEGORIES.PARSE_COORDINATES:
    //   return <GISModelCreator2
    //     input={input}
    //     output={output}
    //     toolName={toolName}
    //     state={state}
    //     isCompleted={isCompleted}
    //   />
    // case TOOL_CATEGORIES.JAVASCRIPT_EXECUTION:
    //   console.log("Rendering JavascriptExecution for toolName:", toolName);
    //   return (
    //     <CodeExecutor
    //       part={part}
    //       key={part.toolCallId}
    //       onResult={onToolCallDirect}
    //       type="javascript"
    //     />
    //   );
    // case TOOL_CATEGORIES.PYTHON_EXECUTION:
    //   console.log("Rendering PythonExecution for toolName:", toolName);
    //   return (
    //     <CodeExecutor
    //       part={part}
    //       key={part.toolCallId}
    //       onResult={onToolCallDirect}
    //       type="python"
    //     />
    //   );
    // case TOOL_CATEGORIES.CREATE_MODEL:  
    //   if (!isCompleted) return null;
    //   return <BrickModelCreators
    //     output={output}
    //     toolName={toolName}
    //     state={state}
    //     isCompleted={isCompleted}
    //   />;
    // case TOOL_CATEGORIES.ENTITY_CONNECTION: {
    //   const relationshipData = getPayload(input, output);
    //   if (!isCompleted) return null;
    //   if (!relationshipData || relationshipData.isError) return null;
    //   const connections = relationshipData.content[0].text.connections;
    //   return (
    //     <div className="flex flex-col gap-2 text-xs">
    //       <RenderToolHeader toolName={toolName} state={state} />
    //       <SetRelationshipOutput data={connections} />
    //     </div>
    //   );
    // }
    // case TOOL_CATEGORIES.OPEN_CREATE_MANY_RELATIONSHIPS_UI:
    //   const data = getPayload(input, output);
    //   if (!isCompleted) return null;
    //   if (!data) return null;
    //   const content = data.content[0].text;
    //   return (
    //     null
    //     // <ItemModals values={content} />
    //   );
    // case TOOL_CATEGORIES.PREPARE_ENTITY_UPDATE:
    //   const updateData = getPayload(input, output);
    //   if (!isCompleted) return null;
    //   if (!updateData) return null;
    //   return (
    //     <>
    //       <ToolMessageFallback  
    //       parts={part}
    //       toolName={toolName}
    //       state={state}
    //       errorText={errorText}
    //       />
    //       <EntityEditors data={output}  />
    //     </>
    //   );
    //   case TOOL_CATEGORIES.MOVE_ENTITIES:
    //     const moveData = getPayload(input, output);
    //     console.log(output);
    //     if (!isCompleted) return null;
    //     if (!moveData) return null;
    //     return (
    //       <>
    //         <ToolMessageFallback  
    //       parts={part}
    //       toolName={toolName}
    //       state={state}
    //       errorText={errorText}
    //       />
    //         <MoveEntitiesOutput data={output} />
    //       </>
    //     );
    //   case TOOL_CATEGORIES.DELETE_ENTITIES:
    //     const deleteData = getPayload(input, output);
    //     if (!isCompleted) return null;
    //     if (!deleteData) return null;
    //     return (
    //       <>
    //         <ToolMessageFallback  
    //       parts={part}
    //       toolName={toolName}
    //       state={state}
    //       errorText={errorText}
    //       />
    //         <DeleteEntitiesOutput data={output} />
    //       </>
    //     );
    //   case TOOL_CATEGORIES.CREATE_ENTITIES:
    //     const createData = getPayload(input, output);
    //     if (!isCompleted) return null;
    //     if (!createData) return null;
    //     return (
    //       <>
    //         <ToolMessageFallback  
    //       parts={part}
    //       toolName={toolName}
    //       state={state}
    //       errorText={errorText}
    //       />
    //         <CreateEntitiesOutput data={output} />
    //       </>
    //     );
    // case TOOL_CATEGORIES.HIDDEN:
    //   // Hide tools that should not be shown to end users
    //   return null;
    case nr.FALLBACK:
    default:
      return /* @__PURE__ */ v.jsx(
        uMe,
        {
          parts: e,
          toolName: a,
          state: i,
          errorText: o
        }
      );
  }
}, mMe = C.memo(pMe), gMe = ({
  message: e,
  prevMessage: t,
  threadId: n,
  isLoading: r,
  isLastMessage: i,
  status: o,
  className: s,
  setMessages: a,
  regenerate: c,
  addToolResult: u,
  messageIndex: f,
  sendMessage: h,
  onReuseMessage: m
}) => {
  const g = C.useMemo(() => e.role === "user", [e.role]);
  if (e.role === "system" || !e.parts.length) return null;
  let b = !1;
  return /* @__PURE__ */ v.jsx("div", { className: "w-full mx-auto max-w-3xl px-4 ", "data-role": e.role, children: /* @__PURE__ */ v.jsx("div", { className: s, children: /* @__PURE__ */ v.jsx("div", { className: "flex flex-col w-full", children: e.parts.map((x, w) => {
    const S = `message-${f}-part-${x.type}-${w}`, _ = w === e.parts.length - 1, N = e.role === "assistant" && x.type === "text" && !b;
    if (N && (b = !0), x.type === "reasoning")
      return /* @__PURE__ */ v.jsx(
        NAe,
        {
          reasoningText: x.text,
          isThinking: _ && i && r
        },
        S
      );
    if (g && x.type === "text" && x.text)
      return t ? /* @__PURE__ */ v.jsxs(C.Fragment, { children: [
        f !== 0 && /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-muted-foreground px-2", children: [
          /* @__PURE__ */ v.jsx(V3, { className: "w-4 h-4 opacity-50", "aria-hidden": !0 }),
          /* @__PURE__ */ v.jsx("div", { className: "flex-1 h-px border-t border-dashed border-muted-foreground/40" })
        ] }),
        /* @__PURE__ */ v.jsx(
          GAe,
          {
            status: o,
            part: x,
            isLast: _,
            message: e,
            setMessages: a,
            sendMessage: h,
            onReuseMessage: m
          },
          S
        )
      ] }, S) : null;
    if (Uu(x)) {
      const P = e.metadata?.toolChoice === "manual" && i && _ && x.state === "input-available" && r;
      return /* @__PURE__ */ v.jsx(
        mMe,
        {
          part: x,
          messageId: e.id,
          isLast: i && _,
          isManualToolInvocation: P,
          showActions: i ? _ && !r : _,
          addToolResult: u
        },
        S
      );
    }
    return x.type === "text" && !g ? /* @__PURE__ */ v.jsx(
      YAe,
      {
        part: x,
        isLast: i && _,
        isLoading: r,
        message: e,
        prevMessage: t,
        showActions: i ? _ && !r : _,
        setMessages: a,
        sendMessage: h,
        regenerate: c,
        threadId: n,
        showAvatar: N,
        onReuseMessage: m
      },
      S
    ) : x.type === "step-start" ? null : /* @__PURE__ */ v.jsxs("div", { children: [
      " unknown part ",
      x.type
    ] }, S);
  }) }) }) });
}, yMe = C.memo(gMe, (e, t) => !(e.message.id !== t.message.id || e.isLoading !== t.isLoading || e.isLastMessage !== t.isLastMessage || e.className !== t.className || t.isLoading && t.isLastMessage || !Nm(e.message.metadata, t.message.metadata) || e.message.parts.length !== t.message.parts.length || !Nm(e.message.parts, t.message.parts)));
function vMe() {
  const [e, t] = C.useState(!1);
  return C.useEffect(() => {
    t(!0);
  }, []), e;
}
const bMe = ({
  words: e,
  duration: t = 3e3,
  className: n
}) => {
  const [r, i] = C.useState(e[0]), [o, s] = C.useState(!1), a = vMe(), c = C.useCallback(() => {
    const u = e[e.indexOf(r) + 1] || e[0];
    i(u), s(!0);
  }, [r, e]);
  return C.useEffect(() => {
    o || setTimeout(() => {
      c();
    }, t);
  }, [o, t, c]), a ? /* @__PURE__ */ v.jsx(
    NA,
    {
      onExitComplete: () => {
        s(!1);
      },
      children: /* @__PURE__ */ v.jsx(
        qf.div,
        {
          initial: {
            opacity: 0,
            y: 10
          },
          animate: {
            opacity: 1,
            y: 0
          },
          transition: {
            type: "spring",
            stiffness: 100,
            damping: 10
          },
          exit: {
            opacity: 0,
            y: -40,
            x: 40,
            filter: "blur(8px)",
            scale: 2,
            position: "absolute"
          },
          className: at(
            "z-10 inline-block relative text-left text-foreground px-2",
            n
          ),
          children: r.split(" ").map((u, f) => /* @__PURE__ */ v.jsxs(
            qf.span,
            {
              initial: { opacity: 0, y: 10, filter: "blur(4px)" },
              animate: { opacity: 1, y: 0, filter: "blur(0px)" },
              transition: {
                delay: f * 0.01,
                duration: 0.03
              },
              className: "inline-block whitespace-nowrap",
              children: [
                u.split("").map((h, m) => /* @__PURE__ */ v.jsx(
                  qf.span,
                  {
                    initial: { opacity: 0, y: 10, filter: "blur(4px)" },
                    animate: { opacity: 1, y: 0, filter: "blur(0px)" },
                    transition: {
                      delay: f * 0.2 + m * 0.08,
                      duration: 0.2
                    },
                    className: "inline-block",
                    children: h
                  },
                  u + m
                )),
                /* @__PURE__ */ v.jsx("span", { className: "inline-block", children: "" })
              ]
            },
            u + f
          ))
        },
        r
      )
    }
  ) : null;
};
function xMe() {
  const e = (/* @__PURE__ */ new Date()).getHours();
  return e < 12 ? "goodMorning" : e < 18 ? "goodAfternoon" : "goodEvening";
}
const wMe = () => {
  const e = { name: "User" }, t = C.useMemo(() => {
    if (!e) return "";
    const n = [
      `Good ${xMe().replace("good", "")}, ${e.name}!`,
      `Nice to see you again, ${e.name}.`,
      `What are you working on today, ${e.name}?`,
      "Let me know when you're ready to begin.",
      "What are your thoughts today?",
      "Where would you like to start?",
      `What are you thinking, ${e.name}?`
    ];
    return n[Math.floor(Math.random() * n.length)];
  }, [e.name]);
  return /* @__PURE__ */ v.jsx(
    qf.div,
    {
      className: "max-w-3xl mx-auto my-1",
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      transition: { delay: 0.3 },
      children: /* @__PURE__ */ v.jsx("div", { className: "rounded-xl p-2 flex flex-col gap-2 leading-relaxed text-center", children: /* @__PURE__ */ v.jsx("h1", { className: "text-sm md:text-base text-blue-700 dark:text-[#1abcfe] drop-shadow-sm font-sans", children: t ? /* @__PURE__ */ v.jsx(bMe, { words: [t], className: "" }) : "" }) })
    },
    "welcome"
  );
};
var Ww = "Switch", [SMe] = ps(Ww), [kMe, CMe] = SMe(Ww), X7 = C.forwardRef(
  (e, t) => {
    const {
      __scopeSwitch: n,
      name: r,
      checked: i,
      defaultChecked: o,
      required: s,
      disabled: a,
      value: c = "on",
      onCheckedChange: u,
      form: f,
      ...h
    } = e, [m, g] = C.useState(null), b = Ft(t, (M) => g(M)), x = C.useRef(!1), w = m ? f || !!m.closest("form") : !0, [S, _] = Qa({
      prop: i,
      defaultProp: o ?? !1,
      onChange: u,
      caller: Ww
    });
    return /* @__PURE__ */ v.jsxs(kMe, { scope: n, checked: S, disabled: a, children: [
      /* @__PURE__ */ v.jsx(
        Et.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": S,
          "aria-required": s,
          "data-state": tH(S),
          "data-disabled": a ? "" : void 0,
          disabled: a,
          value: c,
          ...h,
          ref: b,
          onClick: Ye(e.onClick, (M) => {
            _((N) => !N), w && (x.current = M.isPropagationStopped(), x.current || M.stopPropagation());
          })
        }
      ),
      w && /* @__PURE__ */ v.jsx(
        eH,
        {
          control: m,
          bubbles: !x.current,
          name: r,
          value: c,
          checked: S,
          required: s,
          disabled: a,
          form: f,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
X7.displayName = Ww;
var J7 = "SwitchThumb", Q7 = C.forwardRef(
  (e, t) => {
    const { __scopeSwitch: n, ...r } = e, i = CMe(J7, n);
    return /* @__PURE__ */ v.jsx(
      Et.span,
      {
        "data-state": tH(i.checked),
        "data-disabled": i.disabled ? "" : void 0,
        ...r,
        ref: t
      }
    );
  }
);
Q7.displayName = J7;
var EMe = "SwitchBubbleInput", eH = C.forwardRef(
  ({
    __scopeSwitch: e,
    control: t,
    checked: n,
    bubbles: r = !0,
    ...i
  }, o) => {
    const s = C.useRef(null), a = Ft(s, o), c = nM(n), u = UA(t);
    return C.useEffect(() => {
      const f = s.current;
      if (!f) return;
      const h = window.HTMLInputElement.prototype, g = Object.getOwnPropertyDescriptor(
        h,
        "checked"
      ).set;
      if (c !== n && g) {
        const b = new Event("click", { bubbles: r });
        g.call(f, n), f.dispatchEvent(b);
      }
    }, [c, n, r]), /* @__PURE__ */ v.jsx(
      "input",
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: n,
        ...i,
        tabIndex: -1,
        ref: a,
        style: {
          ...i.style,
          ...u,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
eH.displayName = EMe;
function tH(e) {
  return e ? "checked" : "unchecked";
}
var _Me = X7, TMe = Q7;
function nH({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    _Me,
    {
      "data-slot": "switch",
      className: at(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        e
      ),
      ...t,
      children: /* @__PURE__ */ v.jsx(
        TMe,
        {
          "data-slot": "switch-thumb",
          className: at(
            "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
          )
        }
      )
    }
  );
}
const AMe = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", rH = AMe ? C.useLayoutEffect : C.useEffect;
function iH(e) {
  const t = C.useRef(e);
  return rH(() => {
    t.current = e;
  }), C.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
      r[i] = arguments[i];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
function pL(e, t) {
  t === void 0 && (t = [e]);
  const n = C.useRef(e);
  return rH(() => {
    n.current !== e && (n.current = e);
  }, t), n;
}
function MMe(e) {
  const t = iH(e), n = C.useRef(null), r = C.useCallback(
    (i) => {
      i !== n.current && t?.(i, n.current), n.current = i;
    },
    //eslint-disable-next-line
    []
  );
  return [n, r];
}
let UC = {};
function NMe(e, t) {
  return C.useMemo(() => {
    const n = UC[e] == null ? 0 : UC[e] + 1;
    return UC[e] = n, e + "-" + n;
  }, [e, t]);
}
var jm;
(function(e) {
  e.DragStart = "dragStart", e.DragMove = "dragMove", e.DragEnd = "dragEnd", e.DragCancel = "dragCancel", e.DragOver = "dragOver", e.RegisterDroppable = "registerDroppable", e.SetDroppableDisabled = "setDroppableDisabled", e.UnregisterDroppable = "unregisterDroppable";
})(jm || (jm = {}));
function mL() {
}
const RMe = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
var Uf;
(function(e) {
  e[e.Forward = 1] = "Forward", e[e.Backward = -1] = "Backward";
})(Uf || (Uf = {}));
var gL;
(function(e) {
  e.Click = "click", e.DragStart = "dragstart", e.Keydown = "keydown", e.ContextMenu = "contextmenu", e.Resize = "resize", e.SelectionChange = "selectionchange", e.VisibilityChange = "visibilitychange";
})(gL || (gL = {}));
var ec;
(function(e) {
  e.Space = "Space", e.Down = "ArrowDown", e.Right = "ArrowRight", e.Left = "ArrowLeft", e.Up = "ArrowUp", e.Esc = "Escape", e.Enter = "Enter", e.Tab = "Tab";
})(ec || (ec = {}));
ec.Space, ec.Enter, ec.Esc, ec.Space, ec.Enter, ec.Tab;
var yL;
(function(e) {
  e[e.RightClick = 2] = "RightClick";
})(yL || (yL = {}));
var vL;
(function(e) {
  e[e.Pointer = 0] = "Pointer", e[e.DraggableRect = 1] = "DraggableRect";
})(vL || (vL = {}));
var bL;
(function(e) {
  e[e.TreeOrder = 0] = "TreeOrder", e[e.ReversedTreeOrder = 1] = "ReversedTreeOrder";
})(bL || (bL = {}));
Uf.Backward + "", Uf.Forward + "", Uf.Backward + "", Uf.Forward + "";
var sT;
(function(e) {
  e[e.Always = 0] = "Always", e[e.BeforeDragging = 1] = "BeforeDragging", e[e.WhileDragging = 2] = "WhileDragging";
})(sT || (sT = {}));
var aT;
(function(e) {
  e.Optimized = "optimized";
})(aT || (aT = {}));
function OMe(e) {
  let {
    callback: t,
    disabled: n
  } = e;
  const r = iH(t), i = C.useMemo(
    () => {
      if (n || typeof window > "u" || typeof window.ResizeObserver > "u")
        return;
      const {
        ResizeObserver: o
      } = window;
      return new o(r);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [n]
  );
  return C.useEffect(() => () => i?.disconnect(), [i]), i;
}
sT.WhileDragging, aT.Optimized;
const DMe = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: mL,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: mL
}, PMe = /* @__PURE__ */ C.createContext(DMe);
({
  ...RMe
});
var xL;
(function(e) {
  e[e.Uninitialized = 0] = "Uninitialized", e[e.Initializing = 1] = "Initializing", e[e.Initialized = 2] = "Initialized";
})(xL || (xL = {}));
const jMe = "Droppable", IMe = {
  timeout: 25
};
function zMe(e) {
  let {
    data: t,
    disabled: n = !1,
    id: r,
    resizeObserverConfig: i
  } = e;
  const o = NMe(jMe), {
    active: s,
    dispatch: a,
    over: c,
    measureDroppableContainers: u
  } = C.useContext(PMe), f = C.useRef({
    disabled: n
  }), h = C.useRef(!1), m = C.useRef(null), g = C.useRef(null), {
    disabled: b,
    updateMeasurementsFor: x,
    timeout: w
  } = {
    ...IMe,
    ...i
  }, S = pL(x ?? r), _ = C.useCallback(
    () => {
      if (!h.current) {
        h.current = !0;
        return;
      }
      g.current != null && clearTimeout(g.current), g.current = setTimeout(() => {
        u(Array.isArray(S.current) ? S.current : [S.current]), g.current = null;
      }, w);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [w]
  ), M = OMe({
    callback: _,
    disabled: b || !s
  }), N = C.useCallback((L, U) => {
    M && (U && (M.unobserve(U), h.current = !1), L && M.observe(L));
  }, [M]), [P, I] = MMe(N), O = pL(t);
  return C.useEffect(() => {
    !M || !P.current || (M.disconnect(), h.current = !1, M.observe(P.current));
  }, [P, M]), C.useEffect(
    () => (a({
      type: jm.RegisterDroppable,
      element: {
        id: r,
        key: o,
        disabled: n,
        node: P,
        rect: m,
        data: O
      }
    }), () => a({
      type: jm.UnregisterDroppable,
      key: o,
      id: r
    })),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [r]
  ), C.useEffect(() => {
    n !== f.current.disabled && (a({
      type: jm.SetDroppableDisabled,
      id: r,
      key: o,
      disabled: n
    }), f.current.disabled = n);
  }, [r, o, n, a]), {
    active: s,
    rect: m,
    isOver: c?.id === r,
    node: P,
    over: c,
    setNodeRef: I
  };
}
function LMe(e) {
  return {
    name: e.name,
    size: e.size,
    type: e.type,
    uploadedAt: /* @__PURE__ */ new Date()
  };
}
const BMe = ({ onFilesChange: e, files: t, isAIThinking: n }) => {
  const r = C.useRef(null), [i, o] = C.useState([]), [s, a] = C.useState(!1);
  Ne.useEffect(() => {
    o(t || []);
  }, [t]);
  const c = (x) => {
    o(x), e && e(x);
  }, u = () => {
    const x = document.createElement("input");
    x.type = "file", x.accept = ".json,.xlsx,.xls,.geojson,.ifc", x.multiple = !0, x.click(), x.onchange = async (w) => {
      const S = w.target.files;
      o([...S ? Array.from(S) : []]), f(S), x.remove();
    };
  }, f = (x) => {
    if (!x) return;
    const w = Array.from(x);
    w.forEach((_) => LMe(_));
    const S = [...i, ...w];
    c(S);
  }, h = (x) => {
    f(x.target.files), x.target && (x.target.value = "");
  }, m = (x) => {
    x.preventDefault(), a(!1), f(x.dataTransfer.files);
  }, g = (x) => {
    x.preventDefault(), a(!0);
  }, b = () => a(!1);
  return /* @__PURE__ */ v.jsx("div", { className: "flex flex-col items-end", children: /* @__PURE__ */ v.jsxs(
    "div",
    {
      onDrop: m,
      onDragOver: g,
      onDragLeave: b,
      className: `flex items-center gap-2 rounded-md ${s ? "bg-neutral-100 dark:bg-neutral-800" : ""}`,
      style: { minWidth: 40 },
      children: [
        /* @__PURE__ */ v.jsx(
          "input",
          {
            ref: r,
            type: "file",
            multiple: !0,
            onChange: h,
            className: "hidden",
            disabled: n
          }
        ),
        /* @__PURE__ */ v.jsx(
          Ht,
          {
            disabled: n,
            size: "icon",
            variant: "ghost",
            onClick: u,
            title: "Upload files",
            className: "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
            children: /* @__PURE__ */ v.jsx(OZ, { className: "h-5 w-5" })
          }
        )
      ]
    }
  ) });
};
function Jr(e) {
  this.content = e;
}
Jr.prototype = {
  constructor: Jr,
  find: function(e) {
    for (var t = 0; t < this.content.length; t += 2)
      if (this.content[t] === e) return t;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(e) {
    var t = this.find(e);
    return t == -1 ? void 0 : this.content[t + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(e, t, n) {
    var r = n && n != e ? this.remove(n) : this, i = r.find(e), o = r.content.slice();
    return i == -1 ? o.push(n || e, t) : (o[i + 1] = t, n && (o[i] = n)), new Jr(o);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(e) {
    var t = this.find(e);
    if (t == -1) return this;
    var n = this.content.slice();
    return n.splice(t, 2), new Jr(n);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(e, t) {
    return new Jr([e, t].concat(this.remove(e).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(e, t) {
    var n = this.remove(e).content.slice();
    return n.push(e, t), new Jr(n);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(e, t, n) {
    var r = this.remove(t), i = r.content.slice(), o = r.find(e);
    return i.splice(o == -1 ? i.length : o, 0, t, n), new Jr(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(e) {
    for (var t = 0; t < this.content.length; t += 2)
      e(this.content[t], this.content[t + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(e) {
    return e = Jr.from(e), e.size ? new Jr(e.content.concat(this.subtract(e).content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(e) {
    return e = Jr.from(e), e.size ? new Jr(this.subtract(e).content.concat(e.content)) : this;
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(e) {
    var t = this;
    e = Jr.from(e);
    for (var n = 0; n < e.content.length; n += 2)
      t = t.remove(e.content[n]);
    return t;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var e = {};
    return this.forEach(function(t, n) {
      e[t] = n;
    }), e;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Jr.from = function(e) {
  if (e instanceof Jr) return e;
  var t = [];
  if (e) for (var n in e) t.push(n, e[n]);
  return new Jr(t);
};
function oH(e, t, n) {
  for (let r = 0; ; r++) {
    if (r == e.childCount || r == t.childCount)
      return e.childCount == t.childCount ? null : n;
    let i = e.child(r), o = t.child(r);
    if (i == o) {
      n += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(o))
      return n;
    if (i.isText && i.text != o.text) {
      for (let s = 0; i.text[s] == o.text[s]; s++)
        n++;
      return n;
    }
    if (i.content.size || o.content.size) {
      let s = oH(i.content, o.content, n + 1);
      if (s != null)
        return s;
    }
    n += i.nodeSize;
  }
}
function sH(e, t, n, r) {
  for (let i = e.childCount, o = t.childCount; ; ) {
    if (i == 0 || o == 0)
      return i == o ? null : { a: n, b: r };
    let s = e.child(--i), a = t.child(--o), c = s.nodeSize;
    if (s == a) {
      n -= c, r -= c;
      continue;
    }
    if (!s.sameMarkup(a))
      return { a: n, b: r };
    if (s.isText && s.text != a.text) {
      let u = 0, f = Math.min(s.text.length, a.text.length);
      for (; u < f && s.text[s.text.length - u - 1] == a.text[a.text.length - u - 1]; )
        u++, n--, r--;
      return { a: n, b: r };
    }
    if (s.content.size || a.content.size) {
      let u = sH(s.content, a.content, n - 1, r - 1);
      if (u)
        return u;
    }
    n -= c, r -= c;
  }
}
class $e {
  /**
  @internal
  */
  constructor(t, n) {
    if (this.content = t, this.size = n || 0, n == null)
      for (let r = 0; r < t.length; r++)
        this.size += t[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(t, n, r, i = 0, o) {
    for (let s = 0, a = 0; a < n; s++) {
      let c = this.content[s], u = a + c.nodeSize;
      if (u > t && r(c, i + a, o || null, s) !== !1 && c.content.size) {
        let f = a + 1;
        c.nodesBetween(Math.max(0, t - f), Math.min(c.content.size, n - f), r, i + f);
      }
      a = u;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(t) {
    this.nodesBetween(0, this.size, t);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(t, n, r, i) {
    let o = "", s = !0;
    return this.nodesBetween(t, n, (a, c) => {
      let u = a.isText ? a.text.slice(Math.max(t, c) - c, n - c) : a.isLeaf ? i ? typeof i == "function" ? i(a) : i : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && u || a.isTextblock) && r && (s ? s = !1 : o += r), o += u;
    }, 0), o;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(t) {
    if (!t.size)
      return this;
    if (!this.size)
      return t;
    let n = this.lastChild, r = t.firstChild, i = this.content.slice(), o = 0;
    for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), o = 1); o < t.content.length; o++)
      i.push(t.content[o]);
    return new $e(i, this.size + t.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(t, n = this.size) {
    if (t == 0 && n == this.size)
      return this;
    let r = [], i = 0;
    if (n > t)
      for (let o = 0, s = 0; s < n; o++) {
        let a = this.content[o], c = s + a.nodeSize;
        c > t && ((s < t || c > n) && (a.isText ? a = a.cut(Math.max(0, t - s), Math.min(a.text.length, n - s)) : a = a.cut(Math.max(0, t - s - 1), Math.min(a.content.size, n - s - 1))), r.push(a), i += a.nodeSize), s = c;
      }
    return new $e(r, i);
  }
  /**
  @internal
  */
  cutByIndex(t, n) {
    return t == n ? $e.empty : t == 0 && n == this.content.length ? this : new $e(this.content.slice(t, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(t, n) {
    let r = this.content[t];
    if (r == n)
      return this;
    let i = this.content.slice(), o = this.size + n.nodeSize - r.nodeSize;
    return i[t] = n, new $e(i, o);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(t) {
    return new $e([t].concat(this.content), this.size + t.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(t) {
    return new $e(this.content.concat(t), this.size + t.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(t) {
    if (this.content.length != t.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(t.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(t) {
    let n = this.content[t];
    if (!n)
      throw new RangeError("Index " + t + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(t) {
    return this.content[t] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(t) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n];
      t(i, r, n), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(t, n = 0) {
    return oH(this, t, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(t, n = this.size, r = t.size) {
    return sH(this, t, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(t) {
    if (t == 0)
      return Xv(0, t);
    if (t == this.size)
      return Xv(this.content.length, t);
    if (t > this.size || t < 0)
      throw new RangeError(`Position ${t} outside of fragment (${this})`);
    for (let n = 0, r = 0; ; n++) {
      let i = this.child(n), o = r + i.nodeSize;
      if (o >= t)
        return o == t ? Xv(n + 1, o) : Xv(n, r);
      r = o;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((t) => t.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(t, n) {
    if (!n)
      return $e.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new $e(n.map(t.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(t) {
    if (!t.length)
      return $e.empty;
    let n, r = 0;
    for (let i = 0; i < t.length; i++) {
      let o = t[i];
      r += o.nodeSize, i && o.isText && t[i - 1].sameMarkup(o) ? (n || (n = t.slice(0, i)), n[n.length - 1] = o.withText(n[n.length - 1].text + o.text)) : n && n.push(o);
    }
    return new $e(n || t, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(t) {
    if (!t)
      return $e.empty;
    if (t instanceof $e)
      return t;
    if (Array.isArray(t))
      return this.fromArray(t);
    if (t.attrs)
      return new $e([t], t.nodeSize);
    throw new RangeError("Can not convert " + t + " to a Fragment" + (t.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
$e.empty = new $e([], 0);
const FC = { index: 0, offset: 0 };
function Xv(e, t) {
  return FC.index = e, FC.offset = t, FC;
}
function Xb(e, t) {
  if (e === t)
    return !0;
  if (!(e && typeof e == "object") || !(t && typeof t == "object"))
    return !1;
  let n = Array.isArray(e);
  if (Array.isArray(t) != n)
    return !1;
  if (n) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!Xb(e[r], t[r]))
        return !1;
  } else {
    for (let r in e)
      if (!(r in t) || !Xb(e[r], t[r]))
        return !1;
    for (let r in t)
      if (!(r in e))
        return !1;
  }
  return !0;
}
let En = class lT {
  /**
  @internal
  */
  constructor(t, n) {
    this.type = t, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(t) {
    let n, r = !1;
    for (let i = 0; i < t.length; i++) {
      let o = t[i];
      if (this.eq(o))
        return t;
      if (this.type.excludes(o.type))
        n || (n = t.slice(0, i));
      else {
        if (o.type.excludes(this.type))
          return t;
        !r && o.type.rank > this.type.rank && (n || (n = t.slice(0, i)), n.push(this), r = !0), n && n.push(o);
      }
    }
    return n || (n = t.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(t) {
    for (let n = 0; n < t.length; n++)
      if (this.eq(t[n]))
        return t.slice(0, n).concat(t.slice(n + 1));
    return t;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(t) {
    for (let n = 0; n < t.length; n++)
      if (this.eq(t[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(t) {
    return this == t || this.type == t.type && Xb(this.attrs, t.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let t = { type: this.type.name };
    for (let n in this.attrs) {
      t.attrs = this.attrs;
      break;
    }
    return t;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(t, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = t.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let i = r.create(n.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(t, n) {
    if (t == n)
      return !0;
    if (t.length != n.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!t[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(t) {
    if (!t || Array.isArray(t) && t.length == 0)
      return lT.none;
    if (t instanceof lT)
      return [t];
    let n = t.slice();
    return n.sort((r, i) => r.type.rank - i.type.rank), n;
  }
};
En.none = [];
class Jb extends Error {
}
class Qe {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(t, n, r) {
    this.content = t, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(t, n) {
    let r = lH(this.content, t + this.openStart, n);
    return r && new Qe(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(t, n) {
    return new Qe(aH(this.content, t + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(t) {
    return this.content.eq(t.content) && this.openStart == t.openStart && this.openEnd == t.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let t = { content: this.content.toJSON() };
    return this.openStart > 0 && (t.openStart = this.openStart), this.openEnd > 0 && (t.openEnd = this.openEnd), t;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(t, n) {
    if (!n)
      return Qe.empty;
    let r = n.openStart || 0, i = n.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Qe($e.fromJSON(t, n.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(t, n = !0) {
    let r = 0, i = 0;
    for (let o = t.firstChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.firstChild)
      r++;
    for (let o = t.lastChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.lastChild)
      i++;
    return new Qe(t, r, i);
  }
}
Qe.empty = new Qe($e.empty, 0, 0);
function aH(e, t, n) {
  let { index: r, offset: i } = e.findIndex(t), o = e.maybeChild(r), { index: s, offset: a } = e.findIndex(n);
  if (i == t || o.isText) {
    if (a != n && !e.child(s).isText)
      throw new RangeError("Removing non-flat range");
    return e.cut(0, t).append(e.cut(n));
  }
  if (r != s)
    throw new RangeError("Removing non-flat range");
  return e.replaceChild(r, o.copy(aH(o.content, t - i - 1, n - i - 1)));
}
function lH(e, t, n, r) {
  let { index: i, offset: o } = e.findIndex(t), s = e.maybeChild(i);
  if (o == t || s.isText)
    return r && !r.canReplace(i, i, n) ? null : e.cut(0, t).append(n).append(e.cut(t));
  let a = lH(s.content, t - o - 1, n, s);
  return a && e.replaceChild(i, s.copy(a));
}
function $Me(e, t, n) {
  if (n.openStart > e.depth)
    throw new Jb("Inserted content deeper than insertion position");
  if (e.depth - n.openStart != t.depth - n.openEnd)
    throw new Jb("Inconsistent open depths");
  return cH(e, t, n, 0);
}
function cH(e, t, n, r) {
  let i = e.index(r), o = e.node(r);
  if (i == t.index(r) && r < e.depth - n.openStart) {
    let s = cH(e, t, n, r + 1);
    return o.copy(o.content.replaceChild(i, s));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && e.depth == r && t.depth == r) {
      let s = e.parent, a = s.content;
      return Vu(s, a.cut(0, e.parentOffset).append(n.content).append(a.cut(t.parentOffset)));
    } else {
      let { start: s, end: a } = UMe(n, e);
      return Vu(o, dH(e, s, a, t, r));
    }
  else return Vu(o, Qb(e, t, r));
}
function uH(e, t) {
  if (!t.type.compatibleContent(e.type))
    throw new Jb("Cannot join " + t.type.name + " onto " + e.type.name);
}
function cT(e, t, n) {
  let r = e.node(n);
  return uH(r, t.node(n)), r;
}
function Fu(e, t) {
  let n = t.length - 1;
  n >= 0 && e.isText && e.sameMarkup(t[n]) ? t[n] = e.withText(t[n].text + e.text) : t.push(e);
}
function Im(e, t, n, r) {
  let i = (t || e).node(n), o = 0, s = t ? t.index(n) : i.childCount;
  e && (o = e.index(n), e.depth > n ? o++ : e.textOffset && (Fu(e.nodeAfter, r), o++));
  for (let a = o; a < s; a++)
    Fu(i.child(a), r);
  t && t.depth == n && t.textOffset && Fu(t.nodeBefore, r);
}
function Vu(e, t) {
  return e.type.checkContent(t), e.copy(t);
}
function dH(e, t, n, r, i) {
  let o = e.depth > i && cT(e, t, i + 1), s = r.depth > i && cT(n, r, i + 1), a = [];
  return Im(null, e, i, a), o && s && t.index(i) == n.index(i) ? (uH(o, s), Fu(Vu(o, dH(e, t, n, r, i + 1)), a)) : (o && Fu(Vu(o, Qb(e, t, i + 1)), a), Im(t, n, i, a), s && Fu(Vu(s, Qb(n, r, i + 1)), a)), Im(r, null, i, a), new $e(a);
}
function Qb(e, t, n) {
  let r = [];
  if (Im(null, e, n, r), e.depth > n) {
    let i = cT(e, t, n + 1);
    Fu(Vu(i, Qb(e, t, n + 1)), r);
  }
  return Im(t, null, n, r), new $e(r);
}
function UMe(e, t) {
  let n = t.depth - e.openStart, i = t.node(n).copy(e.content);
  for (let o = n - 1; o >= 0; o--)
    i = t.node(o).copy($e.from(i));
  return {
    start: i.resolveNoCache(e.openStart + n),
    end: i.resolveNoCache(i.content.size - e.openEnd - n)
  };
}
class gg {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.pos = t, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(t) {
    return t == null ? this.depth : t < 0 ? this.depth + t : t;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(t) {
    return this.path[this.resolveDepth(t) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(t) {
    return this.path[this.resolveDepth(t) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(t) {
    return t = this.resolveDepth(t), this.index(t) + (t == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(t) {
    return t = this.resolveDepth(t), t == 0 ? 0 : this.path[t * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(t) {
    return t = this.resolveDepth(t), this.start(t) + this.node(t).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(t) {
    if (t = this.resolveDepth(t), !t)
      throw new RangeError("There is no position before the top-level node");
    return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(t) {
    if (t = this.resolveDepth(t), !t)
      throw new RangeError("There is no position after the top-level node");
    return t == this.depth + 1 ? this.pos : this.path[t * 3 - 1] + this.path[t * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let t = this.parent, n = this.index(this.depth);
    if (n == t.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = t.child(n);
    return r ? t.child(n).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let t = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(t).cut(0, n) : t == 0 ? null : this.parent.child(t - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(t, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let o = 0; o < t; o++)
      i += r.child(o).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let t = this.parent, n = this.index();
    if (t.content.size == 0)
      return En.none;
    if (this.textOffset)
      return t.child(n).marks;
    let r = t.maybeChild(n - 1), i = t.maybeChild(n);
    if (!r) {
      let a = r;
      r = i, i = a;
    }
    let o = r.marks;
    for (var s = 0; s < o.length; s++)
      o[s].type.spec.inclusive === !1 && (!i || !o[s].isInSet(i.marks)) && (o = o[s--].removeFromSet(o));
    return o;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(t) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, i = t.parent.maybeChild(t.index());
    for (var o = 0; o < r.length; o++)
      r[o].type.spec.inclusive === !1 && (!i || !r[o].isInSet(i.marks)) && (r = r[o--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(t) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= t && this.end(n) >= t)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(t = this, n) {
    if (t.pos < this.pos)
      return t.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == t.pos ? 1 : 0); r >= 0; r--)
      if (t.pos <= this.end(r) && (!n || n(this.node(r))))
        return new ex(this, t, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(t) {
    return this.pos - this.parentOffset == t.pos - t.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(t) {
    return t.pos > this.pos ? t : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(t) {
    return t.pos < this.pos ? t : this;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let n = 1; n <= this.depth; n++)
      t += (t ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return t + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(t, n) {
    if (!(n >= 0 && n <= t.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], i = 0, o = n;
    for (let s = t; ; ) {
      let { index: a, offset: c } = s.content.findIndex(o), u = o - c;
      if (r.push(s, a, i + c), !u || (s = s.child(a), s.isText))
        break;
      o = u - 1, i += c + 1;
    }
    return new gg(n, r, o);
  }
  /**
  @internal
  */
  static resolveCached(t, n) {
    let r = wL.get(t);
    if (r)
      for (let o = 0; o < r.elts.length; o++) {
        let s = r.elts[o];
        if (s.pos == n)
          return s;
      }
    else
      wL.set(t, r = new FMe());
    let i = r.elts[r.i] = gg.resolve(t, n);
    return r.i = (r.i + 1) % VMe, i;
  }
}
class FMe {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const VMe = 12, wL = /* @__PURE__ */ new WeakMap();
class ex {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(t, n, r) {
    this.$from = t, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const HMe = /* @__PURE__ */ Object.create(null);
let gc = class uT {
  /**
  @internal
  */
  constructor(t, n, r, i = En.none) {
    this.type = t, this.attrs = n, this.marks = i, this.content = r || $e.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(t) {
    return this.content.child(t);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(t) {
    return this.content.maybeChild(t);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(t) {
    this.content.forEach(t);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(t, n, r, i = 0) {
    this.content.nodesBetween(t, n, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(t) {
    this.nodesBetween(0, this.content.size, t);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(t, n, r, i) {
    return this.content.textBetween(t, n, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(t) {
    return this == t || this.sameMarkup(t) && this.content.eq(t.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(t) {
    return this.hasMarkup(t.type, t.attrs, t.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(t, n, r) {
    return this.type == t && Xb(this.attrs, n || t.defaultAttrs || HMe) && En.sameSet(this.marks, r || En.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(t = null) {
    return t == this.content ? this : new uT(this.type, this.attrs, t, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(t) {
    return t == this.marks ? this : new uT(this.type, this.attrs, this.content, t);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(t, n = this.content.size) {
    return t == 0 && n == this.content.size ? this : this.copy(this.content.cut(t, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(t, n = this.content.size, r = !1) {
    if (t == n)
      return Qe.empty;
    let i = this.resolve(t), o = this.resolve(n), s = r ? 0 : i.sharedDepth(n), a = i.start(s), u = i.node(s).content.cut(i.pos - a, o.pos - a);
    return new Qe(u, i.depth - s, o.depth - s);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(t, n, r) {
    return $Me(this.resolve(t), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(t) {
    for (let n = this; ; ) {
      let { index: r, offset: i } = n.content.findIndex(t);
      if (n = n.maybeChild(r), !n)
        return null;
      if (i == t || n.isText)
        return n;
      t -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(t) {
    let { index: n, offset: r } = this.content.findIndex(t);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(t) {
    if (t == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(t);
    if (r < t)
      return { node: this.content.child(n), index: n, offset: r };
    let i = this.content.child(n - 1);
    return { node: i, index: n - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(t) {
    return gg.resolveCached(this, t);
  }
  /**
  @internal
  */
  resolveNoCache(t) {
    return gg.resolve(this, t);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(t, n, r) {
    let i = !1;
    return n > t && this.nodesBetween(t, n, (o) => (r.isInSet(o.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let t = this.type.name;
    return this.content.size && (t += "(" + this.content.toStringInner() + ")"), fH(this.marks, t);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(t) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, t);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(t, n, r = $e.empty, i = 0, o = r.childCount) {
    let s = this.contentMatchAt(t).matchFragment(r, i, o), a = s && s.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let c = i; c < o; c++)
      if (!this.type.allowsMarks(r.child(c).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(t, n, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let o = this.contentMatchAt(t).matchType(r), s = o && o.matchFragment(this.content, n);
    return s ? s.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(t) {
    return t.content.size ? this.canReplace(this.childCount, this.childCount, t.content) : this.type.compatibleContent(t.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let t = En.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), t = r.addToSet(t);
    }
    if (!En.sameSet(t, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let t = { type: this.type.name };
    for (let n in this.attrs) {
      t.attrs = this.attrs;
      break;
    }
    return this.content.size && (t.content = this.content.toJSON()), this.marks.length && (t.marks = this.marks.map((n) => n.toJSON())), t;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(t, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(t.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return t.text(n.text, r);
    }
    let i = $e.fromJSON(t, n.content), o = t.nodeType(n.type).create(n.attrs, i, r);
    return o.type.checkAttrs(o.attrs), o;
  }
};
gc.prototype.text = void 0;
class tx extends gc {
  /**
  @internal
  */
  constructor(t, n, r, i) {
    if (super(t, n, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : fH(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(t, n) {
    return this.text.slice(t, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(t) {
    return t == this.marks ? this : new tx(this.type, this.attrs, this.text, t);
  }
  withText(t) {
    return t == this.text ? this : new tx(this.type, this.attrs, t, this.marks);
  }
  cut(t = 0, n = this.text.length) {
    return t == 0 && n == this.text.length ? this : this.withText(this.text.slice(t, n));
  }
  eq(t) {
    return this.sameMarkup(t) && this.text == t.text;
  }
  toJSON() {
    let t = super.toJSON();
    return t.text = this.text, t;
  }
}
function fH(e, t) {
  for (let n = e.length - 1; n >= 0; n--)
    t = e[n].type.name + "(" + t + ")";
  return t;
}
class rd {
  /**
  @internal
  */
  constructor(t) {
    this.validEnd = t, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(t, n) {
    let r = new WMe(t, n);
    if (r.next == null)
      return rd.empty;
    let i = hH(r);
    r.next && r.err("Unexpected trailing text");
    let o = JMe(XMe(i));
    return QMe(o, r), o;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(t) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == t)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(t, n = 0, r = t.childCount) {
    let i = this;
    for (let o = n; i && o < r; o++)
      i = i.matchType(t.child(o).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let t = 0; t < this.next.length; t++) {
      let { type: n } = this.next[t];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(t) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < t.next.length; r++)
        if (this.next[n].type == t.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(t, n = !1, r = 0) {
    let i = [this];
    function o(s, a) {
      let c = s.matchFragment(t, r);
      if (c && (!n || c.validEnd))
        return $e.from(a.map((u) => u.createAndFill()));
      for (let u = 0; u < s.next.length; u++) {
        let { type: f, next: h } = s.next[u];
        if (!(f.isText || f.hasRequiredAttrs()) && i.indexOf(h) == -1) {
          i.push(h);
          let m = o(h, a.concat(f));
          if (m)
            return m;
        }
      }
      return null;
    }
    return o(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(t) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == t)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(t);
    return this.wrapCache.push(t, n), n;
  }
  /**
  @internal
  */
  computeWrapping(t) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), o = i.match;
      if (o.matchType(t)) {
        let s = [];
        for (let a = i; a.type; a = a.via)
          s.push(a.type);
        return s.reverse();
      }
      for (let s = 0; s < o.next.length; s++) {
        let { type: a, next: c } = o.next[s];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!i.type || c.validEnd) && (r.push({ match: a.contentMatch, type: a, via: i }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(t) {
    if (t >= this.next.length)
      throw new RangeError(`There's no ${t}th edge in this content match`);
    return this.next[t];
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    function n(r) {
      t.push(r);
      for (let i = 0; i < r.next.length; i++)
        t.indexOf(r.next[i].next) == -1 && n(r.next[i].next);
    }
    return n(this), t.map((r, i) => {
      let o = i + (r.validEnd ? "*" : " ") + " ";
      for (let s = 0; s < r.next.length; s++)
        o += (s ? ", " : "") + r.next[s].type.name + "->" + t.indexOf(r.next[s].next);
      return o;
    }).join(`
`);
  }
}
rd.empty = new rd(!0);
class WMe {
  constructor(t, n) {
    this.string = t, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = t.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(t) {
    return this.next == t && (this.pos++ || !0);
  }
  err(t) {
    throw new SyntaxError(t + " (in content expression '" + this.string + "')");
  }
}
function hH(e) {
  let t = [];
  do
    t.push(qMe(e));
  while (e.eat("|"));
  return t.length == 1 ? t[0] : { type: "choice", exprs: t };
}
function qMe(e) {
  let t = [];
  do
    t.push(GMe(e));
  while (e.next && e.next != ")" && e.next != "|");
  return t.length == 1 ? t[0] : { type: "seq", exprs: t };
}
function GMe(e) {
  let t = YMe(e);
  for (; ; )
    if (e.eat("+"))
      t = { type: "plus", expr: t };
    else if (e.eat("*"))
      t = { type: "star", expr: t };
    else if (e.eat("?"))
      t = { type: "opt", expr: t };
    else if (e.eat("{"))
      t = KMe(e, t);
    else
      break;
  return t;
}
function SL(e) {
  /\D/.test(e.next) && e.err("Expected number, got '" + e.next + "'");
  let t = Number(e.next);
  return e.pos++, t;
}
function KMe(e, t) {
  let n = SL(e), r = n;
  return e.eat(",") && (e.next != "}" ? r = SL(e) : r = -1), e.eat("}") || e.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: t };
}
function ZMe(e, t) {
  let n = e.nodeTypes, r = n[t];
  if (r)
    return [r];
  let i = [];
  for (let o in n) {
    let s = n[o];
    s.isInGroup(t) && i.push(s);
  }
  return i.length == 0 && e.err("No node type or group '" + t + "' found"), i;
}
function YMe(e) {
  if (e.eat("(")) {
    let t = hH(e);
    return e.eat(")") || e.err("Missing closing paren"), t;
  } else if (/\W/.test(e.next))
    e.err("Unexpected token '" + e.next + "'");
  else {
    let t = ZMe(e, e.next).map((n) => (e.inline == null ? e.inline = n.isInline : e.inline != n.isInline && e.err("Mixing inline and block content"), { type: "name", value: n }));
    return e.pos++, t.length == 1 ? t[0] : { type: "choice", exprs: t };
  }
}
function XMe(e) {
  let t = [[]];
  return i(o(e, 0), n()), t;
  function n() {
    return t.push([]) - 1;
  }
  function r(s, a, c) {
    let u = { term: c, to: a };
    return t[s].push(u), u;
  }
  function i(s, a) {
    s.forEach((c) => c.to = a);
  }
  function o(s, a) {
    if (s.type == "choice")
      return s.exprs.reduce((c, u) => c.concat(o(u, a)), []);
    if (s.type == "seq")
      for (let c = 0; ; c++) {
        let u = o(s.exprs[c], a);
        if (c == s.exprs.length - 1)
          return u;
        i(u, a = n());
      }
    else if (s.type == "star") {
      let c = n();
      return r(a, c), i(o(s.expr, c), c), [r(c)];
    } else if (s.type == "plus") {
      let c = n();
      return i(o(s.expr, a), c), i(o(s.expr, c), c), [r(c)];
    } else {
      if (s.type == "opt")
        return [r(a)].concat(o(s.expr, a));
      if (s.type == "range") {
        let c = a;
        for (let u = 0; u < s.min; u++) {
          let f = n();
          i(o(s.expr, c), f), c = f;
        }
        if (s.max == -1)
          i(o(s.expr, c), c);
        else
          for (let u = s.min; u < s.max; u++) {
            let f = n();
            r(c, f), i(o(s.expr, c), f), c = f;
          }
        return [r(c)];
      } else {
        if (s.type == "name")
          return [r(a, void 0, s.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function pH(e, t) {
  return t - e;
}
function kL(e, t) {
  let n = [];
  return r(t), n.sort(pH);
  function r(i) {
    let o = e[i];
    if (o.length == 1 && !o[0].term)
      return r(o[0].to);
    n.push(i);
    for (let s = 0; s < o.length; s++) {
      let { term: a, to: c } = o[s];
      !a && n.indexOf(c) == -1 && r(c);
    }
  }
}
function JMe(e) {
  let t = /* @__PURE__ */ Object.create(null);
  return n(kL(e, 0));
  function n(r) {
    let i = [];
    r.forEach((s) => {
      e[s].forEach(({ term: a, to: c }) => {
        if (!a)
          return;
        let u;
        for (let f = 0; f < i.length; f++)
          i[f][0] == a && (u = i[f][1]);
        kL(e, c).forEach((f) => {
          u || i.push([a, u = []]), u.indexOf(f) == -1 && u.push(f);
        });
      });
    });
    let o = t[r.join(",")] = new rd(r.indexOf(e.length - 1) > -1);
    for (let s = 0; s < i.length; s++) {
      let a = i[s][1].sort(pH);
      o.next.push({ type: i[s][0], next: t[a.join(",")] || n(a) });
    }
    return o;
  }
}
function QMe(e, t) {
  for (let n = 0, r = [e]; n < r.length; n++) {
    let i = r[n], o = !i.validEnd, s = [];
    for (let a = 0; a < i.next.length; a++) {
      let { type: c, next: u } = i.next[a];
      s.push(c.name), o && !(c.isText || c.hasRequiredAttrs()) && (o = !1), r.indexOf(u) == -1 && r.push(u);
    }
    o && t.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function mH(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in e) {
    let r = e[n];
    if (!r.hasDefault)
      return null;
    t[n] = r.default;
  }
  return t;
}
function gH(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in e) {
    let i = t && t[r];
    if (i === void 0) {
      let o = e[r];
      if (o.hasDefault)
        i = o.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = i;
  }
  return n;
}
function yH(e, t, n, r) {
  for (let i in t)
    if (!(i in e))
      throw new RangeError(`Unsupported attribute ${i} for ${n} of type ${i}`);
  for (let i in e) {
    let o = e[i];
    o.validate && o.validate(t[i]);
  }
}
function vH(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  if (t)
    for (let r in t)
      n[r] = new tNe(e, r, t[r]);
  return n;
}
let CL = class bH {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.name = t, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = vH(t, r.attrs), this.defaultAttrs = mH(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || t == "text"), this.isText = t == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == rd.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(t) {
    return this.groups.indexOf(t) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let t in this.attrs)
      if (this.attrs[t].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(t) {
    return this == t || this.contentMatch.compatible(t.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(t) {
    return !t && this.defaultAttrs ? this.defaultAttrs : gH(this.attrs, t);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(t = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new gc(this, this.computeAttrs(t), $e.from(n), En.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(t = null, n, r) {
    return n = $e.from(n), this.checkContent(n), new gc(this, this.computeAttrs(t), n, En.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(t = null, n, r) {
    if (t = this.computeAttrs(t), n = $e.from(n), n.size) {
      let s = this.contentMatch.fillBefore(n);
      if (!s)
        return null;
      n = s.append(n);
    }
    let i = this.contentMatch.matchFragment(n), o = i && i.fillBefore($e.empty, !0);
    return o ? new gc(this, t, n.append(o), En.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(t) {
    let n = this.contentMatch.matchFragment(t);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < t.childCount; r++)
      if (!this.allowsMarks(t.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(t) {
    if (!this.validContent(t))
      throw new RangeError(`Invalid content for node ${this.name}: ${t.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(t) {
    yH(this.attrs, t, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(t) {
    return this.markSet == null || this.markSet.indexOf(t) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(t) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < t.length; n++)
      if (!this.allowsMarkType(t[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(t) {
    if (this.markSet == null)
      return t;
    let n;
    for (let r = 0; r < t.length; r++)
      this.allowsMarkType(t[r].type) ? n && n.push(t[r]) : n || (n = t.slice(0, r));
    return n ? n.length ? n : En.none : t;
  }
  /**
  @internal
  */
  static compile(t, n) {
    let r = /* @__PURE__ */ Object.create(null);
    t.forEach((o, s) => r[o] = new bH(o, n, s));
    let i = n.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let o in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function eNe(e, t, n) {
  let r = n.split("|");
  return (i) => {
    let o = i === null ? "null" : typeof i;
    if (r.indexOf(o) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${t} on type ${e}, got ${o}`);
  };
}
class tNe {
  constructor(t, n, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? eNe(t, n, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class qw {
  /**
  @internal
  */
  constructor(t, n, r, i) {
    this.name = t, this.rank = n, this.schema = r, this.spec = i, this.attrs = vH(t, i.attrs), this.excluded = null;
    let o = mH(this.attrs);
    this.instance = o ? new En(this, o) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(t = null) {
    return !t && this.instance ? this.instance : new En(this, gH(this.attrs, t));
  }
  /**
  @internal
  */
  static compile(t, n) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return t.forEach((o, s) => r[o] = new qw(o, i++, n, s)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(t) {
    for (var n = 0; n < t.length; n++)
      t[n].type == this && (t = t.slice(0, n).concat(t.slice(n + 1)), n--);
    return t;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(t) {
    for (let n = 0; n < t.length; n++)
      if (t[n].type == this)
        return t[n];
  }
  /**
  @internal
  */
  checkAttrs(t) {
    yH(this.attrs, t, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(t) {
    return this.excluded.indexOf(t) > -1;
  }
}
class xH {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(t) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let i in t)
      n[i] = t[i];
    n.nodes = Jr.from(t.nodes), n.marks = Jr.from(t.marks || {}), this.nodes = CL.compile(this.spec.nodes, this), this.marks = qw.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let o = this.nodes[i], s = o.spec.content || "", a = o.spec.marks;
      if (o.contentMatch = r[s] || (r[s] = rd.parse(s, this.nodes)), o.inlineContent = o.contentMatch.inlineContent, o.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!o.isInline || !o.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = o;
      }
      o.markSet = a == "_" ? null : a ? EL(this, a.split(" ")) : a == "" || !o.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let o = this.marks[i], s = o.spec.excludes;
      o.excluded = s == null ? [o] : s == "" ? [] : EL(this, s.split(" "));
    }
    this.nodeFromJSON = (i) => gc.fromJSON(this, i), this.markFromJSON = (i) => En.fromJSON(this, i), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(t, n = null, r, i) {
    if (typeof t == "string")
      t = this.nodeType(t);
    else if (t instanceof CL) {
      if (t.schema != this)
        throw new RangeError("Node type from different schema used (" + t.name + ")");
    } else throw new RangeError("Invalid node type: " + t);
    return t.createChecked(n, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(t, n) {
    let r = this.nodes.text;
    return new tx(r, r.defaultAttrs, t, En.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(t, n) {
    return typeof t == "string" && (t = this.marks[t]), t.create(n);
  }
  /**
  @internal
  */
  nodeType(t) {
    let n = this.nodes[t];
    if (!n)
      throw new RangeError("Unknown node type: " + t);
    return n;
  }
}
function EL(e, t) {
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r], o = e.marks[i], s = o;
    if (o)
      n.push(o);
    else
      for (let a in e.marks) {
        let c = e.marks[a];
        (i == "_" || c.spec.group && c.spec.group.split(" ").indexOf(i) > -1) && n.push(s = c);
      }
    if (!s)
      throw new SyntaxError("Unknown mark type: '" + t[r] + "'");
  }
  return n;
}
function nNe(e) {
  return e.tag != null;
}
function rNe(e) {
  return e.style != null;
}
class yc {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(t, n) {
    this.schema = t, this.rules = n, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    n.forEach((i) => {
      if (nNe(i))
        this.tags.push(i);
      else if (rNe(i)) {
        let o = /[^=]*/.exec(i.style)[0];
        r.indexOf(o) < 0 && r.push(o), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let o = t.nodes[i.node];
      return o.contentMatch.matchType(o);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(t, n = {}) {
    let r = new TL(this, n, !1);
    return r.addAll(t, En.none, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(t, n = {}) {
    let r = new TL(this, n, !0);
    return r.addAll(t, En.none, n.from, n.to), Qe.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(t, n, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let o = this.tags[i];
      if (sNe(t, o.tag) && (o.namespace === void 0 || t.namespaceURI == o.namespace) && (!o.context || n.matchesContext(o.context))) {
        if (o.getAttrs) {
          let s = o.getAttrs(t);
          if (s === !1)
            continue;
          o.attrs = s || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(t, n, r, i) {
    for (let o = i ? this.styles.indexOf(i) + 1 : 0; o < this.styles.length; o++) {
      let s = this.styles[o], a = s.style;
      if (!(a.indexOf(t) != 0 || s.context && !r.matchesContext(s.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > t.length && (a.charCodeAt(t.length) != 61 || a.slice(t.length + 1) != n))) {
        if (s.getAttrs) {
          let c = s.getAttrs(n);
          if (c === !1)
            continue;
          s.attrs = c || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(t) {
    let n = [];
    function r(i) {
      let o = i.priority == null ? 50 : i.priority, s = 0;
      for (; s < n.length; s++) {
        let a = n[s];
        if ((a.priority == null ? 50 : a.priority) < o)
          break;
      }
      n.splice(s, 0, i);
    }
    for (let i in t.marks) {
      let o = t.marks[i].spec.parseDOM;
      o && o.forEach((s) => {
        r(s = AL(s)), s.mark || s.ignore || s.clearMark || (s.mark = i);
      });
    }
    for (let i in t.nodes) {
      let o = t.nodes[i].spec.parseDOM;
      o && o.forEach((s) => {
        r(s = AL(s)), s.node || s.ignore || s.mark || (s.node = i);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(t) {
    return t.cached.domParser || (t.cached.domParser = new yc(t, yc.schemaRules(t)));
  }
}
const wH = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, iNe = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, SH = { ol: !0, ul: !0 }, yg = 1, dT = 2, zm = 4;
function _L(e, t, n) {
  return t != null ? (t ? yg : 0) | (t === "full" ? dT : 0) : e && e.whitespace == "pre" ? yg | dT : n & ~zm;
}
class Jv {
  constructor(t, n, r, i, o, s) {
    this.type = t, this.attrs = n, this.marks = r, this.solid = i, this.options = s, this.content = [], this.activeMarks = En.none, this.match = o || (s & zm ? null : t.contentMatch);
  }
  findWrapping(t) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore($e.from(t));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(t.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(t.type);
  }
  finish(t) {
    if (!(this.options & yg)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let o = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = o.withText(o.text.slice(0, o.text.length - i[0].length));
      }
    }
    let n = $e.from(this.content);
    return !t && this.match && (n = n.append(this.match.fillBefore($e.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(t) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : t.parentNode && !wH.hasOwnProperty(t.parentNode.nodeName.toLowerCase());
  }
}
class TL {
  constructor(t, n, r) {
    this.parser = t, this.options = n, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let i = n.topNode, o, s = _L(null, n.preserveWhitespace, 0) | (r ? zm : 0);
    i ? o = new Jv(i.type, i.attrs, En.none, !0, n.topMatch || i.type.contentMatch, s) : r ? o = new Jv(null, null, En.none, !0, null, s) : o = new Jv(t.schema.topNodeType, null, En.none, !0, null, s), this.nodes = [o], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(t, n) {
    t.nodeType == 3 ? this.addTextNode(t, n) : t.nodeType == 1 && this.addElement(t, n);
  }
  addTextNode(t, n) {
    let r = t.nodeValue, i = this.top, o = i.options & dT ? "full" : this.localPreserveWS || (i.options & yg) > 0, { schema: s } = this.parser;
    if (o === "full" || i.inlineContext(t) || /[^ \t\r\n\u000c]/.test(r)) {
      if (o)
        if (o === "full")
          r = r.replace(/\r\n?/g, `
`);
        else if (s.linebreakReplacement && /[\r\n]/.test(r) && this.top.findWrapping(s.linebreakReplacement.create())) {
          let a = r.split(/\r?\n|\r/);
          for (let c = 0; c < a.length; c++)
            c && this.insertNode(s.linebreakReplacement.create(), n, !0), a[c] && this.insertNode(s.text(a[c]), n, !/\S/.test(a[c]));
          r = "";
        } else
          r = r.replace(/\r?\n|\r/g, " ");
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let a = i.content[i.content.length - 1], c = t.previousSibling;
        (!a || c && c.nodeName == "BR" || a.isText && /[ \t\r\n\u000c]$/.test(a.text)) && (r = r.slice(1));
      }
      r && this.insertNode(s.text(r), n, !/\S/.test(r)), this.findInText(t);
    } else
      this.findInside(t);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(t, n, r) {
    let i = this.localPreserveWS, o = this.top;
    (t.tagName == "PRE" || /pre/.test(t.style && t.style.whiteSpace)) && (this.localPreserveWS = !0);
    let s = t.nodeName.toLowerCase(), a;
    SH.hasOwnProperty(s) && this.parser.normalizeLists && oNe(t);
    let c = this.options.ruleFromNode && this.options.ruleFromNode(t) || (a = this.parser.matchTag(t, this, r));
    e: if (c ? c.ignore : iNe.hasOwnProperty(s))
      this.findInside(t), this.ignoreFallback(t, n);
    else if (!c || c.skip || c.closeParent) {
      c && c.closeParent ? this.open = Math.max(0, this.open - 1) : c && c.skip.nodeType && (t = c.skip);
      let u, f = this.needsBlock;
      if (wH.hasOwnProperty(s))
        o.content.length && o.content[0].isInline && this.open && (this.open--, o = this.top), u = !0, o.type || (this.needsBlock = !0);
      else if (!t.firstChild) {
        this.leafFallback(t, n);
        break e;
      }
      let h = c && c.skip ? n : this.readStyles(t, n);
      h && this.addAll(t, h), u && this.sync(o), this.needsBlock = f;
    } else {
      let u = this.readStyles(t, n);
      u && this.addElementByRule(t, c, u, c.consuming === !1 ? a : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(t, n) {
    t.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(t.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(t, n) {
    t.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(t, n) {
    let r = t.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let o = this.parser.matchedStyles[i], s = r.getPropertyValue(o);
        if (s)
          for (let a = void 0; ; ) {
            let c = this.parser.matchStyle(o, s, this, a);
            if (!c)
              break;
            if (c.ignore)
              return null;
            if (c.clearMark ? n = n.filter((u) => !c.clearMark(u)) : n = n.concat(this.parser.schema.marks[c.mark].create(c.attrs)), c.consuming === !1)
              a = c;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(t, n, r, i) {
    let o, s;
    if (n.node)
      if (s = this.parser.schema.nodes[n.node], s.isLeaf)
        this.insertNode(s.create(n.attrs), r, t.nodeName == "BR") || this.leafFallback(t, r);
      else {
        let c = this.enter(s, n.attrs || null, r, n.preserveWhitespace);
        c && (o = !0, r = c);
      }
    else {
      let c = this.parser.schema.marks[n.mark];
      r = r.concat(c.create(n.attrs));
    }
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(t);
    else if (i)
      this.addElement(t, r, i);
    else if (n.getContent)
      this.findInside(t), n.getContent(t, this.parser.schema).forEach((c) => this.insertNode(c, r, !1));
    else {
      let c = t;
      typeof n.contentElement == "string" ? c = t.querySelector(n.contentElement) : typeof n.contentElement == "function" ? c = n.contentElement(t) : n.contentElement && (c = n.contentElement), this.findAround(t, c, !0), this.addAll(c, r), this.findAround(t, c, !1);
    }
    o && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(t, n, r, i) {
    let o = r || 0;
    for (let s = r ? t.childNodes[r] : t.firstChild, a = i == null ? null : t.childNodes[i]; s != a; s = s.nextSibling, ++o)
      this.findAtPoint(t, o), this.addDOM(s, n);
    this.findAtPoint(t, o);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(t, n, r) {
    let i, o;
    for (let s = this.open, a = 0; s >= 0; s--) {
      let c = this.nodes[s], u = c.findWrapping(t);
      if (u && (!i || i.length > u.length + a) && (i = u, o = c, !u.length))
        break;
      if (c.solid) {
        if (r)
          break;
        a += 2;
      }
    }
    if (!i)
      return null;
    this.sync(o);
    for (let s = 0; s < i.length; s++)
      n = this.enterInner(i[s], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(t, n, r) {
    if (t.isInline && this.needsBlock && !this.top.type) {
      let o = this.textblockFromContext();
      o && (n = this.enterInner(o, null, n));
    }
    let i = this.findPlace(t, n, r);
    if (i) {
      this.closeExtra();
      let o = this.top;
      o.match && (o.match = o.match.matchType(t.type));
      let s = En.none;
      for (let a of i.concat(t.marks))
        (o.type ? o.type.allowsMarkType(a.type) : ML(a.type, t.type)) && (s = a.addToSet(s));
      return o.content.push(t.mark(s)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(t, n, r, i) {
    let o = this.findPlace(t.create(n), r, !1);
    return o && (o = this.enterInner(t, n, r, !0, i)), o;
  }
  // Open a node of the given type
  enterInner(t, n, r, i = !1, o) {
    this.closeExtra();
    let s = this.top;
    s.match = s.match && s.match.matchType(t);
    let a = _L(t, o, s.options);
    s.options & zm && s.content.length == 0 && (a |= zm);
    let c = En.none;
    return r = r.filter((u) => (s.type ? s.type.allowsMarkType(u.type) : ML(u.type, t)) ? (c = u.addToSet(c), !1) : !0), this.nodes.push(new Jv(t, n, c, i, null, a)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(t = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(t));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(t) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == t)
        return this.open = n, !0;
      this.localPreserveWS && (this.nodes[n].options |= yg);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let t = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let i = r.length - 1; i >= 0; i--)
        t += r[i].nodeSize;
      n && t++;
    }
    return t;
  }
  findAtPoint(t, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == t && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(t) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && t.nodeType == 1 && t.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(t, n, r) {
    if (t != n && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && t.nodeType == 1 && t.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(t) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == t && (this.find[n].pos = this.currentPos - (t.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(t) {
    if (t.indexOf("|") > -1)
      return t.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = t.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), o = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), s = (a, c) => {
      for (; a >= 0; a--) {
        let u = n[a];
        if (u == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; c >= o; c--)
            if (s(a - 1, c))
              return !0;
          return !1;
        } else {
          let f = c > 0 || c == 0 && i ? this.nodes[c].type : r && c >= o ? r.node(c - o).type : null;
          if (!f || f.name != u && !f.isInGroup(u))
            return !1;
          c--;
        }
      }
      return !0;
    };
    return s(n.length - 1, this.open);
  }
  textblockFromContext() {
    let t = this.options.context;
    if (t)
      for (let n = t.depth; n >= 0; n--) {
        let r = t.node(n).contentMatchAt(t.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function oNe(e) {
  for (let t = e.firstChild, n = null; t; t = t.nextSibling) {
    let r = t.nodeType == 1 ? t.nodeName.toLowerCase() : null;
    r && SH.hasOwnProperty(r) && n ? (n.appendChild(t), t = n) : r == "li" ? n = t : r && (n = null);
  }
}
function sNe(e, t) {
  return (e.matches || e.msMatchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector).call(e, t);
}
function AL(e) {
  let t = {};
  for (let n in e)
    t[n] = e[n];
  return t;
}
function ML(e, t) {
  let n = t.schema.nodes;
  for (let r in n) {
    let i = n[r];
    if (!i.allowsMarkType(e))
      continue;
    let o = [], s = (a) => {
      o.push(a);
      for (let c = 0; c < a.edgeCount; c++) {
        let { type: u, next: f } = a.edge(c);
        if (u == t || o.indexOf(f) < 0 && s(f))
          return !0;
      }
    };
    if (s(i.contentMatch))
      return !0;
  }
}
class pd {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(t, n) {
    this.nodes = t, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(t, n = {}, r) {
    r || (r = VC(n).createDocumentFragment());
    let i = r, o = [];
    return t.forEach((s) => {
      if (o.length || s.marks.length) {
        let a = 0, c = 0;
        for (; a < o.length && c < s.marks.length; ) {
          let u = s.marks[c];
          if (!this.marks[u.type.name]) {
            c++;
            continue;
          }
          if (!u.eq(o[a][0]) || u.type.spec.spanning === !1)
            break;
          a++, c++;
        }
        for (; a < o.length; )
          i = o.pop()[1];
        for (; c < s.marks.length; ) {
          let u = s.marks[c++], f = this.serializeMark(u, s.isInline, n);
          f && (o.push([u, i]), i.appendChild(f.dom), i = f.contentDOM || f.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(s, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(t, n) {
    let { dom: r, contentDOM: i } = V0(VC(n), this.nodes[t.type.name](t), null, t.attrs);
    if (i) {
      if (t.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(t.content, n, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(t, n = {}) {
    let r = this.serializeNodeInner(t, n);
    for (let i = t.marks.length - 1; i >= 0; i--) {
      let o = this.serializeMark(t.marks[i], t.isInline, n);
      o && ((o.contentDOM || o.dom).appendChild(r), r = o.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(t, n, r = {}) {
    let i = this.marks[t.type.name];
    return i && V0(VC(r), i(t, n), null, t.attrs);
  }
  static renderSpec(t, n, r = null, i) {
    return V0(t, n, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(t) {
    return t.cached.domSerializer || (t.cached.domSerializer = new pd(this.nodesFromSchema(t), this.marksFromSchema(t)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(t) {
    let n = NL(t.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(t) {
    return NL(t.marks);
  }
}
function NL(e) {
  let t = {};
  for (let n in e) {
    let r = e[n].spec.toDOM;
    r && (t[n] = r);
  }
  return t;
}
function VC(e) {
  return e.document || window.document;
}
const RL = /* @__PURE__ */ new WeakMap();
function aNe(e) {
  let t = RL.get(e);
  return t === void 0 && RL.set(e, t = lNe(e)), t;
}
function lNe(e) {
  let t = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          t || (t = []), t.push(r);
        else
          for (let i = 0; i < r.length; i++)
            n(r[i]);
      else
        for (let i in r)
          n(r[i]);
  }
  return n(e), t;
}
function V0(e, t, n, r) {
  if (typeof t == "string")
    return { dom: e.createTextNode(t) };
  if (t.nodeType != null)
    return { dom: t };
  if (t.dom && t.dom.nodeType != null)
    return t;
  let i = t[0], o;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (o = aNe(r)) && o.indexOf(t) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let s = i.indexOf(" ");
  s > 0 && (n = i.slice(0, s), i = i.slice(s + 1));
  let a, c = n ? e.createElementNS(n, i) : e.createElement(i), u = t[1], f = 1;
  if (u && typeof u == "object" && u.nodeType == null && !Array.isArray(u)) {
    f = 2;
    for (let h in u)
      if (u[h] != null) {
        let m = h.indexOf(" ");
        m > 0 ? c.setAttributeNS(h.slice(0, m), h.slice(m + 1), u[h]) : h == "style" && c.style ? c.style.cssText = u[h] : c.setAttribute(h, u[h]);
      }
  }
  for (let h = f; h < t.length; h++) {
    let m = t[h];
    if (m === 0) {
      if (h < t.length - 1 || h > f)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: c, contentDOM: c };
    } else {
      let { dom: g, contentDOM: b } = V0(e, m, n, r);
      if (c.appendChild(g), b) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = b;
      }
    }
  }
  return { dom: c, contentDOM: a };
}
const kH = 65535, CH = Math.pow(2, 16);
function cNe(e, t) {
  return e + t * CH;
}
function OL(e) {
  return e & kH;
}
function uNe(e) {
  return (e - (e & kH)) / CH;
}
const EH = 1, _H = 2, H0 = 4, TH = 8;
class fT {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.pos = t, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & TH) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (EH | H0)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (_H | H0)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & H0) > 0;
  }
}
class uo {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(t, n = !1) {
    if (this.ranges = t, this.inverted = n, !t.length && uo.empty)
      return uo.empty;
  }
  /**
  @internal
  */
  recover(t) {
    let n = 0, r = OL(t);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + n + uNe(t);
  }
  mapResult(t, n = 1) {
    return this._map(t, n, !1);
  }
  map(t, n = 1) {
    return this._map(t, n, !0);
  }
  /**
  @internal
  */
  _map(t, n, r) {
    let i = 0, o = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let c = this.ranges[a] - (this.inverted ? i : 0);
      if (c > t)
        break;
      let u = this.ranges[a + o], f = this.ranges[a + s], h = c + u;
      if (t <= h) {
        let m = u ? t == c ? -1 : t == h ? 1 : n : n, g = c + i + (m < 0 ? 0 : f);
        if (r)
          return g;
        let b = t == (n < 0 ? c : h) ? null : cNe(a / 3, t - c), x = t == c ? _H : t == h ? EH : H0;
        return (n < 0 ? t != c : t != h) && (x |= TH), new fT(g, x, b);
      }
      i += f - u;
    }
    return r ? t + i : new fT(t + i, 0, null);
  }
  /**
  @internal
  */
  touches(t, n) {
    let r = 0, i = OL(n), o = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let c = this.ranges[a] - (this.inverted ? r : 0);
      if (c > t)
        break;
      let u = this.ranges[a + o], f = c + u;
      if (t <= f && a == i * 3)
        return !0;
      r += this.ranges[a + s] - u;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(t) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, o = 0; i < this.ranges.length; i += 3) {
      let s = this.ranges[i], a = s - (this.inverted ? o : 0), c = s + (this.inverted ? 0 : o), u = this.ranges[i + n], f = this.ranges[i + r];
      t(a, a + u, c, c + f), o += f - u;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new uo(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(t) {
    return t == 0 ? uo.empty : new uo(t < 0 ? [0, -t, 0] : [0, 0, t]);
  }
}
uo.empty = new uo([]);
class vg {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(t, n, r = 0, i = t ? t.length : 0) {
    this.mirror = n, this.from = r, this.to = i, this._maps = t || [], this.ownData = !(t || n);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(t = 0, n = this.maps.length) {
    return new vg(this._maps, this.mirror, t, n);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(t, n) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(t), n != null && this.setMirror(this._maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(t) {
    for (let n = 0, r = this._maps.length; n < t._maps.length; n++) {
      let i = t.getMirror(n);
      this.appendMap(t._maps[n], i != null && i < n ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(t) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == t)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(t, n) {
    this.mirror || (this.mirror = []), this.mirror.push(t, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(t) {
    for (let n = t.maps.length - 1, r = this._maps.length + t._maps.length; n >= 0; n--) {
      let i = t.getMirror(n);
      this.appendMap(t._maps[n].invert(), i != null && i > n ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let t = new vg();
    return t.appendMappingInverted(this), t;
  }
  /**
  Map a position through this mapping.
  */
  map(t, n = 1) {
    if (this.mirror)
      return this._map(t, n, !0);
    for (let r = this.from; r < this.to; r++)
      t = this._maps[r].map(t, n);
    return t;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(t, n = 1) {
    return this._map(t, n, !1);
  }
  /**
  @internal
  */
  _map(t, n, r) {
    let i = 0;
    for (let o = this.from; o < this.to; o++) {
      let s = this._maps[o], a = s.mapResult(t, n);
      if (a.recover != null) {
        let c = this.getMirror(o);
        if (c != null && c > o && c < this.to) {
          o = c, t = this._maps[c].recover(a.recover);
          continue;
        }
      }
      i |= a.delInfo, t = a.pos;
    }
    return r ? t : new fT(t, i, null);
  }
}
const HC = /* @__PURE__ */ Object.create(null);
class xi {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return uo.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(t) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(t, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = HC[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(t, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(t, n) {
    if (t in HC)
      throw new RangeError("Duplicate use of step JSON ID " + t);
    return HC[t] = n, n.prototype.jsonID = t, n;
  }
}
class Cr {
  /**
  @internal
  */
  constructor(t, n) {
    this.doc = t, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(t) {
    return new Cr(t, null);
  }
  /**
  Create a failed step result.
  */
  static fail(t) {
    return new Cr(null, t);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(t, n, r, i) {
    try {
      return Cr.ok(t.replace(n, r, i));
    } catch (o) {
      if (o instanceof Jb)
        return Cr.fail(o.message);
      throw o;
    }
  }
}
function pN(e, t, n) {
  let r = [];
  for (let i = 0; i < e.childCount; i++) {
    let o = e.child(i);
    o.content.size && (o = o.copy(pN(o.content, t, o))), o.isInline && (o = t(o, n, i)), r.push(o);
  }
  return $e.fromArray(r);
}
class uc extends xi {
  /**
  Create a mark step.
  */
  constructor(t, n, r) {
    super(), this.from = t, this.to = n, this.mark = r;
  }
  apply(t) {
    let n = t.slice(this.from, this.to), r = t.resolve(this.from), i = r.node(r.sharedDepth(this.to)), o = new Qe(pN(n.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), i), n.openStart, n.openEnd);
    return Cr.fromReplace(t, this.from, this.to, o);
  }
  invert() {
    return new cs(this.from, this.to, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new uc(n.pos, r.pos, this.mark);
  }
  merge(t) {
    return t instanceof uc && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from ? new uc(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new uc(n.from, n.to, t.markFromJSON(n.mark));
  }
}
xi.jsonID("addMark", uc);
class cs extends xi {
  /**
  Create a mark-removing step.
  */
  constructor(t, n, r) {
    super(), this.from = t, this.to = n, this.mark = r;
  }
  apply(t) {
    let n = t.slice(this.from, this.to), r = new Qe(pN(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), t), n.openStart, n.openEnd);
    return Cr.fromReplace(t, this.from, this.to, r);
  }
  invert() {
    return new uc(this.from, this.to, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new cs(n.pos, r.pos, this.mark);
  }
  merge(t) {
    return t instanceof cs && t.mark.eq(this.mark) && this.from <= t.to && this.to >= t.from ? new cs(Math.min(this.from, t.from), Math.max(this.to, t.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new cs(n.from, n.to, t.markFromJSON(n.mark));
  }
}
xi.jsonID("removeMark", cs);
class dc extends xi {
  /**
  Create a node mark step.
  */
  constructor(t, n) {
    super(), this.pos = t, this.mark = n;
  }
  apply(t) {
    let n = t.nodeAt(this.pos);
    if (!n)
      return Cr.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return Cr.fromReplace(t, this.pos, this.pos + 1, new Qe($e.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(t) {
    let n = t.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r))
            return new dc(this.pos, n.marks[i]);
        return new dc(this.pos, this.mark);
      }
    }
    return new id(this.pos, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new dc(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new dc(n.pos, t.markFromJSON(n.mark));
  }
}
xi.jsonID("addNodeMark", dc);
class id extends xi {
  /**
  Create a mark-removing step.
  */
  constructor(t, n) {
    super(), this.pos = t, this.mark = n;
  }
  apply(t) {
    let n = t.nodeAt(this.pos);
    if (!n)
      return Cr.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return Cr.fromReplace(t, this.pos, this.pos + 1, new Qe($e.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(t) {
    let n = t.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new dc(this.pos, this.mark);
  }
  map(t) {
    let n = t.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new id(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new id(n.pos, t.markFromJSON(n.mark));
  }
}
xi.jsonID("removeNodeMark", id);
class Ur extends xi {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(t, n, r, i = !1) {
    super(), this.from = t, this.to = n, this.slice = r, this.structure = i;
  }
  apply(t) {
    return this.structure && hT(t, this.from, this.to) ? Cr.fail("Structure replace would overwrite content") : Cr.fromReplace(t, this.from, this.to, this.slice);
  }
  getMap() {
    return new uo([this.from, this.to - this.from, this.slice.size]);
  }
  invert(t) {
    return new Ur(this.from, this.from + this.slice.size, t.slice(this.from, this.to));
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new Ur(n.pos, Math.max(n.pos, r.pos), this.slice, this.structure);
  }
  merge(t) {
    if (!(t instanceof Ur) || t.structure || this.structure)
      return null;
    if (this.from + this.slice.size == t.from && !this.slice.openEnd && !t.slice.openStart) {
      let n = this.slice.size + t.slice.size == 0 ? Qe.empty : new Qe(this.slice.content.append(t.slice.content), this.slice.openStart, t.slice.openEnd);
      return new Ur(this.from, this.to + (t.to - t.from), n, this.structure);
    } else if (t.to == this.from && !this.slice.openStart && !t.slice.openEnd) {
      let n = this.slice.size + t.slice.size == 0 ? Qe.empty : new Qe(t.slice.content.append(this.slice.content), t.slice.openStart, this.slice.openEnd);
      return new Ur(t.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let t = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (t.slice = this.slice.toJSON()), this.structure && (t.structure = !0), t;
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new Ur(n.from, n.to, Qe.fromJSON(t, n.slice), !!n.structure);
  }
}
xi.jsonID("replace", Ur);
class Hr extends xi {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(t, n, r, i, o, s, a = !1) {
    super(), this.from = t, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = o, this.insert = s, this.structure = a;
  }
  apply(t) {
    if (this.structure && (hT(t, this.from, this.gapFrom) || hT(t, this.gapTo, this.to)))
      return Cr.fail("Structure gap-replace would overwrite content");
    let n = t.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return Cr.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? Cr.fromReplace(t, this.from, this.to, r) : Cr.fail("Content does not fit in gap");
  }
  getMap() {
    return new uo([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(t) {
    let n = this.gapTo - this.gapFrom;
    return new Hr(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, t.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(t) {
    let n = t.mapResult(this.from, 1), r = t.mapResult(this.to, -1), i = this.from == this.gapFrom ? n.pos : t.map(this.gapFrom, -1), o = this.to == this.gapTo ? r.pos : t.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || i < n.pos || o > r.pos ? null : new Hr(n.pos, r.pos, i, o, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let t = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (t.slice = this.slice.toJSON()), this.structure && (t.structure = !0), t;
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Hr(n.from, n.to, n.gapFrom, n.gapTo, Qe.fromJSON(t, n.slice), n.insert, !!n.structure);
  }
}
xi.jsonID("replaceAround", Hr);
function hT(e, t, n) {
  let r = e.resolve(t), i = n - t, o = r.depth;
  for (; i > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount; )
    o--, i--;
  if (i > 0) {
    let s = r.node(o).maybeChild(r.indexAfter(o));
    for (; i > 0; ) {
      if (!s || s.isLeaf)
        return !0;
      s = s.firstChild, i--;
    }
  }
  return !1;
}
function dNe(e, t, n, r) {
  let i = [], o = [], s, a;
  e.doc.nodesBetween(t, n, (c, u, f) => {
    if (!c.isInline)
      return;
    let h = c.marks;
    if (!r.isInSet(h) && f.type.allowsMarkType(r.type)) {
      let m = Math.max(u, t), g = Math.min(u + c.nodeSize, n), b = r.addToSet(h);
      for (let x = 0; x < h.length; x++)
        h[x].isInSet(b) || (s && s.to == m && s.mark.eq(h[x]) ? s.to = g : i.push(s = new cs(m, g, h[x])));
      a && a.to == m ? a.to = g : o.push(a = new uc(m, g, r));
    }
  }), i.forEach((c) => e.step(c)), o.forEach((c) => e.step(c));
}
function fNe(e, t, n, r) {
  let i = [], o = 0;
  e.doc.nodesBetween(t, n, (s, a) => {
    if (!s.isInline)
      return;
    o++;
    let c = null;
    if (r instanceof qw) {
      let u = s.marks, f;
      for (; f = r.isInSet(u); )
        (c || (c = [])).push(f), u = f.removeFromSet(u);
    } else r ? r.isInSet(s.marks) && (c = [r]) : c = s.marks;
    if (c && c.length) {
      let u = Math.min(a + s.nodeSize, n);
      for (let f = 0; f < c.length; f++) {
        let h = c[f], m;
        for (let g = 0; g < i.length; g++) {
          let b = i[g];
          b.step == o - 1 && h.eq(i[g].style) && (m = b);
        }
        m ? (m.to = u, m.step = o) : i.push({ style: h, from: Math.max(a, t), to: u, step: o });
      }
    }
  }), i.forEach((s) => e.step(new cs(s.from, s.to, s.style)));
}
function mN(e, t, n, r = n.contentMatch, i = !0) {
  let o = e.doc.nodeAt(t), s = [], a = t + 1;
  for (let c = 0; c < o.childCount; c++) {
    let u = o.child(c), f = a + u.nodeSize, h = r.matchType(u.type);
    if (!h)
      s.push(new Ur(a, f, Qe.empty));
    else {
      r = h;
      for (let m = 0; m < u.marks.length; m++)
        n.allowsMarkType(u.marks[m].type) || e.step(new cs(a, f, u.marks[m]));
      if (i && u.isText && n.whitespace != "pre") {
        let m, g = /\r?\n|\r/g, b;
        for (; m = g.exec(u.text); )
          b || (b = new Qe($e.from(n.schema.text(" ", n.allowedMarks(u.marks))), 0, 0)), s.push(new Ur(a + m.index, a + m.index + m[0].length, b));
      }
    }
    a = f;
  }
  if (!r.validEnd) {
    let c = r.fillBefore($e.empty, !0);
    e.replace(a, a, new Qe(c, 0, 0));
  }
  for (let c = s.length - 1; c >= 0; c--)
    e.step(s[c]);
}
function hNe(e, t, n) {
  return (t == 0 || e.canReplace(t, e.childCount)) && (n == e.childCount || e.canReplace(0, n));
}
function Hh(e) {
  let n = e.parent.content.cutByIndex(e.startIndex, e.endIndex);
  for (let r = e.depth, i = 0, o = 0; ; --r) {
    let s = e.$from.node(r), a = e.$from.index(r) + i, c = e.$to.indexAfter(r) - o;
    if (r < e.depth && s.canReplace(a, c, n))
      return r;
    if (r == 0 || s.type.spec.isolating || !hNe(s, a, c))
      break;
    a && (i = 1), c < s.childCount && (o = 1);
  }
  return null;
}
function pNe(e, t, n) {
  let { $from: r, $to: i, depth: o } = t, s = r.before(o + 1), a = i.after(o + 1), c = s, u = a, f = $e.empty, h = 0;
  for (let b = o, x = !1; b > n; b--)
    x || r.index(b) > 0 ? (x = !0, f = $e.from(r.node(b).copy(f)), h++) : c--;
  let m = $e.empty, g = 0;
  for (let b = o, x = !1; b > n; b--)
    x || i.after(b + 1) < i.end(b) ? (x = !0, m = $e.from(i.node(b).copy(m)), g++) : u++;
  e.step(new Hr(c, u, s, a, new Qe(f.append(m), h, g), f.size - h, !0));
}
function gN(e, t, n = null, r = e) {
  let i = mNe(e, t), o = i && gNe(r, t);
  return o ? i.map(DL).concat({ type: t, attrs: n }).concat(o.map(DL)) : null;
}
function DL(e) {
  return { type: e, attrs: null };
}
function mNe(e, t) {
  let { parent: n, startIndex: r, endIndex: i } = e, o = n.contentMatchAt(r).findWrapping(t);
  if (!o)
    return null;
  let s = o.length ? o[0] : t;
  return n.canReplaceWith(r, i, s) ? o : null;
}
function gNe(e, t) {
  let { parent: n, startIndex: r, endIndex: i } = e, o = n.child(r), s = t.contentMatch.findWrapping(o.type);
  if (!s)
    return null;
  let c = (s.length ? s[s.length - 1] : t).contentMatch;
  for (let u = r; c && u < i; u++)
    c = c.matchType(n.child(u).type);
  return !c || !c.validEnd ? null : s;
}
function yNe(e, t, n) {
  let r = $e.empty;
  for (let s = n.length - 1; s >= 0; s--) {
    if (r.size) {
      let a = n[s].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = $e.from(n[s].type.create(n[s].attrs, r));
  }
  let i = t.start, o = t.end;
  e.step(new Hr(i, o, i, o, new Qe(r, 0, 0), n.length, !0));
}
function vNe(e, t, n, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let o = e.steps.length;
  e.doc.nodesBetween(t, n, (s, a) => {
    let c = typeof i == "function" ? i(s) : i;
    if (s.isTextblock && !s.hasMarkup(r, c) && bNe(e.doc, e.mapping.slice(o).map(a), r)) {
      let u = null;
      if (r.schema.linebreakReplacement) {
        let g = r.whitespace == "pre", b = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        g && !b ? u = !1 : !g && b && (u = !0);
      }
      u === !1 && MH(e, s, a, o), mN(e, e.mapping.slice(o).map(a, 1), r, void 0, u === null);
      let f = e.mapping.slice(o), h = f.map(a, 1), m = f.map(a + s.nodeSize, 1);
      return e.step(new Hr(h, m, h + 1, m - 1, new Qe($e.from(r.create(c, null, s.marks)), 0, 0), 1, !0)), u === !0 && AH(e, s, a, o), !1;
    }
  });
}
function AH(e, t, n, r) {
  t.forEach((i, o) => {
    if (i.isText) {
      let s, a = /\r?\n|\r/g;
      for (; s = a.exec(i.text); ) {
        let c = e.mapping.slice(r).map(n + 1 + o + s.index);
        e.replaceWith(c, c + 1, t.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function MH(e, t, n, r) {
  t.forEach((i, o) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let s = e.mapping.slice(r).map(n + 1 + o);
      e.replaceWith(s, s + 1, t.type.schema.text(`
`));
    }
  });
}
function bNe(e, t, n) {
  let r = e.resolve(t), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, n);
}
function xNe(e, t, n, r, i) {
  let o = e.doc.nodeAt(t);
  if (!o)
    throw new RangeError("No node at given position");
  n || (n = o.type);
  let s = n.create(r, null, i || o.marks);
  if (o.isLeaf)
    return e.replaceWith(t, t + o.nodeSize, s);
  if (!n.validContent(o.content))
    throw new RangeError("Invalid content for node type " + n.name);
  e.step(new Hr(t, t + o.nodeSize, t + 1, t + o.nodeSize - 1, new Qe($e.from(s), 0, 0), 1, !0));
}
function Ga(e, t, n = 1, r) {
  let i = e.resolve(t), o = i.depth - n, s = r && r[r.length - 1] || i.parent;
  if (o < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !s.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let u = i.depth - 1, f = n - 2; u > o; u--, f--) {
    let h = i.node(u), m = i.index(u);
    if (h.type.spec.isolating)
      return !1;
    let g = h.content.cutByIndex(m, h.childCount), b = r && r[f + 1];
    b && (g = g.replaceChild(0, b.type.create(b.attrs)));
    let x = r && r[f] || h;
    if (!h.canReplace(m + 1, h.childCount) || !x.type.validContent(g))
      return !1;
  }
  let a = i.indexAfter(o), c = r && r[0];
  return i.node(o).canReplaceWith(a, a, c ? c.type : i.node(o + 1).type);
}
function wNe(e, t, n = 1, r) {
  let i = e.doc.resolve(t), o = $e.empty, s = $e.empty;
  for (let a = i.depth, c = i.depth - n, u = n - 1; a > c; a--, u--) {
    o = $e.from(i.node(a).copy(o));
    let f = r && r[u];
    s = $e.from(f ? f.type.create(f.attrs, s) : i.node(a).copy(s));
  }
  e.step(new Ur(t, t, new Qe(o.append(s), n, n), !0));
}
function Fc(e, t) {
  let n = e.resolve(t), r = n.index();
  return NH(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function SNe(e, t) {
  t.content.size || e.type.compatibleContent(t.type);
  let n = e.contentMatchAt(e.childCount), { linebreakReplacement: r } = e.type.schema;
  for (let i = 0; i < t.childCount; i++) {
    let o = t.child(i), s = o.type == r ? e.type.schema.nodes.text : o.type;
    if (n = n.matchType(s), !n || !e.type.allowsMarks(o.marks))
      return !1;
  }
  return n.validEnd;
}
function NH(e, t) {
  return !!(e && t && !e.isLeaf && SNe(e, t));
}
function Gw(e, t, n = -1) {
  let r = e.resolve(t);
  for (let i = r.depth; ; i--) {
    let o, s, a = r.index(i);
    if (i == r.depth ? (o = r.nodeBefore, s = r.nodeAfter) : n > 0 ? (o = r.node(i + 1), a++, s = r.node(i).maybeChild(a)) : (o = r.node(i).maybeChild(a - 1), s = r.node(i + 1)), o && !o.isTextblock && NH(o, s) && r.node(i).canReplace(a, a + 1))
      return t;
    if (i == 0)
      break;
    t = n < 0 ? r.before(i) : r.after(i);
  }
}
function kNe(e, t, n) {
  let r = null, { linebreakReplacement: i } = e.doc.type.schema, o = e.doc.resolve(t - n), s = o.node().type;
  if (i && s.inlineContent) {
    let f = s.whitespace == "pre", h = !!s.contentMatch.matchType(i);
    f && !h ? r = !1 : !f && h && (r = !0);
  }
  let a = e.steps.length;
  if (r === !1) {
    let f = e.doc.resolve(t + n);
    MH(e, f.node(), f.before(), a);
  }
  s.inlineContent && mN(e, t + n - 1, s, o.node().contentMatchAt(o.index()), r == null);
  let c = e.mapping.slice(a), u = c.map(t - n);
  if (e.step(new Ur(u, c.map(t + n, -1), Qe.empty, !0)), r === !0) {
    let f = e.doc.resolve(u);
    AH(e, f.node(), f.before(), e.steps.length);
  }
  return e;
}
function CNe(e, t, n) {
  let r = e.resolve(t);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return t;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.index(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.before(i + 1);
      if (o > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.indexAfter(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.after(i + 1);
      if (o < r.node(i).childCount)
        return null;
    }
  return null;
}
function RH(e, t, n) {
  let r = e.resolve(t);
  if (!n.content.size)
    return t;
  let i = n.content;
  for (let o = 0; o < n.openStart; o++)
    i = i.firstChild.content;
  for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++)
    for (let s = r.depth; s >= 0; s--) {
      let a = s == r.depth ? 0 : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2 ? -1 : 1, c = r.index(s) + (a > 0 ? 1 : 0), u = r.node(s), f = !1;
      if (o == 1)
        f = u.canReplace(c, c, i);
      else {
        let h = u.contentMatchAt(c).findWrapping(i.firstChild.type);
        f = h && u.canReplaceWith(c, c, h[0]);
      }
      if (f)
        return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1);
    }
  return null;
}
function Kw(e, t, n = t, r = Qe.empty) {
  if (t == n && !r.size)
    return null;
  let i = e.resolve(t), o = e.resolve(n);
  return OH(i, o, r) ? new Ur(t, n, r) : new ENe(i, o, r).fit();
}
function OH(e, t, n) {
  return !n.openStart && !n.openEnd && e.start() == t.start() && e.parent.canReplace(e.index(), t.index(), n.content);
}
class ENe {
  constructor(t, n, r) {
    this.$from = t, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = $e.empty;
    for (let i = 0; i <= t.depth; i++) {
      let o = t.node(i);
      this.frontier.push({
        type: o.type,
        match: o.contentMatchAt(t.indexAfter(i))
      });
    }
    for (let i = t.depth; i > 0; i--)
      this.placed = $e.from(t.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let u = this.findFittable();
      u ? this.placeNodes(u) : this.openMore() || this.dropNode();
    }
    let t = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(t < 0 ? this.$to : r.doc.resolve(t));
    if (!i)
      return null;
    let o = this.placed, s = r.depth, a = i.depth;
    for (; s && a && o.childCount == 1; )
      o = o.firstChild.content, s--, a--;
    let c = new Qe(o, s, a);
    return t > -1 ? new Hr(r.pos, t, this.$to.pos, this.$to.end(), c, n) : c.size || r.pos != this.$to.pos ? new Ur(r.pos, i.pos, c) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let t = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < t; r++) {
      let o = n.firstChild;
      if (n.childCount > 1 && (i = 0), o.type.spec.isolating && i <= r) {
        t = r;
        break;
      }
      n = o.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? t : this.unplaced.openStart; r >= 0; r--) {
        let i, o = null;
        r ? (o = WC(this.unplaced.content, r - 1).firstChild, i = o.content) : i = this.unplaced.content;
        let s = i.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: c, match: u } = this.frontier[a], f, h = null;
          if (n == 1 && (s ? u.matchType(s.type) || (h = u.fillBefore($e.from(s), !1)) : o && c.compatibleContent(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: o, inject: h };
          if (n == 2 && s && (f = u.findWrapping(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: o, wrap: f };
          if (o && u.matchType(o.type))
            break;
        }
      }
  }
  openMore() {
    let { content: t, openStart: n, openEnd: r } = this.unplaced, i = WC(t, n);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new Qe(t, n + 1, Math.max(r, i.size + n >= t.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: t, openStart: n, openEnd: r } = this.unplaced, i = WC(t, n);
    if (i.childCount <= 1 && n > 0) {
      let o = t.size - n <= n + i.size;
      this.unplaced = new Qe(mm(t, n - 1, 1), n - 1, o ? n - 1 : r);
    } else
      this.unplaced = new Qe(mm(t, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: t, frontierDepth: n, parent: r, inject: i, wrap: o }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (o)
      for (let x = 0; x < o.length; x++)
        this.openFrontierNode(o[x]);
    let s = this.unplaced, a = r ? r.content : s.content, c = s.openStart - t, u = 0, f = [], { match: h, type: m } = this.frontier[n];
    if (i) {
      for (let x = 0; x < i.childCount; x++)
        f.push(i.child(x));
      h = h.matchFragment(i);
    }
    let g = a.size + t - (s.content.size - s.openEnd);
    for (; u < a.childCount; ) {
      let x = a.child(u), w = h.matchType(x.type);
      if (!w)
        break;
      u++, (u > 1 || c == 0 || x.content.size) && (h = w, f.push(DH(x.mark(m.allowedMarks(x.marks)), u == 1 ? c : 0, u == a.childCount ? g : -1)));
    }
    let b = u == a.childCount;
    b || (g = -1), this.placed = gm(this.placed, n, $e.from(f)), this.frontier[n].match = h, b && g < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let x = 0, w = a; x < g; x++) {
      let S = w.lastChild;
      this.frontier.push({ type: S.type, match: S.contentMatchAt(S.childCount) }), w = S.content;
    }
    this.unplaced = b ? t == 0 ? Qe.empty : new Qe(mm(s.content, t - 1, 1), t - 1, g < 0 ? s.openEnd : t - 1) : new Qe(mm(s.content, t, u), s.openStart, s.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let t = this.frontier[this.depth], n;
    if (!t.type.isTextblock || !qC(this.$to, this.$to.depth, t.type, t.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(t) {
    e: for (let n = Math.min(this.depth, t.depth); n >= 0; n--) {
      let { match: r, type: i } = this.frontier[n], o = n < t.depth && t.end(n + 1) == t.pos + (t.depth - (n + 1)), s = qC(t, n, i, r, o);
      if (s) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: c, type: u } = this.frontier[a], f = qC(t, a, u, c, !0);
          if (!f || f.childCount)
            continue e;
        }
        return { depth: n, fit: s, move: o ? t.doc.resolve(t.after(n + 1)) : t };
      }
    }
  }
  close(t) {
    let n = this.findCloseLevel(t);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = gm(this.placed, n.depth, n.fit)), t = n.move;
    for (let r = n.depth + 1; r <= t.depth; r++) {
      let i = t.node(r), o = i.type.contentMatch.fillBefore(i.content, !0, t.index(r));
      this.openFrontierNode(i.type, i.attrs, o);
    }
    return t;
  }
  openFrontierNode(t, n = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(t), this.placed = gm(this.placed, this.depth, $e.from(t.create(n, r))), this.frontier.push({ type: t, match: t.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore($e.empty, !0);
    n.childCount && (this.placed = gm(this.placed, this.frontier.length, n));
  }
}
function mm(e, t, n) {
  return t == 0 ? e.cutByIndex(n, e.childCount) : e.replaceChild(0, e.firstChild.copy(mm(e.firstChild.content, t - 1, n)));
}
function gm(e, t, n) {
  return t == 0 ? e.append(n) : e.replaceChild(e.childCount - 1, e.lastChild.copy(gm(e.lastChild.content, t - 1, n)));
}
function WC(e, t) {
  for (let n = 0; n < t; n++)
    e = e.firstChild.content;
  return e;
}
function DH(e, t, n) {
  if (t <= 0)
    return e;
  let r = e.content;
  return t > 1 && (r = r.replaceChild(0, DH(r.firstChild, t - 1, r.childCount == 1 ? n - 1 : 0))), t > 0 && (r = e.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(e.type.contentMatch.matchFragment(r).fillBefore($e.empty, !0)))), e.copy(r);
}
function qC(e, t, n, r, i) {
  let o = e.node(t), s = i ? e.indexAfter(t) : e.index(t);
  if (s == o.childCount && !n.compatibleContent(o.type))
    return null;
  let a = r.fillBefore(o.content, !0, s);
  return a && !_Ne(n, o.content, s) ? a : null;
}
function _Ne(e, t, n) {
  for (let r = n; r < t.childCount; r++)
    if (!e.allowsMarks(t.child(r).marks))
      return !0;
  return !1;
}
function TNe(e) {
  return e.spec.defining || e.spec.definingForContent;
}
function ANe(e, t, n, r) {
  if (!r.size)
    return e.deleteRange(t, n);
  let i = e.doc.resolve(t), o = e.doc.resolve(n);
  if (OH(i, o, r))
    return e.step(new Ur(t, n, r));
  let s = jH(i, o);
  s[s.length - 1] == 0 && s.pop();
  let a = -(i.depth + 1);
  s.unshift(a);
  for (let m = i.depth, g = i.pos - 1; m > 0; m--, g--) {
    let b = i.node(m).type.spec;
    if (b.defining || b.definingAsContext || b.isolating)
      break;
    s.indexOf(m) > -1 ? a = m : i.before(m) == g && s.splice(1, 0, -m);
  }
  let c = s.indexOf(a), u = [], f = r.openStart;
  for (let m = r.content, g = 0; ; g++) {
    let b = m.firstChild;
    if (u.push(b), g == r.openStart)
      break;
    m = b.content;
  }
  for (let m = f - 1; m >= 0; m--) {
    let g = u[m], b = TNe(g.type);
    if (b && !g.sameMarkup(i.node(Math.abs(a) - 1)))
      f = m;
    else if (b || !g.type.isTextblock)
      break;
  }
  for (let m = r.openStart; m >= 0; m--) {
    let g = (m + f + 1) % (r.openStart + 1), b = u[g];
    if (b)
      for (let x = 0; x < s.length; x++) {
        let w = s[(x + c) % s.length], S = !0;
        w < 0 && (S = !1, w = -w);
        let _ = i.node(w - 1), M = i.index(w - 1);
        if (_.canReplaceWith(M, M, b.type, b.marks))
          return e.replace(i.before(w), S ? o.after(w) : n, new Qe(PH(r.content, 0, r.openStart, g), g, r.openEnd));
      }
  }
  let h = e.steps.length;
  for (let m = s.length - 1; m >= 0 && (e.replace(t, n, r), !(e.steps.length > h)); m--) {
    let g = s[m];
    g < 0 || (t = i.before(g), n = o.after(g));
  }
}
function PH(e, t, n, r, i) {
  if (t < n) {
    let o = e.firstChild;
    e = e.replaceChild(0, o.copy(PH(o.content, t + 1, n, r, o)));
  }
  if (t > r) {
    let o = i.contentMatchAt(0), s = o.fillBefore(e).append(e);
    e = s.append(o.matchFragment(s).fillBefore($e.empty, !0));
  }
  return e;
}
function MNe(e, t, n, r) {
  if (!r.isInline && t == n && e.doc.resolve(t).parent.content.size) {
    let i = CNe(e.doc, t, r.type);
    i != null && (t = n = i);
  }
  e.replaceRange(t, n, new Qe($e.from(r), 0, 0));
}
function NNe(e, t, n) {
  let r = e.doc.resolve(t), i = e.doc.resolve(n), o = jH(r, i);
  for (let s = 0; s < o.length; s++) {
    let a = o[s], c = s == o.length - 1;
    if (c && a == 0 || r.node(a).type.contentMatch.validEnd)
      return e.delete(r.start(a), i.end(a));
    if (a > 0 && (c || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
      return e.delete(r.before(a), i.after(a));
  }
  for (let s = 1; s <= r.depth && s <= i.depth; s++)
    if (t - r.start(s) == r.depth - s && n > r.end(s) && i.end(s) - n != i.depth - s && r.start(s - 1) == i.start(s - 1) && r.node(s - 1).canReplace(r.index(s - 1), i.index(s - 1)))
      return e.delete(r.before(s), n);
  e.delete(t, n);
}
function jH(e, t) {
  let n = [], r = Math.min(e.depth, t.depth);
  for (let i = r; i >= 0; i--) {
    let o = e.start(i);
    if (o < e.pos - (e.depth - i) || t.end(i) > t.pos + (t.depth - i) || e.node(i).type.spec.isolating || t.node(i).type.spec.isolating)
      break;
    (o == t.start(i) || i == e.depth && i == t.depth && e.parent.inlineContent && t.parent.inlineContent && i && t.start(i - 1) == o - 1) && n.push(i);
  }
  return n;
}
class Qf extends xi {
  /**
  Construct an attribute step.
  */
  constructor(t, n, r) {
    super(), this.pos = t, this.attr = n, this.value = r;
  }
  apply(t) {
    let n = t.nodeAt(this.pos);
    if (!n)
      return Cr.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in n.attrs)
      r[o] = n.attrs[o];
    r[this.attr] = this.value;
    let i = n.type.create(r, null, n.marks);
    return Cr.fromReplace(t, this.pos, this.pos + 1, new Qe($e.from(i), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return uo.empty;
  }
  invert(t) {
    return new Qf(this.pos, this.attr, t.nodeAt(this.pos).attrs[this.attr]);
  }
  map(t) {
    let n = t.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Qf(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(t, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new Qf(n.pos, n.attr, n.value);
  }
}
xi.jsonID("attr", Qf);
class bg extends xi {
  /**
  Construct an attribute step.
  */
  constructor(t, n) {
    super(), this.attr = t, this.value = n;
  }
  apply(t) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in t.attrs)
      n[i] = t.attrs[i];
    n[this.attr] = this.value;
    let r = t.type.create(n, t.content, t.marks);
    return Cr.ok(r);
  }
  getMap() {
    return uo.empty;
  }
  invert(t) {
    return new bg(this.attr, t.attrs[this.attr]);
  }
  map(t) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(t, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new bg(n.attr, n.value);
  }
}
xi.jsonID("docAttr", bg);
let ph = class extends Error {
};
ph = function e(t) {
  let n = Error.call(this, t);
  return n.__proto__ = e.prototype, n;
};
ph.prototype = Object.create(Error.prototype);
ph.prototype.constructor = ph;
ph.prototype.name = "TransformError";
class IH {
  /**
  Create a transform that starts with the given document.
  */
  constructor(t) {
    this.doc = t, this.steps = [], this.docs = [], this.mapping = new vg();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(t) {
    let n = this.maybeStep(t);
    if (n.failed)
      throw new ph(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(t) {
    let n = t.apply(this.doc);
    return n.failed || this.addStep(t, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  Return a single range, in post-transform document positions,
  that covers all content changed by this transform. Returns null
  if no replacements are made. Note that this will ignore changes
  that add/remove marks without replacing the underlying content.
  */
  changedRange() {
    let t = 1e9, n = -1e9;
    for (let r = 0; r < this.mapping.maps.length; r++) {
      let i = this.mapping.maps[r];
      r && (t = i.map(t, 1), n = i.map(n, -1)), i.forEach((o, s, a, c) => {
        t = Math.min(t, a), n = Math.max(n, c);
      });
    }
    return t == 1e9 ? null : { from: t, to: n };
  }
  /**
  @internal
  */
  addStep(t, n) {
    this.docs.push(this.doc), this.steps.push(t), this.mapping.appendMap(t.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(t, n = t, r = Qe.empty) {
    let i = Kw(this.doc, t, n, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(t, n, r) {
    return this.replace(t, n, new Qe($e.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(t, n) {
    return this.replace(t, n, Qe.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(t, n) {
    return this.replaceWith(t, t, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(t, n, r) {
    return ANe(this, t, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(t, n, r) {
    return MNe(this, t, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(t, n) {
    return NNe(this, t, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(t, n) {
    return pNe(this, t, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(t, n = 1) {
    return kNe(this, t, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(t, n) {
    return yNe(this, t, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(t, n = t, r, i = null) {
    return vNe(this, t, n, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(t, n, r = null, i) {
    return xNe(this, t, n, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(t, n, r) {
    return this.step(new Qf(t, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(t, n) {
    return this.step(new bg(t, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(t, n) {
    return this.step(new dc(t, n)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(t, n) {
    let r = this.doc.nodeAt(t);
    if (!r)
      throw new RangeError("No node at position " + t);
    if (n instanceof En)
      n.isInSet(r.marks) && this.step(new id(t, n));
    else {
      let i = r.marks, o, s = [];
      for (; o = n.isInSet(i); )
        s.push(new id(t, o)), i = o.removeFromSet(i);
      for (let a = s.length - 1; a >= 0; a--)
        this.step(s[a]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(t, n = 1, r) {
    return wNe(this, t, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(t, n, r) {
    return dNe(this, t, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(t, n, r) {
    return fNe(this, t, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(t, n, r) {
    return mN(this, t, n, r), this;
  }
}
const GC = /* @__PURE__ */ Object.create(null);
class zt {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(t, n, r) {
    this.$anchor = t, this.$head = n, this.ranges = r || [new RNe(t.min(n), t.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let t = this.ranges;
    for (let n = 0; n < t.length; n++)
      if (t[n].$from.pos != t[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(t, n = Qe.empty) {
    let r = n.content.lastChild, i = null;
    for (let a = 0; a < n.openEnd; a++)
      i = r, r = r.lastChild;
    let o = t.steps.length, s = this.ranges;
    for (let a = 0; a < s.length; a++) {
      let { $from: c, $to: u } = s[a], f = t.mapping.slice(o);
      t.replaceRange(f.map(c.pos), f.map(u.pos), a ? Qe.empty : n), a == 0 && IL(t, o, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(t, n) {
    let r = t.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      let { $from: s, $to: a } = i[o], c = t.mapping.slice(r), u = c.map(s.pos), f = c.map(a.pos);
      o ? t.deleteRange(u, f) : (t.replaceRangeWith(u, f, n), IL(t, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(t, n, r = !1) {
    let i = t.parent.inlineContent ? new kt(t) : Af(t.node(0), t.parent, t.pos, t.index(), n, r);
    if (i)
      return i;
    for (let o = t.depth - 1; o >= 0; o--) {
      let s = n < 0 ? Af(t.node(0), t.node(o), t.before(o + 1), t.index(o), n, r) : Af(t.node(0), t.node(o), t.after(o + 1), t.index(o) + 1, n, r);
      if (s)
        return s;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(t, n = 1) {
    return this.findFrom(t, n) || this.findFrom(t, -n) || new mo(t.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(t) {
    return Af(t, t, 0, 0, 1) || new mo(t);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(t) {
    return Af(t, t, t.content.size, t.childCount, -1) || new mo(t);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(t, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = GC[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(t, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(t, n) {
    if (t in GC)
      throw new RangeError("Duplicate use of selection JSON ID " + t);
    return GC[t] = n, n.prototype.jsonID = t, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return kt.between(this.$anchor, this.$head).getBookmark();
  }
}
zt.prototype.visible = !0;
class RNe {
  /**
  Create a range.
  */
  constructor(t, n) {
    this.$from = t, this.$to = n;
  }
}
let PL = !1;
function jL(e) {
  !PL && !e.parent.inlineContent && (PL = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + e.parent.type.name + ")"));
}
class kt extends zt {
  /**
  Construct a text selection between the given points.
  */
  constructor(t, n = t) {
    jL(t), jL(n), super(t, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(t, n) {
    let r = t.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return zt.near(r);
    let i = t.resolve(n.map(this.anchor));
    return new kt(i.parent.inlineContent ? i : r, r);
  }
  replace(t, n = Qe.empty) {
    if (super.replace(t, n), n == Qe.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && t.ensureMarks(r);
    }
  }
  eq(t) {
    return t instanceof kt && t.anchor == this.anchor && t.head == this.head;
  }
  getBookmark() {
    return new Zw(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new kt(t.resolve(n.anchor), t.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(t, n, r = n) {
    let i = t.resolve(n);
    return new this(i, r == n ? i : t.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(t, n, r) {
    let i = t.pos - n.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let o = zt.findFrom(n, r, !0) || zt.findFrom(n, -r, !0);
      if (o)
        n = o.$head;
      else
        return zt.near(n, r);
    }
    return t.parent.inlineContent || (i == 0 ? t = n : (t = (zt.findFrom(t, -r, !0) || zt.findFrom(t, r, !0)).$anchor, t.pos < n.pos != i < 0 && (t = n))), new kt(t, n);
  }
}
zt.jsonID("text", kt);
class Zw {
  constructor(t, n) {
    this.anchor = t, this.head = n;
  }
  map(t) {
    return new Zw(t.map(this.anchor), t.map(this.head));
  }
  resolve(t) {
    return kt.between(t.resolve(this.anchor), t.resolve(this.head));
  }
}
class ht extends zt {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(t) {
    let n = t.nodeAfter, r = t.node(0).resolve(t.pos + n.nodeSize);
    super(t, r), this.node = n;
  }
  map(t, n) {
    let { deleted: r, pos: i } = n.mapResult(this.anchor), o = t.resolve(i);
    return r ? zt.near(o) : new ht(o);
  }
  content() {
    return new Qe($e.from(this.node), 0, 0);
  }
  eq(t) {
    return t instanceof ht && t.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new yN(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ht(t.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(t, n) {
    return new ht(t.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(t) {
    return !t.isText && t.type.spec.selectable !== !1;
  }
}
ht.prototype.visible = !1;
zt.jsonID("node", ht);
class yN {
  constructor(t) {
    this.anchor = t;
  }
  map(t) {
    let { deleted: n, pos: r } = t.mapResult(this.anchor);
    return n ? new Zw(r, r) : new yN(r);
  }
  resolve(t) {
    let n = t.resolve(this.anchor), r = n.nodeAfter;
    return r && ht.isSelectable(r) ? new ht(n) : zt.near(n);
  }
}
class mo extends zt {
  /**
  Create an all-selection over the given document.
  */
  constructor(t) {
    super(t.resolve(0), t.resolve(t.content.size));
  }
  replace(t, n = Qe.empty) {
    if (n == Qe.empty) {
      t.delete(0, t.doc.content.size);
      let r = zt.atStart(t.doc);
      r.eq(t.selection) || t.setSelection(r);
    } else
      super.replace(t, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(t) {
    return new mo(t);
  }
  map(t) {
    return new mo(t);
  }
  eq(t) {
    return t instanceof mo;
  }
  getBookmark() {
    return ONe;
  }
}
zt.jsonID("all", mo);
const ONe = {
  map() {
    return this;
  },
  resolve(e) {
    return new mo(e);
  }
};
function Af(e, t, n, r, i, o = !1) {
  if (t.inlineContent)
    return kt.create(e, n);
  for (let s = r - (i > 0 ? 0 : 1); i > 0 ? s < t.childCount : s >= 0; s += i) {
    let a = t.child(s);
    if (a.isAtom) {
      if (!o && ht.isSelectable(a))
        return ht.create(e, n - (i < 0 ? a.nodeSize : 0));
    } else {
      let c = Af(e, a, n + i, i < 0 ? a.childCount : 0, i, o);
      if (c)
        return c;
    }
    n += a.nodeSize * i;
  }
  return null;
}
function IL(e, t, n) {
  let r = e.steps.length - 1;
  if (r < t)
    return;
  let i = e.steps[r];
  if (!(i instanceof Ur || i instanceof Hr))
    return;
  let o = e.mapping.maps[r], s;
  o.forEach((a, c, u, f) => {
    s == null && (s = f);
  }), e.setSelection(zt.near(e.doc.resolve(s), n));
}
const zL = 1, Qv = 2, LL = 4;
class DNe extends IH {
  /**
  @internal
  */
  constructor(t) {
    super(t.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = t.selection, this.storedMarks = t.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(t) {
    if (t.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = t, this.curSelectionFor = this.steps.length, this.updated = (this.updated | zL) & ~Qv, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & zL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(t) {
    return this.storedMarks = t, this.updated |= Qv, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(t) {
    return En.sameSet(this.storedMarks || this.selection.$from.marks(), t) || this.setStoredMarks(t), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(t) {
    return this.ensureMarks(t.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(t) {
    return this.ensureMarks(t.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Qv) > 0;
  }
  /**
  @internal
  */
  addStep(t, n) {
    super.addStep(t, n), this.updated = this.updated & ~Qv, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(t) {
    return this.time = t, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(t) {
    return this.selection.replace(this, t), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(t, n = !0) {
    let r = this.selection;
    return n && (t = t.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || En.none))), r.replaceWith(this, t), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(t, n, r) {
    let i = this.doc.type.schema;
    if (n == null)
      return t ? this.replaceSelectionWith(i.text(t), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), !t)
        return this.deleteRange(n, r);
      let o = this.storedMarks;
      if (!o) {
        let s = this.doc.resolve(n);
        o = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, i.text(t, o)), !this.selection.empty && this.selection.to == n + t.length && this.setSelection(zt.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(t, n) {
    return this.meta[typeof t == "string" ? t : t.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(t) {
    return this.meta[typeof t == "string" ? t : t.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let t in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= LL, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & LL) > 0;
  }
}
function BL(e, t) {
  return !t || !e ? e : e.bind(t);
}
class ym {
  constructor(t, n, r) {
    this.name = t, this.init = BL(n.init, r), this.apply = BL(n.apply, r);
  }
}
const PNe = [
  new ym("doc", {
    init(e) {
      return e.doc || e.schema.topNodeType.createAndFill();
    },
    apply(e) {
      return e.doc;
    }
  }),
  new ym("selection", {
    init(e, t) {
      return e.selection || zt.atStart(t.doc);
    },
    apply(e) {
      return e.selection;
    }
  }),
  new ym("storedMarks", {
    init(e) {
      return e.storedMarks || null;
    },
    apply(e, t, n, r) {
      return r.selection.$cursor ? e.storedMarks : null;
    }
  }),
  new ym("scrollToSelection", {
    init() {
      return 0;
    },
    apply(e, t) {
      return e.scrolledIntoView ? t + 1 : t;
    }
  })
];
class KC {
  constructor(t, n) {
    this.schema = t, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = PNe.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new ym(r.key, r.spec.state, r));
    });
  }
}
class Ff {
  /**
  @internal
  */
  constructor(t) {
    this.config = t;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(t) {
    return this.applyTransaction(t).state;
  }
  /**
  @internal
  */
  filterTransaction(t, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, t, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(t) {
    if (!this.filterTransaction(t))
      return { state: this, transactions: [] };
    let n = [t], r = this.applyInner(t), i = null;
    for (; ; ) {
      let o = !1;
      for (let s = 0; s < this.config.plugins.length; s++) {
        let a = this.config.plugins[s];
        if (a.spec.appendTransaction) {
          let c = i ? i[s].n : 0, u = i ? i[s].state : this, f = c < n.length && a.spec.appendTransaction.call(a, c ? n.slice(c) : n, u, r);
          if (f && r.filterTransaction(f, s)) {
            if (f.setMeta("appendedTransaction", t), !i) {
              i = [];
              for (let h = 0; h < this.config.plugins.length; h++)
                i.push(h < s ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(f), r = r.applyInner(f), o = !0;
          }
          i && (i[s] = { state: r, n: n.length });
        }
      }
      if (!o)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(t) {
    if (!t.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Ff(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let o = r[i];
      n[o.name] = o.apply(t, this[o.name], this, n);
    }
    return n;
  }
  /**
  Accessor that constructs and returns a new [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new DNe(this);
  }
  /**
  Create a new state.
  */
  static create(t) {
    let n = new KC(t.doc ? t.doc.type.schema : t.schema, t.plugins), r = new Ff(n);
    for (let i = 0; i < n.fields.length; i++)
      r[n.fields[i].name] = n.fields[i].init(t, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(t) {
    let n = new KC(this.schema, t.plugins), r = n.fields, i = new Ff(n);
    for (let o = 0; o < r.length; o++) {
      let s = r[o].name;
      i[s] = this.hasOwnProperty(s) ? this[s] : r[o].init(t, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(t) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), t && typeof t == "object")
      for (let r in t) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = t[r], o = i.spec.state;
        o && o.toJSON && (n[r] = o.toJSON.call(i, this[i.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(t, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!t.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new KC(t.schema, t.plugins), o = new Ff(i);
    return i.fields.forEach((s) => {
      if (s.name == "doc")
        o.doc = gc.fromJSON(t.schema, n.doc);
      else if (s.name == "selection")
        o.selection = zt.fromJSON(o.doc, n.selection);
      else if (s.name == "storedMarks")
        n.storedMarks && (o.storedMarks = n.storedMarks.map(t.schema.markFromJSON));
      else {
        if (r)
          for (let a in r) {
            let c = r[a], u = c.spec.state;
            if (c.key == s.name && u && u.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              o[s.name] = u.fromJSON.call(c, t, n[a], o);
              return;
            }
          }
        o[s.name] = s.init(t, o);
      }
    }), o;
  }
}
function zH(e, t, n) {
  for (let r in e) {
    let i = e[r];
    i instanceof Function ? i = i.bind(t) : r == "handleDOMEvents" && (i = zH(i, t, {})), n[r] = i;
  }
  return n;
}
class Zn {
  /**
  Create a plugin.
  */
  constructor(t) {
    this.spec = t, this.props = {}, t.props && zH(t.props, this, this.props), this.key = t.key ? t.key.key : LH("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(t) {
    return t[this.key];
  }
}
const ZC = /* @__PURE__ */ Object.create(null);
function LH(e) {
  return e in ZC ? e + "$" + ++ZC[e] : (ZC[e] = 0, e + "$");
}
class Tr {
  /**
  Create a plugin key.
  */
  constructor(t = "key") {
    this.key = LH(t);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(t) {
    return t.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(t) {
    return t[this.key];
  }
}
const vN = (e, t) => e.selection.empty ? !1 : (t && t(e.tr.deleteSelection().scrollIntoView()), !0);
function BH(e, t) {
  let { $cursor: n } = e.selection;
  return !n || (t ? !t.endOfTextblock("backward", e) : n.parentOffset > 0) ? null : n;
}
const $H = (e, t, n) => {
  let r = BH(e, n);
  if (!r)
    return !1;
  let i = bN(r);
  if (!i) {
    let s = r.blockRange(), a = s && Hh(s);
    return a == null ? !1 : (t && t(e.tr.lift(s, a).scrollIntoView()), !0);
  }
  let o = i.nodeBefore;
  if (ZH(e, i, t, -1))
    return !0;
  if (r.parent.content.size == 0 && (mh(o, "end") || ht.isSelectable(o)))
    for (let s = r.depth; ; s--) {
      let a = Kw(e.doc, r.before(s), r.after(s), Qe.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (t) {
          let c = e.tr.step(a);
          c.setSelection(mh(o, "end") ? zt.findFrom(c.doc.resolve(c.mapping.map(i.pos, -1)), -1) : ht.create(c.doc, i.pos - o.nodeSize)), t(c.scrollIntoView());
        }
        return !0;
      }
      if (s == 1 || r.node(s - 1).childCount > 1)
        break;
    }
  return o.isAtom && i.depth == r.depth - 1 ? (t && t(e.tr.delete(i.pos - o.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, jNe = (e, t, n) => {
  let r = BH(e, n);
  if (!r)
    return !1;
  let i = bN(r);
  return i ? UH(e, i, t) : !1;
}, INe = (e, t, n) => {
  let r = VH(e, n);
  if (!r)
    return !1;
  let i = xN(r);
  return i ? UH(e, i, t) : !1;
};
function UH(e, t, n) {
  let r = t.nodeBefore, i = r, o = t.pos - 1;
  for (; !i.isTextblock; o--) {
    if (i.type.spec.isolating)
      return !1;
    let f = i.lastChild;
    if (!f)
      return !1;
    i = f;
  }
  let s = t.nodeAfter, a = s, c = t.pos + 1;
  for (; !a.isTextblock; c++) {
    if (a.type.spec.isolating)
      return !1;
    let f = a.firstChild;
    if (!f)
      return !1;
    a = f;
  }
  let u = Kw(e.doc, o, c, Qe.empty);
  if (!u || u.from != o || u instanceof Ur && u.slice.size >= c - o)
    return !1;
  if (n) {
    let f = e.tr.step(u);
    f.setSelection(kt.create(f.doc, o)), n(f.scrollIntoView());
  }
  return !0;
}
function mh(e, t, n = !1) {
  for (let r = e; r; r = t == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const FH = (e, t, n) => {
  let { $head: r, empty: i } = e.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0)
      return !1;
    o = bN(r);
  }
  let s = o && o.nodeBefore;
  return !s || !ht.isSelectable(s) ? !1 : (t && t(e.tr.setSelection(ht.create(e.doc, o.pos - s.nodeSize)).scrollIntoView()), !0);
};
function bN(e) {
  if (!e.parent.type.spec.isolating)
    for (let t = e.depth - 1; t >= 0; t--) {
      if (e.index(t) > 0)
        return e.doc.resolve(e.before(t + 1));
      if (e.node(t).type.spec.isolating)
        break;
    }
  return null;
}
function VH(e, t) {
  let { $cursor: n } = e.selection;
  return !n || (t ? !t.endOfTextblock("forward", e) : n.parentOffset < n.parent.content.size) ? null : n;
}
const HH = (e, t, n) => {
  let r = VH(e, n);
  if (!r)
    return !1;
  let i = xN(r);
  if (!i)
    return !1;
  let o = i.nodeAfter;
  if (ZH(e, i, t, 1))
    return !0;
  if (r.parent.content.size == 0 && (mh(o, "start") || ht.isSelectable(o))) {
    let s = Kw(e.doc, r.before(), r.after(), Qe.empty);
    if (s && s.slice.size < s.to - s.from) {
      if (t) {
        let a = e.tr.step(s);
        a.setSelection(mh(o, "start") ? zt.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1) : ht.create(a.doc, a.mapping.map(i.pos))), t(a.scrollIntoView());
      }
      return !0;
    }
  }
  return o.isAtom && i.depth == r.depth - 1 ? (t && t(e.tr.delete(i.pos, i.pos + o.nodeSize).scrollIntoView()), !0) : !1;
}, WH = (e, t, n) => {
  let { $head: r, empty: i } = e.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size)
      return !1;
    o = xN(r);
  }
  let s = o && o.nodeAfter;
  return !s || !ht.isSelectable(s) ? !1 : (t && t(e.tr.setSelection(ht.create(e.doc, o.pos)).scrollIntoView()), !0);
};
function xN(e) {
  if (!e.parent.type.spec.isolating)
    for (let t = e.depth - 1; t >= 0; t--) {
      let n = e.node(t);
      if (e.index(t) + 1 < n.childCount)
        return e.doc.resolve(e.after(t + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const zNe = (e, t) => {
  let n = e.selection, r = n instanceof ht, i;
  if (r) {
    if (n.node.isTextblock || !Fc(e.doc, n.from))
      return !1;
    i = n.from;
  } else if (i = Gw(e.doc, n.from, -1), i == null)
    return !1;
  if (t) {
    let o = e.tr.join(i);
    r && o.setSelection(ht.create(o.doc, i - e.doc.resolve(i).nodeBefore.nodeSize)), t(o.scrollIntoView());
  }
  return !0;
}, LNe = (e, t) => {
  let n = e.selection, r;
  if (n instanceof ht) {
    if (n.node.isTextblock || !Fc(e.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = Gw(e.doc, n.to, 1), r == null)
    return !1;
  return t && t(e.tr.join(r).scrollIntoView()), !0;
}, BNe = (e, t) => {
  let { $from: n, $to: r } = e.selection, i = n.blockRange(r), o = i && Hh(i);
  return o == null ? !1 : (t && t(e.tr.lift(i, o).scrollIntoView()), !0);
}, qH = (e, t) => {
  let { $head: n, $anchor: r } = e.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (t && t(e.tr.insertText(`
`).scrollIntoView()), !0);
};
function wN(e) {
  for (let t = 0; t < e.edgeCount; t++) {
    let { type: n } = e.edge(t);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const $Ne = (e, t) => {
  let { $head: n, $anchor: r } = e.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let i = n.node(-1), o = n.indexAfter(-1), s = wN(i.contentMatchAt(o));
  if (!s || !i.canReplaceWith(o, o, s))
    return !1;
  if (t) {
    let a = n.after(), c = e.tr.replaceWith(a, a, s.createAndFill());
    c.setSelection(zt.near(c.doc.resolve(a), 1)), t(c.scrollIntoView());
  }
  return !0;
}, GH = (e, t) => {
  let n = e.selection, { $from: r, $to: i } = n;
  if (n instanceof mo || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let o = wN(i.parent.contentMatchAt(i.indexAfter()));
  if (!o || !o.isTextblock)
    return !1;
  if (t) {
    let s = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, a = e.tr.insert(s, o.createAndFill());
    a.setSelection(kt.create(a.doc, s + 1)), t(a.scrollIntoView());
  }
  return !0;
}, KH = (e, t) => {
  let { $cursor: n } = e.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let o = n.before();
    if (Ga(e.doc, o))
      return t && t(e.tr.split(o).scrollIntoView()), !0;
  }
  let r = n.blockRange(), i = r && Hh(r);
  return i == null ? !1 : (t && t(e.tr.lift(r, i).scrollIntoView()), !0);
};
function UNe(e) {
  return (t, n) => {
    let { $from: r, $to: i } = t.selection;
    if (t.selection instanceof ht && t.selection.node.isBlock)
      return !r.parentOffset || !Ga(t.doc, r.pos) ? !1 : (n && n(t.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let o = [], s, a, c = !1, u = !1;
    for (let g = r.depth; ; g--)
      if (r.node(g).isBlock) {
        c = r.end(g) == r.pos + (r.depth - g), u = r.start(g) == r.pos - (r.depth - g), a = wN(r.node(g - 1).contentMatchAt(r.indexAfter(g - 1))), o.unshift(c && a ? { type: a } : null), s = g;
        break;
      } else {
        if (g == 1)
          return !1;
        o.unshift(null);
      }
    let f = t.tr;
    (t.selection instanceof kt || t.selection instanceof mo) && f.deleteSelection();
    let h = f.mapping.map(r.pos), m = Ga(f.doc, h, o.length, o);
    if (m || (o[0] = a ? { type: a } : null, m = Ga(f.doc, h, o.length, o)), !m)
      return !1;
    if (f.split(h, o.length, o), !c && u && r.node(s).type != a) {
      let g = f.mapping.map(r.before(s)), b = f.doc.resolve(g);
      a && r.node(s - 1).canReplaceWith(b.index(), b.index() + 1, a) && f.setNodeMarkup(f.mapping.map(r.before(s)), a);
    }
    return n && n(f.scrollIntoView()), !0;
  };
}
const FNe = UNe(), VNe = (e, t) => {
  let { $from: n, to: r } = e.selection, i, o = n.sharedDepth(r);
  return o == 0 ? !1 : (i = n.before(o), t && t(e.tr.setSelection(ht.create(e.doc, i))), !0);
};
function HNe(e, t, n) {
  let r = t.nodeBefore, i = t.nodeAfter, o = t.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && t.parent.canReplace(o - 1, o) ? (n && n(e.tr.delete(t.pos - r.nodeSize, t.pos).scrollIntoView()), !0) : !t.parent.canReplace(o, o + 1) || !(i.isTextblock || Fc(e.doc, t.pos)) ? !1 : (n && n(e.tr.join(t.pos).scrollIntoView()), !0);
}
function ZH(e, t, n, r) {
  let i = t.nodeBefore, o = t.nodeAfter, s, a, c = i.type.spec.isolating || o.type.spec.isolating;
  if (!c && HNe(e, t, n))
    return !0;
  let u = !c && t.parent.canReplace(t.index(), t.index() + 1);
  if (u && (s = (a = i.contentMatchAt(i.childCount)).findWrapping(o.type)) && a.matchType(s[0] || o.type).validEnd) {
    if (n) {
      let g = t.pos + o.nodeSize, b = $e.empty;
      for (let S = s.length - 1; S >= 0; S--)
        b = $e.from(s[S].create(null, b));
      b = $e.from(i.copy(b));
      let x = e.tr.step(new Hr(t.pos - 1, g, t.pos, g, new Qe(b, 1, 0), s.length, !0)), w = x.doc.resolve(g + 2 * s.length);
      w.nodeAfter && w.nodeAfter.type == i.type && Fc(x.doc, w.pos) && x.join(w.pos), n(x.scrollIntoView());
    }
    return !0;
  }
  let f = o.type.spec.isolating || r > 0 && c ? null : zt.findFrom(t, 1), h = f && f.$from.blockRange(f.$to), m = h && Hh(h);
  if (m != null && m >= t.depth)
    return n && n(e.tr.lift(h, m).scrollIntoView()), !0;
  if (u && mh(o, "start", !0) && mh(i, "end")) {
    let g = i, b = [];
    for (; b.push(g), !g.isTextblock; )
      g = g.lastChild;
    let x = o, w = 1;
    for (; !x.isTextblock; x = x.firstChild)
      w++;
    if (g.canReplace(g.childCount, g.childCount, x.content)) {
      if (n) {
        let S = $e.empty;
        for (let M = b.length - 1; M >= 0; M--)
          S = $e.from(b[M].copy(S));
        let _ = e.tr.step(new Hr(t.pos - b.length, t.pos + o.nodeSize, t.pos + w, t.pos + o.nodeSize - w, new Qe(S, b.length, 0), 0, !0));
        n(_.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function YH(e) {
  return function(t, n) {
    let r = t.selection, i = e < 0 ? r.$from : r.$to, o = i.depth;
    for (; i.node(o).isInline; ) {
      if (!o)
        return !1;
      o--;
    }
    return i.node(o).isTextblock ? (n && n(t.tr.setSelection(kt.create(t.doc, e < 0 ? i.start(o) : i.end(o)))), !0) : !1;
  };
}
const WNe = YH(-1), qNe = YH(1);
function GNe(e, t = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, s = i.blockRange(o), a = s && gN(s, e, t);
    return a ? (r && r(n.tr.wrap(s, a).scrollIntoView()), !0) : !1;
  };
}
function $L(e, t = null) {
  return function(n, r) {
    let i = !1;
    for (let o = 0; o < n.selection.ranges.length && !i; o++) {
      let { $from: { pos: s }, $to: { pos: a } } = n.selection.ranges[o];
      n.doc.nodesBetween(s, a, (c, u) => {
        if (i)
          return !1;
        if (!(!c.isTextblock || c.hasMarkup(e, t)))
          if (c.type == e)
            i = !0;
          else {
            let f = n.doc.resolve(u), h = f.index();
            i = f.parent.canReplaceWith(h, h + 1, e);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let o = n.tr;
      for (let s = 0; s < n.selection.ranges.length; s++) {
        let { $from: { pos: a }, $to: { pos: c } } = n.selection.ranges[s];
        o.setBlockType(a, c, e, t);
      }
      r(o.scrollIntoView());
    }
    return !0;
  };
}
function SN(...e) {
  return function(t, n, r) {
    for (let i = 0; i < e.length; i++)
      if (e[i](t, n, r))
        return !0;
    return !1;
  };
}
SN(vN, $H, FH);
SN(vN, HH, WH);
SN(qH, GH, KH, FNe);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function KNe(e, t = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, s = i.blockRange(o);
    if (!s)
      return !1;
    let a = r ? n.tr : null;
    return ZNe(a, s, e, t) ? (r && r(a.scrollIntoView()), !0) : !1;
  };
}
function ZNe(e, t, n, r = null) {
  let i = !1, o = t, s = t.$from.doc;
  if (t.depth >= 2 && t.$from.node(t.depth - 1).type.compatibleContent(n) && t.startIndex == 0) {
    if (t.$from.index(t.depth - 1) == 0)
      return !1;
    let c = s.resolve(t.start - 2);
    o = new ex(c, c, t.depth), t.endIndex < t.parent.childCount && (t = new ex(t.$from, s.resolve(t.$to.end(t.depth)), t.depth)), i = !0;
  }
  let a = gN(o, n, r, t);
  return a ? (e && YNe(e, t, a, i, n), !0) : !1;
}
function YNe(e, t, n, r, i) {
  let o = $e.empty;
  for (let f = n.length - 1; f >= 0; f--)
    o = $e.from(n[f].type.create(n[f].attrs, o));
  e.step(new Hr(t.start - (r ? 2 : 0), t.end, t.start, t.end, new Qe(o, 0, 0), n.length, !0));
  let s = 0;
  for (let f = 0; f < n.length; f++)
    n[f].type == i && (s = f + 1);
  let a = n.length - s, c = t.start + n.length - (r ? 2 : 0), u = t.parent;
  for (let f = t.startIndex, h = t.endIndex, m = !0; f < h; f++, m = !1)
    !m && Ga(e.doc, c, a) && (e.split(c, a), c += 2 * a), c += u.child(f).nodeSize;
  return e;
}
function XNe(e) {
  return function(t, n) {
    let { $from: r, $to: i } = t.selection, o = r.blockRange(i, (s) => s.childCount > 0 && s.firstChild.type == e);
    return o ? n ? r.node(o.depth - 1).type == e ? JNe(t, n, e, o) : QNe(t, n, o) : !0 : !1;
  };
}
function JNe(e, t, n, r) {
  let i = e.tr, o = r.end, s = r.$to.end(r.depth);
  o < s && (i.step(new Hr(o - 1, s, o, s, new Qe($e.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new ex(i.doc.resolve(r.$from.pos), i.doc.resolve(s), r.depth));
  const a = Hh(r);
  if (a == null)
    return !1;
  i.lift(r, a);
  let c = i.doc.resolve(i.mapping.map(o, -1) - 1);
  return Fc(i.doc, c.pos) && c.nodeBefore.type == c.nodeAfter.type && i.join(c.pos), t(i.scrollIntoView()), !0;
}
function QNe(e, t, n) {
  let r = e.tr, i = n.parent;
  for (let g = n.end, b = n.endIndex - 1, x = n.startIndex; b > x; b--)
    g -= i.child(b).nodeSize, r.delete(g - 1, g + 1);
  let o = r.doc.resolve(n.start), s = o.nodeAfter;
  if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, c = n.endIndex == i.childCount, u = o.node(-1), f = o.index(-1);
  if (!u.canReplace(f + (a ? 0 : 1), f + 1, s.content.append(c ? $e.empty : $e.from(i))))
    return !1;
  let h = o.pos, m = h + s.nodeSize;
  return r.step(new Hr(h - (a ? 1 : 0), m + (c ? 1 : 0), h + 1, m - 1, new Qe((a ? $e.empty : $e.from(i.copy($e.empty))).append(c ? $e.empty : $e.from(i.copy($e.empty))), a ? 0 : 1, c ? 0 : 1), a ? 0 : 1)), t(r.scrollIntoView()), !0;
}
function eRe(e) {
  return function(t, n) {
    let { $from: r, $to: i } = t.selection, o = r.blockRange(i, (u) => u.childCount > 0 && u.firstChild.type == e);
    if (!o)
      return !1;
    let s = o.startIndex;
    if (s == 0)
      return !1;
    let a = o.parent, c = a.child(s - 1);
    if (c.type != e)
      return !1;
    if (n) {
      let u = c.lastChild && c.lastChild.type == a.type, f = $e.from(u ? e.create() : null), h = new Qe($e.from(e.create(null, $e.from(a.type.create(null, f)))), u ? 3 : 1, 0), m = o.start, g = o.end;
      n(t.tr.step(new Hr(m - (u ? 3 : 1), g, m, g, h, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
const ti = function(e) {
  for (var t = 0; ; t++)
    if (e = e.previousSibling, !e)
      return t;
}, gh = function(e) {
  let t = e.assignedSlot || e.parentNode;
  return t && t.nodeType == 11 ? t.host : t;
};
let pT = null;
const $a = function(e, t, n) {
  let r = pT || (pT = document.createRange());
  return r.setEnd(e, n ?? e.nodeValue.length), r.setStart(e, t || 0), r;
}, tRe = function() {
  pT = null;
}, od = function(e, t, n, r) {
  return n && (UL(e, t, n, r, -1) || UL(e, t, n, r, 1));
}, nRe = /^(img|br|input|textarea|hr)$/i;
function UL(e, t, n, r, i) {
  for (var o; ; ) {
    if (e == n && t == r)
      return !0;
    if (t == (i < 0 ? 0 : zo(e))) {
      let s = e.parentNode;
      if (!s || s.nodeType != 1 || sy(e) || nRe.test(e.nodeName) || e.contentEditable == "false")
        return !1;
      t = ti(e) + (i < 0 ? 0 : 1), e = s;
    } else if (e.nodeType == 1) {
      let s = e.childNodes[t + (i < 0 ? -1 : 0)];
      if (s.nodeType == 1 && s.contentEditable == "false")
        if (!((o = s.pmViewDesc) === null || o === void 0) && o.ignoreForSelection)
          t += i;
        else
          return !1;
      else
        e = s, t = i < 0 ? zo(e) : 0;
    } else
      return !1;
  }
}
function zo(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length;
}
function rRe(e, t) {
  for (; ; ) {
    if (e.nodeType == 3 && t)
      return e;
    if (e.nodeType == 1 && t > 0) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[t - 1], t = zo(e);
    } else if (e.parentNode && !sy(e))
      t = ti(e), e = e.parentNode;
    else
      return null;
  }
}
function iRe(e, t) {
  for (; ; ) {
    if (e.nodeType == 3 && t < e.nodeValue.length)
      return e;
    if (e.nodeType == 1 && t < e.childNodes.length) {
      if (e.contentEditable == "false")
        return null;
      e = e.childNodes[t], t = 0;
    } else if (e.parentNode && !sy(e))
      t = ti(e) + 1, e = e.parentNode;
    else
      return null;
  }
}
function oRe(e, t, n) {
  for (let r = t == 0, i = t == zo(e); r || i; ) {
    if (e == n)
      return !0;
    let o = ti(e);
    if (e = e.parentNode, !e)
      return !1;
    r = r && o == 0, i = i && o == zo(e);
  }
}
function sy(e) {
  let t;
  for (let n = e; n && !(t = n.pmViewDesc); n = n.parentNode)
    ;
  return t && t.node && t.node.isBlock && (t.dom == e || t.contentDOM == e);
}
const Yw = function(e) {
  return e.focusNode && od(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset);
};
function Nu(e, t) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = e, n.key = n.code = t, n;
}
function sRe(e) {
  let t = e.activeElement;
  for (; t && t.shadowRoot; )
    t = t.shadowRoot.activeElement;
  return t;
}
function aRe(e, t, n) {
  if (e.caretPositionFromPoint)
    try {
      let r = e.caretPositionFromPoint(t, n);
      if (r)
        return { node: r.offsetNode, offset: Math.min(zo(r.offsetNode), r.offset) };
    } catch {
    }
  if (e.caretRangeFromPoint) {
    let r = e.caretRangeFromPoint(t, n);
    if (r)
      return { node: r.startContainer, offset: Math.min(zo(r.startContainer), r.startOffset) };
  }
}
const Qs = typeof navigator < "u" ? navigator : null, FL = typeof document < "u" ? document : null, Vc = Qs && Qs.userAgent || "", mT = /Edge\/(\d+)/.exec(Vc), XH = /MSIE \d/.exec(Vc), gT = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Vc), Ki = !!(XH || gT || mT), vc = XH ? document.documentMode : gT ? +gT[1] : mT ? +mT[1] : 0, Vo = !Ki && /gecko\/(\d+)/i.test(Vc);
Vo && +(/Firefox\/(\d+)/.exec(Vc) || [0, 0])[1];
const yT = !Ki && /Chrome\/(\d+)/.exec(Vc), Vr = !!yT, JH = yT ? +yT[1] : 0, ii = !Ki && !!Qs && /Apple Computer/.test(Qs.vendor), yh = ii && (/Mobile\/\w+/.test(Vc) || !!Qs && Qs.maxTouchPoints > 2), jo = yh || (Qs ? /Mac/.test(Qs.platform) : !1), QH = Qs ? /Win/.test(Qs.platform) : !1, Ha = /Android \d/.test(Vc), ay = !!FL && "webkitFontSmoothing" in FL.documentElement.style, lRe = ay ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function cRe(e) {
  let t = e.defaultView && e.defaultView.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: e.documentElement.clientWidth,
    top: 0,
    bottom: e.documentElement.clientHeight
  };
}
function Pa(e, t) {
  return typeof e == "number" ? e : e[t];
}
function uRe(e) {
  let t = e.getBoundingClientRect(), n = t.width / e.offsetWidth || 1, r = t.height / e.offsetHeight || 1;
  return {
    left: t.left,
    right: t.left + e.clientWidth * n,
    top: t.top,
    bottom: t.top + e.clientHeight * r
  };
}
function VL(e, t, n) {
  let r = e.someProp("scrollThreshold") || 0, i = e.someProp("scrollMargin") || 5, o = e.dom.ownerDocument;
  for (let s = n || e.dom; s; ) {
    if (s.nodeType != 1) {
      s = gh(s);
      continue;
    }
    let a = s, c = a == o.body, u = c ? cRe(o) : uRe(a), f = 0, h = 0;
    if (t.top < u.top + Pa(r, "top") ? h = -(u.top - t.top + Pa(i, "top")) : t.bottom > u.bottom - Pa(r, "bottom") && (h = t.bottom - t.top > u.bottom - u.top ? t.top + Pa(i, "top") - u.top : t.bottom - u.bottom + Pa(i, "bottom")), t.left < u.left + Pa(r, "left") ? f = -(u.left - t.left + Pa(i, "left")) : t.right > u.right - Pa(r, "right") && (f = t.right - u.right + Pa(i, "right")), f || h)
      if (c)
        o.defaultView.scrollBy(f, h);
      else {
        let g = a.scrollLeft, b = a.scrollTop;
        h && (a.scrollTop += h), f && (a.scrollLeft += f);
        let x = a.scrollLeft - g, w = a.scrollTop - b;
        t = { left: t.left - x, top: t.top - w, right: t.right - x, bottom: t.bottom - w };
      }
    let m = c ? "fixed" : getComputedStyle(s).position;
    if (/^(fixed|sticky)$/.test(m))
      break;
    s = m == "absolute" ? s.offsetParent : gh(s);
  }
}
function dRe(e) {
  let t = e.dom.getBoundingClientRect(), n = Math.max(0, t.top), r, i;
  for (let o = (t.left + t.right) / 2, s = n + 1; s < Math.min(innerHeight, t.bottom); s += 5) {
    let a = e.root.elementFromPoint(o, s);
    if (!a || a == e.dom || !e.dom.contains(a))
      continue;
    let c = a.getBoundingClientRect();
    if (c.top >= n - 20) {
      r = a, i = c.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: eW(e.dom) };
}
function eW(e) {
  let t = [], n = e.ownerDocument;
  for (let r = e; r && (t.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), e != n); r = gh(r))
    ;
  return t;
}
function fRe({ refDOM: e, refTop: t, stack: n }) {
  let r = e ? e.getBoundingClientRect().top : 0;
  tW(n, r == 0 ? 0 : r - t);
}
function tW(e, t) {
  for (let n = 0; n < e.length; n++) {
    let { dom: r, top: i, left: o } = e[n];
    r.scrollTop != i + t && (r.scrollTop = i + t), r.scrollLeft != o && (r.scrollLeft = o);
  }
}
let vf = null;
function hRe(e) {
  if (e.setActive)
    return e.setActive();
  if (vf)
    return e.focus(vf);
  let t = eW(e);
  e.focus(vf == null ? {
    get preventScroll() {
      return vf = { preventScroll: !0 }, !0;
    }
  } : void 0), vf || (vf = !1, tW(t, 0));
}
function nW(e, t) {
  let n, r = 2e8, i, o = 0, s = t.top, a = t.top, c, u;
  for (let f = e.firstChild, h = 0; f; f = f.nextSibling, h++) {
    let m;
    if (f.nodeType == 1)
      m = f.getClientRects();
    else if (f.nodeType == 3)
      m = $a(f).getClientRects();
    else
      continue;
    for (let g = 0; g < m.length; g++) {
      let b = m[g];
      if (b.top <= s && b.bottom >= a) {
        s = Math.max(b.bottom, s), a = Math.min(b.top, a);
        let x = b.left > t.left ? b.left - t.left : b.right < t.left ? t.left - b.right : 0;
        if (x < r) {
          n = f, r = x, i = x && n.nodeType == 3 ? {
            left: b.right < t.left ? b.right : b.left,
            top: t.top
          } : t, f.nodeType == 1 && x && (o = h + (t.left >= (b.left + b.right) / 2 ? 1 : 0));
          continue;
        }
      } else b.top > t.top && !c && b.left <= t.left && b.right >= t.left && (c = f, u = { left: Math.max(b.left, Math.min(b.right, t.left)), top: b.top });
      !n && (t.left >= b.right && t.top >= b.top || t.left >= b.left && t.top >= b.bottom) && (o = h + 1);
    }
  }
  return !n && c && (n = c, i = u, r = 0), n && n.nodeType == 3 ? pRe(n, i) : !n || r && n.nodeType == 1 ? { node: e, offset: o } : nW(n, i);
}
function pRe(e, t) {
  let n = e.nodeValue.length, r = document.createRange(), i;
  for (let o = 0; o < n; o++) {
    r.setEnd(e, o + 1), r.setStart(e, o);
    let s = Jl(r, 1);
    if (s.top != s.bottom && kN(t, s)) {
      i = { node: e, offset: o + (t.left >= (s.left + s.right) / 2 ? 1 : 0) };
      break;
    }
  }
  return r.detach(), i || { node: e, offset: 0 };
}
function kN(e, t) {
  return e.left >= t.left - 1 && e.left <= t.right + 1 && e.top >= t.top - 1 && e.top <= t.bottom + 1;
}
function mRe(e, t) {
  let n = e.parentNode;
  return n && /^li$/i.test(n.nodeName) && t.left < e.getBoundingClientRect().left ? n : e;
}
function gRe(e, t, n) {
  let { node: r, offset: i } = nW(t, n), o = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let s = r.getBoundingClientRect();
    o = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
  }
  return e.docView.posFromDOM(r, i, o);
}
function yRe(e, t, n, r) {
  let i = -1;
  for (let o = t, s = !1; o != e.dom; ) {
    let a = e.docView.nearestDesc(o, !0), c;
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((c = a.dom.getBoundingClientRect()).width || c.height) && (a.node.isBlock && a.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(a.dom.nodeName) && (!s && c.left > r.left || c.top > r.top ? i = a.posBefore : (!s && c.right < r.left || c.bottom < r.top) && (i = a.posAfter), s = !0), !a.contentDOM && i < 0 && !a.node.isText))
      return (a.node.isBlock ? r.top < (c.top + c.bottom) / 2 : r.left < (c.left + c.right) / 2) ? a.posBefore : a.posAfter;
    o = a.dom.parentNode;
  }
  return i > -1 ? i : e.docView.posFromDOM(t, n, -1);
}
function rW(e, t, n) {
  let r = e.childNodes.length;
  if (r && n.top < n.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (t.top - n.top) / (n.bottom - n.top)) - 2)), o = i; ; ) {
      let s = e.childNodes[o];
      if (s.nodeType == 1) {
        let a = s.getClientRects();
        for (let c = 0; c < a.length; c++) {
          let u = a[c];
          if (kN(t, u))
            return rW(s, t, u);
        }
      }
      if ((o = (o + 1) % r) == i)
        break;
    }
  return e;
}
function vRe(e, t) {
  let n = e.dom.ownerDocument, r, i = 0, o = aRe(n, t.left, t.top);
  o && ({ node: r, offset: i } = o);
  let s = (e.root.elementFromPoint ? e.root : n).elementFromPoint(t.left, t.top), a;
  if (!s || !e.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let u = e.dom.getBoundingClientRect();
    if (!kN(t, u) || (s = rW(e.dom, t, u), !s))
      return null;
  }
  if (ii)
    for (let u = s; r && u; u = gh(u))
      u.draggable && (r = void 0);
  if (s = mRe(s, t), r) {
    if (Vo && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let f = r.childNodes[i], h;
      f.nodeName == "IMG" && (h = f.getBoundingClientRect()).right <= t.left && h.bottom > t.top && i++;
    }
    let u;
    ay && i && r.nodeType == 1 && (u = r.childNodes[i - 1]).nodeType == 1 && u.contentEditable == "false" && u.getBoundingClientRect().top >= t.top && i--, r == e.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && t.top > r.lastChild.getBoundingClientRect().bottom ? a = e.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (a = yRe(e, r, i, t));
  }
  a == null && (a = gRe(e, s, t));
  let c = e.docView.nearestDesc(s, !0);
  return { pos: a, inside: c ? c.posAtStart - c.border : -1 };
}
function HL(e) {
  return e.top < e.bottom || e.left < e.right;
}
function Jl(e, t) {
  let n = e.getClientRects();
  if (n.length) {
    let r = n[t < 0 ? 0 : n.length - 1];
    if (HL(r))
      return r;
  }
  return Array.prototype.find.call(n, HL) || e.getBoundingClientRect();
}
const bRe = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function iW(e, t, n) {
  let { node: r, offset: i, atom: o } = e.docView.domFromPos(t, n < 0 ? -1 : 1), s = ay || Vo;
  if (r.nodeType == 3)
    if (s && (bRe.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
      let c = Jl($a(r, i, i), n);
      if (Vo && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let u = Jl($a(r, i - 1, i - 1), -1);
        if (u.top == c.top) {
          let f = Jl($a(r, i, i + 1), -1);
          if (f.top != c.top)
            return tm(f, f.left < u.left);
        }
      }
      return c;
    } else {
      let c = i, u = i, f = n < 0 ? 1 : -1;
      return n < 0 && !i ? (u++, f = -1) : n >= 0 && i == r.nodeValue.length ? (c--, f = 1) : n < 0 ? c-- : u++, tm(Jl($a(r, c, u), f), f < 0);
    }
  if (!e.state.doc.resolve(t - (o || 0)).parent.inlineContent) {
    if (o == null && i && (n < 0 || i == zo(r))) {
      let c = r.childNodes[i - 1];
      if (c.nodeType == 1)
        return YC(c.getBoundingClientRect(), !1);
    }
    if (o == null && i < zo(r)) {
      let c = r.childNodes[i];
      if (c.nodeType == 1)
        return YC(c.getBoundingClientRect(), !0);
    }
    return YC(r.getBoundingClientRect(), n >= 0);
  }
  if (o == null && i && (n < 0 || i == zo(r))) {
    let c = r.childNodes[i - 1], u = c.nodeType == 3 ? $a(c, zo(c) - (s ? 0 : 1)) : c.nodeType == 1 && (c.nodeName != "BR" || !c.nextSibling) ? c : null;
    if (u)
      return tm(Jl(u, 1), !1);
  }
  if (o == null && i < zo(r)) {
    let c = r.childNodes[i];
    for (; c.pmViewDesc && c.pmViewDesc.ignoreForCoords; )
      c = c.nextSibling;
    let u = c ? c.nodeType == 3 ? $a(c, 0, s ? 0 : 1) : c.nodeType == 1 ? c : null : null;
    if (u)
      return tm(Jl(u, -1), !0);
  }
  return tm(Jl(r.nodeType == 3 ? $a(r) : r, -n), n >= 0);
}
function tm(e, t) {
  if (e.width == 0)
    return e;
  let n = t ? e.left : e.right;
  return { top: e.top, bottom: e.bottom, left: n, right: n };
}
function YC(e, t) {
  if (e.height == 0)
    return e;
  let n = t ? e.top : e.bottom;
  return { top: n, bottom: n, left: e.left, right: e.right };
}
function oW(e, t, n) {
  let r = e.state, i = e.root.activeElement;
  r != t && e.updateState(t), i != e.dom && e.focus();
  try {
    return n();
  } finally {
    r != t && e.updateState(r), i != e.dom && i && i.focus();
  }
}
function xRe(e, t, n) {
  let r = t.selection, i = n == "up" ? r.$from : r.$to;
  return oW(e, t, () => {
    let { node: o } = e.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = e.docView.nearestDesc(o, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        o = a.contentDOM || a.dom;
        break;
      }
      o = a.dom.parentNode;
    }
    let s = iW(e, i.pos, 1);
    for (let a = o.firstChild; a; a = a.nextSibling) {
      let c;
      if (a.nodeType == 1)
        c = a.getClientRects();
      else if (a.nodeType == 3)
        c = $a(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let u = 0; u < c.length; u++) {
        let f = c[u];
        if (f.bottom > f.top + 1 && (n == "up" ? s.top - f.top > (f.bottom - s.top) * 2 : f.bottom - s.bottom > (s.bottom - f.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const wRe = /[\u0590-\u08ac]/;
function SRe(e, t, n) {
  let { $head: r } = t.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, o = !i, s = i == r.parent.content.size, a = e.domSelection();
  return a ? !wRe.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? o : s : oW(e, t, () => {
    let { focusNode: c, focusOffset: u, anchorNode: f, anchorOffset: h } = e.domSelectionRange(), m = a.caretBidiLevel;
    a.modify("move", n, "character");
    let g = r.depth ? e.docView.domAfterPos(r.before()) : e.dom, { focusNode: b, focusOffset: x } = e.domSelectionRange(), w = b && !g.contains(b.nodeType == 1 ? b : b.parentNode) || c == b && u == x;
    try {
      a.collapse(f, h), c && (c != f || u != h) && a.extend && a.extend(c, u);
    } catch {
    }
    return m != null && (a.caretBidiLevel = m), w;
  }) : r.pos == r.start() || r.pos == r.end();
}
let WL = null, qL = null, GL = !1;
function kRe(e, t, n) {
  return WL == t && qL == n ? GL : (WL = t, qL = n, GL = n == "up" || n == "down" ? xRe(e, t, n) : SRe(e, t, n));
}
const Ho = 0, KL = 1, ju = 2, ea = 3;
class ly {
  constructor(t, n, r, i) {
    this.parent = t, this.children = n, this.dom = r, this.contentDOM = i, this.dirty = Ho, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(t) {
    return !1;
  }
  matchesMark(t) {
    return !1;
  }
  matchesNode(t, n, r) {
    return !1;
  }
  matchesHack(t) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(t) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let t = 0;
    for (let n = 0; n < this.children.length; n++)
      t += this.children[n].size;
    return t;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let t = 0; t < this.children.length; t++)
      this.children[t].destroy();
  }
  posBeforeChild(t) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let i = this.children[n];
      if (i == t)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(t, n, r) {
    if (this.contentDOM && this.contentDOM.contains(t.nodeType == 1 ? t : t.parentNode))
      if (r < 0) {
        let o, s;
        if (t == this.contentDOM)
          o = t.childNodes[n - 1];
        else {
          for (; t.parentNode != this.contentDOM; )
            t = t.parentNode;
          o = t.previousSibling;
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this); )
          o = o.previousSibling;
        return o ? this.posBeforeChild(s) + s.size : this.posAtStart;
      } else {
        let o, s;
        if (t == this.contentDOM)
          o = t.childNodes[n];
        else {
          for (; t.parentNode != this.contentDOM; )
            t = t.parentNode;
          o = t.nextSibling;
        }
        for (; o && !((s = o.pmViewDesc) && s.parent == this); )
          o = o.nextSibling;
        return o ? this.posBeforeChild(s) : this.posAtEnd;
      }
    let i;
    if (t == this.dom && this.contentDOM)
      i = n > ti(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = t.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let o = t; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !1;
            break;
          }
          if (o.previousSibling)
            break;
        }
      if (i == null && n == t.childNodes.length)
        for (let o = t; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !0;
            break;
          }
          if (o.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(t, n = !1) {
    for (let r = !0, i = t; i; i = i.parentNode) {
      let o = this.getDesc(i), s;
      if (o && (!n || o.node))
        if (r && (s = o.nodeDOM) && !(s.nodeType == 1 ? s.contains(t.nodeType == 1 ? t : t.parentNode) : s == t))
          r = !1;
        else
          return o;
    }
  }
  getDesc(t) {
    let n = t.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(t, n, r) {
    for (let i = t; i; i = i.parentNode) {
      let o = this.getDesc(i);
      if (o)
        return o.localPosFromDOM(t, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(t) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let i = this.children[n], o = r + i.size;
      if (r == t && o != r) {
        for (; !i.border && i.children.length; )
          for (let s = 0; s < i.children.length; s++) {
            let a = i.children[s];
            if (a.size) {
              i = a;
              break;
            }
          }
        return i;
      }
      if (t < o)
        return i.descAt(t - r - i.border);
      r = o;
    }
  }
  domFromPos(t, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: t + 1 };
    let r = 0, i = 0;
    for (let o = 0; r < this.children.length; r++) {
      let s = this.children[r], a = o + s.size;
      if (a > t || s instanceof aW) {
        i = t - o;
        break;
      }
      o = a;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, n);
    for (let o; r && !(o = this.children[r - 1]).size && o instanceof sW && o.side >= 0; r--)
      ;
    if (n <= 0) {
      let o, s = !0;
      for (; o = r ? this.children[r - 1] : null, !(!o || o.dom.parentNode == this.contentDOM); r--, s = !1)
        ;
      return o && n && s && !o.border && !o.domAtom ? o.domFromPos(o.size, n) : { node: this.contentDOM, offset: o ? ti(o.dom) + 1 : 0 };
    } else {
      let o, s = !0;
      for (; o = r < this.children.length ? this.children[r] : null, !(!o || o.dom.parentNode == this.contentDOM); r++, s = !1)
        ;
      return o && s && !o.border && !o.domAtom ? o.domFromPos(0, n) : { node: this.contentDOM, offset: o ? ti(o.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(t, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: t, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, o = -1;
    for (let s = r, a = 0; ; a++) {
      let c = this.children[a], u = s + c.size;
      if (i == -1 && t <= u) {
        let f = s + c.border;
        if (t >= f && n <= u - c.border && c.node && c.contentDOM && this.contentDOM.contains(c.contentDOM))
          return c.parseRange(t, n, f);
        t = s;
        for (let h = a; h > 0; h--) {
          let m = this.children[h - 1];
          if (m.size && m.dom.parentNode == this.contentDOM && !m.emptyChildAt(1)) {
            i = ti(m.dom) + 1;
            break;
          }
          t -= m.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (u > n || a == this.children.length - 1)) {
        n = u;
        for (let f = a + 1; f < this.children.length; f++) {
          let h = this.children[f];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
            o = ti(h.dom);
            break;
          }
          n += h.size;
        }
        o == -1 && (o = this.contentDOM.childNodes.length);
        break;
      }
      s = u;
    }
    return { node: this.contentDOM, from: t, to: n, fromOffset: i, toOffset: o };
  }
  emptyChildAt(t) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[t < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(t);
  }
  domAfterPos(t) {
    let { node: n, offset: r } = this.domFromPos(t, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + t);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(t, n, r, i = !1) {
    let o = Math.min(t, n), s = Math.max(t, n);
    for (let g = 0, b = 0; g < this.children.length; g++) {
      let x = this.children[g], w = b + x.size;
      if (o > b && s < w)
        return x.setSelection(t - b - x.border, n - b - x.border, r, i);
      b = w;
    }
    let a = this.domFromPos(t, t ? -1 : 1), c = n == t ? a : this.domFromPos(n, n ? -1 : 1), u = r.root.getSelection(), f = r.domSelectionRange(), h = !1;
    if ((Vo || ii) && t == n) {
      let { node: g, offset: b } = a;
      if (g.nodeType == 3) {
        if (h = !!(b && g.nodeValue[b - 1] == `
`), h && b == g.nodeValue.length)
          for (let x = g, w; x; x = x.parentNode) {
            if (w = x.nextSibling) {
              w.nodeName == "BR" && (a = c = { node: w.parentNode, offset: ti(w) + 1 });
              break;
            }
            let S = x.pmViewDesc;
            if (S && S.node && S.node.isBlock)
              break;
          }
      } else {
        let x = g.childNodes[b - 1];
        h = x && (x.nodeName == "BR" || x.contentEditable == "false");
      }
    }
    if (Vo && f.focusNode && f.focusNode != c.node && f.focusNode.nodeType == 1) {
      let g = f.focusNode.childNodes[f.focusOffset];
      g && g.contentEditable == "false" && (i = !0);
    }
    if (!(i || h && ii) && od(a.node, a.offset, f.anchorNode, f.anchorOffset) && od(c.node, c.offset, f.focusNode, f.focusOffset))
      return;
    let m = !1;
    if ((u.extend || t == n) && !(h && Vo)) {
      u.collapse(a.node, a.offset);
      try {
        t != n && u.extend(c.node, c.offset), m = !0;
      } catch {
      }
    }
    if (!m) {
      if (t > n) {
        let b = a;
        a = c, c = b;
      }
      let g = document.createRange();
      g.setEnd(c.node, c.offset), g.setStart(a.node, a.offset), u.removeAllRanges(), u.addRange(g);
    }
  }
  ignoreMutation(t) {
    return !this.contentDOM && t.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(t, n) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let o = this.children[i], s = r + o.size;
      if (r == s ? t <= s && n >= r : t < s && n > r) {
        let a = r + o.border, c = s - o.border;
        if (t >= a && n <= c) {
          this.dirty = t == r || n == s ? ju : KL, t == a && n == c && (o.contentLost || o.dom.parentNode != this.contentDOM) ? o.dirty = ea : o.markDirty(t - a, n - a);
          return;
        } else
          o.dirty = o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length ? ju : ea;
      }
      r = s;
    }
    this.dirty = ju;
  }
  markParentsDirty() {
    let t = 1;
    for (let n = this.parent; n; n = n.parent, t++) {
      let r = t == 1 ? ju : KL;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(t) {
    return !1;
  }
}
class sW extends ly {
  constructor(t, n, r, i) {
    let o, s = n.type.toDOM;
    if (typeof s == "function" && (s = s(r, () => {
      if (!o)
        return i;
      if (o.parent)
        return o.parent.posBeforeChild(o);
    })), !n.type.spec.raw) {
      if (s.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(s), s = a;
      }
      s.contentEditable = "false", s.classList.add("ProseMirror-widget");
    }
    super(t, [], s, null), this.widget = n, this.widget = n, o = this;
  }
  matchesWidget(t) {
    return this.dirty == Ho && t.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(t) {
    let n = this.widget.spec.stopEvent;
    return n ? n(t) : !1;
  }
  ignoreMutation(t) {
    return t.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CRe extends ly {
  constructor(t, n, r, i) {
    super(t, [], n, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(t, n) {
    return t != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(t) {
    return { node: this.textDOM, offset: t };
  }
  ignoreMutation(t) {
    return t.type === "characterData" && t.target.nodeValue == t.oldValue;
  }
}
class sd extends ly {
  constructor(t, n, r, i, o) {
    super(t, [], r, i), this.mark = n, this.spec = o;
  }
  static create(t, n, r, i) {
    let o = i.nodeViews[n.type.name], s = o && o(n, i, r);
    return (!s || !s.dom) && (s = pd.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new sd(t, n, s.dom, s.contentDOM || s.dom, s);
  }
  parseRule() {
    return this.dirty & ea || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(t) {
    return this.dirty != ea && this.mark.eq(t);
  }
  markDirty(t, n) {
    if (super.markDirty(t, n), this.dirty != Ho) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Ho;
    }
  }
  slice(t, n, r) {
    let i = sd.create(this.parent, this.mark, !0, r), o = this.children, s = this.size;
    n < s && (o = bT(o, n, s, r)), t > 0 && (o = bT(o, 0, t, r));
    for (let a = 0; a < o.length; a++)
      o[a].parent = i;
    return i.children = o, i;
  }
  ignoreMutation(t) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(t) : super.ignoreMutation(t);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class bc extends ly {
  constructor(t, n, r, i, o, s, a, c, u) {
    super(t, [], o, s), this.node = n, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(t, n, r, i, o, s) {
    let a = o.nodeViews[n.type.name], c, u = a && a(n, o, () => {
      if (!c)
        return s;
      if (c.parent)
        return c.parent.posBeforeChild(c);
    }, r, i), f = u && u.dom, h = u && u.contentDOM;
    if (n.isText) {
      if (!f)
        f = document.createTextNode(n.text);
      else if (f.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else f || ({ dom: f, contentDOM: h } = pd.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !h && !n.isText && f.nodeName != "BR" && (f.hasAttribute("contenteditable") || (f.contentEditable = "false"), n.type.spec.draggable && (f.draggable = !0));
    let m = f;
    return f = uW(f, r, n), u ? c = new ERe(t, n, r, i, f, h || null, m, u, o, s + 1) : n.isText ? new Xw(t, n, r, i, f, m, o) : new bc(t, n, r, i, f, h || null, m, o, s + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let t = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (t.preserveWhitespace = "full"), !this.contentDOM)
      t.getContent = () => this.node.content;
    else if (!this.contentLost)
      t.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          t.contentElement = r.dom.parentNode;
          break;
        }
      }
      t.contentElement || (t.getContent = () => $e.empty);
    }
    return t;
  }
  matchesNode(t, n, r) {
    return this.dirty == Ho && t.eq(this.node) && nx(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(t, n) {
    let r = this.node.inlineContent, i = n, o = t.composing ? this.localCompositionInfo(t, n) : null, s = o && o.pos > -1 ? o : null, a = o && o.pos < 0, c = new TRe(this, s && s.node, t);
    NRe(this.node, this.innerDeco, (u, f, h) => {
      u.spec.marks ? c.syncToMarks(u.spec.marks, r, t, f) : u.type.side >= 0 && !h && c.syncToMarks(f == this.node.childCount ? En.none : this.node.child(f).marks, r, t, f), c.placeWidget(u, t, i);
    }, (u, f, h, m) => {
      c.syncToMarks(u.marks, r, t, m);
      let g;
      c.findNodeMatch(u, f, h, m) || a && t.state.selection.from > i && t.state.selection.to < i + u.nodeSize && (g = c.findIndexWithChild(o.node)) > -1 && c.updateNodeAt(u, f, h, g, t) || c.updateNextNode(u, f, h, t, m, i) || c.addNode(u, f, h, t, i), i += u.nodeSize;
    }), c.syncToMarks([], r, t, 0), this.node.isTextblock && c.addTextblockHacks(), c.destroyRest(), (c.changed || this.dirty == ju) && (s && this.protectLocalComposition(t, s), lW(this.contentDOM, this.children, t), yh && RRe(this.dom));
  }
  localCompositionInfo(t, n) {
    let { from: r, to: i } = t.state.selection;
    if (!(t.state.selection instanceof kt) || r < n || i > n + this.node.content.size)
      return null;
    let o = t.input.compositionNode;
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let s = o.nodeValue, a = ORe(this.node.content, s, r - n, i - n);
      return a < 0 ? null : { node: o, pos: a, text: s };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(t, { node: n, pos: r, text: i }) {
    if (this.getDesc(n))
      return;
    let o = n;
    for (; o.parentNode != this.contentDOM; o = o.parentNode) {
      for (; o.previousSibling; )
        o.parentNode.removeChild(o.previousSibling);
      for (; o.nextSibling; )
        o.parentNode.removeChild(o.nextSibling);
      o.pmViewDesc && (o.pmViewDesc = void 0);
    }
    let s = new CRe(this, o, n, i);
    t.input.compositionNodes.push(s), this.children = bT(this.children, r, r + i.length, t, s);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(t, n, r, i) {
    return this.dirty == ea || !t.sameMarkup(this.node) ? !1 : (this.updateInner(t, n, r, i), !0);
  }
  updateInner(t, n, r, i) {
    this.updateOuterDeco(n), this.node = t, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Ho;
  }
  updateOuterDeco(t) {
    if (nx(t, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = cW(this.dom, this.nodeDOM, vT(this.outerDeco, this.node, n), vT(t, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = t;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.nodeDOM.draggable = !0));
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.nodeDOM.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function ZL(e, t, n, r, i) {
  uW(r, t, e);
  let o = new bc(void 0, e, t, n, r, r, r, i, 0);
  return o.contentDOM && o.updateChildren(i, 0), o;
}
class Xw extends bc {
  constructor(t, n, r, i, o, s, a) {
    super(t, n, r, i, o, null, s, a, 0);
  }
  parseRule() {
    let t = this.nodeDOM.parentNode;
    for (; t && t != this.dom && !t.pmIsDeco; )
      t = t.parentNode;
    return { skip: t || !0 };
  }
  update(t, n, r, i) {
    return this.dirty == ea || this.dirty != Ho && !this.inParent() || !t.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != Ho || t.text != this.node.text) && t.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = t.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = t, this.dirty = Ho, !0);
  }
  inParent() {
    let t = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == t)
        return !0;
    return !1;
  }
  domFromPos(t) {
    return { node: this.nodeDOM, offset: t };
  }
  localPosFromDOM(t, n, r) {
    return t == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(t, n, r);
  }
  ignoreMutation(t) {
    return t.type != "characterData" && t.type != "selection";
  }
  slice(t, n, r) {
    let i = this.node.cut(t, n), o = document.createTextNode(i.text);
    return new Xw(this.parent, i, this.outerDeco, this.innerDeco, o, o, r);
  }
  markDirty(t, n) {
    super.markDirty(t, n), this.dom != this.nodeDOM && (t == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = ea);
  }
  get domAtom() {
    return !1;
  }
  isText(t) {
    return this.node.text == t;
  }
}
class aW extends ly {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(t) {
    return this.dirty == Ho && this.dom.nodeName == t;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class ERe extends bc {
  constructor(t, n, r, i, o, s, a, c, u, f) {
    super(t, n, r, i, o, s, a, u, f), this.spec = c;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(t, n, r, i) {
    if (this.dirty == ea)
      return !1;
    if (this.spec.update && (this.node.type == t.type || this.spec.multiType)) {
      let o = this.spec.update(t, n, r);
      return o && this.updateInner(t, n, r, i), o;
    } else return !this.contentDOM && !t.isLeaf ? !1 : super.update(t, n, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(t, n, r, i) {
    this.spec.setSelection ? this.spec.setSelection(t, n, r.root) : super.setSelection(t, n, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(t) {
    return this.spec.stopEvent ? this.spec.stopEvent(t) : !1;
  }
  ignoreMutation(t) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(t) : super.ignoreMutation(t);
  }
}
function lW(e, t, n) {
  let r = e.firstChild, i = !1;
  for (let o = 0; o < t.length; o++) {
    let s = t[o], a = s.dom;
    if (a.parentNode == e) {
      for (; a != r; )
        r = YL(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, e.insertBefore(a, r);
    if (s instanceof sd) {
      let c = r ? r.previousSibling : e.lastChild;
      lW(s.contentDOM, s.children, n), r = c ? c.nextSibling : e.firstChild;
    }
  }
  for (; r; )
    r = YL(r), i = !0;
  i && n.trackWrites == e && (n.trackWrites = null);
}
const Lm = function(e) {
  e && (this.nodeName = e);
};
Lm.prototype = /* @__PURE__ */ Object.create(null);
const Iu = [new Lm()];
function vT(e, t, n) {
  if (e.length == 0)
    return Iu;
  let r = n ? Iu[0] : new Lm(), i = [r];
  for (let o = 0; o < e.length; o++) {
    let s = e[o].type.attrs;
    if (s) {
      s.nodeName && i.push(r = new Lm(s.nodeName));
      for (let a in s) {
        let c = s[a];
        c != null && (n && i.length == 1 && i.push(r = new Lm(t.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + c : a == "style" ? r.style = (r.style ? r.style + ";" : "") + c : a != "nodeName" && (r[a] = c));
      }
    }
  }
  return i;
}
function cW(e, t, n, r) {
  if (n == Iu && r == Iu)
    return t;
  let i = t;
  for (let o = 0; o < r.length; o++) {
    let s = r[o], a = n[o];
    if (o) {
      let c;
      a && a.nodeName == s.nodeName && i != e && (c = i.parentNode) && c.nodeName.toLowerCase() == s.nodeName || (c = document.createElement(s.nodeName), c.pmIsDeco = !0, c.appendChild(i), a = Iu[0]), i = c;
    }
    _Re(i, a || Iu[0], s);
  }
  return i;
}
function _Re(e, t, n) {
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && e.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != t[r] && e.setAttribute(r, n[r]);
  if (t.class != n.class) {
    let r = t.class ? t.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let o = 0; o < r.length; o++)
      i.indexOf(r[o]) == -1 && e.classList.remove(r[o]);
    for (let o = 0; o < i.length; o++)
      r.indexOf(i[o]) == -1 && e.classList.add(i[o]);
    e.classList.length == 0 && e.removeAttribute("class");
  }
  if (t.style != n.style) {
    if (t.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(t.style); )
        e.style.removeProperty(i[1]);
    }
    n.style && (e.style.cssText += n.style);
  }
}
function uW(e, t, n) {
  return cW(e, e, Iu, vT(t, n, e.nodeType != 1));
}
function nx(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!e[n].type.eq(t[n].type))
      return !1;
  return !0;
}
function YL(e) {
  let t = e.nextSibling;
  return e.parentNode.removeChild(e), t;
}
class TRe {
  constructor(t, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = t, this.preMatch = ARe(t.node.content, t);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(t, n) {
    if (t != n) {
      for (let r = t; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(t, n - t), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(t, n, r, i) {
    let o = 0, s = this.stack.length >> 1, a = Math.min(s, t.length);
    for (; o < a && (o == s - 1 ? this.top : this.stack[o + 1 << 1]).matchesMark(t[o]) && t[o].type.spec.spanning !== !1; )
      o++;
    for (; o < s; )
      this.destroyRest(), this.top.dirty = Ho, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < t.length; ) {
      this.stack.push(this.top, this.index + 1);
      let c = -1, u = this.top.children.length;
      i < this.preMatch.index && (u = Math.min(this.index + 3, u));
      for (let f = this.index; f < u; f++) {
        let h = this.top.children[f];
        if (h.matchesMark(t[s]) && !this.isLocked(h.dom)) {
          c = f;
          break;
        }
      }
      if (c > -1)
        c > this.index && (this.changed = !0, this.destroyBetween(this.index, c)), this.top = this.top.children[this.index];
      else {
        let f = sd.create(this.top, t[s], n, r);
        this.top.children.splice(this.index, 0, f), this.top = f, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(t, n, r, i) {
    let o = -1, s;
    if (i >= this.preMatch.index && (s = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && s.matchesNode(t, n, r))
      o = this.top.children.indexOf(s, this.index);
    else
      for (let a = this.index, c = Math.min(this.top.children.length, a + 5); a < c; a++) {
        let u = this.top.children[a];
        if (u.matchesNode(t, n, r) && !this.preMatch.matched.has(u)) {
          o = a;
          break;
        }
      }
    return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
  }
  updateNodeAt(t, n, r, i, o) {
    let s = this.top.children[i];
    return s.dirty == ea && s.dom == s.contentDOM && (s.dirty = ju), s.update(t, n, r, o) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(t) {
    for (; ; ) {
      let n = t.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = t.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      t = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(t, n, r, i, o, s) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let c = this.top.children[a];
      if (c instanceof bc) {
        let u = this.preMatch.matched.get(c);
        if (u != null && u != o)
          return !1;
        let f = c.dom, h, m = this.isLocked(f) && !(t.isText && c.node && c.node.isText && c.nodeDOM.nodeValue == t.text && c.dirty != ea && nx(n, c.outerDeco));
        if (!m && c.update(t, n, r, i))
          return this.destroyBetween(this.index, a), c.dom != f && (this.changed = !0), this.index++, !0;
        if (!m && (h = this.recreateWrapper(c, t, n, r, i, s)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = h, h.contentDOM && (h.dirty = ju, h.updateChildren(i, s + 1), h.dirty = Ho), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(t, n, r, i, o, s) {
    if (t.dirty || n.isAtom || !t.children.length || !t.node.content.eq(n.content) || !nx(r, t.outerDeco) || !i.eq(t.innerDeco))
      return null;
    let a = bc.create(this.top, n, r, i, o, s);
    if (a.contentDOM) {
      a.children = t.children, t.children = [];
      for (let c of a.children)
        c.parent = a;
    }
    return t.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(t, n, r, i, o) {
    let s = bc.create(this.top, t, n, r, i, o);
    s.contentDOM && s.updateChildren(i, o + 1), this.top.children.splice(this.index++, 0, s), this.changed = !0;
  }
  placeWidget(t, n, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(t) && (t == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let o = new sW(this.top, t, n, r);
      this.top.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let t = this.top.children[this.index - 1], n = this.top;
    for (; t instanceof sd; )
      n = t, t = n.children[n.children.length - 1];
    (!t || // Empty textblock
    !(t instanceof Xw) || /\n$/.test(t.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(t.node.text)) && ((ii || Vr) && t && t.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(t, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(t))
      this.index++;
    else {
      let r = document.createElement(t);
      t == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), t == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new aW(this.top, [], r, null);
      n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(t) {
    return this.lock && (t == this.lock || t.nodeType == 1 && t.contains(this.lock.parentNode));
  }
}
function ARe(e, t) {
  let n = t, r = n.children.length, i = e.childCount, o = /* @__PURE__ */ new Map(), s = [];
  e: for (; i > 0; ) {
    let a;
    for (; ; )
      if (r) {
        let u = n.children[r - 1];
        if (u instanceof sd)
          n = u, r = u.children.length;
        else {
          a = u, r--;
          break;
        }
      } else {
        if (n == t)
          break e;
        r = n.parent.children.indexOf(n), n = n.parent;
      }
    let c = a.node;
    if (c) {
      if (c != e.child(i - 1))
        break;
      --i, o.set(a, i), s.push(a);
    }
  }
  return { index: i, matched: o, matches: s.reverse() };
}
function MRe(e, t) {
  return e.type.side - t.type.side;
}
function NRe(e, t, n, r) {
  let i = t.locals(e), o = 0;
  if (i.length == 0) {
    for (let u = 0; u < e.childCount; u++) {
      let f = e.child(u);
      r(f, i, t.forChild(o, f), u), o += f.nodeSize;
    }
    return;
  }
  let s = 0, a = [], c = null;
  for (let u = 0; ; ) {
    let f, h;
    for (; s < i.length && i[s].to == o; ) {
      let w = i[s++];
      w.widget && (f ? (h || (h = [f])).push(w) : f = w);
    }
    if (f)
      if (h) {
        h.sort(MRe);
        for (let w = 0; w < h.length; w++)
          n(h[w], u, !!c);
      } else
        n(f, u, !!c);
    let m, g;
    if (c)
      g = -1, m = c, c = null;
    else if (u < e.childCount)
      g = u, m = e.child(u++);
    else
      break;
    for (let w = 0; w < a.length; w++)
      a[w].to <= o && a.splice(w--, 1);
    for (; s < i.length && i[s].from <= o && i[s].to > o; )
      a.push(i[s++]);
    let b = o + m.nodeSize;
    if (m.isText) {
      let w = b;
      s < i.length && i[s].from < w && (w = i[s].from);
      for (let S = 0; S < a.length; S++)
        a[S].to < w && (w = a[S].to);
      w < b && (c = m.cut(w - o), m = m.cut(0, w - o), b = w, g = -1);
    } else
      for (; s < i.length && i[s].to < b; )
        s++;
    let x = m.isInline && !m.isLeaf ? a.filter((w) => !w.inline) : a.slice();
    r(m, x, t.forChild(o, m), g), o = b;
  }
}
function RRe(e) {
  if (e.nodeName == "UL" || e.nodeName == "OL") {
    let t = e.style.cssText;
    e.style.cssText = t + "; list-style: square !important", window.getComputedStyle(e).listStyle, e.style.cssText = t;
  }
}
function ORe(e, t, n, r) {
  for (let i = 0, o = 0; i < e.childCount && o <= r; ) {
    let s = e.child(i++), a = o;
    if (o += s.nodeSize, !s.isText)
      continue;
    let c = s.text;
    for (; i < e.childCount; ) {
      let u = e.child(i++);
      if (o += u.nodeSize, !u.isText)
        break;
      c += u.text;
    }
    if (o >= n) {
      if (o >= r && c.slice(r - t.length - a, r - a) == t)
        return r - t.length;
      let u = a < r ? c.lastIndexOf(t, r - a - 1) : -1;
      if (u >= 0 && u + t.length + a >= n)
        return a + u;
      if (n == r && c.length >= r + t.length - a && c.slice(r - a, r - a + t.length) == t)
        return r;
    }
  }
  return -1;
}
function bT(e, t, n, r, i) {
  let o = [];
  for (let s = 0, a = 0; s < e.length; s++) {
    let c = e[s], u = a, f = a += c.size;
    u >= n || f <= t ? o.push(c) : (u < t && o.push(c.slice(0, t - u, r)), i && (o.push(i), i = void 0), f > n && o.push(c.slice(n - u, c.size, r)));
  }
  return o;
}
function CN(e, t = null) {
  let n = e.domSelectionRange(), r = e.state.doc;
  if (!n.focusNode)
    return null;
  let i = e.docView.nearestDesc(n.focusNode), o = i && i.size == 0, s = e.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (s < 0)
    return null;
  let a = r.resolve(s), c, u;
  if (Yw(n)) {
    for (c = s; i && !i.node; )
      i = i.parent;
    let h = i.node;
    if (i && h.isAtom && ht.isSelectable(h) && i.parent && !(h.isInline && oRe(n.focusNode, n.focusOffset, i.dom))) {
      let m = i.posBefore;
      u = new ht(s == m ? a : r.resolve(m));
    }
  } else {
    if (n instanceof e.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let h = s, m = s;
      for (let g = 0; g < n.rangeCount; g++) {
        let b = n.getRangeAt(g);
        h = Math.min(h, e.docView.posFromDOM(b.startContainer, b.startOffset, 1)), m = Math.max(m, e.docView.posFromDOM(b.endContainer, b.endOffset, -1));
      }
      if (h < 0)
        return null;
      [c, s] = m == e.state.selection.anchor ? [m, h] : [h, m], a = r.resolve(s);
    } else
      c = e.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (c < 0)
      return null;
  }
  let f = r.resolve(c);
  if (!u) {
    let h = t == "pointer" || e.state.selection.head < a.pos && !o ? 1 : -1;
    u = EN(e, f, a, h);
  }
  return u;
}
function dW(e) {
  return e.editable ? e.hasFocus() : hW(e) && document.activeElement && document.activeElement.contains(e.dom);
}
function Ka(e, t = !1) {
  let n = e.state.selection;
  if (fW(e, n), !!dW(e)) {
    if (!t && e.input.mouseDown && e.input.mouseDown.allowDefault && Vr) {
      let r = e.domSelectionRange(), i = e.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && od(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        e.input.mouseDown.delayedSelectionSync = !0, e.domObserver.setCurSelection();
        return;
      }
    }
    if (e.domObserver.disconnectSelection(), e.cursorWrapper)
      PRe(e);
    else {
      let { anchor: r, head: i } = n, o, s;
      XL && !(n instanceof kt) && (n.$from.parent.inlineContent || (o = JL(e, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = JL(e, n.to))), e.docView.setSelection(r, i, e, t), XL && (o && QL(o), s && QL(s)), n.visible ? e.dom.classList.remove("ProseMirror-hideselection") : (e.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && DRe(e));
    }
    e.domObserver.setCurSelection(), e.domObserver.connectSelection();
  }
}
const XL = ii || Vr && JH < 63;
function JL(e, t) {
  let { node: n, offset: r } = e.docView.domFromPos(t, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, o = r ? n.childNodes[r - 1] : null;
  if (ii && i && i.contentEditable == "false")
    return XC(i);
  if ((!i || i.contentEditable == "false") && (!o || o.contentEditable == "false")) {
    if (i)
      return XC(i);
    if (o)
      return XC(o);
  }
}
function XC(e) {
  return e.contentEditable = "true", ii && e.draggable && (e.draggable = !1, e.wasDraggable = !0), e;
}
function QL(e) {
  e.contentEditable = "false", e.wasDraggable && (e.draggable = !0, e.wasDraggable = null);
}
function DRe(e) {
  let t = e.dom.ownerDocument;
  t.removeEventListener("selectionchange", e.input.hideSelectionGuard);
  let n = e.domSelectionRange(), r = n.anchorNode, i = n.anchorOffset;
  t.addEventListener("selectionchange", e.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != i) && (t.removeEventListener("selectionchange", e.input.hideSelectionGuard), setTimeout(() => {
      (!dW(e) || e.state.selection.visible) && e.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function PRe(e) {
  let t = e.domSelection();
  if (!t)
    return;
  let n = e.cursorWrapper.dom, r = n.nodeName == "IMG";
  r ? t.collapse(n.parentNode, ti(n) + 1) : t.collapse(n, 0), !r && !e.state.selection.visible && Ki && vc <= 11 && (n.disabled = !0, n.disabled = !1);
}
function fW(e, t) {
  if (t instanceof ht) {
    let n = e.docView.descAt(t.from);
    n != e.lastSelectedViewDesc && (e5(e), n && n.selectNode(), e.lastSelectedViewDesc = n);
  } else
    e5(e);
}
function e5(e) {
  e.lastSelectedViewDesc && (e.lastSelectedViewDesc.parent && e.lastSelectedViewDesc.deselectNode(), e.lastSelectedViewDesc = void 0);
}
function EN(e, t, n, r) {
  return e.someProp("createSelectionBetween", (i) => i(e, t, n)) || kt.between(t, n, r);
}
function t5(e) {
  return e.editable && !e.hasFocus() ? !1 : hW(e);
}
function hW(e) {
  let t = e.domSelectionRange();
  if (!t.anchorNode)
    return !1;
  try {
    return e.dom.contains(t.anchorNode.nodeType == 3 ? t.anchorNode.parentNode : t.anchorNode) && (e.editable || e.dom.contains(t.focusNode.nodeType == 3 ? t.focusNode.parentNode : t.focusNode));
  } catch {
    return !1;
  }
}
function jRe(e) {
  let t = e.docView.domFromPos(e.state.selection.anchor, 0), n = e.domSelectionRange();
  return od(t.node, t.offset, n.anchorNode, n.anchorOffset);
}
function xT(e, t) {
  let { $anchor: n, $head: r } = e.selection, i = t > 0 ? n.max(r) : n.min(r), o = i.parent.inlineContent ? i.depth ? e.doc.resolve(t > 0 ? i.after() : i.before()) : null : i;
  return o && zt.findFrom(o, t);
}
function tc(e, t) {
  return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()), !0;
}
function n5(e, t, n) {
  let r = e.state.selection;
  if (r instanceof kt)
    if (n.indexOf("s") > -1) {
      let { $head: i } = r, o = i.textOffset ? null : t < 0 ? i.nodeBefore : i.nodeAfter;
      if (!o || o.isText || !o.isLeaf)
        return !1;
      let s = e.state.doc.resolve(i.pos + o.nodeSize * (t < 0 ? -1 : 1));
      return tc(e, new kt(r.$anchor, s));
    } else if (r.empty) {
      if (e.endOfTextblock(t > 0 ? "forward" : "backward")) {
        let i = xT(e.state, t);
        return i && i instanceof ht ? tc(e, i) : !1;
      } else if (!(jo && n.indexOf("m") > -1)) {
        let i = r.$head, o = i.textOffset ? null : t < 0 ? i.nodeBefore : i.nodeAfter, s;
        if (!o || o.isText)
          return !1;
        let a = t < 0 ? i.pos - o.nodeSize : i.pos;
        return o.isAtom || (s = e.docView.descAt(a)) && !s.contentDOM ? ht.isSelectable(o) ? tc(e, new ht(t < 0 ? e.state.doc.resolve(i.pos - o.nodeSize) : i)) : ay ? tc(e, new kt(e.state.doc.resolve(t < 0 ? a : a + o.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof ht && r.node.isInline)
      return tc(e, new kt(t > 0 ? r.$to : r.$from));
    {
      let i = xT(e.state, t);
      return i ? tc(e, i) : !1;
    }
  }
}
function rx(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length;
}
function Bm(e, t) {
  let n = e.pmViewDesc;
  return n && n.size == 0 && (t < 0 || e.nextSibling || e.nodeName != "BR");
}
function bf(e, t) {
  return t < 0 ? IRe(e) : zRe(e);
}
function IRe(e) {
  let t = e.domSelectionRange(), n = t.focusNode, r = t.focusOffset;
  if (!n)
    return;
  let i, o, s = !1;
  for (Vo && n.nodeType == 1 && r < rx(n) && Bm(n.childNodes[r], -1) && (s = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[r - 1];
        if (Bm(a, -1))
          i = n, o = --r;
        else if (a.nodeType == 3)
          n = a, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (pW(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && Bm(a, -1); )
          i = n.parentNode, o = ti(a), a = a.previousSibling;
        if (a)
          n = a, r = rx(n);
        else {
          if (n = n.parentNode, n == e.dom)
            break;
          r = 0;
        }
      }
    }
  s ? wT(e, n, r) : i && wT(e, i, o);
}
function zRe(e) {
  let t = e.domSelectionRange(), n = t.focusNode, r = t.focusOffset;
  if (!n)
    return;
  let i = rx(n), o, s;
  for (; ; )
    if (r < i) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[r];
      if (Bm(a, 1))
        o = n, s = ++r;
      else
        break;
    } else {
      if (pW(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && Bm(a, 1); )
          o = a.parentNode, s = ti(a) + 1, a = a.nextSibling;
        if (a)
          n = a, r = 0, i = rx(n);
        else {
          if (n = n.parentNode, n == e.dom)
            break;
          r = i = 0;
        }
      }
    }
  o && wT(e, o, s);
}
function pW(e) {
  let t = e.pmViewDesc;
  return t && t.node && t.node.isBlock;
}
function LRe(e, t) {
  for (; e && t == e.childNodes.length && !sy(e); )
    t = ti(e) + 1, e = e.parentNode;
  for (; e && t < e.childNodes.length; ) {
    let n = e.childNodes[t];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    e = n, t = 0;
  }
}
function BRe(e, t) {
  for (; e && !t && !sy(e); )
    t = ti(e), e = e.parentNode;
  for (; e && t; ) {
    let n = e.childNodes[t - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    e = n, t = e.childNodes.length;
  }
}
function wT(e, t, n) {
  if (t.nodeType != 3) {
    let o, s;
    (s = LRe(t, n)) ? (t = s, n = 0) : (o = BRe(t, n)) && (t = o, n = o.nodeValue.length);
  }
  let r = e.domSelection();
  if (!r)
    return;
  if (Yw(r)) {
    let o = document.createRange();
    o.setEnd(t, n), o.setStart(t, n), r.removeAllRanges(), r.addRange(o);
  } else r.extend && r.extend(t, n);
  e.domObserver.setCurSelection();
  let { state: i } = e;
  setTimeout(() => {
    e.state == i && Ka(e);
  }, 50);
}
function r5(e, t) {
  let n = e.state.doc.resolve(t);
  if (!(Vr || QH) && n.parent.inlineContent) {
    let i = e.coordsAtPos(t);
    if (t > n.start()) {
      let o = e.coordsAtPos(t - 1), s = (o.top + o.bottom) / 2;
      if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left < i.left ? "ltr" : "rtl";
    }
    if (t < n.end()) {
      let o = e.coordsAtPos(t + 1), s = (o.top + o.bottom) / 2;
      if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(e.dom).direction == "rtl" ? "rtl" : "ltr";
}
function i5(e, t, n) {
  let r = e.state.selection;
  if (r instanceof kt && !r.empty || n.indexOf("s") > -1 || jo && n.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: o } = r;
  if (!i.parent.inlineContent || e.endOfTextblock(t < 0 ? "up" : "down")) {
    let s = xT(e.state, t);
    if (s && s instanceof ht)
      return tc(e, s);
  }
  if (!i.parent.inlineContent) {
    let s = t < 0 ? i : o, a = r instanceof mo ? zt.near(s, t) : zt.findFrom(s, t);
    return a ? tc(e, a) : !1;
  }
  return !1;
}
function o5(e, t) {
  if (!(e.state.selection instanceof kt))
    return !0;
  let { $head: n, $anchor: r, empty: i } = e.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (e.endOfTextblock(t > 0 ? "forward" : "backward"))
    return !0;
  let o = !n.textOffset && (t < 0 ? n.nodeBefore : n.nodeAfter);
  if (o && !o.isText) {
    let s = e.state.tr;
    return t < 0 ? s.delete(n.pos - o.nodeSize, n.pos) : s.delete(n.pos, n.pos + o.nodeSize), e.dispatch(s), !0;
  }
  return !1;
}
function s5(e, t, n) {
  e.domObserver.stop(), t.contentEditable = n, e.domObserver.start();
}
function $Re(e) {
  if (!ii || e.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: t, focusOffset: n } = e.domSelectionRange();
  if (t && t.nodeType == 1 && n == 0 && t.firstChild && t.firstChild.contentEditable == "false") {
    let r = t.firstChild;
    s5(e, r, "true"), setTimeout(() => s5(e, r, "false"), 20);
  }
  return !1;
}
function URe(e) {
  let t = "";
  return e.ctrlKey && (t += "c"), e.metaKey && (t += "m"), e.altKey && (t += "a"), e.shiftKey && (t += "s"), t;
}
function FRe(e, t) {
  let n = t.keyCode, r = URe(t);
  if (n == 8 || jo && n == 72 && r == "c")
    return o5(e, -1) || bf(e, -1);
  if (n == 46 && !t.shiftKey || jo && n == 68 && r == "c")
    return o5(e, 1) || bf(e, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || jo && n == 66 && r == "c") {
    let i = n == 37 ? r5(e, e.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return n5(e, i, r) || bf(e, i);
  } else if (n == 39 || jo && n == 70 && r == "c") {
    let i = n == 39 ? r5(e, e.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return n5(e, i, r) || bf(e, i);
  } else {
    if (n == 38 || jo && n == 80 && r == "c")
      return i5(e, -1, r) || bf(e, -1);
    if (n == 40 || jo && n == 78 && r == "c")
      return $Re(e) || i5(e, 1, r) || bf(e, 1);
    if (r == (jo ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function _N(e, t) {
  e.someProp("transformCopied", (g) => {
    t = g(t, e);
  });
  let n = [], { content: r, openStart: i, openEnd: o } = t;
  for (; i > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, o--;
    let g = r.firstChild;
    n.push(g.type.name, g.attrs != g.type.defaultAttrs ? g.attrs : null), r = g.content;
  }
  let s = e.someProp("clipboardSerializer") || pd.fromSchema(e.state.schema), a = xW(), c = a.createElement("div");
  c.appendChild(s.serializeFragment(r, { document: a }));
  let u = c.firstChild, f, h = 0;
  for (; u && u.nodeType == 1 && (f = bW[u.nodeName.toLowerCase()]); ) {
    for (let g = f.length - 1; g >= 0; g--) {
      let b = a.createElement(f[g]);
      for (; c.firstChild; )
        b.appendChild(c.firstChild);
      c.appendChild(b), h++;
    }
    u = c.firstChild;
  }
  u && u.nodeType == 1 && u.setAttribute("data-pm-slice", `${i} ${o}${h ? ` -${h}` : ""} ${JSON.stringify(n)}`);
  let m = e.someProp("clipboardTextSerializer", (g) => g(t, e)) || t.content.textBetween(0, t.content.size, `

`);
  return { dom: c, text: m, slice: t };
}
function mW(e, t, n, r, i) {
  let o = i.parent.type.spec.code, s, a;
  if (!n && !t)
    return null;
  let c = !!t && (r || o || !n);
  if (c) {
    if (e.someProp("transformPastedText", (m) => {
      t = m(t, o || r, e);
    }), o)
      return a = new Qe($e.from(e.state.schema.text(t.replace(/\r\n?/g, `
`))), 0, 0), e.someProp("transformPasted", (m) => {
        a = m(a, e, !0);
      }), a;
    let h = e.someProp("clipboardTextParser", (m) => m(t, i, r, e));
    if (h)
      a = h;
    else {
      let m = i.marks(), { schema: g } = e.state, b = pd.fromSchema(g);
      s = document.createElement("div"), t.split(/(?:\r\n?|\n)+/).forEach((x) => {
        let w = s.appendChild(document.createElement("p"));
        x && w.appendChild(b.serializeNode(g.text(x, m)));
      });
    }
  } else
    e.someProp("transformPastedHTML", (h) => {
      n = h(n, e);
    }), s = qRe(n), ay && GRe(s);
  let u = s && s.querySelector("[data-pm-slice]"), f = u && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(u.getAttribute("data-pm-slice") || "");
  if (f && f[3])
    for (let h = +f[3]; h > 0; h--) {
      let m = s.firstChild;
      for (; m && m.nodeType != 1; )
        m = m.nextSibling;
      if (!m)
        break;
      s = m;
    }
  if (a || (a = (e.someProp("clipboardParser") || e.someProp("domParser") || yc.fromSchema(e.state.schema)).parseSlice(s, {
    preserveWhitespace: !!(c || f),
    context: i,
    ruleFromNode(m) {
      return m.nodeName == "BR" && !m.nextSibling && m.parentNode && !VRe.test(m.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), f)
    a = KRe(a5(a, +f[1], +f[2]), f[4]);
  else if (a = Qe.maxOpen(HRe(a.content, i), !0), a.openStart || a.openEnd) {
    let h = 0, m = 0;
    for (let g = a.content.firstChild; h < a.openStart && !g.type.spec.isolating; h++, g = g.firstChild)
      ;
    for (let g = a.content.lastChild; m < a.openEnd && !g.type.spec.isolating; m++, g = g.lastChild)
      ;
    a = a5(a, h, m);
  }
  return e.someProp("transformPasted", (h) => {
    a = h(a, e, c);
  }), a;
}
const VRe = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function HRe(e, t) {
  if (e.childCount < 2)
    return e;
  for (let n = t.depth; n >= 0; n--) {
    let i = t.node(n).contentMatchAt(t.index(n)), o, s = [];
    if (e.forEach((a) => {
      if (!s)
        return;
      let c = i.findWrapping(a.type), u;
      if (!c)
        return s = null;
      if (u = s.length && o.length && yW(c, o, a, s[s.length - 1], 0))
        s[s.length - 1] = u;
      else {
        s.length && (s[s.length - 1] = vW(s[s.length - 1], o.length));
        let f = gW(a, c);
        s.push(f), i = i.matchType(f.type), o = c;
      }
    }), s)
      return $e.from(s);
  }
  return e;
}
function gW(e, t, n = 0) {
  for (let r = t.length - 1; r >= n; r--)
    e = t[r].create(null, $e.from(e));
  return e;
}
function yW(e, t, n, r, i) {
  if (i < e.length && i < t.length && e[i] == t[i]) {
    let o = yW(e, t, n, r.lastChild, i + 1);
    if (o)
      return r.copy(r.content.replaceChild(r.childCount - 1, o));
    if (r.contentMatchAt(r.childCount).matchType(i == e.length - 1 ? n.type : e[i + 1]))
      return r.copy(r.content.append($e.from(gW(n, e, i + 1))));
  }
}
function vW(e, t) {
  if (t == 0)
    return e;
  let n = e.content.replaceChild(e.childCount - 1, vW(e.lastChild, t - 1)), r = e.contentMatchAt(e.childCount).fillBefore($e.empty, !0);
  return e.copy(n.append(r));
}
function ST(e, t, n, r, i, o) {
  let s = t < 0 ? e.firstChild : e.lastChild, a = s.content;
  return e.childCount > 1 && (o = 0), i < r - 1 && (a = ST(a, t, n, r, i + 1, o)), i >= n && (a = t < 0 ? s.contentMatchAt(0).fillBefore(a, o <= i).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore($e.empty, !0))), e.replaceChild(t < 0 ? 0 : e.childCount - 1, s.copy(a));
}
function a5(e, t, n) {
  return t < e.openStart && (e = new Qe(ST(e.content, -1, t, e.openStart, 0, e.openEnd), t, e.openEnd)), n < e.openEnd && (e = new Qe(ST(e.content, 1, n, e.openEnd, 0, 0), e.openStart, n)), e;
}
const bW = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let l5 = null;
function xW() {
  return l5 || (l5 = document.implementation.createHTMLDocument("title"));
}
let JC = null;
function WRe(e) {
  let t = window.trustedTypes;
  return t ? (JC || (JC = t.defaultPolicy || t.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), JC.createHTML(e)) : e;
}
function qRe(e) {
  let t = /^(\s*<meta [^>]*>)*/.exec(e);
  t && (e = e.slice(t[0].length));
  let n = xW().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(e), i;
  if ((i = r && bW[r[1].toLowerCase()]) && (e = i.map((o) => "<" + o + ">").join("") + e + i.map((o) => "</" + o + ">").reverse().join("")), n.innerHTML = WRe(e), i)
    for (let o = 0; o < i.length; o++)
      n = n.querySelector(i[o]) || n;
  return n;
}
function GRe(e) {
  let t = e.querySelectorAll(Vr ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < t.length; n++) {
    let r = t[n];
    r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "), r);
  }
}
function KRe(e, t) {
  if (!e.size)
    return e;
  let n = e.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(t);
  } catch {
    return e;
  }
  let { content: i, openStart: o, openEnd: s } = e;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let c = n.nodes[r[a]];
    if (!c || c.hasRequiredAttrs())
      break;
    i = $e.from(c.create(r[a + 1], i)), o++, s++;
  }
  return new Qe(i, o, s);
}
const Ri = {}, Oi = {}, ZRe = { touchstart: !0, touchmove: !0 };
class YRe {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.badSafariComposition = !1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function XRe(e) {
  for (let t in Ri) {
    let n = Ri[t];
    e.dom.addEventListener(t, e.input.eventHandlers[t] = (r) => {
      QRe(e, r) && !TN(e, r) && (e.editable || !(r.type in Oi)) && n(e, r);
    }, ZRe[t] ? { passive: !0 } : void 0);
  }
  ii && e.dom.addEventListener("input", () => null), kT(e);
}
function fc(e, t) {
  e.input.lastSelectionOrigin = t, e.input.lastSelectionTime = Date.now();
}
function JRe(e) {
  e.domObserver.stop();
  for (let t in e.input.eventHandlers)
    e.dom.removeEventListener(t, e.input.eventHandlers[t]);
  clearTimeout(e.input.composingTimeout), clearTimeout(e.input.lastIOSEnterFallbackTimeout);
}
function kT(e) {
  e.someProp("handleDOMEvents", (t) => {
    for (let n in t)
      e.input.eventHandlers[n] || e.dom.addEventListener(n, e.input.eventHandlers[n] = (r) => TN(e, r));
  });
}
function TN(e, t) {
  return e.someProp("handleDOMEvents", (n) => {
    let r = n[t.type];
    return r ? r(e, t) || t.defaultPrevented : !1;
  });
}
function QRe(e, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let n = t.target; n != e.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(t))
      return !1;
  return !0;
}
function e2e(e, t) {
  !TN(e, t) && Ri[t.type] && (e.editable || !(t.type in Oi)) && Ri[t.type](e, t);
}
Oi.keydown = (e, t) => {
  let n = t;
  if (e.input.shiftKey = n.keyCode == 16 || n.shiftKey, !SW(e, n) && (e.input.lastKeyCode = n.keyCode, e.input.lastKeyCodeTime = Date.now(), !(Ha && Vr && n.keyCode == 13)))
    if (n.keyCode != 229 && e.domObserver.forceFlush(), yh && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      e.input.lastIOSEnter = r, e.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        e.input.lastIOSEnter == r && (e.someProp("handleKeyDown", (i) => i(e, Nu(13, "Enter"))), e.input.lastIOSEnter = 0);
      }, 200);
    } else e.someProp("handleKeyDown", (r) => r(e, n)) || FRe(e, n) ? n.preventDefault() : fc(e, "key");
};
Oi.keyup = (e, t) => {
  t.keyCode == 16 && (e.input.shiftKey = !1);
};
Oi.keypress = (e, t) => {
  let n = t;
  if (SW(e, n) || !n.charCode || n.ctrlKey && !n.altKey || jo && n.metaKey)
    return;
  if (e.someProp("handleKeyPress", (i) => i(e, n))) {
    n.preventDefault();
    return;
  }
  let r = e.state.selection;
  if (!(r instanceof kt) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(n.charCode), o = () => e.state.tr.insertText(i).scrollIntoView();
    !/[\r\n]/.test(i) && !e.someProp("handleTextInput", (s) => s(e, r.$from.pos, r.$to.pos, i, o)) && e.dispatch(o()), n.preventDefault();
  }
};
function Jw(e) {
  return { left: e.clientX, top: e.clientY };
}
function t2e(e, t) {
  let n = t.x - e.clientX, r = t.y - e.clientY;
  return n * n + r * r < 100;
}
function AN(e, t, n, r, i) {
  if (r == -1)
    return !1;
  let o = e.state.doc.resolve(r);
  for (let s = o.depth + 1; s > 0; s--)
    if (e.someProp(t, (a) => s > o.depth ? a(e, n, o.nodeAfter, o.before(s), i, !0) : a(e, n, o.node(s), o.before(s), i, !1)))
      return !0;
  return !1;
}
function eh(e, t, n) {
  if (e.focused || e.focus(), e.state.selection.eq(t))
    return;
  let r = e.state.tr.setSelection(t);
  r.setMeta("pointer", !0), e.dispatch(r);
}
function n2e(e, t) {
  if (t == -1)
    return !1;
  let n = e.state.doc.resolve(t), r = n.nodeAfter;
  return r && r.isAtom && ht.isSelectable(r) ? (eh(e, new ht(n)), !0) : !1;
}
function r2e(e, t) {
  if (t == -1)
    return !1;
  let n = e.state.selection, r, i;
  n instanceof ht && (r = n.node);
  let o = e.state.doc.resolve(t);
  for (let s = o.depth + 1; s > 0; s--) {
    let a = s > o.depth ? o.nodeAfter : o.node(s);
    if (ht.isSelectable(a)) {
      r && n.$from.depth > 0 && s >= n.$from.depth && o.before(n.$from.depth + 1) == n.$from.pos ? i = o.before(n.$from.depth) : i = o.before(s);
      break;
    }
  }
  return i != null ? (eh(e, ht.create(e.state.doc, i)), !0) : !1;
}
function i2e(e, t, n, r, i) {
  return AN(e, "handleClickOn", t, n, r) || e.someProp("handleClick", (o) => o(e, t, r)) || (i ? r2e(e, n) : n2e(e, n));
}
function o2e(e, t, n, r) {
  return AN(e, "handleDoubleClickOn", t, n, r) || e.someProp("handleDoubleClick", (i) => i(e, t, r));
}
function s2e(e, t, n, r) {
  return AN(e, "handleTripleClickOn", t, n, r) || e.someProp("handleTripleClick", (i) => i(e, t, r)) || a2e(e, n, r);
}
function a2e(e, t, n) {
  if (n.button != 0)
    return !1;
  let r = e.state.doc;
  if (t == -1)
    return r.inlineContent ? (eh(e, kt.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(t);
  for (let o = i.depth + 1; o > 0; o--) {
    let s = o > i.depth ? i.nodeAfter : i.node(o), a = i.before(o);
    if (s.inlineContent)
      eh(e, kt.create(r, a + 1, a + 1 + s.content.size));
    else if (ht.isSelectable(s))
      eh(e, ht.create(r, a));
    else
      continue;
    return !0;
  }
}
function MN(e) {
  return ix(e);
}
const wW = jo ? "metaKey" : "ctrlKey";
Ri.mousedown = (e, t) => {
  let n = t;
  e.input.shiftKey = n.shiftKey;
  let r = MN(e), i = Date.now(), o = "singleClick";
  i - e.input.lastClick.time < 500 && t2e(n, e.input.lastClick) && !n[wW] && e.input.lastClick.button == n.button && (e.input.lastClick.type == "singleClick" ? o = "doubleClick" : e.input.lastClick.type == "doubleClick" && (o = "tripleClick")), e.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: o, button: n.button };
  let s = e.posAtCoords(Jw(n));
  s && (o == "singleClick" ? (e.input.mouseDown && e.input.mouseDown.done(), e.input.mouseDown = new l2e(e, s, n, !!r)) : (o == "doubleClick" ? o2e : s2e)(e, s.pos, s.inside, n) ? n.preventDefault() : fc(e, "pointer"));
};
class l2e {
  constructor(t, n, r, i) {
    this.view = t, this.pos = n, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = t.state.doc, this.selectNode = !!r[wW], this.allowDefault = r.shiftKey;
    let o, s;
    if (n.inside > -1)
      o = t.state.doc.nodeAt(n.inside), s = n.inside;
    else {
      let f = t.state.doc.resolve(n.pos);
      o = f.parent, s = f.depth ? f.before() : 0;
    }
    const a = i ? null : r.target, c = a ? t.docView.nearestDesc(a, !0) : null;
    this.target = c && c.nodeDOM.nodeType == 1 ? c.nodeDOM : null;
    let { selection: u } = t.state;
    (r.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1 || u instanceof ht && u.from <= s && u.to > s) && (this.mightDrag = {
      node: o,
      pos: s,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Vo && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), t.root.addEventListener("mouseup", this.up = this.up.bind(this)), t.root.addEventListener("mousemove", this.move = this.move.bind(this)), fc(t, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Ka(this.view)), this.view.input.mouseDown = null;
  }
  up(t) {
    if (this.done(), !this.view.dom.contains(t.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Jw(t))), this.updateAllowDefault(t), this.allowDefault || !n ? fc(this.view, "pointer") : i2e(this.view, n.pos, n.inside, t, this.selectNode) ? t.preventDefault() : t.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    ii && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Vr && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (eh(this.view, zt.near(this.view.state.doc.resolve(n.pos))), t.preventDefault()) : fc(this.view, "pointer");
  }
  move(t) {
    this.updateAllowDefault(t), fc(this.view, "pointer"), t.buttons == 0 && this.done();
  }
  updateAllowDefault(t) {
    !this.allowDefault && (Math.abs(this.event.x - t.clientX) > 4 || Math.abs(this.event.y - t.clientY) > 4) && (this.allowDefault = !0);
  }
}
Ri.touchstart = (e) => {
  e.input.lastTouch = Date.now(), MN(e), fc(e, "pointer");
};
Ri.touchmove = (e) => {
  e.input.lastTouch = Date.now(), fc(e, "pointer");
};
Ri.contextmenu = (e) => MN(e);
function SW(e, t) {
  return e.composing ? !0 : ii && Math.abs(t.timeStamp - e.input.compositionEndedAt) < 500 ? (e.input.compositionEndedAt = -2e8, !0) : !1;
}
const c2e = Ha ? 5e3 : -1;
Oi.compositionstart = Oi.compositionupdate = (e) => {
  if (!e.composing) {
    e.domObserver.flush();
    let { state: t } = e, n = t.selection.$to;
    if (t.selection instanceof kt && (t.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1) || Vr && QH && u2e(e)))
      e.markCursor = e.state.storedMarks || n.marks(), ix(e, !0), e.markCursor = null;
    else if (ix(e, !t.selection.empty), Vo && t.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = e.domSelectionRange();
      for (let i = r.focusNode, o = r.focusOffset; i && i.nodeType == 1 && o != 0; ) {
        let s = o < 0 ? i.lastChild : i.childNodes[o - 1];
        if (!s)
          break;
        if (s.nodeType == 3) {
          let a = e.domSelection();
          a && a.collapse(s, s.nodeValue.length);
          break;
        } else
          i = s, o = -1;
      }
    }
    e.input.composing = !0;
  }
  kW(e, c2e);
};
function u2e(e) {
  let { focusNode: t, focusOffset: n } = e.domSelectionRange();
  if (!t || t.nodeType != 1 || n >= t.childNodes.length)
    return !1;
  let r = t.childNodes[n];
  return r.nodeType == 1 && r.contentEditable == "false";
}
Oi.compositionend = (e, t) => {
  e.composing && (e.input.composing = !1, e.input.compositionEndedAt = t.timeStamp, e.input.compositionPendingChanges = e.domObserver.pendingRecords().length ? e.input.compositionID : 0, e.input.compositionNode = null, e.input.badSafariComposition ? e.domObserver.forceFlush() : e.input.compositionPendingChanges && Promise.resolve().then(() => e.domObserver.flush()), e.input.compositionID++, kW(e, 20));
};
function kW(e, t) {
  clearTimeout(e.input.composingTimeout), t > -1 && (e.input.composingTimeout = setTimeout(() => ix(e), t));
}
function CW(e) {
  for (e.composing && (e.input.composing = !1, e.input.compositionEndedAt = f2e()); e.input.compositionNodes.length > 0; )
    e.input.compositionNodes.pop().markParentsDirty();
}
function d2e(e) {
  let t = e.domSelectionRange();
  if (!t.focusNode)
    return null;
  let n = rRe(t.focusNode, t.focusOffset), r = iRe(t.focusNode, t.focusOffset);
  if (n && r && n != r) {
    let i = r.pmViewDesc, o = e.domObserver.lastChangedTextNode;
    if (n == o || r == o)
      return o;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (e.input.compositionNode == r) {
      let s = n.pmViewDesc;
      if (!(!s || !s.isText(n.nodeValue)))
        return r;
    }
  }
  return n || r;
}
function f2e() {
  let e = document.createEvent("Event");
  return e.initEvent("event", !0, !0), e.timeStamp;
}
function ix(e, t = !1) {
  if (!(Ha && e.domObserver.flushingSoon >= 0)) {
    if (e.domObserver.forceFlush(), CW(e), t || e.docView && e.docView.dirty) {
      let n = CN(e), r = e.state.selection;
      return n && !n.eq(r) ? e.dispatch(e.state.tr.setSelection(n)) : (e.markCursor || t) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? e.dispatch(e.state.tr.deleteSelection()) : e.updateState(e.state), !0;
    }
    return !1;
  }
}
function h2e(e, t) {
  if (!e.dom.parentNode)
    return;
  let n = e.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(t), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(t), e.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), e.focus();
  }, 50);
}
const xg = Ki && vc < 15 || yh && lRe < 604;
Ri.copy = Oi.cut = (e, t) => {
  let n = t, r = e.state.selection, i = n.type == "cut";
  if (r.empty)
    return;
  let o = xg ? null : n.clipboardData, s = r.content(), { dom: a, text: c } = _N(e, s);
  o ? (n.preventDefault(), o.clearData(), o.setData("text/html", a.innerHTML), o.setData("text/plain", c)) : h2e(e, a), i && e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function p2e(e) {
  return e.openStart == 0 && e.openEnd == 0 && e.content.childCount == 1 ? e.content.firstChild : null;
}
function m2e(e, t) {
  if (!e.dom.parentNode)
    return;
  let n = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code, r = e.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = e.input.shiftKey && e.input.lastKeyCode != 45;
  setTimeout(() => {
    e.focus(), r.parentNode && r.parentNode.removeChild(r), n ? wg(e, r.value, null, i, t) : wg(e, r.textContent, r.innerHTML, i, t);
  }, 50);
}
function wg(e, t, n, r, i) {
  let o = mW(e, t, n, r, e.state.selection.$from);
  if (e.someProp("handlePaste", (c) => c(e, i, o || Qe.empty)))
    return !0;
  if (!o)
    return !1;
  let s = p2e(o), a = s ? e.state.tr.replaceSelectionWith(s, r) : e.state.tr.replaceSelection(o);
  return e.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function EW(e) {
  let t = e.getData("text/plain") || e.getData("Text");
  if (t)
    return t;
  let n = e.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
Oi.paste = (e, t) => {
  let n = t;
  if (e.composing && !Ha)
    return;
  let r = xg ? null : n.clipboardData, i = e.input.shiftKey && e.input.lastKeyCode != 45;
  r && wg(e, EW(r), r.getData("text/html"), i, n) ? n.preventDefault() : m2e(e, n);
};
class _W {
  constructor(t, n, r) {
    this.slice = t, this.move = n, this.node = r;
  }
}
const g2e = jo ? "altKey" : "ctrlKey";
function TW(e, t) {
  let n = e.someProp("dragCopies", (r) => !r(t));
  return n ?? !t[g2e];
}
Ri.dragstart = (e, t) => {
  let n = t, r = e.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let i = e.state.selection, o = i.empty ? null : e.posAtCoords(Jw(n)), s;
  if (!(o && o.pos >= i.from && o.pos <= (i instanceof ht ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      s = ht.create(e.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let h = e.docView.nearestDesc(n.target, !0);
      h && h.node.type.spec.draggable && h != e.docView && (s = ht.create(e.state.doc, h.posBefore));
    }
  }
  let a = (s || e.state.selection).content(), { dom: c, text: u, slice: f } = _N(e, a);
  (!n.dataTransfer.files.length || !Vr || JH > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(xg ? "Text" : "text/html", c.innerHTML), n.dataTransfer.effectAllowed = "copyMove", xg || n.dataTransfer.setData("text/plain", u), e.dragging = new _W(f, TW(e, n), s);
};
Ri.dragend = (e) => {
  let t = e.dragging;
  window.setTimeout(() => {
    e.dragging == t && (e.dragging = null);
  }, 50);
};
Oi.dragover = Oi.dragenter = (e, t) => t.preventDefault();
Oi.drop = (e, t) => {
  try {
    y2e(e, t, e.dragging);
  } finally {
    e.dragging = null;
  }
};
function y2e(e, t, n) {
  if (!t.dataTransfer)
    return;
  let r = e.posAtCoords(Jw(t));
  if (!r)
    return;
  let i = e.state.doc.resolve(r.pos), o = n && n.slice;
  o ? e.someProp("transformPasted", (g) => {
    o = g(o, e, !1);
  }) : o = mW(e, EW(t.dataTransfer), xg ? null : t.dataTransfer.getData("text/html"), !1, i);
  let s = !!(n && TW(e, t));
  if (e.someProp("handleDrop", (g) => g(e, t, o || Qe.empty, s))) {
    t.preventDefault();
    return;
  }
  if (!o)
    return;
  t.preventDefault();
  let a = o ? RH(e.state.doc, i.pos, o) : i.pos;
  a == null && (a = i.pos);
  let c = e.state.tr;
  if (s) {
    let { node: g } = n;
    g ? g.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(a), f = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, h = c.doc;
  if (f ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(h))
    return;
  let m = c.doc.resolve(u);
  if (f && ht.isSelectable(o.content.firstChild) && m.nodeAfter && m.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new ht(m));
  else {
    let g = c.mapping.map(a);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((b, x, w, S) => g = S), c.setSelection(EN(e, m, c.doc.resolve(g)));
  }
  e.focus(), e.dispatch(c.setMeta("uiEvent", "drop"));
}
Ri.focus = (e) => {
  e.input.lastFocus = Date.now(), e.focused || (e.domObserver.stop(), e.dom.classList.add("ProseMirror-focused"), e.domObserver.start(), e.focused = !0, setTimeout(() => {
    e.docView && e.hasFocus() && !e.domObserver.currentSelection.eq(e.domSelectionRange()) && Ka(e);
  }, 20));
};
Ri.blur = (e, t) => {
  let n = t;
  e.focused && (e.domObserver.stop(), e.dom.classList.remove("ProseMirror-focused"), e.domObserver.start(), n.relatedTarget && e.dom.contains(n.relatedTarget) && e.domObserver.currentSelection.clear(), e.focused = !1);
};
Ri.beforeinput = (e, t) => {
  if (Vr && Ha && t.inputType == "deleteContentBackward") {
    e.domObserver.flushSoon();
    let { domChangeCount: r } = e.input;
    setTimeout(() => {
      if (e.input.domChangeCount != r || (e.dom.blur(), e.focus(), e.someProp("handleKeyDown", (o) => o(e, Nu(8, "Backspace")))))
        return;
      let { $cursor: i } = e.state.selection;
      i && i.pos > 0 && e.dispatch(e.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let e in Oi)
  Ri[e] = Oi[e];
function Sg(e, t) {
  if (e == t)
    return !0;
  for (let n in e)
    if (e[n] !== t[n])
      return !1;
  for (let n in t)
    if (!(n in e))
      return !1;
  return !0;
}
class ox {
  constructor(t, n) {
    this.toDOM = t, this.spec = n || Hu, this.side = this.spec.side || 0;
  }
  map(t, n, r, i) {
    let { pos: o, deleted: s } = t.mapResult(n.from + i, this.side < 0 ? -1 : 1);
    return s ? null : new gi(o - r, o - r, this);
  }
  valid() {
    return !0;
  }
  eq(t) {
    return this == t || t instanceof ox && (this.spec.key && this.spec.key == t.spec.key || this.toDOM == t.toDOM && Sg(this.spec, t.spec));
  }
  destroy(t) {
    this.spec.destroy && this.spec.destroy(t);
  }
}
class xc {
  constructor(t, n) {
    this.attrs = t, this.spec = n || Hu;
  }
  map(t, n, r, i) {
    let o = t.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r, s = t.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return o >= s ? null : new gi(o, s, this);
  }
  valid(t, n) {
    return n.from < n.to;
  }
  eq(t) {
    return this == t || t instanceof xc && Sg(this.attrs, t.attrs) && Sg(this.spec, t.spec);
  }
  static is(t) {
    return t.type instanceof xc;
  }
  destroy() {
  }
}
class NN {
  constructor(t, n) {
    this.attrs = t, this.spec = n || Hu;
  }
  map(t, n, r, i) {
    let o = t.mapResult(n.from + i, 1);
    if (o.deleted)
      return null;
    let s = t.mapResult(n.to + i, -1);
    return s.deleted || s.pos <= o.pos ? null : new gi(o.pos - r, s.pos - r, this);
  }
  valid(t, n) {
    let { index: r, offset: i } = t.content.findIndex(n.from), o;
    return i == n.from && !(o = t.child(r)).isText && i + o.nodeSize == n.to;
  }
  eq(t) {
    return this == t || t instanceof NN && Sg(this.attrs, t.attrs) && Sg(this.spec, t.spec);
  }
  destroy() {
  }
}
class gi {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.from = t, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(t, n) {
    return new gi(t, n, this.type);
  }
  /**
  @internal
  */
  eq(t, n = 0) {
    return this.type.eq(t.type) && this.from + n == t.from && this.to + n == t.to;
  }
  /**
  @internal
  */
  map(t, n, r) {
    return this.type.map(t, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(t, n, r) {
    return new gi(t, t, new ox(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(t, n, r, i) {
    return new gi(t, n, new xc(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(t, n, r, i) {
    return new gi(t, n, new NN(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof xc;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof ox;
  }
}
const Mf = [], Hu = {};
class qn {
  /**
  @internal
  */
  constructor(t, n) {
    this.local = t.length ? t : Mf, this.children = n.length ? n : Mf;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(t, n) {
    return n.length ? sx(n, t, 0, Hu) : fi;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(t, n, r) {
    let i = [];
    return this.findInner(t ?? 0, n ?? 1e9, i, 0, r), i;
  }
  findInner(t, n, r, i, o) {
    for (let s = 0; s < this.local.length; s++) {
      let a = this.local[s];
      a.from <= n && a.to >= t && (!o || o(a.spec)) && r.push(a.copy(a.from + i, a.to + i));
    }
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] < n && this.children[s + 1] > t) {
        let a = this.children[s] + 1;
        this.children[s + 2].findInner(t - a, n - a, r, i + a, o);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(t, n, r) {
    return this == fi || t.maps.length == 0 ? this : this.mapInner(t, n, 0, 0, r || Hu);
  }
  /**
  @internal
  */
  mapInner(t, n, r, i, o) {
    let s;
    for (let a = 0; a < this.local.length; a++) {
      let c = this.local[a].map(t, r, i);
      c && c.type.valid(n, c) ? (s || (s = [])).push(c) : o.onRemove && o.onRemove(this.local[a].spec);
    }
    return this.children.length ? v2e(this.children, s || [], t, n, r, i, o) : s ? new qn(s.sort(Wu), Mf) : fi;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(t, n) {
    return n.length ? this == fi ? qn.create(t, n) : this.addInner(t, n, 0) : this;
  }
  addInner(t, n, r) {
    let i, o = 0;
    t.forEach((a, c) => {
      let u = c + r, f;
      if (f = MW(n, a, u)) {
        for (i || (i = this.children.slice()); o < i.length && i[o] < c; )
          o += 3;
        i[o] == c ? i[o + 2] = i[o + 2].addInner(a, f, u + 1) : i.splice(o, 0, c, c + a.nodeSize, sx(f, a, u + 1, Hu)), o += 3;
      }
    });
    let s = AW(o ? NW(n) : n, -r);
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(t, s[a]) || s.splice(a--, 1);
    return new qn(s.length ? this.local.concat(s).sort(Wu) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(t) {
    return t.length == 0 || this == fi ? this : this.removeInner(t, 0);
  }
  removeInner(t, n) {
    let r = this.children, i = this.local;
    for (let o = 0; o < r.length; o += 3) {
      let s, a = r[o] + n, c = r[o + 1] + n;
      for (let f = 0, h; f < t.length; f++)
        (h = t[f]) && h.from > a && h.to < c && (t[f] = null, (s || (s = [])).push(h));
      if (!s)
        continue;
      r == this.children && (r = this.children.slice());
      let u = r[o + 2].removeInner(s, a + 1);
      u != fi ? r[o + 2] = u : (r.splice(o, 3), o -= 3);
    }
    if (i.length) {
      for (let o = 0, s; o < t.length; o++)
        if (s = t[o])
          for (let a = 0; a < i.length; a++)
            i[a].eq(s, n) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new qn(i, r) : fi;
  }
  forChild(t, n) {
    if (this == fi)
      return this;
    if (n.isLeaf)
      return qn.empty;
    let r, i;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= t) {
        this.children[a] == t && (r = this.children[a + 2]);
        break;
      }
    let o = t + 1, s = o + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let c = this.local[a];
      if (c.from < s && c.to > o && c.type instanceof xc) {
        let u = Math.max(o, c.from) - o, f = Math.min(s, c.to) - o;
        u < f && (i || (i = [])).push(c.copy(u, f));
      }
    }
    if (i) {
      let a = new qn(i.sort(Wu), Mf);
      return r ? new ic([a, r]) : a;
    }
    return r || fi;
  }
  /**
  @internal
  */
  eq(t) {
    if (this == t)
      return !0;
    if (!(t instanceof qn) || this.local.length != t.local.length || this.children.length != t.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(t.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != t.children[n] || this.children[n + 1] != t.children[n + 1] || !this.children[n + 2].eq(t.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(t) {
    return RN(this.localsInner(t));
  }
  /**
  @internal
  */
  localsInner(t) {
    if (this == fi)
      return Mf;
    if (t.inlineContent || !this.local.some(xc.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof xc || n.push(this.local[r]);
    return n;
  }
  forEachSet(t) {
    t(this);
  }
}
qn.empty = new qn([], []);
qn.removeOverlap = RN;
const fi = qn.empty;
class ic {
  constructor(t) {
    this.members = t;
  }
  map(t, n) {
    const r = this.members.map((i) => i.map(t, n, Hu));
    return ic.from(r);
  }
  forChild(t, n) {
    if (n.isLeaf)
      return qn.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].forChild(t, n);
      o != fi && (o instanceof ic ? r = r.concat(o.members) : r.push(o));
    }
    return ic.from(r);
  }
  eq(t) {
    if (!(t instanceof ic) || t.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(t.members[n]))
        return !1;
    return !0;
  }
  locals(t) {
    let n, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].localsInner(t);
      if (o.length)
        if (!n)
          n = o;
        else {
          r && (n = n.slice(), r = !1);
          for (let s = 0; s < o.length; s++)
            n.push(o[s]);
        }
    }
    return n ? RN(r ? n : n.sort(Wu)) : Mf;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(t) {
    switch (t.length) {
      case 0:
        return fi;
      case 1:
        return t[0];
      default:
        return new ic(t.every((n) => n instanceof qn) ? t : t.reduce((n, r) => n.concat(r instanceof qn ? r : r.members), []));
    }
  }
  forEachSet(t) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(t);
  }
}
function v2e(e, t, n, r, i, o, s) {
  let a = e.slice();
  for (let u = 0, f = o; u < n.maps.length; u++) {
    let h = 0;
    n.maps[u].forEach((m, g, b, x) => {
      let w = x - b - (g - m);
      for (let S = 0; S < a.length; S += 3) {
        let _ = a[S + 1];
        if (_ < 0 || m > _ + f - h)
          continue;
        let M = a[S] + f - h;
        g >= M ? a[S + 1] = m <= M ? -2 : -1 : m >= f && w && (a[S] += w, a[S + 1] += w);
      }
      h += w;
    }), f = n.maps[u].map(f, -1);
  }
  let c = !1;
  for (let u = 0; u < a.length; u += 3)
    if (a[u + 1] < 0) {
      if (a[u + 1] == -2) {
        c = !0, a[u + 1] = -1;
        continue;
      }
      let f = n.map(e[u] + o), h = f - i;
      if (h < 0 || h >= r.content.size) {
        c = !0;
        continue;
      }
      let m = n.map(e[u + 1] + o, -1), g = m - i, { index: b, offset: x } = r.content.findIndex(h), w = r.maybeChild(b);
      if (w && x == h && x + w.nodeSize == g) {
        let S = a[u + 2].mapInner(n, w, f + 1, e[u] + o + 1, s);
        S != fi ? (a[u] = h, a[u + 1] = g, a[u + 2] = S) : (a[u + 1] = -2, c = !0);
      } else
        c = !0;
    }
  if (c) {
    let u = b2e(a, e, t, n, i, o, s), f = sx(u, r, 0, s);
    t = f.local;
    for (let h = 0; h < a.length; h += 3)
      a[h + 1] < 0 && (a.splice(h, 3), h -= 3);
    for (let h = 0, m = 0; h < f.children.length; h += 3) {
      let g = f.children[h];
      for (; m < a.length && a[m] < g; )
        m += 3;
      a.splice(m, 0, f.children[h], f.children[h + 1], f.children[h + 2]);
    }
  }
  return new qn(t.sort(Wu), a);
}
function AW(e, t) {
  if (!t || !e.length)
    return e;
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    n.push(new gi(i.from + t, i.to + t, i.type));
  }
  return n;
}
function b2e(e, t, n, r, i, o, s) {
  function a(c, u) {
    for (let f = 0; f < c.local.length; f++) {
      let h = c.local[f].map(r, i, u);
      h ? n.push(h) : s.onRemove && s.onRemove(c.local[f].spec);
    }
    for (let f = 0; f < c.children.length; f += 3)
      a(c.children[f + 2], c.children[f] + u + 1);
  }
  for (let c = 0; c < e.length; c += 3)
    e[c + 1] == -1 && a(e[c + 2], t[c] + o + 1);
  return n;
}
function MW(e, t, n) {
  if (t.isLeaf)
    return null;
  let r = n + t.nodeSize, i = null;
  for (let o = 0, s; o < e.length; o++)
    (s = e[o]) && s.from > n && s.to < r && ((i || (i = [])).push(s), e[o] = null);
  return i;
}
function NW(e) {
  let t = [];
  for (let n = 0; n < e.length; n++)
    e[n] != null && t.push(e[n]);
  return t;
}
function sx(e, t, n, r) {
  let i = [], o = !1;
  t.forEach((a, c) => {
    let u = MW(e, a, c + n);
    if (u) {
      o = !0;
      let f = sx(u, a, n + c + 1, r);
      f != fi && i.push(c, c + a.nodeSize, f);
    }
  });
  let s = AW(o ? NW(e) : e, -n).sort(Wu);
  for (let a = 0; a < s.length; a++)
    s[a].type.valid(t, s[a]) || (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
  return s.length || i.length ? new qn(s, i) : fi;
}
function Wu(e, t) {
  return e.from - t.from || e.to - t.to;
}
function RN(e) {
  let t = e;
  for (let n = 0; n < t.length - 1; n++) {
    let r = t[n];
    if (r.from != r.to)
      for (let i = n + 1; i < t.length; i++) {
        let o = t[i];
        if (o.from == r.from) {
          o.to != r.to && (t == e && (t = e.slice()), t[i] = o.copy(o.from, r.to), c5(t, i + 1, o.copy(r.to, o.to)));
          continue;
        } else {
          o.from < r.to && (t == e && (t = e.slice()), t[n] = r.copy(r.from, o.from), c5(t, i, r.copy(o.from, r.to)));
          break;
        }
      }
  }
  return t;
}
function c5(e, t, n) {
  for (; t < e.length && Wu(n, e[t]) > 0; )
    t++;
  e.splice(t, 0, n);
}
function QC(e) {
  let t = [];
  return e.someProp("decorations", (n) => {
    let r = n(e.state);
    r && r != fi && t.push(r);
  }), e.cursorWrapper && t.push(qn.create(e.state.doc, [e.cursorWrapper.deco])), ic.from(t);
}
const x2e = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, w2e = Ki && vc <= 11;
class S2e {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(t) {
    this.anchorNode = t.anchorNode, this.anchorOffset = t.anchorOffset, this.focusNode = t.focusNode, this.focusOffset = t.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(t) {
    return t.anchorNode == this.anchorNode && t.anchorOffset == this.anchorOffset && t.focusNode == this.focusNode && t.focusOffset == this.focusOffset;
  }
}
class k2e {
  constructor(t, n) {
    this.view = t, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new S2e(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      Ki && vc <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : ii && t.composing && r.some((i) => i.type == "childList" && i.target.nodeName == "TR") ? (t.input.badSafariComposition = !0, this.flushSoon()) : this.flush();
    }), w2e && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, x2e)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let t = this.observer.takeRecords();
      if (t.length) {
        for (let n = 0; n < t.length; n++)
          this.queue.push(t[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (t5(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Ka(this.view);
      if (Ki && vc <= 11 && !this.view.state.selection.empty) {
        let t = this.view.domSelectionRange();
        if (t.focusNode && od(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(t) {
    if (!t.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let o = t.focusNode; o; o = gh(o))
      n.add(o);
    for (let o = t.anchorNode; o; o = gh(o))
      if (n.has(o)) {
        r = o;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let t of this.observer.takeRecords())
        this.queue.push(t);
    return this.queue;
  }
  flush() {
    let { view: t } = this;
    if (!t.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = t.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && t5(t) && !this.ignoreSelectionChange(r), o = -1, s = -1, a = !1, c = [];
    if (t.editable)
      for (let f = 0; f < n.length; f++) {
        let h = this.registerMutation(n[f], c);
        h && (o = o < 0 ? h.from : Math.min(h.from, o), s = s < 0 ? h.to : Math.max(h.to, s), h.typeOver && (a = !0));
      }
    if (Vo && c.length) {
      let f = c.filter((h) => h.nodeName == "BR");
      if (f.length == 2) {
        let [h, m] = f;
        h.parentNode && h.parentNode.parentNode == m.parentNode ? m.remove() : h.remove();
      } else {
        let { focusNode: h } = this.currentSelection;
        for (let m of f) {
          let g = m.parentNode;
          g && g.nodeName == "LI" && (!h || _2e(t, h) != g) && m.remove();
        }
      }
    } else if ((Vr || ii) && c.some((f) => f.nodeName == "BR") && (t.input.lastKeyCode == 8 || t.input.lastKeyCode == 46)) {
      for (let f of c)
        if (f.nodeName == "BR" && f.parentNode) {
          let h = f.nextSibling;
          h && h.nodeType == 1 && h.contentEditable == "false" && f.parentNode.removeChild(f);
        }
    }
    let u = null;
    o < 0 && i && t.input.lastFocus > Date.now() - 200 && Math.max(t.input.lastTouch, t.input.lastClick.time) < Date.now() - 300 && Yw(r) && (u = CN(t)) && u.eq(zt.near(t.state.doc.resolve(0), 1)) ? (t.input.lastFocus = 0, Ka(t), this.currentSelection.set(r), t.scrollToSelection()) : (o > -1 || i) && (o > -1 && (t.docView.markDirty(o, s), C2e(t)), t.input.badSafariComposition && (t.input.badSafariComposition = !1, T2e(t, c)), this.handleDOMChange(o, s, a, c), t.docView && t.docView.dirty ? t.updateState(t.state) : this.currentSelection.eq(r) || Ka(t), this.currentSelection.set(r));
  }
  registerMutation(t, n) {
    if (n.indexOf(t.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(t.target);
    if (t.type == "attributes" && (r == this.view.docView || t.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    t.attributeName == "style" && !t.oldValue && !t.target.getAttribute("style")) || !r || r.ignoreMutation(t))
      return null;
    if (t.type == "childList") {
      for (let f = 0; f < t.addedNodes.length; f++) {
        let h = t.addedNodes[f];
        n.push(h), h.nodeType == 3 && (this.lastChangedTextNode = h);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(t.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = t.previousSibling, o = t.nextSibling;
      if (Ki && vc <= 11 && t.addedNodes.length)
        for (let f = 0; f < t.addedNodes.length; f++) {
          let { previousSibling: h, nextSibling: m } = t.addedNodes[f];
          (!h || Array.prototype.indexOf.call(t.addedNodes, h) < 0) && (i = h), (!m || Array.prototype.indexOf.call(t.addedNodes, m) < 0) && (o = m);
        }
      let s = i && i.parentNode == t.target ? ti(i) + 1 : 0, a = r.localPosFromDOM(t.target, s, -1), c = o && o.parentNode == t.target ? ti(o) : t.target.childNodes.length, u = r.localPosFromDOM(t.target, c, 1);
      return { from: a, to: u };
    } else return t.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = t.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: t.target.nodeValue == t.oldValue
    });
  }
}
let u5 = /* @__PURE__ */ new WeakMap(), d5 = !1;
function C2e(e) {
  if (!u5.has(e) && (u5.set(e, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(e.dom).whiteSpace) !== -1)) {
    if (e.requiresGeckoHackNode = Vo, d5)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), d5 = !0;
  }
}
function f5(e, t) {
  let n = t.startContainer, r = t.startOffset, i = t.endContainer, o = t.endOffset, s = e.domAtPos(e.state.selection.anchor);
  return od(s.node, s.offset, i, o) && ([n, r, i, o] = [i, o, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o };
}
function E2e(e, t) {
  if (t.getComposedRanges) {
    let i = t.getComposedRanges(e.root)[0];
    if (i)
      return f5(e, i);
  }
  let n;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return e.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), e.dom.removeEventListener("beforeinput", r, !0), n ? f5(e, n) : null;
}
function _2e(e, t) {
  for (let n = t.parentNode; n && n != e.dom; n = n.parentNode) {
    let r = e.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock)
      return n;
  }
  return null;
}
function T2e(e, t) {
  var n;
  let { focusNode: r, focusOffset: i } = e.domSelectionRange();
  for (let o of t)
    if (((n = o.parentNode) === null || n === void 0 ? void 0 : n.nodeName) == "TR") {
      let s = o.nextSibling;
      for (; s && s.nodeName != "TD" && s.nodeName != "TH"; )
        s = s.nextSibling;
      if (s) {
        let a = s;
        for (; ; ) {
          let c = a.firstChild;
          if (!c || c.nodeType != 1 || c.contentEditable == "false" || /^(BR|IMG)$/.test(c.nodeName))
            break;
          a = c;
        }
        a.insertBefore(o, a.firstChild), r == o && e.domSelection().collapse(o, i);
      } else
        o.parentNode.removeChild(o);
    }
}
function A2e(e, t, n) {
  let { node: r, fromOffset: i, toOffset: o, from: s, to: a } = e.docView.parseRange(t, n), c = e.domSelectionRange(), u, f = c.anchorNode;
  if (f && e.dom.contains(f.nodeType == 1 ? f : f.parentNode) && (u = [{ node: f, offset: c.anchorOffset }], Yw(c) || u.push({ node: c.focusNode, offset: c.focusOffset })), Vr && e.input.lastKeyCode === 8)
    for (let w = o; w > i; w--) {
      let S = r.childNodes[w - 1], _ = S.pmViewDesc;
      if (S.nodeName == "BR" && !_) {
        o = w;
        break;
      }
      if (!_ || _.size)
        break;
    }
  let h = e.state.doc, m = e.someProp("domParser") || yc.fromSchema(e.state.schema), g = h.resolve(s), b = null, x = m.parse(r, {
    topNode: g.parent,
    topMatch: g.parent.contentMatchAt(g.index()),
    topOpen: !0,
    from: i,
    to: o,
    preserveWhitespace: g.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: u,
    ruleFromNode: M2e,
    context: g
  });
  if (u && u[0].pos != null) {
    let w = u[0].pos, S = u[1] && u[1].pos;
    S == null && (S = w), b = { anchor: w + s, head: S + s };
  }
  return { doc: x, sel: b, from: s, to: a };
}
function M2e(e) {
  let t = e.pmViewDesc;
  if (t)
    return t.parseRule();
  if (e.nodeName == "BR" && e.parentNode) {
    if (ii && /^(ul|ol)$/i.test(e.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (e.parentNode.lastChild == e || ii && /^(tr|table)$/i.test(e.parentNode.nodeName))
      return { ignore: !0 };
  } else if (e.nodeName == "IMG" && e.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const N2e = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function R2e(e, t, n, r, i) {
  let o = e.input.compositionPendingChanges || (e.composing ? e.input.compositionID : 0);
  if (e.input.compositionPendingChanges = 0, t < 0) {
    let O = e.input.lastSelectionTime > Date.now() - 50 ? e.input.lastSelectionOrigin : null, L = CN(e, O);
    if (L && !e.state.selection.eq(L)) {
      if (Vr && Ha && e.input.lastKeyCode === 13 && Date.now() - 100 < e.input.lastKeyCodeTime && e.someProp("handleKeyDown", (B) => B(e, Nu(13, "Enter"))))
        return;
      let U = e.state.tr.setSelection(L);
      O == "pointer" ? U.setMeta("pointer", !0) : O == "key" && U.scrollIntoView(), o && U.setMeta("composition", o), e.dispatch(U);
    }
    return;
  }
  let s = e.state.doc.resolve(t), a = s.sharedDepth(n);
  t = s.before(a + 1), n = e.state.doc.resolve(n).after(a + 1);
  let c = e.state.selection, u = A2e(e, t, n), f = e.state.doc, h = f.slice(u.from, u.to), m, g;
  e.input.lastKeyCode === 8 && Date.now() - 100 < e.input.lastKeyCodeTime ? (m = e.state.selection.to, g = "end") : (m = e.state.selection.from, g = "start"), e.input.lastKeyCode = null;
  let b = P2e(h.content, u.doc.content, u.from, m, g);
  if (b && e.input.domChangeCount++, (yh && e.input.lastIOSEnter > Date.now() - 225 || Ha) && i.some((O) => O.nodeType == 1 && !N2e.test(O.nodeName)) && (!b || b.endA >= b.endB) && e.someProp("handleKeyDown", (O) => O(e, Nu(13, "Enter")))) {
    e.input.lastIOSEnter = 0;
    return;
  }
  if (!b)
    if (r && c instanceof kt && !c.empty && c.$head.sameParent(c.$anchor) && !e.composing && !(u.sel && u.sel.anchor != u.sel.head))
      b = { start: c.from, endA: c.to, endB: c.to };
    else {
      if (u.sel) {
        let O = h5(e, e.state.doc, u.sel);
        if (O && !O.eq(e.state.selection)) {
          let L = e.state.tr.setSelection(O);
          o && L.setMeta("composition", o), e.dispatch(L);
        }
      }
      return;
    }
  e.state.selection.from < e.state.selection.to && b.start == b.endB && e.state.selection instanceof kt && (b.start > e.state.selection.from && b.start <= e.state.selection.from + 2 && e.state.selection.from >= u.from ? b.start = e.state.selection.from : b.endA < e.state.selection.to && b.endA >= e.state.selection.to - 2 && e.state.selection.to <= u.to && (b.endB += e.state.selection.to - b.endA, b.endA = e.state.selection.to)), Ki && vc <= 11 && b.endB == b.start + 1 && b.endA == b.start && b.start > u.from && u.doc.textBetween(b.start - u.from - 1, b.start - u.from + 1) == " " && (b.start--, b.endA--, b.endB--);
  let x = u.doc.resolveNoCache(b.start - u.from), w = u.doc.resolveNoCache(b.endB - u.from), S = f.resolve(b.start), _ = x.sameParent(w) && x.parent.inlineContent && S.end() >= b.endA;
  if ((yh && e.input.lastIOSEnter > Date.now() - 225 && (!_ || i.some((O) => O.nodeName == "DIV" || O.nodeName == "P")) || !_ && x.pos < u.doc.content.size && (!x.sameParent(w) || !x.parent.inlineContent) && x.pos < w.pos && !/\S/.test(u.doc.textBetween(x.pos, w.pos, "", ""))) && e.someProp("handleKeyDown", (O) => O(e, Nu(13, "Enter")))) {
    e.input.lastIOSEnter = 0;
    return;
  }
  if (e.state.selection.anchor > b.start && D2e(f, b.start, b.endA, x, w) && e.someProp("handleKeyDown", (O) => O(e, Nu(8, "Backspace")))) {
    Ha && Vr && e.domObserver.suppressSelectionUpdates();
    return;
  }
  Vr && b.endB == b.start && (e.input.lastChromeDelete = Date.now()), Ha && !_ && x.start() != w.start() && w.parentOffset == 0 && x.depth == w.depth && u.sel && u.sel.anchor == u.sel.head && u.sel.head == b.endA && (b.endB -= 2, w = u.doc.resolveNoCache(b.endB - u.from), setTimeout(() => {
    e.someProp("handleKeyDown", function(O) {
      return O(e, Nu(13, "Enter"));
    });
  }, 20));
  let M = b.start, N = b.endA, P = (O) => {
    let L = O || e.state.tr.replace(M, N, u.doc.slice(b.start - u.from, b.endB - u.from));
    if (u.sel) {
      let U = h5(e, L.doc, u.sel);
      U && !(Vr && e.composing && U.empty && (b.start != b.endB || e.input.lastChromeDelete < Date.now() - 100) && (U.head == M || U.head == L.mapping.map(N) - 1) || Ki && U.empty && U.head == M) && L.setSelection(U);
    }
    return o && L.setMeta("composition", o), L.scrollIntoView();
  }, I;
  if (_)
    if (x.pos == w.pos) {
      Ki && vc <= 11 && x.parentOffset == 0 && (e.domObserver.suppressSelectionUpdates(), setTimeout(() => Ka(e), 20));
      let O = P(e.state.tr.delete(M, N)), L = f.resolve(b.start).marksAcross(f.resolve(b.endA));
      L && O.ensureMarks(L), e.dispatch(O);
    } else if (
      // Adding or removing a mark
      b.endA == b.endB && (I = O2e(x.parent.content.cut(x.parentOffset, w.parentOffset), S.parent.content.cut(S.parentOffset, b.endA - S.start())))
    ) {
      let O = P(e.state.tr);
      I.type == "add" ? O.addMark(M, N, I.mark) : O.removeMark(M, N, I.mark), e.dispatch(O);
    } else if (x.parent.child(x.index()).isText && x.index() == w.index() - (w.textOffset ? 0 : 1)) {
      let O = x.parent.textBetween(x.parentOffset, w.parentOffset), L = () => P(e.state.tr.insertText(O, M, N));
      e.someProp("handleTextInput", (U) => U(e, M, N, O, L)) || e.dispatch(L());
    } else
      e.dispatch(P());
  else
    e.dispatch(P());
}
function h5(e, t, n) {
  return Math.max(n.anchor, n.head) > t.content.size ? null : EN(e, t.resolve(n.anchor), t.resolve(n.head));
}
function O2e(e, t) {
  let n = e.firstChild.marks, r = t.firstChild.marks, i = n, o = r, s, a, c;
  for (let f = 0; f < r.length; f++)
    i = r[f].removeFromSet(i);
  for (let f = 0; f < n.length; f++)
    o = n[f].removeFromSet(o);
  if (i.length == 1 && o.length == 0)
    a = i[0], s = "add", c = (f) => f.mark(a.addToSet(f.marks));
  else if (i.length == 0 && o.length == 1)
    a = o[0], s = "remove", c = (f) => f.mark(a.removeFromSet(f.marks));
  else
    return null;
  let u = [];
  for (let f = 0; f < t.childCount; f++)
    u.push(c(t.child(f)));
  if ($e.from(u).eq(e))
    return { mark: a, type: s };
}
function D2e(e, t, n, r, i) {
  if (
    // The content must have shrunk
    n - t <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    eE(r, !0, !1) < i.pos
  )
    return !1;
  let o = e.resolve(t);
  if (!r.parent.isTextblock) {
    let a = o.nodeAfter;
    return a != null && n == t + a.nodeSize;
  }
  if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
    return !1;
  let s = e.resolve(eE(o, !0, !0));
  return !s.parent.isTextblock || s.pos > n || eE(s, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
}
function eE(e, t, n) {
  let r = e.depth, i = t ? e.end() : e.pos;
  for (; r > 0 && (t || e.indexAfter(r) == e.node(r).childCount); )
    r--, i++, t = !1;
  if (n) {
    let o = e.node(r).maybeChild(e.indexAfter(r));
    for (; o && !o.isLeaf; )
      o = o.firstChild, i++;
  }
  return i;
}
function P2e(e, t, n, r, i) {
  let o = e.findDiffStart(t, n);
  if (o == null)
    return null;
  let { a: s, b: a } = e.findDiffEnd(t, n + e.size, n + t.size);
  if (i == "end") {
    let c = Math.max(0, o - Math.min(s, a));
    r -= s + c - o;
  }
  if (s < o && e.size < t.size) {
    let c = r <= o && r >= s ? o - r : 0;
    o -= c, o && o < t.size && p5(t.textBetween(o - 1, o + 1)) && (o += c ? 1 : -1), a = o + (a - s), s = o;
  } else if (a < o) {
    let c = r <= o && r >= a ? o - r : 0;
    o -= c, o && o < e.size && p5(e.textBetween(o - 1, o + 1)) && (o += c ? 1 : -1), s = o + (s - a), a = o;
  }
  return { start: o, endA: s, endB: a };
}
function p5(e) {
  if (e.length != 2)
    return !1;
  let t = e.charCodeAt(0), n = e.charCodeAt(1);
  return t >= 56320 && t <= 57343 && n >= 55296 && n <= 56319;
}
class RW {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(t, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new YRe(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(b5), this.dispatch = this.dispatch.bind(this), this.dom = t && t.mount || document.createElement("div"), t && (t.appendChild ? t.appendChild(this.dom) : typeof t == "function" ? t(this.dom) : t.mount && (this.mounted = !0)), this.editable = y5(this), g5(this), this.nodeViews = v5(this), this.docView = ZL(this.state.doc, m5(this), QC(this), this.dom, this), this.domObserver = new k2e(this, (r, i, o, s) => R2e(this, r, i, o, s)), this.domObserver.start(), XRe(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let t = this._props;
      this._props = {};
      for (let n in t)
        this._props[n] = t[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(t) {
    t.handleDOMEvents != this._props.handleDOMEvents && kT(this);
    let n = this._props;
    this._props = t, t.plugins && (t.plugins.forEach(b5), this.directPlugins = t.plugins), this.updateStateInner(t.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(t) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in t)
      n[r] = t[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(t) {
    this.updateStateInner(t, this._props);
  }
  updateStateInner(t, n) {
    var r;
    let i = this.state, o = !1, s = !1;
    t.storedMarks && this.composing && (CW(this), s = !0), this.state = t;
    let a = i.plugins != t.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let g = v5(this);
      I2e(g, this.nodeViews) && (this.nodeViews = g, o = !0);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && kT(this), this.editable = y5(this), g5(this);
    let c = QC(this), u = m5(this), f = i.plugins != t.plugins && !i.doc.eq(t.doc) ? "reset" : t.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", h = o || !this.docView.matchesNode(t.doc, u, c);
    (h || !t.selection.eq(i.selection)) && (s = !0);
    let m = f == "preserve" && s && this.dom.style.overflowAnchor == null && dRe(this);
    if (s) {
      this.domObserver.stop();
      let g = h && (Ki || Vr) && !this.composing && !i.selection.empty && !t.selection.empty && j2e(i.selection, t.selection);
      if (h) {
        let b = Vr ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = d2e(this)), (o || !this.docView.update(t.doc, u, c, this)) && (this.docView.updateOuterDeco(u), this.docView.destroy(), this.docView = ZL(t.doc, u, c, this.dom, this)), b && (!this.trackWrites || !this.dom.contains(this.trackWrites)) && (g = !0);
      }
      g || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && jRe(this)) ? Ka(this, g) : (fW(this, t.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(t.doc) && this.updateDraggedNode(this.dragging, i), f == "reset" ? this.dom.scrollTop = 0 : f == "to selection" ? this.scrollToSelection() : m && fRe(m);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let t = this.domSelectionRange().focusNode;
    if (!(!t || !this.dom.contains(t.nodeType == 1 ? t : t.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof ht) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && VL(this, n.getBoundingClientRect(), t);
      } else
        VL(this, this.coordsAtPos(this.state.selection.head, 1), t);
    }
  }
  destroyPluginViews() {
    let t;
    for (; t = this.pluginViews.pop(); )
      t.destroy && t.destroy();
  }
  updatePluginViews(t) {
    if (!t || t.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, t);
      }
  }
  updateDraggedNode(t, n) {
    let r = t.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let o = r.from + (this.state.doc.content.size - n.doc.content.size);
      (o > 0 && this.state.doc.nodeAt(o)) == r.node && (i = o);
    }
    this.dragging = new _W(t.slice, t.move, i < 0 ? void 0 : ht.create(this.state.doc, i));
  }
  someProp(t, n) {
    let r = this._props && this._props[t], i;
    if (r != null && (i = n ? n(r) : r))
      return i;
    for (let s = 0; s < this.directPlugins.length; s++) {
      let a = this.directPlugins[s].props[t];
      if (a != null && (i = n ? n(a) : a))
        return i;
    }
    let o = this.state.plugins;
    if (o)
      for (let s = 0; s < o.length; s++) {
        let a = o[s].props[t];
        if (a != null && (i = n ? n(a) : a))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Ki) {
      let t = this.root.activeElement;
      if (t == this.dom)
        return !0;
      if (!t || !this.dom.contains(t))
        return !1;
      for (; t && this.dom != t && this.dom.contains(t); ) {
        if (t.contentEditable == "false")
          return !1;
        t = t.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && hRe(this.dom), Ka(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let t = this._root;
    if (t == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return t || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(t) {
    return vRe(this, t);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(t, n = 1) {
    return iW(this, t, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(t, n = 0) {
    return this.docView.domFromPos(t, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(t) {
    let n = this.docView.descAt(t);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(t, n, r = -1) {
    let i = this.docView.posFromDOM(t, n, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(t, n) {
    return kRe(this, n || this.state, t);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(t, n) {
    return wg(this, "", t, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(t, n) {
    return wg(this, t, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(t) {
    return _N(this, t);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (JRe(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], QC(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, tRe());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(t) {
    return e2e(this, t);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let t = this.domSelection();
    return t ? ii && this.root.nodeType === 11 && sRe(this.dom.ownerDocument) == this.dom && E2e(this, t) || t : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
RW.prototype.dispatch = function(e) {
  let t = this._props.dispatchTransaction;
  t ? t.call(this, e) : this.updateState(this.state.apply(e));
};
function m5(e) {
  let t = /* @__PURE__ */ Object.create(null);
  return t.class = "ProseMirror", t.contenteditable = String(e.editable), e.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(e.state)), n)
      for (let r in n)
        r == "class" ? t.class += " " + n[r] : r == "style" ? t.style = (t.style ? t.style + ";" : "") + n[r] : !t[r] && r != "contenteditable" && r != "nodeName" && (t[r] = String(n[r]));
  }), t.translate || (t.translate = "no"), [gi.node(0, e.state.doc.content.size, t)];
}
function g5(e) {
  if (e.markCursor) {
    let t = document.createElement("img");
    t.className = "ProseMirror-separator", t.setAttribute("mark-placeholder", "true"), t.setAttribute("alt", ""), e.cursorWrapper = { dom: t, deco: gi.widget(e.state.selection.from, t, { raw: !0, marks: e.markCursor }) };
  } else
    e.cursorWrapper = null;
}
function y5(e) {
  return !e.someProp("editable", (t) => t(e.state) === !1);
}
function j2e(e, t) {
  let n = Math.min(e.$anchor.sharedDepth(e.head), t.$anchor.sharedDepth(t.head));
  return e.$anchor.start(n) != t.$anchor.start(n);
}
function v5(e) {
  let t = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(t, i) || (t[i] = r[i]);
  }
  return e.someProp("nodeViews", n), e.someProp("markViews", n), t;
}
function I2e(e, t) {
  let n = 0, r = 0;
  for (let i in e) {
    if (e[i] != t[i])
      return !0;
    n++;
  }
  for (let i in t)
    r++;
  return n != r;
}
function b5(e) {
  if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Rc = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, ax = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, z2e = typeof navigator < "u" && /Mac/.test(navigator.platform), L2e = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var ni = 0; ni < 10; ni++) Rc[48 + ni] = Rc[96 + ni] = String(ni);
for (var ni = 1; ni <= 24; ni++) Rc[ni + 111] = "F" + ni;
for (var ni = 65; ni <= 90; ni++)
  Rc[ni] = String.fromCharCode(ni + 32), ax[ni] = String.fromCharCode(ni);
for (var tE in Rc) ax.hasOwnProperty(tE) || (ax[tE] = Rc[tE]);
function B2e(e) {
  var t = z2e && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || L2e && e.shiftKey && e.key && e.key.length == 1 || e.key == "Unidentified", n = !t && e.key || (e.shiftKey ? ax : Rc)[e.keyCode] || e.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const $2e = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), U2e = typeof navigator < "u" && /Win/.test(navigator.platform);
function F2e(e) {
  let t = e.split(/-(?!$)/), n = t[t.length - 1];
  n == "Space" && (n = " ");
  let r, i, o, s;
  for (let a = 0; a < t.length - 1; a++) {
    let c = t[a];
    if (/^(cmd|meta|m)$/i.test(c))
      s = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      i = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      $2e ? s = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return r && (n = "Alt-" + n), i && (n = "Ctrl-" + n), s && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function V2e(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in e)
    t[F2e(n)] = e[n];
  return t;
}
function nE(e, t, n = !0) {
  return t.altKey && (e = "Alt-" + e), t.ctrlKey && (e = "Ctrl-" + e), t.metaKey && (e = "Meta-" + e), n && t.shiftKey && (e = "Shift-" + e), e;
}
function H2e(e) {
  return new Zn({ props: { handleKeyDown: OW(e) } });
}
function OW(e) {
  let t = V2e(e);
  return function(n, r) {
    let i = B2e(r), o, s = t[nE(i, r)];
    if (s && s(n.state, n.dispatch, n))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let a = t[nE(i, r, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(U2e && r.ctrlKey && r.altKey) && (o = Rc[r.keyCode]) && o != i) {
        let a = t[nE(o, r)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
var W2e = Object.defineProperty, ON = (e, t) => {
  for (var n in t)
    W2e(e, n, { get: t[n], enumerable: !0 });
};
function Qw(e) {
  const { state: t, transaction: n } = e;
  let { selection: r } = n, { doc: i } = n, { storedMarks: o } = n;
  return {
    ...t,
    apply: t.apply.bind(t),
    applyTransaction: t.applyTransaction.bind(t),
    plugins: t.plugins,
    schema: t.schema,
    reconfigure: t.reconfigure.bind(t),
    toJSON: t.toJSON.bind(t),
    get storedMarks() {
      return o;
    },
    get selection() {
      return r;
    },
    get doc() {
      return i;
    },
    get tr() {
      return r = n.selection, i = n.doc, o = n.storedMarks, n;
    }
  };
}
var e1 = class {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: t, state: n } = this, { view: r } = t, { tr: i } = n, o = this.buildProps(i);
    return Object.fromEntries(
      Object.entries(e).map(([s, a]) => [s, (...u) => {
        const f = a(...u)(o);
        return !i.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(i), f;
      }])
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, t = !0) {
    const { rawCommands: n, editor: r, state: i } = this, { view: o } = r, s = [], a = !!e, c = e || i.tr, u = () => (!a && t && !c.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(c), s.every((h) => h === !0)), f = {
      ...Object.fromEntries(
        Object.entries(n).map(([h, m]) => [h, (...b) => {
          const x = this.buildProps(c, t), w = m(...b)(x);
          return s.push(w), f;
        }])
      ),
      run: u
    };
    return f;
  }
  createCan(e) {
    const { rawCommands: t, state: n } = this, r = !1, i = e || n.tr, o = this.buildProps(i, r);
    return {
      ...Object.fromEntries(
        Object.entries(t).map(([a, c]) => [a, (...u) => c(...u)({ ...o, dispatch: void 0 })])
      ),
      chain: () => this.createChain(i, r)
    };
  }
  buildProps(e, t = !0) {
    const { rawCommands: n, editor: r, state: i } = this, { view: o } = r, s = {
      tr: e,
      editor: r,
      view: o,
      state: Qw({
        state: i,
        transaction: e
      }),
      dispatch: t ? () => {
      } : void 0,
      chain: () => this.createChain(e, t),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(
          Object.entries(n).map(([a, c]) => [a, (...u) => c(...u)(s)])
        );
      }
    };
    return s;
  }
}, DW = {};
ON(DW, {
  blur: () => q2e,
  clearContent: () => G2e,
  clearNodes: () => K2e,
  command: () => Z2e,
  createParagraphNear: () => Y2e,
  cut: () => X2e,
  deleteCurrentNode: () => J2e,
  deleteNode: () => Q2e,
  deleteRange: () => eOe,
  deleteSelection: () => tOe,
  enter: () => nOe,
  exitCode: () => rOe,
  extendMarkRange: () => iOe,
  first: () => oOe,
  focus: () => aOe,
  forEach: () => lOe,
  insertContent: () => cOe,
  insertContentAt: () => fOe,
  joinBackward: () => mOe,
  joinDown: () => pOe,
  joinForward: () => gOe,
  joinItemBackward: () => yOe,
  joinItemForward: () => vOe,
  joinTextblockBackward: () => bOe,
  joinTextblockForward: () => xOe,
  joinUp: () => hOe,
  keyboardShortcut: () => SOe,
  lift: () => kOe,
  liftEmptyBlock: () => COe,
  liftListItem: () => EOe,
  newlineInCode: () => _Oe,
  resetAttributes: () => TOe,
  scrollIntoView: () => AOe,
  selectAll: () => MOe,
  selectNodeBackward: () => NOe,
  selectNodeForward: () => ROe,
  selectParentNode: () => OOe,
  selectTextblockEnd: () => DOe,
  selectTextblockStart: () => POe,
  setContent: () => jOe,
  setMark: () => tDe,
  setMeta: () => nDe,
  setNode: () => rDe,
  setNodeSelection: () => iDe,
  setTextDirection: () => oDe,
  setTextSelection: () => sDe,
  sinkListItem: () => aDe,
  splitBlock: () => lDe,
  splitListItem: () => cDe,
  toggleList: () => uDe,
  toggleMark: () => dDe,
  toggleNode: () => fDe,
  toggleWrap: () => hDe,
  undoInputRule: () => pDe,
  unsetAllMarks: () => mDe,
  unsetMark: () => gDe,
  unsetTextDirection: () => yDe,
  updateAttributes: () => vDe,
  wrapIn: () => bDe,
  wrapInList: () => xDe
});
var q2e = () => ({ editor: e, view: t }) => (requestAnimationFrame(() => {
  var n;
  e.isDestroyed || (t.dom.blur(), (n = window?.getSelection()) == null || n.removeAllRanges());
}), !0), G2e = (e = !0) => ({ commands: t }) => t.setContent("", { emitUpdate: e }), K2e = () => ({ state: e, tr: t, dispatch: n }) => {
  const { selection: r } = t, { ranges: i } = r;
  return n && i.forEach(({ $from: o, $to: s }) => {
    e.doc.nodesBetween(o.pos, s.pos, (a, c) => {
      if (a.type.isText)
        return;
      const { doc: u, mapping: f } = t, h = u.resolve(f.map(c)), m = u.resolve(f.map(c + a.nodeSize)), g = h.blockRange(m);
      if (!g)
        return;
      const b = Hh(g);
      if (a.type.isTextblock) {
        const { defaultType: x } = h.parent.contentMatchAt(h.index());
        t.setNodeMarkup(g.start, x);
      }
      (b || b === 0) && t.lift(g, b);
    });
  }), !0;
}, Z2e = (e) => (t) => e(t), Y2e = () => ({ state: e, dispatch: t }) => GH(e, t), X2e = (e, t) => ({ editor: n, tr: r }) => {
  const { state: i } = n, o = i.doc.slice(e.from, e.to);
  r.deleteRange(e.from, e.to);
  const s = r.mapping.map(t);
  return r.insert(s, o.content), r.setSelection(new kt(r.doc.resolve(Math.max(s - 1, 0)))), !0;
}, J2e = () => ({ tr: e, dispatch: t }) => {
  const { selection: n } = e, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const i = e.selection.$anchor;
  for (let o = i.depth; o > 0; o -= 1)
    if (i.node(o).type === r.type) {
      if (t) {
        const a = i.before(o), c = i.after(o);
        e.delete(a, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
};
function _r(e, t) {
  if (typeof e == "string") {
    if (!t.nodes[e])
      throw Error(`There is no node type named '${e}'. Maybe you forgot to add the extension?`);
    return t.nodes[e];
  }
  return e;
}
var Q2e = (e) => ({ tr: t, state: n, dispatch: r }) => {
  const i = _r(e, n.schema), o = t.selection.$anchor;
  for (let s = o.depth; s > 0; s -= 1)
    if (o.node(s).type === i) {
      if (r) {
        const c = o.before(s), u = o.after(s);
        t.delete(c, u).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, eOe = (e) => ({ tr: t, dispatch: n }) => {
  const { from: r, to: i } = e;
  return n && t.delete(r, i), !0;
}, tOe = () => ({ state: e, dispatch: t }) => vN(e, t), nOe = () => ({ commands: e }) => e.keyboardShortcut("Enter"), rOe = () => ({ state: e, dispatch: t }) => $Ne(e, t);
function DN(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
function lx(e, t, n = { strict: !0 }) {
  const r = Object.keys(t);
  return r.length ? r.every((i) => n.strict ? t[i] === e[i] : DN(t[i]) ? t[i].test(e[i]) : t[i] === e[i]) : !0;
}
function PW(e, t, n = {}) {
  return e.find((r) => r.type === t && lx(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((i) => [i, r.attrs[i]])),
    n
  ));
}
function x5(e, t, n = {}) {
  return !!PW(e, t, n);
}
function PN(e, t, n) {
  var r;
  if (!e || !t)
    return;
  let i = e.parent.childAfter(e.parentOffset);
  if ((!i.node || !i.node.marks.some((f) => f.type === t)) && (i = e.parent.childBefore(e.parentOffset)), !i.node || !i.node.marks.some((f) => f.type === t) || (n = n || ((r = i.node.marks[0]) == null ? void 0 : r.attrs), !PW([...i.node.marks], t, n)))
    return;
  let s = i.index, a = e.start() + i.offset, c = s + 1, u = a + i.node.nodeSize;
  for (; s > 0 && x5([...e.parent.child(s - 1).marks], t, n); )
    s -= 1, a -= e.parent.child(s).nodeSize;
  for (; c < e.parent.childCount && x5([...e.parent.child(c).marks], t, n); )
    u += e.parent.child(c).nodeSize, c += 1;
  return {
    from: a,
    to: u
  };
}
function ol(e, t) {
  if (typeof e == "string") {
    if (!t.marks[e])
      throw Error(`There is no mark type named '${e}'. Maybe you forgot to add the extension?`);
    return t.marks[e];
  }
  return e;
}
var iOe = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const o = ol(e, r.schema), { doc: s, selection: a } = n, { $from: c, from: u, to: f } = a;
  if (i) {
    const h = PN(c, o, t);
    if (h && h.from <= u && h.to >= f) {
      const m = kt.create(s, h.from, h.to);
      n.setSelection(m);
    }
  }
  return !0;
}, oOe = (e) => (t) => {
  const n = typeof e == "function" ? e(t) : e;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](t))
      return !0;
  return !1;
};
function jW(e) {
  return e instanceof kt;
}
function zu(e = 0, t = 0, n = 0) {
  return Math.min(Math.max(e, t), n);
}
function IW(e, t = null) {
  if (!t)
    return null;
  const n = zt.atStart(e), r = zt.atEnd(e);
  if (t === "start" || t === !0)
    return n;
  if (t === "end")
    return r;
  const i = n.from, o = r.to;
  return t === "all" ? kt.create(e, zu(0, i, o), zu(e.content.size, i, o)) : kt.create(e, zu(t, i, o), zu(t, i, o));
}
function CT() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function kg() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function sOe() {
  return typeof navigator < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1;
}
var aOe = (e = null, t = {}) => ({ editor: n, view: r, tr: i, dispatch: o }) => {
  t = {
    scrollIntoView: !0,
    ...t
  };
  const s = () => {
    (kg() || CT()) && r.dom.focus(), sOe() && !kg() && !CT() && r.dom.focus({ preventScroll: !0 }), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), t?.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  try {
    if (r.hasFocus() && e === null || e === !1)
      return !0;
  } catch {
    return !1;
  }
  if (o && e === null && !jW(n.state.selection))
    return s(), !0;
  const a = IW(i.doc, e) || n.state.selection, c = n.state.selection.eq(a);
  return o && (c || i.setSelection(a), c && i.storedMarks && i.setStoredMarks(i.storedMarks), s()), !0;
}, lOe = (e, t) => (n) => e.every((r, i) => t(r, { ...n, index: i })), cOe = (e, t) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, e, t), zW = (e) => {
  const t = e.childNodes;
  for (let n = t.length - 1; n >= 0; n -= 1) {
    const r = t[n];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? e.removeChild(r) : r.nodeType === 1 && zW(r);
  }
  return e;
};
function e0(e) {
  if (typeof window > "u")
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  const t = `<body>${e}</body>`, n = new window.DOMParser().parseFromString(t, "text/html").body;
  return zW(n);
}
function Cg(e, t, n) {
  if (e instanceof gc || e instanceof $e)
    return e;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const r = typeof e == "object" && e !== null, i = typeof e == "string";
  if (r)
    try {
      if (Array.isArray(e) && e.length > 0)
        return $e.fromArray(e.map((a) => t.nodeFromJSON(a)));
      const s = t.nodeFromJSON(e);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (o) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: o });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", e, "Error:", o), Cg("", t, n);
    }
  if (i) {
    if (n.errorOnInvalidContent) {
      let s = !1, a = "";
      const c = new xH({
        topNode: t.spec.topNode,
        marks: t.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: t.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (u) => (s = !0, a = typeof u == "string" ? u : u.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? yc.fromSchema(c).parseSlice(e0(e), n.parseOptions) : yc.fromSchema(c).parse(e0(e), n.parseOptions), n.errorOnInvalidContent && s)
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${a}`)
        });
    }
    const o = yc.fromSchema(t);
    return n.slice ? o.parseSlice(e0(e), n.parseOptions).content : o.parse(e0(e), n.parseOptions);
  }
  return Cg("", t, n);
}
function uOe(e, t, n) {
  const r = e.steps.length - 1;
  if (r < t)
    return;
  const i = e.steps[r];
  if (!(i instanceof Ur || i instanceof Hr))
    return;
  const o = e.mapping.maps[r];
  let s = 0;
  o.forEach((a, c, u, f) => {
    s === 0 && (s = f);
  }), e.setSelection(zt.near(e.doc.resolve(s), n));
}
var dOe = (e) => !("type" in e), fOe = (e, t, n) => ({ tr: r, dispatch: i, editor: o }) => {
  var s;
  if (i) {
    n = {
      parseOptions: o.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    const c = (w) => {
      o.emit("contentError", {
        editor: o,
        error: w,
        disableCollaboration: () => {
          "collaboration" in o.storage && typeof o.storage.collaboration == "object" && o.storage.collaboration && (o.storage.collaboration.isDisabled = !0);
        }
      });
    }, u = {
      preserveWhitespace: "full",
      ...n.parseOptions
    };
    if (!n.errorOnInvalidContent && !o.options.enableContentCheck && o.options.emitContentError)
      try {
        Cg(t, o.schema, {
          parseOptions: u,
          errorOnInvalidContent: !0
        });
      } catch (w) {
        c(w);
      }
    try {
      a = Cg(t, o.schema, {
        parseOptions: u,
        errorOnInvalidContent: (s = n.errorOnInvalidContent) != null ? s : o.options.enableContentCheck
      });
    } catch (w) {
      return c(w), !1;
    }
    let { from: f, to: h } = typeof e == "number" ? { from: e, to: e } : { from: e.from, to: e.to }, m = !0, g = !0;
    if ((dOe(a) ? a : [a]).forEach((w) => {
      w.check(), m = m ? w.isText && w.marks.length === 0 : !1, g = g ? w.isBlock : !1;
    }), f === h && g) {
      const { parent: w } = r.doc.resolve(f);
      w.isTextblock && !w.type.spec.code && !w.childCount && (f -= 1, h += 1);
    }
    let x;
    if (m) {
      if (Array.isArray(t))
        x = t.map((w) => w.text || "").join("");
      else if (t instanceof $e) {
        let w = "";
        t.forEach((S) => {
          S.text && (w += S.text);
        }), x = w;
      } else typeof t == "object" && t && t.text ? x = t.text : x = t;
      r.insertText(x, f, h);
    } else {
      x = a;
      const w = r.doc.resolve(f), S = w.node(), _ = w.parentOffset === 0, M = S.isText || S.isTextblock, N = S.content.size > 0;
      _ && M && N && (f = Math.max(0, f - 1)), r.replaceWith(f, h, x);
    }
    n.updateSelection && uOe(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: f, text: x }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: f, text: x });
  }
  return !0;
}, hOe = () => ({ state: e, dispatch: t }) => zNe(e, t), pOe = () => ({ state: e, dispatch: t }) => LNe(e, t), mOe = () => ({ state: e, dispatch: t }) => $H(e, t), gOe = () => ({ state: e, dispatch: t }) => HH(e, t), yOe = () => ({ state: e, dispatch: t, tr: n }) => {
  try {
    const r = Gw(e.doc, e.selection.$from.pos, -1);
    return r == null ? !1 : (n.join(r, 2), t && t(n), !0);
  } catch {
    return !1;
  }
}, vOe = () => ({ state: e, dispatch: t, tr: n }) => {
  try {
    const r = Gw(e.doc, e.selection.$from.pos, 1);
    return r == null ? !1 : (n.join(r, 2), t && t(n), !0);
  } catch {
    return !1;
  }
}, bOe = () => ({ state: e, dispatch: t }) => jNe(e, t), xOe = () => ({ state: e, dispatch: t }) => INe(e, t);
function LW() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function wOe(e) {
  const t = e.split(/-(?!$)/);
  let n = t[t.length - 1];
  n === "Space" && (n = " ");
  let r, i, o, s;
  for (let a = 0; a < t.length - 1; a += 1) {
    const c = t[a];
    if (/^(cmd|meta|m)$/i.test(c))
      s = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      i = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      kg() || LW() ? s = !0 : i = !0;
    else
      throw new Error(`Unrecognized modifier name: ${c}`);
  }
  return r && (n = `Alt-${n}`), i && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), o && (n = `Shift-${n}`), n;
}
var SOe = (e) => ({ editor: t, view: n, tr: r, dispatch: i }) => {
  const o = wOe(e).split(/-(?!$)/), s = o.find((u) => !["Alt", "Ctrl", "Meta", "Shift"].includes(u)), a = new KeyboardEvent("keydown", {
    key: s === "Space" ? " " : s,
    altKey: o.includes("Alt"),
    ctrlKey: o.includes("Ctrl"),
    metaKey: o.includes("Meta"),
    shiftKey: o.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), c = t.captureTransaction(() => {
    n.someProp("handleKeyDown", (u) => u(n, a));
  });
  return c?.steps.forEach((u) => {
    const f = u.map(r.mapping);
    f && i && r.maybeStep(f);
  }), !0;
};
function Oc(e, t, n = {}) {
  const { from: r, to: i, empty: o } = e.selection, s = t ? _r(t, e.schema) : null, a = [];
  e.doc.nodesBetween(r, i, (h, m) => {
    if (h.isText)
      return;
    const g = Math.max(r, m), b = Math.min(i, m + h.nodeSize);
    a.push({
      node: h,
      from: g,
      to: b
    });
  });
  const c = i - r, u = a.filter((h) => s ? s.name === h.node.type.name : !0).filter((h) => lx(h.node.attrs, n, { strict: !1 }));
  return o ? !!u.length : u.reduce((h, m) => h + m.to - m.from, 0) >= c;
}
var kOe = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const i = _r(e, n.schema);
  return Oc(n, i, t) ? BNe(n, r) : !1;
}, COe = () => ({ state: e, dispatch: t }) => KH(e, t), EOe = (e) => ({ state: t, dispatch: n }) => {
  const r = _r(e, t.schema);
  return XNe(r)(t, n);
}, _Oe = () => ({ state: e, dispatch: t }) => qH(e, t);
function t1(e, t) {
  return t.nodes[e] ? "node" : t.marks[e] ? "mark" : null;
}
function w5(e, t) {
  const n = typeof t == "string" ? [t] : t;
  return Object.keys(e).reduce((r, i) => (n.includes(i) || (r[i] = e[i]), r), {});
}
var TOe = (e, t) => ({ tr: n, state: r, dispatch: i }) => {
  let o = null, s = null;
  const a = t1(
    typeof e == "string" ? e : e.name,
    r.schema
  );
  if (!a)
    return !1;
  a === "node" && (o = _r(e, r.schema)), a === "mark" && (s = ol(e, r.schema));
  let c = !1;
  return n.selection.ranges.forEach((u) => {
    r.doc.nodesBetween(u.$from.pos, u.$to.pos, (f, h) => {
      o && o === f.type && (c = !0, i && n.setNodeMarkup(h, void 0, w5(f.attrs, t))), s && f.marks.length && f.marks.forEach((m) => {
        s === m.type && (c = !0, i && n.addMark(h, h + f.nodeSize, s.create(w5(m.attrs, t))));
      });
    });
  }), c;
}, AOe = () => ({ tr: e, dispatch: t }) => (t && e.scrollIntoView(), !0), MOe = () => ({ tr: e, dispatch: t }) => {
  if (t) {
    const n = new mo(e.doc);
    e.setSelection(n);
  }
  return !0;
}, NOe = () => ({ state: e, dispatch: t }) => FH(e, t), ROe = () => ({ state: e, dispatch: t }) => WH(e, t), OOe = () => ({ state: e, dispatch: t }) => VNe(e, t), DOe = () => ({ state: e, dispatch: t }) => qNe(e, t), POe = () => ({ state: e, dispatch: t }) => WNe(e, t);
function ET(e, t, n = {}, r = {}) {
  return Cg(e, t, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
var jOe = (e, { errorOnInvalidContent: t, emitUpdate: n = !0, parseOptions: r = {} } = {}) => ({ editor: i, tr: o, dispatch: s, commands: a }) => {
  const { doc: c } = o;
  if (r.preserveWhitespace !== "full") {
    const u = ET(e, i.schema, r, {
      errorOnInvalidContent: t ?? i.options.enableContentCheck
    });
    return s && o.replaceWith(0, c.content.size, u).setMeta("preventUpdate", !n), !0;
  }
  return s && o.setMeta("preventUpdate", !n), a.insertContentAt({ from: 0, to: c.content.size }, e, {
    parseOptions: r,
    errorOnInvalidContent: t ?? i.options.enableContentCheck
  });
};
function BW(e, t) {
  const n = ol(t, e.schema), { from: r, to: i, empty: o } = e.selection, s = [];
  o ? (e.storedMarks && s.push(...e.storedMarks), s.push(...e.selection.$head.marks())) : e.doc.nodesBetween(r, i, (c) => {
    s.push(...c.marks);
  });
  const a = s.find((c) => c.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function $W(e, t) {
  const n = new IH(e);
  return t.forEach((r) => {
    r.steps.forEach((i) => {
      n.step(i);
    });
  }), n;
}
function IOe(e) {
  for (let t = 0; t < e.edgeCount; t += 1) {
    const { type: n } = e.edge(t);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function zOe(e, t, n) {
  const r = [];
  return e.nodesBetween(t.from, t.to, (i, o) => {
    n(i) && r.push({
      node: i,
      pos: o
    });
  }), r;
}
function LOe(e, t) {
  for (let n = e.depth; n > 0; n -= 1) {
    const r = e.node(n);
    if (t(r))
      return {
        pos: n > 0 ? e.before(n) : 0,
        start: e.start(n),
        depth: n,
        node: r
      };
  }
}
function n1(e) {
  return (t) => LOe(t.$from, e);
}
function ft(e, t, n) {
  return e.config[t] === void 0 && e.parent ? ft(e.parent, t, n) : typeof e.config[t] == "function" ? e.config[t].bind({
    ...n,
    parent: e.parent ? ft(e.parent, t, n) : null
  }) : e.config[t];
}
function jN(e) {
  return e.map((t) => {
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    }, r = ft(t, "addExtensions", n);
    return r ? [t, ...jN(r())] : t;
  }).flat(10);
}
function IN(e, t) {
  const n = pd.fromSchema(t).serializeFragment(e), i = document.implementation.createHTMLDocument().createElement("div");
  return i.appendChild(n), i.innerHTML;
}
function UW(e) {
  return typeof e == "function";
}
function mn(e, t = void 0, ...n) {
  return UW(e) ? t ? e.bind(t)(...n) : e(...n) : e;
}
function BOe(e = {}) {
  return Object.keys(e).length === 0 && e.constructor === Object;
}
function vh(e) {
  const t = e.filter((i) => i.type === "extension"), n = e.filter((i) => i.type === "node"), r = e.filter((i) => i.type === "mark");
  return {
    baseExtensions: t,
    nodeExtensions: n,
    markExtensions: r
  };
}
function FW(e) {
  const t = [], { nodeExtensions: n, markExtensions: r } = vh(e), i = [...n, ...r], o = {
    default: null,
    validate: void 0,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return e.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage,
      extensions: i
    }, c = ft(
      s,
      "addGlobalAttributes",
      a
    );
    if (!c)
      return;
    c().forEach((f) => {
      f.types.forEach((h) => {
        Object.entries(f.attributes).forEach(([m, g]) => {
          t.push({
            type: h,
            name: m,
            attribute: {
              ...o,
              ...g
            }
          });
        });
      });
    });
  }), i.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage
    }, c = ft(
      s,
      "addAttributes",
      a
    );
    if (!c)
      return;
    const u = c();
    Object.entries(u).forEach(([f, h]) => {
      const m = {
        ...o,
        ...h
      };
      typeof m?.default == "function" && (m.default = m.default()), m?.isRequired && m?.default === void 0 && delete m.default, t.push({
        type: s.name,
        name: f,
        attribute: m
      });
    });
  }), t;
}
function or(...e) {
  return e.filter((t) => !!t).reduce((t, n) => {
    const r = { ...t };
    return Object.entries(n).forEach(([i, o]) => {
      if (!r[i]) {
        r[i] = o;
        return;
      }
      if (i === "class") {
        const a = o ? String(o).split(" ") : [], c = r[i] ? r[i].split(" ") : [], u = a.filter((f) => !c.includes(f));
        r[i] = [...c, ...u].join(" ");
      } else if (i === "style") {
        const a = o ? o.split(";").map((f) => f.trim()).filter(Boolean) : [], c = r[i] ? r[i].split(";").map((f) => f.trim()).filter(Boolean) : [], u = /* @__PURE__ */ new Map();
        c.forEach((f) => {
          const [h, m] = f.split(":").map((g) => g.trim());
          u.set(h, m);
        }), a.forEach((f) => {
          const [h, m] = f.split(":").map((g) => g.trim());
          u.set(h, m);
        }), r[i] = Array.from(u.entries()).map(([f, h]) => `${f}: ${h}`).join("; ");
      } else
        r[i] = o;
    }), r;
  }, {});
}
function bh(e, t) {
  return t.filter((n) => n.type === e.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(e.attrs) || {} : {
    [n.name]: e.attrs[n.name]
  }).reduce((n, r) => or(n, r), {});
}
function $Oe(e) {
  return typeof e != "string" ? e : e.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(e) : e === "true" ? !0 : e === "false" ? !1 : e;
}
function S5(e, t) {
  return "style" in e ? e : {
    ...e,
    getAttrs: (n) => {
      const r = e.getAttrs ? e.getAttrs(n) : e.attrs;
      if (r === !1)
        return !1;
      const i = t.reduce((o, s) => {
        const a = s.attribute.parseHTML ? s.attribute.parseHTML(n) : $Oe(n.getAttribute(s.name));
        return a == null ? o : {
          ...o,
          [s.name]: a
        };
      }, {});
      return { ...r, ...i };
    }
  };
}
function k5(e) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(e).filter(([t, n]) => t === "attrs" && BOe(n) ? !1 : n != null)
  );
}
function C5(e) {
  var t, n;
  const r = {};
  return !((t = e?.attribute) != null && t.isRequired) && "default" in (e?.attribute || {}) && (r.default = e.attribute.default), ((n = e?.attribute) == null ? void 0 : n.validate) !== void 0 && (r.validate = e.attribute.validate), [e.name, r];
}
function UOe(e, t) {
  var n;
  const r = FW(e), { nodeExtensions: i, markExtensions: o } = vh(e), s = (n = i.find((u) => ft(u, "topNode"))) == null ? void 0 : n.name, a = Object.fromEntries(
    i.map((u) => {
      const f = r.filter((S) => S.type === u.name), h = {
        name: u.name,
        options: u.options,
        storage: u.storage,
        editor: t
      }, m = e.reduce((S, _) => {
        const M = ft(_, "extendNodeSchema", h);
        return {
          ...S,
          ...M ? M(u) : {}
        };
      }, {}), g = k5({
        ...m,
        content: mn(ft(u, "content", h)),
        marks: mn(ft(u, "marks", h)),
        group: mn(ft(u, "group", h)),
        inline: mn(ft(u, "inline", h)),
        atom: mn(ft(u, "atom", h)),
        selectable: mn(ft(u, "selectable", h)),
        draggable: mn(ft(u, "draggable", h)),
        code: mn(ft(u, "code", h)),
        whitespace: mn(ft(u, "whitespace", h)),
        linebreakReplacement: mn(
          ft(u, "linebreakReplacement", h)
        ),
        defining: mn(ft(u, "defining", h)),
        isolating: mn(ft(u, "isolating", h)),
        attrs: Object.fromEntries(f.map(C5))
      }), b = mn(ft(u, "parseHTML", h));
      b && (g.parseDOM = b.map(
        (S) => S5(S, f)
      ));
      const x = ft(u, "renderHTML", h);
      x && (g.toDOM = (S) => x({
        node: S,
        HTMLAttributes: bh(S, f)
      }));
      const w = ft(u, "renderText", h);
      return w && (g.toText = w), [u.name, g];
    })
  ), c = Object.fromEntries(
    o.map((u) => {
      const f = r.filter((w) => w.type === u.name), h = {
        name: u.name,
        options: u.options,
        storage: u.storage,
        editor: t
      }, m = e.reduce((w, S) => {
        const _ = ft(S, "extendMarkSchema", h);
        return {
          ...w,
          ..._ ? _(u) : {}
        };
      }, {}), g = k5({
        ...m,
        inclusive: mn(ft(u, "inclusive", h)),
        excludes: mn(ft(u, "excludes", h)),
        group: mn(ft(u, "group", h)),
        spanning: mn(ft(u, "spanning", h)),
        code: mn(ft(u, "code", h)),
        attrs: Object.fromEntries(f.map(C5))
      }), b = mn(ft(u, "parseHTML", h));
      b && (g.parseDOM = b.map(
        (w) => S5(w, f)
      ));
      const x = ft(u, "renderHTML", h);
      return x && (g.toDOM = (w) => x({
        mark: w,
        HTMLAttributes: bh(w, f)
      })), [u.name, g];
    })
  );
  return new xH({
    topNode: s,
    nodes: a,
    marks: c
  });
}
function FOe(e) {
  const t = e.filter((n, r) => e.indexOf(n) !== r);
  return Array.from(new Set(t));
}
function cx(e) {
  return e.sort((n, r) => {
    const i = ft(n, "priority") || 100, o = ft(r, "priority") || 100;
    return i > o ? -1 : i < o ? 1 : 0;
  });
}
function VW(e) {
  const t = cx(jN(e)), n = FOe(t.map((r) => r.name));
  return n.length && console.warn(
    `[tiptap warn]: Duplicate extension names found: [${n.map((r) => `'${r}'`).join(", ")}]. This can lead to issues.`
  ), t;
}
function HW(e, t, n) {
  const { from: r, to: i } = t, { blockSeparator: o = `

`, textSerializers: s = {} } = n || {};
  let a = "";
  return e.nodesBetween(r, i, (c, u, f, h) => {
    var m;
    c.isBlock && u > r && (a += o);
    const g = s?.[c.type.name];
    if (g)
      return f && (a += g({
        node: c,
        pos: u,
        parent: f,
        index: h,
        range: t
      })), !1;
    c.isText && (a += (m = c?.text) == null ? void 0 : m.slice(Math.max(r, u) - u, i - u));
  }), a;
}
function VOe(e, t) {
  const n = {
    from: 0,
    to: e.content.size
  };
  return HW(e, n, t);
}
function WW(e) {
  return Object.fromEntries(
    Object.entries(e.nodes).filter(([, t]) => t.spec.toText).map(([t, n]) => [t, n.spec.toText])
  );
}
function HOe(e, t) {
  const n = _r(t, e.schema), { from: r, to: i } = e.selection, o = [];
  e.doc.nodesBetween(r, i, (a) => {
    o.push(a);
  });
  const s = o.reverse().find((a) => a.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function qW(e, t) {
  const n = t1(
    typeof t == "string" ? t : t.name,
    e.schema
  );
  return n === "node" ? HOe(e, t) : n === "mark" ? BW(e, t) : {};
}
function WOe(e, t = JSON.stringify) {
  const n = {};
  return e.filter((r) => {
    const i = t(r);
    return Object.prototype.hasOwnProperty.call(n, i) ? !1 : n[i] = !0;
  });
}
function qOe(e) {
  const t = WOe(e);
  return t.length === 1 ? t : t.filter((n, r) => !t.filter((o, s) => s !== r).some((o) => n.oldRange.from >= o.oldRange.from && n.oldRange.to <= o.oldRange.to && n.newRange.from >= o.newRange.from && n.newRange.to <= o.newRange.to));
}
function GW(e) {
  const { mapping: t, steps: n } = e, r = [];
  return t.maps.forEach((i, o) => {
    const s = [];
    if (i.ranges.length)
      i.forEach((a, c) => {
        s.push({ from: a, to: c });
      });
    else {
      const { from: a, to: c } = n[o];
      if (a === void 0 || c === void 0)
        return;
      s.push({ from: a, to: c });
    }
    s.forEach(({ from: a, to: c }) => {
      const u = t.slice(o).map(a, -1), f = t.slice(o).map(c), h = t.invert().map(u, -1), m = t.invert().map(f);
      r.push({
        oldRange: {
          from: h,
          to: m
        },
        newRange: {
          from: u,
          to: f
        }
      });
    });
  }), qOe(r);
}
function zN(e, t, n) {
  const r = [];
  return e === t ? n.resolve(e).marks().forEach((i) => {
    const o = n.resolve(e), s = PN(o, i.type);
    s && r.push({
      mark: i,
      ...s
    });
  }) : n.nodesBetween(e, t, (i, o) => {
    !i || i?.nodeSize === void 0 || r.push(
      ...i.marks.map((s) => ({
        from: o,
        to: o + i.nodeSize,
        mark: s
      }))
    );
  }), r;
}
var GOe = (e, t, n, r = 20) => {
  const i = e.doc.resolve(n);
  let o = r, s = null;
  for (; o > 0 && s === null; ) {
    const a = i.node(o);
    a?.type.name === t ? s = a : o -= 1;
  }
  return [s, o];
};
function t0(e, t) {
  return t.nodes[e] || t.marks[e] || null;
}
function W0(e, t, n) {
  return Object.fromEntries(
    Object.entries(n).filter(([r]) => {
      const i = e.find((o) => o.type === t && o.name === r);
      return i ? i.attribute.keepOnSplit : !1;
    })
  );
}
var KOe = (e, t = 500) => {
  let n = "";
  const r = e.parentOffset;
  return e.parent.nodesBetween(Math.max(0, r - t), r, (i, o, s, a) => {
    var c, u;
    const f = ((u = (c = i.type.spec).toText) == null ? void 0 : u.call(c, {
      node: i,
      pos: o,
      parent: s,
      index: a
    })) || i.textContent || "%leaf%";
    n += i.isAtom && !i.isText ? f : f.slice(0, Math.max(0, r - o));
  }), n;
};
function _T(e, t, n = {}) {
  const { empty: r, ranges: i } = e.selection, o = t ? ol(t, e.schema) : null;
  if (r)
    return !!(e.storedMarks || e.selection.$from.marks()).filter((h) => o ? o.name === h.type.name : !0).find((h) => lx(h.attrs, n, { strict: !1 }));
  let s = 0;
  const a = [];
  if (i.forEach(({ $from: h, $to: m }) => {
    const g = h.pos, b = m.pos;
    e.doc.nodesBetween(g, b, (x, w) => {
      if (!x.isText && !x.marks.length)
        return;
      const S = Math.max(g, w), _ = Math.min(b, w + x.nodeSize), M = _ - S;
      s += M, a.push(
        ...x.marks.map((N) => ({
          mark: N,
          from: S,
          to: _
        }))
      );
    });
  }), s === 0)
    return !1;
  const c = a.filter((h) => o ? o.name === h.mark.type.name : !0).filter((h) => lx(h.mark.attrs, n, { strict: !1 })).reduce((h, m) => h + m.to - m.from, 0), u = a.filter((h) => o ? h.mark.type !== o && h.mark.type.excludes(o) : !0).reduce((h, m) => h + m.to - m.from, 0);
  return (c > 0 ? c + u : c) >= s;
}
function ZOe(e, t, n = {}) {
  if (!t)
    return Oc(e, null, n) || _T(e, null, n);
  const r = t1(t, e.schema);
  return r === "node" ? Oc(e, t, n) : r === "mark" ? _T(e, t, n) : !1;
}
var YOe = (e, t) => {
  const { $from: n, $to: r, $anchor: i } = e.selection;
  if (t) {
    const o = n1((a) => a.type.name === t)(e.selection);
    if (!o)
      return !1;
    const s = e.doc.resolve(o.pos + 1);
    return i.pos + 1 === s.end();
  }
  return !(r.parentOffset < r.parent.nodeSize - 2 || n.pos !== r.pos);
}, XOe = (e) => {
  const { $from: t, $to: n } = e.selection;
  return !(t.parentOffset > 0 || t.pos !== n.pos);
};
function E5(e, t) {
  return Array.isArray(t) ? t.some((n) => (typeof n == "string" ? n : n.name) === e.name) : t;
}
function _5(e, t) {
  const { nodeExtensions: n } = vh(t), r = n.find((s) => s.name === e);
  if (!r)
    return !1;
  const i = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, o = mn(ft(r, "group", i));
  return typeof o != "string" ? !1 : o.split(" ").includes("list");
}
function r1(e, {
  checkChildren: t = !0,
  ignoreWhitespace: n = !1
} = {}) {
  var r;
  if (n) {
    if (e.type.name === "hardBreak")
      return !0;
    if (e.isText)
      return /^\s*$/m.test((r = e.text) != null ? r : "");
  }
  if (e.isText)
    return !e.text;
  if (e.isAtom || e.isLeaf)
    return !1;
  if (e.content.childCount === 0)
    return !0;
  if (t) {
    let i = !0;
    return e.content.forEach((o) => {
      i !== !1 && (r1(o, { ignoreWhitespace: n, checkChildren: t }) || (i = !1));
    }), i;
  }
  return !1;
}
function KW(e) {
  return e instanceof ht;
}
var ZW = class YW {
  constructor(t) {
    this.position = t;
  }
  /**
   * Creates a MappablePosition from a JSON object.
   */
  static fromJSON(t) {
    return new YW(t.position);
  }
  /**
   * Converts the MappablePosition to a JSON object.
   */
  toJSON() {
    return {
      position: this.position
    };
  }
};
function JOe(e, t) {
  const n = t.mapping.mapResult(e.position);
  return {
    position: new ZW(n.pos),
    mapResult: n
  };
}
function QOe(e) {
  return new ZW(e);
}
function eDe(e, t, n) {
  var r;
  const { selection: i } = t;
  let o = null;
  if (jW(i) && (o = i.$cursor), o) {
    const a = (r = e.storedMarks) != null ? r : o.marks();
    return o.parent.type.allowsMarkType(n) && (!!n.isInSet(a) || !a.some((u) => u.type.excludes(n)));
  }
  const { ranges: s } = i;
  return s.some(({ $from: a, $to: c }) => {
    let u = a.depth === 0 ? e.doc.inlineContent && e.doc.type.allowsMarkType(n) : !1;
    return e.doc.nodesBetween(a.pos, c.pos, (f, h, m) => {
      if (u)
        return !1;
      if (f.isInline) {
        const g = !m || m.type.allowsMarkType(n), b = !!n.isInSet(f.marks) || !f.marks.some((x) => x.type.excludes(n));
        u = g && b;
      }
      return !u;
    }), u;
  });
}
var tDe = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const { selection: o } = n, { empty: s, ranges: a } = o, c = ol(e, r.schema);
  if (i)
    if (s) {
      const u = BW(r, c);
      n.addStoredMark(
        c.create({
          ...u,
          ...t
        })
      );
    } else
      a.forEach((u) => {
        const f = u.$from.pos, h = u.$to.pos;
        r.doc.nodesBetween(f, h, (m, g) => {
          const b = Math.max(g, f), x = Math.min(g + m.nodeSize, h);
          m.marks.find((S) => S.type === c) ? m.marks.forEach((S) => {
            c === S.type && n.addMark(
              b,
              x,
              c.create({
                ...S.attrs,
                ...t
              })
            );
          }) : n.addMark(b, x, c.create(t));
        });
      });
  return eDe(r, n, c);
}, nDe = (e, t) => ({ tr: n }) => (n.setMeta(e, t), !0), rDe = (e, t = {}) => ({ state: n, dispatch: r, chain: i }) => {
  const o = _r(e, n.schema);
  let s;
  return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), o.isTextblock ? i().command(({ commands: a }) => $L(o, { ...s, ...t })(n) ? !0 : a.clearNodes()).command(({ state: a }) => $L(o, { ...s, ...t })(a, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, iDe = (e) => ({ tr: t, dispatch: n }) => {
  if (n) {
    const { doc: r } = t, i = zu(e, 0, r.content.size), o = ht.create(r, i);
    t.setSelection(o);
  }
  return !0;
}, oDe = (e, t) => ({ tr: n, state: r, dispatch: i }) => {
  const { selection: o } = r;
  let s, a;
  return typeof t == "number" ? (s = t, a = t) : t && "from" in t && "to" in t ? (s = t.from, a = t.to) : (s = o.from, a = o.to), i && n.doc.nodesBetween(s, a, (c, u) => {
    c.isText || n.setNodeMarkup(u, void 0, {
      ...c.attrs,
      dir: e
    });
  }), !0;
}, sDe = (e) => ({ tr: t, dispatch: n }) => {
  if (n) {
    const { doc: r } = t, { from: i, to: o } = typeof e == "number" ? { from: e, to: e } : e, s = kt.atStart(r).from, a = kt.atEnd(r).to, c = zu(i, s, a), u = zu(o, s, a), f = kt.create(r, c, u);
    t.setSelection(f);
  }
  return !0;
}, aDe = (e) => ({ state: t, dispatch: n }) => {
  const r = _r(e, t.schema);
  return eRe(r)(t, n);
};
function T5(e, t) {
  const n = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks();
  if (n) {
    const r = n.filter((i) => t?.includes(i.type.name));
    e.tr.ensureMarks(r);
  }
}
var lDe = ({ keepMarks: e = !0 } = {}) => ({ tr: t, state: n, dispatch: r, editor: i }) => {
  const { selection: o, doc: s } = t, { $from: a, $to: c } = o, u = i.extensionManager.attributes, f = W0(u, a.node().type.name, a.node().attrs);
  if (o instanceof ht && o.node.isBlock)
    return !a.parentOffset || !Ga(s, a.pos) ? !1 : (r && (e && T5(n, i.extensionManager.splittableMarks), t.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const h = c.parentOffset === c.parent.content.size, m = a.depth === 0 ? void 0 : IOe(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let g = h && m ? [
    {
      type: m,
      attrs: f
    }
  ] : void 0, b = Ga(t.doc, t.mapping.map(a.pos), 1, g);
  if (!g && !b && Ga(t.doc, t.mapping.map(a.pos), 1, m ? [{ type: m }] : void 0) && (b = !0, g = m ? [
    {
      type: m,
      attrs: f
    }
  ] : void 0), r) {
    if (b && (o instanceof kt && t.deleteSelection(), t.split(t.mapping.map(a.pos), 1, g), m && !h && !a.parentOffset && a.parent.type !== m)) {
      const x = t.mapping.map(a.before()), w = t.doc.resolve(x);
      a.node(-1).canReplaceWith(w.index(), w.index() + 1, m) && t.setNodeMarkup(t.mapping.map(a.before()), m);
    }
    e && T5(n, i.extensionManager.splittableMarks), t.scrollIntoView();
  }
  return b;
}, cDe = (e, t = {}) => ({ tr: n, state: r, dispatch: i, editor: o }) => {
  var s;
  const a = _r(e, r.schema), { $from: c, $to: u } = r.selection, f = r.selection.node;
  if (f && f.isBlock || c.depth < 2 || !c.sameParent(u))
    return !1;
  const h = c.node(-1);
  if (h.type !== a)
    return !1;
  const m = o.extensionManager.attributes;
  if (c.parent.content.size === 0 && c.node(-1).childCount === c.indexAfter(-1)) {
    if (c.depth === 2 || c.node(-3).type !== a || c.index(-2) !== c.node(-2).childCount - 1)
      return !1;
    if (i) {
      let S = $e.empty;
      const _ = c.index(-1) ? 1 : c.index(-2) ? 2 : 3;
      for (let L = c.depth - _; L >= c.depth - 3; L -= 1)
        S = $e.from(c.node(L).copy(S));
      const M = (
        // eslint-disable-next-line no-nested-ternary
        c.indexAfter(-1) < c.node(-2).childCount ? 1 : c.indexAfter(-2) < c.node(-3).childCount ? 2 : 3
      ), N = {
        ...W0(m, c.node().type.name, c.node().attrs),
        ...t
      }, P = ((s = a.contentMatch.defaultType) == null ? void 0 : s.createAndFill(N)) || void 0;
      S = S.append($e.from(a.createAndFill(null, P) || void 0));
      const I = c.before(c.depth - (_ - 1));
      n.replace(I, c.after(-M), new Qe(S, 4 - _, 0));
      let O = -1;
      n.doc.nodesBetween(I, n.doc.content.size, (L, U) => {
        if (O > -1)
          return !1;
        L.isTextblock && L.content.size === 0 && (O = U + 1);
      }), O > -1 && n.setSelection(kt.near(n.doc.resolve(O))), n.scrollIntoView();
    }
    return !0;
  }
  const g = u.pos === c.end() ? h.contentMatchAt(0).defaultType : null, b = {
    ...W0(m, h.type.name, h.attrs),
    ...t
  }, x = {
    ...W0(m, c.node().type.name, c.node().attrs),
    ...t
  };
  n.delete(c.pos, u.pos);
  const w = g ? [
    { type: a, attrs: b },
    { type: g, attrs: x }
  ] : [{ type: a, attrs: b }];
  if (!Ga(n.doc, c.pos, 2))
    return !1;
  if (i) {
    const { selection: S, storedMarks: _ } = r, { splittableMarks: M } = o.extensionManager, N = _ || S.$to.parentOffset && S.$from.marks();
    if (n.split(c.pos, 2, w).scrollIntoView(), !N || !i)
      return !0;
    const P = N.filter((I) => M.includes(I.type.name));
    n.ensureMarks(P);
  }
  return !0;
}, rE = (e, t) => {
  const n = n1((s) => s.type === t)(e.selection);
  if (!n)
    return !0;
  const r = e.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const i = e.doc.nodeAt(r);
  return n.node.type === i?.type && Fc(e.doc, n.pos) && e.join(n.pos), !0;
}, iE = (e, t) => {
  const n = n1((s) => s.type === t)(e.selection);
  if (!n)
    return !0;
  const r = e.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const i = e.doc.nodeAt(r);
  return n.node.type === i?.type && Fc(e.doc, r) && e.join(r), !0;
}, uDe = (e, t, n, r = {}) => ({ editor: i, tr: o, state: s, dispatch: a, chain: c, commands: u, can: f }) => {
  const { extensions: h, splittableMarks: m } = i.extensionManager, g = _r(e, s.schema), b = _r(t, s.schema), { selection: x, storedMarks: w } = s, { $from: S, $to: _ } = x, M = S.blockRange(_), N = w || x.$to.parentOffset && x.$from.marks();
  if (!M)
    return !1;
  const P = n1((I) => _5(I.type.name, h))(x);
  if (M.depth >= 1 && P && M.depth - P.depth <= 1) {
    if (P.node.type === g)
      return u.liftListItem(b);
    if (_5(P.node.type.name, h) && g.validContent(P.node.content) && a)
      return c().command(() => (o.setNodeMarkup(P.pos, g), !0)).command(() => rE(o, g)).command(() => iE(o, g)).run();
  }
  return !n || !N || !a ? c().command(() => f().wrapInList(g, r) ? !0 : u.clearNodes()).wrapInList(g, r).command(() => rE(o, g)).command(() => iE(o, g)).run() : c().command(() => {
    const I = f().wrapInList(g, r), O = N.filter((L) => m.includes(L.type.name));
    return o.ensureMarks(O), I ? !0 : u.clearNodes();
  }).wrapInList(g, r).command(() => rE(o, g)).command(() => iE(o, g)).run();
}, dDe = (e, t = {}, n = {}) => ({ state: r, commands: i }) => {
  const { extendEmptyMarkRange: o = !1 } = n, s = ol(e, r.schema);
  return _T(r, s, t) ? i.unsetMark(s, { extendEmptyMarkRange: o }) : i.setMark(s, t);
}, fDe = (e, t, n = {}) => ({ state: r, commands: i }) => {
  const o = _r(e, r.schema), s = _r(t, r.schema), a = Oc(r, o, n);
  let c;
  return r.selection.$anchor.sameParent(r.selection.$head) && (c = r.selection.$anchor.parent.attrs), a ? i.setNode(s, c) : i.setNode(o, { ...c, ...n });
}, hDe = (e, t = {}) => ({ state: n, commands: r }) => {
  const i = _r(e, n.schema);
  return Oc(n, i, t) ? r.lift(i) : r.wrapIn(i, t);
}, pDe = () => ({ state: e, dispatch: t }) => {
  const n = e.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const i = n[r];
    let o;
    if (i.spec.isInputRules && (o = i.getState(e))) {
      if (t) {
        const s = e.tr, a = o.transform;
        for (let c = a.steps.length - 1; c >= 0; c -= 1)
          s.step(a.steps[c].invert(a.docs[c]));
        if (o.text) {
          const c = s.doc.resolve(o.from).marks();
          s.replaceWith(o.from, o.to, e.schema.text(o.text, c));
        } else
          s.delete(o.from, o.to);
      }
      return !0;
    }
  }
  return !1;
}, mDe = () => ({ tr: e, dispatch: t }) => {
  const { selection: n } = e, { empty: r, ranges: i } = n;
  return r || t && i.forEach((o) => {
    e.removeMark(o.$from.pos, o.$to.pos);
  }), !0;
}, gDe = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  var o;
  const { extendEmptyMarkRange: s = !1 } = t, { selection: a } = n, c = ol(e, r.schema), { $from: u, empty: f, ranges: h } = a;
  if (!i)
    return !0;
  if (f && s) {
    let { from: m, to: g } = a;
    const b = (o = u.marks().find((w) => w.type === c)) == null ? void 0 : o.attrs, x = PN(u, c, b);
    x && (m = x.from, g = x.to), n.removeMark(m, g, c);
  } else
    h.forEach((m) => {
      n.removeMark(m.$from.pos, m.$to.pos, c);
    });
  return n.removeStoredMark(c), !0;
}, yDe = (e) => ({ tr: t, state: n, dispatch: r }) => {
  const { selection: i } = n;
  let o, s;
  return typeof e == "number" ? (o = e, s = e) : e && "from" in e && "to" in e ? (o = e.from, s = e.to) : (o = i.from, s = i.to), r && t.doc.nodesBetween(o, s, (a, c) => {
    if (a.isText)
      return;
    const u = { ...a.attrs };
    delete u.dir, t.setNodeMarkup(c, void 0, u);
  }), !0;
}, vDe = (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => {
  let o = null, s = null;
  const a = t1(
    typeof e == "string" ? e : e.name,
    r.schema
  );
  if (!a)
    return !1;
  a === "node" && (o = _r(e, r.schema)), a === "mark" && (s = ol(e, r.schema));
  let c = !1;
  return n.selection.ranges.forEach((u) => {
    const f = u.$from.pos, h = u.$to.pos;
    let m, g, b, x;
    n.selection.empty ? r.doc.nodesBetween(f, h, (w, S) => {
      o && o === w.type && (c = !0, b = Math.max(S, f), x = Math.min(S + w.nodeSize, h), m = S, g = w);
    }) : r.doc.nodesBetween(f, h, (w, S) => {
      S < f && o && o === w.type && (c = !0, b = Math.max(S, f), x = Math.min(S + w.nodeSize, h), m = S, g = w), S >= f && S <= h && (o && o === w.type && (c = !0, i && n.setNodeMarkup(S, void 0, {
        ...w.attrs,
        ...t
      })), s && w.marks.length && w.marks.forEach((_) => {
        if (s === _.type && (c = !0, i)) {
          const M = Math.max(S, f), N = Math.min(S + w.nodeSize, h);
          n.addMark(
            M,
            N,
            s.create({
              ..._.attrs,
              ...t
            })
          );
        }
      }));
    }), g && (m !== void 0 && i && n.setNodeMarkup(m, void 0, {
      ...g.attrs,
      ...t
    }), s && g.marks.length && g.marks.forEach((w) => {
      s === w.type && i && n.addMark(
        b,
        x,
        s.create({
          ...w.attrs,
          ...t
        })
      );
    }));
  }), c;
}, bDe = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const i = _r(e, n.schema);
  return GNe(i, t)(n, r);
}, xDe = (e, t = {}) => ({ state: n, dispatch: r }) => {
  const i = _r(e, n.schema);
  return KNe(i, t)(n, r);
}, wDe = class {
  constructor() {
    this.callbacks = {};
  }
  on(e, t) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
  }
  emit(e, ...t) {
    const n = this.callbacks[e];
    return n && n.forEach((r) => r.apply(this, t)), this;
  }
  off(e, t) {
    const n = this.callbacks[e];
    return n && (t ? this.callbacks[e] = n.filter((r) => r !== t) : delete this.callbacks[e]), this;
  }
  once(e, t) {
    const n = (...r) => {
      this.off(e, n), t.apply(this, r);
    };
    return this.on(e, n);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}, i1 = class {
  constructor(e) {
    var t;
    this.find = e.find, this.handler = e.handler, this.undoable = (t = e.undoable) != null ? t : !0;
  }
}, SDe = (e, t) => {
  if (DN(t))
    return t.exec(e);
  const n = t(e);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = e, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function n0(e) {
  var t;
  const { editor: n, from: r, to: i, text: o, rules: s, plugin: a } = e, { view: c } = n;
  if (c.composing)
    return !1;
  const u = c.state.doc.resolve(r);
  if (
    // check for code node
    u.parent.type.spec.code || (t = u.nodeBefore || u.nodeAfter) != null && t.marks.find((m) => m.type.spec.code)
  )
    return !1;
  let f = !1;
  const h = KOe(u) + o;
  return s.forEach((m) => {
    if (f)
      return;
    const g = SDe(h, m.find);
    if (!g)
      return;
    const b = c.state.tr, x = Qw({
      state: c.state,
      transaction: b
    }), w = {
      from: r - (g[0].length - o.length),
      to: i
    }, { commands: S, chain: _, can: M } = new e1({
      editor: n,
      state: x
    });
    m.handler({
      state: x,
      range: w,
      match: g,
      commands: S,
      chain: _,
      can: M
    }) === null || !b.steps.length || (m.undoable && b.setMeta(a, {
      transform: b,
      from: r,
      to: i,
      text: o
    }), c.dispatch(b), f = !0);
  }), f;
}
function kDe(e) {
  const { editor: t, rules: n } = e, r = new Zn({
    state: {
      init() {
        return null;
      },
      apply(i, o, s) {
        const a = i.getMeta(r);
        if (a)
          return a;
        const c = i.getMeta("applyInputRules");
        return c && setTimeout(() => {
          let { text: f } = c;
          typeof f == "string" ? f = f : f = IN($e.from(f), s.schema);
          const { from: h } = c, m = h + f.length;
          n0({
            editor: t,
            from: h,
            to: m,
            text: f,
            rules: n,
            plugin: r
          });
        }), i.selectionSet || i.docChanged ? null : o;
      }
    },
    props: {
      handleTextInput(i, o, s, a) {
        return n0({
          editor: t,
          from: o,
          to: s,
          text: a,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (i) => (setTimeout(() => {
          const { $cursor: o } = i.state.selection;
          o && n0({
            editor: t,
            from: o.pos,
            to: o.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(i, o) {
        if (o.key !== "Enter")
          return !1;
        const { $cursor: s } = i.state.selection;
        return s ? n0({
          editor: t,
          from: s.pos,
          to: s.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function CDe(e) {
  return Object.prototype.toString.call(e).slice(8, -1);
}
function r0(e) {
  return CDe(e) !== "Object" ? !1 : e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype;
}
function XW(e, t) {
  const n = { ...e };
  return r0(e) && r0(t) && Object.keys(t).forEach((r) => {
    r0(t[r]) && r0(e[r]) ? n[r] = XW(e[r], t[r]) : n[r] = t[r];
  }), n;
}
var LN = class {
  constructor(e = {}) {
    this.type = "extendable", this.parent = null, this.child = null, this.name = "", this.config = {
      name: this.name
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name;
  }
  get options() {
    return {
      ...mn(
        ft(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...mn(
        ft(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => XW(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new this.constructor({ ...this.config, ...e });
    return t.parent = this, this.child = t, t.name = "name" in e ? e.name : t.parent.name, t;
  }
}, md = class JW extends LN {
  constructor() {
    super(...arguments), this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new JW(n);
  }
  static handleExit({ editor: t, mark: n }) {
    const { tr: r } = t.state, i = t.state.selection.$from;
    if (i.pos === i.end()) {
      const s = i.marks();
      if (!!!s.find((u) => u?.type.name === n.name))
        return !1;
      const c = s.find((u) => u?.type.name === n.name);
      return c && r.removeStoredMark(c), r.insertText(" ", i.pos), t.view.dispatch(r), !0;
    }
    return !1;
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
};
function EDe(e) {
  return typeof e == "number";
}
var _De = class {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}, TDe = (e, t, n) => {
  if (DN(t))
    return [...e.matchAll(t)];
  const r = t(e, n);
  return r ? r.map((i) => {
    const o = [i.text];
    return o.index = i.index, o.input = e, o.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), o.push(i.replaceWith)), o;
  }) : [];
};
function ADe(e) {
  const { editor: t, state: n, from: r, to: i, rule: o, pasteEvent: s, dropEvent: a } = e, { commands: c, chain: u, can: f } = new e1({
    editor: t,
    state: n
  }), h = [];
  return n.doc.nodesBetween(r, i, (g, b) => {
    var x, w, S, _, M;
    if ((w = (x = g.type) == null ? void 0 : x.spec) != null && w.code || !(g.isText || g.isTextblock || g.isInline))
      return;
    const N = (M = (_ = (S = g.content) == null ? void 0 : S.size) != null ? _ : g.nodeSize) != null ? M : 0, P = Math.max(r, b), I = Math.min(i, b + N);
    if (P >= I)
      return;
    const O = g.isText ? g.text || "" : g.textBetween(P - b, I - b, void 0, "");
    TDe(O, o.find, s).forEach((U) => {
      if (U.index === void 0)
        return;
      const B = P + U.index + 1, G = B + U[0].length, Y = {
        from: n.tr.mapping.map(B),
        to: n.tr.mapping.map(G)
      }, he = o.handler({
        state: n,
        range: Y,
        match: U,
        commands: c,
        chain: u,
        can: f,
        pasteEvent: s,
        dropEvent: a
      });
      h.push(he);
    });
  }), h.every((g) => g !== null);
}
var i0 = null, MDe = (e) => {
  var t;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (t = n.clipboardData) == null || t.setData("text/html", e), n;
};
function NDe(e) {
  const { editor: t, rules: n } = e;
  let r = null, i = !1, o = !1, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const c = ({
    state: f,
    from: h,
    to: m,
    rule: g,
    pasteEvt: b
  }) => {
    const x = f.tr, w = Qw({
      state: f,
      transaction: x
    });
    if (!(!ADe({
      editor: t,
      state: w,
      from: Math.max(h - 1, 0),
      to: m.b - 1,
      rule: g,
      pasteEvent: b,
      dropEvent: a
    }) || !x.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, x;
    }
  };
  return n.map((f) => new Zn({
    // we register a global drag handler to track the current drag source element
    view(h) {
      const m = (b) => {
        var x;
        r = (x = h.dom.parentElement) != null && x.contains(b.target) ? h.dom.parentElement : null, r && (i0 = t);
      }, g = () => {
        i0 && (i0 = null);
      };
      return window.addEventListener("dragstart", m), window.addEventListener("dragend", g), {
        destroy() {
          window.removeEventListener("dragstart", m), window.removeEventListener("dragend", g);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (h, m) => {
          if (o = r === h.dom.parentElement, a = m, !o) {
            const g = i0;
            g?.isEditable && setTimeout(() => {
              const b = g.state.selection;
              b && g.commands.deleteRange({ from: b.from, to: b.to });
            }, 10);
          }
          return !1;
        },
        paste: (h, m) => {
          var g;
          const b = (g = m.clipboardData) == null ? void 0 : g.getData("text/html");
          return s = m, i = !!b?.includes("data-pm-slice"), !1;
        }
      }
    },
    appendTransaction: (h, m, g) => {
      const b = h[0], x = b.getMeta("uiEvent") === "paste" && !i, w = b.getMeta("uiEvent") === "drop" && !o, S = b.getMeta("applyPasteRules"), _ = !!S;
      if (!x && !w && !_)
        return;
      if (_) {
        let { text: P } = S;
        typeof P == "string" ? P = P : P = IN($e.from(P), g.schema);
        const { from: I } = S, O = I + P.length, L = MDe(P);
        return c({
          rule: f,
          state: g,
          from: I,
          to: { b: O },
          pasteEvt: L
        });
      }
      const M = m.doc.content.findDiffStart(g.doc.content), N = m.doc.content.findDiffEnd(g.doc.content);
      if (!(!EDe(M) || !N || M === N.b))
        return c({
          rule: f,
          state: g,
          from: M,
          to: N,
          pasteEvt: s
        });
    }
  }));
}
var o1 = class {
  constructor(e, t) {
    this.splittableMarks = [], this.editor = t, this.baseExtensions = e, this.extensions = VW(e), this.schema = UOe(this.extensions, t), this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, t) => {
      const n = {
        name: t.name,
        options: t.options,
        storage: this.editor.extensionStorage[t.name],
        editor: this.editor,
        type: t0(t.name, this.schema)
      }, r = ft(t, "addCommands", n);
      return r ? {
        ...e,
        ...r()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this;
    return cx([...this.extensions].reverse()).flatMap((r) => {
      const i = {
        name: r.name,
        options: r.options,
        storage: this.editor.extensionStorage[r.name],
        editor: e,
        type: t0(r.name, this.schema)
      }, o = [], s = ft(
        r,
        "addKeyboardShortcuts",
        i
      );
      let a = {};
      if (r.type === "mark" && ft(r, "exitable", i) && (a.ArrowRight = () => md.handleExit({ editor: e, mark: r })), s) {
        const m = Object.fromEntries(
          Object.entries(s()).map(([g, b]) => [g, () => b({ editor: e })])
        );
        a = { ...a, ...m };
      }
      const c = H2e(a);
      o.push(c);
      const u = ft(r, "addInputRules", i);
      if (E5(r, e.options.enableInputRules) && u) {
        const m = u();
        if (m && m.length) {
          const g = kDe({
            editor: e,
            rules: m
          }), b = Array.isArray(g) ? g : [g];
          o.push(...b);
        }
      }
      const f = ft(r, "addPasteRules", i);
      if (E5(r, e.options.enablePasteRules) && f) {
        const m = f();
        if (m && m.length) {
          const g = NDe({ editor: e, rules: m });
          o.push(...g);
        }
      }
      const h = ft(
        r,
        "addProseMirrorPlugins",
        i
      );
      if (h) {
        const m = h();
        o.push(...m);
      }
      return o;
    });
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return FW(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: t } = vh(this.extensions);
    return Object.fromEntries(
      t.filter((n) => !!ft(n, "addNodeView")).map((n) => {
        const r = this.attributes.filter((c) => c.type === n.name), i = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: e,
          type: _r(n.name, this.schema)
        }, o = ft(n, "addNodeView", i);
        if (!o)
          return [];
        const s = o();
        if (!s)
          return [];
        const a = (c, u, f, h, m) => {
          const g = bh(c, r);
          return s({
            // pass-through
            node: c,
            view: u,
            getPos: f,
            decorations: h,
            innerDecorations: m,
            // tiptap-specific
            editor: e,
            extension: n,
            HTMLAttributes: g
          });
        };
        return [n.name, a];
      })
    );
  }
  /**
   * Get the composed dispatchTransaction function from all extensions.
   * @param baseDispatch The base dispatch function (e.g. from the editor or user props)
   * @returns A composed dispatch function
   */
  dispatchTransaction(e) {
    const { editor: t } = this;
    return cx([...this.extensions].reverse()).reduceRight((r, i) => {
      const o = {
        name: i.name,
        options: i.options,
        storage: this.editor.extensionStorage[i.name],
        editor: t,
        type: t0(i.name, this.schema)
      }, s = ft(
        i,
        "dispatchTransaction",
        o
      );
      return s ? (a) => {
        s.call(o, { transaction: a, next: r });
      } : r;
    }, e);
  }
  get markViews() {
    const { editor: e } = this, { markExtensions: t } = vh(this.extensions);
    return Object.fromEntries(
      t.filter((n) => !!ft(n, "addMarkView")).map((n) => {
        const r = this.attributes.filter((a) => a.type === n.name), i = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: e,
          type: ol(n.name, this.schema)
        }, o = ft(n, "addMarkView", i);
        if (!o)
          return [];
        const s = (a, c, u) => {
          const f = bh(a, r);
          return o()({
            // pass-through
            mark: a,
            view: c,
            inline: u,
            // tiptap-specific
            editor: e,
            extension: n,
            HTMLAttributes: f,
            updateAttributes: (h) => {
              WDe(a, e, h);
            }
          });
        };
        return [n.name, s];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const e = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      e.map((t) => [t.name, t.storage])
    ), e.forEach((t) => {
      var n;
      const r = {
        name: t.name,
        options: t.options,
        storage: this.editor.extensionStorage[t.name],
        editor: this.editor,
        type: t0(t.name, this.schema)
      };
      t.type === "mark" && ((n = mn(ft(t, "keepOnSplit", r))) == null || n) && this.splittableMarks.push(t.name);
      const i = ft(t, "onBeforeCreate", r), o = ft(t, "onCreate", r), s = ft(t, "onUpdate", r), a = ft(
        t,
        "onSelectionUpdate",
        r
      ), c = ft(t, "onTransaction", r), u = ft(t, "onFocus", r), f = ft(t, "onBlur", r), h = ft(t, "onDestroy", r);
      i && this.editor.on("beforeCreate", i), o && this.editor.on("create", o), s && this.editor.on("update", s), a && this.editor.on("selectionUpdate", a), c && this.editor.on("transaction", c), u && this.editor.on("focus", u), f && this.editor.on("blur", f), h && this.editor.on("destroy", h);
    });
  }
};
o1.resolve = VW;
o1.sort = cx;
o1.flatten = jN;
var RDe = {};
ON(RDe, {
  ClipboardTextSerializer: () => eq,
  Commands: () => tq,
  Delete: () => nq,
  Drop: () => rq,
  Editable: () => iq,
  FocusEvents: () => sq,
  Keymap: () => aq,
  Paste: () => lq,
  Tabindex: () => cq,
  TextDirection: () => uq,
  focusEventsPluginKey: () => oq
});
var hr = class QW extends LN {
  constructor() {
    super(...arguments), this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new QW(n);
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
}, eq = hr.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: e } = this, { state: t, schema: n } = e, { doc: r, selection: i } = t, { ranges: o } = i, s = Math.min(...o.map((f) => f.$from.pos)), a = Math.max(...o.map((f) => f.$to.pos)), c = WW(n);
            return HW(r, { from: s, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: c
            });
          }
        }
      })
    ];
  }
}), tq = hr.create({
  name: "commands",
  addCommands() {
    return {
      ...DW
    };
  }
}), nq = hr.create({
  name: "delete",
  onUpdate({ transaction: e, appendedTransactions: t }) {
    var n, r, i;
    const o = () => {
      var s, a, c, u;
      if ((u = (c = (a = (s = this.editor.options.coreExtensionOptions) == null ? void 0 : s.delete) == null ? void 0 : a.filterTransaction) == null ? void 0 : c.call(a, e)) != null ? u : e.getMeta("y-sync$"))
        return;
      const f = $W(e.before, [e, ...t]);
      GW(f).forEach((g) => {
        f.mapping.mapResult(g.oldRange.from).deletedAfter && f.mapping.mapResult(g.oldRange.to).deletedBefore && f.before.nodesBetween(g.oldRange.from, g.oldRange.to, (b, x) => {
          const w = x + b.nodeSize - 2, S = g.oldRange.from <= x && w <= g.oldRange.to;
          this.editor.emit("delete", {
            type: "node",
            node: b,
            from: x,
            to: w,
            newFrom: f.mapping.map(x),
            newTo: f.mapping.map(w),
            deletedRange: g.oldRange,
            newRange: g.newRange,
            partial: !S,
            editor: this.editor,
            transaction: e,
            combinedTransform: f
          });
        });
      });
      const m = f.mapping;
      f.steps.forEach((g, b) => {
        var x, w;
        if (g instanceof cs) {
          const S = m.slice(b).map(g.from, -1), _ = m.slice(b).map(g.to), M = m.invert().map(S, -1), N = m.invert().map(_), P = (x = f.doc.nodeAt(S - 1)) == null ? void 0 : x.marks.some((O) => O.eq(g.mark)), I = (w = f.doc.nodeAt(_)) == null ? void 0 : w.marks.some((O) => O.eq(g.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: g.mark,
            from: g.from,
            to: g.to,
            deletedRange: {
              from: M,
              to: N
            },
            newRange: {
              from: S,
              to: _
            },
            partial: !!(I || P),
            editor: this.editor,
            transaction: e,
            combinedTransform: f
          });
        }
      });
    };
    (i = (r = (n = this.editor.options.coreExtensionOptions) == null ? void 0 : n.delete) == null ? void 0 : r.async) == null || i ? setTimeout(o, 0) : o();
  }
}), rq = hr.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("tiptapDrop"),
        props: {
          handleDrop: (e, t, n, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: t,
              slice: n,
              moved: r
            });
          }
        }
      })
    ];
  }
}), iq = hr.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), oq = new Tr("focusEvents"), sq = hr.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: e } = this;
    return [
      new Zn({
        key: oq,
        props: {
          handleDOMEvents: {
            focus: (t, n) => {
              e.isFocused = !0;
              const r = e.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return t.dispatch(r), !1;
            },
            blur: (t, n) => {
              e.isFocused = !1;
              const r = e.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return t.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), aq = hr.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const e = () => this.editor.commands.first(({ commands: s }) => [
      () => s.undoInputRule(),
      // maybe convert first text block node to default node
      () => s.command(({ tr: a }) => {
        const { selection: c, doc: u } = a, { empty: f, $anchor: h } = c, { pos: m, parent: g } = h, b = h.parent.isTextblock && m > 0 ? a.doc.resolve(m - 1) : h, x = b.parent.type.spec.isolating, w = h.pos - h.parentOffset, S = x && b.parent.childCount === 1 ? w === h.pos : zt.atStart(u).from === m;
        return !f || !g.type.isTextblock || g.textContent.length || !S || S && h.parent.type.name === "paragraph" ? !1 : s.clearNodes();
      }),
      () => s.deleteSelection(),
      () => s.joinBackward(),
      () => s.selectNodeBackward()
    ]), t = () => this.editor.commands.first(({ commands: s }) => [
      () => s.deleteSelection(),
      () => s.deleteCurrentNode(),
      () => s.joinForward(),
      () => s.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: s }) => [
        () => s.newlineInCode(),
        () => s.createParagraphNear(),
        () => s.liftEmptyBlock(),
        () => s.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: e,
      "Mod-Backspace": e,
      "Shift-Backspace": e,
      Delete: t,
      "Mod-Delete": t,
      "Mod-a": () => this.editor.commands.selectAll()
    }, i = {
      ...r
    }, o = {
      ...r,
      "Ctrl-h": e,
      "Alt-Backspace": e,
      "Ctrl-d": t,
      "Ctrl-Alt-Backspace": t,
      "Alt-Delete": t,
      "Alt-d": t,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return kg() || LW() ? o : i;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
      // with many other commands.
      new Zn({
        key: new Tr("clearDocument"),
        appendTransaction: (e, t, n) => {
          if (e.some((x) => x.getMeta("composition")))
            return;
          const r = e.some((x) => x.docChanged) && !t.doc.eq(n.doc), i = e.some((x) => x.getMeta("preventClearDocument"));
          if (!r || i)
            return;
          const { empty: o, from: s, to: a } = t.selection, c = zt.atStart(t.doc).from, u = zt.atEnd(t.doc).to;
          if (o || !(s === c && a === u) || !r1(n.doc))
            return;
          const m = n.tr, g = Qw({
            state: n,
            transaction: m
          }), { commands: b } = new e1({
            editor: this.editor,
            state: g
          });
          if (b.clearNodes(), !!m.steps.length)
            return m;
        }
      })
    ];
  }
}), lq = hr.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("tiptapPaste"),
        props: {
          handlePaste: (e, t, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: t,
              slice: n
            });
          }
        }
      })
    ];
  }
}), cq = hr.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
}), uq = hr.create({
  name: "textDirection",
  addOptions() {
    return {
      direction: void 0
    };
  },
  addGlobalAttributes() {
    if (!this.options.direction)
      return [];
    const { nodeExtensions: e } = vh(this.extensions);
    return [
      {
        types: e.filter((t) => t.name !== "text").map((t) => t.name),
        attributes: {
          dir: {
            default: this.options.direction,
            parseHTML: (t) => {
              const n = t.getAttribute("dir");
              return n && (n === "ltr" || n === "rtl" || n === "auto") ? n : this.options.direction;
            },
            renderHTML: (t) => t.dir ? {
              dir: t.dir
            } : {}
          }
        }
      }
    ];
  },
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("textDirection"),
        props: {
          attributes: () => {
            const e = this.options.direction;
            return e ? {
              dir: e
            } : {};
          }
        }
      })
    ];
  }
}), ODe = class vm {
  constructor(t, n, r = !1, i = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = t, this.editor = n, this.currentNode = i;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var t;
    return (t = this.actualDepth) != null ? t : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(t) {
    let n = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, t);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const t = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(t);
    return new vm(n, this.editor);
  }
  get before() {
    let t = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return t.depth !== this.depth && (t = this.resolvedPos.doc.resolve(this.from - 3)), new vm(t, this.editor);
  }
  get after() {
    let t = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return t.depth !== this.depth && (t = this.resolvedPos.doc.resolve(this.to + 3)), new vm(t, this.editor);
  }
  get children() {
    const t = [];
    return this.node.content.forEach((n, r) => {
      const i = n.isBlock && !n.isTextblock, o = n.isAtom && !n.isText, s = n.isInline, a = this.pos + r + (o ? 0 : 1);
      if (a < 0 || a > this.resolvedPos.doc.nodeSize - 2)
        return;
      const c = this.resolvedPos.doc.resolve(a);
      if (!i && !s && c.depth <= this.depth)
        return;
      const u = new vm(c, this.editor, i, i || s ? n : null);
      i && (u.actualDepth = this.depth + 1), t.push(u);
    }), t;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const t = this.children;
    return t[t.length - 1] || null;
  }
  closest(t, n = {}) {
    let r = null, i = this.parent;
    for (; i && !r; ) {
      if (i.node.type.name === t)
        if (Object.keys(n).length > 0) {
          const o = i.node.attrs, s = Object.keys(n);
          for (let a = 0; a < s.length; a += 1) {
            const c = s[a];
            if (o[c] !== n[c])
              break;
          }
        } else
          r = i;
      i = i.parent;
    }
    return r;
  }
  querySelector(t, n = {}) {
    return this.querySelectorAll(t, n, !0)[0] || null;
  }
  querySelectorAll(t, n = {}, r = !1) {
    let i = [];
    if (!this.children || this.children.length === 0)
      return i;
    const o = Object.keys(n);
    return this.children.forEach((s) => {
      r && i.length > 0 || (s.node.type.name === t && o.every((c) => n[c] === s.node.attrs[c]) && i.push(s), !(r && i.length > 0) && (i = i.concat(s.querySelectorAll(t, n, r))));
    }), i;
  }
  setAttribute(t) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...t
    }), this.editor.view.dispatch(n);
  }
}, DDe = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function PDe(e, t, n) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null)
    return r;
  const i = document.createElement("style");
  return t && i.setAttribute("nonce", t), i.setAttribute("data-tiptap-style", ""), i.innerHTML = e, document.getElementsByTagName("head")[0].appendChild(i), i;
}
var jDe = class extends wDe {
  constructor(e = {}) {
    super(), this.css = null, this.className = "tiptap", this.editorView = null, this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.instanceId = Math.random().toString(36).slice(2, 9), this.options = {
      element: typeof document < "u" ? document.createElement("div") : null,
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      textDirection: void 0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      emitContentError: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onMount: () => null,
      onUnmount: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: r }) => {
        throw r;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null,
      enableExtensionDispatchTransaction: !0
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.utils = {
      getUpdatedPosition: JOe,
      createMappablePosition: QOe
    }, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("mount", this.options.onMount), this.on("unmount", this.options.onUnmount), this.on("contentError", this.options.onContentError), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: r, slice: i, moved: o }) => this.options.onDrop(r, i, o)), this.on("paste", ({ event: r, slice: i }) => this.options.onPaste(r, i)), this.on("delete", this.options.onDelete);
    const t = this.createDoc(), n = IW(t, this.options.autofocus);
    this.editorState = Ff.create({
      doc: t,
      schema: this.schema,
      selection: n || void 0
    }), this.options.element && this.mount(this.options.element);
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(e) {
    if (typeof document > "u")
      throw new Error(
        "[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment."
      );
    this.createView(e), this.emit("mount", { editor: this }), this.css && !document.head.contains(this.css) && document.head.appendChild(this.css), window.setTimeout(() => {
      this.isDestroyed || (this.options.autofocus !== !1 && this.options.autofocus !== null && this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    if (this.editorView) {
      const e = this.editorView.dom;
      e?.editor && delete e.editor, this.editorView.destroy();
    }
    if (this.editorView = null, this.isInitialized = !1, this.css && !document.querySelectorAll(`.${this.className}`).length)
      try {
        typeof this.css.remove == "function" ? this.css.remove() : this.css.parentNode && this.css.parentNode.removeChild(this.css);
      } catch (e) {
        console.warn("Failed to remove CSS element:", e);
      }
    this.css = null, this.emit("unmount", { editor: this });
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && typeof document < "u" && (this.css = PDe(DDe, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.editorView || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, t = !0) {
    this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    return this.editorView ? this.editorView : new Proxy(
      {
        state: this.editorState,
        updateState: (e) => {
          this.editorState = e;
        },
        dispatch: (e) => {
          this.dispatchTransaction(e);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: !1,
        dragging: null,
        editable: !0,
        isDestroyed: !1
      },
      {
        get: (e, t) => {
          if (this.editorView)
            return this.editorView[t];
          if (t === "state")
            return this.editorState;
          if (t in e)
            return Reflect.get(e, t);
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${t}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.editorView && (this.editorState = this.view.state), this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, t) {
    const n = UW(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], r = this.state.reconfigure({ plugins: n });
    return this.view.updateState(r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const t = this.state.plugins;
    let n = t;
    if ([].concat(e).forEach((i) => {
      const o = typeof i == "string" ? `${i}$` : i.key;
      n = n.filter((s) => !s.key.startsWith(o));
    }), t.length === n.length)
      return;
    const r = this.state.reconfigure({
      plugins: n
    });
    return this.view.updateState(r), r;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, t;
    const r = [...this.options.enableCoreExtensions ? [
      iq,
      eq.configure({
        blockSeparator: (t = (e = this.options.coreExtensionOptions) == null ? void 0 : e.clipboardTextSerializer) == null ? void 0 : t.blockSeparator
      }),
      tq,
      sq,
      aq,
      cq,
      rq,
      lq,
      nq,
      uq.configure({
        direction: this.options.textDirection
      })
    ].filter((i) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[i.name] !== !1 : !0) : [], ...this.options.extensions].filter((i) => ["extension", "node", "mark"].includes(i?.type));
    this.extensionManager = new o1(r, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new e1({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let e;
    try {
      e = ET(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (t) {
      if (!(t instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(t.message))
        throw t;
      this.emit("contentError", {
        editor: this,
        error: t,
        disableCollaboration: () => {
          "collaboration" in this.storage && typeof this.storage.collaboration == "object" && this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((n) => n.name !== "collaboration"), this.createExtensionManager();
        }
      }), e = ET(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: !1
      });
    }
    return e;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(e) {
    const { editorProps: t, enableExtensionDispatchTransaction: n } = this.options, r = t.dispatchTransaction || this.dispatchTransaction.bind(this), i = n ? this.extensionManager.dispatchTransaction(r) : r;
    this.editorView = new RW(e, {
      ...t,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...t?.attributes
      },
      dispatchTransaction: i,
      state: this.editorState,
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
    const o = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(o), this.prependClass(), this.injectCSS();
    const s = this.view.dom;
    s.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `${this.className} ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const t = this.capturedTransaction;
    return this.capturedTransaction = null, t;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((u) => {
        var f;
        return (f = this.capturedTransaction) == null ? void 0 : f.step(u);
      });
      return;
    }
    const { state: t, transactions: n } = this.state.applyTransaction(e), r = !this.state.selection.eq(t.selection), i = n.includes(e), o = this.state;
    if (this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: t
    }), !i)
      return;
    this.view.updateState(t), this.emit("transaction", {
      editor: this,
      transaction: e,
      appendedTransactions: n.slice(1)
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const s = n.findLast((u) => u.getMeta("focus") || u.getMeta("blur")), a = s?.getMeta("focus"), c = s?.getMeta("blur");
    a && this.emit("focus", {
      editor: this,
      event: a.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: s
    }), c && this.emit("blur", {
      editor: this,
      event: c.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: s
    }), !(e.getMeta("preventUpdate") || !n.some((u) => u.docChanged) || o.doc.eq(t.doc)) && this.emit("update", {
      editor: this,
      transaction: e,
      appendedTransactions: n.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return qW(this.state, e);
  }
  isActive(e, t) {
    const n = typeof e == "string" ? e : null, r = typeof e == "string" ? t : e;
    return ZOe(this.state, n, r);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return IN(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: t = `

`, textSerializers: n = {} } = e || {};
    return VOe(this.state.doc, {
      blockSeparator: t,
      textSerializers: {
        ...WW(this.schema),
        ...n
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return r1(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy"), this.unmount(), this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e, t;
    return (t = (e = this.editorView) == null ? void 0 : e.isDestroyed) != null ? t : !0;
  }
  $node(e, t) {
    var n;
    return ((n = this.$doc) == null ? void 0 : n.querySelector(e, t)) || null;
  }
  $nodes(e, t) {
    var n;
    return ((n = this.$doc) == null ? void 0 : n.querySelectorAll(e, t)) || null;
  }
  $pos(e) {
    const t = this.state.doc.resolve(e);
    return new ODe(t, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function xh(e) {
  return new i1({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const i = mn(e.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: o } = t, s = r[r.length - 1], a = r[0];
      if (s) {
        const c = a.search(/\S/), u = n.from + a.indexOf(s), f = u + s.length;
        if (zN(n.from, n.to, t.doc).filter((g) => g.mark.type.excluded.find((x) => x === e.type && x !== g.mark.type)).filter((g) => g.to > u).length)
          return null;
        f < n.to && o.delete(f, n.to), u > n.from && o.delete(n.from + c, u);
        const m = n.from + c + s.length;
        o.addMark(n.from + c, m, e.type.create(i || {})), o.removeStoredMark(e.type);
      }
    },
    undoable: e.undoable
  });
}
function IDe(e) {
  return new i1({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const i = mn(e.getAttributes, void 0, r) || {}, { tr: o } = t, s = n.from;
      let a = n.to;
      const c = e.type.create(i);
      if (r[1]) {
        const u = r[0].lastIndexOf(r[1]);
        let f = s + u;
        f > a ? f = a : a = f + r[1].length;
        const h = r[0][r[0].length - 1];
        o.insertText(h, s + r[0].length - 1), o.replaceWith(f, a, c);
      } else if (r[0]) {
        const u = e.type.isInline ? s : s - 1;
        o.insert(u, e.type.create(i)).delete(o.mapping.map(s), o.mapping.map(a));
      }
      o.scrollIntoView();
    },
    undoable: e.undoable
  });
}
function TT(e) {
  return new i1({
    find: e.find,
    handler: ({ state: t, range: n, match: r }) => {
      const i = t.doc.resolve(n.from), o = mn(e.getAttributes, void 0, r) || {};
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), e.type))
        return null;
      t.tr.delete(n.from, n.to).setBlockType(n.from, n.from, e.type, o);
    },
    undoable: e.undoable
  });
}
function wh(e) {
  return new i1({
    find: e.find,
    handler: ({ state: t, range: n, match: r, chain: i }) => {
      const o = mn(e.getAttributes, void 0, r) || {}, s = t.tr.delete(n.from, n.to), c = s.doc.resolve(n.from).blockRange(), u = c && gN(c, e.type, o);
      if (!u)
        return null;
      if (s.wrap(c, u), e.keepMarks && e.editor) {
        const { selection: h, storedMarks: m } = t, { splittableMarks: g } = e.editor.extensionManager, b = m || h.$to.parentOffset && h.$from.marks();
        if (b) {
          const x = b.filter((w) => g.includes(w.type.name));
          s.ensureMarks(x);
        }
      }
      if (e.keepAttributes) {
        const h = e.type.name === "bulletList" || e.type.name === "orderedList" ? "listItem" : "taskList";
        i().updateAttributes(h, o).run();
      }
      const f = s.doc.resolve(n.from - 1).nodeBefore;
      f && f.type === e.type && Fc(s.doc, n.from - 1) && (!e.joinPredicate || e.joinPredicate(r, f)) && s.join(n.from - 1);
    },
    undoable: e.undoable
  });
}
function zDe(e, t) {
  const { selection: n } = e, { $from: r } = n;
  if (n instanceof ht) {
    const o = r.index();
    return r.parent.canReplaceWith(o, o + 1, t);
  }
  let i = r.depth;
  for (; i >= 0; ) {
    const o = r.index(i);
    if (r.node(i).contentMatchAt(o).matchType(t))
      return !0;
    i -= 1;
  }
  return !1;
}
function LDe(e) {
  return e.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var BDe = {};
ON(BDe, {
  createAtomBlockMarkdownSpec: () => $De,
  createBlockMarkdownSpec: () => UDe,
  createInlineMarkdownSpec: () => HDe,
  parseAttributes: () => BN,
  parseIndentedBlocks: () => AT,
  renderNestedMarkdownContent: () => UN,
  serializeAttributes: () => $N
});
function BN(e) {
  if (!e?.trim())
    return {};
  const t = {}, n = [], r = e.replace(/["']([^"']*)["']/g, (u) => (n.push(u), `__QUOTED_${n.length - 1}__`)), i = r.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);
  if (i) {
    const u = i.map((f) => f.trim().slice(1));
    t.class = u.join(" ");
  }
  const o = r.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);
  o && (t.id = o[1]);
  const s = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;
  Array.from(r.matchAll(s)).forEach(([, u, f]) => {
    var h;
    const m = parseInt(((h = f.match(/__QUOTED_(\d+)__/)) == null ? void 0 : h[1]) || "0", 10), g = n[m];
    g && (t[u] = g.slice(1, -1));
  });
  const c = r.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, "").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, "").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, "").trim();
  return c && c.split(/\s+/).filter(Boolean).forEach((f) => {
    f.match(/^[a-zA-Z][\w-]*$/) && (t[f] = !0);
  }), t;
}
function $N(e) {
  if (!e || Object.keys(e).length === 0)
    return "";
  const t = [];
  return e.class && String(e.class).split(/\s+/).filter(Boolean).forEach((r) => t.push(`.${r}`)), e.id && t.push(`#${e.id}`), Object.entries(e).forEach(([n, r]) => {
    n === "class" || n === "id" || (r === !0 ? t.push(n) : r !== !1 && r != null && t.push(`${n}="${String(r)}"`));
  }), t.join(" ");
}
function $De(e) {
  const {
    nodeName: t,
    name: n,
    parseAttributes: r = BN,
    serializeAttributes: i = $N,
    defaultAttributes: o = {},
    requiredAttributes: s = [],
    allowedAttributes: a
  } = e, c = n || t, u = (f) => {
    if (!a)
      return f;
    const h = {};
    return a.forEach((m) => {
      m in f && (h[m] = f[m]);
    }), h;
  };
  return {
    parseMarkdown: (f, h) => {
      const m = { ...o, ...f.attributes };
      return h.createNode(t, m, []);
    },
    markdownTokenizer: {
      name: t,
      level: "block",
      start(f) {
        var h;
        const m = new RegExp(`^:::${c}(?:\\s|$)`, "m"), g = (h = f.match(m)) == null ? void 0 : h.index;
        return g !== void 0 ? g : -1;
      },
      tokenize(f, h, m) {
        const g = new RegExp(`^:::${c}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`), b = f.match(g);
        if (!b)
          return;
        const x = b[1] || "", w = r(x);
        if (!s.find((_) => !(_ in w)))
          return {
            type: t,
            raw: b[0],
            attributes: w
          };
      }
    },
    renderMarkdown: (f) => {
      const h = u(f.attrs || {}), m = i(h), g = m ? ` {${m}}` : "";
      return `:::${c}${g} :::`;
    }
  };
}
function UDe(e) {
  const {
    nodeName: t,
    name: n,
    getContent: r,
    parseAttributes: i = BN,
    serializeAttributes: o = $N,
    defaultAttributes: s = {},
    content: a = "block",
    allowedAttributes: c
  } = e, u = n || t, f = (h) => {
    if (!c)
      return h;
    const m = {};
    return c.forEach((g) => {
      g in h && (m[g] = h[g]);
    }), m;
  };
  return {
    parseMarkdown: (h, m) => {
      let g;
      if (r) {
        const x = r(h);
        g = typeof x == "string" ? [{ type: "text", text: x }] : x;
      } else a === "block" ? g = m.parseChildren(h.tokens || []) : g = m.parseInline(h.tokens || []);
      const b = { ...s, ...h.attributes };
      return m.createNode(t, b, g);
    },
    markdownTokenizer: {
      name: t,
      level: "block",
      start(h) {
        var m;
        const g = new RegExp(`^:::${u}`, "m"), b = (m = h.match(g)) == null ? void 0 : m.index;
        return b !== void 0 ? b : -1;
      },
      tokenize(h, m, g) {
        var b;
        const x = new RegExp(`^:::${u}(?:\\s+\\{([^}]*)\\})?\\s*\\n`), w = h.match(x);
        if (!w)
          return;
        const [S, _ = ""] = w, M = i(_);
        let N = 1;
        const P = S.length;
        let I = "";
        const O = /^:::([\w-]*)(\s.*)?/gm, L = h.slice(P);
        for (O.lastIndex = 0; ; ) {
          const U = O.exec(L);
          if (U === null)
            break;
          const B = U.index, G = U[1];
          if (!((b = U[2]) != null && b.endsWith(":::"))) {
            if (G)
              N += 1;
            else if (N -= 1, N === 0) {
              const Y = L.slice(0, B);
              I = Y.trim();
              const he = h.slice(0, P + B + U[0].length);
              let ie = [];
              if (I)
                if (a === "block")
                  for (ie = g.blockTokens(Y), ie.forEach((ne) => {
                    ne.text && (!ne.tokens || ne.tokens.length === 0) && (ne.tokens = g.inlineTokens(ne.text));
                  }); ie.length > 0; ) {
                    const ne = ie[ie.length - 1];
                    if (ne.type === "paragraph" && (!ne.text || ne.text.trim() === ""))
                      ie.pop();
                    else
                      break;
                  }
                else
                  ie = g.inlineTokens(I);
              return {
                type: t,
                raw: he,
                attributes: M,
                content: I,
                tokens: ie
              };
            }
          }
        }
      }
    },
    renderMarkdown: (h, m) => {
      const g = f(h.attrs || {}), b = o(g), x = b ? ` {${b}}` : "", w = m.renderChildren(h.content || [], `

`);
      return `:::${u}${x}

${w}

:::`;
    }
  };
}
function FDe(e) {
  if (!e.trim())
    return {};
  const t = {}, n = /(\w+)=(?:"([^"]*)"|'([^']*)')/g;
  let r = n.exec(e);
  for (; r !== null; ) {
    const [, i, o, s] = r;
    t[i] = o || s, r = n.exec(e);
  }
  return t;
}
function VDe(e) {
  return Object.entries(e).filter(([, t]) => t != null).map(([t, n]) => `${t}="${n}"`).join(" ");
}
function HDe(e) {
  const {
    nodeName: t,
    name: n,
    getContent: r,
    parseAttributes: i = FDe,
    serializeAttributes: o = VDe,
    defaultAttributes: s = {},
    selfClosing: a = !1,
    allowedAttributes: c
  } = e, u = n || t, f = (m) => {
    if (!c)
      return m;
    const g = {};
    return c.forEach((b) => {
      const x = typeof b == "string" ? b : b.name, w = typeof b == "string" ? void 0 : b.skipIfDefault;
      if (x in m) {
        const S = m[x];
        if (w !== void 0 && S === w)
          return;
        g[x] = S;
      }
    }), g;
  }, h = u.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  return {
    parseMarkdown: (m, g) => {
      const b = { ...s, ...m.attributes };
      if (a)
        return g.createNode(t, b);
      const x = r ? r(m) : m.content || "";
      return x ? g.createNode(t, b, [g.createTextNode(x)]) : g.createNode(t, b, []);
    },
    markdownTokenizer: {
      name: t,
      level: "inline",
      start(m) {
        const g = a ? new RegExp(`\\[${h}\\s*[^\\]]*\\]`) : new RegExp(`\\[${h}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${h}\\]`), b = m.match(g), x = b?.index;
        return x !== void 0 ? x : -1;
      },
      tokenize(m, g, b) {
        const x = a ? new RegExp(`^\\[${h}\\s*([^\\]]*)\\]`) : new RegExp(`^\\[${h}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${h}\\]`), w = m.match(x);
        if (!w)
          return;
        let S = "", _ = "";
        if (a) {
          const [, N] = w;
          _ = N;
        } else {
          const [, N, P] = w;
          _ = N, S = P || "";
        }
        const M = i(_.trim());
        return {
          type: t,
          raw: w[0],
          content: S.trim(),
          attributes: M
        };
      }
    },
    renderMarkdown: (m) => {
      let g = "";
      r ? g = r(m) : m.content && m.content.length > 0 && (g = m.content.filter((S) => S.type === "text").map((S) => S.text).join(""));
      const b = f(m.attrs || {}), x = o(b), w = x ? ` ${x}` : "";
      return a ? `[${u}${w}]` : `[${u}${w}]${g}[/${u}]`;
    }
  };
}
function AT(e, t, n) {
  var r, i, o, s;
  const a = e.split(`
`), c = [];
  let u = "", f = 0;
  const h = t.baseIndentSize || 2;
  for (; f < a.length; ) {
    const m = a[f], g = m.match(t.itemPattern);
    if (!g) {
      if (c.length > 0)
        break;
      if (m.trim() === "") {
        f += 1, u = `${u}${m}
`;
        continue;
      } else
        return;
    }
    const b = t.extractItemData(g), { indentLevel: x, mainContent: w } = b;
    u = `${u}${m}
`;
    const S = [w];
    for (f += 1; f < a.length; ) {
      const P = a[f];
      if (P.trim() === "") {
        const O = a.slice(f + 1).findIndex((B) => B.trim() !== "");
        if (O === -1)
          break;
        if ((((i = (r = a[f + 1 + O].match(/^(\s*)/)) == null ? void 0 : r[1]) == null ? void 0 : i.length) || 0) > x) {
          S.push(P), u = `${u}${P}
`, f += 1;
          continue;
        } else
          break;
      }
      if ((((s = (o = P.match(/^(\s*)/)) == null ? void 0 : o[1]) == null ? void 0 : s.length) || 0) > x)
        S.push(P), u = `${u}${P}
`, f += 1;
      else
        break;
    }
    let _;
    const M = S.slice(1);
    if (M.length > 0) {
      const P = M.map((I) => I.slice(x + h)).join(`
`);
      P.trim() && (t.customNestedParser ? _ = t.customNestedParser(P) : _ = n.blockTokens(P));
    }
    const N = t.createToken(b, _);
    c.push(N);
  }
  if (c.length !== 0)
    return {
      items: c,
      raw: u
    };
}
function UN(e, t, n, r) {
  if (!e || !Array.isArray(e.content))
    return "";
  const i = typeof n == "function" ? n(r) : n, [o, ...s] = e.content, a = t.renderChildren([o]), c = [`${i}${a}`];
  return s && s.length > 0 && s.forEach((u) => {
    const f = t.renderChildren([u]);
    if (f) {
      const h = f.split(`
`).map((m) => m ? t.indent(m) : "").join(`
`);
      c.push(h);
    }
  }), c.join(`
`);
}
function WDe(e, t, n = {}) {
  const { state: r } = t, { doc: i, tr: o } = r, s = e;
  i.descendants((a, c) => {
    const u = o.mapping.map(c), f = o.mapping.map(c) + a.nodeSize;
    let h = null;
    if (a.marks.forEach((g) => {
      if (g !== s)
        return !1;
      h = g;
    }), !h)
      return;
    let m = !1;
    if (Object.keys(n).forEach((g) => {
      n[g] !== h.attrs[g] && (m = !0);
    }), m) {
      const g = e.type.create({
        ...e.attrs,
        ...n
      });
      o.removeMark(u, f, e.type), o.addMark(u, f, g);
    }
  }), o.docChanged && t.view.dispatch(o);
}
var ji = class dq extends LN {
  constructor() {
    super(...arguments), this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(t = {}) {
    const n = typeof t == "function" ? t() : t;
    return new dq(n);
  }
  configure(t) {
    return super.configure(t);
  }
  extend(t) {
    const n = typeof t == "function" ? t() : t;
    return super.extend(n);
  }
}, qDe = class {
  constructor(e, t, n) {
    this.isDragging = !1, this.component = e, this.editor = t.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...n
    }, this.extension = t.extension, this.node = t.node, this.decorations = t.decorations, this.innerDecorations = t.innerDecorations, this.view = t.view, this.HTMLAttributes = t.HTMLAttributes, this.getPos = t.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(e) {
    var t, n, r, i, o, s, a;
    const { view: c } = this.editor, u = e.target, f = u.nodeType === 3 ? (t = u.parentElement) == null ? void 0 : t.closest("[data-drag-handle]") : u.closest("[data-drag-handle]");
    if (!this.dom || (n = this.contentDOM) != null && n.contains(u) || !f)
      return;
    let h = 0, m = 0;
    if (this.dom !== f) {
      const _ = this.dom.getBoundingClientRect(), M = f.getBoundingClientRect(), N = (i = e.offsetX) != null ? i : (r = e.nativeEvent) == null ? void 0 : r.offsetX, P = (s = e.offsetY) != null ? s : (o = e.nativeEvent) == null ? void 0 : o.offsetY;
      h = M.x - _.x + N, m = M.y - _.y + P;
    }
    const g = this.dom.cloneNode(!0);
    try {
      const _ = this.dom.getBoundingClientRect();
      g.style.width = `${Math.round(_.width)}px`, g.style.height = `${Math.round(_.height)}px`, g.style.boxSizing = "border-box", g.style.pointerEvents = "none";
    } catch {
    }
    let b = null;
    try {
      b = document.createElement("div"), b.style.position = "absolute", b.style.top = "-9999px", b.style.left = "-9999px", b.style.pointerEvents = "none", b.appendChild(g), document.body.appendChild(b), (a = e.dataTransfer) == null || a.setDragImage(g, h, m);
    } finally {
      b && setTimeout(() => {
        try {
          b?.remove();
        } catch {
        }
      }, 0);
    }
    const x = this.getPos();
    if (typeof x != "number")
      return;
    const w = ht.create(c.state.doc, x), S = c.state.tr.setSelection(w);
    c.dispatch(S);
  }
  stopEvent(e) {
    var t;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: e });
    const n = e.target;
    if (!(this.dom.contains(n) && !((t = this.contentDOM) != null && t.contains(n))))
      return !1;
    const i = e.type.startsWith("drag"), o = e.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(n.tagName) || n.isContentEditable) && !o && !i)
      return !0;
    const { isEditable: a } = this.editor, { isDragging: c } = this, u = !!this.node.type.spec.draggable, f = ht.isSelectable(this.node), h = e.type === "copy", m = e.type === "paste", g = e.type === "cut", b = e.type === "mousedown";
    if (!u && f && i && e.target === this.dom && e.preventDefault(), u && i && !c && e.target === this.dom)
      return e.preventDefault(), !1;
    if (u && a && !c && b) {
      const x = n.closest("[data-drag-handle]");
      x && (this.dom === x || this.dom.contains(x)) && (this.isDragging = !0, document.addEventListener(
        "dragend",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ), document.addEventListener(
        "drop",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ), document.addEventListener(
        "mouseup",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ));
    }
    return !(c || o || h || m || g || b && f);
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? !0 : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (kg() || CT()) && this.editor.isFocused && [...Array.from(e.addedNodes), ...Array.from(e.removedNodes)].every((n) => n.isContentEditable) ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(e) {
    this.editor.commands.command(({ tr: t }) => {
      const n = this.getPos();
      return typeof n != "number" ? !1 : (t.setNodeMarkup(n, void 0, {
        ...this.node.attrs,
        ...e
      }), !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const e = this.getPos();
    if (typeof e != "number")
      return;
    const t = e + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: e, to: t });
  }
};
function ad(e) {
  return new _De({
    find: e.find,
    handler: ({ state: t, range: n, match: r, pasteEvent: i }) => {
      const o = mn(e.getAttributes, void 0, r, i);
      if (o === !1 || o === null)
        return null;
      const { tr: s } = t, a = r[r.length - 1], c = r[0];
      let u = n.to;
      if (a) {
        const f = c.search(/\S/), h = n.from + c.indexOf(a), m = h + a.length;
        if (zN(n.from, n.to, t.doc).filter((b) => b.mark.type.excluded.find((w) => w === e.type && w !== b.mark.type)).filter((b) => b.to > h).length)
          return null;
        m < n.to && s.delete(m, n.to), h > n.from && s.delete(n.from + f, h), u = n.from + f + a.length, s.addMark(n.from + f, u, e.type.create(o || {})), s.removeStoredMark(e.type);
      }
    }
  });
}
const { getOwnPropertyNames: GDe, getOwnPropertySymbols: KDe } = Object, { hasOwnProperty: ZDe } = Object.prototype;
function oE(e, t) {
  return function(r, i, o) {
    return e(r, i, o) && t(r, i, o);
  };
}
function o0(e) {
  return function(n, r, i) {
    if (!n || !r || typeof n != "object" || typeof r != "object")
      return e(n, r, i);
    const { cache: o } = i, s = o.get(n), a = o.get(r);
    if (s && a)
      return s === r && a === n;
    o.set(n, r), o.set(r, n);
    const c = e(n, r, i);
    return o.delete(n), o.delete(r), c;
  };
}
function YDe(e) {
  return e?.[Symbol.toStringTag];
}
function A5(e) {
  return GDe(e).concat(KDe(e));
}
const XDe = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  Object.hasOwn || ((e, t) => ZDe.call(e, t))
);
function gd(e, t) {
  return e === t || !e && !t && e !== e && t !== t;
}
const JDe = "__v", QDe = "__o", ePe = "_owner", { getOwnPropertyDescriptor: M5, keys: N5 } = Object;
function tPe(e, t) {
  return e.byteLength === t.byteLength && ux(new Uint8Array(e), new Uint8Array(t));
}
function nPe(e, t, n) {
  let r = e.length;
  if (t.length !== r)
    return !1;
  for (; r-- > 0; )
    if (!n.equals(e[r], t[r], r, r, e, t, n))
      return !1;
  return !0;
}
function rPe(e, t) {
  return e.byteLength === t.byteLength && ux(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), new Uint8Array(t.buffer, t.byteOffset, t.byteLength));
}
function iPe(e, t) {
  return gd(e.getTime(), t.getTime());
}
function oPe(e, t) {
  return e.name === t.name && e.message === t.message && e.cause === t.cause && e.stack === t.stack;
}
function sPe(e, t) {
  return e === t;
}
function R5(e, t, n) {
  const r = e.size;
  if (r !== t.size)
    return !1;
  if (!r)
    return !0;
  const i = new Array(r), o = e.entries();
  let s, a, c = 0;
  for (; (s = o.next()) && !s.done; ) {
    const u = t.entries();
    let f = !1, h = 0;
    for (; (a = u.next()) && !a.done; ) {
      if (i[h]) {
        h++;
        continue;
      }
      const m = s.value, g = a.value;
      if (n.equals(m[0], g[0], c, h, e, t, n) && n.equals(m[1], g[1], m[0], g[0], e, t, n)) {
        f = i[h] = !0;
        break;
      }
      h++;
    }
    if (!f)
      return !1;
    c++;
  }
  return !0;
}
const aPe = gd;
function lPe(e, t, n) {
  const r = N5(e);
  let i = r.length;
  if (N5(t).length !== i)
    return !1;
  for (; i-- > 0; )
    if (!fq(e, t, n, r[i]))
      return !1;
  return !0;
}
function nm(e, t, n) {
  const r = A5(e);
  let i = r.length;
  if (A5(t).length !== i)
    return !1;
  let o, s, a;
  for (; i-- > 0; )
    if (o = r[i], !fq(e, t, n, o) || (s = M5(e, o), a = M5(t, o), (s || a) && (!s || !a || s.configurable !== a.configurable || s.enumerable !== a.enumerable || s.writable !== a.writable)))
      return !1;
  return !0;
}
function cPe(e, t) {
  return gd(e.valueOf(), t.valueOf());
}
function uPe(e, t) {
  return e.source === t.source && e.flags === t.flags;
}
function O5(e, t, n) {
  const r = e.size;
  if (r !== t.size)
    return !1;
  if (!r)
    return !0;
  const i = new Array(r), o = e.values();
  let s, a;
  for (; (s = o.next()) && !s.done; ) {
    const c = t.values();
    let u = !1, f = 0;
    for (; (a = c.next()) && !a.done; ) {
      if (!i[f] && n.equals(s.value, a.value, s.value, a.value, e, t, n)) {
        u = i[f] = !0;
        break;
      }
      f++;
    }
    if (!u)
      return !1;
  }
  return !0;
}
function ux(e, t) {
  let n = e.byteLength;
  if (t.byteLength !== n || e.byteOffset !== t.byteOffset)
    return !1;
  for (; n-- > 0; )
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function dPe(e, t) {
  return e.hostname === t.hostname && e.pathname === t.pathname && e.protocol === t.protocol && e.port === t.port && e.hash === t.hash && e.username === t.username && e.password === t.password;
}
function fq(e, t, n, r) {
  return (r === ePe || r === QDe || r === JDe) && (e.$$typeof || t.$$typeof) ? !0 : XDe(t, r) && n.equals(e[r], t[r], r, r, e, t, n);
}
const fPe = "[object ArrayBuffer]", hPe = "[object Arguments]", pPe = "[object Boolean]", mPe = "[object DataView]", gPe = "[object Date]", yPe = "[object Error]", vPe = "[object Map]", bPe = "[object Number]", xPe = "[object Object]", wPe = "[object RegExp]", SPe = "[object Set]", kPe = "[object String]", CPe = {
  "[object Int8Array]": !0,
  "[object Uint8Array]": !0,
  "[object Uint8ClampedArray]": !0,
  "[object Int16Array]": !0,
  "[object Uint16Array]": !0,
  "[object Int32Array]": !0,
  "[object Uint32Array]": !0,
  "[object Float16Array]": !0,
  "[object Float32Array]": !0,
  "[object Float64Array]": !0,
  "[object BigInt64Array]": !0,
  "[object BigUint64Array]": !0
}, EPe = "[object URL]", _Pe = Object.prototype.toString;
function TPe({ areArrayBuffersEqual: e, areArraysEqual: t, areDataViewsEqual: n, areDatesEqual: r, areErrorsEqual: i, areFunctionsEqual: o, areMapsEqual: s, areNumbersEqual: a, areObjectsEqual: c, arePrimitiveWrappersEqual: u, areRegExpsEqual: f, areSetsEqual: h, areTypedArraysEqual: m, areUrlsEqual: g, unknownTagComparators: b }) {
  return function(w, S, _) {
    if (w === S)
      return !0;
    if (w == null || S == null)
      return !1;
    const M = typeof w;
    if (M !== typeof S)
      return !1;
    if (M !== "object")
      return M === "number" ? a(w, S, _) : M === "function" ? o(w, S, _) : !1;
    const N = w.constructor;
    if (N !== S.constructor)
      return !1;
    if (N === Object)
      return c(w, S, _);
    if (Array.isArray(w))
      return t(w, S, _);
    if (N === Date)
      return r(w, S, _);
    if (N === RegExp)
      return f(w, S, _);
    if (N === Map)
      return s(w, S, _);
    if (N === Set)
      return h(w, S, _);
    const P = _Pe.call(w);
    if (P === gPe)
      return r(w, S, _);
    if (P === wPe)
      return f(w, S, _);
    if (P === vPe)
      return s(w, S, _);
    if (P === SPe)
      return h(w, S, _);
    if (P === xPe)
      return typeof w.then != "function" && typeof S.then != "function" && c(w, S, _);
    if (P === EPe)
      return g(w, S, _);
    if (P === yPe)
      return i(w, S, _);
    if (P === hPe)
      return c(w, S, _);
    if (CPe[P])
      return m(w, S, _);
    if (P === fPe)
      return e(w, S, _);
    if (P === mPe)
      return n(w, S, _);
    if (P === pPe || P === bPe || P === kPe)
      return u(w, S, _);
    if (b) {
      let I = b[P];
      if (!I) {
        const O = YDe(w);
        O && (I = b[O]);
      }
      if (I)
        return I(w, S, _);
    }
    return !1;
  };
}
function APe({ circular: e, createCustomConfig: t, strict: n }) {
  let r = {
    areArrayBuffersEqual: tPe,
    areArraysEqual: n ? nm : nPe,
    areDataViewsEqual: rPe,
    areDatesEqual: iPe,
    areErrorsEqual: oPe,
    areFunctionsEqual: sPe,
    areMapsEqual: n ? oE(R5, nm) : R5,
    areNumbersEqual: aPe,
    areObjectsEqual: n ? nm : lPe,
    arePrimitiveWrappersEqual: cPe,
    areRegExpsEqual: uPe,
    areSetsEqual: n ? oE(O5, nm) : O5,
    areTypedArraysEqual: n ? oE(ux, nm) : ux,
    areUrlsEqual: dPe,
    unknownTagComparators: void 0
  };
  if (t && (r = Object.assign({}, r, t(r))), e) {
    const i = o0(r.areArraysEqual), o = o0(r.areMapsEqual), s = o0(r.areObjectsEqual), a = o0(r.areSetsEqual);
    r = Object.assign({}, r, {
      areArraysEqual: i,
      areMapsEqual: o,
      areObjectsEqual: s,
      areSetsEqual: a
    });
  }
  return r;
}
function MPe(e) {
  return function(t, n, r, i, o, s, a) {
    return e(t, n, a);
  };
}
function NPe({ circular: e, comparator: t, createState: n, equals: r, strict: i }) {
  if (n)
    return function(a, c) {
      const { cache: u = e ? /* @__PURE__ */ new WeakMap() : void 0, meta: f } = n();
      return t(a, c, {
        cache: u,
        equals: r,
        meta: f,
        strict: i
      });
    };
  if (e)
    return function(a, c) {
      return t(a, c, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: r,
        meta: void 0,
        strict: i
      });
    };
  const o = {
    cache: void 0,
    equals: r,
    meta: void 0,
    strict: i
  };
  return function(a, c) {
    return t(a, c, o);
  };
}
const RPe = Hc();
Hc({ strict: !0 });
Hc({ circular: !0 });
Hc({
  circular: !0,
  strict: !0
});
Hc({
  createInternalComparator: () => gd
});
Hc({
  strict: !0,
  createInternalComparator: () => gd
});
Hc({
  circular: !0,
  createInternalComparator: () => gd
});
Hc({
  circular: !0,
  createInternalComparator: () => gd,
  strict: !0
});
function Hc(e = {}) {
  const { circular: t = !1, createInternalComparator: n, createState: r, strict: i = !1 } = e, o = APe(e), s = TPe(o), a = n ? n(s) : MPe(s);
  return NPe({ circular: t, comparator: s, createState: r, equals: a, strict: i });
}
var sE = { exports: {} }, aE = {};
var D5;
function OPe() {
  if (D5) return aE;
  D5 = 1;
  var e = cd(), t = I3();
  function n(u, f) {
    return u === f && (u !== 0 || 1 / u === 1 / f) || u !== u && f !== f;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, a = e.useMemo, c = e.useDebugValue;
  return aE.useSyncExternalStoreWithSelector = function(u, f, h, m, g) {
    var b = o(null);
    if (b.current === null) {
      var x = { hasValue: !1, value: null };
      b.current = x;
    } else x = b.current;
    b = a(
      function() {
        function S(I) {
          if (!_) {
            if (_ = !0, M = I, I = m(I), g !== void 0 && x.hasValue) {
              var O = x.value;
              if (g(O, I))
                return N = O;
            }
            return N = I;
          }
          if (O = N, r(M, I)) return O;
          var L = m(I);
          return g !== void 0 && g(O, L) ? (M = I, O) : (M = I, N = L);
        }
        var _ = !1, M, N, P = h === void 0 ? null : h;
        return [
          function() {
            return S(f());
          },
          P === null ? void 0 : function() {
            return S(P());
          }
        ];
      },
      [f, h, m, g]
    );
    var w = i(u, b[0], b[1]);
    return s(
      function() {
        x.hasValue = !0, x.value = w;
      },
      [w]
    ), c(w), w;
  }, aE;
}
var P5;
function DPe() {
  return P5 || (P5 = 1, sE.exports = OPe()), sE.exports;
}
var PPe = DPe(), jPe = (...e) => (t) => {
  e.forEach((n) => {
    typeof n == "function" ? n(t) : n && (n.current = t);
  });
}, IPe = ({ contentComponent: e }) => {
  const t = nh.useSyncExternalStore(
    e.subscribe,
    e.getSnapshot,
    e.getServerSnapshot
  );
  return /* @__PURE__ */ v.jsx(v.Fragment, { children: Object.values(t) });
};
function zPe() {
  const e = /* @__PURE__ */ new Set();
  let t = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(n) {
      return e.add(n), () => {
        e.delete(n);
      };
    },
    getSnapshot() {
      return t;
    },
    getServerSnapshot() {
      return t;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(n, r) {
      t = {
        ...t,
        [n]: q3.createPortal(r.reactElement, r.element, n)
      }, e.forEach((i) => i());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(n) {
      const r = { ...t };
      delete r[n], t = r, e.forEach((i) => i());
    }
  };
}
var LPe = class extends Ne.Component {
  constructor(e) {
    var t;
    super(e), this.editorContentRef = Ne.createRef(), this.initialized = !1, this.state = {
      hasContentComponentInitialized: !!((t = e.editor) != null && t.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    var e;
    const t = this.props.editor;
    if (t && !t.isDestroyed && ((e = t.view.dom) != null && e.parentNode)) {
      if (t.contentComponent)
        return;
      const n = this.editorContentRef.current;
      n.append(...t.view.dom.parentNode.childNodes), t.setOptions({
        element: n
      }), t.contentComponent = zPe(), this.state.hasContentComponentInitialized || (this.unsubscribeToContentComponent = t.contentComponent.subscribe(() => {
        this.setState((r) => r.hasContentComponentInitialized ? r : {
          hasContentComponentInitialized: !0
        }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent();
      })), t.createNodeViews(), this.initialized = !0;
    }
  }
  componentWillUnmount() {
    var e;
    const t = this.props.editor;
    if (t) {
      this.initialized = !1, t.isDestroyed || t.view.setProps({
        nodeViews: {}
      }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent(), t.contentComponent = null;
      try {
        if (!((e = t.view.dom) != null && e.parentNode))
          return;
        const n = document.createElement("div");
        n.append(...t.view.dom.parentNode.childNodes), t.setOptions({
          element: n
        });
      } catch {
      }
    }
  }
  render() {
    const { editor: e, innerRef: t, ...n } = this.props;
    return /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
      /* @__PURE__ */ v.jsx("div", { ref: jPe(t, this.editorContentRef), ...n }),
      e?.contentComponent && /* @__PURE__ */ v.jsx(IPe, { contentComponent: e.contentComponent })
    ] });
  }
}, BPe = C.forwardRef(
  (e, t) => {
    const n = Ne.useMemo(() => Math.floor(Math.random() * 4294967295).toString(), [e.editor]);
    return Ne.createElement(LPe, {
      key: n,
      innerRef: t,
      ...e
    });
  }
), hq = Ne.memo(BPe), $Pe = typeof window < "u" ? C.useLayoutEffect : C.useEffect, UPe = class {
  constructor(e) {
    this.transactionNumber = 0, this.lastTransactionNumber = 0, this.subscribers = /* @__PURE__ */ new Set(), this.editor = e, this.lastSnapshot = { editor: e, transactionNumber: 0 }, this.getSnapshot = this.getSnapshot.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.watch = this.watch.bind(this), this.subscribe = this.subscribe.bind(this);
  }
  /**
   * Get the current editor instance.
   */
  getSnapshot() {
    return this.transactionNumber === this.lastTransactionNumber ? this.lastSnapshot : (this.lastTransactionNumber = this.transactionNumber, this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber }, this.lastSnapshot);
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return { editor: null, transactionNumber: 0 };
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(e) {
    return this.subscribers.add(e), () => {
      this.subscribers.delete(e);
    };
  }
  /**
   * Watch the editor instance for changes.
   */
  watch(e) {
    if (this.editor = e, this.editor) {
      const t = () => {
        this.transactionNumber += 1, this.subscribers.forEach((r) => r());
      }, n = this.editor;
      return n.on("transaction", t), () => {
        n.off("transaction", t);
      };
    }
  }
};
function FPe(e) {
  var t;
  const [n] = C.useState(() => new UPe(e.editor)), r = PPe.useSyncExternalStoreWithSelector(
    n.subscribe,
    n.getSnapshot,
    n.getServerSnapshot,
    e.selector,
    (t = e.equalityFn) != null ? t : RPe
  );
  return $Pe(() => n.watch(e.editor), [e.editor, n]), C.useDebugValue(r), r;
}
var VPe = !1, MT = typeof window > "u", HPe = MT || !!(typeof window < "u" && window.next), WPe = class pq {
  constructor(t) {
    this.editor = null, this.subscriptions = /* @__PURE__ */ new Set(), this.isComponentMounted = !1, this.previousDeps = null, this.instanceId = "", this.options = t, this.subscriptions = /* @__PURE__ */ new Set(), this.setEditor(this.getInitialEditor()), this.scheduleDestroy(), this.getEditor = this.getEditor.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.subscribe = this.subscribe.bind(this), this.refreshEditorInstance = this.refreshEditorInstance.bind(this), this.scheduleDestroy = this.scheduleDestroy.bind(this), this.onRender = this.onRender.bind(this), this.createEditor = this.createEditor.bind(this);
  }
  setEditor(t) {
    this.editor = t, this.instanceId = Math.random().toString(36).slice(2, 9), this.subscriptions.forEach((n) => n());
  }
  getInitialEditor() {
    return this.options.current.immediatelyRender === void 0 ? MT || HPe ? null : this.createEditor() : (this.options.current.immediatelyRender, this.options.current.immediatelyRender ? this.createEditor() : null);
  }
  /**
   * Create a new editor instance. And attach event listeners.
   */
  createEditor() {
    const t = {
      ...this.options.current,
      // Always call the most recent version of the callback function by default
      onBeforeCreate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onBeforeCreate) == null ? void 0 : o.call(i, ...r);
      },
      onBlur: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onBlur) == null ? void 0 : o.call(i, ...r);
      },
      onCreate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onCreate) == null ? void 0 : o.call(i, ...r);
      },
      onDestroy: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onDestroy) == null ? void 0 : o.call(i, ...r);
      },
      onFocus: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onFocus) == null ? void 0 : o.call(i, ...r);
      },
      onSelectionUpdate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onSelectionUpdate) == null ? void 0 : o.call(i, ...r);
      },
      onTransaction: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onTransaction) == null ? void 0 : o.call(i, ...r);
      },
      onUpdate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onUpdate) == null ? void 0 : o.call(i, ...r);
      },
      onContentError: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onContentError) == null ? void 0 : o.call(i, ...r);
      },
      onDrop: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onDrop) == null ? void 0 : o.call(i, ...r);
      },
      onPaste: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onPaste) == null ? void 0 : o.call(i, ...r);
      },
      onDelete: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onDelete) == null ? void 0 : o.call(i, ...r);
      }
    };
    return new jDe(t);
  }
  /**
   * Get the current editor instance.
   */
  getEditor() {
    return this.editor;
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return null;
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(t) {
    return this.subscriptions.add(t), () => {
      this.subscriptions.delete(t);
    };
  }
  static compareOptions(t, n) {
    return Object.keys(t).every((r) => [
      "onCreate",
      "onBeforeCreate",
      "onDestroy",
      "onUpdate",
      "onTransaction",
      "onFocus",
      "onBlur",
      "onSelectionUpdate",
      "onContentError",
      "onDrop",
      "onPaste"
    ].includes(r) ? !0 : r === "extensions" && t.extensions && n.extensions ? t.extensions.length !== n.extensions.length ? !1 : t.extensions.every((i, o) => {
      var s;
      return i === ((s = n.extensions) == null ? void 0 : s[o]);
    }) : t[r] === n[r]);
  }
  /**
   * On each render, we will create, update, or destroy the editor instance.
   * @param deps The dependencies to watch for changes
   * @returns A cleanup function
   */
  onRender(t) {
    return () => (this.isComponentMounted = !0, clearTimeout(this.scheduledDestructionTimeout), this.editor && !this.editor.isDestroyed && t.length === 0 ? pq.compareOptions(this.options.current, this.editor.options) || this.editor.setOptions({
      ...this.options.current,
      editable: this.editor.isEditable
    }) : this.refreshEditorInstance(t), () => {
      this.isComponentMounted = !1, this.scheduleDestroy();
    });
  }
  /**
   * Recreate the editor instance if the dependencies have changed.
   */
  refreshEditorInstance(t) {
    if (this.editor && !this.editor.isDestroyed) {
      if (this.previousDeps === null) {
        this.previousDeps = t;
        return;
      }
      if (this.previousDeps.length === t.length && this.previousDeps.every((r, i) => r === t[i]))
        return;
    }
    this.editor && !this.editor.isDestroyed && this.editor.destroy(), this.setEditor(this.createEditor()), this.previousDeps = t;
  }
  /**
   * Schedule the destruction of the editor instance.
   * This will only destroy the editor if it was not mounted on the next tick.
   * This is to avoid destroying the editor instance when it's actually still mounted.
   */
  scheduleDestroy() {
    const t = this.instanceId, n = this.editor;
    this.scheduledDestructionTimeout = setTimeout(() => {
      if (this.isComponentMounted && this.instanceId === t) {
        n && n.setOptions(this.options.current);
        return;
      }
      n && !n.isDestroyed && (n.destroy(), this.instanceId === t && this.setEditor(null));
    }, 1);
  }
};
function qPe(e = {}, t = []) {
  const n = C.useRef(e);
  n.current = e;
  const [r] = C.useState(() => new WPe(n)), i = nh.useSyncExternalStore(
    r.subscribe,
    r.getEditor,
    r.getServerSnapshot
  );
  return C.useDebugValue(i), C.useEffect(r.onRender(t)), FPe({
    editor: i,
    selector: ({ transactionNumber: o }) => e.shouldRerenderOnTransaction === !1 || e.shouldRerenderOnTransaction === void 0 ? null : e.immediatelyRender && o === 0 ? 0 : o + 1
  }), i;
}
var mq = C.createContext({
  editor: null
});
mq.Consumer;
var gq = C.createContext({
  onDragStart: () => {
  },
  nodeViewContentChildren: void 0,
  nodeViewContentRef: () => {
  }
}), GPe = () => C.useContext(gq), KPe = Ne.forwardRef((e, t) => {
  const { onDragStart: n } = GPe(), r = e.as || "div";
  return (
    // @ts-ignore
    /* @__PURE__ */ v.jsx(
      r,
      {
        ...e,
        ref: t,
        "data-node-view-wrapper": "",
        onDragStart: n,
        style: {
          whiteSpace: "normal",
          ...e.style
        }
      }
    )
  );
});
function j5(e) {
  return !!(typeof e == "function" && e.prototype && e.prototype.isReactComponent);
}
function I5(e) {
  return !!(typeof e == "object" && e.$$typeof && (e.$$typeof.toString() === "Symbol(react.forward_ref)" || e.$$typeof.description === "react.forward_ref"));
}
function ZPe(e) {
  return !!(typeof e == "object" && e.$$typeof && (e.$$typeof.toString() === "Symbol(react.memo)" || e.$$typeof.description === "react.memo"));
}
function YPe(e) {
  if (j5(e) || I5(e))
    return !0;
  if (ZPe(e)) {
    const t = e.type;
    if (t)
      return j5(t) || I5(t);
  }
  return !1;
}
function XPe() {
  try {
    if (C.version)
      return parseInt(C.version.split(".")[0], 10) >= 19;
  } catch {
  }
  return !1;
}
var JPe = class {
  /**
   * Immediately creates element and renders the provided React component.
   */
  constructor(e, { editor: t, props: n = {}, as: r = "div", className: i = "" }) {
    this.ref = null, this.destroyed = !1, this.id = Math.floor(Math.random() * 4294967295).toString(), this.component = e, this.editor = t, this.props = n, this.element = document.createElement(r), this.element.classList.add("react-renderer"), i && this.element.classList.add(...i.split(" ")), this.editor.isInitialized ? tl.flushSync(() => {
      this.render();
    }) : queueMicrotask(() => {
      this.destroyed || this.render();
    });
  }
  /**
   * Render the React component.
   */
  render() {
    var e;
    if (this.destroyed)
      return;
    const t = this.component, n = this.props, r = this.editor, i = XPe(), o = YPe(t), s = { ...n };
    s.ref && !(i || o) && delete s.ref, !s.ref && (i || o) && (s.ref = (a) => {
      this.ref = a;
    }), this.reactElement = /* @__PURE__ */ v.jsx(t, { ...s }), (e = r?.contentComponent) == null || e.setRenderer(this.id, this);
  }
  /**
   * Re-renders the React component with new props.
   */
  updateProps(e = {}) {
    this.destroyed || (this.props = {
      ...this.props,
      ...e
    }, this.render());
  }
  /**
   * Destroy the React component.
   */
  destroy() {
    var e;
    this.destroyed = !0;
    const t = this.editor;
    (e = t?.contentComponent) == null || e.removeRenderer(this.id);
    try {
      this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element);
    } catch {
    }
  }
  /**
   * Update the attributes of the element that holds the React component.
   */
  updateAttributes(e) {
    Object.keys(e).forEach((t) => {
      this.element.setAttribute(t, e[t]);
    });
  }
};
Ne.createContext({
  markViewContentRef: () => {
  }
});
var QPe = class extends qDe {
  constructor(e, t, n) {
    if (super(e, t, n), this.selectionRafId = null, this.cachedExtensionWithSyncedStorage = null, !this.node.isLeaf) {
      this.options.contentDOMElementTag ? this.contentDOMElement = document.createElement(this.options.contentDOMElementTag) : this.contentDOMElement = document.createElement(this.node.isInline ? "span" : "div"), this.contentDOMElement.dataset.nodeViewContentReact = "", this.contentDOMElement.dataset.nodeViewWrapper = "", this.contentDOMElement.style.whiteSpace = "inherit";
      const r = this.dom.querySelector("[data-node-view-content]");
      if (!r)
        return;
      r.appendChild(this.contentDOMElement);
    }
  }
  /**
   * Returns a proxy of the extension that redirects storage access to the editor's mutable storage.
   * This preserves the original prototype chain (instanceof checks, methods like configure/extend work).
   * Cached to avoid proxy creation on every update.
   */
  get extensionWithSyncedStorage() {
    if (!this.cachedExtensionWithSyncedStorage) {
      const e = this.editor, t = this.extension;
      this.cachedExtensionWithSyncedStorage = new Proxy(t, {
        get(n, r, i) {
          var o;
          return r === "storage" ? (o = e.storage[t.name]) != null ? o : {} : Reflect.get(n, r, i);
        }
      });
    }
    return this.cachedExtensionWithSyncedStorage;
  }
  /**
   * Setup the React component.
   * Called on initialization.
   */
  mount() {
    const e = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: !1,
      extension: this.extensionWithSyncedStorage,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (c = {}) => this.updateAttributes(c),
      deleteNode: () => this.deleteNode(),
      ref: C.createRef()
    };
    if (!this.component.displayName) {
      const c = (u) => u.charAt(0).toUpperCase() + u.substring(1);
      this.component.displayName = c(this.extension.name);
    }
    const r = { onDragStart: this.onDragStart.bind(this), nodeViewContentRef: (c) => {
      c && this.contentDOMElement && c.firstChild !== this.contentDOMElement && (c.hasAttribute("data-node-view-wrapper") && c.removeAttribute("data-node-view-wrapper"), c.appendChild(this.contentDOMElement));
    } }, i = this.component, o = C.memo((c) => /* @__PURE__ */ v.jsx(gq.Provider, { value: r, children: C.createElement(i, c) }));
    o.displayName = "ReactNodeView";
    let s = this.node.isInline ? "span" : "div";
    this.options.as && (s = this.options.as);
    const { className: a = "" } = this.options;
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.renderer = new JPe(o, {
      editor: this.editor,
      props: e,
      as: s,
      className: `node-${this.node.type.name} ${a}`.trim()
    }), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.updateElementAttributes();
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    var e;
    if (this.renderer.element.firstElementChild && !((e = this.renderer.element.firstElementChild) != null && e.hasAttribute("data-node-view-wrapper")))
      throw Error("Please use the NodeViewWrapper component for your node view.");
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    return this.node.isLeaf ? null : this.contentDOMElement;
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    this.selectionRafId && (cancelAnimationFrame(this.selectionRafId), this.selectionRafId = null), this.selectionRafId = requestAnimationFrame(() => {
      this.selectionRafId = null;
      const { from: e, to: t } = this.editor.state.selection, n = this.getPos();
      if (typeof n == "number")
        if (e <= n && t >= n + this.node.nodeSize) {
          if (this.renderer.props.selected)
            return;
          this.selectNode();
        } else {
          if (!this.renderer.props.selected)
            return;
          this.deselectNode();
        }
    });
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(e, t, n) {
    const r = (i) => {
      this.renderer.updateProps(i), typeof this.options.attrs == "function" && this.updateElementAttributes();
    };
    if (e.type !== this.node.type)
      return !1;
    if (typeof this.options.update == "function") {
      const i = this.node, o = this.decorations, s = this.innerDecorations;
      return this.node = e, this.decorations = t, this.innerDecorations = n, this.options.update({
        oldNode: i,
        oldDecorations: o,
        newNode: e,
        newDecorations: t,
        oldInnerDecorations: s,
        innerDecorations: n,
        updateProps: () => r({ node: e, decorations: t, innerDecorations: n, extension: this.extensionWithSyncedStorage })
      });
    }
    return e === this.node && this.decorations === t && this.innerDecorations === n || (this.node = e, this.decorations = t, this.innerDecorations = n, r({ node: e, decorations: t, innerDecorations: n, extension: this.extensionWithSyncedStorage })), !0;
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: !0
    }), this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: !1
    }), this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  /**
   * Destroy the React component instance.
   */
  destroy() {
    this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate), this.contentDOMElement = null, this.selectionRafId && (cancelAnimationFrame(this.selectionRafId), this.selectionRafId = null);
  }
  /**
   * Update the attributes of the top-level element that holds the React component.
   * Applying the attributes defined in the `attrs` option.
   */
  updateElementAttributes() {
    if (this.options.attrs) {
      let e = {};
      if (typeof this.options.attrs == "function") {
        const t = this.editor.extensionManager.attributes, n = bh(this.node, t);
        e = this.options.attrs({ node: this.node, HTMLAttributes: n });
      } else
        e = this.options.attrs;
      this.renderer.updateAttributes(e);
    }
  }
};
function eje(e, t) {
  return (n) => n.editor.contentComponent ? new QPe(e, n, t) : {};
}
var FN = C.createContext({
  get editor() {
    throw new Error("useTiptap must be used within a <Tiptap> provider");
  }
});
FN.displayName = "TiptapContext";
var tje = () => C.useContext(FN);
function yq({ editor: e, instance: t, children: n }) {
  const r = e ?? t;
  if (!r)
    throw new Error("Tiptap: An editor instance is required. Pass a non-null `editor` prop.");
  const i = C.useMemo(() => ({ editor: r }), [r]), o = C.useMemo(() => ({ editor: r }), [r]);
  return /* @__PURE__ */ v.jsx(mq.Provider, { value: o, children: /* @__PURE__ */ v.jsx(FN.Provider, { value: i, children: n }) });
}
yq.displayName = "Tiptap";
function vq({ ...e }) {
  const { editor: t } = tje();
  return /* @__PURE__ */ v.jsx(hq, { editor: t, ...e });
}
vq.displayName = "Tiptap.Content";
Object.assign(yq, {
  /**
   * The Tiptap Content component that renders the EditorContent with the editor instance from the context.
   * @see TiptapContent
   */
  Content: vq
});
var dx = (e, t) => {
  if (e === "slot")
    return 0;
  if (e instanceof Function)
    return e(t);
  const { children: n, ...r } = t ?? {};
  if (e === "svg")
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  return [e, r, n];
}, nje = /^\s*>\s$/, rje = ji.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [{ tag: "blockquote" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return /* @__PURE__ */ dx("blockquote", { ...or(this.options.HTMLAttributes, e), children: /* @__PURE__ */ dx("slot", {}) });
  },
  parseMarkdown: (e, t) => t.createNode("blockquote", void 0, t.parseChildren(e.tokens || [])),
  renderMarkdown: (e, t) => {
    if (!e.content)
      return "";
    const n = ">", r = [];
    return e.content.forEach((i) => {
      const a = t.renderChildren([i]).split(`
`).map((c) => c.trim() === "" ? n : `${n} ${c}`);
      r.push(a.join(`
`));
    }), r.join(`
${n}
`);
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: e }) => e.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: e }) => e.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: e }) => e.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wh({
        find: nje,
        type: this.type
      })
    ];
  }
}), ije = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, oje = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, sje = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, aje = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, lje = md.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (e) => e.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (e) => e.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return /* @__PURE__ */ dx("strong", { ...or(this.options.HTMLAttributes, e), children: /* @__PURE__ */ dx("slot", {}) });
  },
  markdownTokenName: "strong",
  parseMarkdown: (e, t) => t.applyMark("bold", t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => `**${t.renderChildren(e)}**`,
  addCommands() {
    return {
      setBold: () => ({ commands: e }) => e.setMark(this.name),
      toggleBold: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetBold: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      xh({
        find: ije,
        type: this.type
      }),
      xh({
        find: sje,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ad({
        find: oje,
        type: this.type
      }),
      ad({
        find: aje,
        type: this.type
      })
    ];
  }
}), cje = /(^|[^`])`([^`]+)`(?!`)$/, uje = /(^|[^`])`([^`]+)`(?!`)/g, dje = md.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [{ tag: "code" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["code", or(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "codespan",
  parseMarkdown: (e, t) => t.applyMark("code", [{ type: "text", text: e.text || "" }]),
  renderMarkdown: (e, t) => e.content ? `\`${t.renderChildren(e.content)}\`` : "",
  addCommands() {
    return {
      setCode: () => ({ commands: e }) => e.setMark(this.name),
      toggleCode: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetCode: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      xh({
        find: cje,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ad({
        find: uje,
        type: this.type
      })
    ];
  }
}), lE = 4, fje = /^```([a-z]+)?[\s\n]$/, hje = /^~~~([a-z]+)?[\s\n]$/, pje = ji.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      enableTabIndentation: !1,
      tabSize: lE,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (e) => {
          var t;
          const { languageClassPrefix: n } = this.options;
          if (!n)
            return null;
          const o = [...((t = e.firstElementChild) == null ? void 0 : t.classList) || []].filter((s) => s.startsWith(n)).map((s) => s.replace(n, ""))[0];
          return o || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "pre",
      or(this.options.HTMLAttributes, t),
      [
        "code",
        {
          class: e.attrs.language ? this.options.languageClassPrefix + e.attrs.language : null
        },
        0
      ]
    ];
  },
  markdownTokenName: "code",
  parseMarkdown: (e, t) => {
    var n;
    return ((n = e.raw) == null ? void 0 : n.startsWith("```")) === !1 && e.codeBlockStyle !== "indented" ? [] : t.createNode(
      "codeBlock",
      { language: e.lang || null },
      e.text ? [t.createTextNode(e.text)] : []
    );
  },
  renderMarkdown: (e, t) => {
    var n;
    let r = "";
    const i = ((n = e.attrs) == null ? void 0 : n.language) || "";
    return e.content ? r = [`\`\`\`${i}`, t.renderChildren(e.content), "```"].join(`
`) : r = `\`\`\`${i}

\`\`\``, r;
  },
  addCommands() {
    return {
      setCodeBlock: (e) => ({ commands: t }) => t.setNode(this.name, e),
      toggleCodeBlock: (e) => ({ commands: t }) => t.toggleNode(this.name, "paragraph", e)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: e, $anchor: t } = this.editor.state.selection, n = t.pos === 1;
        return !e || t.parent.type.name !== this.name ? !1 : n || !t.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // handle tab indentation
      Tab: ({ editor: e }) => {
        var t;
        if (!this.options.enableTabIndentation)
          return !1;
        const n = (t = this.options.tabSize) != null ? t : lE, { state: r } = e, { selection: i } = r, { $from: o, empty: s } = i;
        if (o.parent.type !== this.type)
          return !1;
        const a = " ".repeat(n);
        return s ? e.commands.insertContent(a) : e.commands.command(({ tr: c }) => {
          const { from: u, to: f } = i, g = r.doc.textBetween(u, f, `
`, `
`).split(`
`).map((b) => a + b).join(`
`);
          return c.replaceWith(u, f, r.schema.text(g)), !0;
        });
      },
      // handle shift+tab reverse indentation
      "Shift-Tab": ({ editor: e }) => {
        var t;
        if (!this.options.enableTabIndentation)
          return !1;
        const n = (t = this.options.tabSize) != null ? t : lE, { state: r } = e, { selection: i } = r, { $from: o, empty: s } = i;
        return o.parent.type !== this.type ? !1 : s ? e.commands.command(({ tr: a }) => {
          var c;
          const { pos: u } = o, f = o.start(), h = o.end(), g = r.doc.textBetween(f, h, `
`, `
`).split(`
`);
          let b = 0, x = 0;
          const w = u - f;
          for (let I = 0; I < g.length; I += 1) {
            if (x + g[I].length >= w) {
              b = I;
              break;
            }
            x += g[I].length + 1;
          }
          const _ = ((c = g[b].match(/^ */)) == null ? void 0 : c[0]) || "", M = Math.min(_.length, n);
          if (M === 0)
            return !0;
          let N = f;
          for (let I = 0; I < b; I += 1)
            N += g[I].length + 1;
          return a.delete(N, N + M), u - N <= M && a.setSelection(kt.create(a.doc, N)), !0;
        }) : e.commands.command(({ tr: a }) => {
          const { from: c, to: u } = i, m = r.doc.textBetween(c, u, `
`, `
`).split(`
`).map((g) => {
            var b;
            const x = ((b = g.match(/^ */)) == null ? void 0 : b[0]) || "", w = Math.min(x.length, n);
            return g.slice(w);
          }).join(`
`);
          return a.replaceWith(c, u, r.schema.text(m)), !0;
        });
      },
      // exit node on triple enter
      Enter: ({ editor: e }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: t } = e, { selection: n } = t, { $from: r, empty: i } = n;
        if (!i || r.parent.type !== this.type)
          return !1;
        const o = r.parentOffset === r.parent.nodeSize - 2, s = r.parent.textContent.endsWith(`

`);
        return !o || !s ? !1 : e.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: e }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: t } = e, { selection: n, doc: r } = t, { $from: i, empty: o } = n;
        if (!o || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2))
          return !1;
        const a = i.after();
        return a === void 0 ? !1 : r.nodeAt(a) ? e.commands.command(({ tr: u }) => (u.setSelection(zt.near(r.resolve(a))), !0)) : e.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      TT({
        find: fje,
        type: this.type,
        getAttributes: (e) => ({
          language: e[1]
        })
      }),
      TT({
        find: hje,
        type: this.type,
        getAttributes: (e) => ({
          language: e[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Zn({
        key: new Tr("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (e, t) => {
            if (!t.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = t.clipboardData.getData("text/plain"), r = t.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, o = i?.mode;
            if (!n || !o)
              return !1;
            const { tr: s, schema: a } = e.state, c = a.text(n.replace(/\r\n?/g, `
`));
            return s.replaceSelectionWith(this.type.create({ language: o }, c)), s.selection.$from.parent.type !== this.type && s.setSelection(kt.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.setMeta("paste", !0), e.dispatch(s), !0;
          }
        }
      })
    ];
  }
}), mje = ji.create({
  name: "doc",
  topNode: !0,
  content: "block+",
  renderMarkdown: (e, t) => e.content ? t.renderChildren(e.content, `

`) : ""
}), gje = ji.create({
  name: "hardBreak",
  markdownTokenName: "br",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["br", or(this.options.HTMLAttributes, e)];
  },
  renderText() {
    return `
`;
  },
  renderMarkdown: () => `  
`,
  parseMarkdown: () => ({
    type: "hardBreak"
  }),
  addCommands() {
    return {
      setHardBreak: () => ({ commands: e, chain: t, state: n, editor: r }) => e.first([
        () => e.exitCode(),
        () => e.command(() => {
          const { selection: i, storedMarks: o } = n;
          if (i.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: s } = this.options, { splittableMarks: a } = r.extensionManager, c = o || i.$to.parentOffset && i.$from.marks();
          return t().insertContent({ type: this.name }).command(({ tr: u, dispatch: f }) => {
            if (f && c && s) {
              const h = c.filter((m) => a.includes(m.type.name));
              u.ensureMarks(h);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), yje = ji.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((e) => ({
      tag: `h${e}`,
      attrs: { level: e }
    }));
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [`h${this.options.levels.includes(e.attrs.level) ? e.attrs.level : this.options.levels[0]}`, or(this.options.HTMLAttributes, t), 0];
  },
  parseMarkdown: (e, t) => t.createNode("heading", { level: e.depth || 1 }, t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => {
    var n;
    const r = (n = e.attrs) != null && n.level ? parseInt(e.attrs.level, 10) : 1, i = "#".repeat(r);
    return e.content ? `${i} ${t.renderChildren(e.content)}` : "";
  },
  addCommands() {
    return {
      setHeading: (e) => ({ commands: t }) => this.options.levels.includes(e.level) ? t.setNode(this.name, e) : !1,
      toggleHeading: (e) => ({ commands: t }) => this.options.levels.includes(e.level) ? t.toggleNode(this.name, "paragraph", e) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce(
      (e, t) => ({
        ...e,
        [`Mod-Alt-${t}`]: () => this.editor.commands.toggleHeading({ level: t })
      }),
      {}
    );
  },
  addInputRules() {
    return this.options.levels.map((e) => TT({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${e}})\\s$`),
      type: this.type,
      getAttributes: {
        level: e
      }
    }));
  }
}), vje = ji.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {},
      nextNodeType: "paragraph"
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["hr", or(this.options.HTMLAttributes, e)];
  },
  markdownTokenName: "hr",
  parseMarkdown: (e, t) => t.createNode("horizontalRule"),
  renderMarkdown: () => "---",
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: e, state: t }) => {
        if (!zDe(t, t.schema.nodes[this.name]))
          return !1;
        const { selection: n } = t, { $to: r } = n, i = e();
        return KW(n) ? i.insertContentAt(r.pos, {
          type: this.name
        }) : i.insertContent({ type: this.name }), i.command(({ state: o, tr: s, dispatch: a }) => {
          if (a) {
            const { $to: c } = s.selection, u = c.end();
            if (c.nodeAfter)
              c.nodeAfter.isTextblock ? s.setSelection(kt.create(s.doc, c.pos + 1)) : c.nodeAfter.isBlock ? s.setSelection(ht.create(s.doc, c.pos)) : s.setSelection(kt.create(s.doc, c.pos));
            else {
              const f = o.schema.nodes[this.options.nextNodeType] || c.parent.type.contentMatch.defaultType, h = f?.create();
              h && (s.insert(u, h), s.setSelection(kt.create(s.doc, u + 1)));
            }
            s.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      IDe({
        find: /^(?:---|-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), bje = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, xje = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, wje = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, Sje = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, kje = md.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (e) => e.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (e) => e.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["em", or(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: e }) => e.setMark(this.name),
      toggleItalic: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetItalic: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  markdownTokenName: "em",
  parseMarkdown: (e, t) => t.applyMark("italic", t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => `*${t.renderChildren(e)}*`,
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      xh({
        find: bje,
        type: this.type
      }),
      xh({
        find: wje,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ad({
        find: xje,
        type: this.type
      }),
      ad({
        find: Sje,
        type: this.type
      })
    ];
  }
});
const Cje = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", Eje = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", NT = "numeric", RT = "ascii", OT = "alpha", $m = "asciinumeric", bm = "alphanumeric", DT = "domain", bq = "emoji", _je = "scheme", Tje = "slashscheme", cE = "whitespace";
function Aje(e, t) {
  return e in t || (t[e] = []), t[e];
}
function Lu(e, t, n) {
  t[NT] && (t[$m] = !0, t[bm] = !0), t[RT] && (t[$m] = !0, t[OT] = !0), t[$m] && (t[bm] = !0), t[OT] && (t[bm] = !0), t[bm] && (t[DT] = !0), t[bq] && (t[DT] = !0);
  for (const r in t) {
    const i = Aje(r, n);
    i.indexOf(e) < 0 && i.push(e);
  }
}
function Mje(e, t) {
  const n = {};
  for (const r in t)
    t[r].indexOf(e) >= 0 && (n[r] = !0);
  return n;
}
function qi(e = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = e;
}
qi.groups = {};
qi.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(e) {
    const t = this, n = t.j[e];
    if (n)
      return n;
    for (let r = 0; r < t.jr.length; r++) {
      const i = t.jr[r][0], o = t.jr[r][1];
      if (o && i.test(e))
        return o;
    }
    return t.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(e, t = !1) {
    return t ? e in this.j : !!this.go(e);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(e, t, n, r) {
    for (let i = 0; i < e.length; i++)
      this.tt(e[i], t, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(e, t, n, r) {
    r = r || qi.groups;
    let i;
    return t && t.j ? i = t : (i = new qi(t), n && r && Lu(t, n, r)), this.jr.push([e, i]), i;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(e, t, n, r) {
    let i = this;
    const o = e.length;
    if (!o)
      return i;
    for (let s = 0; s < o - 1; s++)
      i = i.tt(e[s]);
    return i.tt(e[o - 1], t, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(e, t, n, r) {
    r = r || qi.groups;
    const i = this;
    if (t && t.j)
      return i.j[e] = t, t;
    const o = t;
    let s, a = i.go(e);
    if (a ? (s = new qi(), Object.assign(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new qi(), o) {
      if (r)
        if (s.t && typeof s.t == "string") {
          const c = Object.assign(Mje(s.t, r), n);
          Lu(o, c, r);
        } else n && Lu(o, n, r);
      s.t = o;
    }
    return i.j[e] = s, s;
  }
};
const jt = (e, t, n, r, i) => e.ta(t, n, r, i), er = (e, t, n, r, i) => e.tr(t, n, r, i), z5 = (e, t, n, r, i) => e.ts(t, n, r, i), Ue = (e, t, n, r, i) => e.tt(t, n, r, i), Ba = "WORD", PT = "UWORD", xq = "ASCIINUMERICAL", wq = "ALPHANUMERICAL", Eg = "LOCALHOST", jT = "TLD", IT = "UTLD", q0 = "SCHEME", Nf = "SLASH_SCHEME", VN = "NUM", zT = "WS", HN = "NL", Um = "OPENBRACE", Fm = "CLOSEBRACE", fx = "OPENBRACKET", hx = "CLOSEBRACKET", px = "OPENPAREN", mx = "CLOSEPAREN", gx = "OPENANGLEBRACKET", yx = "CLOSEANGLEBRACKET", vx = "FULLWIDTHLEFTPAREN", bx = "FULLWIDTHRIGHTPAREN", xx = "LEFTCORNERBRACKET", wx = "RIGHTCORNERBRACKET", Sx = "LEFTWHITECORNERBRACKET", kx = "RIGHTWHITECORNERBRACKET", Cx = "FULLWIDTHLESSTHAN", Ex = "FULLWIDTHGREATERTHAN", _x = "AMPERSAND", Tx = "APOSTROPHE", Ax = "ASTERISK", nc = "AT", Mx = "BACKSLASH", Nx = "BACKTICK", Rx = "CARET", oc = "COLON", WN = "COMMA", Ox = "DOLLAR", zs = "DOT", Dx = "EQUALS", qN = "EXCLAMATION", Do = "HYPHEN", Vm = "PERCENT", Px = "PIPE", jx = "PLUS", Ix = "POUND", Hm = "QUERY", GN = "QUOTE", Sq = "FULLWIDTHMIDDLEDOT", KN = "SEMI", Ls = "SLASH", Wm = "TILDE", zx = "UNDERSCORE", kq = "EMOJI", Lx = "SYM";
var Cq = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: wq,
  AMPERSAND: _x,
  APOSTROPHE: Tx,
  ASCIINUMERICAL: xq,
  ASTERISK: Ax,
  AT: nc,
  BACKSLASH: Mx,
  BACKTICK: Nx,
  CARET: Rx,
  CLOSEANGLEBRACKET: yx,
  CLOSEBRACE: Fm,
  CLOSEBRACKET: hx,
  CLOSEPAREN: mx,
  COLON: oc,
  COMMA: WN,
  DOLLAR: Ox,
  DOT: zs,
  EMOJI: kq,
  EQUALS: Dx,
  EXCLAMATION: qN,
  FULLWIDTHGREATERTHAN: Ex,
  FULLWIDTHLEFTPAREN: vx,
  FULLWIDTHLESSTHAN: Cx,
  FULLWIDTHMIDDLEDOT: Sq,
  FULLWIDTHRIGHTPAREN: bx,
  HYPHEN: Do,
  LEFTCORNERBRACKET: xx,
  LEFTWHITECORNERBRACKET: Sx,
  LOCALHOST: Eg,
  NL: HN,
  NUM: VN,
  OPENANGLEBRACKET: gx,
  OPENBRACE: Um,
  OPENBRACKET: fx,
  OPENPAREN: px,
  PERCENT: Vm,
  PIPE: Px,
  PLUS: jx,
  POUND: Ix,
  QUERY: Hm,
  QUOTE: GN,
  RIGHTCORNERBRACKET: wx,
  RIGHTWHITECORNERBRACKET: kx,
  SCHEME: q0,
  SEMI: KN,
  SLASH: Ls,
  SLASH_SCHEME: Nf,
  SYM: Lx,
  TILDE: Wm,
  TLD: jT,
  UNDERSCORE: zx,
  UTLD: IT,
  UWORD: PT,
  WORD: Ba,
  WS: zT
});
const ja = /[a-z]/, rm = new RegExp("\\p{L}", "u"), uE = new RegExp("\\p{Emoji}", "u"), Ia = /\d/, dE = /\s/, L5 = "\r", fE = `
`, Nje = "", Rje = "", hE = "";
let s0 = null, a0 = null;
function Oje(e = []) {
  const t = {};
  qi.groups = t;
  const n = new qi();
  s0 == null && (s0 = B5(Cje)), a0 == null && (a0 = B5(Eje)), Ue(n, "'", Tx), Ue(n, "{", Um), Ue(n, "}", Fm), Ue(n, "[", fx), Ue(n, "]", hx), Ue(n, "(", px), Ue(n, ")", mx), Ue(n, "<", gx), Ue(n, ">", yx), Ue(n, "", vx), Ue(n, "", bx), Ue(n, "", xx), Ue(n, "", wx), Ue(n, "", Sx), Ue(n, "", kx), Ue(n, "", Cx), Ue(n, "", Ex), Ue(n, "&", _x), Ue(n, "*", Ax), Ue(n, "@", nc), Ue(n, "`", Nx), Ue(n, "^", Rx), Ue(n, ":", oc), Ue(n, ",", WN), Ue(n, "$", Ox), Ue(n, ".", zs), Ue(n, "=", Dx), Ue(n, "!", qN), Ue(n, "-", Do), Ue(n, "%", Vm), Ue(n, "|", Px), Ue(n, "+", jx), Ue(n, "#", Ix), Ue(n, "?", Hm), Ue(n, '"', GN), Ue(n, "/", Ls), Ue(n, ";", KN), Ue(n, "~", Wm), Ue(n, "_", zx), Ue(n, "\\", Mx), Ue(n, "", Sq);
  const r = er(n, Ia, VN, {
    [NT]: !0
  });
  er(r, Ia, r);
  const i = er(r, ja, xq, {
    [$m]: !0
  }), o = er(r, rm, wq, {
    [bm]: !0
  }), s = er(n, ja, Ba, {
    [RT]: !0
  });
  er(s, Ia, i), er(s, ja, s), er(i, Ia, i), er(i, ja, i);
  const a = er(n, rm, PT, {
    [OT]: !0
  });
  er(a, ja), er(a, Ia, o), er(a, rm, a), er(o, Ia, o), er(o, ja), er(o, rm, o);
  const c = Ue(n, fE, HN, {
    [cE]: !0
  }), u = Ue(n, L5, zT, {
    [cE]: !0
  }), f = er(n, dE, zT, {
    [cE]: !0
  });
  Ue(n, hE, f), Ue(u, fE, c), Ue(u, hE, f), er(u, dE, f), Ue(f, L5), Ue(f, fE), er(f, dE, f), Ue(f, hE, f);
  const h = er(n, uE, kq, {
    [bq]: !0
  });
  Ue(h, "#"), er(h, uE, h), Ue(h, Nje, h);
  const m = Ue(h, Rje);
  Ue(m, "#"), er(m, uE, h);
  const g = [[ja, s], [Ia, i]], b = [[ja, null], [rm, a], [Ia, o]];
  for (let x = 0; x < s0.length; x++)
    Hl(n, s0[x], jT, Ba, g);
  for (let x = 0; x < a0.length; x++)
    Hl(n, a0[x], IT, PT, b);
  Lu(jT, {
    tld: !0,
    ascii: !0
  }, t), Lu(IT, {
    utld: !0,
    alpha: !0
  }, t), Hl(n, "file", q0, Ba, g), Hl(n, "mailto", q0, Ba, g), Hl(n, "http", Nf, Ba, g), Hl(n, "https", Nf, Ba, g), Hl(n, "ftp", Nf, Ba, g), Hl(n, "ftps", Nf, Ba, g), Lu(q0, {
    scheme: !0,
    ascii: !0
  }, t), Lu(Nf, {
    slashscheme: !0,
    ascii: !0
  }, t), e = e.sort((x, w) => x[0] > w[0] ? 1 : -1);
  for (let x = 0; x < e.length; x++) {
    const w = e[x][0], _ = e[x][1] ? {
      [_je]: !0
    } : {
      [Tje]: !0
    };
    w.indexOf("-") >= 0 ? _[DT] = !0 : ja.test(w) ? Ia.test(w) ? _[$m] = !0 : _[RT] = !0 : _[NT] = !0, z5(n, w, w, _);
  }
  return z5(n, "localhost", Eg, {
    ascii: !0
  }), n.jd = new qi(Lx), {
    start: n,
    tokens: Object.assign({
      groups: t
    }, Cq)
  };
}
function Eq(e, t) {
  const n = Dje(t.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = n.length, i = [];
  let o = 0, s = 0;
  for (; s < r; ) {
    let a = e, c = null, u = 0, f = null, h = -1, m = -1;
    for (; s < r && (c = a.go(n[s])); )
      a = c, a.accepts() ? (h = 0, m = 0, f = a) : h >= 0 && (h += n[s].length, m++), u += n[s].length, o += n[s].length, s++;
    o -= h, s -= m, u -= h, i.push({
      t: f.t,
      // token type/name
      v: t.slice(o - u, o),
      // string value
      s: o - u,
      // start index
      e: o
      // end index (excluding)
    });
  }
  return i;
}
function Dje(e) {
  const t = [], n = e.length;
  let r = 0;
  for (; r < n; ) {
    let i = e.charCodeAt(r), o, s = i < 55296 || i > 56319 || r + 1 === n || (o = e.charCodeAt(r + 1)) < 56320 || o > 57343 ? e[r] : e.slice(r, r + 2);
    t.push(s), r += s.length;
  }
  return t;
}
function Hl(e, t, n, r, i) {
  let o;
  const s = t.length;
  for (let a = 0; a < s - 1; a++) {
    const c = t[a];
    e.j[c] ? o = e.j[c] : (o = new qi(r), o.jr = i.slice(), e.j[c] = o), e = o;
  }
  return o = new qi(n), o.jr = i.slice(), e.j[t[s - 1]] = o, o;
}
function B5(e) {
  const t = [], n = [];
  let r = 0, i = "0123456789";
  for (; r < e.length; ) {
    let o = 0;
    for (; i.indexOf(e[r + o]) >= 0; )
      o++;
    if (o > 0) {
      t.push(n.join(""));
      for (let s = parseInt(e.substring(r, r + o), 10); s > 0; s--)
        n.pop();
      r += o;
    } else
      n.push(e[r]), r++;
  }
  return t;
}
const _g = {
  defaultProtocol: "http",
  events: null,
  format: $5,
  formatHref: $5,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function ZN(e, t = null) {
  let n = Object.assign({}, _g);
  e && (n = Object.assign(n, e instanceof ZN ? e.o : e));
  const r = n.ignoreTags, i = [];
  for (let o = 0; o < r.length; o++)
    i.push(r[o].toUpperCase());
  this.o = n, t && (this.defaultRender = t), this.ignoreTags = i;
}
ZN.prototype = {
  o: _g,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(e) {
    return e;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(e) {
    return this.get("validate", e.toString(), e);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(e, t, n) {
    const r = t != null;
    let i = this.o[e];
    return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : _g[e], typeof i == "function" && r && (i = i(t, n))) : typeof i == "function" && r && (i = i(t, n.t, n)), i);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(e, t, n) {
    let r = this.o[e];
    return typeof r == "function" && t != null && (r = r(t, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(e) {
    const t = e.render(this);
    return (this.get("render", null, e) || this.defaultRender)(t, e.t, e);
  }
};
function $5(e) {
  return e;
}
function _q(e, t) {
  this.t = "token", this.v = e, this.tk = t;
}
_q.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(e) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(e) {
    const t = this.toString(), n = e.get("truncate", t, this), r = e.get("format", t, this);
    return n && r.length > n ? r.substring(0, n) + "" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(e) {
    return e.get("formatHref", this.toHref(e.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(e = _g.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(e),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(e) {
    return {
      type: this.t,
      value: this.toFormattedString(e),
      isLink: this.isLink,
      href: this.toFormattedHref(e),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(e) {
    return e.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(e) {
    const t = this, n = this.toHref(e.get("defaultProtocol")), r = e.get("formatHref", n, this), i = e.get("tagName", n, t), o = this.toFormattedString(e), s = {}, a = e.get("className", n, t), c = e.get("target", n, t), u = e.get("rel", n, t), f = e.getObj("attributes", n, t), h = e.getObj("events", n, t);
    return s.href = r, a && (s.class = a), c && (s.target = c), u && (s.rel = u), f && Object.assign(s, f), {
      tagName: i,
      attributes: s,
      content: o,
      eventListeners: h
    };
  }
};
function s1(e, t) {
  class n extends _q {
    constructor(i, o) {
      super(i, o), this.t = e;
    }
  }
  for (const r in t)
    n.prototype[r] = t[r];
  return n.t = e, n;
}
const U5 = s1("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), F5 = s1("text"), Pje = s1("nl"), l0 = s1("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(e = _g.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${e}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const e = this.tk;
    return e.length >= 2 && e[0].t !== Eg && e[1].t === oc;
  }
}), Mo = (e) => new qi(e);
function jje({
  groups: e
}) {
  const t = e.domain.concat([_x, Ax, nc, Mx, Nx, Rx, Ox, Dx, Do, VN, Vm, Px, jx, Ix, Ls, Lx, Wm, zx]), n = [Tx, oc, WN, zs, qN, Vm, Hm, GN, KN, gx, yx, Um, Fm, hx, fx, px, mx, vx, bx, xx, wx, Sx, kx, Cx, Ex], r = [_x, Tx, Ax, Mx, Nx, Rx, Ox, Dx, Do, Um, Fm, Vm, Px, jx, Ix, Hm, Ls, Lx, Wm, zx], i = Mo(), o = Ue(i, Wm);
  jt(o, r, o), jt(o, e.domain, o);
  const s = Mo(), a = Mo(), c = Mo();
  jt(i, e.domain, s), jt(i, e.scheme, a), jt(i, e.slashscheme, c), jt(s, r, o), jt(s, e.domain, s);
  const u = Ue(s, nc);
  Ue(o, nc, u), Ue(a, nc, u), Ue(c, nc, u);
  const f = Ue(o, zs);
  jt(f, r, o), jt(f, e.domain, o);
  const h = Mo();
  jt(u, e.domain, h), jt(h, e.domain, h);
  const m = Ue(h, zs);
  jt(m, e.domain, h);
  const g = Mo(U5);
  jt(m, e.tld, g), jt(m, e.utld, g), Ue(u, Eg, g);
  const b = Ue(h, Do);
  Ue(b, Do, b), jt(b, e.domain, h), jt(g, e.domain, h), Ue(g, zs, m), Ue(g, Do, b);
  const x = Ue(g, oc);
  jt(x, e.numeric, U5);
  const w = Ue(s, Do), S = Ue(s, zs);
  Ue(w, Do, w), jt(w, e.domain, s), jt(S, r, o), jt(S, e.domain, s);
  const _ = Mo(l0);
  jt(S, e.tld, _), jt(S, e.utld, _), jt(_, e.domain, s), jt(_, r, o), Ue(_, zs, S), Ue(_, Do, w), Ue(_, nc, u);
  const M = Ue(_, oc), N = Mo(l0);
  jt(M, e.numeric, N);
  const P = Mo(l0), I = Mo();
  jt(P, t, P), jt(P, n, I), jt(I, t, P), jt(I, n, I), Ue(_, Ls, P), Ue(N, Ls, P);
  const O = Ue(a, oc), L = Ue(c, oc), U = Ue(L, Ls), B = Ue(U, Ls);
  jt(a, e.domain, s), Ue(a, zs, S), Ue(a, Do, w), jt(c, e.domain, s), Ue(c, zs, S), Ue(c, Do, w), jt(O, e.domain, P), Ue(O, Ls, P), Ue(O, Hm, P), jt(B, e.domain, P), jt(B, t, P), Ue(B, Ls, P);
  const G = [
    [Um, Fm],
    // {}
    [fx, hx],
    // []
    [px, mx],
    // ()
    [gx, yx],
    // <>
    [vx, bx],
    // 
    [xx, wx],
    // 
    [Sx, kx],
    // 
    [Cx, Ex]
    // 
  ];
  for (let Y = 0; Y < G.length; Y++) {
    const [he, ie] = G[Y], ne = Ue(P, he);
    Ue(I, he, ne), Ue(ne, ie, P);
    const H = Mo(l0);
    jt(ne, t, H);
    const Q = Mo();
    jt(ne, n), jt(H, t, H), jt(H, n, Q), jt(Q, t, H), jt(Q, n, Q), Ue(H, ie, P), Ue(Q, ie, P);
  }
  return Ue(i, Eg, _), Ue(i, HN, Pje), {
    start: i,
    tokens: Cq
  };
}
function Ije(e, t, n) {
  let r = n.length, i = 0, o = [], s = [];
  for (; i < r; ) {
    let a = e, c = null, u = null, f = 0, h = null, m = -1;
    for (; i < r && !(c = a.go(n[i].t)); )
      s.push(n[i++]);
    for (; i < r && (u = c || a.go(n[i].t)); )
      c = null, a = u, a.accepts() ? (m = 0, h = a) : m >= 0 && m++, i++, f++;
    if (m < 0)
      i -= f, i < r && (s.push(n[i]), i++);
    else {
      s.length > 0 && (o.push(pE(F5, t, s)), s = []), i -= m, f -= m;
      const g = h.t, b = n.slice(i - f, i);
      o.push(pE(g, t, b));
    }
  }
  return s.length > 0 && o.push(pE(F5, t, s)), o;
}
function pE(e, t, n) {
  const r = n[0].s, i = n[n.length - 1].e, o = t.slice(r, i);
  return new e(o, n);
}
const zje = typeof console < "u" && console && console.warn || (() => {
}), Lje = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", Fn = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function Bje() {
  return qi.groups = {}, Fn.scanner = null, Fn.parser = null, Fn.tokenQueue = [], Fn.pluginQueue = [], Fn.customSchemes = [], Fn.initialized = !1, Fn;
}
function V5(e, t = !1) {
  if (Fn.initialized && zje(`linkifyjs: already initialized - will not register custom scheme "${e}" ${Lje}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(e))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  Fn.customSchemes.push([e, t]);
}
function $je() {
  Fn.scanner = Oje(Fn.customSchemes);
  for (let e = 0; e < Fn.tokenQueue.length; e++)
    Fn.tokenQueue[e][1]({
      scanner: Fn.scanner
    });
  Fn.parser = jje(Fn.scanner.tokens);
  for (let e = 0; e < Fn.pluginQueue.length; e++)
    Fn.pluginQueue[e][1]({
      scanner: Fn.scanner,
      parser: Fn.parser
    });
  return Fn.initialized = !0, Fn;
}
function YN(e) {
  return Fn.initialized || $je(), Ije(Fn.parser.start, e, Eq(Fn.scanner.start, e));
}
YN.scan = Eq;
function Tq(e, t = null, n = null) {
  if (t && typeof t == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${t}; must be a string`);
    n = t, t = null;
  }
  const r = new ZN(n), i = YN(e), o = [];
  for (let s = 0; s < i.length; s++) {
    const a = i[s];
    a.isLink && (!t || a.t === t) && r.check(a) && o.push(a.toFormattedObject(r));
  }
  return o;
}
var XN = "[\0- -\u2029]", Uje = new RegExp(XN), Fje = new RegExp(`${XN}$`), Vje = new RegExp(XN, "g");
function Hje(e) {
  return e.length === 1 ? e[0].isLink : e.length === 3 && e[1].isLink ? ["()", "[]"].includes(e[0].value + e[2].value) : !1;
}
function Wje(e) {
  return new Zn({
    key: new Tr("autolink"),
    appendTransaction: (t, n, r) => {
      const i = t.some((u) => u.docChanged) && !n.doc.eq(r.doc), o = t.some((u) => u.getMeta("preventAutolink"));
      if (!i || o)
        return;
      const { tr: s } = r, a = $W(n.doc, [...t]);
      if (GW(a).forEach(({ newRange: u }) => {
        const f = zOe(r.doc, u, (g) => g.isTextblock);
        let h, m;
        if (f.length > 1)
          h = f[0], m = r.doc.textBetween(
            h.pos,
            h.pos + h.node.nodeSize,
            void 0,
            " "
          );
        else if (f.length) {
          const g = r.doc.textBetween(u.from, u.to, " ", " ");
          if (!Fje.test(g))
            return;
          h = f[0], m = r.doc.textBetween(h.pos, u.to, void 0, " ");
        }
        if (h && m) {
          const g = m.split(Uje).filter(Boolean);
          if (g.length <= 0)
            return !1;
          const b = g[g.length - 1], x = h.pos + m.lastIndexOf(b);
          if (!b)
            return !1;
          const w = YN(b).map((S) => S.toObject(e.defaultProtocol));
          if (!Hje(w))
            return !1;
          w.filter((S) => S.isLink).map((S) => ({
            ...S,
            from: x + S.start + 1,
            to: x + S.end + 1
          })).filter((S) => r.schema.marks.code ? !r.doc.rangeHasMark(S.from, S.to, r.schema.marks.code) : !0).filter((S) => e.validate(S.value)).filter((S) => e.shouldAutoLink(S.value)).forEach((S) => {
            zN(S.from, S.to, r.doc).some((_) => _.mark.type === e.type) || s.addMark(
              S.from,
              S.to,
              e.type.create({
                href: S.href
              })
            );
          });
        }
      }), !!s.steps.length)
        return s;
    }
  });
}
function qje(e) {
  return new Zn({
    key: new Tr("handleClickLink"),
    props: {
      handleClick: (t, n, r) => {
        var i, o;
        if (r.button !== 0 || !t.editable)
          return !1;
        let s = null;
        if (r.target instanceof HTMLAnchorElement)
          s = r.target;
        else {
          const c = r.target;
          if (!c)
            return !1;
          const u = e.editor.view.dom;
          s = c.closest("a"), s && !u.contains(s) && (s = null);
        }
        if (!s)
          return !1;
        let a = !1;
        if (e.enableClickSelection && (a = e.editor.commands.extendMarkRange(e.type.name)), e.openOnClick) {
          const c = qW(t.state, e.type.name), u = (i = s.href) != null ? i : c.href, f = (o = s.target) != null ? o : c.target;
          u && (window.open(u, f), a = !0);
        }
        return a;
      }
    }
  });
}
function Gje(e) {
  return new Zn({
    key: new Tr("handlePasteLink"),
    props: {
      handlePaste: (t, n, r) => {
        const { shouldAutoLink: i } = e, { state: o } = t, { selection: s } = o, { empty: a } = s;
        if (a)
          return !1;
        let c = "";
        r.content.forEach((f) => {
          c += f.textContent;
        });
        const u = Tq(c, { defaultProtocol: e.defaultProtocol }).find(
          (f) => f.isLink && f.value === c
        );
        return !c || !u || i !== void 0 && !i(u.value) ? !1 : e.editor.commands.setMark(e.type, {
          href: u.href
        });
      }
    }
  });
}
function Eu(e, t) {
  const n = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return t && t.forEach((r) => {
    const i = typeof r == "string" ? r : r.scheme;
    i && n.push(i);
  }), !e || e.replace(Vje, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var Kje = md.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((e) => {
      if (typeof e == "string") {
        V5(e);
        return;
      }
      V5(e.scheme, e.optionalSlashes);
    });
  },
  onDestroy() {
    Bje();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      enableClickSelection: !1,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (e, t) => !!Eu(e, t.protocols),
      validate: (e) => !!e,
      shouldAutoLink: (e) => {
        const t = /^[a-z][a-z0-9+.-]*:\/\//i.test(e), n = /^[a-z][a-z0-9+.-]*:/i.test(e);
        if (t || n && !e.includes("@"))
          return !0;
        const i = (e.includes("@") ? e.split("@").pop() : e).split(/[/?#:]/)[0];
        return !(/^\d{1,3}(\.\d{1,3}){3}$/.test(i) || !/\./.test(i));
      }
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(e) {
          return e.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (e) => {
          const t = e.getAttribute("href");
          return !t || !this.options.isAllowedUri(t, {
            defaultValidate: (n) => !!Eu(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return this.options.isAllowedUri(e.href, {
      defaultValidate: (t) => !!Eu(t, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", or(this.options.HTMLAttributes, e), 0] : ["a", or(this.options.HTMLAttributes, { ...e, href: "" }), 0];
  },
  markdownTokenName: "link",
  parseMarkdown: (e, t) => t.applyMark("link", t.parseInline(e.tokens || []), {
    href: e.href,
    title: e.title || null
  }),
  renderMarkdown: (e, t) => {
    var n, r, i, o;
    const s = (r = (n = e.attrs) == null ? void 0 : n.href) != null ? r : "", a = (o = (i = e.attrs) == null ? void 0 : i.title) != null ? o : "", c = t.renderChildren(e);
    return a ? `[${c}](${s} "${a}")` : `[${c}](${s})`;
  },
  addCommands() {
    return {
      setLink: (e) => ({ chain: t }) => {
        const { href: n } = e;
        return this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!Eu(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? t().setMark(this.name, e).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (e) => ({ chain: t }) => {
        const { href: n } = e || {};
        return n && !this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!Eu(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? !1 : t().toggleMark(this.name, e, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run();
      },
      unsetLink: () => ({ chain: e }) => e().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      ad({
        find: (e) => {
          const t = [];
          if (e) {
            const { protocols: n, defaultProtocol: r } = this.options, i = Tq(e).filter(
              (o) => o.isLink && this.options.isAllowedUri(o.value, {
                defaultValidate: (s) => !!Eu(s, n),
                protocols: n,
                defaultProtocol: r
              })
            );
            i.length && i.forEach((o) => {
              this.options.shouldAutoLink(o.value) && t.push({
                text: o.value,
                data: {
                  href: o.href
                },
                index: o.start
              });
            });
          }
          return t;
        },
        type: this.type,
        getAttributes: (e) => {
          var t;
          return {
            href: (t = e.data) == null ? void 0 : t.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const e = [], { protocols: t, defaultProtocol: n } = this.options;
    return this.options.autolink && e.push(
      Wje({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (r) => this.options.isAllowedUri(r, {
          defaultValidate: (i) => !!Eu(i, t),
          protocols: t,
          defaultProtocol: n
        }),
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), e.push(
      qje({
        type: this.type,
        editor: this.editor,
        openOnClick: this.options.openOnClick === "whenNotEditable" ? !0 : this.options.openOnClick,
        enableClickSelection: this.options.enableClickSelection
      })
    ), this.options.linkOnPaste && e.push(
      Gje({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type,
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), e;
  }
}), Zje = Object.defineProperty, Yje = (e, t) => {
  for (var n in t)
    Zje(e, n, { get: t[n], enumerable: !0 });
}, Xje = "listItem", H5 = "textStyle", W5 = /^\s*([-+*])\s$/, Aq = ji.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [{ tag: "ul" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["ul", or(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (e, t) => e.type !== "list" || e.ordered ? [] : {
    type: "bulletList",
    content: e.items ? t.parseChildren(e.items) : []
  },
  renderMarkdown: (e, t) => e.content ? t.renderChildren(e.content, `
`) : "",
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: e, chain: t }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Xje, this.editor.getAttributes(H5)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let e = wh({
      find: W5,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (e = wh({
      find: W5,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(H5),
      editor: this.editor
    })), [e];
  }
}), Mq = ji.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["li", or(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "list_item",
  parseMarkdown: (e, t) => {
    if (e.type !== "list_item")
      return [];
    let n = [];
    if (e.tokens && e.tokens.length > 0)
      if (e.tokens.some((i) => i.type === "paragraph"))
        n = t.parseChildren(e.tokens);
      else {
        const i = e.tokens[0];
        if (i && i.type === "text" && i.tokens && i.tokens.length > 0) {
          if (n = [
            {
              type: "paragraph",
              content: t.parseInline(i.tokens)
            }
          ], e.tokens.length > 1) {
            const s = e.tokens.slice(1), a = t.parseChildren(s);
            n.push(...a);
          }
        } else
          n = t.parseChildren(e.tokens);
      }
    return n.length === 0 && (n = [
      {
        type: "paragraph",
        content: []
      }
    ]), {
      type: "listItem",
      content: n
    };
  },
  renderMarkdown: (e, t, n) => UN(
    e,
    t,
    (r) => {
      var i, o;
      return r.parentType === "bulletList" ? "- " : r.parentType === "orderedList" ? `${(((o = (i = r.meta) == null ? void 0 : i.parentAttrs) == null ? void 0 : o.start) || 1) + r.index}. ` : "- ";
    },
    n
  ),
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), Jje = {};
Yje(Jje, {
  findListItemPos: () => cy,
  getNextListDepth: () => JN,
  handleBackspace: () => LT,
  handleDelete: () => BT,
  hasListBefore: () => Nq,
  hasListItemAfter: () => Qje,
  hasListItemBefore: () => Rq,
  listItemHasSubList: () => Oq,
  nextListIsDeeper: () => Dq,
  nextListIsHigher: () => Pq
});
var cy = (e, t) => {
  const { $from: n } = t.selection, r = _r(e, t.schema);
  let i = null, o = n.depth, s = n.pos, a = null;
  for (; o > 0 && a === null; )
    i = n.node(o), i.type === r ? a = o : (o -= 1, s -= 1);
  return a === null ? null : { $pos: t.doc.resolve(s), depth: a };
}, JN = (e, t) => {
  const n = cy(e, t);
  if (!n)
    return !1;
  const [, r] = GOe(t, e, n.$pos.pos + 4);
  return r;
}, Nq = (e, t, n) => {
  const { $anchor: r } = e.selection, i = Math.max(0, r.pos - 2), o = e.doc.resolve(i).node();
  return !(!o || !n.includes(o.type.name));
}, Rq = (e, t) => {
  var n;
  const { $anchor: r } = t.selection, i = t.doc.resolve(r.pos - 2);
  return !(i.index() === 0 || ((n = i.nodeBefore) == null ? void 0 : n.type.name) !== e);
}, Oq = (e, t, n) => {
  if (!n)
    return !1;
  const r = _r(e, t.schema);
  let i = !1;
  return n.descendants((o) => {
    o.type === r && (i = !0);
  }), i;
}, LT = (e, t, n) => {
  if (e.commands.undoInputRule())
    return !0;
  if (e.state.selection.from !== e.state.selection.to)
    return !1;
  if (!Oc(e.state, t) && Nq(e.state, t, n)) {
    const { $anchor: a } = e.state.selection, c = e.state.doc.resolve(a.before() - 1), u = [];
    c.node().descendants((m, g) => {
      m.type.name === t && u.push({ node: m, pos: g });
    });
    const f = u.at(-1);
    if (!f)
      return !1;
    const h = e.state.doc.resolve(c.start() + f.pos + 1);
    return e.chain().cut({ from: a.start() - 1, to: a.end() + 1 }, h.end()).joinForward().run();
  }
  if (!Oc(e.state, t) || !XOe(e.state))
    return !1;
  const r = cy(t, e.state);
  if (!r)
    return !1;
  const o = e.state.doc.resolve(r.$pos.pos - 2).node(r.depth), s = Oq(t, e.state, o);
  return Rq(t, e.state) && !s ? e.commands.joinItemBackward() : e.chain().liftListItem(t).run();
}, Dq = (e, t) => {
  const n = JN(e, t), r = cy(e, t);
  return !r || !n ? !1 : n > r.depth;
}, Pq = (e, t) => {
  const n = JN(e, t), r = cy(e, t);
  return !r || !n ? !1 : n < r.depth;
}, BT = (e, t) => {
  if (!Oc(e.state, t) || !YOe(e.state, t))
    return !1;
  const { selection: n } = e.state, { $from: r, $to: i } = n;
  return !n.empty && r.sameParent(i) ? !1 : Dq(t, e.state) ? e.chain().focus(e.state.selection.from + 4).lift(t).joinBackward().run() : Pq(t, e.state) ? e.chain().joinForward().joinBackward().run() : e.commands.joinItemForward();
}, Qje = (e, t) => {
  var n;
  const { $anchor: r } = t.selection, i = t.doc.resolve(r.pos - r.parentOffset - 2);
  return !(i.index() === i.parent.childCount - 1 || ((n = i.nodeAfter) == null ? void 0 : n.type.name) !== e);
}, jq = hr.create({
  name: "listKeymap",
  addOptions() {
    return {
      listTypes: [
        {
          itemName: "listItem",
          wrapperNames: ["bulletList", "orderedList"]
        },
        {
          itemName: "taskItem",
          wrapperNames: ["taskList"]
        }
      ]
    };
  },
  addKeyboardShortcuts() {
    return {
      Delete: ({ editor: e }) => {
        let t = !1;
        return this.options.listTypes.forEach(({ itemName: n }) => {
          e.state.schema.nodes[n] !== void 0 && BT(e, n) && (t = !0);
        }), t;
      },
      "Mod-Delete": ({ editor: e }) => {
        let t = !1;
        return this.options.listTypes.forEach(({ itemName: n }) => {
          e.state.schema.nodes[n] !== void 0 && BT(e, n) && (t = !0);
        }), t;
      },
      Backspace: ({ editor: e }) => {
        let t = !1;
        return this.options.listTypes.forEach(({ itemName: n, wrapperNames: r }) => {
          e.state.schema.nodes[n] !== void 0 && LT(e, n, r) && (t = !0);
        }), t;
      },
      "Mod-Backspace": ({ editor: e }) => {
        let t = !1;
        return this.options.listTypes.forEach(({ itemName: n, wrapperNames: r }) => {
          e.state.schema.nodes[n] !== void 0 && LT(e, n, r) && (t = !0);
        }), t;
      }
    };
  }
}), q5 = /^(\s*)(\d+)\.\s+(.*)$/, eIe = /^\s/;
function tIe(e) {
  const t = [];
  let n = 0, r = 0;
  for (; n < e.length; ) {
    const i = e[n], o = i.match(q5);
    if (!o)
      break;
    const [, s, a, c] = o, u = s.length;
    let f = c, h = n + 1;
    const m = [i];
    for (; h < e.length; ) {
      const g = e[h];
      if (g.match(q5))
        break;
      if (g.trim() === "")
        m.push(g), f += `
`, h += 1;
      else if (g.match(eIe))
        m.push(g), f += `
${g.slice(u + 2)}`, h += 1;
      else
        break;
    }
    t.push({
      indent: u,
      number: parseInt(a, 10),
      content: f.trim(),
      raw: m.join(`
`)
    }), r = h, n = h;
  }
  return [t, r];
}
function Iq(e, t, n) {
  var r;
  const i = [];
  let o = 0;
  for (; o < e.length; ) {
    const s = e[o];
    if (s.indent === t) {
      const a = s.content.split(`
`), c = ((r = a[0]) == null ? void 0 : r.trim()) || "", u = [];
      c && u.push({
        type: "paragraph",
        raw: c,
        tokens: n.inlineTokens(c)
      });
      const f = a.slice(1).join(`
`).trim();
      if (f) {
        const g = n.blockTokens(f);
        u.push(...g);
      }
      let h = o + 1;
      const m = [];
      for (; h < e.length && e[h].indent > t; )
        m.push(e[h]), h += 1;
      if (m.length > 0) {
        const g = Math.min(...m.map((x) => x.indent)), b = Iq(m, g, n);
        u.push({
          type: "list",
          ordered: !0,
          start: m[0].number,
          items: b,
          raw: m.map((x) => x.raw).join(`
`)
        });
      }
      i.push({
        type: "list_item",
        raw: s.raw,
        tokens: u
      }), o = h;
    } else
      o += 1;
  }
  return i;
}
function nIe(e, t) {
  return e.map((n) => {
    if (n.type !== "list_item")
      return t.parseChildren([n])[0];
    const r = [];
    return n.tokens && n.tokens.length > 0 && n.tokens.forEach((i) => {
      if (i.type === "paragraph" || i.type === "list" || i.type === "blockquote" || i.type === "code")
        r.push(...t.parseChildren([i]));
      else if (i.type === "text" && i.tokens) {
        const o = t.parseChildren([i]);
        r.push({
          type: "paragraph",
          content: o
        });
      } else {
        const o = t.parseChildren([i]);
        o.length > 0 && r.push(...o);
      }
    }), {
      type: "listItem",
      content: r
    };
  });
}
var rIe = "listItem", G5 = "textStyle", K5 = /^(\d+)\.\s$/, zq = ji.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (e) => e.hasAttribute("start") ? parseInt(e.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: null,
        parseHTML: (e) => e.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    const { start: t, ...n } = e;
    return t === 1 ? ["ol", or(this.options.HTMLAttributes, n), 0] : ["ol", or(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (e, t) => {
    if (e.type !== "list" || !e.ordered)
      return [];
    const n = e.start || 1, r = e.items ? nIe(e.items, t) : [];
    return n !== 1 ? {
      type: "orderedList",
      attrs: { start: n },
      content: r
    } : {
      type: "orderedList",
      content: r
    };
  },
  renderMarkdown: (e, t) => e.content ? t.renderChildren(e.content, `
`) : "",
  markdownTokenizer: {
    name: "orderedList",
    level: "block",
    start: (e) => {
      const t = e.match(/^(\s*)(\d+)\.\s+/), n = t?.index;
      return n !== void 0 ? n : -1;
    },
    tokenize: (e, t, n) => {
      var r;
      const i = e.split(`
`), [o, s] = tIe(i);
      if (o.length === 0)
        return;
      const a = Iq(o, 0, n);
      return a.length === 0 ? void 0 : {
        type: "list",
        ordered: !0,
        start: ((r = o[0]) == null ? void 0 : r.number) || 1,
        items: a,
        raw: i.slice(0, s).join(`
`)
      };
    }
  },
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: e, chain: t }) => this.options.keepAttributes ? t().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(rIe, this.editor.getAttributes(G5)).run() : e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let e = wh({
      find: K5,
      type: this.type,
      getAttributes: (t) => ({ start: +t[1] }),
      joinPredicate: (t, n) => n.childCount + n.attrs.start === +t[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (e = wh({
      find: K5,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (t) => ({ start: +t[1], ...this.editor.getAttributes(G5) }),
      joinPredicate: (t, n) => n.childCount + n.attrs.start === +t[1],
      editor: this.editor
    })), [e];
  }
}), iIe = /^\s*(\[([( |x])?\])\s$/, oIe = ji.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList",
      a11y: void 0
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (e) => {
          const t = e.getAttribute("data-checked");
          return t === "" || t === "true";
        },
        renderHTML: (e) => ({
          "data-checked": e.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "li",
      or(this.options.HTMLAttributes, t, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: e.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  parseMarkdown: (e, t) => {
    const n = [];
    if (e.tokens && e.tokens.length > 0 ? n.push(t.createNode("paragraph", {}, t.parseInline(e.tokens))) : e.text ? n.push(t.createNode("paragraph", {}, [t.createNode("text", { text: e.text })])) : n.push(t.createNode("paragraph", {}, [])), e.nestedTokens && e.nestedTokens.length > 0) {
      const r = t.parseChildren(e.nestedTokens);
      n.push(...r);
    }
    return t.createNode("taskItem", { checked: e.checked || !1 }, n);
  },
  renderMarkdown: (e, t) => {
    var n;
    const i = `- [${(n = e.attrs) != null && n.checked ? "x" : " "}] `;
    return UN(e, t, i);
  },
  addKeyboardShortcuts() {
    const e = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...e,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : e;
  },
  addNodeView() {
    return ({ node: e, HTMLAttributes: t, getPos: n, editor: r }) => {
      const i = document.createElement("li"), o = document.createElement("label"), s = document.createElement("span"), a = document.createElement("input"), c = document.createElement("div"), u = (h) => {
        var m, g;
        a.ariaLabel = ((g = (m = this.options.a11y) == null ? void 0 : m.checkboxLabel) == null ? void 0 : g.call(m, h, a.checked)) || `Task item checkbox for ${h.textContent || "empty task item"}`;
      };
      u(e), o.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (h) => h.preventDefault()), a.addEventListener("change", (h) => {
        if (!r.isEditable && !this.options.onReadOnlyChecked) {
          a.checked = !a.checked;
          return;
        }
        const { checked: m } = h.target;
        r.isEditable && typeof n == "function" && r.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: g }) => {
          const b = n();
          if (typeof b != "number")
            return !1;
          const x = g.doc.nodeAt(b);
          return g.setNodeMarkup(b, void 0, {
            ...x?.attrs,
            checked: m
          }), !0;
        }).run(), !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(e, m) || (a.checked = !a.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([h, m]) => {
        i.setAttribute(h, m);
      }), i.dataset.checked = e.attrs.checked, a.checked = e.attrs.checked, o.append(a, s), i.append(o, c), Object.entries(t).forEach(([h, m]) => {
        i.setAttribute(h, m);
      });
      let f = new Set(Object.keys(t));
      return {
        dom: i,
        contentDOM: c,
        update: (h) => {
          if (h.type !== this.type)
            return !1;
          i.dataset.checked = h.attrs.checked, a.checked = h.attrs.checked, u(h);
          const m = r.extensionManager.attributes, g = bh(h, m), b = new Set(Object.keys(g)), x = this.options.HTMLAttributes;
          return f.forEach((w) => {
            b.has(w) || (w in x ? i.setAttribute(w, x[w]) : i.removeAttribute(w));
          }), Object.entries(g).forEach(([w, S]) => {
            S == null ? w in x ? i.setAttribute(w, x[w]) : i.removeAttribute(w) : i.setAttribute(w, S);
          }), f = b, !0;
        }
      };
    };
  },
  addInputRules() {
    return [
      wh({
        find: iIe,
        type: this.type,
        getAttributes: (e) => ({
          checked: e[e.length - 1] === "x"
        })
      })
    ];
  }
}), sIe = ji.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["ul", or(this.options.HTMLAttributes, e, { "data-type": this.name }), 0];
  },
  parseMarkdown: (e, t) => t.createNode("taskList", {}, t.parseChildren(e.items || [])),
  renderMarkdown: (e, t) => e.content ? t.renderChildren(e.content, `
`) : "",
  markdownTokenizer: {
    name: "taskList",
    level: "block",
    start(e) {
      var t;
      const n = (t = e.match(/^\s*[-+*]\s+\[([ xX])\]\s+/)) == null ? void 0 : t.index;
      return n !== void 0 ? n : -1;
    },
    tokenize(e, t, n) {
      const r = (o) => {
        const s = AT(
          o,
          {
            itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
            extractItemData: (a) => ({
              indentLevel: a[1].length,
              mainContent: a[4],
              checked: a[3].toLowerCase() === "x"
            }),
            createToken: (a, c) => ({
              type: "taskItem",
              raw: "",
              mainContent: a.mainContent,
              indentLevel: a.indentLevel,
              checked: a.checked,
              text: a.mainContent,
              tokens: n.inlineTokens(a.mainContent),
              nestedTokens: c
            }),
            // Allow recursive nesting
            customNestedParser: r
          },
          n
        );
        return s ? [
          {
            type: "taskList",
            raw: s.raw,
            items: s.items
          }
        ] : n.blockTokens(o);
      }, i = AT(
        e,
        {
          itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
          extractItemData: (o) => ({
            indentLevel: o[1].length,
            mainContent: o[4],
            checked: o[3].toLowerCase() === "x"
          }),
          createToken: (o, s) => ({
            type: "taskItem",
            raw: "",
            mainContent: o.mainContent,
            indentLevel: o.indentLevel,
            checked: o.checked,
            text: o.mainContent,
            tokens: n.inlineTokens(o.mainContent),
            nestedTokens: s
          }),
          // Use the recursive parser for nested content
          customNestedParser: r
        },
        n
      );
      if (i)
        return {
          type: "taskList",
          raw: i.raw,
          items: i.items
        };
    }
  },
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: e }) => e.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
hr.create({
  name: "listKit",
  addExtensions() {
    const e = [];
    return this.options.bulletList !== !1 && e.push(Aq.configure(this.options.bulletList)), this.options.listItem !== !1 && e.push(Mq.configure(this.options.listItem)), this.options.listKeymap !== !1 && e.push(jq.configure(this.options.listKeymap)), this.options.orderedList !== !1 && e.push(zq.configure(this.options.orderedList)), this.options.taskItem !== !1 && e.push(oIe.configure(this.options.taskItem)), this.options.taskList !== !1 && e.push(sIe.configure(this.options.taskList)), e;
  }
});
var Z5 = "&nbsp;", aIe = "", lIe = ji.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["p", or(this.options.HTMLAttributes, e), 0];
  },
  parseMarkdown: (e, t) => {
    const n = e.tokens || [];
    if (n.length === 1 && n[0].type === "image")
      return t.parseChildren([n[0]]);
    const r = t.parseInline(n);
    return r.length === 1 && r[0].type === "text" && (r[0].text === Z5 || r[0].text === aIe) ? t.createNode("paragraph", void 0, []) : t.createNode("paragraph", void 0, r);
  },
  renderMarkdown: (e, t) => {
    if (!e)
      return "";
    const n = Array.isArray(e.content) ? e.content : [];
    return n.length === 0 ? Z5 : t.renderChildren(n);
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: e }) => e.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), cIe = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, uIe = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, dIe = md.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (e) => e.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["s", or(this.options.HTMLAttributes, e), 0];
  },
  markdownTokenName: "del",
  parseMarkdown: (e, t) => t.applyMark("strike", t.parseInline(e.tokens || [])),
  renderMarkdown: (e, t) => `~~${t.renderChildren(e)}~~`,
  addCommands() {
    return {
      setStrike: () => ({ commands: e }) => e.setMark(this.name),
      toggleStrike: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetStrike: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      xh({
        find: cIe,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ad({
        find: uIe,
        type: this.type
      })
    ];
  }
}), fIe = ji.create({
  name: "text",
  group: "inline",
  parseMarkdown: (e) => ({
    type: "text",
    text: e.text || ""
  }),
  renderMarkdown: (e) => e.text || ""
}), hIe = md.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (e) => e.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: e }) {
    return ["u", or(this.options.HTMLAttributes, e), 0];
  },
  parseMarkdown(e, t) {
    return t.applyMark(this.name || "underline", t.parseInline(e.tokens || []));
  },
  renderMarkdown(e, t) {
    return `++${t.renderChildren(e)}++`;
  },
  markdownTokenizer: {
    name: "underline",
    level: "inline",
    start(e) {
      return e.indexOf("++");
    },
    tokenize(e, t, n) {
      const i = /^(\+\+)([\s\S]+?)(\+\+)/.exec(e);
      if (!i)
        return;
      const o = i[2].trim();
      return {
        type: "underline",
        raw: i[0],
        text: o,
        tokens: n.inlineTokens(o)
      };
    }
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: e }) => e.setMark(this.name),
      toggleUnderline: () => ({ commands: e }) => e.toggleMark(this.name),
      unsetUnderline: () => ({ commands: e }) => e.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
function pIe(e = {}) {
  return new Zn({
    view(t) {
      return new mIe(t, e);
    }
  });
}
class mIe {
  constructor(t, n) {
    var r;
    this.editorView = t, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let o = (s) => {
        this[i](s);
      };
      return t.dom.addEventListener(i, o), { name: i, handler: o };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: t, handler: n }) => this.editorView.dom.removeEventListener(t, n));
  }
  update(t, n) {
    this.cursorPos != null && n.doc != t.state.doc && (this.cursorPos > t.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(t) {
    t != this.cursorPos && (this.cursorPos = t, t == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let t = this.editorView.state.doc.resolve(this.cursorPos), n = !t.parent.inlineContent, r, i = this.editorView.dom, o = i.getBoundingClientRect(), s = o.width / i.offsetWidth, a = o.height / i.offsetHeight;
    if (n) {
      let h = t.nodeBefore, m = t.nodeAfter;
      if (h || m) {
        let g = this.editorView.nodeDOM(this.cursorPos - (h ? h.nodeSize : 0));
        if (g) {
          let b = g.getBoundingClientRect(), x = h ? b.bottom : b.top;
          h && m && (x = (x + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let w = this.width / 2 * a;
          r = { left: b.left, right: b.right, top: x - w, bottom: x + w };
        }
      }
    }
    if (!r) {
      let h = this.editorView.coordsAtPos(this.cursorPos), m = this.width / 2 * s;
      r = { left: h.left - m, right: h.left + m, top: h.top, bottom: h.bottom };
    }
    let c = this.editorView.dom.offsetParent;
    this.element || (this.element = c.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let u, f;
    if (!c || c == document.body && getComputedStyle(c).position == "static")
      u = -pageXOffset, f = -pageYOffset;
    else {
      let h = c.getBoundingClientRect(), m = h.width / c.offsetWidth, g = h.height / c.offsetHeight;
      u = h.left - c.scrollLeft * m, f = h.top - c.scrollTop * g;
    }
    this.element.style.left = (r.left - u) / s + "px", this.element.style.top = (r.top - f) / a + "px", this.element.style.width = (r.right - r.left) / s + "px", this.element.style.height = (r.bottom - r.top) / a + "px";
  }
  scheduleRemoval(t) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), t);
  }
  dragover(t) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: t.clientX, top: t.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), i = r && r.type.spec.disableDropCursor, o = typeof i == "function" ? i(this.editorView, n, t) : i;
    if (n && !o) {
      let s = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = RH(this.editorView.state.doc, s, this.editorView.dragging.slice);
        a != null && (s = a);
      }
      this.setCursor(s), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(t) {
    this.editorView.dom.contains(t.relatedTarget) || this.setCursor(null);
  }
}
class rr extends zt {
  /**
  Create a gap cursor.
  */
  constructor(t) {
    super(t, t);
  }
  map(t, n) {
    let r = t.resolve(n.map(this.head));
    return rr.valid(r) ? new rr(r) : zt.near(r);
  }
  content() {
    return Qe.empty;
  }
  eq(t) {
    return t instanceof rr && t.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(t, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new rr(t.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new QN(this.anchor);
  }
  /**
  @internal
  */
  static valid(t) {
    let n = t.parent;
    if (n.isTextblock || !gIe(t) || !yIe(t))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = n.contentMatchAt(t.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(t, n, r = !1) {
    e: for (; ; ) {
      if (!r && rr.valid(t))
        return t;
      let i = t.pos, o = null;
      for (let s = t.depth; ; s--) {
        let a = t.node(s);
        if (n > 0 ? t.indexAfter(s) < a.childCount : t.index(s) > 0) {
          o = a.child(n > 0 ? t.indexAfter(s) : t.index(s) - 1);
          break;
        } else if (s == 0)
          return null;
        i += n;
        let c = t.doc.resolve(i);
        if (rr.valid(c))
          return c;
      }
      for (; ; ) {
        let s = n > 0 ? o.firstChild : o.lastChild;
        if (!s) {
          if (o.isAtom && !o.isText && !ht.isSelectable(o)) {
            t = t.doc.resolve(i + o.nodeSize * n), r = !1;
            continue e;
          }
          break;
        }
        o = s, i += n;
        let a = t.doc.resolve(i);
        if (rr.valid(a))
          return a;
      }
      return null;
    }
  }
}
rr.prototype.visible = !1;
rr.findFrom = rr.findGapCursorFrom;
zt.jsonID("gapcursor", rr);
class QN {
  constructor(t) {
    this.pos = t;
  }
  map(t) {
    return new QN(t.map(this.pos));
  }
  resolve(t) {
    let n = t.resolve(this.pos);
    return rr.valid(n) ? new rr(n) : zt.near(n);
  }
}
function Lq(e) {
  return e.isAtom || e.spec.isolating || e.spec.createGapCursor;
}
function gIe(e) {
  for (let t = e.depth; t >= 0; t--) {
    let n = e.index(t), r = e.node(t);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || Lq(i.type))
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function yIe(e) {
  for (let t = e.depth; t >= 0; t--) {
    let n = e.indexAfter(t), r = e.node(t);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || Lq(i.type))
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function vIe() {
  return new Zn({
    props: {
      decorations: SIe,
      createSelectionBetween(e, t, n) {
        return t.pos == n.pos && rr.valid(n) ? new rr(n) : null;
      },
      handleClick: xIe,
      handleKeyDown: bIe,
      handleDOMEvents: { beforeinput: wIe }
    }
  });
}
const bIe = OW({
  ArrowLeft: c0("horiz", -1),
  ArrowRight: c0("horiz", 1),
  ArrowUp: c0("vert", -1),
  ArrowDown: c0("vert", 1)
});
function c0(e, t) {
  const n = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
  return function(r, i, o) {
    let s = r.selection, a = t > 0 ? s.$to : s.$from, c = s.empty;
    if (s instanceof kt) {
      if (!o.endOfTextblock(n) || a.depth == 0)
        return !1;
      c = !1, a = r.doc.resolve(t > 0 ? a.after() : a.before());
    }
    let u = rr.findGapCursorFrom(a, t, c);
    return u ? (i && i(r.tr.setSelection(new rr(u))), !0) : !1;
  };
}
function xIe(e, t, n) {
  if (!e || !e.editable)
    return !1;
  let r = e.state.doc.resolve(t);
  if (!rr.valid(r))
    return !1;
  let i = e.posAtCoords({ left: n.clientX, top: n.clientY });
  return i && i.inside > -1 && ht.isSelectable(e.state.doc.nodeAt(i.inside)) ? !1 : (e.dispatch(e.state.tr.setSelection(new rr(r))), !0);
}
function wIe(e, t) {
  if (t.inputType != "insertCompositionText" || !(e.state.selection instanceof rr))
    return !1;
  let { $from: n } = e.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(e.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = $e.empty;
  for (let s = r.length - 1; s >= 0; s--)
    i = $e.from(r[s].createAndFill(null, i));
  let o = e.state.tr.replace(n.pos, n.pos, new Qe(i, 0, 0));
  return o.setSelection(kt.near(o.doc.resolve(n.pos + 1))), e.dispatch(o), !1;
}
function SIe(e) {
  if (!(e.selection instanceof rr))
    return null;
  let t = document.createElement("div");
  return t.className = "ProseMirror-gapcursor", qn.create(e.doc, [gi.widget(e.selection.head, t, { key: "gapcursor" })]);
}
var Bx = 200, Wr = function() {
};
Wr.prototype.append = function(t) {
  return t.length ? (t = Wr.from(t), !this.length && t || t.length < Bx && this.leafAppend(t) || this.length < Bx && t.leafPrepend(this) || this.appendInner(t)) : this;
};
Wr.prototype.prepend = function(t) {
  return t.length ? Wr.from(t).append(this) : this;
};
Wr.prototype.appendInner = function(t) {
  return new kIe(this, t);
};
Wr.prototype.slice = function(t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = this.length), t >= n ? Wr.empty : this.sliceInner(Math.max(0, t), Math.min(this.length, n));
};
Wr.prototype.get = function(t) {
  if (!(t < 0 || t >= this.length))
    return this.getInner(t);
};
Wr.prototype.forEach = function(t, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(t, n, r, 0) : this.forEachInvertedInner(t, n, r, 0);
};
Wr.prototype.map = function(t, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(o, s) {
    return i.push(t(o, s));
  }, n, r), i;
};
Wr.from = function(t) {
  return t instanceof Wr ? t : t && t.length ? new Bq(t) : Wr.empty;
};
var Bq = /* @__PURE__ */ (function(e) {
  function t(r) {
    e.call(this), this.values = r;
  }
  e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return t.prototype.flatten = function() {
    return this.values;
  }, t.prototype.sliceInner = function(i, o) {
    return i == 0 && o == this.length ? this : new t(this.values.slice(i, o));
  }, t.prototype.getInner = function(i) {
    return this.values[i];
  }, t.prototype.forEachInner = function(i, o, s, a) {
    for (var c = o; c < s; c++)
      if (i(this.values[c], a + c) === !1)
        return !1;
  }, t.prototype.forEachInvertedInner = function(i, o, s, a) {
    for (var c = o - 1; c >= s; c--)
      if (i(this.values[c], a + c) === !1)
        return !1;
  }, t.prototype.leafAppend = function(i) {
    if (this.length + i.length <= Bx)
      return new t(this.values.concat(i.flatten()));
  }, t.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= Bx)
      return new t(i.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(t.prototype, n), t;
})(Wr);
Wr.empty = new Bq([]);
var kIe = /* @__PURE__ */ (function(e) {
  function t(n, r) {
    e.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, t.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, t.prototype.forEachInner = function(r, i, o, s) {
    var a = this.left.length;
    if (i < a && this.left.forEachInner(r, i, Math.min(o, a), s) === !1 || o > a && this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, o) - a, s + a) === !1)
      return !1;
  }, t.prototype.forEachInvertedInner = function(r, i, o, s) {
    var a = this.left.length;
    if (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(o, a) - a, s + a) === !1 || o < a && this.left.forEachInvertedInner(r, Math.min(i, a), o, s) === !1)
      return !1;
  }, t.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var o = this.left.length;
    return i <= o ? this.left.slice(r, i) : r >= o ? this.right.slice(r - o, i - o) : this.left.slice(r, o).append(this.right.slice(0, i - o));
  }, t.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new t(this.left, i);
  }, t.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new t(i, this.right);
  }, t.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new t(this.left, new t(this.right, r)) : new t(this, r);
  }, t;
})(Wr);
const CIe = 500;
class as {
  constructor(t, n) {
    this.items = t, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(t, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, o;
    n && (i = this.remapping(r, this.items.length), o = i.maps.length);
    let s = t.tr, a, c, u = [], f = [];
    return this.items.forEach((h, m) => {
      if (!h.step) {
        i || (i = this.remapping(r, m + 1), o = i.maps.length), o--, f.push(h);
        return;
      }
      if (i) {
        f.push(new Bs(h.map));
        let g = h.step.map(i.slice(o)), b;
        g && s.maybeStep(g).doc && (b = s.mapping.maps[s.mapping.maps.length - 1], u.push(new Bs(b, void 0, void 0, u.length + f.length))), o--, b && i.appendMap(b, o);
      } else
        s.maybeStep(h.step);
      if (h.selection)
        return a = i ? h.selection.map(i.slice(o)) : h.selection, c = new as(this.items.slice(0, r).append(f.reverse().concat(u)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: c, transform: s, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(t, n, r, i) {
    let o = [], s = this.eventCount, a = this.items, c = !i && a.length ? a.get(a.length - 1) : null;
    for (let f = 0; f < t.steps.length; f++) {
      let h = t.steps[f].invert(t.docs[f]), m = new Bs(t.mapping.maps[f], h, n), g;
      (g = c && c.merge(m)) && (m = g, f ? o.pop() : a = a.slice(0, a.length - 1)), o.push(m), n && (s++, n = void 0), i || (c = m);
    }
    let u = s - r.depth;
    return u > _Ie && (a = EIe(a, u), s -= u), new as(a.append(o), s);
  }
  remapping(t, n) {
    let r = new vg();
    return this.items.forEach((i, o) => {
      let s = i.mirrorOffset != null && o - i.mirrorOffset >= t ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, s);
    }, t, n), r;
  }
  addMaps(t) {
    return this.eventCount == 0 ? this : new as(this.items.append(t.map((n) => new Bs(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(t, n) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - n), o = t.mapping, s = t.steps.length, a = this.eventCount;
    this.items.forEach((m) => {
      m.selection && a--;
    }, i);
    let c = n;
    this.items.forEach((m) => {
      let g = o.getMirror(--c);
      if (g == null)
        return;
      s = Math.min(s, g);
      let b = o.maps[g];
      if (m.step) {
        let x = t.steps[g].invert(t.docs[g]), w = m.selection && m.selection.map(o.slice(c + 1, g));
        w && a++, r.push(new Bs(b, x, w));
      } else
        r.push(new Bs(b));
    }, i);
    let u = [];
    for (let m = n; m < s; m++)
      u.push(new Bs(o.maps[m]));
    let f = this.items.slice(0, i).append(u).append(r), h = new as(f, a);
    return h.emptyItemCount() > CIe && (h = h.compress(this.items.length - r.length)), h;
  }
  emptyItemCount() {
    let t = 0;
    return this.items.forEach((n) => {
      n.step || t++;
    }), t;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(t = this.items.length) {
    let n = this.remapping(0, t), r = n.maps.length, i = [], o = 0;
    return this.items.forEach((s, a) => {
      if (a >= t)
        i.push(s), s.selection && o++;
      else if (s.step) {
        let c = s.step.map(n.slice(r)), u = c && c.getMap();
        if (r--, u && n.appendMap(u, r), c) {
          let f = s.selection && s.selection.map(n.slice(r));
          f && o++;
          let h = new Bs(u.invert(), c, f), m, g = i.length - 1;
          (m = i.length && i[g].merge(h)) ? i[g] = m : i.push(h);
        }
      } else s.map && r--;
    }, this.items.length, 0), new as(Wr.from(i.reverse()), o);
  }
}
as.empty = new as(Wr.empty, 0);
function EIe(e, t) {
  let n;
  return e.forEach((r, i) => {
    if (r.selection && t-- == 0)
      return n = i, !1;
  }), e.slice(n);
}
class Bs {
  constructor(t, n, r, i) {
    this.map = t, this.step = n, this.selection = r, this.mirrorOffset = i;
  }
  merge(t) {
    if (this.step && t.step && !t.selection) {
      let n = t.step.merge(this.step);
      if (n)
        return new Bs(n.getMap().invert(), n, this.selection);
    }
  }
}
class rc {
  constructor(t, n, r, i, o) {
    this.done = t, this.undone = n, this.prevRanges = r, this.prevTime = i, this.prevComposition = o;
  }
}
const _Ie = 20;
function TIe(e, t, n, r) {
  let i = n.getMeta(qu), o;
  if (i)
    return i.historyState;
  n.getMeta(NIe) && (e = new rc(e.done, e.undone, null, 0, -1));
  let s = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return e;
  if (s && s.getMeta(qu))
    return s.getMeta(qu).redo ? new rc(e.done.addTransform(n, void 0, r, G0(t)), e.undone, Y5(n.mapping.maps), e.prevTime, e.prevComposition) : new rc(e.done, e.undone.addTransform(n, void 0, r, G0(t)), null, e.prevTime, e.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(s && s.getMeta("addToHistory") === !1)) {
    let a = n.getMeta("composition"), c = e.prevTime == 0 || !s && e.prevComposition != a && (e.prevTime < (n.time || 0) - r.newGroupDelay || !AIe(n, e.prevRanges)), u = s ? mE(e.prevRanges, n.mapping) : Y5(n.mapping.maps);
    return new rc(e.done.addTransform(n, c ? t.selection.getBookmark() : void 0, r, G0(t)), as.empty, u, n.time, a ?? e.prevComposition);
  } else return (o = n.getMeta("rebased")) ? new rc(e.done.rebased(n, o), e.undone.rebased(n, o), mE(e.prevRanges, n.mapping), e.prevTime, e.prevComposition) : new rc(e.done.addMaps(n.mapping.maps), e.undone.addMaps(n.mapping.maps), mE(e.prevRanges, n.mapping), e.prevTime, e.prevComposition);
}
function AIe(e, t) {
  if (!t)
    return !1;
  if (!e.docChanged)
    return !0;
  let n = !1;
  return e.mapping.maps[0].forEach((r, i) => {
    for (let o = 0; o < t.length; o += 2)
      r <= t[o + 1] && i >= t[o] && (n = !0);
  }), n;
}
function Y5(e) {
  let t = [];
  for (let n = e.length - 1; n >= 0 && t.length == 0; n--)
    e[n].forEach((r, i, o, s) => t.push(o, s));
  return t;
}
function mE(e, t) {
  if (!e)
    return null;
  let n = [];
  for (let r = 0; r < e.length; r += 2) {
    let i = t.map(e[r], 1), o = t.map(e[r + 1], -1);
    i <= o && n.push(i, o);
  }
  return n;
}
function MIe(e, t, n) {
  let r = G0(t), i = qu.get(t).spec.config, o = (n ? e.undone : e.done).popEvent(t, r);
  if (!o)
    return null;
  let s = o.selection.resolve(o.transform.doc), a = (n ? e.done : e.undone).addTransform(o.transform, t.selection.getBookmark(), i, r), c = new rc(n ? a : o.remaining, n ? o.remaining : a, null, 0, -1);
  return o.transform.setSelection(s).setMeta(qu, { redo: n, historyState: c });
}
let gE = !1, X5 = null;
function G0(e) {
  let t = e.plugins;
  if (X5 != t) {
    gE = !1, X5 = t;
    for (let n = 0; n < t.length; n++)
      if (t[n].spec.historyPreserveItems) {
        gE = !0;
        break;
      }
  }
  return gE;
}
const qu = new Tr("history"), NIe = new Tr("closeHistory");
function RIe(e = {}) {
  return e = {
    depth: e.depth || 100,
    newGroupDelay: e.newGroupDelay || 500
  }, new Zn({
    key: qu,
    state: {
      init() {
        return new rc(as.empty, as.empty, null, 0, -1);
      },
      apply(t, n, r) {
        return TIe(n, r, t, e);
      }
    },
    config: e,
    props: {
      handleDOMEvents: {
        beforeinput(t, n) {
          let r = n.inputType, i = r == "historyUndo" ? Uq : r == "historyRedo" ? Fq : null;
          return !i || !t.editable ? !1 : (n.preventDefault(), i(t.state, t.dispatch));
        }
      }
    }
  });
}
function $q(e, t) {
  return (n, r) => {
    let i = qu.getState(n);
    if (!i || (e ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let o = MIe(i, n, e);
      o && r(t ? o.scrollIntoView() : o);
    }
    return !0;
  };
}
const Uq = $q(!1, !0), Fq = $q(!0, !0);
hr.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (e) => e.length,
      wordCounter: (e) => e.split(" ").filter((t) => t !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (e) => {
      const t = e?.node || this.editor.state.doc;
      if ((e?.mode || this.options.mode) === "textSize") {
        const r = t.textBetween(0, t.content.size, void 0, " ");
        return this.options.textCounter(r);
      }
      return t.nodeSize;
    }, this.storage.words = (e) => {
      const t = e?.node || this.editor.state.doc, n = t.textBetween(0, t.content.size, " ", " ");
      return this.options.wordCounter(n);
    };
  },
  addProseMirrorPlugins() {
    let e = !1;
    return [
      new Zn({
        key: new Tr("characterCount"),
        appendTransaction: (t, n, r) => {
          if (e)
            return;
          const i = this.options.limit;
          if (i == null || i === 0) {
            e = !0;
            return;
          }
          const o = this.storage.characters({ node: r.doc });
          if (o > i) {
            const s = o - i, a = 0, c = s;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${i} characters. Content was automatically trimmed.`
            );
            const u = r.tr.deleteRange(a, c);
            return e = !0, u;
          }
          e = !0;
        },
        filterTransaction: (t, n) => {
          const r = this.options.limit;
          if (!t.docChanged || r === 0 || r === null || r === void 0)
            return !0;
          const i = this.storage.characters({ node: n.doc }), o = this.storage.characters({ node: t.doc });
          if (o <= r || i > r && o > r && o <= i)
            return !0;
          if (i > r && o > r && o > i || !t.getMeta("paste"))
            return !1;
          const a = t.selection.$head.pos, c = o - r, u = a - c, f = a;
          return t.deleteRange(u, f), !(this.storage.characters({ node: t.doc }) > r);
        }
      })
    ];
  }
});
var OIe = hr.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [pIe(this.options)];
  }
});
hr.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Zn({
        key: new Tr("focus"),
        props: {
          decorations: ({ doc: e, selection: t }) => {
            const { isEditable: n, isFocused: r } = this.editor, { anchor: i } = t, o = [];
            if (!n || !r)
              return qn.create(e, []);
            let s = 0;
            this.options.mode === "deepest" && e.descendants((c, u) => {
              if (c.isText)
                return;
              if (!(i >= u && i <= u + c.nodeSize - 1))
                return !1;
              s += 1;
            });
            let a = 0;
            return e.descendants((c, u) => {
              if (c.isText || !(i >= u && i <= u + c.nodeSize - 1))
                return !1;
              if (a += 1, this.options.mode === "deepest" && s - a > 0 || this.options.mode === "shallowest" && a > 1)
                return this.options.mode === "deepest";
              o.push(
                gi.node(u, u + c.nodeSize, {
                  class: this.options.className
                })
              );
            }), qn.create(e, o);
          }
        }
      })
    ];
  }
});
var DIe = hr.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [vIe()];
  },
  extendNodeSchema(e) {
    var t;
    const n = {
      name: e.name,
      options: e.options,
      storage: e.storage
    };
    return {
      allowGapCursor: (t = mn(ft(e, "allowGapCursor", n))) != null ? t : null
    };
  }
}), J5 = "placeholder";
function PIe(e) {
  return e.replace(/\s+/g, "-").replace(/[^a-zA-Z0-9-]/g, "").replace(/^[0-9-]+/, "").replace(/^-+/, "").toLowerCase();
}
var jIe = hr.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      dataAttribute: J5,
      placeholder: "Write something ",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    const e = this.options.dataAttribute ? `data-${PIe(this.options.dataAttribute)}` : `data-${J5}`;
    return [
      new Zn({
        key: new Tr("placeholder"),
        props: {
          decorations: ({ doc: t, selection: n }) => {
            const r = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: i } = n, o = [];
            if (!r)
              return null;
            const s = this.editor.isEmpty;
            return t.descendants((a, c) => {
              const u = i >= c && i <= c + a.nodeSize, f = !a.isLeaf && r1(a);
              if ((u || !this.options.showOnlyCurrent) && f) {
                const h = [this.options.emptyNodeClass];
                s && h.push(this.options.emptyEditorClass);
                const m = gi.node(c, c + a.nodeSize, {
                  class: h.join(" "),
                  [e]: typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: a,
                    pos: c,
                    hasAnchor: u
                  }) : this.options.placeholder
                });
                o.push(m);
              }
              return this.options.includeChildren;
            }), qn.create(t, o);
          }
        }
      })
    ];
  }
});
hr.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor: e, options: t } = this;
    return [
      new Zn({
        key: new Tr("selection"),
        props: {
          decorations(n) {
            return n.selection.empty || e.isFocused || !e.isEditable || KW(n.selection) || e.view.dragging ? null : qn.create(n.doc, [
              gi.inline(n.selection.from, n.selection.to, {
                class: t.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function Q5({ types: e, node: t }) {
  return t && Array.isArray(e) && e.includes(t.type) || t?.type === e;
}
var IIe = hr.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: void 0,
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    var e;
    const t = new Tr(this.name), n = this.options.node || ((e = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : e.name) || "paragraph", r = Object.entries(this.editor.schema.nodes).map(([, i]) => i).filter((i) => (this.options.notAfter || []).concat(n).includes(i.name));
    return [
      new Zn({
        key: t,
        appendTransaction: (i, o, s) => {
          const { doc: a, tr: c, schema: u } = s, f = t.getState(s), h = a.content.size, m = u.nodes[n];
          if (f)
            return c.insert(h, m.create());
        },
        state: {
          init: (i, o) => {
            const s = o.tr.doc.lastChild;
            return !Q5({ node: s, types: r });
          },
          apply: (i, o) => {
            if (!i.docChanged || i.getMeta("__uniqueIDTransaction"))
              return o;
            const s = i.doc.lastChild;
            return !Q5({ node: s, types: r });
          }
        }
      })
    ];
  }
}), zIe = hr.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: e, dispatch: t }) => Uq(e, t),
      redo: () => ({ state: e, dispatch: t }) => Fq(e, t)
    };
  },
  addProseMirrorPlugins() {
    return [RIe(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-": () => this.editor.commands.undo(),
      "Shift-Mod-": () => this.editor.commands.redo()
    };
  }
}), LIe = hr.create({
  name: "starterKit",
  addExtensions() {
    var e, t, n, r;
    const i = [];
    return this.options.bold !== !1 && i.push(lje.configure(this.options.bold)), this.options.blockquote !== !1 && i.push(rje.configure(this.options.blockquote)), this.options.bulletList !== !1 && i.push(Aq.configure(this.options.bulletList)), this.options.code !== !1 && i.push(dje.configure(this.options.code)), this.options.codeBlock !== !1 && i.push(pje.configure(this.options.codeBlock)), this.options.document !== !1 && i.push(mje.configure(this.options.document)), this.options.dropcursor !== !1 && i.push(OIe.configure(this.options.dropcursor)), this.options.gapcursor !== !1 && i.push(DIe.configure(this.options.gapcursor)), this.options.hardBreak !== !1 && i.push(gje.configure(this.options.hardBreak)), this.options.heading !== !1 && i.push(yje.configure(this.options.heading)), this.options.undoRedo !== !1 && i.push(zIe.configure(this.options.undoRedo)), this.options.horizontalRule !== !1 && i.push(vje.configure(this.options.horizontalRule)), this.options.italic !== !1 && i.push(kje.configure(this.options.italic)), this.options.listItem !== !1 && i.push(Mq.configure(this.options.listItem)), this.options.listKeymap !== !1 && i.push(jq.configure((e = this.options) == null ? void 0 : e.listKeymap)), this.options.link !== !1 && i.push(Kje.configure((t = this.options) == null ? void 0 : t.link)), this.options.orderedList !== !1 && i.push(zq.configure(this.options.orderedList)), this.options.paragraph !== !1 && i.push(lIe.configure(this.options.paragraph)), this.options.strike !== !1 && i.push(dIe.configure(this.options.strike)), this.options.text !== !1 && i.push(fIe.configure(this.options.text)), this.options.underline !== !1 && i.push(hIe.configure((n = this.options) == null ? void 0 : n.underline)), this.options.trailingNode !== !1 && i.push(IIe.configure((r = this.options) == null ? void 0 : r.trailingNode)), i;
  }
}), BIe = LIe, $Ie = jIe;
function UIe(e) {
  var t;
  const { char: n, allowSpaces: r, allowToIncludeChar: i, allowedPrefixes: o, startOfLine: s, $position: a } = e, c = r && !i, u = LDe(n), f = new RegExp(`\\s${u}$`), h = s ? "^" : "", m = i ? "" : u, g = c ? new RegExp(`${h}${u}.*?(?=\\s${m}|$)`, "gm") : new RegExp(`${h}(?:^)?${u}[^\\s${m}]*`, "gm"), b = ((t = a.nodeBefore) == null ? void 0 : t.isText) && a.nodeBefore.text;
  if (!b)
    return null;
  const x = a.pos - b.length, w = Array.from(b.matchAll(g)).pop();
  if (!w || w.input === void 0 || w.index === void 0)
    return null;
  const S = w.input.slice(Math.max(0, w.index - 1), w.index), _ = new RegExp(`^[${o?.join("")}\0]?$`).test(S);
  if (o !== null && !_)
    return null;
  const M = x + w.index;
  let N = M + w[0].length;
  return c && f.test(b.slice(N - 1, N + 1)) && (w[0] += " ", N += 1), M < a.pos && N >= a.pos ? {
    range: {
      from: M,
      to: N
    },
    query: w[0].slice(n.length),
    text: w[0]
  } : null;
}
var FIe = new Tr("suggestion");
function VIe({
  pluginKey: e = FIe,
  editor: t,
  char: n = "@",
  allowSpaces: r = !1,
  allowToIncludeChar: i = !1,
  allowedPrefixes: o = [" "],
  startOfLine: s = !1,
  decorationTag: a = "span",
  decorationClass: c = "suggestion",
  decorationContent: u = "",
  decorationEmptyClass: f = "is-empty",
  command: h = () => null,
  items: m = () => [],
  render: g = () => ({}),
  allow: b = () => !0,
  findSuggestionMatch: x = UIe,
  shouldShow: w
}) {
  let S;
  const _ = g?.(), M = () => {
    const O = t.state.selection.$anchor.pos, L = t.view.coordsAtPos(O), { top: U, right: B, bottom: G, left: Y } = L;
    try {
      return new DOMRect(Y, U, B - Y, G - U);
    } catch {
      return null;
    }
  }, N = (O, L) => L ? () => {
    const U = e.getState(t.state), B = U?.decorationId, G = O.dom.querySelector(`[data-decoration-id="${B}"]`);
    return G?.getBoundingClientRect() || null;
  } : M;
  function P(O, L) {
    var U;
    try {
      const G = e.getState(O.state), Y = G?.decorationId ? O.dom.querySelector(`[data-decoration-id="${G.decorationId}"]`) : null, he = {
        // @ts-ignore editor is available in closure
        editor: t,
        range: G?.range || { from: 0, to: 0 },
        query: G?.query || null,
        text: G?.text || null,
        items: [],
        command: (ie) => h({ editor: t, range: G?.range || { from: 0, to: 0 }, props: ie }),
        decorationNode: Y,
        clientRect: N(O, Y)
      };
      (U = _?.onExit) == null || U.call(_, he);
    } catch {
    }
    const B = O.state.tr.setMeta(L, { exit: !0 });
    O.dispatch(B);
  }
  const I = new Zn({
    key: e,
    view() {
      return {
        update: async (O, L) => {
          var U, B, G, Y, he, ie, ne;
          const H = (U = this.key) == null ? void 0 : U.getState(L), Q = (B = this.key) == null ? void 0 : B.getState(O.state), X = H.active && Q.active && H.range.from !== Q.range.from, Se = !H.active && Q.active, W = H.active && !Q.active, Z = !Se && !W && H.query !== Q.query, pe = Se || X && Z, F = Z || X, ee = W || X && Z;
          if (!pe && !F && !ee)
            return;
          const ge = ee && !pe ? H : Q, re = O.dom.querySelector(`[data-decoration-id="${ge.decorationId}"]`);
          S = {
            editor: t,
            range: ge.range,
            query: ge.query,
            text: ge.text,
            items: [],
            command: (J) => h({
              editor: t,
              range: ge.range,
              props: J
            }),
            decorationNode: re,
            clientRect: N(O, re)
          }, pe && ((G = _?.onBeforeStart) == null || G.call(_, S)), F && ((Y = _?.onBeforeUpdate) == null || Y.call(_, S)), (F || pe) && (S.items = await m({
            editor: t,
            query: ge.query
          })), ee && ((he = _?.onExit) == null || he.call(_, S)), F && ((ie = _?.onUpdate) == null || ie.call(_, S)), pe && ((ne = _?.onStart) == null || ne.call(_, S));
        },
        destroy: () => {
          var O;
          S && ((O = _?.onExit) == null || O.call(_, S));
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        return {
          active: !1,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: !1
        };
      },
      // Apply changes to the plugin state from a view transaction.
      apply(O, L, U, B) {
        const { isEditable: G } = t, { composing: Y } = t.view, { selection: he } = O, { empty: ie, from: ne } = he, H = { ...L }, Q = O.getMeta(e);
        if (Q && Q.exit)
          return H.active = !1, H.decorationId = null, H.range = { from: 0, to: 0 }, H.query = null, H.text = null, H;
        if (H.composing = Y, G && (ie || t.view.composing)) {
          (ne < L.range.from || ne > L.range.to) && !Y && !L.composing && (H.active = !1);
          const X = x({
            char: n,
            allowSpaces: r,
            allowToIncludeChar: i,
            allowedPrefixes: o,
            startOfLine: s,
            $position: he.$from
          }), Se = `id_${Math.floor(Math.random() * 4294967295)}`;
          X && b({
            editor: t,
            state: B,
            range: X.range,
            isActive: L.active
          }) && (!w || w({
            editor: t,
            range: X.range,
            query: X.query,
            text: X.text,
            transaction: O
          })) ? (H.active = !0, H.decorationId = L.decorationId ? L.decorationId : Se, H.range = X.range, H.query = X.query, H.text = X.text) : H.active = !1;
        } else
          H.active = !1;
        return H.active || (H.decorationId = null, H.range = { from: 0, to: 0 }, H.query = null, H.text = null), H;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(O, L) {
        var U, B, G, Y;
        const { active: he, range: ie } = I.getState(O.state);
        if (!he)
          return !1;
        if (L.key === "Escape" || L.key === "Esc") {
          const H = I.getState(O.state), Q = (U = S?.decorationNode) != null ? U : null, X = Q ?? (H?.decorationId ? O.dom.querySelector(`[data-decoration-id="${H.decorationId}"]`) : null);
          if (((B = _?.onKeyDown) == null ? void 0 : B.call(_, { view: O, event: L, range: H.range })) || !1)
            return !0;
          const W = {
            editor: t,
            range: H.range,
            query: H.query,
            text: H.text,
            items: [],
            command: (Z) => h({ editor: t, range: H.range, props: Z }),
            decorationNode: X,
            // If we have a cached decoration node, use it for the clientRect
            // to avoid another DOM lookup. If not, leave clientRect null and
            // let consumer decide if they want to query.
            clientRect: X ? () => X.getBoundingClientRect() || null : null
          };
          return (G = _?.onExit) == null || G.call(_, W), P(O, e), !0;
        }
        return ((Y = _?.onKeyDown) == null ? void 0 : Y.call(_, { view: O, event: L, range: ie })) || !1;
      },
      // Setup decorator on the currently active suggestion.
      decorations(O) {
        const { active: L, range: U, decorationId: B, query: G } = I.getState(O);
        if (!L)
          return null;
        const Y = !G?.length, he = [c];
        return Y && he.push(f), qn.create(O.doc, [
          gi.inline(U.from, U.to, {
            nodeName: a,
            class: he.join(" "),
            "data-decoration-id": B,
            "data-decoration-content": u
          })
        ]);
      }
    }
  });
  return I;
}
var HIe = VIe;
function WIe() {
  return /* @__PURE__ */ v.jsxs("svg", { className: "animate-spin h-4 w-4 text-muted-foreground", viewBox: "0 0 24 24", children: [
    /* @__PURE__ */ v.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4", fill: "none" }),
    /* @__PURE__ */ v.jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z" })
  ] });
}
function u0({
  items: e,
  selectedIndex: t,
  onSelect: n,
  onHover: r,
  loading: i = !1
}) {
  const [o, s] = C.useState(""), a = C.useMemo(() => {
    const u = (Array.isArray(e) ? e : Object.values(e)).flatMap(
      (h) => Object.values(h)
    );
    if (!o.trim()) return u;
    const f = o.trim().toLowerCase();
    return u.filter(
      (h) => h.name.toLowerCase().includes(f) || h.description?.toLowerCase().includes(f) || h.serverName.toLowerCase().includes(f)
    );
  }, [e, o]);
  return /* @__PURE__ */ v.jsxs("div", { className: "bg-popover rounded-lg shadow-lg divide-y max-h-96 overflow-auto w-96 mb-2 border focus:border-accent", children: [
    /* @__PURE__ */ v.jsx("div", { className: "px-4 py-2 sticky top-0 bg-popover z-10 border-b", children: /* @__PURE__ */ v.jsx(
      "input",
      {
        type: "text",
        className: "w-full px-2 py-1 rounded border text-sm bg-background outline-none focus:ring-2 focus:ring-accent focus:border-accent",
        placeholder: "Search tools... (name / description / mcp)",
        value: o,
        onChange: (c) => s(c.target.value)
      }
    ) }),
    i ? /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 px-4 py-3", children: [
      /* @__PURE__ */ v.jsx(WIe, {}),
      /* @__PURE__ */ v.jsx("div", { className: "text-sm text-muted-foreground", children: "Loading tools..." })
    ] }) : a.length === 0 ? /* @__PURE__ */ v.jsx("div", { className: "px-4 py-3 text-sm text-muted-foreground", children: "No results" }) : a.map((c, u) => /* @__PURE__ */ v.jsxs(
      "div",
      {
        role: "option",
        "aria-selected": u === t,
        onMouseDown: (f) => {
          f.preventDefault(), n(c);
        },
        onMouseEnter: () => r(u),
        className: `flex items-center gap-3 px-4 py-3 cursor-pointer transition-colors select-none ${u === t ? "bg-accent/15 text-accent-foreground" : "hover:bg-accent/50"}`,
        children: [
          /* @__PURE__ */ v.jsx("div", { className: "shrink-0 w-8 h-8 rounded-full bg-slate-100 dark:bg-neutral-800 flex items-center justify-center text-sm font-semibold text-slate-700", children: c.name ? c.name.charAt(0).toUpperCase() : "?" }),
          /* @__PURE__ */ v.jsxs("div", { className: "min-w-0 flex-1", children: [
            /* @__PURE__ */ v.jsxs(Gi, { children: [
              /* @__PURE__ */ v.jsx(KA, { asChild: !0, children: /* @__PURE__ */ v.jsx("span", { className: "font-medium text-sm truncate hover:underline decoration-dotted cursor-help", children: c.name }) }),
              /* @__PURE__ */ v.jsxs(sw, { side: "right", align: "start", className: "z-1000 bg-white/95 backdrop-blur text-neutral-900 max-w-xs text-xs shadow-2xl border border-neutral-200 rounded-xl px-5 py-4", children: [
                /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-3 mb-2", children: [
                  /* @__PURE__ */ v.jsx("div", { className: "w-9 h-9 rounded-full bg-linear-to-tr from-accent to-muted flex items-center justify-center text-lg font-bold text-white shadow", children: c.name ? c.name.charAt(0).toUpperCase() : "?" }),
                  /* @__PURE__ */ v.jsxs("div", { children: [
                    /* @__PURE__ */ v.jsx("div", { className: "font-semibold text-base text-neutral-800", children: c.name }),
                    /* @__PURE__ */ v.jsxs("div", { className: "text-[11px] text-neutral-500 mt-0.5", children: [
                      "MCP: ",
                      /* @__PURE__ */ v.jsx("span", { className: "font-medium text-neutral-700", children: c.serverName })
                    ] })
                  ] })
                ] }),
                c.description && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
                  /* @__PURE__ */ v.jsx("div", { className: "border-t border-neutral-200 my-2" }),
                  /* @__PURE__ */ v.jsx("div", { className: "text-sm text-neutral-700 leading-relaxed", children: c.description })
                ] })
              ] })
            ] }),
            c.description && /* @__PURE__ */ v.jsx("div", { className: "text-xs text-muted-foreground truncate mt-0.5", children: c.description }),
            /* @__PURE__ */ v.jsxs("div", { className: "text-[11px] text-muted-foreground truncate mt-0.5", children: [
              "MCP: ",
              /* @__PURE__ */ v.jsx("span", { className: "font-medium", children: c.serverName })
            ] })
          ] }),
          /* @__PURE__ */ v.jsxs("div", { className: "ml-auto flex items-center gap-2", children: [
            /* @__PURE__ */ v.jsx("span", { className: "text-[11px] px-2 py-0.5 rounded bg-muted text-muted-foreground", children: c.serverName }),
            /* @__PURE__ */ v.jsx("div", { className: "text-xs text-neutral-400", children: "Select" })
          ] })
        ]
      },
      `${c.serverId}-${c.id || c.name}-${u}`
    ))
  ] });
}
function qIe(e) {
  return {
    items: async ({ query: t }) => {
      try {
        const n = e?.mcpServerList?.value || [], r = e?.allowedMcpServers?.value || {}, i = n.reduce((a, c) => {
          const u = c.name, f = c.id, h = r[f]?.tools || [];
          a[u] || (a[u] = []);
          const m = c.toolInfo.filter((g) => h.includes(g.name)).map((g) => ({
            ...g,
            serverId: c.id,
            serverName: c.name
          }));
          return m.length > 0 && a[u].push(...m), a;
        }, {});
        if (!t) return i;
        const o = String(t).toLowerCase();
        return Object.fromEntries(
          Object.entries(i).map(([a, c]) => [
            a,
            c.filter((u) => u.name.toLowerCase().includes(o))
          ]).filter(([, a]) => a.length > 0)
        );
      } catch {
        return [];
      }
    },
    render: () => {
      let t = null, n = null, r = {}, i = 0, o = null;
      const s = () => Object.values(r).flat();
      return {
        onStart: (a) => {
          o = a.command, r = a.items || {}, i = 0, t = document.createElement("div"), t.style.position = "absolute", t.style.zIndex = "9999", t.style.left = "0px", t.style.top = "0px", document.body.appendChild(t);
          const c = () => {
            if (!t || !a.clientRect) return;
            const u = a.clientRect();
            if (u) {
              t.style.left = `${u.left + window.scrollX}px`;
              const f = t.offsetHeight || 40;
              t.style.top = `${u.top + window.scrollY - f}px`, t.style.width = `${u.width}px`;
            }
          };
          n = A3.createRoot(t), n.render(
            /* @__PURE__ */ v.jsx(
              u0,
              {
                items: a.items,
                selectedIndex: 0,
                onSelect: (u) => {
                  console.log("Selected mention item:", u), a.command(u);
                },
                onHover: (u) => {
                  i = u;
                }
              }
            )
          ), requestAnimationFrame(c);
        },
        onUpdate: (a) => {
          o = a.command, r = a.items || {};
          const c = s();
          i = Math.min(i, Math.max(c.length - 1, 0)), n && n.render(
            /* @__PURE__ */ v.jsx(
              u0,
              {
                items: r,
                selectedIndex: i,
                onSelect: (u) => a.command(u),
                onHover: (u) => {
                  i = u;
                }
              }
            )
          ), t && a.clientRect && requestAnimationFrame(() => {
            if (!t) return;
            const f = a.clientRect();
            if (f) {
              const h = t.offsetHeight || 40;
              t.style.left = `${f.left + window.scrollX}px`, t.style.top = `${f.top + window.scrollY - h}px`, t.style.width = `${f.width}px`;
            }
          });
        },
        onKeyDown: (a) => {
          const c = a.event;
          if (c.key === "ArrowDown") {
            c.preventDefault(), c.stopPropagation();
            const u = s();
            return i = Math.min(i + 1, Math.max(u.length - 1, 0)), n && n.render(
              /* @__PURE__ */ v.jsx(
                u0,
                {
                  items: r,
                  selectedIndex: i,
                  onSelect: (f) => {
                    o && o(f);
                  },
                  onHover: (f) => {
                    i = f;
                  }
                }
              )
            ), !0;
          }
          if (c.key === "ArrowUp")
            return c.preventDefault(), c.stopPropagation(), i = Math.max(i - 1, 0), n && n.render(
              /* @__PURE__ */ v.jsx(
                u0,
                {
                  items: r,
                  selectedIndex: i,
                  onSelect: (u) => {
                    o && o(u);
                  },
                  onHover: (u) => {
                    i = u;
                  }
                }
              )
            ), !0;
          if (c.key === "Enter" || c.key === "Tab") {
            const u = s()[i];
            if (u && o)
              return c.preventDefault(), c.stopPropagation(), o(u), !0;
          }
          return !1;
        },
        onExit: () => {
          if (n && t) {
            n.unmount();
            try {
              t.remove();
            } catch {
            }
            n = null, t = null;
          }
          if (t) {
            try {
              t.remove();
            } catch {
            }
            t = null;
          }
        }
      };
    }
  };
}
const GIe = ji.create({
  name: "mention",
  inline: !0,
  group: "inline",
  atom: !0,
  addOptions() {
    return {
      chatbotServerStore: void 0
    };
  },
  addAttributes() {
    return {
      id: { default: null },
      label: { default: null },
      description: { default: null },
      serverId: { default: null },
      serverName: { default: null }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span[data-mention]"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "span",
      or(t, { "data-mention": "", "data-id": e.attrs.id, class: "mention-node" }),
      `@${e.attrs.label}`
    ];
  },
  addCommands() {
    return {
      insertMention: (e) => ({ chain: t }) => {
        try {
          return t().focus().insertContent({ type: this.name, attrs: e }).run();
        } catch {
          return !1;
        }
      }
    };
  },
  addProseMirrorPlugins() {
    const e = this.editor, t = qIe(this.options.chatbotServerStore), n = Object.assign({ editor: e, char: "@", startOfLine: !1 }, t);
    return n.command = ({ editor: r, range: i, props: o }) => {
      try {
        const s = o.label || o.name || o.id || "unknown";
        setTimeout(() => {
          r.chain().focus().setTextSelection(i.from).deleteRange(i).insertContent([{
            type: "mention",
            attrs: {
              id: o.id || o.name,
              label: s,
              description: o.description,
              serverId: o.serverId,
              serverName: o.serverName
            }
          }, { type: "text", text: " " }]).run();
        }, 0);
        const a = new CustomEvent("tiptap-mention-inserted", { detail: { ...o, label: s } });
        window.dispatchEvent(a);
      } catch (s) {
        console.error("Error inserting mention:", s);
      }
    }, [HIe(n)];
  }
}), KIe = (e) => {
  const { node: t, deleteNode: n, editor: r } = e, { id: i, name: o, classUri: s, versionId: a } = t.attrs, [c, u] = C.useState(!1), f = (S) => {
    S.preventDefault(), S.stopPropagation(), n(), setTimeout(() => {
      try {
        r?.commands?.focus();
      } catch {
      }
    }, 0);
  }, h = (S) => {
    S.preventDefault(), S.stopPropagation();
    const _ = new CustomEvent("entity-isolate", {
      detail: { id: i, name: o, classUri: s, versionId: a }
    });
    window.dispatchEvent(_), cn.success(`Isolated ${o}`);
  }, m = (S) => {
    S.preventDefault(), S.stopPropagation();
    const _ = new CustomEvent("entity-reset-visibility", {
      detail: { id: i, name: o }
    });
    window.dispatchEvent(_), cn.success("Reset visibility");
  }, g = (S) => {
    S.preventDefault(), S.stopPropagation();
    const _ = [
      `Name: ${o}`,
      i ? `Element ID: ${i}` : null,
      a ? `Version ID: ${a}` : null,
      s ? `Class: ${s}` : null
    ].filter(Boolean).join(`
`);
    navigator.clipboard.writeText(_).then(() => {
      cn.success("Copied entity info");
    }).catch(() => {
      cn.error("Failed to copy");
    });
  }, b = (S) => {
    S.preventDefault(), S.stopPropagation();
    const _ = new CustomEvent("entity-zoom-select", {
      detail: { id: i, name: o, classUri: s, versionId: a }
    });
    window.dispatchEvent(_);
  }, x = () => {
    u(!0);
    const S = new CustomEvent("entity-hover", {
      detail: { id: i, name: o, classUri: s, versionId: a, hover: !0 }
    });
    window.dispatchEvent(S);
  }, w = () => {
    u(!1);
    const S = new CustomEvent("entity-hover", {
      detail: { id: i, name: o, classUri: s, versionId: a, hover: !1 }
    });
    window.dispatchEvent(S);
  };
  return /* @__PURE__ */ v.jsx(KPe, { className: "inline select-none", contentEditable: !1, children: /* @__PURE__ */ v.jsxs(
    "span",
    {
      className: "mt-1 inline-flex items-center gap-1 mx-0.5 px-2 py-0.5 rounded-md bg-emerald-600/20 border border-emerald-600/30 cursor-default transition-colors hover:bg-emerald-600/30",
      onMouseEnter: x,
      onMouseLeave: w,
      onDoubleClick: b,
      children: [
        /* @__PURE__ */ v.jsx("span", { className: "select-none", children: o || "Entity" }),
        /* @__PURE__ */ v.jsxs("div", { className: "inline-flex items-center gap-0.5", children: [
          c && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
            /* @__PURE__ */ v.jsx(
              "button",
              {
                className: "inline-flex items-center justify-center bg-transparent border-none cursor-pointer p-0.5 m-0 text-emerald-600/80 transition-all rounded-sm hover:bg-emerald-600/20 hover:text-emerald-600",
                onClick: h,
                onMouseDown: (S) => S.preventDefault(),
                title: "Isolate",
                children: /* @__PURE__ */ v.jsx(WT, { className: "h-3 w-3" })
              }
            ),
            /* @__PURE__ */ v.jsx(
              "button",
              {
                className: "inline-flex items-center justify-center bg-transparent border-none cursor-pointer p-0.5 m-0 text-emerald-600/80 transition-all rounded-sm hover:bg-emerald-600/20 hover:text-emerald-600",
                onClick: m,
                onMouseDown: (S) => S.preventDefault(),
                title: "Reset visibility",
                children: /* @__PURE__ */ v.jsx(GT, { className: "h-3 w-3" })
              }
            ),
            /* @__PURE__ */ v.jsx(
              "button",
              {
                className: "inline-flex items-center justify-center bg-transparent border-none cursor-pointer p-0.5 m-0 text-emerald-600/80 transition-all rounded-sm hover:bg-emerald-600/20 hover:text-emerald-600",
                onClick: g,
                onMouseDown: (S) => S.preventDefault(),
                title: "Copy info",
                children: /* @__PURE__ */ v.jsx(Sc, { className: "h-3 w-3" })
              }
            )
          ] }),
          /* @__PURE__ */ v.jsx(
            "button",
            {
              className: "inline-flex items-center justify-center bg-transparent border-none cursor-pointer p-0.5 m-0 text-emerald-600/60 transition-all rounded-sm hover:bg-red-500/10 hover:text-red-500",
              onClick: f,
              onMouseDown: (S) => S.preventDefault(),
              title: "Remove entity",
              children: /* @__PURE__ */ v.jsx(Rg, { className: "h-3 w-3" })
            }
          )
        ] })
      ]
    }
  ) });
}, ZIe = ji.create({
  name: "entity",
  inline: !0,
  group: "inline",
  atom: !0,
  draggable: !1,
  addAttributes() {
    return {
      id: { default: null },
      name: { default: null },
      classUri: { default: null },
      versionId: { default: null }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span[data-entity]"
      }
    ];
  },
  renderHTML({ node: e, HTMLAttributes: t }) {
    return [
      "span",
      or(t, {
        "data-entity": "",
        "data-id": e.attrs.id,
        "data-class-uri": e.attrs.classUri,
        "data-version-id": e.attrs.versionId,
        class: "entity-node"
      }),
      e.attrs.name ? String(e.attrs.name) : "Entity"
    ];
  },
  addNodeView() {
    return eje(KIe);
  },
  renderText({ node: e }) {
    const t = e?.attrs?.name ? String(e.attrs.name) : "Entity", n = e?.attrs?.id ? String(e.attrs.id) : "", r = e?.attrs?.versionId ? String(e.attrs.versionId) : "";
    return n && r ? `[Name: ${t}, Element Id: ${n}: VersionId: ${r}]` : n ? `[${t}:${n}]` : r ? `[Name: ${t}, VersionId:${r}]` : `[${t}]`;
  }
});
async function YIe() {
  const e = await zc(), t = await fetch(`${Wa}/chat/tools`, { headers: e });
  if (!t.ok) return { ok: !1, tools: [] };
  const n = await t.json().catch(() => null);
  return Array.isArray(n) ? { ok: !0, tools: n } : n && Array.isArray(n?.tools) ? {
    ok: !!(n?.ok ?? !0),
    tools: n.tools
  } : { ok: !1, tools: [] };
}
function XIe(e) {
  const {
    localValue: t,
    history: n,
    historyIndex: r,
    setHistoryIndex: i,
    setLocalValue: o,
    onChange: s,
    doSendAndClear: a,
    mention: c
  } = e;
  return (u) => {
    if ((u.ctrlKey || u.metaKey) && (u.key === "c" || u.key === "v" || u.key === "x" || u.key === "a")) {
      u.stopPropagation();
      return;
    }
    if ((u.ctrlKey || u.metaKey) && u.key === "End") {
      u.preventDefault(), a();
      return;
    }
    if (u.ctrlKey && u.key === "Enter" && (u.preventDefault(), a()), u.key === "ArrowUp") {
      if (t.trim() === "" && n.length === 0) return;
      if (t.trim() === "" || r !== null) {
        u.preventDefault();
        const h = r === null ? n.length - 1 : Math.max(0, r - 1);
        i(h);
        const m = n[h];
        m !== void 0 && (o(m), s && s(m));
      }
      return;
    }
    try {
      if (c.handleKeyDown(u), u.defaultPrevented) return;
    } catch {
    }
    if (u.key === "ArrowDown") {
      if (r === null) return;
      u.preventDefault();
      const h = r + 1;
      if (h >= n.length)
        i(null), o(""), s && s("");
      else {
        i(h);
        const m = n[h];
        m !== void 0 && (o(m), s && s(m));
      }
      return;
    }
  };
}
function JIe(e) {
  if (!isFinite(e) || e <= 0) return "0 B";
  const t = ["B", "KB", "MB", "GB", "TB"], n = Math.min(t.length - 1, Math.floor(Math.log(e) / Math.log(1024))), r = e / Math.pow(1024, n);
  return `${n === 0 ? Math.round(r) : r.toFixed(2)} ${t[n]}`;
}
async function QIe(e) {
  if (!e) throw new Error("No file provided");
  try {
    const t = await RAe(e);
    if (!t) throw new Error("No metadata returned from S3 upload");
    return {
      fileName: e.name,
      mimeType: e.type || t.mimeType || "application/octet-stream",
      s3Key: t.s3Key || t.key || t.keyName || "",
      size: e.size,
      url: t.url || t.s3Url || t.location || void 0,
      status: "uploaded",
      ...t
    };
  } catch (t) {
    return console.error("S3 upload failed:", t), {
      fileName: e.name,
      mimeType: e.type || "application/octet-stream",
      s3Key: "",
      size: e.size,
      status: "error",
      error: t?.message || String(t)
    };
  }
}
function eze({
  number: e,
  className: t
}) {
  const n = u6(0), r = rre(n, Math.round);
  return C.useEffect(() => wre(n, e, { duration: 1 }).stop, [e]), /* @__PURE__ */ v.jsx(qf.span, { className: at(t), children: r });
}
const tze = 2500, nze = (e) => {
  const {
    tools: t,
    onClickAllChecked: n,
    isAuthorizing: r,
    authorizationUrl: i,
    error: o,
    checked: s,
    onToolClick: a
  } = e, [c, u] = C.useState(!1), [f, h] = C.useState(""), [m, g] = C.useState(!1), b = C.useRef(null), x = !!i, w = C.useMemo(() => t.filter(
    (N) => N.name.toLowerCase().includes(f.toLowerCase())
  ), [t, f]), S = C.useCallback(() => {
    b.current !== null && (window.clearInterval(b.current), b.current = null), g(!1);
  }, []), _ = C.useCallback(() => {
    b.current === null && (b.current = window.setInterval(() => {
      S_(`${Ws}/list`);
    }, tze), g(!0));
  }, []);
  C.useEffect(() => {
    (!r || o) && S();
  }, [o, r, S]), C.useEffect(() => S, [S]);
  const M = C.useCallback(
    () => cN(() => u(!0)).ifOk(() => (x && (window.open(i, "_blank", "noopener,noreferrer"), _()), S_(`${Ws}/list`))).ifFail(gb).watch(() => u(!1)),
    [i, x, _]
  );
  return r ? /* @__PURE__ */ v.jsxs(
    m9,
    {
      className: "transition-colors border-none",
      children: [
        c ? /* @__PURE__ */ v.jsx(qT, { className: "animate-spin" }) : /* @__PURE__ */ v.jsx(X0, {}),
        /* @__PURE__ */ v.jsx(g9, { children: "Authorization Required" }),
        /* @__PURE__ */ v.jsx(y9, { children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-2", children: [
          /* @__PURE__ */ v.jsx("span", { children: m ? "Waiting for authorization to complete." : "Pending authorization to access this MCP server." }),
          /* @__PURE__ */ v.jsx(
            Ht,
            {
              variant: "outline",
              size: "sm",
              onClick: M,
              disabled: !x || c,
              className: "cursor-pointer",
              children: "Authorize"
            }
          )
        ] }) })
      ]
    }
  ) : /* @__PURE__ */ v.jsxs("div", { children: [
    /* @__PURE__ */ v.jsxs(
      mfe,
      {
        className: "text-muted-foreground flex items-center gap-2",
        onClick: (N) => {
          N.preventDefault(), n(!s);
        },
        children: [
          /* @__PURE__ */ v.jsx(
            "input",
            {
              autoFocus: !0,
              placeholder: "Search tools...",
              value: f,
              onKeyDown: (N) => {
                N.stopPropagation();
              },
              onChange: (N) => h(N.target.value),
              onClick: (N) => {
                N.stopPropagation();
              },
              className: "placeholder:text-muted-foreground flex w-full text-xs   outline-hidden disabled:cursor-not-allowed disabled:opacity-50"
            }
          ),
          /* @__PURE__ */ v.jsx("div", { className: "flex-1" }),
          /* @__PURE__ */ v.jsx(nH, { checked: s })
        ]
      }
    ),
    /* @__PURE__ */ v.jsx(Sb, {}),
    /* @__PURE__ */ v.jsx("div", { className: "max-h-96 overflow-y-auto", children: w.length === 0 ? /* @__PURE__ */ v.jsx("div", { className: "text-sm text-muted-foreground w-full h-full flex items-center justify-center py-6", children: "No results found" }) : w.map((N) => /* @__PURE__ */ v.jsxs(
      ls,
      {
        className: "flex items-center gap-2 cursor-pointer mb-1",
        onClick: (P) => {
          P.preventDefault(), a(N.name, !N.checked);
        },
        children: [
          /* @__PURE__ */ v.jsxs("div", { className: "mx-1 flex-1 min-w-0", children: [
            /* @__PURE__ */ v.jsx("p", { className: "font-medium text-xs mb-1 truncate", children: N.name }),
            /* @__PURE__ */ v.jsx("p", { className: "text-xs text-muted-foreground truncate", children: N.description })
          ] }),
          /* @__PURE__ */ v.jsx(Z7, { checked: N.checked, className: "ml-auto" })
        ]
      },
      N.name
    )) })
  ] });
}, rze = () => {
  const {
    chatbotServerStore: { allowedMcpServers: e, mcpServerList: t }
  } = ra(), n = C.useMemo(() => t.value.length === 0 ? [] : [...t.value].sort(
    (i, o) => (i.status === "connected" ? -1 : 1) - (o.status === "connected" ? -1 : 1)
  ).map((i) => {
    const o = e.value?.[i.id]?.tools ?? [];
    return {
      id: i.id,
      serverName: i.name,
      checked: o.length > 0,
      tools: (i.toolInfo || []).map((s) => ({
        name: s.name,
        checked: o.includes(s.name),
        description: s.description
      })),
      error: i.error,
      status: i.status,
      authorizationUrl: i.authorizationUrl
    };
  }), [t.value, e.value]), r = C.useCallback(
    (i, o) => {
      const a = {
        ...e.value || {},
        [i]: {
          tools: o
        }
      };
      e.value = a, localStorage.setItem(mb.ALLOWED_MCP_SERVERS, JSON.stringify(a));
    },
    [e]
  );
  return /* @__PURE__ */ v.jsxs(hfe, { className: "max-h-96 overflow-y-auto", children: [
    n.map((i) => /* @__PURE__ */ v.jsxs(gfe, { children: [
      /* @__PURE__ */ v.jsxs(
        yfe,
        {
          className: "flex items-center gap-2 font-semibold cursor-pointer",
          onClick: (o) => {
            o.preventDefault(), r(
              i.id,
              i.checked ? [] : i.tools.map((s) => s.name)
            );
          },
          children: [
            /* @__PURE__ */ v.jsx("div", { className: "flex items-center justify-center p-1 rounded bg-input/40 border", children: /* @__PURE__ */ v.jsx(lh, { className: "fill-foreground size-2.5" }) }),
            /* @__PURE__ */ v.jsx("span", { className: at("truncate", !i.checked && "opacity-30"), children: i.serverName }),
            i.error ? /* @__PURE__ */ v.jsx(
              "span",
              {
                className: at("text-xs text-destructive ml-1 p-1 rounded"),
                children: "error"
              }
            ) : null,
            /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-2 ml-auto", children: i.status === "authorizing" ? /* @__PURE__ */ v.jsx("div", { className: "flex items-center gap-1", children: /* @__PURE__ */ v.jsx(X0, { className: "size-3 text-muted-foreground" }) }) : /* @__PURE__ */ v.jsx(v.Fragment, { children: i.tools.filter((o) => o.checked).length > 0 ? /* @__PURE__ */ v.jsx("span", { className: "w-5 h-5 items-center justify-start flex text-[8px] text-muted-foreground font-semibold ", children: /* @__PURE__ */ v.jsx(
              Dh,
              {
                variant: "outline",
                className: "h-5 min-w-5 rounded-full px-1 font-mono tabular-nums",
                children: i.tools.filter((o) => o.checked).length
              }
            ) }) : null }) })
          ]
        }
      ),
      /* @__PURE__ */ v.jsx(ffe, { children: /* @__PURE__ */ v.jsx(vfe, { className: "w-80 relative", children: /* @__PURE__ */ v.jsx(
        nze,
        {
          tools: i.tools,
          isAuthorizing: i.status === "authorizing",
          authorizationUrl: i.authorizationUrl,
          error: i.error,
          checked: i.checked,
          serverId: i.id,
          onClickAllChecked: (o) => {
            r(
              i.id,
              o ? i.tools.map((s) => s.name) : []
            );
          },
          onToolClick: (o, s) => {
            const a = i.tools.filter((c) => c.checked).map((c) => c.name);
            r(
              i.id,
              s ? a.concat(o) : a.filter((c) => c !== o)
            );
          }
        }
      ) }) })
    ] }, i.id)),
    t.value.length !== 0 && /* @__PURE__ */ v.jsx("div", { className: "py-1 w-full", children: /* @__PURE__ */ v.jsx(Sb, {}) }),
    /* @__PURE__ */ v.jsxs("div", { className: "text-sm text-muted-foreground w-full h-full flex flex-col items-center justify-center py-6", children: [
      t.value.length !== 0 ? /* @__PURE__ */ v.jsx("div", { children: "Welcome to additional MCP servers!" }) : /* @__PURE__ */ v.jsx("div", { children: "No MCP servers detected." }),
      /* @__PURE__ */ v.jsx(yw, { to: "/chat-bot/mcp/create", children: /* @__PURE__ */ v.jsxs(
        Ht,
        {
          variant: "ghost",
          className: "mt-2 text-primary flex items-center gap-1",
          children: [
            "Add a server ",
            /* @__PURE__ */ v.jsx(Ng, { className: "size-4" })
          ]
        }
      ) })
    ] })
  ] });
};
function ize({
  align: e,
  side: t,
  mentions: n,
  className: r
}) {
  const [i, o] = C.useState(!1), { data: s, isLoading: a } = d9(), {
    chatbotServerStore: { allowedMcpServers: c, mcpServerList: u }
  } = ra(), f = C.useMemo(() => n?.find((g) => g.type === "agent"), [n]);
  let h = C.useMemo(() => {
    if (n?.length)
      return n.map((x) => x.name);
    const g = u.value.map((x) => x.id);
    return [...Object.values(
      t9(c?.value ?? {}).filter(
        (x, w) => g.includes(String(w))
      )
    ).map((x) => x.tools ?? []).flat()];
  }, [
    n,
    u.value,
    c.value,
    s
  ]);
  const m = C.useMemo(() => /* @__PURE__ */ v.jsxs(
    Ht,
    {
      variant: "ghost",
      size: "sm",
      className: at(
        "gap-0.5 bg-background/50 border rounded-full data-[state=open]:bg-input! hover:bg-input! cursor-pointer",
        !h.length && !a && "text-muted-foreground bg-transparent border-transparent",
        a && "bg-input/60",
        i && "bg-input!",
        r
      ),
      children: [
        /* @__PURE__ */ v.jsx("span", { className: h ? "" : "text-muted-foreground", children: f ? "Agent" : n?.length ?? !1 ? "Mention" : "Tools" }),
        (!f && h.length > 0 || a) && /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
          /* @__PURE__ */ v.jsx("div", { className: "h-4 hidden sm:block mx-1", children: /* @__PURE__ */ v.jsx(yb, { orientation: "vertical" }) }),
          /* @__PURE__ */ v.jsx("div", { className: "min-w-5 flex justify-center", children: a ? /* @__PURE__ */ v.jsx(qT, { className: "animate-spin size-3.5" }) : (n?.length ?? 0) > 0 ? /* @__PURE__ */ v.jsx(F3, { className: "size-3.5" }) : /* @__PURE__ */ v.jsx(
            eze,
            {
              number: h.length,
              className: "text-xs"
            }
          ) })
        ] })
      ]
    }
  ), [
    h.length,
    a,
    i,
    r,
    f,
    n?.length
  ]);
  return /* @__PURE__ */ v.jsxs(Qu, { open: i, onOpenChange: o, children: [
    /* @__PURE__ */ v.jsx(ed, { asChild: !0, children: /* @__PURE__ */ v.jsx("div", { children: /* @__PURE__ */ v.jsxs(Gi, { children: [
      /* @__PURE__ */ v.jsx(fo, { asChild: !0, children: m }),
      /* @__PURE__ */ v.jsxs(
        Bo,
        {
          align: e,
          side: t,
          className: "p-4 text-xs bg-card border border-border",
          children: [
            /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ v.jsx(J0, { className: "size-3.5" }),
              /* @__PURE__ */ v.jsx("span", { className: "text-sm", children: "Tools Setup" })
            ] }),
            /* @__PURE__ */ v.jsx("p", { className: "text-muted-foreground mt-4 whitespace-pre-wrap", children: `"Select tools that the chatbot can use.
The chatbot will use selected tools based on its own judgment.

You can also force the use of specific tools through @mention.",` })
          ]
        }
      )
    ] }) }) }),
    /* @__PURE__ */ v.jsx(td, { className: "md:w-72", align: e, side: t, children: /* @__PURE__ */ v.jsxs("div", { className: "py-2", children: [
      /* @__PURE__ */ v.jsxs("div", { className: "py-1", children: [
        /* @__PURE__ */ v.jsx("span", { className: "px-3 text-sm font-medium", children: "MCP Servers" }),
        /* @__PURE__ */ v.jsx(Sb, {})
      ] }),
      /* @__PURE__ */ v.jsx(rze, {}),
      /* @__PURE__ */ v.jsx(Sb, {})
    ] }) })
  ] });
}
const Vq = window.SpeechRecognition || window.webkitSpeechRecognition, Hq = !!Vq, oze = (e) => () => {
  const { isListening: t, recognitionRef: n, setIsListening: r, onTranscript: i, language: o = "en-US" } = e;
  if (!Hq) {
    alert("Speech recognition is not supported. Please use Chrome or Edge.");
    return;
  }
  if (t) {
    n.current && (n.current.stop(), n.current = null), r(!1);
    return;
  }
  let s = "";
  const a = new Vq();
  a.continuous = !0, a.interimResults = !0, a.lang = o, a.onresult = (c) => {
    s = "";
    for (let u = 0; u < c.results.length; u++) {
      const f = c.results[u][0].transcript;
      c.results[u].isFinal && (s += f + " ");
    }
    s && i && (i(s), s = "");
  }, a.onend = () => {
    r(!1), n.current = null;
  }, a.onerror = (c) => {
    c.error === "not-allowed" || c.error === "permission-denied" ? alert("Please allow microphone access in your browser.") : c.error !== "aborted" && console.error("Speech recognition error:", c.error), r(!1);
  };
  try {
    a.start(), n.current = a, r(!0);
  } catch (c) {
    console.error("Failed to start speech recognition", c), r(!1);
  }
}, sze = (e) => async () => {
  const {
    localValue: t,
    isAIThinking: n,
    isListening: r,
    recognitionRef: i,
    editor: o,
    setHistory: s,
    setHistoryIndex: a,
    setLocalValue: c,
    setIsListening: u,
    setFiles: f,
    startedTypingRef: h,
    onChange: m,
    onSend: g
  } = e, b = (t || "").trim();
  if (n || !b) return;
  if (r && i.current)
    try {
      i.current.stop(), i.current = null, u(!1);
    } catch (w) {
      console.error("Error stopping speech recognition:", w);
    }
  const x = [];
  if (o && o.state && o.state.doc)
    try {
      o.state.doc.descendants((w) => (w && w.type && w.type.name === "mention" && w.attrs && x.push({
        type: "mcpTool",
        name: w.attrs.id ?? w.attrs.label ?? "",
        label: w.attrs.label ?? w.attrs.id ?? "",
        description: w.attrs.description ?? "",
        serverId: w.attrs.serverId ?? "",
        serverName: w.attrs.serverName ?? ""
      }), !0));
    } catch (w) {
      console.error("Error collecting mentions:", w);
    }
  try {
    if (b && s((w) => w[w.length - 1] === b ? w : [...w, b].slice(-10)), a(null), c(""), m && m(""), f([]), o && o.view)
      try {
        o.commands.setContent(""), setTimeout(() => {
          if (o && o.view)
            try {
              o.commands.focus();
            } catch {
            }
        }, 100);
      } catch (w) {
        console.error("Error clearing editor:", w);
      }
    h.current = !1, await g(b, x);
  } catch (w) {
    throw console.error("PromptInput: send error", w), w;
  }
};
var K0 = /* @__PURE__ */ ((e) => (e.Hierarchy = "Hierarchy", e.System = "System", e.GraphRelationship = "GraphRelationship", e.GraphComputation = "GraphComputation", e.MakeAsRootProject = "MakeAsRootProject", e.HandleRelationship = "HandleRelationship", e.HandleComposite = "HandleComposite", e.InspectionRelationship = "InspectionRelationship", e.PropertyReferenceEntity = "PropertyReferenceEntity", e.ImportedModelBachedGroup = "ImportedModelBachedGroup", e.ImportedModelFloorPlan = "ImportedModelFloorPlan", e.ImportedModelPdfViewer = "ImportedModelPdfViewer", e.ImportedModel3D = "ImportedModel3D", e.MakeAsRootBachedGroup = "MakeAsRootBachedGroup", e.HandlePromptUserInputChatbot = "HandlePromptUserInputChatbot", e.HandleRelationshipCreationSource = "HandleRelationshipCreationSource", e.HandleRelationshipCreationTarget = "HandleRelationshipCreationTarget", e))(K0 || {});
function e3(e) {
  const {
    value: t = "",
    onChange: n,
    onSend: r,
    opStop: i,
    onFilesChange: o,
    files: s,
    onStartTyping: a,
    onUseNextSuggestionChange: c
  } = e, u = C.useRef(n), f = C.useRef(null), h = C.useRef("");
  C.useEffect(() => {
    u.current = n;
  }, [n]), C.useEffect(() => () => {
    f.current && (window.clearTimeout(f.current), f.current = null);
  }, []), $3();
  const {
    chatbotStore: { isAIThinking: m },
    chatbotThreadStore: { addThreadMention: g, removeThreadMention: b },
    chatbotServerStore: x
  } = ra(), { setNodeRef: w, isOver: S } = zMe({
    id: K0.HandlePromptUserInputChatbot
  }), _ = qPe({
    extensions: [
      BIe,
      $Ie.configure({
        placeholder: "Ask any thing"
      }),
      GIe.configure({ chatbotServerStore: x }),
      ZIe
    ],
    content: t ?? "",
    editable: !m.value,
    editorProps: {
      attributes: {
        class: "min-h-16 max-h-40 overflow-y-auto dark:bg-neutral-700 bg-neutral-200 resize-none border-0 focus-visible:ring-0 px-3 text-neutral-800 placeholder:text-neutral-600 dark:text-white dark:placeholder:text-gray-400"
      }
    },
    // Auto-focus on creation
    autofocus: "end"
  }), M = C.useRef(null), [N, P] = C.useState(!1), [I, O] = C.useState([]), [L, U] = C.useState(null), [B, G] = C.useState(s ?? []), [Y, he] = C.useState(t), ie = C.useRef(!1), ne = C.useRef(!1), [H, Q] = C.useState(() => {
    try {
      const ee = localStorage.getItem(mb.AI_USE_NEXT_SUGGESTION);
      return ee ? JSON.parse(ee) : !1;
    } catch {
      return !1;
    }
  }), X = C.useRef({});
  C.useEffect(() => {
    try {
      localStorage.setItem(
        "useNextSuggestion",
        JSON.stringify(H)
      );
    } catch {
    }
    c && c(H);
  }, [H, c]), C.useEffect(() => {
    const ee = (ge) => {
      const re = ge?.detail;
      if (re)
        try {
          g({
            type: "mcpTool",
            name: re.name,
            label: re.label ? re.label : re.name,
            description: re.description,
            serverId: re.serverId,
            serverName: re.serverName
          });
        } catch {
        }
    };
    return window.addEventListener(
      "tiptap-mention-inserted",
      ee
    ), () => window.removeEventListener(
      "tiptap-mention-inserted",
      ee
    );
  }, [g]), C.useEffect(() => {
    if (Array.isArray(s))
      try {
        const ee = JSON.stringify(B || []), ge = JSON.stringify(s || []);
        ee !== ge && G(s || []);
      } catch {
        G(s || []);
      }
  }, [s]), C.useEffect(() => {
    he(t ?? "");
  }, [t]), C.useEffect(() => {
    if (_)
      try {
        const ee = _.getText(), ge = t ?? "";
        if (ee !== ge) {
          if (ne.current && Math.abs(ee.length - ge.length) < 5)
            return;
          ne.current = !1, _.commands.setContent(ge), _.commands.focus("end");
        }
      } catch {
      }
  }, [_, t]);
  const Se = (ee) => {
    G(ee), o && o(ee);
  };
  C.useEffect(() => {
    if (_ && _.view)
      try {
        _.commands.focus();
      } catch {
      }
  }, [_]), C.useEffect(() => {
    if (!_) return;
    const ee = _.view?.dom ?? null;
    if (!ee) return;
    const ge = 240;
    let re = null;
    const J = () => {
      try {
        ee.style.height = "auto";
        const be = ee.scrollHeight || ee.offsetHeight;
        be > ge ? (ee.style.height = `${ge}px`, ee.style.overflowY = "auto") : (ee.style.height = `${Math.max(48, be)}px`, ee.style.overflowY = "hidden");
      } catch {
      }
    }, xe = () => {
      try {
        re && window.cancelAnimationFrame(re), re = window.requestAnimationFrame(() => {
          re = null, J();
        });
      } catch {
        J();
      }
    };
    return _.on("update", xe), xe(), () => {
      try {
        _.off("update", xe);
      } catch {
      }
      try {
        re && window.cancelAnimationFrame(re);
      } catch {
      }
      try {
        ee && (ee.style.overflowY = "", ee.style.height = "");
      } catch {
      }
    };
  }, [_]), C.useEffect(() => {
    if (!m.value && _ && _.view)
      try {
        _.commands.focus();
      } catch {
      }
  }, [m.value, _]), C.useEffect(() => {
    if (_)
      try {
        _.setEditable(!m.value);
      } catch {
      }
  }, [_, m.value]);
  const W = {
    handleKeyDown: (ee) => {
    }
  };
  C.useEffect(() => {
    if (!_) return;
    const ee = () => {
      ne.current = !0;
      const ge = _.getText();
      he(ge), h.current = ge, u.current && (f.current && window.clearTimeout(f.current), f.current = window.setTimeout(() => {
        try {
          u.current?.(h.current);
        } catch {
        }
      }, 400)), !ie.current && ge.trim().length > 0 && (ie.current = !0, a && a());
      const re = [];
      _.state.doc.descendants((Ae) => (Ae.type && Ae.type.name === "mention" && re.push(Ae.attrs.label ?? Ae.attrs.id ?? ""), !0));
      const J = X.current || {}, xe = new Set(re);
      Object.values(J).forEach((Ae) => {
        if (!xe.has(Ae)) {
          try {
            b(Ae);
          } catch {
          }
          (async () => {
            try {
              const tt = await YIe(), Ge = new CustomEvent("mention-tools-fetched", {
                detail: tt
              });
              window.dispatchEvent(Ge);
            } catch {
            }
          })();
        }
      });
      const be = {};
      re.forEach((Ae, tt) => {
        be[String(tt)] = Ae;
      }), X.current = be;
    };
    return _.on("update", ee), () => {
      _.off("update", ee);
    };
  }, [_, n, a, b]);
  const Z = async () => {
    ne.current = !1, await sze({
      localValue: Y,
      isAIThinking: m.value,
      isListening: N,
      recognitionRef: M,
      editor: _,
      setHistory: O,
      setHistoryIndex: U,
      setLocalValue: he,
      setIsListening: P,
      setFiles: G,
      startedTypingRef: ie,
      onChange: n,
      onSend: r
    })();
  }, pe = oze({
    isListening: N,
    recognitionRef: M,
    setIsListening: P,
    onTranscript: (ee) => {
      if (_ && _.commands)
        try {
          _.commands.focus(), _.commands.insertContent(ee);
        } catch (ge) {
          console.error("Error inserting speech text:", ge);
        }
      he((ge) => {
        const re = ge + ee;
        return h.current = re, u.current && (f.current && window.clearTimeout(f.current), f.current = window.setTimeout(() => {
          try {
            u.current?.(h.current);
          } catch {
          }
        }, 400)), re;
      });
    },
    language: "en-US"
    // change to "vi-VN" if you want Vietnamese
  }), F = (ee) => {
    const ge = B.filter((re, J) => J !== ee);
    G(ge);
  };
  return C.useEffect(() => {
    const ee = document.createElement("style");
    return ee.innerHTML = `
      .ProseMirror, .ProseMirror * {
        user-select: text !important;
        -webkit-user-select: text !important;
      }
      .ProseMirror p.is-editor-empty:first-child::before {
        content: attr(data-placeholder);
        float: left;
        color: #6b7280;
        pointer-events: none;
        height: 0;
      }
    `, document.head.appendChild(ee), () => {
      document.head.removeChild(ee);
    };
  }, []), C.useEffect(() => {
    if (!_) return;
    const ee = _.view?.dom;
    if (!ee) return;
    const ge = (re) => {
    };
    return ee.addEventListener("paste", ge), () => {
      ee.removeEventListener("paste", ge);
    };
  }, [_]), C.useEffect(() => {
    if (!_) return;
    const ee = (ge) => {
      const re = ge?.detail;
      if (re && _.isEditable)
        try {
          const J = (() => {
            try {
              return new URLSearchParams(window.location.search).get("version_id");
            } catch {
              return null;
            }
          })(), xe = re.position, be = _.view, Ae = xe && be?.posAtCoords ? be.posAtCoords({ left: xe.x, top: xe.y }) : null, tt = Ae && typeof Ae.pos == "number" ? Ae.pos : _.state.selection.from, Ge = re.entities || (re.id && re.name ? [{ id: re.id, name: re.name, classUri: re.classUri, versionId: re.versionId }] : []);
          if (Ge.length === 0) return;
          const nt = [];
          Ge.forEach((_t, yn) => {
            nt.push({
              type: "entity",
              attrs: {
                id: _t.id,
                name: _t.name,
                classUri: _t.classUri ?? null,
                versionId: _t.versionId ?? J ?? null
              }
            }), nt.push({ type: "text", text: " " });
          }), _.chain().focus().insertContentAt(tt, nt).run();
        } catch {
        }
    };
    return window.addEventListener(K0.HandlePromptUserInputChatbot, ee), () => window.removeEventListener(K0.HandlePromptUserInputChatbot, ee);
  }, [_]), /* @__PURE__ */ v.jsxs(
    "div",
    {
      ref: w,
      className: `w-full border-t dark:bg-neutral-700 bg-neutral-200 backdrop-blur-md shadow-xl dark:border-0 p-2 flex flex-col gap-2 transition-all ${S ? "ring-4 ring-blue-500 ring-inset bg-blue-50 dark:bg-blue-950/30" : ""}`,
      children: [
        /* @__PURE__ */ v.jsxs("div", { className: "flex-1 flex flex-col", children: [
          B.length > 0 && /* @__PURE__ */ v.jsx("div", { className: "flex mt-1 w-full flex-wrap gap-2 max-h-32 overflow-y-auto wrap-break-word p-2", children: B.map((ee, ge) => /* @__PURE__ */ v.jsxs(
            Dh,
            {
              variant: "outline",
              className: "flex items-center justify-between gap-2 text-sm py-1 bg-background/50 dark:bg-neutral-800 rounded-md px-2 border",
              children: [
                /* @__PURE__ */ v.jsxs("div", { className: "truncate flex items-baseline gap-2", children: [
                  /* @__PURE__ */ v.jsx("div", { className: "font-medium", children: ee.name }),
                  ee.size && /* @__PURE__ */ v.jsx("div", { className: "text-xs text-neutral-500", children: JIe(ee.size) })
                ] }),
                /* @__PURE__ */ v.jsx(
                  "button",
                  {
                    onClick: () => F(ge),
                    title: "Remove",
                    className: "cursor-pointer text-neutral-400 hover:text-red-500 p-1",
                    children: /* @__PURE__ */ v.jsx(Rg, { className: "h-4 w-4" })
                  }
                )
              ]
            },
            ge
          )) }),
          /* @__PURE__ */ v.jsx("div", { className: "relative", children: ((ge) => !!ge && typeof ge.state == "object" && typeof ge.commands == "object")(_) ? /* @__PURE__ */ v.jsx(
            hq,
            {
              editor: _,
              tabIndex: 0,
              onCopy: (ge) => {
                ge.stopPropagation();
              },
              onCut: (ge) => {
                ge.stopPropagation();
              },
              onPaste: (ge) => {
                ge.stopPropagation();
              },
              onKeyDown: (ge) => {
                const re = ge.key?.toLowerCase();
                if ((ge.ctrlKey || ge.metaKey) && (re === "c" || re === "x" || re === "v" || re === "a")) {
                  ge.stopPropagation();
                  return;
                }
                try {
                  W.handleKeyDown(ge);
                } catch {
                }
                const xe = XIe({
                  localValue: Y,
                  history: I,
                  historyIndex: L,
                  setHistoryIndex: U,
                  setLocalValue: he,
                  onChange: n,
                  doSendAndClear: Z,
                  mention: { handleKeyDown: W.handleKeyDown }
                });
                try {
                  xe(ge);
                } catch {
                }
              },
              "data-chatbot-text": "chatbot-input"
            }
          ) : null })
        ] }),
        /* @__PURE__ */ v.jsxs("div", { className: "flex flex-row items-center gap-2", children: [
          /* @__PURE__ */ v.jsx(
            ize,
            {
              className: "mx-1",
              align: "start",
              side: "top",
              mentions: []
            }
          ),
          /* @__PURE__ */ v.jsxs("div", { className: "flex flex-row items-center gap-2 ml-auto", children: [
            /* @__PURE__ */ v.jsx(
              BMe,
              {
                files: B,
                onFilesChange: Se,
                isAIThinking: m.value
              }
            ),
            /* @__PURE__ */ v.jsx(
              Ht,
              {
                size: "icon",
                variant: "ghost",
                onClick: pe,
                type: "button",
                disabled: !Hq || m.value,
                "aria-pressed": N,
                title: N ? "Stop voice" : "Start voice",
                className: N ? "cursor-pointer  bg-neutral-200 dark:bg-neutral-800 text-red-500 dark:text-red-400" : "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
                children: N ? /* @__PURE__ */ v.jsx(mY, { className: "h-5 w-5" }) : /* @__PURE__ */ v.jsx(yY, { className: "h-5 w-5" })
              }
            ),
            /* @__PURE__ */ v.jsxs(Qu, { children: [
              /* @__PURE__ */ v.jsx(ed, { asChild: !0, children: /* @__PURE__ */ v.jsx(
                Ht,
                {
                  size: "icon",
                  variant: "ghost",
                  disabled: m.value,
                  title: "Using next suggestion",
                  className: "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
                  children: /* @__PURE__ */ v.jsx(uY, { className: "h-5 w-5" })
                }
              ) }),
              /* @__PURE__ */ v.jsx(td, { align: "end", side: "top", className: "w-72", children: /* @__PURE__ */ v.jsxs(
                ls,
                {
                  onSelect: (ee) => ee.preventDefault(),
                  className: "flex items-center justify-between gap-3 cursor-pointer px-3 py-2",
                  children: [
                    /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2", children: [
                      /* @__PURE__ */ v.jsx(tY, { className: "h-4 w-4 text-amber-500 shrink-0" }),
                      /* @__PURE__ */ v.jsx("span", { className: "text-sm font-medium whitespace-nowrap", children: "Using next suggestion" })
                    ] }),
                    /* @__PURE__ */ v.jsx(
                      nH,
                      {
                        checked: H,
                        onCheckedChange: (ee) => Q(ee),
                        className: "shrink-0"
                      }
                    )
                  ]
                }
              ) })
            ] }),
            m.value ? /* @__PURE__ */ v.jsx(
              Ht,
              {
                size: "icon",
                className: "cursor-pointer rounded-full bg-red-900 text-white hover:bg-blue-600 transition-colors shadow-md dark:bg-red-900 dark:hover:bg-neutral-800",
                onClick: i,
                disabled: !m.value,
                title: "Stop thinking",
                children: /* @__PURE__ */ v.jsx(xY, { className: "h-5 w-5" })
              }
            ) : /* @__PURE__ */ v.jsx(
              Ht,
              {
                size: "icon",
                className: "cursor-pointer rounded-full bg-blue-500 text-white hover:bg-blue-600 transition-colors shadow-md dark:bg-green-500 dark:hover:bg-neutral-800",
                onClick: Z,
                disabled: m.value || !(Y || "").trim(),
                title: "Send (Ctrl+End)",
                children: /* @__PURE__ */ v.jsx(RY, { className: "h-5 w-5" })
              }
            )
          ] })
        ] })
      ]
    }
  );
}
function t3() {
  return /* @__PURE__ */ v.jsxs("div", { className: "flex items-center gap-2 text-muted-foreground text-xs px-6 py-2 mt-1", children: [
    /* @__PURE__ */ v.jsx(HT, { className: "h-4 w-4 text-blue-400 dark:text-[#1abcfe] animate-pulse" }),
    /* @__PURE__ */ v.jsx("span", { className: "animate-pulse", children: "Thinking" })
  ] });
}
const aze = ({
  error: e
}) => {
  const [t, n] = C.useState(!1), r = e?.message ?? "Unknown error", i = r.length > 200 ? r.slice(0, 200) + "" : r;
  return /* @__PURE__ */ v.jsx("div", { className: "w-full mx-auto max-w-2xl px-4 mt-6", children: /* @__PURE__ */ v.jsxs("div", { className: "flex items-start gap-3 bg-stone-50 dark:bg-stone-800/30 border border-stone-200 dark:border-stone-700 rounded-xl p-4 shadow-sm", children: [
    /* @__PURE__ */ v.jsx("div", { className: "flex-shrink-0 mt-1", children: /* @__PURE__ */ v.jsx(GY, { className: "h-6 w-6 text-amber-500" }) }),
    /* @__PURE__ */ v.jsxs("div", { className: "flex-1 min-w-0", children: [
      /* @__PURE__ */ v.jsx("div", { className: "font-semibold text-stone-800 dark:text-stone-200 mb-1", children: "Oops! Something went wrong" }),
      /* @__PURE__ */ v.jsx("div", { className: "whitespace-pre-wrap break-words text-stone-700 dark:text-stone-300 text-sm leading-relaxed", children: t ? r : i }),
      r.length > 200 && /* @__PURE__ */ v.jsx(
        "button",
        {
          className: "mt-2 text-xs text-blue-600 dark:text-blue-400 underline hover:opacity-80",
          onClick: () => n((o) => !o),
          children: t ? "Show less" : "Show more"
        }
      ),
      /* @__PURE__ */ v.jsx("div", { className: "mt-3 text-xs text-stone-500 dark:text-stone-400", children: "Try refreshing the page or checking your connection. If the problem keeps happening, please contact support." })
    ] })
  ] }) });
}, lze = (e, t) => {
  t(e ?? ""), setTimeout(() => {
    const n = document.querySelector(
      'div[data-chatbot-text="chatbot-input"]'
    );
    if (n && n.focus)
      try {
        n.focus();
      } catch {
      }
  }, 100);
}, a1 = C.createContext(null);
a1.displayName = "PanelGroupContext";
const ir = {
  group: "data-panel-group",
  groupDirection: "data-panel-group-direction",
  groupId: "data-panel-group-id",
  panel: "data-panel",
  panelCollapsible: "data-panel-collapsible",
  panelId: "data-panel-id",
  panelSize: "data-panel-size",
  resizeHandle: "data-resize-handle",
  resizeHandleActive: "data-resize-handle-active",
  resizeHandleEnabled: "data-panel-resize-handle-enabled",
  resizeHandleId: "data-panel-resize-handle-id",
  resizeHandleState: "data-resize-handle-state"
}, eR = 10, Gu = C.useLayoutEffect, n3 = Fx.useId, cze = typeof n3 == "function" ? n3 : () => null;
let uze = 0;
function tR(e = null) {
  const t = cze(), n = C.useRef(e || t || null);
  return n.current === null && (n.current = "" + uze++), e ?? n.current;
}
function Wq({
  children: e,
  className: t = "",
  collapsedSize: n,
  collapsible: r,
  defaultSize: i,
  forwardedRef: o,
  id: s,
  maxSize: a,
  minSize: c,
  onCollapse: u,
  onExpand: f,
  onResize: h,
  order: m,
  style: g,
  tagName: b = "div",
  ...x
}) {
  const w = C.useContext(a1);
  if (w === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    collapsePanel: S,
    expandPanel: _,
    getPanelSize: M,
    getPanelStyle: N,
    groupId: P,
    isPanelCollapsed: I,
    reevaluatePanelConstraints: O,
    registerPanel: L,
    resizePanel: U,
    unregisterPanel: B
  } = w, G = tR(s), Y = C.useRef({
    callbacks: {
      onCollapse: u,
      onExpand: f,
      onResize: h
    },
    constraints: {
      collapsedSize: n,
      collapsible: r,
      defaultSize: i,
      maxSize: a,
      minSize: c
    },
    id: G,
    idIsFromProps: s !== void 0,
    order: m
  });
  C.useRef({
    didLogMissingDefaultSizeWarning: !1
  }), Gu(() => {
    const {
      callbacks: ie,
      constraints: ne
    } = Y.current, H = {
      ...ne
    };
    Y.current.id = G, Y.current.idIsFromProps = s !== void 0, Y.current.order = m, ie.onCollapse = u, ie.onExpand = f, ie.onResize = h, ne.collapsedSize = n, ne.collapsible = r, ne.defaultSize = i, ne.maxSize = a, ne.minSize = c, (H.collapsedSize !== ne.collapsedSize || H.collapsible !== ne.collapsible || H.maxSize !== ne.maxSize || H.minSize !== ne.minSize) && O(Y.current, H);
  }), Gu(() => {
    const ie = Y.current;
    return L(ie), () => {
      B(ie);
    };
  }, [m, G, L, B]), C.useImperativeHandle(o, () => ({
    collapse: () => {
      S(Y.current);
    },
    expand: (ie) => {
      _(Y.current, ie);
    },
    getId() {
      return G;
    },
    getSize() {
      return M(Y.current);
    },
    isCollapsed() {
      return I(Y.current);
    },
    isExpanded() {
      return !I(Y.current);
    },
    resize: (ie) => {
      U(Y.current, ie);
    }
  }), [S, _, M, I, G, U]);
  const he = N(Y.current, i);
  return C.createElement(b, {
    ...x,
    children: e,
    className: t,
    id: G,
    style: {
      ...he,
      ...g
    },
    // CSS selectors
    [ir.groupId]: P,
    [ir.panel]: "",
    [ir.panelCollapsible]: r || void 0,
    [ir.panelId]: G,
    [ir.panelSize]: parseFloat("" + he.flexGrow).toFixed(1)
  });
}
const qq = C.forwardRef((e, t) => C.createElement(Wq, {
  ...e,
  forwardedRef: t
}));
Wq.displayName = "Panel";
qq.displayName = "forwardRef(Panel)";
let $T = null, Z0 = -1, sc = null;
function dze(e, t, n) {
  const r = (t & Xq) !== 0, i = (t & Jq) !== 0, o = (t & Qq) !== 0, s = (t & eG) !== 0;
  if (t) {
    if (r)
      return o ? "se-resize" : s ? "ne-resize" : "e-resize";
    if (i)
      return o ? "sw-resize" : s ? "nw-resize" : "w-resize";
    if (o)
      return "s-resize";
    if (s)
      return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function fze() {
  sc !== null && (document.head.removeChild(sc), $T = null, sc = null, Z0 = -1);
}
function yE(e, t, n) {
  var r, i;
  const o = dze(e, t);
  if ($T !== o) {
    if ($T = o, sc === null && (sc = document.createElement("style"), document.head.appendChild(sc)), Z0 >= 0) {
      var s;
      (s = sc.sheet) === null || s === void 0 || s.removeRule(Z0);
    }
    Z0 = (r = (i = sc.sheet) === null || i === void 0 ? void 0 : i.insertRule(`*{cursor: ${o} !important;}`)) !== null && r !== void 0 ? r : -1;
  }
}
function Gq(e) {
  return e.type === "keydown";
}
function Kq(e) {
  return e.type.startsWith("pointer");
}
function Zq(e) {
  return e.type.startsWith("mouse");
}
function l1(e) {
  if (Kq(e)) {
    if (e.isPrimary)
      return {
        x: e.clientX,
        y: e.clientY
      };
  } else if (Zq(e))
    return {
      x: e.clientX,
      y: e.clientY
    };
  return {
    x: 1 / 0,
    y: 1 / 0
  };
}
function hze() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
function pze(e, t, n) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function mze(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: o3(e),
    b: o3(t)
  };
  let r;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), r = e;
  It(r, "Stacking order can only be calculated for elements with a common ancestor");
  const i = {
    a: i3(r3(n.a)),
    b: i3(r3(n.b))
  };
  if (i.a === i.b) {
    const o = r.childNodes, s = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let a = o.length;
    for (; a--; ) {
      const c = o[a];
      if (c === s.a) return 1;
      if (c === s.b) return -1;
    }
  }
  return Math.sign(i.a - i.b);
}
const gze = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function yze(e) {
  var t;
  const n = getComputedStyle((t = Yq(e)) !== null && t !== void 0 ? t : e).display;
  return n === "flex" || n === "inline-flex";
}
function vze(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || yze(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || gze.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function r3(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (It(n, "Missing node"), vze(n)) return n;
  }
  return null;
}
function i3(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function o3(e) {
  const t = [];
  for (; e; )
    t.push(e), e = Yq(e);
  return t;
}
function Yq(e) {
  const {
    parentNode: t
  } = e;
  return t && t instanceof ShadowRoot ? t.host : t;
}
const Xq = 1, Jq = 2, Qq = 4, eG = 8, bze = hze() === "coarse";
let ds = [], th = !1, ac = /* @__PURE__ */ new Map(), c1 = /* @__PURE__ */ new Map();
const Tg = /* @__PURE__ */ new Set();
function xze(e, t, n, r, i) {
  var o;
  const {
    ownerDocument: s
  } = t, a = {
    direction: n,
    element: t,
    hitAreaMargins: r,
    setResizeHandlerState: i
  }, c = (o = ac.get(s)) !== null && o !== void 0 ? o : 0;
  return ac.set(s, c + 1), Tg.add(a), $x(), function() {
    var f;
    c1.delete(e), Tg.delete(a);
    const h = (f = ac.get(s)) !== null && f !== void 0 ? f : 1;
    if (ac.set(s, h - 1), $x(), h === 1 && ac.delete(s), ds.includes(a)) {
      const m = ds.indexOf(a);
      m >= 0 && ds.splice(m, 1), u1(), i("up", !0, null);
    }
  };
}
function wze(e) {
  const {
    target: t
  } = e, {
    x: n,
    y: r
  } = l1(e);
  th = !0, nR({
    target: t,
    x: n,
    y: r
  }), $x(), ds.length > 0 && (Ux("down", e), u1(), e.preventDefault(), tG(t) || e.stopImmediatePropagation());
}
function vE(e) {
  const {
    x: t,
    y: n
  } = l1(e);
  if (th && // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
  e.type !== "pointerleave" && e.buttons === 0 && (th = !1, Ux("up", e)), !th) {
    const {
      target: r
    } = e;
    nR({
      target: r,
      x: t,
      y: n
    });
  }
  Ux("move", e), u1(), ds.length > 0 && e.preventDefault();
}
function bE(e) {
  const {
    target: t
  } = e, {
    x: n,
    y: r
  } = l1(e);
  c1.clear(), th = !1, ds.length > 0 && (e.preventDefault(), tG(t) || e.stopImmediatePropagation()), Ux("up", e), nR({
    target: t,
    x: n,
    y: r
  }), u1(), $x();
}
function tG(e) {
  let t = e;
  for (; t; ) {
    if (t.hasAttribute(ir.resizeHandle))
      return !0;
    t = t.parentElement;
  }
  return !1;
}
function nR({
  target: e,
  x: t,
  y: n
}) {
  ds.splice(0);
  let r = null;
  (e instanceof HTMLElement || e instanceof SVGElement) && (r = e), Tg.forEach((i) => {
    const {
      element: o,
      hitAreaMargins: s
    } = i, a = o.getBoundingClientRect(), {
      bottom: c,
      left: u,
      right: f,
      top: h
    } = a, m = bze ? s.coarse : s.fine;
    if (t >= u - m && t <= f + m && n >= h - m && n <= c + m) {
      if (r !== null && document.contains(r) && o !== r && !o.contains(r) && !r.contains(o) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      mze(r, o) > 0) {
        let b = r, x = !1;
        for (; b && !b.contains(o); ) {
          if (pze(b.getBoundingClientRect(), a)) {
            x = !0;
            break;
          }
          b = b.parentElement;
        }
        if (x)
          return;
      }
      ds.push(i);
    }
  });
}
function xE(e, t) {
  c1.set(e, t);
}
function u1() {
  let e = !1, t = !1;
  ds.forEach((r) => {
    const {
      direction: i
    } = r;
    i === "horizontal" ? e = !0 : t = !0;
  });
  let n = 0;
  c1.forEach((r) => {
    n |= r;
  }), e && t ? yE("intersection", n) : e ? yE("horizontal", n) : t ? yE("vertical", n) : fze();
}
let wE;
function $x() {
  var e;
  (e = wE) === null || e === void 0 || e.abort(), wE = new AbortController();
  const t = {
    capture: !0,
    signal: wE.signal
  };
  Tg.size && (th ? (ds.length > 0 && ac.forEach((n, r) => {
    const {
      body: i
    } = r;
    n > 0 && (i.addEventListener("contextmenu", bE, t), i.addEventListener("pointerleave", vE, t), i.addEventListener("pointermove", vE, t));
  }), ac.forEach((n, r) => {
    const {
      body: i
    } = r;
    i.addEventListener("pointerup", bE, t), i.addEventListener("pointercancel", bE, t);
  })) : ac.forEach((n, r) => {
    const {
      body: i
    } = r;
    n > 0 && (i.addEventListener("pointerdown", wze, t), i.addEventListener("pointermove", vE, t));
  }));
}
function Ux(e, t) {
  Tg.forEach((n) => {
    const {
      setResizeHandlerState: r
    } = n, i = ds.includes(n);
    r(e, i, t);
  });
}
function Sze() {
  const [e, t] = C.useState(0);
  return C.useCallback(() => t((n) => n + 1), []);
}
function It(e, t) {
  if (!e)
    throw console.error(t), Error(t);
}
function ld(e, t, n = eR) {
  return e.toFixed(n) === t.toFixed(n) ? 0 : e > t ? 1 : -1;
}
function Fa(e, t, n = eR) {
  return ld(e, t, n) === 0;
}
function lo(e, t, n) {
  return ld(e, t, n) === 0;
}
function kze(e, t, n) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++) {
    const i = e[r], o = t[r];
    if (!lo(i, o, n))
      return !1;
  }
  return !0;
}
function Vf({
  panelConstraints: e,
  panelIndex: t,
  size: n
}) {
  const r = e[t];
  It(r != null, `Panel constraints not found for index ${t}`);
  let {
    collapsedSize: i = 0,
    collapsible: o,
    maxSize: s = 100,
    minSize: a = 0
  } = r;
  if (ld(n, a) < 0)
    if (o) {
      const c = (i + a) / 2;
      ld(n, c) < 0 ? n = i : n = a;
    } else
      n = a;
  return n = Math.min(s, n), n = parseFloat(n.toFixed(eR)), n;
}
function xm({
  delta: e,
  initialLayout: t,
  panelConstraints: n,
  pivotIndices: r,
  prevLayout: i,
  trigger: o
}) {
  if (lo(e, 0))
    return t;
  const s = [...t], [a, c] = r;
  It(a != null, "Invalid first pivot index"), It(c != null, "Invalid second pivot index");
  let u = 0;
  if (o === "keyboard") {
    {
      const h = e < 0 ? c : a, m = n[h];
      It(m, `Panel constraints not found for index ${h}`);
      const {
        collapsedSize: g = 0,
        collapsible: b,
        minSize: x = 0
      } = m;
      if (b) {
        const w = t[h];
        if (It(w != null, `Previous layout not found for panel index ${h}`), lo(w, g)) {
          const S = x - w;
          ld(S, Math.abs(e)) > 0 && (e = e < 0 ? 0 - S : S);
        }
      }
    }
    {
      const h = e < 0 ? a : c, m = n[h];
      It(m, `No panel constraints found for index ${h}`);
      const {
        collapsedSize: g = 0,
        collapsible: b,
        minSize: x = 0
      } = m;
      if (b) {
        const w = t[h];
        if (It(w != null, `Previous layout not found for panel index ${h}`), lo(w, x)) {
          const S = w - g;
          ld(S, Math.abs(e)) > 0 && (e = e < 0 ? 0 - S : S);
        }
      }
    }
  }
  {
    const h = e < 0 ? 1 : -1;
    let m = e < 0 ? c : a, g = 0;
    for (; ; ) {
      const x = t[m];
      It(x != null, `Previous layout not found for panel index ${m}`);
      const S = Vf({
        panelConstraints: n,
        panelIndex: m,
        size: 100
      }) - x;
      if (g += S, m += h, m < 0 || m >= n.length)
        break;
    }
    const b = Math.min(Math.abs(e), Math.abs(g));
    e = e < 0 ? 0 - b : b;
  }
  {
    let m = e < 0 ? a : c;
    for (; m >= 0 && m < n.length; ) {
      const g = Math.abs(e) - Math.abs(u), b = t[m];
      It(b != null, `Previous layout not found for panel index ${m}`);
      const x = b - g, w = Vf({
        panelConstraints: n,
        panelIndex: m,
        size: x
      });
      if (!lo(b, w) && (u += b - w, s[m] = w, u.toFixed(3).localeCompare(Math.abs(e).toFixed(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? m-- : m++;
    }
  }
  if (kze(i, s))
    return i;
  {
    const h = e < 0 ? c : a, m = t[h];
    It(m != null, `Previous layout not found for panel index ${h}`);
    const g = m + u, b = Vf({
      panelConstraints: n,
      panelIndex: h,
      size: g
    });
    if (s[h] = b, !lo(b, g)) {
      let x = g - b, S = e < 0 ? c : a;
      for (; S >= 0 && S < n.length; ) {
        const _ = s[S];
        It(_ != null, `Previous layout not found for panel index ${S}`);
        const M = _ + x, N = Vf({
          panelConstraints: n,
          panelIndex: S,
          size: M
        });
        if (lo(_, N) || (x -= N - _, s[S] = N), lo(x, 0))
          break;
        e > 0 ? S-- : S++;
      }
    }
  }
  const f = s.reduce((h, m) => m + h, 0);
  return lo(f, 100) ? s : i;
}
function Cze({
  layout: e,
  panelsArray: t,
  pivotIndices: n
}) {
  let r = 0, i = 100, o = 0, s = 0;
  const a = n[0];
  It(a != null, "No pivot index found"), t.forEach((h, m) => {
    const {
      constraints: g
    } = h, {
      maxSize: b = 100,
      minSize: x = 0
    } = g;
    m === a ? (r = x, i = b) : (o += x, s += b);
  });
  const c = Math.min(i, 100 - o), u = Math.max(r, 100 - s), f = e[a];
  return {
    valueMax: c,
    valueMin: u,
    valueNow: f
  };
}
function Ag(e, t = document) {
  return Array.from(t.querySelectorAll(`[${ir.resizeHandleId}][data-panel-group-id="${e}"]`));
}
function nG(e, t, n = document) {
  const i = Ag(e, n).findIndex((o) => o.getAttribute(ir.resizeHandleId) === t);
  return i ?? null;
}
function rG(e, t, n) {
  const r = nG(e, t, n);
  return r != null ? [r, r + 1] : [-1, -1];
}
function Eze(e) {
  return e instanceof HTMLElement ? !0 : typeof e == "object" && e !== null && "tagName" in e && "getAttribute" in e;
}
function iG(e, t = document) {
  if (Eze(t) && t.dataset.panelGroupId == e)
    return t;
  const n = t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return n || null;
}
function d1(e, t = document) {
  const n = t.querySelector(`[${ir.resizeHandleId}="${e}"]`);
  return n || null;
}
function _ze(e, t, n, r = document) {
  var i, o, s, a;
  const c = d1(t, r), u = Ag(e, r), f = c ? u.indexOf(c) : -1, h = (i = (o = n[f]) === null || o === void 0 ? void 0 : o.id) !== null && i !== void 0 ? i : null, m = (s = (a = n[f + 1]) === null || a === void 0 ? void 0 : a.id) !== null && s !== void 0 ? s : null;
  return [h, m];
}
function Tze({
  committedValuesRef: e,
  eagerValuesRef: t,
  groupId: n,
  layout: r,
  panelDataArray: i,
  panelGroupElement: o,
  setLayout: s
}) {
  C.useRef({
    didWarnAboutMissingResizeHandle: !1
  }), Gu(() => {
    if (!o)
      return;
    const a = Ag(n, o);
    for (let c = 0; c < i.length - 1; c++) {
      const {
        valueMax: u,
        valueMin: f,
        valueNow: h
      } = Cze({
        layout: r,
        panelsArray: i,
        pivotIndices: [c, c + 1]
      }), m = a[c];
      if (m != null) {
        const g = i[c];
        It(g, `No panel data found for index "${c}"`), m.setAttribute("aria-controls", g.id), m.setAttribute("aria-valuemax", "" + Math.round(u)), m.setAttribute("aria-valuemin", "" + Math.round(f)), m.setAttribute("aria-valuenow", h != null ? "" + Math.round(h) : "");
      }
    }
    return () => {
      a.forEach((c, u) => {
        c.removeAttribute("aria-controls"), c.removeAttribute("aria-valuemax"), c.removeAttribute("aria-valuemin"), c.removeAttribute("aria-valuenow");
      });
    };
  }, [n, r, i, o]), C.useEffect(() => {
    if (!o)
      return;
    const a = t.current;
    It(a, "Eager values not found");
    const {
      panelDataArray: c
    } = a, u = iG(n, o);
    It(u != null, `No group found for id "${n}"`);
    const f = Ag(n, o);
    It(f, `No resize handles found for group id "${n}"`);
    const h = f.map((m) => {
      const g = m.getAttribute(ir.resizeHandleId);
      It(g, "Resize handle element has no handle id attribute");
      const [b, x] = _ze(n, g, c, o);
      if (b == null || x == null)
        return () => {
        };
      const w = (S) => {
        if (!S.defaultPrevented)
          switch (S.key) {
            case "Enter": {
              S.preventDefault();
              const _ = c.findIndex((M) => M.id === b);
              if (_ >= 0) {
                const M = c[_];
                It(M, `No panel data found for index ${_}`);
                const N = r[_], {
                  collapsedSize: P = 0,
                  collapsible: I,
                  minSize: O = 0
                } = M.constraints;
                if (N != null && I) {
                  const L = xm({
                    delta: lo(N, P) ? O - P : P - N,
                    initialLayout: r,
                    panelConstraints: c.map((U) => U.constraints),
                    pivotIndices: rG(n, g, o),
                    prevLayout: r,
                    trigger: "keyboard"
                  });
                  r !== L && s(L);
                }
              }
              break;
            }
          }
      };
      return m.addEventListener("keydown", w), () => {
        m.removeEventListener("keydown", w);
      };
    });
    return () => {
      h.forEach((m) => m());
    };
  }, [o, e, t, n, r, i, s]);
}
function s3(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function oG(e, t) {
  const n = e === "horizontal", {
    x: r,
    y: i
  } = l1(t);
  return n ? r : i;
}
function Aze(e, t, n, r, i) {
  const o = n === "horizontal", s = d1(t, i);
  It(s, `No resize handle element found for id "${t}"`);
  const a = s.getAttribute(ir.groupId);
  It(a, "Resize handle element has no group id attribute");
  let {
    initialCursorPosition: c
  } = r;
  const u = oG(n, e), f = iG(a, i);
  It(f, `No group element found for id "${a}"`);
  const h = f.getBoundingClientRect(), m = o ? h.width : h.height;
  return (u - c) / m * 100;
}
function Mze(e, t, n, r, i, o) {
  if (Gq(e)) {
    const s = n === "horizontal";
    let a = 0;
    e.shiftKey ? a = 100 : i != null ? a = i : a = 10;
    let c = 0;
    switch (e.key) {
      case "ArrowDown":
        c = s ? 0 : a;
        break;
      case "ArrowLeft":
        c = s ? -a : 0;
        break;
      case "ArrowRight":
        c = s ? a : 0;
        break;
      case "ArrowUp":
        c = s ? 0 : -a;
        break;
      case "End":
        c = 100;
        break;
      case "Home":
        c = -100;
        break;
    }
    return c;
  } else
    return r == null ? 0 : Aze(e, t, n, r, o);
}
function Nze({
  panelDataArray: e
}) {
  const t = Array(e.length), n = e.map((o) => o.constraints);
  let r = 0, i = 100;
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    It(s, `Panel constraints not found for index ${o}`);
    const {
      defaultSize: a
    } = s;
    a != null && (r++, t[o] = a, i -= a);
  }
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    It(s, `Panel constraints not found for index ${o}`);
    const {
      defaultSize: a
    } = s;
    if (a != null)
      continue;
    const c = e.length - r, u = i / c;
    r++, t[o] = u, i -= u;
  }
  return t;
}
function xf(e, t, n) {
  t.forEach((r, i) => {
    const o = e[i];
    It(o, `Panel data not found for index ${i}`);
    const {
      callbacks: s,
      constraints: a,
      id: c
    } = o, {
      collapsedSize: u = 0,
      collapsible: f
    } = a, h = n[c];
    if (h == null || r !== h) {
      n[c] = r;
      const {
        onCollapse: m,
        onExpand: g,
        onResize: b
      } = s;
      b && b(r, h), f && (m || g) && (g && (h == null || Fa(h, u)) && !Fa(r, u) && g(), m && (h == null || !Fa(h, u)) && Fa(r, u) && m());
    }
  });
}
function d0(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n])
      return !1;
  return !0;
}
function Rze({
  defaultSize: e,
  dragState: t,
  layout: n,
  panelData: r,
  panelIndex: i,
  precision: o = 3
}) {
  const s = n[i];
  let a;
  return s == null ? a = e != null ? e.toFixed(o) : "1" : r.length === 1 ? a = "1" : a = s.toFixed(o), {
    flexBasis: 0,
    flexGrow: a,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: t !== null ? "none" : void 0
  };
}
function Oze(e, t = 10) {
  let n = null;
  return (...i) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...i);
    }, t);
  };
}
function a3(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, n) => {
        localStorage.setItem(t, n);
      };
    else
      throw new Error("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function sG(e) {
  return `react-resizable-panels:${e}`;
}
function aG(e) {
  return e.map((t) => {
    const {
      constraints: n,
      id: r,
      idIsFromProps: i,
      order: o
    } = t;
    return i ? r : o ? `${o}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((t, n) => t.localeCompare(n)).join(",");
}
function lG(e, t) {
  try {
    const n = sG(e), r = t.getItem(n);
    if (r) {
      const i = JSON.parse(r);
      if (typeof i == "object" && i != null)
        return i;
    }
  } catch {
  }
  return null;
}
function Dze(e, t, n) {
  var r, i;
  const o = (r = lG(e, n)) !== null && r !== void 0 ? r : {}, s = aG(t);
  return (i = o[s]) !== null && i !== void 0 ? i : null;
}
function Pze(e, t, n, r, i) {
  var o;
  const s = sG(e), a = aG(t), c = (o = lG(e, i)) !== null && o !== void 0 ? o : {};
  c[a] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: r
  };
  try {
    i.setItem(s, JSON.stringify(c));
  } catch (u) {
    console.error(u);
  }
}
function l3({
  layout: e,
  panelConstraints: t
}) {
  const n = [...e], r = n.reduce((o, s) => o + s, 0);
  if (n.length !== t.length)
    throw Error(`Invalid ${t.length} panel layout: ${n.map((o) => `${o}%`).join(", ")}`);
  if (!lo(r, 100) && n.length > 0)
    for (let o = 0; o < t.length; o++) {
      const s = n[o];
      It(s != null, `No layout data found for index ${o}`);
      const a = 100 / r * s;
      n[o] = a;
    }
  let i = 0;
  for (let o = 0; o < t.length; o++) {
    const s = n[o];
    It(s != null, `No layout data found for index ${o}`);
    const a = Vf({
      panelConstraints: t,
      panelIndex: o,
      size: s
    });
    s != a && (i += s - a, n[o] = a);
  }
  if (!lo(i, 0))
    for (let o = 0; o < t.length; o++) {
      const s = n[o];
      It(s != null, `No layout data found for index ${o}`);
      const a = s + i, c = Vf({
        panelConstraints: t,
        panelIndex: o,
        size: a
      });
      if (s !== c && (i -= c - s, n[o] = c, lo(i, 0)))
        break;
    }
  return n;
}
const jze = 100, wm = {
  getItem: (e) => (a3(wm), wm.getItem(e)),
  setItem: (e, t) => {
    a3(wm), wm.setItem(e, t);
  }
}, c3 = {};
function cG({
  autoSaveId: e = null,
  children: t,
  className: n = "",
  direction: r,
  forwardedRef: i,
  id: o = null,
  onLayout: s = null,
  keyboardResizeBy: a = null,
  storage: c = wm,
  style: u,
  tagName: f = "div",
  ...h
}) {
  const m = tR(o), g = C.useRef(null), [b, x] = C.useState(null), [w, S] = C.useState([]), _ = Sze(), M = C.useRef({}), N = C.useRef(/* @__PURE__ */ new Map()), P = C.useRef(0), I = C.useRef({
    autoSaveId: e,
    direction: r,
    dragState: b,
    id: m,
    keyboardResizeBy: a,
    onLayout: s,
    storage: c
  }), O = C.useRef({
    layout: w,
    panelDataArray: [],
    panelDataArrayChanged: !1
  });
  C.useRef({
    didLogIdAndOrderWarning: !1,
    didLogPanelConstraintsWarning: !1,
    prevPanelIds: []
  }), C.useImperativeHandle(i, () => ({
    getId: () => I.current.id,
    getLayout: () => {
      const {
        layout: F
      } = O.current;
      return F;
    },
    setLayout: (F) => {
      const {
        onLayout: ee
      } = I.current, {
        layout: ge,
        panelDataArray: re
      } = O.current, J = l3({
        layout: F,
        panelConstraints: re.map((xe) => xe.constraints)
      });
      s3(ge, J) || (S(J), O.current.layout = J, ee && ee(J), xf(re, J, M.current));
    }
  }), []), Gu(() => {
    I.current.autoSaveId = e, I.current.direction = r, I.current.dragState = b, I.current.id = m, I.current.onLayout = s, I.current.storage = c;
  }), Tze({
    committedValuesRef: I,
    eagerValuesRef: O,
    groupId: m,
    layout: w,
    panelDataArray: O.current.panelDataArray,
    setLayout: S,
    panelGroupElement: g.current
  }), C.useEffect(() => {
    const {
      panelDataArray: F
    } = O.current;
    if (e) {
      if (w.length === 0 || w.length !== F.length)
        return;
      let ee = c3[e];
      ee == null && (ee = Oze(Pze, jze), c3[e] = ee);
      const ge = [...F], re = new Map(N.current);
      ee(e, ge, re, w, c);
    }
  }, [e, w, c]), C.useEffect(() => {
  });
  const L = C.useCallback((F) => {
    const {
      onLayout: ee
    } = I.current, {
      layout: ge,
      panelDataArray: re
    } = O.current;
    if (F.constraints.collapsible) {
      const J = re.map((tt) => tt.constraints), {
        collapsedSize: xe = 0,
        panelSize: be,
        pivotIndices: Ae
      } = _u(re, F, ge);
      if (It(be != null, `Panel size not found for panel "${F.id}"`), !Fa(be, xe)) {
        N.current.set(F.id, be);
        const Ge = Rf(re, F) === re.length - 1 ? be - xe : xe - be, nt = xm({
          delta: Ge,
          initialLayout: ge,
          panelConstraints: J,
          pivotIndices: Ae,
          prevLayout: ge,
          trigger: "imperative-api"
        });
        d0(ge, nt) || (S(nt), O.current.layout = nt, ee && ee(nt), xf(re, nt, M.current));
      }
    }
  }, []), U = C.useCallback((F, ee) => {
    const {
      onLayout: ge
    } = I.current, {
      layout: re,
      panelDataArray: J
    } = O.current;
    if (F.constraints.collapsible) {
      const xe = J.map((_t) => _t.constraints), {
        collapsedSize: be = 0,
        panelSize: Ae = 0,
        minSize: tt = 0,
        pivotIndices: Ge
      } = _u(J, F, re), nt = ee ?? tt;
      if (Fa(Ae, be)) {
        const _t = N.current.get(F.id), yn = _t != null && _t >= nt ? _t : nt, Vt = Rf(J, F) === J.length - 1 ? Ae - yn : yn - Ae, xt = xm({
          delta: Vt,
          initialLayout: re,
          panelConstraints: xe,
          pivotIndices: Ge,
          prevLayout: re,
          trigger: "imperative-api"
        });
        d0(re, xt) || (S(xt), O.current.layout = xt, ge && ge(xt), xf(J, xt, M.current));
      }
    }
  }, []), B = C.useCallback((F) => {
    const {
      layout: ee,
      panelDataArray: ge
    } = O.current, {
      panelSize: re
    } = _u(ge, F, ee);
    return It(re != null, `Panel size not found for panel "${F.id}"`), re;
  }, []), G = C.useCallback((F, ee) => {
    const {
      panelDataArray: ge
    } = O.current, re = Rf(ge, F);
    return Rze({
      defaultSize: ee,
      dragState: b,
      layout: w,
      panelData: ge,
      panelIndex: re
    });
  }, [b, w]), Y = C.useCallback((F) => {
    const {
      layout: ee,
      panelDataArray: ge
    } = O.current, {
      collapsedSize: re = 0,
      collapsible: J,
      panelSize: xe
    } = _u(ge, F, ee);
    return It(xe != null, `Panel size not found for panel "${F.id}"`), J === !0 && Fa(xe, re);
  }, []), he = C.useCallback((F) => {
    const {
      layout: ee,
      panelDataArray: ge
    } = O.current, {
      collapsedSize: re = 0,
      collapsible: J,
      panelSize: xe
    } = _u(ge, F, ee);
    return It(xe != null, `Panel size not found for panel "${F.id}"`), !J || ld(xe, re) > 0;
  }, []), ie = C.useCallback((F) => {
    const {
      panelDataArray: ee
    } = O.current;
    ee.push(F), ee.sort((ge, re) => {
      const J = ge.order, xe = re.order;
      return J == null && xe == null ? 0 : J == null ? -1 : xe == null ? 1 : J - xe;
    }), O.current.panelDataArrayChanged = !0, _();
  }, [_]);
  Gu(() => {
    if (O.current.panelDataArrayChanged) {
      O.current.panelDataArrayChanged = !1;
      const {
        autoSaveId: F,
        onLayout: ee,
        storage: ge
      } = I.current, {
        layout: re,
        panelDataArray: J
      } = O.current;
      let xe = null;
      if (F) {
        const Ae = Dze(F, J, ge);
        Ae && (N.current = new Map(Object.entries(Ae.expandToSizes)), xe = Ae.layout);
      }
      xe == null && (xe = Nze({
        panelDataArray: J
      }));
      const be = l3({
        layout: xe,
        panelConstraints: J.map((Ae) => Ae.constraints)
      });
      s3(re, be) || (S(be), O.current.layout = be, ee && ee(be), xf(J, be, M.current));
    }
  }), Gu(() => {
    const F = O.current;
    return () => {
      F.layout = [];
    };
  }, []);
  const ne = C.useCallback((F) => {
    let ee = !1;
    const ge = g.current;
    return ge && window.getComputedStyle(ge, null).getPropertyValue("direction") === "rtl" && (ee = !0), function(J) {
      J.preventDefault();
      const xe = g.current;
      if (!xe)
        return () => null;
      const {
        direction: be,
        dragState: Ae,
        id: tt,
        keyboardResizeBy: Ge,
        onLayout: nt
      } = I.current, {
        layout: _t,
        panelDataArray: yn
      } = O.current, {
        initialLayout: St
      } = Ae ?? {}, Vt = rG(tt, F, xe);
      let xt = Mze(J, F, be, Ae, Ge, xe);
      const Kt = be === "horizontal";
      Kt && ee && (xt = -xt);
      const An = yn.map((Pn) => Pn.constraints), Nt = xm({
        delta: xt,
        initialLayout: St ?? _t,
        panelConstraints: An,
        pivotIndices: Vt,
        prevLayout: _t,
        trigger: Gq(J) ? "keyboard" : "mouse-or-touch"
      }), sn = !d0(_t, Nt);
      (Kq(J) || Zq(J)) && P.current != xt && (P.current = xt, !sn && xt !== 0 ? Kt ? xE(F, xt < 0 ? Xq : Jq) : xE(F, xt < 0 ? Qq : eG) : xE(F, 0)), sn && (S(Nt), O.current.layout = Nt, nt && nt(Nt), xf(yn, Nt, M.current));
    };
  }, []), H = C.useCallback((F, ee) => {
    const {
      onLayout: ge
    } = I.current, {
      layout: re,
      panelDataArray: J
    } = O.current, xe = J.map((_t) => _t.constraints), {
      panelSize: be,
      pivotIndices: Ae
    } = _u(J, F, re);
    It(be != null, `Panel size not found for panel "${F.id}"`);
    const Ge = Rf(J, F) === J.length - 1 ? be - ee : ee - be, nt = xm({
      delta: Ge,
      initialLayout: re,
      panelConstraints: xe,
      pivotIndices: Ae,
      prevLayout: re,
      trigger: "imperative-api"
    });
    d0(re, nt) || (S(nt), O.current.layout = nt, ge && ge(nt), xf(J, nt, M.current));
  }, []), Q = C.useCallback((F, ee) => {
    const {
      layout: ge,
      panelDataArray: re
    } = O.current, {
      collapsedSize: J = 0,
      collapsible: xe
    } = ee, {
      collapsedSize: be = 0,
      collapsible: Ae,
      maxSize: tt = 100,
      minSize: Ge = 0
    } = F.constraints, {
      panelSize: nt
    } = _u(re, F, ge);
    nt != null && (xe && Ae && Fa(nt, J) ? Fa(J, be) || H(F, be) : nt < Ge ? H(F, Ge) : nt > tt && H(F, tt));
  }, [H]), X = C.useCallback((F, ee) => {
    const {
      direction: ge
    } = I.current, {
      layout: re
    } = O.current;
    if (!g.current)
      return;
    const J = d1(F, g.current);
    It(J, `Drag handle element not found for id "${F}"`);
    const xe = oG(ge, ee);
    x({
      dragHandleId: F,
      dragHandleRect: J.getBoundingClientRect(),
      initialCursorPosition: xe,
      initialLayout: re
    });
  }, []), Se = C.useCallback(() => {
    x(null);
  }, []), W = C.useCallback((F) => {
    const {
      panelDataArray: ee
    } = O.current, ge = Rf(ee, F);
    ge >= 0 && (ee.splice(ge, 1), delete M.current[F.id], O.current.panelDataArrayChanged = !0, _());
  }, [_]), Z = C.useMemo(() => ({
    collapsePanel: L,
    direction: r,
    dragState: b,
    expandPanel: U,
    getPanelSize: B,
    getPanelStyle: G,
    groupId: m,
    isPanelCollapsed: Y,
    isPanelExpanded: he,
    reevaluatePanelConstraints: Q,
    registerPanel: ie,
    registerResizeHandle: ne,
    resizePanel: H,
    startDragging: X,
    stopDragging: Se,
    unregisterPanel: W,
    panelGroupElement: g.current
  }), [L, b, r, U, B, G, m, Y, he, Q, ie, ne, H, X, Se, W]), pe = {
    display: "flex",
    flexDirection: r === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return C.createElement(a1.Provider, {
    value: Z
  }, C.createElement(f, {
    ...h,
    children: t,
    className: n,
    id: o,
    ref: g,
    style: {
      ...pe,
      ...u
    },
    // CSS selectors
    [ir.group]: "",
    [ir.groupDirection]: r,
    [ir.groupId]: m
  }));
}
const uG = C.forwardRef((e, t) => C.createElement(cG, {
  ...e,
  forwardedRef: t
}));
cG.displayName = "PanelGroup";
uG.displayName = "forwardRef(PanelGroup)";
function Rf(e, t) {
  return e.findIndex((n) => n === t || n.id === t.id);
}
function _u(e, t, n) {
  const r = Rf(e, t), o = r === e.length - 1 ? [r - 1, r] : [r, r + 1], s = n[r];
  return {
    ...t.constraints,
    panelSize: s,
    pivotIndices: o
  };
}
function Ize({
  disabled: e,
  handleId: t,
  resizeHandler: n,
  panelGroupElement: r
}) {
  C.useEffect(() => {
    if (e || n == null || r == null)
      return;
    const i = d1(t, r);
    if (i == null)
      return;
    const o = (s) => {
      if (!s.defaultPrevented)
        switch (s.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            s.preventDefault(), n(s);
            break;
          }
          case "F6": {
            s.preventDefault();
            const a = i.getAttribute(ir.groupId);
            It(a, `No group element found for id "${a}"`);
            const c = Ag(a, r), u = nG(a, t, r);
            It(u !== null, `No resize element found for id "${t}"`);
            const f = s.shiftKey ? u > 0 ? u - 1 : c.length - 1 : u + 1 < c.length ? u + 1 : 0;
            c[f].focus();
            break;
          }
        }
    };
    return i.addEventListener("keydown", o), () => {
      i.removeEventListener("keydown", o);
    };
  }, [r, e, t, n]);
}
function dG({
  children: e = null,
  className: t = "",
  disabled: n = !1,
  hitAreaMargins: r,
  id: i,
  onBlur: o,
  onClick: s,
  onDragging: a,
  onFocus: c,
  onPointerDown: u,
  onPointerUp: f,
  style: h = {},
  tabIndex: m = 0,
  tagName: g = "div",
  ...b
}) {
  var x, w;
  const S = C.useRef(null), _ = C.useRef({
    onClick: s,
    onDragging: a,
    onPointerDown: u,
    onPointerUp: f
  });
  C.useEffect(() => {
    _.current.onClick = s, _.current.onDragging = a, _.current.onPointerDown = u, _.current.onPointerUp = f;
  });
  const M = C.useContext(a1);
  if (M === null)
    throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
  const {
    direction: N,
    groupId: P,
    registerResizeHandle: I,
    startDragging: O,
    stopDragging: L,
    panelGroupElement: U
  } = M, B = tR(i), [G, Y] = C.useState("inactive"), [he, ie] = C.useState(!1), [ne, H] = C.useState(null), Q = C.useRef({
    state: G
  });
  Gu(() => {
    Q.current.state = G;
  }), C.useEffect(() => {
    if (n)
      H(null);
    else {
      const Z = I(B);
      H(() => Z);
    }
  }, [n, B, I]);
  const X = (x = r?.coarse) !== null && x !== void 0 ? x : 15, Se = (w = r?.fine) !== null && w !== void 0 ? w : 5;
  C.useEffect(() => {
    if (n || ne == null)
      return;
    const Z = S.current;
    It(Z, "Element ref not attached");
    let pe = !1;
    return xze(B, Z, N, {
      coarse: X,
      fine: Se
    }, (ee, ge, re) => {
      if (!ge) {
        Y("inactive");
        return;
      }
      switch (ee) {
        case "down": {
          Y("drag"), pe = !1, It(re, 'Expected event to be defined for "down" action'), O(B, re);
          const {
            onDragging: J,
            onPointerDown: xe
          } = _.current;
          J?.(!0), xe?.();
          break;
        }
        case "move": {
          const {
            state: J
          } = Q.current;
          pe = !0, J !== "drag" && Y("hover"), It(re, 'Expected event to be defined for "move" action'), ne(re);
          break;
        }
        case "up": {
          Y("hover"), L();
          const {
            onClick: J,
            onDragging: xe,
            onPointerUp: be
          } = _.current;
          xe?.(!1), be?.(), pe || J?.();
          break;
        }
      }
    });
  }, [X, N, n, Se, I, B, ne, O, L]), Ize({
    disabled: n,
    handleId: B,
    resizeHandler: ne,
    panelGroupElement: U
  });
  const W = {
    touchAction: "none",
    userSelect: "none"
  };
  return C.createElement(g, {
    ...b,
    children: e,
    className: t,
    id: i,
    onBlur: () => {
      ie(!1), o?.();
    },
    onFocus: () => {
      ie(!0), c?.();
    },
    ref: S,
    role: "separator",
    style: {
      ...W,
      ...h
    },
    tabIndex: m,
    // CSS selectors
    [ir.groupDirection]: N,
    [ir.groupId]: P,
    [ir.resizeHandle]: "",
    [ir.resizeHandleActive]: G === "drag" ? "pointer" : he ? "keyboard" : void 0,
    [ir.resizeHandleEnabled]: !n,
    [ir.resizeHandleId]: B,
    [ir.resizeHandleState]: G
  });
}
dG.displayName = "PanelResizeHandle";
function zze({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ v.jsx(
    uG,
    {
      "data-slot": "resizable-panel-group",
      className: at(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        e
      ),
      ...t
    }
  );
}
function u3({
  ...e
}) {
  return /* @__PURE__ */ v.jsx(qq, { "data-slot": "resizable-panel", ...e });
}
function Lze({
  withHandle: e,
  className: t,
  ...n
}) {
  return /* @__PURE__ */ v.jsx(
    dG,
    {
      "data-slot": "resizable-handle",
      className: at(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:translate-x-0 data-[panel-group-direction=vertical]:after:-translate-y-1/2 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        t
      ),
      ...n,
      children: e && /* @__PURE__ */ v.jsx("div", { className: "bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border", children: /* @__PURE__ */ v.jsx(ZZ, { className: "size-2.5" }) })
    }
  );
}
async function Bze(e) {
  const { filesToSend: t, parts: n, messages: r, setMessages: i, sendMessage: o, metadata: s } = e;
  if (!t || t.length === 0) return;
  const a = t.map((b) => ({
    fileName: b.name,
    mimeType: b.type || "application/octet-stream",
    size: b.size,
    s3Key: "",
    url: void 0,
    status: "uploading"
  })), c = `temp-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`, u = {
    id: c,
    role: "user",
    parts: n,
    metadata: { ...s || {}, attachments: a }
  };
  let f = Array.isArray(r) ? [...r] : [];
  f.push(u);
  try {
    i(f);
  } catch {
  }
  const h = t.map(async (b, x) => {
    const w = await QIe(b);
    f = (f || []).map((S) => {
      if (S.id !== c) return S;
      const _ = Array.isArray(S.metadata?.attachments) ? [...S.metadata.attachments] : [];
      return _[x] = w, { ...S, metadata: { ...S.metadata, attachments: _ } };
    });
    try {
      i(f);
    } catch {
    }
    return w;
  }), m = await Promise.all(h), g = (f || []).filter((b) => b.id !== c);
  try {
    i(g);
  } catch {
  }
  try {
    await o({
      role: "user",
      parts: n,
      metadata: { ...s || {}, attachments: m }
    });
  } catch (b) {
    const x = {
      id: u.id,
      role: u.role,
      parts: u.parts,
      metadata: { ...u.metadata, attachments: m }
    };
    try {
      i([...g || [], x]);
    } catch {
    }
    console.error("sendMessage failed:", b);
  }
}
const $ze = ({
  onClose: e,
  threadId: t
}) => {
  const {
    chatbotStore: {
      allowedAppDefaultToolkit: n,
      toolChoice: r,
      isNewThread: i,
      currentThreadId: o,
      threadMessages: s,
      isLoadingThread: a,
      isAIThinking: c,
      storeThreads: u,
      useNextSuggestion: f,
      isStopStream: h
    },
    chatbotStore: m,
    chatbotServerStore: { allowedMcpServers: g },
    chatbotThreadStore: { threadMentions: b }
  } = ra(), [x, w] = C.useState(""), [S, _] = C.useState([]), [M, N] = C.useState(!1), [P, I] = C.useState(!0), O = new URLSearchParams(window.location.search), L = O.get("project_id") || "unknown", U = O.get("version_id") || "unknown", B = async (mt) => {
    try {
      localStorage.setItem("ai-name", mt);
    } catch {
    }
  }, G = o.value || t, Y = !i.value && !ng(G), he = 10, {
    messages: ie,
    pagination: ne,
    loadMore: H
  } = gpe(G, 50, Y), Q = C.useMemo(() => {
    const mt = s.value[G] || [];
    return mt.length > 0 ? mt : Y && ie.length > 0 ? ie : [];
  }, [s.value, G, Y, ie]), X = C.useMemo(
    () => upe(G),
    [G]
  );
  ype(f);
  const {
    saveMessages: Se
  } = vpe({
    threadId: G,
    enabled: !0,
    maxInMemory: he
  }), {
    messages: W,
    status: Z,
    sendMessage: pe,
    setMessages: F,
    stop: ee,
    error: ge,
    regenerate: re,
    addToolOutput: J
    //IMPORTANT for manual tool approvals
  } = Gbe({
    id: G,
    sendAutomaticallyWhen: Ube,
    transport: new IF({
      api: `${Wa}/ai-chat`,
      fetch: async (mt, ke) => {
        const Pe = await zc();
        return fetch(mt, {
          ...ke,
          headers: {
            ...Pe,
            ...ke?.headers
          }
        });
      },
      prepareSendMessagesRequest: ({
        messages: mt,
        body: ke,
        id: Pe,
        trigger: He,
        messageId: et
      }) => {
        const bt = Dbe(mt), Ct = Array.isArray(mt) && mt.length ? mt[mt.length - 1] : void 0;
        if (!Ct)
          return { body: ke ?? {} };
        const fn = localStorage.getItem("ai-name") || Q$, Lt = {
          provider: fn.startsWith("gpt") ? "openai" : "azure",
          model: fn
        };
        return { body: {
          id: o.value || Pe,
          chatModel: Lt,
          toolChoice: r.value || "auto",
          allowedAppDefaultToolkit: n.value,
          allowedMcpServers: g.value,
          mentions: b.value[G] || [],
          message: Ct,
          // server expects single message
          messages: bt,
          // Add converted ModelMessages for backend
          trigger: He,
          // 'submit-message' | 'regenerate-message'
          messageId: et,
          // ID of message to regenerate (for regenerate-message trigger)
          projectId: L,
          versionId: U,
          usingNextSuggestion: f.value
        } };
      }
    }),
    messages: Q,
    generateId: ple,
    experimental_throttle: 100,
    onFinish: (mt) => {
    },
    onToolCall: (mt) => {
    },
    onData: (mt) => {
    },
    onError: (mt) => {
      console.log(" onError:", mt), X.onError(mt);
    }
  }), xe = C.useCallback(
    async (mt) => {
      await J(mt);
    },
    [J]
  ), be = W, Ae = F, tt = C.useRef(G), Ge = C.useRef(be), nt = Z === "streaming" || Z === "submitted";
  c.value = nt;
  const _t = C.useCallback(
    () => {
      ee(), h.value = !0;
    },
    [ee, be, Ae]
  );
  C.useEffect(() => {
    Q.length > 0 && be.length === 0 && Ae(Q);
  }, [G, Q, be.length, Ae]);
  const { scrollAreaRef: yn, containerRef: St, topSentinelRef: Vt, scrollToBottom: xt } = dpe(
    be.length > 0 ? be : Q,
    a.value,
    Y ? H : void 0,
    Y ? ne.hasMore : !1
  ), Kt = () => {
    if (ng(G)) {
      const mt = ipe(G);
      o.value = mt, i.value = !0;
    }
  }, An = C.useCallback(
    async (mt, ke) => {
      const Pe = (mt ?? x ?? "").trim();
      if (!(!Pe || nt))
        try {
          c.value = !0, ke && ke.length > 0 && (b.value = {
            ...b.value,
            [G]: ke
          });
          const He = [...S];
          _([]), w(""), N(!1);
          const et = Pe ? [{ type: "text", text: Pe }] : [{ type: "text", text: "" }];
          if (He.length > 0 ? await Bze({
            filesToSend: He,
            parts: et,
            messages: be,
            setMessages: Ae,
            sendMessage: pe
          }) : await pe({
            role: "user",
            parts: et,
            metadata: {
              mentions: ke
            }
          }), i.value && !nt) {
            const bt = await o8();
            try {
              bt.ok && (u.value = [...bt.threads]);
            } catch (Ct) {
              console.error("Error fetching threads:", Ct);
            }
          }
          nt || (c.value = !1), i.value = !1, setTimeout(() => xt(!0), 100);
        } catch (He) {
          c.value = !1, console.error("sendMessage error:", He);
        }
    },
    [
      x,
      S,
      nt,
      pe,
      xt,
      _,
      N,
      X
    ]
  ), Nt = C.useMemo(() => {
    const mt = (He) => He.filter((et) => et.role !== "system"), ke = mt(be), Pe = mt(Q || []);
    return ke.length > 0 ? ke : Pe;
  }, [be, Q]);
  C.useEffect(() => {
    const mt = he * 2, ke = (Pe, He) => {
      if (Pe.length <= He) return Pe;
      let et = Pe.slice(-He);
      const bt = et[0];
      if (bt && bt.role === "user" && bt.parts?.some((Lt) => Lt.type === "tool-result"))
        for (let Lt = Pe.length - He - 1; Lt >= 0; Lt--) {
          const nn = Pe[Lt];
          if (nn && nn.role === "assistant" && nn.parts?.some((Ve) => Ve.type === "tool-call")) {
            et = Pe.slice(Lt);
            break;
          }
        }
      const Ct = et[et.length - 1];
      if (Ct && Ct.role === "assistant") {
        const fn = Ct.parts?.filter(
          (Lt) => Lt.type === "tool-call" && !Lt.result
        );
        if (fn && fn.length > 0)
          return Pe;
      }
      return et;
    };
    if (be.length > mt) {
      const Pe = ke(be, he);
      Pe.length !== be.length && Ae(Pe);
    } else if (Z !== "streaming" && Z !== "submitted" && be.length > he) {
      const Pe = ke(be, he);
      Pe.length !== be.length && Ae(Pe);
    }
  }, [be, Z, Ae, he]), C.useEffect(() => {
    be !== Ge.current && (Ge.current = be, tt.current = G);
  }, [be, G]), C.useEffect(() => {
    if (tt.current === G && be.length > 0 && G) {
      const ke = s.value[G] || [], Pe = new Map(
        ke.map((Ct) => [Ct.id, Ct.createdAt])
      );
      let He = be;
      if (be.length > 10) {
        He = be.slice(-10);
        const Ct = He[0];
        if (Ct && Ct.role === "user" && Ct.parts?.some((Lt) => Lt.type === "tool-result"))
          for (let Lt = be.indexOf(Ct) - 1; Lt >= 0; Lt--) {
            const nn = be[Lt];
            if (nn && nn.role === "assistant" && nn.parts?.some((Ve) => Ve.type === "tool-call")) {
              He = be.slice(Lt);
              break;
            }
          }
      }
      const et = He.map((Ct) => ({
        id: Ct.id,
        threadId: G,
        role: Ct.role,
        parts: Ct.parts,
        metadata: Ct.metadata,
        createdAt: Pe.get(Ct.id) || /* @__PURE__ */ new Date()
      })), bt = s.value;
      JSON.stringify(bt[G]) !== JSON.stringify(et) && (s.value = {
        ...bt,
        [G]: et
      }), Z !== "streaming" && Se(be).catch((Ct) => {
        console.error("Failed to save messages to IndexedDB:", Ct);
      });
    }
  }, [be, G, Z, s, Se]), C.useEffect(() => {
    be.length > 0 && xt(!0);
  }, [be.length, xt]), C.useEffect(() => () => {
    m.cleanup(), Ae([]), _([]), w("");
  }, [m]);
  const sn = () => {
    I(!P);
  }, { handleThreadSelect: Pn, handleNewThread: Mn } = lpe({
    threadId: t,
    setMessages: Ae,
    stop: _t,
    setHideError: N
  });
  return /* @__PURE__ */ v.jsxs("div", { className: "relative h-full w-full flex flex-col overflow-hidden", children: [
    /* @__PURE__ */ v.jsx(
      Zhe,
      {
        onClose: e,
        setApiKeyByName: B,
        onToggleSidebar: sn,
        isSidebarOpen: P
      }
    ),
    /* @__PURE__ */ v.jsxs(zze, { direction: "horizontal", className: "flex-1 min-h-0", children: [
      /* @__PURE__ */ v.jsx(
        u3,
        {
          defaultSize: 25,
          minSize: 21,
          maxSize: 26,
          collapsible: !0,
          collapsedSize: 0,
          className: P ? "z-1000 overflow-auto-y" : "hidden",
          children: /* @__PURE__ */ v.jsx(
            ape,
            {
              isOpen: P,
              onThreadSelect: Pn,
              onNewThread: Mn
            }
          )
        }
      ),
      P && /* @__PURE__ */ v.jsx(Lze, { withHandle: !0 }),
      /* @__PURE__ */ v.jsx(u3, { defaultSize: 80, minSize: 50, children: /* @__PURE__ */ v.jsxs("div", { className: "h-full flex flex-col gap-2 overflow-y-auto overflow-hidden", children: [
        a.value ? /* @__PURE__ */ v.jsx(a8, { message: "Loading thread..." }) : /* @__PURE__ */ v.jsxs(C.Fragment, { children: [
          /* @__PURE__ */ v.jsx(
            "div",
            {
              ref: St,
              className: "flex-1 overflow-hidden",
              "data-chatbot-text": "data-chatbot",
              tabIndex: 0,
              children: /* @__PURE__ */ v.jsx(
                JT,
                {
                  ref: yn,
                  className: "h-full pr-2 chat-scroll-area",
                  children: /* @__PURE__ */ v.jsxs("div", { className: "flex flex-col gap-3 py-2 min-h-full justify-end overflow-x-auto wrap-break-word", children: [
                    Y && ne.hasMore && /* @__PURE__ */ v.jsx(
                      "div",
                      {
                        ref: Vt,
                        className: "h-4 flex items-center justify-center",
                        children: ne.isLoadingMore && /* @__PURE__ */ v.jsx("span", { className: "text-xs text-muted-foreground", children: "Loading..." })
                      }
                    ),
                    /* @__PURE__ */ v.jsx(NA, { initial: !1, children: Nt.map((mt, ke) => {
                      const Pe = Nt[ke - 1] ?? mt;
                      return /* @__PURE__ */ v.jsx(
                        yMe,
                        {
                          threadId: t,
                          messageIndex: ke,
                          message: mt,
                          prevMessage: Pe,
                          isLoading: nt,
                          isLastMessage: ke === Nt.length - 1,
                          status: Z,
                          setMessages: Ae,
                          sendMessage: pe,
                          regenerate: re,
                          addToolResult: xe,
                          onReuseMessage: (He) => lze(He, w)
                        },
                        mt.id
                      );
                    }) }),
                    Nt.length > 0 && (Z === "streaming" || Z === "submitted") && /* @__PURE__ */ v.jsx(t3, {}),
                    !M && ge && /* @__PURE__ */ v.jsx(aze, { error: ge }),
                    /* @__PURE__ */ v.jsx("div", { className: "min-w-0 min-h-52" })
                  ] })
                }
              )
            }
          ),
          Nt.length !== 0 && /* @__PURE__ */ v.jsx(
            e3,
            {
              value: x,
              onChange: w,
              onSend: An,
              onFilesChange: _,
              files: S,
              mcpServers: [],
              opStop: _t,
              onToggleMcpServer: () => {
              },
              onStartTyping: Kt,
              onUseNextSuggestionChange: (mt) => {
                f.value = mt;
              }
            }
          )
        ] }),
        Nt.length === 0 && /* @__PURE__ */ v.jsxs(C.Fragment, { children: [
          /* @__PURE__ */ v.jsx(wMe, {}),
          (Z === "streaming" || Z === "submitted") && /* @__PURE__ */ v.jsx("div", { className: "flex justify-center py-4", children: /* @__PURE__ */ v.jsx(t3, {}) }),
          /* @__PURE__ */ v.jsx(
            e3,
            {
              value: x,
              onChange: w,
              onSend: An,
              onFilesChange: _,
              files: S,
              mcpServers: [],
              onToggleMcpServer: () => {
              },
              opStop: _t,
              onStartTyping: Kt,
              onUseNextSuggestionChange: (mt) => {
                f.value = mt;
              }
            }
          )
        ] })
      ] }) })
    ] })
  ] });
};
var im = { exports: {} }, SE = {}, kE = { exports: {} }, CE, d3;
function Uze() {
  if (d3) return CE;
  d3 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return CE = e, CE;
}
var EE, f3;
function Fze() {
  if (f3) return EE;
  f3 = 1;
  var e = /* @__PURE__ */ Uze();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, EE = function() {
    function r(s, a, c, u, f, h) {
      if (h !== e) {
        var m = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw m.name = "Invariant Violation", m;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var o = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, EE;
}
var h3;
function fG() {
  return h3 || (h3 = 1, kE.exports = /* @__PURE__ */ Fze()()), kE.exports;
}
function hG(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (n = hG(e[t])) && (r && (r += " "), r += n);
  else for (t in e) e[t] && (r && (r += " "), r += t);
  return r;
}
function p3() {
  for (var e, t, n = 0, r = ""; n < arguments.length; ) (e = arguments[n++]) && (t = hG(e)) && (r && (r += " "), r += t);
  return r;
}
const Vze = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: p3,
  default: p3
}, Symbol.toStringTag, { value: "Module" })), Hze = /* @__PURE__ */ jK(Vze);
var dr = {}, Wl = {}, m3;
function f1() {
  if (m3) return Wl;
  m3 = 1, Object.defineProperty(Wl, "__esModule", {
    value: !0
  }), Wl.dontSetMe = i, Wl.findInArray = e, Wl.int = r, Wl.isFunction = t, Wl.isNum = n;
  function e(o, s) {
    for (let a = 0, c = o.length; a < c; a++)
      if (s.apply(s, [o[a], a, o])) return o[a];
  }
  function t(o) {
    return typeof o == "function" || Object.prototype.toString.call(o) === "[object Function]";
  }
  function n(o) {
    return typeof o == "number" && !isNaN(o);
  }
  function r(o) {
    return parseInt(o, 10);
  }
  function i(o, s, a) {
    if (o[s])
      return new Error("Invalid prop ".concat(s, " passed to ").concat(a, " - do not set this, set it on the child."));
  }
  return Wl;
}
var ql = {}, g3;
function Wze() {
  if (g3) return ql;
  g3 = 1, Object.defineProperty(ql, "__esModule", {
    value: !0
  }), ql.browserPrefixToKey = n, ql.browserPrefixToStyle = r, ql.default = void 0, ql.getPrefix = t;
  const e = ["Moz", "Webkit", "O", "ms"];
  function t() {
    var o;
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
    if (typeof window > "u") return "";
    const a = (o = window.document) === null || o === void 0 || (o = o.documentElement) === null || o === void 0 ? void 0 : o.style;
    if (!a || s in a) return "";
    for (let c = 0; c < e.length; c++)
      if (n(s, e[c]) in a) return e[c];
    return "";
  }
  function n(o, s) {
    return s ? "".concat(s).concat(i(o)) : o;
  }
  function r(o, s) {
    return s ? "-".concat(s.toLowerCase(), "-").concat(o) : o;
  }
  function i(o) {
    let s = "", a = !0;
    for (let c = 0; c < o.length; c++)
      a ? (s += o[c].toUpperCase(), a = !1) : o[c] === "-" ? a = !0 : s += o[c];
    return s;
  }
  return ql.default = t(), ql;
}
var y3;
function rR() {
  if (y3) return dr;
  y3 = 1, Object.defineProperty(dr, "__esModule", {
    value: !0
  }), dr.addClassName = P, dr.addEvent = a, dr.addUserSelectStyles = M, dr.createCSSTransform = b, dr.createSVGTransform = x, dr.getTouch = S, dr.getTouchIdentifier = _, dr.getTranslation = w, dr.innerHeight = h, dr.innerWidth = m, dr.matchesSelector = o, dr.matchesSelectorAndParentsTo = s, dr.offsetXYFromParent = g, dr.outerHeight = u, dr.outerWidth = f, dr.removeClassName = I, dr.removeEvent = c, dr.removeUserSelectStyles = N;
  var e = f1(), t = r(Wze());
  function n(O) {
    if (typeof WeakMap != "function") return null;
    var L = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap();
    return (n = function(B) {
      return B ? U : L;
    })(O);
  }
  function r(O, L) {
    if (O && O.__esModule)
      return O;
    if (O === null || typeof O != "object" && typeof O != "function")
      return { default: O };
    var U = n(L);
    if (U && U.has(O))
      return U.get(O);
    var B = {}, G = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var Y in O)
      if (Y !== "default" && Object.prototype.hasOwnProperty.call(O, Y)) {
        var he = G ? Object.getOwnPropertyDescriptor(O, Y) : null;
        he && (he.get || he.set) ? Object.defineProperty(B, Y, he) : B[Y] = O[Y];
      }
    return B.default = O, U && U.set(O, B), B;
  }
  let i = "";
  function o(O, L) {
    return i || (i = (0, e.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(U) {
      return (0, e.isFunction)(O[U]);
    })), (0, e.isFunction)(O[i]) ? O[i](L) : !1;
  }
  function s(O, L, U) {
    let B = O;
    do {
      if (o(B, L)) return !0;
      if (B === U) return !1;
      B = B.parentNode;
    } while (B);
    return !1;
  }
  function a(O, L, U, B) {
    if (!O) return;
    const G = {
      capture: !0,
      ...B
    };
    O.addEventListener ? O.addEventListener(L, U, G) : O.attachEvent ? O.attachEvent("on" + L, U) : O["on" + L] = U;
  }
  function c(O, L, U, B) {
    if (!O) return;
    const G = {
      capture: !0,
      ...B
    };
    O.removeEventListener ? O.removeEventListener(L, U, G) : O.detachEvent ? O.detachEvent("on" + L, U) : O["on" + L] = null;
  }
  function u(O) {
    let L = O.clientHeight;
    const U = O.ownerDocument.defaultView.getComputedStyle(O);
    return L += (0, e.int)(U.borderTopWidth), L += (0, e.int)(U.borderBottomWidth), L;
  }
  function f(O) {
    let L = O.clientWidth;
    const U = O.ownerDocument.defaultView.getComputedStyle(O);
    return L += (0, e.int)(U.borderLeftWidth), L += (0, e.int)(U.borderRightWidth), L;
  }
  function h(O) {
    let L = O.clientHeight;
    const U = O.ownerDocument.defaultView.getComputedStyle(O);
    return L -= (0, e.int)(U.paddingTop), L -= (0, e.int)(U.paddingBottom), L;
  }
  function m(O) {
    let L = O.clientWidth;
    const U = O.ownerDocument.defaultView.getComputedStyle(O);
    return L -= (0, e.int)(U.paddingLeft), L -= (0, e.int)(U.paddingRight), L;
  }
  function g(O, L, U) {
    const G = L === L.ownerDocument.body ? {
      left: 0,
      top: 0
    } : L.getBoundingClientRect(), Y = (O.clientX + L.scrollLeft - G.left) / U, he = (O.clientY + L.scrollTop - G.top) / U;
    return {
      x: Y,
      y: he
    };
  }
  function b(O, L) {
    const U = w(O, L, "px");
    return {
      [(0, t.browserPrefixToKey)("transform", t.default)]: U
    };
  }
  function x(O, L) {
    return w(O, L, "");
  }
  function w(O, L, U) {
    let {
      x: B,
      y: G
    } = O, Y = "translate(".concat(B).concat(U, ",").concat(G).concat(U, ")");
    if (L) {
      const he = "".concat(typeof L.x == "string" ? L.x : L.x + U), ie = "".concat(typeof L.y == "string" ? L.y : L.y + U);
      Y = "translate(".concat(he, ", ").concat(ie, ")") + Y;
    }
    return Y;
  }
  function S(O, L) {
    return O.targetTouches && (0, e.findInArray)(O.targetTouches, (U) => L === U.identifier) || O.changedTouches && (0, e.findInArray)(O.changedTouches, (U) => L === U.identifier);
  }
  function _(O) {
    if (O.targetTouches && O.targetTouches[0]) return O.targetTouches[0].identifier;
    if (O.changedTouches && O.changedTouches[0]) return O.changedTouches[0].identifier;
  }
  function M(O) {
    if (!O) return;
    let L = O.getElementById("react-draggable-style-el");
    L || (L = O.createElement("style"), L.type = "text/css", L.id = "react-draggable-style-el", L.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, L.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, O.getElementsByTagName("head")[0].appendChild(L)), O.body && P(O.body, "react-draggable-transparent-selection");
  }
  function N(O) {
    if (O)
      try {
        if (O.body && I(O.body, "react-draggable-transparent-selection"), O.selection)
          O.selection.empty();
        else {
          const L = (O.defaultView || window).getSelection();
          L && L.type !== "Caret" && L.removeAllRanges();
        }
      } catch {
      }
  }
  function P(O, L) {
    O.classList ? O.classList.add(L) : O.className.match(new RegExp("(?:^|\\s)".concat(L, "(?!\\S)"))) || (O.className += " ".concat(L));
  }
  function I(O, L) {
    O.classList ? O.classList.remove(L) : O.className = O.className.replace(new RegExp("(?:^|\\s)".concat(L, "(?!\\S)"), "g"), "");
  }
  return dr;
}
var Rs = {}, v3;
function pG() {
  if (v3) return Rs;
  v3 = 1, Object.defineProperty(Rs, "__esModule", {
    value: !0
  }), Rs.canDragX = i, Rs.canDragY = o, Rs.createCoreData = a, Rs.createDraggableData = c, Rs.getBoundPosition = n, Rs.getControlPosition = s, Rs.snapToGrid = r;
  var e = f1(), t = rR();
  function n(h, m, g) {
    if (!h.props.bounds) return [m, g];
    let {
      bounds: b
    } = h.props;
    b = typeof b == "string" ? b : u(b);
    const x = f(h);
    if (typeof b == "string") {
      const {
        ownerDocument: w
      } = x, S = w.defaultView;
      let _;
      if (b === "parent" ? _ = x.parentNode : _ = w.querySelector(b), !(_ instanceof S.HTMLElement))
        throw new Error('Bounds selector "' + b + '" could not find an element.');
      const M = _, N = S.getComputedStyle(x), P = S.getComputedStyle(M);
      b = {
        left: -x.offsetLeft + (0, e.int)(P.paddingLeft) + (0, e.int)(N.marginLeft),
        top: -x.offsetTop + (0, e.int)(P.paddingTop) + (0, e.int)(N.marginTop),
        right: (0, t.innerWidth)(M) - (0, t.outerWidth)(x) - x.offsetLeft + (0, e.int)(P.paddingRight) - (0, e.int)(N.marginRight),
        bottom: (0, t.innerHeight)(M) - (0, t.outerHeight)(x) - x.offsetTop + (0, e.int)(P.paddingBottom) - (0, e.int)(N.marginBottom)
      };
    }
    return (0, e.isNum)(b.right) && (m = Math.min(m, b.right)), (0, e.isNum)(b.bottom) && (g = Math.min(g, b.bottom)), (0, e.isNum)(b.left) && (m = Math.max(m, b.left)), (0, e.isNum)(b.top) && (g = Math.max(g, b.top)), [m, g];
  }
  function r(h, m, g) {
    const b = Math.round(m / h[0]) * h[0], x = Math.round(g / h[1]) * h[1];
    return [b, x];
  }
  function i(h) {
    return h.props.axis === "both" || h.props.axis === "x";
  }
  function o(h) {
    return h.props.axis === "both" || h.props.axis === "y";
  }
  function s(h, m, g) {
    const b = typeof m == "number" ? (0, t.getTouch)(h, m) : null;
    if (typeof m == "number" && !b) return null;
    const x = f(g), w = g.props.offsetParent || x.offsetParent || x.ownerDocument.body;
    return (0, t.offsetXYFromParent)(b || h, w, g.props.scale);
  }
  function a(h, m, g) {
    const b = !(0, e.isNum)(h.lastX), x = f(h);
    return b ? {
      node: x,
      deltaX: 0,
      deltaY: 0,
      lastX: m,
      lastY: g,
      x: m,
      y: g
    } : {
      node: x,
      deltaX: m - h.lastX,
      deltaY: g - h.lastY,
      lastX: h.lastX,
      lastY: h.lastY,
      x: m,
      y: g
    };
  }
  function c(h, m) {
    const g = h.props.scale;
    return {
      node: m.node,
      x: h.state.x + m.deltaX / g,
      y: h.state.y + m.deltaY / g,
      deltaX: m.deltaX / g,
      deltaY: m.deltaY / g,
      lastX: h.state.x,
      lastY: h.state.y
    };
  }
  function u(h) {
    return {
      left: h.left,
      top: h.top,
      right: h.right,
      bottom: h.bottom
    };
  }
  function f(h) {
    const m = h.findDOMNode();
    if (!m)
      throw new Error("<DraggableCore>: Unmounted during event!");
    return m;
  }
  return Rs;
}
var om = {}, f0 = {}, b3;
function mG() {
  if (b3) return f0;
  b3 = 1, Object.defineProperty(f0, "__esModule", {
    value: !0
  }), f0.default = e;
  function e() {
  }
  return f0;
}
var x3;
function qze() {
  if (x3) return om;
  x3 = 1, Object.defineProperty(om, "__esModule", {
    value: !0
  }), om.default = void 0;
  var e = u(cd()), t = a(/* @__PURE__ */ fG()), n = a(Vx()), r = rR(), i = pG(), o = f1(), s = a(mG());
  function a(w) {
    return w && w.__esModule ? w : { default: w };
  }
  function c(w) {
    if (typeof WeakMap != "function") return null;
    var S = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap();
    return (c = function(M) {
      return M ? _ : S;
    })(w);
  }
  function u(w, S) {
    if (w && w.__esModule)
      return w;
    if (w === null || typeof w != "object" && typeof w != "function")
      return { default: w };
    var _ = c(S);
    if (_ && _.has(w))
      return _.get(w);
    var M = {}, N = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var P in w)
      if (P !== "default" && Object.prototype.hasOwnProperty.call(w, P)) {
        var I = N ? Object.getOwnPropertyDescriptor(w, P) : null;
        I && (I.get || I.set) ? Object.defineProperty(M, P, I) : M[P] = w[P];
      }
    return M.default = w, _ && _.set(w, M), M;
  }
  function f(w, S, _) {
    return S = h(S), S in w ? Object.defineProperty(w, S, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : w[S] = _, w;
  }
  function h(w) {
    var S = m(w, "string");
    return typeof S == "symbol" ? S : String(S);
  }
  function m(w, S) {
    if (typeof w != "object" || w === null) return w;
    var _ = w[Symbol.toPrimitive];
    if (_ !== void 0) {
      var M = _.call(w, S);
      if (typeof M != "object") return M;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (S === "string" ? String : Number)(w);
  }
  const g = {
    touch: {
      start: "touchstart",
      move: "touchmove",
      stop: "touchend"
    },
    mouse: {
      start: "mousedown",
      move: "mousemove",
      stop: "mouseup"
    }
  };
  let b = g.mouse, x = class extends e.Component {
    constructor() {
      super(...arguments), f(this, "dragging", !1), f(this, "lastX", NaN), f(this, "lastY", NaN), f(this, "touchIdentifier", null), f(this, "mounted", !1), f(this, "handleDragStart", (S) => {
        if (this.props.onMouseDown(S), !this.props.allowAnyClick && typeof S.button == "number" && S.button !== 0) return !1;
        const _ = this.findDOMNode();
        if (!_ || !_.ownerDocument || !_.ownerDocument.body)
          throw new Error("<DraggableCore> not mounted on DragStart!");
        const {
          ownerDocument: M
        } = _;
        if (this.props.disabled || !(S.target instanceof M.defaultView.Node) || this.props.handle && !(0, r.matchesSelectorAndParentsTo)(S.target, this.props.handle, _) || this.props.cancel && (0, r.matchesSelectorAndParentsTo)(S.target, this.props.cancel, _))
          return;
        S.type === "touchstart" && S.preventDefault();
        const N = (0, r.getTouchIdentifier)(S);
        this.touchIdentifier = N;
        const P = (0, i.getControlPosition)(S, N, this);
        if (P == null) return;
        const {
          x: I,
          y: O
        } = P, L = (0, i.createCoreData)(this, I, O);
        (0, s.default)("DraggableCore: handleDragStart: %j", L), (0, s.default)("calling", this.props.onStart), !(this.props.onStart(S, L) === !1 || this.mounted === !1) && (this.props.enableUserSelectHack && (0, r.addUserSelectStyles)(M), this.dragging = !0, this.lastX = I, this.lastY = O, (0, r.addEvent)(M, b.move, this.handleDrag), (0, r.addEvent)(M, b.stop, this.handleDragStop));
      }), f(this, "handleDrag", (S) => {
        const _ = (0, i.getControlPosition)(S, this.touchIdentifier, this);
        if (_ == null) return;
        let {
          x: M,
          y: N
        } = _;
        if (Array.isArray(this.props.grid)) {
          let O = M - this.lastX, L = N - this.lastY;
          if ([O, L] = (0, i.snapToGrid)(this.props.grid, O, L), !O && !L) return;
          M = this.lastX + O, N = this.lastY + L;
        }
        const P = (0, i.createCoreData)(this, M, N);
        if ((0, s.default)("DraggableCore: handleDrag: %j", P), this.props.onDrag(S, P) === !1 || this.mounted === !1) {
          try {
            this.handleDragStop(new MouseEvent("mouseup"));
          } catch {
            const L = document.createEvent("MouseEvents");
            L.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), this.handleDragStop(L);
          }
          return;
        }
        this.lastX = M, this.lastY = N;
      }), f(this, "handleDragStop", (S) => {
        if (!this.dragging) return;
        const _ = (0, i.getControlPosition)(S, this.touchIdentifier, this);
        if (_ == null) return;
        let {
          x: M,
          y: N
        } = _;
        if (Array.isArray(this.props.grid)) {
          let L = M - this.lastX || 0, U = N - this.lastY || 0;
          [L, U] = (0, i.snapToGrid)(this.props.grid, L, U), M = this.lastX + L, N = this.lastY + U;
        }
        const P = (0, i.createCoreData)(this, M, N);
        if (this.props.onStop(S, P) === !1 || this.mounted === !1) return !1;
        const O = this.findDOMNode();
        O && this.props.enableUserSelectHack && (0, r.removeUserSelectStyles)(O.ownerDocument), (0, s.default)("DraggableCore: handleDragStop: %j", P), this.dragging = !1, this.lastX = NaN, this.lastY = NaN, O && ((0, s.default)("DraggableCore: Removing handlers"), (0, r.removeEvent)(O.ownerDocument, b.move, this.handleDrag), (0, r.removeEvent)(O.ownerDocument, b.stop, this.handleDragStop));
      }), f(this, "onMouseDown", (S) => (b = g.mouse, this.handleDragStart(S))), f(this, "onMouseUp", (S) => (b = g.mouse, this.handleDragStop(S))), f(this, "onTouchStart", (S) => (b = g.touch, this.handleDragStart(S))), f(this, "onTouchEnd", (S) => (b = g.touch, this.handleDragStop(S)));
    }
    componentDidMount() {
      this.mounted = !0;
      const S = this.findDOMNode();
      S && (0, r.addEvent)(S, g.touch.start, this.onTouchStart, {
        passive: !1
      });
    }
    componentWillUnmount() {
      this.mounted = !1;
      const S = this.findDOMNode();
      if (S) {
        const {
          ownerDocument: _
        } = S;
        (0, r.removeEvent)(_, g.mouse.move, this.handleDrag), (0, r.removeEvent)(_, g.touch.move, this.handleDrag), (0, r.removeEvent)(_, g.mouse.stop, this.handleDragStop), (0, r.removeEvent)(_, g.touch.stop, this.handleDragStop), (0, r.removeEvent)(S, g.touch.start, this.onTouchStart, {
          passive: !1
        }), this.props.enableUserSelectHack && (0, r.removeUserSelectStyles)(_);
      }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() {
      var S, _;
      return (S = this.props) !== null && S !== void 0 && S.nodeRef ? (_ = this.props) === null || _ === void 0 || (_ = _.nodeRef) === null || _ === void 0 ? void 0 : _.current : n.default.findDOMNode(this);
    }
    render() {
      return /* @__PURE__ */ e.cloneElement(e.Children.only(this.props.children), {
        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        // onTouchStart is added on `componentDidMount` so they can be added with
        // {passive: false}, which allows it to cancel. See
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        onTouchEnd: this.onTouchEnd
      });
    }
  };
  return om.default = x, f(x, "displayName", "DraggableCore"), f(x, "propTypes", {
    /**
     * `allowAnyClick` allows dragging using any mouse button.
     * By default, we only accept the left button.
     *
     * Defaults to `false`.
     */
    allowAnyClick: t.default.bool,
    children: t.default.node.isRequired,
    /**
     * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
     * with the exception of `onMouseDown`, will not fire.
     */
    disabled: t.default.bool,
    /**
     * By default, we add 'user-select:none' attributes to the document body
     * to prevent ugly text selection during drag. If this is causing problems
     * for your app, set this to `false`.
     */
    enableUserSelectHack: t.default.bool,
    /**
     * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
     * instead of using the parent node.
     */
    offsetParent: function(w, S) {
      if (w[S] && w[S].nodeType !== 1)
        throw new Error("Draggable's offsetParent must be a DOM Node.");
    },
    /**
     * `grid` specifies the x and y that dragging should snap to.
     */
    grid: t.default.arrayOf(t.default.number),
    /**
     * `handle` specifies a selector to be used as the handle that initiates drag.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable handle=".handle">
     *              <div>
     *                  <div className="handle">Click me to drag</div>
     *                  <div>This is some other content</div>
     *              </div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    handle: t.default.string,
    /**
     * `cancel` specifies a selector to be used to prevent drag initialization.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *           return(
     *               <Draggable cancel=".cancel">
     *                   <div>
     *                     <div className="cancel">You can't drag from here</div>
     *                     <div>Dragging here works fine</div>
     *                   </div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    cancel: t.default.string,
    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
     * Unfortunately, in order for <Draggable> to work properly, we need raw access
     * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
     * as in this example:
     *
     * function MyComponent() {
     *   const nodeRef = React.useRef(null);
     *   return (
     *     <Draggable nodeRef={nodeRef}>
     *       <div ref={nodeRef}>Example Target</div>
     *     </Draggable>
     *   );
     * }
     *
     * This can be used for arbitrarily nested components, so long as the ref ends up
     * pointing to the actual child DOM node and not a custom component.
     */
    nodeRef: t.default.object,
    /**
     * Called when dragging starts.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onStart: t.default.func,
    /**
     * Called while dragging.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onDrag: t.default.func,
    /**
     * Called when dragging stops.
     * If this function returns the boolean false, the drag will remain active.
     */
    onStop: t.default.func,
    /**
     * A workaround option which can be passed if onMouseDown needs to be accessed,
     * since it'll always be blocked (as there is internal use of onMouseDown)
     */
    onMouseDown: t.default.func,
    /**
     * `scale`, if set, applies scaling while dragging an element
     */
    scale: t.default.number,
    /**
     * These properties should be defined on the child, not here.
     */
    className: o.dontSetMe,
    style: o.dontSetMe,
    transform: o.dontSetMe
  }), f(x, "defaultProps", {
    allowAnyClick: !1,
    // by default only accept left click
    disabled: !1,
    enableUserSelectHack: !0,
    onStart: function() {
    },
    onDrag: function() {
    },
    onStop: function() {
    },
    onMouseDown: function() {
    },
    scale: 1
  }), om;
}
var w3;
function Gze() {
  return w3 || (w3 = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "DraggableCore", {
      enumerable: !0,
      get: function() {
        return c.default;
      }
    }), e.default = void 0;
    var t = m(cd()), n = f(/* @__PURE__ */ fG()), r = f(Vx()), i = f(Hze), o = rR(), s = pG(), a = f1(), c = f(qze()), u = f(mG());
    function f(_) {
      return _ && _.__esModule ? _ : { default: _ };
    }
    function h(_) {
      if (typeof WeakMap != "function") return null;
      var M = /* @__PURE__ */ new WeakMap(), N = /* @__PURE__ */ new WeakMap();
      return (h = function(P) {
        return P ? N : M;
      })(_);
    }
    function m(_, M) {
      if (_ && _.__esModule)
        return _;
      if (_ === null || typeof _ != "object" && typeof _ != "function")
        return { default: _ };
      var N = h(M);
      if (N && N.has(_))
        return N.get(_);
      var P = {}, I = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var O in _)
        if (O !== "default" && Object.prototype.hasOwnProperty.call(_, O)) {
          var L = I ? Object.getOwnPropertyDescriptor(_, O) : null;
          L && (L.get || L.set) ? Object.defineProperty(P, O, L) : P[O] = _[O];
        }
      return P.default = _, N && N.set(_, P), P;
    }
    function g() {
      return g = Object.assign ? Object.assign.bind() : function(_) {
        for (var M = 1; M < arguments.length; M++) {
          var N = arguments[M];
          for (var P in N)
            Object.prototype.hasOwnProperty.call(N, P) && (_[P] = N[P]);
        }
        return _;
      }, g.apply(this, arguments);
    }
    function b(_, M, N) {
      return M = x(M), M in _ ? Object.defineProperty(_, M, { value: N, enumerable: !0, configurable: !0, writable: !0 }) : _[M] = N, _;
    }
    function x(_) {
      var M = w(_, "string");
      return typeof M == "symbol" ? M : String(M);
    }
    function w(_, M) {
      if (typeof _ != "object" || _ === null) return _;
      var N = _[Symbol.toPrimitive];
      if (N !== void 0) {
        var P = N.call(_, M);
        if (typeof P != "object") return P;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (M === "string" ? String : Number)(_);
    }
    class S extends t.Component {
      // React 16.3+
      // Arity (props, state)
      static getDerivedStateFromProps(M, N) {
        let {
          position: P
        } = M, {
          prevPropsPosition: I
        } = N;
        return P && (!I || P.x !== I.x || P.y !== I.y) ? ((0, u.default)("Draggable: getDerivedStateFromProps %j", {
          position: P,
          prevPropsPosition: I
        }), {
          x: P.x,
          y: P.y,
          prevPropsPosition: {
            ...P
          }
        }) : null;
      }
      constructor(M) {
        super(M), b(this, "onDragStart", (N, P) => {
          if ((0, u.default)("Draggable: onDragStart: %j", P), this.props.onStart(N, (0, s.createDraggableData)(this, P)) === !1) return !1;
          this.setState({
            dragging: !0,
            dragged: !0
          });
        }), b(this, "onDrag", (N, P) => {
          if (!this.state.dragging) return !1;
          (0, u.default)("Draggable: onDrag: %j", P);
          const I = (0, s.createDraggableData)(this, P), O = {
            x: I.x,
            y: I.y,
            slackX: 0,
            slackY: 0
          };
          if (this.props.bounds) {
            const {
              x: U,
              y: B
            } = O;
            O.x += this.state.slackX, O.y += this.state.slackY;
            const [G, Y] = (0, s.getBoundPosition)(this, O.x, O.y);
            O.x = G, O.y = Y, O.slackX = this.state.slackX + (U - O.x), O.slackY = this.state.slackY + (B - O.y), I.x = O.x, I.y = O.y, I.deltaX = O.x - this.state.x, I.deltaY = O.y - this.state.y;
          }
          if (this.props.onDrag(N, I) === !1) return !1;
          this.setState(O);
        }), b(this, "onDragStop", (N, P) => {
          if (!this.state.dragging || this.props.onStop(N, (0, s.createDraggableData)(this, P)) === !1) return !1;
          (0, u.default)("Draggable: onDragStop: %j", P);
          const O = {
            dragging: !1,
            slackX: 0,
            slackY: 0
          };
          if (!!this.props.position) {
            const {
              x: U,
              y: B
            } = this.props.position;
            O.x = U, O.y = B;
          }
          this.setState(O);
        }), this.state = {
          // Whether or not we are currently dragging.
          dragging: !1,
          // Whether or not we have been dragged before.
          dragged: !1,
          // Current transform x and y.
          x: M.position ? M.position.x : M.defaultPosition.x,
          y: M.position ? M.position.y : M.defaultPosition.y,
          prevPropsPosition: {
            ...M.position
          },
          // Used for compensating for out-of-bounds drags
          slackX: 0,
          slackY: 0,
          // Can only determine if SVG after mounting
          isElementSVG: !1
        }, M.position && !(M.onDrag || M.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
      }
      componentDidMount() {
        typeof window.SVGElement < "u" && this.findDOMNode() instanceof window.SVGElement && this.setState({
          isElementSVG: !0
        });
      }
      componentWillUnmount() {
        this.setState({
          dragging: !1
        });
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        var M, N;
        return (M = (N = this.props) === null || N === void 0 || (N = N.nodeRef) === null || N === void 0 ? void 0 : N.current) !== null && M !== void 0 ? M : r.default.findDOMNode(this);
      }
      render() {
        const {
          axis: M,
          bounds: N,
          children: P,
          defaultPosition: I,
          defaultClassName: O,
          defaultClassNameDragging: L,
          defaultClassNameDragged: U,
          position: B,
          positionOffset: G,
          scale: Y,
          ...he
        } = this.props;
        let ie = {}, ne = null;
        const Q = !!!B || this.state.dragging, X = B || I, Se = {
          // Set left if horizontal drag is enabled
          x: (0, s.canDragX)(this) && Q ? this.state.x : X.x,
          // Set top if vertical drag is enabled
          y: (0, s.canDragY)(this) && Q ? this.state.y : X.y
        };
        this.state.isElementSVG ? ne = (0, o.createSVGTransform)(Se, G) : ie = (0, o.createCSSTransform)(Se, G);
        const W = (0, i.default)(P.props.className || "", O, {
          [L]: this.state.dragging,
          [U]: this.state.dragged
        });
        return /* @__PURE__ */ t.createElement(c.default, g({}, he, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), /* @__PURE__ */ t.cloneElement(t.Children.only(P), {
          className: W,
          style: {
            ...P.props.style,
            ...ie
          },
          transform: ne
        }));
      }
    }
    e.default = S, b(S, "displayName", "Draggable"), b(S, "propTypes", {
      // Accepts all props <DraggableCore> accepts.
      ...c.default.propTypes,
      /**
       * `axis` determines which axis the draggable can move.
       *
       *  Note that all callbacks will still return data as normal. This only
       *  controls flushing to the DOM.
       *
       * 'both' allows movement horizontally and vertically.
       * 'x' limits movement to horizontal axis.
       * 'y' limits movement to vertical axis.
       * 'none' limits all movement.
       *
       * Defaults to 'both'.
       */
      axis: n.default.oneOf(["both", "x", "y", "none"]),
      /**
       * `bounds` determines the range of movement available to the element.
       * Available values are:
       *
       * 'parent' restricts movement within the Draggable's parent node.
       *
       * Alternatively, pass an object with the following properties, all of which are optional:
       *
       * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
       *
       * All values are in px.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable bounds={{right: 300, bottom: 300}}>
       *              <div>Content</div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      bounds: n.default.oneOfType([n.default.shape({
        left: n.default.number,
        right: n.default.number,
        top: n.default.number,
        bottom: n.default.number
      }), n.default.string, n.default.oneOf([!1])]),
      defaultClassName: n.default.string,
      defaultClassNameDragging: n.default.string,
      defaultClassNameDragged: n.default.string,
      /**
       * `defaultPosition` specifies the x and y that the dragged item should start at
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable defaultPosition={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      defaultPosition: n.default.shape({
        x: n.default.number,
        y: n.default.number
      }),
      positionOffset: n.default.shape({
        x: n.default.oneOfType([n.default.number, n.default.string]),
        y: n.default.oneOfType([n.default.number, n.default.string])
      }),
      /**
       * `position`, if present, defines the current position of the element.
       *
       *  This is similar to how form elements in React work - if no `position` is supplied, the component
       *  is uncontrolled.
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable position={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      position: n.default.shape({
        x: n.default.number,
        y: n.default.number
      }),
      /**
       * These properties should be defined on the child, not here.
       */
      className: a.dontSetMe,
      style: a.dontSetMe,
      transform: a.dontSetMe
    }), b(S, "defaultProps", {
      ...c.default.defaultProps,
      axis: "both",
      bounds: !1,
      defaultClassName: "react-draggable",
      defaultClassNameDragging: "react-draggable-dragging",
      defaultClassNameDragged: "react-draggable-dragged",
      defaultPosition: {
        x: 0,
        y: 0
      },
      scale: 1
    });
  })(SE)), SE;
}
var S3;
function Kze() {
  if (S3) return im.exports;
  S3 = 1;
  const {
    default: e,
    DraggableCore: t
  } = Gze();
  return im.exports = e, im.exports.default = e, im.exports.DraggableCore = t, im.exports;
}
var Zze = Kze();
const Yze = /* @__PURE__ */ Dc(Zze);
var br = function() {
  return br = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, br.apply(this, arguments);
}, k3 = {
  width: "100%",
  height: "10px",
  top: "0px",
  left: "0px",
  cursor: "row-resize"
}, C3 = {
  width: "10px",
  height: "100%",
  top: "0px",
  left: "0px",
  cursor: "col-resize"
}, h0 = {
  width: "20px",
  height: "20px",
  position: "absolute",
  zIndex: 1
}, Xze = {
  top: br(br({}, k3), { top: "-5px" }),
  right: br(br({}, C3), { left: void 0, right: "-5px" }),
  bottom: br(br({}, k3), { top: void 0, bottom: "-5px" }),
  left: br(br({}, C3), { left: "-5px" }),
  topRight: br(br({}, h0), { right: "-10px", top: "-10px", cursor: "ne-resize" }),
  bottomRight: br(br({}, h0), { right: "-10px", bottom: "-10px", cursor: "se-resize" }),
  bottomLeft: br(br({}, h0), { left: "-10px", bottom: "-10px", cursor: "sw-resize" }),
  topLeft: br(br({}, h0), { left: "-10px", top: "-10px", cursor: "nw-resize" })
}, Jze = C.memo(function(e) {
  var t = e.onResizeStart, n = e.direction, r = e.children, i = e.replaceStyles, o = e.className, s = C.useCallback(function(u) {
    t(u, n);
  }, [t, n]), a = C.useCallback(function(u) {
    t(u, n);
  }, [t, n]), c = C.useMemo(function() {
    return br(br({ position: "absolute", userSelect: "none" }, Xze[n]), i ?? {});
  }, [i, n]);
  return v.jsx("div", { className: o || void 0, style: c, onMouseDown: s, onTouchStart: a, children: r });
}), Qze = /* @__PURE__ */ (function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
})(), $s = function() {
  return $s = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, $s.apply(this, arguments);
}, eLe = {
  width: "auto",
  height: "auto"
}, p0 = function(e, t, n) {
  return Math.max(Math.min(e, n), t);
}, E3 = function(e, t, n) {
  var r = Math.round(e / t);
  return r * t + n * (r - 1);
}, wf = function(e, t) {
  return new RegExp(e, "i").test(t);
}, m0 = function(e) {
  return !!(e.touches && e.touches.length);
}, tLe = function(e) {
  return !!((e.clientX || e.clientX === 0) && (e.clientY || e.clientY === 0));
}, _3 = function(e, t, n) {
  n === void 0 && (n = 0);
  var r = t.reduce(function(o, s, a) {
    return Math.abs(s - e) < Math.abs(t[o] - e) ? a : o;
  }, 0), i = Math.abs(t[r] - e);
  return n === 0 || i < n ? t[r] : e;
}, _E = function(e) {
  return e = e.toString(), e === "auto" || e.endsWith("px") || e.endsWith("%") || e.endsWith("vh") || e.endsWith("vw") || e.endsWith("vmax") || e.endsWith("vmin") ? e : "".concat(e, "px");
}, g0 = function(e, t, n, r) {
  if (e && typeof e == "string") {
    if (e.endsWith("px"))
      return Number(e.replace("px", ""));
    if (e.endsWith("%")) {
      var i = Number(e.replace("%", "")) / 100;
      return t * i;
    }
    if (e.endsWith("vw")) {
      var i = Number(e.replace("vw", "")) / 100;
      return n * i;
    }
    if (e.endsWith("vh")) {
      var i = Number(e.replace("vh", "")) / 100;
      return r * i;
    }
  }
  return e;
}, nLe = function(e, t, n, r, i, o, s) {
  return r = g0(r, e.width, t, n), i = g0(i, e.height, t, n), o = g0(o, e.width, t, n), s = g0(s, e.height, t, n), {
    maxWidth: typeof r > "u" ? void 0 : Number(r),
    maxHeight: typeof i > "u" ? void 0 : Number(i),
    minWidth: typeof o > "u" ? void 0 : Number(o),
    minHeight: typeof s > "u" ? void 0 : Number(s)
  };
}, rLe = function(e) {
  return Array.isArray(e) ? e : [e, e];
}, iLe = [
  "as",
  "ref",
  "style",
  "className",
  "grid",
  "gridGap",
  "snap",
  "bounds",
  "boundsByDirection",
  "size",
  "defaultSize",
  "minWidth",
  "minHeight",
  "maxWidth",
  "maxHeight",
  "lockAspectRatio",
  "lockAspectRatioExtraWidth",
  "lockAspectRatioExtraHeight",
  "enable",
  "handleStyles",
  "handleClasses",
  "handleWrapperStyle",
  "handleWrapperClass",
  "children",
  "onResizeStart",
  "onResize",
  "onResizeStop",
  "handleComponent",
  "scale",
  "resizeRatio",
  "snapGap"
], T3 = "__resizable_base__", oLe = (
  /** @class */
  (function(e) {
    Qze(t, e);
    function t(n) {
      var r, i, o, s, a = e.call(this, n) || this;
      return a.ratio = 1, a.resizable = null, a.parentLeft = 0, a.parentTop = 0, a.resizableLeft = 0, a.resizableRight = 0, a.resizableTop = 0, a.resizableBottom = 0, a.targetLeft = 0, a.targetTop = 0, a.delta = {
        width: 0,
        height: 0
      }, a.appendBase = function() {
        if (!a.resizable || !a.window)
          return null;
        var c = a.parentNode;
        if (!c)
          return null;
        var u = a.window.document.createElement("div");
        return u.style.width = "100%", u.style.height = "100%", u.style.position = "absolute", u.style.transform = "scale(0, 0)", u.style.left = "0", u.style.flex = "0 0 100%", u.classList ? u.classList.add(T3) : u.className += T3, c.appendChild(u), u;
      }, a.removeBase = function(c) {
        var u = a.parentNode;
        u && u.removeChild(c);
      }, a.state = {
        isResizing: !1,
        width: (i = (r = a.propsSize) === null || r === void 0 ? void 0 : r.width) !== null && i !== void 0 ? i : "auto",
        height: (s = (o = a.propsSize) === null || o === void 0 ? void 0 : o.height) !== null && s !== void 0 ? s : "auto",
        direction: "right",
        original: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        backgroundStyle: {
          height: "100%",
          width: "100%",
          backgroundColor: "rgba(0,0,0,0)",
          cursor: "auto",
          opacity: 0,
          position: "fixed",
          zIndex: 9999,
          top: "0",
          left: "0",
          bottom: "0",
          right: "0"
        },
        flexBasis: void 0
      }, a.onResizeStart = a.onResizeStart.bind(a), a.onMouseMove = a.onMouseMove.bind(a), a.onMouseUp = a.onMouseUp.bind(a), a;
    }
    return Object.defineProperty(t.prototype, "parentNode", {
      get: function() {
        return this.resizable ? this.resizable.parentNode : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "window", {
      get: function() {
        return !this.resizable || !this.resizable.ownerDocument ? null : this.resizable.ownerDocument.defaultView;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "propsSize", {
      get: function() {
        return this.props.size || this.props.defaultSize || eLe;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "size", {
      get: function() {
        var n = 0, r = 0;
        if (this.resizable && this.window) {
          var i = this.resizable.offsetWidth, o = this.resizable.offsetHeight, s = this.resizable.style.position;
          s !== "relative" && (this.resizable.style.position = "relative"), n = this.resizable.style.width !== "auto" ? this.resizable.offsetWidth : i, r = this.resizable.style.height !== "auto" ? this.resizable.offsetHeight : o, this.resizable.style.position = s;
        }
        return { width: n, height: r };
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "sizeStyle", {
      get: function() {
        var n = this, r = this.props.size, i = function(a) {
          var c;
          if (typeof n.state[a] > "u" || n.state[a] === "auto")
            return "auto";
          if (n.propsSize && n.propsSize[a] && (!((c = n.propsSize[a]) === null || c === void 0) && c.toString().endsWith("%"))) {
            if (n.state[a].toString().endsWith("%"))
              return n.state[a].toString();
            var u = n.getParentSize(), f = Number(n.state[a].toString().replace("px", "")), h = f / u[a] * 100;
            return "".concat(h, "%");
          }
          return _E(n.state[a]);
        }, o = r && typeof r.width < "u" && !this.state.isResizing ? _E(r.width) : i("width"), s = r && typeof r.height < "u" && !this.state.isResizing ? _E(r.height) : i("height");
        return { width: o, height: s };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.getParentSize = function() {
      if (!this.parentNode)
        return this.window ? { width: this.window.innerWidth, height: this.window.innerHeight } : { width: 0, height: 0 };
      var n = this.appendBase();
      if (!n)
        return { width: 0, height: 0 };
      var r = !1, i = this.parentNode.style.flexWrap;
      i !== "wrap" && (r = !0, this.parentNode.style.flexWrap = "wrap"), n.style.position = "relative", n.style.minWidth = "100%", n.style.minHeight = "100%";
      var o = {
        width: n.offsetWidth,
        height: n.offsetHeight
      };
      return r && (this.parentNode.style.flexWrap = i), this.removeBase(n), o;
    }, t.prototype.bindEvents = function() {
      this.window && (this.window.addEventListener("mouseup", this.onMouseUp), this.window.addEventListener("mousemove", this.onMouseMove), this.window.addEventListener("mouseleave", this.onMouseUp), this.window.addEventListener("touchmove", this.onMouseMove, {
        capture: !0,
        passive: !1
      }), this.window.addEventListener("touchend", this.onMouseUp));
    }, t.prototype.unbindEvents = function() {
      this.window && (this.window.removeEventListener("mouseup", this.onMouseUp), this.window.removeEventListener("mousemove", this.onMouseMove), this.window.removeEventListener("mouseleave", this.onMouseUp), this.window.removeEventListener("touchmove", this.onMouseMove, !0), this.window.removeEventListener("touchend", this.onMouseUp));
    }, t.prototype.componentDidMount = function() {
      if (!(!this.resizable || !this.window)) {
        var n = this.window.getComputedStyle(this.resizable);
        this.setState({
          width: this.state.width || this.size.width,
          height: this.state.height || this.size.height,
          flexBasis: n.flexBasis !== "auto" ? n.flexBasis : void 0
        });
      }
    }, t.prototype.componentWillUnmount = function() {
      this.window && this.unbindEvents();
    }, t.prototype.createSizeForCssProperty = function(n, r) {
      var i = this.propsSize && this.propsSize[r];
      return this.state[r] === "auto" && this.state.original[r] === n && (typeof i > "u" || i === "auto") ? "auto" : n;
    }, t.prototype.calculateNewMaxFromBoundary = function(n, r) {
      var i = this.props.boundsByDirection, o = this.state.direction, s = i && wf("left", o), a = i && wf("top", o), c, u;
      if (this.props.bounds === "parent") {
        var f = this.parentNode;
        f && (c = s ? this.resizableRight - this.parentLeft : f.offsetWidth + (this.parentLeft - this.resizableLeft), u = a ? this.resizableBottom - this.parentTop : f.offsetHeight + (this.parentTop - this.resizableTop));
      } else this.props.bounds === "window" ? this.window && (c = s ? this.resizableRight : this.window.innerWidth - this.resizableLeft, u = a ? this.resizableBottom : this.window.innerHeight - this.resizableTop) : this.props.bounds && (c = s ? this.resizableRight - this.targetLeft : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft), u = a ? this.resizableBottom - this.targetTop : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop));
      return c && Number.isFinite(c) && (n = n && n < c ? n : c), u && Number.isFinite(u) && (r = r && r < u ? r : u), { maxWidth: n, maxHeight: r };
    }, t.prototype.calculateNewSizeFromDirection = function(n, r) {
      var i = this.props.scale || 1, o = rLe(this.props.resizeRatio || 1), s = o[0], a = o[1], c = this.state, u = c.direction, f = c.original, h = this.props, m = h.lockAspectRatio, g = h.lockAspectRatioExtraHeight, b = h.lockAspectRatioExtraWidth, x = f.width, w = f.height, S = g || 0, _ = b || 0;
      return wf("right", u) && (x = f.width + (n - f.x) * s / i, m && (w = (x - _) / this.ratio + S)), wf("left", u) && (x = f.width - (n - f.x) * s / i, m && (w = (x - _) / this.ratio + S)), wf("bottom", u) && (w = f.height + (r - f.y) * a / i, m && (x = (w - S) * this.ratio + _)), wf("top", u) && (w = f.height - (r - f.y) * a / i, m && (x = (w - S) * this.ratio + _)), { newWidth: x, newHeight: w };
    }, t.prototype.calculateNewSizeFromAspectRatio = function(n, r, i, o) {
      var s = this.props, a = s.lockAspectRatio, c = s.lockAspectRatioExtraHeight, u = s.lockAspectRatioExtraWidth, f = typeof o.width > "u" ? 10 : o.width, h = typeof i.width > "u" || i.width < 0 ? n : i.width, m = typeof o.height > "u" ? 10 : o.height, g = typeof i.height > "u" || i.height < 0 ? r : i.height, b = c || 0, x = u || 0;
      if (a) {
        var w = (m - b) * this.ratio + x, S = (g - b) * this.ratio + x, _ = (f - x) / this.ratio + b, M = (h - x) / this.ratio + b, N = Math.max(f, w), P = Math.min(h, S), I = Math.max(m, _), O = Math.min(g, M);
        n = p0(n, N, P), r = p0(r, I, O);
      } else
        n = p0(n, f, h), r = p0(r, m, g);
      return { newWidth: n, newHeight: r };
    }, t.prototype.setBoundingClientRect = function() {
      var n = 1 / (this.props.scale || 1);
      if (this.props.bounds === "parent") {
        var r = this.parentNode;
        if (r) {
          var i = r.getBoundingClientRect();
          this.parentLeft = i.left * n, this.parentTop = i.top * n;
        }
      }
      if (this.props.bounds && typeof this.props.bounds != "string") {
        var o = this.props.bounds.getBoundingClientRect();
        this.targetLeft = o.left * n, this.targetTop = o.top * n;
      }
      if (this.resizable) {
        var s = this.resizable.getBoundingClientRect(), a = s.left, c = s.top, u = s.right, f = s.bottom;
        this.resizableLeft = a * n, this.resizableRight = u * n, this.resizableTop = c * n, this.resizableBottom = f * n;
      }
    }, t.prototype.onResizeStart = function(n, r) {
      if (!(!this.resizable || !this.window)) {
        var i = 0, o = 0;
        if (n.nativeEvent && tLe(n.nativeEvent) ? (i = n.nativeEvent.clientX, o = n.nativeEvent.clientY) : n.nativeEvent && m0(n.nativeEvent) && (i = n.nativeEvent.touches[0].clientX, o = n.nativeEvent.touches[0].clientY), this.props.onResizeStart && this.resizable) {
          var s = this.props.onResizeStart(n, r, this.resizable);
          if (s === !1)
            return;
        }
        this.props.size && (typeof this.props.size.height < "u" && this.props.size.height !== this.state.height && this.setState({ height: this.props.size.height }), typeof this.props.size.width < "u" && this.props.size.width !== this.state.width && this.setState({ width: this.props.size.width })), this.ratio = typeof this.props.lockAspectRatio == "number" ? this.props.lockAspectRatio : this.size.width / this.size.height;
        var a, c = this.window.getComputedStyle(this.resizable);
        if (c.flexBasis !== "auto") {
          var u = this.parentNode;
          if (u) {
            var f = this.window.getComputedStyle(u).flexDirection;
            this.flexDir = f.startsWith("row") ? "row" : "column", a = c.flexBasis;
          }
        }
        this.setBoundingClientRect(), this.bindEvents();
        var h = {
          original: {
            x: i,
            y: o,
            width: this.size.width,
            height: this.size.height
          },
          isResizing: !0,
          backgroundStyle: $s($s({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(n.target).cursor || "auto" }),
          direction: r,
          flexBasis: a
        };
        this.setState(h);
      }
    }, t.prototype.onMouseMove = function(n) {
      var r = this;
      if (!(!this.state.isResizing || !this.resizable || !this.window)) {
        if (this.window.TouchEvent && m0(n))
          try {
            n.preventDefault(), n.stopPropagation();
          } catch {
          }
        var i = this.props, o = i.maxWidth, s = i.maxHeight, a = i.minWidth, c = i.minHeight, u = m0(n) ? n.touches[0].clientX : n.clientX, f = m0(n) ? n.touches[0].clientY : n.clientY, h = this.state, m = h.direction, g = h.original, b = h.width, x = h.height, w = this.getParentSize(), S = nLe(w, this.window.innerWidth, this.window.innerHeight, o, s, a, c);
        o = S.maxWidth, s = S.maxHeight, a = S.minWidth, c = S.minHeight;
        var _ = this.calculateNewSizeFromDirection(u, f), M = _.newHeight, N = _.newWidth, P = this.calculateNewMaxFromBoundary(o, s);
        this.props.snap && this.props.snap.x && (N = _3(N, this.props.snap.x, this.props.snapGap)), this.props.snap && this.props.snap.y && (M = _3(M, this.props.snap.y, this.props.snapGap));
        var I = this.calculateNewSizeFromAspectRatio(N, M, { width: P.maxWidth, height: P.maxHeight }, { width: a, height: c });
        if (N = I.newWidth, M = I.newHeight, this.props.grid) {
          var O = E3(N, this.props.grid[0], this.props.gridGap ? this.props.gridGap[0] : 0), L = E3(M, this.props.grid[1], this.props.gridGap ? this.props.gridGap[1] : 0), U = this.props.snapGap || 0, B = U === 0 || Math.abs(O - N) <= U ? O : N, G = U === 0 || Math.abs(L - M) <= U ? L : M;
          N = B, M = G;
        }
        var Y = {
          width: N - g.width,
          height: M - g.height
        };
        if (this.delta = Y, b && typeof b == "string") {
          if (b.endsWith("%")) {
            var he = N / w.width * 100;
            N = "".concat(he, "%");
          } else if (b.endsWith("vw")) {
            var ie = N / this.window.innerWidth * 100;
            N = "".concat(ie, "vw");
          } else if (b.endsWith("vh")) {
            var ne = N / this.window.innerHeight * 100;
            N = "".concat(ne, "vh");
          }
        }
        if (x && typeof x == "string") {
          if (x.endsWith("%")) {
            var he = M / w.height * 100;
            M = "".concat(he, "%");
          } else if (x.endsWith("vw")) {
            var ie = M / this.window.innerWidth * 100;
            M = "".concat(ie, "vw");
          } else if (x.endsWith("vh")) {
            var ne = M / this.window.innerHeight * 100;
            M = "".concat(ne, "vh");
          }
        }
        var H = {
          width: this.createSizeForCssProperty(N, "width"),
          height: this.createSizeForCssProperty(M, "height")
        };
        this.flexDir === "row" ? H.flexBasis = H.width : this.flexDir === "column" && (H.flexBasis = H.height);
        var Q = this.state.width !== H.width, X = this.state.height !== H.height, Se = this.state.flexBasis !== H.flexBasis, W = Q || X || Se;
        W && tl.flushSync(function() {
          r.setState(H);
        }), this.props.onResize && W && this.props.onResize(n, m, this.resizable, Y);
      }
    }, t.prototype.onMouseUp = function(n) {
      var r, i, o = this.state, s = o.isResizing, a = o.direction;
      o.original, !(!s || !this.resizable) && (this.props.onResizeStop && this.props.onResizeStop(n, a, this.resizable, this.delta), this.props.size && this.setState({ width: (r = this.props.size.width) !== null && r !== void 0 ? r : "auto", height: (i = this.props.size.height) !== null && i !== void 0 ? i : "auto" }), this.unbindEvents(), this.setState({
        isResizing: !1,
        backgroundStyle: $s($s({}, this.state.backgroundStyle), { cursor: "auto" })
      }));
    }, t.prototype.updateSize = function(n) {
      var r, i;
      this.setState({ width: (r = n.width) !== null && r !== void 0 ? r : "auto", height: (i = n.height) !== null && i !== void 0 ? i : "auto" });
    }, t.prototype.renderResizer = function() {
      var n = this, r = this.props, i = r.enable, o = r.handleStyles, s = r.handleClasses, a = r.handleWrapperStyle, c = r.handleWrapperClass, u = r.handleComponent;
      if (!i)
        return null;
      var f = Object.keys(i).map(function(h) {
        return i[h] !== !1 ? v.jsx(Jze, { direction: h, onResizeStart: n.onResizeStart, replaceStyles: o && o[h], className: s && s[h], children: u && u[h] ? u[h] : null }, h) : null;
      });
      return v.jsx("div", { className: c, style: a, children: f });
    }, t.prototype.render = function() {
      var n = this, r = Object.keys(this.props).reduce(function(s, a) {
        return iLe.indexOf(a) !== -1 || (s[a] = n.props[a]), s;
      }, {}), i = $s($s($s({ position: "relative", userSelect: this.state.isResizing ? "none" : "auto" }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: "border-box", flexShrink: 0 });
      this.state.flexBasis && (i.flexBasis = this.state.flexBasis);
      var o = this.props.as || "div";
      return v.jsxs(o, $s({ style: i, className: this.props.className }, r, {
        // `ref` is after `extendsProps` to ensure this one wins over a version
        // passed in
        ref: function(s) {
          s && (n.resizable = s);
        },
        children: [this.state.isResizing && v.jsx("div", { style: this.state.backgroundStyle }), this.props.children, this.renderResizer()]
      }));
    }, t.defaultProps = {
      as: "div",
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      enable: {
        top: !0,
        right: !0,
        bottom: !0,
        left: !0,
        topRight: !0,
        bottomRight: !0,
        bottomLeft: !0,
        topLeft: !0
      },
      style: {},
      grid: [1, 1],
      gridGap: [0, 0],
      lockAspectRatio: !1,
      lockAspectRatioExtraWidth: 0,
      lockAspectRatioExtraHeight: 0,
      scale: 1,
      resizeRatio: 1,
      snapGap: 0
    }, t;
  })(C.PureComponent)
);
var UT = function(e, t) {
  return UT = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r) r.hasOwnProperty(i) && (n[i] = r[i]);
  }, UT(e, t);
};
function sLe(e, t) {
  UT(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Rr = function() {
  return Rr = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, Rr.apply(this, arguments);
};
function aLe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
var lLe = {
  width: "auto",
  height: "auto",
  display: "inline-block",
  position: "absolute",
  top: 0,
  left: 0
}, cLe = function(e) {
  return {
    bottom: e,
    bottomLeft: e,
    bottomRight: e,
    left: e,
    right: e,
    top: e,
    topLeft: e,
    topRight: e
  };
}, uLe = (
  /** @class */
  (function(e) {
    sLe(t, e);
    function t(n) {
      var r = e.call(this, n) || this;
      return r.resizingPosition = { x: 0, y: 0 }, r.offsetFromParent = { left: 0, top: 0 }, r.resizableElement = { current: null }, r.originalPosition = { x: 0, y: 0 }, r.state = {
        resizing: !1,
        bounds: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        },
        maxWidth: n.maxWidth,
        maxHeight: n.maxHeight
      }, r.onResizeStart = r.onResizeStart.bind(r), r.onResize = r.onResize.bind(r), r.onResizeStop = r.onResizeStop.bind(r), r.onDragStart = r.onDragStart.bind(r), r.onDrag = r.onDrag.bind(r), r.onDragStop = r.onDragStop.bind(r), r.getMaxSizesFromProps = r.getMaxSizesFromProps.bind(r), r;
    }
    return t.prototype.componentDidMount = function() {
      this.updateOffsetFromParent();
      var n = this.offsetFromParent, r = n.left, i = n.top, o = this.getDraggablePosition(), s = o.x, a = o.y;
      this.draggable.setState({
        x: s - r,
        y: a - i
      }), this.forceUpdate();
    }, t.prototype.getDraggablePosition = function() {
      var n = this.draggable.state, r = n.x, i = n.y;
      return { x: r, y: i };
    }, t.prototype.getParent = function() {
      return this.resizable && this.resizable.parentNode;
    }, t.prototype.getParentSize = function() {
      return this.resizable.getParentSize();
    }, t.prototype.getMaxSizesFromProps = function() {
      var n = typeof this.props.maxWidth > "u" ? Number.MAX_SAFE_INTEGER : this.props.maxWidth, r = typeof this.props.maxHeight > "u" ? Number.MAX_SAFE_INTEGER : this.props.maxHeight;
      return { maxWidth: n, maxHeight: r };
    }, t.prototype.getSelfElement = function() {
      return this.resizable && this.resizable.resizable;
    }, t.prototype.getOffsetHeight = function(n) {
      var r = this.props.scale;
      switch (this.props.bounds) {
        case "window":
          return window.innerHeight / r;
        case "body":
          return document.body.offsetHeight / r;
        default:
          return n.offsetHeight;
      }
    }, t.prototype.getOffsetWidth = function(n) {
      var r = this.props.scale;
      switch (this.props.bounds) {
        case "window":
          return window.innerWidth / r;
        case "body":
          return document.body.offsetWidth / r;
        default:
          return n.offsetWidth;
      }
    }, t.prototype.onDragStart = function(n, r) {
      this.props.onDragStart && this.props.onDragStart(n, r);
      var i = this.getDraggablePosition();
      if (this.originalPosition = i, !!this.props.bounds) {
        var o = this.getParent(), s = this.props.scale, a;
        if (this.props.bounds === "parent")
          a = o;
        else if (this.props.bounds === "body") {
          var c = o.getBoundingClientRect(), u = c.left, f = c.top, h = document.body.getBoundingClientRect(), m = -(u - o.offsetLeft * s - h.left) / s, g = -(f - o.offsetTop * s - h.top) / s, b = (document.body.offsetWidth - this.resizable.size.width * s) / s + m, x = (document.body.offsetHeight - this.resizable.size.height * s) / s + g;
          return this.setState({ bounds: { top: g, right: b, bottom: x, left: m } });
        } else if (this.props.bounds === "window") {
          if (!this.resizable)
            return;
          var w = o.getBoundingClientRect(), S = w.left, _ = w.top, M = -(S - o.offsetLeft * s) / s, N = -(_ - o.offsetTop * s) / s, b = (window.innerWidth - this.resizable.size.width * s) / s + M, x = (window.innerHeight - this.resizable.size.height * s) / s + N;
          return this.setState({ bounds: { top: N, right: b, bottom: x, left: M } });
        } else typeof this.props.bounds == "string" ? a = document.querySelector(this.props.bounds) : this.props.bounds instanceof HTMLElement && (a = this.props.bounds);
        if (!(!(a instanceof HTMLElement) || !(o instanceof HTMLElement))) {
          var P = a.getBoundingClientRect(), I = P.left, O = P.top, L = o.getBoundingClientRect(), U = L.left, B = L.top, G = (I - U) / s, Y = O - B;
          if (this.resizable) {
            this.updateOffsetFromParent();
            var he = this.offsetFromParent;
            this.setState({
              bounds: {
                top: Y - he.top,
                right: G + (a.offsetWidth - this.resizable.size.width) - he.left / s,
                bottom: Y + (a.offsetHeight - this.resizable.size.height) - he.top,
                left: G - he.left / s
              }
            });
          }
        }
      }
    }, t.prototype.onDrag = function(n, r) {
      if (this.props.onDrag) {
        var i = this.offsetFromParent, o = i.left, s = i.top;
        if (!this.props.dragAxis || this.props.dragAxis === "both")
          return this.props.onDrag(n, Rr(Rr({}, r), { x: r.x + o, y: r.y + s }));
        if (this.props.dragAxis === "x")
          return this.props.onDrag(n, Rr(Rr({}, r), { x: r.x + o, y: this.originalPosition.y + s, deltaY: 0 }));
        if (this.props.dragAxis === "y")
          return this.props.onDrag(n, Rr(Rr({}, r), { x: this.originalPosition.x + o, y: r.y + s, deltaX: 0 }));
      }
    }, t.prototype.onDragStop = function(n, r) {
      if (this.props.onDragStop) {
        var i = this.offsetFromParent, o = i.left, s = i.top;
        if (!this.props.dragAxis || this.props.dragAxis === "both")
          return this.props.onDragStop(n, Rr(Rr({}, r), { x: r.x + o, y: r.y + s }));
        if (this.props.dragAxis === "x")
          return this.props.onDragStop(n, Rr(Rr({}, r), { x: r.x + o, y: this.originalPosition.y + s, deltaY: 0 }));
        if (this.props.dragAxis === "y")
          return this.props.onDragStop(n, Rr(Rr({}, r), { x: this.originalPosition.x + o, y: r.y + s, deltaX: 0 }));
      }
    }, t.prototype.onResizeStart = function(n, r, i) {
      n.stopPropagation(), this.setState({
        resizing: !0
      });
      var o = this.props.scale, s = this.offsetFromParent, a = this.getDraggablePosition();
      if (this.resizingPosition = { x: a.x + s.left, y: a.y + s.top }, this.originalPosition = a, this.props.bounds) {
        var c = this.getParent(), u = void 0;
        this.props.bounds === "parent" ? u = c : this.props.bounds === "body" ? u = document.body : this.props.bounds === "window" ? u = window : typeof this.props.bounds == "string" ? u = document.querySelector(this.props.bounds) : this.props.bounds instanceof HTMLElement && (u = this.props.bounds);
        var f = this.getSelfElement();
        if (f instanceof Element && (u instanceof HTMLElement || u === window) && c instanceof HTMLElement) {
          var h = this.getMaxSizesFromProps(), m = h.maxWidth, g = h.maxHeight, b = this.getParentSize();
          if (m && typeof m == "string")
            if (m.endsWith("%")) {
              var x = Number(m.replace("%", "")) / 100;
              m = b.width * x;
            } else m.endsWith("px") && (m = Number(m.replace("px", "")));
          if (g && typeof g == "string")
            if (g.endsWith("%")) {
              var x = Number(g.replace("%", "")) / 100;
              g = b.height * x;
            } else g.endsWith("px") && (g = Number(g.replace("px", "")));
          var w = f.getBoundingClientRect(), S = w.left, _ = w.top, M = this.props.bounds === "window" ? { left: 0, top: 0 } : u.getBoundingClientRect(), N = M.left, P = M.top, I = this.getOffsetWidth(u), O = this.getOffsetHeight(u), L = r.toLowerCase().endsWith("left"), U = r.toLowerCase().endsWith("right"), B = r.startsWith("top"), G = r.startsWith("bottom");
          if ((L || B) && this.resizable) {
            var Y = (S - N) / o + this.resizable.size.width;
            this.setState({ maxWidth: Y > Number(m) ? m : Y });
          }
          if (U || this.props.lockAspectRatio && !L && !B) {
            var Y = I + (N - S) / o;
            this.setState({ maxWidth: Y > Number(m) ? m : Y });
          }
          if ((B || L) && this.resizable) {
            var Y = (_ - P) / o + this.resizable.size.height;
            this.setState({
              maxHeight: Y > Number(g) ? g : Y
            });
          }
          if (G || this.props.lockAspectRatio && !B && !L) {
            var Y = O + (P - _) / o;
            this.setState({
              maxHeight: Y > Number(g) ? g : Y
            });
          }
        }
      } else
        this.setState({
          maxWidth: this.props.maxWidth,
          maxHeight: this.props.maxHeight
        });
      this.props.onResizeStart && this.props.onResizeStart(n, r, i);
    }, t.prototype.onResize = function(n, r, i, o) {
      var s = this, a = { x: this.originalPosition.x, y: this.originalPosition.y }, c = -o.width, u = -o.height, f = ["top", "left", "topLeft", "bottomLeft", "topRight"];
      f.includes(r) && (r === "bottomLeft" ? a.x += c : (r === "topRight" || (a.x += c), a.y += u));
      var h = this.draggable.state;
      (a.x !== h.x || a.y !== h.y) && tl.flushSync(function() {
        s.draggable.setState(a);
      }), this.updateOffsetFromParent();
      var m = this.offsetFromParent, g = this.getDraggablePosition().x + m.left, b = this.getDraggablePosition().y + m.top;
      this.resizingPosition = { x: g, y: b }, this.props.onResize && this.props.onResize(n, r, i, o, {
        x: g,
        y: b
      });
    }, t.prototype.onResizeStop = function(n, r, i, o) {
      this.setState({
        resizing: !1
      });
      var s = this.getMaxSizesFromProps(), a = s.maxWidth, c = s.maxHeight;
      this.setState({ maxWidth: a, maxHeight: c }), this.props.onResizeStop && this.props.onResizeStop(n, r, i, o, this.resizingPosition);
    }, t.prototype.updateSize = function(n) {
      this.resizable && this.resizable.updateSize({ width: n.width, height: n.height });
    }, t.prototype.updatePosition = function(n) {
      this.draggable.setState(n);
    }, t.prototype.updateOffsetFromParent = function() {
      var n = this.props.scale, r = this.getParent(), i = this.getSelfElement();
      if (!r || i === null)
        return {
          top: 0,
          left: 0
        };
      var o = r.getBoundingClientRect(), s = o.left, a = o.top, c = i.getBoundingClientRect(), u = this.getDraggablePosition(), f = r.scrollLeft, h = r.scrollTop;
      this.offsetFromParent = {
        left: c.left - s + f - u.x * n,
        top: c.top - a + h - u.y * n
      };
    }, t.prototype.render = function() {
      var n = this, r = this.props, i = r.disableDragging, o = r.style, s = r.dragHandleClassName, a = r.position, c = r.onMouseDown, u = r.onMouseUp, f = r.dragAxis, h = r.dragGrid, m = r.bounds, g = r.enableUserSelectHack, b = r.cancel, x = r.children;
      r.onResizeStart, r.onResize, r.onResizeStop, r.onDragStart, r.onDrag, r.onDragStop;
      var w = r.resizeHandleStyles, S = r.resizeHandleClasses, _ = r.resizeHandleComponent, M = r.enableResizing, N = r.resizeGrid, P = r.resizeHandleWrapperClass, I = r.resizeHandleWrapperStyle, O = r.scale, L = r.allowAnyClick, U = r.dragPositionOffset, B = aLe(r, ["disableDragging", "style", "dragHandleClassName", "position", "onMouseDown", "onMouseUp", "dragAxis", "dragGrid", "bounds", "enableUserSelectHack", "cancel", "children", "onResizeStart", "onResize", "onResizeStop", "onDragStart", "onDrag", "onDragStop", "resizeHandleStyles", "resizeHandleClasses", "resizeHandleComponent", "enableResizing", "resizeGrid", "resizeHandleWrapperClass", "resizeHandleWrapperStyle", "scale", "allowAnyClick", "dragPositionOffset"]), G = this.props.default ? Rr({}, this.props.default) : void 0;
      delete B.default;
      var Y = i || s ? { cursor: "auto" } : { cursor: "move" }, he = Rr(Rr(Rr({}, lLe), Y), o), ie = this.offsetFromParent, ne = ie.left, H = ie.top, Q;
      a && (Q = {
        x: a.x - ne,
        y: a.y - H
      });
      var X = this.state.resizing ? void 0 : Q, Se = this.state.resizing ? "both" : f;
      return C.createElement(
        Yze,
        {
          ref: function(W) {
            W && (n.draggable = W);
          },
          handle: s ? ".".concat(s) : void 0,
          defaultPosition: G,
          onMouseDown: c,
          // @ts-expect-error
          onMouseUp: u,
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop,
          axis: Se,
          disabled: i,
          grid: h,
          bounds: m ? this.state.bounds : void 0,
          position: X,
          enableUserSelectHack: g,
          cancel: b,
          scale: O,
          allowAnyClick: L,
          nodeRef: this.resizableElement,
          positionOffset: U
        },
        C.createElement(oLe, Rr({}, B, { ref: function(W) {
          W && (n.resizable = W, n.resizableElement.current = W.resizable);
        }, defaultSize: G, size: this.props.size, enable: typeof M == "boolean" ? cLe(M) : M, onResizeStart: this.onResizeStart, onResize: this.onResize, onResizeStop: this.onResizeStop, style: he, minWidth: this.props.minWidth, minHeight: this.props.minHeight, maxWidth: this.state.resizing ? this.state.maxWidth : this.props.maxWidth, maxHeight: this.state.resizing ? this.state.maxHeight : this.props.maxHeight, grid: N, handleWrapperClass: P, handleWrapperStyle: I, lockAspectRatio: this.props.lockAspectRatio, lockAspectRatioExtraWidth: this.props.lockAspectRatioExtraWidth, lockAspectRatioExtraHeight: this.props.lockAspectRatioExtraHeight, handleStyles: w, handleClasses: S, handleComponent: _, scale: this.props.scale }), x)
      );
    }, t.defaultProps = {
      maxWidth: Number.MAX_SAFE_INTEGER,
      maxHeight: Number.MAX_SAFE_INTEGER,
      scale: 1,
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      onDragStart: function() {
      },
      onDrag: function() {
      },
      onDragStop: function() {
      }
    }, t;
  })(C.PureComponent)
);
function dLe() {
  return `temp-${s8()}`;
}
const fLe = () => {
  $3();
  const [e, t] = C.useState(!1), [n, r] = C.useState(!1), {
    chatbotStore: { chatbotReady: i, ChatbotConfig: o, ChatbotThreadConfig: s, isLoadingThread: a },
    chatbotStore: c,
    chatbotThreadStore: { threadMentions: u }
  } = ra();
  if (!c.currentThreadId.value) {
    const f = dLe();
    c.currentThreadId.value = f;
  }
  return C.useEffect(() => {
    o();
  }, []), C.useEffect(() => {
    let f = !1;
    return e && i.value && !n && (a.value = !0, s().then(() => {
      f || r(!0);
    }).catch((h) => {
      f || console.error("Failed to configure thread:", h);
    }).finally(() => {
      f || (a.value = !1);
    })), () => {
      f = !0;
    };
  }, [e, i.value, n, s]), i.value ? /* @__PURE__ */ v.jsxs(v.Fragment, { children: [
    /* @__PURE__ */ v.jsx(
      uLe,
      {
        default: {
          x: window.innerWidth - 850,
          y: 120,
          width: 800,
          height: window.innerHeight - 150
        },
        minWidth: 500,
        minHeight: 400,
        maxWidth: window.innerWidth - 100,
        maxHeight: window.innerHeight - 100,
        bounds: "window",
        dragHandleClassName: "chatbot-drag-handle",
        className: "z-50",
        style: {
          position: "fixed",
          opacity: e ? 1 : 0,
          visibility: e ? "visible" : "hidden",
          pointerEvents: e ? "auto" : "none"
        },
        children: /* @__PURE__ */ v.jsx("div", { className: "w-full h-full rounded-2xl shadow-xl border backdrop-blur-md flex flex-col bg-background overflow-hidden z-[1000]", children: /* @__PURE__ */ v.jsx(
          $ze,
          {
            onClose: () => {
              t(!1), u.value = {};
            },
            threadId: c.currentThreadId.value || ""
          }
        ) })
      }
    ),
    !e && /* @__PURE__ */ v.jsx(
      "button",
      {
        onClick: () => t(!0),
        className: "fixed bottom-4 right-4 z-50 cursor-pointer p-3 rounded-full border-2 shadow-sm bg-background hover:bg-core-navy-60 hover:shadow-2xl transition-all",
        children: /* @__PURE__ */ v.jsx(HT, { className: "h-6 w-6" })
      }
    )
  ] }) : null;
}, hLe = C.memo(fLe);
let za = null;
const pLe = {
  init(e) {
    if (!e.apiHost) {
      console.error("ChatbotEmbed: apiHost is required");
      return;
    }
    const t = e.containerId || "chatbot-root";
    let n = document.getElementById(t);
    return n || (n = document.createElement("div"), n.id = t, document.body.appendChild(n)), window.__CHATBOT_CONFIG__ = e, nle(e.apiHost), za || (za = FK.createRoot(n)), za.render(
      Ne.createElement(
        Ne.StrictMode,
        null,
        Ne.createElement(hLe)
      )
    ), {
      destroy: () => {
        za && (za.unmount(), za = null), n && n.parentNode && n.parentNode.removeChild(n);
      }
    };
  },
  destroy() {
    za && (za.unmount(), za = null);
  }
};
typeof window < "u" && (window.ChatbotEmbed = pLe);
export {
  f9 as C,
  XAe as J,
  qT as L,
  Ne as R,
  h9 as a,
  qle as b,
  Gle as c,
  p9 as d,
  yLe as e,
  hc as f,
  vLe as g,
  Dc as h,
  PK as i,
  v as j,
  fG as k,
  RPe as l,
  at as m,
  pLe as n,
  C as r
};
