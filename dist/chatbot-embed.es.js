function JN(e, t) {
  for (var n = 0; n < t.length; n++) {
    const o = t[n];
    if (typeof o != "string" && !Array.isArray(o)) {
      for (const a in o)
        if (a !== "default" && !(a in e)) {
          const l = Object.getOwnPropertyDescriptor(o, a);
          l && Object.defineProperty(e, a, l.get ? l : {
            enumerable: !0,
            get: () => o[a]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
function Ml(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function QN(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function o() {
      var a = !1;
      try {
        a = this instanceof o;
      } catch {
      }
      return a ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(o) {
    var a = Object.getOwnPropertyDescriptor(e, o);
    Object.defineProperty(n, o, a.get ? a : {
      enumerable: !0,
      get: function() {
        return e[o];
      }
    });
  }), n;
}
var xp = { exports: {} }, Te = {};
var Qx;
function eO() {
  if (Qx) return Te;
  Qx = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), o = /* @__PURE__ */ Symbol.for("react.strict_mode"), a = /* @__PURE__ */ Symbol.for("react.profiler"), l = /* @__PURE__ */ Symbol.for("react.consumer"), c = /* @__PURE__ */ Symbol.for("react.context"), f = /* @__PURE__ */ Symbol.for("react.forward_ref"), d = /* @__PURE__ */ Symbol.for("react.suspense"), h = /* @__PURE__ */ Symbol.for("react.memo"), m = /* @__PURE__ */ Symbol.for("react.lazy"), g = /* @__PURE__ */ Symbol.for("react.activity"), b = Symbol.iterator;
  function x(k) {
    return k === null || typeof k != "object" ? null : (k = b && k[b] || k["@@iterator"], typeof k == "function" ? k : null);
  }
  var _ = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, E = Object.assign, T = {};
  function C(k, X, H) {
    this.props = k, this.context = X, this.refs = T, this.updater = H || _;
  }
  C.prototype.isReactComponent = {}, C.prototype.setState = function(k, X) {
    if (typeof k != "object" && typeof k != "function" && k != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, k, X, "setState");
  }, C.prototype.forceUpdate = function(k) {
    this.updater.enqueueForceUpdate(this, k, "forceUpdate");
  };
  function z() {
  }
  z.prototype = C.prototype;
  function A(k, X, H) {
    this.props = k, this.context = X, this.refs = T, this.updater = H || _;
  }
  var R = A.prototype = new z();
  R.constructor = A, E(R, C.prototype), R.isPureReactComponent = !0;
  var O = Array.isArray;
  function L() {
  }
  var M = { H: null, A: null, T: null, S: null }, N = Object.prototype.hasOwnProperty;
  function j(k, X, H) {
    var K = H.ref;
    return {
      $$typeof: e,
      type: k,
      key: X,
      ref: K !== void 0 ? K : null,
      props: H
    };
  }
  function Y(k, X) {
    return j(k.type, X, k.props);
  }
  function ne(k) {
    return typeof k == "object" && k !== null && k.$$typeof === e;
  }
  function J(k) {
    var X = { "=": "=0", ":": "=2" };
    return "$" + k.replace(/[=:]/g, function(H) {
      return X[H];
    });
  }
  var he = /\/+/g;
  function fe(k, X) {
    return typeof k == "object" && k !== null && k.key != null ? J("" + k.key) : X.toString(36);
  }
  function de(k) {
    switch (k.status) {
      case "fulfilled":
        return k.value;
      case "rejected":
        throw k.reason;
      default:
        switch (typeof k.status == "string" ? k.then(L, L) : (k.status = "pending", k.then(
          function(X) {
            k.status === "pending" && (k.status = "fulfilled", k.value = X);
          },
          function(X) {
            k.status === "pending" && (k.status = "rejected", k.reason = X);
          }
        )), k.status) {
          case "fulfilled":
            return k.value;
          case "rejected":
            throw k.reason;
        }
    }
    throw k;
  }
  function I(k, X, H, K, le) {
    var se = typeof k;
    (se === "undefined" || se === "boolean") && (k = null);
    var U = !1;
    if (k === null) U = !0;
    else
      switch (se) {
        case "bigint":
        case "string":
        case "number":
          U = !0;
          break;
        case "object":
          switch (k.$$typeof) {
            case e:
            case t:
              U = !0;
              break;
            case m:
              return U = k._init, I(
                U(k._payload),
                X,
                H,
                K,
                le
              );
          }
      }
    if (U)
      return le = le(k), U = K === "" ? "." + fe(k, 0) : K, O(le) ? (H = "", U != null && (H = U.replace(he, "$&/") + "/"), I(le, X, H, "", function(ue) {
        return ue;
      })) : le != null && (ne(le) && (le = Y(
        le,
        H + (le.key == null || k && k.key === le.key ? "" : ("" + le.key).replace(
          he,
          "$&/"
        ) + "/") + U
      )), X.push(le)), 1;
    U = 0;
    var ie = K === "" ? "." : K + ":";
    if (O(k))
      for (var ce = 0; ce < k.length; ce++)
        K = k[ce], se = ie + fe(K, ce), U += I(
          K,
          X,
          H,
          se,
          le
        );
    else if (ce = x(k), typeof ce == "function")
      for (k = ce.call(k), ce = 0; !(K = k.next()).done; )
        K = K.value, se = ie + fe(K, ce++), U += I(
          K,
          X,
          H,
          se,
          le
        );
    else if (se === "object") {
      if (typeof k.then == "function")
        return I(
          de(k),
          X,
          H,
          K,
          le
        );
      throw X = String(k), Error(
        "Objects are not valid as a React child (found: " + (X === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : X) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return U;
  }
  function G(k, X, H) {
    if (k == null) return k;
    var K = [], le = 0;
    return I(k, K, "", "", function(se) {
      return X.call(H, se, le++);
    }), K;
  }
  function B(k) {
    if (k._status === -1) {
      var X = k._result;
      X = X(), X.then(
        function(H) {
          (k._status === 0 || k._status === -1) && (k._status = 1, k._result = H);
        },
        function(H) {
          (k._status === 0 || k._status === -1) && (k._status = 2, k._result = H);
        }
      ), k._status === -1 && (k._status = 0, k._result = X);
    }
    if (k._status === 1) return k._result.default;
    throw k._result;
  }
  var te = typeof reportError == "function" ? reportError : function(k) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var X = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof k == "object" && k !== null && typeof k.message == "string" ? String(k.message) : String(k),
        error: k
      });
      if (!window.dispatchEvent(X)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", k);
      return;
    }
    console.error(k);
  }, ae = {
    map: G,
    forEach: function(k, X, H) {
      G(
        k,
        function() {
          X.apply(this, arguments);
        },
        H
      );
    },
    count: function(k) {
      var X = 0;
      return G(k, function() {
        X++;
      }), X;
    },
    toArray: function(k) {
      return G(k, function(X) {
        return X;
      }) || [];
    },
    only: function(k) {
      if (!ne(k))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return k;
    }
  };
  return Te.Activity = g, Te.Children = ae, Te.Component = C, Te.Fragment = n, Te.Profiler = a, Te.PureComponent = A, Te.StrictMode = o, Te.Suspense = d, Te.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = M, Te.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(k) {
      return M.H.useMemoCache(k);
    }
  }, Te.cache = function(k) {
    return function() {
      return k.apply(null, arguments);
    };
  }, Te.cacheSignal = function() {
    return null;
  }, Te.cloneElement = function(k, X, H) {
    if (k == null)
      throw Error(
        "The argument must be a React element, but you passed " + k + "."
      );
    var K = E({}, k.props), le = k.key;
    if (X != null)
      for (se in X.key !== void 0 && (le = "" + X.key), X)
        !N.call(X, se) || se === "key" || se === "__self" || se === "__source" || se === "ref" && X.ref === void 0 || (K[se] = X[se]);
    var se = arguments.length - 2;
    if (se === 1) K.children = H;
    else if (1 < se) {
      for (var U = Array(se), ie = 0; ie < se; ie++)
        U[ie] = arguments[ie + 2];
      K.children = U;
    }
    return j(k.type, le, K);
  }, Te.createContext = function(k) {
    return k = {
      $$typeof: c,
      _currentValue: k,
      _currentValue2: k,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, k.Provider = k, k.Consumer = {
      $$typeof: l,
      _context: k
    }, k;
  }, Te.createElement = function(k, X, H) {
    var K, le = {}, se = null;
    if (X != null)
      for (K in X.key !== void 0 && (se = "" + X.key), X)
        N.call(X, K) && K !== "key" && K !== "__self" && K !== "__source" && (le[K] = X[K]);
    var U = arguments.length - 2;
    if (U === 1) le.children = H;
    else if (1 < U) {
      for (var ie = Array(U), ce = 0; ce < U; ce++)
        ie[ce] = arguments[ce + 2];
      le.children = ie;
    }
    if (k && k.defaultProps)
      for (K in U = k.defaultProps, U)
        le[K] === void 0 && (le[K] = U[K]);
    return j(k, se, le);
  }, Te.createRef = function() {
    return { current: null };
  }, Te.forwardRef = function(k) {
    return { $$typeof: f, render: k };
  }, Te.isValidElement = ne, Te.lazy = function(k) {
    return {
      $$typeof: m,
      _payload: { _status: -1, _result: k },
      _init: B
    };
  }, Te.memo = function(k, X) {
    return {
      $$typeof: h,
      type: k,
      compare: X === void 0 ? null : X
    };
  }, Te.startTransition = function(k) {
    var X = M.T, H = {};
    M.T = H;
    try {
      var K = k(), le = M.S;
      le !== null && le(H, K), typeof K == "object" && K !== null && typeof K.then == "function" && K.then(L, te);
    } catch (se) {
      te(se);
    } finally {
      X !== null && H.types !== null && (X.types = H.types), M.T = X;
    }
  }, Te.unstable_useCacheRefresh = function() {
    return M.H.useCacheRefresh();
  }, Te.use = function(k) {
    return M.H.use(k);
  }, Te.useActionState = function(k, X, H) {
    return M.H.useActionState(k, X, H);
  }, Te.useCallback = function(k, X) {
    return M.H.useCallback(k, X);
  }, Te.useContext = function(k) {
    return M.H.useContext(k);
  }, Te.useDebugValue = function() {
  }, Te.useDeferredValue = function(k, X) {
    return M.H.useDeferredValue(k, X);
  }, Te.useEffect = function(k, X) {
    return M.H.useEffect(k, X);
  }, Te.useEffectEvent = function(k) {
    return M.H.useEffectEvent(k);
  }, Te.useId = function() {
    return M.H.useId();
  }, Te.useImperativeHandle = function(k, X, H) {
    return M.H.useImperativeHandle(k, X, H);
  }, Te.useInsertionEffect = function(k, X) {
    return M.H.useInsertionEffect(k, X);
  }, Te.useLayoutEffect = function(k, X) {
    return M.H.useLayoutEffect(k, X);
  }, Te.useMemo = function(k, X) {
    return M.H.useMemo(k, X);
  }, Te.useOptimistic = function(k, X) {
    return M.H.useOptimistic(k, X);
  }, Te.useReducer = function(k, X, H) {
    return M.H.useReducer(k, X, H);
  }, Te.useRef = function(k) {
    return M.H.useRef(k);
  }, Te.useState = function(k) {
    return M.H.useState(k);
  }, Te.useSyncExternalStore = function(k, X, H) {
    return M.H.useSyncExternalStore(
      k,
      X,
      H
    );
  }, Te.useTransition = function() {
    return M.H.useTransition();
  }, Te.version = "19.2.4", Te;
}
var eS;
function zl() {
  return eS || (eS = 1, xp.exports = eO()), xp.exports;
}
var y = zl();
const Kn = /* @__PURE__ */ Ml(y), _f = /* @__PURE__ */ JN({
  __proto__: null,
  default: Kn
}, [y]);
var Sp = { exports: {} }, Hs = {}, wp = { exports: {} }, Ep = {};
var tS;
function tO() {
  return tS || (tS = 1, (function(e) {
    function t(I, G) {
      var B = I.length;
      I.push(G);
      e: for (; 0 < B; ) {
        var te = B - 1 >>> 1, ae = I[te];
        if (0 < a(ae, G))
          I[te] = G, I[B] = ae, B = te;
        else break e;
      }
    }
    function n(I) {
      return I.length === 0 ? null : I[0];
    }
    function o(I) {
      if (I.length === 0) return null;
      var G = I[0], B = I.pop();
      if (B !== G) {
        I[0] = B;
        e: for (var te = 0, ae = I.length, k = ae >>> 1; te < k; ) {
          var X = 2 * (te + 1) - 1, H = I[X], K = X + 1, le = I[K];
          if (0 > a(H, B))
            K < ae && 0 > a(le, H) ? (I[te] = le, I[K] = B, te = K) : (I[te] = H, I[X] = B, te = X);
          else if (K < ae && 0 > a(le, B))
            I[te] = le, I[K] = B, te = K;
          else break e;
        }
      }
      return G;
    }
    function a(I, G) {
      var B = I.sortIndex - G.sortIndex;
      return B !== 0 ? B : I.id - G.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var l = performance;
      e.unstable_now = function() {
        return l.now();
      };
    } else {
      var c = Date, f = c.now();
      e.unstable_now = function() {
        return c.now() - f;
      };
    }
    var d = [], h = [], m = 1, g = null, b = 3, x = !1, _ = !1, E = !1, T = !1, C = typeof setTimeout == "function" ? setTimeout : null, z = typeof clearTimeout == "function" ? clearTimeout : null, A = typeof setImmediate < "u" ? setImmediate : null;
    function R(I) {
      for (var G = n(h); G !== null; ) {
        if (G.callback === null) o(h);
        else if (G.startTime <= I)
          o(h), G.sortIndex = G.expirationTime, t(d, G);
        else break;
        G = n(h);
      }
    }
    function O(I) {
      if (E = !1, R(I), !_)
        if (n(d) !== null)
          _ = !0, L || (L = !0, J());
        else {
          var G = n(h);
          G !== null && de(O, G.startTime - I);
        }
    }
    var L = !1, M = -1, N = 5, j = -1;
    function Y() {
      return T ? !0 : !(e.unstable_now() - j < N);
    }
    function ne() {
      if (T = !1, L) {
        var I = e.unstable_now();
        j = I;
        var G = !0;
        try {
          e: {
            _ = !1, E && (E = !1, z(M), M = -1), x = !0;
            var B = b;
            try {
              t: {
                for (R(I), g = n(d); g !== null && !(g.expirationTime > I && Y()); ) {
                  var te = g.callback;
                  if (typeof te == "function") {
                    g.callback = null, b = g.priorityLevel;
                    var ae = te(
                      g.expirationTime <= I
                    );
                    if (I = e.unstable_now(), typeof ae == "function") {
                      g.callback = ae, R(I), G = !0;
                      break t;
                    }
                    g === n(d) && o(d), R(I);
                  } else o(d);
                  g = n(d);
                }
                if (g !== null) G = !0;
                else {
                  var k = n(h);
                  k !== null && de(
                    O,
                    k.startTime - I
                  ), G = !1;
                }
              }
              break e;
            } finally {
              g = null, b = B, x = !1;
            }
            G = void 0;
          }
        } finally {
          G ? J() : L = !1;
        }
      }
    }
    var J;
    if (typeof A == "function")
      J = function() {
        A(ne);
      };
    else if (typeof MessageChannel < "u") {
      var he = new MessageChannel(), fe = he.port2;
      he.port1.onmessage = ne, J = function() {
        fe.postMessage(null);
      };
    } else
      J = function() {
        C(ne, 0);
      };
    function de(I, G) {
      M = C(function() {
        I(e.unstable_now());
      }, G);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(I) {
      I.callback = null;
    }, e.unstable_forceFrameRate = function(I) {
      0 > I || 125 < I ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : N = 0 < I ? Math.floor(1e3 / I) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return b;
    }, e.unstable_next = function(I) {
      switch (b) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = b;
      }
      var B = b;
      b = G;
      try {
        return I();
      } finally {
        b = B;
      }
    }, e.unstable_requestPaint = function() {
      T = !0;
    }, e.unstable_runWithPriority = function(I, G) {
      switch (I) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          I = 3;
      }
      var B = b;
      b = I;
      try {
        return G();
      } finally {
        b = B;
      }
    }, e.unstable_scheduleCallback = function(I, G, B) {
      var te = e.unstable_now();
      switch (typeof B == "object" && B !== null ? (B = B.delay, B = typeof B == "number" && 0 < B ? te + B : te) : B = te, I) {
        case 1:
          var ae = -1;
          break;
        case 2:
          ae = 250;
          break;
        case 5:
          ae = 1073741823;
          break;
        case 4:
          ae = 1e4;
          break;
        default:
          ae = 5e3;
      }
      return ae = B + ae, I = {
        id: m++,
        callback: G,
        priorityLevel: I,
        startTime: B,
        expirationTime: ae,
        sortIndex: -1
      }, B > te ? (I.sortIndex = B, t(h, I), n(d) === null && I === n(h) && (E ? (z(M), M = -1) : E = !0, de(O, B - te))) : (I.sortIndex = ae, t(d, I), _ || x || (_ = !0, L || (L = !0, J()))), I;
    }, e.unstable_shouldYield = Y, e.unstable_wrapCallback = function(I) {
      var G = b;
      return function() {
        var B = b;
        b = G;
        try {
          return I.apply(this, arguments);
        } finally {
          b = B;
        }
      };
    };
  })(Ep)), Ep;
}
var nS;
function nO() {
  return nS || (nS = 1, wp.exports = tO()), wp.exports;
}
var _p = { exports: {} }, Zt = {};
var rS;
function rO() {
  if (rS) return Zt;
  rS = 1;
  var e = zl();
  function t(d) {
    var h = "https://react.dev/errors/" + d;
    if (1 < arguments.length) {
      h += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var m = 2; m < arguments.length; m++)
        h += "&args[]=" + encodeURIComponent(arguments[m]);
    }
    return "Minified React error #" + d + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var o = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, a = /* @__PURE__ */ Symbol.for("react.portal");
  function l(d, h, m) {
    var g = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: a,
      key: g == null ? null : "" + g,
      children: d,
      containerInfo: h,
      implementation: m
    };
  }
  var c = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function f(d, h) {
    if (d === "font") return "";
    if (typeof h == "string")
      return h === "use-credentials" ? h : "";
  }
  return Zt.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = o, Zt.createPortal = function(d, h) {
    var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11)
      throw Error(t(299));
    return l(d, h, null, m);
  }, Zt.flushSync = function(d) {
    var h = c.T, m = o.p;
    try {
      if (c.T = null, o.p = 2, d) return d();
    } finally {
      c.T = h, o.p = m, o.d.f();
    }
  }, Zt.preconnect = function(d, h) {
    typeof d == "string" && (h ? (h = h.crossOrigin, h = typeof h == "string" ? h === "use-credentials" ? h : "" : void 0) : h = null, o.d.C(d, h));
  }, Zt.prefetchDNS = function(d) {
    typeof d == "string" && o.d.D(d);
  }, Zt.preinit = function(d, h) {
    if (typeof d == "string" && h && typeof h.as == "string") {
      var m = h.as, g = f(m, h.crossOrigin), b = typeof h.integrity == "string" ? h.integrity : void 0, x = typeof h.fetchPriority == "string" ? h.fetchPriority : void 0;
      m === "style" ? o.d.S(
        d,
        typeof h.precedence == "string" ? h.precedence : void 0,
        {
          crossOrigin: g,
          integrity: b,
          fetchPriority: x
        }
      ) : m === "script" && o.d.X(d, {
        crossOrigin: g,
        integrity: b,
        fetchPriority: x,
        nonce: typeof h.nonce == "string" ? h.nonce : void 0
      });
    }
  }, Zt.preinitModule = function(d, h) {
    if (typeof d == "string")
      if (typeof h == "object" && h !== null) {
        if (h.as == null || h.as === "script") {
          var m = f(
            h.as,
            h.crossOrigin
          );
          o.d.M(d, {
            crossOrigin: m,
            integrity: typeof h.integrity == "string" ? h.integrity : void 0,
            nonce: typeof h.nonce == "string" ? h.nonce : void 0
          });
        }
      } else h == null && o.d.M(d);
  }, Zt.preload = function(d, h) {
    if (typeof d == "string" && typeof h == "object" && h !== null && typeof h.as == "string") {
      var m = h.as, g = f(m, h.crossOrigin);
      o.d.L(d, m, {
        crossOrigin: g,
        integrity: typeof h.integrity == "string" ? h.integrity : void 0,
        nonce: typeof h.nonce == "string" ? h.nonce : void 0,
        type: typeof h.type == "string" ? h.type : void 0,
        fetchPriority: typeof h.fetchPriority == "string" ? h.fetchPriority : void 0,
        referrerPolicy: typeof h.referrerPolicy == "string" ? h.referrerPolicy : void 0,
        imageSrcSet: typeof h.imageSrcSet == "string" ? h.imageSrcSet : void 0,
        imageSizes: typeof h.imageSizes == "string" ? h.imageSizes : void 0,
        media: typeof h.media == "string" ? h.media : void 0
      });
    }
  }, Zt.preloadModule = function(d, h) {
    if (typeof d == "string")
      if (h) {
        var m = f(h.as, h.crossOrigin);
        o.d.m(d, {
          as: typeof h.as == "string" && h.as !== "script" ? h.as : void 0,
          crossOrigin: m,
          integrity: typeof h.integrity == "string" ? h.integrity : void 0
        });
      } else o.d.m(d);
  }, Zt.requestFormReset = function(d) {
    o.d.r(d);
  }, Zt.unstable_batchedUpdates = function(d, h) {
    return d(h);
  }, Zt.useFormState = function(d, h, m) {
    return c.H.useFormState(d, h, m);
  }, Zt.useFormStatus = function() {
    return c.H.useHostTransitionStatus();
  }, Zt.version = "19.2.4", Zt;
}
var oS;
function Tf() {
  if (oS) return _p.exports;
  oS = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), _p.exports = rO(), _p.exports;
}
var iS;
function oO() {
  if (iS) return Hs;
  iS = 1;
  var e = nO(), t = zl(), n = Tf();
  function o(r) {
    var i = "https://react.dev/errors/" + r;
    if (1 < arguments.length) {
      i += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var s = 2; s < arguments.length; s++)
        i += "&args[]=" + encodeURIComponent(arguments[s]);
    }
    return "Minified React error #" + r + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function a(r) {
    return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11);
  }
  function l(r) {
    var i = r, s = r;
    if (r.alternate) for (; i.return; ) i = i.return;
    else {
      r = i;
      do
        i = r, (i.flags & 4098) !== 0 && (s = i.return), r = i.return;
      while (r);
    }
    return i.tag === 3 ? s : null;
  }
  function c(r) {
    if (r.tag === 13) {
      var i = r.memoizedState;
      if (i === null && (r = r.alternate, r !== null && (i = r.memoizedState)), i !== null) return i.dehydrated;
    }
    return null;
  }
  function f(r) {
    if (r.tag === 31) {
      var i = r.memoizedState;
      if (i === null && (r = r.alternate, r !== null && (i = r.memoizedState)), i !== null) return i.dehydrated;
    }
    return null;
  }
  function d(r) {
    if (l(r) !== r)
      throw Error(o(188));
  }
  function h(r) {
    var i = r.alternate;
    if (!i) {
      if (i = l(r), i === null) throw Error(o(188));
      return i !== r ? null : r;
    }
    for (var s = r, u = i; ; ) {
      var p = s.return;
      if (p === null) break;
      var v = p.alternate;
      if (v === null) {
        if (u = p.return, u !== null) {
          s = u;
          continue;
        }
        break;
      }
      if (p.child === v.child) {
        for (v = p.child; v; ) {
          if (v === s) return d(p), r;
          if (v === u) return d(p), i;
          v = v.sibling;
        }
        throw Error(o(188));
      }
      if (s.return !== u.return) s = p, u = v;
      else {
        for (var w = !1, D = p.child; D; ) {
          if (D === s) {
            w = !0, s = p, u = v;
            break;
          }
          if (D === u) {
            w = !0, u = p, s = v;
            break;
          }
          D = D.sibling;
        }
        if (!w) {
          for (D = v.child; D; ) {
            if (D === s) {
              w = !0, s = v, u = p;
              break;
            }
            if (D === u) {
              w = !0, u = v, s = p;
              break;
            }
            D = D.sibling;
          }
          if (!w) throw Error(o(189));
        }
      }
      if (s.alternate !== u) throw Error(o(190));
    }
    if (s.tag !== 3) throw Error(o(188));
    return s.stateNode.current === s ? r : i;
  }
  function m(r) {
    var i = r.tag;
    if (i === 5 || i === 26 || i === 27 || i === 6) return r;
    for (r = r.child; r !== null; ) {
      if (i = m(r), i !== null) return i;
      r = r.sibling;
    }
    return null;
  }
  var g = Object.assign, b = /* @__PURE__ */ Symbol.for("react.element"), x = /* @__PURE__ */ Symbol.for("react.transitional.element"), _ = /* @__PURE__ */ Symbol.for("react.portal"), E = /* @__PURE__ */ Symbol.for("react.fragment"), T = /* @__PURE__ */ Symbol.for("react.strict_mode"), C = /* @__PURE__ */ Symbol.for("react.profiler"), z = /* @__PURE__ */ Symbol.for("react.consumer"), A = /* @__PURE__ */ Symbol.for("react.context"), R = /* @__PURE__ */ Symbol.for("react.forward_ref"), O = /* @__PURE__ */ Symbol.for("react.suspense"), L = /* @__PURE__ */ Symbol.for("react.suspense_list"), M = /* @__PURE__ */ Symbol.for("react.memo"), N = /* @__PURE__ */ Symbol.for("react.lazy"), j = /* @__PURE__ */ Symbol.for("react.activity"), Y = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel"), ne = Symbol.iterator;
  function J(r) {
    return r === null || typeof r != "object" ? null : (r = ne && r[ne] || r["@@iterator"], typeof r == "function" ? r : null);
  }
  var he = /* @__PURE__ */ Symbol.for("react.client.reference");
  function fe(r) {
    if (r == null) return null;
    if (typeof r == "function")
      return r.$$typeof === he ? null : r.displayName || r.name || null;
    if (typeof r == "string") return r;
    switch (r) {
      case E:
        return "Fragment";
      case C:
        return "Profiler";
      case T:
        return "StrictMode";
      case O:
        return "Suspense";
      case L:
        return "SuspenseList";
      case j:
        return "Activity";
    }
    if (typeof r == "object")
      switch (r.$$typeof) {
        case _:
          return "Portal";
        case A:
          return r.displayName || "Context";
        case z:
          return (r._context.displayName || "Context") + ".Consumer";
        case R:
          var i = r.render;
          return r = r.displayName, r || (r = i.displayName || i.name || "", r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"), r;
        case M:
          return i = r.displayName || null, i !== null ? i : fe(r.type) || "Memo";
        case N:
          i = r._payload, r = r._init;
          try {
            return fe(r(i));
          } catch {
          }
      }
    return null;
  }
  var de = Array.isArray, I = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, G = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, B = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, te = [], ae = -1;
  function k(r) {
    return { current: r };
  }
  function X(r) {
    0 > ae || (r.current = te[ae], te[ae] = null, ae--);
  }
  function H(r, i) {
    ae++, te[ae] = r.current, r.current = i;
  }
  var K = k(null), le = k(null), se = k(null), U = k(null);
  function ie(r, i) {
    switch (H(se, i), H(le, r), H(K, null), i.nodeType) {
      case 9:
      case 11:
        r = (r = i.documentElement) && (r = r.namespaceURI) ? wx(r) : 0;
        break;
      default:
        if (r = i.tagName, i = i.namespaceURI)
          i = wx(i), r = Ex(i, r);
        else
          switch (r) {
            case "svg":
              r = 1;
              break;
            case "math":
              r = 2;
              break;
            default:
              r = 0;
          }
    }
    X(K), H(K, r);
  }
  function ce() {
    X(K), X(le), X(se);
  }
  function ue(r) {
    r.memoizedState !== null && H(U, r);
    var i = K.current, s = Ex(i, r.type);
    i !== s && (H(le, r), H(K, s));
  }
  function _e(r) {
    le.current === r && (X(K), X(le)), U.current === r && (X(U), Vs._currentValue = B);
  }
  var ze, je;
  function Je(r) {
    if (ze === void 0)
      try {
        throw Error();
      } catch (s) {
        var i = s.stack.trim().match(/\n( *(at )?)/);
        ze = i && i[1] || "", je = -1 < s.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < s.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + ze + r + je;
  }
  var cn = !1;
  function _n(r, i) {
    if (!r || cn) return "";
    cn = !0;
    var s = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var u = {
        DetermineComponentFrameRoot: function() {
          try {
            if (i) {
              var oe = function() {
                throw Error();
              };
              if (Object.defineProperty(oe.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(oe, []);
                } catch (W) {
                  var q = W;
                }
                Reflect.construct(r, [], oe);
              } else {
                try {
                  oe.call();
                } catch (W) {
                  q = W;
                }
                r.call(oe.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (W) {
                q = W;
              }
              (oe = r()) && typeof oe.catch == "function" && oe.catch(function() {
              });
            }
          } catch (W) {
            if (W && q && typeof W.stack == "string")
              return [W.stack, q.stack];
          }
          return [null, null];
        }
      };
      u.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var p = Object.getOwnPropertyDescriptor(
        u.DetermineComponentFrameRoot,
        "name"
      );
      p && p.configurable && Object.defineProperty(
        u.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var v = u.DetermineComponentFrameRoot(), w = v[0], D = v[1];
      if (w && D) {
        var P = w.split(`
`), F = D.split(`
`);
        for (p = u = 0; u < P.length && !P[u].includes("DetermineComponentFrameRoot"); )
          u++;
        for (; p < F.length && !F[p].includes(
          "DetermineComponentFrameRoot"
        ); )
          p++;
        if (u === P.length || p === F.length)
          for (u = P.length - 1, p = F.length - 1; 1 <= u && 0 <= p && P[u] !== F[p]; )
            p--;
        for (; 1 <= u && 0 <= p; u--, p--)
          if (P[u] !== F[p]) {
            if (u !== 1 || p !== 1)
              do
                if (u--, p--, 0 > p || P[u] !== F[p]) {
                  var Q = `
` + P[u].replace(" at new ", " at ");
                  return r.displayName && Q.includes("<anonymous>") && (Q = Q.replace("<anonymous>", r.displayName)), Q;
                }
              while (1 <= u && 0 <= p);
            break;
          }
      }
    } finally {
      cn = !1, Error.prepareStackTrace = s;
    }
    return (s = r ? r.displayName || r.name : "") ? Je(s) : "";
  }
  function Sr(r, i) {
    switch (r.tag) {
      case 26:
      case 27:
      case 5:
        return Je(r.type);
      case 16:
        return Je("Lazy");
      case 13:
        return r.child !== i && i !== null ? Je("Suspense Fallback") : Je("Suspense");
      case 19:
        return Je("SuspenseList");
      case 0:
      case 15:
        return _n(r.type, !1);
      case 11:
        return _n(r.type.render, !1);
      case 1:
        return _n(r.type, !0);
      case 31:
        return Je("Activity");
      default:
        return "";
    }
  }
  function jt(r) {
    try {
      var i = "", s = null;
      do
        i += Sr(r, s), s = r, r = r.return;
      while (r);
      return i;
    } catch (u) {
      return `
Error generating stack: ` + u.message + `
` + u.stack;
    }
  }
  var Ti = Object.prototype.hasOwnProperty, Wa = e.unstable_scheduleCallback, wr = e.unstable_cancelCallback, Hl = e.unstable_shouldYield, sd = e.unstable_requestPaint, un = e.unstable_now, Nz = e.unstable_getCurrentPriorityLevel, ey = e.unstable_ImmediatePriority, ty = e.unstable_UserBlockingPriority, Zl = e.unstable_NormalPriority, Oz = e.unstable_LowPriority, ny = e.unstable_IdlePriority, jz = e.log, kz = e.unstable_setDisableYieldValue, Ka = null, fn = null;
  function Xr(r) {
    if (typeof jz == "function" && kz(r), fn && typeof fn.setStrictMode == "function")
      try {
        fn.setStrictMode(Ka, r);
      } catch {
      }
  }
  var dn = Math.clz32 ? Math.clz32 : Iz, Pz = Math.log, Lz = Math.LN2;
  function Iz(r) {
    return r >>>= 0, r === 0 ? 32 : 31 - (Pz(r) / Lz | 0) | 0;
  }
  var Fl = 256, Gl = 262144, Yl = 4194304;
  function $o(r) {
    var i = r & 42;
    if (i !== 0) return i;
    switch (r & -r) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return r & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return r & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return r & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return r;
    }
  }
  function ql(r, i, s) {
    var u = r.pendingLanes;
    if (u === 0) return 0;
    var p = 0, v = r.suspendedLanes, w = r.pingedLanes;
    r = r.warmLanes;
    var D = u & 134217727;
    return D !== 0 ? (u = D & ~v, u !== 0 ? p = $o(u) : (w &= D, w !== 0 ? p = $o(w) : s || (s = D & ~r, s !== 0 && (p = $o(s))))) : (D = u & ~v, D !== 0 ? p = $o(D) : w !== 0 ? p = $o(w) : s || (s = u & ~r, s !== 0 && (p = $o(s)))), p === 0 ? 0 : i !== 0 && i !== p && (i & v) === 0 && (v = p & -p, s = i & -i, v >= s || v === 32 && (s & 4194048) !== 0) ? i : p;
  }
  function Ja(r, i) {
    return (r.pendingLanes & ~(r.suspendedLanes & ~r.pingedLanes) & i) === 0;
  }
  function Vz(r, i) {
    switch (r) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return i + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function ry() {
    var r = Yl;
    return Yl <<= 1, (Yl & 62914560) === 0 && (Yl = 4194304), r;
  }
  function ld(r) {
    for (var i = [], s = 0; 31 > s; s++) i.push(r);
    return i;
  }
  function Qa(r, i) {
    r.pendingLanes |= i, i !== 268435456 && (r.suspendedLanes = 0, r.pingedLanes = 0, r.warmLanes = 0);
  }
  function Uz(r, i, s, u, p, v) {
    var w = r.pendingLanes;
    r.pendingLanes = s, r.suspendedLanes = 0, r.pingedLanes = 0, r.warmLanes = 0, r.expiredLanes &= s, r.entangledLanes &= s, r.errorRecoveryDisabledLanes &= s, r.shellSuspendCounter = 0;
    var D = r.entanglements, P = r.expirationTimes, F = r.hiddenUpdates;
    for (s = w & ~s; 0 < s; ) {
      var Q = 31 - dn(s), oe = 1 << Q;
      D[Q] = 0, P[Q] = -1;
      var q = F[Q];
      if (q !== null)
        for (F[Q] = null, Q = 0; Q < q.length; Q++) {
          var W = q[Q];
          W !== null && (W.lane &= -536870913);
        }
      s &= ~oe;
    }
    u !== 0 && oy(r, u, 0), v !== 0 && p === 0 && r.tag !== 0 && (r.suspendedLanes |= v & ~(w & ~i));
  }
  function oy(r, i, s) {
    r.pendingLanes |= i, r.suspendedLanes &= ~i;
    var u = 31 - dn(i);
    r.entangledLanes |= i, r.entanglements[u] = r.entanglements[u] | 1073741824 | s & 261930;
  }
  function iy(r, i) {
    var s = r.entangledLanes |= i;
    for (r = r.entanglements; s; ) {
      var u = 31 - dn(s), p = 1 << u;
      p & i | r[u] & i && (r[u] |= i), s &= ~p;
    }
  }
  function ay(r, i) {
    var s = i & -i;
    return s = (s & 42) !== 0 ? 1 : cd(s), (s & (r.suspendedLanes | i)) !== 0 ? 0 : s;
  }
  function cd(r) {
    switch (r) {
      case 2:
        r = 1;
        break;
      case 8:
        r = 4;
        break;
      case 32:
        r = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        r = 128;
        break;
      case 268435456:
        r = 134217728;
        break;
      default:
        r = 0;
    }
    return r;
  }
  function ud(r) {
    return r &= -r, 2 < r ? 8 < r ? (r & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function sy() {
    var r = G.p;
    return r !== 0 ? r : (r = window.event, r === void 0 ? 32 : Gx(r.type));
  }
  function ly(r, i) {
    var s = G.p;
    try {
      return G.p = r, i();
    } finally {
      G.p = s;
    }
  }
  var Wr = Math.random().toString(36).slice(2), kt = "__reactFiber$" + Wr, Jt = "__reactProps$" + Wr, Ci = "__reactContainer$" + Wr, fd = "__reactEvents$" + Wr, Bz = "__reactListeners$" + Wr, $z = "__reactHandles$" + Wr, cy = "__reactResources$" + Wr, es = "__reactMarker$" + Wr;
  function dd(r) {
    delete r[kt], delete r[Jt], delete r[fd], delete r[Bz], delete r[$z];
  }
  function Ai(r) {
    var i = r[kt];
    if (i) return i;
    for (var s = r.parentNode; s; ) {
      if (i = s[Ci] || s[kt]) {
        if (s = i.alternate, i.child !== null || s !== null && s.child !== null)
          for (r = zx(r); r !== null; ) {
            if (s = r[kt]) return s;
            r = zx(r);
          }
        return i;
      }
      r = s, s = r.parentNode;
    }
    return null;
  }
  function Ri(r) {
    if (r = r[kt] || r[Ci]) {
      var i = r.tag;
      if (i === 5 || i === 6 || i === 13 || i === 31 || i === 26 || i === 27 || i === 3)
        return r;
    }
    return null;
  }
  function ts(r) {
    var i = r.tag;
    if (i === 5 || i === 26 || i === 27 || i === 6) return r.stateNode;
    throw Error(o(33));
  }
  function Mi(r) {
    var i = r[cy];
    return i || (i = r[cy] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), i;
  }
  function Nt(r) {
    r[es] = !0;
  }
  var uy = /* @__PURE__ */ new Set(), fy = {};
  function Ho(r, i) {
    zi(r, i), zi(r + "Capture", i);
  }
  function zi(r, i) {
    for (fy[r] = i, r = 0; r < i.length; r++)
      uy.add(i[r]);
  }
  var Hz = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), dy = {}, hy = {};
  function Zz(r) {
    return Ti.call(hy, r) ? !0 : Ti.call(dy, r) ? !1 : Hz.test(r) ? hy[r] = !0 : (dy[r] = !0, !1);
  }
  function Xl(r, i, s) {
    if (Zz(i))
      if (s === null) r.removeAttribute(i);
      else {
        switch (typeof s) {
          case "undefined":
          case "function":
          case "symbol":
            r.removeAttribute(i);
            return;
          case "boolean":
            var u = i.toLowerCase().slice(0, 5);
            if (u !== "data-" && u !== "aria-") {
              r.removeAttribute(i);
              return;
            }
        }
        r.setAttribute(i, "" + s);
      }
  }
  function Wl(r, i, s) {
    if (s === null) r.removeAttribute(i);
    else {
      switch (typeof s) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          r.removeAttribute(i);
          return;
      }
      r.setAttribute(i, "" + s);
    }
  }
  function Er(r, i, s, u) {
    if (u === null) r.removeAttribute(s);
    else {
      switch (typeof u) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          r.removeAttribute(s);
          return;
      }
      r.setAttributeNS(i, s, "" + u);
    }
  }
  function Tn(r) {
    switch (typeof r) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return r;
      case "object":
        return r;
      default:
        return "";
    }
  }
  function py(r) {
    var i = r.type;
    return (r = r.nodeName) && r.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
  }
  function Fz(r, i, s) {
    var u = Object.getOwnPropertyDescriptor(
      r.constructor.prototype,
      i
    );
    if (!r.hasOwnProperty(i) && typeof u < "u" && typeof u.get == "function" && typeof u.set == "function") {
      var p = u.get, v = u.set;
      return Object.defineProperty(r, i, {
        configurable: !0,
        get: function() {
          return p.call(this);
        },
        set: function(w) {
          s = "" + w, v.call(this, w);
        }
      }), Object.defineProperty(r, i, {
        enumerable: u.enumerable
      }), {
        getValue: function() {
          return s;
        },
        setValue: function(w) {
          s = "" + w;
        },
        stopTracking: function() {
          r._valueTracker = null, delete r[i];
        }
      };
    }
  }
  function hd(r) {
    if (!r._valueTracker) {
      var i = py(r) ? "checked" : "value";
      r._valueTracker = Fz(
        r,
        i,
        "" + r[i]
      );
    }
  }
  function my(r) {
    if (!r) return !1;
    var i = r._valueTracker;
    if (!i) return !0;
    var s = i.getValue(), u = "";
    return r && (u = py(r) ? r.checked ? "true" : "false" : r.value), r = u, r !== s ? (i.setValue(r), !0) : !1;
  }
  function Kl(r) {
    if (r = r || (typeof document < "u" ? document : void 0), typeof r > "u") return null;
    try {
      return r.activeElement || r.body;
    } catch {
      return r.body;
    }
  }
  var Gz = /[\n"\\]/g;
  function Cn(r) {
    return r.replace(
      Gz,
      function(i) {
        return "\\" + i.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function pd(r, i, s, u, p, v, w, D) {
    r.name = "", w != null && typeof w != "function" && typeof w != "symbol" && typeof w != "boolean" ? r.type = w : r.removeAttribute("type"), i != null ? w === "number" ? (i === 0 && r.value === "" || r.value != i) && (r.value = "" + Tn(i)) : r.value !== "" + Tn(i) && (r.value = "" + Tn(i)) : w !== "submit" && w !== "reset" || r.removeAttribute("value"), i != null ? md(r, w, Tn(i)) : s != null ? md(r, w, Tn(s)) : u != null && r.removeAttribute("value"), p == null && v != null && (r.defaultChecked = !!v), p != null && (r.checked = p && typeof p != "function" && typeof p != "symbol"), D != null && typeof D != "function" && typeof D != "symbol" && typeof D != "boolean" ? r.name = "" + Tn(D) : r.removeAttribute("name");
  }
  function gy(r, i, s, u, p, v, w, D) {
    if (v != null && typeof v != "function" && typeof v != "symbol" && typeof v != "boolean" && (r.type = v), i != null || s != null) {
      if (!(v !== "submit" && v !== "reset" || i != null)) {
        hd(r);
        return;
      }
      s = s != null ? "" + Tn(s) : "", i = i != null ? "" + Tn(i) : s, D || i === r.value || (r.value = i), r.defaultValue = i;
    }
    u = u ?? p, u = typeof u != "function" && typeof u != "symbol" && !!u, r.checked = D ? r.checked : !!u, r.defaultChecked = !!u, w != null && typeof w != "function" && typeof w != "symbol" && typeof w != "boolean" && (r.name = w), hd(r);
  }
  function md(r, i, s) {
    i === "number" && Kl(r.ownerDocument) === r || r.defaultValue === "" + s || (r.defaultValue = "" + s);
  }
  function Di(r, i, s, u) {
    if (r = r.options, i) {
      i = {};
      for (var p = 0; p < s.length; p++)
        i["$" + s[p]] = !0;
      for (s = 0; s < r.length; s++)
        p = i.hasOwnProperty("$" + r[s].value), r[s].selected !== p && (r[s].selected = p), p && u && (r[s].defaultSelected = !0);
    } else {
      for (s = "" + Tn(s), i = null, p = 0; p < r.length; p++) {
        if (r[p].value === s) {
          r[p].selected = !0, u && (r[p].defaultSelected = !0);
          return;
        }
        i !== null || r[p].disabled || (i = r[p]);
      }
      i !== null && (i.selected = !0);
    }
  }
  function vy(r, i, s) {
    if (i != null && (i = "" + Tn(i), i !== r.value && (r.value = i), s == null)) {
      r.defaultValue !== i && (r.defaultValue = i);
      return;
    }
    r.defaultValue = s != null ? "" + Tn(s) : "";
  }
  function yy(r, i, s, u) {
    if (i == null) {
      if (u != null) {
        if (s != null) throw Error(o(92));
        if (de(u)) {
          if (1 < u.length) throw Error(o(93));
          u = u[0];
        }
        s = u;
      }
      s == null && (s = ""), i = s;
    }
    s = Tn(i), r.defaultValue = s, u = r.textContent, u === s && u !== "" && u !== null && (r.value = u), hd(r);
  }
  function Ni(r, i) {
    if (i) {
      var s = r.firstChild;
      if (s && s === r.lastChild && s.nodeType === 3) {
        s.nodeValue = i;
        return;
      }
    }
    r.textContent = i;
  }
  var Yz = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function by(r, i, s) {
    var u = i.indexOf("--") === 0;
    s == null || typeof s == "boolean" || s === "" ? u ? r.setProperty(i, "") : i === "float" ? r.cssFloat = "" : r[i] = "" : u ? r.setProperty(i, s) : typeof s != "number" || s === 0 || Yz.has(i) ? i === "float" ? r.cssFloat = s : r[i] = ("" + s).trim() : r[i] = s + "px";
  }
  function xy(r, i, s) {
    if (i != null && typeof i != "object")
      throw Error(o(62));
    if (r = r.style, s != null) {
      for (var u in s)
        !s.hasOwnProperty(u) || i != null && i.hasOwnProperty(u) || (u.indexOf("--") === 0 ? r.setProperty(u, "") : u === "float" ? r.cssFloat = "" : r[u] = "");
      for (var p in i)
        u = i[p], i.hasOwnProperty(p) && s[p] !== u && by(r, p, u);
    } else
      for (var v in i)
        i.hasOwnProperty(v) && by(r, v, i[v]);
  }
  function gd(r) {
    if (r.indexOf("-") === -1) return !1;
    switch (r) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var qz = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), Xz = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Jl(r) {
    return Xz.test("" + r) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : r;
  }
  function _r() {
  }
  var vd = null;
  function yd(r) {
    return r = r.target || r.srcElement || window, r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === 3 ? r.parentNode : r;
  }
  var Oi = null, ji = null;
  function Sy(r) {
    var i = Ri(r);
    if (i && (r = i.stateNode)) {
      var s = r[Jt] || null;
      e: switch (r = i.stateNode, i.type) {
        case "input":
          if (pd(
            r,
            s.value,
            s.defaultValue,
            s.defaultValue,
            s.checked,
            s.defaultChecked,
            s.type,
            s.name
          ), i = s.name, s.type === "radio" && i != null) {
            for (s = r; s.parentNode; ) s = s.parentNode;
            for (s = s.querySelectorAll(
              'input[name="' + Cn(
                "" + i
              ) + '"][type="radio"]'
            ), i = 0; i < s.length; i++) {
              var u = s[i];
              if (u !== r && u.form === r.form) {
                var p = u[Jt] || null;
                if (!p) throw Error(o(90));
                pd(
                  u,
                  p.value,
                  p.defaultValue,
                  p.defaultValue,
                  p.checked,
                  p.defaultChecked,
                  p.type,
                  p.name
                );
              }
            }
            for (i = 0; i < s.length; i++)
              u = s[i], u.form === r.form && my(u);
          }
          break e;
        case "textarea":
          vy(r, s.value, s.defaultValue);
          break e;
        case "select":
          i = s.value, i != null && Di(r, !!s.multiple, i, !1);
      }
    }
  }
  var bd = !1;
  function wy(r, i, s) {
    if (bd) return r(i, s);
    bd = !0;
    try {
      var u = r(i);
      return u;
    } finally {
      if (bd = !1, (Oi !== null || ji !== null) && (Vc(), Oi && (i = Oi, r = ji, ji = Oi = null, Sy(i), r)))
        for (i = 0; i < r.length; i++) Sy(r[i]);
    }
  }
  function ns(r, i) {
    var s = r.stateNode;
    if (s === null) return null;
    var u = s[Jt] || null;
    if (u === null) return null;
    s = u[i];
    e: switch (i) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (u = !u.disabled) || (r = r.type, u = !(r === "button" || r === "input" || r === "select" || r === "textarea")), r = !u;
        break e;
      default:
        r = !1;
    }
    if (r) return null;
    if (s && typeof s != "function")
      throw Error(
        o(231, i, typeof s)
      );
    return s;
  }
  var Tr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), xd = !1;
  if (Tr)
    try {
      var rs = {};
      Object.defineProperty(rs, "passive", {
        get: function() {
          xd = !0;
        }
      }), window.addEventListener("test", rs, rs), window.removeEventListener("test", rs, rs);
    } catch {
      xd = !1;
    }
  var Kr = null, Sd = null, Ql = null;
  function Ey() {
    if (Ql) return Ql;
    var r, i = Sd, s = i.length, u, p = "value" in Kr ? Kr.value : Kr.textContent, v = p.length;
    for (r = 0; r < s && i[r] === p[r]; r++) ;
    var w = s - r;
    for (u = 1; u <= w && i[s - u] === p[v - u]; u++) ;
    return Ql = p.slice(r, 1 < u ? 1 - u : void 0);
  }
  function ec(r) {
    var i = r.keyCode;
    return "charCode" in r ? (r = r.charCode, r === 0 && i === 13 && (r = 13)) : r = i, r === 10 && (r = 13), 32 <= r || r === 13 ? r : 0;
  }
  function tc() {
    return !0;
  }
  function _y() {
    return !1;
  }
  function Qt(r) {
    function i(s, u, p, v, w) {
      this._reactName = s, this._targetInst = p, this.type = u, this.nativeEvent = v, this.target = w, this.currentTarget = null;
      for (var D in r)
        r.hasOwnProperty(D) && (s = r[D], this[D] = s ? s(v) : v[D]);
      return this.isDefaultPrevented = (v.defaultPrevented != null ? v.defaultPrevented : v.returnValue === !1) ? tc : _y, this.isPropagationStopped = _y, this;
    }
    return g(i.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var s = this.nativeEvent;
        s && (s.preventDefault ? s.preventDefault() : typeof s.returnValue != "unknown" && (s.returnValue = !1), this.isDefaultPrevented = tc);
      },
      stopPropagation: function() {
        var s = this.nativeEvent;
        s && (s.stopPropagation ? s.stopPropagation() : typeof s.cancelBubble != "unknown" && (s.cancelBubble = !0), this.isPropagationStopped = tc);
      },
      persist: function() {
      },
      isPersistent: tc
    }), i;
  }
  var Zo = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(r) {
      return r.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, nc = Qt(Zo), os = g({}, Zo, { view: 0, detail: 0 }), Wz = Qt(os), wd, Ed, is, rc = g({}, os, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Td,
    button: 0,
    buttons: 0,
    relatedTarget: function(r) {
      return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget;
    },
    movementX: function(r) {
      return "movementX" in r ? r.movementX : (r !== is && (is && r.type === "mousemove" ? (wd = r.screenX - is.screenX, Ed = r.screenY - is.screenY) : Ed = wd = 0, is = r), wd);
    },
    movementY: function(r) {
      return "movementY" in r ? r.movementY : Ed;
    }
  }), Ty = Qt(rc), Kz = g({}, rc, { dataTransfer: 0 }), Jz = Qt(Kz), Qz = g({}, os, { relatedTarget: 0 }), _d = Qt(Qz), eD = g({}, Zo, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), tD = Qt(eD), nD = g({}, Zo, {
    clipboardData: function(r) {
      return "clipboardData" in r ? r.clipboardData : window.clipboardData;
    }
  }), rD = Qt(nD), oD = g({}, Zo, { data: 0 }), Cy = Qt(oD), iD = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, aD = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, sD = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function lD(r) {
    var i = this.nativeEvent;
    return i.getModifierState ? i.getModifierState(r) : (r = sD[r]) ? !!i[r] : !1;
  }
  function Td() {
    return lD;
  }
  var cD = g({}, os, {
    key: function(r) {
      if (r.key) {
        var i = iD[r.key] || r.key;
        if (i !== "Unidentified") return i;
      }
      return r.type === "keypress" ? (r = ec(r), r === 13 ? "Enter" : String.fromCharCode(r)) : r.type === "keydown" || r.type === "keyup" ? aD[r.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Td,
    charCode: function(r) {
      return r.type === "keypress" ? ec(r) : 0;
    },
    keyCode: function(r) {
      return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
    },
    which: function(r) {
      return r.type === "keypress" ? ec(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
    }
  }), uD = Qt(cD), fD = g({}, rc, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), Ay = Qt(fD), dD = g({}, os, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Td
  }), hD = Qt(dD), pD = g({}, Zo, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), mD = Qt(pD), gD = g({}, rc, {
    deltaX: function(r) {
      return "deltaX" in r ? r.deltaX : "wheelDeltaX" in r ? -r.wheelDeltaX : 0;
    },
    deltaY: function(r) {
      return "deltaY" in r ? r.deltaY : "wheelDeltaY" in r ? -r.wheelDeltaY : "wheelDelta" in r ? -r.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), vD = Qt(gD), yD = g({}, Zo, {
    newState: 0,
    oldState: 0
  }), bD = Qt(yD), xD = [9, 13, 27, 32], Cd = Tr && "CompositionEvent" in window, as = null;
  Tr && "documentMode" in document && (as = document.documentMode);
  var SD = Tr && "TextEvent" in window && !as, Ry = Tr && (!Cd || as && 8 < as && 11 >= as), My = " ", zy = !1;
  function Dy(r, i) {
    switch (r) {
      case "keyup":
        return xD.indexOf(i.keyCode) !== -1;
      case "keydown":
        return i.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Ny(r) {
    return r = r.detail, typeof r == "object" && "data" in r ? r.data : null;
  }
  var ki = !1;
  function wD(r, i) {
    switch (r) {
      case "compositionend":
        return Ny(i);
      case "keypress":
        return i.which !== 32 ? null : (zy = !0, My);
      case "textInput":
        return r = i.data, r === My && zy ? null : r;
      default:
        return null;
    }
  }
  function ED(r, i) {
    if (ki)
      return r === "compositionend" || !Cd && Dy(r, i) ? (r = Ey(), Ql = Sd = Kr = null, ki = !1, r) : null;
    switch (r) {
      case "paste":
        return null;
      case "keypress":
        if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
          if (i.char && 1 < i.char.length)
            return i.char;
          if (i.which) return String.fromCharCode(i.which);
        }
        return null;
      case "compositionend":
        return Ry && i.locale !== "ko" ? null : i.data;
      default:
        return null;
    }
  }
  var _D = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Oy(r) {
    var i = r && r.nodeName && r.nodeName.toLowerCase();
    return i === "input" ? !!_D[r.type] : i === "textarea";
  }
  function jy(r, i, s, u) {
    Oi ? ji ? ji.push(u) : ji = [u] : Oi = u, i = Gc(i, "onChange"), 0 < i.length && (s = new nc(
      "onChange",
      "change",
      null,
      s,
      u
    ), r.push({ event: s, listeners: i }));
  }
  var ss = null, ls = null;
  function TD(r) {
    gx(r, 0);
  }
  function oc(r) {
    var i = ts(r);
    if (my(i)) return r;
  }
  function ky(r, i) {
    if (r === "change") return i;
  }
  var Py = !1;
  if (Tr) {
    var Ad;
    if (Tr) {
      var Rd = "oninput" in document;
      if (!Rd) {
        var Ly = document.createElement("div");
        Ly.setAttribute("oninput", "return;"), Rd = typeof Ly.oninput == "function";
      }
      Ad = Rd;
    } else Ad = !1;
    Py = Ad && (!document.documentMode || 9 < document.documentMode);
  }
  function Iy() {
    ss && (ss.detachEvent("onpropertychange", Vy), ls = ss = null);
  }
  function Vy(r) {
    if (r.propertyName === "value" && oc(ls)) {
      var i = [];
      jy(
        i,
        ls,
        r,
        yd(r)
      ), wy(TD, i);
    }
  }
  function CD(r, i, s) {
    r === "focusin" ? (Iy(), ss = i, ls = s, ss.attachEvent("onpropertychange", Vy)) : r === "focusout" && Iy();
  }
  function AD(r) {
    if (r === "selectionchange" || r === "keyup" || r === "keydown")
      return oc(ls);
  }
  function RD(r, i) {
    if (r === "click") return oc(i);
  }
  function MD(r, i) {
    if (r === "input" || r === "change")
      return oc(i);
  }
  function zD(r, i) {
    return r === i && (r !== 0 || 1 / r === 1 / i) || r !== r && i !== i;
  }
  var hn = typeof Object.is == "function" ? Object.is : zD;
  function cs(r, i) {
    if (hn(r, i)) return !0;
    if (typeof r != "object" || r === null || typeof i != "object" || i === null)
      return !1;
    var s = Object.keys(r), u = Object.keys(i);
    if (s.length !== u.length) return !1;
    for (u = 0; u < s.length; u++) {
      var p = s[u];
      if (!Ti.call(i, p) || !hn(r[p], i[p]))
        return !1;
    }
    return !0;
  }
  function Uy(r) {
    for (; r && r.firstChild; ) r = r.firstChild;
    return r;
  }
  function By(r, i) {
    var s = Uy(r);
    r = 0;
    for (var u; s; ) {
      if (s.nodeType === 3) {
        if (u = r + s.textContent.length, r <= i && u >= i)
          return { node: s, offset: i - r };
        r = u;
      }
      e: {
        for (; s; ) {
          if (s.nextSibling) {
            s = s.nextSibling;
            break e;
          }
          s = s.parentNode;
        }
        s = void 0;
      }
      s = Uy(s);
    }
  }
  function $y(r, i) {
    return r && i ? r === i ? !0 : r && r.nodeType === 3 ? !1 : i && i.nodeType === 3 ? $y(r, i.parentNode) : "contains" in r ? r.contains(i) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(i) & 16) : !1 : !1;
  }
  function Hy(r) {
    r = r != null && r.ownerDocument != null && r.ownerDocument.defaultView != null ? r.ownerDocument.defaultView : window;
    for (var i = Kl(r.document); i instanceof r.HTMLIFrameElement; ) {
      try {
        var s = typeof i.contentWindow.location.href == "string";
      } catch {
        s = !1;
      }
      if (s) r = i.contentWindow;
      else break;
      i = Kl(r.document);
    }
    return i;
  }
  function Md(r) {
    var i = r && r.nodeName && r.nodeName.toLowerCase();
    return i && (i === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || i === "textarea" || r.contentEditable === "true");
  }
  var DD = Tr && "documentMode" in document && 11 >= document.documentMode, Pi = null, zd = null, us = null, Dd = !1;
  function Zy(r, i, s) {
    var u = s.window === s ? s.document : s.nodeType === 9 ? s : s.ownerDocument;
    Dd || Pi == null || Pi !== Kl(u) || (u = Pi, "selectionStart" in u && Md(u) ? u = { start: u.selectionStart, end: u.selectionEnd } : (u = (u.ownerDocument && u.ownerDocument.defaultView || window).getSelection(), u = {
      anchorNode: u.anchorNode,
      anchorOffset: u.anchorOffset,
      focusNode: u.focusNode,
      focusOffset: u.focusOffset
    }), us && cs(us, u) || (us = u, u = Gc(zd, "onSelect"), 0 < u.length && (i = new nc(
      "onSelect",
      "select",
      null,
      i,
      s
    ), r.push({ event: i, listeners: u }), i.target = Pi)));
  }
  function Fo(r, i) {
    var s = {};
    return s[r.toLowerCase()] = i.toLowerCase(), s["Webkit" + r] = "webkit" + i, s["Moz" + r] = "moz" + i, s;
  }
  var Li = {
    animationend: Fo("Animation", "AnimationEnd"),
    animationiteration: Fo("Animation", "AnimationIteration"),
    animationstart: Fo("Animation", "AnimationStart"),
    transitionrun: Fo("Transition", "TransitionRun"),
    transitionstart: Fo("Transition", "TransitionStart"),
    transitioncancel: Fo("Transition", "TransitionCancel"),
    transitionend: Fo("Transition", "TransitionEnd")
  }, Nd = {}, Fy = {};
  Tr && (Fy = document.createElement("div").style, "AnimationEvent" in window || (delete Li.animationend.animation, delete Li.animationiteration.animation, delete Li.animationstart.animation), "TransitionEvent" in window || delete Li.transitionend.transition);
  function Go(r) {
    if (Nd[r]) return Nd[r];
    if (!Li[r]) return r;
    var i = Li[r], s;
    for (s in i)
      if (i.hasOwnProperty(s) && s in Fy)
        return Nd[r] = i[s];
    return r;
  }
  var Gy = Go("animationend"), Yy = Go("animationiteration"), qy = Go("animationstart"), ND = Go("transitionrun"), OD = Go("transitionstart"), jD = Go("transitioncancel"), Xy = Go("transitionend"), Wy = /* @__PURE__ */ new Map(), Od = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Od.push("scrollEnd");
  function Hn(r, i) {
    Wy.set(r, i), Ho(i, [r]);
  }
  var ic = typeof reportError == "function" ? reportError : function(r) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var i = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof r == "object" && r !== null && typeof r.message == "string" ? String(r.message) : String(r),
        error: r
      });
      if (!window.dispatchEvent(i)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", r);
      return;
    }
    console.error(r);
  }, An = [], Ii = 0, jd = 0;
  function ac() {
    for (var r = Ii, i = jd = Ii = 0; i < r; ) {
      var s = An[i];
      An[i++] = null;
      var u = An[i];
      An[i++] = null;
      var p = An[i];
      An[i++] = null;
      var v = An[i];
      if (An[i++] = null, u !== null && p !== null) {
        var w = u.pending;
        w === null ? p.next = p : (p.next = w.next, w.next = p), u.pending = p;
      }
      v !== 0 && Ky(s, p, v);
    }
  }
  function sc(r, i, s, u) {
    An[Ii++] = r, An[Ii++] = i, An[Ii++] = s, An[Ii++] = u, jd |= u, r.lanes |= u, r = r.alternate, r !== null && (r.lanes |= u);
  }
  function kd(r, i, s, u) {
    return sc(r, i, s, u), lc(r);
  }
  function Yo(r, i) {
    return sc(r, null, null, i), lc(r);
  }
  function Ky(r, i, s) {
    r.lanes |= s;
    var u = r.alternate;
    u !== null && (u.lanes |= s);
    for (var p = !1, v = r.return; v !== null; )
      v.childLanes |= s, u = v.alternate, u !== null && (u.childLanes |= s), v.tag === 22 && (r = v.stateNode, r === null || r._visibility & 1 || (p = !0)), r = v, v = v.return;
    return r.tag === 3 ? (v = r.stateNode, p && i !== null && (p = 31 - dn(s), r = v.hiddenUpdates, u = r[p], u === null ? r[p] = [i] : u.push(i), i.lane = s | 536870912), v) : null;
  }
  function lc(r) {
    if (50 < Ns)
      throw Ns = 0, Zh = null, Error(o(185));
    for (var i = r.return; i !== null; )
      r = i, i = r.return;
    return r.tag === 3 ? r.stateNode : null;
  }
  var Vi = {};
  function kD(r, i, s, u) {
    this.tag = r, this.key = s, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = u, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function pn(r, i, s, u) {
    return new kD(r, i, s, u);
  }
  function Pd(r) {
    return r = r.prototype, !(!r || !r.isReactComponent);
  }
  function Cr(r, i) {
    var s = r.alternate;
    return s === null ? (s = pn(
      r.tag,
      i,
      r.key,
      r.mode
    ), s.elementType = r.elementType, s.type = r.type, s.stateNode = r.stateNode, s.alternate = r, r.alternate = s) : (s.pendingProps = i, s.type = r.type, s.flags = 0, s.subtreeFlags = 0, s.deletions = null), s.flags = r.flags & 65011712, s.childLanes = r.childLanes, s.lanes = r.lanes, s.child = r.child, s.memoizedProps = r.memoizedProps, s.memoizedState = r.memoizedState, s.updateQueue = r.updateQueue, i = r.dependencies, s.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }, s.sibling = r.sibling, s.index = r.index, s.ref = r.ref, s.refCleanup = r.refCleanup, s;
  }
  function Jy(r, i) {
    r.flags &= 65011714;
    var s = r.alternate;
    return s === null ? (r.childLanes = 0, r.lanes = i, r.child = null, r.subtreeFlags = 0, r.memoizedProps = null, r.memoizedState = null, r.updateQueue = null, r.dependencies = null, r.stateNode = null) : (r.childLanes = s.childLanes, r.lanes = s.lanes, r.child = s.child, r.subtreeFlags = 0, r.deletions = null, r.memoizedProps = s.memoizedProps, r.memoizedState = s.memoizedState, r.updateQueue = s.updateQueue, r.type = s.type, i = s.dependencies, r.dependencies = i === null ? null : {
      lanes: i.lanes,
      firstContext: i.firstContext
    }), r;
  }
  function cc(r, i, s, u, p, v) {
    var w = 0;
    if (u = r, typeof r == "function") Pd(r) && (w = 1);
    else if (typeof r == "string")
      w = UN(
        r,
        s,
        K.current
      ) ? 26 : r === "html" || r === "head" || r === "body" ? 27 : 5;
    else
      e: switch (r) {
        case j:
          return r = pn(31, s, i, p), r.elementType = j, r.lanes = v, r;
        case E:
          return qo(s.children, p, v, i);
        case T:
          w = 8, p |= 24;
          break;
        case C:
          return r = pn(12, s, i, p | 2), r.elementType = C, r.lanes = v, r;
        case O:
          return r = pn(13, s, i, p), r.elementType = O, r.lanes = v, r;
        case L:
          return r = pn(19, s, i, p), r.elementType = L, r.lanes = v, r;
        default:
          if (typeof r == "object" && r !== null)
            switch (r.$$typeof) {
              case A:
                w = 10;
                break e;
              case z:
                w = 9;
                break e;
              case R:
                w = 11;
                break e;
              case M:
                w = 14;
                break e;
              case N:
                w = 16, u = null;
                break e;
            }
          w = 29, s = Error(
            o(130, r === null ? "null" : typeof r, "")
          ), u = null;
      }
    return i = pn(w, s, i, p), i.elementType = r, i.type = u, i.lanes = v, i;
  }
  function qo(r, i, s, u) {
    return r = pn(7, r, u, i), r.lanes = s, r;
  }
  function Ld(r, i, s) {
    return r = pn(6, r, null, i), r.lanes = s, r;
  }
  function Qy(r) {
    var i = pn(18, null, null, 0);
    return i.stateNode = r, i;
  }
  function Id(r, i, s) {
    return i = pn(
      4,
      r.children !== null ? r.children : [],
      r.key,
      i
    ), i.lanes = s, i.stateNode = {
      containerInfo: r.containerInfo,
      pendingChildren: null,
      implementation: r.implementation
    }, i;
  }
  var e0 = /* @__PURE__ */ new WeakMap();
  function Rn(r, i) {
    if (typeof r == "object" && r !== null) {
      var s = e0.get(r);
      return s !== void 0 ? s : (i = {
        value: r,
        source: i,
        stack: jt(i)
      }, e0.set(r, i), i);
    }
    return {
      value: r,
      source: i,
      stack: jt(i)
    };
  }
  var Ui = [], Bi = 0, uc = null, fs = 0, Mn = [], zn = 0, Jr = null, nr = 1, rr = "";
  function Ar(r, i) {
    Ui[Bi++] = fs, Ui[Bi++] = uc, uc = r, fs = i;
  }
  function t0(r, i, s) {
    Mn[zn++] = nr, Mn[zn++] = rr, Mn[zn++] = Jr, Jr = r;
    var u = nr;
    r = rr;
    var p = 32 - dn(u) - 1;
    u &= ~(1 << p), s += 1;
    var v = 32 - dn(i) + p;
    if (30 < v) {
      var w = p - p % 5;
      v = (u & (1 << w) - 1).toString(32), u >>= w, p -= w, nr = 1 << 32 - dn(i) + p | s << p | u, rr = v + r;
    } else
      nr = 1 << v | s << p | u, rr = r;
  }
  function Vd(r) {
    r.return !== null && (Ar(r, 1), t0(r, 1, 0));
  }
  function Ud(r) {
    for (; r === uc; )
      uc = Ui[--Bi], Ui[Bi] = null, fs = Ui[--Bi], Ui[Bi] = null;
    for (; r === Jr; )
      Jr = Mn[--zn], Mn[zn] = null, rr = Mn[--zn], Mn[zn] = null, nr = Mn[--zn], Mn[zn] = null;
  }
  function n0(r, i) {
    Mn[zn++] = nr, Mn[zn++] = rr, Mn[zn++] = Jr, nr = i.id, rr = i.overflow, Jr = r;
  }
  var Pt = null, rt = null, Ue = !1, Qr = null, Dn = !1, Bd = Error(o(519));
  function eo(r) {
    var i = Error(
      o(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    throw ds(Rn(i, r)), Bd;
  }
  function r0(r) {
    var i = r.stateNode, s = r.type, u = r.memoizedProps;
    switch (i[kt] = r, i[Jt] = u, s) {
      case "dialog":
        Pe("cancel", i), Pe("close", i);
        break;
      case "iframe":
      case "object":
      case "embed":
        Pe("load", i);
        break;
      case "video":
      case "audio":
        for (s = 0; s < js.length; s++)
          Pe(js[s], i);
        break;
      case "source":
        Pe("error", i);
        break;
      case "img":
      case "image":
      case "link":
        Pe("error", i), Pe("load", i);
        break;
      case "details":
        Pe("toggle", i);
        break;
      case "input":
        Pe("invalid", i), gy(
          i,
          u.value,
          u.defaultValue,
          u.checked,
          u.defaultChecked,
          u.type,
          u.name,
          !0
        );
        break;
      case "select":
        Pe("invalid", i);
        break;
      case "textarea":
        Pe("invalid", i), yy(i, u.value, u.defaultValue, u.children);
    }
    s = u.children, typeof s != "string" && typeof s != "number" && typeof s != "bigint" || i.textContent === "" + s || u.suppressHydrationWarning === !0 || xx(i.textContent, s) ? (u.popover != null && (Pe("beforetoggle", i), Pe("toggle", i)), u.onScroll != null && Pe("scroll", i), u.onScrollEnd != null && Pe("scrollend", i), u.onClick != null && (i.onclick = _r), i = !0) : i = !1, i || eo(r, !0);
  }
  function o0(r) {
    for (Pt = r.return; Pt; )
      switch (Pt.tag) {
        case 5:
        case 31:
        case 13:
          Dn = !1;
          return;
        case 27:
        case 3:
          Dn = !0;
          return;
        default:
          Pt = Pt.return;
      }
  }
  function $i(r) {
    if (r !== Pt) return !1;
    if (!Ue) return o0(r), Ue = !0, !1;
    var i = r.tag, s;
    if ((s = i !== 3 && i !== 27) && ((s = i === 5) && (s = r.type, s = !(s !== "form" && s !== "button") || ip(r.type, r.memoizedProps)), s = !s), s && rt && eo(r), o0(r), i === 13) {
      if (r = r.memoizedState, r = r !== null ? r.dehydrated : null, !r) throw Error(o(317));
      rt = Mx(r);
    } else if (i === 31) {
      if (r = r.memoizedState, r = r !== null ? r.dehydrated : null, !r) throw Error(o(317));
      rt = Mx(r);
    } else
      i === 27 ? (i = rt, mo(r.type) ? (r = up, up = null, rt = r) : rt = i) : rt = Pt ? On(r.stateNode.nextSibling) : null;
    return !0;
  }
  function Xo() {
    rt = Pt = null, Ue = !1;
  }
  function $d() {
    var r = Qr;
    return r !== null && (rn === null ? rn = r : rn.push.apply(
      rn,
      r
    ), Qr = null), r;
  }
  function ds(r) {
    Qr === null ? Qr = [r] : Qr.push(r);
  }
  var Hd = k(null), Wo = null, Rr = null;
  function to(r, i, s) {
    H(Hd, i._currentValue), i._currentValue = s;
  }
  function Mr(r) {
    r._currentValue = Hd.current, X(Hd);
  }
  function Zd(r, i, s) {
    for (; r !== null; ) {
      var u = r.alternate;
      if ((r.childLanes & i) !== i ? (r.childLanes |= i, u !== null && (u.childLanes |= i)) : u !== null && (u.childLanes & i) !== i && (u.childLanes |= i), r === s) break;
      r = r.return;
    }
  }
  function Fd(r, i, s, u) {
    var p = r.child;
    for (p !== null && (p.return = r); p !== null; ) {
      var v = p.dependencies;
      if (v !== null) {
        var w = p.child;
        v = v.firstContext;
        e: for (; v !== null; ) {
          var D = v;
          v = p;
          for (var P = 0; P < i.length; P++)
            if (D.context === i[P]) {
              v.lanes |= s, D = v.alternate, D !== null && (D.lanes |= s), Zd(
                v.return,
                s,
                r
              ), u || (w = null);
              break e;
            }
          v = D.next;
        }
      } else if (p.tag === 18) {
        if (w = p.return, w === null) throw Error(o(341));
        w.lanes |= s, v = w.alternate, v !== null && (v.lanes |= s), Zd(w, s, r), w = null;
      } else w = p.child;
      if (w !== null) w.return = p;
      else
        for (w = p; w !== null; ) {
          if (w === r) {
            w = null;
            break;
          }
          if (p = w.sibling, p !== null) {
            p.return = w.return, w = p;
            break;
          }
          w = w.return;
        }
      p = w;
    }
  }
  function Hi(r, i, s, u) {
    r = null;
    for (var p = i, v = !1; p !== null; ) {
      if (!v) {
        if ((p.flags & 524288) !== 0) v = !0;
        else if ((p.flags & 262144) !== 0) break;
      }
      if (p.tag === 10) {
        var w = p.alternate;
        if (w === null) throw Error(o(387));
        if (w = w.memoizedProps, w !== null) {
          var D = p.type;
          hn(p.pendingProps.value, w.value) || (r !== null ? r.push(D) : r = [D]);
        }
      } else if (p === U.current) {
        if (w = p.alternate, w === null) throw Error(o(387));
        w.memoizedState.memoizedState !== p.memoizedState.memoizedState && (r !== null ? r.push(Vs) : r = [Vs]);
      }
      p = p.return;
    }
    r !== null && Fd(
      i,
      r,
      s,
      u
    ), i.flags |= 262144;
  }
  function fc(r) {
    for (r = r.firstContext; r !== null; ) {
      if (!hn(
        r.context._currentValue,
        r.memoizedValue
      ))
        return !0;
      r = r.next;
    }
    return !1;
  }
  function Ko(r) {
    Wo = r, Rr = null, r = r.dependencies, r !== null && (r.firstContext = null);
  }
  function Lt(r) {
    return i0(Wo, r);
  }
  function dc(r, i) {
    return Wo === null && Ko(r), i0(r, i);
  }
  function i0(r, i) {
    var s = i._currentValue;
    if (i = { context: i, memoizedValue: s, next: null }, Rr === null) {
      if (r === null) throw Error(o(308));
      Rr = i, r.dependencies = { lanes: 0, firstContext: i }, r.flags |= 524288;
    } else Rr = Rr.next = i;
    return s;
  }
  var PD = typeof AbortController < "u" ? AbortController : function() {
    var r = [], i = this.signal = {
      aborted: !1,
      addEventListener: function(s, u) {
        r.push(u);
      }
    };
    this.abort = function() {
      i.aborted = !0, r.forEach(function(s) {
        return s();
      });
    };
  }, LD = e.unstable_scheduleCallback, ID = e.unstable_NormalPriority, St = {
    $$typeof: A,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function Gd() {
    return {
      controller: new PD(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function hs(r) {
    r.refCount--, r.refCount === 0 && LD(ID, function() {
      r.controller.abort();
    });
  }
  var ps = null, Yd = 0, Zi = 0, Fi = null;
  function VD(r, i) {
    if (ps === null) {
      var s = ps = [];
      Yd = 0, Zi = Wh(), Fi = {
        status: "pending",
        value: void 0,
        then: function(u) {
          s.push(u);
        }
      };
    }
    return Yd++, i.then(a0, a0), i;
  }
  function a0() {
    if (--Yd === 0 && ps !== null) {
      Fi !== null && (Fi.status = "fulfilled");
      var r = ps;
      ps = null, Zi = 0, Fi = null;
      for (var i = 0; i < r.length; i++) (0, r[i])();
    }
  }
  function UD(r, i) {
    var s = [], u = {
      status: "pending",
      value: null,
      reason: null,
      then: function(p) {
        s.push(p);
      }
    };
    return r.then(
      function() {
        u.status = "fulfilled", u.value = i;
        for (var p = 0; p < s.length; p++) (0, s[p])(i);
      },
      function(p) {
        for (u.status = "rejected", u.reason = p, p = 0; p < s.length; p++)
          (0, s[p])(void 0);
      }
    ), u;
  }
  var s0 = I.S;
  I.S = function(r, i) {
    Zb = un(), typeof i == "object" && i !== null && typeof i.then == "function" && VD(r, i), s0 !== null && s0(r, i);
  };
  var Jo = k(null);
  function qd() {
    var r = Jo.current;
    return r !== null ? r : Qe.pooledCache;
  }
  function hc(r, i) {
    i === null ? H(Jo, Jo.current) : H(Jo, i.pool);
  }
  function l0() {
    var r = qd();
    return r === null ? null : { parent: St._currentValue, pool: r };
  }
  var Gi = Error(o(460)), Xd = Error(o(474)), pc = Error(o(542)), mc = { then: function() {
  } };
  function c0(r) {
    return r = r.status, r === "fulfilled" || r === "rejected";
  }
  function u0(r, i, s) {
    switch (s = r[s], s === void 0 ? r.push(i) : s !== i && (i.then(_r, _r), i = s), i.status) {
      case "fulfilled":
        return i.value;
      case "rejected":
        throw r = i.reason, d0(r), r;
      default:
        if (typeof i.status == "string") i.then(_r, _r);
        else {
          if (r = Qe, r !== null && 100 < r.shellSuspendCounter)
            throw Error(o(482));
          r = i, r.status = "pending", r.then(
            function(u) {
              if (i.status === "pending") {
                var p = i;
                p.status = "fulfilled", p.value = u;
              }
            },
            function(u) {
              if (i.status === "pending") {
                var p = i;
                p.status = "rejected", p.reason = u;
              }
            }
          );
        }
        switch (i.status) {
          case "fulfilled":
            return i.value;
          case "rejected":
            throw r = i.reason, d0(r), r;
        }
        throw ei = i, Gi;
    }
  }
  function Qo(r) {
    try {
      var i = r._init;
      return i(r._payload);
    } catch (s) {
      throw s !== null && typeof s == "object" && typeof s.then == "function" ? (ei = s, Gi) : s;
    }
  }
  var ei = null;
  function f0() {
    if (ei === null) throw Error(o(459));
    var r = ei;
    return ei = null, r;
  }
  function d0(r) {
    if (r === Gi || r === pc)
      throw Error(o(483));
  }
  var Yi = null, ms = 0;
  function gc(r) {
    var i = ms;
    return ms += 1, Yi === null && (Yi = []), u0(Yi, r, i);
  }
  function gs(r, i) {
    i = i.props.ref, r.ref = i !== void 0 ? i : null;
  }
  function vc(r, i) {
    throw i.$$typeof === b ? Error(o(525)) : (r = Object.prototype.toString.call(i), Error(
      o(
        31,
        r === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : r
      )
    ));
  }
  function h0(r) {
    function i($, V) {
      if (r) {
        var Z = $.deletions;
        Z === null ? ($.deletions = [V], $.flags |= 16) : Z.push(V);
      }
    }
    function s($, V) {
      if (!r) return null;
      for (; V !== null; )
        i($, V), V = V.sibling;
      return null;
    }
    function u($) {
      for (var V = /* @__PURE__ */ new Map(); $ !== null; )
        $.key !== null ? V.set($.key, $) : V.set($.index, $), $ = $.sibling;
      return V;
    }
    function p($, V) {
      return $ = Cr($, V), $.index = 0, $.sibling = null, $;
    }
    function v($, V, Z) {
      return $.index = Z, r ? (Z = $.alternate, Z !== null ? (Z = Z.index, Z < V ? ($.flags |= 67108866, V) : Z) : ($.flags |= 67108866, V)) : ($.flags |= 1048576, V);
    }
    function w($) {
      return r && $.alternate === null && ($.flags |= 67108866), $;
    }
    function D($, V, Z, re) {
      return V === null || V.tag !== 6 ? (V = Ld(Z, $.mode, re), V.return = $, V) : (V = p(V, Z), V.return = $, V);
    }
    function P($, V, Z, re) {
      var Se = Z.type;
      return Se === E ? Q(
        $,
        V,
        Z.props.children,
        re,
        Z.key
      ) : V !== null && (V.elementType === Se || typeof Se == "object" && Se !== null && Se.$$typeof === N && Qo(Se) === V.type) ? (V = p(V, Z.props), gs(V, Z), V.return = $, V) : (V = cc(
        Z.type,
        Z.key,
        Z.props,
        null,
        $.mode,
        re
      ), gs(V, Z), V.return = $, V);
    }
    function F($, V, Z, re) {
      return V === null || V.tag !== 4 || V.stateNode.containerInfo !== Z.containerInfo || V.stateNode.implementation !== Z.implementation ? (V = Id(Z, $.mode, re), V.return = $, V) : (V = p(V, Z.children || []), V.return = $, V);
    }
    function Q($, V, Z, re, Se) {
      return V === null || V.tag !== 7 ? (V = qo(
        Z,
        $.mode,
        re,
        Se
      ), V.return = $, V) : (V = p(V, Z), V.return = $, V);
    }
    function oe($, V, Z) {
      if (typeof V == "string" && V !== "" || typeof V == "number" || typeof V == "bigint")
        return V = Ld(
          "" + V,
          $.mode,
          Z
        ), V.return = $, V;
      if (typeof V == "object" && V !== null) {
        switch (V.$$typeof) {
          case x:
            return Z = cc(
              V.type,
              V.key,
              V.props,
              null,
              $.mode,
              Z
            ), gs(Z, V), Z.return = $, Z;
          case _:
            return V = Id(
              V,
              $.mode,
              Z
            ), V.return = $, V;
          case N:
            return V = Qo(V), oe($, V, Z);
        }
        if (de(V) || J(V))
          return V = qo(
            V,
            $.mode,
            Z,
            null
          ), V.return = $, V;
        if (typeof V.then == "function")
          return oe($, gc(V), Z);
        if (V.$$typeof === A)
          return oe(
            $,
            dc($, V),
            Z
          );
        vc($, V);
      }
      return null;
    }
    function q($, V, Z, re) {
      var Se = V !== null ? V.key : null;
      if (typeof Z == "string" && Z !== "" || typeof Z == "number" || typeof Z == "bigint")
        return Se !== null ? null : D($, V, "" + Z, re);
      if (typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case x:
            return Z.key === Se ? P($, V, Z, re) : null;
          case _:
            return Z.key === Se ? F($, V, Z, re) : null;
          case N:
            return Z = Qo(Z), q($, V, Z, re);
        }
        if (de(Z) || J(Z))
          return Se !== null ? null : Q($, V, Z, re, null);
        if (typeof Z.then == "function")
          return q(
            $,
            V,
            gc(Z),
            re
          );
        if (Z.$$typeof === A)
          return q(
            $,
            V,
            dc($, Z),
            re
          );
        vc($, Z);
      }
      return null;
    }
    function W($, V, Z, re, Se) {
      if (typeof re == "string" && re !== "" || typeof re == "number" || typeof re == "bigint")
        return $ = $.get(Z) || null, D(V, $, "" + re, Se);
      if (typeof re == "object" && re !== null) {
        switch (re.$$typeof) {
          case x:
            return $ = $.get(
              re.key === null ? Z : re.key
            ) || null, P(V, $, re, Se);
          case _:
            return $ = $.get(
              re.key === null ? Z : re.key
            ) || null, F(V, $, re, Se);
          case N:
            return re = Qo(re), W(
              $,
              V,
              Z,
              re,
              Se
            );
        }
        if (de(re) || J(re))
          return $ = $.get(Z) || null, Q(V, $, re, Se, null);
        if (typeof re.then == "function")
          return W(
            $,
            V,
            Z,
            gc(re),
            Se
          );
        if (re.$$typeof === A)
          return W(
            $,
            V,
            Z,
            dc(V, re),
            Se
          );
        vc(V, re);
      }
      return null;
    }
    function me($, V, Z, re) {
      for (var Se = null, $e = null, be = V, Me = V = 0, Ve = null; be !== null && Me < Z.length; Me++) {
        be.index > Me ? (Ve = be, be = null) : Ve = be.sibling;
        var He = q(
          $,
          be,
          Z[Me],
          re
        );
        if (He === null) {
          be === null && (be = Ve);
          break;
        }
        r && be && He.alternate === null && i($, be), V = v(He, V, Me), $e === null ? Se = He : $e.sibling = He, $e = He, be = Ve;
      }
      if (Me === Z.length)
        return s($, be), Ue && Ar($, Me), Se;
      if (be === null) {
        for (; Me < Z.length; Me++)
          be = oe($, Z[Me], re), be !== null && (V = v(
            be,
            V,
            Me
          ), $e === null ? Se = be : $e.sibling = be, $e = be);
        return Ue && Ar($, Me), Se;
      }
      for (be = u(be); Me < Z.length; Me++)
        Ve = W(
          be,
          $,
          Me,
          Z[Me],
          re
        ), Ve !== null && (r && Ve.alternate !== null && be.delete(
          Ve.key === null ? Me : Ve.key
        ), V = v(
          Ve,
          V,
          Me
        ), $e === null ? Se = Ve : $e.sibling = Ve, $e = Ve);
      return r && be.forEach(function(xo) {
        return i($, xo);
      }), Ue && Ar($, Me), Se;
    }
    function Ee($, V, Z, re) {
      if (Z == null) throw Error(o(151));
      for (var Se = null, $e = null, be = V, Me = V = 0, Ve = null, He = Z.next(); be !== null && !He.done; Me++, He = Z.next()) {
        be.index > Me ? (Ve = be, be = null) : Ve = be.sibling;
        var xo = q($, be, He.value, re);
        if (xo === null) {
          be === null && (be = Ve);
          break;
        }
        r && be && xo.alternate === null && i($, be), V = v(xo, V, Me), $e === null ? Se = xo : $e.sibling = xo, $e = xo, be = Ve;
      }
      if (He.done)
        return s($, be), Ue && Ar($, Me), Se;
      if (be === null) {
        for (; !He.done; Me++, He = Z.next())
          He = oe($, He.value, re), He !== null && (V = v(He, V, Me), $e === null ? Se = He : $e.sibling = He, $e = He);
        return Ue && Ar($, Me), Se;
      }
      for (be = u(be); !He.done; Me++, He = Z.next())
        He = W(be, $, Me, He.value, re), He !== null && (r && He.alternate !== null && be.delete(He.key === null ? Me : He.key), V = v(He, V, Me), $e === null ? Se = He : $e.sibling = He, $e = He);
      return r && be.forEach(function(KN) {
        return i($, KN);
      }), Ue && Ar($, Me), Se;
    }
    function Ke($, V, Z, re) {
      if (typeof Z == "object" && Z !== null && Z.type === E && Z.key === null && (Z = Z.props.children), typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case x:
            e: {
              for (var Se = Z.key; V !== null; ) {
                if (V.key === Se) {
                  if (Se = Z.type, Se === E) {
                    if (V.tag === 7) {
                      s(
                        $,
                        V.sibling
                      ), re = p(
                        V,
                        Z.props.children
                      ), re.return = $, $ = re;
                      break e;
                    }
                  } else if (V.elementType === Se || typeof Se == "object" && Se !== null && Se.$$typeof === N && Qo(Se) === V.type) {
                    s(
                      $,
                      V.sibling
                    ), re = p(V, Z.props), gs(re, Z), re.return = $, $ = re;
                    break e;
                  }
                  s($, V);
                  break;
                } else i($, V);
                V = V.sibling;
              }
              Z.type === E ? (re = qo(
                Z.props.children,
                $.mode,
                re,
                Z.key
              ), re.return = $, $ = re) : (re = cc(
                Z.type,
                Z.key,
                Z.props,
                null,
                $.mode,
                re
              ), gs(re, Z), re.return = $, $ = re);
            }
            return w($);
          case _:
            e: {
              for (Se = Z.key; V !== null; ) {
                if (V.key === Se)
                  if (V.tag === 4 && V.stateNode.containerInfo === Z.containerInfo && V.stateNode.implementation === Z.implementation) {
                    s(
                      $,
                      V.sibling
                    ), re = p(V, Z.children || []), re.return = $, $ = re;
                    break e;
                  } else {
                    s($, V);
                    break;
                  }
                else i($, V);
                V = V.sibling;
              }
              re = Id(Z, $.mode, re), re.return = $, $ = re;
            }
            return w($);
          case N:
            return Z = Qo(Z), Ke(
              $,
              V,
              Z,
              re
            );
        }
        if (de(Z))
          return me(
            $,
            V,
            Z,
            re
          );
        if (J(Z)) {
          if (Se = J(Z), typeof Se != "function") throw Error(o(150));
          return Z = Se.call(Z), Ee(
            $,
            V,
            Z,
            re
          );
        }
        if (typeof Z.then == "function")
          return Ke(
            $,
            V,
            gc(Z),
            re
          );
        if (Z.$$typeof === A)
          return Ke(
            $,
            V,
            dc($, Z),
            re
          );
        vc($, Z);
      }
      return typeof Z == "string" && Z !== "" || typeof Z == "number" || typeof Z == "bigint" ? (Z = "" + Z, V !== null && V.tag === 6 ? (s($, V.sibling), re = p(V, Z), re.return = $, $ = re) : (s($, V), re = Ld(Z, $.mode, re), re.return = $, $ = re), w($)) : s($, V);
    }
    return function($, V, Z, re) {
      try {
        ms = 0;
        var Se = Ke(
          $,
          V,
          Z,
          re
        );
        return Yi = null, Se;
      } catch (be) {
        if (be === Gi || be === pc) throw be;
        var $e = pn(29, be, null, $.mode);
        return $e.lanes = re, $e.return = $, $e;
      }
    };
  }
  var ti = h0(!0), p0 = h0(!1), no = !1;
  function Wd(r) {
    r.updateQueue = {
      baseState: r.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function Kd(r, i) {
    r = r.updateQueue, i.updateQueue === r && (i.updateQueue = {
      baseState: r.baseState,
      firstBaseUpdate: r.firstBaseUpdate,
      lastBaseUpdate: r.lastBaseUpdate,
      shared: r.shared,
      callbacks: null
    });
  }
  function ro(r) {
    return { lane: r, tag: 0, payload: null, callback: null, next: null };
  }
  function oo(r, i, s) {
    var u = r.updateQueue;
    if (u === null) return null;
    if (u = u.shared, (Ze & 2) !== 0) {
      var p = u.pending;
      return p === null ? i.next = i : (i.next = p.next, p.next = i), u.pending = i, i = lc(r), Ky(r, null, s), i;
    }
    return sc(r, u, i, s), lc(r);
  }
  function vs(r, i, s) {
    if (i = i.updateQueue, i !== null && (i = i.shared, (s & 4194048) !== 0)) {
      var u = i.lanes;
      u &= r.pendingLanes, s |= u, i.lanes = s, iy(r, s);
    }
  }
  function Jd(r, i) {
    var s = r.updateQueue, u = r.alternate;
    if (u !== null && (u = u.updateQueue, s === u)) {
      var p = null, v = null;
      if (s = s.firstBaseUpdate, s !== null) {
        do {
          var w = {
            lane: s.lane,
            tag: s.tag,
            payload: s.payload,
            callback: null,
            next: null
          };
          v === null ? p = v = w : v = v.next = w, s = s.next;
        } while (s !== null);
        v === null ? p = v = i : v = v.next = i;
      } else p = v = i;
      s = {
        baseState: u.baseState,
        firstBaseUpdate: p,
        lastBaseUpdate: v,
        shared: u.shared,
        callbacks: u.callbacks
      }, r.updateQueue = s;
      return;
    }
    r = s.lastBaseUpdate, r === null ? s.firstBaseUpdate = i : r.next = i, s.lastBaseUpdate = i;
  }
  var Qd = !1;
  function ys() {
    if (Qd) {
      var r = Fi;
      if (r !== null) throw r;
    }
  }
  function bs(r, i, s, u) {
    Qd = !1;
    var p = r.updateQueue;
    no = !1;
    var v = p.firstBaseUpdate, w = p.lastBaseUpdate, D = p.shared.pending;
    if (D !== null) {
      p.shared.pending = null;
      var P = D, F = P.next;
      P.next = null, w === null ? v = F : w.next = F, w = P;
      var Q = r.alternate;
      Q !== null && (Q = Q.updateQueue, D = Q.lastBaseUpdate, D !== w && (D === null ? Q.firstBaseUpdate = F : D.next = F, Q.lastBaseUpdate = P));
    }
    if (v !== null) {
      var oe = p.baseState;
      w = 0, Q = F = P = null, D = v;
      do {
        var q = D.lane & -536870913, W = q !== D.lane;
        if (W ? (Ie & q) === q : (u & q) === q) {
          q !== 0 && q === Zi && (Qd = !0), Q !== null && (Q = Q.next = {
            lane: 0,
            tag: D.tag,
            payload: D.payload,
            callback: null,
            next: null
          });
          e: {
            var me = r, Ee = D;
            q = i;
            var Ke = s;
            switch (Ee.tag) {
              case 1:
                if (me = Ee.payload, typeof me == "function") {
                  oe = me.call(Ke, oe, q);
                  break e;
                }
                oe = me;
                break e;
              case 3:
                me.flags = me.flags & -65537 | 128;
              case 0:
                if (me = Ee.payload, q = typeof me == "function" ? me.call(Ke, oe, q) : me, q == null) break e;
                oe = g({}, oe, q);
                break e;
              case 2:
                no = !0;
            }
          }
          q = D.callback, q !== null && (r.flags |= 64, W && (r.flags |= 8192), W = p.callbacks, W === null ? p.callbacks = [q] : W.push(q));
        } else
          W = {
            lane: q,
            tag: D.tag,
            payload: D.payload,
            callback: D.callback,
            next: null
          }, Q === null ? (F = Q = W, P = oe) : Q = Q.next = W, w |= q;
        if (D = D.next, D === null) {
          if (D = p.shared.pending, D === null)
            break;
          W = D, D = W.next, W.next = null, p.lastBaseUpdate = W, p.shared.pending = null;
        }
      } while (!0);
      Q === null && (P = oe), p.baseState = P, p.firstBaseUpdate = F, p.lastBaseUpdate = Q, v === null && (p.shared.lanes = 0), co |= w, r.lanes = w, r.memoizedState = oe;
    }
  }
  function m0(r, i) {
    if (typeof r != "function")
      throw Error(o(191, r));
    r.call(i);
  }
  function g0(r, i) {
    var s = r.callbacks;
    if (s !== null)
      for (r.callbacks = null, r = 0; r < s.length; r++)
        m0(s[r], i);
  }
  var qi = k(null), yc = k(0);
  function v0(r, i) {
    r = Ir, H(yc, r), H(qi, i), Ir = r | i.baseLanes;
  }
  function eh() {
    H(yc, Ir), H(qi, qi.current);
  }
  function th() {
    Ir = yc.current, X(qi), X(yc);
  }
  var mn = k(null), Nn = null;
  function io(r) {
    var i = r.alternate;
    H(vt, vt.current & 1), H(mn, r), Nn === null && (i === null || qi.current !== null || i.memoizedState !== null) && (Nn = r);
  }
  function nh(r) {
    H(vt, vt.current), H(mn, r), Nn === null && (Nn = r);
  }
  function y0(r) {
    r.tag === 22 ? (H(vt, vt.current), H(mn, r), Nn === null && (Nn = r)) : ao();
  }
  function ao() {
    H(vt, vt.current), H(mn, mn.current);
  }
  function gn(r) {
    X(mn), Nn === r && (Nn = null), X(vt);
  }
  var vt = k(0);
  function bc(r) {
    for (var i = r; i !== null; ) {
      if (i.tag === 13) {
        var s = i.memoizedState;
        if (s !== null && (s = s.dehydrated, s === null || lp(s) || cp(s)))
          return i;
      } else if (i.tag === 19 && (i.memoizedProps.revealOrder === "forwards" || i.memoizedProps.revealOrder === "backwards" || i.memoizedProps.revealOrder === "unstable_legacy-backwards" || i.memoizedProps.revealOrder === "together")) {
        if ((i.flags & 128) !== 0) return i;
      } else if (i.child !== null) {
        i.child.return = i, i = i.child;
        continue;
      }
      if (i === r) break;
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === r) return null;
        i = i.return;
      }
      i.sibling.return = i.return, i = i.sibling;
    }
    return null;
  }
  var zr = 0, Ae = null, Xe = null, wt = null, xc = !1, Xi = !1, ni = !1, Sc = 0, xs = 0, Wi = null, BD = 0;
  function ht() {
    throw Error(o(321));
  }
  function rh(r, i) {
    if (i === null) return !1;
    for (var s = 0; s < i.length && s < r.length; s++)
      if (!hn(r[s], i[s])) return !1;
    return !0;
  }
  function oh(r, i, s, u, p, v) {
    return zr = v, Ae = i, i.memoizedState = null, i.updateQueue = null, i.lanes = 0, I.H = r === null || r.memoizedState === null ? tb : bh, ni = !1, v = s(u, p), ni = !1, Xi && (v = x0(
      i,
      s,
      u,
      p
    )), b0(r), v;
  }
  function b0(r) {
    I.H = Es;
    var i = Xe !== null && Xe.next !== null;
    if (zr = 0, wt = Xe = Ae = null, xc = !1, xs = 0, Wi = null, i) throw Error(o(300));
    r === null || Et || (r = r.dependencies, r !== null && fc(r) && (Et = !0));
  }
  function x0(r, i, s, u) {
    Ae = r;
    var p = 0;
    do {
      if (Xi && (Wi = null), xs = 0, Xi = !1, 25 <= p) throw Error(o(301));
      if (p += 1, wt = Xe = null, r.updateQueue != null) {
        var v = r.updateQueue;
        v.lastEffect = null, v.events = null, v.stores = null, v.memoCache != null && (v.memoCache.index = 0);
      }
      I.H = nb, v = i(s, u);
    } while (Xi);
    return v;
  }
  function $D() {
    var r = I.H, i = r.useState()[0];
    return i = typeof i.then == "function" ? Ss(i) : i, r = r.useState()[0], (Xe !== null ? Xe.memoizedState : null) !== r && (Ae.flags |= 1024), i;
  }
  function ih() {
    var r = Sc !== 0;
    return Sc = 0, r;
  }
  function ah(r, i, s) {
    i.updateQueue = r.updateQueue, i.flags &= -2053, r.lanes &= ~s;
  }
  function sh(r) {
    if (xc) {
      for (r = r.memoizedState; r !== null; ) {
        var i = r.queue;
        i !== null && (i.pending = null), r = r.next;
      }
      xc = !1;
    }
    zr = 0, wt = Xe = Ae = null, Xi = !1, xs = Sc = 0, Wi = null;
  }
  function Gt() {
    var r = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return wt === null ? Ae.memoizedState = wt = r : wt = wt.next = r, wt;
  }
  function yt() {
    if (Xe === null) {
      var r = Ae.alternate;
      r = r !== null ? r.memoizedState : null;
    } else r = Xe.next;
    var i = wt === null ? Ae.memoizedState : wt.next;
    if (i !== null)
      wt = i, Xe = r;
    else {
      if (r === null)
        throw Ae.alternate === null ? Error(o(467)) : Error(o(310));
      Xe = r, r = {
        memoizedState: Xe.memoizedState,
        baseState: Xe.baseState,
        baseQueue: Xe.baseQueue,
        queue: Xe.queue,
        next: null
      }, wt === null ? Ae.memoizedState = wt = r : wt = wt.next = r;
    }
    return wt;
  }
  function wc() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function Ss(r) {
    var i = xs;
    return xs += 1, Wi === null && (Wi = []), r = u0(Wi, r, i), i = Ae, (wt === null ? i.memoizedState : wt.next) === null && (i = i.alternate, I.H = i === null || i.memoizedState === null ? tb : bh), r;
  }
  function Ec(r) {
    if (r !== null && typeof r == "object") {
      if (typeof r.then == "function") return Ss(r);
      if (r.$$typeof === A) return Lt(r);
    }
    throw Error(o(438, String(r)));
  }
  function lh(r) {
    var i = null, s = Ae.updateQueue;
    if (s !== null && (i = s.memoCache), i == null) {
      var u = Ae.alternate;
      u !== null && (u = u.updateQueue, u !== null && (u = u.memoCache, u != null && (i = {
        data: u.data.map(function(p) {
          return p.slice();
        }),
        index: 0
      })));
    }
    if (i == null && (i = { data: [], index: 0 }), s === null && (s = wc(), Ae.updateQueue = s), s.memoCache = i, s = i.data[i.index], s === void 0)
      for (s = i.data[i.index] = Array(r), u = 0; u < r; u++)
        s[u] = Y;
    return i.index++, s;
  }
  function Dr(r, i) {
    return typeof i == "function" ? i(r) : i;
  }
  function _c(r) {
    var i = yt();
    return ch(i, Xe, r);
  }
  function ch(r, i, s) {
    var u = r.queue;
    if (u === null) throw Error(o(311));
    u.lastRenderedReducer = s;
    var p = r.baseQueue, v = u.pending;
    if (v !== null) {
      if (p !== null) {
        var w = p.next;
        p.next = v.next, v.next = w;
      }
      i.baseQueue = p = v, u.pending = null;
    }
    if (v = r.baseState, p === null) r.memoizedState = v;
    else {
      i = p.next;
      var D = w = null, P = null, F = i, Q = !1;
      do {
        var oe = F.lane & -536870913;
        if (oe !== F.lane ? (Ie & oe) === oe : (zr & oe) === oe) {
          var q = F.revertLane;
          if (q === 0)
            P !== null && (P = P.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: F.action,
              hasEagerState: F.hasEagerState,
              eagerState: F.eagerState,
              next: null
            }), oe === Zi && (Q = !0);
          else if ((zr & q) === q) {
            F = F.next, q === Zi && (Q = !0);
            continue;
          } else
            oe = {
              lane: 0,
              revertLane: F.revertLane,
              gesture: null,
              action: F.action,
              hasEagerState: F.hasEagerState,
              eagerState: F.eagerState,
              next: null
            }, P === null ? (D = P = oe, w = v) : P = P.next = oe, Ae.lanes |= q, co |= q;
          oe = F.action, ni && s(v, oe), v = F.hasEagerState ? F.eagerState : s(v, oe);
        } else
          q = {
            lane: oe,
            revertLane: F.revertLane,
            gesture: F.gesture,
            action: F.action,
            hasEagerState: F.hasEagerState,
            eagerState: F.eagerState,
            next: null
          }, P === null ? (D = P = q, w = v) : P = P.next = q, Ae.lanes |= oe, co |= oe;
        F = F.next;
      } while (F !== null && F !== i);
      if (P === null ? w = v : P.next = D, !hn(v, r.memoizedState) && (Et = !0, Q && (s = Fi, s !== null)))
        throw s;
      r.memoizedState = v, r.baseState = w, r.baseQueue = P, u.lastRenderedState = v;
    }
    return p === null && (u.lanes = 0), [r.memoizedState, u.dispatch];
  }
  function uh(r) {
    var i = yt(), s = i.queue;
    if (s === null) throw Error(o(311));
    s.lastRenderedReducer = r;
    var u = s.dispatch, p = s.pending, v = i.memoizedState;
    if (p !== null) {
      s.pending = null;
      var w = p = p.next;
      do
        v = r(v, w.action), w = w.next;
      while (w !== p);
      hn(v, i.memoizedState) || (Et = !0), i.memoizedState = v, i.baseQueue === null && (i.baseState = v), s.lastRenderedState = v;
    }
    return [v, u];
  }
  function S0(r, i, s) {
    var u = Ae, p = yt(), v = Ue;
    if (v) {
      if (s === void 0) throw Error(o(407));
      s = s();
    } else s = i();
    var w = !hn(
      (Xe || p).memoizedState,
      s
    );
    if (w && (p.memoizedState = s, Et = !0), p = p.queue, hh(_0.bind(null, u, p, r), [
      r
    ]), p.getSnapshot !== i || w || wt !== null && wt.memoizedState.tag & 1) {
      if (u.flags |= 2048, Ki(
        9,
        { destroy: void 0 },
        E0.bind(
          null,
          u,
          p,
          s,
          i
        ),
        null
      ), Qe === null) throw Error(o(349));
      v || (zr & 127) !== 0 || w0(u, i, s);
    }
    return s;
  }
  function w0(r, i, s) {
    r.flags |= 16384, r = { getSnapshot: i, value: s }, i = Ae.updateQueue, i === null ? (i = wc(), Ae.updateQueue = i, i.stores = [r]) : (s = i.stores, s === null ? i.stores = [r] : s.push(r));
  }
  function E0(r, i, s, u) {
    i.value = s, i.getSnapshot = u, T0(i) && C0(r);
  }
  function _0(r, i, s) {
    return s(function() {
      T0(i) && C0(r);
    });
  }
  function T0(r) {
    var i = r.getSnapshot;
    r = r.value;
    try {
      var s = i();
      return !hn(r, s);
    } catch {
      return !0;
    }
  }
  function C0(r) {
    var i = Yo(r, 2);
    i !== null && on(i, r, 2);
  }
  function fh(r) {
    var i = Gt();
    if (typeof r == "function") {
      var s = r;
      if (r = s(), ni) {
        Xr(!0);
        try {
          s();
        } finally {
          Xr(!1);
        }
      }
    }
    return i.memoizedState = i.baseState = r, i.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Dr,
      lastRenderedState: r
    }, i;
  }
  function A0(r, i, s, u) {
    return r.baseState = s, ch(
      r,
      Xe,
      typeof u == "function" ? u : Dr
    );
  }
  function HD(r, i, s, u, p) {
    if (Ac(r)) throw Error(o(485));
    if (r = i.action, r !== null) {
      var v = {
        payload: p,
        action: r,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(w) {
          v.listeners.push(w);
        }
      };
      I.T !== null ? s(!0) : v.isTransition = !1, u(v), s = i.pending, s === null ? (v.next = i.pending = v, R0(i, v)) : (v.next = s.next, i.pending = s.next = v);
    }
  }
  function R0(r, i) {
    var s = i.action, u = i.payload, p = r.state;
    if (i.isTransition) {
      var v = I.T, w = {};
      I.T = w;
      try {
        var D = s(p, u), P = I.S;
        P !== null && P(w, D), M0(r, i, D);
      } catch (F) {
        dh(r, i, F);
      } finally {
        v !== null && w.types !== null && (v.types = w.types), I.T = v;
      }
    } else
      try {
        v = s(p, u), M0(r, i, v);
      } catch (F) {
        dh(r, i, F);
      }
  }
  function M0(r, i, s) {
    s !== null && typeof s == "object" && typeof s.then == "function" ? s.then(
      function(u) {
        z0(r, i, u);
      },
      function(u) {
        return dh(r, i, u);
      }
    ) : z0(r, i, s);
  }
  function z0(r, i, s) {
    i.status = "fulfilled", i.value = s, D0(i), r.state = s, i = r.pending, i !== null && (s = i.next, s === i ? r.pending = null : (s = s.next, i.next = s, R0(r, s)));
  }
  function dh(r, i, s) {
    var u = r.pending;
    if (r.pending = null, u !== null) {
      u = u.next;
      do
        i.status = "rejected", i.reason = s, D0(i), i = i.next;
      while (i !== u);
    }
    r.action = null;
  }
  function D0(r) {
    r = r.listeners;
    for (var i = 0; i < r.length; i++) (0, r[i])();
  }
  function N0(r, i) {
    return i;
  }
  function O0(r, i) {
    if (Ue) {
      var s = Qe.formState;
      if (s !== null) {
        e: {
          var u = Ae;
          if (Ue) {
            if (rt) {
              t: {
                for (var p = rt, v = Dn; p.nodeType !== 8; ) {
                  if (!v) {
                    p = null;
                    break t;
                  }
                  if (p = On(
                    p.nextSibling
                  ), p === null) {
                    p = null;
                    break t;
                  }
                }
                v = p.data, p = v === "F!" || v === "F" ? p : null;
              }
              if (p) {
                rt = On(
                  p.nextSibling
                ), u = p.data === "F!";
                break e;
              }
            }
            eo(u);
          }
          u = !1;
        }
        u && (i = s[0]);
      }
    }
    return s = Gt(), s.memoizedState = s.baseState = i, u = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: N0,
      lastRenderedState: i
    }, s.queue = u, s = J0.bind(
      null,
      Ae,
      u
    ), u.dispatch = s, u = fh(!1), v = yh.bind(
      null,
      Ae,
      !1,
      u.queue
    ), u = Gt(), p = {
      state: i,
      dispatch: null,
      action: r,
      pending: null
    }, u.queue = p, s = HD.bind(
      null,
      Ae,
      p,
      v,
      s
    ), p.dispatch = s, u.memoizedState = r, [i, s, !1];
  }
  function j0(r) {
    var i = yt();
    return k0(i, Xe, r);
  }
  function k0(r, i, s) {
    if (i = ch(
      r,
      i,
      N0
    )[0], r = _c(Dr)[0], typeof i == "object" && i !== null && typeof i.then == "function")
      try {
        var u = Ss(i);
      } catch (w) {
        throw w === Gi ? pc : w;
      }
    else u = i;
    i = yt();
    var p = i.queue, v = p.dispatch;
    return s !== i.memoizedState && (Ae.flags |= 2048, Ki(
      9,
      { destroy: void 0 },
      ZD.bind(null, p, s),
      null
    )), [u, v, r];
  }
  function ZD(r, i) {
    r.action = i;
  }
  function P0(r) {
    var i = yt(), s = Xe;
    if (s !== null)
      return k0(i, s, r);
    yt(), i = i.memoizedState, s = yt();
    var u = s.queue.dispatch;
    return s.memoizedState = r, [i, u, !1];
  }
  function Ki(r, i, s, u) {
    return r = { tag: r, create: s, deps: u, inst: i, next: null }, i = Ae.updateQueue, i === null && (i = wc(), Ae.updateQueue = i), s = i.lastEffect, s === null ? i.lastEffect = r.next = r : (u = s.next, s.next = r, r.next = u, i.lastEffect = r), r;
  }
  function L0() {
    return yt().memoizedState;
  }
  function Tc(r, i, s, u) {
    var p = Gt();
    Ae.flags |= r, p.memoizedState = Ki(
      1 | i,
      { destroy: void 0 },
      s,
      u === void 0 ? null : u
    );
  }
  function Cc(r, i, s, u) {
    var p = yt();
    u = u === void 0 ? null : u;
    var v = p.memoizedState.inst;
    Xe !== null && u !== null && rh(u, Xe.memoizedState.deps) ? p.memoizedState = Ki(i, v, s, u) : (Ae.flags |= r, p.memoizedState = Ki(
      1 | i,
      v,
      s,
      u
    ));
  }
  function I0(r, i) {
    Tc(8390656, 8, r, i);
  }
  function hh(r, i) {
    Cc(2048, 8, r, i);
  }
  function FD(r) {
    Ae.flags |= 4;
    var i = Ae.updateQueue;
    if (i === null)
      i = wc(), Ae.updateQueue = i, i.events = [r];
    else {
      var s = i.events;
      s === null ? i.events = [r] : s.push(r);
    }
  }
  function V0(r) {
    var i = yt().memoizedState;
    return FD({ ref: i, nextImpl: r }), function() {
      if ((Ze & 2) !== 0) throw Error(o(440));
      return i.impl.apply(void 0, arguments);
    };
  }
  function U0(r, i) {
    return Cc(4, 2, r, i);
  }
  function B0(r, i) {
    return Cc(4, 4, r, i);
  }
  function $0(r, i) {
    if (typeof i == "function") {
      r = r();
      var s = i(r);
      return function() {
        typeof s == "function" ? s() : i(null);
      };
    }
    if (i != null)
      return r = r(), i.current = r, function() {
        i.current = null;
      };
  }
  function H0(r, i, s) {
    s = s != null ? s.concat([r]) : null, Cc(4, 4, $0.bind(null, i, r), s);
  }
  function ph() {
  }
  function Z0(r, i) {
    var s = yt();
    i = i === void 0 ? null : i;
    var u = s.memoizedState;
    return i !== null && rh(i, u[1]) ? u[0] : (s.memoizedState = [r, i], r);
  }
  function F0(r, i) {
    var s = yt();
    i = i === void 0 ? null : i;
    var u = s.memoizedState;
    if (i !== null && rh(i, u[1]))
      return u[0];
    if (u = r(), ni) {
      Xr(!0);
      try {
        r();
      } finally {
        Xr(!1);
      }
    }
    return s.memoizedState = [u, i], u;
  }
  function mh(r, i, s) {
    return s === void 0 || (zr & 1073741824) !== 0 && (Ie & 261930) === 0 ? r.memoizedState = i : (r.memoizedState = s, r = Gb(), Ae.lanes |= r, co |= r, s);
  }
  function G0(r, i, s, u) {
    return hn(s, i) ? s : qi.current !== null ? (r = mh(r, s, u), hn(r, i) || (Et = !0), r) : (zr & 42) === 0 || (zr & 1073741824) !== 0 && (Ie & 261930) === 0 ? (Et = !0, r.memoizedState = s) : (r = Gb(), Ae.lanes |= r, co |= r, i);
  }
  function Y0(r, i, s, u, p) {
    var v = G.p;
    G.p = v !== 0 && 8 > v ? v : 8;
    var w = I.T, D = {};
    I.T = D, yh(r, !1, i, s);
    try {
      var P = p(), F = I.S;
      if (F !== null && F(D, P), P !== null && typeof P == "object" && typeof P.then == "function") {
        var Q = UD(
          P,
          u
        );
        ws(
          r,
          i,
          Q,
          bn(r)
        );
      } else
        ws(
          r,
          i,
          u,
          bn(r)
        );
    } catch (oe) {
      ws(
        r,
        i,
        { then: function() {
        }, status: "rejected", reason: oe },
        bn()
      );
    } finally {
      G.p = v, w !== null && D.types !== null && (w.types = D.types), I.T = w;
    }
  }
  function GD() {
  }
  function gh(r, i, s, u) {
    if (r.tag !== 5) throw Error(o(476));
    var p = q0(r).queue;
    Y0(
      r,
      p,
      i,
      B,
      s === null ? GD : function() {
        return X0(r), s(u);
      }
    );
  }
  function q0(r) {
    var i = r.memoizedState;
    if (i !== null) return i;
    i = {
      memoizedState: B,
      baseState: B,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Dr,
        lastRenderedState: B
      },
      next: null
    };
    var s = {};
    return i.next = {
      memoizedState: s,
      baseState: s,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Dr,
        lastRenderedState: s
      },
      next: null
    }, r.memoizedState = i, r = r.alternate, r !== null && (r.memoizedState = i), i;
  }
  function X0(r) {
    var i = q0(r);
    i.next === null && (i = r.alternate.memoizedState), ws(
      r,
      i.next.queue,
      {},
      bn()
    );
  }
  function vh() {
    return Lt(Vs);
  }
  function W0() {
    return yt().memoizedState;
  }
  function K0() {
    return yt().memoizedState;
  }
  function YD(r) {
    for (var i = r.return; i !== null; ) {
      switch (i.tag) {
        case 24:
        case 3:
          var s = bn();
          r = ro(s);
          var u = oo(i, r, s);
          u !== null && (on(u, i, s), vs(u, i, s)), i = { cache: Gd() }, r.payload = i;
          return;
      }
      i = i.return;
    }
  }
  function qD(r, i, s) {
    var u = bn();
    s = {
      lane: u,
      revertLane: 0,
      gesture: null,
      action: s,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Ac(r) ? Q0(i, s) : (s = kd(r, i, s, u), s !== null && (on(s, r, u), eb(s, i, u)));
  }
  function J0(r, i, s) {
    var u = bn();
    ws(r, i, s, u);
  }
  function ws(r, i, s, u) {
    var p = {
      lane: u,
      revertLane: 0,
      gesture: null,
      action: s,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Ac(r)) Q0(i, p);
    else {
      var v = r.alternate;
      if (r.lanes === 0 && (v === null || v.lanes === 0) && (v = i.lastRenderedReducer, v !== null))
        try {
          var w = i.lastRenderedState, D = v(w, s);
          if (p.hasEagerState = !0, p.eagerState = D, hn(D, w))
            return sc(r, i, p, 0), Qe === null && ac(), !1;
        } catch {
        }
      if (s = kd(r, i, p, u), s !== null)
        return on(s, r, u), eb(s, i, u), !0;
    }
    return !1;
  }
  function yh(r, i, s, u) {
    if (u = {
      lane: 2,
      revertLane: Wh(),
      gesture: null,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Ac(r)) {
      if (i) throw Error(o(479));
    } else
      i = kd(
        r,
        s,
        u,
        2
      ), i !== null && on(i, r, 2);
  }
  function Ac(r) {
    var i = r.alternate;
    return r === Ae || i !== null && i === Ae;
  }
  function Q0(r, i) {
    Xi = xc = !0;
    var s = r.pending;
    s === null ? i.next = i : (i.next = s.next, s.next = i), r.pending = i;
  }
  function eb(r, i, s) {
    if ((s & 4194048) !== 0) {
      var u = i.lanes;
      u &= r.pendingLanes, s |= u, i.lanes = s, iy(r, s);
    }
  }
  var Es = {
    readContext: Lt,
    use: Ec,
    useCallback: ht,
    useContext: ht,
    useEffect: ht,
    useImperativeHandle: ht,
    useLayoutEffect: ht,
    useInsertionEffect: ht,
    useMemo: ht,
    useReducer: ht,
    useRef: ht,
    useState: ht,
    useDebugValue: ht,
    useDeferredValue: ht,
    useTransition: ht,
    useSyncExternalStore: ht,
    useId: ht,
    useHostTransitionStatus: ht,
    useFormState: ht,
    useActionState: ht,
    useOptimistic: ht,
    useMemoCache: ht,
    useCacheRefresh: ht
  };
  Es.useEffectEvent = ht;
  var tb = {
    readContext: Lt,
    use: Ec,
    useCallback: function(r, i) {
      return Gt().memoizedState = [
        r,
        i === void 0 ? null : i
      ], r;
    },
    useContext: Lt,
    useEffect: I0,
    useImperativeHandle: function(r, i, s) {
      s = s != null ? s.concat([r]) : null, Tc(
        4194308,
        4,
        $0.bind(null, i, r),
        s
      );
    },
    useLayoutEffect: function(r, i) {
      return Tc(4194308, 4, r, i);
    },
    useInsertionEffect: function(r, i) {
      Tc(4, 2, r, i);
    },
    useMemo: function(r, i) {
      var s = Gt();
      i = i === void 0 ? null : i;
      var u = r();
      if (ni) {
        Xr(!0);
        try {
          r();
        } finally {
          Xr(!1);
        }
      }
      return s.memoizedState = [u, i], u;
    },
    useReducer: function(r, i, s) {
      var u = Gt();
      if (s !== void 0) {
        var p = s(i);
        if (ni) {
          Xr(!0);
          try {
            s(i);
          } finally {
            Xr(!1);
          }
        }
      } else p = i;
      return u.memoizedState = u.baseState = p, r = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: r,
        lastRenderedState: p
      }, u.queue = r, r = r.dispatch = qD.bind(
        null,
        Ae,
        r
      ), [u.memoizedState, r];
    },
    useRef: function(r) {
      var i = Gt();
      return r = { current: r }, i.memoizedState = r;
    },
    useState: function(r) {
      r = fh(r);
      var i = r.queue, s = J0.bind(null, Ae, i);
      return i.dispatch = s, [r.memoizedState, s];
    },
    useDebugValue: ph,
    useDeferredValue: function(r, i) {
      var s = Gt();
      return mh(s, r, i);
    },
    useTransition: function() {
      var r = fh(!1);
      return r = Y0.bind(
        null,
        Ae,
        r.queue,
        !0,
        !1
      ), Gt().memoizedState = r, [!1, r];
    },
    useSyncExternalStore: function(r, i, s) {
      var u = Ae, p = Gt();
      if (Ue) {
        if (s === void 0)
          throw Error(o(407));
        s = s();
      } else {
        if (s = i(), Qe === null)
          throw Error(o(349));
        (Ie & 127) !== 0 || w0(u, i, s);
      }
      p.memoizedState = s;
      var v = { value: s, getSnapshot: i };
      return p.queue = v, I0(_0.bind(null, u, v, r), [
        r
      ]), u.flags |= 2048, Ki(
        9,
        { destroy: void 0 },
        E0.bind(
          null,
          u,
          v,
          s,
          i
        ),
        null
      ), s;
    },
    useId: function() {
      var r = Gt(), i = Qe.identifierPrefix;
      if (Ue) {
        var s = rr, u = nr;
        s = (u & ~(1 << 32 - dn(u) - 1)).toString(32) + s, i = "_" + i + "R_" + s, s = Sc++, 0 < s && (i += "H" + s.toString(32)), i += "_";
      } else
        s = BD++, i = "_" + i + "r_" + s.toString(32) + "_";
      return r.memoizedState = i;
    },
    useHostTransitionStatus: vh,
    useFormState: O0,
    useActionState: O0,
    useOptimistic: function(r) {
      var i = Gt();
      i.memoizedState = i.baseState = r;
      var s = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return i.queue = s, i = yh.bind(
        null,
        Ae,
        !0,
        s
      ), s.dispatch = i, [r, i];
    },
    useMemoCache: lh,
    useCacheRefresh: function() {
      return Gt().memoizedState = YD.bind(
        null,
        Ae
      );
    },
    useEffectEvent: function(r) {
      var i = Gt(), s = { impl: r };
      return i.memoizedState = s, function() {
        if ((Ze & 2) !== 0)
          throw Error(o(440));
        return s.impl.apply(void 0, arguments);
      };
    }
  }, bh = {
    readContext: Lt,
    use: Ec,
    useCallback: Z0,
    useContext: Lt,
    useEffect: hh,
    useImperativeHandle: H0,
    useInsertionEffect: U0,
    useLayoutEffect: B0,
    useMemo: F0,
    useReducer: _c,
    useRef: L0,
    useState: function() {
      return _c(Dr);
    },
    useDebugValue: ph,
    useDeferredValue: function(r, i) {
      var s = yt();
      return G0(
        s,
        Xe.memoizedState,
        r,
        i
      );
    },
    useTransition: function() {
      var r = _c(Dr)[0], i = yt().memoizedState;
      return [
        typeof r == "boolean" ? r : Ss(r),
        i
      ];
    },
    useSyncExternalStore: S0,
    useId: W0,
    useHostTransitionStatus: vh,
    useFormState: j0,
    useActionState: j0,
    useOptimistic: function(r, i) {
      var s = yt();
      return A0(s, Xe, r, i);
    },
    useMemoCache: lh,
    useCacheRefresh: K0
  };
  bh.useEffectEvent = V0;
  var nb = {
    readContext: Lt,
    use: Ec,
    useCallback: Z0,
    useContext: Lt,
    useEffect: hh,
    useImperativeHandle: H0,
    useInsertionEffect: U0,
    useLayoutEffect: B0,
    useMemo: F0,
    useReducer: uh,
    useRef: L0,
    useState: function() {
      return uh(Dr);
    },
    useDebugValue: ph,
    useDeferredValue: function(r, i) {
      var s = yt();
      return Xe === null ? mh(s, r, i) : G0(
        s,
        Xe.memoizedState,
        r,
        i
      );
    },
    useTransition: function() {
      var r = uh(Dr)[0], i = yt().memoizedState;
      return [
        typeof r == "boolean" ? r : Ss(r),
        i
      ];
    },
    useSyncExternalStore: S0,
    useId: W0,
    useHostTransitionStatus: vh,
    useFormState: P0,
    useActionState: P0,
    useOptimistic: function(r, i) {
      var s = yt();
      return Xe !== null ? A0(s, Xe, r, i) : (s.baseState = r, [r, s.queue.dispatch]);
    },
    useMemoCache: lh,
    useCacheRefresh: K0
  };
  nb.useEffectEvent = V0;
  function xh(r, i, s, u) {
    i = r.memoizedState, s = s(u, i), s = s == null ? i : g({}, i, s), r.memoizedState = s, r.lanes === 0 && (r.updateQueue.baseState = s);
  }
  var Sh = {
    enqueueSetState: function(r, i, s) {
      r = r._reactInternals;
      var u = bn(), p = ro(u);
      p.payload = i, s != null && (p.callback = s), i = oo(r, p, u), i !== null && (on(i, r, u), vs(i, r, u));
    },
    enqueueReplaceState: function(r, i, s) {
      r = r._reactInternals;
      var u = bn(), p = ro(u);
      p.tag = 1, p.payload = i, s != null && (p.callback = s), i = oo(r, p, u), i !== null && (on(i, r, u), vs(i, r, u));
    },
    enqueueForceUpdate: function(r, i) {
      r = r._reactInternals;
      var s = bn(), u = ro(s);
      u.tag = 2, i != null && (u.callback = i), i = oo(r, u, s), i !== null && (on(i, r, s), vs(i, r, s));
    }
  };
  function rb(r, i, s, u, p, v, w) {
    return r = r.stateNode, typeof r.shouldComponentUpdate == "function" ? r.shouldComponentUpdate(u, v, w) : i.prototype && i.prototype.isPureReactComponent ? !cs(s, u) || !cs(p, v) : !0;
  }
  function ob(r, i, s, u) {
    r = i.state, typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(s, u), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(s, u), i.state !== r && Sh.enqueueReplaceState(i, i.state, null);
  }
  function ri(r, i) {
    var s = i;
    if ("ref" in i) {
      s = {};
      for (var u in i)
        u !== "ref" && (s[u] = i[u]);
    }
    if (r = r.defaultProps) {
      s === i && (s = g({}, s));
      for (var p in r)
        s[p] === void 0 && (s[p] = r[p]);
    }
    return s;
  }
  function ib(r) {
    ic(r);
  }
  function ab(r) {
    console.error(r);
  }
  function sb(r) {
    ic(r);
  }
  function Rc(r, i) {
    try {
      var s = r.onUncaughtError;
      s(i.value, { componentStack: i.stack });
    } catch (u) {
      setTimeout(function() {
        throw u;
      });
    }
  }
  function lb(r, i, s) {
    try {
      var u = r.onCaughtError;
      u(s.value, {
        componentStack: s.stack,
        errorBoundary: i.tag === 1 ? i.stateNode : null
      });
    } catch (p) {
      setTimeout(function() {
        throw p;
      });
    }
  }
  function wh(r, i, s) {
    return s = ro(s), s.tag = 3, s.payload = { element: null }, s.callback = function() {
      Rc(r, i);
    }, s;
  }
  function cb(r) {
    return r = ro(r), r.tag = 3, r;
  }
  function ub(r, i, s, u) {
    var p = s.type.getDerivedStateFromError;
    if (typeof p == "function") {
      var v = u.value;
      r.payload = function() {
        return p(v);
      }, r.callback = function() {
        lb(i, s, u);
      };
    }
    var w = s.stateNode;
    w !== null && typeof w.componentDidCatch == "function" && (r.callback = function() {
      lb(i, s, u), typeof p != "function" && (uo === null ? uo = /* @__PURE__ */ new Set([this]) : uo.add(this));
      var D = u.stack;
      this.componentDidCatch(u.value, {
        componentStack: D !== null ? D : ""
      });
    });
  }
  function XD(r, i, s, u, p) {
    if (s.flags |= 32768, u !== null && typeof u == "object" && typeof u.then == "function") {
      if (i = s.alternate, i !== null && Hi(
        i,
        s,
        p,
        !0
      ), s = mn.current, s !== null) {
        switch (s.tag) {
          case 31:
          case 13:
            return Nn === null ? Uc() : s.alternate === null && pt === 0 && (pt = 3), s.flags &= -257, s.flags |= 65536, s.lanes = p, u === mc ? s.flags |= 16384 : (i = s.updateQueue, i === null ? s.updateQueue = /* @__PURE__ */ new Set([u]) : i.add(u), Yh(r, u, p)), !1;
          case 22:
            return s.flags |= 65536, u === mc ? s.flags |= 16384 : (i = s.updateQueue, i === null ? (i = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([u])
            }, s.updateQueue = i) : (s = i.retryQueue, s === null ? i.retryQueue = /* @__PURE__ */ new Set([u]) : s.add(u)), Yh(r, u, p)), !1;
        }
        throw Error(o(435, s.tag));
      }
      return Yh(r, u, p), Uc(), !1;
    }
    if (Ue)
      return i = mn.current, i !== null ? ((i.flags & 65536) === 0 && (i.flags |= 256), i.flags |= 65536, i.lanes = p, u !== Bd && (r = Error(o(422), { cause: u }), ds(Rn(r, s)))) : (u !== Bd && (i = Error(o(423), {
        cause: u
      }), ds(
        Rn(i, s)
      )), r = r.current.alternate, r.flags |= 65536, p &= -p, r.lanes |= p, u = Rn(u, s), p = wh(
        r.stateNode,
        u,
        p
      ), Jd(r, p), pt !== 4 && (pt = 2)), !1;
    var v = Error(o(520), { cause: u });
    if (v = Rn(v, s), Ds === null ? Ds = [v] : Ds.push(v), pt !== 4 && (pt = 2), i === null) return !0;
    u = Rn(u, s), s = i;
    do {
      switch (s.tag) {
        case 3:
          return s.flags |= 65536, r = p & -p, s.lanes |= r, r = wh(s.stateNode, u, r), Jd(s, r), !1;
        case 1:
          if (i = s.type, v = s.stateNode, (s.flags & 128) === 0 && (typeof i.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (uo === null || !uo.has(v))))
            return s.flags |= 65536, p &= -p, s.lanes |= p, p = cb(p), ub(
              p,
              r,
              s,
              u
            ), Jd(s, p), !1;
      }
      s = s.return;
    } while (s !== null);
    return !1;
  }
  var Eh = Error(o(461)), Et = !1;
  function It(r, i, s, u) {
    i.child = r === null ? p0(i, null, s, u) : ti(
      i,
      r.child,
      s,
      u
    );
  }
  function fb(r, i, s, u, p) {
    s = s.render;
    var v = i.ref;
    if ("ref" in u) {
      var w = {};
      for (var D in u)
        D !== "ref" && (w[D] = u[D]);
    } else w = u;
    return Ko(i), u = oh(
      r,
      i,
      s,
      w,
      v,
      p
    ), D = ih(), r !== null && !Et ? (ah(r, i, p), Nr(r, i, p)) : (Ue && D && Vd(i), i.flags |= 1, It(r, i, u, p), i.child);
  }
  function db(r, i, s, u, p) {
    if (r === null) {
      var v = s.type;
      return typeof v == "function" && !Pd(v) && v.defaultProps === void 0 && s.compare === null ? (i.tag = 15, i.type = v, hb(
        r,
        i,
        v,
        u,
        p
      )) : (r = cc(
        s.type,
        null,
        u,
        i,
        i.mode,
        p
      ), r.ref = i.ref, r.return = i, i.child = r);
    }
    if (v = r.child, !Dh(r, p)) {
      var w = v.memoizedProps;
      if (s = s.compare, s = s !== null ? s : cs, s(w, u) && r.ref === i.ref)
        return Nr(r, i, p);
    }
    return i.flags |= 1, r = Cr(v, u), r.ref = i.ref, r.return = i, i.child = r;
  }
  function hb(r, i, s, u, p) {
    if (r !== null) {
      var v = r.memoizedProps;
      if (cs(v, u) && r.ref === i.ref)
        if (Et = !1, i.pendingProps = u = v, Dh(r, p))
          (r.flags & 131072) !== 0 && (Et = !0);
        else
          return i.lanes = r.lanes, Nr(r, i, p);
    }
    return _h(
      r,
      i,
      s,
      u,
      p
    );
  }
  function pb(r, i, s, u) {
    var p = u.children, v = r !== null ? r.memoizedState : null;
    if (r === null && i.stateNode === null && (i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), u.mode === "hidden") {
      if ((i.flags & 128) !== 0) {
        if (v = v !== null ? v.baseLanes | s : s, r !== null) {
          for (u = i.child = r.child, p = 0; u !== null; )
            p = p | u.lanes | u.childLanes, u = u.sibling;
          u = p & ~v;
        } else u = 0, i.child = null;
        return mb(
          r,
          i,
          v,
          s,
          u
        );
      }
      if ((s & 536870912) !== 0)
        i.memoizedState = { baseLanes: 0, cachePool: null }, r !== null && hc(
          i,
          v !== null ? v.cachePool : null
        ), v !== null ? v0(i, v) : eh(), y0(i);
      else
        return u = i.lanes = 536870912, mb(
          r,
          i,
          v !== null ? v.baseLanes | s : s,
          s,
          u
        );
    } else
      v !== null ? (hc(i, v.cachePool), v0(i, v), ao(), i.memoizedState = null) : (r !== null && hc(i, null), eh(), ao());
    return It(r, i, p, s), i.child;
  }
  function _s(r, i) {
    return r !== null && r.tag === 22 || i.stateNode !== null || (i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), i.sibling;
  }
  function mb(r, i, s, u, p) {
    var v = qd();
    return v = v === null ? null : { parent: St._currentValue, pool: v }, i.memoizedState = {
      baseLanes: s,
      cachePool: v
    }, r !== null && hc(i, null), eh(), y0(i), r !== null && Hi(r, i, u, !0), i.childLanes = p, null;
  }
  function Mc(r, i) {
    return i = Dc(
      { mode: i.mode, children: i.children },
      r.mode
    ), i.ref = r.ref, r.child = i, i.return = r, i;
  }
  function gb(r, i, s) {
    return ti(i, r.child, null, s), r = Mc(i, i.pendingProps), r.flags |= 2, gn(i), i.memoizedState = null, r;
  }
  function WD(r, i, s) {
    var u = i.pendingProps, p = (i.flags & 128) !== 0;
    if (i.flags &= -129, r === null) {
      if (Ue) {
        if (u.mode === "hidden")
          return r = Mc(i, u), i.lanes = 536870912, _s(null, r);
        if (nh(i), (r = rt) ? (r = Rx(
          r,
          Dn
        ), r = r !== null && r.data === "&" ? r : null, r !== null && (i.memoizedState = {
          dehydrated: r,
          treeContext: Jr !== null ? { id: nr, overflow: rr } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, s = Qy(r), s.return = i, i.child = s, Pt = i, rt = null)) : r = null, r === null) throw eo(i);
        return i.lanes = 536870912, null;
      }
      return Mc(i, u);
    }
    var v = r.memoizedState;
    if (v !== null) {
      var w = v.dehydrated;
      if (nh(i), p)
        if (i.flags & 256)
          i.flags &= -257, i = gb(
            r,
            i,
            s
          );
        else if (i.memoizedState !== null)
          i.child = r.child, i.flags |= 128, i = null;
        else throw Error(o(558));
      else if (Et || Hi(r, i, s, !1), p = (s & r.childLanes) !== 0, Et || p) {
        if (u = Qe, u !== null && (w = ay(u, s), w !== 0 && w !== v.retryLane))
          throw v.retryLane = w, Yo(r, w), on(u, r, w), Eh;
        Uc(), i = gb(
          r,
          i,
          s
        );
      } else
        r = v.treeContext, rt = On(w.nextSibling), Pt = i, Ue = !0, Qr = null, Dn = !1, r !== null && n0(i, r), i = Mc(i, u), i.flags |= 4096;
      return i;
    }
    return r = Cr(r.child, {
      mode: u.mode,
      children: u.children
    }), r.ref = i.ref, i.child = r, r.return = i, r;
  }
  function zc(r, i) {
    var s = i.ref;
    if (s === null)
      r !== null && r.ref !== null && (i.flags |= 4194816);
    else {
      if (typeof s != "function" && typeof s != "object")
        throw Error(o(284));
      (r === null || r.ref !== s) && (i.flags |= 4194816);
    }
  }
  function _h(r, i, s, u, p) {
    return Ko(i), s = oh(
      r,
      i,
      s,
      u,
      void 0,
      p
    ), u = ih(), r !== null && !Et ? (ah(r, i, p), Nr(r, i, p)) : (Ue && u && Vd(i), i.flags |= 1, It(r, i, s, p), i.child);
  }
  function vb(r, i, s, u, p, v) {
    return Ko(i), i.updateQueue = null, s = x0(
      i,
      u,
      s,
      p
    ), b0(r), u = ih(), r !== null && !Et ? (ah(r, i, v), Nr(r, i, v)) : (Ue && u && Vd(i), i.flags |= 1, It(r, i, s, v), i.child);
  }
  function yb(r, i, s, u, p) {
    if (Ko(i), i.stateNode === null) {
      var v = Vi, w = s.contextType;
      typeof w == "object" && w !== null && (v = Lt(w)), v = new s(u, v), i.memoizedState = v.state !== null && v.state !== void 0 ? v.state : null, v.updater = Sh, i.stateNode = v, v._reactInternals = i, v = i.stateNode, v.props = u, v.state = i.memoizedState, v.refs = {}, Wd(i), w = s.contextType, v.context = typeof w == "object" && w !== null ? Lt(w) : Vi, v.state = i.memoizedState, w = s.getDerivedStateFromProps, typeof w == "function" && (xh(
        i,
        s,
        w,
        u
      ), v.state = i.memoizedState), typeof s.getDerivedStateFromProps == "function" || typeof v.getSnapshotBeforeUpdate == "function" || typeof v.UNSAFE_componentWillMount != "function" && typeof v.componentWillMount != "function" || (w = v.state, typeof v.componentWillMount == "function" && v.componentWillMount(), typeof v.UNSAFE_componentWillMount == "function" && v.UNSAFE_componentWillMount(), w !== v.state && Sh.enqueueReplaceState(v, v.state, null), bs(i, u, v, p), ys(), v.state = i.memoizedState), typeof v.componentDidMount == "function" && (i.flags |= 4194308), u = !0;
    } else if (r === null) {
      v = i.stateNode;
      var D = i.memoizedProps, P = ri(s, D);
      v.props = P;
      var F = v.context, Q = s.contextType;
      w = Vi, typeof Q == "object" && Q !== null && (w = Lt(Q));
      var oe = s.getDerivedStateFromProps;
      Q = typeof oe == "function" || typeof v.getSnapshotBeforeUpdate == "function", D = i.pendingProps !== D, Q || typeof v.UNSAFE_componentWillReceiveProps != "function" && typeof v.componentWillReceiveProps != "function" || (D || F !== w) && ob(
        i,
        v,
        u,
        w
      ), no = !1;
      var q = i.memoizedState;
      v.state = q, bs(i, u, v, p), ys(), F = i.memoizedState, D || q !== F || no ? (typeof oe == "function" && (xh(
        i,
        s,
        oe,
        u
      ), F = i.memoizedState), (P = no || rb(
        i,
        s,
        P,
        u,
        q,
        F,
        w
      )) ? (Q || typeof v.UNSAFE_componentWillMount != "function" && typeof v.componentWillMount != "function" || (typeof v.componentWillMount == "function" && v.componentWillMount(), typeof v.UNSAFE_componentWillMount == "function" && v.UNSAFE_componentWillMount()), typeof v.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof v.componentDidMount == "function" && (i.flags |= 4194308), i.memoizedProps = u, i.memoizedState = F), v.props = u, v.state = F, v.context = w, u = P) : (typeof v.componentDidMount == "function" && (i.flags |= 4194308), u = !1);
    } else {
      v = i.stateNode, Kd(r, i), w = i.memoizedProps, Q = ri(s, w), v.props = Q, oe = i.pendingProps, q = v.context, F = s.contextType, P = Vi, typeof F == "object" && F !== null && (P = Lt(F)), D = s.getDerivedStateFromProps, (F = typeof D == "function" || typeof v.getSnapshotBeforeUpdate == "function") || typeof v.UNSAFE_componentWillReceiveProps != "function" && typeof v.componentWillReceiveProps != "function" || (w !== oe || q !== P) && ob(
        i,
        v,
        u,
        P
      ), no = !1, q = i.memoizedState, v.state = q, bs(i, u, v, p), ys();
      var W = i.memoizedState;
      w !== oe || q !== W || no || r !== null && r.dependencies !== null && fc(r.dependencies) ? (typeof D == "function" && (xh(
        i,
        s,
        D,
        u
      ), W = i.memoizedState), (Q = no || rb(
        i,
        s,
        Q,
        u,
        q,
        W,
        P
      ) || r !== null && r.dependencies !== null && fc(r.dependencies)) ? (F || typeof v.UNSAFE_componentWillUpdate != "function" && typeof v.componentWillUpdate != "function" || (typeof v.componentWillUpdate == "function" && v.componentWillUpdate(u, W, P), typeof v.UNSAFE_componentWillUpdate == "function" && v.UNSAFE_componentWillUpdate(
        u,
        W,
        P
      )), typeof v.componentDidUpdate == "function" && (i.flags |= 4), typeof v.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof v.componentDidUpdate != "function" || w === r.memoizedProps && q === r.memoizedState || (i.flags |= 4), typeof v.getSnapshotBeforeUpdate != "function" || w === r.memoizedProps && q === r.memoizedState || (i.flags |= 1024), i.memoizedProps = u, i.memoizedState = W), v.props = u, v.state = W, v.context = P, u = Q) : (typeof v.componentDidUpdate != "function" || w === r.memoizedProps && q === r.memoizedState || (i.flags |= 4), typeof v.getSnapshotBeforeUpdate != "function" || w === r.memoizedProps && q === r.memoizedState || (i.flags |= 1024), u = !1);
    }
    return v = u, zc(r, i), u = (i.flags & 128) !== 0, v || u ? (v = i.stateNode, s = u && typeof s.getDerivedStateFromError != "function" ? null : v.render(), i.flags |= 1, r !== null && u ? (i.child = ti(
      i,
      r.child,
      null,
      p
    ), i.child = ti(
      i,
      null,
      s,
      p
    )) : It(r, i, s, p), i.memoizedState = v.state, r = i.child) : r = Nr(
      r,
      i,
      p
    ), r;
  }
  function bb(r, i, s, u) {
    return Xo(), i.flags |= 256, It(r, i, s, u), i.child;
  }
  var Th = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function Ch(r) {
    return { baseLanes: r, cachePool: l0() };
  }
  function Ah(r, i, s) {
    return r = r !== null ? r.childLanes & ~s : 0, i && (r |= yn), r;
  }
  function xb(r, i, s) {
    var u = i.pendingProps, p = !1, v = (i.flags & 128) !== 0, w;
    if ((w = v) || (w = r !== null && r.memoizedState === null ? !1 : (vt.current & 2) !== 0), w && (p = !0, i.flags &= -129), w = (i.flags & 32) !== 0, i.flags &= -33, r === null) {
      if (Ue) {
        if (p ? io(i) : ao(), (r = rt) ? (r = Rx(
          r,
          Dn
        ), r = r !== null && r.data !== "&" ? r : null, r !== null && (i.memoizedState = {
          dehydrated: r,
          treeContext: Jr !== null ? { id: nr, overflow: rr } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, s = Qy(r), s.return = i, i.child = s, Pt = i, rt = null)) : r = null, r === null) throw eo(i);
        return cp(r) ? i.lanes = 32 : i.lanes = 536870912, null;
      }
      var D = u.children;
      return u = u.fallback, p ? (ao(), p = i.mode, D = Dc(
        { mode: "hidden", children: D },
        p
      ), u = qo(
        u,
        p,
        s,
        null
      ), D.return = i, u.return = i, D.sibling = u, i.child = D, u = i.child, u.memoizedState = Ch(s), u.childLanes = Ah(
        r,
        w,
        s
      ), i.memoizedState = Th, _s(null, u)) : (io(i), Rh(i, D));
    }
    var P = r.memoizedState;
    if (P !== null && (D = P.dehydrated, D !== null)) {
      if (v)
        i.flags & 256 ? (io(i), i.flags &= -257, i = Mh(
          r,
          i,
          s
        )) : i.memoizedState !== null ? (ao(), i.child = r.child, i.flags |= 128, i = null) : (ao(), D = u.fallback, p = i.mode, u = Dc(
          { mode: "visible", children: u.children },
          p
        ), D = qo(
          D,
          p,
          s,
          null
        ), D.flags |= 2, u.return = i, D.return = i, u.sibling = D, i.child = u, ti(
          i,
          r.child,
          null,
          s
        ), u = i.child, u.memoizedState = Ch(s), u.childLanes = Ah(
          r,
          w,
          s
        ), i.memoizedState = Th, i = _s(null, u));
      else if (io(i), cp(D)) {
        if (w = D.nextSibling && D.nextSibling.dataset, w) var F = w.dgst;
        w = F, u = Error(o(419)), u.stack = "", u.digest = w, ds({ value: u, source: null, stack: null }), i = Mh(
          r,
          i,
          s
        );
      } else if (Et || Hi(r, i, s, !1), w = (s & r.childLanes) !== 0, Et || w) {
        if (w = Qe, w !== null && (u = ay(w, s), u !== 0 && u !== P.retryLane))
          throw P.retryLane = u, Yo(r, u), on(w, r, u), Eh;
        lp(D) || Uc(), i = Mh(
          r,
          i,
          s
        );
      } else
        lp(D) ? (i.flags |= 192, i.child = r.child, i = null) : (r = P.treeContext, rt = On(
          D.nextSibling
        ), Pt = i, Ue = !0, Qr = null, Dn = !1, r !== null && n0(i, r), i = Rh(
          i,
          u.children
        ), i.flags |= 4096);
      return i;
    }
    return p ? (ao(), D = u.fallback, p = i.mode, P = r.child, F = P.sibling, u = Cr(P, {
      mode: "hidden",
      children: u.children
    }), u.subtreeFlags = P.subtreeFlags & 65011712, F !== null ? D = Cr(
      F,
      D
    ) : (D = qo(
      D,
      p,
      s,
      null
    ), D.flags |= 2), D.return = i, u.return = i, u.sibling = D, i.child = u, _s(null, u), u = i.child, D = r.child.memoizedState, D === null ? D = Ch(s) : (p = D.cachePool, p !== null ? (P = St._currentValue, p = p.parent !== P ? { parent: P, pool: P } : p) : p = l0(), D = {
      baseLanes: D.baseLanes | s,
      cachePool: p
    }), u.memoizedState = D, u.childLanes = Ah(
      r,
      w,
      s
    ), i.memoizedState = Th, _s(r.child, u)) : (io(i), s = r.child, r = s.sibling, s = Cr(s, {
      mode: "visible",
      children: u.children
    }), s.return = i, s.sibling = null, r !== null && (w = i.deletions, w === null ? (i.deletions = [r], i.flags |= 16) : w.push(r)), i.child = s, i.memoizedState = null, s);
  }
  function Rh(r, i) {
    return i = Dc(
      { mode: "visible", children: i },
      r.mode
    ), i.return = r, r.child = i;
  }
  function Dc(r, i) {
    return r = pn(22, r, null, i), r.lanes = 0, r;
  }
  function Mh(r, i, s) {
    return ti(i, r.child, null, s), r = Rh(
      i,
      i.pendingProps.children
    ), r.flags |= 2, i.memoizedState = null, r;
  }
  function Sb(r, i, s) {
    r.lanes |= i;
    var u = r.alternate;
    u !== null && (u.lanes |= i), Zd(r.return, i, s);
  }
  function zh(r, i, s, u, p, v) {
    var w = r.memoizedState;
    w === null ? r.memoizedState = {
      isBackwards: i,
      rendering: null,
      renderingStartTime: 0,
      last: u,
      tail: s,
      tailMode: p,
      treeForkCount: v
    } : (w.isBackwards = i, w.rendering = null, w.renderingStartTime = 0, w.last = u, w.tail = s, w.tailMode = p, w.treeForkCount = v);
  }
  function wb(r, i, s) {
    var u = i.pendingProps, p = u.revealOrder, v = u.tail;
    u = u.children;
    var w = vt.current, D = (w & 2) !== 0;
    if (D ? (w = w & 1 | 2, i.flags |= 128) : w &= 1, H(vt, w), It(r, i, u, s), u = Ue ? fs : 0, !D && r !== null && (r.flags & 128) !== 0)
      e: for (r = i.child; r !== null; ) {
        if (r.tag === 13)
          r.memoizedState !== null && Sb(r, s, i);
        else if (r.tag === 19)
          Sb(r, s, i);
        else if (r.child !== null) {
          r.child.return = r, r = r.child;
          continue;
        }
        if (r === i) break e;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === i)
            break e;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
    switch (p) {
      case "forwards":
        for (s = i.child, p = null; s !== null; )
          r = s.alternate, r !== null && bc(r) === null && (p = s), s = s.sibling;
        s = p, s === null ? (p = i.child, i.child = null) : (p = s.sibling, s.sibling = null), zh(
          i,
          !1,
          p,
          s,
          v,
          u
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (s = null, p = i.child, i.child = null; p !== null; ) {
          if (r = p.alternate, r !== null && bc(r) === null) {
            i.child = p;
            break;
          }
          r = p.sibling, p.sibling = s, s = p, p = r;
        }
        zh(
          i,
          !0,
          s,
          null,
          v,
          u
        );
        break;
      case "together":
        zh(
          i,
          !1,
          null,
          null,
          void 0,
          u
        );
        break;
      default:
        i.memoizedState = null;
    }
    return i.child;
  }
  function Nr(r, i, s) {
    if (r !== null && (i.dependencies = r.dependencies), co |= i.lanes, (s & i.childLanes) === 0)
      if (r !== null) {
        if (Hi(
          r,
          i,
          s,
          !1
        ), (s & i.childLanes) === 0)
          return null;
      } else return null;
    if (r !== null && i.child !== r.child)
      throw Error(o(153));
    if (i.child !== null) {
      for (r = i.child, s = Cr(r, r.pendingProps), i.child = s, s.return = i; r.sibling !== null; )
        r = r.sibling, s = s.sibling = Cr(r, r.pendingProps), s.return = i;
      s.sibling = null;
    }
    return i.child;
  }
  function Dh(r, i) {
    return (r.lanes & i) !== 0 ? !0 : (r = r.dependencies, !!(r !== null && fc(r)));
  }
  function KD(r, i, s) {
    switch (i.tag) {
      case 3:
        ie(i, i.stateNode.containerInfo), to(i, St, r.memoizedState.cache), Xo();
        break;
      case 27:
      case 5:
        ue(i);
        break;
      case 4:
        ie(i, i.stateNode.containerInfo);
        break;
      case 10:
        to(
          i,
          i.type,
          i.memoizedProps.value
        );
        break;
      case 31:
        if (i.memoizedState !== null)
          return i.flags |= 128, nh(i), null;
        break;
      case 13:
        var u = i.memoizedState;
        if (u !== null)
          return u.dehydrated !== null ? (io(i), i.flags |= 128, null) : (s & i.child.childLanes) !== 0 ? xb(r, i, s) : (io(i), r = Nr(
            r,
            i,
            s
          ), r !== null ? r.sibling : null);
        io(i);
        break;
      case 19:
        var p = (r.flags & 128) !== 0;
        if (u = (s & i.childLanes) !== 0, u || (Hi(
          r,
          i,
          s,
          !1
        ), u = (s & i.childLanes) !== 0), p) {
          if (u)
            return wb(
              r,
              i,
              s
            );
          i.flags |= 128;
        }
        if (p = i.memoizedState, p !== null && (p.rendering = null, p.tail = null, p.lastEffect = null), H(vt, vt.current), u) break;
        return null;
      case 22:
        return i.lanes = 0, pb(
          r,
          i,
          s,
          i.pendingProps
        );
      case 24:
        to(i, St, r.memoizedState.cache);
    }
    return Nr(r, i, s);
  }
  function Eb(r, i, s) {
    if (r !== null)
      if (r.memoizedProps !== i.pendingProps)
        Et = !0;
      else {
        if (!Dh(r, s) && (i.flags & 128) === 0)
          return Et = !1, KD(
            r,
            i,
            s
          );
        Et = (r.flags & 131072) !== 0;
      }
    else
      Et = !1, Ue && (i.flags & 1048576) !== 0 && t0(i, fs, i.index);
    switch (i.lanes = 0, i.tag) {
      case 16:
        e: {
          var u = i.pendingProps;
          if (r = Qo(i.elementType), i.type = r, typeof r == "function")
            Pd(r) ? (u = ri(r, u), i.tag = 1, i = yb(
              null,
              i,
              r,
              u,
              s
            )) : (i.tag = 0, i = _h(
              null,
              i,
              r,
              u,
              s
            ));
          else {
            if (r != null) {
              var p = r.$$typeof;
              if (p === R) {
                i.tag = 11, i = fb(
                  null,
                  i,
                  r,
                  u,
                  s
                );
                break e;
              } else if (p === M) {
                i.tag = 14, i = db(
                  null,
                  i,
                  r,
                  u,
                  s
                );
                break e;
              }
            }
            throw i = fe(r) || r, Error(o(306, i, ""));
          }
        }
        return i;
      case 0:
        return _h(
          r,
          i,
          i.type,
          i.pendingProps,
          s
        );
      case 1:
        return u = i.type, p = ri(
          u,
          i.pendingProps
        ), yb(
          r,
          i,
          u,
          p,
          s
        );
      case 3:
        e: {
          if (ie(
            i,
            i.stateNode.containerInfo
          ), r === null) throw Error(o(387));
          u = i.pendingProps;
          var v = i.memoizedState;
          p = v.element, Kd(r, i), bs(i, u, null, s);
          var w = i.memoizedState;
          if (u = w.cache, to(i, St, u), u !== v.cache && Fd(
            i,
            [St],
            s,
            !0
          ), ys(), u = w.element, v.isDehydrated)
            if (v = {
              element: u,
              isDehydrated: !1,
              cache: w.cache
            }, i.updateQueue.baseState = v, i.memoizedState = v, i.flags & 256) {
              i = bb(
                r,
                i,
                u,
                s
              );
              break e;
            } else if (u !== p) {
              p = Rn(
                Error(o(424)),
                i
              ), ds(p), i = bb(
                r,
                i,
                u,
                s
              );
              break e;
            } else
              for (r = i.stateNode.containerInfo, r.nodeType === 9 ? r = r.body : r = r.nodeName === "HTML" ? r.ownerDocument.body : r, rt = On(r.firstChild), Pt = i, Ue = !0, Qr = null, Dn = !0, s = p0(
                i,
                null,
                u,
                s
              ), i.child = s; s; )
                s.flags = s.flags & -3 | 4096, s = s.sibling;
          else {
            if (Xo(), u === p) {
              i = Nr(
                r,
                i,
                s
              );
              break e;
            }
            It(r, i, u, s);
          }
          i = i.child;
        }
        return i;
      case 26:
        return zc(r, i), r === null ? (s = jx(
          i.type,
          null,
          i.pendingProps,
          null
        )) ? i.memoizedState = s : Ue || (s = i.type, r = i.pendingProps, u = Yc(
          se.current
        ).createElement(s), u[kt] = i, u[Jt] = r, Vt(u, s, r), Nt(u), i.stateNode = u) : i.memoizedState = jx(
          i.type,
          r.memoizedProps,
          i.pendingProps,
          r.memoizedState
        ), null;
      case 27:
        return ue(i), r === null && Ue && (u = i.stateNode = Dx(
          i.type,
          i.pendingProps,
          se.current
        ), Pt = i, Dn = !0, p = rt, mo(i.type) ? (up = p, rt = On(u.firstChild)) : rt = p), It(
          r,
          i,
          i.pendingProps.children,
          s
        ), zc(r, i), r === null && (i.flags |= 4194304), i.child;
      case 5:
        return r === null && Ue && ((p = u = rt) && (u = AN(
          u,
          i.type,
          i.pendingProps,
          Dn
        ), u !== null ? (i.stateNode = u, Pt = i, rt = On(u.firstChild), Dn = !1, p = !0) : p = !1), p || eo(i)), ue(i), p = i.type, v = i.pendingProps, w = r !== null ? r.memoizedProps : null, u = v.children, ip(p, v) ? u = null : w !== null && ip(p, w) && (i.flags |= 32), i.memoizedState !== null && (p = oh(
          r,
          i,
          $D,
          null,
          null,
          s
        ), Vs._currentValue = p), zc(r, i), It(r, i, u, s), i.child;
      case 6:
        return r === null && Ue && ((r = s = rt) && (s = RN(
          s,
          i.pendingProps,
          Dn
        ), s !== null ? (i.stateNode = s, Pt = i, rt = null, r = !0) : r = !1), r || eo(i)), null;
      case 13:
        return xb(r, i, s);
      case 4:
        return ie(
          i,
          i.stateNode.containerInfo
        ), u = i.pendingProps, r === null ? i.child = ti(
          i,
          null,
          u,
          s
        ) : It(r, i, u, s), i.child;
      case 11:
        return fb(
          r,
          i,
          i.type,
          i.pendingProps,
          s
        );
      case 7:
        return It(
          r,
          i,
          i.pendingProps,
          s
        ), i.child;
      case 8:
        return It(
          r,
          i,
          i.pendingProps.children,
          s
        ), i.child;
      case 12:
        return It(
          r,
          i,
          i.pendingProps.children,
          s
        ), i.child;
      case 10:
        return u = i.pendingProps, to(i, i.type, u.value), It(r, i, u.children, s), i.child;
      case 9:
        return p = i.type._context, u = i.pendingProps.children, Ko(i), p = Lt(p), u = u(p), i.flags |= 1, It(r, i, u, s), i.child;
      case 14:
        return db(
          r,
          i,
          i.type,
          i.pendingProps,
          s
        );
      case 15:
        return hb(
          r,
          i,
          i.type,
          i.pendingProps,
          s
        );
      case 19:
        return wb(r, i, s);
      case 31:
        return WD(r, i, s);
      case 22:
        return pb(
          r,
          i,
          s,
          i.pendingProps
        );
      case 24:
        return Ko(i), u = Lt(St), r === null ? (p = qd(), p === null && (p = Qe, v = Gd(), p.pooledCache = v, v.refCount++, v !== null && (p.pooledCacheLanes |= s), p = v), i.memoizedState = { parent: u, cache: p }, Wd(i), to(i, St, p)) : ((r.lanes & s) !== 0 && (Kd(r, i), bs(i, null, null, s), ys()), p = r.memoizedState, v = i.memoizedState, p.parent !== u ? (p = { parent: u, cache: u }, i.memoizedState = p, i.lanes === 0 && (i.memoizedState = i.updateQueue.baseState = p), to(i, St, u)) : (u = v.cache, to(i, St, u), u !== p.cache && Fd(
          i,
          [St],
          s,
          !0
        ))), It(
          r,
          i,
          i.pendingProps.children,
          s
        ), i.child;
      case 29:
        throw i.pendingProps;
    }
    throw Error(o(156, i.tag));
  }
  function Or(r) {
    r.flags |= 4;
  }
  function Nh(r, i, s, u, p) {
    if ((i = (r.mode & 32) !== 0) && (i = !1), i) {
      if (r.flags |= 16777216, (p & 335544128) === p)
        if (r.stateNode.complete) r.flags |= 8192;
        else if (Wb()) r.flags |= 8192;
        else
          throw ei = mc, Xd;
    } else r.flags &= -16777217;
  }
  function _b(r, i) {
    if (i.type !== "stylesheet" || (i.state.loading & 4) !== 0)
      r.flags &= -16777217;
    else if (r.flags |= 16777216, !Vx(i))
      if (Wb()) r.flags |= 8192;
      else
        throw ei = mc, Xd;
  }
  function Nc(r, i) {
    i !== null && (r.flags |= 4), r.flags & 16384 && (i = r.tag !== 22 ? ry() : 536870912, r.lanes |= i, ta |= i);
  }
  function Ts(r, i) {
    if (!Ue)
      switch (r.tailMode) {
        case "hidden":
          i = r.tail;
          for (var s = null; i !== null; )
            i.alternate !== null && (s = i), i = i.sibling;
          s === null ? r.tail = null : s.sibling = null;
          break;
        case "collapsed":
          s = r.tail;
          for (var u = null; s !== null; )
            s.alternate !== null && (u = s), s = s.sibling;
          u === null ? i || r.tail === null ? r.tail = null : r.tail.sibling = null : u.sibling = null;
      }
  }
  function ot(r) {
    var i = r.alternate !== null && r.alternate.child === r.child, s = 0, u = 0;
    if (i)
      for (var p = r.child; p !== null; )
        s |= p.lanes | p.childLanes, u |= p.subtreeFlags & 65011712, u |= p.flags & 65011712, p.return = r, p = p.sibling;
    else
      for (p = r.child; p !== null; )
        s |= p.lanes | p.childLanes, u |= p.subtreeFlags, u |= p.flags, p.return = r, p = p.sibling;
    return r.subtreeFlags |= u, r.childLanes = s, i;
  }
  function JD(r, i, s) {
    var u = i.pendingProps;
    switch (Ud(i), i.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ot(i), null;
      case 1:
        return ot(i), null;
      case 3:
        return s = i.stateNode, u = null, r !== null && (u = r.memoizedState.cache), i.memoizedState.cache !== u && (i.flags |= 2048), Mr(St), ce(), s.pendingContext && (s.context = s.pendingContext, s.pendingContext = null), (r === null || r.child === null) && ($i(i) ? Or(i) : r === null || r.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024, $d())), ot(i), null;
      case 26:
        var p = i.type, v = i.memoizedState;
        return r === null ? (Or(i), v !== null ? (ot(i), _b(i, v)) : (ot(i), Nh(
          i,
          p,
          null,
          u,
          s
        ))) : v ? v !== r.memoizedState ? (Or(i), ot(i), _b(i, v)) : (ot(i), i.flags &= -16777217) : (r = r.memoizedProps, r !== u && Or(i), ot(i), Nh(
          i,
          p,
          r,
          u,
          s
        )), null;
      case 27:
        if (_e(i), s = se.current, p = i.type, r !== null && i.stateNode != null)
          r.memoizedProps !== u && Or(i);
        else {
          if (!u) {
            if (i.stateNode === null)
              throw Error(o(166));
            return ot(i), null;
          }
          r = K.current, $i(i) ? r0(i) : (r = Dx(p, u, s), i.stateNode = r, Or(i));
        }
        return ot(i), null;
      case 5:
        if (_e(i), p = i.type, r !== null && i.stateNode != null)
          r.memoizedProps !== u && Or(i);
        else {
          if (!u) {
            if (i.stateNode === null)
              throw Error(o(166));
            return ot(i), null;
          }
          if (v = K.current, $i(i))
            r0(i);
          else {
            var w = Yc(
              se.current
            );
            switch (v) {
              case 1:
                v = w.createElementNS(
                  "http://www.w3.org/2000/svg",
                  p
                );
                break;
              case 2:
                v = w.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  p
                );
                break;
              default:
                switch (p) {
                  case "svg":
                    v = w.createElementNS(
                      "http://www.w3.org/2000/svg",
                      p
                    );
                    break;
                  case "math":
                    v = w.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      p
                    );
                    break;
                  case "script":
                    v = w.createElement("div"), v.innerHTML = "<script><\/script>", v = v.removeChild(
                      v.firstChild
                    );
                    break;
                  case "select":
                    v = typeof u.is == "string" ? w.createElement("select", {
                      is: u.is
                    }) : w.createElement("select"), u.multiple ? v.multiple = !0 : u.size && (v.size = u.size);
                    break;
                  default:
                    v = typeof u.is == "string" ? w.createElement(p, { is: u.is }) : w.createElement(p);
                }
            }
            v[kt] = i, v[Jt] = u;
            e: for (w = i.child; w !== null; ) {
              if (w.tag === 5 || w.tag === 6)
                v.appendChild(w.stateNode);
              else if (w.tag !== 4 && w.tag !== 27 && w.child !== null) {
                w.child.return = w, w = w.child;
                continue;
              }
              if (w === i) break e;
              for (; w.sibling === null; ) {
                if (w.return === null || w.return === i)
                  break e;
                w = w.return;
              }
              w.sibling.return = w.return, w = w.sibling;
            }
            i.stateNode = v;
            e: switch (Vt(v, p, u), p) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                u = !!u.autoFocus;
                break e;
              case "img":
                u = !0;
                break e;
              default:
                u = !1;
            }
            u && Or(i);
          }
        }
        return ot(i), Nh(
          i,
          i.type,
          r === null ? null : r.memoizedProps,
          i.pendingProps,
          s
        ), null;
      case 6:
        if (r && i.stateNode != null)
          r.memoizedProps !== u && Or(i);
        else {
          if (typeof u != "string" && i.stateNode === null)
            throw Error(o(166));
          if (r = se.current, $i(i)) {
            if (r = i.stateNode, s = i.memoizedProps, u = null, p = Pt, p !== null)
              switch (p.tag) {
                case 27:
                case 5:
                  u = p.memoizedProps;
              }
            r[kt] = i, r = !!(r.nodeValue === s || u !== null && u.suppressHydrationWarning === !0 || xx(r.nodeValue, s)), r || eo(i, !0);
          } else
            r = Yc(r).createTextNode(
              u
            ), r[kt] = i, i.stateNode = r;
        }
        return ot(i), null;
      case 31:
        if (s = i.memoizedState, r === null || r.memoizedState !== null) {
          if (u = $i(i), s !== null) {
            if (r === null) {
              if (!u) throw Error(o(318));
              if (r = i.memoizedState, r = r !== null ? r.dehydrated : null, !r) throw Error(o(557));
              r[kt] = i;
            } else
              Xo(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4;
            ot(i), r = !1;
          } else
            s = $d(), r !== null && r.memoizedState !== null && (r.memoizedState.hydrationErrors = s), r = !0;
          if (!r)
            return i.flags & 256 ? (gn(i), i) : (gn(i), null);
          if ((i.flags & 128) !== 0)
            throw Error(o(558));
        }
        return ot(i), null;
      case 13:
        if (u = i.memoizedState, r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
          if (p = $i(i), u !== null && u.dehydrated !== null) {
            if (r === null) {
              if (!p) throw Error(o(318));
              if (p = i.memoizedState, p = p !== null ? p.dehydrated : null, !p) throw Error(o(317));
              p[kt] = i;
            } else
              Xo(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4;
            ot(i), p = !1;
          } else
            p = $d(), r !== null && r.memoizedState !== null && (r.memoizedState.hydrationErrors = p), p = !0;
          if (!p)
            return i.flags & 256 ? (gn(i), i) : (gn(i), null);
        }
        return gn(i), (i.flags & 128) !== 0 ? (i.lanes = s, i) : (s = u !== null, r = r !== null && r.memoizedState !== null, s && (u = i.child, p = null, u.alternate !== null && u.alternate.memoizedState !== null && u.alternate.memoizedState.cachePool !== null && (p = u.alternate.memoizedState.cachePool.pool), v = null, u.memoizedState !== null && u.memoizedState.cachePool !== null && (v = u.memoizedState.cachePool.pool), v !== p && (u.flags |= 2048)), s !== r && s && (i.child.flags |= 8192), Nc(i, i.updateQueue), ot(i), null);
      case 4:
        return ce(), r === null && ep(i.stateNode.containerInfo), ot(i), null;
      case 10:
        return Mr(i.type), ot(i), null;
      case 19:
        if (X(vt), u = i.memoizedState, u === null) return ot(i), null;
        if (p = (i.flags & 128) !== 0, v = u.rendering, v === null)
          if (p) Ts(u, !1);
          else {
            if (pt !== 0 || r !== null && (r.flags & 128) !== 0)
              for (r = i.child; r !== null; ) {
                if (v = bc(r), v !== null) {
                  for (i.flags |= 128, Ts(u, !1), r = v.updateQueue, i.updateQueue = r, Nc(i, r), i.subtreeFlags = 0, r = s, s = i.child; s !== null; )
                    Jy(s, r), s = s.sibling;
                  return H(
                    vt,
                    vt.current & 1 | 2
                  ), Ue && Ar(i, u.treeForkCount), i.child;
                }
                r = r.sibling;
              }
            u.tail !== null && un() > Lc && (i.flags |= 128, p = !0, Ts(u, !1), i.lanes = 4194304);
          }
        else {
          if (!p)
            if (r = bc(v), r !== null) {
              if (i.flags |= 128, p = !0, r = r.updateQueue, i.updateQueue = r, Nc(i, r), Ts(u, !0), u.tail === null && u.tailMode === "hidden" && !v.alternate && !Ue)
                return ot(i), null;
            } else
              2 * un() - u.renderingStartTime > Lc && s !== 536870912 && (i.flags |= 128, p = !0, Ts(u, !1), i.lanes = 4194304);
          u.isBackwards ? (v.sibling = i.child, i.child = v) : (r = u.last, r !== null ? r.sibling = v : i.child = v, u.last = v);
        }
        return u.tail !== null ? (r = u.tail, u.rendering = r, u.tail = r.sibling, u.renderingStartTime = un(), r.sibling = null, s = vt.current, H(
          vt,
          p ? s & 1 | 2 : s & 1
        ), Ue && Ar(i, u.treeForkCount), r) : (ot(i), null);
      case 22:
      case 23:
        return gn(i), th(), u = i.memoizedState !== null, r !== null ? r.memoizedState !== null !== u && (i.flags |= 8192) : u && (i.flags |= 8192), u ? (s & 536870912) !== 0 && (i.flags & 128) === 0 && (ot(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : ot(i), s = i.updateQueue, s !== null && Nc(i, s.retryQueue), s = null, r !== null && r.memoizedState !== null && r.memoizedState.cachePool !== null && (s = r.memoizedState.cachePool.pool), u = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (u = i.memoizedState.cachePool.pool), u !== s && (i.flags |= 2048), r !== null && X(Jo), null;
      case 24:
        return s = null, r !== null && (s = r.memoizedState.cache), i.memoizedState.cache !== s && (i.flags |= 2048), Mr(St), ot(i), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(o(156, i.tag));
  }
  function QD(r, i) {
    switch (Ud(i), i.tag) {
      case 1:
        return r = i.flags, r & 65536 ? (i.flags = r & -65537 | 128, i) : null;
      case 3:
        return Mr(St), ce(), r = i.flags, (r & 65536) !== 0 && (r & 128) === 0 ? (i.flags = r & -65537 | 128, i) : null;
      case 26:
      case 27:
      case 5:
        return _e(i), null;
      case 31:
        if (i.memoizedState !== null) {
          if (gn(i), i.alternate === null)
            throw Error(o(340));
          Xo();
        }
        return r = i.flags, r & 65536 ? (i.flags = r & -65537 | 128, i) : null;
      case 13:
        if (gn(i), r = i.memoizedState, r !== null && r.dehydrated !== null) {
          if (i.alternate === null)
            throw Error(o(340));
          Xo();
        }
        return r = i.flags, r & 65536 ? (i.flags = r & -65537 | 128, i) : null;
      case 19:
        return X(vt), null;
      case 4:
        return ce(), null;
      case 10:
        return Mr(i.type), null;
      case 22:
      case 23:
        return gn(i), th(), r !== null && X(Jo), r = i.flags, r & 65536 ? (i.flags = r & -65537 | 128, i) : null;
      case 24:
        return Mr(St), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function Tb(r, i) {
    switch (Ud(i), i.tag) {
      case 3:
        Mr(St), ce();
        break;
      case 26:
      case 27:
      case 5:
        _e(i);
        break;
      case 4:
        ce();
        break;
      case 31:
        i.memoizedState !== null && gn(i);
        break;
      case 13:
        gn(i);
        break;
      case 19:
        X(vt);
        break;
      case 10:
        Mr(i.type);
        break;
      case 22:
      case 23:
        gn(i), th(), r !== null && X(Jo);
        break;
      case 24:
        Mr(St);
    }
  }
  function Cs(r, i) {
    try {
      var s = i.updateQueue, u = s !== null ? s.lastEffect : null;
      if (u !== null) {
        var p = u.next;
        s = p;
        do {
          if ((s.tag & r) === r) {
            u = void 0;
            var v = s.create, w = s.inst;
            u = v(), w.destroy = u;
          }
          s = s.next;
        } while (s !== p);
      }
    } catch (D) {
      Ye(i, i.return, D);
    }
  }
  function so(r, i, s) {
    try {
      var u = i.updateQueue, p = u !== null ? u.lastEffect : null;
      if (p !== null) {
        var v = p.next;
        u = v;
        do {
          if ((u.tag & r) === r) {
            var w = u.inst, D = w.destroy;
            if (D !== void 0) {
              w.destroy = void 0, p = i;
              var P = s, F = D;
              try {
                F();
              } catch (Q) {
                Ye(
                  p,
                  P,
                  Q
                );
              }
            }
          }
          u = u.next;
        } while (u !== v);
      }
    } catch (Q) {
      Ye(i, i.return, Q);
    }
  }
  function Cb(r) {
    var i = r.updateQueue;
    if (i !== null) {
      var s = r.stateNode;
      try {
        g0(i, s);
      } catch (u) {
        Ye(r, r.return, u);
      }
    }
  }
  function Ab(r, i, s) {
    s.props = ri(
      r.type,
      r.memoizedProps
    ), s.state = r.memoizedState;
    try {
      s.componentWillUnmount();
    } catch (u) {
      Ye(r, i, u);
    }
  }
  function As(r, i) {
    try {
      var s = r.ref;
      if (s !== null) {
        switch (r.tag) {
          case 26:
          case 27:
          case 5:
            var u = r.stateNode;
            break;
          case 30:
            u = r.stateNode;
            break;
          default:
            u = r.stateNode;
        }
        typeof s == "function" ? r.refCleanup = s(u) : s.current = u;
      }
    } catch (p) {
      Ye(r, i, p);
    }
  }
  function or(r, i) {
    var s = r.ref, u = r.refCleanup;
    if (s !== null)
      if (typeof u == "function")
        try {
          u();
        } catch (p) {
          Ye(r, i, p);
        } finally {
          r.refCleanup = null, r = r.alternate, r != null && (r.refCleanup = null);
        }
      else if (typeof s == "function")
        try {
          s(null);
        } catch (p) {
          Ye(r, i, p);
        }
      else s.current = null;
  }
  function Rb(r) {
    var i = r.type, s = r.memoizedProps, u = r.stateNode;
    try {
      e: switch (i) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          s.autoFocus && u.focus();
          break e;
        case "img":
          s.src ? u.src = s.src : s.srcSet && (u.srcset = s.srcSet);
      }
    } catch (p) {
      Ye(r, r.return, p);
    }
  }
  function Oh(r, i, s) {
    try {
      var u = r.stateNode;
      SN(u, r.type, s, i), u[Jt] = i;
    } catch (p) {
      Ye(r, r.return, p);
    }
  }
  function Mb(r) {
    return r.tag === 5 || r.tag === 3 || r.tag === 26 || r.tag === 27 && mo(r.type) || r.tag === 4;
  }
  function jh(r) {
    e: for (; ; ) {
      for (; r.sibling === null; ) {
        if (r.return === null || Mb(r.return)) return null;
        r = r.return;
      }
      for (r.sibling.return = r.return, r = r.sibling; r.tag !== 5 && r.tag !== 6 && r.tag !== 18; ) {
        if (r.tag === 27 && mo(r.type) || r.flags & 2 || r.child === null || r.tag === 4) continue e;
        r.child.return = r, r = r.child;
      }
      if (!(r.flags & 2)) return r.stateNode;
    }
  }
  function kh(r, i, s) {
    var u = r.tag;
    if (u === 5 || u === 6)
      r = r.stateNode, i ? (s.nodeType === 9 ? s.body : s.nodeName === "HTML" ? s.ownerDocument.body : s).insertBefore(r, i) : (i = s.nodeType === 9 ? s.body : s.nodeName === "HTML" ? s.ownerDocument.body : s, i.appendChild(r), s = s._reactRootContainer, s != null || i.onclick !== null || (i.onclick = _r));
    else if (u !== 4 && (u === 27 && mo(r.type) && (s = r.stateNode, i = null), r = r.child, r !== null))
      for (kh(r, i, s), r = r.sibling; r !== null; )
        kh(r, i, s), r = r.sibling;
  }
  function Oc(r, i, s) {
    var u = r.tag;
    if (u === 5 || u === 6)
      r = r.stateNode, i ? s.insertBefore(r, i) : s.appendChild(r);
    else if (u !== 4 && (u === 27 && mo(r.type) && (s = r.stateNode), r = r.child, r !== null))
      for (Oc(r, i, s), r = r.sibling; r !== null; )
        Oc(r, i, s), r = r.sibling;
  }
  function zb(r) {
    var i = r.stateNode, s = r.memoizedProps;
    try {
      for (var u = r.type, p = i.attributes; p.length; )
        i.removeAttributeNode(p[0]);
      Vt(i, u, s), i[kt] = r, i[Jt] = s;
    } catch (v) {
      Ye(r, r.return, v);
    }
  }
  var jr = !1, _t = !1, Ph = !1, Db = typeof WeakSet == "function" ? WeakSet : Set, Ot = null;
  function eN(r, i) {
    if (r = r.containerInfo, rp = eu, r = Hy(r), Md(r)) {
      if ("selectionStart" in r)
        var s = {
          start: r.selectionStart,
          end: r.selectionEnd
        };
      else
        e: {
          s = (s = r.ownerDocument) && s.defaultView || window;
          var u = s.getSelection && s.getSelection();
          if (u && u.rangeCount !== 0) {
            s = u.anchorNode;
            var p = u.anchorOffset, v = u.focusNode;
            u = u.focusOffset;
            try {
              s.nodeType, v.nodeType;
            } catch {
              s = null;
              break e;
            }
            var w = 0, D = -1, P = -1, F = 0, Q = 0, oe = r, q = null;
            t: for (; ; ) {
              for (var W; oe !== s || p !== 0 && oe.nodeType !== 3 || (D = w + p), oe !== v || u !== 0 && oe.nodeType !== 3 || (P = w + u), oe.nodeType === 3 && (w += oe.nodeValue.length), (W = oe.firstChild) !== null; )
                q = oe, oe = W;
              for (; ; ) {
                if (oe === r) break t;
                if (q === s && ++F === p && (D = w), q === v && ++Q === u && (P = w), (W = oe.nextSibling) !== null) break;
                oe = q, q = oe.parentNode;
              }
              oe = W;
            }
            s = D === -1 || P === -1 ? null : { start: D, end: P };
          } else s = null;
        }
      s = s || { start: 0, end: 0 };
    } else s = null;
    for (op = { focusedElem: r, selectionRange: s }, eu = !1, Ot = i; Ot !== null; )
      if (i = Ot, r = i.child, (i.subtreeFlags & 1028) !== 0 && r !== null)
        r.return = i, Ot = r;
      else
        for (; Ot !== null; ) {
          switch (i = Ot, v = i.alternate, r = i.flags, i.tag) {
            case 0:
              if ((r & 4) !== 0 && (r = i.updateQueue, r = r !== null ? r.events : null, r !== null))
                for (s = 0; s < r.length; s++)
                  p = r[s], p.ref.impl = p.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((r & 1024) !== 0 && v !== null) {
                r = void 0, s = i, p = v.memoizedProps, v = v.memoizedState, u = s.stateNode;
                try {
                  var me = ri(
                    s.type,
                    p
                  );
                  r = u.getSnapshotBeforeUpdate(
                    me,
                    v
                  ), u.__reactInternalSnapshotBeforeUpdate = r;
                } catch (Ee) {
                  Ye(
                    s,
                    s.return,
                    Ee
                  );
                }
              }
              break;
            case 3:
              if ((r & 1024) !== 0) {
                if (r = i.stateNode.containerInfo, s = r.nodeType, s === 9)
                  sp(r);
                else if (s === 1)
                  switch (r.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      sp(r);
                      break;
                    default:
                      r.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((r & 1024) !== 0) throw Error(o(163));
          }
          if (r = i.sibling, r !== null) {
            r.return = i.return, Ot = r;
            break;
          }
          Ot = i.return;
        }
  }
  function Nb(r, i, s) {
    var u = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 15:
        Pr(r, s), u & 4 && Cs(5, s);
        break;
      case 1:
        if (Pr(r, s), u & 4)
          if (r = s.stateNode, i === null)
            try {
              r.componentDidMount();
            } catch (w) {
              Ye(s, s.return, w);
            }
          else {
            var p = ri(
              s.type,
              i.memoizedProps
            );
            i = i.memoizedState;
            try {
              r.componentDidUpdate(
                p,
                i,
                r.__reactInternalSnapshotBeforeUpdate
              );
            } catch (w) {
              Ye(
                s,
                s.return,
                w
              );
            }
          }
        u & 64 && Cb(s), u & 512 && As(s, s.return);
        break;
      case 3:
        if (Pr(r, s), u & 64 && (r = s.updateQueue, r !== null)) {
          if (i = null, s.child !== null)
            switch (s.child.tag) {
              case 27:
              case 5:
                i = s.child.stateNode;
                break;
              case 1:
                i = s.child.stateNode;
            }
          try {
            g0(r, i);
          } catch (w) {
            Ye(s, s.return, w);
          }
        }
        break;
      case 27:
        i === null && u & 4 && zb(s);
      case 26:
      case 5:
        Pr(r, s), i === null && u & 4 && Rb(s), u & 512 && As(s, s.return);
        break;
      case 12:
        Pr(r, s);
        break;
      case 31:
        Pr(r, s), u & 4 && kb(r, s);
        break;
      case 13:
        Pr(r, s), u & 4 && Pb(r, s), u & 64 && (r = s.memoizedState, r !== null && (r = r.dehydrated, r !== null && (s = cN.bind(
          null,
          s
        ), MN(r, s))));
        break;
      case 22:
        if (u = s.memoizedState !== null || jr, !u) {
          i = i !== null && i.memoizedState !== null || _t, p = jr;
          var v = _t;
          jr = u, (_t = i) && !v ? Lr(
            r,
            s,
            (s.subtreeFlags & 8772) !== 0
          ) : Pr(r, s), jr = p, _t = v;
        }
        break;
      case 30:
        break;
      default:
        Pr(r, s);
    }
  }
  function Ob(r) {
    var i = r.alternate;
    i !== null && (r.alternate = null, Ob(i)), r.child = null, r.deletions = null, r.sibling = null, r.tag === 5 && (i = r.stateNode, i !== null && dd(i)), r.stateNode = null, r.return = null, r.dependencies = null, r.memoizedProps = null, r.memoizedState = null, r.pendingProps = null, r.stateNode = null, r.updateQueue = null;
  }
  var lt = null, en = !1;
  function kr(r, i, s) {
    for (s = s.child; s !== null; )
      jb(r, i, s), s = s.sibling;
  }
  function jb(r, i, s) {
    if (fn && typeof fn.onCommitFiberUnmount == "function")
      try {
        fn.onCommitFiberUnmount(Ka, s);
      } catch {
      }
    switch (s.tag) {
      case 26:
        _t || or(s, i), kr(
          r,
          i,
          s
        ), s.memoizedState ? s.memoizedState.count-- : s.stateNode && (s = s.stateNode, s.parentNode.removeChild(s));
        break;
      case 27:
        _t || or(s, i);
        var u = lt, p = en;
        mo(s.type) && (lt = s.stateNode, en = !1), kr(
          r,
          i,
          s
        ), Ps(s.stateNode), lt = u, en = p;
        break;
      case 5:
        _t || or(s, i);
      case 6:
        if (u = lt, p = en, lt = null, kr(
          r,
          i,
          s
        ), lt = u, en = p, lt !== null)
          if (en)
            try {
              (lt.nodeType === 9 ? lt.body : lt.nodeName === "HTML" ? lt.ownerDocument.body : lt).removeChild(s.stateNode);
            } catch (v) {
              Ye(
                s,
                i,
                v
              );
            }
          else
            try {
              lt.removeChild(s.stateNode);
            } catch (v) {
              Ye(
                s,
                i,
                v
              );
            }
        break;
      case 18:
        lt !== null && (en ? (r = lt, Cx(
          r.nodeType === 9 ? r.body : r.nodeName === "HTML" ? r.ownerDocument.body : r,
          s.stateNode
        ), ca(r)) : Cx(lt, s.stateNode));
        break;
      case 4:
        u = lt, p = en, lt = s.stateNode.containerInfo, en = !0, kr(
          r,
          i,
          s
        ), lt = u, en = p;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        so(2, s, i), _t || so(4, s, i), kr(
          r,
          i,
          s
        );
        break;
      case 1:
        _t || (or(s, i), u = s.stateNode, typeof u.componentWillUnmount == "function" && Ab(
          s,
          i,
          u
        )), kr(
          r,
          i,
          s
        );
        break;
      case 21:
        kr(
          r,
          i,
          s
        );
        break;
      case 22:
        _t = (u = _t) || s.memoizedState !== null, kr(
          r,
          i,
          s
        ), _t = u;
        break;
      default:
        kr(
          r,
          i,
          s
        );
    }
  }
  function kb(r, i) {
    if (i.memoizedState === null && (r = i.alternate, r !== null && (r = r.memoizedState, r !== null))) {
      r = r.dehydrated;
      try {
        ca(r);
      } catch (s) {
        Ye(i, i.return, s);
      }
    }
  }
  function Pb(r, i) {
    if (i.memoizedState === null && (r = i.alternate, r !== null && (r = r.memoizedState, r !== null && (r = r.dehydrated, r !== null))))
      try {
        ca(r);
      } catch (s) {
        Ye(i, i.return, s);
      }
  }
  function tN(r) {
    switch (r.tag) {
      case 31:
      case 13:
      case 19:
        var i = r.stateNode;
        return i === null && (i = r.stateNode = new Db()), i;
      case 22:
        return r = r.stateNode, i = r._retryCache, i === null && (i = r._retryCache = new Db()), i;
      default:
        throw Error(o(435, r.tag));
    }
  }
  function jc(r, i) {
    var s = tN(r);
    i.forEach(function(u) {
      if (!s.has(u)) {
        s.add(u);
        var p = uN.bind(null, r, u);
        u.then(p, p);
      }
    });
  }
  function tn(r, i) {
    var s = i.deletions;
    if (s !== null)
      for (var u = 0; u < s.length; u++) {
        var p = s[u], v = r, w = i, D = w;
        e: for (; D !== null; ) {
          switch (D.tag) {
            case 27:
              if (mo(D.type)) {
                lt = D.stateNode, en = !1;
                break e;
              }
              break;
            case 5:
              lt = D.stateNode, en = !1;
              break e;
            case 3:
            case 4:
              lt = D.stateNode.containerInfo, en = !0;
              break e;
          }
          D = D.return;
        }
        if (lt === null) throw Error(o(160));
        jb(v, w, p), lt = null, en = !1, v = p.alternate, v !== null && (v.return = null), p.return = null;
      }
    if (i.subtreeFlags & 13886)
      for (i = i.child; i !== null; )
        Lb(i, r), i = i.sibling;
  }
  var Zn = null;
  function Lb(r, i) {
    var s = r.alternate, u = r.flags;
    switch (r.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        tn(i, r), nn(r), u & 4 && (so(3, r, r.return), Cs(3, r), so(5, r, r.return));
        break;
      case 1:
        tn(i, r), nn(r), u & 512 && (_t || s === null || or(s, s.return)), u & 64 && jr && (r = r.updateQueue, r !== null && (u = r.callbacks, u !== null && (s = r.shared.hiddenCallbacks, r.shared.hiddenCallbacks = s === null ? u : s.concat(u))));
        break;
      case 26:
        var p = Zn;
        if (tn(i, r), nn(r), u & 512 && (_t || s === null || or(s, s.return)), u & 4) {
          var v = s !== null ? s.memoizedState : null;
          if (u = r.memoizedState, s === null)
            if (u === null)
              if (r.stateNode === null) {
                e: {
                  u = r.type, s = r.memoizedProps, p = p.ownerDocument || p;
                  t: switch (u) {
                    case "title":
                      v = p.getElementsByTagName("title")[0], (!v || v[es] || v[kt] || v.namespaceURI === "http://www.w3.org/2000/svg" || v.hasAttribute("itemprop")) && (v = p.createElement(u), p.head.insertBefore(
                        v,
                        p.querySelector("head > title")
                      )), Vt(v, u, s), v[kt] = r, Nt(v), u = v;
                      break e;
                    case "link":
                      var w = Lx(
                        "link",
                        "href",
                        p
                      ).get(u + (s.href || ""));
                      if (w) {
                        for (var D = 0; D < w.length; D++)
                          if (v = w[D], v.getAttribute("href") === (s.href == null || s.href === "" ? null : s.href) && v.getAttribute("rel") === (s.rel == null ? null : s.rel) && v.getAttribute("title") === (s.title == null ? null : s.title) && v.getAttribute("crossorigin") === (s.crossOrigin == null ? null : s.crossOrigin)) {
                            w.splice(D, 1);
                            break t;
                          }
                      }
                      v = p.createElement(u), Vt(v, u, s), p.head.appendChild(v);
                      break;
                    case "meta":
                      if (w = Lx(
                        "meta",
                        "content",
                        p
                      ).get(u + (s.content || ""))) {
                        for (D = 0; D < w.length; D++)
                          if (v = w[D], v.getAttribute("content") === (s.content == null ? null : "" + s.content) && v.getAttribute("name") === (s.name == null ? null : s.name) && v.getAttribute("property") === (s.property == null ? null : s.property) && v.getAttribute("http-equiv") === (s.httpEquiv == null ? null : s.httpEquiv) && v.getAttribute("charset") === (s.charSet == null ? null : s.charSet)) {
                            w.splice(D, 1);
                            break t;
                          }
                      }
                      v = p.createElement(u), Vt(v, u, s), p.head.appendChild(v);
                      break;
                    default:
                      throw Error(o(468, u));
                  }
                  v[kt] = r, Nt(v), u = v;
                }
                r.stateNode = u;
              } else
                Ix(
                  p,
                  r.type,
                  r.stateNode
                );
            else
              r.stateNode = Px(
                p,
                u,
                r.memoizedProps
              );
          else
            v !== u ? (v === null ? s.stateNode !== null && (s = s.stateNode, s.parentNode.removeChild(s)) : v.count--, u === null ? Ix(
              p,
              r.type,
              r.stateNode
            ) : Px(
              p,
              u,
              r.memoizedProps
            )) : u === null && r.stateNode !== null && Oh(
              r,
              r.memoizedProps,
              s.memoizedProps
            );
        }
        break;
      case 27:
        tn(i, r), nn(r), u & 512 && (_t || s === null || or(s, s.return)), s !== null && u & 4 && Oh(
          r,
          r.memoizedProps,
          s.memoizedProps
        );
        break;
      case 5:
        if (tn(i, r), nn(r), u & 512 && (_t || s === null || or(s, s.return)), r.flags & 32) {
          p = r.stateNode;
          try {
            Ni(p, "");
          } catch (me) {
            Ye(r, r.return, me);
          }
        }
        u & 4 && r.stateNode != null && (p = r.memoizedProps, Oh(
          r,
          p,
          s !== null ? s.memoizedProps : p
        )), u & 1024 && (Ph = !0);
        break;
      case 6:
        if (tn(i, r), nn(r), u & 4) {
          if (r.stateNode === null)
            throw Error(o(162));
          u = r.memoizedProps, s = r.stateNode;
          try {
            s.nodeValue = u;
          } catch (me) {
            Ye(r, r.return, me);
          }
        }
        break;
      case 3:
        if (Wc = null, p = Zn, Zn = qc(i.containerInfo), tn(i, r), Zn = p, nn(r), u & 4 && s !== null && s.memoizedState.isDehydrated)
          try {
            ca(i.containerInfo);
          } catch (me) {
            Ye(r, r.return, me);
          }
        Ph && (Ph = !1, Ib(r));
        break;
      case 4:
        u = Zn, Zn = qc(
          r.stateNode.containerInfo
        ), tn(i, r), nn(r), Zn = u;
        break;
      case 12:
        tn(i, r), nn(r);
        break;
      case 31:
        tn(i, r), nn(r), u & 4 && (u = r.updateQueue, u !== null && (r.updateQueue = null, jc(r, u)));
        break;
      case 13:
        tn(i, r), nn(r), r.child.flags & 8192 && r.memoizedState !== null != (s !== null && s.memoizedState !== null) && (Pc = un()), u & 4 && (u = r.updateQueue, u !== null && (r.updateQueue = null, jc(r, u)));
        break;
      case 22:
        p = r.memoizedState !== null;
        var P = s !== null && s.memoizedState !== null, F = jr, Q = _t;
        if (jr = F || p, _t = Q || P, tn(i, r), _t = Q, jr = F, nn(r), u & 8192)
          e: for (i = r.stateNode, i._visibility = p ? i._visibility & -2 : i._visibility | 1, p && (s === null || P || jr || _t || oi(r)), s = null, i = r; ; ) {
            if (i.tag === 5 || i.tag === 26) {
              if (s === null) {
                P = s = i;
                try {
                  if (v = P.stateNode, p)
                    w = v.style, typeof w.setProperty == "function" ? w.setProperty("display", "none", "important") : w.display = "none";
                  else {
                    D = P.stateNode;
                    var oe = P.memoizedProps.style, q = oe != null && oe.hasOwnProperty("display") ? oe.display : null;
                    D.style.display = q == null || typeof q == "boolean" ? "" : ("" + q).trim();
                  }
                } catch (me) {
                  Ye(P, P.return, me);
                }
              }
            } else if (i.tag === 6) {
              if (s === null) {
                P = i;
                try {
                  P.stateNode.nodeValue = p ? "" : P.memoizedProps;
                } catch (me) {
                  Ye(P, P.return, me);
                }
              }
            } else if (i.tag === 18) {
              if (s === null) {
                P = i;
                try {
                  var W = P.stateNode;
                  p ? Ax(W, !0) : Ax(P.stateNode, !1);
                } catch (me) {
                  Ye(P, P.return, me);
                }
              }
            } else if ((i.tag !== 22 && i.tag !== 23 || i.memoizedState === null || i === r) && i.child !== null) {
              i.child.return = i, i = i.child;
              continue;
            }
            if (i === r) break e;
            for (; i.sibling === null; ) {
              if (i.return === null || i.return === r) break e;
              s === i && (s = null), i = i.return;
            }
            s === i && (s = null), i.sibling.return = i.return, i = i.sibling;
          }
        u & 4 && (u = r.updateQueue, u !== null && (s = u.retryQueue, s !== null && (u.retryQueue = null, jc(r, s))));
        break;
      case 19:
        tn(i, r), nn(r), u & 4 && (u = r.updateQueue, u !== null && (r.updateQueue = null, jc(r, u)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        tn(i, r), nn(r);
    }
  }
  function nn(r) {
    var i = r.flags;
    if (i & 2) {
      try {
        for (var s, u = r.return; u !== null; ) {
          if (Mb(u)) {
            s = u;
            break;
          }
          u = u.return;
        }
        if (s == null) throw Error(o(160));
        switch (s.tag) {
          case 27:
            var p = s.stateNode, v = jh(r);
            Oc(r, v, p);
            break;
          case 5:
            var w = s.stateNode;
            s.flags & 32 && (Ni(w, ""), s.flags &= -33);
            var D = jh(r);
            Oc(r, D, w);
            break;
          case 3:
          case 4:
            var P = s.stateNode.containerInfo, F = jh(r);
            kh(
              r,
              F,
              P
            );
            break;
          default:
            throw Error(o(161));
        }
      } catch (Q) {
        Ye(r, r.return, Q);
      }
      r.flags &= -3;
    }
    i & 4096 && (r.flags &= -4097);
  }
  function Ib(r) {
    if (r.subtreeFlags & 1024)
      for (r = r.child; r !== null; ) {
        var i = r;
        Ib(i), i.tag === 5 && i.flags & 1024 && i.stateNode.reset(), r = r.sibling;
      }
  }
  function Pr(r, i) {
    if (i.subtreeFlags & 8772)
      for (i = i.child; i !== null; )
        Nb(r, i.alternate, i), i = i.sibling;
  }
  function oi(r) {
    for (r = r.child; r !== null; ) {
      var i = r;
      switch (i.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          so(4, i, i.return), oi(i);
          break;
        case 1:
          or(i, i.return);
          var s = i.stateNode;
          typeof s.componentWillUnmount == "function" && Ab(
            i,
            i.return,
            s
          ), oi(i);
          break;
        case 27:
          Ps(i.stateNode);
        case 26:
        case 5:
          or(i, i.return), oi(i);
          break;
        case 22:
          i.memoizedState === null && oi(i);
          break;
        case 30:
          oi(i);
          break;
        default:
          oi(i);
      }
      r = r.sibling;
    }
  }
  function Lr(r, i, s) {
    for (s = s && (i.subtreeFlags & 8772) !== 0, i = i.child; i !== null; ) {
      var u = i.alternate, p = r, v = i, w = v.flags;
      switch (v.tag) {
        case 0:
        case 11:
        case 15:
          Lr(
            p,
            v,
            s
          ), Cs(4, v);
          break;
        case 1:
          if (Lr(
            p,
            v,
            s
          ), u = v, p = u.stateNode, typeof p.componentDidMount == "function")
            try {
              p.componentDidMount();
            } catch (F) {
              Ye(u, u.return, F);
            }
          if (u = v, p = u.updateQueue, p !== null) {
            var D = u.stateNode;
            try {
              var P = p.shared.hiddenCallbacks;
              if (P !== null)
                for (p.shared.hiddenCallbacks = null, p = 0; p < P.length; p++)
                  m0(P[p], D);
            } catch (F) {
              Ye(u, u.return, F);
            }
          }
          s && w & 64 && Cb(v), As(v, v.return);
          break;
        case 27:
          zb(v);
        case 26:
        case 5:
          Lr(
            p,
            v,
            s
          ), s && u === null && w & 4 && Rb(v), As(v, v.return);
          break;
        case 12:
          Lr(
            p,
            v,
            s
          );
          break;
        case 31:
          Lr(
            p,
            v,
            s
          ), s && w & 4 && kb(p, v);
          break;
        case 13:
          Lr(
            p,
            v,
            s
          ), s && w & 4 && Pb(p, v);
          break;
        case 22:
          v.memoizedState === null && Lr(
            p,
            v,
            s
          ), As(v, v.return);
          break;
        case 30:
          break;
        default:
          Lr(
            p,
            v,
            s
          );
      }
      i = i.sibling;
    }
  }
  function Lh(r, i) {
    var s = null;
    r !== null && r.memoizedState !== null && r.memoizedState.cachePool !== null && (s = r.memoizedState.cachePool.pool), r = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (r = i.memoizedState.cachePool.pool), r !== s && (r != null && r.refCount++, s != null && hs(s));
  }
  function Ih(r, i) {
    r = null, i.alternate !== null && (r = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== r && (i.refCount++, r != null && hs(r));
  }
  function Fn(r, i, s, u) {
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; )
        Vb(
          r,
          i,
          s,
          u
        ), i = i.sibling;
  }
  function Vb(r, i, s, u) {
    var p = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 15:
        Fn(
          r,
          i,
          s,
          u
        ), p & 2048 && Cs(9, i);
        break;
      case 1:
        Fn(
          r,
          i,
          s,
          u
        );
        break;
      case 3:
        Fn(
          r,
          i,
          s,
          u
        ), p & 2048 && (r = null, i.alternate !== null && (r = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== r && (i.refCount++, r != null && hs(r)));
        break;
      case 12:
        if (p & 2048) {
          Fn(
            r,
            i,
            s,
            u
          ), r = i.stateNode;
          try {
            var v = i.memoizedProps, w = v.id, D = v.onPostCommit;
            typeof D == "function" && D(
              w,
              i.alternate === null ? "mount" : "update",
              r.passiveEffectDuration,
              -0
            );
          } catch (P) {
            Ye(i, i.return, P);
          }
        } else
          Fn(
            r,
            i,
            s,
            u
          );
        break;
      case 31:
        Fn(
          r,
          i,
          s,
          u
        );
        break;
      case 13:
        Fn(
          r,
          i,
          s,
          u
        );
        break;
      case 23:
        break;
      case 22:
        v = i.stateNode, w = i.alternate, i.memoizedState !== null ? v._visibility & 2 ? Fn(
          r,
          i,
          s,
          u
        ) : Rs(r, i) : v._visibility & 2 ? Fn(
          r,
          i,
          s,
          u
        ) : (v._visibility |= 2, Ji(
          r,
          i,
          s,
          u,
          (i.subtreeFlags & 10256) !== 0 || !1
        )), p & 2048 && Lh(w, i);
        break;
      case 24:
        Fn(
          r,
          i,
          s,
          u
        ), p & 2048 && Ih(i.alternate, i);
        break;
      default:
        Fn(
          r,
          i,
          s,
          u
        );
    }
  }
  function Ji(r, i, s, u, p) {
    for (p = p && ((i.subtreeFlags & 10256) !== 0 || !1), i = i.child; i !== null; ) {
      var v = r, w = i, D = s, P = u, F = w.flags;
      switch (w.tag) {
        case 0:
        case 11:
        case 15:
          Ji(
            v,
            w,
            D,
            P,
            p
          ), Cs(8, w);
          break;
        case 23:
          break;
        case 22:
          var Q = w.stateNode;
          w.memoizedState !== null ? Q._visibility & 2 ? Ji(
            v,
            w,
            D,
            P,
            p
          ) : Rs(
            v,
            w
          ) : (Q._visibility |= 2, Ji(
            v,
            w,
            D,
            P,
            p
          )), p && F & 2048 && Lh(
            w.alternate,
            w
          );
          break;
        case 24:
          Ji(
            v,
            w,
            D,
            P,
            p
          ), p && F & 2048 && Ih(w.alternate, w);
          break;
        default:
          Ji(
            v,
            w,
            D,
            P,
            p
          );
      }
      i = i.sibling;
    }
  }
  function Rs(r, i) {
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; ) {
        var s = r, u = i, p = u.flags;
        switch (u.tag) {
          case 22:
            Rs(s, u), p & 2048 && Lh(
              u.alternate,
              u
            );
            break;
          case 24:
            Rs(s, u), p & 2048 && Ih(u.alternate, u);
            break;
          default:
            Rs(s, u);
        }
        i = i.sibling;
      }
  }
  var Ms = 8192;
  function Qi(r, i, s) {
    if (r.subtreeFlags & Ms)
      for (r = r.child; r !== null; )
        Ub(
          r,
          i,
          s
        ), r = r.sibling;
  }
  function Ub(r, i, s) {
    switch (r.tag) {
      case 26:
        Qi(
          r,
          i,
          s
        ), r.flags & Ms && r.memoizedState !== null && BN(
          s,
          Zn,
          r.memoizedState,
          r.memoizedProps
        );
        break;
      case 5:
        Qi(
          r,
          i,
          s
        );
        break;
      case 3:
      case 4:
        var u = Zn;
        Zn = qc(r.stateNode.containerInfo), Qi(
          r,
          i,
          s
        ), Zn = u;
        break;
      case 22:
        r.memoizedState === null && (u = r.alternate, u !== null && u.memoizedState !== null ? (u = Ms, Ms = 16777216, Qi(
          r,
          i,
          s
        ), Ms = u) : Qi(
          r,
          i,
          s
        ));
        break;
      default:
        Qi(
          r,
          i,
          s
        );
    }
  }
  function Bb(r) {
    var i = r.alternate;
    if (i !== null && (r = i.child, r !== null)) {
      i.child = null;
      do
        i = r.sibling, r.sibling = null, r = i;
      while (r !== null);
    }
  }
  function zs(r) {
    var i = r.deletions;
    if ((r.flags & 16) !== 0) {
      if (i !== null)
        for (var s = 0; s < i.length; s++) {
          var u = i[s];
          Ot = u, Hb(
            u,
            r
          );
        }
      Bb(r);
    }
    if (r.subtreeFlags & 10256)
      for (r = r.child; r !== null; )
        $b(r), r = r.sibling;
  }
  function $b(r) {
    switch (r.tag) {
      case 0:
      case 11:
      case 15:
        zs(r), r.flags & 2048 && so(9, r, r.return);
        break;
      case 3:
        zs(r);
        break;
      case 12:
        zs(r);
        break;
      case 22:
        var i = r.stateNode;
        r.memoizedState !== null && i._visibility & 2 && (r.return === null || r.return.tag !== 13) ? (i._visibility &= -3, kc(r)) : zs(r);
        break;
      default:
        zs(r);
    }
  }
  function kc(r) {
    var i = r.deletions;
    if ((r.flags & 16) !== 0) {
      if (i !== null)
        for (var s = 0; s < i.length; s++) {
          var u = i[s];
          Ot = u, Hb(
            u,
            r
          );
        }
      Bb(r);
    }
    for (r = r.child; r !== null; ) {
      switch (i = r, i.tag) {
        case 0:
        case 11:
        case 15:
          so(8, i, i.return), kc(i);
          break;
        case 22:
          s = i.stateNode, s._visibility & 2 && (s._visibility &= -3, kc(i));
          break;
        default:
          kc(i);
      }
      r = r.sibling;
    }
  }
  function Hb(r, i) {
    for (; Ot !== null; ) {
      var s = Ot;
      switch (s.tag) {
        case 0:
        case 11:
        case 15:
          so(8, s, i);
          break;
        case 23:
        case 22:
          if (s.memoizedState !== null && s.memoizedState.cachePool !== null) {
            var u = s.memoizedState.cachePool.pool;
            u != null && u.refCount++;
          }
          break;
        case 24:
          hs(s.memoizedState.cache);
      }
      if (u = s.child, u !== null) u.return = s, Ot = u;
      else
        e: for (s = r; Ot !== null; ) {
          u = Ot;
          var p = u.sibling, v = u.return;
          if (Ob(u), u === s) {
            Ot = null;
            break e;
          }
          if (p !== null) {
            p.return = v, Ot = p;
            break e;
          }
          Ot = v;
        }
    }
  }
  var nN = {
    getCacheForType: function(r) {
      var i = Lt(St), s = i.data.get(r);
      return s === void 0 && (s = r(), i.data.set(r, s)), s;
    },
    cacheSignal: function() {
      return Lt(St).controller.signal;
    }
  }, rN = typeof WeakMap == "function" ? WeakMap : Map, Ze = 0, Qe = null, ke = null, Ie = 0, Ge = 0, vn = null, lo = !1, ea = !1, Vh = !1, Ir = 0, pt = 0, co = 0, ii = 0, Uh = 0, yn = 0, ta = 0, Ds = null, rn = null, Bh = !1, Pc = 0, Zb = 0, Lc = 1 / 0, Ic = null, uo = null, At = 0, fo = null, na = null, Vr = 0, $h = 0, Hh = null, Fb = null, Ns = 0, Zh = null;
  function bn() {
    return (Ze & 2) !== 0 && Ie !== 0 ? Ie & -Ie : I.T !== null ? Wh() : sy();
  }
  function Gb() {
    if (yn === 0)
      if ((Ie & 536870912) === 0 || Ue) {
        var r = Gl;
        Gl <<= 1, (Gl & 3932160) === 0 && (Gl = 262144), yn = r;
      } else yn = 536870912;
    return r = mn.current, r !== null && (r.flags |= 32), yn;
  }
  function on(r, i, s) {
    (r === Qe && (Ge === 2 || Ge === 9) || r.cancelPendingCommit !== null) && (ra(r, 0), ho(
      r,
      Ie,
      yn,
      !1
    )), Qa(r, s), ((Ze & 2) === 0 || r !== Qe) && (r === Qe && ((Ze & 2) === 0 && (ii |= s), pt === 4 && ho(
      r,
      Ie,
      yn,
      !1
    )), ir(r));
  }
  function Yb(r, i, s) {
    if ((Ze & 6) !== 0) throw Error(o(327));
    var u = !s && (i & 127) === 0 && (i & r.expiredLanes) === 0 || Ja(r, i), p = u ? aN(r, i) : Gh(r, i, !0), v = u;
    do {
      if (p === 0) {
        ea && !u && ho(r, i, 0, !1);
        break;
      } else {
        if (s = r.current.alternate, v && !oN(s)) {
          p = Gh(r, i, !1), v = !1;
          continue;
        }
        if (p === 2) {
          if (v = i, r.errorRecoveryDisabledLanes & v)
            var w = 0;
          else
            w = r.pendingLanes & -536870913, w = w !== 0 ? w : w & 536870912 ? 536870912 : 0;
          if (w !== 0) {
            i = w;
            e: {
              var D = r;
              p = Ds;
              var P = D.current.memoizedState.isDehydrated;
              if (P && (ra(D, w).flags |= 256), w = Gh(
                D,
                w,
                !1
              ), w !== 2) {
                if (Vh && !P) {
                  D.errorRecoveryDisabledLanes |= v, ii |= v, p = 4;
                  break e;
                }
                v = rn, rn = p, v !== null && (rn === null ? rn = v : rn.push.apply(
                  rn,
                  v
                ));
              }
              p = w;
            }
            if (v = !1, p !== 2) continue;
          }
        }
        if (p === 1) {
          ra(r, 0), ho(r, i, 0, !0);
          break;
        }
        e: {
          switch (u = r, v = p, v) {
            case 0:
            case 1:
              throw Error(o(345));
            case 4:
              if ((i & 4194048) !== i) break;
            case 6:
              ho(
                u,
                i,
                yn,
                !lo
              );
              break e;
            case 2:
              rn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(o(329));
          }
          if ((i & 62914560) === i && (p = Pc + 300 - un(), 10 < p)) {
            if (ho(
              u,
              i,
              yn,
              !lo
            ), ql(u, 0, !0) !== 0) break e;
            Vr = i, u.timeoutHandle = _x(
              qb.bind(
                null,
                u,
                s,
                rn,
                Ic,
                Bh,
                i,
                yn,
                ii,
                ta,
                lo,
                v,
                "Throttled",
                -0,
                0
              ),
              p
            );
            break e;
          }
          qb(
            u,
            s,
            rn,
            Ic,
            Bh,
            i,
            yn,
            ii,
            ta,
            lo,
            v,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    ir(r);
  }
  function qb(r, i, s, u, p, v, w, D, P, F, Q, oe, q, W) {
    if (r.timeoutHandle = -1, oe = i.subtreeFlags, oe & 8192 || (oe & 16785408) === 16785408) {
      oe = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: _r
      }, Ub(
        i,
        v,
        oe
      );
      var me = (v & 62914560) === v ? Pc - un() : (v & 4194048) === v ? Zb - un() : 0;
      if (me = $N(
        oe,
        me
      ), me !== null) {
        Vr = v, r.cancelPendingCommit = me(
          nx.bind(
            null,
            r,
            i,
            v,
            s,
            u,
            p,
            w,
            D,
            P,
            Q,
            oe,
            null,
            q,
            W
          )
        ), ho(r, v, w, !F);
        return;
      }
    }
    nx(
      r,
      i,
      v,
      s,
      u,
      p,
      w,
      D,
      P
    );
  }
  function oN(r) {
    for (var i = r; ; ) {
      var s = i.tag;
      if ((s === 0 || s === 11 || s === 15) && i.flags & 16384 && (s = i.updateQueue, s !== null && (s = s.stores, s !== null)))
        for (var u = 0; u < s.length; u++) {
          var p = s[u], v = p.getSnapshot;
          p = p.value;
          try {
            if (!hn(v(), p)) return !1;
          } catch {
            return !1;
          }
        }
      if (s = i.child, i.subtreeFlags & 16384 && s !== null)
        s.return = i, i = s;
      else {
        if (i === r) break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === r) return !0;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
    }
    return !0;
  }
  function ho(r, i, s, u) {
    i &= ~Uh, i &= ~ii, r.suspendedLanes |= i, r.pingedLanes &= ~i, u && (r.warmLanes |= i), u = r.expirationTimes;
    for (var p = i; 0 < p; ) {
      var v = 31 - dn(p), w = 1 << v;
      u[v] = -1, p &= ~w;
    }
    s !== 0 && oy(r, s, i);
  }
  function Vc() {
    return (Ze & 6) === 0 ? (Os(0), !1) : !0;
  }
  function Fh() {
    if (ke !== null) {
      if (Ge === 0)
        var r = ke.return;
      else
        r = ke, Rr = Wo = null, sh(r), Yi = null, ms = 0, r = ke;
      for (; r !== null; )
        Tb(r.alternate, r), r = r.return;
      ke = null;
    }
  }
  function ra(r, i) {
    var s = r.timeoutHandle;
    s !== -1 && (r.timeoutHandle = -1, _N(s)), s = r.cancelPendingCommit, s !== null && (r.cancelPendingCommit = null, s()), Vr = 0, Fh(), Qe = r, ke = s = Cr(r.current, null), Ie = i, Ge = 0, vn = null, lo = !1, ea = Ja(r, i), Vh = !1, ta = yn = Uh = ii = co = pt = 0, rn = Ds = null, Bh = !1, (i & 8) !== 0 && (i |= i & 32);
    var u = r.entangledLanes;
    if (u !== 0)
      for (r = r.entanglements, u &= i; 0 < u; ) {
        var p = 31 - dn(u), v = 1 << p;
        i |= r[p], u &= ~v;
      }
    return Ir = i, ac(), s;
  }
  function Xb(r, i) {
    Ae = null, I.H = Es, i === Gi || i === pc ? (i = f0(), Ge = 3) : i === Xd ? (i = f0(), Ge = 4) : Ge = i === Eh ? 8 : i !== null && typeof i == "object" && typeof i.then == "function" ? 6 : 1, vn = i, ke === null && (pt = 1, Rc(
      r,
      Rn(i, r.current)
    ));
  }
  function Wb() {
    var r = mn.current;
    return r === null ? !0 : (Ie & 4194048) === Ie ? Nn === null : (Ie & 62914560) === Ie || (Ie & 536870912) !== 0 ? r === Nn : !1;
  }
  function Kb() {
    var r = I.H;
    return I.H = Es, r === null ? Es : r;
  }
  function Jb() {
    var r = I.A;
    return I.A = nN, r;
  }
  function Uc() {
    pt = 4, lo || (Ie & 4194048) !== Ie && mn.current !== null || (ea = !0), (co & 134217727) === 0 && (ii & 134217727) === 0 || Qe === null || ho(
      Qe,
      Ie,
      yn,
      !1
    );
  }
  function Gh(r, i, s) {
    var u = Ze;
    Ze |= 2;
    var p = Kb(), v = Jb();
    (Qe !== r || Ie !== i) && (Ic = null, ra(r, i)), i = !1;
    var w = pt;
    e: do
      try {
        if (Ge !== 0 && ke !== null) {
          var D = ke, P = vn;
          switch (Ge) {
            case 8:
              Fh(), w = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              mn.current === null && (i = !0);
              var F = Ge;
              if (Ge = 0, vn = null, oa(r, D, P, F), s && ea) {
                w = 0;
                break e;
              }
              break;
            default:
              F = Ge, Ge = 0, vn = null, oa(r, D, P, F);
          }
        }
        iN(), w = pt;
        break;
      } catch (Q) {
        Xb(r, Q);
      }
    while (!0);
    return i && r.shellSuspendCounter++, Rr = Wo = null, Ze = u, I.H = p, I.A = v, ke === null && (Qe = null, Ie = 0, ac()), w;
  }
  function iN() {
    for (; ke !== null; ) Qb(ke);
  }
  function aN(r, i) {
    var s = Ze;
    Ze |= 2;
    var u = Kb(), p = Jb();
    Qe !== r || Ie !== i ? (Ic = null, Lc = un() + 500, ra(r, i)) : ea = Ja(
      r,
      i
    );
    e: do
      try {
        if (Ge !== 0 && ke !== null) {
          i = ke;
          var v = vn;
          t: switch (Ge) {
            case 1:
              Ge = 0, vn = null, oa(r, i, v, 1);
              break;
            case 2:
            case 9:
              if (c0(v)) {
                Ge = 0, vn = null, ex(i);
                break;
              }
              i = function() {
                Ge !== 2 && Ge !== 9 || Qe !== r || (Ge = 7), ir(r);
              }, v.then(i, i);
              break e;
            case 3:
              Ge = 7;
              break e;
            case 4:
              Ge = 5;
              break e;
            case 7:
              c0(v) ? (Ge = 0, vn = null, ex(i)) : (Ge = 0, vn = null, oa(r, i, v, 7));
              break;
            case 5:
              var w = null;
              switch (ke.tag) {
                case 26:
                  w = ke.memoizedState;
                case 5:
                case 27:
                  var D = ke;
                  if (w ? Vx(w) : D.stateNode.complete) {
                    Ge = 0, vn = null;
                    var P = D.sibling;
                    if (P !== null) ke = P;
                    else {
                      var F = D.return;
                      F !== null ? (ke = F, Bc(F)) : ke = null;
                    }
                    break t;
                  }
              }
              Ge = 0, vn = null, oa(r, i, v, 5);
              break;
            case 6:
              Ge = 0, vn = null, oa(r, i, v, 6);
              break;
            case 8:
              Fh(), pt = 6;
              break e;
            default:
              throw Error(o(462));
          }
        }
        sN();
        break;
      } catch (Q) {
        Xb(r, Q);
      }
    while (!0);
    return Rr = Wo = null, I.H = u, I.A = p, Ze = s, ke !== null ? 0 : (Qe = null, Ie = 0, ac(), pt);
  }
  function sN() {
    for (; ke !== null && !Hl(); )
      Qb(ke);
  }
  function Qb(r) {
    var i = Eb(r.alternate, r, Ir);
    r.memoizedProps = r.pendingProps, i === null ? Bc(r) : ke = i;
  }
  function ex(r) {
    var i = r, s = i.alternate;
    switch (i.tag) {
      case 15:
      case 0:
        i = vb(
          s,
          i,
          i.pendingProps,
          i.type,
          void 0,
          Ie
        );
        break;
      case 11:
        i = vb(
          s,
          i,
          i.pendingProps,
          i.type.render,
          i.ref,
          Ie
        );
        break;
      case 5:
        sh(i);
      default:
        Tb(s, i), i = ke = Jy(i, Ir), i = Eb(s, i, Ir);
    }
    r.memoizedProps = r.pendingProps, i === null ? Bc(r) : ke = i;
  }
  function oa(r, i, s, u) {
    Rr = Wo = null, sh(i), Yi = null, ms = 0;
    var p = i.return;
    try {
      if (XD(
        r,
        p,
        i,
        s,
        Ie
      )) {
        pt = 1, Rc(
          r,
          Rn(s, r.current)
        ), ke = null;
        return;
      }
    } catch (v) {
      if (p !== null) throw ke = p, v;
      pt = 1, Rc(
        r,
        Rn(s, r.current)
      ), ke = null;
      return;
    }
    i.flags & 32768 ? (Ue || u === 1 ? r = !0 : ea || (Ie & 536870912) !== 0 ? r = !1 : (lo = r = !0, (u === 2 || u === 9 || u === 3 || u === 6) && (u = mn.current, u !== null && u.tag === 13 && (u.flags |= 16384))), tx(i, r)) : Bc(i);
  }
  function Bc(r) {
    var i = r;
    do {
      if ((i.flags & 32768) !== 0) {
        tx(
          i,
          lo
        );
        return;
      }
      r = i.return;
      var s = JD(
        i.alternate,
        i,
        Ir
      );
      if (s !== null) {
        ke = s;
        return;
      }
      if (i = i.sibling, i !== null) {
        ke = i;
        return;
      }
      ke = i = r;
    } while (i !== null);
    pt === 0 && (pt = 5);
  }
  function tx(r, i) {
    do {
      var s = QD(r.alternate, r);
      if (s !== null) {
        s.flags &= 32767, ke = s;
        return;
      }
      if (s = r.return, s !== null && (s.flags |= 32768, s.subtreeFlags = 0, s.deletions = null), !i && (r = r.sibling, r !== null)) {
        ke = r;
        return;
      }
      ke = r = s;
    } while (r !== null);
    pt = 6, ke = null;
  }
  function nx(r, i, s, u, p, v, w, D, P) {
    r.cancelPendingCommit = null;
    do
      $c();
    while (At !== 0);
    if ((Ze & 6) !== 0) throw Error(o(327));
    if (i !== null) {
      if (i === r.current) throw Error(o(177));
      if (v = i.lanes | i.childLanes, v |= jd, Uz(
        r,
        s,
        v,
        w,
        D,
        P
      ), r === Qe && (ke = Qe = null, Ie = 0), na = i, fo = r, Vr = s, $h = v, Hh = p, Fb = u, (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? (r.callbackNode = null, r.callbackPriority = 0, fN(Zl, function() {
        return sx(), null;
      })) : (r.callbackNode = null, r.callbackPriority = 0), u = (i.flags & 13878) !== 0, (i.subtreeFlags & 13878) !== 0 || u) {
        u = I.T, I.T = null, p = G.p, G.p = 2, w = Ze, Ze |= 4;
        try {
          eN(r, i, s);
        } finally {
          Ze = w, G.p = p, I.T = u;
        }
      }
      At = 1, rx(), ox(), ix();
    }
  }
  function rx() {
    if (At === 1) {
      At = 0;
      var r = fo, i = na, s = (i.flags & 13878) !== 0;
      if ((i.subtreeFlags & 13878) !== 0 || s) {
        s = I.T, I.T = null;
        var u = G.p;
        G.p = 2;
        var p = Ze;
        Ze |= 4;
        try {
          Lb(i, r);
          var v = op, w = Hy(r.containerInfo), D = v.focusedElem, P = v.selectionRange;
          if (w !== D && D && D.ownerDocument && $y(
            D.ownerDocument.documentElement,
            D
          )) {
            if (P !== null && Md(D)) {
              var F = P.start, Q = P.end;
              if (Q === void 0 && (Q = F), "selectionStart" in D)
                D.selectionStart = F, D.selectionEnd = Math.min(
                  Q,
                  D.value.length
                );
              else {
                var oe = D.ownerDocument || document, q = oe && oe.defaultView || window;
                if (q.getSelection) {
                  var W = q.getSelection(), me = D.textContent.length, Ee = Math.min(P.start, me), Ke = P.end === void 0 ? Ee : Math.min(P.end, me);
                  !W.extend && Ee > Ke && (w = Ke, Ke = Ee, Ee = w);
                  var $ = By(
                    D,
                    Ee
                  ), V = By(
                    D,
                    Ke
                  );
                  if ($ && V && (W.rangeCount !== 1 || W.anchorNode !== $.node || W.anchorOffset !== $.offset || W.focusNode !== V.node || W.focusOffset !== V.offset)) {
                    var Z = oe.createRange();
                    Z.setStart($.node, $.offset), W.removeAllRanges(), Ee > Ke ? (W.addRange(Z), W.extend(V.node, V.offset)) : (Z.setEnd(V.node, V.offset), W.addRange(Z));
                  }
                }
              }
            }
            for (oe = [], W = D; W = W.parentNode; )
              W.nodeType === 1 && oe.push({
                element: W,
                left: W.scrollLeft,
                top: W.scrollTop
              });
            for (typeof D.focus == "function" && D.focus(), D = 0; D < oe.length; D++) {
              var re = oe[D];
              re.element.scrollLeft = re.left, re.element.scrollTop = re.top;
            }
          }
          eu = !!rp, op = rp = null;
        } finally {
          Ze = p, G.p = u, I.T = s;
        }
      }
      r.current = i, At = 2;
    }
  }
  function ox() {
    if (At === 2) {
      At = 0;
      var r = fo, i = na, s = (i.flags & 8772) !== 0;
      if ((i.subtreeFlags & 8772) !== 0 || s) {
        s = I.T, I.T = null;
        var u = G.p;
        G.p = 2;
        var p = Ze;
        Ze |= 4;
        try {
          Nb(r, i.alternate, i);
        } finally {
          Ze = p, G.p = u, I.T = s;
        }
      }
      At = 3;
    }
  }
  function ix() {
    if (At === 4 || At === 3) {
      At = 0, sd();
      var r = fo, i = na, s = Vr, u = Fb;
      (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? At = 5 : (At = 0, na = fo = null, ax(r, r.pendingLanes));
      var p = r.pendingLanes;
      if (p === 0 && (uo = null), ud(s), i = i.stateNode, fn && typeof fn.onCommitFiberRoot == "function")
        try {
          fn.onCommitFiberRoot(
            Ka,
            i,
            void 0,
            (i.current.flags & 128) === 128
          );
        } catch {
        }
      if (u !== null) {
        i = I.T, p = G.p, G.p = 2, I.T = null;
        try {
          for (var v = r.onRecoverableError, w = 0; w < u.length; w++) {
            var D = u[w];
            v(D.value, {
              componentStack: D.stack
            });
          }
        } finally {
          I.T = i, G.p = p;
        }
      }
      (Vr & 3) !== 0 && $c(), ir(r), p = r.pendingLanes, (s & 261930) !== 0 && (p & 42) !== 0 ? r === Zh ? Ns++ : (Ns = 0, Zh = r) : Ns = 0, Os(0);
    }
  }
  function ax(r, i) {
    (r.pooledCacheLanes &= i) === 0 && (i = r.pooledCache, i != null && (r.pooledCache = null, hs(i)));
  }
  function $c() {
    return rx(), ox(), ix(), sx();
  }
  function sx() {
    if (At !== 5) return !1;
    var r = fo, i = $h;
    $h = 0;
    var s = ud(Vr), u = I.T, p = G.p;
    try {
      G.p = 32 > s ? 32 : s, I.T = null, s = Hh, Hh = null;
      var v = fo, w = Vr;
      if (At = 0, na = fo = null, Vr = 0, (Ze & 6) !== 0) throw Error(o(331));
      var D = Ze;
      if (Ze |= 4, $b(v.current), Vb(
        v,
        v.current,
        w,
        s
      ), Ze = D, Os(0, !1), fn && typeof fn.onPostCommitFiberRoot == "function")
        try {
          fn.onPostCommitFiberRoot(Ka, v);
        } catch {
        }
      return !0;
    } finally {
      G.p = p, I.T = u, ax(r, i);
    }
  }
  function lx(r, i, s) {
    i = Rn(s, i), i = wh(r.stateNode, i, 2), r = oo(r, i, 2), r !== null && (Qa(r, 2), ir(r));
  }
  function Ye(r, i, s) {
    if (r.tag === 3)
      lx(r, r, s);
    else
      for (; i !== null; ) {
        if (i.tag === 3) {
          lx(
            i,
            r,
            s
          );
          break;
        } else if (i.tag === 1) {
          var u = i.stateNode;
          if (typeof i.type.getDerivedStateFromError == "function" || typeof u.componentDidCatch == "function" && (uo === null || !uo.has(u))) {
            r = Rn(s, r), s = cb(2), u = oo(i, s, 2), u !== null && (ub(
              s,
              u,
              i,
              r
            ), Qa(u, 2), ir(u));
            break;
          }
        }
        i = i.return;
      }
  }
  function Yh(r, i, s) {
    var u = r.pingCache;
    if (u === null) {
      u = r.pingCache = new rN();
      var p = /* @__PURE__ */ new Set();
      u.set(i, p);
    } else
      p = u.get(i), p === void 0 && (p = /* @__PURE__ */ new Set(), u.set(i, p));
    p.has(s) || (Vh = !0, p.add(s), r = lN.bind(null, r, i, s), i.then(r, r));
  }
  function lN(r, i, s) {
    var u = r.pingCache;
    u !== null && u.delete(i), r.pingedLanes |= r.suspendedLanes & s, r.warmLanes &= ~s, Qe === r && (Ie & s) === s && (pt === 4 || pt === 3 && (Ie & 62914560) === Ie && 300 > un() - Pc ? (Ze & 2) === 0 && ra(r, 0) : Uh |= s, ta === Ie && (ta = 0)), ir(r);
  }
  function cx(r, i) {
    i === 0 && (i = ry()), r = Yo(r, i), r !== null && (Qa(r, i), ir(r));
  }
  function cN(r) {
    var i = r.memoizedState, s = 0;
    i !== null && (s = i.retryLane), cx(r, s);
  }
  function uN(r, i) {
    var s = 0;
    switch (r.tag) {
      case 31:
      case 13:
        var u = r.stateNode, p = r.memoizedState;
        p !== null && (s = p.retryLane);
        break;
      case 19:
        u = r.stateNode;
        break;
      case 22:
        u = r.stateNode._retryCache;
        break;
      default:
        throw Error(o(314));
    }
    u !== null && u.delete(i), cx(r, s);
  }
  function fN(r, i) {
    return Wa(r, i);
  }
  var Hc = null, ia = null, qh = !1, Zc = !1, Xh = !1, po = 0;
  function ir(r) {
    r !== ia && r.next === null && (ia === null ? Hc = ia = r : ia = ia.next = r), Zc = !0, qh || (qh = !0, hN());
  }
  function Os(r, i) {
    if (!Xh && Zc) {
      Xh = !0;
      do
        for (var s = !1, u = Hc; u !== null; ) {
          if (r !== 0) {
            var p = u.pendingLanes;
            if (p === 0) var v = 0;
            else {
              var w = u.suspendedLanes, D = u.pingedLanes;
              v = (1 << 31 - dn(42 | r) + 1) - 1, v &= p & ~(w & ~D), v = v & 201326741 ? v & 201326741 | 1 : v ? v | 2 : 0;
            }
            v !== 0 && (s = !0, hx(u, v));
          } else
            v = Ie, v = ql(
              u,
              u === Qe ? v : 0,
              u.cancelPendingCommit !== null || u.timeoutHandle !== -1
            ), (v & 3) === 0 || Ja(u, v) || (s = !0, hx(u, v));
          u = u.next;
        }
      while (s);
      Xh = !1;
    }
  }
  function dN() {
    ux();
  }
  function ux() {
    Zc = qh = !1;
    var r = 0;
    po !== 0 && EN() && (r = po);
    for (var i = un(), s = null, u = Hc; u !== null; ) {
      var p = u.next, v = fx(u, i);
      v === 0 ? (u.next = null, s === null ? Hc = p : s.next = p, p === null && (ia = s)) : (s = u, (r !== 0 || (v & 3) !== 0) && (Zc = !0)), u = p;
    }
    At !== 0 && At !== 5 || Os(r), po !== 0 && (po = 0);
  }
  function fx(r, i) {
    for (var s = r.suspendedLanes, u = r.pingedLanes, p = r.expirationTimes, v = r.pendingLanes & -62914561; 0 < v; ) {
      var w = 31 - dn(v), D = 1 << w, P = p[w];
      P === -1 ? ((D & s) === 0 || (D & u) !== 0) && (p[w] = Vz(D, i)) : P <= i && (r.expiredLanes |= D), v &= ~D;
    }
    if (i = Qe, s = Ie, s = ql(
      r,
      r === i ? s : 0,
      r.cancelPendingCommit !== null || r.timeoutHandle !== -1
    ), u = r.callbackNode, s === 0 || r === i && (Ge === 2 || Ge === 9) || r.cancelPendingCommit !== null)
      return u !== null && u !== null && wr(u), r.callbackNode = null, r.callbackPriority = 0;
    if ((s & 3) === 0 || Ja(r, s)) {
      if (i = s & -s, i === r.callbackPriority) return i;
      switch (u !== null && wr(u), ud(s)) {
        case 2:
        case 8:
          s = ty;
          break;
        case 32:
          s = Zl;
          break;
        case 268435456:
          s = ny;
          break;
        default:
          s = Zl;
      }
      return u = dx.bind(null, r), s = Wa(s, u), r.callbackPriority = i, r.callbackNode = s, i;
    }
    return u !== null && u !== null && wr(u), r.callbackPriority = 2, r.callbackNode = null, 2;
  }
  function dx(r, i) {
    if (At !== 0 && At !== 5)
      return r.callbackNode = null, r.callbackPriority = 0, null;
    var s = r.callbackNode;
    if ($c() && r.callbackNode !== s)
      return null;
    var u = Ie;
    return u = ql(
      r,
      r === Qe ? u : 0,
      r.cancelPendingCommit !== null || r.timeoutHandle !== -1
    ), u === 0 ? null : (Yb(r, u, i), fx(r, un()), r.callbackNode != null && r.callbackNode === s ? dx.bind(null, r) : null);
  }
  function hx(r, i) {
    if ($c()) return null;
    Yb(r, i, !0);
  }
  function hN() {
    TN(function() {
      (Ze & 6) !== 0 ? Wa(
        ey,
        dN
      ) : ux();
    });
  }
  function Wh() {
    if (po === 0) {
      var r = Zi;
      r === 0 && (r = Fl, Fl <<= 1, (Fl & 261888) === 0 && (Fl = 256)), po = r;
    }
    return po;
  }
  function px(r) {
    return r == null || typeof r == "symbol" || typeof r == "boolean" ? null : typeof r == "function" ? r : Jl("" + r);
  }
  function mx(r, i) {
    var s = i.ownerDocument.createElement("input");
    return s.name = i.name, s.value = i.value, r.id && s.setAttribute("form", r.id), i.parentNode.insertBefore(s, i), r = new FormData(r), s.parentNode.removeChild(s), r;
  }
  function pN(r, i, s, u, p) {
    if (i === "submit" && s && s.stateNode === p) {
      var v = px(
        (p[Jt] || null).action
      ), w = u.submitter;
      w && (i = (i = w[Jt] || null) ? px(i.formAction) : w.getAttribute("formAction"), i !== null && (v = i, w = null));
      var D = new nc(
        "action",
        "action",
        null,
        u,
        p
      );
      r.push({
        event: D,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (u.defaultPrevented) {
                if (po !== 0) {
                  var P = w ? mx(p, w) : new FormData(p);
                  gh(
                    s,
                    {
                      pending: !0,
                      data: P,
                      method: p.method,
                      action: v
                    },
                    null,
                    P
                  );
                }
              } else
                typeof v == "function" && (D.preventDefault(), P = w ? mx(p, w) : new FormData(p), gh(
                  s,
                  {
                    pending: !0,
                    data: P,
                    method: p.method,
                    action: v
                  },
                  v,
                  P
                ));
            },
            currentTarget: p
          }
        ]
      });
    }
  }
  for (var Kh = 0; Kh < Od.length; Kh++) {
    var Jh = Od[Kh], mN = Jh.toLowerCase(), gN = Jh[0].toUpperCase() + Jh.slice(1);
    Hn(
      mN,
      "on" + gN
    );
  }
  Hn(Gy, "onAnimationEnd"), Hn(Yy, "onAnimationIteration"), Hn(qy, "onAnimationStart"), Hn("dblclick", "onDoubleClick"), Hn("focusin", "onFocus"), Hn("focusout", "onBlur"), Hn(ND, "onTransitionRun"), Hn(OD, "onTransitionStart"), Hn(jD, "onTransitionCancel"), Hn(Xy, "onTransitionEnd"), zi("onMouseEnter", ["mouseout", "mouseover"]), zi("onMouseLeave", ["mouseout", "mouseover"]), zi("onPointerEnter", ["pointerout", "pointerover"]), zi("onPointerLeave", ["pointerout", "pointerover"]), Ho(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Ho(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Ho("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Ho(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Ho(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Ho(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var js = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), vN = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(js)
  );
  function gx(r, i) {
    i = (i & 4) !== 0;
    for (var s = 0; s < r.length; s++) {
      var u = r[s], p = u.event;
      u = u.listeners;
      e: {
        var v = void 0;
        if (i)
          for (var w = u.length - 1; 0 <= w; w--) {
            var D = u[w], P = D.instance, F = D.currentTarget;
            if (D = D.listener, P !== v && p.isPropagationStopped())
              break e;
            v = D, p.currentTarget = F;
            try {
              v(p);
            } catch (Q) {
              ic(Q);
            }
            p.currentTarget = null, v = P;
          }
        else
          for (w = 0; w < u.length; w++) {
            if (D = u[w], P = D.instance, F = D.currentTarget, D = D.listener, P !== v && p.isPropagationStopped())
              break e;
            v = D, p.currentTarget = F;
            try {
              v(p);
            } catch (Q) {
              ic(Q);
            }
            p.currentTarget = null, v = P;
          }
      }
    }
  }
  function Pe(r, i) {
    var s = i[fd];
    s === void 0 && (s = i[fd] = /* @__PURE__ */ new Set());
    var u = r + "__bubble";
    s.has(u) || (vx(i, r, 2, !1), s.add(u));
  }
  function Qh(r, i, s) {
    var u = 0;
    i && (u |= 4), vx(
      s,
      r,
      u,
      i
    );
  }
  var Fc = "_reactListening" + Math.random().toString(36).slice(2);
  function ep(r) {
    if (!r[Fc]) {
      r[Fc] = !0, uy.forEach(function(s) {
        s !== "selectionchange" && (vN.has(s) || Qh(s, !1, r), Qh(s, !0, r));
      });
      var i = r.nodeType === 9 ? r : r.ownerDocument;
      i === null || i[Fc] || (i[Fc] = !0, Qh("selectionchange", !1, i));
    }
  }
  function vx(r, i, s, u) {
    switch (Gx(i)) {
      case 2:
        var p = FN;
        break;
      case 8:
        p = GN;
        break;
      default:
        p = mp;
    }
    s = p.bind(
      null,
      i,
      s,
      r
    ), p = void 0, !xd || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (p = !0), u ? p !== void 0 ? r.addEventListener(i, s, {
      capture: !0,
      passive: p
    }) : r.addEventListener(i, s, !0) : p !== void 0 ? r.addEventListener(i, s, {
      passive: p
    }) : r.addEventListener(i, s, !1);
  }
  function tp(r, i, s, u, p) {
    var v = u;
    if ((i & 1) === 0 && (i & 2) === 0 && u !== null)
      e: for (; ; ) {
        if (u === null) return;
        var w = u.tag;
        if (w === 3 || w === 4) {
          var D = u.stateNode.containerInfo;
          if (D === p) break;
          if (w === 4)
            for (w = u.return; w !== null; ) {
              var P = w.tag;
              if ((P === 3 || P === 4) && w.stateNode.containerInfo === p)
                return;
              w = w.return;
            }
          for (; D !== null; ) {
            if (w = Ai(D), w === null) return;
            if (P = w.tag, P === 5 || P === 6 || P === 26 || P === 27) {
              u = v = w;
              continue e;
            }
            D = D.parentNode;
          }
        }
        u = u.return;
      }
    wy(function() {
      var F = v, Q = yd(s), oe = [];
      e: {
        var q = Wy.get(r);
        if (q !== void 0) {
          var W = nc, me = r;
          switch (r) {
            case "keypress":
              if (ec(s) === 0) break e;
            case "keydown":
            case "keyup":
              W = uD;
              break;
            case "focusin":
              me = "focus", W = _d;
              break;
            case "focusout":
              me = "blur", W = _d;
              break;
            case "beforeblur":
            case "afterblur":
              W = _d;
              break;
            case "click":
              if (s.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              W = Ty;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              W = Jz;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              W = hD;
              break;
            case Gy:
            case Yy:
            case qy:
              W = tD;
              break;
            case Xy:
              W = mD;
              break;
            case "scroll":
            case "scrollend":
              W = Wz;
              break;
            case "wheel":
              W = vD;
              break;
            case "copy":
            case "cut":
            case "paste":
              W = rD;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              W = Ay;
              break;
            case "toggle":
            case "beforetoggle":
              W = bD;
          }
          var Ee = (i & 4) !== 0, Ke = !Ee && (r === "scroll" || r === "scrollend"), $ = Ee ? q !== null ? q + "Capture" : null : q;
          Ee = [];
          for (var V = F, Z; V !== null; ) {
            var re = V;
            if (Z = re.stateNode, re = re.tag, re !== 5 && re !== 26 && re !== 27 || Z === null || $ === null || (re = ns(V, $), re != null && Ee.push(
              ks(V, re, Z)
            )), Ke) break;
            V = V.return;
          }
          0 < Ee.length && (q = new W(
            q,
            me,
            null,
            s,
            Q
          ), oe.push({ event: q, listeners: Ee }));
        }
      }
      if ((i & 7) === 0) {
        e: {
          if (q = r === "mouseover" || r === "pointerover", W = r === "mouseout" || r === "pointerout", q && s !== vd && (me = s.relatedTarget || s.fromElement) && (Ai(me) || me[Ci]))
            break e;
          if ((W || q) && (q = Q.window === Q ? Q : (q = Q.ownerDocument) ? q.defaultView || q.parentWindow : window, W ? (me = s.relatedTarget || s.toElement, W = F, me = me ? Ai(me) : null, me !== null && (Ke = l(me), Ee = me.tag, me !== Ke || Ee !== 5 && Ee !== 27 && Ee !== 6) && (me = null)) : (W = null, me = F), W !== me)) {
            if (Ee = Ty, re = "onMouseLeave", $ = "onMouseEnter", V = "mouse", (r === "pointerout" || r === "pointerover") && (Ee = Ay, re = "onPointerLeave", $ = "onPointerEnter", V = "pointer"), Ke = W == null ? q : ts(W), Z = me == null ? q : ts(me), q = new Ee(
              re,
              V + "leave",
              W,
              s,
              Q
            ), q.target = Ke, q.relatedTarget = Z, re = null, Ai(Q) === F && (Ee = new Ee(
              $,
              V + "enter",
              me,
              s,
              Q
            ), Ee.target = Z, Ee.relatedTarget = Ke, re = Ee), Ke = re, W && me)
              t: {
                for (Ee = yN, $ = W, V = me, Z = 0, re = $; re; re = Ee(re))
                  Z++;
                re = 0;
                for (var Se = V; Se; Se = Ee(Se))
                  re++;
                for (; 0 < Z - re; )
                  $ = Ee($), Z--;
                for (; 0 < re - Z; )
                  V = Ee(V), re--;
                for (; Z--; ) {
                  if ($ === V || V !== null && $ === V.alternate) {
                    Ee = $;
                    break t;
                  }
                  $ = Ee($), V = Ee(V);
                }
                Ee = null;
              }
            else Ee = null;
            W !== null && yx(
              oe,
              q,
              W,
              Ee,
              !1
            ), me !== null && Ke !== null && yx(
              oe,
              Ke,
              me,
              Ee,
              !0
            );
          }
        }
        e: {
          if (q = F ? ts(F) : window, W = q.nodeName && q.nodeName.toLowerCase(), W === "select" || W === "input" && q.type === "file")
            var $e = ky;
          else if (Oy(q))
            if (Py)
              $e = MD;
            else {
              $e = AD;
              var be = CD;
            }
          else
            W = q.nodeName, !W || W.toLowerCase() !== "input" || q.type !== "checkbox" && q.type !== "radio" ? F && gd(F.elementType) && ($e = ky) : $e = RD;
          if ($e && ($e = $e(r, F))) {
            jy(
              oe,
              $e,
              s,
              Q
            );
            break e;
          }
          be && be(r, q, F), r === "focusout" && F && q.type === "number" && F.memoizedProps.value != null && md(q, "number", q.value);
        }
        switch (be = F ? ts(F) : window, r) {
          case "focusin":
            (Oy(be) || be.contentEditable === "true") && (Pi = be, zd = F, us = null);
            break;
          case "focusout":
            us = zd = Pi = null;
            break;
          case "mousedown":
            Dd = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Dd = !1, Zy(oe, s, Q);
            break;
          case "selectionchange":
            if (DD) break;
          case "keydown":
          case "keyup":
            Zy(oe, s, Q);
        }
        var Me;
        if (Cd)
          e: {
            switch (r) {
              case "compositionstart":
                var Ve = "onCompositionStart";
                break e;
              case "compositionend":
                Ve = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Ve = "onCompositionUpdate";
                break e;
            }
            Ve = void 0;
          }
        else
          ki ? Dy(r, s) && (Ve = "onCompositionEnd") : r === "keydown" && s.keyCode === 229 && (Ve = "onCompositionStart");
        Ve && (Ry && s.locale !== "ko" && (ki || Ve !== "onCompositionStart" ? Ve === "onCompositionEnd" && ki && (Me = Ey()) : (Kr = Q, Sd = "value" in Kr ? Kr.value : Kr.textContent, ki = !0)), be = Gc(F, Ve), 0 < be.length && (Ve = new Cy(
          Ve,
          r,
          null,
          s,
          Q
        ), oe.push({ event: Ve, listeners: be }), Me ? Ve.data = Me : (Me = Ny(s), Me !== null && (Ve.data = Me)))), (Me = SD ? wD(r, s) : ED(r, s)) && (Ve = Gc(F, "onBeforeInput"), 0 < Ve.length && (be = new Cy(
          "onBeforeInput",
          "beforeinput",
          null,
          s,
          Q
        ), oe.push({
          event: be,
          listeners: Ve
        }), be.data = Me)), pN(
          oe,
          r,
          F,
          s,
          Q
        );
      }
      gx(oe, i);
    });
  }
  function ks(r, i, s) {
    return {
      instance: r,
      listener: i,
      currentTarget: s
    };
  }
  function Gc(r, i) {
    for (var s = i + "Capture", u = []; r !== null; ) {
      var p = r, v = p.stateNode;
      if (p = p.tag, p !== 5 && p !== 26 && p !== 27 || v === null || (p = ns(r, s), p != null && u.unshift(
        ks(r, p, v)
      ), p = ns(r, i), p != null && u.push(
        ks(r, p, v)
      )), r.tag === 3) return u;
      r = r.return;
    }
    return [];
  }
  function yN(r) {
    if (r === null) return null;
    do
      r = r.return;
    while (r && r.tag !== 5 && r.tag !== 27);
    return r || null;
  }
  function yx(r, i, s, u, p) {
    for (var v = i._reactName, w = []; s !== null && s !== u; ) {
      var D = s, P = D.alternate, F = D.stateNode;
      if (D = D.tag, P !== null && P === u) break;
      D !== 5 && D !== 26 && D !== 27 || F === null || (P = F, p ? (F = ns(s, v), F != null && w.unshift(
        ks(s, F, P)
      )) : p || (F = ns(s, v), F != null && w.push(
        ks(s, F, P)
      ))), s = s.return;
    }
    w.length !== 0 && r.push({ event: i, listeners: w });
  }
  var bN = /\r\n?/g, xN = /\u0000|\uFFFD/g;
  function bx(r) {
    return (typeof r == "string" ? r : "" + r).replace(bN, `
`).replace(xN, "");
  }
  function xx(r, i) {
    return i = bx(i), bx(r) === i;
  }
  function We(r, i, s, u, p, v) {
    switch (s) {
      case "children":
        typeof u == "string" ? i === "body" || i === "textarea" && u === "" || Ni(r, u) : (typeof u == "number" || typeof u == "bigint") && i !== "body" && Ni(r, "" + u);
        break;
      case "className":
        Wl(r, "class", u);
        break;
      case "tabIndex":
        Wl(r, "tabindex", u);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Wl(r, s, u);
        break;
      case "style":
        xy(r, u, v);
        break;
      case "data":
        if (i !== "object") {
          Wl(r, "data", u);
          break;
        }
      case "src":
      case "href":
        if (u === "" && (i !== "a" || s !== "href")) {
          r.removeAttribute(s);
          break;
        }
        if (u == null || typeof u == "function" || typeof u == "symbol" || typeof u == "boolean") {
          r.removeAttribute(s);
          break;
        }
        u = Jl("" + u), r.setAttribute(s, u);
        break;
      case "action":
      case "formAction":
        if (typeof u == "function") {
          r.setAttribute(
            s,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof v == "function" && (s === "formAction" ? (i !== "input" && We(r, i, "name", p.name, p, null), We(
            r,
            i,
            "formEncType",
            p.formEncType,
            p,
            null
          ), We(
            r,
            i,
            "formMethod",
            p.formMethod,
            p,
            null
          ), We(
            r,
            i,
            "formTarget",
            p.formTarget,
            p,
            null
          )) : (We(r, i, "encType", p.encType, p, null), We(r, i, "method", p.method, p, null), We(r, i, "target", p.target, p, null)));
        if (u == null || typeof u == "symbol" || typeof u == "boolean") {
          r.removeAttribute(s);
          break;
        }
        u = Jl("" + u), r.setAttribute(s, u);
        break;
      case "onClick":
        u != null && (r.onclick = _r);
        break;
      case "onScroll":
        u != null && Pe("scroll", r);
        break;
      case "onScrollEnd":
        u != null && Pe("scrollend", r);
        break;
      case "dangerouslySetInnerHTML":
        if (u != null) {
          if (typeof u != "object" || !("__html" in u))
            throw Error(o(61));
          if (s = u.__html, s != null) {
            if (p.children != null) throw Error(o(60));
            r.innerHTML = s;
          }
        }
        break;
      case "multiple":
        r.multiple = u && typeof u != "function" && typeof u != "symbol";
        break;
      case "muted":
        r.muted = u && typeof u != "function" && typeof u != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (u == null || typeof u == "function" || typeof u == "boolean" || typeof u == "symbol") {
          r.removeAttribute("xlink:href");
          break;
        }
        s = Jl("" + u), r.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          s
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        u != null && typeof u != "function" && typeof u != "symbol" ? r.setAttribute(s, "" + u) : r.removeAttribute(s);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        u && typeof u != "function" && typeof u != "symbol" ? r.setAttribute(s, "") : r.removeAttribute(s);
        break;
      case "capture":
      case "download":
        u === !0 ? r.setAttribute(s, "") : u !== !1 && u != null && typeof u != "function" && typeof u != "symbol" ? r.setAttribute(s, u) : r.removeAttribute(s);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        u != null && typeof u != "function" && typeof u != "symbol" && !isNaN(u) && 1 <= u ? r.setAttribute(s, u) : r.removeAttribute(s);
        break;
      case "rowSpan":
      case "start":
        u == null || typeof u == "function" || typeof u == "symbol" || isNaN(u) ? r.removeAttribute(s) : r.setAttribute(s, u);
        break;
      case "popover":
        Pe("beforetoggle", r), Pe("toggle", r), Xl(r, "popover", u);
        break;
      case "xlinkActuate":
        Er(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          u
        );
        break;
      case "xlinkArcrole":
        Er(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          u
        );
        break;
      case "xlinkRole":
        Er(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          u
        );
        break;
      case "xlinkShow":
        Er(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          u
        );
        break;
      case "xlinkTitle":
        Er(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          u
        );
        break;
      case "xlinkType":
        Er(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          u
        );
        break;
      case "xmlBase":
        Er(
          r,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          u
        );
        break;
      case "xmlLang":
        Er(
          r,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          u
        );
        break;
      case "xmlSpace":
        Er(
          r,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          u
        );
        break;
      case "is":
        Xl(r, "is", u);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < s.length) || s[0] !== "o" && s[0] !== "O" || s[1] !== "n" && s[1] !== "N") && (s = qz.get(s) || s, Xl(r, s, u));
    }
  }
  function np(r, i, s, u, p, v) {
    switch (s) {
      case "style":
        xy(r, u, v);
        break;
      case "dangerouslySetInnerHTML":
        if (u != null) {
          if (typeof u != "object" || !("__html" in u))
            throw Error(o(61));
          if (s = u.__html, s != null) {
            if (p.children != null) throw Error(o(60));
            r.innerHTML = s;
          }
        }
        break;
      case "children":
        typeof u == "string" ? Ni(r, u) : (typeof u == "number" || typeof u == "bigint") && Ni(r, "" + u);
        break;
      case "onScroll":
        u != null && Pe("scroll", r);
        break;
      case "onScrollEnd":
        u != null && Pe("scrollend", r);
        break;
      case "onClick":
        u != null && (r.onclick = _r);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!fy.hasOwnProperty(s))
          e: {
            if (s[0] === "o" && s[1] === "n" && (p = s.endsWith("Capture"), i = s.slice(2, p ? s.length - 7 : void 0), v = r[Jt] || null, v = v != null ? v[s] : null, typeof v == "function" && r.removeEventListener(i, v, p), typeof u == "function")) {
              typeof v != "function" && v !== null && (s in r ? r[s] = null : r.hasAttribute(s) && r.removeAttribute(s)), r.addEventListener(i, u, p);
              break e;
            }
            s in r ? r[s] = u : u === !0 ? r.setAttribute(s, "") : Xl(r, s, u);
          }
    }
  }
  function Vt(r, i, s) {
    switch (i) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Pe("error", r), Pe("load", r);
        var u = !1, p = !1, v;
        for (v in s)
          if (s.hasOwnProperty(v)) {
            var w = s[v];
            if (w != null)
              switch (v) {
                case "src":
                  u = !0;
                  break;
                case "srcSet":
                  p = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(o(137, i));
                default:
                  We(r, i, v, w, s, null);
              }
          }
        p && We(r, i, "srcSet", s.srcSet, s, null), u && We(r, i, "src", s.src, s, null);
        return;
      case "input":
        Pe("invalid", r);
        var D = v = w = p = null, P = null, F = null;
        for (u in s)
          if (s.hasOwnProperty(u)) {
            var Q = s[u];
            if (Q != null)
              switch (u) {
                case "name":
                  p = Q;
                  break;
                case "type":
                  w = Q;
                  break;
                case "checked":
                  P = Q;
                  break;
                case "defaultChecked":
                  F = Q;
                  break;
                case "value":
                  v = Q;
                  break;
                case "defaultValue":
                  D = Q;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Q != null)
                    throw Error(o(137, i));
                  break;
                default:
                  We(r, i, u, Q, s, null);
              }
          }
        gy(
          r,
          v,
          D,
          P,
          F,
          w,
          p,
          !1
        );
        return;
      case "select":
        Pe("invalid", r), u = w = v = null;
        for (p in s)
          if (s.hasOwnProperty(p) && (D = s[p], D != null))
            switch (p) {
              case "value":
                v = D;
                break;
              case "defaultValue":
                w = D;
                break;
              case "multiple":
                u = D;
              default:
                We(r, i, p, D, s, null);
            }
        i = v, s = w, r.multiple = !!u, i != null ? Di(r, !!u, i, !1) : s != null && Di(r, !!u, s, !0);
        return;
      case "textarea":
        Pe("invalid", r), v = p = u = null;
        for (w in s)
          if (s.hasOwnProperty(w) && (D = s[w], D != null))
            switch (w) {
              case "value":
                u = D;
                break;
              case "defaultValue":
                p = D;
                break;
              case "children":
                v = D;
                break;
              case "dangerouslySetInnerHTML":
                if (D != null) throw Error(o(91));
                break;
              default:
                We(r, i, w, D, s, null);
            }
        yy(r, u, p, v);
        return;
      case "option":
        for (P in s)
          s.hasOwnProperty(P) && (u = s[P], u != null) && (P === "selected" ? r.selected = u && typeof u != "function" && typeof u != "symbol" : We(r, i, P, u, s, null));
        return;
      case "dialog":
        Pe("beforetoggle", r), Pe("toggle", r), Pe("cancel", r), Pe("close", r);
        break;
      case "iframe":
      case "object":
        Pe("load", r);
        break;
      case "video":
      case "audio":
        for (u = 0; u < js.length; u++)
          Pe(js[u], r);
        break;
      case "image":
        Pe("error", r), Pe("load", r);
        break;
      case "details":
        Pe("toggle", r);
        break;
      case "embed":
      case "source":
      case "link":
        Pe("error", r), Pe("load", r);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (F in s)
          if (s.hasOwnProperty(F) && (u = s[F], u != null))
            switch (F) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(o(137, i));
              default:
                We(r, i, F, u, s, null);
            }
        return;
      default:
        if (gd(i)) {
          for (Q in s)
            s.hasOwnProperty(Q) && (u = s[Q], u !== void 0 && np(
              r,
              i,
              Q,
              u,
              s,
              void 0
            ));
          return;
        }
    }
    for (D in s)
      s.hasOwnProperty(D) && (u = s[D], u != null && We(r, i, D, u, s, null));
  }
  function SN(r, i, s, u) {
    switch (i) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var p = null, v = null, w = null, D = null, P = null, F = null, Q = null;
        for (W in s) {
          var oe = s[W];
          if (s.hasOwnProperty(W) && oe != null)
            switch (W) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                P = oe;
              default:
                u.hasOwnProperty(W) || We(r, i, W, null, u, oe);
            }
        }
        for (var q in u) {
          var W = u[q];
          if (oe = s[q], u.hasOwnProperty(q) && (W != null || oe != null))
            switch (q) {
              case "type":
                v = W;
                break;
              case "name":
                p = W;
                break;
              case "checked":
                F = W;
                break;
              case "defaultChecked":
                Q = W;
                break;
              case "value":
                w = W;
                break;
              case "defaultValue":
                D = W;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (W != null)
                  throw Error(o(137, i));
                break;
              default:
                W !== oe && We(
                  r,
                  i,
                  q,
                  W,
                  u,
                  oe
                );
            }
        }
        pd(
          r,
          w,
          D,
          P,
          F,
          Q,
          v,
          p
        );
        return;
      case "select":
        W = w = D = q = null;
        for (v in s)
          if (P = s[v], s.hasOwnProperty(v) && P != null)
            switch (v) {
              case "value":
                break;
              case "multiple":
                W = P;
              default:
                u.hasOwnProperty(v) || We(
                  r,
                  i,
                  v,
                  null,
                  u,
                  P
                );
            }
        for (p in u)
          if (v = u[p], P = s[p], u.hasOwnProperty(p) && (v != null || P != null))
            switch (p) {
              case "value":
                q = v;
                break;
              case "defaultValue":
                D = v;
                break;
              case "multiple":
                w = v;
              default:
                v !== P && We(
                  r,
                  i,
                  p,
                  v,
                  u,
                  P
                );
            }
        i = D, s = w, u = W, q != null ? Di(r, !!s, q, !1) : !!u != !!s && (i != null ? Di(r, !!s, i, !0) : Di(r, !!s, s ? [] : "", !1));
        return;
      case "textarea":
        W = q = null;
        for (D in s)
          if (p = s[D], s.hasOwnProperty(D) && p != null && !u.hasOwnProperty(D))
            switch (D) {
              case "value":
                break;
              case "children":
                break;
              default:
                We(r, i, D, null, u, p);
            }
        for (w in u)
          if (p = u[w], v = s[w], u.hasOwnProperty(w) && (p != null || v != null))
            switch (w) {
              case "value":
                q = p;
                break;
              case "defaultValue":
                W = p;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (p != null) throw Error(o(91));
                break;
              default:
                p !== v && We(r, i, w, p, u, v);
            }
        vy(r, q, W);
        return;
      case "option":
        for (var me in s)
          q = s[me], s.hasOwnProperty(me) && q != null && !u.hasOwnProperty(me) && (me === "selected" ? r.selected = !1 : We(
            r,
            i,
            me,
            null,
            u,
            q
          ));
        for (P in u)
          q = u[P], W = s[P], u.hasOwnProperty(P) && q !== W && (q != null || W != null) && (P === "selected" ? r.selected = q && typeof q != "function" && typeof q != "symbol" : We(
            r,
            i,
            P,
            q,
            u,
            W
          ));
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Ee in s)
          q = s[Ee], s.hasOwnProperty(Ee) && q != null && !u.hasOwnProperty(Ee) && We(r, i, Ee, null, u, q);
        for (F in u)
          if (q = u[F], W = s[F], u.hasOwnProperty(F) && q !== W && (q != null || W != null))
            switch (F) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (q != null)
                  throw Error(o(137, i));
                break;
              default:
                We(
                  r,
                  i,
                  F,
                  q,
                  u,
                  W
                );
            }
        return;
      default:
        if (gd(i)) {
          for (var Ke in s)
            q = s[Ke], s.hasOwnProperty(Ke) && q !== void 0 && !u.hasOwnProperty(Ke) && np(
              r,
              i,
              Ke,
              void 0,
              u,
              q
            );
          for (Q in u)
            q = u[Q], W = s[Q], !u.hasOwnProperty(Q) || q === W || q === void 0 && W === void 0 || np(
              r,
              i,
              Q,
              q,
              u,
              W
            );
          return;
        }
    }
    for (var $ in s)
      q = s[$], s.hasOwnProperty($) && q != null && !u.hasOwnProperty($) && We(r, i, $, null, u, q);
    for (oe in u)
      q = u[oe], W = s[oe], !u.hasOwnProperty(oe) || q === W || q == null && W == null || We(r, i, oe, q, u, W);
  }
  function Sx(r) {
    switch (r) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function wN() {
    if (typeof performance.getEntriesByType == "function") {
      for (var r = 0, i = 0, s = performance.getEntriesByType("resource"), u = 0; u < s.length; u++) {
        var p = s[u], v = p.transferSize, w = p.initiatorType, D = p.duration;
        if (v && D && Sx(w)) {
          for (w = 0, D = p.responseEnd, u += 1; u < s.length; u++) {
            var P = s[u], F = P.startTime;
            if (F > D) break;
            var Q = P.transferSize, oe = P.initiatorType;
            Q && Sx(oe) && (P = P.responseEnd, w += Q * (P < D ? 1 : (D - F) / (P - F)));
          }
          if (--u, i += 8 * (v + w) / (p.duration / 1e3), r++, 10 < r) break;
        }
      }
      if (0 < r) return i / r / 1e6;
    }
    return navigator.connection && (r = navigator.connection.downlink, typeof r == "number") ? r : 5;
  }
  var rp = null, op = null;
  function Yc(r) {
    return r.nodeType === 9 ? r : r.ownerDocument;
  }
  function wx(r) {
    switch (r) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function Ex(r, i) {
    if (r === 0)
      switch (i) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return r === 1 && i === "foreignObject" ? 0 : r;
  }
  function ip(r, i) {
    return r === "textarea" || r === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.children == "bigint" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
  }
  var ap = null;
  function EN() {
    var r = window.event;
    return r && r.type === "popstate" ? r === ap ? !1 : (ap = r, !0) : (ap = null, !1);
  }
  var _x = typeof setTimeout == "function" ? setTimeout : void 0, _N = typeof clearTimeout == "function" ? clearTimeout : void 0, Tx = typeof Promise == "function" ? Promise : void 0, TN = typeof queueMicrotask == "function" ? queueMicrotask : typeof Tx < "u" ? function(r) {
    return Tx.resolve(null).then(r).catch(CN);
  } : _x;
  function CN(r) {
    setTimeout(function() {
      throw r;
    });
  }
  function mo(r) {
    return r === "head";
  }
  function Cx(r, i) {
    var s = i, u = 0;
    do {
      var p = s.nextSibling;
      if (r.removeChild(s), p && p.nodeType === 8)
        if (s = p.data, s === "/$" || s === "/&") {
          if (u === 0) {
            r.removeChild(p), ca(i);
            return;
          }
          u--;
        } else if (s === "$" || s === "$?" || s === "$~" || s === "$!" || s === "&")
          u++;
        else if (s === "html")
          Ps(r.ownerDocument.documentElement);
        else if (s === "head") {
          s = r.ownerDocument.head, Ps(s);
          for (var v = s.firstChild; v; ) {
            var w = v.nextSibling, D = v.nodeName;
            v[es] || D === "SCRIPT" || D === "STYLE" || D === "LINK" && v.rel.toLowerCase() === "stylesheet" || s.removeChild(v), v = w;
          }
        } else
          s === "body" && Ps(r.ownerDocument.body);
      s = p;
    } while (s);
    ca(i);
  }
  function Ax(r, i) {
    var s = r;
    r = 0;
    do {
      var u = s.nextSibling;
      if (s.nodeType === 1 ? i ? (s._stashedDisplay = s.style.display, s.style.display = "none") : (s.style.display = s._stashedDisplay || "", s.getAttribute("style") === "" && s.removeAttribute("style")) : s.nodeType === 3 && (i ? (s._stashedText = s.nodeValue, s.nodeValue = "") : s.nodeValue = s._stashedText || ""), u && u.nodeType === 8)
        if (s = u.data, s === "/$") {
          if (r === 0) break;
          r--;
        } else
          s !== "$" && s !== "$?" && s !== "$~" && s !== "$!" || r++;
      s = u;
    } while (s);
  }
  function sp(r) {
    var i = r.firstChild;
    for (i && i.nodeType === 10 && (i = i.nextSibling); i; ) {
      var s = i;
      switch (i = i.nextSibling, s.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          sp(s), dd(s);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (s.rel.toLowerCase() === "stylesheet") continue;
      }
      r.removeChild(s);
    }
  }
  function AN(r, i, s, u) {
    for (; r.nodeType === 1; ) {
      var p = s;
      if (r.nodeName.toLowerCase() !== i.toLowerCase()) {
        if (!u && (r.nodeName !== "INPUT" || r.type !== "hidden"))
          break;
      } else if (u) {
        if (!r[es])
          switch (i) {
            case "meta":
              if (!r.hasAttribute("itemprop")) break;
              return r;
            case "link":
              if (v = r.getAttribute("rel"), v === "stylesheet" && r.hasAttribute("data-precedence"))
                break;
              if (v !== p.rel || r.getAttribute("href") !== (p.href == null || p.href === "" ? null : p.href) || r.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin) || r.getAttribute("title") !== (p.title == null ? null : p.title))
                break;
              return r;
            case "style":
              if (r.hasAttribute("data-precedence")) break;
              return r;
            case "script":
              if (v = r.getAttribute("src"), (v !== (p.src == null ? null : p.src) || r.getAttribute("type") !== (p.type == null ? null : p.type) || r.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin)) && v && r.hasAttribute("async") && !r.hasAttribute("itemprop"))
                break;
              return r;
            default:
              return r;
          }
      } else if (i === "input" && r.type === "hidden") {
        var v = p.name == null ? null : "" + p.name;
        if (p.type === "hidden" && r.getAttribute("name") === v)
          return r;
      } else return r;
      if (r = On(r.nextSibling), r === null) break;
    }
    return null;
  }
  function RN(r, i, s) {
    if (i === "") return null;
    for (; r.nodeType !== 3; )
      if ((r.nodeType !== 1 || r.nodeName !== "INPUT" || r.type !== "hidden") && !s || (r = On(r.nextSibling), r === null)) return null;
    return r;
  }
  function Rx(r, i) {
    for (; r.nodeType !== 8; )
      if ((r.nodeType !== 1 || r.nodeName !== "INPUT" || r.type !== "hidden") && !i || (r = On(r.nextSibling), r === null)) return null;
    return r;
  }
  function lp(r) {
    return r.data === "$?" || r.data === "$~";
  }
  function cp(r) {
    return r.data === "$!" || r.data === "$?" && r.ownerDocument.readyState !== "loading";
  }
  function MN(r, i) {
    var s = r.ownerDocument;
    if (r.data === "$~") r._reactRetry = i;
    else if (r.data !== "$?" || s.readyState !== "loading")
      i();
    else {
      var u = function() {
        i(), s.removeEventListener("DOMContentLoaded", u);
      };
      s.addEventListener("DOMContentLoaded", u), r._reactRetry = u;
    }
  }
  function On(r) {
    for (; r != null; r = r.nextSibling) {
      var i = r.nodeType;
      if (i === 1 || i === 3) break;
      if (i === 8) {
        if (i = r.data, i === "$" || i === "$!" || i === "$?" || i === "$~" || i === "&" || i === "F!" || i === "F")
          break;
        if (i === "/$" || i === "/&") return null;
      }
    }
    return r;
  }
  var up = null;
  function Mx(r) {
    r = r.nextSibling;
    for (var i = 0; r; ) {
      if (r.nodeType === 8) {
        var s = r.data;
        if (s === "/$" || s === "/&") {
          if (i === 0)
            return On(r.nextSibling);
          i--;
        } else
          s !== "$" && s !== "$!" && s !== "$?" && s !== "$~" && s !== "&" || i++;
      }
      r = r.nextSibling;
    }
    return null;
  }
  function zx(r) {
    r = r.previousSibling;
    for (var i = 0; r; ) {
      if (r.nodeType === 8) {
        var s = r.data;
        if (s === "$" || s === "$!" || s === "$?" || s === "$~" || s === "&") {
          if (i === 0) return r;
          i--;
        } else s !== "/$" && s !== "/&" || i++;
      }
      r = r.previousSibling;
    }
    return null;
  }
  function Dx(r, i, s) {
    switch (i = Yc(s), r) {
      case "html":
        if (r = i.documentElement, !r) throw Error(o(452));
        return r;
      case "head":
        if (r = i.head, !r) throw Error(o(453));
        return r;
      case "body":
        if (r = i.body, !r) throw Error(o(454));
        return r;
      default:
        throw Error(o(451));
    }
  }
  function Ps(r) {
    for (var i = r.attributes; i.length; )
      r.removeAttributeNode(i[0]);
    dd(r);
  }
  var jn = /* @__PURE__ */ new Map(), Nx = /* @__PURE__ */ new Set();
  function qc(r) {
    return typeof r.getRootNode == "function" ? r.getRootNode() : r.nodeType === 9 ? r : r.ownerDocument;
  }
  var Ur = G.d;
  G.d = {
    f: zN,
    r: DN,
    D: NN,
    C: ON,
    L: jN,
    m: kN,
    X: LN,
    S: PN,
    M: IN
  };
  function zN() {
    var r = Ur.f(), i = Vc();
    return r || i;
  }
  function DN(r) {
    var i = Ri(r);
    i !== null && i.tag === 5 && i.type === "form" ? X0(i) : Ur.r(r);
  }
  var aa = typeof document > "u" ? null : document;
  function Ox(r, i, s) {
    var u = aa;
    if (u && typeof i == "string" && i) {
      var p = Cn(i);
      p = 'link[rel="' + r + '"][href="' + p + '"]', typeof s == "string" && (p += '[crossorigin="' + s + '"]'), Nx.has(p) || (Nx.add(p), r = { rel: r, crossOrigin: s, href: i }, u.querySelector(p) === null && (i = u.createElement("link"), Vt(i, "link", r), Nt(i), u.head.appendChild(i)));
    }
  }
  function NN(r) {
    Ur.D(r), Ox("dns-prefetch", r, null);
  }
  function ON(r, i) {
    Ur.C(r, i), Ox("preconnect", r, i);
  }
  function jN(r, i, s) {
    Ur.L(r, i, s);
    var u = aa;
    if (u && r && i) {
      var p = 'link[rel="preload"][as="' + Cn(i) + '"]';
      i === "image" && s && s.imageSrcSet ? (p += '[imagesrcset="' + Cn(
        s.imageSrcSet
      ) + '"]', typeof s.imageSizes == "string" && (p += '[imagesizes="' + Cn(
        s.imageSizes
      ) + '"]')) : p += '[href="' + Cn(r) + '"]';
      var v = p;
      switch (i) {
        case "style":
          v = sa(r);
          break;
        case "script":
          v = la(r);
      }
      jn.has(v) || (r = g(
        {
          rel: "preload",
          href: i === "image" && s && s.imageSrcSet ? void 0 : r,
          as: i
        },
        s
      ), jn.set(v, r), u.querySelector(p) !== null || i === "style" && u.querySelector(Ls(v)) || i === "script" && u.querySelector(Is(v)) || (i = u.createElement("link"), Vt(i, "link", r), Nt(i), u.head.appendChild(i)));
    }
  }
  function kN(r, i) {
    Ur.m(r, i);
    var s = aa;
    if (s && r) {
      var u = i && typeof i.as == "string" ? i.as : "script", p = 'link[rel="modulepreload"][as="' + Cn(u) + '"][href="' + Cn(r) + '"]', v = p;
      switch (u) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          v = la(r);
      }
      if (!jn.has(v) && (r = g({ rel: "modulepreload", href: r }, i), jn.set(v, r), s.querySelector(p) === null)) {
        switch (u) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (s.querySelector(Is(v)))
              return;
        }
        u = s.createElement("link"), Vt(u, "link", r), Nt(u), s.head.appendChild(u);
      }
    }
  }
  function PN(r, i, s) {
    Ur.S(r, i, s);
    var u = aa;
    if (u && r) {
      var p = Mi(u).hoistableStyles, v = sa(r);
      i = i || "default";
      var w = p.get(v);
      if (!w) {
        var D = { loading: 0, preload: null };
        if (w = u.querySelector(
          Ls(v)
        ))
          D.loading = 5;
        else {
          r = g(
            { rel: "stylesheet", href: r, "data-precedence": i },
            s
          ), (s = jn.get(v)) && fp(r, s);
          var P = w = u.createElement("link");
          Nt(P), Vt(P, "link", r), P._p = new Promise(function(F, Q) {
            P.onload = F, P.onerror = Q;
          }), P.addEventListener("load", function() {
            D.loading |= 1;
          }), P.addEventListener("error", function() {
            D.loading |= 2;
          }), D.loading |= 4, Xc(w, i, u);
        }
        w = {
          type: "stylesheet",
          instance: w,
          count: 1,
          state: D
        }, p.set(v, w);
      }
    }
  }
  function LN(r, i) {
    Ur.X(r, i);
    var s = aa;
    if (s && r) {
      var u = Mi(s).hoistableScripts, p = la(r), v = u.get(p);
      v || (v = s.querySelector(Is(p)), v || (r = g({ src: r, async: !0 }, i), (i = jn.get(p)) && dp(r, i), v = s.createElement("script"), Nt(v), Vt(v, "link", r), s.head.appendChild(v)), v = {
        type: "script",
        instance: v,
        count: 1,
        state: null
      }, u.set(p, v));
    }
  }
  function IN(r, i) {
    Ur.M(r, i);
    var s = aa;
    if (s && r) {
      var u = Mi(s).hoistableScripts, p = la(r), v = u.get(p);
      v || (v = s.querySelector(Is(p)), v || (r = g({ src: r, async: !0, type: "module" }, i), (i = jn.get(p)) && dp(r, i), v = s.createElement("script"), Nt(v), Vt(v, "link", r), s.head.appendChild(v)), v = {
        type: "script",
        instance: v,
        count: 1,
        state: null
      }, u.set(p, v));
    }
  }
  function jx(r, i, s, u) {
    var p = (p = se.current) ? qc(p) : null;
    if (!p) throw Error(o(446));
    switch (r) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof s.precedence == "string" && typeof s.href == "string" ? (i = sa(s.href), s = Mi(
          p
        ).hoistableStyles, u = s.get(i), u || (u = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, s.set(i, u)), u) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (s.rel === "stylesheet" && typeof s.href == "string" && typeof s.precedence == "string") {
          r = sa(s.href);
          var v = Mi(
            p
          ).hoistableStyles, w = v.get(r);
          if (w || (p = p.ownerDocument || p, w = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, v.set(r, w), (v = p.querySelector(
            Ls(r)
          )) && !v._p && (w.instance = v, w.state.loading = 5), jn.has(r) || (s = {
            rel: "preload",
            as: "style",
            href: s.href,
            crossOrigin: s.crossOrigin,
            integrity: s.integrity,
            media: s.media,
            hrefLang: s.hrefLang,
            referrerPolicy: s.referrerPolicy
          }, jn.set(r, s), v || VN(
            p,
            r,
            s,
            w.state
          ))), i && u === null)
            throw Error(o(528, ""));
          return w;
        }
        if (i && u !== null)
          throw Error(o(529, ""));
        return null;
      case "script":
        return i = s.async, s = s.src, typeof s == "string" && i && typeof i != "function" && typeof i != "symbol" ? (i = la(s), s = Mi(
          p
        ).hoistableScripts, u = s.get(i), u || (u = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, s.set(i, u)), u) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(o(444, r));
    }
  }
  function sa(r) {
    return 'href="' + Cn(r) + '"';
  }
  function Ls(r) {
    return 'link[rel="stylesheet"][' + r + "]";
  }
  function kx(r) {
    return g({}, r, {
      "data-precedence": r.precedence,
      precedence: null
    });
  }
  function VN(r, i, s, u) {
    r.querySelector('link[rel="preload"][as="style"][' + i + "]") ? u.loading = 1 : (i = r.createElement("link"), u.preload = i, i.addEventListener("load", function() {
      return u.loading |= 1;
    }), i.addEventListener("error", function() {
      return u.loading |= 2;
    }), Vt(i, "link", s), Nt(i), r.head.appendChild(i));
  }
  function la(r) {
    return '[src="' + Cn(r) + '"]';
  }
  function Is(r) {
    return "script[async]" + r;
  }
  function Px(r, i, s) {
    if (i.count++, i.instance === null)
      switch (i.type) {
        case "style":
          var u = r.querySelector(
            'style[data-href~="' + Cn(s.href) + '"]'
          );
          if (u)
            return i.instance = u, Nt(u), u;
          var p = g({}, s, {
            "data-href": s.href,
            "data-precedence": s.precedence,
            href: null,
            precedence: null
          });
          return u = (r.ownerDocument || r).createElement(
            "style"
          ), Nt(u), Vt(u, "style", p), Xc(u, s.precedence, r), i.instance = u;
        case "stylesheet":
          p = sa(s.href);
          var v = r.querySelector(
            Ls(p)
          );
          if (v)
            return i.state.loading |= 4, i.instance = v, Nt(v), v;
          u = kx(s), (p = jn.get(p)) && fp(u, p), v = (r.ownerDocument || r).createElement("link"), Nt(v);
          var w = v;
          return w._p = new Promise(function(D, P) {
            w.onload = D, w.onerror = P;
          }), Vt(v, "link", u), i.state.loading |= 4, Xc(v, s.precedence, r), i.instance = v;
        case "script":
          return v = la(s.src), (p = r.querySelector(
            Is(v)
          )) ? (i.instance = p, Nt(p), p) : (u = s, (p = jn.get(v)) && (u = g({}, s), dp(u, p)), r = r.ownerDocument || r, p = r.createElement("script"), Nt(p), Vt(p, "link", u), r.head.appendChild(p), i.instance = p);
        case "void":
          return null;
        default:
          throw Error(o(443, i.type));
      }
    else
      i.type === "stylesheet" && (i.state.loading & 4) === 0 && (u = i.instance, i.state.loading |= 4, Xc(u, s.precedence, r));
    return i.instance;
  }
  function Xc(r, i, s) {
    for (var u = s.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), p = u.length ? u[u.length - 1] : null, v = p, w = 0; w < u.length; w++) {
      var D = u[w];
      if (D.dataset.precedence === i) v = D;
      else if (v !== p) break;
    }
    v ? v.parentNode.insertBefore(r, v.nextSibling) : (i = s.nodeType === 9 ? s.head : s, i.insertBefore(r, i.firstChild));
  }
  function fp(r, i) {
    r.crossOrigin == null && (r.crossOrigin = i.crossOrigin), r.referrerPolicy == null && (r.referrerPolicy = i.referrerPolicy), r.title == null && (r.title = i.title);
  }
  function dp(r, i) {
    r.crossOrigin == null && (r.crossOrigin = i.crossOrigin), r.referrerPolicy == null && (r.referrerPolicy = i.referrerPolicy), r.integrity == null && (r.integrity = i.integrity);
  }
  var Wc = null;
  function Lx(r, i, s) {
    if (Wc === null) {
      var u = /* @__PURE__ */ new Map(), p = Wc = /* @__PURE__ */ new Map();
      p.set(s, u);
    } else
      p = Wc, u = p.get(s), u || (u = /* @__PURE__ */ new Map(), p.set(s, u));
    if (u.has(r)) return u;
    for (u.set(r, null), s = s.getElementsByTagName(r), p = 0; p < s.length; p++) {
      var v = s[p];
      if (!(v[es] || v[kt] || r === "link" && v.getAttribute("rel") === "stylesheet") && v.namespaceURI !== "http://www.w3.org/2000/svg") {
        var w = v.getAttribute(i) || "";
        w = r + w;
        var D = u.get(w);
        D ? D.push(v) : u.set(w, [v]);
      }
    }
    return u;
  }
  function Ix(r, i, s) {
    r = r.ownerDocument || r, r.head.insertBefore(
      s,
      i === "title" ? r.querySelector("head > title") : null
    );
  }
  function UN(r, i, s) {
    if (s === 1 || i.itemProp != null) return !1;
    switch (r) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof i.precedence != "string" || typeof i.href != "string" || i.href === "")
          break;
        return !0;
      case "link":
        if (typeof i.rel != "string" || typeof i.href != "string" || i.href === "" || i.onLoad || i.onError)
          break;
        return i.rel === "stylesheet" ? (r = i.disabled, typeof i.precedence == "string" && r == null) : !0;
      case "script":
        if (i.async && typeof i.async != "function" && typeof i.async != "symbol" && !i.onLoad && !i.onError && i.src && typeof i.src == "string")
          return !0;
    }
    return !1;
  }
  function Vx(r) {
    return !(r.type === "stylesheet" && (r.state.loading & 3) === 0);
  }
  function BN(r, i, s, u) {
    if (s.type === "stylesheet" && (typeof u.media != "string" || matchMedia(u.media).matches !== !1) && (s.state.loading & 4) === 0) {
      if (s.instance === null) {
        var p = sa(u.href), v = i.querySelector(
          Ls(p)
        );
        if (v) {
          i = v._p, i !== null && typeof i == "object" && typeof i.then == "function" && (r.count++, r = Kc.bind(r), i.then(r, r)), s.state.loading |= 4, s.instance = v, Nt(v);
          return;
        }
        v = i.ownerDocument || i, u = kx(u), (p = jn.get(p)) && fp(u, p), v = v.createElement("link"), Nt(v);
        var w = v;
        w._p = new Promise(function(D, P) {
          w.onload = D, w.onerror = P;
        }), Vt(v, "link", u), s.instance = v;
      }
      r.stylesheets === null && (r.stylesheets = /* @__PURE__ */ new Map()), r.stylesheets.set(s, i), (i = s.state.preload) && (s.state.loading & 3) === 0 && (r.count++, s = Kc.bind(r), i.addEventListener("load", s), i.addEventListener("error", s));
    }
  }
  var hp = 0;
  function $N(r, i) {
    return r.stylesheets && r.count === 0 && Qc(r, r.stylesheets), 0 < r.count || 0 < r.imgCount ? function(s) {
      var u = setTimeout(function() {
        if (r.stylesheets && Qc(r, r.stylesheets), r.unsuspend) {
          var v = r.unsuspend;
          r.unsuspend = null, v();
        }
      }, 6e4 + i);
      0 < r.imgBytes && hp === 0 && (hp = 62500 * wN());
      var p = setTimeout(
        function() {
          if (r.waitingForImages = !1, r.count === 0 && (r.stylesheets && Qc(r, r.stylesheets), r.unsuspend)) {
            var v = r.unsuspend;
            r.unsuspend = null, v();
          }
        },
        (r.imgBytes > hp ? 50 : 800) + i
      );
      return r.unsuspend = s, function() {
        r.unsuspend = null, clearTimeout(u), clearTimeout(p);
      };
    } : null;
  }
  function Kc() {
    if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
      if (this.stylesheets) Qc(this, this.stylesheets);
      else if (this.unsuspend) {
        var r = this.unsuspend;
        this.unsuspend = null, r();
      }
    }
  }
  var Jc = null;
  function Qc(r, i) {
    r.stylesheets = null, r.unsuspend !== null && (r.count++, Jc = /* @__PURE__ */ new Map(), i.forEach(HN, r), Jc = null, Kc.call(r));
  }
  function HN(r, i) {
    if (!(i.state.loading & 4)) {
      var s = Jc.get(r);
      if (s) var u = s.get(null);
      else {
        s = /* @__PURE__ */ new Map(), Jc.set(r, s);
        for (var p = r.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), v = 0; v < p.length; v++) {
          var w = p[v];
          (w.nodeName === "LINK" || w.getAttribute("media") !== "not all") && (s.set(w.dataset.precedence, w), u = w);
        }
        u && s.set(null, u);
      }
      p = i.instance, w = p.getAttribute("data-precedence"), v = s.get(w) || u, v === u && s.set(null, p), s.set(w, p), this.count++, u = Kc.bind(this), p.addEventListener("load", u), p.addEventListener("error", u), v ? v.parentNode.insertBefore(p, v.nextSibling) : (r = r.nodeType === 9 ? r.head : r, r.insertBefore(p, r.firstChild)), i.state.loading |= 4;
    }
  }
  var Vs = {
    $$typeof: A,
    Provider: null,
    Consumer: null,
    _currentValue: B,
    _currentValue2: B,
    _threadCount: 0
  };
  function ZN(r, i, s, u, p, v, w, D, P) {
    this.tag = 1, this.containerInfo = r, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = ld(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ld(0), this.hiddenUpdates = ld(null), this.identifierPrefix = u, this.onUncaughtError = p, this.onCaughtError = v, this.onRecoverableError = w, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = P, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function Ux(r, i, s, u, p, v, w, D, P, F, Q, oe) {
    return r = new ZN(
      r,
      i,
      s,
      w,
      P,
      F,
      Q,
      oe,
      D
    ), i = 1, v === !0 && (i |= 24), v = pn(3, null, null, i), r.current = v, v.stateNode = r, i = Gd(), i.refCount++, r.pooledCache = i, i.refCount++, v.memoizedState = {
      element: u,
      isDehydrated: s,
      cache: i
    }, Wd(v), r;
  }
  function Bx(r) {
    return r ? (r = Vi, r) : Vi;
  }
  function $x(r, i, s, u, p, v) {
    p = Bx(p), u.context === null ? u.context = p : u.pendingContext = p, u = ro(i), u.payload = { element: s }, v = v === void 0 ? null : v, v !== null && (u.callback = v), s = oo(r, u, i), s !== null && (on(s, r, i), vs(s, r, i));
  }
  function Hx(r, i) {
    if (r = r.memoizedState, r !== null && r.dehydrated !== null) {
      var s = r.retryLane;
      r.retryLane = s !== 0 && s < i ? s : i;
    }
  }
  function pp(r, i) {
    Hx(r, i), (r = r.alternate) && Hx(r, i);
  }
  function Zx(r) {
    if (r.tag === 13 || r.tag === 31) {
      var i = Yo(r, 67108864);
      i !== null && on(i, r, 67108864), pp(r, 67108864);
    }
  }
  function Fx(r) {
    if (r.tag === 13 || r.tag === 31) {
      var i = bn();
      i = cd(i);
      var s = Yo(r, i);
      s !== null && on(s, r, i), pp(r, i);
    }
  }
  var eu = !0;
  function FN(r, i, s, u) {
    var p = I.T;
    I.T = null;
    var v = G.p;
    try {
      G.p = 2, mp(r, i, s, u);
    } finally {
      G.p = v, I.T = p;
    }
  }
  function GN(r, i, s, u) {
    var p = I.T;
    I.T = null;
    var v = G.p;
    try {
      G.p = 8, mp(r, i, s, u);
    } finally {
      G.p = v, I.T = p;
    }
  }
  function mp(r, i, s, u) {
    if (eu) {
      var p = gp(u);
      if (p === null)
        tp(
          r,
          i,
          u,
          tu,
          s
        ), Yx(r, u);
      else if (qN(
        p,
        r,
        i,
        s,
        u
      ))
        u.stopPropagation();
      else if (Yx(r, u), i & 4 && -1 < YN.indexOf(r)) {
        for (; p !== null; ) {
          var v = Ri(p);
          if (v !== null)
            switch (v.tag) {
              case 3:
                if (v = v.stateNode, v.current.memoizedState.isDehydrated) {
                  var w = $o(v.pendingLanes);
                  if (w !== 0) {
                    var D = v;
                    for (D.pendingLanes |= 2, D.entangledLanes |= 2; w; ) {
                      var P = 1 << 31 - dn(w);
                      D.entanglements[1] |= P, w &= ~P;
                    }
                    ir(v), (Ze & 6) === 0 && (Lc = un() + 500, Os(0));
                  }
                }
                break;
              case 31:
              case 13:
                D = Yo(v, 2), D !== null && on(D, v, 2), Vc(), pp(v, 2);
            }
          if (v = gp(u), v === null && tp(
            r,
            i,
            u,
            tu,
            s
          ), v === p) break;
          p = v;
        }
        p !== null && u.stopPropagation();
      } else
        tp(
          r,
          i,
          u,
          null,
          s
        );
    }
  }
  function gp(r) {
    return r = yd(r), vp(r);
  }
  var tu = null;
  function vp(r) {
    if (tu = null, r = Ai(r), r !== null) {
      var i = l(r);
      if (i === null) r = null;
      else {
        var s = i.tag;
        if (s === 13) {
          if (r = c(i), r !== null) return r;
          r = null;
        } else if (s === 31) {
          if (r = f(i), r !== null) return r;
          r = null;
        } else if (s === 3) {
          if (i.stateNode.current.memoizedState.isDehydrated)
            return i.tag === 3 ? i.stateNode.containerInfo : null;
          r = null;
        } else i !== r && (r = null);
      }
    }
    return tu = r, null;
  }
  function Gx(r) {
    switch (r) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (Nz()) {
          case ey:
            return 2;
          case ty:
            return 8;
          case Zl:
          case Oz:
            return 32;
          case ny:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var yp = !1, go = null, vo = null, yo = null, Us = /* @__PURE__ */ new Map(), Bs = /* @__PURE__ */ new Map(), bo = [], YN = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function Yx(r, i) {
    switch (r) {
      case "focusin":
      case "focusout":
        go = null;
        break;
      case "dragenter":
      case "dragleave":
        vo = null;
        break;
      case "mouseover":
      case "mouseout":
        yo = null;
        break;
      case "pointerover":
      case "pointerout":
        Us.delete(i.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Bs.delete(i.pointerId);
    }
  }
  function $s(r, i, s, u, p, v) {
    return r === null || r.nativeEvent !== v ? (r = {
      blockedOn: i,
      domEventName: s,
      eventSystemFlags: u,
      nativeEvent: v,
      targetContainers: [p]
    }, i !== null && (i = Ri(i), i !== null && Zx(i)), r) : (r.eventSystemFlags |= u, i = r.targetContainers, p !== null && i.indexOf(p) === -1 && i.push(p), r);
  }
  function qN(r, i, s, u, p) {
    switch (i) {
      case "focusin":
        return go = $s(
          go,
          r,
          i,
          s,
          u,
          p
        ), !0;
      case "dragenter":
        return vo = $s(
          vo,
          r,
          i,
          s,
          u,
          p
        ), !0;
      case "mouseover":
        return yo = $s(
          yo,
          r,
          i,
          s,
          u,
          p
        ), !0;
      case "pointerover":
        var v = p.pointerId;
        return Us.set(
          v,
          $s(
            Us.get(v) || null,
            r,
            i,
            s,
            u,
            p
          )
        ), !0;
      case "gotpointercapture":
        return v = p.pointerId, Bs.set(
          v,
          $s(
            Bs.get(v) || null,
            r,
            i,
            s,
            u,
            p
          )
        ), !0;
    }
    return !1;
  }
  function qx(r) {
    var i = Ai(r.target);
    if (i !== null) {
      var s = l(i);
      if (s !== null) {
        if (i = s.tag, i === 13) {
          if (i = c(s), i !== null) {
            r.blockedOn = i, ly(r.priority, function() {
              Fx(s);
            });
            return;
          }
        } else if (i === 31) {
          if (i = f(s), i !== null) {
            r.blockedOn = i, ly(r.priority, function() {
              Fx(s);
            });
            return;
          }
        } else if (i === 3 && s.stateNode.current.memoizedState.isDehydrated) {
          r.blockedOn = s.tag === 3 ? s.stateNode.containerInfo : null;
          return;
        }
      }
    }
    r.blockedOn = null;
  }
  function nu(r) {
    if (r.blockedOn !== null) return !1;
    for (var i = r.targetContainers; 0 < i.length; ) {
      var s = gp(r.nativeEvent);
      if (s === null) {
        s = r.nativeEvent;
        var u = new s.constructor(
          s.type,
          s
        );
        vd = u, s.target.dispatchEvent(u), vd = null;
      } else
        return i = Ri(s), i !== null && Zx(i), r.blockedOn = s, !1;
      i.shift();
    }
    return !0;
  }
  function Xx(r, i, s) {
    nu(r) && s.delete(i);
  }
  function XN() {
    yp = !1, go !== null && nu(go) && (go = null), vo !== null && nu(vo) && (vo = null), yo !== null && nu(yo) && (yo = null), Us.forEach(Xx), Bs.forEach(Xx);
  }
  function ru(r, i) {
    r.blockedOn === i && (r.blockedOn = null, yp || (yp = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      XN
    )));
  }
  var ou = null;
  function Wx(r) {
    ou !== r && (ou = r, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        ou === r && (ou = null);
        for (var i = 0; i < r.length; i += 3) {
          var s = r[i], u = r[i + 1], p = r[i + 2];
          if (typeof u != "function") {
            if (vp(u || s) === null)
              continue;
            break;
          }
          var v = Ri(s);
          v !== null && (r.splice(i, 3), i -= 3, gh(
            v,
            {
              pending: !0,
              data: p,
              method: s.method,
              action: u
            },
            u,
            p
          ));
        }
      }
    ));
  }
  function ca(r) {
    function i(P) {
      return ru(P, r);
    }
    go !== null && ru(go, r), vo !== null && ru(vo, r), yo !== null && ru(yo, r), Us.forEach(i), Bs.forEach(i);
    for (var s = 0; s < bo.length; s++) {
      var u = bo[s];
      u.blockedOn === r && (u.blockedOn = null);
    }
    for (; 0 < bo.length && (s = bo[0], s.blockedOn === null); )
      qx(s), s.blockedOn === null && bo.shift();
    if (s = (r.ownerDocument || r).$$reactFormReplay, s != null)
      for (u = 0; u < s.length; u += 3) {
        var p = s[u], v = s[u + 1], w = p[Jt] || null;
        if (typeof v == "function")
          w || Wx(s);
        else if (w) {
          var D = null;
          if (v && v.hasAttribute("formAction")) {
            if (p = v, w = v[Jt] || null)
              D = w.formAction;
            else if (vp(p) !== null) continue;
          } else D = w.action;
          typeof D == "function" ? s[u + 1] = D : (s.splice(u, 3), u -= 3), Wx(s);
        }
      }
  }
  function Kx() {
    function r(v) {
      v.canIntercept && v.info === "react-transition" && v.intercept({
        handler: function() {
          return new Promise(function(w) {
            return p = w;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function i() {
      p !== null && (p(), p = null), u || setTimeout(s, 20);
    }
    function s() {
      if (!u && !navigation.transition) {
        var v = navigation.currentEntry;
        v && v.url != null && navigation.navigate(v.url, {
          state: v.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if (typeof navigation == "object") {
      var u = !1, p = null;
      return navigation.addEventListener("navigate", r), navigation.addEventListener("navigatesuccess", i), navigation.addEventListener("navigateerror", i), setTimeout(s, 100), function() {
        u = !0, navigation.removeEventListener("navigate", r), navigation.removeEventListener("navigatesuccess", i), navigation.removeEventListener("navigateerror", i), p !== null && (p(), p = null);
      };
    }
  }
  function bp(r) {
    this._internalRoot = r;
  }
  iu.prototype.render = bp.prototype.render = function(r) {
    var i = this._internalRoot;
    if (i === null) throw Error(o(409));
    var s = i.current, u = bn();
    $x(s, u, r, i, null, null);
  }, iu.prototype.unmount = bp.prototype.unmount = function() {
    var r = this._internalRoot;
    if (r !== null) {
      this._internalRoot = null;
      var i = r.containerInfo;
      $x(r.current, 2, null, r, null, null), Vc(), i[Ci] = null;
    }
  };
  function iu(r) {
    this._internalRoot = r;
  }
  iu.prototype.unstable_scheduleHydration = function(r) {
    if (r) {
      var i = sy();
      r = { blockedOn: null, target: r, priority: i };
      for (var s = 0; s < bo.length && i !== 0 && i < bo[s].priority; s++) ;
      bo.splice(s, 0, r), s === 0 && qx(r);
    }
  };
  var Jx = t.version;
  if (Jx !== "19.2.4")
    throw Error(
      o(
        527,
        Jx,
        "19.2.4"
      )
    );
  G.findDOMNode = function(r) {
    var i = r._reactInternals;
    if (i === void 0)
      throw typeof r.render == "function" ? Error(o(188)) : (r = Object.keys(r).join(","), Error(o(268, r)));
    return r = h(i), r = r !== null ? m(r) : null, r = r === null ? null : r.stateNode, r;
  };
  var WN = {
    bundleType: 0,
    version: "19.2.4",
    rendererPackageName: "react-dom",
    currentDispatcherRef: I,
    reconcilerVersion: "19.2.4"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var au = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!au.isDisabled && au.supportsFiber)
      try {
        Ka = au.inject(
          WN
        ), fn = au;
      } catch {
      }
  }
  return Hs.createRoot = function(r, i) {
    if (!a(r)) throw Error(o(299));
    var s = !1, u = "", p = ib, v = ab, w = sb;
    return i != null && (i.unstable_strictMode === !0 && (s = !0), i.identifierPrefix !== void 0 && (u = i.identifierPrefix), i.onUncaughtError !== void 0 && (p = i.onUncaughtError), i.onCaughtError !== void 0 && (v = i.onCaughtError), i.onRecoverableError !== void 0 && (w = i.onRecoverableError)), i = Ux(
      r,
      1,
      !1,
      null,
      null,
      s,
      u,
      null,
      p,
      v,
      w,
      Kx
    ), r[Ci] = i.current, ep(r), new bp(i);
  }, Hs.hydrateRoot = function(r, i, s) {
    if (!a(r)) throw Error(o(299));
    var u = !1, p = "", v = ib, w = ab, D = sb, P = null;
    return s != null && (s.unstable_strictMode === !0 && (u = !0), s.identifierPrefix !== void 0 && (p = s.identifierPrefix), s.onUncaughtError !== void 0 && (v = s.onUncaughtError), s.onCaughtError !== void 0 && (w = s.onCaughtError), s.onRecoverableError !== void 0 && (D = s.onRecoverableError), s.formState !== void 0 && (P = s.formState)), i = Ux(
      r,
      1,
      !0,
      i,
      s ?? null,
      u,
      p,
      P,
      v,
      w,
      D,
      Kx
    ), i.context = Bx(null), s = i.current, u = bn(), u = cd(u), p = ro(u), p.callback = null, oo(s, p, u), s = u, i.current.lanes = s, Qa(i, s), ir(i), r[Ci] = i.current, ep(r), new iu(i);
  }, Hs.version = "19.2.4", Hs;
}
var aS;
function iO() {
  if (aS) return Sp.exports;
  aS = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Sp.exports = oO(), Sp.exports;
}
var aO = iO();
const sO = /* @__PURE__ */ Ml(aO);
var Tp = { exports: {} }, Zs = {};
var sS;
function lO() {
  if (sS) return Zs;
  sS = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.fragment");
  function n(o, a, l) {
    var c = null;
    if (l !== void 0 && (c = "" + l), a.key !== void 0 && (c = "" + a.key), "key" in a) {
      l = {};
      for (var f in a)
        f !== "key" && (l[f] = a[f]);
    } else l = a;
    return a = l.ref, {
      $$typeof: e,
      type: o,
      key: c,
      ref: a !== void 0 ? a : null,
      props: l
    };
  }
  return Zs.Fragment = t, Zs.jsx = n, Zs.jsxs = n, Zs;
}
var lS;
function cO() {
  return lS || (lS = 1, Tp.exports = lO()), Tp.exports;
}
var S = cO(), Po = Tf();
const uO = /* @__PURE__ */ Ml(Po);
var Fs = { exports: {} }, Cp = {}, Ap = { exports: {} }, Rp, cS;
function fO() {
  if (cS) return Rp;
  cS = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Rp = e, Rp;
}
var Mp, uS;
function dO() {
  if (uS) return Mp;
  uS = 1;
  var e = /* @__PURE__ */ fO();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Mp = function() {
    function o(c, f, d, h, m, g) {
      if (g !== e) {
        var b = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw b.name = "Invariant Violation", b;
      }
    }
    o.isRequired = o;
    function a() {
      return o;
    }
    var l = {
      array: o,
      bigint: o,
      bool: o,
      func: o,
      number: o,
      object: o,
      string: o,
      symbol: o,
      any: o,
      arrayOf: a,
      element: o,
      elementType: o,
      instanceOf: a,
      node: o,
      objectOf: a,
      oneOf: a,
      oneOfType: a,
      shape: a,
      exact: a,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return l.PropTypes = l, l;
  }, Mp;
}
var fS;
function RE() {
  return fS || (fS = 1, Ap.exports = /* @__PURE__ */ dO()()), Ap.exports;
}
function ME(e) {
  var t, n, o = "";
  if (typeof e == "string" || typeof e == "number") o += e;
  else if (typeof e == "object") if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (n = ME(e[t])) && (o && (o += " "), o += n);
  else for (t in e) e[t] && (o && (o += " "), o += t);
  return o;
}
function dS() {
  for (var e, t, n = 0, o = ""; n < arguments.length; ) (e = arguments[n++]) && (t = ME(e)) && (o && (o += " "), o += t);
  return o;
}
const hO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: dS,
  default: dS
}, Symbol.toStringTag, { value: "Module" })), pO = /* @__PURE__ */ QN(hO);
var bt = {}, So = {}, hS;
function Cf() {
  if (hS) return So;
  hS = 1, Object.defineProperty(So, "__esModule", {
    value: !0
  }), So.dontSetMe = a, So.findInArray = e, So.int = o, So.isFunction = t, So.isNum = n;
  function e(l, c) {
    for (let f = 0, d = l.length; f < d; f++)
      if (c.apply(c, [l[f], f, l])) return l[f];
  }
  function t(l) {
    return typeof l == "function" || Object.prototype.toString.call(l) === "[object Function]";
  }
  function n(l) {
    return typeof l == "number" && !isNaN(l);
  }
  function o(l) {
    return parseInt(l, 10);
  }
  function a(l, c, f) {
    if (l[c])
      return new Error("Invalid prop ".concat(c, " passed to ").concat(f, " - do not set this, set it on the child."));
  }
  return So;
}
var wo = {}, pS;
function mO() {
  if (pS) return wo;
  pS = 1, Object.defineProperty(wo, "__esModule", {
    value: !0
  }), wo.browserPrefixToKey = n, wo.browserPrefixToStyle = o, wo.default = void 0, wo.getPrefix = t;
  const e = ["Moz", "Webkit", "O", "ms"];
  function t() {
    var l;
    let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
    if (typeof window > "u") return "";
    const f = (l = window.document) === null || l === void 0 || (l = l.documentElement) === null || l === void 0 ? void 0 : l.style;
    if (!f || c in f) return "";
    for (let d = 0; d < e.length; d++)
      if (n(c, e[d]) in f) return e[d];
    return "";
  }
  function n(l, c) {
    return c ? "".concat(c).concat(a(l)) : l;
  }
  function o(l, c) {
    return c ? "-".concat(c.toLowerCase(), "-").concat(l) : l;
  }
  function a(l) {
    let c = "", f = !0;
    for (let d = 0; d < l.length; d++)
      f ? (c += l[d].toUpperCase(), f = !1) : l[d] === "-" ? f = !0 : c += l[d];
    return c;
  }
  return wo.default = t(), wo;
}
var mS;
function yg() {
  if (mS) return bt;
  mS = 1, Object.defineProperty(bt, "__esModule", {
    value: !0
  }), bt.addClassName = O, bt.addEvent = f, bt.addUserSelectStyles = A, bt.createCSSTransform = _, bt.createSVGTransform = E, bt.getTouch = C, bt.getTouchIdentifier = z, bt.getTranslation = T, bt.innerHeight = g, bt.innerWidth = b, bt.matchesSelector = l, bt.matchesSelectorAndParentsTo = c, bt.offsetXYFromParent = x, bt.outerHeight = h, bt.outerWidth = m, bt.removeClassName = L, bt.removeEvent = d, bt.removeUserSelectStyles = R;
  var e = Cf(), t = o(mO());
  function n(M) {
    if (typeof WeakMap != "function") return null;
    var N = /* @__PURE__ */ new WeakMap(), j = /* @__PURE__ */ new WeakMap();
    return (n = function(Y) {
      return Y ? j : N;
    })(M);
  }
  function o(M, N) {
    if (M && M.__esModule)
      return M;
    if (M === null || typeof M != "object" && typeof M != "function")
      return { default: M };
    var j = n(N);
    if (j && j.has(M))
      return j.get(M);
    var Y = {}, ne = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var J in M)
      if (J !== "default" && Object.prototype.hasOwnProperty.call(M, J)) {
        var he = ne ? Object.getOwnPropertyDescriptor(M, J) : null;
        he && (he.get || he.set) ? Object.defineProperty(Y, J, he) : Y[J] = M[J];
      }
    return Y.default = M, j && j.set(M, Y), Y;
  }
  let a = "";
  function l(M, N) {
    return a || (a = (0, e.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(j) {
      return (0, e.isFunction)(M[j]);
    })), (0, e.isFunction)(M[a]) ? M[a](N) : !1;
  }
  function c(M, N, j) {
    let Y = M;
    do {
      if (l(Y, N)) return !0;
      if (Y === j) return !1;
      Y = Y.parentNode;
    } while (Y);
    return !1;
  }
  function f(M, N, j, Y) {
    if (!M) return;
    const ne = {
      capture: !0,
      ...Y
    };
    M.addEventListener ? M.addEventListener(N, j, ne) : M.attachEvent ? M.attachEvent("on" + N, j) : M["on" + N] = j;
  }
  function d(M, N, j, Y) {
    if (!M) return;
    const ne = {
      capture: !0,
      ...Y
    };
    M.removeEventListener ? M.removeEventListener(N, j, ne) : M.detachEvent ? M.detachEvent("on" + N, j) : M["on" + N] = null;
  }
  function h(M) {
    let N = M.clientHeight;
    const j = M.ownerDocument.defaultView.getComputedStyle(M);
    return N += (0, e.int)(j.borderTopWidth), N += (0, e.int)(j.borderBottomWidth), N;
  }
  function m(M) {
    let N = M.clientWidth;
    const j = M.ownerDocument.defaultView.getComputedStyle(M);
    return N += (0, e.int)(j.borderLeftWidth), N += (0, e.int)(j.borderRightWidth), N;
  }
  function g(M) {
    let N = M.clientHeight;
    const j = M.ownerDocument.defaultView.getComputedStyle(M);
    return N -= (0, e.int)(j.paddingTop), N -= (0, e.int)(j.paddingBottom), N;
  }
  function b(M) {
    let N = M.clientWidth;
    const j = M.ownerDocument.defaultView.getComputedStyle(M);
    return N -= (0, e.int)(j.paddingLeft), N -= (0, e.int)(j.paddingRight), N;
  }
  function x(M, N, j) {
    const ne = N === N.ownerDocument.body ? {
      left: 0,
      top: 0
    } : N.getBoundingClientRect(), J = (M.clientX + N.scrollLeft - ne.left) / j, he = (M.clientY + N.scrollTop - ne.top) / j;
    return {
      x: J,
      y: he
    };
  }
  function _(M, N) {
    const j = T(M, N, "px");
    return {
      [(0, t.browserPrefixToKey)("transform", t.default)]: j
    };
  }
  function E(M, N) {
    return T(M, N, "");
  }
  function T(M, N, j) {
    let {
      x: Y,
      y: ne
    } = M, J = "translate(".concat(Y).concat(j, ",").concat(ne).concat(j, ")");
    if (N) {
      const he = "".concat(typeof N.x == "string" ? N.x : N.x + j), fe = "".concat(typeof N.y == "string" ? N.y : N.y + j);
      J = "translate(".concat(he, ", ").concat(fe, ")") + J;
    }
    return J;
  }
  function C(M, N) {
    return M.targetTouches && (0, e.findInArray)(M.targetTouches, (j) => N === j.identifier) || M.changedTouches && (0, e.findInArray)(M.changedTouches, (j) => N === j.identifier);
  }
  function z(M) {
    if (M.targetTouches && M.targetTouches[0]) return M.targetTouches[0].identifier;
    if (M.changedTouches && M.changedTouches[0]) return M.changedTouches[0].identifier;
  }
  function A(M) {
    if (!M) return;
    let N = M.getElementById("react-draggable-style-el");
    N || (N = M.createElement("style"), N.type = "text/css", N.id = "react-draggable-style-el", N.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, N.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, M.getElementsByTagName("head")[0].appendChild(N)), M.body && O(M.body, "react-draggable-transparent-selection");
  }
  function R(M) {
    if (M)
      try {
        if (M.body && L(M.body, "react-draggable-transparent-selection"), M.selection)
          M.selection.empty();
        else {
          const N = (M.defaultView || window).getSelection();
          N && N.type !== "Caret" && N.removeAllRanges();
        }
      } catch {
      }
  }
  function O(M, N) {
    M.classList ? M.classList.add(N) : M.className.match(new RegExp("(?:^|\\s)".concat(N, "(?!\\S)"))) || (M.className += " ".concat(N));
  }
  function L(M, N) {
    M.classList ? M.classList.remove(N) : M.className = M.className.replace(new RegExp("(?:^|\\s)".concat(N, "(?!\\S)"), "g"), "");
  }
  return bt;
}
var ar = {}, gS;
function zE() {
  if (gS) return ar;
  gS = 1, Object.defineProperty(ar, "__esModule", {
    value: !0
  }), ar.canDragX = a, ar.canDragY = l, ar.createCoreData = f, ar.createDraggableData = d, ar.getBoundPosition = n, ar.getControlPosition = c, ar.snapToGrid = o;
  var e = Cf(), t = yg();
  function n(g, b, x) {
    if (!g.props.bounds) return [b, x];
    let {
      bounds: _
    } = g.props;
    _ = typeof _ == "string" ? _ : h(_);
    const E = m(g);
    if (typeof _ == "string") {
      const {
        ownerDocument: T
      } = E, C = T.defaultView;
      let z;
      if (_ === "parent" ? z = E.parentNode : z = T.querySelector(_), !(z instanceof C.HTMLElement))
        throw new Error('Bounds selector "' + _ + '" could not find an element.');
      const A = z, R = C.getComputedStyle(E), O = C.getComputedStyle(A);
      _ = {
        left: -E.offsetLeft + (0, e.int)(O.paddingLeft) + (0, e.int)(R.marginLeft),
        top: -E.offsetTop + (0, e.int)(O.paddingTop) + (0, e.int)(R.marginTop),
        right: (0, t.innerWidth)(A) - (0, t.outerWidth)(E) - E.offsetLeft + (0, e.int)(O.paddingRight) - (0, e.int)(R.marginRight),
        bottom: (0, t.innerHeight)(A) - (0, t.outerHeight)(E) - E.offsetTop + (0, e.int)(O.paddingBottom) - (0, e.int)(R.marginBottom)
      };
    }
    return (0, e.isNum)(_.right) && (b = Math.min(b, _.right)), (0, e.isNum)(_.bottom) && (x = Math.min(x, _.bottom)), (0, e.isNum)(_.left) && (b = Math.max(b, _.left)), (0, e.isNum)(_.top) && (x = Math.max(x, _.top)), [b, x];
  }
  function o(g, b, x) {
    const _ = Math.round(b / g[0]) * g[0], E = Math.round(x / g[1]) * g[1];
    return [_, E];
  }
  function a(g) {
    return g.props.axis === "both" || g.props.axis === "x";
  }
  function l(g) {
    return g.props.axis === "both" || g.props.axis === "y";
  }
  function c(g, b, x) {
    const _ = typeof b == "number" ? (0, t.getTouch)(g, b) : null;
    if (typeof b == "number" && !_) return null;
    const E = m(x), T = x.props.offsetParent || E.offsetParent || E.ownerDocument.body;
    return (0, t.offsetXYFromParent)(_ || g, T, x.props.scale);
  }
  function f(g, b, x) {
    const _ = !(0, e.isNum)(g.lastX), E = m(g);
    return _ ? {
      node: E,
      deltaX: 0,
      deltaY: 0,
      lastX: b,
      lastY: x,
      x: b,
      y: x
    } : {
      node: E,
      deltaX: b - g.lastX,
      deltaY: x - g.lastY,
      lastX: g.lastX,
      lastY: g.lastY,
      x: b,
      y: x
    };
  }
  function d(g, b) {
    const x = g.props.scale;
    return {
      node: b.node,
      x: g.state.x + b.deltaX / x,
      y: g.state.y + b.deltaY / x,
      deltaX: b.deltaX / x,
      deltaY: b.deltaY / x,
      lastX: g.state.x,
      lastY: g.state.y
    };
  }
  function h(g) {
    return {
      left: g.left,
      top: g.top,
      right: g.right,
      bottom: g.bottom
    };
  }
  function m(g) {
    const b = g.findDOMNode();
    if (!b)
      throw new Error("<DraggableCore>: Unmounted during event!");
    return b;
  }
  return ar;
}
var Gs = {}, su = {}, vS;
function DE() {
  if (vS) return su;
  vS = 1, Object.defineProperty(su, "__esModule", {
    value: !0
  }), su.default = e;
  function e() {
  }
  return su;
}
var yS;
function gO() {
  if (yS) return Gs;
  yS = 1, Object.defineProperty(Gs, "__esModule", {
    value: !0
  }), Gs.default = void 0;
  var e = h(zl()), t = f(/* @__PURE__ */ RE()), n = f(Tf()), o = yg(), a = zE(), l = Cf(), c = f(DE());
  function f(T) {
    return T && T.__esModule ? T : { default: T };
  }
  function d(T) {
    if (typeof WeakMap != "function") return null;
    var C = /* @__PURE__ */ new WeakMap(), z = /* @__PURE__ */ new WeakMap();
    return (d = function(A) {
      return A ? z : C;
    })(T);
  }
  function h(T, C) {
    if (T && T.__esModule)
      return T;
    if (T === null || typeof T != "object" && typeof T != "function")
      return { default: T };
    var z = d(C);
    if (z && z.has(T))
      return z.get(T);
    var A = {}, R = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var O in T)
      if (O !== "default" && Object.prototype.hasOwnProperty.call(T, O)) {
        var L = R ? Object.getOwnPropertyDescriptor(T, O) : null;
        L && (L.get || L.set) ? Object.defineProperty(A, O, L) : A[O] = T[O];
      }
    return A.default = T, z && z.set(T, A), A;
  }
  function m(T, C, z) {
    return C = g(C), C in T ? Object.defineProperty(T, C, { value: z, enumerable: !0, configurable: !0, writable: !0 }) : T[C] = z, T;
  }
  function g(T) {
    var C = b(T, "string");
    return typeof C == "symbol" ? C : String(C);
  }
  function b(T, C) {
    if (typeof T != "object" || T === null) return T;
    var z = T[Symbol.toPrimitive];
    if (z !== void 0) {
      var A = z.call(T, C);
      if (typeof A != "object") return A;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (C === "string" ? String : Number)(T);
  }
  const x = {
    touch: {
      start: "touchstart",
      move: "touchmove",
      stop: "touchend"
    },
    mouse: {
      start: "mousedown",
      move: "mousemove",
      stop: "mouseup"
    }
  };
  let _ = x.mouse, E = class extends e.Component {
    constructor() {
      super(...arguments), m(this, "dragging", !1), m(this, "lastX", NaN), m(this, "lastY", NaN), m(this, "touchIdentifier", null), m(this, "mounted", !1), m(this, "handleDragStart", (C) => {
        if (this.props.onMouseDown(C), !this.props.allowAnyClick && typeof C.button == "number" && C.button !== 0) return !1;
        const z = this.findDOMNode();
        if (!z || !z.ownerDocument || !z.ownerDocument.body)
          throw new Error("<DraggableCore> not mounted on DragStart!");
        const {
          ownerDocument: A
        } = z;
        if (this.props.disabled || !(C.target instanceof A.defaultView.Node) || this.props.handle && !(0, o.matchesSelectorAndParentsTo)(C.target, this.props.handle, z) || this.props.cancel && (0, o.matchesSelectorAndParentsTo)(C.target, this.props.cancel, z))
          return;
        C.type === "touchstart" && C.preventDefault();
        const R = (0, o.getTouchIdentifier)(C);
        this.touchIdentifier = R;
        const O = (0, a.getControlPosition)(C, R, this);
        if (O == null) return;
        const {
          x: L,
          y: M
        } = O, N = (0, a.createCoreData)(this, L, M);
        (0, c.default)("DraggableCore: handleDragStart: %j", N), (0, c.default)("calling", this.props.onStart), !(this.props.onStart(C, N) === !1 || this.mounted === !1) && (this.props.enableUserSelectHack && (0, o.addUserSelectStyles)(A), this.dragging = !0, this.lastX = L, this.lastY = M, (0, o.addEvent)(A, _.move, this.handleDrag), (0, o.addEvent)(A, _.stop, this.handleDragStop));
      }), m(this, "handleDrag", (C) => {
        const z = (0, a.getControlPosition)(C, this.touchIdentifier, this);
        if (z == null) return;
        let {
          x: A,
          y: R
        } = z;
        if (Array.isArray(this.props.grid)) {
          let M = A - this.lastX, N = R - this.lastY;
          if ([M, N] = (0, a.snapToGrid)(this.props.grid, M, N), !M && !N) return;
          A = this.lastX + M, R = this.lastY + N;
        }
        const O = (0, a.createCoreData)(this, A, R);
        if ((0, c.default)("DraggableCore: handleDrag: %j", O), this.props.onDrag(C, O) === !1 || this.mounted === !1) {
          try {
            this.handleDragStop(new MouseEvent("mouseup"));
          } catch {
            const N = document.createEvent("MouseEvents");
            N.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), this.handleDragStop(N);
          }
          return;
        }
        this.lastX = A, this.lastY = R;
      }), m(this, "handleDragStop", (C) => {
        if (!this.dragging) return;
        const z = (0, a.getControlPosition)(C, this.touchIdentifier, this);
        if (z == null) return;
        let {
          x: A,
          y: R
        } = z;
        if (Array.isArray(this.props.grid)) {
          let N = A - this.lastX || 0, j = R - this.lastY || 0;
          [N, j] = (0, a.snapToGrid)(this.props.grid, N, j), A = this.lastX + N, R = this.lastY + j;
        }
        const O = (0, a.createCoreData)(this, A, R);
        if (this.props.onStop(C, O) === !1 || this.mounted === !1) return !1;
        const M = this.findDOMNode();
        M && this.props.enableUserSelectHack && (0, o.removeUserSelectStyles)(M.ownerDocument), (0, c.default)("DraggableCore: handleDragStop: %j", O), this.dragging = !1, this.lastX = NaN, this.lastY = NaN, M && ((0, c.default)("DraggableCore: Removing handlers"), (0, o.removeEvent)(M.ownerDocument, _.move, this.handleDrag), (0, o.removeEvent)(M.ownerDocument, _.stop, this.handleDragStop));
      }), m(this, "onMouseDown", (C) => (_ = x.mouse, this.handleDragStart(C))), m(this, "onMouseUp", (C) => (_ = x.mouse, this.handleDragStop(C))), m(this, "onTouchStart", (C) => (_ = x.touch, this.handleDragStart(C))), m(this, "onTouchEnd", (C) => (_ = x.touch, this.handleDragStop(C)));
    }
    componentDidMount() {
      this.mounted = !0;
      const C = this.findDOMNode();
      C && (0, o.addEvent)(C, x.touch.start, this.onTouchStart, {
        passive: !1
      });
    }
    componentWillUnmount() {
      this.mounted = !1;
      const C = this.findDOMNode();
      if (C) {
        const {
          ownerDocument: z
        } = C;
        (0, o.removeEvent)(z, x.mouse.move, this.handleDrag), (0, o.removeEvent)(z, x.touch.move, this.handleDrag), (0, o.removeEvent)(z, x.mouse.stop, this.handleDragStop), (0, o.removeEvent)(z, x.touch.stop, this.handleDragStop), (0, o.removeEvent)(C, x.touch.start, this.onTouchStart, {
          passive: !1
        }), this.props.enableUserSelectHack && (0, o.removeUserSelectStyles)(z);
      }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() {
      var C, z;
      return (C = this.props) !== null && C !== void 0 && C.nodeRef ? (z = this.props) === null || z === void 0 || (z = z.nodeRef) === null || z === void 0 ? void 0 : z.current : n.default.findDOMNode(this);
    }
    render() {
      return /* @__PURE__ */ e.cloneElement(e.Children.only(this.props.children), {
        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        // onTouchStart is added on `componentDidMount` so they can be added with
        // {passive: false}, which allows it to cancel. See
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        onTouchEnd: this.onTouchEnd
      });
    }
  };
  return Gs.default = E, m(E, "displayName", "DraggableCore"), m(E, "propTypes", {
    /**
     * `allowAnyClick` allows dragging using any mouse button.
     * By default, we only accept the left button.
     *
     * Defaults to `false`.
     */
    allowAnyClick: t.default.bool,
    children: t.default.node.isRequired,
    /**
     * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
     * with the exception of `onMouseDown`, will not fire.
     */
    disabled: t.default.bool,
    /**
     * By default, we add 'user-select:none' attributes to the document body
     * to prevent ugly text selection during drag. If this is causing problems
     * for your app, set this to `false`.
     */
    enableUserSelectHack: t.default.bool,
    /**
     * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
     * instead of using the parent node.
     */
    offsetParent: function(T, C) {
      if (T[C] && T[C].nodeType !== 1)
        throw new Error("Draggable's offsetParent must be a DOM Node.");
    },
    /**
     * `grid` specifies the x and y that dragging should snap to.
     */
    grid: t.default.arrayOf(t.default.number),
    /**
     * `handle` specifies a selector to be used as the handle that initiates drag.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable handle=".handle">
     *              <div>
     *                  <div className="handle">Click me to drag</div>
     *                  <div>This is some other content</div>
     *              </div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    handle: t.default.string,
    /**
     * `cancel` specifies a selector to be used to prevent drag initialization.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *           return(
     *               <Draggable cancel=".cancel">
     *                   <div>
     *                     <div className="cancel">You can't drag from here</div>
     *                     <div>Dragging here works fine</div>
     *                   </div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    cancel: t.default.string,
    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
     * Unfortunately, in order for <Draggable> to work properly, we need raw access
     * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
     * as in this example:
     *
     * function MyComponent() {
     *   const nodeRef = React.useRef(null);
     *   return (
     *     <Draggable nodeRef={nodeRef}>
     *       <div ref={nodeRef}>Example Target</div>
     *     </Draggable>
     *   );
     * }
     *
     * This can be used for arbitrarily nested components, so long as the ref ends up
     * pointing to the actual child DOM node and not a custom component.
     */
    nodeRef: t.default.object,
    /**
     * Called when dragging starts.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onStart: t.default.func,
    /**
     * Called while dragging.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onDrag: t.default.func,
    /**
     * Called when dragging stops.
     * If this function returns the boolean false, the drag will remain active.
     */
    onStop: t.default.func,
    /**
     * A workaround option which can be passed if onMouseDown needs to be accessed,
     * since it'll always be blocked (as there is internal use of onMouseDown)
     */
    onMouseDown: t.default.func,
    /**
     * `scale`, if set, applies scaling while dragging an element
     */
    scale: t.default.number,
    /**
     * These properties should be defined on the child, not here.
     */
    className: l.dontSetMe,
    style: l.dontSetMe,
    transform: l.dontSetMe
  }), m(E, "defaultProps", {
    allowAnyClick: !1,
    // by default only accept left click
    disabled: !1,
    enableUserSelectHack: !0,
    onStart: function() {
    },
    onDrag: function() {
    },
    onStop: function() {
    },
    onMouseDown: function() {
    },
    scale: 1
  }), Gs;
}
var bS;
function vO() {
  return bS || (bS = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "DraggableCore", {
      enumerable: !0,
      get: function() {
        return d.default;
      }
    }), e.default = void 0;
    var t = b(zl()), n = m(/* @__PURE__ */ RE()), o = m(Tf()), a = m(pO), l = yg(), c = zE(), f = Cf(), d = m(gO()), h = m(DE());
    function m(z) {
      return z && z.__esModule ? z : { default: z };
    }
    function g(z) {
      if (typeof WeakMap != "function") return null;
      var A = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap();
      return (g = function(O) {
        return O ? R : A;
      })(z);
    }
    function b(z, A) {
      if (z && z.__esModule)
        return z;
      if (z === null || typeof z != "object" && typeof z != "function")
        return { default: z };
      var R = g(A);
      if (R && R.has(z))
        return R.get(z);
      var O = {}, L = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var M in z)
        if (M !== "default" && Object.prototype.hasOwnProperty.call(z, M)) {
          var N = L ? Object.getOwnPropertyDescriptor(z, M) : null;
          N && (N.get || N.set) ? Object.defineProperty(O, M, N) : O[M] = z[M];
        }
      return O.default = z, R && R.set(z, O), O;
    }
    function x() {
      return x = Object.assign ? Object.assign.bind() : function(z) {
        for (var A = 1; A < arguments.length; A++) {
          var R = arguments[A];
          for (var O in R)
            Object.prototype.hasOwnProperty.call(R, O) && (z[O] = R[O]);
        }
        return z;
      }, x.apply(this, arguments);
    }
    function _(z, A, R) {
      return A = E(A), A in z ? Object.defineProperty(z, A, { value: R, enumerable: !0, configurable: !0, writable: !0 }) : z[A] = R, z;
    }
    function E(z) {
      var A = T(z, "string");
      return typeof A == "symbol" ? A : String(A);
    }
    function T(z, A) {
      if (typeof z != "object" || z === null) return z;
      var R = z[Symbol.toPrimitive];
      if (R !== void 0) {
        var O = R.call(z, A);
        if (typeof O != "object") return O;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (A === "string" ? String : Number)(z);
    }
    class C extends t.Component {
      // React 16.3+
      // Arity (props, state)
      static getDerivedStateFromProps(A, R) {
        let {
          position: O
        } = A, {
          prevPropsPosition: L
        } = R;
        return O && (!L || O.x !== L.x || O.y !== L.y) ? ((0, h.default)("Draggable: getDerivedStateFromProps %j", {
          position: O,
          prevPropsPosition: L
        }), {
          x: O.x,
          y: O.y,
          prevPropsPosition: {
            ...O
          }
        }) : null;
      }
      constructor(A) {
        super(A), _(this, "onDragStart", (R, O) => {
          if ((0, h.default)("Draggable: onDragStart: %j", O), this.props.onStart(R, (0, c.createDraggableData)(this, O)) === !1) return !1;
          this.setState({
            dragging: !0,
            dragged: !0
          });
        }), _(this, "onDrag", (R, O) => {
          if (!this.state.dragging) return !1;
          (0, h.default)("Draggable: onDrag: %j", O);
          const L = (0, c.createDraggableData)(this, O), M = {
            x: L.x,
            y: L.y,
            slackX: 0,
            slackY: 0
          };
          if (this.props.bounds) {
            const {
              x: j,
              y: Y
            } = M;
            M.x += this.state.slackX, M.y += this.state.slackY;
            const [ne, J] = (0, c.getBoundPosition)(this, M.x, M.y);
            M.x = ne, M.y = J, M.slackX = this.state.slackX + (j - M.x), M.slackY = this.state.slackY + (Y - M.y), L.x = M.x, L.y = M.y, L.deltaX = M.x - this.state.x, L.deltaY = M.y - this.state.y;
          }
          if (this.props.onDrag(R, L) === !1) return !1;
          this.setState(M);
        }), _(this, "onDragStop", (R, O) => {
          if (!this.state.dragging || this.props.onStop(R, (0, c.createDraggableData)(this, O)) === !1) return !1;
          (0, h.default)("Draggable: onDragStop: %j", O);
          const M = {
            dragging: !1,
            slackX: 0,
            slackY: 0
          };
          if (!!this.props.position) {
            const {
              x: j,
              y: Y
            } = this.props.position;
            M.x = j, M.y = Y;
          }
          this.setState(M);
        }), this.state = {
          // Whether or not we are currently dragging.
          dragging: !1,
          // Whether or not we have been dragged before.
          dragged: !1,
          // Current transform x and y.
          x: A.position ? A.position.x : A.defaultPosition.x,
          y: A.position ? A.position.y : A.defaultPosition.y,
          prevPropsPosition: {
            ...A.position
          },
          // Used for compensating for out-of-bounds drags
          slackX: 0,
          slackY: 0,
          // Can only determine if SVG after mounting
          isElementSVG: !1
        }, A.position && !(A.onDrag || A.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
      }
      componentDidMount() {
        typeof window.SVGElement < "u" && this.findDOMNode() instanceof window.SVGElement && this.setState({
          isElementSVG: !0
        });
      }
      componentWillUnmount() {
        this.setState({
          dragging: !1
        });
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        var A, R;
        return (A = (R = this.props) === null || R === void 0 || (R = R.nodeRef) === null || R === void 0 ? void 0 : R.current) !== null && A !== void 0 ? A : o.default.findDOMNode(this);
      }
      render() {
        const {
          axis: A,
          bounds: R,
          children: O,
          defaultPosition: L,
          defaultClassName: M,
          defaultClassNameDragging: N,
          defaultClassNameDragged: j,
          position: Y,
          positionOffset: ne,
          scale: J,
          ...he
        } = this.props;
        let fe = {}, de = null;
        const G = !!!Y || this.state.dragging, B = Y || L, te = {
          // Set left if horizontal drag is enabled
          x: (0, c.canDragX)(this) && G ? this.state.x : B.x,
          // Set top if vertical drag is enabled
          y: (0, c.canDragY)(this) && G ? this.state.y : B.y
        };
        this.state.isElementSVG ? de = (0, l.createSVGTransform)(te, ne) : fe = (0, l.createCSSTransform)(te, ne);
        const ae = (0, a.default)(O.props.className || "", M, {
          [N]: this.state.dragging,
          [j]: this.state.dragged
        });
        return /* @__PURE__ */ t.createElement(d.default, x({}, he, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), /* @__PURE__ */ t.cloneElement(t.Children.only(O), {
          className: ae,
          style: {
            ...O.props.style,
            ...fe
          },
          transform: de
        }));
      }
    }
    e.default = C, _(C, "displayName", "Draggable"), _(C, "propTypes", {
      // Accepts all props <DraggableCore> accepts.
      ...d.default.propTypes,
      /**
       * `axis` determines which axis the draggable can move.
       *
       *  Note that all callbacks will still return data as normal. This only
       *  controls flushing to the DOM.
       *
       * 'both' allows movement horizontally and vertically.
       * 'x' limits movement to horizontal axis.
       * 'y' limits movement to vertical axis.
       * 'none' limits all movement.
       *
       * Defaults to 'both'.
       */
      axis: n.default.oneOf(["both", "x", "y", "none"]),
      /**
       * `bounds` determines the range of movement available to the element.
       * Available values are:
       *
       * 'parent' restricts movement within the Draggable's parent node.
       *
       * Alternatively, pass an object with the following properties, all of which are optional:
       *
       * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
       *
       * All values are in px.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable bounds={{right: 300, bottom: 300}}>
       *              <div>Content</div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      bounds: n.default.oneOfType([n.default.shape({
        left: n.default.number,
        right: n.default.number,
        top: n.default.number,
        bottom: n.default.number
      }), n.default.string, n.default.oneOf([!1])]),
      defaultClassName: n.default.string,
      defaultClassNameDragging: n.default.string,
      defaultClassNameDragged: n.default.string,
      /**
       * `defaultPosition` specifies the x and y that the dragged item should start at
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable defaultPosition={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      defaultPosition: n.default.shape({
        x: n.default.number,
        y: n.default.number
      }),
      positionOffset: n.default.shape({
        x: n.default.oneOfType([n.default.number, n.default.string]),
        y: n.default.oneOfType([n.default.number, n.default.string])
      }),
      /**
       * `position`, if present, defines the current position of the element.
       *
       *  This is similar to how form elements in React work - if no `position` is supplied, the component
       *  is uncontrolled.
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable position={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      position: n.default.shape({
        x: n.default.number,
        y: n.default.number
      }),
      /**
       * These properties should be defined on the child, not here.
       */
      className: f.dontSetMe,
      style: f.dontSetMe,
      transform: f.dontSetMe
    }), _(C, "defaultProps", {
      ...d.default.defaultProps,
      axis: "both",
      bounds: !1,
      defaultClassName: "react-draggable",
      defaultClassNameDragging: "react-draggable-dragging",
      defaultClassNameDragged: "react-draggable-dragged",
      defaultPosition: {
        x: 0,
        y: 0
      },
      scale: 1
    });
  })(Cp)), Cp;
}
var xS;
function yO() {
  if (xS) return Fs.exports;
  xS = 1;
  const {
    default: e,
    DraggableCore: t
  } = vO();
  return Fs.exports = e, Fs.exports.default = e, Fs.exports.DraggableCore = t, Fs.exports;
}
var bO = yO();
const xO = /* @__PURE__ */ Ml(bO);
var Tt = function() {
  return Tt = Object.assign || function(e) {
    for (var t, n = 1, o = arguments.length; n < o; n++) {
      t = arguments[n];
      for (var a in t) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
    }
    return e;
  }, Tt.apply(this, arguments);
}, SS = {
  width: "100%",
  height: "10px",
  top: "0px",
  left: "0px",
  cursor: "row-resize"
}, wS = {
  width: "10px",
  height: "100%",
  top: "0px",
  left: "0px",
  cursor: "col-resize"
}, lu = {
  width: "20px",
  height: "20px",
  position: "absolute",
  zIndex: 1
}, SO = {
  top: Tt(Tt({}, SS), { top: "-5px" }),
  right: Tt(Tt({}, wS), { left: void 0, right: "-5px" }),
  bottom: Tt(Tt({}, SS), { top: void 0, bottom: "-5px" }),
  left: Tt(Tt({}, wS), { left: "-5px" }),
  topRight: Tt(Tt({}, lu), { right: "-10px", top: "-10px", cursor: "ne-resize" }),
  bottomRight: Tt(Tt({}, lu), { right: "-10px", bottom: "-10px", cursor: "se-resize" }),
  bottomLeft: Tt(Tt({}, lu), { left: "-10px", bottom: "-10px", cursor: "sw-resize" }),
  topLeft: Tt(Tt({}, lu), { left: "-10px", top: "-10px", cursor: "nw-resize" })
}, wO = y.memo(function(e) {
  var t = e.onResizeStart, n = e.direction, o = e.children, a = e.replaceStyles, l = e.className, c = y.useCallback(function(h) {
    t(h, n);
  }, [t, n]), f = y.useCallback(function(h) {
    t(h, n);
  }, [t, n]), d = y.useMemo(function() {
    return Tt(Tt({ position: "absolute", userSelect: "none" }, SO[n]), a ?? {});
  }, [a, n]);
  return S.jsx("div", { className: l || void 0, style: d, onMouseDown: c, onTouchStart: f, children: o });
}), EO = /* @__PURE__ */ (function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {
      o.__proto__ = a;
    } || function(o, a) {
      for (var l in a) Object.prototype.hasOwnProperty.call(a, l) && (o[l] = a[l]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function o() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (o.prototype = n.prototype, new o());
  };
})(), lr = function() {
  return lr = Object.assign || function(e) {
    for (var t, n = 1, o = arguments.length; n < o; n++) {
      t = arguments[n];
      for (var a in t) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
    }
    return e;
  }, lr.apply(this, arguments);
}, _O = {
  width: "auto",
  height: "auto"
}, cu = function(e, t, n) {
  return Math.max(Math.min(e, n), t);
}, ES = function(e, t, n) {
  var o = Math.round(e / t);
  return o * t + n * (o - 1);
}, ua = function(e, t) {
  return new RegExp(e, "i").test(t);
}, uu = function(e) {
  return !!(e.touches && e.touches.length);
}, TO = function(e) {
  return !!((e.clientX || e.clientX === 0) && (e.clientY || e.clientY === 0));
}, _S = function(e, t, n) {
  n === void 0 && (n = 0);
  var o = t.reduce(function(l, c, f) {
    return Math.abs(c - e) < Math.abs(t[l] - e) ? f : l;
  }, 0), a = Math.abs(t[o] - e);
  return n === 0 || a < n ? t[o] : e;
}, zp = function(e) {
  return e = e.toString(), e === "auto" || e.endsWith("px") || e.endsWith("%") || e.endsWith("vh") || e.endsWith("vw") || e.endsWith("vmax") || e.endsWith("vmin") ? e : "".concat(e, "px");
}, fu = function(e, t, n, o) {
  if (e && typeof e == "string") {
    if (e.endsWith("px"))
      return Number(e.replace("px", ""));
    if (e.endsWith("%")) {
      var a = Number(e.replace("%", "")) / 100;
      return t * a;
    }
    if (e.endsWith("vw")) {
      var a = Number(e.replace("vw", "")) / 100;
      return n * a;
    }
    if (e.endsWith("vh")) {
      var a = Number(e.replace("vh", "")) / 100;
      return o * a;
    }
  }
  return e;
}, CO = function(e, t, n, o, a, l, c) {
  return o = fu(o, e.width, t, n), a = fu(a, e.height, t, n), l = fu(l, e.width, t, n), c = fu(c, e.height, t, n), {
    maxWidth: typeof o > "u" ? void 0 : Number(o),
    maxHeight: typeof a > "u" ? void 0 : Number(a),
    minWidth: typeof l > "u" ? void 0 : Number(l),
    minHeight: typeof c > "u" ? void 0 : Number(c)
  };
}, AO = function(e) {
  return Array.isArray(e) ? e : [e, e];
}, RO = [
  "as",
  "ref",
  "style",
  "className",
  "grid",
  "gridGap",
  "snap",
  "bounds",
  "boundsByDirection",
  "size",
  "defaultSize",
  "minWidth",
  "minHeight",
  "maxWidth",
  "maxHeight",
  "lockAspectRatio",
  "lockAspectRatioExtraWidth",
  "lockAspectRatioExtraHeight",
  "enable",
  "handleStyles",
  "handleClasses",
  "handleWrapperStyle",
  "handleWrapperClass",
  "children",
  "onResizeStart",
  "onResize",
  "onResizeStop",
  "handleComponent",
  "scale",
  "resizeRatio",
  "snapGap"
], TS = "__resizable_base__", MO = (
  /** @class */
  (function(e) {
    EO(t, e);
    function t(n) {
      var o, a, l, c, f = e.call(this, n) || this;
      return f.ratio = 1, f.resizable = null, f.parentLeft = 0, f.parentTop = 0, f.resizableLeft = 0, f.resizableRight = 0, f.resizableTop = 0, f.resizableBottom = 0, f.targetLeft = 0, f.targetTop = 0, f.delta = {
        width: 0,
        height: 0
      }, f.appendBase = function() {
        if (!f.resizable || !f.window)
          return null;
        var d = f.parentNode;
        if (!d)
          return null;
        var h = f.window.document.createElement("div");
        return h.style.width = "100%", h.style.height = "100%", h.style.position = "absolute", h.style.transform = "scale(0, 0)", h.style.left = "0", h.style.flex = "0 0 100%", h.classList ? h.classList.add(TS) : h.className += TS, d.appendChild(h), h;
      }, f.removeBase = function(d) {
        var h = f.parentNode;
        h && h.removeChild(d);
      }, f.state = {
        isResizing: !1,
        width: (a = (o = f.propsSize) === null || o === void 0 ? void 0 : o.width) !== null && a !== void 0 ? a : "auto",
        height: (c = (l = f.propsSize) === null || l === void 0 ? void 0 : l.height) !== null && c !== void 0 ? c : "auto",
        direction: "right",
        original: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        backgroundStyle: {
          height: "100%",
          width: "100%",
          backgroundColor: "rgba(0,0,0,0)",
          cursor: "auto",
          opacity: 0,
          position: "fixed",
          zIndex: 9999,
          top: "0",
          left: "0",
          bottom: "0",
          right: "0"
        },
        flexBasis: void 0
      }, f.onResizeStart = f.onResizeStart.bind(f), f.onMouseMove = f.onMouseMove.bind(f), f.onMouseUp = f.onMouseUp.bind(f), f;
    }
    return Object.defineProperty(t.prototype, "parentNode", {
      get: function() {
        return this.resizable ? this.resizable.parentNode : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "window", {
      get: function() {
        return !this.resizable || !this.resizable.ownerDocument ? null : this.resizable.ownerDocument.defaultView;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "propsSize", {
      get: function() {
        return this.props.size || this.props.defaultSize || _O;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "size", {
      get: function() {
        var n = 0, o = 0;
        if (this.resizable && this.window) {
          var a = this.resizable.offsetWidth, l = this.resizable.offsetHeight, c = this.resizable.style.position;
          c !== "relative" && (this.resizable.style.position = "relative"), n = this.resizable.style.width !== "auto" ? this.resizable.offsetWidth : a, o = this.resizable.style.height !== "auto" ? this.resizable.offsetHeight : l, this.resizable.style.position = c;
        }
        return { width: n, height: o };
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "sizeStyle", {
      get: function() {
        var n = this, o = this.props.size, a = function(f) {
          var d;
          if (typeof n.state[f] > "u" || n.state[f] === "auto")
            return "auto";
          if (n.propsSize && n.propsSize[f] && (!((d = n.propsSize[f]) === null || d === void 0) && d.toString().endsWith("%"))) {
            if (n.state[f].toString().endsWith("%"))
              return n.state[f].toString();
            var h = n.getParentSize(), m = Number(n.state[f].toString().replace("px", "")), g = m / h[f] * 100;
            return "".concat(g, "%");
          }
          return zp(n.state[f]);
        }, l = o && typeof o.width < "u" && !this.state.isResizing ? zp(o.width) : a("width"), c = o && typeof o.height < "u" && !this.state.isResizing ? zp(o.height) : a("height");
        return { width: l, height: c };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.getParentSize = function() {
      if (!this.parentNode)
        return this.window ? { width: this.window.innerWidth, height: this.window.innerHeight } : { width: 0, height: 0 };
      var n = this.appendBase();
      if (!n)
        return { width: 0, height: 0 };
      var o = !1, a = this.parentNode.style.flexWrap;
      a !== "wrap" && (o = !0, this.parentNode.style.flexWrap = "wrap"), n.style.position = "relative", n.style.minWidth = "100%", n.style.minHeight = "100%";
      var l = {
        width: n.offsetWidth,
        height: n.offsetHeight
      };
      return o && (this.parentNode.style.flexWrap = a), this.removeBase(n), l;
    }, t.prototype.bindEvents = function() {
      this.window && (this.window.addEventListener("mouseup", this.onMouseUp), this.window.addEventListener("mousemove", this.onMouseMove), this.window.addEventListener("mouseleave", this.onMouseUp), this.window.addEventListener("touchmove", this.onMouseMove, {
        capture: !0,
        passive: !1
      }), this.window.addEventListener("touchend", this.onMouseUp));
    }, t.prototype.unbindEvents = function() {
      this.window && (this.window.removeEventListener("mouseup", this.onMouseUp), this.window.removeEventListener("mousemove", this.onMouseMove), this.window.removeEventListener("mouseleave", this.onMouseUp), this.window.removeEventListener("touchmove", this.onMouseMove, !0), this.window.removeEventListener("touchend", this.onMouseUp));
    }, t.prototype.componentDidMount = function() {
      if (!(!this.resizable || !this.window)) {
        var n = this.window.getComputedStyle(this.resizable);
        this.setState({
          width: this.state.width || this.size.width,
          height: this.state.height || this.size.height,
          flexBasis: n.flexBasis !== "auto" ? n.flexBasis : void 0
        });
      }
    }, t.prototype.componentWillUnmount = function() {
      this.window && this.unbindEvents();
    }, t.prototype.createSizeForCssProperty = function(n, o) {
      var a = this.propsSize && this.propsSize[o];
      return this.state[o] === "auto" && this.state.original[o] === n && (typeof a > "u" || a === "auto") ? "auto" : n;
    }, t.prototype.calculateNewMaxFromBoundary = function(n, o) {
      var a = this.props.boundsByDirection, l = this.state.direction, c = a && ua("left", l), f = a && ua("top", l), d, h;
      if (this.props.bounds === "parent") {
        var m = this.parentNode;
        m && (d = c ? this.resizableRight - this.parentLeft : m.offsetWidth + (this.parentLeft - this.resizableLeft), h = f ? this.resizableBottom - this.parentTop : m.offsetHeight + (this.parentTop - this.resizableTop));
      } else this.props.bounds === "window" ? this.window && (d = c ? this.resizableRight : this.window.innerWidth - this.resizableLeft, h = f ? this.resizableBottom : this.window.innerHeight - this.resizableTop) : this.props.bounds && (d = c ? this.resizableRight - this.targetLeft : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft), h = f ? this.resizableBottom - this.targetTop : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop));
      return d && Number.isFinite(d) && (n = n && n < d ? n : d), h && Number.isFinite(h) && (o = o && o < h ? o : h), { maxWidth: n, maxHeight: o };
    }, t.prototype.calculateNewSizeFromDirection = function(n, o) {
      var a = this.props.scale || 1, l = AO(this.props.resizeRatio || 1), c = l[0], f = l[1], d = this.state, h = d.direction, m = d.original, g = this.props, b = g.lockAspectRatio, x = g.lockAspectRatioExtraHeight, _ = g.lockAspectRatioExtraWidth, E = m.width, T = m.height, C = x || 0, z = _ || 0;
      return ua("right", h) && (E = m.width + (n - m.x) * c / a, b && (T = (E - z) / this.ratio + C)), ua("left", h) && (E = m.width - (n - m.x) * c / a, b && (T = (E - z) / this.ratio + C)), ua("bottom", h) && (T = m.height + (o - m.y) * f / a, b && (E = (T - C) * this.ratio + z)), ua("top", h) && (T = m.height - (o - m.y) * f / a, b && (E = (T - C) * this.ratio + z)), { newWidth: E, newHeight: T };
    }, t.prototype.calculateNewSizeFromAspectRatio = function(n, o, a, l) {
      var c = this.props, f = c.lockAspectRatio, d = c.lockAspectRatioExtraHeight, h = c.lockAspectRatioExtraWidth, m = typeof l.width > "u" ? 10 : l.width, g = typeof a.width > "u" || a.width < 0 ? n : a.width, b = typeof l.height > "u" ? 10 : l.height, x = typeof a.height > "u" || a.height < 0 ? o : a.height, _ = d || 0, E = h || 0;
      if (f) {
        var T = (b - _) * this.ratio + E, C = (x - _) * this.ratio + E, z = (m - E) / this.ratio + _, A = (g - E) / this.ratio + _, R = Math.max(m, T), O = Math.min(g, C), L = Math.max(b, z), M = Math.min(x, A);
        n = cu(n, R, O), o = cu(o, L, M);
      } else
        n = cu(n, m, g), o = cu(o, b, x);
      return { newWidth: n, newHeight: o };
    }, t.prototype.setBoundingClientRect = function() {
      var n = 1 / (this.props.scale || 1);
      if (this.props.bounds === "parent") {
        var o = this.parentNode;
        if (o) {
          var a = o.getBoundingClientRect();
          this.parentLeft = a.left * n, this.parentTop = a.top * n;
        }
      }
      if (this.props.bounds && typeof this.props.bounds != "string") {
        var l = this.props.bounds.getBoundingClientRect();
        this.targetLeft = l.left * n, this.targetTop = l.top * n;
      }
      if (this.resizable) {
        var c = this.resizable.getBoundingClientRect(), f = c.left, d = c.top, h = c.right, m = c.bottom;
        this.resizableLeft = f * n, this.resizableRight = h * n, this.resizableTop = d * n, this.resizableBottom = m * n;
      }
    }, t.prototype.onResizeStart = function(n, o) {
      if (!(!this.resizable || !this.window)) {
        var a = 0, l = 0;
        if (n.nativeEvent && TO(n.nativeEvent) ? (a = n.nativeEvent.clientX, l = n.nativeEvent.clientY) : n.nativeEvent && uu(n.nativeEvent) && (a = n.nativeEvent.touches[0].clientX, l = n.nativeEvent.touches[0].clientY), this.props.onResizeStart && this.resizable) {
          var c = this.props.onResizeStart(n, o, this.resizable);
          if (c === !1)
            return;
        }
        this.props.size && (typeof this.props.size.height < "u" && this.props.size.height !== this.state.height && this.setState({ height: this.props.size.height }), typeof this.props.size.width < "u" && this.props.size.width !== this.state.width && this.setState({ width: this.props.size.width })), this.ratio = typeof this.props.lockAspectRatio == "number" ? this.props.lockAspectRatio : this.size.width / this.size.height;
        var f, d = this.window.getComputedStyle(this.resizable);
        if (d.flexBasis !== "auto") {
          var h = this.parentNode;
          if (h) {
            var m = this.window.getComputedStyle(h).flexDirection;
            this.flexDir = m.startsWith("row") ? "row" : "column", f = d.flexBasis;
          }
        }
        this.setBoundingClientRect(), this.bindEvents();
        var g = {
          original: {
            x: a,
            y: l,
            width: this.size.width,
            height: this.size.height
          },
          isResizing: !0,
          backgroundStyle: lr(lr({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(n.target).cursor || "auto" }),
          direction: o,
          flexBasis: f
        };
        this.setState(g);
      }
    }, t.prototype.onMouseMove = function(n) {
      var o = this;
      if (!(!this.state.isResizing || !this.resizable || !this.window)) {
        if (this.window.TouchEvent && uu(n))
          try {
            n.preventDefault(), n.stopPropagation();
          } catch {
          }
        var a = this.props, l = a.maxWidth, c = a.maxHeight, f = a.minWidth, d = a.minHeight, h = uu(n) ? n.touches[0].clientX : n.clientX, m = uu(n) ? n.touches[0].clientY : n.clientY, g = this.state, b = g.direction, x = g.original, _ = g.width, E = g.height, T = this.getParentSize(), C = CO(T, this.window.innerWidth, this.window.innerHeight, l, c, f, d);
        l = C.maxWidth, c = C.maxHeight, f = C.minWidth, d = C.minHeight;
        var z = this.calculateNewSizeFromDirection(h, m), A = z.newHeight, R = z.newWidth, O = this.calculateNewMaxFromBoundary(l, c);
        this.props.snap && this.props.snap.x && (R = _S(R, this.props.snap.x, this.props.snapGap)), this.props.snap && this.props.snap.y && (A = _S(A, this.props.snap.y, this.props.snapGap));
        var L = this.calculateNewSizeFromAspectRatio(R, A, { width: O.maxWidth, height: O.maxHeight }, { width: f, height: d });
        if (R = L.newWidth, A = L.newHeight, this.props.grid) {
          var M = ES(R, this.props.grid[0], this.props.gridGap ? this.props.gridGap[0] : 0), N = ES(A, this.props.grid[1], this.props.gridGap ? this.props.gridGap[1] : 0), j = this.props.snapGap || 0, Y = j === 0 || Math.abs(M - R) <= j ? M : R, ne = j === 0 || Math.abs(N - A) <= j ? N : A;
          R = Y, A = ne;
        }
        var J = {
          width: R - x.width,
          height: A - x.height
        };
        if (this.delta = J, _ && typeof _ == "string") {
          if (_.endsWith("%")) {
            var he = R / T.width * 100;
            R = "".concat(he, "%");
          } else if (_.endsWith("vw")) {
            var fe = R / this.window.innerWidth * 100;
            R = "".concat(fe, "vw");
          } else if (_.endsWith("vh")) {
            var de = R / this.window.innerHeight * 100;
            R = "".concat(de, "vh");
          }
        }
        if (E && typeof E == "string") {
          if (E.endsWith("%")) {
            var he = A / T.height * 100;
            A = "".concat(he, "%");
          } else if (E.endsWith("vw")) {
            var fe = A / this.window.innerWidth * 100;
            A = "".concat(fe, "vw");
          } else if (E.endsWith("vh")) {
            var de = A / this.window.innerHeight * 100;
            A = "".concat(de, "vh");
          }
        }
        var I = {
          width: this.createSizeForCssProperty(R, "width"),
          height: this.createSizeForCssProperty(A, "height")
        };
        this.flexDir === "row" ? I.flexBasis = I.width : this.flexDir === "column" && (I.flexBasis = I.height);
        var G = this.state.width !== I.width, B = this.state.height !== I.height, te = this.state.flexBasis !== I.flexBasis, ae = G || B || te;
        ae && Po.flushSync(function() {
          o.setState(I);
        }), this.props.onResize && ae && this.props.onResize(n, b, this.resizable, J);
      }
    }, t.prototype.onMouseUp = function(n) {
      var o, a, l = this.state, c = l.isResizing, f = l.direction;
      l.original, !(!c || !this.resizable) && (this.props.onResizeStop && this.props.onResizeStop(n, f, this.resizable, this.delta), this.props.size && this.setState({ width: (o = this.props.size.width) !== null && o !== void 0 ? o : "auto", height: (a = this.props.size.height) !== null && a !== void 0 ? a : "auto" }), this.unbindEvents(), this.setState({
        isResizing: !1,
        backgroundStyle: lr(lr({}, this.state.backgroundStyle), { cursor: "auto" })
      }));
    }, t.prototype.updateSize = function(n) {
      var o, a;
      this.setState({ width: (o = n.width) !== null && o !== void 0 ? o : "auto", height: (a = n.height) !== null && a !== void 0 ? a : "auto" });
    }, t.prototype.renderResizer = function() {
      var n = this, o = this.props, a = o.enable, l = o.handleStyles, c = o.handleClasses, f = o.handleWrapperStyle, d = o.handleWrapperClass, h = o.handleComponent;
      if (!a)
        return null;
      var m = Object.keys(a).map(function(g) {
        return a[g] !== !1 ? S.jsx(wO, { direction: g, onResizeStart: n.onResizeStart, replaceStyles: l && l[g], className: c && c[g], children: h && h[g] ? h[g] : null }, g) : null;
      });
      return S.jsx("div", { className: d, style: f, children: m });
    }, t.prototype.render = function() {
      var n = this, o = Object.keys(this.props).reduce(function(c, f) {
        return RO.indexOf(f) !== -1 || (c[f] = n.props[f]), c;
      }, {}), a = lr(lr(lr({ position: "relative", userSelect: this.state.isResizing ? "none" : "auto" }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: "border-box", flexShrink: 0 });
      this.state.flexBasis && (a.flexBasis = this.state.flexBasis);
      var l = this.props.as || "div";
      return S.jsxs(l, lr({ style: a, className: this.props.className }, o, {
        // `ref` is after `extendsProps` to ensure this one wins over a version
        // passed in
        ref: function(c) {
          c && (n.resizable = c);
        },
        children: [this.state.isResizing && S.jsx("div", { style: this.state.backgroundStyle }), this.props.children, this.renderResizer()]
      }));
    }, t.defaultProps = {
      as: "div",
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      enable: {
        top: !0,
        right: !0,
        bottom: !0,
        left: !0,
        topRight: !0,
        bottomRight: !0,
        bottomLeft: !0,
        topLeft: !0
      },
      style: {},
      grid: [1, 1],
      gridGap: [0, 0],
      lockAspectRatio: !1,
      lockAspectRatioExtraWidth: 0,
      lockAspectRatioExtraHeight: 0,
      scale: 1,
      resizeRatio: 1,
      snapGap: 0
    }, t;
  })(y.PureComponent)
);
var Sm = function(e, t) {
  return Sm = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, o) {
    n.__proto__ = o;
  } || function(n, o) {
    for (var a in o) o.hasOwnProperty(a) && (n[a] = o[a]);
  }, Sm(e, t);
};
function zO(e, t) {
  Sm(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Mt = function() {
  return Mt = Object.assign || function(t) {
    for (var n, o = 1, a = arguments.length; o < a; o++) {
      n = arguments[o];
      for (var l in n) Object.prototype.hasOwnProperty.call(n, l) && (t[l] = n[l]);
    }
    return t;
  }, Mt.apply(this, arguments);
};
function DO(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, o = Object.getOwnPropertySymbols(e); a < o.length; a++)
      t.indexOf(o[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[a]) && (n[o[a]] = e[o[a]]);
  return n;
}
var NO = {
  width: "auto",
  height: "auto",
  display: "inline-block",
  position: "absolute",
  top: 0,
  left: 0
}, OO = function(e) {
  return {
    bottom: e,
    bottomLeft: e,
    bottomRight: e,
    left: e,
    right: e,
    top: e,
    topLeft: e,
    topRight: e
  };
}, jO = (
  /** @class */
  (function(e) {
    zO(t, e);
    function t(n) {
      var o = e.call(this, n) || this;
      return o.resizingPosition = { x: 0, y: 0 }, o.offsetFromParent = { left: 0, top: 0 }, o.resizableElement = { current: null }, o.originalPosition = { x: 0, y: 0 }, o.state = {
        resizing: !1,
        bounds: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        },
        maxWidth: n.maxWidth,
        maxHeight: n.maxHeight
      }, o.onResizeStart = o.onResizeStart.bind(o), o.onResize = o.onResize.bind(o), o.onResizeStop = o.onResizeStop.bind(o), o.onDragStart = o.onDragStart.bind(o), o.onDrag = o.onDrag.bind(o), o.onDragStop = o.onDragStop.bind(o), o.getMaxSizesFromProps = o.getMaxSizesFromProps.bind(o), o;
    }
    return t.prototype.componentDidMount = function() {
      this.updateOffsetFromParent();
      var n = this.offsetFromParent, o = n.left, a = n.top, l = this.getDraggablePosition(), c = l.x, f = l.y;
      this.draggable.setState({
        x: c - o,
        y: f - a
      }), this.forceUpdate();
    }, t.prototype.getDraggablePosition = function() {
      var n = this.draggable.state, o = n.x, a = n.y;
      return { x: o, y: a };
    }, t.prototype.getParent = function() {
      return this.resizable && this.resizable.parentNode;
    }, t.prototype.getParentSize = function() {
      return this.resizable.getParentSize();
    }, t.prototype.getMaxSizesFromProps = function() {
      var n = typeof this.props.maxWidth > "u" ? Number.MAX_SAFE_INTEGER : this.props.maxWidth, o = typeof this.props.maxHeight > "u" ? Number.MAX_SAFE_INTEGER : this.props.maxHeight;
      return { maxWidth: n, maxHeight: o };
    }, t.prototype.getSelfElement = function() {
      return this.resizable && this.resizable.resizable;
    }, t.prototype.getOffsetHeight = function(n) {
      var o = this.props.scale;
      switch (this.props.bounds) {
        case "window":
          return window.innerHeight / o;
        case "body":
          return document.body.offsetHeight / o;
        default:
          return n.offsetHeight;
      }
    }, t.prototype.getOffsetWidth = function(n) {
      var o = this.props.scale;
      switch (this.props.bounds) {
        case "window":
          return window.innerWidth / o;
        case "body":
          return document.body.offsetWidth / o;
        default:
          return n.offsetWidth;
      }
    }, t.prototype.onDragStart = function(n, o) {
      this.props.onDragStart && this.props.onDragStart(n, o);
      var a = this.getDraggablePosition();
      if (this.originalPosition = a, !!this.props.bounds) {
        var l = this.getParent(), c = this.props.scale, f;
        if (this.props.bounds === "parent")
          f = l;
        else if (this.props.bounds === "body") {
          var d = l.getBoundingClientRect(), h = d.left, m = d.top, g = document.body.getBoundingClientRect(), b = -(h - l.offsetLeft * c - g.left) / c, x = -(m - l.offsetTop * c - g.top) / c, _ = (document.body.offsetWidth - this.resizable.size.width * c) / c + b, E = (document.body.offsetHeight - this.resizable.size.height * c) / c + x;
          return this.setState({ bounds: { top: x, right: _, bottom: E, left: b } });
        } else if (this.props.bounds === "window") {
          if (!this.resizable)
            return;
          var T = l.getBoundingClientRect(), C = T.left, z = T.top, A = -(C - l.offsetLeft * c) / c, R = -(z - l.offsetTop * c) / c, _ = (window.innerWidth - this.resizable.size.width * c) / c + A, E = (window.innerHeight - this.resizable.size.height * c) / c + R;
          return this.setState({ bounds: { top: R, right: _, bottom: E, left: A } });
        } else typeof this.props.bounds == "string" ? f = document.querySelector(this.props.bounds) : this.props.bounds instanceof HTMLElement && (f = this.props.bounds);
        if (!(!(f instanceof HTMLElement) || !(l instanceof HTMLElement))) {
          var O = f.getBoundingClientRect(), L = O.left, M = O.top, N = l.getBoundingClientRect(), j = N.left, Y = N.top, ne = (L - j) / c, J = M - Y;
          if (this.resizable) {
            this.updateOffsetFromParent();
            var he = this.offsetFromParent;
            this.setState({
              bounds: {
                top: J - he.top,
                right: ne + (f.offsetWidth - this.resizable.size.width) - he.left / c,
                bottom: J + (f.offsetHeight - this.resizable.size.height) - he.top,
                left: ne - he.left / c
              }
            });
          }
        }
      }
    }, t.prototype.onDrag = function(n, o) {
      if (this.props.onDrag) {
        var a = this.offsetFromParent, l = a.left, c = a.top;
        if (!this.props.dragAxis || this.props.dragAxis === "both")
          return this.props.onDrag(n, Mt(Mt({}, o), { x: o.x + l, y: o.y + c }));
        if (this.props.dragAxis === "x")
          return this.props.onDrag(n, Mt(Mt({}, o), { x: o.x + l, y: this.originalPosition.y + c, deltaY: 0 }));
        if (this.props.dragAxis === "y")
          return this.props.onDrag(n, Mt(Mt({}, o), { x: this.originalPosition.x + l, y: o.y + c, deltaX: 0 }));
      }
    }, t.prototype.onDragStop = function(n, o) {
      if (this.props.onDragStop) {
        var a = this.offsetFromParent, l = a.left, c = a.top;
        if (!this.props.dragAxis || this.props.dragAxis === "both")
          return this.props.onDragStop(n, Mt(Mt({}, o), { x: o.x + l, y: o.y + c }));
        if (this.props.dragAxis === "x")
          return this.props.onDragStop(n, Mt(Mt({}, o), { x: o.x + l, y: this.originalPosition.y + c, deltaY: 0 }));
        if (this.props.dragAxis === "y")
          return this.props.onDragStop(n, Mt(Mt({}, o), { x: this.originalPosition.x + l, y: o.y + c, deltaX: 0 }));
      }
    }, t.prototype.onResizeStart = function(n, o, a) {
      n.stopPropagation(), this.setState({
        resizing: !0
      });
      var l = this.props.scale, c = this.offsetFromParent, f = this.getDraggablePosition();
      if (this.resizingPosition = { x: f.x + c.left, y: f.y + c.top }, this.originalPosition = f, this.props.bounds) {
        var d = this.getParent(), h = void 0;
        this.props.bounds === "parent" ? h = d : this.props.bounds === "body" ? h = document.body : this.props.bounds === "window" ? h = window : typeof this.props.bounds == "string" ? h = document.querySelector(this.props.bounds) : this.props.bounds instanceof HTMLElement && (h = this.props.bounds);
        var m = this.getSelfElement();
        if (m instanceof Element && (h instanceof HTMLElement || h === window) && d instanceof HTMLElement) {
          var g = this.getMaxSizesFromProps(), b = g.maxWidth, x = g.maxHeight, _ = this.getParentSize();
          if (b && typeof b == "string")
            if (b.endsWith("%")) {
              var E = Number(b.replace("%", "")) / 100;
              b = _.width * E;
            } else b.endsWith("px") && (b = Number(b.replace("px", "")));
          if (x && typeof x == "string")
            if (x.endsWith("%")) {
              var E = Number(x.replace("%", "")) / 100;
              x = _.height * E;
            } else x.endsWith("px") && (x = Number(x.replace("px", "")));
          var T = m.getBoundingClientRect(), C = T.left, z = T.top, A = this.props.bounds === "window" ? { left: 0, top: 0 } : h.getBoundingClientRect(), R = A.left, O = A.top, L = this.getOffsetWidth(h), M = this.getOffsetHeight(h), N = o.toLowerCase().endsWith("left"), j = o.toLowerCase().endsWith("right"), Y = o.startsWith("top"), ne = o.startsWith("bottom");
          if ((N || Y) && this.resizable) {
            var J = (C - R) / l + this.resizable.size.width;
            this.setState({ maxWidth: J > Number(b) ? b : J });
          }
          if (j || this.props.lockAspectRatio && !N && !Y) {
            var J = L + (R - C) / l;
            this.setState({ maxWidth: J > Number(b) ? b : J });
          }
          if ((Y || N) && this.resizable) {
            var J = (z - O) / l + this.resizable.size.height;
            this.setState({
              maxHeight: J > Number(x) ? x : J
            });
          }
          if (ne || this.props.lockAspectRatio && !Y && !N) {
            var J = M + (O - z) / l;
            this.setState({
              maxHeight: J > Number(x) ? x : J
            });
          }
        }
      } else
        this.setState({
          maxWidth: this.props.maxWidth,
          maxHeight: this.props.maxHeight
        });
      this.props.onResizeStart && this.props.onResizeStart(n, o, a);
    }, t.prototype.onResize = function(n, o, a, l) {
      var c = this, f = { x: this.originalPosition.x, y: this.originalPosition.y }, d = -l.width, h = -l.height, m = ["top", "left", "topLeft", "bottomLeft", "topRight"];
      m.includes(o) && (o === "bottomLeft" ? f.x += d : (o === "topRight" || (f.x += d), f.y += h));
      var g = this.draggable.state;
      (f.x !== g.x || f.y !== g.y) && Po.flushSync(function() {
        c.draggable.setState(f);
      }), this.updateOffsetFromParent();
      var b = this.offsetFromParent, x = this.getDraggablePosition().x + b.left, _ = this.getDraggablePosition().y + b.top;
      this.resizingPosition = { x, y: _ }, this.props.onResize && this.props.onResize(n, o, a, l, {
        x,
        y: _
      });
    }, t.prototype.onResizeStop = function(n, o, a, l) {
      this.setState({
        resizing: !1
      });
      var c = this.getMaxSizesFromProps(), f = c.maxWidth, d = c.maxHeight;
      this.setState({ maxWidth: f, maxHeight: d }), this.props.onResizeStop && this.props.onResizeStop(n, o, a, l, this.resizingPosition);
    }, t.prototype.updateSize = function(n) {
      this.resizable && this.resizable.updateSize({ width: n.width, height: n.height });
    }, t.prototype.updatePosition = function(n) {
      this.draggable.setState(n);
    }, t.prototype.updateOffsetFromParent = function() {
      var n = this.props.scale, o = this.getParent(), a = this.getSelfElement();
      if (!o || a === null)
        return {
          top: 0,
          left: 0
        };
      var l = o.getBoundingClientRect(), c = l.left, f = l.top, d = a.getBoundingClientRect(), h = this.getDraggablePosition(), m = o.scrollLeft, g = o.scrollTop;
      this.offsetFromParent = {
        left: d.left - c + m - h.x * n,
        top: d.top - f + g - h.y * n
      };
    }, t.prototype.render = function() {
      var n = this, o = this.props, a = o.disableDragging, l = o.style, c = o.dragHandleClassName, f = o.position, d = o.onMouseDown, h = o.onMouseUp, m = o.dragAxis, g = o.dragGrid, b = o.bounds, x = o.enableUserSelectHack, _ = o.cancel, E = o.children;
      o.onResizeStart, o.onResize, o.onResizeStop, o.onDragStart, o.onDrag, o.onDragStop;
      var T = o.resizeHandleStyles, C = o.resizeHandleClasses, z = o.resizeHandleComponent, A = o.enableResizing, R = o.resizeGrid, O = o.resizeHandleWrapperClass, L = o.resizeHandleWrapperStyle, M = o.scale, N = o.allowAnyClick, j = o.dragPositionOffset, Y = DO(o, ["disableDragging", "style", "dragHandleClassName", "position", "onMouseDown", "onMouseUp", "dragAxis", "dragGrid", "bounds", "enableUserSelectHack", "cancel", "children", "onResizeStart", "onResize", "onResizeStop", "onDragStart", "onDrag", "onDragStop", "resizeHandleStyles", "resizeHandleClasses", "resizeHandleComponent", "enableResizing", "resizeGrid", "resizeHandleWrapperClass", "resizeHandleWrapperStyle", "scale", "allowAnyClick", "dragPositionOffset"]), ne = this.props.default ? Mt({}, this.props.default) : void 0;
      delete Y.default;
      var J = a || c ? { cursor: "auto" } : { cursor: "move" }, he = Mt(Mt(Mt({}, NO), J), l), fe = this.offsetFromParent, de = fe.left, I = fe.top, G;
      f && (G = {
        x: f.x - de,
        y: f.y - I
      });
      var B = this.state.resizing ? void 0 : G, te = this.state.resizing ? "both" : m;
      return y.createElement(
        xO,
        {
          ref: function(ae) {
            ae && (n.draggable = ae);
          },
          handle: c ? ".".concat(c) : void 0,
          defaultPosition: ne,
          onMouseDown: d,
          // @ts-expect-error
          onMouseUp: h,
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop,
          axis: te,
          disabled: a,
          grid: g,
          bounds: b ? this.state.bounds : void 0,
          position: B,
          enableUserSelectHack: x,
          cancel: _,
          scale: M,
          allowAnyClick: N,
          nodeRef: this.resizableElement,
          positionOffset: j
        },
        y.createElement(MO, Mt({}, Y, { ref: function(ae) {
          ae && (n.resizable = ae, n.resizableElement.current = ae.resizable);
        }, defaultSize: ne, size: this.props.size, enable: typeof A == "boolean" ? OO(A) : A, onResizeStart: this.onResizeStart, onResize: this.onResize, onResizeStop: this.onResizeStop, style: he, minWidth: this.props.minWidth, minHeight: this.props.minHeight, maxWidth: this.state.resizing ? this.state.maxWidth : this.props.maxWidth, maxHeight: this.state.resizing ? this.state.maxHeight : this.props.maxHeight, grid: R, handleWrapperClass: O, handleWrapperStyle: L, lockAspectRatio: this.props.lockAspectRatio, lockAspectRatioExtraWidth: this.props.lockAspectRatioExtraWidth, lockAspectRatioExtraHeight: this.props.lockAspectRatioExtraHeight, handleStyles: T, handleClasses: C, handleComponent: z, scale: this.props.scale }), E)
      );
    }, t.defaultProps = {
      maxWidth: Number.MAX_SAFE_INTEGER,
      maxHeight: Number.MAX_SAFE_INTEGER,
      scale: 1,
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      onDragStart: function() {
      },
      onDrag: function() {
      },
      onDragStop: function() {
      }
    }, t;
  })(y.PureComponent)
);
const NE = (...e) => e.filter((t, n, o) => !!t && t.trim() !== "" && o.indexOf(t) === n).join(" ").trim();
const kO = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const PO = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, o) => o ? o.toUpperCase() : n.toLowerCase()
);
const CS = (e) => {
  const t = PO(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
};
var LO = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
const IO = (e) => {
  for (const t in e)
    if (t.startsWith("aria-") || t === "role" || t === "title")
      return !0;
  return !1;
};
const VO = y.forwardRef(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: o,
    className: a = "",
    children: l,
    iconNode: c,
    ...f
  }, d) => y.createElement(
    "svg",
    {
      ref: d,
      ...LO,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: o ? Number(n) * 24 / Number(t) : n,
      className: NE("lucide", a),
      ...!l && !IO(f) && { "aria-hidden": "true" },
      ...f
    },
    [
      ...c.map(([h, m]) => y.createElement(h, m)),
      ...Array.isArray(l) ? l : [l]
    ]
  )
);
const nt = (e, t) => {
  const n = y.forwardRef(
    ({ className: o, ...a }, l) => y.createElement(VO, {
      ref: l,
      iconNode: t,
      className: NE(
        `lucide-${kO(CS(e))}`,
        `lucide-${e}`,
        o
      ),
      ...a
    })
  );
  return n.displayName = CS(e), n;
};
const UO = [
  [
    "path",
    {
      d: "M17 3a2 2 0 0 1 2 2v15a1 1 0 0 1-1.496.868l-4.512-2.578a2 2 0 0 0-1.984 0l-4.512 2.578A1 1 0 0 1 5 20V5a2 2 0 0 1 2-2z",
      key: "oz39mx"
    }
  ]
], BO = nt("bookmark", UO);
const $O = [
  ["path", { d: "M12 6V2H8", key: "1155em" }],
  ["path", { d: "M15 11v2", key: "i11awn" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "M20 12h2", key: "1q8mjw" }],
  [
    "path",
    {
      d: "M20 16a2 2 0 0 1-2 2H8.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 4 20.286V8a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2z",
      key: "11gyqh"
    }
  ],
  ["path", { d: "M9 11v2", key: "1ueba0" }]
], bg = nt("bot-message-square", $O);
const HO = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], OE = nt("check", HO);
const ZO = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], xg = nt("chevron-down", ZO);
const FO = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], jE = nt("chevron-up", FO);
const GO = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
], wm = nt("copy", GO);
const YO = [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }],
  ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }]
], qO = nt("ellipsis-vertical", YO);
const XO = [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
], WO = nt("grip-vertical", XO);
const KO = [
  [
    "path",
    {
      d: "M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5",
      key: "1gvzjb"
    }
  ],
  ["path", { d: "M9 18h6", key: "x1upvd" }],
  ["path", { d: "M10 22h4", key: "ceow96" }]
], JO = nt("lightbulb", KO);
const QO = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]], e2 = nt("loader-circle", QO);
const t2 = [
  ["path", { d: "M4 5h16", key: "1tepv9" }],
  ["path", { d: "M4 12h16", key: "1lakjw" }],
  ["path", { d: "M4 19h16", key: "1djgab" }]
], n2 = nt("menu", t2);
const r2 = [
  [
    "path",
    {
      d: "M2.992 16.342a2 2 0 0 1 .094 1.167l-1.065 3.29a1 1 0 0 0 1.236 1.168l3.413-.998a2 2 0 0 1 1.099.092 10 10 0 1 0-4.777-4.719",
      key: "1sd12s"
    }
  ]
], o2 = nt("message-circle", r2);
const i2 = [
  [
    "path",
    {
      d: "M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z",
      key: "18887p"
    }
  ],
  ["path", { d: "M7 11h10", key: "1twpyw" }],
  ["path", { d: "M7 15h6", key: "d9of3u" }],
  ["path", { d: "M7 7h8", key: "af5zfr" }]
], a2 = nt("message-square-text", i2);
const s2 = [
  [
    "path",
    {
      d: "M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z",
      key: "18887p"
    }
  ]
], AS = nt("message-square", s2);
const l2 = [
  ["path", { d: "M12 19v3", key: "npa21l" }],
  ["path", { d: "M15 9.34V5a3 3 0 0 0-5.68-1.33", key: "1gzdoj" }],
  ["path", { d: "M16.95 16.95A7 7 0 0 1 5 12v-2", key: "cqa7eg" }],
  ["path", { d: "M18.89 13.23A7 7 0 0 0 19 12v-2", key: "16hl24" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }],
  ["path", { d: "M9 9v3a3 3 0 0 0 5.12 2.12", key: "r2i35w" }]
], c2 = nt("mic-off", l2);
const u2 = [
  ["path", { d: "M12 19v3", key: "npa21l" }],
  ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
  ["rect", { x: "9", y: "2", width: "6", height: "13", rx: "3", key: "s6n7sd" }]
], f2 = nt("mic", u2);
const d2 = [
  [
    "path",
    {
      d: "m16 6-8.414 8.586a2 2 0 0 0 2.829 2.829l8.414-8.586a4 4 0 1 0-5.657-5.657l-8.379 8.551a6 6 0 1 0 8.485 8.485l8.379-8.551",
      key: "1miecu"
    }
  ]
], h2 = nt("paperclip", d2);
const p2 = [
  ["rect", { x: "14", y: "3", width: "5", height: "18", rx: "1", key: "kaeet6" }],
  ["rect", { x: "5", y: "3", width: "5", height: "18", rx: "1", key: "1wsw3u" }]
], m2 = nt("pause", p2);
const g2 = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
], v2 = nt("plus", g2);
const y2 = [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
], b2 = nt("send", y2);
const x2 = [
  [
    "path",
    {
      d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
      key: "1i5ecw"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], S2 = nt("settings", x2);
const w2 = [
  ["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }],
  [
    "path",
    {
      d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
      key: "ohrbg2"
    }
  ]
], E2 = nt("square-pen", w2);
const _2 = [
  ["path", { d: "M10 11v6", key: "nco0om" }],
  ["path", { d: "M14 11v6", key: "outv1u" }],
  ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6", key: "miytrc" }],
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2", key: "e791ji" }]
], T2 = nt("trash-2", _2);
const C2 = [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
], A2 = nt("triangle-alert", C2);
const R2 = [
  ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
  ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
], M2 = nt("user", R2);
const z2 = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
], Af = nt("x", z2);
var kE = "vercel.ai.error", D2 = Symbol.for(kE), RS, MS, mr = class PE extends (MS = Error, RS = D2, MS) {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: t,
    message: n,
    cause: o
  }) {
    super(n), this[RS] = !0, this.name = t, this.cause = o;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(t) {
    return PE.hasMarker(t, kE);
  }
  static hasMarker(t, n) {
    const o = Symbol.for(n);
    return t != null && typeof t == "object" && o in t && typeof t[o] == "boolean" && t[o] === !0;
  }
};
function Sg(e) {
  return e == null ? "unknown error" : typeof e == "string" ? e : e instanceof Error ? e.message : JSON.stringify(e);
}
var LE = "AI_InvalidArgumentError", IE = `vercel.ai.error.${LE}`, N2 = Symbol.for(IE), zS, DS, O2 = class extends (DS = mr, zS = N2, DS) {
  constructor({
    message: e,
    cause: t,
    argument: n
  }) {
    super({ name: LE, message: e, cause: t }), this[zS] = !0, this.argument = n;
  }
  static isInstance(e) {
    return mr.hasMarker(e, IE);
  }
}, VE = "AI_JSONParseError", UE = `vercel.ai.error.${VE}`, j2 = Symbol.for(UE), NS, OS, jS = class extends (OS = mr, NS = j2, OS) {
  constructor({ text: e, cause: t }) {
    super({
      name: VE,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${Sg(t)}`,
      cause: t
    }), this[NS] = !0, this.text = e;
  }
  static isInstance(e) {
    return mr.hasMarker(e, UE);
  }
}, BE = "AI_TypeValidationError", $E = `vercel.ai.error.${BE}`, k2 = Symbol.for($E), kS, PS, Bu = class Em extends (PS = mr, kS = k2, PS) {
  constructor({ value: t, cause: n }) {
    super({
      name: BE,
      message: `Type validation failed: Value: ${JSON.stringify(t)}.
Error message: ${Sg(n)}`,
      cause: n
    }), this[kS] = !0, this.value = t;
  }
  static isInstance(t) {
    return mr.hasMarker(t, $E);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: t,
    cause: n
  }) {
    return Em.isInstance(n) && n.value === t ? n : new Em({ value: t, cause: n });
  }
};
class LS extends Error {
  constructor(t, n) {
    super(t), this.name = "ParseError", this.type = n.type, this.field = n.field, this.value = n.value, this.line = n.line;
  }
}
function Dp(e) {
}
function P2(e) {
  if (typeof e == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent: t = Dp, onError: n = Dp, onRetry: o = Dp, onComment: a } = e;
  let l = "", c = !0, f, d = "", h = "";
  function m(E) {
    const T = c ? E.replace(/^\xEF\xBB\xBF/, "") : E, [C, z] = L2(`${l}${T}`);
    for (const A of C)
      g(A);
    l = z, c = !1;
  }
  function g(E) {
    if (E === "") {
      x();
      return;
    }
    if (E.startsWith(":")) {
      a && a(E.slice(E.startsWith(": ") ? 2 : 1));
      return;
    }
    const T = E.indexOf(":");
    if (T !== -1) {
      const C = E.slice(0, T), z = E[T + 1] === " " ? 2 : 1, A = E.slice(T + z);
      b(C, A, E);
      return;
    }
    b(E, "", E);
  }
  function b(E, T, C) {
    switch (E) {
      case "event":
        h = T;
        break;
      case "data":
        d = `${d}${T}
`;
        break;
      case "id":
        f = T.includes("\0") ? void 0 : T;
        break;
      case "retry":
        /^\d+$/.test(T) ? o(parseInt(T, 10)) : n(
          new LS(`Invalid \`retry\` value: "${T}"`, {
            type: "invalid-retry",
            value: T,
            line: C
          })
        );
        break;
      default:
        n(
          new LS(
            `Unknown field "${E.length > 20 ? `${E.slice(0, 20)}` : E}"`,
            { type: "unknown-field", field: E, value: T, line: C }
          )
        );
        break;
    }
  }
  function x() {
    d.length > 0 && t({
      id: f,
      event: h || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: d.endsWith(`
`) ? d.slice(0, -1) : d
    }), f = void 0, d = "", h = "";
  }
  function _(E = {}) {
    l && E.consume && g(l), c = !0, f = void 0, d = "", h = "", l = "";
  }
  return { feed: m, reset: _ };
}
function L2(e) {
  const t = [];
  let n = "", o = 0;
  for (; o < e.length; ) {
    const a = e.indexOf("\r", o), l = e.indexOf(`
`, o);
    let c = -1;
    if (a !== -1 && l !== -1 ? c = Math.min(a, l) : a !== -1 ? a === e.length - 1 ? c = -1 : c = a : l !== -1 && (c = l), c === -1) {
      n = e.slice(o);
      break;
    } else {
      const f = e.slice(o, c);
      t.push(f), o = c + 1, e[o - 1] === "\r" && e[o] === `
` && o++;
    }
  }
  return [t, n];
}
class I2 extends TransformStream {
  constructor({ onError: t, onRetry: n, onComment: o } = {}) {
    let a;
    super({
      start(l) {
        a = P2({
          onEvent: (c) => {
            l.enqueue(c);
          },
          onError(c) {
            t === "terminate" ? l.error(c) : typeof t == "function" && t(c);
          },
          onRetry: n,
          onComment: o
        });
      },
      transform(l) {
        a.feed(l);
      }
    });
  }
}
function ee(e, t, n) {
  function o(f, d) {
    if (f._zod || Object.defineProperty(f, "_zod", {
      value: {
        def: d,
        constr: c,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), f._zod.traits.has(e))
      return;
    f._zod.traits.add(e), t(f, d);
    const h = c.prototype, m = Object.keys(h);
    for (let g = 0; g < m.length; g++) {
      const b = m[g];
      b in f || (f[b] = h[b].bind(f));
    }
  }
  const a = n?.Parent ?? Object;
  class l extends a {
  }
  Object.defineProperty(l, "name", { value: e });
  function c(f) {
    var d;
    const h = n?.Parent ? new l() : this;
    o(h, f), (d = h._zod).deferred ?? (d.deferred = []);
    for (const m of h._zod.deferred)
      m();
    return h;
  }
  return Object.defineProperty(c, "init", { value: o }), Object.defineProperty(c, Symbol.hasInstance, {
    value: (f) => n?.Parent && f instanceof n.Parent ? !0 : f?._zod?.traits?.has(e)
  }), Object.defineProperty(c, "name", { value: e }), c;
}
class Aa extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class HE extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
}
const ZE = {};
function zo(e) {
  return ZE;
}
function FE(e) {
  const t = Object.values(e).filter((o) => typeof o == "number");
  return Object.entries(e).filter(([o, a]) => t.indexOf(+o) === -1).map(([o, a]) => a);
}
function _m(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function Rf(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function wg(e) {
  return e == null;
}
function Eg(e) {
  const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function V2(e, t) {
  const n = (e.toString().split(".")[1] || "").length, o = t.toString();
  let a = (o.split(".")[1] || "").length;
  if (a === 0 && /\d?e-\d?/.test(o)) {
    const d = o.match(/\d?e-(\d?)/);
    d?.[1] && (a = Number.parseInt(d[1]));
  }
  const l = n > a ? n : a, c = Number.parseInt(e.toFixed(l).replace(".", "")), f = Number.parseInt(t.toFixed(l).replace(".", ""));
  return c % f / 10 ** l;
}
const IS = /* @__PURE__ */ Symbol("evaluating");
function Be(e, t, n) {
  let o;
  Object.defineProperty(e, t, {
    get() {
      if (o !== IS)
        return o === void 0 && (o = IS, o = n()), o;
    },
    set(a) {
      Object.defineProperty(e, t, {
        value: a
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function wi(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function Lo(...e) {
  const t = {};
  for (const n of e) {
    const o = Object.getOwnPropertyDescriptors(n);
    Object.assign(t, o);
  }
  return Object.defineProperties({}, t);
}
function VS(e) {
  return JSON.stringify(e);
}
function U2(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const GE = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function dl(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const B2 = Rf(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function Oa(e) {
  if (dl(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0 || typeof t != "function")
    return !0;
  const n = t.prototype;
  return !(dl(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
function YE(e) {
  return Oa(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
const $2 = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function ja(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Io(e, t, n) {
  const o = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (o._zod.parent = e), o;
}
function xe(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function H2(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const Z2 = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function F2(e, t) {
  const n = e._zod.def, o = n.checks;
  if (o && o.length > 0)
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  const l = Lo(e._zod.def, {
    get shape() {
      const c = {};
      for (const f in t) {
        if (!(f in n.shape))
          throw new Error(`Unrecognized key: "${f}"`);
        t[f] && (c[f] = n.shape[f]);
      }
      return wi(this, "shape", c), c;
    },
    checks: []
  });
  return Io(e, l);
}
function G2(e, t) {
  const n = e._zod.def, o = n.checks;
  if (o && o.length > 0)
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  const l = Lo(e._zod.def, {
    get shape() {
      const c = { ...e._zod.def.shape };
      for (const f in t) {
        if (!(f in n.shape))
          throw new Error(`Unrecognized key: "${f}"`);
        t[f] && delete c[f];
      }
      return wi(this, "shape", c), c;
    },
    checks: []
  });
  return Io(e, l);
}
function Y2(e, t) {
  if (!Oa(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const n = e._zod.def.checks;
  if (n && n.length > 0) {
    const l = e._zod.def.shape;
    for (const c in t)
      if (Object.getOwnPropertyDescriptor(l, c) !== void 0)
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  const a = Lo(e._zod.def, {
    get shape() {
      const l = { ...e._zod.def.shape, ...t };
      return wi(this, "shape", l), l;
    }
  });
  return Io(e, a);
}
function q2(e, t) {
  if (!Oa(t))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const n = Lo(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape, ...t };
      return wi(this, "shape", o), o;
    }
  });
  return Io(e, n);
}
function X2(e, t) {
  const n = Lo(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape, ...t._zod.def.shape };
      return wi(this, "shape", o), o;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return Io(e, n);
}
function W2(e, t, n) {
  const a = t._zod.def.checks;
  if (a && a.length > 0)
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  const c = Lo(t._zod.def, {
    get shape() {
      const f = t._zod.def.shape, d = { ...f };
      if (n)
        for (const h in n) {
          if (!(h in f))
            throw new Error(`Unrecognized key: "${h}"`);
          n[h] && (d[h] = e ? new e({
            type: "optional",
            innerType: f[h]
          }) : f[h]);
        }
      else
        for (const h in f)
          d[h] = e ? new e({
            type: "optional",
            innerType: f[h]
          }) : f[h];
      return wi(this, "shape", d), d;
    },
    checks: []
  });
  return Io(t, c);
}
function K2(e, t, n) {
  const o = Lo(t._zod.def, {
    get shape() {
      const a = t._zod.def.shape, l = { ...a };
      if (n)
        for (const c in n) {
          if (!(c in l))
            throw new Error(`Unrecognized key: "${c}"`);
          n[c] && (l[c] = new e({
            type: "nonoptional",
            innerType: a[c]
          }));
        }
      else
        for (const c in a)
          l[c] = new e({
            type: "nonoptional",
            innerType: a[c]
          });
      return wi(this, "shape", l), l;
    }
  });
  return Io(t, o);
}
function xa(e, t = 0) {
  if (e.aborted === !0)
    return !0;
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n]?.continue !== !0)
      return !0;
  return !1;
}
function Sa(e, t) {
  return t.map((n) => {
    var o;
    return (o = n).path ?? (o.path = []), n.path.unshift(e), n;
  });
}
function du(e) {
  return typeof e == "string" ? e : e?.message;
}
function Do(e, t, n) {
  const o = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const a = du(e.inst?._zod.def?.error?.(e)) ?? du(t?.error?.(e)) ?? du(n.customError?.(e)) ?? du(n.localeError?.(e)) ?? "Invalid input";
    o.message = a;
  }
  return delete o.inst, delete o.continue, t?.reportInput || delete o.input, o;
}
function _g(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function hl(...e) {
  const [t, n, o] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: n,
    inst: o
  } : { ...t };
}
const qE = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, _m, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, XE = ee("$ZodError", qE), WE = ee("$ZodError", qE, { Parent: Error });
function J2(e, t = (n) => n.message) {
  const n = {}, o = [];
  for (const a of e.issues)
    a.path.length > 0 ? (n[a.path[0]] = n[a.path[0]] || [], n[a.path[0]].push(t(a))) : o.push(t(a));
  return { formErrors: o, fieldErrors: n };
}
function Q2(e, t = (n) => n.message) {
  const n = { _errors: [] }, o = (a) => {
    for (const l of a.issues)
      if (l.code === "invalid_union" && l.errors.length)
        l.errors.map((c) => o({ issues: c }));
      else if (l.code === "invalid_key")
        o({ issues: l.issues });
      else if (l.code === "invalid_element")
        o({ issues: l.issues });
      else if (l.path.length === 0)
        n._errors.push(t(l));
      else {
        let c = n, f = 0;
        for (; f < l.path.length; ) {
          const d = l.path[f];
          f === l.path.length - 1 ? (c[d] = c[d] || { _errors: [] }, c[d]._errors.push(t(l))) : c[d] = c[d] || { _errors: [] }, c = c[d], f++;
        }
      }
  };
  return o(e), n;
}
const Tg = (e) => (t, n, o, a) => {
  const l = o ? Object.assign(o, { async: !1 }) : { async: !1 }, c = t._zod.run({ value: n, issues: [] }, l);
  if (c instanceof Promise)
    throw new Aa();
  if (c.issues.length) {
    const f = new (a?.Err ?? e)(c.issues.map((d) => Do(d, l, zo())));
    throw GE(f, a?.callee), f;
  }
  return c.value;
}, Cg = (e) => async (t, n, o, a) => {
  const l = o ? Object.assign(o, { async: !0 }) : { async: !0 };
  let c = t._zod.run({ value: n, issues: [] }, l);
  if (c instanceof Promise && (c = await c), c.issues.length) {
    const f = new (a?.Err ?? e)(c.issues.map((d) => Do(d, l, zo())));
    throw GE(f, a?.callee), f;
  }
  return c.value;
}, Mf = (e) => (t, n, o) => {
  const a = o ? { ...o, async: !1 } : { async: !1 }, l = t._zod.run({ value: n, issues: [] }, a);
  if (l instanceof Promise)
    throw new Aa();
  return l.issues.length ? {
    success: !1,
    error: new (e ?? XE)(l.issues.map((c) => Do(c, a, zo())))
  } : { success: !0, data: l.value };
}, ej = /* @__PURE__ */ Mf(WE), zf = (e) => async (t, n, o) => {
  const a = o ? Object.assign(o, { async: !0 }) : { async: !0 };
  let l = t._zod.run({ value: n, issues: [] }, a);
  return l instanceof Promise && (l = await l), l.issues.length ? {
    success: !1,
    error: new e(l.issues.map((c) => Do(c, a, zo())))
  } : { success: !0, data: l.value };
}, tj = /* @__PURE__ */ zf(WE), nj = (e) => (t, n, o) => {
  const a = o ? Object.assign(o, { direction: "backward" }) : { direction: "backward" };
  return Tg(e)(t, n, a);
}, rj = (e) => (t, n, o) => Tg(e)(t, n, o), oj = (e) => async (t, n, o) => {
  const a = o ? Object.assign(o, { direction: "backward" }) : { direction: "backward" };
  return Cg(e)(t, n, a);
}, ij = (e) => async (t, n, o) => Cg(e)(t, n, o), aj = (e) => (t, n, o) => {
  const a = o ? Object.assign(o, { direction: "backward" }) : { direction: "backward" };
  return Mf(e)(t, n, a);
}, sj = (e) => (t, n, o) => Mf(e)(t, n, o), lj = (e) => async (t, n, o) => {
  const a = o ? Object.assign(o, { direction: "backward" }) : { direction: "backward" };
  return zf(e)(t, n, a);
}, cj = (e) => async (t, n, o) => zf(e)(t, n, o), uj = /^[cC][^\s-]{8,}$/, fj = /^[0-9a-z]+$/, dj = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, hj = /^[0-9a-vA-V]{20}$/, pj = /^[A-Za-z0-9]{27}$/, mj = /^[a-zA-Z0-9_-]{21}$/, gj = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, vj = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, US = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, yj = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, bj = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function xj() {
  return new RegExp(bj, "u");
}
const Sj = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, wj = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, Ej = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, _j = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Tj = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, KE = /^[A-Za-z0-9_-]*$/, Cj = /^\+[1-9]\d{6,14}$/, JE = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", Aj = /* @__PURE__ */ new RegExp(`^${JE}$`);
function QE(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function Rj(e) {
  return new RegExp(`^${QE(e)}$`);
}
function Mj(e) {
  const t = QE({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const o = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${JE}T(?:${o})$`);
}
const zj = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, Dj = /^-?\d+$/, e_ = /^-?\d+(?:\.\d+)?$/, Nj = /^(?:true|false)$/i, Oj = /^null$/i, jj = /^[^A-Z]*$/, kj = /^[^a-z]*$/, sn = /* @__PURE__ */ ee("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), t_ = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, n_ = /* @__PURE__ */ ee("$ZodCheckLessThan", (e, t) => {
  sn.init(e, t);
  const n = t_[typeof t.value];
  e._zod.onattach.push((o) => {
    const a = o._zod.bag, l = (t.inclusive ? a.maximum : a.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < l && (t.inclusive ? a.maximum = t.value : a.exclusiveMaximum = t.value);
  }), e._zod.check = (o) => {
    (t.inclusive ? o.value <= t.value : o.value < t.value) || o.issues.push({
      origin: n,
      code: "too_big",
      maximum: typeof t.value == "object" ? t.value.getTime() : t.value,
      input: o.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), r_ = /* @__PURE__ */ ee("$ZodCheckGreaterThan", (e, t) => {
  sn.init(e, t);
  const n = t_[typeof t.value];
  e._zod.onattach.push((o) => {
    const a = o._zod.bag, l = (t.inclusive ? a.minimum : a.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > l && (t.inclusive ? a.minimum = t.value : a.exclusiveMinimum = t.value);
  }), e._zod.check = (o) => {
    (t.inclusive ? o.value >= t.value : o.value > t.value) || o.issues.push({
      origin: n,
      code: "too_small",
      minimum: typeof t.value == "object" ? t.value.getTime() : t.value,
      input: o.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), Pj = /* @__PURE__ */ ee("$ZodCheckMultipleOf", (e, t) => {
  sn.init(e, t), e._zod.onattach.push((n) => {
    var o;
    (o = n._zod.bag).multipleOf ?? (o.multipleOf = t.value);
  }), e._zod.check = (n) => {
    if (typeof n.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof n.value == "bigint" ? n.value % t.value === BigInt(0) : V2(n.value, t.value) === 0) || n.issues.push({
      origin: typeof n.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Lj = /* @__PURE__ */ ee("$ZodCheckNumberFormat", (e, t) => {
  sn.init(e, t), t.format = t.format || "float64";
  const n = t.format?.includes("int"), o = n ? "int" : "number", [a, l] = Z2[t.format];
  e._zod.onattach.push((c) => {
    const f = c._zod.bag;
    f.format = t.format, f.minimum = a, f.maximum = l, n && (f.pattern = Dj);
  }), e._zod.check = (c) => {
    const f = c.value;
    if (n) {
      if (!Number.isInteger(f)) {
        c.issues.push({
          expected: o,
          format: t.format,
          code: "invalid_type",
          continue: !1,
          input: f,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(f)) {
        f > 0 ? c.issues.push({
          input: f,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: o,
          inclusive: !0,
          continue: !t.abort
        }) : c.issues.push({
          input: f,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: o,
          inclusive: !0,
          continue: !t.abort
        });
        return;
      }
    }
    f < a && c.issues.push({
      origin: "number",
      input: f,
      code: "too_small",
      minimum: a,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), f > l && c.issues.push({
      origin: "number",
      input: f,
      code: "too_big",
      maximum: l,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    });
  };
}), Ij = /* @__PURE__ */ ee("$ZodCheckMaxLength", (e, t) => {
  var n;
  sn.init(e, t), (n = e._zod.def).when ?? (n.when = (o) => {
    const a = o.value;
    return !wg(a) && a.length !== void 0;
  }), e._zod.onattach.push((o) => {
    const a = o._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < a && (o._zod.bag.maximum = t.maximum);
  }), e._zod.check = (o) => {
    const a = o.value;
    if (a.length <= t.maximum)
      return;
    const c = _g(a);
    o.issues.push({
      origin: c,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: a,
      inst: e,
      continue: !t.abort
    });
  };
}), Vj = /* @__PURE__ */ ee("$ZodCheckMinLength", (e, t) => {
  var n;
  sn.init(e, t), (n = e._zod.def).when ?? (n.when = (o) => {
    const a = o.value;
    return !wg(a) && a.length !== void 0;
  }), e._zod.onattach.push((o) => {
    const a = o._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > a && (o._zod.bag.minimum = t.minimum);
  }), e._zod.check = (o) => {
    const a = o.value;
    if (a.length >= t.minimum)
      return;
    const c = _g(a);
    o.issues.push({
      origin: c,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: a,
      inst: e,
      continue: !t.abort
    });
  };
}), Uj = /* @__PURE__ */ ee("$ZodCheckLengthEquals", (e, t) => {
  var n;
  sn.init(e, t), (n = e._zod.def).when ?? (n.when = (o) => {
    const a = o.value;
    return !wg(a) && a.length !== void 0;
  }), e._zod.onattach.push((o) => {
    const a = o._zod.bag;
    a.minimum = t.length, a.maximum = t.length, a.length = t.length;
  }), e._zod.check = (o) => {
    const a = o.value, l = a.length;
    if (l === t.length)
      return;
    const c = _g(a), f = l > t.length;
    o.issues.push({
      origin: c,
      ...f ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: o.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Df = /* @__PURE__ */ ee("$ZodCheckStringFormat", (e, t) => {
  var n, o;
  sn.init(e, t), e._zod.onattach.push((a) => {
    const l = a._zod.bag;
    l.format = t.format, t.pattern && (l.patterns ?? (l.patterns = /* @__PURE__ */ new Set()), l.patterns.add(t.pattern));
  }), t.pattern ? (n = e._zod).check ?? (n.check = (a) => {
    t.pattern.lastIndex = 0, !t.pattern.test(a.value) && a.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: a.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (o = e._zod).check ?? (o.check = () => {
  });
}), Bj = /* @__PURE__ */ ee("$ZodCheckRegex", (e, t) => {
  Df.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: n.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), $j = /* @__PURE__ */ ee("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = jj), Df.init(e, t);
}), Hj = /* @__PURE__ */ ee("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = kj), Df.init(e, t);
}), Zj = /* @__PURE__ */ ee("$ZodCheckIncludes", (e, t) => {
  sn.init(e, t);
  const n = ja(t.includes), o = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = o, e._zod.onattach.push((a) => {
    const l = a._zod.bag;
    l.patterns ?? (l.patterns = /* @__PURE__ */ new Set()), l.patterns.add(o);
  }), e._zod.check = (a) => {
    a.value.includes(t.includes, t.position) || a.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: a.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Fj = /* @__PURE__ */ ee("$ZodCheckStartsWith", (e, t) => {
  sn.init(e, t);
  const n = new RegExp(`^${ja(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((o) => {
    const a = o._zod.bag;
    a.patterns ?? (a.patterns = /* @__PURE__ */ new Set()), a.patterns.add(n);
  }), e._zod.check = (o) => {
    o.value.startsWith(t.prefix) || o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: o.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Gj = /* @__PURE__ */ ee("$ZodCheckEndsWith", (e, t) => {
  sn.init(e, t);
  const n = new RegExp(`.*${ja(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((o) => {
    const a = o._zod.bag;
    a.patterns ?? (a.patterns = /* @__PURE__ */ new Set()), a.patterns.add(n);
  }), e._zod.check = (o) => {
    o.value.endsWith(t.suffix) || o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: o.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Yj = /* @__PURE__ */ ee("$ZodCheckOverwrite", (e, t) => {
  sn.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
class qj {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const o = t.split(`
`).filter((c) => c), a = Math.min(...o.map((c) => c.length - c.trimStart().length)), l = o.map((c) => c.slice(a)).map((c) => " ".repeat(this.indent * 2) + c);
    for (const c of l)
      this.content.push(c);
  }
  compile() {
    const t = Function, n = this?.args, a = [...(this?.content ?? [""]).map((l) => `  ${l}`)];
    return new t(...n, a.join(`
`));
  }
}
const Xj = {
  major: 4,
  minor: 3,
  patch: 6
}, at = /* @__PURE__ */ ee("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = Xj;
  const o = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && o.unshift(e);
  for (const a of o)
    for (const l of a._zod.onattach)
      l(e);
  if (o.length === 0)
    (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const a = (c, f, d) => {
      let h = xa(c), m;
      for (const g of f) {
        if (g._zod.def.when) {
          if (!g._zod.def.when(c))
            continue;
        } else if (h)
          continue;
        const b = c.issues.length, x = g._zod.check(c);
        if (x instanceof Promise && d?.async === !1)
          throw new Aa();
        if (m || x instanceof Promise)
          m = (m ?? Promise.resolve()).then(async () => {
            await x, c.issues.length !== b && (h || (h = xa(c, b)));
          });
        else {
          if (c.issues.length === b)
            continue;
          h || (h = xa(c, b));
        }
      }
      return m ? m.then(() => c) : c;
    }, l = (c, f, d) => {
      if (xa(c))
        return c.aborted = !0, c;
      const h = a(f, o, d);
      if (h instanceof Promise) {
        if (d.async === !1)
          throw new Aa();
        return h.then((m) => e._zod.parse(m, d));
      }
      return e._zod.parse(h, d);
    };
    e._zod.run = (c, f) => {
      if (f.skipChecks)
        return e._zod.parse(c, f);
      if (f.direction === "backward") {
        const h = e._zod.parse({ value: c.value, issues: [] }, { ...f, skipChecks: !0 });
        return h instanceof Promise ? h.then((m) => l(m, c, f)) : l(h, c, f);
      }
      const d = e._zod.parse(c, f);
      if (d instanceof Promise) {
        if (f.async === !1)
          throw new Aa();
        return d.then((h) => a(h, o, f));
      }
      return a(d, o, f);
    };
  }
  Be(e, "~standard", () => ({
    validate: (a) => {
      try {
        const l = ej(e, a);
        return l.success ? { value: l.data } : { issues: l.error?.issues };
      } catch {
        return tj(e, a).then((c) => c.success ? { value: c.data } : { issues: c.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), Ag = /* @__PURE__ */ ee("$ZodString", (e, t) => {
  at.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? zj(e._zod.bag), e._zod.parse = (n, o) => {
    if (t.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), ct = /* @__PURE__ */ ee("$ZodStringFormat", (e, t) => {
  Df.init(e, t), Ag.init(e, t);
}), Wj = /* @__PURE__ */ ee("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = vj), ct.init(e, t);
}), Kj = /* @__PURE__ */ ee("$ZodUUID", (e, t) => {
  if (t.version) {
    const o = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (o === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = US(o));
  } else
    t.pattern ?? (t.pattern = US());
  ct.init(e, t);
}), Jj = /* @__PURE__ */ ee("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = yj), ct.init(e, t);
}), Qj = /* @__PURE__ */ ee("$ZodURL", (e, t) => {
  ct.init(e, t), e._zod.check = (n) => {
    try {
      const o = n.value.trim(), a = new URL(o);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(a.hostname) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: t.hostname.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(a.protocol.endsWith(":") ? a.protocol.slice(0, -1) : a.protocol) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? n.value = a.href : n.value = o;
      return;
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "url",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), ek = /* @__PURE__ */ ee("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = xj()), ct.init(e, t);
}), tk = /* @__PURE__ */ ee("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = mj), ct.init(e, t);
}), nk = /* @__PURE__ */ ee("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = uj), ct.init(e, t);
}), rk = /* @__PURE__ */ ee("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = fj), ct.init(e, t);
}), ok = /* @__PURE__ */ ee("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = dj), ct.init(e, t);
}), ik = /* @__PURE__ */ ee("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = hj), ct.init(e, t);
}), ak = /* @__PURE__ */ ee("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = pj), ct.init(e, t);
}), sk = /* @__PURE__ */ ee("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = Mj(t)), ct.init(e, t);
}), lk = /* @__PURE__ */ ee("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = Aj), ct.init(e, t);
}), ck = /* @__PURE__ */ ee("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = Rj(t)), ct.init(e, t);
}), uk = /* @__PURE__ */ ee("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = gj), ct.init(e, t);
}), fk = /* @__PURE__ */ ee("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = Sj), ct.init(e, t), e._zod.bag.format = "ipv4";
}), dk = /* @__PURE__ */ ee("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = wj), ct.init(e, t), e._zod.bag.format = "ipv6", e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), hk = /* @__PURE__ */ ee("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = Ej), ct.init(e, t);
}), pk = /* @__PURE__ */ ee("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = _j), ct.init(e, t), e._zod.check = (n) => {
    const o = n.value.split("/");
    try {
      if (o.length !== 2)
        throw new Error();
      const [a, l] = o;
      if (!l)
        throw new Error();
      const c = Number(l);
      if (`${c}` !== l)
        throw new Error();
      if (c < 0 || c > 128)
        throw new Error();
      new URL(`http://[${a}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function o_(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const mk = /* @__PURE__ */ ee("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = Tj), ct.init(e, t), e._zod.bag.contentEncoding = "base64", e._zod.check = (n) => {
    o_(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function gk(e) {
  if (!KE.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (o) => o === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return o_(n);
}
const vk = /* @__PURE__ */ ee("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = KE), ct.init(e, t), e._zod.bag.contentEncoding = "base64url", e._zod.check = (n) => {
    gk(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), yk = /* @__PURE__ */ ee("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = Cj), ct.init(e, t);
});
function bk(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3)
      return !1;
    const [o] = n;
    if (!o)
      return !1;
    const a = JSON.parse(atob(o));
    return !("typ" in a && a?.typ !== "JWT" || !a.alg || t && (!("alg" in a) || a.alg !== t));
  } catch {
    return !1;
  }
}
const xk = /* @__PURE__ */ ee("$ZodJWT", (e, t) => {
  ct.init(e, t), e._zod.check = (n) => {
    bk(n.value, t.alg) || n.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), i_ = /* @__PURE__ */ ee("$ZodNumber", (e, t) => {
  at.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? e_, e._zod.parse = (n, o) => {
    if (t.coerce)
      try {
        n.value = Number(n.value);
      } catch {
      }
    const a = n.value;
    if (typeof a == "number" && !Number.isNaN(a) && Number.isFinite(a))
      return n;
    const l = typeof a == "number" ? Number.isNaN(a) ? "NaN" : Number.isFinite(a) ? void 0 : "Infinity" : void 0;
    return n.issues.push({
      expected: "number",
      code: "invalid_type",
      input: a,
      inst: e,
      ...l ? { received: l } : {}
    }), n;
  };
}), Sk = /* @__PURE__ */ ee("$ZodNumberFormat", (e, t) => {
  Lj.init(e, t), i_.init(e, t);
}), wk = /* @__PURE__ */ ee("$ZodBoolean", (e, t) => {
  at.init(e, t), e._zod.pattern = Nj, e._zod.parse = (n, o) => {
    if (t.coerce)
      try {
        n.value = !!n.value;
      } catch {
      }
    const a = n.value;
    return typeof a == "boolean" || n.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: a,
      inst: e
    }), n;
  };
}), Ek = /* @__PURE__ */ ee("$ZodNull", (e, t) => {
  at.init(e, t), e._zod.pattern = Oj, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (n, o) => {
    const a = n.value;
    return a === null || n.issues.push({
      expected: "null",
      code: "invalid_type",
      input: a,
      inst: e
    }), n;
  };
}), _k = /* @__PURE__ */ ee("$ZodUnknown", (e, t) => {
  at.init(e, t), e._zod.parse = (n) => n;
}), Tk = /* @__PURE__ */ ee("$ZodNever", (e, t) => {
  at.init(e, t), e._zod.parse = (n, o) => (n.issues.push({
    expected: "never",
    code: "invalid_type",
    input: n.value,
    inst: e
  }), n);
});
function BS(e, t, n) {
  e.issues.length && t.issues.push(...Sa(n, e.issues)), t.value[n] = e.value;
}
const Ck = /* @__PURE__ */ ee("$ZodArray", (e, t) => {
  at.init(e, t), e._zod.parse = (n, o) => {
    const a = n.value;
    if (!Array.isArray(a))
      return n.issues.push({
        expected: "array",
        code: "invalid_type",
        input: a,
        inst: e
      }), n;
    n.value = Array(a.length);
    const l = [];
    for (let c = 0; c < a.length; c++) {
      const f = a[c], d = t.element._zod.run({
        value: f,
        issues: []
      }, o);
      d instanceof Promise ? l.push(d.then((h) => BS(h, n, c))) : BS(d, n, c);
    }
    return l.length ? Promise.all(l).then(() => n) : n;
  };
});
function $u(e, t, n, o, a) {
  if (e.issues.length) {
    if (a && !(n in o))
      return;
    t.issues.push(...Sa(n, e.issues));
  }
  e.value === void 0 ? n in o && (t.value[n] = void 0) : t.value[n] = e.value;
}
function a_(e) {
  const t = Object.keys(e.shape);
  for (const o of t)
    if (!e.shape?.[o]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${o}": expected a Zod schema`);
  const n = H2(e.shape);
  return {
    ...e,
    keys: t,
    keySet: new Set(t),
    numKeys: t.length,
    optionalKeys: new Set(n)
  };
}
function s_(e, t, n, o, a, l) {
  const c = [], f = a.keySet, d = a.catchall._zod, h = d.def.type, m = d.optout === "optional";
  for (const g in t) {
    if (f.has(g))
      continue;
    if (h === "never") {
      c.push(g);
      continue;
    }
    const b = d.run({ value: t[g], issues: [] }, o);
    b instanceof Promise ? e.push(b.then((x) => $u(x, n, g, t, m))) : $u(b, n, g, t, m);
  }
  return c.length && n.issues.push({
    code: "unrecognized_keys",
    keys: c,
    input: t,
    inst: l
  }), e.length ? Promise.all(e).then(() => n) : n;
}
const Ak = /* @__PURE__ */ ee("$ZodObject", (e, t) => {
  if (at.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
    const f = t.shape;
    Object.defineProperty(t, "shape", {
      get: () => {
        const d = { ...f };
        return Object.defineProperty(t, "shape", {
          value: d
        }), d;
      }
    });
  }
  const o = Rf(() => a_(t));
  Be(e._zod, "propValues", () => {
    const f = t.shape, d = {};
    for (const h in f) {
      const m = f[h]._zod;
      if (m.values) {
        d[h] ?? (d[h] = /* @__PURE__ */ new Set());
        for (const g of m.values)
          d[h].add(g);
      }
    }
    return d;
  });
  const a = dl, l = t.catchall;
  let c;
  e._zod.parse = (f, d) => {
    c ?? (c = o.value);
    const h = f.value;
    if (!a(h))
      return f.issues.push({
        expected: "object",
        code: "invalid_type",
        input: h,
        inst: e
      }), f;
    f.value = {};
    const m = [], g = c.shape;
    for (const b of c.keys) {
      const x = g[b], _ = x._zod.optout === "optional", E = x._zod.run({ value: h[b], issues: [] }, d);
      E instanceof Promise ? m.push(E.then((T) => $u(T, f, b, h, _))) : $u(E, f, b, h, _);
    }
    return l ? s_(m, h, f, d, o.value, e) : m.length ? Promise.all(m).then(() => f) : f;
  };
}), Rk = /* @__PURE__ */ ee("$ZodObjectJIT", (e, t) => {
  Ak.init(e, t);
  const n = e._zod.parse, o = Rf(() => a_(t)), a = (b) => {
    const x = new qj(["shape", "payload", "ctx"]), _ = o.value, E = (A) => {
      const R = VS(A);
      return `shape[${R}]._zod.run({ value: input[${R}], issues: [] }, ctx)`;
    };
    x.write("const input = payload.value;");
    const T = /* @__PURE__ */ Object.create(null);
    let C = 0;
    for (const A of _.keys)
      T[A] = `key_${C++}`;
    x.write("const newResult = {};");
    for (const A of _.keys) {
      const R = T[A], O = VS(A), M = b[A]?._zod?.optout === "optional";
      x.write(`const ${R} = ${E(A)};`), M ? x.write(`
        if (${R}.issues.length) {
          if (${O} in input) {
            payload.issues = payload.issues.concat(${R}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${O}, ...iss.path] : [${O}]
            })));
          }
        }
        
        if (${R}.value === undefined) {
          if (${O} in input) {
            newResult[${O}] = undefined;
          }
        } else {
          newResult[${O}] = ${R}.value;
        }
        
      `) : x.write(`
        if (${R}.issues.length) {
          payload.issues = payload.issues.concat(${R}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${O}, ...iss.path] : [${O}]
          })));
        }
        
        if (${R}.value === undefined) {
          if (${O} in input) {
            newResult[${O}] = undefined;
          }
        } else {
          newResult[${O}] = ${R}.value;
        }
        
      `);
    }
    x.write("payload.value = newResult;"), x.write("return payload;");
    const z = x.compile();
    return (A, R) => z(b, A, R);
  };
  let l;
  const c = dl, f = !ZE.jitless, h = f && B2.value, m = t.catchall;
  let g;
  e._zod.parse = (b, x) => {
    g ?? (g = o.value);
    const _ = b.value;
    return c(_) ? f && h && x?.async === !1 && x.jitless !== !0 ? (l || (l = a(t.shape)), b = l(b, x), m ? s_([], _, b, x, g, e) : b) : n(b, x) : (b.issues.push({
      expected: "object",
      code: "invalid_type",
      input: _,
      inst: e
    }), b);
  };
});
function $S(e, t, n, o) {
  for (const l of e)
    if (l.issues.length === 0)
      return t.value = l.value, t;
  const a = e.filter((l) => !xa(l));
  return a.length === 1 ? (t.value = a[0].value, a[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: n,
    errors: e.map((l) => l.issues.map((c) => Do(c, o, zo())))
  }), t);
}
const l_ = /* @__PURE__ */ ee("$ZodUnion", (e, t) => {
  at.init(e, t), Be(e._zod, "optin", () => t.options.some((a) => a._zod.optin === "optional") ? "optional" : void 0), Be(e._zod, "optout", () => t.options.some((a) => a._zod.optout === "optional") ? "optional" : void 0), Be(e._zod, "values", () => {
    if (t.options.every((a) => a._zod.values))
      return new Set(t.options.flatMap((a) => Array.from(a._zod.values)));
  }), Be(e._zod, "pattern", () => {
    if (t.options.every((a) => a._zod.pattern)) {
      const a = t.options.map((l) => l._zod.pattern);
      return new RegExp(`^(${a.map((l) => Eg(l.source)).join("|")})$`);
    }
  });
  const n = t.options.length === 1, o = t.options[0]._zod.run;
  e._zod.parse = (a, l) => {
    if (n)
      return o(a, l);
    let c = !1;
    const f = [];
    for (const d of t.options) {
      const h = d._zod.run({
        value: a.value,
        issues: []
      }, l);
      if (h instanceof Promise)
        f.push(h), c = !0;
      else {
        if (h.issues.length === 0)
          return h;
        f.push(h);
      }
    }
    return c ? Promise.all(f).then((d) => $S(d, a, e, l)) : $S(f, a, e, l);
  };
}), Mk = /* @__PURE__ */ ee("$ZodDiscriminatedUnion", (e, t) => {
  t.inclusive = !1, l_.init(e, t);
  const n = e._zod.parse;
  Be(e._zod, "propValues", () => {
    const a = {};
    for (const l of t.options) {
      const c = l._zod.propValues;
      if (!c || Object.keys(c).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(l)}"`);
      for (const [f, d] of Object.entries(c)) {
        a[f] || (a[f] = /* @__PURE__ */ new Set());
        for (const h of d)
          a[f].add(h);
      }
    }
    return a;
  });
  const o = Rf(() => {
    const a = t.options, l = /* @__PURE__ */ new Map();
    for (const c of a) {
      const f = c._zod.propValues?.[t.discriminator];
      if (!f || f.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(c)}"`);
      for (const d of f) {
        if (l.has(d))
          throw new Error(`Duplicate discriminator value "${String(d)}"`);
        l.set(d, c);
      }
    }
    return l;
  });
  e._zod.parse = (a, l) => {
    const c = a.value;
    if (!dl(c))
      return a.issues.push({
        code: "invalid_type",
        expected: "object",
        input: c,
        inst: e
      }), a;
    const f = o.value.get(c?.[t.discriminator]);
    return f ? f._zod.run(a, l) : t.unionFallback ? n(a, l) : (a.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: t.discriminator,
      input: c,
      path: [t.discriminator],
      inst: e
    }), a);
  };
}), zk = /* @__PURE__ */ ee("$ZodIntersection", (e, t) => {
  at.init(e, t), e._zod.parse = (n, o) => {
    const a = n.value, l = t.left._zod.run({ value: a, issues: [] }, o), c = t.right._zod.run({ value: a, issues: [] }, o);
    return l instanceof Promise || c instanceof Promise ? Promise.all([l, c]).then(([d, h]) => HS(n, d, h)) : HS(n, l, c);
  };
});
function Tm(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (Oa(e) && Oa(t)) {
    const n = Object.keys(t), o = Object.keys(e).filter((l) => n.indexOf(l) !== -1), a = { ...e, ...t };
    for (const l of o) {
      const c = Tm(e[l], t[l]);
      if (!c.valid)
        return {
          valid: !1,
          mergeErrorPath: [l, ...c.mergeErrorPath]
        };
      a[l] = c.data;
    }
    return { valid: !0, data: a };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const n = [];
    for (let o = 0; o < e.length; o++) {
      const a = e[o], l = t[o], c = Tm(a, l);
      if (!c.valid)
        return {
          valid: !1,
          mergeErrorPath: [o, ...c.mergeErrorPath]
        };
      n.push(c.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function HS(e, t, n) {
  const o = /* @__PURE__ */ new Map();
  let a;
  for (const f of t.issues)
    if (f.code === "unrecognized_keys") {
      a ?? (a = f);
      for (const d of f.keys)
        o.has(d) || o.set(d, {}), o.get(d).l = !0;
    } else
      e.issues.push(f);
  for (const f of n.issues)
    if (f.code === "unrecognized_keys")
      for (const d of f.keys)
        o.has(d) || o.set(d, {}), o.get(d).r = !0;
    else
      e.issues.push(f);
  const l = [...o].filter(([, f]) => f.l && f.r).map(([f]) => f);
  if (l.length && a && e.issues.push({ ...a, keys: l }), xa(e))
    return e;
  const c = Tm(t.value, n.value);
  if (!c.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(c.mergeErrorPath)}`);
  return e.value = c.data, e;
}
const Dk = /* @__PURE__ */ ee("$ZodRecord", (e, t) => {
  at.init(e, t), e._zod.parse = (n, o) => {
    const a = n.value;
    if (!Oa(a))
      return n.issues.push({
        expected: "record",
        code: "invalid_type",
        input: a,
        inst: e
      }), n;
    const l = [], c = t.keyType._zod.values;
    if (c) {
      n.value = {};
      const f = /* @__PURE__ */ new Set();
      for (const h of c)
        if (typeof h == "string" || typeof h == "number" || typeof h == "symbol") {
          f.add(typeof h == "number" ? h.toString() : h);
          const m = t.valueType._zod.run({ value: a[h], issues: [] }, o);
          m instanceof Promise ? l.push(m.then((g) => {
            g.issues.length && n.issues.push(...Sa(h, g.issues)), n.value[h] = g.value;
          })) : (m.issues.length && n.issues.push(...Sa(h, m.issues)), n.value[h] = m.value);
        }
      let d;
      for (const h in a)
        f.has(h) || (d = d ?? [], d.push(h));
      d && d.length > 0 && n.issues.push({
        code: "unrecognized_keys",
        input: a,
        inst: e,
        keys: d
      });
    } else {
      n.value = {};
      for (const f of Reflect.ownKeys(a)) {
        if (f === "__proto__")
          continue;
        let d = t.keyType._zod.run({ value: f, issues: [] }, o);
        if (d instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (typeof f == "string" && e_.test(f) && d.issues.length) {
          const g = t.keyType._zod.run({ value: Number(f), issues: [] }, o);
          if (g instanceof Promise)
            throw new Error("Async schemas not supported in object keys currently");
          g.issues.length === 0 && (d = g);
        }
        if (d.issues.length) {
          t.mode === "loose" ? n.value[f] = a[f] : n.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: d.issues.map((g) => Do(g, o, zo())),
            input: f,
            path: [f],
            inst: e
          });
          continue;
        }
        const m = t.valueType._zod.run({ value: a[f], issues: [] }, o);
        m instanceof Promise ? l.push(m.then((g) => {
          g.issues.length && n.issues.push(...Sa(f, g.issues)), n.value[d.value] = g.value;
        })) : (m.issues.length && n.issues.push(...Sa(f, m.issues)), n.value[d.value] = m.value);
      }
    }
    return l.length ? Promise.all(l).then(() => n) : n;
  };
}), Nk = /* @__PURE__ */ ee("$ZodEnum", (e, t) => {
  at.init(e, t);
  const n = FE(t.entries), o = new Set(n);
  e._zod.values = o, e._zod.pattern = new RegExp(`^(${n.filter((a) => $2.has(typeof a)).map((a) => typeof a == "string" ? ja(a) : a.toString()).join("|")})$`), e._zod.parse = (a, l) => {
    const c = a.value;
    return o.has(c) || a.issues.push({
      code: "invalid_value",
      values: n,
      input: c,
      inst: e
    }), a;
  };
}), Ok = /* @__PURE__ */ ee("$ZodLiteral", (e, t) => {
  if (at.init(e, t), t.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  const n = new Set(t.values);
  e._zod.values = n, e._zod.pattern = new RegExp(`^(${t.values.map((o) => typeof o == "string" ? ja(o) : o ? ja(o.toString()) : String(o)).join("|")})$`), e._zod.parse = (o, a) => {
    const l = o.value;
    return n.has(l) || o.issues.push({
      code: "invalid_value",
      values: t.values,
      input: l,
      inst: e
    }), o;
  };
}), jk = /* @__PURE__ */ ee("$ZodTransform", (e, t) => {
  at.init(e, t), e._zod.parse = (n, o) => {
    if (o.direction === "backward")
      throw new HE(e.constructor.name);
    const a = t.transform(n.value, n);
    if (o.async)
      return (a instanceof Promise ? a : Promise.resolve(a)).then((c) => (n.value = c, n));
    if (a instanceof Promise)
      throw new Aa();
    return n.value = a, n;
  };
});
function ZS(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
const c_ = /* @__PURE__ */ ee("$ZodOptional", (e, t) => {
  at.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", Be(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), Be(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${Eg(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, o) => {
    if (t.innerType._zod.optin === "optional") {
      const a = t.innerType._zod.run(n, o);
      return a instanceof Promise ? a.then((l) => ZS(l, n.value)) : ZS(a, n.value);
    }
    return n.value === void 0 ? n : t.innerType._zod.run(n, o);
  };
}), kk = /* @__PURE__ */ ee("$ZodExactOptional", (e, t) => {
  c_.init(e, t), Be(e._zod, "values", () => t.innerType._zod.values), Be(e._zod, "pattern", () => t.innerType._zod.pattern), e._zod.parse = (n, o) => t.innerType._zod.run(n, o);
}), Pk = /* @__PURE__ */ ee("$ZodNullable", (e, t) => {
  at.init(e, t), Be(e._zod, "optin", () => t.innerType._zod.optin), Be(e._zod, "optout", () => t.innerType._zod.optout), Be(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${Eg(n.source)}|null)$`) : void 0;
  }), Be(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, o) => n.value === null ? n : t.innerType._zod.run(n, o);
}), Lk = /* @__PURE__ */ ee("$ZodDefault", (e, t) => {
  at.init(e, t), e._zod.optin = "optional", Be(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, o) => {
    if (o.direction === "backward")
      return t.innerType._zod.run(n, o);
    if (n.value === void 0)
      return n.value = t.defaultValue, n;
    const a = t.innerType._zod.run(n, o);
    return a instanceof Promise ? a.then((l) => FS(l, t)) : FS(a, t);
  };
});
function FS(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const Ik = /* @__PURE__ */ ee("$ZodPrefault", (e, t) => {
  at.init(e, t), e._zod.optin = "optional", Be(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, o) => (o.direction === "backward" || n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, o));
}), Vk = /* @__PURE__ */ ee("$ZodNonOptional", (e, t) => {
  at.init(e, t), Be(e._zod, "values", () => {
    const n = t.innerType._zod.values;
    return n ? new Set([...n].filter((o) => o !== void 0)) : void 0;
  }), e._zod.parse = (n, o) => {
    const a = t.innerType._zod.run(n, o);
    return a instanceof Promise ? a.then((l) => GS(l, e)) : GS(a, e);
  };
});
function GS(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const Uk = /* @__PURE__ */ ee("$ZodCatch", (e, t) => {
  at.init(e, t), Be(e._zod, "optin", () => t.innerType._zod.optin), Be(e._zod, "optout", () => t.innerType._zod.optout), Be(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, o) => {
    if (o.direction === "backward")
      return t.innerType._zod.run(n, o);
    const a = t.innerType._zod.run(n, o);
    return a instanceof Promise ? a.then((l) => (n.value = l.value, l.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: l.issues.map((c) => Do(c, o, zo()))
      },
      input: n.value
    }), n.issues = []), n)) : (n.value = a.value, a.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: a.issues.map((l) => Do(l, o, zo()))
      },
      input: n.value
    }), n.issues = []), n);
  };
}), Bk = /* @__PURE__ */ ee("$ZodPipe", (e, t) => {
  at.init(e, t), Be(e._zod, "values", () => t.in._zod.values), Be(e._zod, "optin", () => t.in._zod.optin), Be(e._zod, "optout", () => t.out._zod.optout), Be(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, o) => {
    if (o.direction === "backward") {
      const l = t.out._zod.run(n, o);
      return l instanceof Promise ? l.then((c) => hu(c, t.in, o)) : hu(l, t.in, o);
    }
    const a = t.in._zod.run(n, o);
    return a instanceof Promise ? a.then((l) => hu(l, t.out, o)) : hu(a, t.out, o);
  };
});
function hu(e, t, n) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, n);
}
const $k = /* @__PURE__ */ ee("$ZodReadonly", (e, t) => {
  at.init(e, t), Be(e._zod, "propValues", () => t.innerType._zod.propValues), Be(e._zod, "values", () => t.innerType._zod.values), Be(e._zod, "optin", () => t.innerType?._zod?.optin), Be(e._zod, "optout", () => t.innerType?._zod?.optout), e._zod.parse = (n, o) => {
    if (o.direction === "backward")
      return t.innerType._zod.run(n, o);
    const a = t.innerType._zod.run(n, o);
    return a instanceof Promise ? a.then(YS) : YS(a);
  };
});
function YS(e) {
  return e.value = Object.freeze(e.value), e;
}
const Hk = /* @__PURE__ */ ee("$ZodLazy", (e, t) => {
  at.init(e, t), Be(e._zod, "innerType", () => t.getter()), Be(e._zod, "pattern", () => e._zod.innerType?._zod?.pattern), Be(e._zod, "propValues", () => e._zod.innerType?._zod?.propValues), Be(e._zod, "optin", () => e._zod.innerType?._zod?.optin ?? void 0), Be(e._zod, "optout", () => e._zod.innerType?._zod?.optout ?? void 0), e._zod.parse = (n, o) => e._zod.innerType._zod.run(n, o);
}), Zk = /* @__PURE__ */ ee("$ZodCustom", (e, t) => {
  sn.init(e, t), at.init(e, t), e._zod.parse = (n, o) => n, e._zod.check = (n) => {
    const o = n.value, a = t.fn(o);
    if (a instanceof Promise)
      return a.then((l) => qS(l, n, o, e));
    qS(a, n, o, e);
  };
});
function qS(e, t, n, o) {
  if (!e) {
    const a = {
      code: "custom",
      input: n,
      inst: o,
      // incorporates params.error into issue reporting
      path: [...o._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !o._zod.def.abort
      // params: inst._zod.def.params,
    };
    o._zod.def.params && (a.params = o._zod.def.params), t.issues.push(hl(a));
  }
}
var XS;
class Fk {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    const o = n[0];
    return this._map.set(t, o), o && typeof o == "object" && "id" in o && this._idmap.set(o.id, t), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const n = this._map.get(t);
    return n && typeof n == "object" && "id" in n && this._idmap.delete(n.id), this._map.delete(t), this;
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const o = { ...this.get(n) ?? {} };
      delete o.id;
      const a = { ...o, ...this._map.get(t) };
      return Object.keys(a).length ? a : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function Gk() {
  return new Fk();
}
(XS = globalThis).__zod_globalRegistry ?? (XS.__zod_globalRegistry = Gk());
const Xs = globalThis.__zod_globalRegistry;
// @__NO_SIDE_EFFECTS__
function Yk(e, t) {
  return new e({
    type: "string",
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function qk(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function WS(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Xk(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Wk(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Kk(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Jk(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Qk(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function eP(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function tP(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function nP(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function rP(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function oP(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function iP(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function aP(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function sP(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function lP(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function cP(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function uP(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function fP(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function dP(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function hP(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function pP(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function mP(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function gP(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function vP(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function yP(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function bP(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function xP(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function SP(e, t) {
  return new e({
    type: "boolean",
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function wP(e, t) {
  return new e({
    type: "null",
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function EP(e) {
  return new e({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _P(e, t) {
  return new e({
    type: "never",
    ...xe(t)
  });
}
// @__NO_SIDE_EFFECTS__
function KS(e, t) {
  return new n_({
    check: "less_than",
    ...xe(t),
    value: e,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function Np(e, t) {
  return new n_({
    check: "less_than",
    ...xe(t),
    value: e,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function JS(e, t) {
  return new r_({
    check: "greater_than",
    ...xe(t),
    value: e,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function Op(e, t) {
  return new r_({
    check: "greater_than",
    ...xe(t),
    value: e,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function QS(e, t) {
  return new Pj({
    check: "multiple_of",
    ...xe(t),
    value: e
  });
}
// @__NO_SIDE_EFFECTS__
function u_(e, t) {
  return new Ij({
    check: "max_length",
    ...xe(t),
    maximum: e
  });
}
// @__NO_SIDE_EFFECTS__
function Hu(e, t) {
  return new Vj({
    check: "min_length",
    ...xe(t),
    minimum: e
  });
}
// @__NO_SIDE_EFFECTS__
function f_(e, t) {
  return new Uj({
    check: "length_equals",
    ...xe(t),
    length: e
  });
}
// @__NO_SIDE_EFFECTS__
function TP(e, t) {
  return new Bj({
    check: "string_format",
    format: "regex",
    ...xe(t),
    pattern: e
  });
}
// @__NO_SIDE_EFFECTS__
function CP(e) {
  return new $j({
    check: "string_format",
    format: "lowercase",
    ...xe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function AP(e) {
  return new Hj({
    check: "string_format",
    format: "uppercase",
    ...xe(e)
  });
}
// @__NO_SIDE_EFFECTS__
function RP(e, t) {
  return new Zj({
    check: "string_format",
    format: "includes",
    ...xe(t),
    includes: e
  });
}
// @__NO_SIDE_EFFECTS__
function MP(e, t) {
  return new Fj({
    check: "string_format",
    format: "starts_with",
    ...xe(t),
    prefix: e
  });
}
// @__NO_SIDE_EFFECTS__
function zP(e, t) {
  return new Gj({
    check: "string_format",
    format: "ends_with",
    ...xe(t),
    suffix: e
  });
}
// @__NO_SIDE_EFFECTS__
function Va(e) {
  return new Yj({
    check: "overwrite",
    tx: e
  });
}
// @__NO_SIDE_EFFECTS__
function DP(e) {
  return /* @__PURE__ */ Va((t) => t.normalize(e));
}
// @__NO_SIDE_EFFECTS__
function NP() {
  return /* @__PURE__ */ Va((e) => e.trim());
}
// @__NO_SIDE_EFFECTS__
function OP() {
  return /* @__PURE__ */ Va((e) => e.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function jP() {
  return /* @__PURE__ */ Va((e) => e.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function kP() {
  return /* @__PURE__ */ Va((e) => U2(e));
}
// @__NO_SIDE_EFFECTS__
function PP(e, t, n) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...xe(n)
  });
}
// @__NO_SIDE_EFFECTS__
function LP(e, t, n) {
  const o = xe(n);
  return o.abort ?? (o.abort = !0), new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...o
  });
}
// @__NO_SIDE_EFFECTS__
function IP(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...xe(n)
  });
}
// @__NO_SIDE_EFFECTS__
function VP(e) {
  const t = /* @__PURE__ */ UP((n) => (n.addIssue = (o) => {
    if (typeof o == "string")
      n.issues.push(hl(o, n.value, t._zod.def));
    else {
      const a = o;
      a.fatal && (a.continue = !1), a.code ?? (a.code = "custom"), a.input ?? (a.input = n.value), a.inst ?? (a.inst = t), a.continue ?? (a.continue = !t._zod.def.abort), n.issues.push(hl(a));
    }
  }, e(n.value, n)));
  return t;
}
// @__NO_SIDE_EFFECTS__
function UP(e, t) {
  const n = new sn({
    check: "custom",
    ...xe(t)
  });
  return n._zod.check = e, n;
}
function Zu(e) {
  let t = e?.target ?? "draft-2020-12";
  return t === "draft-4" && (t = "draft-04"), t === "draft-7" && (t = "draft-07"), {
    processors: e.processors ?? {},
    metadataRegistry: e?.metadata ?? Xs,
    target: t,
    unrepresentable: e?.unrepresentable ?? "throw",
    override: e?.override ?? (() => {
    }),
    io: e?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: e?.cycles ?? "ref",
    reused: e?.reused ?? "inline",
    external: e?.external ?? void 0
  };
}
function tt(e, t, n = { path: [], schemaPath: [] }) {
  var o;
  const a = e._zod.def, l = t.seen.get(e);
  if (l)
    return l.count++, n.schemaPath.includes(e) && (l.cycle = n.path), l.schema;
  const c = { schema: {}, count: 1, cycle: void 0, path: n.path };
  t.seen.set(e, c);
  const f = e._zod.toJSONSchema?.();
  if (f)
    c.schema = f;
  else {
    const m = {
      ...n,
      schemaPath: [...n.schemaPath, e],
      path: n.path
    };
    if (e._zod.processJSONSchema)
      e._zod.processJSONSchema(t, c.schema, m);
    else {
      const b = c.schema, x = t.processors[a.type];
      if (!x)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${a.type}`);
      x(e, t, b, m);
    }
    const g = e._zod.parent;
    g && (c.ref || (c.ref = g), tt(g, t, m), t.seen.get(g).isParent = !0);
  }
  const d = t.metadataRegistry.get(e);
  return d && Object.assign(c.schema, d), t.io === "input" && qt(e) && (delete c.schema.examples, delete c.schema.default), t.io === "input" && c.schema._prefault && ((o = c.schema).default ?? (o.default = c.schema._prefault)), delete c.schema._prefault, t.seen.get(e).schema;
}
function Fu(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const o = /* @__PURE__ */ new Map();
  for (const c of e.seen.entries()) {
    const f = e.metadataRegistry.get(c[0])?.id;
    if (f) {
      const d = o.get(f);
      if (d && d !== c[0])
        throw new Error(`Duplicate schema id "${f}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      o.set(f, c[0]);
    }
  }
  const a = (c) => {
    const f = e.target === "draft-2020-12" ? "$defs" : "definitions";
    if (e.external) {
      const g = e.external.registry.get(c[0])?.id, b = e.external.uri ?? ((_) => _);
      if (g)
        return { ref: b(g) };
      const x = c[1].defId ?? c[1].schema.id ?? `schema${e.counter++}`;
      return c[1].defId = x, { defId: x, ref: `${b("__shared")}#/${f}/${x}` };
    }
    if (c[1] === n)
      return { ref: "#" };
    const h = `#/${f}/`, m = c[1].schema.id ?? `__schema${e.counter++}`;
    return { defId: m, ref: h + m };
  }, l = (c) => {
    if (c[1].schema.$ref)
      return;
    const f = c[1], { ref: d, defId: h } = a(c);
    f.def = { ...f.schema }, h && (f.defId = h);
    const m = f.schema;
    for (const g in m)
      delete m[g];
    m.$ref = d;
  };
  if (e.cycles === "throw")
    for (const c of e.seen.entries()) {
      const f = c[1];
      if (f.cycle)
        throw new Error(`Cycle detected: #/${f.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (const c of e.seen.entries()) {
    const f = c[1];
    if (t === c[0]) {
      l(c);
      continue;
    }
    if (e.external) {
      const h = e.external.registry.get(c[0])?.id;
      if (t !== c[0] && h) {
        l(c);
        continue;
      }
    }
    if (e.metadataRegistry.get(c[0])?.id) {
      l(c);
      continue;
    }
    if (f.cycle) {
      l(c);
      continue;
    }
    if (f.count > 1 && e.reused === "ref") {
      l(c);
      continue;
    }
  }
}
function Gu(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const o = (c) => {
    const f = e.seen.get(c);
    if (f.ref === null)
      return;
    const d = f.def ?? f.schema, h = { ...d }, m = f.ref;
    if (f.ref = null, m) {
      o(m);
      const b = e.seen.get(m), x = b.schema;
      if (x.$ref && (e.target === "draft-07" || e.target === "draft-04" || e.target === "openapi-3.0") ? (d.allOf = d.allOf ?? [], d.allOf.push(x)) : Object.assign(d, x), Object.assign(d, h), c._zod.parent === m)
        for (const E in d)
          E === "$ref" || E === "allOf" || E in h || delete d[E];
      if (x.$ref && b.def)
        for (const E in d)
          E === "$ref" || E === "allOf" || E in b.def && JSON.stringify(d[E]) === JSON.stringify(b.def[E]) && delete d[E];
    }
    const g = c._zod.parent;
    if (g && g !== m) {
      o(g);
      const b = e.seen.get(g);
      if (b?.schema.$ref && (d.$ref = b.schema.$ref, b.def))
        for (const x in d)
          x === "$ref" || x === "allOf" || x in b.def && JSON.stringify(d[x]) === JSON.stringify(b.def[x]) && delete d[x];
    }
    e.override({
      zodSchema: c,
      jsonSchema: d,
      path: f.path ?? []
    });
  };
  for (const c of [...e.seen.entries()].reverse())
    o(c[0]);
  const a = {};
  if (e.target === "draft-2020-12" ? a.$schema = "https://json-schema.org/draft/2020-12/schema" : e.target === "draft-07" ? a.$schema = "http://json-schema.org/draft-07/schema#" : e.target === "draft-04" ? a.$schema = "http://json-schema.org/draft-04/schema#" : e.target, e.external?.uri) {
    const c = e.external.registry.get(t)?.id;
    if (!c)
      throw new Error("Schema is missing an `id` property");
    a.$id = e.external.uri(c);
  }
  Object.assign(a, n.def ?? n.schema);
  const l = e.external?.defs ?? {};
  for (const c of e.seen.entries()) {
    const f = c[1];
    f.def && f.defId && (l[f.defId] = f.def);
  }
  e.external || Object.keys(l).length > 0 && (e.target === "draft-2020-12" ? a.$defs = l : a.definitions = l);
  try {
    const c = JSON.parse(JSON.stringify(a));
    return Object.defineProperty(c, "~standard", {
      value: {
        ...t["~standard"],
        jsonSchema: {
          input: Yu(t, "input", e.processors),
          output: Yu(t, "output", e.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), c;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function qt(e, t) {
  const n = t ?? { seen: /* @__PURE__ */ new Set() };
  if (n.seen.has(e))
    return !1;
  n.seen.add(e);
  const o = e._zod.def;
  if (o.type === "transform")
    return !0;
  if (o.type === "array")
    return qt(o.element, n);
  if (o.type === "set")
    return qt(o.valueType, n);
  if (o.type === "lazy")
    return qt(o.getter(), n);
  if (o.type === "promise" || o.type === "optional" || o.type === "nonoptional" || o.type === "nullable" || o.type === "readonly" || o.type === "default" || o.type === "prefault")
    return qt(o.innerType, n);
  if (o.type === "intersection")
    return qt(o.left, n) || qt(o.right, n);
  if (o.type === "record" || o.type === "map")
    return qt(o.keyType, n) || qt(o.valueType, n);
  if (o.type === "pipe")
    return qt(o.in, n) || qt(o.out, n);
  if (o.type === "object") {
    for (const a in o.shape)
      if (qt(o.shape[a], n))
        return !0;
    return !1;
  }
  if (o.type === "union") {
    for (const a of o.options)
      if (qt(a, n))
        return !0;
    return !1;
  }
  if (o.type === "tuple") {
    for (const a of o.items)
      if (qt(a, n))
        return !0;
    return !!(o.rest && qt(o.rest, n));
  }
  return !1;
}
const BP = (e, t = {}) => (n) => {
  const o = Zu({ ...n, processors: t });
  return tt(e, o), Fu(o, e), Gu(o, e);
}, Yu = (e, t, n = {}) => (o) => {
  const { libraryOptions: a, target: l } = o ?? {}, c = Zu({ ...a ?? {}, target: l, io: t, processors: n });
  return tt(e, c), Fu(c, e), Gu(c, e);
}, $P = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, d_ = (e, t, n, o) => {
  const a = n;
  a.type = "string";
  const { minimum: l, maximum: c, format: f, patterns: d, contentEncoding: h } = e._zod.bag;
  if (typeof l == "number" && (a.minLength = l), typeof c == "number" && (a.maxLength = c), f && (a.format = $P[f] ?? f, a.format === "" && delete a.format, f === "time" && delete a.format), h && (a.contentEncoding = h), d && d.size > 0) {
    const m = [...d];
    m.length === 1 ? a.pattern = m[0].source : m.length > 1 && (a.allOf = [
      ...m.map((g) => ({
        ...t.target === "draft-07" || t.target === "draft-04" || t.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: g.source
      }))
    ]);
  }
}, h_ = (e, t, n, o) => {
  const a = n, { minimum: l, maximum: c, format: f, multipleOf: d, exclusiveMaximum: h, exclusiveMinimum: m } = e._zod.bag;
  typeof f == "string" && f.includes("int") ? a.type = "integer" : a.type = "number", typeof m == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (a.minimum = m, a.exclusiveMinimum = !0) : a.exclusiveMinimum = m), typeof l == "number" && (a.minimum = l, typeof m == "number" && t.target !== "draft-04" && (m >= l ? delete a.minimum : delete a.exclusiveMinimum)), typeof h == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (a.maximum = h, a.exclusiveMaximum = !0) : a.exclusiveMaximum = h), typeof c == "number" && (a.maximum = c, typeof h == "number" && t.target !== "draft-04" && (h <= c ? delete a.maximum : delete a.exclusiveMaximum)), typeof d == "number" && (a.multipleOf = d);
}, p_ = (e, t, n, o) => {
  n.type = "boolean";
}, HP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("BigInt cannot be represented in JSON Schema");
}, ZP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Symbols cannot be represented in JSON Schema");
}, m_ = (e, t, n, o) => {
  t.target === "openapi-3.0" ? (n.type = "string", n.nullable = !0, n.enum = [null]) : n.type = "null";
}, FP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Undefined cannot be represented in JSON Schema");
}, GP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Void cannot be represented in JSON Schema");
}, g_ = (e, t, n, o) => {
  n.not = {};
}, YP = (e, t, n, o) => {
}, v_ = (e, t, n, o) => {
}, qP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Date cannot be represented in JSON Schema");
}, y_ = (e, t, n, o) => {
  const a = e._zod.def, l = FE(a.entries);
  l.every((c) => typeof c == "number") && (n.type = "number"), l.every((c) => typeof c == "string") && (n.type = "string"), n.enum = l;
}, b_ = (e, t, n, o) => {
  const a = e._zod.def, l = [];
  for (const c of a.values)
    if (c === void 0) {
      if (t.unrepresentable === "throw")
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof c == "bigint") {
      if (t.unrepresentable === "throw")
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      l.push(Number(c));
    } else
      l.push(c);
  if (l.length !== 0) if (l.length === 1) {
    const c = l[0];
    n.type = c === null ? "null" : typeof c, t.target === "draft-04" || t.target === "openapi-3.0" ? n.enum = [c] : n.const = c;
  } else
    l.every((c) => typeof c == "number") && (n.type = "number"), l.every((c) => typeof c == "string") && (n.type = "string"), l.every((c) => typeof c == "boolean") && (n.type = "boolean"), l.every((c) => c === null) && (n.type = "null"), n.enum = l;
}, XP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("NaN cannot be represented in JSON Schema");
}, WP = (e, t, n, o) => {
  const a = n, l = e._zod.pattern;
  if (!l)
    throw new Error("Pattern not found in template literal");
  a.type = "string", a.pattern = l.source;
}, KP = (e, t, n, o) => {
  const a = n, l = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  }, { minimum: c, maximum: f, mime: d } = e._zod.bag;
  c !== void 0 && (l.minLength = c), f !== void 0 && (l.maxLength = f), d ? d.length === 1 ? (l.contentMediaType = d[0], Object.assign(a, l)) : (Object.assign(a, l), a.anyOf = d.map((h) => ({ contentMediaType: h }))) : Object.assign(a, l);
}, JP = (e, t, n, o) => {
  n.type = "boolean";
}, x_ = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, QP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Function types cannot be represented in JSON Schema");
}, S_ = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, e4 = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Map cannot be represented in JSON Schema");
}, t4 = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Set cannot be represented in JSON Schema");
}, w_ = (e, t, n, o) => {
  const a = n, l = e._zod.def, { minimum: c, maximum: f } = e._zod.bag;
  typeof c == "number" && (a.minItems = c), typeof f == "number" && (a.maxItems = f), a.type = "array", a.items = tt(l.element, t, { ...o, path: [...o.path, "items"] });
}, E_ = (e, t, n, o) => {
  const a = n, l = e._zod.def;
  a.type = "object", a.properties = {};
  const c = l.shape;
  for (const h in c)
    a.properties[h] = tt(c[h], t, {
      ...o,
      path: [...o.path, "properties", h]
    });
  const f = new Set(Object.keys(c)), d = new Set([...f].filter((h) => {
    const m = l.shape[h]._zod;
    return t.io === "input" ? m.optin === void 0 : m.optout === void 0;
  }));
  d.size > 0 && (a.required = Array.from(d)), l.catchall?._zod.def.type === "never" ? a.additionalProperties = !1 : l.catchall ? l.catchall && (a.additionalProperties = tt(l.catchall, t, {
    ...o,
    path: [...o.path, "additionalProperties"]
  })) : t.io === "output" && (a.additionalProperties = !1);
}, __ = (e, t, n, o) => {
  const a = e._zod.def, l = a.inclusive === !1, c = a.options.map((f, d) => tt(f, t, {
    ...o,
    path: [...o.path, l ? "oneOf" : "anyOf", d]
  }));
  l ? n.oneOf = c : n.anyOf = c;
}, T_ = (e, t, n, o) => {
  const a = e._zod.def, l = tt(a.left, t, {
    ...o,
    path: [...o.path, "allOf", 0]
  }), c = tt(a.right, t, {
    ...o,
    path: [...o.path, "allOf", 1]
  }), f = (h) => "allOf" in h && Object.keys(h).length === 1, d = [
    ...f(l) ? l.allOf : [l],
    ...f(c) ? c.allOf : [c]
  ];
  n.allOf = d;
}, n4 = (e, t, n, o) => {
  const a = n, l = e._zod.def;
  a.type = "array";
  const c = t.target === "draft-2020-12" ? "prefixItems" : "items", f = t.target === "draft-2020-12" || t.target === "openapi-3.0" ? "items" : "additionalItems", d = l.items.map((b, x) => tt(b, t, {
    ...o,
    path: [...o.path, c, x]
  })), h = l.rest ? tt(l.rest, t, {
    ...o,
    path: [...o.path, f, ...t.target === "openapi-3.0" ? [l.items.length] : []]
  }) : null;
  t.target === "draft-2020-12" ? (a.prefixItems = d, h && (a.items = h)) : t.target === "openapi-3.0" ? (a.items = {
    anyOf: d
  }, h && a.items.anyOf.push(h), a.minItems = d.length, h || (a.maxItems = d.length)) : (a.items = d, h && (a.additionalItems = h));
  const { minimum: m, maximum: g } = e._zod.bag;
  typeof m == "number" && (a.minItems = m), typeof g == "number" && (a.maxItems = g);
}, C_ = (e, t, n, o) => {
  const a = n, l = e._zod.def;
  a.type = "object";
  const c = l.keyType, d = c._zod.bag?.patterns;
  if (l.mode === "loose" && d && d.size > 0) {
    const m = tt(l.valueType, t, {
      ...o,
      path: [...o.path, "patternProperties", "*"]
    });
    a.patternProperties = {};
    for (const g of d)
      a.patternProperties[g.source] = m;
  } else
    (t.target === "draft-07" || t.target === "draft-2020-12") && (a.propertyNames = tt(l.keyType, t, {
      ...o,
      path: [...o.path, "propertyNames"]
    })), a.additionalProperties = tt(l.valueType, t, {
      ...o,
      path: [...o.path, "additionalProperties"]
    });
  const h = c._zod.values;
  if (h) {
    const m = [...h].filter((g) => typeof g == "string" || typeof g == "number");
    m.length > 0 && (a.required = m);
  }
}, A_ = (e, t, n, o) => {
  const a = e._zod.def, l = tt(a.innerType, t, o), c = t.seen.get(e);
  t.target === "openapi-3.0" ? (c.ref = a.innerType, n.nullable = !0) : n.anyOf = [l, { type: "null" }];
}, R_ = (e, t, n, o) => {
  const a = e._zod.def;
  tt(a.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = a.innerType;
}, M_ = (e, t, n, o) => {
  const a = e._zod.def;
  tt(a.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = a.innerType, n.default = JSON.parse(JSON.stringify(a.defaultValue));
}, z_ = (e, t, n, o) => {
  const a = e._zod.def;
  tt(a.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = a.innerType, t.io === "input" && (n._prefault = JSON.parse(JSON.stringify(a.defaultValue)));
}, D_ = (e, t, n, o) => {
  const a = e._zod.def;
  tt(a.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = a.innerType;
  let c;
  try {
    c = a.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  n.default = c;
}, N_ = (e, t, n, o) => {
  const a = e._zod.def, l = t.io === "input" ? a.in._zod.def.type === "transform" ? a.out : a.in : a.out;
  tt(l, t, o);
  const c = t.seen.get(e);
  c.ref = l;
}, O_ = (e, t, n, o) => {
  const a = e._zod.def;
  tt(a.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = a.innerType, n.readOnly = !0;
}, r4 = (e, t, n, o) => {
  const a = e._zod.def;
  tt(a.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = a.innerType;
}, Rg = (e, t, n, o) => {
  const a = e._zod.def;
  tt(a.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = a.innerType;
}, j_ = (e, t, n, o) => {
  const a = e._zod.innerType;
  tt(a, t, o);
  const l = t.seen.get(e);
  l.ref = a;
}, ew = {
  string: d_,
  number: h_,
  boolean: p_,
  bigint: HP,
  symbol: ZP,
  null: m_,
  undefined: FP,
  void: GP,
  never: g_,
  any: YP,
  unknown: v_,
  date: qP,
  enum: y_,
  literal: b_,
  nan: XP,
  template_literal: WP,
  file: KP,
  success: JP,
  custom: x_,
  function: QP,
  transform: S_,
  map: e4,
  set: t4,
  array: w_,
  object: E_,
  union: __,
  intersection: T_,
  tuple: n4,
  record: C_,
  nullable: A_,
  nonoptional: R_,
  default: M_,
  prefault: z_,
  catch: D_,
  pipe: N_,
  readonly: O_,
  promise: r4,
  optional: Rg,
  lazy: j_
};
function o4(e, t) {
  if ("_idmap" in e) {
    const o = e, a = Zu({ ...t, processors: ew }), l = {};
    for (const d of o._idmap.entries()) {
      const [h, m] = d;
      tt(m, a);
    }
    const c = {}, f = {
      registry: o,
      uri: t?.uri,
      defs: l
    };
    a.external = f;
    for (const d of o._idmap.entries()) {
      const [h, m] = d;
      Fu(a, m), c[h] = Gu(a, m);
    }
    if (Object.keys(l).length > 0) {
      const d = a.target === "draft-2020-12" ? "$defs" : "definitions";
      c.__shared = {
        [d]: l
      };
    }
    return { schemas: c };
  }
  const n = Zu({ ...t, processors: ew });
  return tt(e, n), Fu(n, e), Gu(n, e);
}
const i4 = /* @__PURE__ */ ee("ZodISODateTime", (e, t) => {
  sk.init(e, t), dt.init(e, t);
});
function a4(e) {
  return /* @__PURE__ */ mP(i4, e);
}
const s4 = /* @__PURE__ */ ee("ZodISODate", (e, t) => {
  lk.init(e, t), dt.init(e, t);
});
function l4(e) {
  return /* @__PURE__ */ gP(s4, e);
}
const c4 = /* @__PURE__ */ ee("ZodISOTime", (e, t) => {
  ck.init(e, t), dt.init(e, t);
});
function u4(e) {
  return /* @__PURE__ */ vP(c4, e);
}
const f4 = /* @__PURE__ */ ee("ZodISODuration", (e, t) => {
  uk.init(e, t), dt.init(e, t);
});
function d4(e) {
  return /* @__PURE__ */ yP(f4, e);
}
const h4 = (e, t) => {
  XE.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (n) => Q2(e, n)
      // enumerable: false,
    },
    flatten: {
      value: (n) => J2(e, n)
      // enumerable: false,
    },
    addIssue: {
      value: (n) => {
        e.issues.push(n), e.message = JSON.stringify(e.issues, _m, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (n) => {
        e.issues.push(...n), e.message = JSON.stringify(e.issues, _m, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, Bn = ee("ZodError", h4, {
  Parent: Error
}), p4 = /* @__PURE__ */ Tg(Bn), m4 = /* @__PURE__ */ Cg(Bn), g4 = /* @__PURE__ */ Mf(Bn), k_ = /* @__PURE__ */ zf(Bn), v4 = /* @__PURE__ */ nj(Bn), y4 = /* @__PURE__ */ rj(Bn), b4 = /* @__PURE__ */ oj(Bn), x4 = /* @__PURE__ */ ij(Bn), S4 = /* @__PURE__ */ aj(Bn), w4 = /* @__PURE__ */ sj(Bn), E4 = /* @__PURE__ */ lj(Bn), _4 = /* @__PURE__ */ cj(Bn), st = /* @__PURE__ */ ee("ZodType", (e, t) => (at.init(e, t), Object.assign(e["~standard"], {
  jsonSchema: {
    input: Yu(e, "input"),
    output: Yu(e, "output")
  }
}), e.toJSONSchema = BP(e, {}), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(Lo(t, {
  checks: [
    ...t.checks ?? [],
    ...n.map((o) => typeof o == "function" ? { _zod: { check: o, def: { check: "custom" }, onattach: [] } } : o)
  ]
}), {
  parent: !0
}), e.with = e.check, e.clone = (n, o) => Io(e, n, o), e.brand = () => e, e.register = ((n, o) => (n.add(e, o), e)), e.parse = (n, o) => p4(e, n, o, { callee: e.parse }), e.safeParse = (n, o) => g4(e, n, o), e.parseAsync = async (n, o) => m4(e, n, o, { callee: e.parseAsync }), e.safeParseAsync = async (n, o) => k_(e, n, o), e.spa = e.safeParseAsync, e.encode = (n, o) => v4(e, n, o), e.decode = (n, o) => y4(e, n, o), e.encodeAsync = async (n, o) => b4(e, n, o), e.decodeAsync = async (n, o) => x4(e, n, o), e.safeEncode = (n, o) => S4(e, n, o), e.safeDecode = (n, o) => w4(e, n, o), e.safeEncodeAsync = async (n, o) => E4(e, n, o), e.safeDecodeAsync = async (n, o) => _4(e, n, o), e.refine = (n, o) => e.check(xL(n, o)), e.superRefine = (n) => e.check(SL(n)), e.overwrite = (n) => e.check(/* @__PURE__ */ Va(n)), e.optional = () => rw(e), e.exactOptional = () => aL(e), e.nullable = () => ow(e), e.nullish = () => rw(ow(e)), e.nonoptional = (n) => dL(e, n), e.array = () => Ua(e), e.or = (n) => Un([e, n]), e.and = (n) => eL(e, n), e.transform = (n) => iw(e, oL(n)), e.default = (n) => cL(e, n), e.prefault = (n) => fL(e, n), e.catch = (n) => pL(e, n), e.pipe = (n) => iw(e, n), e.readonly = () => vL(e), e.describe = (n) => {
  const o = e.clone();
  return Xs.add(o, { description: n }), o;
}, Object.defineProperty(e, "description", {
  get() {
    return Xs.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...n) => {
  if (n.length === 0)
    return Xs.get(e);
  const o = e.clone();
  return Xs.add(o, n[0]), o;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e.apply = (n) => n(e), e)), P_ = /* @__PURE__ */ ee("_ZodString", (e, t) => {
  Ag.init(e, t), st.init(e, t), e._zod.processJSONSchema = (o, a, l) => d_(e, o, a);
  const n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...o) => e.check(/* @__PURE__ */ TP(...o)), e.includes = (...o) => e.check(/* @__PURE__ */ RP(...o)), e.startsWith = (...o) => e.check(/* @__PURE__ */ MP(...o)), e.endsWith = (...o) => e.check(/* @__PURE__ */ zP(...o)), e.min = (...o) => e.check(/* @__PURE__ */ Hu(...o)), e.max = (...o) => e.check(/* @__PURE__ */ u_(...o)), e.length = (...o) => e.check(/* @__PURE__ */ f_(...o)), e.nonempty = (...o) => e.check(/* @__PURE__ */ Hu(1, ...o)), e.lowercase = (o) => e.check(/* @__PURE__ */ CP(o)), e.uppercase = (o) => e.check(/* @__PURE__ */ AP(o)), e.trim = () => e.check(/* @__PURE__ */ NP()), e.normalize = (...o) => e.check(/* @__PURE__ */ DP(...o)), e.toLowerCase = () => e.check(/* @__PURE__ */ OP()), e.toUpperCase = () => e.check(/* @__PURE__ */ jP()), e.slugify = () => e.check(/* @__PURE__ */ kP());
}), T4 = /* @__PURE__ */ ee("ZodString", (e, t) => {
  Ag.init(e, t), P_.init(e, t), e.email = (n) => e.check(/* @__PURE__ */ qk(C4, n)), e.url = (n) => e.check(/* @__PURE__ */ Qk(A4, n)), e.jwt = (n) => e.check(/* @__PURE__ */ pP($4, n)), e.emoji = (n) => e.check(/* @__PURE__ */ eP(R4, n)), e.guid = (n) => e.check(/* @__PURE__ */ WS(tw, n)), e.uuid = (n) => e.check(/* @__PURE__ */ Xk(pu, n)), e.uuidv4 = (n) => e.check(/* @__PURE__ */ Wk(pu, n)), e.uuidv6 = (n) => e.check(/* @__PURE__ */ Kk(pu, n)), e.uuidv7 = (n) => e.check(/* @__PURE__ */ Jk(pu, n)), e.nanoid = (n) => e.check(/* @__PURE__ */ tP(M4, n)), e.guid = (n) => e.check(/* @__PURE__ */ WS(tw, n)), e.cuid = (n) => e.check(/* @__PURE__ */ nP(z4, n)), e.cuid2 = (n) => e.check(/* @__PURE__ */ rP(D4, n)), e.ulid = (n) => e.check(/* @__PURE__ */ oP(N4, n)), e.base64 = (n) => e.check(/* @__PURE__ */ fP(V4, n)), e.base64url = (n) => e.check(/* @__PURE__ */ dP(U4, n)), e.xid = (n) => e.check(/* @__PURE__ */ iP(O4, n)), e.ksuid = (n) => e.check(/* @__PURE__ */ aP(j4, n)), e.ipv4 = (n) => e.check(/* @__PURE__ */ sP(k4, n)), e.ipv6 = (n) => e.check(/* @__PURE__ */ lP(P4, n)), e.cidrv4 = (n) => e.check(/* @__PURE__ */ cP(L4, n)), e.cidrv6 = (n) => e.check(/* @__PURE__ */ uP(I4, n)), e.e164 = (n) => e.check(/* @__PURE__ */ hP(B4, n)), e.datetime = (n) => e.check(a4(n)), e.date = (n) => e.check(l4(n)), e.time = (n) => e.check(u4(n)), e.duration = (n) => e.check(d4(n));
});
function we(e) {
  return /* @__PURE__ */ Yk(T4, e);
}
const dt = /* @__PURE__ */ ee("ZodStringFormat", (e, t) => {
  ct.init(e, t), P_.init(e, t);
}), C4 = /* @__PURE__ */ ee("ZodEmail", (e, t) => {
  Jj.init(e, t), dt.init(e, t);
}), tw = /* @__PURE__ */ ee("ZodGUID", (e, t) => {
  Wj.init(e, t), dt.init(e, t);
}), pu = /* @__PURE__ */ ee("ZodUUID", (e, t) => {
  Kj.init(e, t), dt.init(e, t);
}), A4 = /* @__PURE__ */ ee("ZodURL", (e, t) => {
  Qj.init(e, t), dt.init(e, t);
}), R4 = /* @__PURE__ */ ee("ZodEmoji", (e, t) => {
  ek.init(e, t), dt.init(e, t);
}), M4 = /* @__PURE__ */ ee("ZodNanoID", (e, t) => {
  tk.init(e, t), dt.init(e, t);
}), z4 = /* @__PURE__ */ ee("ZodCUID", (e, t) => {
  nk.init(e, t), dt.init(e, t);
}), D4 = /* @__PURE__ */ ee("ZodCUID2", (e, t) => {
  rk.init(e, t), dt.init(e, t);
}), N4 = /* @__PURE__ */ ee("ZodULID", (e, t) => {
  ok.init(e, t), dt.init(e, t);
}), O4 = /* @__PURE__ */ ee("ZodXID", (e, t) => {
  ik.init(e, t), dt.init(e, t);
}), j4 = /* @__PURE__ */ ee("ZodKSUID", (e, t) => {
  ak.init(e, t), dt.init(e, t);
}), k4 = /* @__PURE__ */ ee("ZodIPv4", (e, t) => {
  fk.init(e, t), dt.init(e, t);
}), P4 = /* @__PURE__ */ ee("ZodIPv6", (e, t) => {
  dk.init(e, t), dt.init(e, t);
}), L4 = /* @__PURE__ */ ee("ZodCIDRv4", (e, t) => {
  hk.init(e, t), dt.init(e, t);
}), I4 = /* @__PURE__ */ ee("ZodCIDRv6", (e, t) => {
  pk.init(e, t), dt.init(e, t);
}), V4 = /* @__PURE__ */ ee("ZodBase64", (e, t) => {
  mk.init(e, t), dt.init(e, t);
}), U4 = /* @__PURE__ */ ee("ZodBase64URL", (e, t) => {
  vk.init(e, t), dt.init(e, t);
}), B4 = /* @__PURE__ */ ee("ZodE164", (e, t) => {
  yk.init(e, t), dt.init(e, t);
}), $4 = /* @__PURE__ */ ee("ZodJWT", (e, t) => {
  xk.init(e, t), dt.init(e, t);
}), L_ = /* @__PURE__ */ ee("ZodNumber", (e, t) => {
  i_.init(e, t), st.init(e, t), e._zod.processJSONSchema = (o, a, l) => h_(e, o, a), e.gt = (o, a) => e.check(/* @__PURE__ */ JS(o, a)), e.gte = (o, a) => e.check(/* @__PURE__ */ Op(o, a)), e.min = (o, a) => e.check(/* @__PURE__ */ Op(o, a)), e.lt = (o, a) => e.check(/* @__PURE__ */ KS(o, a)), e.lte = (o, a) => e.check(/* @__PURE__ */ Np(o, a)), e.max = (o, a) => e.check(/* @__PURE__ */ Np(o, a)), e.int = (o) => e.check(nw(o)), e.safe = (o) => e.check(nw(o)), e.positive = (o) => e.check(/* @__PURE__ */ JS(0, o)), e.nonnegative = (o) => e.check(/* @__PURE__ */ Op(0, o)), e.negative = (o) => e.check(/* @__PURE__ */ KS(0, o)), e.nonpositive = (o) => e.check(/* @__PURE__ */ Np(0, o)), e.multipleOf = (o, a) => e.check(/* @__PURE__ */ QS(o, a)), e.step = (o, a) => e.check(/* @__PURE__ */ QS(o, a)), e.finite = () => e;
  const n = e._zod.bag;
  e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? 0.5), e.isFinite = !0, e.format = n.format ?? null;
});
function H4(e) {
  return /* @__PURE__ */ bP(L_, e);
}
const Z4 = /* @__PURE__ */ ee("ZodNumberFormat", (e, t) => {
  Sk.init(e, t), L_.init(e, t);
});
function nw(e) {
  return /* @__PURE__ */ xP(Z4, e);
}
const F4 = /* @__PURE__ */ ee("ZodBoolean", (e, t) => {
  wk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => p_(e, n, o);
});
function an(e) {
  return /* @__PURE__ */ SP(F4, e);
}
const G4 = /* @__PURE__ */ ee("ZodNull", (e, t) => {
  Ek.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => m_(e, n, o);
});
function Y4(e) {
  return /* @__PURE__ */ wP(G4, e);
}
const q4 = /* @__PURE__ */ ee("ZodUnknown", (e, t) => {
  _k.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => v_();
});
function cr() {
  return /* @__PURE__ */ EP(q4);
}
const X4 = /* @__PURE__ */ ee("ZodNever", (e, t) => {
  Tk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => g_(e, n, o);
});
function I_(e) {
  return /* @__PURE__ */ _P(X4, e);
}
const W4 = /* @__PURE__ */ ee("ZodArray", (e, t) => {
  Ck.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => w_(e, n, o, a), e.element = t.element, e.min = (n, o) => e.check(/* @__PURE__ */ Hu(n, o)), e.nonempty = (n) => e.check(/* @__PURE__ */ Hu(1, n)), e.max = (n, o) => e.check(/* @__PURE__ */ u_(n, o)), e.length = (n, o) => e.check(/* @__PURE__ */ f_(n, o)), e.unwrap = () => e.element;
});
function Ua(e, t) {
  return /* @__PURE__ */ PP(W4, e, t);
}
const V_ = /* @__PURE__ */ ee("ZodObject", (e, t) => {
  Rk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => E_(e, n, o, a), Be(e, "shape", () => t.shape), e.keyof = () => B_(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: cr() }), e.loose = () => e.clone({ ...e._zod.def, catchall: cr() }), e.strict = () => e.clone({ ...e._zod.def, catchall: I_() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => Y2(e, n), e.safeExtend = (n) => q2(e, n), e.merge = (n) => X2(e, n), e.pick = (n) => F2(e, n), e.omit = (n) => G2(e, n), e.partial = (...n) => W2($_, e, n[0]), e.required = (...n) => K2(H_, e, n[0]);
});
function Bt(e, t) {
  const n = {
    type: "object",
    shape: e ?? {},
    ...xe(t)
  };
  return new V_(n);
}
function ut(e, t) {
  return new V_({
    type: "object",
    shape: e,
    catchall: I_(),
    ...xe(t)
  });
}
const U_ = /* @__PURE__ */ ee("ZodUnion", (e, t) => {
  l_.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => __(e, n, o, a), e.options = t.options;
});
function Un(e, t) {
  return new U_({
    type: "union",
    options: e,
    ...xe(t)
  });
}
const K4 = /* @__PURE__ */ ee("ZodDiscriminatedUnion", (e, t) => {
  U_.init(e, t), Mk.init(e, t);
});
function J4(e, t, n) {
  return new K4({
    type: "union",
    options: t,
    discriminator: e,
    ...xe(n)
  });
}
const Q4 = /* @__PURE__ */ ee("ZodIntersection", (e, t) => {
  zk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => T_(e, n, o, a);
});
function eL(e, t) {
  return new Q4({
    type: "intersection",
    left: e,
    right: t
  });
}
const tL = /* @__PURE__ */ ee("ZodRecord", (e, t) => {
  Dk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => C_(e, n, o, a), e.keyType = t.keyType, e.valueType = t.valueType;
});
function Cm(e, t, n) {
  return new tL({
    type: "record",
    keyType: e,
    valueType: t,
    ...xe(n)
  });
}
const Am = /* @__PURE__ */ ee("ZodEnum", (e, t) => {
  Nk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (o, a, l) => y_(e, o, a), e.enum = t.entries, e.options = Object.values(t.entries);
  const n = new Set(Object.keys(t.entries));
  e.extract = (o, a) => {
    const l = {};
    for (const c of o)
      if (n.has(c))
        l[c] = t.entries[c];
      else
        throw new Error(`Key ${c} not found in enum`);
    return new Am({
      ...t,
      checks: [],
      ...xe(a),
      entries: l
    });
  }, e.exclude = (o, a) => {
    const l = { ...t.entries };
    for (const c of o)
      if (n.has(c))
        delete l[c];
      else
        throw new Error(`Key ${c} not found in enum`);
    return new Am({
      ...t,
      checks: [],
      ...xe(a),
      entries: l
    });
  };
});
function B_(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((o) => [o, o])) : e;
  return new Am({
    type: "enum",
    entries: n,
    ...xe(t)
  });
}
const nL = /* @__PURE__ */ ee("ZodLiteral", (e, t) => {
  Ok.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => b_(e, n, o), e.values = new Set(t.values), Object.defineProperty(e, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function Oe(e, t) {
  return new nL({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...xe(t)
  });
}
const rL = /* @__PURE__ */ ee("ZodTransform", (e, t) => {
  jk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => S_(e, n), e._zod.parse = (n, o) => {
    if (o.direction === "backward")
      throw new HE(e.constructor.name);
    n.addIssue = (l) => {
      if (typeof l == "string")
        n.issues.push(hl(l, n.value, t));
      else {
        const c = l;
        c.fatal && (c.continue = !1), c.code ?? (c.code = "custom"), c.input ?? (c.input = n.value), c.inst ?? (c.inst = e), n.issues.push(hl(c));
      }
    };
    const a = t.transform(n.value, n);
    return a instanceof Promise ? a.then((l) => (n.value = l, n)) : (n.value = a, n);
  };
});
function oL(e) {
  return new rL({
    type: "transform",
    transform: e
  });
}
const $_ = /* @__PURE__ */ ee("ZodOptional", (e, t) => {
  c_.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => Rg(e, n, o, a), e.unwrap = () => e._zod.def.innerType;
});
function rw(e) {
  return new $_({
    type: "optional",
    innerType: e
  });
}
const iL = /* @__PURE__ */ ee("ZodExactOptional", (e, t) => {
  kk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => Rg(e, n, o, a), e.unwrap = () => e._zod.def.innerType;
});
function aL(e) {
  return new iL({
    type: "optional",
    innerType: e
  });
}
const sL = /* @__PURE__ */ ee("ZodNullable", (e, t) => {
  Pk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => A_(e, n, o, a), e.unwrap = () => e._zod.def.innerType;
});
function ow(e) {
  return new sL({
    type: "nullable",
    innerType: e
  });
}
const lL = /* @__PURE__ */ ee("ZodDefault", (e, t) => {
  Lk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => M_(e, n, o, a), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function cL(e, t) {
  return new lL({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : YE(t);
    }
  });
}
const uL = /* @__PURE__ */ ee("ZodPrefault", (e, t) => {
  Ik.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => z_(e, n, o, a), e.unwrap = () => e._zod.def.innerType;
});
function fL(e, t) {
  return new uL({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : YE(t);
    }
  });
}
const H_ = /* @__PURE__ */ ee("ZodNonOptional", (e, t) => {
  Vk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => R_(e, n, o, a), e.unwrap = () => e._zod.def.innerType;
});
function dL(e, t) {
  return new H_({
    type: "nonoptional",
    innerType: e,
    ...xe(t)
  });
}
const hL = /* @__PURE__ */ ee("ZodCatch", (e, t) => {
  Uk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => D_(e, n, o, a), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function pL(e, t) {
  return new hL({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const mL = /* @__PURE__ */ ee("ZodPipe", (e, t) => {
  Bk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => N_(e, n, o, a), e.in = t.in, e.out = t.out;
});
function iw(e, t) {
  return new mL({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const gL = /* @__PURE__ */ ee("ZodReadonly", (e, t) => {
  $k.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => O_(e, n, o, a), e.unwrap = () => e._zod.def.innerType;
});
function vL(e) {
  return new gL({
    type: "readonly",
    innerType: e
  });
}
const yL = /* @__PURE__ */ ee("ZodLazy", (e, t) => {
  Hk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => j_(e, n, o, a), e.unwrap = () => e._zod.def.getter();
});
function bL(e) {
  return new yL({
    type: "lazy",
    getter: e
  });
}
const Mg = /* @__PURE__ */ ee("ZodCustom", (e, t) => {
  Zk.init(e, t), st.init(e, t), e._zod.processJSONSchema = (n, o, a) => x_(e, n);
});
function Z_(e, t) {
  return /* @__PURE__ */ LP(Mg, e ?? (() => !0), t);
}
function xL(e, t = {}) {
  return /* @__PURE__ */ IP(Mg, e, t);
}
function SL(e) {
  return /* @__PURE__ */ VP(e);
}
function qu(e, t = {}) {
  const n = new Mg({
    type: "custom",
    check: "custom",
    fn: (o) => o instanceof e,
    abort: !0,
    ...xe(t)
  });
  return n._zod.bag.Class = e, n._zod.check = (o) => {
    o.value instanceof e || o.issues.push({
      code: "invalid_type",
      expected: e.name,
      input: o.value,
      inst: n,
      path: [...n._zod.def.path ?? []]
    });
  }, n;
}
var pl;
(function(e) {
  e.assertEqual = (a) => {
  };
  function t(a) {
  }
  e.assertIs = t;
  function n(a) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (a) => {
    const l = {};
    for (const c of a)
      l[c] = c;
    return l;
  }, e.getValidEnumValues = (a) => {
    const l = e.objectKeys(a).filter((f) => typeof a[a[f]] != "number"), c = {};
    for (const f of l)
      c[f] = a[f];
    return e.objectValues(c);
  }, e.objectValues = (a) => e.objectKeys(a).map(function(l) {
    return a[l];
  }), e.objectKeys = typeof Object.keys == "function" ? (a) => Object.keys(a) : (a) => {
    const l = [];
    for (const c in a)
      Object.prototype.hasOwnProperty.call(a, c) && l.push(c);
    return l;
  }, e.find = (a, l) => {
    for (const c of a)
      if (l(c))
        return c;
  }, e.isInteger = typeof Number.isInteger == "function" ? (a) => Number.isInteger(a) : (a) => typeof a == "number" && Number.isFinite(a) && Math.floor(a) === a;
  function o(a, l = " | ") {
    return a.map((c) => typeof c == "string" ? `'${c}'` : c).join(l);
  }
  e.joinValues = o, e.jsonStringifyReplacer = (a, l) => typeof l == "bigint" ? l.toString() : l;
})(pl || (pl = {}));
var aw;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(aw || (aw = {}));
pl.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
pl.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class Xu extends Error {
  get errors() {
    return this.issues;
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = (o) => {
      this.issues = [...this.issues, o];
    }, this.addIssues = (o = []) => {
      this.issues = [...this.issues, ...o];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  format(t) {
    const n = t || function(l) {
      return l.message;
    }, o = { _errors: [] }, a = (l) => {
      for (const c of l.issues)
        if (c.code === "invalid_union")
          c.unionErrors.map(a);
        else if (c.code === "invalid_return_type")
          a(c.returnTypeError);
        else if (c.code === "invalid_arguments")
          a(c.argumentsError);
        else if (c.path.length === 0)
          o._errors.push(n(c));
        else {
          let f = o, d = 0;
          for (; d < c.path.length; ) {
            const h = c.path[d];
            d === c.path.length - 1 ? (f[h] = f[h] || { _errors: [] }, f[h]._errors.push(n(c))) : f[h] = f[h] || { _errors: [] }, f = f[h], d++;
          }
        }
    };
    return a(this), o;
  }
  static assert(t) {
    if (!(t instanceof Xu))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, pl.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = /* @__PURE__ */ Object.create(null), o = [];
    for (const a of this.issues)
      if (a.path.length > 0) {
        const l = a.path[0];
        n[l] = n[l] || [], n[l].push(t(a));
      } else
        o.push(t(a));
    return { formErrors: o, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
Xu.create = (e) => new Xu(e);
var sw;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
})(sw || (sw = {}));
var Ce;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Ce || (Ce = {}));
var Dl = ({
  prefix: e,
  size: t = 16,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: o = "-"
} = {}) => {
  const a = () => {
    const l = n.length, c = new Array(t);
    for (let f = 0; f < t; f++)
      c[f] = n[Math.random() * l | 0];
    return c.join("");
  };
  if (e == null)
    return a;
  if (n.includes(o))
    throw new O2({
      argument: "separator",
      message: `The separator "${o}" must not be part of the alphabet "${n}".`
    });
  return () => `${e}${o}${a()}`;
}, wL = Dl();
function lw(e = globalThis) {
  var t, n, o;
  return e.window ? "runtime/browser" : (t = e.navigator) != null && t.userAgent ? `runtime/${e.navigator.userAgent.toLowerCase()}` : (o = (n = e.process) == null ? void 0 : n.versions) != null && o.node ? `runtime/node.js/${e.process.version.substring(0)}` : e.EdgeRuntime ? "runtime/vercel-edge" : "runtime/unknown";
}
function ci(e) {
  if (e == null)
    return {};
  const t = {};
  if (e instanceof Headers)
    e.forEach((n, o) => {
      t[o.toLowerCase()] = n;
    });
  else {
    Array.isArray(e) || (e = Object.entries(e));
    for (const [n, o] of e)
      o != null && (t[n.toLowerCase()] = o);
  }
  return t;
}
function cw(e, ...t) {
  const n = new Headers(ci(e)), o = n.get("user-agent") || "";
  return n.set(
    "user-agent",
    [o, ...t].filter(Boolean).join(" ")
  ), Object.fromEntries(n.entries());
}
var EL = /"__proto__"\s*:/, _L = /"constructor"\s*:/;
function uw(e) {
  const t = JSON.parse(e);
  return t === null || typeof t != "object" || EL.test(e) === !1 && _L.test(e) === !1 ? t : TL(t);
}
function TL(e) {
  let t = [e];
  for (; t.length; ) {
    const n = t;
    t = [];
    for (const o of n) {
      if (Object.prototype.hasOwnProperty.call(o, "__proto__"))
        throw new SyntaxError("Object contains forbidden prototype property");
      if (Object.prototype.hasOwnProperty.call(o, "constructor") && Object.prototype.hasOwnProperty.call(o.constructor, "prototype"))
        throw new SyntaxError("Object contains forbidden prototype property");
      for (const a in o) {
        const l = o[a];
        l && typeof l == "object" && t.push(l);
      }
    }
  }
  return e;
}
function CL(e) {
  const { stackTraceLimit: t } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch {
    return uw(e);
  }
  try {
    return uw(e);
  } finally {
    Error.stackTraceLimit = t;
  }
}
var Wu = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function AL(e) {
  return { [Wu]: !0, validate: e };
}
function RL(e) {
  return typeof e == "object" && e !== null && Wu in e && e[Wu] === !0 && "validate" in e;
}
function ML(e) {
  let t;
  return () => (t == null && (t = e()), t);
}
function zL(e) {
  return RL(e) ? e : typeof e == "function" ? e() : DL(e);
}
function DL(e) {
  return AL(async (t) => {
    const n = await e["~standard"].validate(t);
    return n.issues == null ? { success: !0, value: n.value } : {
      success: !1,
      error: new Bu({
        value: t,
        cause: n.issues
      })
    };
  });
}
async function fw({
  value: e,
  schema: t
}) {
  const n = await zg({ value: e, schema: t });
  if (!n.success)
    throw Bu.wrap({ value: e, cause: n.error });
  return n.value;
}
async function zg({
  value: e,
  schema: t
}) {
  const n = zL(t);
  try {
    if (n.validate == null)
      return { success: !0, value: e, rawValue: e };
    const o = await n.validate(e);
    return o.success ? { success: !0, value: o.value, rawValue: e } : {
      success: !1,
      error: Bu.wrap({ value: e, cause: o.error }),
      rawValue: e
    };
  } catch (o) {
    return {
      success: !1,
      error: Bu.wrap({ value: e, cause: o }),
      rawValue: e
    };
  }
}
async function Ku({
  text: e,
  schema: t
}) {
  try {
    const n = CL(e);
    return t == null ? { success: !0, value: n, rawValue: n } : await zg({ value: n, schema: t });
  } catch (n) {
    return {
      success: !1,
      error: jS.isInstance(n) ? n : new jS({ text: e, cause: n }),
      rawValue: void 0
    };
  }
}
function NL({
  stream: e,
  schema: t
}) {
  return e.pipeThrough(new TextDecoderStream()).pipeThrough(new I2()).pipeThrough(
    new TransformStream({
      async transform({ data: n }, o) {
        n !== "[DONE]" && o.enqueue(await Ku({ text: n, schema: t }));
      }
    })
  );
}
async function fa(e) {
  return typeof e == "function" && (e = e()), Promise.resolve(e);
}
function Ru(e) {
  if (e.type === "object") {
    e.additionalProperties = !1;
    const t = e.properties;
    if (t != null)
      for (const n in t)
        t[n] = Ru(
          t[n]
        );
  }
  return e.type === "array" && e.items != null && (Array.isArray(e.items) ? e.items = e.items.map(
    (t) => Ru(t)
  ) : e.items = Ru(
    e.items
  )), e;
}
var OL = (e, t) => {
  let n = 0;
  for (; n < e.length && n < t.length && e[n] === t[n]; n++)
    ;
  return [(e.length - n).toString(), ...t.slice(n)].join("/");
}, jL = /* @__PURE__ */ Symbol(
  "Let zodToJsonSchema decide on which parser to use"
), dw = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, kL = (e) => typeof e == "string" ? {
  ...dw,
  name: e
} : {
  ...dw,
  ...e
};
function En() {
  return {};
}
function PL(e, t) {
  var n, o, a;
  const l = {
    type: "array"
  };
  return (n = e.type) != null && n._def && ((a = (o = e.type) == null ? void 0 : o._def) == null ? void 0 : a.typeName) !== Ce.ZodAny && (l.items = qe(e.type._def, {
    ...t,
    currentPath: [...t.currentPath, "items"]
  })), e.minLength && (l.minItems = e.minLength.value), e.maxLength && (l.maxItems = e.maxLength.value), e.exactLength && (l.minItems = e.exactLength.value, l.maxItems = e.exactLength.value), l;
}
function LL(e) {
  const t = {
    type: "integer",
    format: "int64"
  };
  if (!e.checks) return t;
  for (const n of e.checks)
    switch (n.kind) {
      case "min":
        n.inclusive ? t.minimum = n.value : t.exclusiveMinimum = n.value;
        break;
      case "max":
        n.inclusive ? t.maximum = n.value : t.exclusiveMaximum = n.value;
        break;
      case "multipleOf":
        t.multipleOf = n.value;
        break;
    }
  return t;
}
function IL() {
  return { type: "boolean" };
}
function F_(e, t) {
  return qe(e.type._def, t);
}
var VL = (e, t) => qe(e.innerType._def, t);
function G_(e, t, n) {
  const o = n ?? t.dateStrategy;
  if (Array.isArray(o))
    return {
      anyOf: o.map((a, l) => G_(e, t, a))
    };
  switch (o) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return UL(e);
  }
}
var UL = (e) => {
  const t = {
    type: "integer",
    format: "unix-time"
  };
  for (const n of e.checks)
    switch (n.kind) {
      case "min":
        t.minimum = n.value;
        break;
      case "max":
        t.maximum = n.value;
        break;
    }
  return t;
};
function BL(e, t) {
  return {
    ...qe(e.innerType._def, t),
    default: e.defaultValue()
  };
}
function $L(e, t) {
  return t.effectStrategy === "input" ? qe(e.schema._def, t) : En();
}
function HL(e) {
  return {
    type: "string",
    enum: Array.from(e.values)
  };
}
var ZL = (e) => "type" in e && e.type === "string" ? !1 : "allOf" in e;
function FL(e, t) {
  const n = [
    qe(e.left._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "0"]
    }),
    qe(e.right._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "1"]
    })
  ].filter((a) => !!a), o = [];
  return n.forEach((a) => {
    if (ZL(a))
      o.push(...a.allOf);
    else {
      let l = a;
      if ("additionalProperties" in a && a.additionalProperties === !1) {
        const { additionalProperties: c, ...f } = a;
        l = f;
      }
      o.push(l);
    }
  }), o.length ? { allOf: o } : void 0;
}
function GL(e) {
  const t = typeof e.value;
  return t !== "bigint" && t !== "number" && t !== "boolean" && t !== "string" ? {
    type: Array.isArray(e.value) ? "array" : "object"
  } : {
    type: t === "bigint" ? "integer" : t,
    const: e.value
  };
}
var jp = void 0, Gn = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (jp === void 0 && (jp = RegExp(
    "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
    "u"
  )), jp),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function Y_(e, t) {
  const n = {
    type: "string"
  };
  if (e.checks)
    for (const o of e.checks)
      switch (o.kind) {
        case "min":
          n.minLength = typeof n.minLength == "number" ? Math.max(n.minLength, o.value) : o.value;
          break;
        case "max":
          n.maxLength = typeof n.maxLength == "number" ? Math.min(n.maxLength, o.value) : o.value;
          break;
        case "email":
          switch (t.emailStrategy) {
            case "format:email":
              Yn(n, "email", o.message, t);
              break;
            case "format:idn-email":
              Yn(n, "idn-email", o.message, t);
              break;
            case "pattern:zod":
              Yt(n, Gn.email, o.message, t);
              break;
          }
          break;
        case "url":
          Yn(n, "uri", o.message, t);
          break;
        case "uuid":
          Yn(n, "uuid", o.message, t);
          break;
        case "regex":
          Yt(n, o.regex, o.message, t);
          break;
        case "cuid":
          Yt(n, Gn.cuid, o.message, t);
          break;
        case "cuid2":
          Yt(n, Gn.cuid2, o.message, t);
          break;
        case "startsWith":
          Yt(
            n,
            RegExp(`^${kp(o.value, t)}`),
            o.message,
            t
          );
          break;
        case "endsWith":
          Yt(
            n,
            RegExp(`${kp(o.value, t)}$`),
            o.message,
            t
          );
          break;
        case "datetime":
          Yn(n, "date-time", o.message, t);
          break;
        case "date":
          Yn(n, "date", o.message, t);
          break;
        case "time":
          Yn(n, "time", o.message, t);
          break;
        case "duration":
          Yn(n, "duration", o.message, t);
          break;
        case "length":
          n.minLength = typeof n.minLength == "number" ? Math.max(n.minLength, o.value) : o.value, n.maxLength = typeof n.maxLength == "number" ? Math.min(n.maxLength, o.value) : o.value;
          break;
        case "includes": {
          Yt(
            n,
            RegExp(kp(o.value, t)),
            o.message,
            t
          );
          break;
        }
        case "ip": {
          o.version !== "v6" && Yn(n, "ipv4", o.message, t), o.version !== "v4" && Yn(n, "ipv6", o.message, t);
          break;
        }
        case "base64url":
          Yt(n, Gn.base64url, o.message, t);
          break;
        case "jwt":
          Yt(n, Gn.jwt, o.message, t);
          break;
        case "cidr": {
          o.version !== "v6" && Yt(n, Gn.ipv4Cidr, o.message, t), o.version !== "v4" && Yt(n, Gn.ipv6Cidr, o.message, t);
          break;
        }
        case "emoji":
          Yt(n, Gn.emoji(), o.message, t);
          break;
        case "ulid": {
          Yt(n, Gn.ulid, o.message, t);
          break;
        }
        case "base64": {
          switch (t.base64Strategy) {
            case "format:binary": {
              Yn(n, "binary", o.message, t);
              break;
            }
            case "contentEncoding:base64": {
              n.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              Yt(n, Gn.base64, o.message, t);
              break;
            }
          }
          break;
        }
        case "nanoid":
          Yt(n, Gn.nanoid, o.message, t);
      }
  return n;
}
function kp(e, t) {
  return t.patternStrategy === "escape" ? qL(e) : e;
}
var YL = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function qL(e) {
  let t = "";
  for (let n = 0; n < e.length; n++)
    YL.has(e[n]) || (t += "\\"), t += e[n];
  return t;
}
function Yn(e, t, n, o) {
  var a;
  e.format || (a = e.anyOf) != null && a.some((l) => l.format) ? (e.anyOf || (e.anyOf = []), e.format && (e.anyOf.push({
    format: e.format
  }), delete e.format), e.anyOf.push({
    format: t,
    ...n && o.errorMessages && { errorMessage: { format: n } }
  })) : e.format = t;
}
function Yt(e, t, n, o) {
  var a;
  e.pattern || (a = e.allOf) != null && a.some((l) => l.pattern) ? (e.allOf || (e.allOf = []), e.pattern && (e.allOf.push({
    pattern: e.pattern
  }), delete e.pattern), e.allOf.push({
    pattern: hw(t, o),
    ...n && o.errorMessages && { errorMessage: { pattern: n } }
  })) : e.pattern = hw(t, o);
}
function hw(e, t) {
  var n;
  if (!t.applyRegexFlags || !e.flags)
    return e.source;
  const o = {
    i: e.flags.includes("i"),
    // Case-insensitive
    m: e.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: e.flags.includes("s")
    // `.` matches newlines
  }, a = o.i ? e.source.toLowerCase() : e.source;
  let l = "", c = !1, f = !1, d = !1;
  for (let h = 0; h < a.length; h++) {
    if (c) {
      l += a[h], c = !1;
      continue;
    }
    if (o.i) {
      if (f) {
        if (a[h].match(/[a-z]/)) {
          d ? (l += a[h], l += `${a[h - 2]}-${a[h]}`.toUpperCase(), d = !1) : a[h + 1] === "-" && ((n = a[h + 2]) != null && n.match(/[a-z]/)) ? (l += a[h], d = !0) : l += `${a[h]}${a[h].toUpperCase()}`;
          continue;
        }
      } else if (a[h].match(/[a-z]/)) {
        l += `[${a[h]}${a[h].toUpperCase()}]`;
        continue;
      }
    }
    if (o.m) {
      if (a[h] === "^") {
        l += `(^|(?<=[\r
]))`;
        continue;
      } else if (a[h] === "$") {
        l += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (o.s && a[h] === ".") {
      l += f ? `${a[h]}\r
` : `[${a[h]}\r
]`;
      continue;
    }
    l += a[h], a[h] === "\\" ? c = !0 : f && a[h] === "]" ? f = !1 : !f && a[h] === "[" && (f = !0);
  }
  try {
    new RegExp(l);
  } catch {
    return console.warn(
      `Could not convert regex pattern at ${t.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    ), e.source;
  }
  return l;
}
function q_(e, t) {
  var n, o, a, l, c, f;
  const d = {
    type: "object",
    additionalProperties: (n = qe(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    })) != null ? n : t.allowedAdditionalProperties
  };
  if (((o = e.keyType) == null ? void 0 : o._def.typeName) === Ce.ZodString && ((a = e.keyType._def.checks) != null && a.length)) {
    const { type: h, ...m } = Y_(e.keyType._def, t);
    return {
      ...d,
      propertyNames: m
    };
  } else {
    if (((l = e.keyType) == null ? void 0 : l._def.typeName) === Ce.ZodEnum)
      return {
        ...d,
        propertyNames: {
          enum: e.keyType._def.values
        }
      };
    if (((c = e.keyType) == null ? void 0 : c._def.typeName) === Ce.ZodBranded && e.keyType._def.type._def.typeName === Ce.ZodString && ((f = e.keyType._def.type._def.checks) != null && f.length)) {
      const { type: h, ...m } = F_(
        e.keyType._def,
        t
      );
      return {
        ...d,
        propertyNames: m
      };
    }
  }
  return d;
}
function XL(e, t) {
  if (t.mapStrategy === "record")
    return q_(e, t);
  const n = qe(e.keyType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "0"]
  }) || En(), o = qe(e.valueType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "1"]
  }) || En();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, o],
      minItems: 2,
      maxItems: 2
    }
  };
}
function WL(e) {
  const t = e.values, o = Object.keys(e.values).filter((l) => typeof t[t[l]] != "number").map((l) => t[l]), a = Array.from(
    new Set(o.map((l) => typeof l))
  );
  return {
    type: a.length === 1 ? a[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: o
  };
}
function KL() {
  return { not: En() };
}
function JL() {
  return {
    type: "null"
  };
}
var Rm = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function QL(e, t) {
  const n = e.options instanceof Map ? Array.from(e.options.values()) : e.options;
  if (n.every(
    (o) => o._def.typeName in Rm && (!o._def.checks || !o._def.checks.length)
  )) {
    const o = n.reduce((a, l) => {
      const c = Rm[l._def.typeName];
      return c && !a.includes(c) ? [...a, c] : a;
    }, []);
    return {
      type: o.length > 1 ? o : o[0]
    };
  } else if (n.every((o) => o._def.typeName === "ZodLiteral" && !o.description)) {
    const o = n.reduce(
      (a, l) => {
        const c = typeof l._def.value;
        switch (c) {
          case "string":
          case "number":
          case "boolean":
            return [...a, c];
          case "bigint":
            return [...a, "integer"];
          case "object":
            if (l._def.value === null) return [...a, "null"];
          default:
            return a;
        }
      },
      []
    );
    if (o.length === n.length) {
      const a = o.filter((l, c, f) => f.indexOf(l) === c);
      return {
        type: a.length > 1 ? a : a[0],
        enum: n.reduce(
          (l, c) => l.includes(c._def.value) ? l : [...l, c._def.value],
          []
        )
      };
    }
  } else if (n.every((o) => o._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce(
        (o, a) => [
          ...o,
          ...a._def.values.filter((l) => !o.includes(l))
        ],
        []
      )
    };
  return e3(e, t);
}
var e3 = (e, t) => {
  const n = (e.options instanceof Map ? Array.from(e.options.values()) : e.options).map(
    (o, a) => qe(o._def, {
      ...t,
      currentPath: [...t.currentPath, "anyOf", `${a}`]
    })
  ).filter(
    (o) => !!o && (!t.strictUnions || typeof o == "object" && Object.keys(o).length > 0)
  );
  return n.length ? { anyOf: n } : void 0;
};
function t3(e, t) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    e.innerType._def.typeName
  ) && (!e.innerType._def.checks || !e.innerType._def.checks.length))
    return {
      type: [
        Rm[e.innerType._def.typeName],
        "null"
      ]
    };
  const n = qe(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "0"]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function n3(e) {
  const t = {
    type: "number"
  };
  if (!e.checks) return t;
  for (const n of e.checks)
    switch (n.kind) {
      case "int":
        t.type = "integer";
        break;
      case "min":
        n.inclusive ? t.minimum = n.value : t.exclusiveMinimum = n.value;
        break;
      case "max":
        n.inclusive ? t.maximum = n.value : t.exclusiveMaximum = n.value;
        break;
      case "multipleOf":
        t.multipleOf = n.value;
        break;
    }
  return t;
}
function r3(e, t) {
  const n = {
    type: "object",
    properties: {}
  }, o = [], a = e.shape();
  for (const c in a) {
    let f = a[c];
    if (f === void 0 || f._def === void 0)
      continue;
    const d = i3(f), h = qe(f._def, {
      ...t,
      currentPath: [...t.currentPath, "properties", c],
      propertyPath: [...t.currentPath, "properties", c]
    });
    h !== void 0 && (n.properties[c] = h, d || o.push(c));
  }
  o.length && (n.required = o);
  const l = o3(e, t);
  return l !== void 0 && (n.additionalProperties = l), n;
}
function o3(e, t) {
  if (e.catchall._def.typeName !== "ZodNever")
    return qe(e.catchall._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    });
  switch (e.unknownKeys) {
    case "passthrough":
      return t.allowedAdditionalProperties;
    case "strict":
      return t.rejectedAdditionalProperties;
    case "strip":
      return t.removeAdditionalStrategy === "strict" ? t.allowedAdditionalProperties : t.rejectedAdditionalProperties;
  }
}
function i3(e) {
  try {
    return e.isOptional();
  } catch {
    return !0;
  }
}
var a3 = (e, t) => {
  var n;
  if (t.currentPath.toString() === ((n = t.propertyPath) == null ? void 0 : n.toString()))
    return qe(e.innerType._def, t);
  const o = qe(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "1"]
  });
  return o ? { anyOf: [{ not: En() }, o] } : En();
}, s3 = (e, t) => {
  if (t.pipeStrategy === "input")
    return qe(e.in._def, t);
  if (t.pipeStrategy === "output")
    return qe(e.out._def, t);
  const n = qe(e.in._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", "0"]
  }), o = qe(e.out._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", n ? "1" : "0"]
  });
  return {
    allOf: [n, o].filter((a) => a !== void 0)
  };
};
function l3(e, t) {
  return qe(e.type._def, t);
}
function c3(e, t) {
  const o = {
    type: "array",
    uniqueItems: !0,
    items: qe(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "items"]
    })
  };
  return e.minSize && (o.minItems = e.minSize.value), e.maxSize && (o.maxItems = e.maxSize.value), o;
}
function u3(e, t) {
  return e.rest ? {
    type: "array",
    minItems: e.items.length,
    items: e.items.map(
      (n, o) => qe(n._def, {
        ...t,
        currentPath: [...t.currentPath, "items", `${o}`]
      })
    ).reduce(
      (n, o) => o === void 0 ? n : [...n, o],
      []
    ),
    additionalItems: qe(e.rest._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: e.items.length,
    maxItems: e.items.length,
    items: e.items.map(
      (n, o) => qe(n._def, {
        ...t,
        currentPath: [...t.currentPath, "items", `${o}`]
      })
    ).reduce(
      (n, o) => o === void 0 ? n : [...n, o],
      []
    )
  };
}
function f3() {
  return {
    not: En()
  };
}
function d3() {
  return En();
}
var h3 = (e, t) => qe(e.innerType._def, t), p3 = (e, t, n) => {
  switch (t) {
    case Ce.ZodString:
      return Y_(e, n);
    case Ce.ZodNumber:
      return n3(e);
    case Ce.ZodObject:
      return r3(e, n);
    case Ce.ZodBigInt:
      return LL(e);
    case Ce.ZodBoolean:
      return IL();
    case Ce.ZodDate:
      return G_(e, n);
    case Ce.ZodUndefined:
      return f3();
    case Ce.ZodNull:
      return JL();
    case Ce.ZodArray:
      return PL(e, n);
    case Ce.ZodUnion:
    case Ce.ZodDiscriminatedUnion:
      return QL(e, n);
    case Ce.ZodIntersection:
      return FL(e, n);
    case Ce.ZodTuple:
      return u3(e, n);
    case Ce.ZodRecord:
      return q_(e, n);
    case Ce.ZodLiteral:
      return GL(e);
    case Ce.ZodEnum:
      return HL(e);
    case Ce.ZodNativeEnum:
      return WL(e);
    case Ce.ZodNullable:
      return t3(e, n);
    case Ce.ZodOptional:
      return a3(e, n);
    case Ce.ZodMap:
      return XL(e, n);
    case Ce.ZodSet:
      return c3(e, n);
    case Ce.ZodLazy:
      return () => e.getter()._def;
    case Ce.ZodPromise:
      return l3(e, n);
    case Ce.ZodNaN:
    case Ce.ZodNever:
      return KL();
    case Ce.ZodEffects:
      return $L(e, n);
    case Ce.ZodAny:
      return En();
    case Ce.ZodUnknown:
      return d3();
    case Ce.ZodDefault:
      return BL(e, n);
    case Ce.ZodBranded:
      return F_(e, n);
    case Ce.ZodReadonly:
      return h3(e, n);
    case Ce.ZodCatch:
      return VL(e, n);
    case Ce.ZodPipeline:
      return s3(e, n);
    case Ce.ZodFunction:
    case Ce.ZodVoid:
    case Ce.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((o) => {
      })();
  }
};
function qe(e, t, n = !1) {
  var o;
  const a = t.seen.get(e);
  if (t.override) {
    const d = (o = t.override) == null ? void 0 : o.call(
      t,
      e,
      t,
      a,
      n
    );
    if (d !== jL)
      return d;
  }
  if (a && !n) {
    const d = m3(a, t);
    if (d !== void 0)
      return d;
  }
  const l = { def: e, path: t.currentPath, jsonSchema: void 0 };
  t.seen.set(e, l);
  const c = p3(e, e.typeName, t), f = typeof c == "function" ? qe(c(), t) : c;
  if (f && g3(e, t, f), t.postProcess) {
    const d = t.postProcess(f, e, t);
    return l.jsonSchema = f, d;
  }
  return l.jsonSchema = f, f;
}
var m3 = (e, t) => {
  switch (t.$refStrategy) {
    case "root":
      return { $ref: e.path.join("/") };
    case "relative":
      return { $ref: OL(t.currentPath, e.path) };
    case "none":
    case "seen":
      return e.path.length < t.currentPath.length && e.path.every((n, o) => t.currentPath[o] === n) ? (console.warn(
        `Recursive reference detected at ${t.currentPath.join(
          "/"
        )}! Defaulting to any`
      ), En()) : t.$refStrategy === "seen" ? En() : void 0;
  }
}, g3 = (e, t, n) => (e.description && (n.description = e.description), n), v3 = (e) => {
  const t = kL(e), n = t.name !== void 0 ? [...t.basePath, t.definitionPath, t.name] : t.basePath;
  return {
    ...t,
    currentPath: n,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(t.definitions).map(([o, a]) => [
        a._def,
        {
          def: a._def,
          path: [...t.basePath, t.definitionPath, o],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
}, y3 = (e, t) => {
  var n;
  const o = v3(t);
  let a = typeof t == "object" && t.definitions ? Object.entries(t.definitions).reduce(
    (h, [m, g]) => {
      var b;
      return {
        ...h,
        [m]: (b = qe(
          g._def,
          {
            ...o,
            currentPath: [...o.basePath, o.definitionPath, m]
          },
          !0
        )) != null ? b : En()
      };
    },
    {}
  ) : void 0;
  const l = typeof t == "string" ? t : t?.nameStrategy === "title" ? void 0 : t?.name, c = (n = qe(
    e._def,
    l === void 0 ? o : {
      ...o,
      currentPath: [...o.basePath, o.definitionPath, l]
    },
    !1
  )) != null ? n : En(), f = typeof t == "object" && t.name !== void 0 && t.nameStrategy === "title" ? t.name : void 0;
  f !== void 0 && (c.title = f);
  const d = l === void 0 ? a ? {
    ...c,
    [o.definitionPath]: a
  } : c : {
    $ref: [
      ...o.$refStrategy === "relative" ? [] : o.basePath,
      o.definitionPath,
      l
    ].join("/"),
    [o.definitionPath]: {
      ...a,
      [l]: c
    }
  };
  return d.$schema = "http://json-schema.org/draft-07/schema#", d;
}, b3 = y3;
function x3(e, t) {
  var n;
  const o = (n = void 0) != null ? n : !1;
  return Dg(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => b3(e, {
      $refStrategy: o ? "root" : "none"
    }),
    {
      validate: async (a) => {
        const l = await e.safeParseAsync(a);
        return l.success ? { success: !0, value: l.data } : { success: !1, error: l.error };
      }
    }
  );
}
function S3(e, t) {
  var n;
  const o = (n = void 0) != null ? n : !1;
  return Dg(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => Ru(
      o4(e, {
        target: "draft-7",
        io: "input",
        reused: o ? "ref" : "inline"
      })
    ),
    {
      validate: async (a) => {
        const l = await k_(e, a);
        return l.success ? { success: !0, value: l.data } : { success: !1, error: l.error };
      }
    }
  );
}
function w3(e) {
  return "_zod" in e;
}
function X_(e, t) {
  return w3(e) ? S3(e) : x3(e);
}
var Mm = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function Dg(e, {
  validate: t
} = {}) {
  return {
    [Mm]: !0,
    _type: void 0,
    // should never be used directly
    [Wu]: !0,
    get jsonSchema() {
      return typeof e == "function" && (e = e()), e;
    },
    validate: t
  };
}
function E3(e) {
  return typeof e == "object" && e !== null && Mm in e && e[Mm] === !0 && "jsonSchema" in e && "validate" in e;
}
function _3(e) {
  return e == null ? Dg({
    properties: {},
    additionalProperties: !1
  }) : E3(e) ? e : typeof e == "function" ? e() : X_(e);
}
var T3 = Object.defineProperty, C3 = (e, t) => {
  for (var n in t)
    T3(e, n, { get: t[n], enumerable: !0 });
}, W_ = "AI_NoObjectGeneratedError", K_ = `vercel.ai.error.${W_}`, A3 = Symbol.for(K_), J_, pw = class extends mr {
  constructor({
    message: e = "No object generated.",
    cause: t,
    text: n,
    response: o,
    usage: a,
    finishReason: l
  }) {
    super({ name: W_, message: e, cause: t }), this[J_] = !0, this.text = n, this.response = o, this.usage = a, this.finishReason = l;
  }
  static isInstance(e) {
    return mr.hasMarker(e, K_);
  }
};
J_ = A3;
var Q_ = "AI_MessageConversionError", eT = `vercel.ai.error.${Q_}`, R3 = Symbol.for(eT), tT, M3 = class extends mr {
  constructor({
    originalMessage: e,
    message: t
  }) {
    super({ name: Q_, message: t }), this[tT] = !0, this.originalMessage = e;
  }
  static isInstance(e) {
    return mr.hasMarker(e, eT);
  }
};
tT = R3;
var mw = "5.0.126", nT = Un([
  we(),
  qu(Uint8Array),
  qu(ArrayBuffer),
  Z_(
    // Buffer might not be available in some environments such as CloudFlare:
    (e) => {
      var t, n;
      return (n = (t = globalThis.Buffer) == null ? void 0 : t.isBuffer(e)) != null ? n : !1;
    },
    { message: "Must be a Buffer" }
  )
]), ml = bL(
  () => Un([
    Y4(),
    we(),
    H4(),
    an(),
    Cm(we(), ml),
    Ua(ml)
  ])
), xt = Cm(
  we(),
  Cm(we(), ml)
), rT = Bt({
  type: Oe("text"),
  text: we(),
  providerOptions: xt.optional()
}), z3 = Bt({
  type: Oe("image"),
  image: Un([nT, qu(URL)]),
  mediaType: we().optional(),
  providerOptions: xt.optional()
}), oT = Bt({
  type: Oe("file"),
  data: Un([nT, qu(URL)]),
  filename: we().optional(),
  mediaType: we(),
  providerOptions: xt.optional()
}), D3 = Bt({
  type: Oe("reasoning"),
  text: we(),
  providerOptions: xt.optional()
}), N3 = Bt({
  type: Oe("tool-call"),
  toolCallId: we(),
  toolName: we(),
  input: cr(),
  providerOptions: xt.optional(),
  providerExecuted: an().optional()
}), O3 = J4("type", [
  Bt({
    type: Oe("text"),
    value: we()
  }),
  Bt({
    type: Oe("json"),
    value: ml
  }),
  Bt({
    type: Oe("error-text"),
    value: we()
  }),
  Bt({
    type: Oe("error-json"),
    value: ml
  }),
  Bt({
    type: Oe("content"),
    value: Ua(
      Un([
        Bt({
          type: Oe("text"),
          text: we()
        }),
        Bt({
          type: Oe("media"),
          data: we(),
          mediaType: we()
        })
      ])
    )
  })
]), iT = Bt({
  type: Oe("tool-result"),
  toolCallId: we(),
  toolName: we(),
  output: O3,
  providerOptions: xt.optional()
}), j3 = Bt(
  {
    role: Oe("system"),
    content: we(),
    providerOptions: xt.optional()
  }
), k3 = Bt({
  role: Oe("user"),
  content: Un([
    we(),
    Ua(Un([rT, z3, oT]))
  ]),
  providerOptions: xt.optional()
}), P3 = Bt({
  role: Oe("assistant"),
  content: Un([
    we(),
    Ua(
      Un([
        rT,
        oT,
        D3,
        N3,
        iT
      ])
    )
  ]),
  providerOptions: xt.optional()
}), L3 = Bt({
  role: Oe("tool"),
  content: Ua(iT),
  providerOptions: xt.optional()
});
Un([
  j3,
  k3,
  P3,
  L3
]);
function gw({
  output: e,
  tool: t,
  errorMode: n
}) {
  return n === "text" ? { type: "error-text", value: Sg(e) } : n === "json" ? { type: "error-json", value: vw(e) } : t?.toModelOutput ? t.toModelOutput(e) : typeof e == "string" ? { type: "text", value: e } : { type: "json", value: vw(e) };
}
function vw(e) {
  return e === void 0 ? null : e;
}
Dl({
  prefix: "aitxt",
  size: 24
});
(class extends TransformStream {
  constructor() {
    super({
      transform(e, t) {
        t.enqueue(`data: ${JSON.stringify(e)}

`);
      },
      flush(e) {
        e.enqueue(`data: [DONE]

`);
      }
    });
  }
});
var I3 = ML(
  () => X_(
    Un([
      ut({
        type: Oe("text-start"),
        id: we(),
        providerMetadata: xt.optional()
      }),
      ut({
        type: Oe("text-delta"),
        id: we(),
        delta: we(),
        providerMetadata: xt.optional()
      }),
      ut({
        type: Oe("text-end"),
        id: we(),
        providerMetadata: xt.optional()
      }),
      ut({
        type: Oe("error"),
        errorText: we()
      }),
      ut({
        type: Oe("tool-input-start"),
        toolCallId: we(),
        toolName: we(),
        providerExecuted: an().optional(),
        dynamic: an().optional()
      }),
      ut({
        type: Oe("tool-input-delta"),
        toolCallId: we(),
        inputTextDelta: we()
      }),
      ut({
        type: Oe("tool-input-available"),
        toolCallId: we(),
        toolName: we(),
        input: cr(),
        providerExecuted: an().optional(),
        providerMetadata: xt.optional(),
        dynamic: an().optional()
      }),
      ut({
        type: Oe("tool-input-error"),
        toolCallId: we(),
        toolName: we(),
        input: cr(),
        providerExecuted: an().optional(),
        providerMetadata: xt.optional(),
        dynamic: an().optional(),
        errorText: we()
      }),
      ut({
        type: Oe("tool-output-available"),
        toolCallId: we(),
        output: cr(),
        providerExecuted: an().optional(),
        dynamic: an().optional(),
        preliminary: an().optional()
      }),
      ut({
        type: Oe("tool-output-error"),
        toolCallId: we(),
        errorText: we(),
        providerExecuted: an().optional(),
        dynamic: an().optional()
      }),
      ut({
        type: Oe("reasoning-start"),
        id: we(),
        providerMetadata: xt.optional()
      }),
      ut({
        type: Oe("reasoning-delta"),
        id: we(),
        delta: we(),
        providerMetadata: xt.optional()
      }),
      ut({
        type: Oe("reasoning-end"),
        id: we(),
        providerMetadata: xt.optional()
      }),
      ut({
        type: Oe("source-url"),
        sourceId: we(),
        url: we(),
        title: we().optional(),
        providerMetadata: xt.optional()
      }),
      ut({
        type: Oe("source-document"),
        sourceId: we(),
        mediaType: we(),
        title: we(),
        filename: we().optional(),
        providerMetadata: xt.optional()
      }),
      ut({
        type: Oe("file"),
        url: we(),
        mediaType: we(),
        providerMetadata: xt.optional()
      }),
      ut({
        type: Z_(
          (e) => typeof e == "string" && e.startsWith("data-"),
          { message: 'Type must start with "data-"' }
        ),
        id: we().optional(),
        data: cr(),
        transient: an().optional()
      }),
      ut({
        type: Oe("start-step")
      }),
      ut({
        type: Oe("finish-step")
      }),
      ut({
        type: Oe("start"),
        messageId: we().optional(),
        messageMetadata: cr().optional()
      }),
      ut({
        type: Oe("finish"),
        finishReason: B_([
          "stop",
          "length",
          "content-filter",
          "tool-calls",
          "error",
          "other",
          "unknown"
        ]).optional(),
        messageMetadata: cr().optional()
      }),
      ut({
        type: Oe("abort")
      }),
      ut({
        type: Oe("message-metadata"),
        messageMetadata: cr()
      })
    ])
  )
);
function V3(e) {
  return e.type.startsWith("data-");
}
function aT(e, t) {
  if (e === void 0 && t === void 0)
    return;
  if (e === void 0)
    return t;
  if (t === void 0)
    return e;
  const n = { ...e };
  for (const o in t)
    if (Object.prototype.hasOwnProperty.call(t, o)) {
      const a = t[o];
      if (a === void 0)
        continue;
      const l = o in e ? e[o] : void 0, c = a !== null && typeof a == "object" && !Array.isArray(a) && !(a instanceof Date) && !(a instanceof RegExp), f = l != null && typeof l == "object" && !Array.isArray(l) && !(l instanceof Date) && !(l instanceof RegExp);
      c && f ? n[o] = aT(
        l,
        a
      ) : n[o] = a;
    }
  return n;
}
function U3(e) {
  const t = ["ROOT"];
  let n = -1, o = null;
  function a(d, h, m) {
    switch (d) {
      case '"': {
        n = h, t.pop(), t.push(m), t.push("INSIDE_STRING");
        break;
      }
      case "f":
      case "t":
      case "n": {
        n = h, o = h, t.pop(), t.push(m), t.push("INSIDE_LITERAL");
        break;
      }
      case "-": {
        t.pop(), t.push(m), t.push("INSIDE_NUMBER");
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9": {
        n = h, t.pop(), t.push(m), t.push("INSIDE_NUMBER");
        break;
      }
      case "{": {
        n = h, t.pop(), t.push(m), t.push("INSIDE_OBJECT_START");
        break;
      }
      case "[": {
        n = h, t.pop(), t.push(m), t.push("INSIDE_ARRAY_START");
        break;
      }
    }
  }
  function l(d, h) {
    switch (d) {
      case ",": {
        t.pop(), t.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        n = h, t.pop();
        break;
      }
    }
  }
  function c(d, h) {
    switch (d) {
      case ",": {
        t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        n = h, t.pop();
        break;
      }
    }
  }
  for (let d = 0; d < e.length; d++) {
    const h = e[d];
    switch (t[t.length - 1]) {
      case "ROOT":
        a(h, d, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (h) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            n = d, t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        h === '"' && (t.pop(), t.push("INSIDE_OBJECT_KEY"));
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        h === '"' && (t.pop(), t.push("INSIDE_OBJECT_AFTER_KEY"));
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        h === ":" && (t.pop(), t.push("INSIDE_OBJECT_BEFORE_VALUE"));
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        a(h, d, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        l(h, d);
        break;
      }
      case "INSIDE_STRING": {
        switch (h) {
          case '"': {
            t.pop(), n = d;
            break;
          }
          case "\\": {
            t.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default:
            n = d;
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        h === "]" ? (n = d, t.pop()) : (n = d, a(h, d, "INSIDE_ARRAY_AFTER_VALUE"));
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (h) {
          case ",": {
            t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            n = d, t.pop();
            break;
          }
          default: {
            n = d;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        a(h, d, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        t.pop(), n = d;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (h) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            n = d;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".":
            break;
          case ",": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && c(h, d), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && l(h, d);
            break;
          }
          case "}": {
            t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && l(h, d);
            break;
          }
          case "]": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && c(h, d);
            break;
          }
          default: {
            t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const g = e.substring(o, d + 1);
        !"false".startsWith(g) && !"true".startsWith(g) && !"null".startsWith(g) ? (t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" ? l(h, d) : t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && c(h, d)) : n = d;
        break;
      }
    }
  }
  let f = e.slice(0, n + 1);
  for (let d = t.length - 1; d >= 0; d--)
    switch (t[d]) {
      case "INSIDE_STRING": {
        f += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        f += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        f += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const m = e.substring(o, e.length);
        "true".startsWith(m) ? f += "true".slice(m.length) : "false".startsWith(m) ? f += "false".slice(m.length) : "null".startsWith(m) && (f += "null".slice(m.length));
      }
    }
  return f;
}
async function sT(e) {
  if (e === void 0)
    return { value: void 0, state: "undefined-input" };
  let t = await Ku({ text: e });
  return t.success ? { value: t.value, state: "successful-parse" } : (t = await Ku({ text: U3(e) }), t.success ? { value: t.value, state: "repaired-parse" } : { value: void 0, state: "failed-parse" });
}
function Pp(e) {
  return e.type.startsWith("data-");
}
function Lp(e) {
  return e.type === "text";
}
function Ip(e) {
  return e.type === "file";
}
function yw(e) {
  return e.type === "reasoning";
}
function Ra(e) {
  return e.type.startsWith("tool-");
}
function Ng(e) {
  return e.type === "dynamic-tool";
}
function gl(e) {
  return Ra(e) || Ng(e);
}
function Ju(e) {
  return e.type.split("-").slice(1).join("-");
}
function B3(e) {
  return Ng(e) ? e.toolName : Ju(e);
}
function $3({
  lastMessage: e,
  messageId: t
}) {
  return {
    message: e?.role === "assistant" ? e : {
      id: t,
      metadata: void 0,
      role: "assistant",
      parts: []
    },
    activeTextParts: {},
    activeReasoningParts: {},
    partialToolCalls: {}
  };
}
function H3({
  stream: e,
  messageMetadataSchema: t,
  dataPartSchemas: n,
  runUpdateMessageJob: o,
  onError: a,
  onToolCall: l,
  onData: c
}) {
  return e.pipeThrough(
    new TransformStream({
      async transform(f, d) {
        await o(async ({ state: h, write: m }) => {
          var g, b, x, _;
          function E(R) {
            const L = h.message.parts.filter(Ra).find(
              (M) => M.toolCallId === R
            );
            if (L == null)
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available"
              );
            return L;
          }
          function T(R) {
            const L = h.message.parts.filter(
              (M) => M.type === "dynamic-tool"
            ).find(
              (M) => M.toolCallId === R
            );
            if (L == null)
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available"
              );
            return L;
          }
          function C(R) {
            var O;
            const L = h.message.parts.find(
              (j) => Ra(j) && j.toolCallId === R.toolCallId
            ), M = R, N = L;
            L != null ? (L.state = R.state, N.input = M.input, N.output = M.output, N.errorText = M.errorText, N.rawInput = M.rawInput, N.preliminary = M.preliminary, N.providerExecuted = (O = M.providerExecuted) != null ? O : L.providerExecuted, M.providerMetadata != null && L.state === "input-available" && (L.callProviderMetadata = M.providerMetadata)) : h.message.parts.push({
              type: `tool-${R.toolName}`,
              toolCallId: R.toolCallId,
              state: R.state,
              input: M.input,
              output: M.output,
              rawInput: M.rawInput,
              errorText: M.errorText,
              providerExecuted: M.providerExecuted,
              preliminary: M.preliminary,
              ...M.providerMetadata != null ? { callProviderMetadata: M.providerMetadata } : {}
            });
          }
          function z(R) {
            var O, L;
            const M = h.message.parts.find(
              (Y) => Y.type === "dynamic-tool" && Y.toolCallId === R.toolCallId
            ), N = R, j = M;
            M != null ? (M.state = R.state, j.toolName = R.toolName, j.input = N.input, j.output = N.output, j.errorText = N.errorText, j.rawInput = (O = N.rawInput) != null ? O : j.rawInput, j.preliminary = N.preliminary, j.providerExecuted = (L = N.providerExecuted) != null ? L : M.providerExecuted, N.providerMetadata != null && M.state === "input-available" && (M.callProviderMetadata = N.providerMetadata)) : h.message.parts.push({
              type: "dynamic-tool",
              toolName: R.toolName,
              toolCallId: R.toolCallId,
              state: R.state,
              input: N.input,
              output: N.output,
              errorText: N.errorText,
              preliminary: N.preliminary,
              providerExecuted: N.providerExecuted,
              ...N.providerMetadata != null ? { callProviderMetadata: N.providerMetadata } : {}
            });
          }
          async function A(R) {
            if (R != null) {
              const O = h.message.metadata != null ? aT(h.message.metadata, R) : R;
              t != null && await fw({
                value: O,
                schema: t
              }), h.message.metadata = O;
            }
          }
          switch (f.type) {
            case "text-start": {
              const R = {
                type: "text",
                text: "",
                providerMetadata: f.providerMetadata,
                state: "streaming"
              };
              h.activeTextParts[f.id] = R, h.message.parts.push(R), m();
              break;
            }
            case "text-delta": {
              const R = h.activeTextParts[f.id];
              R.text += f.delta, R.providerMetadata = (g = f.providerMetadata) != null ? g : R.providerMetadata, m();
              break;
            }
            case "text-end": {
              const R = h.activeTextParts[f.id];
              R.state = "done", R.providerMetadata = (b = f.providerMetadata) != null ? b : R.providerMetadata, delete h.activeTextParts[f.id], m();
              break;
            }
            case "reasoning-start": {
              const R = {
                type: "reasoning",
                text: "",
                providerMetadata: f.providerMetadata,
                state: "streaming"
              };
              h.activeReasoningParts[f.id] = R, h.message.parts.push(R), m();
              break;
            }
            case "reasoning-delta": {
              const R = h.activeReasoningParts[f.id];
              R.text += f.delta, R.providerMetadata = (x = f.providerMetadata) != null ? x : R.providerMetadata, m();
              break;
            }
            case "reasoning-end": {
              const R = h.activeReasoningParts[f.id];
              R.providerMetadata = (_ = f.providerMetadata) != null ? _ : R.providerMetadata, R.state = "done", delete h.activeReasoningParts[f.id], m();
              break;
            }
            case "file": {
              h.message.parts.push({
                type: "file",
                mediaType: f.mediaType,
                url: f.url
              }), m();
              break;
            }
            case "source-url": {
              h.message.parts.push({
                type: "source-url",
                sourceId: f.sourceId,
                url: f.url,
                title: f.title,
                providerMetadata: f.providerMetadata
              }), m();
              break;
            }
            case "source-document": {
              h.message.parts.push({
                type: "source-document",
                sourceId: f.sourceId,
                mediaType: f.mediaType,
                title: f.title,
                filename: f.filename,
                providerMetadata: f.providerMetadata
              }), m();
              break;
            }
            case "tool-input-start": {
              const R = h.message.parts.filter(Ra);
              h.partialToolCalls[f.toolCallId] = {
                text: "",
                toolName: f.toolName,
                index: R.length,
                dynamic: f.dynamic
              }, f.dynamic ? z({
                toolCallId: f.toolCallId,
                toolName: f.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: f.providerExecuted
              }) : C({
                toolCallId: f.toolCallId,
                toolName: f.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: f.providerExecuted
              }), m();
              break;
            }
            case "tool-input-delta": {
              const R = h.partialToolCalls[f.toolCallId];
              R.text += f.inputTextDelta;
              const { value: O } = await sT(
                R.text
              );
              R.dynamic ? z({
                toolCallId: f.toolCallId,
                toolName: R.toolName,
                state: "input-streaming",
                input: O
              }) : C({
                toolCallId: f.toolCallId,
                toolName: R.toolName,
                state: "input-streaming",
                input: O
              }), m();
              break;
            }
            case "tool-input-available": {
              f.dynamic ? z({
                toolCallId: f.toolCallId,
                toolName: f.toolName,
                state: "input-available",
                input: f.input,
                providerExecuted: f.providerExecuted,
                providerMetadata: f.providerMetadata
              }) : C({
                toolCallId: f.toolCallId,
                toolName: f.toolName,
                state: "input-available",
                input: f.input,
                providerExecuted: f.providerExecuted,
                providerMetadata: f.providerMetadata
              }), m(), l && !f.providerExecuted && await l({
                toolCall: f
              });
              break;
            }
            case "tool-input-error": {
              f.dynamic ? z({
                toolCallId: f.toolCallId,
                toolName: f.toolName,
                state: "output-error",
                input: f.input,
                errorText: f.errorText,
                providerExecuted: f.providerExecuted,
                providerMetadata: f.providerMetadata
              }) : C({
                toolCallId: f.toolCallId,
                toolName: f.toolName,
                state: "output-error",
                input: void 0,
                rawInput: f.input,
                errorText: f.errorText,
                providerExecuted: f.providerExecuted,
                providerMetadata: f.providerMetadata
              }), m();
              break;
            }
            case "tool-output-available": {
              if (f.dynamic) {
                const R = T(
                  f.toolCallId
                );
                z({
                  toolCallId: f.toolCallId,
                  toolName: R.toolName,
                  state: "output-available",
                  input: R.input,
                  output: f.output,
                  preliminary: f.preliminary
                });
              } else {
                const R = E(f.toolCallId);
                C({
                  toolCallId: f.toolCallId,
                  toolName: Ju(R),
                  state: "output-available",
                  input: R.input,
                  output: f.output,
                  providerExecuted: f.providerExecuted,
                  preliminary: f.preliminary
                });
              }
              m();
              break;
            }
            case "tool-output-error": {
              if (f.dynamic) {
                const R = T(
                  f.toolCallId
                );
                z({
                  toolCallId: f.toolCallId,
                  toolName: R.toolName,
                  state: "output-error",
                  input: R.input,
                  errorText: f.errorText,
                  providerExecuted: f.providerExecuted
                });
              } else {
                const R = E(f.toolCallId);
                C({
                  toolCallId: f.toolCallId,
                  toolName: Ju(R),
                  state: "output-error",
                  input: R.input,
                  rawInput: R.rawInput,
                  errorText: f.errorText,
                  providerExecuted: f.providerExecuted
                });
              }
              m();
              break;
            }
            case "start-step": {
              h.message.parts.push({ type: "step-start" });
              break;
            }
            case "finish-step": {
              h.activeTextParts = {}, h.activeReasoningParts = {};
              break;
            }
            case "start": {
              f.messageId != null && (h.message.id = f.messageId), await A(f.messageMetadata), (f.messageId != null || f.messageMetadata != null) && m();
              break;
            }
            case "finish": {
              f.finishReason != null && (h.finishReason = f.finishReason), await A(f.messageMetadata), f.messageMetadata != null && m();
              break;
            }
            case "message-metadata": {
              await A(f.messageMetadata), f.messageMetadata != null && m();
              break;
            }
            case "error": {
              a?.(new Error(f.errorText));
              break;
            }
            default:
              if (V3(f)) {
                n?.[f.type] != null && await fw({
                  value: f.data,
                  schema: n[f.type]
                });
                const R = f;
                if (R.transient) {
                  c?.(R);
                  break;
                }
                const O = R.id != null ? h.message.parts.find(
                  (L) => R.type === L.type && R.id === L.id
                ) : void 0;
                O != null ? O.data = R.data : h.message.parts.push(R), c?.(R), m();
              }
          }
          d.enqueue(f);
        });
      }
    })
  );
}
async function Z3({
  stream: e,
  onError: t
}) {
  const n = e.getReader();
  try {
    for (; ; ) {
      const { done: o } = await n.read();
      if (o)
        break;
    }
  } catch (o) {
    t?.(o);
  } finally {
    n.releaseLock();
  }
}
Dl({
  prefix: "aitxt",
  size: 24
});
function F3(e, t) {
  const n = [];
  t?.ignoreIncompleteToolCalls && (e = e.map((o) => ({
    ...o,
    parts: o.parts.filter(
      (a) => !gl(a) || a.state !== "input-streaming" && a.state !== "input-available"
    )
  })));
  for (const o of e)
    switch (o.role) {
      case "system": {
        const a = o.parts.filter(
          (c) => c.type === "text"
        ), l = a.reduce((c, f) => f.providerMetadata != null ? { ...c, ...f.providerMetadata } : c, {});
        n.push({
          role: "system",
          content: a.map((c) => c.text).join(""),
          ...Object.keys(l).length > 0 ? { providerOptions: l } : {}
        });
        break;
      }
      case "user": {
        n.push({
          role: "user",
          content: o.parts.map((a) => {
            var l;
            if (Lp(a))
              return {
                type: "text",
                text: a.text,
                ...a.providerMetadata != null ? { providerOptions: a.providerMetadata } : {}
              };
            if (Ip(a))
              return {
                type: "file",
                mediaType: a.mediaType,
                filename: a.filename,
                data: a.url,
                ...a.providerMetadata != null ? { providerOptions: a.providerMetadata } : {}
              };
            if (Pp(a))
              return (l = t?.convertDataPart) == null ? void 0 : l.call(
                t,
                a
              );
          }).filter((a) => a != null)
        });
        break;
      }
      case "assistant": {
        if (o.parts != null) {
          let a = function() {
            var c, f, d;
            if (l.length === 0)
              return;
            const h = [];
            for (const g of l)
              if (Lp(g))
                h.push({
                  type: "text",
                  text: g.text,
                  ...g.providerMetadata != null ? { providerOptions: g.providerMetadata } : {}
                });
              else if (Ip(g))
                h.push({
                  type: "file",
                  mediaType: g.mediaType,
                  filename: g.filename,
                  data: g.url
                });
              else if (yw(g))
                h.push({
                  type: "reasoning",
                  text: g.text,
                  providerOptions: g.providerMetadata
                });
              else if (Ng(g)) {
                const b = g.toolName;
                g.state !== "input-streaming" && h.push({
                  type: "tool-call",
                  toolCallId: g.toolCallId,
                  toolName: b,
                  input: g.input,
                  ...g.callProviderMetadata != null ? { providerOptions: g.callProviderMetadata } : {}
                });
              } else if (Ra(g)) {
                const b = Ju(g);
                g.state !== "input-streaming" && (h.push({
                  type: "tool-call",
                  toolCallId: g.toolCallId,
                  toolName: b,
                  input: g.state === "output-error" ? (c = g.input) != null ? c : g.rawInput : g.input,
                  providerExecuted: g.providerExecuted,
                  ...g.callProviderMetadata != null ? { providerOptions: g.callProviderMetadata } : {}
                }), g.providerExecuted === !0 && (g.state === "output-available" || g.state === "output-error") && h.push({
                  type: "tool-result",
                  toolCallId: g.toolCallId,
                  toolName: b,
                  output: gw({
                    output: g.state === "output-error" ? g.errorText : g.output,
                    tool: (f = t?.tools) == null ? void 0 : f[b],
                    errorMode: g.state === "output-error" ? "json" : "none"
                  }),
                  ...g.callProviderMetadata != null ? { providerOptions: g.callProviderMetadata } : {}
                }));
              } else if (Pp(g)) {
                const b = (d = t?.convertDataPart) == null ? void 0 : d.call(
                  t,
                  g
                );
                b != null && h.push(b);
              } else {
                const b = g;
                throw new Error(`Unsupported part: ${b}`);
              }
            n.push({
              role: "assistant",
              content: h
            });
            const m = l.filter(
              (g) => Ra(g) && g.providerExecuted !== !0 || g.type === "dynamic-tool"
            );
            m.length > 0 && n.push({
              role: "tool",
              content: m.map((g) => {
                var b;
                switch (g.state) {
                  case "output-error":
                  case "output-available": {
                    const x = B3(g);
                    return {
                      type: "tool-result",
                      toolCallId: g.toolCallId,
                      toolName: x,
                      output: gw({
                        output: g.state === "output-error" ? g.errorText : g.output,
                        tool: (b = t?.tools) == null ? void 0 : b[x],
                        errorMode: g.state === "output-error" ? "text" : "none"
                      }),
                      ...g.callProviderMetadata != null ? { providerOptions: g.callProviderMetadata } : {}
                    };
                  }
                  default:
                    return null;
                }
              }).filter(
                (g) => g != null
              )
            }), l = [];
          }, l = [];
          for (const c of o.parts)
            Lp(c) || yw(c) || Ip(c) || gl(c) || Pp(c) ? l.push(c) : c.type === "step-start" && a();
          a();
          break;
        }
        break;
      }
      default: {
        const a = o.role;
        throw new M3({
          originalMessage: o,
          message: `Unsupported role: ${a}`
        });
      }
    }
  return n;
}
Dl({ prefix: "aiobj", size: 24 });
var G3 = class {
  constructor() {
    this.queue = [], this.isProcessing = !1;
  }
  async processQueue() {
    if (!this.isProcessing) {
      for (this.isProcessing = !0; this.queue.length > 0; )
        await this.queue[0](), this.queue.shift();
      this.isProcessing = !1;
    }
  }
  async run(e) {
    return new Promise((t, n) => {
      this.queue.push(async () => {
        try {
          await e(), t();
        } catch (o) {
          n(o);
        }
      }), this.processQueue();
    });
  }
};
Dl({ prefix: "aiobj", size: 24 });
var Y3 = {};
C3(Y3, {
  object: () => X3,
  text: () => q3
});
var q3 = () => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: e }) {
    return { partial: e };
  },
  async parseOutput({ text: e }) {
    return e;
  }
}), X3 = ({
  schema: e
}) => {
  const t = _3(e);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: t.jsonSchema
    },
    async parsePartial({ text: n }) {
      const o = await sT(n);
      switch (o.state) {
        case "failed-parse":
        case "undefined-input":
          return;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: o.value
          };
        default: {
          const a = o.state;
          throw new Error(`Unsupported parse state: ${a}`);
        }
      }
    },
    async parseOutput({ text: n }, o) {
      const a = await Ku({ text: n });
      if (!a.success)
        throw new pw({
          message: "No object generated: could not parse the response.",
          cause: a.error,
          text: n,
          response: o.response,
          usage: o.usage,
          finishReason: o.finishReason
        });
      const l = await zg({
        value: a.value,
        schema: t
      });
      if (!l.success)
        throw new pw({
          message: "No object generated: response did not match schema.",
          cause: l.error,
          text: n,
          response: o.response,
          usage: o.usage,
          finishReason: o.finishReason
        });
      return l.value;
    }
  };
};
async function W3(e) {
  if (e == null)
    return [];
  if (!globalThis.FileList || !(e instanceof globalThis.FileList))
    throw new Error("FileList is not supported in the current environment");
  return Promise.all(
    Array.from(e).map(async (t) => {
      const { name: n, type: o } = t, a = await new Promise((l, c) => {
        const f = new FileReader();
        f.onload = (d) => {
          var h;
          l((h = d.target) == null ? void 0 : h.result);
        }, f.onerror = (d) => c(d), f.readAsDataURL(t);
      });
      return {
        type: "file",
        mediaType: o,
        filename: n,
        url: a
      };
    })
  );
}
var K3 = class {
  constructor({
    api: e = "/api/chat",
    credentials: t,
    headers: n,
    body: o,
    fetch: a,
    prepareSendMessagesRequest: l,
    prepareReconnectToStreamRequest: c
  }) {
    this.api = e, this.credentials = t, this.headers = n, this.body = o, this.fetch = a, this.prepareSendMessagesRequest = l, this.prepareReconnectToStreamRequest = c;
  }
  async sendMessages({
    abortSignal: e,
    ...t
  }) {
    var n, o, a, l, c;
    const f = await fa(this.body), d = await fa(this.headers), h = await fa(this.credentials), m = {
      ...ci(d),
      ...ci(t.headers)
    }, g = await ((n = this.prepareSendMessagesRequest) == null ? void 0 : n.call(this, {
      api: this.api,
      id: t.chatId,
      messages: t.messages,
      body: { ...f, ...t.body },
      headers: m,
      credentials: h,
      requestMetadata: t.metadata,
      trigger: t.trigger,
      messageId: t.messageId
    })), b = (o = g?.api) != null ? o : this.api, x = g?.headers !== void 0 ? ci(g.headers) : m, _ = g?.body !== void 0 ? g.body : {
      ...f,
      ...t.body,
      id: t.chatId,
      messages: t.messages,
      trigger: t.trigger,
      messageId: t.messageId
    }, E = (a = g?.credentials) != null ? a : h, C = await ((l = this.fetch) != null ? l : globalThis.fetch)(b, {
      method: "POST",
      headers: cw(
        {
          "Content-Type": "application/json",
          ...x
        },
        `ai-sdk/${mw}`,
        lw()
      ),
      body: JSON.stringify(_),
      credentials: E,
      signal: e
    });
    if (!C.ok)
      throw new Error(
        (c = await C.text()) != null ? c : "Failed to fetch the chat response."
      );
    if (!C.body)
      throw new Error("The response body is empty.");
    return this.processResponseStream(C.body);
  }
  async reconnectToStream(e) {
    var t, n, o, a, l;
    const c = await fa(this.body), f = await fa(this.headers), d = await fa(this.credentials), h = {
      ...ci(f),
      ...ci(e.headers)
    }, m = await ((t = this.prepareReconnectToStreamRequest) == null ? void 0 : t.call(this, {
      api: this.api,
      id: e.chatId,
      body: { ...c, ...e.body },
      headers: h,
      credentials: d,
      requestMetadata: e.metadata
    })), g = (n = m?.api) != null ? n : `${this.api}/${e.chatId}/stream`, b = m?.headers !== void 0 ? ci(m.headers) : h, x = (o = m?.credentials) != null ? o : d, E = await ((a = this.fetch) != null ? a : globalThis.fetch)(g, {
      method: "GET",
      headers: cw(
        b,
        `ai-sdk/${mw}`,
        lw()
      ),
      credentials: x
    });
    if (E.status === 204)
      return null;
    if (!E.ok)
      throw new Error(
        (l = await E.text()) != null ? l : "Failed to fetch the chat response."
      );
    if (!E.body)
      throw new Error("The response body is empty.");
    return this.processResponseStream(E.body);
  }
}, lT = class extends K3 {
  constructor(e = {}) {
    super(e);
  }
  processResponseStream(e) {
    return NL({
      stream: e,
      schema: I3
    }).pipeThrough(
      new TransformStream({
        async transform(t, n) {
          if (!t.success)
            throw t.error;
          n.enqueue(t.value);
        }
      })
    );
  }
}, J3 = class {
  constructor({
    generateId: e = wL,
    id: t = e(),
    transport: n = new lT(),
    messageMetadataSchema: o,
    dataPartSchemas: a,
    state: l,
    onError: c,
    onToolCall: f,
    onFinish: d,
    onData: h,
    sendAutomaticallyWhen: m
  }) {
    this.activeResponse = void 0, this.jobExecutor = new G3(), this.sendMessage = async (g, b) => {
      var x, _, E, T;
      if (g == null) {
        await this.makeRequest({
          trigger: "submit-message",
          messageId: (x = this.lastMessage) == null ? void 0 : x.id,
          ...b
        });
        return;
      }
      let C;
      if ("text" in g || "files" in g ? C = {
        parts: [
          ...Array.isArray(g.files) ? g.files : await W3(g.files),
          ..."text" in g && g.text != null ? [{ type: "text", text: g.text }] : []
        ]
      } : C = g, g.messageId != null) {
        const z = this.state.messages.findIndex(
          (A) => A.id === g.messageId
        );
        if (z === -1)
          throw new Error(`message with id ${g.messageId} not found`);
        if (this.state.messages[z].role !== "user")
          throw new Error(
            `message with id ${g.messageId} is not a user message`
          );
        this.state.messages = this.state.messages.slice(0, z + 1), this.state.replaceMessage(z, {
          ...C,
          id: g.messageId,
          role: (_ = C.role) != null ? _ : "user",
          metadata: g.metadata
        });
      } else
        this.state.pushMessage({
          ...C,
          id: (E = C.id) != null ? E : this.generateId(),
          role: (T = C.role) != null ? T : "user",
          metadata: g.metadata
        });
      await this.makeRequest({
        trigger: "submit-message",
        messageId: g.messageId,
        ...b
      });
    }, this.regenerate = async ({
      messageId: g,
      ...b
    } = {}) => {
      const x = g == null ? this.state.messages.length - 1 : this.state.messages.findIndex((_) => _.id === g);
      if (x === -1)
        throw new Error(`message ${g} not found`);
      this.state.messages = this.state.messages.slice(
        0,
        // if the message is a user message, we need to include it in the request:
        this.messages[x].role === "assistant" ? x : x + 1
      ), await this.makeRequest({
        trigger: "regenerate-message",
        messageId: g,
        ...b
      });
    }, this.resumeStream = async (g = {}) => {
      await this.makeRequest({ trigger: "resume-stream", ...g });
    }, this.clearError = () => {
      this.status === "error" && (this.state.error = void 0, this.setStatus({ status: "ready" }));
    }, this.addToolOutput = async ({
      state: g = "output-available",
      tool: b,
      toolCallId: x,
      output: _,
      errorText: E
    }) => this.jobExecutor.run(async () => {
      var T, C;
      const z = this.state.messages, A = z[z.length - 1];
      this.state.replaceMessage(z.length - 1, {
        ...A,
        parts: A.parts.map(
          (R) => gl(R) && R.toolCallId === x ? { ...R, state: g, output: _, errorText: E } : R
        )
      }), this.activeResponse && (this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(
        (R) => gl(R) && R.toolCallId === x ? {
          ...R,
          state: g,
          output: _,
          errorText: E
        } : R
      )), this.status !== "streaming" && this.status !== "submitted" && ((T = this.sendAutomaticallyWhen) != null && T.call(this, { messages: this.state.messages })) && this.makeRequest({
        trigger: "submit-message",
        messageId: (C = this.lastMessage) == null ? void 0 : C.id
      });
    }), this.addToolResult = this.addToolOutput, this.stop = async () => {
      var g;
      this.status !== "streaming" && this.status !== "submitted" || (g = this.activeResponse) != null && g.abortController && this.activeResponse.abortController.abort();
    }, this.id = t, this.transport = n, this.generateId = e, this.messageMetadataSchema = o, this.dataPartSchemas = a, this.state = l, this.onError = c, this.onToolCall = f, this.onFinish = d, this.onData = h, this.sendAutomaticallyWhen = m;
  }
  /**
   * Hook status:
   *
   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.
   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.
   * - `ready`: The full response has been received and processed; a new user message can be submitted.
   * - `error`: An error occurred during the API request, preventing successful completion.
   */
  get status() {
    return this.state.status;
  }
  setStatus({
    status: e,
    error: t
  }) {
    this.status !== e && (this.state.status = e, this.state.error = t);
  }
  get error() {
    return this.state.error;
  }
  get messages() {
    return this.state.messages;
  }
  get lastMessage() {
    return this.state.messages[this.state.messages.length - 1];
  }
  set messages(e) {
    this.state.messages = e;
  }
  async makeRequest({
    trigger: e,
    metadata: t,
    headers: n,
    body: o,
    messageId: a
  }) {
    var l, c, f, d;
    this.setStatus({ status: "submitted", error: void 0 });
    const h = this.lastMessage;
    let m = !1, g = !1, b = !1;
    try {
      const x = {
        state: $3({
          lastMessage: this.state.snapshot(h),
          messageId: this.generateId()
        }),
        abortController: new AbortController()
      };
      x.abortController.signal.addEventListener("abort", () => {
        m = !0;
      }), this.activeResponse = x;
      let _;
      if (e === "resume-stream") {
        const T = await this.transport.reconnectToStream({
          chatId: this.id,
          metadata: t,
          headers: n,
          body: o
        });
        if (T == null) {
          this.setStatus({ status: "ready" });
          return;
        }
        _ = T;
      } else
        _ = await this.transport.sendMessages({
          chatId: this.id,
          messages: this.state.messages,
          abortSignal: x.abortController.signal,
          metadata: t,
          headers: n,
          body: o,
          trigger: e,
          messageId: a
        });
      const E = (T) => (
        // serialize the job execution to avoid race conditions:
        this.jobExecutor.run(
          () => T({
            state: x.state,
            write: () => {
              var C;
              this.setStatus({ status: "streaming" }), x.state.message.id === ((C = this.lastMessage) == null ? void 0 : C.id) ? this.state.replaceMessage(
                this.state.messages.length - 1,
                x.state.message
              ) : this.state.pushMessage(x.state.message);
            }
          })
        )
      );
      await Z3({
        stream: H3({
          stream: _,
          onToolCall: this.onToolCall,
          onData: this.onData,
          messageMetadataSchema: this.messageMetadataSchema,
          dataPartSchemas: this.dataPartSchemas,
          runUpdateMessageJob: E,
          onError: (T) => {
            throw T;
          }
        }),
        onError: (T) => {
          throw T;
        }
      }), this.setStatus({ status: "ready" });
    } catch (x) {
      if (m || x.name === "AbortError")
        return m = !0, this.setStatus({ status: "ready" }), null;
      b = !0, x instanceof TypeError && (x.message.toLowerCase().includes("fetch") || x.message.toLowerCase().includes("network")) && (g = !0), this.onError && x instanceof Error && this.onError(x), this.setStatus({ status: "error", error: x });
    } finally {
      try {
        (c = this.onFinish) == null || c.call(this, {
          message: this.activeResponse.state.message,
          messages: this.state.messages,
          isAbort: m,
          isDisconnect: g,
          isError: b,
          finishReason: (l = this.activeResponse) == null ? void 0 : l.state.finishReason
        });
      } catch (x) {
        console.error(x);
      }
      this.activeResponse = void 0;
    }
    (f = this.sendAutomaticallyWhen) != null && f.call(this, { messages: this.state.messages }) && !b && await this.makeRequest({
      trigger: "submit-message",
      messageId: (d = this.lastMessage) == null ? void 0 : d.id,
      metadata: t,
      headers: n,
      body: o
    });
  }
};
function Q3({
  messages: e
}) {
  const t = e[e.length - 1];
  if (!t || t.role !== "assistant")
    return !1;
  const n = t.parts.reduce((a, l, c) => l.type === "step-start" ? c : a, -1), o = t.parts.slice(n + 1).filter(gl).filter((a) => !a.providerExecuted);
  return o.length > 0 && o.every(
    (a) => a.state === "output-available" || a.state === "output-error"
  );
}
var Vp, bw;
function eI() {
  if (bw) return Vp;
  bw = 1;
  function e(t, n) {
    if (typeof t != "function")
      throw new TypeError(`Expected the first argument to be a \`function\`, got \`${typeof t}\`.`);
    let o, a = 0;
    return function(...c) {
      clearTimeout(o);
      const f = Date.now(), d = f - a, h = n - d;
      h <= 0 ? (a = f, t.apply(this, c)) : o = setTimeout(() => {
        a = Date.now(), t.apply(this, c);
      }, h);
    };
  }
  return Vp = e, Vp;
}
var tI = /* @__PURE__ */ eI();
const nI = /* @__PURE__ */ Ml(tI);
var cT = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, it = (e, t, n) => (cT(e, t, "read from private field"), n ? n.call(e) : t.get(e)), sr = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, _o = (e, t, n, o) => (cT(e, t, "write to private field"), t.set(e, n), n);
function rI(e, t) {
  return t != null ? nI(e, t) : e;
}
var kn, Mu, zu, Ws, Ks, Js, va, zm, Dm, oI = class {
  constructor(e = []) {
    sr(this, kn, void 0), sr(this, Mu, "ready"), sr(this, zu, void 0), sr(this, Ws, /* @__PURE__ */ new Set()), sr(this, Ks, /* @__PURE__ */ new Set()), sr(this, Js, /* @__PURE__ */ new Set()), this.pushMessage = (t) => {
      _o(this, kn, it(this, kn).concat(t)), it(this, va).call(this);
    }, this.popMessage = () => {
      _o(this, kn, it(this, kn).slice(0, -1)), it(this, va).call(this);
    }, this.replaceMessage = (t, n) => {
      _o(this, kn, [
        ...it(this, kn).slice(0, t),
        // We deep clone the message here to ensure the new React Compiler (currently in RC) detects deeply nested parts/metadata changes:
        this.snapshot(n),
        ...it(this, kn).slice(t + 1)
      ]), it(this, va).call(this);
    }, this.snapshot = (t) => structuredClone(t), this["~registerMessagesCallback"] = (t, n) => {
      const o = n ? rI(t, n) : t;
      return it(this, Ws).add(o), () => {
        it(this, Ws).delete(o);
      };
    }, this["~registerStatusCallback"] = (t) => (it(this, Ks).add(t), () => {
      it(this, Ks).delete(t);
    }), this["~registerErrorCallback"] = (t) => (it(this, Js).add(t), () => {
      it(this, Js).delete(t);
    }), sr(this, va, () => {
      it(this, Ws).forEach((t) => t());
    }), sr(this, zm, () => {
      it(this, Ks).forEach((t) => t());
    }), sr(this, Dm, () => {
      it(this, Js).forEach((t) => t());
    }), _o(this, kn, e);
  }
  get status() {
    return it(this, Mu);
  }
  set status(e) {
    _o(this, Mu, e), it(this, zm).call(this);
  }
  get error() {
    return it(this, zu);
  }
  set error(e) {
    _o(this, zu, e), it(this, Dm).call(this);
  }
  get messages() {
    return it(this, kn);
  }
  set messages(e) {
    _o(this, kn, [...e]), it(this, va).call(this);
  }
};
kn = /* @__PURE__ */ new WeakMap();
Mu = /* @__PURE__ */ new WeakMap();
zu = /* @__PURE__ */ new WeakMap();
Ws = /* @__PURE__ */ new WeakMap();
Ks = /* @__PURE__ */ new WeakMap();
Js = /* @__PURE__ */ new WeakMap();
va = /* @__PURE__ */ new WeakMap();
zm = /* @__PURE__ */ new WeakMap();
Dm = /* @__PURE__ */ new WeakMap();
var ya, xw = class extends J3 {
  constructor({ messages: e, ...t }) {
    const n = new oI(e);
    super({ ...t, state: n }), sr(this, ya, void 0), this["~registerMessagesCallback"] = (o, a) => it(this, ya)["~registerMessagesCallback"](o, a), this["~registerStatusCallback"] = (o) => it(this, ya)["~registerStatusCallback"](o), this["~registerErrorCallback"] = (o) => it(this, ya)["~registerErrorCallback"](o), _o(this, ya, n);
  }
};
ya = /* @__PURE__ */ new WeakMap();
function iI({
  experimental_throttle: e,
  resume: t = !1,
  ...n
} = {}) {
  const o = y.useRef(
    "chat" in n ? n.chat : new xw(n)
  );
  ("chat" in n && n.chat !== o.current || "id" in n && o.current.id !== n.id) && (o.current = "chat" in n ? n.chat : new xw(n));
  const l = y.useCallback(
    (m) => o.current["~registerMessagesCallback"](m, e),
    // `chatRef.current.id` is required to trigger re-subscription when the chat ID changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [e, o.current.id]
  ), c = y.useSyncExternalStore(
    l,
    () => o.current.messages,
    () => o.current.messages
  ), f = y.useSyncExternalStore(
    o.current["~registerStatusCallback"],
    () => o.current.status,
    () => o.current.status
  ), d = y.useSyncExternalStore(
    o.current["~registerErrorCallback"],
    () => o.current.error,
    () => o.current.error
  ), h = y.useCallback(
    (m) => {
      typeof m == "function" && (m = m(o.current.messages)), o.current.messages = m;
    },
    [o]
  );
  return y.useEffect(() => {
    t && o.current.resumeStream();
  }, [t, o]), {
    id: o.current.id,
    messages: c,
    setMessages: h,
    sendMessage: o.current.sendMessage,
    regenerate: o.current.regenerate,
    clearError: o.current.clearError,
    stop: o.current.stop,
    error: d,
    resumeStream: o.current.resumeStream,
    status: f,
    /**
     * @deprecated Use `addToolOutput` instead.
     */
    addToolResult: o.current.addToolOutput,
    addToolOutput: o.current.addToolOutput
  };
}
const Og = y.createContext({});
function jg(e) {
  const t = y.useRef(null);
  return t.current === null && (t.current = e()), t.current;
}
const uT = typeof window < "u", fT = uT ? y.useLayoutEffect : y.useEffect, Nf = /* @__PURE__ */ y.createContext(null);
function kg(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function Pg(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
const gr = (e, t, n) => n > t ? t : n < e ? e : n;
let Lg = () => {
};
const Fr = {}, dT = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
function hT(e) {
  return typeof e == "object" && e !== null;
}
const pT = (e) => /^0[^.\s]+$/u.test(e);
// @__NO_SIDE_EFFECTS__
function Ig(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const In = /* @__NO_SIDE_EFFECTS__ */ (e) => e, aI = (e, t) => (n) => t(e(n)), Nl = (...e) => e.reduce(aI), vl = /* @__NO_SIDE_EFFECTS__ */ (e, t, n) => {
  const o = t - e;
  return o === 0 ? 1 : (n - e) / o;
};
class Vg {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return kg(this.subscriptions, t), () => Pg(this.subscriptions, t);
  }
  notify(t, n, o) {
    const a = this.subscriptions.length;
    if (a)
      if (a === 1)
        this.subscriptions[0](t, n, o);
      else
        for (let l = 0; l < a; l++) {
          const c = this.subscriptions[l];
          c && c(t, n, o);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const Zr = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, Ln = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3;
function mT(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const gT = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, sI = 1e-7, lI = 12;
function cI(e, t, n, o, a) {
  let l, c, f = 0;
  do
    c = t + (n - t) / 2, l = gT(c, o, a) - e, l > 0 ? n = c : t = c;
  while (Math.abs(l) > sI && ++f < lI);
  return c;
}
function Ol(e, t, n, o) {
  if (e === t && n === o)
    return In;
  const a = (l) => cI(l, 0, 1, e, n);
  return (l) => l === 0 || l === 1 ? l : gT(a(l), t, o);
}
const vT = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, yT = (e) => (t) => 1 - e(1 - t), bT = /* @__PURE__ */ Ol(0.33, 1.53, 0.69, 0.99), Ug = /* @__PURE__ */ yT(bT), xT = /* @__PURE__ */ vT(Ug), ST = (e) => (e *= 2) < 1 ? 0.5 * Ug(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), Bg = (e) => 1 - Math.sin(Math.acos(e)), wT = yT(Bg), ET = vT(Bg), uI = /* @__PURE__ */ Ol(0.42, 0, 1, 1), fI = /* @__PURE__ */ Ol(0, 0, 0.58, 1), _T = /* @__PURE__ */ Ol(0.42, 0, 0.58, 1), dI = (e) => Array.isArray(e) && typeof e[0] != "number", TT = (e) => Array.isArray(e) && typeof e[0] == "number", hI = {
  linear: In,
  easeIn: uI,
  easeInOut: _T,
  easeOut: fI,
  circIn: Bg,
  circInOut: ET,
  circOut: wT,
  backIn: Ug,
  backInOut: xT,
  backOut: bT,
  anticipate: ST
}, pI = (e) => typeof e == "string", Sw = (e) => {
  if (TT(e)) {
    Lg(e.length === 4);
    const [t, n, o, a] = e;
    return Ol(t, n, o, a);
  } else if (pI(e))
    return hI[e];
  return e;
}, mu = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function mI(e, t) {
  let n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), a = !1, l = !1;
  const c = /* @__PURE__ */ new WeakSet();
  let f = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function d(m) {
    c.has(m) && (h.schedule(m), e()), m(f);
  }
  const h = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (m, g = !1, b = !1) => {
      const _ = b && a ? n : o;
      return g && c.add(m), _.has(m) || _.add(m), m;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (m) => {
      o.delete(m), c.delete(m);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (m) => {
      if (f = m, a) {
        l = !0;
        return;
      }
      a = !0, [n, o] = [o, n], n.forEach(d), n.clear(), a = !1, l && (l = !1, h.process(m));
    }
  };
  return h;
}
const gI = 40;
function CT(e, t) {
  let n = !1, o = !0;
  const a = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, l = () => n = !0, c = mu.reduce((A, R) => (A[R] = mI(l), A), {}), { setup: f, read: d, resolveKeyframes: h, preUpdate: m, update: g, preRender: b, render: x, postRender: _ } = c, E = () => {
    const A = Fr.useManualTiming ? a.timestamp : performance.now();
    n = !1, Fr.useManualTiming || (a.delta = o ? 1e3 / 60 : Math.max(Math.min(A - a.timestamp, gI), 1)), a.timestamp = A, a.isProcessing = !0, f.process(a), d.process(a), h.process(a), m.process(a), g.process(a), b.process(a), x.process(a), _.process(a), a.isProcessing = !1, n && t && (o = !1, e(E));
  }, T = () => {
    n = !0, o = !0, a.isProcessing || e(E);
  };
  return { schedule: mu.reduce((A, R) => {
    const O = c[R];
    return A[R] = (L, M = !1, N = !1) => (n || T(), O.schedule(L, M, N)), A;
  }, {}), cancel: (A) => {
    for (let R = 0; R < mu.length; R++)
      c[mu[R]].cancel(A);
  }, state: a, steps: c };
}
const { schedule: et, cancel: No, state: Ut, steps: Up } = /* @__PURE__ */ CT(typeof requestAnimationFrame < "u" ? requestAnimationFrame : In, !0);
let Du;
function vI() {
  Du = void 0;
}
const Xt = {
  now: () => (Du === void 0 && Xt.set(Ut.isProcessing || Fr.useManualTiming ? Ut.timestamp : performance.now()), Du),
  set: (e) => {
    Du = e, queueMicrotask(vI);
  }
}, AT = (e) => (t) => typeof t == "string" && t.startsWith(e), RT = /* @__PURE__ */ AT("--"), yI = /* @__PURE__ */ AT("var(--"), $g = (e) => yI(e) ? bI.test(e.split("/*")[0].trim()) : !1, bI = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
function ww(e) {
  return typeof e != "string" ? !1 : e.split("/*")[0].includes("var(--");
}
const Ba = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, yl = {
  ...Ba,
  transform: (e) => gr(0, 1, e)
}, gu = {
  ...Ba,
  default: 1
}, ll = (e) => Math.round(e * 1e5) / 1e5, Hg = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function xI(e) {
  return e == null;
}
const SI = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Zg = (e, t) => (n) => !!(typeof n == "string" && SI.test(n) && n.startsWith(e) || t && !xI(n) && Object.prototype.hasOwnProperty.call(n, t)), MT = (e, t, n) => (o) => {
  if (typeof o != "string")
    return o;
  const [a, l, c, f] = o.match(Hg);
  return {
    [e]: parseFloat(a),
    [t]: parseFloat(l),
    [n]: parseFloat(c),
    alpha: f !== void 0 ? parseFloat(f) : 1
  };
}, wI = (e) => gr(0, 255, e), Bp = {
  ...Ba,
  transform: (e) => Math.round(wI(e))
}, fi = {
  test: /* @__PURE__ */ Zg("rgb", "red"),
  parse: /* @__PURE__ */ MT("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: o = 1 }) => "rgba(" + Bp.transform(e) + ", " + Bp.transform(t) + ", " + Bp.transform(n) + ", " + ll(yl.transform(o)) + ")"
};
function EI(e) {
  let t = "", n = "", o = "", a = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), o = e.substring(5, 7), a = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), o = e.substring(3, 4), a = e.substring(4, 5), t += t, n += n, o += o, a += a), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(o, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
const Nm = {
  test: /* @__PURE__ */ Zg("#"),
  parse: EI,
  transform: fi.transform
}, jl = /* @__NO_SIDE_EFFECTS__ */ (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), To = /* @__PURE__ */ jl("deg"), dr = /* @__PURE__ */ jl("%"), ye = /* @__PURE__ */ jl("px"), _I = /* @__PURE__ */ jl("vh"), TI = /* @__PURE__ */ jl("vw"), Ew = {
  ...dr,
  parse: (e) => dr.parse(e) / 100,
  transform: (e) => dr.transform(e * 100)
}, wa = {
  test: /* @__PURE__ */ Zg("hsl", "hue"),
  parse: /* @__PURE__ */ MT("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: o = 1 }) => "hsla(" + Math.round(e) + ", " + dr.transform(ll(t)) + ", " + dr.transform(ll(n)) + ", " + ll(yl.transform(o)) + ")"
}, Ct = {
  test: (e) => fi.test(e) || Nm.test(e) || wa.test(e),
  parse: (e) => fi.test(e) ? fi.parse(e) : wa.test(e) ? wa.parse(e) : Nm.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? fi.transform(e) : wa.transform(e),
  getAnimatableNone: (e) => {
    const t = Ct.parse(e);
    return t.alpha = 0, Ct.transform(t);
  }
}, CI = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function AI(e) {
  return isNaN(e) && typeof e == "string" && (e.match(Hg)?.length || 0) + (e.match(CI)?.length || 0) > 0;
}
const zT = "number", DT = "color", RI = "var", MI = "var(", _w = "${}", zI = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function bl(e) {
  const t = e.toString(), n = [], o = {
    color: [],
    number: [],
    var: []
  }, a = [];
  let l = 0;
  const f = t.replace(zI, (d) => (Ct.test(d) ? (o.color.push(l), a.push(DT), n.push(Ct.parse(d))) : d.startsWith(MI) ? (o.var.push(l), a.push(RI), n.push(d)) : (o.number.push(l), a.push(zT), n.push(parseFloat(d))), ++l, _w)).split(_w);
  return { values: n, split: f, indexes: o, types: a };
}
function NT(e) {
  return bl(e).values;
}
function OT(e) {
  const { split: t, types: n } = bl(e), o = t.length;
  return (a) => {
    let l = "";
    for (let c = 0; c < o; c++)
      if (l += t[c], a[c] !== void 0) {
        const f = n[c];
        f === zT ? l += ll(a[c]) : f === DT ? l += Ct.transform(a[c]) : l += a[c];
      }
    return l;
  };
}
const DI = (e) => typeof e == "number" ? 0 : Ct.test(e) ? Ct.getAnimatableNone(e) : e;
function NI(e) {
  const t = NT(e);
  return OT(e)(t.map(DI));
}
const Oo = {
  test: AI,
  parse: NT,
  createTransformer: OT,
  getAnimatableNone: NI
};
function $p(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function OI({ hue: e, saturation: t, lightness: n, alpha: o }) {
  e /= 360, t /= 100, n /= 100;
  let a = 0, l = 0, c = 0;
  if (!t)
    a = l = c = n;
  else {
    const f = n < 0.5 ? n * (1 + t) : n + t - n * t, d = 2 * n - f;
    a = $p(d, f, e + 1 / 3), l = $p(d, f, e), c = $p(d, f, e - 1 / 3);
  }
  return {
    red: Math.round(a * 255),
    green: Math.round(l * 255),
    blue: Math.round(c * 255),
    alpha: o
  };
}
function Qu(e, t) {
  return (n) => n > 0 ? t : e;
}
const ft = (e, t, n) => e + (t - e) * n, Hp = (e, t, n) => {
  const o = e * e, a = n * (t * t - o) + o;
  return a < 0 ? 0 : Math.sqrt(a);
}, jI = [Nm, fi, wa], kI = (e) => jI.find((t) => t.test(e));
function Tw(e) {
  const t = kI(e);
  if (!t)
    return !1;
  let n = t.parse(e);
  return t === wa && (n = OI(n)), n;
}
const Cw = (e, t) => {
  const n = Tw(e), o = Tw(t);
  if (!n || !o)
    return Qu(e, t);
  const a = { ...n };
  return (l) => (a.red = Hp(n.red, o.red, l), a.green = Hp(n.green, o.green, l), a.blue = Hp(n.blue, o.blue, l), a.alpha = ft(n.alpha, o.alpha, l), fi.transform(a));
}, Om = /* @__PURE__ */ new Set(["none", "hidden"]);
function PI(e, t) {
  return Om.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function LI(e, t) {
  return (n) => ft(e, t, n);
}
function Fg(e) {
  return typeof e == "number" ? LI : typeof e == "string" ? $g(e) ? Qu : Ct.test(e) ? Cw : UI : Array.isArray(e) ? jT : typeof e == "object" ? Ct.test(e) ? Cw : II : Qu;
}
function jT(e, t) {
  const n = [...e], o = n.length, a = e.map((l, c) => Fg(l)(l, t[c]));
  return (l) => {
    for (let c = 0; c < o; c++)
      n[c] = a[c](l);
    return n;
  };
}
function II(e, t) {
  const n = { ...e, ...t }, o = {};
  for (const a in n)
    e[a] !== void 0 && t[a] !== void 0 && (o[a] = Fg(e[a])(e[a], t[a]));
  return (a) => {
    for (const l in o)
      n[l] = o[l](a);
    return n;
  };
}
function VI(e, t) {
  const n = [], o = { color: 0, var: 0, number: 0 };
  for (let a = 0; a < t.values.length; a++) {
    const l = t.types[a], c = e.indexes[l][o[l]], f = e.values[c] ?? 0;
    n[a] = f, o[l]++;
  }
  return n;
}
const UI = (e, t) => {
  const n = Oo.createTransformer(t), o = bl(e), a = bl(t);
  return o.indexes.var.length === a.indexes.var.length && o.indexes.color.length === a.indexes.color.length && o.indexes.number.length >= a.indexes.number.length ? Om.has(e) && !a.values.length || Om.has(t) && !o.values.length ? PI(e, t) : Nl(jT(VI(o, a), a.values), n) : Qu(e, t);
};
function kT(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? ft(e, t, n) : Fg(e)(e, t);
}
const BI = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: (n = !0) => et.update(t, n),
    stop: () => No(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Ut.isProcessing ? Ut.timestamp : Xt.now()
  };
}, PT = (e, t, n = 10) => {
  let o = "";
  const a = Math.max(Math.round(t / n), 2);
  for (let l = 0; l < a; l++)
    o += Math.round(e(l / (a - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${o.substring(0, o.length - 2)})`;
}, ef = 2e4;
function Gg(e) {
  let t = 0;
  const n = 50;
  let o = e.next(t);
  for (; !o.done && t < ef; )
    t += n, o = e.next(t);
  return t >= ef ? 1 / 0 : t;
}
function $I(e, t = 100, n) {
  const o = n({ ...e, keyframes: [0, t] }), a = Math.min(Gg(o), ef);
  return {
    type: "keyframes",
    ease: (l) => o.next(a * l).value / t,
    duration: /* @__PURE__ */ Ln(a)
  };
}
const HI = 5;
function LT(e, t, n) {
  const o = Math.max(t - HI, 0);
  return mT(n - e(o), t - o);
}
const mt = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, Zp = 1e-3;
function ZI({ duration: e = mt.duration, bounce: t = mt.bounce, velocity: n = mt.velocity, mass: o = mt.mass }) {
  let a, l, c = 1 - t;
  c = gr(mt.minDamping, mt.maxDamping, c), e = gr(mt.minDuration, mt.maxDuration, /* @__PURE__ */ Ln(e)), c < 1 ? (a = (h) => {
    const m = h * c, g = m * e, b = m - n, x = jm(h, c), _ = Math.exp(-g);
    return Zp - b / x * _;
  }, l = (h) => {
    const g = h * c * e, b = g * n + n, x = Math.pow(c, 2) * Math.pow(h, 2) * e, _ = Math.exp(-g), E = jm(Math.pow(h, 2), c);
    return (-a(h) + Zp > 0 ? -1 : 1) * ((b - x) * _) / E;
  }) : (a = (h) => {
    const m = Math.exp(-h * e), g = (h - n) * e + 1;
    return -Zp + m * g;
  }, l = (h) => {
    const m = Math.exp(-h * e), g = (n - h) * (e * e);
    return m * g;
  });
  const f = 5 / e, d = GI(a, l, f);
  if (e = /* @__PURE__ */ Zr(e), isNaN(d))
    return {
      stiffness: mt.stiffness,
      damping: mt.damping,
      duration: e
    };
  {
    const h = Math.pow(d, 2) * o;
    return {
      stiffness: h,
      damping: c * 2 * Math.sqrt(o * h),
      duration: e
    };
  }
}
const FI = 12;
function GI(e, t, n) {
  let o = n;
  for (let a = 1; a < FI; a++)
    o = o - e(o) / t(o);
  return o;
}
function jm(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const YI = ["duration", "bounce"], qI = ["stiffness", "damping", "mass"];
function Aw(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function XI(e) {
  let t = {
    velocity: mt.velocity,
    stiffness: mt.stiffness,
    damping: mt.damping,
    mass: mt.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!Aw(e, qI) && Aw(e, YI))
    if (e.visualDuration) {
      const n = e.visualDuration, o = 2 * Math.PI / (n * 1.2), a = o * o, l = 2 * gr(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(a);
      t = {
        ...t,
        mass: mt.mass,
        stiffness: a,
        damping: l
      };
    } else {
      const n = ZI(e);
      t = {
        ...t,
        ...n,
        mass: mt.mass
      }, t.isResolvedFromDuration = !0;
    }
  return t;
}
function tf(e = mt.visualDuration, t = mt.bounce) {
  const n = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: t
  } : e;
  let { restSpeed: o, restDelta: a } = n;
  const l = n.keyframes[0], c = n.keyframes[n.keyframes.length - 1], f = { done: !1, value: l }, { stiffness: d, damping: h, mass: m, duration: g, velocity: b, isResolvedFromDuration: x } = XI({
    ...n,
    velocity: -/* @__PURE__ */ Ln(n.velocity || 0)
  }), _ = b || 0, E = h / (2 * Math.sqrt(d * m)), T = c - l, C = /* @__PURE__ */ Ln(Math.sqrt(d / m)), z = Math.abs(T) < 5;
  o || (o = z ? mt.restSpeed.granular : mt.restSpeed.default), a || (a = z ? mt.restDelta.granular : mt.restDelta.default);
  let A;
  if (E < 1) {
    const O = jm(C, E);
    A = (L) => {
      const M = Math.exp(-E * C * L);
      return c - M * ((_ + E * C * T) / O * Math.sin(O * L) + T * Math.cos(O * L));
    };
  } else if (E === 1)
    A = (O) => c - Math.exp(-C * O) * (T + (_ + C * T) * O);
  else {
    const O = C * Math.sqrt(E * E - 1);
    A = (L) => {
      const M = Math.exp(-E * C * L), N = Math.min(O * L, 300);
      return c - M * ((_ + E * C * T) * Math.sinh(N) + O * T * Math.cosh(N)) / O;
    };
  }
  const R = {
    calculatedDuration: x && g || null,
    next: (O) => {
      const L = A(O);
      if (x)
        f.done = O >= g;
      else {
        let M = O === 0 ? _ : 0;
        E < 1 && (M = O === 0 ? /* @__PURE__ */ Zr(_) : LT(A, O, L));
        const N = Math.abs(M) <= o, j = Math.abs(c - L) <= a;
        f.done = N && j;
      }
      return f.value = f.done ? c : L, f;
    },
    toString: () => {
      const O = Math.min(Gg(R), ef), L = PT((M) => R.next(O * M).value, O, 30);
      return O + "ms " + L;
    },
    toTransition: () => {
    }
  };
  return R;
}
tf.applyToOptions = (e) => {
  const t = $I(e, 100, tf);
  return e.ease = t.ease, e.duration = /* @__PURE__ */ Zr(t.duration), e.type = "keyframes", e;
};
function km({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: o = 325, bounceDamping: a = 10, bounceStiffness: l = 500, modifyTarget: c, min: f, max: d, restDelta: h = 0.5, restSpeed: m }) {
  const g = e[0], b = {
    done: !1,
    value: g
  }, x = (N) => f !== void 0 && N < f || d !== void 0 && N > d, _ = (N) => f === void 0 ? d : d === void 0 || Math.abs(f - N) < Math.abs(d - N) ? f : d;
  let E = n * t;
  const T = g + E, C = c === void 0 ? T : c(T);
  C !== T && (E = C - g);
  const z = (N) => -E * Math.exp(-N / o), A = (N) => C + z(N), R = (N) => {
    const j = z(N), Y = A(N);
    b.done = Math.abs(j) <= h, b.value = b.done ? C : Y;
  };
  let O, L;
  const M = (N) => {
    x(b.value) && (O = N, L = tf({
      keyframes: [b.value, _(b.value)],
      velocity: LT(A, N, b.value),
      // TODO: This should be passing * 1000
      damping: a,
      stiffness: l,
      restDelta: h,
      restSpeed: m
    }));
  };
  return M(0), {
    calculatedDuration: null,
    next: (N) => {
      let j = !1;
      return !L && O === void 0 && (j = !0, R(N), M(N)), O !== void 0 && N >= O ? L.next(N - O) : (!j && R(N), b);
    }
  };
}
function WI(e, t, n) {
  const o = [], a = n || Fr.mix || kT, l = e.length - 1;
  for (let c = 0; c < l; c++) {
    let f = a(e[c], e[c + 1]);
    if (t) {
      const d = Array.isArray(t) ? t[c] || In : t;
      f = Nl(d, f);
    }
    o.push(f);
  }
  return o;
}
function KI(e, t, { clamp: n = !0, ease: o, mixer: a } = {}) {
  const l = e.length;
  if (Lg(l === t.length), l === 1)
    return () => t[0];
  if (l === 2 && t[0] === t[1])
    return () => t[1];
  const c = e[0] === e[1];
  e[0] > e[l - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const f = WI(t, o, a), d = f.length, h = (m) => {
    if (c && m < e[0])
      return t[0];
    let g = 0;
    if (d > 1)
      for (; g < e.length - 2 && !(m < e[g + 1]); g++)
        ;
    const b = /* @__PURE__ */ vl(e[g], e[g + 1], m);
    return f[g](b);
  };
  return n ? (m) => h(gr(e[0], e[l - 1], m)) : h;
}
function JI(e, t) {
  const n = e[e.length - 1];
  for (let o = 1; o <= t; o++) {
    const a = /* @__PURE__ */ vl(0, t, o);
    e.push(ft(n, 1, a));
  }
}
function QI(e) {
  const t = [0];
  return JI(t, e.length - 1), t;
}
function e5(e, t) {
  return e.map((n) => n * t);
}
function t5(e, t) {
  return e.map(() => t || _T).splice(0, e.length - 1);
}
function cl({ duration: e = 300, keyframes: t, times: n, ease: o = "easeInOut" }) {
  const a = dI(o) ? o.map(Sw) : Sw(o), l = {
    done: !1,
    value: t[0]
  }, c = e5(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : QI(t),
    e
  ), f = KI(c, t, {
    ease: Array.isArray(a) ? a : t5(t, a)
  });
  return {
    calculatedDuration: e,
    next: (d) => (l.value = f(d), l.done = d >= e, l)
  };
}
const n5 = (e) => e !== null;
function Yg(e, { repeat: t, repeatType: n = "loop" }, o, a = 1) {
  const l = e.filter(n5), f = a < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : l.length - 1;
  return !f || o === void 0 ? l[f] : o;
}
const r5 = {
  decay: km,
  inertia: km,
  tween: cl,
  keyframes: cl,
  spring: tf
};
function IT(e) {
  typeof e.type == "string" && (e.type = r5[e.type]);
}
class qg {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
}
const o5 = (e) => e / 100;
class Xg extends qg {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      const { motionValue: n } = this.options;
      n && n.updatedAt !== Xt.now() && this.tick(Xt.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.());
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    IT(t);
    const { type: n = cl, repeat: o = 0, repeatDelay: a = 0, repeatType: l, velocity: c = 0 } = t;
    let { keyframes: f } = t;
    const d = n || cl;
    d !== cl && typeof f[0] != "number" && (this.mixKeyframes = Nl(o5, kT(f[0], f[1])), f = [0, 100]);
    const h = d({ ...t, keyframes: f });
    l === "mirror" && (this.mirroredGenerator = d({
      ...t,
      keyframes: [...f].reverse(),
      velocity: -c
    })), h.calculatedDuration === null && (h.calculatedDuration = Gg(h));
    const { calculatedDuration: m } = h;
    this.calculatedDuration = m, this.resolvedDuration = m + a, this.totalDuration = this.resolvedDuration * (o + 1) - a, this.generator = h;
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(t, n = !1) {
    const { generator: o, totalDuration: a, mixKeyframes: l, mirroredGenerator: c, resolvedDuration: f, calculatedDuration: d } = this;
    if (this.startTime === null)
      return o.next(0);
    const { delay: h = 0, keyframes: m, repeat: g, repeatType: b, repeatDelay: x, type: _, onUpdate: E, finalKeyframe: T } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - a / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
    const C = this.currentTime - h * (this.playbackSpeed >= 0 ? 1 : -1), z = this.playbackSpeed >= 0 ? C < 0 : C > a;
    this.currentTime = Math.max(C, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = a);
    let A = this.currentTime, R = o;
    if (g) {
      const N = Math.min(this.currentTime, a) / f;
      let j = Math.floor(N), Y = N % 1;
      !Y && N >= 1 && (Y = 1), Y === 1 && j--, j = Math.min(j, g + 1), j % 2 && (b === "reverse" ? (Y = 1 - Y, x && (Y -= x / f)) : b === "mirror" && (R = c)), A = gr(0, 1, Y) * f;
    }
    const O = z ? { done: !1, value: m[0] } : R.next(A);
    l && (O.value = l(O.value));
    let { done: L } = O;
    !z && d !== null && (L = this.playbackSpeed >= 0 ? this.currentTime >= a : this.currentTime <= 0);
    const M = this.holdTime === null && (this.state === "finished" || this.state === "running" && L);
    return M && _ !== km && (O.value = Yg(m, this.options, T, this.speed)), E && E(O.value), M && this.finish(), O;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return /* @__PURE__ */ Ln(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ Ln(t);
  }
  get time() {
    return /* @__PURE__ */ Ln(this.currentTime);
  }
  set time(t) {
    t = /* @__PURE__ */ Zr(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), this.driver?.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(Xt.now());
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = /* @__PURE__ */ Ln(this.currentTime));
  }
  play() {
    if (this.isStopped)
      return;
    const { driver: t = BI, startTime: n } = this.options;
    this.driver || (this.driver = t((a) => this.tick(a))), this.options.onPlay?.();
    const o = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = o) : this.holdTime !== null ? this.startTime = o - this.holdTime : this.startTime || (this.startTime = n ?? o), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(Xt.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.();
  }
  cancel() {
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), t.observe(this);
  }
}
function i5(e) {
  for (let t = 1; t < e.length; t++)
    e[t] ?? (e[t] = e[t - 1]);
}
const di = (e) => e * 180 / Math.PI, Pm = (e) => {
  const t = di(Math.atan2(e[1], e[0]));
  return Lm(t);
}, a5 = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
  rotate: Pm,
  rotateZ: Pm,
  skewX: (e) => di(Math.atan(e[1])),
  skewY: (e) => di(Math.atan(e[2])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2
}, Lm = (e) => (e = e % 360, e < 0 && (e += 360), e), Rw = Pm, Mw = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]), zw = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]), s5 = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: Mw,
  scaleY: zw,
  scale: (e) => (Mw(e) + zw(e)) / 2,
  rotateX: (e) => Lm(di(Math.atan2(e[6], e[5]))),
  rotateY: (e) => Lm(di(Math.atan2(-e[2], e[0]))),
  rotateZ: Rw,
  rotate: Rw,
  skewX: (e) => di(Math.atan(e[4])),
  skewY: (e) => di(Math.atan(e[1])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2
};
function Im(e) {
  return e.includes("scale") ? 1 : 0;
}
function Vm(e, t) {
  if (!e || e === "none")
    return Im(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let o, a;
  if (n)
    o = s5, a = n;
  else {
    const f = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    o = a5, a = f;
  }
  if (!a)
    return Im(t);
  const l = o[t], c = a[1].split(",").map(c5);
  return typeof l == "function" ? l(c) : c[l];
}
const l5 = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return Vm(n, t);
};
function c5(e) {
  return parseFloat(e.trim());
}
const $a = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Ha = new Set($a), Dw = (e) => e === Ba || e === ye, u5 = /* @__PURE__ */ new Set(["x", "y", "z"]), f5 = $a.filter((e) => !u5.has(e));
function d5(e) {
  const t = [];
  return f5.forEach((n) => {
    const o = e.getValue(n);
    o !== void 0 && (t.push([n, o.get()]), o.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const Mo = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: (e, { transform: t }) => Vm(t, "x"),
  y: (e, { transform: t }) => Vm(t, "y")
};
Mo.translateX = Mo.x;
Mo.translateY = Mo.y;
const pi = /* @__PURE__ */ new Set();
let Um = !1, Bm = !1, $m = !1;
function VT() {
  if (Bm) {
    const e = Array.from(pi).filter((o) => o.needsMeasurement), t = new Set(e.map((o) => o.element)), n = /* @__PURE__ */ new Map();
    t.forEach((o) => {
      const a = d5(o);
      a.length && (n.set(o, a), o.render());
    }), e.forEach((o) => o.measureInitialState()), t.forEach((o) => {
      o.render();
      const a = n.get(o);
      a && a.forEach(([l, c]) => {
        o.getValue(l)?.set(c);
      });
    }), e.forEach((o) => o.measureEndState()), e.forEach((o) => {
      o.suspendedScrollY !== void 0 && window.scrollTo(0, o.suspendedScrollY);
    });
  }
  Bm = !1, Um = !1, pi.forEach((e) => e.complete($m)), pi.clear();
}
function UT() {
  pi.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (Bm = !0);
  });
}
function h5() {
  $m = !0, UT(), VT(), $m = !1;
}
class Wg {
  constructor(t, n, o, a, l, c = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = o, this.motionValue = a, this.element = l, this.isAsync = c;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (pi.add(this), Um || (Um = !0, et.read(UT), et.resolveKeyframes(VT))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: o, motionValue: a } = this;
    if (t[0] === null) {
      const l = a?.get(), c = t[t.length - 1];
      if (l !== void 0)
        t[0] = l;
      else if (o && n) {
        const f = o.readValue(n, c);
        f != null && (t[0] = f);
      }
      t[0] === void 0 && (t[0] = c), a && l === void 0 && a.set(t[0]);
    }
    i5(t);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(t = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), pi.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (pi.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const p5 = (e) => e.startsWith("--");
function m5(e, t, n) {
  p5(t) ? e.style.setProperty(t, n) : e.style[t] = n;
}
const g5 = /* @__PURE__ */ Ig(() => window.ScrollTimeline !== void 0), v5 = {};
function y5(e, t) {
  const n = /* @__PURE__ */ Ig(e);
  return () => v5[t] ?? n();
}
const BT = /* @__PURE__ */ y5(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), Qs = ([e, t, n, o]) => `cubic-bezier(${e}, ${t}, ${n}, ${o})`, Nw = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ Qs([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ Qs([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ Qs([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ Qs([0.33, 1.53, 0.69, 0.99])
};
function $T(e, t) {
  if (e)
    return typeof e == "function" ? BT() ? PT(e, t) : "ease-out" : TT(e) ? Qs(e) : Array.isArray(e) ? e.map((n) => $T(n, t) || Nw.easeOut) : Nw[e];
}
function b5(e, t, n, { delay: o = 0, duration: a = 300, repeat: l = 0, repeatType: c = "loop", ease: f = "easeOut", times: d } = {}, h = void 0) {
  const m = {
    [t]: n
  };
  d && (m.offset = d);
  const g = $T(f, a);
  Array.isArray(g) && (m.easing = g);
  const b = {
    delay: o,
    duration: a,
    easing: Array.isArray(g) ? "linear" : g,
    fill: "both",
    iterations: l + 1,
    direction: c === "reverse" ? "alternate" : "normal"
  };
  return h && (b.pseudoElement = h), e.animate(m, b);
}
function HT(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
function x5({ type: e, ...t }) {
  return HT(e) && BT() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
class S5 extends qg {
  constructor(t) {
    if (super(), this.finishedTime = null, this.isStopped = !1, this.manualStartTime = null, !t)
      return;
    const { element: n, name: o, keyframes: a, pseudoElement: l, allowFlatten: c = !1, finalKeyframe: f, onComplete: d } = t;
    this.isPseudoElement = !!l, this.allowFlatten = c, this.options = t, Lg(typeof t.type != "string");
    const h = x5(t);
    this.animation = b5(n, o, a, h, l), h.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !l) {
        const m = Yg(a, this.options, f, this.speed);
        this.updateMotionValue ? this.updateMotionValue(m) : m5(n, o, m), this.animation.cancel();
      }
      d?.(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.manualStartTime = null, this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    const t = this.options?.element;
    !this.isPseudoElement && t?.isConnected && this.animation.commitStyles?.();
  }
  get duration() {
    const t = this.animation.effect?.getComputedTiming?.().duration || 0;
    return /* @__PURE__ */ Ln(Number(t));
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ Ln(t);
  }
  get time() {
    return /* @__PURE__ */ Ln(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    this.manualStartTime = null, this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ Zr(t);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), this.animation.playbackRate = t;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return this.manualStartTime ?? Number(this.animation.startTime);
  }
  set startTime(t) {
    this.manualStartTime = this.animation.startTime = t;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: t, observe: n }) {
    return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, t && g5() ? (this.animation.timeline = t, In) : n(this);
  }
}
const ZT = {
  anticipate: ST,
  backInOut: xT,
  circInOut: ET
};
function w5(e) {
  return e in ZT;
}
function E5(e) {
  typeof e.ease == "string" && w5(e.ease) && (e.ease = ZT[e.ease]);
}
const Fp = 10;
class _5 extends S5 {
  constructor(t) {
    E5(t), IT(t), super(t), t.startTime !== void 0 && (this.startTime = t.startTime), this.options = t;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read committed styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: o, onComplete: a, element: l, ...c } = this.options;
    if (!n)
      return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const f = new Xg({
      ...c,
      autoplay: !1
    }), d = Math.max(Fp, Xt.now() - this.startTime), h = gr(0, Fp, d - Fp);
    n.setWithVelocity(f.sample(Math.max(0, d - h)).value, f.sample(d).value, h), f.stop();
  }
}
const Ow = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(Oo.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function T5(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function C5(e, t, n, o) {
  const a = e[0];
  if (a === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const l = e[e.length - 1], c = Ow(a, t), f = Ow(l, t);
  return !c || !f ? !1 : T5(e) || (n === "spring" || HT(n)) && o;
}
function Hm(e) {
  e.duration = 0, e.type = "keyframes";
}
const A5 = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), R5 = /* @__PURE__ */ Ig(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function M5(e) {
  const { motionValue: t, name: n, repeatDelay: o, repeatType: a, damping: l, type: c } = e;
  if (!(t?.owner?.current instanceof HTMLElement))
    return !1;
  const { onUpdate: d, transformTemplate: h } = t.owner.getProps();
  return R5() && n && A5.has(n) && (n !== "transform" || !h) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !d && !o && a !== "mirror" && l !== 0 && c !== "inertia";
}
const z5 = 40;
class D5 extends qg {
  constructor({ autoplay: t = !0, delay: n = 0, type: o = "keyframes", repeat: a = 0, repeatDelay: l = 0, repeatType: c = "loop", keyframes: f, name: d, motionValue: h, element: m, ...g }) {
    super(), this.stop = () => {
      this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel();
    }, this.createdAt = Xt.now();
    const b = {
      autoplay: t,
      delay: n,
      type: o,
      repeat: a,
      repeatDelay: l,
      repeatType: c,
      name: d,
      motionValue: h,
      element: m,
      ...g
    }, x = m?.KeyframeResolver || Wg;
    this.keyframeResolver = new x(f, (_, E, T) => this.onKeyframesResolved(_, E, b, !T), d, h, m), this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(t, n, o, a) {
    this.keyframeResolver = void 0;
    const { name: l, type: c, velocity: f, delay: d, isHandoff: h, onUpdate: m } = o;
    this.resolvedAt = Xt.now(), C5(t, l, c, f) || ((Fr.instantAnimations || !d) && m?.(Yg(t, o, n)), t[0] = t[t.length - 1], Hm(o), o.repeat = 0);
    const b = {
      startTime: a ? this.resolvedAt ? this.resolvedAt - this.createdAt > z5 ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...o,
      keyframes: t
    }, x = !h && M5(b), _ = b.motionValue?.owner?.current, E = x ? new _5({
      ...b,
      element: _
    }) : new Xg(b);
    E.finished.then(() => {
      this.notifyFinished();
    }).catch(In), this.pendingTimeline && (this.stopTimeline = E.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = E;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    return this._animation || (this.keyframeResolver?.resume(), h5()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();
  }
}
function FT(e, t, n, o = 0, a = 1) {
  const l = Array.from(e).sort((h, m) => h.sortNodePosition(m)).indexOf(t), c = e.size, f = (c - 1) * o;
  return typeof n == "function" ? n(l, c) : a === 1 ? l * o : f - l * o;
}
const N5 = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function O5(e) {
  const t = N5.exec(e);
  if (!t)
    return [,];
  const [, n, o, a] = t;
  return [`--${n ?? o}`, a];
}
function GT(e, t, n = 1) {
  const [o, a] = O5(e);
  if (!o)
    return;
  const l = window.getComputedStyle(t).getPropertyValue(o);
  if (l) {
    const c = l.trim();
    return dT(c) ? parseFloat(c) : c;
  }
  return $g(a) ? GT(a, t, n + 1) : a;
}
const j5 = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, k5 = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), P5 = {
  type: "keyframes",
  duration: 0.8
}, L5 = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, I5 = (e, { keyframes: t }) => t.length > 2 ? P5 : Ha.has(e) ? e.startsWith("scale") ? k5(t[1]) : j5 : L5, V5 = (e) => e !== null;
function U5(e, { repeat: t, repeatType: n = "loop" }, o) {
  const a = e.filter(V5), l = t && n !== "loop" && t % 2 === 1 ? 0 : a.length - 1;
  return a[l];
}
function Kg(e, t) {
  return e?.[t] ?? e?.default ?? e;
}
function B5({ when: e, delay: t, delayChildren: n, staggerChildren: o, staggerDirection: a, repeat: l, repeatType: c, repeatDelay: f, from: d, elapsed: h, ...m }) {
  return !!Object.keys(m).length;
}
const Jg = (e, t, n, o = {}, a, l) => (c) => {
  const f = Kg(o, e) || {}, d = f.delay || o.delay || 0;
  let { elapsed: h = 0 } = o;
  h = h - /* @__PURE__ */ Zr(d);
  const m = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...f,
    delay: -h,
    onUpdate: (b) => {
      t.set(b), f.onUpdate && f.onUpdate(b);
    },
    onComplete: () => {
      c(), f.onComplete && f.onComplete();
    },
    name: e,
    motionValue: t,
    element: l ? void 0 : a
  };
  B5(f) || Object.assign(m, I5(e, m)), m.duration && (m.duration = /* @__PURE__ */ Zr(m.duration)), m.repeatDelay && (m.repeatDelay = /* @__PURE__ */ Zr(m.repeatDelay)), m.from !== void 0 && (m.keyframes[0] = m.from);
  let g = !1;
  if ((m.type === !1 || m.duration === 0 && !m.repeatDelay) && (Hm(m), m.delay === 0 && (g = !0)), (Fr.instantAnimations || Fr.skipAnimations || a?.shouldSkipAnimations) && (g = !0, Hm(m), m.delay = 0), m.allowFlatten = !f.type && !f.ease, g && !l && t.get() !== void 0) {
    const b = U5(m.keyframes, f);
    if (b !== void 0) {
      et.update(() => {
        m.onUpdate(b), m.onComplete();
      });
      return;
    }
  }
  return f.isSync ? new Xg(m) : new D5(m);
};
function jw(e) {
  const t = [{}, {}];
  return e?.values.forEach((n, o) => {
    t[0][o] = n.get(), t[1][o] = n.getVelocity();
  }), t;
}
function Qg(e, t, n, o) {
  if (typeof t == "function") {
    const [a, l] = jw(o);
    t = t(n !== void 0 ? n : e.custom, a, l);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [a, l] = jw(o);
    t = t(n !== void 0 ? n : e.custom, a, l);
  }
  return t;
}
function Ma(e, t, n) {
  const o = e.getProps();
  return Qg(o, t, n !== void 0 ? n : o.custom, e);
}
const YT = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...$a
]), kw = 30, $5 = (e) => !isNaN(parseFloat(e));
class H5 {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(t, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (o) => {
      const a = Xt.now();
      if (this.updatedAt !== a && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(o), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents))
        for (const l of this.dependents)
          l.dirty();
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = Xt.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = $5(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new Vg());
    const o = this.events[t].add(n);
    return t === "change" ? () => {
      o(), et.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : o;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t) {
    this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t);
  }
  setWithVelocity(t, n, o) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - o;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = Xt.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > kw)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, kw);
    return mT(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function ka(e, t) {
  return new H5(e, t);
}
const Zm = (e) => Array.isArray(e);
function Z5(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, ka(n));
}
function F5(e) {
  return Zm(e) ? e[e.length - 1] || 0 : e;
}
function G5(e, t) {
  const n = Ma(e, t);
  let { transitionEnd: o = {}, transition: a = {}, ...l } = n || {};
  l = { ...l, ...o };
  for (const c in l) {
    const f = F5(l[c]);
    Z5(e, c, f);
  }
}
const Ft = (e) => !!(e && e.getVelocity);
function Y5(e) {
  return !!(Ft(e) && e.add);
}
function Fm(e, t) {
  const n = e.getValue("willChange");
  if (Y5(n))
    return n.add(t);
  if (!n && Fr.WillChange) {
    const o = new Fr.WillChange("auto");
    e.addValue("willChange", o), o.add(t);
  }
}
function ev(e) {
  return e.replace(/([A-Z])/g, (t) => `-${t.toLowerCase()}`);
}
const q5 = "framerAppearId", qT = "data-" + ev(q5);
function XT(e) {
  return e.props[qT];
}
function X5({ protectedKeys: e, needsAnimating: t }, n) {
  const o = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, o;
}
function WT(e, t, { delay: n = 0, transitionOverride: o, type: a } = {}) {
  let { transition: l = e.getDefaultTransition(), transitionEnd: c, ...f } = t;
  const d = l?.reduceMotion;
  o && (l = o);
  const h = [], m = a && e.animationState && e.animationState.getState()[a];
  for (const g in f) {
    const b = e.getValue(g, e.latestValues[g] ?? null), x = f[g];
    if (x === void 0 || m && X5(m, g))
      continue;
    const _ = {
      delay: n,
      ...Kg(l || {}, g)
    }, E = b.get();
    if (E !== void 0 && !b.isAnimating && !Array.isArray(x) && x === E && !_.velocity)
      continue;
    let T = !1;
    if (window.MotionHandoffAnimation) {
      const A = XT(e);
      if (A) {
        const R = window.MotionHandoffAnimation(A, g, et);
        R !== null && (_.startTime = R, T = !0);
      }
    }
    Fm(e, g);
    const C = d ?? e.shouldReduceMotion;
    b.start(Jg(g, b, x, C && YT.has(g) ? { type: !1 } : _, e, T));
    const z = b.animation;
    z && h.push(z);
  }
  return c && Promise.all(h).then(() => {
    et.update(() => {
      c && G5(e, c);
    });
  }), h;
}
function Gm(e, t, n = {}) {
  const o = Ma(e, t, n.type === "exit" ? e.presenceContext?.custom : void 0);
  let { transition: a = e.getDefaultTransition() || {} } = o || {};
  n.transitionOverride && (a = n.transitionOverride);
  const l = o ? () => Promise.all(WT(e, o, n)) : () => Promise.resolve(), c = e.variantChildren && e.variantChildren.size ? (d = 0) => {
    const { delayChildren: h = 0, staggerChildren: m, staggerDirection: g } = a;
    return W5(e, t, d, h, m, g, n);
  } : () => Promise.resolve(), { when: f } = a;
  if (f) {
    const [d, h] = f === "beforeChildren" ? [l, c] : [c, l];
    return d().then(() => h());
  } else
    return Promise.all([l(), c(n.delay)]);
}
function W5(e, t, n = 0, o = 0, a = 0, l = 1, c) {
  const f = [];
  for (const d of e.variantChildren)
    d.notify("AnimationStart", t), f.push(Gm(d, t, {
      ...c,
      delay: n + (typeof o == "function" ? 0 : o) + FT(e.variantChildren, d, o, a, l)
    }).then(() => d.notify("AnimationComplete", t)));
  return Promise.all(f);
}
function K5(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let o;
  if (Array.isArray(t)) {
    const a = t.map((l) => Gm(e, l, n));
    o = Promise.all(a);
  } else if (typeof t == "string")
    o = Gm(e, t, n);
  else {
    const a = typeof t == "function" ? Ma(e, t, n.custom) : t;
    o = Promise.all(WT(e, a, n));
  }
  return o.then(() => {
    e.notify("AnimationComplete", t);
  });
}
const J5 = {
  test: (e) => e === "auto",
  parse: (e) => e
}, KT = (e) => (t) => t.test(e), JT = [Ba, ye, dr, To, TI, _I, J5], Pw = (e) => JT.find(KT(e));
function Q5(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || pT(e) : !0;
}
const eV = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function tV(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [o] = n.match(Hg) || [];
  if (!o)
    return e;
  const a = n.replace(o, "");
  let l = eV.has(t) ? 1 : 0;
  return o !== n && (l *= 100), t + "(" + l + a + ")";
}
const nV = /\b([a-z-]*)\(.*?\)/gu, Ym = {
  ...Oo,
  getAnimatableNone: (e) => {
    const t = e.match(nV);
    return t ? t.map(tV).join(" ") : e;
  }
}, Lw = {
  ...Ba,
  transform: Math.round
}, rV = {
  rotate: To,
  rotateX: To,
  rotateY: To,
  rotateZ: To,
  scale: gu,
  scaleX: gu,
  scaleY: gu,
  scaleZ: gu,
  skew: To,
  skewX: To,
  skewY: To,
  distance: ye,
  translateX: ye,
  translateY: ye,
  translateZ: ye,
  x: ye,
  y: ye,
  z: ye,
  perspective: ye,
  transformPerspective: ye,
  opacity: yl,
  originX: Ew,
  originY: Ew,
  originZ: ye
}, tv = {
  // Border props
  borderWidth: ye,
  borderTopWidth: ye,
  borderRightWidth: ye,
  borderBottomWidth: ye,
  borderLeftWidth: ye,
  borderRadius: ye,
  borderTopLeftRadius: ye,
  borderTopRightRadius: ye,
  borderBottomRightRadius: ye,
  borderBottomLeftRadius: ye,
  // Positioning props
  width: ye,
  maxWidth: ye,
  height: ye,
  maxHeight: ye,
  top: ye,
  right: ye,
  bottom: ye,
  left: ye,
  inset: ye,
  insetBlock: ye,
  insetBlockStart: ye,
  insetBlockEnd: ye,
  insetInline: ye,
  insetInlineStart: ye,
  insetInlineEnd: ye,
  // Spacing props
  padding: ye,
  paddingTop: ye,
  paddingRight: ye,
  paddingBottom: ye,
  paddingLeft: ye,
  paddingBlock: ye,
  paddingBlockStart: ye,
  paddingBlockEnd: ye,
  paddingInline: ye,
  paddingInlineStart: ye,
  paddingInlineEnd: ye,
  margin: ye,
  marginTop: ye,
  marginRight: ye,
  marginBottom: ye,
  marginLeft: ye,
  marginBlock: ye,
  marginBlockStart: ye,
  marginBlockEnd: ye,
  marginInline: ye,
  marginInlineStart: ye,
  marginInlineEnd: ye,
  // Typography
  fontSize: ye,
  // Misc
  backgroundPositionX: ye,
  backgroundPositionY: ye,
  ...rV,
  zIndex: Lw,
  // SVG
  fillOpacity: yl,
  strokeOpacity: yl,
  numOctaves: Lw
}, oV = {
  ...tv,
  // Color props
  color: Ct,
  backgroundColor: Ct,
  outlineColor: Ct,
  fill: Ct,
  stroke: Ct,
  // Border props
  borderColor: Ct,
  borderTopColor: Ct,
  borderRightColor: Ct,
  borderBottomColor: Ct,
  borderLeftColor: Ct,
  filter: Ym,
  WebkitFilter: Ym
}, QT = (e) => oV[e];
function eC(e, t) {
  let n = QT(e);
  return n !== Ym && (n = Oo), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const iV = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function aV(e, t, n) {
  let o = 0, a;
  for (; o < e.length && !a; ) {
    const l = e[o];
    typeof l == "string" && !iV.has(l) && bl(l).values.length && (a = e[o]), o++;
  }
  if (a && n)
    for (const l of t)
      e[l] = eC(n, a);
}
class sV extends Wg {
  constructor(t, n, o, a, l) {
    super(t, n, o, a, l, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: o } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let m = 0; m < t.length; m++) {
      let g = t[m];
      if (typeof g == "string" && (g = g.trim(), $g(g))) {
        const b = GT(g, n.current);
        b !== void 0 && (t[m] = b), m === t.length - 1 && (this.finalKeyframe = g);
      }
    }
    if (this.resolveNoneKeyframes(), !YT.has(o) || t.length !== 2)
      return;
    const [a, l] = t, c = Pw(a), f = Pw(l), d = ww(a), h = ww(l);
    if (d !== h && Mo[o]) {
      this.needsMeasurement = !0;
      return;
    }
    if (c !== f)
      if (Dw(c) && Dw(f))
        for (let m = 0; m < t.length; m++) {
          const g = t[m];
          typeof g == "string" && (t[m] = parseFloat(g));
        }
      else Mo[o] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, o = [];
    for (let a = 0; a < t.length; a++)
      (t[a] === null || Q5(t[a])) && o.push(a);
    o.length && aV(t, o, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: o } = this;
    if (!t || !t.current)
      return;
    o === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Mo[o](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const a = n[n.length - 1];
    a !== void 0 && t.getValue(o, a).jump(a, !1);
  }
  measureEndState() {
    const { element: t, name: n, unresolvedKeyframes: o } = this;
    if (!t || !t.current)
      return;
    const a = t.getValue(n);
    a && a.jump(this.measuredOrigin, !1);
    const l = o.length - 1, c = o[l];
    o[l] = Mo[n](t.measureViewportBox(), window.getComputedStyle(t.current)), c !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = c), this.removedTransforms?.length && this.removedTransforms.forEach(([f, d]) => {
      t.getValue(f).set(d);
    }), this.resolveNoneKeyframes();
  }
}
function lV(e, t, n) {
  if (e == null)
    return [];
  if (e instanceof EventTarget)
    return [e];
  if (typeof e == "string") {
    let o = document;
    const a = n?.[e] ?? o.querySelectorAll(e);
    return a ? Array.from(a) : [];
  }
  return Array.from(e).filter((o) => o != null);
}
const tC = (e, t) => t && typeof e == "number" ? t.transform(e) : e;
function qm(e) {
  return hT(e) && "offsetHeight" in e;
}
const { schedule: nv } = /* @__PURE__ */ CT(queueMicrotask, !1), Xn = {
  x: !1,
  y: !1
};
function nC() {
  return Xn.x || Xn.y;
}
function cV(e) {
  return e === "x" || e === "y" ? Xn[e] ? null : (Xn[e] = !0, () => {
    Xn[e] = !1;
  }) : Xn.x || Xn.y ? null : (Xn.x = Xn.y = !0, () => {
    Xn.x = Xn.y = !1;
  });
}
function rC(e, t) {
  const n = lV(e), o = new AbortController(), a = {
    passive: !0,
    ...t,
    signal: o.signal
  };
  return [n, a, () => o.abort()];
}
function Iw(e) {
  return !(e.pointerType === "touch" || nC());
}
function uV(e, t, n = {}) {
  const [o, a, l] = rC(e, n), c = (f) => {
    if (!Iw(f))
      return;
    const { target: d } = f, h = t(d, f);
    if (typeof h != "function" || !d)
      return;
    const m = (g) => {
      Iw(g) && (h(g), d.removeEventListener("pointerleave", m));
    };
    d.addEventListener("pointerleave", m, a);
  };
  return o.forEach((f) => {
    f.addEventListener("pointerenter", c, a);
  }), l;
}
const oC = (e, t) => t ? e === t ? !0 : oC(e, t.parentElement) : !1, rv = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, fV = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function dV(e) {
  return fV.has(e.tagName) || e.isContentEditable === !0;
}
const hV = /* @__PURE__ */ new Set(["INPUT", "SELECT", "TEXTAREA"]);
function pV(e) {
  return hV.has(e.tagName) || e.isContentEditable === !0;
}
const Nu = /* @__PURE__ */ new WeakSet();
function Vw(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function Gp(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const mV = (e, t) => {
  const n = e.currentTarget;
  if (!n)
    return;
  const o = Vw(() => {
    if (Nu.has(n))
      return;
    Gp(n, "down");
    const a = Vw(() => {
      Gp(n, "up");
    }), l = () => Gp(n, "cancel");
    n.addEventListener("keyup", a, t), n.addEventListener("blur", l, t);
  });
  n.addEventListener("keydown", o, t), n.addEventListener("blur", () => n.removeEventListener("keydown", o), t);
};
function Uw(e) {
  return rv(e) && !nC();
}
function gV(e, t, n = {}) {
  const [o, a, l] = rC(e, n), c = (f) => {
    const d = f.currentTarget;
    if (!Uw(f))
      return;
    Nu.add(d);
    const h = t(d, f), m = (x, _) => {
      window.removeEventListener("pointerup", g), window.removeEventListener("pointercancel", b), Nu.has(d) && Nu.delete(d), Uw(x) && typeof h == "function" && h(x, { success: _ });
    }, g = (x) => {
      m(x, d === window || d === document || n.useGlobalTarget || oC(d, x.target));
    }, b = (x) => {
      m(x, !1);
    };
    window.addEventListener("pointerup", g, a), window.addEventListener("pointercancel", b, a);
  };
  return o.forEach((f) => {
    (n.useGlobalTarget ? window : f).addEventListener("pointerdown", c, a), qm(f) && (f.addEventListener("focus", (h) => mV(h, a)), !dV(f) && !f.hasAttribute("tabindex") && (f.tabIndex = 0));
  }), l;
}
function iC(e) {
  return hT(e) && "ownerSVGElement" in e;
}
function vV(e) {
  return iC(e) && e.tagName === "svg";
}
const yV = [...JT, Ct, Oo], bV = (e) => yV.find(KT(e)), Bw = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Ea = () => ({
  x: Bw(),
  y: Bw()
}), $w = () => ({ min: 0, max: 0 }), zt = () => ({
  x: $w(),
  y: $w()
}), Xm = { current: null }, aC = { current: !1 }, xV = typeof window < "u";
function SV() {
  if (aC.current = !0, !!xV)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => Xm.current = e.matches;
      e.addEventListener("change", t), t();
    } else
      Xm.current = !1;
}
const wV = /* @__PURE__ */ new WeakMap();
function Of(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function xl(e) {
  return typeof e == "string" || Array.isArray(e);
}
const ov = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], iv = ["initial", ...ov];
function jf(e) {
  return Of(e.animate) || iv.some((t) => xl(e[t]));
}
function sC(e) {
  return !!(jf(e) || e.variants);
}
function EV(e, t, n) {
  for (const o in t) {
    const a = t[o], l = n[o];
    if (Ft(a))
      e.addValue(o, a);
    else if (Ft(l))
      e.addValue(o, ka(a, { owner: e }));
    else if (l !== a)
      if (e.hasValue(o)) {
        const c = e.getValue(o);
        c.liveStyle === !0 ? c.jump(a) : c.hasAnimated || c.set(a);
      } else {
        const c = e.getStaticValue(o);
        e.addValue(o, ka(c !== void 0 ? c : a, { owner: e }));
      }
  }
  for (const o in n)
    t[o] === void 0 && e.removeValue(o);
  return t;
}
const Hw = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
let nf = {};
function lC(e) {
  nf = e;
}
function _V() {
  return nf;
}
class TV {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, o) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: o, reducedMotionConfig: a, skipAnimations: l, blockInitialAnimation: c, visualState: f }, d = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.shouldSkipAnimations = !1, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = Wg, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const x = Xt.now();
      this.renderScheduledAt < x && (this.renderScheduledAt = x, et.render(this.render, !1, !0));
    };
    const { latestValues: h, renderState: m } = f;
    this.latestValues = h, this.baseTarget = { ...h }, this.initialValues = n.initial ? { ...h } : {}, this.renderState = m, this.parent = t, this.props = n, this.presenceContext = o, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = a, this.skipAnimationsConfig = l, this.options = d, this.blockInitialAnimation = !!c, this.isControllingVariants = jf(n), this.isVariantNode = sC(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: g, ...b } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const x in b) {
      const _ = b[x];
      h[x] !== void 0 && Ft(_) && _.set(h[x]);
    }
  }
  mount(t) {
    this.current = t, wV.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, o) => this.bindToMotionValue(o, n)), this.reducedMotionConfig === "never" ? this.shouldReduceMotion = !1 : this.reducedMotionConfig === "always" ? this.shouldReduceMotion = !0 : (aC.current || SV(), this.shouldReduceMotion = Xm.current), this.shouldSkipAnimations = this.skipAnimationsConfig ?? !1, this.parent?.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), No(this.notifyUpdate), No(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features) {
      const n = this.features[t];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  addChild(t) {
    this.children.add(t), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(t);
  }
  removeChild(t) {
    this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t);
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const o = Ha.has(t);
    o && this.onBindTransform && this.onBindTransform();
    const a = n.on("change", (c) => {
      this.latestValues[t] = c, this.props.onUpdate && et.preRender(this.notifyUpdate), o && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let l;
    typeof window < "u" && window.MotionCheckAppearSync && (l = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      a(), l && l(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in nf) {
      const n = nf[t];
      if (!n)
        continue;
      const { isEnabled: o, Feature: a } = n;
      if (!this.features[t] && a && o(this.props) && (this.features[t] = new a(this)), this.features[t]) {
        const l = this.features[t];
        l.isMounted ? l.update() : (l.mount(), l.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : zt();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let o = 0; o < Hw.length; o++) {
      const a = Hw[o];
      this.propEventSubscriptions[a] && (this.propEventSubscriptions[a](), delete this.propEventSubscriptions[a]);
      const l = "on" + a, c = t[l];
      c && (this.propEventSubscriptions[a] = this.on(a, c));
    }
    this.prevMotionValues = EV(this, this.scrapeMotionValuesFromProps(t, this.prevProps || {}, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const o = this.values.get(t);
    n !== o && (o && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let o = this.values.get(t);
    return o === void 0 && n !== void 0 && (o = ka(n === null ? void 0 : n, { owner: this }), this.addValue(t, o)), o;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    let o = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return o != null && (typeof o == "string" && (dT(o) || pT(o)) ? o = parseFloat(o) : !bV(o) && Oo.test(n) && (o = eC(t, n)), this.setBaseTarget(t, Ft(o) ? o.get() : o)), Ft(o) ? o.get() : o;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    const { initial: n } = this.props;
    let o;
    if (typeof n == "string" || typeof n == "object") {
      const l = Qg(this.props, n, this.presenceContext?.custom);
      l && (o = l[t]);
    }
    if (n && o !== void 0)
      return o;
    const a = this.getBaseTargetFromProps(this.props, t);
    return a !== void 0 && !Ft(a) ? a : this.initialValues[t] !== void 0 && o === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new Vg()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
  scheduleRenderMicrotask() {
    nv.render(this.render);
  }
}
class cC extends TV {
  constructor() {
    super(...arguments), this.KeyframeResolver = sV;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    const o = t.style;
    return o ? o[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: o }) {
    delete n[t], delete o[t];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    Ft(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
class Vo {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
function uC({ top: e, left: t, right: n, bottom: o }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: o }
  };
}
function CV({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function AV(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), o = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: o.y,
    right: o.x
  };
}
function Yp(e) {
  return e === void 0 || e === 1;
}
function Wm({ scale: e, scaleX: t, scaleY: n }) {
  return !Yp(e) || !Yp(t) || !Yp(n);
}
function ui(e) {
  return Wm(e) || fC(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function fC(e) {
  return Zw(e.x) || Zw(e.y);
}
function Zw(e) {
  return e && e !== "0%";
}
function rf(e, t, n) {
  const o = e - n, a = t * o;
  return n + a;
}
function Fw(e, t, n, o, a) {
  return a !== void 0 && (e = rf(e, a, o)), rf(e, n, o) + t;
}
function Km(e, t = 0, n = 1, o, a) {
  e.min = Fw(e.min, t, n, o, a), e.max = Fw(e.max, t, n, o, a);
}
function dC(e, { x: t, y: n }) {
  Km(e.x, t.translate, t.scale, t.originPoint), Km(e.y, n.translate, n.scale, n.originPoint);
}
const Gw = 0.999999999999, Yw = 1.0000000000001;
function RV(e, t, n, o = !1) {
  const a = n.length;
  if (!a)
    return;
  t.x = t.y = 1;
  let l, c;
  for (let f = 0; f < a; f++) {
    l = n[f], c = l.projectionDelta;
    const { visualElement: d } = l.options;
    d && d.props.style && d.props.style.display === "contents" || (o && l.options.layoutScroll && l.scroll && l !== l.root && Ta(e, {
      x: -l.scroll.offset.x,
      y: -l.scroll.offset.y
    }), c && (t.x *= c.x.scale, t.y *= c.y.scale, dC(e, c)), o && ui(l.latestValues) && Ta(e, l.latestValues));
  }
  t.x < Yw && t.x > Gw && (t.x = 1), t.y < Yw && t.y > Gw && (t.y = 1);
}
function _a(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function qw(e, t, n, o, a = 0.5) {
  const l = ft(e.min, e.max, a);
  Km(e, t, n, l, o);
}
function Ta(e, t) {
  qw(e.x, t.x, t.scaleX, t.scale, t.originX), qw(e.y, t.y, t.scaleY, t.scale, t.originY);
}
function hC(e, t) {
  return uC(AV(e.getBoundingClientRect(), t));
}
function MV(e, t, n) {
  const o = hC(e, n), { scroll: a } = t;
  return a && (_a(o.x, a.offset.x), _a(o.y, a.offset.y)), o;
}
const zV = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, DV = $a.length;
function NV(e, t, n) {
  let o = "", a = !0;
  for (let l = 0; l < DV; l++) {
    const c = $a[l], f = e[c];
    if (f === void 0)
      continue;
    let d = !0;
    if (typeof f == "number")
      d = f === (c.startsWith("scale") ? 1 : 0);
    else {
      const h = parseFloat(f);
      d = c.startsWith("scale") ? h === 1 : h === 0;
    }
    if (!d || n) {
      const h = tC(f, tv[c]);
      if (!d) {
        a = !1;
        const m = zV[c] || c;
        o += `${m}(${h}) `;
      }
      n && (t[c] = h);
    }
  }
  return o = o.trim(), n ? o = n(t, a ? "" : o) : a && (o = "none"), o;
}
function av(e, t, n) {
  const { style: o, vars: a, transformOrigin: l } = e;
  let c = !1, f = !1;
  for (const d in t) {
    const h = t[d];
    if (Ha.has(d)) {
      c = !0;
      continue;
    } else if (RT(d)) {
      a[d] = h;
      continue;
    } else {
      const m = tC(h, tv[d]);
      d.startsWith("origin") ? (f = !0, l[d] = m) : o[d] = m;
    }
  }
  if (t.transform || (c || n ? o.transform = NV(t, e.transform, n) : o.transform && (o.transform = "none")), f) {
    const { originX: d = "50%", originY: h = "50%", originZ: m = 0 } = l;
    o.transformOrigin = `${d} ${h} ${m}`;
  }
}
function pC(e, { style: t, vars: n }, o, a) {
  const l = e.style;
  let c;
  for (c in t)
    l[c] = t[c];
  a?.applyProjectionStyles(l, o);
  for (c in n)
    l.setProperty(c, n[c]);
}
function Xw(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const Ys = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (ye.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = Xw(e, t.target.x), o = Xw(e, t.target.y);
    return `${n}% ${o}%`;
  }
}, OV = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const o = e, a = Oo.parse(e);
    if (a.length > 5)
      return o;
    const l = Oo.createTransformer(e), c = typeof a[0] != "number" ? 1 : 0, f = n.x.scale * t.x, d = n.y.scale * t.y;
    a[0 + c] /= f, a[1 + c] /= d;
    const h = ft(f, d, 0.5);
    return typeof a[2 + c] == "number" && (a[2 + c] /= h), typeof a[3 + c] == "number" && (a[3 + c] /= h), l(a);
  }
}, Jm = {
  borderRadius: {
    ...Ys,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Ys,
  borderTopRightRadius: Ys,
  borderBottomLeftRadius: Ys,
  borderBottomRightRadius: Ys,
  boxShadow: OV
};
function mC(e, { layout: t, layoutId: n }) {
  return Ha.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Jm[e] || e === "opacity");
}
function sv(e, t, n) {
  const o = e.style, a = t?.style, l = {};
  if (!o)
    return l;
  for (const c in o)
    (Ft(o[c]) || a && Ft(a[c]) || mC(c, e) || n?.getValue(c)?.liveStyle !== void 0) && (l[c] = o[c]);
  return l;
}
function jV(e) {
  return window.getComputedStyle(e);
}
class kV extends cC {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = pC;
  }
  readValueFromInstance(t, n) {
    if (Ha.has(n))
      return this.projection?.isProjecting ? Im(n) : l5(t, n);
    {
      const o = jV(t), a = (RT(n) ? o.getPropertyValue(n) : o[n]) || 0;
      return typeof a == "string" ? a.trim() : a;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return hC(t, n);
  }
  build(t, n, o) {
    av(t, n, o.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, o) {
    return sv(t, n, o);
  }
}
const PV = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, LV = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function IV(e, t, n = 1, o = 0, a = !0) {
  e.pathLength = 1;
  const l = a ? PV : LV;
  e[l.offset] = `${-o}`, e[l.array] = `${t} ${n}`;
}
const VV = [
  "offsetDistance",
  "offsetPath",
  "offsetRotate",
  "offsetAnchor"
];
function gC(e, {
  attrX: t,
  attrY: n,
  attrScale: o,
  pathLength: a,
  pathSpacing: l = 1,
  pathOffset: c = 0,
  // This is object creation, which we try to avoid per-frame.
  ...f
}, d, h, m) {
  if (av(e, f, h), d) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: g, style: b } = e;
  g.transform && (b.transform = g.transform, delete g.transform), (b.transform || g.transformOrigin) && (b.transformOrigin = g.transformOrigin ?? "50% 50%", delete g.transformOrigin), b.transform && (b.transformBox = m?.transformBox ?? "fill-box", delete g.transformBox);
  for (const x of VV)
    g[x] !== void 0 && (b[x] = g[x], delete g[x]);
  t !== void 0 && (g.x = t), n !== void 0 && (g.y = n), o !== void 0 && (g.scale = o), a !== void 0 && IV(g, a, l, c, !1);
}
const vC = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]), yC = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function UV(e, t, n, o) {
  pC(e, t, void 0, o);
  for (const a in t.attrs)
    e.setAttribute(vC.has(a) ? a : ev(a), t.attrs[a]);
}
function bC(e, t, n) {
  const o = sv(e, t, n);
  for (const a in e)
    if (Ft(e[a]) || Ft(t[a])) {
      const l = $a.indexOf(a) !== -1 ? "attr" + a.charAt(0).toUpperCase() + a.substring(1) : a;
      o[l] = e[a];
    }
  return o;
}
class BV extends cC {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = zt;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (Ha.has(n)) {
      const o = QT(n);
      return o && o.default || 0;
    }
    return n = vC.has(n) ? n : ev(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, o) {
    return bC(t, n, o);
  }
  build(t, n, o) {
    gC(t, n, this.isSVGTag, o.transformTemplate, o.style);
  }
  renderInstance(t, n, o, a) {
    UV(t, n, o, a);
  }
  mount(t) {
    this.isSVGTag = yC(t.tagName), super.mount(t);
  }
}
const $V = iv.length;
function xC(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const n = e.parent ? xC(e.parent) || {} : {};
    return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
  }
  const t = {};
  for (let n = 0; n < $V; n++) {
    const o = iv[n], a = e.props[o];
    (xl(a) || a === !1) && (t[o] = a);
  }
  return t;
}
function SC(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let o = 0; o < n; o++)
    if (t[o] !== e[o])
      return !1;
  return !0;
}
const HV = [...ov].reverse(), ZV = ov.length;
function FV(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: o }) => K5(e, n, o)));
}
function GV(e) {
  let t = FV(e), n = Ww(), o = !0;
  const a = (d) => (h, m) => {
    const g = Ma(e, m, d === "exit" ? e.presenceContext?.custom : void 0);
    if (g) {
      const { transition: b, transitionEnd: x, ..._ } = g;
      h = { ...h, ..._, ...x };
    }
    return h;
  };
  function l(d) {
    t = d(e);
  }
  function c(d) {
    const { props: h } = e, m = xC(e.parent) || {}, g = [], b = /* @__PURE__ */ new Set();
    let x = {}, _ = 1 / 0;
    for (let T = 0; T < ZV; T++) {
      const C = HV[T], z = n[C], A = h[C] !== void 0 ? h[C] : m[C], R = xl(A), O = C === d ? z.isActive : null;
      O === !1 && (_ = T);
      let L = A === m[C] && A !== h[C] && R;
      if (L && o && e.manuallyAnimateOnMount && (L = !1), z.protectedKeys = { ...x }, // If it isn't active and hasn't *just* been set as inactive
      !z.isActive && O === null || // If we didn't and don't have any defined prop for this animation type
      !A && !z.prevProp || // Or if the prop doesn't define an animation
      Of(A) || typeof A == "boolean")
        continue;
      const M = YV(z.prevProp, A);
      let N = M || // If we're making this variant active, we want to always make it active
      C === d && z.isActive && !L && R || // If we removed a higher-priority variant (i is in reverse order)
      T > _ && R, j = !1;
      const Y = Array.isArray(A) ? A : [A];
      let ne = Y.reduce(a(C), {});
      O === !1 && (ne = {});
      const { prevResolvedValues: J = {} } = z, he = {
        ...J,
        ...ne
      }, fe = (G) => {
        N = !0, b.has(G) && (j = !0, b.delete(G)), z.needsAnimating[G] = !0;
        const B = e.getValue(G);
        B && (B.liveStyle = !1);
      };
      for (const G in he) {
        const B = ne[G], te = J[G];
        if (x.hasOwnProperty(G))
          continue;
        let ae = !1;
        Zm(B) && Zm(te) ? ae = !SC(B, te) : ae = B !== te, ae ? B != null ? fe(G) : b.add(G) : B !== void 0 && b.has(G) ? fe(G) : z.protectedKeys[G] = !0;
      }
      z.prevProp = A, z.prevResolvedValues = ne, z.isActive && (x = { ...x, ...ne }), o && e.blockInitialAnimation && (N = !1);
      const de = L && M;
      N && (!de || j) && g.push(...Y.map((G) => {
        const B = { type: C };
        if (typeof G == "string" && o && !de && e.manuallyAnimateOnMount && e.parent) {
          const { parent: te } = e, ae = Ma(te, G);
          if (te.enteringChildren && ae) {
            const { delayChildren: k } = ae.transition || {};
            B.delay = FT(te.enteringChildren, e, k);
          }
        }
        return {
          animation: G,
          options: B
        };
      }));
    }
    if (b.size) {
      const T = {};
      if (typeof h.initial != "boolean") {
        const C = Ma(e, Array.isArray(h.initial) ? h.initial[0] : h.initial);
        C && C.transition && (T.transition = C.transition);
      }
      b.forEach((C) => {
        const z = e.getBaseTarget(C), A = e.getValue(C);
        A && (A.liveStyle = !0), T[C] = z ?? null;
      }), g.push({ animation: T });
    }
    let E = !!g.length;
    return o && (h.initial === !1 || h.initial === h.animate) && !e.manuallyAnimateOnMount && (E = !1), o = !1, E ? t(g) : Promise.resolve();
  }
  function f(d, h) {
    if (n[d].isActive === h)
      return Promise.resolve();
    e.variantChildren?.forEach((g) => g.animationState?.setActive(d, h)), n[d].isActive = h;
    const m = c(d);
    for (const g in n)
      n[g].protectedKeys = {};
    return m;
  }
  return {
    animateChanges: c,
    setActive: f,
    setAnimateFunction: l,
    getState: () => n,
    reset: () => {
      n = Ww();
    }
  };
}
function YV(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !SC(t, e) : !1;
}
function ai(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function Ww() {
  return {
    animate: ai(!0),
    whileInView: ai(),
    whileHover: ai(),
    whileTap: ai(),
    whileDrag: ai(),
    whileFocus: ai(),
    exit: ai()
  };
}
function Kw(e, t) {
  e.min = t.min, e.max = t.max;
}
function qn(e, t) {
  Kw(e.x, t.x), Kw(e.y, t.y);
}
function Jw(e, t) {
  e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin;
}
const wC = 1e-4, qV = 1 - wC, XV = 1 + wC, EC = 0.01, WV = 0 - EC, KV = 0 + EC;
function Wt(e) {
  return e.max - e.min;
}
function JV(e, t, n) {
  return Math.abs(e - t) <= n;
}
function Qw(e, t, n, o = 0.5) {
  e.origin = o, e.originPoint = ft(t.min, t.max, e.origin), e.scale = Wt(n) / Wt(t), e.translate = ft(n.min, n.max, e.origin) - e.originPoint, (e.scale >= qV && e.scale <= XV || isNaN(e.scale)) && (e.scale = 1), (e.translate >= WV && e.translate <= KV || isNaN(e.translate)) && (e.translate = 0);
}
function ul(e, t, n, o) {
  Qw(e.x, t.x, n.x, o ? o.originX : void 0), Qw(e.y, t.y, n.y, o ? o.originY : void 0);
}
function e1(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + Wt(t);
}
function QV(e, t, n) {
  e1(e.x, t.x, n.x), e1(e.y, t.y, n.y);
}
function t1(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + Wt(t);
}
function of(e, t, n) {
  t1(e.x, t.x, n.x), t1(e.y, t.y, n.y);
}
function n1(e, t, n, o, a) {
  return e -= t, e = rf(e, 1 / n, o), a !== void 0 && (e = rf(e, 1 / a, o)), e;
}
function e6(e, t = 0, n = 1, o = 0.5, a, l = e, c = e) {
  if (dr.test(t) && (t = parseFloat(t), t = ft(c.min, c.max, t / 100) - c.min), typeof t != "number")
    return;
  let f = ft(l.min, l.max, o);
  e === l && (f -= t), e.min = n1(e.min, t, n, f, a), e.max = n1(e.max, t, n, f, a);
}
function r1(e, t, [n, o, a], l, c) {
  e6(e, t[n], t[o], t[a], t.scale, l, c);
}
const t6 = ["x", "scaleX", "originX"], n6 = ["y", "scaleY", "originY"];
function o1(e, t, n, o) {
  r1(e.x, t, t6, n ? n.x : void 0, o ? o.x : void 0), r1(e.y, t, n6, n ? n.y : void 0, o ? o.y : void 0);
}
function i1(e) {
  return e.translate === 0 && e.scale === 1;
}
function _C(e) {
  return i1(e.x) && i1(e.y);
}
function a1(e, t) {
  return e.min === t.min && e.max === t.max;
}
function r6(e, t) {
  return a1(e.x, t.x) && a1(e.y, t.y);
}
function s1(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function TC(e, t) {
  return s1(e.x, t.x) && s1(e.y, t.y);
}
function l1(e) {
  return Wt(e.x) / Wt(e.y);
}
function c1(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
function Pn(e) {
  return [e("x"), e("y")];
}
function o6(e, t, n) {
  let o = "";
  const a = e.x.translate / t.x, l = e.y.translate / t.y, c = n?.z || 0;
  if ((a || l || c) && (o = `translate3d(${a}px, ${l}px, ${c}px) `), (t.x !== 1 || t.y !== 1) && (o += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { transformPerspective: h, rotate: m, rotateX: g, rotateY: b, skewX: x, skewY: _ } = n;
    h && (o = `perspective(${h}px) ${o}`), m && (o += `rotate(${m}deg) `), g && (o += `rotateX(${g}deg) `), b && (o += `rotateY(${b}deg) `), x && (o += `skewX(${x}deg) `), _ && (o += `skewY(${_}deg) `);
  }
  const f = e.x.scale * t.x, d = e.y.scale * t.y;
  return (f !== 1 || d !== 1) && (o += `scale(${f}, ${d})`), o || "none";
}
const CC = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], i6 = CC.length, u1 = (e) => typeof e == "string" ? parseFloat(e) : e, f1 = (e) => typeof e == "number" || ye.test(e);
function a6(e, t, n, o, a, l) {
  a ? (e.opacity = ft(0, n.opacity ?? 1, s6(o)), e.opacityExit = ft(t.opacity ?? 1, 0, l6(o))) : l && (e.opacity = ft(t.opacity ?? 1, n.opacity ?? 1, o));
  for (let c = 0; c < i6; c++) {
    const f = `border${CC[c]}Radius`;
    let d = d1(t, f), h = d1(n, f);
    if (d === void 0 && h === void 0)
      continue;
    d || (d = 0), h || (h = 0), d === 0 || h === 0 || f1(d) === f1(h) ? (e[f] = Math.max(ft(u1(d), u1(h), o), 0), (dr.test(h) || dr.test(d)) && (e[f] += "%")) : e[f] = h;
  }
  (t.rotate || n.rotate) && (e.rotate = ft(t.rotate || 0, n.rotate || 0, o));
}
function d1(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const s6 = /* @__PURE__ */ AC(0, 0.5, wT), l6 = /* @__PURE__ */ AC(0.5, 0.95, In);
function AC(e, t, n) {
  return (o) => o < e ? 0 : o > t ? 1 : n(/* @__PURE__ */ vl(e, t, o));
}
function c6(e, t, n) {
  const o = Ft(e) ? e : ka(e);
  return o.start(Jg("", o, t, n)), o.animation;
}
function Sl(e, t, n, o = { passive: !0 }) {
  return e.addEventListener(t, n, o), () => e.removeEventListener(t, n);
}
const u6 = (e, t) => e.depth - t.depth;
class f6 {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    kg(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    Pg(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(u6), this.isDirty = !1, this.children.forEach(t);
  }
}
function d6(e, t) {
  const n = Xt.now(), o = ({ timestamp: a }) => {
    const l = a - n;
    l >= t && (No(o), e(l - t));
  };
  return et.setup(o, !0), () => No(o);
}
function Ou(e) {
  return Ft(e) ? e.get() : e;
}
class h6 {
  constructor() {
    this.members = [];
  }
  add(t) {
    kg(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (Pg(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((a) => t === a);
    if (n === 0)
      return !1;
    let o;
    for (let a = n; a >= 0; a--) {
      const l = this.members[a];
      if (l.isPresent !== !1) {
        o = l;
        break;
      }
    }
    return o ? (this.promote(o), !0) : !1;
  }
  promote(t, n) {
    const o = this.lead;
    if (t !== o && (this.prevLead = o, this.lead = t, t.show(), o)) {
      o.instance && o.scheduleRender(), t.scheduleRender();
      const a = o.options.layoutDependency, l = t.options.layoutDependency;
      a !== void 0 && l !== void 0 && a === l || (t.resumeFrom = o, n && (t.resumeFrom.preserveOpacity = !0), o.snapshot && (t.snapshot = o.snapshot, t.snapshot.latestValues = o.animationValues || o.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0));
      const { crossfade: f } = t.options;
      f === !1 && o.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: o } = t;
      n.onExitComplete && n.onExitComplete(), o && o.options.onExitComplete && o.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
const ju = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
}, qp = ["", "X", "Y", "Z"], p6 = 1e3;
let m6 = 0;
function Xp(e, t, n, o) {
  const { latestValues: a } = t;
  a[e] && (n[e] = a[e], t.setStaticValue(e, 0), o && (o[e] = 0));
}
function RC(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: t } = e.options;
  if (!t)
    return;
  const n = XT(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: a, layoutId: l } = e.options;
    window.MotionCancelOptimisedAnimation(n, "transform", et, !(a || l));
  }
  const { parent: o } = e;
  o && !o.hasCheckedOptimisedAppear && RC(o);
}
function MC({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: o, resetTransform: a }) {
  return class {
    constructor(c = {}, f = t?.()) {
      this.id = m6++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(y6), this.nodes.forEach(w6), this.nodes.forEach(E6), this.nodes.forEach(b6);
      }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = c, this.root = f ? f.root || f : this, this.path = f ? [...f.path, f] : [], this.parent = f, this.depth = f ? f.depth + 1 : 0;
      for (let d = 0; d < this.path.length; d++)
        this.path[d].shouldResetTransform = !0;
      this.root === this && (this.nodes = new f6());
    }
    addEventListener(c, f) {
      return this.eventHandlers.has(c) || this.eventHandlers.set(c, new Vg()), this.eventHandlers.get(c).add(f);
    }
    notifyListeners(c, ...f) {
      const d = this.eventHandlers.get(c);
      d && d.notify(...f);
    }
    hasListeners(c) {
      return this.eventHandlers.has(c);
    }
    /**
     * Lifecycles
     */
    mount(c) {
      if (this.instance)
        return;
      this.isSVG = iC(c) && !vV(c), this.instance = c;
      const { layoutId: f, layout: d, visualElement: h } = this.options;
      if (h && !h.current && h.mount(c), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (d || f) && (this.isLayoutDirty = !0), e) {
        let m, g = 0;
        const b = () => this.root.updateBlockedByResize = !1;
        et.read(() => {
          g = window.innerWidth;
        }), e(c, () => {
          const x = window.innerWidth;
          x !== g && (g = x, this.root.updateBlockedByResize = !0, m && m(), m = d6(b, 250), ju.hasAnimatedSinceResize && (ju.hasAnimatedSinceResize = !1, this.nodes.forEach(m1)));
        });
      }
      f && this.root.registerSharedNode(f, this), this.options.animate !== !1 && h && (f || d) && this.addEventListener("didUpdate", ({ delta: m, hasLayoutChanged: g, hasRelativeLayoutChanged: b, layout: x }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const _ = this.options.transition || h.getDefaultTransition() || R6, { onLayoutAnimationStart: E, onLayoutAnimationComplete: T } = h.getProps(), C = !this.targetLayout || !TC(this.targetLayout, x), z = !g && b;
        if (this.options.layoutRoot || this.resumeFrom || z || g && (C || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const A = {
            ...Kg(_, "layout"),
            onPlay: E,
            onComplete: T
          };
          (h.shouldReduceMotion || this.options.layoutRoot) && (A.delay = 0, A.type = !1), this.startAnimation(A), this.setAnimationOrigin(m, z);
        } else
          g || m1(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = x;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const c = this.getStack();
      c && c.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), No(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(_6), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: c } = this.options;
      return c && c.getProps().transformTemplate;
    }
    willUpdate(c = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && RC(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let m = 0; m < this.path.length; m++) {
        const g = this.path[m];
        g.shouldResetTransform = !0, g.updateScroll("snapshot"), g.options.layoutRoot && g.willUpdate(!1);
      }
      const { layoutId: f, layout: d } = this.options;
      if (f === void 0 && !d)
        return;
      const h = this.getTransformTemplate();
      this.prevTransformTemplateValue = h ? h(this.latestValues, "") : void 0, this.updateSnapshot(), c && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(h1);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(p1);
        return;
      }
      this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(S6), this.nodes.forEach(g6), this.nodes.forEach(v6)) : this.nodes.forEach(p1), this.clearAllSnapshots();
      const f = Xt.now();
      Ut.delta = gr(0, 1e3 / 60, f - Ut.timestamp), Ut.timestamp = f, Ut.isProcessing = !0, Up.update.process(Ut), Up.preRender.process(Ut), Up.render.process(Ut), Ut.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, nv.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(x6), this.sharedNodes.forEach(T6);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, et.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      et.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !Wt(this.snapshot.measuredBox.x) && !Wt(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let d = 0; d < this.path.length; d++)
          this.path[d].updateScroll();
      const c = this.layout;
      this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = zt(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: f } = this.options;
      f && f.notify("LayoutMeasure", this.layout.layoutBox, c ? c.layoutBox : void 0);
    }
    updateScroll(c = "measure") {
      let f = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === c && (f = !1), f && this.instance) {
        const d = o(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: c,
          isRoot: d,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : d
        };
      }
    }
    resetTransform() {
      if (!a)
        return;
      const c = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, f = this.projectionDelta && !_C(this.projectionDelta), d = this.getTransformTemplate(), h = d ? d(this.latestValues, "") : void 0, m = h !== this.prevTransformTemplateValue;
      c && this.instance && (f || ui(this.latestValues) || m) && (a(this.instance, h), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(c = !0) {
      const f = this.measurePageBox();
      let d = this.removeElementScroll(f);
      return c && (d = this.removeTransform(d)), M6(d), {
        animationId: this.root.animationId,
        measuredBox: f,
        layoutBox: d,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: c } = this.options;
      if (!c)
        return zt();
      const f = c.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(z6))) {
        const { scroll: h } = this.root;
        h && (_a(f.x, h.offset.x), _a(f.y, h.offset.y));
      }
      return f;
    }
    removeElementScroll(c) {
      const f = zt();
      if (qn(f, c), this.scroll?.wasRoot)
        return f;
      for (let d = 0; d < this.path.length; d++) {
        const h = this.path[d], { scroll: m, options: g } = h;
        h !== this.root && m && g.layoutScroll && (m.wasRoot && qn(f, c), _a(f.x, m.offset.x), _a(f.y, m.offset.y));
      }
      return f;
    }
    applyTransform(c, f = !1) {
      const d = zt();
      qn(d, c);
      for (let h = 0; h < this.path.length; h++) {
        const m = this.path[h];
        !f && m.options.layoutScroll && m.scroll && m !== m.root && Ta(d, {
          x: -m.scroll.offset.x,
          y: -m.scroll.offset.y
        }), ui(m.latestValues) && Ta(d, m.latestValues);
      }
      return ui(this.latestValues) && Ta(d, this.latestValues), d;
    }
    removeTransform(c) {
      const f = zt();
      qn(f, c);
      for (let d = 0; d < this.path.length; d++) {
        const h = this.path[d];
        if (!h.instance || !ui(h.latestValues))
          continue;
        Wm(h.latestValues) && h.updateSnapshot();
        const m = zt(), g = h.measurePageBox();
        qn(m, g), o1(f, h.latestValues, h.snapshot ? h.snapshot.layoutBox : void 0, m);
      }
      return ui(this.latestValues) && o1(f, this.latestValues), f;
    }
    setTargetDelta(c) {
      this.targetDelta = c, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(c) {
      this.options = {
        ...this.options,
        ...c,
        crossfade: c.crossfade !== void 0 ? c.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ut.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(c = !1) {
      const f = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = f.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = f.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = f.isSharedProjectionDirty);
      const d = !!this.resumingFrom || this !== f;
      if (!(c || d && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: m, layoutId: g } = this.options;
      if (!this.layout || !(m || g))
        return;
      this.resolvedRelativeTargetAt = Ut.timestamp;
      const b = this.getClosestProjectingParent();
      b && this.linkedParentVersion !== b.layoutVersion && !b.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (b && b.layout ? this.createRelativeTarget(b, this.layout.layoutBox, b.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = zt(), this.targetWithTransforms = zt()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), QV(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : qn(this.target, this.layout.layoutBox), dC(this.target, this.targetDelta)) : qn(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, b && !!b.resumingFrom == !!this.resumingFrom && !b.options.layoutScroll && b.target && this.animationProgress !== 1 ? this.createRelativeTarget(b, this.target, b.target) : this.relativeParent = this.relativeTarget = void 0));
    }
    getClosestProjectingParent() {
      if (!(!this.parent || Wm(this.parent.latestValues) || fC(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    createRelativeTarget(c, f, d) {
      this.relativeParent = c, this.linkedParentVersion = c.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = zt(), this.relativeTargetOrigin = zt(), of(this.relativeTargetOrigin, f, d), qn(this.relativeTarget, this.relativeTargetOrigin);
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      const c = this.getLead(), f = !!this.resumingFrom || this !== c;
      let d = !0;
      if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (d = !1), f && (this.isSharedProjectionDirty || this.isTransformDirty) && (d = !1), this.resolvedRelativeTargetAt === Ut.timestamp && (d = !1), d)
        return;
      const { layout: h, layoutId: m } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(h || m))
        return;
      qn(this.layoutCorrected, this.layout.layoutBox);
      const g = this.treeScale.x, b = this.treeScale.y;
      RV(this.layoutCorrected, this.treeScale, this.path, f), c.layout && !c.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (c.target = c.layout.layoutBox, c.targetWithTransforms = zt());
      const { target: x } = c;
      if (!x) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Jw(this.prevProjectionDelta.x, this.projectionDelta.x), Jw(this.prevProjectionDelta.y, this.projectionDelta.y)), ul(this.projectionDelta, this.layoutCorrected, x, this.latestValues), (this.treeScale.x !== g || this.treeScale.y !== b || !c1(this.projectionDelta.x, this.prevProjectionDelta.x) || !c1(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", x));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(c = !0) {
      if (this.options.visualElement?.scheduleRender(), c) {
        const f = this.getStack();
        f && f.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = Ea(), this.projectionDelta = Ea(), this.projectionDeltaWithTransform = Ea();
    }
    setAnimationOrigin(c, f = !1) {
      const d = this.snapshot, h = d ? d.latestValues : {}, m = { ...this.latestValues }, g = Ea();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !f;
      const b = zt(), x = d ? d.source : void 0, _ = this.layout ? this.layout.source : void 0, E = x !== _, T = this.getStack(), C = !T || T.members.length <= 1, z = !!(E && !C && this.options.crossfade === !0 && !this.path.some(A6));
      this.animationProgress = 0;
      let A;
      this.mixTargetDelta = (R) => {
        const O = R / 1e3;
        g1(g.x, c.x, O), g1(g.y, c.y, O), this.setTargetDelta(g), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (of(b, this.layout.layoutBox, this.relativeParent.layout.layoutBox), C6(this.relativeTarget, this.relativeTargetOrigin, b, O), A && r6(this.relativeTarget, A) && (this.isProjectionDirty = !1), A || (A = zt()), qn(A, this.relativeTarget)), E && (this.animationValues = m, a6(m, h, this.latestValues, O, z, C)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = O;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(c) {
      this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (No(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = et.update(() => {
        ju.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = ka(0)), this.currentAnimation = c6(this.motionValue, [0, 1e3], {
          ...c,
          velocity: 0,
          isSync: !0,
          onUpdate: (f) => {
            this.mixTargetDelta(f), c.onUpdate && c.onUpdate(f);
          },
          onStop: () => {
          },
          onComplete: () => {
            c.onComplete && c.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const c = this.getStack();
      c && c.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(p6), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const c = this.getLead();
      let { targetWithTransforms: f, target: d, layout: h, latestValues: m } = c;
      if (!(!f || !d || !h)) {
        if (this !== c && this.layout && h && zC(this.options.animationType, this.layout.layoutBox, h.layoutBox)) {
          d = this.target || zt();
          const g = Wt(this.layout.layoutBox.x);
          d.x.min = c.target.x.min, d.x.max = d.x.min + g;
          const b = Wt(this.layout.layoutBox.y);
          d.y.min = c.target.y.min, d.y.max = d.y.min + b;
        }
        qn(f, d), Ta(f, m), ul(this.projectionDeltaWithTransform, this.layoutCorrected, f, m);
      }
    }
    registerSharedNode(c, f) {
      this.sharedNodes.has(c) || this.sharedNodes.set(c, new h6()), this.sharedNodes.get(c).add(f);
      const h = f.options.initialPromotionConfig;
      f.promote({
        transition: h ? h.transition : void 0,
        preserveFollowOpacity: h && h.shouldPreserveFollowOpacity ? h.shouldPreserveFollowOpacity(f) : void 0
      });
    }
    isLead() {
      const c = this.getStack();
      return c ? c.lead === this : !0;
    }
    getLead() {
      const { layoutId: c } = this.options;
      return c ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId: c } = this.options;
      return c ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId: c } = this.options;
      if (c)
        return this.root.sharedNodes.get(c);
    }
    promote({ needsReset: c, transition: f, preserveFollowOpacity: d } = {}) {
      const h = this.getStack();
      h && h.promote(this, d), c && (this.projectionDelta = void 0, this.needsReset = !0), f && this.setOptions({ transition: f });
    }
    relegate() {
      const c = this.getStack();
      return c ? c.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: c } = this.options;
      if (!c)
        return;
      let f = !1;
      const { latestValues: d } = c;
      if ((d.z || d.rotate || d.rotateX || d.rotateY || d.rotateZ || d.skewX || d.skewY) && (f = !0), !f)
        return;
      const h = {};
      d.z && Xp("z", c, h, this.animationValues);
      for (let m = 0; m < qp.length; m++)
        Xp(`rotate${qp[m]}`, c, h, this.animationValues), Xp(`skew${qp[m]}`, c, h, this.animationValues);
      c.render();
      for (const m in h)
        c.setStaticValue(m, h[m]), this.animationValues && (this.animationValues[m] = h[m]);
      c.scheduleRender();
    }
    applyProjectionStyles(c, f) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        c.visibility = "hidden";
        return;
      }
      const d = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = !1, c.visibility = "", c.opacity = "", c.pointerEvents = Ou(f?.pointerEvents) || "", c.transform = d ? d(this.latestValues, "") : "none";
        return;
      }
      const h = this.getLead();
      if (!this.projectionDelta || !this.layout || !h.target) {
        this.options.layoutId && (c.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, c.pointerEvents = Ou(f?.pointerEvents) || ""), this.hasProjected && !ui(this.latestValues) && (c.transform = d ? d({}, "") : "none", this.hasProjected = !1);
        return;
      }
      c.visibility = "";
      const m = h.animationValues || h.latestValues;
      this.applyTransformsToTarget();
      let g = o6(this.projectionDeltaWithTransform, this.treeScale, m);
      d && (g = d(m, g)), c.transform = g;
      const { x: b, y: x } = this.projectionDelta;
      c.transformOrigin = `${b.origin * 100}% ${x.origin * 100}% 0`, h.animationValues ? c.opacity = h === this ? m.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : m.opacityExit : c.opacity = h === this ? m.opacity !== void 0 ? m.opacity : "" : m.opacityExit !== void 0 ? m.opacityExit : 0;
      for (const _ in Jm) {
        if (m[_] === void 0)
          continue;
        const { correct: E, applyTo: T, isCSSVariable: C } = Jm[_], z = g === "none" ? m[_] : E(m[_], h);
        if (T) {
          const A = T.length;
          for (let R = 0; R < A; R++)
            c[T[R]] = z;
        } else
          C ? this.options.visualElement.renderState.vars[_] = z : c[_] = z;
      }
      this.options.layoutId && (c.pointerEvents = h === this ? Ou(f?.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((c) => c.currentAnimation?.stop()), this.root.nodes.forEach(h1), this.root.sharedNodes.clear();
    }
  };
}
function g6(e) {
  e.updateLayout();
}
function v6(e) {
  const t = e.resumeFrom?.snapshot || e.snapshot;
  if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: o } = e.layout, { animationType: a } = e.options, l = t.source !== e.layout.source;
    a === "size" ? Pn((m) => {
      const g = l ? t.measuredBox[m] : t.layoutBox[m], b = Wt(g);
      g.min = n[m].min, g.max = g.min + b;
    }) : zC(a, t.layoutBox, n) && Pn((m) => {
      const g = l ? t.measuredBox[m] : t.layoutBox[m], b = Wt(n[m]);
      g.max = g.min + b, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[m].max = e.relativeTarget[m].min + b);
    });
    const c = Ea();
    ul(c, n, t.layoutBox);
    const f = Ea();
    l ? ul(f, e.applyTransform(o, !0), t.measuredBox) : ul(f, n, t.layoutBox);
    const d = !_C(c);
    let h = !1;
    if (!e.resumeFrom) {
      const m = e.getClosestProjectingParent();
      if (m && !m.resumeFrom) {
        const { snapshot: g, layout: b } = m;
        if (g && b) {
          const x = zt();
          of(x, t.layoutBox, g.layoutBox);
          const _ = zt();
          of(_, n, b.layoutBox), TC(x, _) || (h = !0), m.options.layoutRoot && (e.relativeTarget = _, e.relativeTargetOrigin = x, e.relativeParent = m);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: n,
      snapshot: t,
      delta: f,
      layoutDelta: c,
      hasLayoutChanged: d,
      hasRelativeLayoutChanged: h
    });
  } else if (e.isLead()) {
    const { onExitComplete: n } = e.options;
    n && n();
  }
  e.options.transition = void 0;
}
function y6(e) {
  e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function b6(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function x6(e) {
  e.clearSnapshot();
}
function h1(e) {
  e.clearMeasurements();
}
function p1(e) {
  e.isLayoutDirty = !1;
}
function S6(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function m1(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function w6(e) {
  e.resolveTargetDelta();
}
function E6(e) {
  e.calcProjection();
}
function _6(e) {
  e.resetSkewAndRotation();
}
function T6(e) {
  e.removeLeadSnapshot();
}
function g1(e, t, n) {
  e.translate = ft(t.translate, 0, n), e.scale = ft(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function v1(e, t, n, o) {
  e.min = ft(t.min, n.min, o), e.max = ft(t.max, n.max, o);
}
function C6(e, t, n, o) {
  v1(e.x, t.x, n.x, o), v1(e.y, t.y, n.y, o);
}
function A6(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const R6 = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, y1 = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), b1 = y1("applewebkit/") && !y1("chrome/") ? Math.round : In;
function x1(e) {
  e.min = b1(e.min), e.max = b1(e.max);
}
function M6(e) {
  x1(e.x), x1(e.y);
}
function zC(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !JV(l1(t), l1(n), 0.2);
}
function z6(e) {
  return e !== e.root && e.scroll?.wasRoot;
}
const D6 = MC({
  attachResizeListener: (e, t) => Sl(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body?.scrollLeft || 0,
    y: document.documentElement.scrollTop || document.body?.scrollTop || 0
  }),
  checkIsScrollRoot: () => !0
}), Wp = {
  current: void 0
}, DC = MC({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!Wp.current) {
      const e = new D6({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), Wp.current = e;
    }
    return Wp.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), lv = y.createContext({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
});
function S1(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function N6(...e) {
  return (t) => {
    let n = !1;
    const o = e.map((a) => {
      const l = S1(a, t);
      return !n && typeof l == "function" && (n = !0), l;
    });
    if (n)
      return () => {
        for (let a = 0; a < o.length; a++) {
          const l = o[a];
          typeof l == "function" ? l() : S1(e[a], null);
        }
      };
  };
}
function O6(...e) {
  return y.useCallback(N6(...e), e);
}
class j6 extends y.Component {
  getSnapshotBeforeUpdate(t) {
    const n = this.props.childRef.current;
    if (n && t.isPresent && !this.props.isPresent) {
      const o = n.offsetParent, a = qm(o) && o.offsetWidth || 0, l = qm(o) && o.offsetHeight || 0, c = this.props.sizeRef.current;
      c.height = n.offsetHeight || 0, c.width = n.offsetWidth || 0, c.top = n.offsetTop, c.left = n.offsetLeft, c.right = a - c.width - c.left, c.bottom = l - c.height - c.top;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function k6({ children: e, isPresent: t, anchorX: n, anchorY: o, root: a }) {
  const l = y.useId(), c = y.useRef(null), f = y.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }), { nonce: d } = y.useContext(lv), h = e.props?.ref ?? e?.ref, m = O6(c, h);
  return y.useInsertionEffect(() => {
    const { width: g, height: b, top: x, left: _, right: E, bottom: T } = f.current;
    if (t || !c.current || !g || !b)
      return;
    const C = n === "left" ? `left: ${_}` : `right: ${E}`, z = o === "bottom" ? `bottom: ${T}` : `top: ${x}`;
    c.current.dataset.motionPopId = l;
    const A = document.createElement("style");
    d && (A.nonce = d);
    const R = a ?? document.head;
    return R.appendChild(A), A.sheet && A.sheet.insertRule(`
          [data-motion-pop-id="${l}"] {
            position: absolute !important;
            width: ${g}px !important;
            height: ${b}px !important;
            ${C}px !important;
            ${z}px !important;
          }
        `), () => {
      R.contains(A) && R.removeChild(A);
    };
  }, [t]), S.jsx(j6, { isPresent: t, childRef: c, sizeRef: f, children: y.cloneElement(e, { ref: m }) });
}
const P6 = ({ children: e, initial: t, isPresent: n, onExitComplete: o, custom: a, presenceAffectsLayout: l, mode: c, anchorX: f, anchorY: d, root: h }) => {
  const m = jg(L6), g = y.useId();
  let b = !0, x = y.useMemo(() => (b = !1, {
    id: g,
    initial: t,
    isPresent: n,
    custom: a,
    onExitComplete: (_) => {
      m.set(_, !0);
      for (const E of m.values())
        if (!E)
          return;
      o && o();
    },
    register: (_) => (m.set(_, !1), () => m.delete(_))
  }), [n, m, o]);
  return l && b && (x = { ...x }), y.useMemo(() => {
    m.forEach((_, E) => m.set(E, !1));
  }, [n]), y.useEffect(() => {
    !n && !m.size && o && o();
  }, [n]), c === "popLayout" && (e = S.jsx(k6, { isPresent: n, anchorX: f, anchorY: d, root: h, children: e })), S.jsx(Nf.Provider, { value: x, children: e });
};
function L6() {
  return /* @__PURE__ */ new Map();
}
function NC(e = !0) {
  const t = y.useContext(Nf);
  if (t === null)
    return [!0, null];
  const { isPresent: n, onExitComplete: o, register: a } = t, l = y.useId();
  y.useEffect(() => {
    if (e)
      return a(l);
  }, [e]);
  const c = y.useCallback(() => e && o && o(l), [l, o, e]);
  return !n && o ? [!1, c] : [!0];
}
const vu = (e) => e.key || "";
function w1(e) {
  const t = [];
  return y.Children.forEach(e, (n) => {
    y.isValidElement(n) && t.push(n);
  }), t;
}
const OC = ({ children: e, custom: t, initial: n = !0, onExitComplete: o, presenceAffectsLayout: a = !0, mode: l = "sync", propagate: c = !1, anchorX: f = "left", anchorY: d = "top", root: h }) => {
  const [m, g] = NC(c), b = y.useMemo(() => w1(e), [e]), x = c && !m ? [] : b.map(vu), _ = y.useRef(!0), E = y.useRef(b), T = jg(() => /* @__PURE__ */ new Map()), C = y.useRef(/* @__PURE__ */ new Set()), [z, A] = y.useState(b), [R, O] = y.useState(b);
  fT(() => {
    _.current = !1, E.current = b;
    for (let N = 0; N < R.length; N++) {
      const j = vu(R[N]);
      x.includes(j) ? (T.delete(j), C.current.delete(j)) : T.get(j) !== !0 && T.set(j, !1);
    }
  }, [R, x.length, x.join("-")]);
  const L = [];
  if (b !== z) {
    let N = [...b];
    for (let j = 0; j < R.length; j++) {
      const Y = R[j], ne = vu(Y);
      x.includes(ne) || (N.splice(j, 0, Y), L.push(Y));
    }
    return l === "wait" && L.length && (N = L), O(w1(N)), A(b), null;
  }
  const { forceRender: M } = y.useContext(Og);
  return S.jsx(S.Fragment, { children: R.map((N) => {
    const j = vu(N), Y = c && !m ? !1 : b === R || x.includes(j), ne = () => {
      if (C.current.has(j))
        return;
      if (C.current.add(j), T.has(j))
        T.set(j, !0);
      else
        return;
      let J = !0;
      T.forEach((he) => {
        he || (J = !1);
      }), J && (M?.(), O(E.current), c && g?.(), o && o());
    };
    return S.jsx(P6, { isPresent: Y, initial: !_.current || n ? void 0 : !1, custom: t, presenceAffectsLayout: a, mode: l, root: h, onExitComplete: Y ? void 0 : ne, anchorX: f, anchorY: d, children: N }, j);
  }) });
}, jC = y.createContext({ strict: !1 }), E1 = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
let _1 = !1;
function I6() {
  if (_1)
    return;
  const e = {};
  for (const t in E1)
    e[t] = {
      isEnabled: (n) => E1[t].some((o) => !!n[o])
    };
  lC(e), _1 = !0;
}
function kC() {
  return I6(), _V();
}
function V6(e) {
  const t = kC();
  for (const n in e)
    t[n] = {
      ...t[n],
      ...e[n]
    };
  lC(t);
}
const U6 = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function af(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || U6.has(e);
}
let PC = (e) => !af(e);
function B6(e) {
  typeof e == "function" && (PC = (t) => t.startsWith("on") ? !af(t) : e(t));
}
try {
  B6(require("@emotion/is-prop-valid").default);
} catch {
}
function $6(e, t, n) {
  const o = {};
  for (const a in e)
    a === "values" && typeof e.values == "object" || (PC(a) || n === !0 && af(a) || !t && !af(a) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && a.startsWith("onDrag")) && (o[a] = e[a]);
  return o;
}
const kf = /* @__PURE__ */ y.createContext({});
function H6(e, t) {
  if (jf(e)) {
    const { initial: n, animate: o } = e;
    return {
      initial: n === !1 || xl(n) ? n : void 0,
      animate: xl(o) ? o : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function Z6(e) {
  const { initial: t, animate: n } = H6(e, y.useContext(kf));
  return y.useMemo(() => ({ initial: t, animate: n }), [T1(t), T1(n)]);
}
function T1(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const cv = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function LC(e, t, n) {
  for (const o in t)
    !Ft(t[o]) && !mC(o, n) && (e[o] = t[o]);
}
function F6({ transformTemplate: e }, t) {
  return y.useMemo(() => {
    const n = cv();
    return av(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function G6(e, t) {
  const n = e.style || {}, o = {};
  return LC(o, n, e), Object.assign(o, F6(e, t)), o;
}
function Y6(e, t) {
  const n = {}, o = G6(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, o.userSelect = o.WebkitUserSelect = o.WebkitTouchCallout = "none", o.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = o, n;
}
const IC = () => ({
  ...cv(),
  attrs: {}
});
function q6(e, t, n, o) {
  const a = y.useMemo(() => {
    const l = IC();
    return gC(l, t, yC(o), e.transformTemplate, e.style), {
      ...l.attrs,
      style: { ...l.style }
    };
  }, [t]);
  if (e.style) {
    const l = {};
    LC(l, e.style, e), a.style = { ...l, ...a.style };
  }
  return a;
}
const X6 = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function uv(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(X6.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(e))
    )
  );
}
function W6(e, t, n, { latestValues: o }, a, l = !1, c) {
  const d = (c ?? uv(e) ? q6 : Y6)(t, o, a, e), h = $6(t, typeof e == "string", l), m = e !== y.Fragment ? { ...h, ...d, ref: n } : {}, { children: g } = t, b = y.useMemo(() => Ft(g) ? g.get() : g, [g]);
  return y.createElement(e, {
    ...m,
    children: b
  });
}
function K6({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, o, a) {
  return {
    latestValues: J6(n, o, a, e),
    renderState: t()
  };
}
function J6(e, t, n, o) {
  const a = {}, l = o(e, {});
  for (const b in l)
    a[b] = Ou(l[b]);
  let { initial: c, animate: f } = e;
  const d = jf(e), h = sC(e);
  t && h && !d && e.inherit !== !1 && (c === void 0 && (c = t.initial), f === void 0 && (f = t.animate));
  let m = n ? n.initial === !1 : !1;
  m = m || c === !1;
  const g = m ? f : c;
  if (g && typeof g != "boolean" && !Of(g)) {
    const b = Array.isArray(g) ? g : [g];
    for (let x = 0; x < b.length; x++) {
      const _ = Qg(e, b[x]);
      if (_) {
        const { transitionEnd: E, transition: T, ...C } = _;
        for (const z in C) {
          let A = C[z];
          if (Array.isArray(A)) {
            const R = m ? A.length - 1 : 0;
            A = A[R];
          }
          A !== null && (a[z] = A);
        }
        for (const z in E)
          a[z] = E[z];
      }
    }
  }
  return a;
}
const VC = (e) => (t, n) => {
  const o = y.useContext(kf), a = y.useContext(Nf), l = () => K6(e, t, o, a);
  return n ? l() : jg(l);
}, Q6 = /* @__PURE__ */ VC({
  scrapeMotionValuesFromProps: sv,
  createRenderState: cv
}), eU = /* @__PURE__ */ VC({
  scrapeMotionValuesFromProps: bC,
  createRenderState: IC
}), tU = /* @__PURE__ */ Symbol.for("motionComponentSymbol");
function nU(e, t, n) {
  const o = y.useRef(n);
  y.useInsertionEffect(() => {
    o.current = n;
  });
  const a = y.useRef(null);
  return y.useCallback((l) => {
    l && e.onMount?.(l), t && (l ? t.mount(l) : t.unmount());
    const c = o.current;
    if (typeof c == "function")
      if (l) {
        const f = c(l);
        typeof f == "function" && (a.current = f);
      } else a.current ? (a.current(), a.current = null) : c(l);
    else c && (c.current = l);
  }, [t]);
}
const UC = y.createContext({});
function el(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function rU(e, t, n, o, a, l) {
  const { visualElement: c } = y.useContext(kf), f = y.useContext(jC), d = y.useContext(Nf), h = y.useContext(lv), m = h.reducedMotion, g = h.skipAnimations, b = y.useRef(null), x = y.useRef(!1);
  o = o || f.renderer, !b.current && o && (b.current = o(e, {
    visualState: t,
    parent: c,
    props: n,
    presenceContext: d,
    blockInitialAnimation: d ? d.initial === !1 : !1,
    reducedMotionConfig: m,
    skipAnimations: g,
    isSVG: l
  }), x.current && b.current && (b.current.manuallyAnimateOnMount = !0));
  const _ = b.current, E = y.useContext(UC);
  _ && !_.projection && a && (_.type === "html" || _.type === "svg") && oU(b.current, n, a, E);
  const T = y.useRef(!1);
  y.useInsertionEffect(() => {
    _ && T.current && _.update(n, d);
  });
  const C = n[qT], z = y.useRef(!!C && !window.MotionHandoffIsComplete?.(C) && window.MotionHasOptimisedAnimation?.(C));
  return fT(() => {
    x.current = !0, _ && (T.current = !0, window.MotionIsMounted = !0, _.updateFeatures(), _.scheduleRenderMicrotask(), z.current && _.animationState && _.animationState.animateChanges());
  }), y.useEffect(() => {
    _ && (!z.current && _.animationState && _.animationState.animateChanges(), z.current && (queueMicrotask(() => {
      window.MotionHandoffMarkAsComplete?.(C);
    }), z.current = !1), _.enteringChildren = void 0);
  }), _;
}
function oU(e, t, n, o) {
  const { layoutId: a, layout: l, drag: c, dragConstraints: f, layoutScroll: d, layoutRoot: h, layoutCrossfade: m } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : BC(e.parent)), e.projection.setOptions({
    layoutId: a,
    layout: l,
    alwaysMeasureLayout: !!c || f && el(f),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof l == "string" ? l : "both",
    initialPromotionConfig: o,
    crossfade: m,
    layoutScroll: d,
    layoutRoot: h
  });
}
function BC(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : BC(e.parent);
}
function Kp(e, { forwardMotionProps: t = !1, type: n } = {}, o, a) {
  o && V6(o);
  const l = n ? n === "svg" : uv(e), c = l ? eU : Q6;
  function f(h, m) {
    let g;
    const b = {
      ...y.useContext(lv),
      ...h,
      layoutId: iU(h)
    }, { isStatic: x } = b, _ = Z6(h), E = c(h, x);
    if (!x && uT) {
      aU();
      const T = sU(b);
      g = T.MeasureLayout, _.visualElement = rU(e, E, b, a, T.ProjectionNode, l);
    }
    return S.jsxs(kf.Provider, { value: _, children: [g && _.visualElement ? S.jsx(g, { visualElement: _.visualElement, ...b }) : null, W6(e, h, nU(E, _.visualElement, m), E, x, t, l)] });
  }
  f.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`;
  const d = y.forwardRef(f);
  return d[tU] = e, d;
}
function iU({ layoutId: e }) {
  const t = y.useContext(Og).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function aU(e, t) {
  y.useContext(jC).strict;
}
function sU(e) {
  const t = kC(), { drag: n, layout: o } = t;
  if (!n && !o)
    return {};
  const a = { ...n, ...o };
  return {
    MeasureLayout: n?.isEnabled(e) || o?.isEnabled(e) ? a.MeasureLayout : void 0,
    ProjectionNode: a.ProjectionNode
  };
}
function lU(e, t) {
  if (typeof Proxy > "u")
    return Kp;
  const n = /* @__PURE__ */ new Map(), o = (l, c) => Kp(l, c, e, t), a = (l, c) => o(l, c);
  return new Proxy(a, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (l, c) => c === "create" ? o : (n.has(c) || n.set(c, Kp(c, void 0, e, t)), n.get(c))
  });
}
const cU = (e, t) => t.isSVG ?? uv(e) ? new BV(t) : new kV(t, {
  allowProjection: e !== y.Fragment
});
class uU extends Vo {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = GV(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    Of(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    this.node.animationState.reset(), this.unmountControls?.();
  }
}
let fU = 0;
class dU extends Vo {
  constructor() {
    super(...arguments), this.id = fU++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: o } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === o)
      return;
    const a = this.node.animationState.setActive("exit", !t);
    n && !t && a.then(() => {
      n(this.id);
    });
  }
  mount() {
    const { register: t, onExitComplete: n } = this.node.presenceContext || {};
    n && n(this.id), t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const hU = {
  animation: {
    Feature: uU
  },
  exit: {
    Feature: dU
  }
};
function kl(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
const pU = (e) => (t) => rv(t) && e(t, kl(t));
function fl(e, t, n, o) {
  return Sl(e, t, pU(n), o);
}
const $C = ({ current: e }) => e ? e.ownerDocument.defaultView : null, C1 = (e, t) => Math.abs(e - t);
function mU(e, t) {
  const n = C1(e.x, t.x), o = C1(e.y, t.y);
  return Math.sqrt(n ** 2 + o ** 2);
}
const A1 = /* @__PURE__ */ new Set(["auto", "scroll"]);
class HC {
  constructor(t, n, { transformPagePoint: o, contextWindow: a = window, dragSnapToOrigin: l = !1, distanceThreshold: c = 3, element: f } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.scrollPositions = /* @__PURE__ */ new Map(), this.removeScrollListeners = null, this.onElementScroll = (x) => {
      this.handleScroll(x.target);
    }, this.onWindowScroll = () => {
      this.handleScroll(window);
    }, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const x = Qp(this.lastMoveEventInfo, this.history), _ = this.startEvent !== null, E = mU(x.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!_ && !E)
        return;
      const { point: T } = x, { timestamp: C } = Ut;
      this.history.push({ ...T, timestamp: C });
      const { onStart: z, onMove: A } = this.handlers;
      _ || (z && z(this.lastMoveEvent, x), this.startEvent = this.lastMoveEvent), A && A(this.lastMoveEvent, x);
    }, this.handlePointerMove = (x, _) => {
      this.lastMoveEvent = x, this.lastMoveEventInfo = Jp(_, this.transformPagePoint), et.update(this.updatePoint, !0);
    }, this.handlePointerUp = (x, _) => {
      this.end();
      const { onEnd: E, onSessionEnd: T, resumeAnimation: C } = this.handlers;
      if ((this.dragSnapToOrigin || !this.startEvent) && C && C(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const z = Qp(x.type === "pointercancel" ? this.lastMoveEventInfo : Jp(_, this.transformPagePoint), this.history);
      this.startEvent && E && E(x, z), T && T(x, z);
    }, !rv(t))
      return;
    this.dragSnapToOrigin = l, this.handlers = n, this.transformPagePoint = o, this.distanceThreshold = c, this.contextWindow = a || window;
    const d = kl(t), h = Jp(d, this.transformPagePoint), { point: m } = h, { timestamp: g } = Ut;
    this.history = [{ ...m, timestamp: g }];
    const { onSessionStart: b } = n;
    b && b(t, Qp(h, this.history)), this.removeListeners = Nl(fl(this.contextWindow, "pointermove", this.handlePointerMove), fl(this.contextWindow, "pointerup", this.handlePointerUp), fl(this.contextWindow, "pointercancel", this.handlePointerUp)), f && this.startScrollTracking(f);
  }
  /**
   * Start tracking scroll on ancestors and window.
   */
  startScrollTracking(t) {
    let n = t.parentElement;
    for (; n; ) {
      const o = getComputedStyle(n);
      (A1.has(o.overflowX) || A1.has(o.overflowY)) && this.scrollPositions.set(n, {
        x: n.scrollLeft,
        y: n.scrollTop
      }), n = n.parentElement;
    }
    this.scrollPositions.set(window, {
      x: window.scrollX,
      y: window.scrollY
    }), window.addEventListener("scroll", this.onElementScroll, {
      capture: !0,
      passive: !0
    }), window.addEventListener("scroll", this.onWindowScroll, {
      passive: !0
    }), this.removeScrollListeners = () => {
      window.removeEventListener("scroll", this.onElementScroll, {
        capture: !0
      }), window.removeEventListener("scroll", this.onWindowScroll);
    };
  }
  /**
   * Handle scroll compensation during drag.
   *
   * For element scroll: adjusts history origin since pageX/pageY doesn't change.
   * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.
   */
  handleScroll(t) {
    const n = this.scrollPositions.get(t);
    if (!n)
      return;
    const o = t === window, a = o ? { x: window.scrollX, y: window.scrollY } : {
      x: t.scrollLeft,
      y: t.scrollTop
    }, l = { x: a.x - n.x, y: a.y - n.y };
    l.x === 0 && l.y === 0 || (o ? this.lastMoveEventInfo && (this.lastMoveEventInfo.point.x += l.x, this.lastMoveEventInfo.point.y += l.y) : this.history.length > 0 && (this.history[0].x -= l.x, this.history[0].y -= l.y), this.scrollPositions.set(t, a), et.update(this.updatePoint, !0));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), this.removeScrollListeners && this.removeScrollListeners(), this.scrollPositions.clear(), No(this.updatePoint);
  }
}
function Jp(e, t) {
  return t ? { point: t(e.point) } : e;
}
function R1(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function Qp({ point: e }, t) {
  return {
    point: e,
    delta: R1(e, ZC(t)),
    offset: R1(e, gU(t)),
    velocity: vU(t, 0.1)
  };
}
function gU(e) {
  return e[0];
}
function ZC(e) {
  return e[e.length - 1];
}
function vU(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, o = null;
  const a = ZC(e);
  for (; n >= 0 && (o = e[n], !(a.timestamp - o.timestamp > /* @__PURE__ */ Zr(t))); )
    n--;
  if (!o)
    return { x: 0, y: 0 };
  const l = /* @__PURE__ */ Ln(a.timestamp - o.timestamp);
  if (l === 0)
    return { x: 0, y: 0 };
  const c = {
    x: (a.x - o.x) / l,
    y: (a.y - o.y) / l
  };
  return c.x === 1 / 0 && (c.x = 0), c.y === 1 / 0 && (c.y = 0), c;
}
function yU(e, { min: t, max: n }, o) {
  return t !== void 0 && e < t ? e = o ? ft(t, e, o.min) : Math.max(e, t) : n !== void 0 && e > n && (e = o ? ft(n, e, o.max) : Math.min(e, n)), e;
}
function M1(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function bU(e, { top: t, left: n, bottom: o, right: a }) {
  return {
    x: M1(e.x, n, a),
    y: M1(e.y, t, o)
  };
}
function z1(e, t) {
  let n = t.min - e.min, o = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, o] = [o, n]), { min: n, max: o };
}
function xU(e, t) {
  return {
    x: z1(e.x, t.x),
    y: z1(e.y, t.y)
  };
}
function SU(e, t) {
  let n = 0.5;
  const o = Wt(e), a = Wt(t);
  return a > o ? n = /* @__PURE__ */ vl(t.min, t.max - o, e.min) : o > a && (n = /* @__PURE__ */ vl(e.min, e.max - a, t.min)), gr(0, 1, n);
}
function wU(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const Qm = 0.35;
function EU(e = Qm) {
  return e === !1 ? e = 0 : e === !0 && (e = Qm), {
    x: D1(e, "left", "right"),
    y: D1(e, "top", "bottom")
  };
}
function D1(e, t, n) {
  return {
    min: N1(e, t),
    max: N1(e, n)
  };
}
function N1(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const _U = /* @__PURE__ */ new WeakMap();
class TU {
  constructor(t) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = zt(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1, distanceThreshold: o } = {}) {
    const { presenceContext: a } = this.visualElement;
    if (a && a.isPresent === !1)
      return;
    const l = (g) => {
      n ? (this.stopAnimation(), this.snapToCursor(kl(g).point)) : this.pauseAnimation();
    }, c = (g, b) => {
      this.stopAnimation();
      const { drag: x, dragPropagation: _, onDragStart: E } = this.getProps();
      if (x && !_ && (this.openDragLock && this.openDragLock(), this.openDragLock = cV(x), !this.openDragLock))
        return;
      this.latestPointerEvent = g, this.latestPanInfo = b, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Pn((C) => {
        let z = this.getAxisMotionValue(C).get() || 0;
        if (dr.test(z)) {
          const { projection: A } = this.visualElement;
          if (A && A.layout) {
            const R = A.layout.layoutBox[C];
            R && (z = Wt(R) * (parseFloat(z) / 100));
          }
        }
        this.originPoint[C] = z;
      }), E && et.update(() => E(g, b), !1, !0), Fm(this.visualElement, "transform");
      const { animationState: T } = this.visualElement;
      T && T.setActive("whileDrag", !0);
    }, f = (g, b) => {
      this.latestPointerEvent = g, this.latestPanInfo = b;
      const { dragPropagation: x, dragDirectionLock: _, onDirectionLock: E, onDrag: T } = this.getProps();
      if (!x && !this.openDragLock)
        return;
      const { offset: C } = b;
      if (_ && this.currentDirection === null) {
        this.currentDirection = CU(C), this.currentDirection !== null && E && E(this.currentDirection);
        return;
      }
      this.updateAxis("x", b.point, C), this.updateAxis("y", b.point, C), this.visualElement.render(), T && et.update(() => T(g, b), !1, !0);
    }, d = (g, b) => {
      this.latestPointerEvent = g, this.latestPanInfo = b, this.stop(g, b), this.latestPointerEvent = null, this.latestPanInfo = null;
    }, h = () => Pn((g) => this.getAnimationState(g) === "paused" && this.getAxisMotionValue(g).animation?.play()), { dragSnapToOrigin: m } = this.getProps();
    this.panSession = new HC(t, {
      onSessionStart: l,
      onStart: c,
      onMove: f,
      onSessionEnd: d,
      resumeAnimation: h
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: m,
      distanceThreshold: o,
      contextWindow: $C(this.visualElement),
      element: this.visualElement.current
    });
  }
  /**
   * @internal
   */
  stop(t, n) {
    const o = t || this.latestPointerEvent, a = n || this.latestPanInfo, l = this.isDragging;
    if (this.cancel(), !l || !a || !o)
      return;
    const { velocity: c } = a;
    this.startAnimation(c);
    const { onDragEnd: f } = this.getProps();
    f && et.postRender(() => f(o, a));
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.endPanSession();
    const { dragPropagation: o } = this.getProps();
    !o && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1);
  }
  /**
   * Clean up the pan session without modifying other drag state.
   * This is used during unmount to ensure event listeners are removed
   * without affecting projection animations or drag locks.
   * @internal
   */
  endPanSession() {
    this.panSession && this.panSession.end(), this.panSession = void 0;
  }
  updateAxis(t, n, o) {
    const { drag: a } = this.getProps();
    if (!o || !yu(t, a, this.currentDirection))
      return;
    const l = this.getAxisMotionValue(t);
    let c = this.originPoint[t] + o[t];
    this.constraints && this.constraints[t] && (c = yU(c, this.constraints[t], this.elastic[t])), l.set(c);
  }
  resolveConstraints() {
    const { dragConstraints: t, dragElastic: n } = this.getProps(), o = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, a = this.constraints;
    t && el(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && o ? this.constraints = bU(o.layoutBox, t) : this.constraints = !1, this.elastic = EU(n), a !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && Pn((l) => {
      this.constraints !== !1 && this.getAxisMotionValue(l) && (this.constraints[l] = wU(o.layoutBox[l], this.constraints[l]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !el(t))
      return !1;
    const o = t.current, { projection: a } = this.visualElement;
    if (!a || !a.layout)
      return !1;
    const l = MV(o, a.root, this.visualElement.getTransformPagePoint());
    let c = xU(a.layout.layoutBox, l);
    if (n) {
      const f = n(CV(c));
      this.hasMutatedConstraints = !!f, f && (c = uC(f));
    }
    return c;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: o, dragElastic: a, dragTransition: l, dragSnapToOrigin: c, onDragTransitionEnd: f } = this.getProps(), d = this.constraints || {}, h = Pn((m) => {
      if (!yu(m, n, this.currentDirection))
        return;
      let g = d && d[m] || {};
      c && (g = { min: 0, max: 0 });
      const b = a ? 200 : 1e6, x = a ? 40 : 1e7, _ = {
        type: "inertia",
        velocity: o ? t[m] : 0,
        bounceStiffness: b,
        bounceDamping: x,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...l,
        ...g
      };
      return this.startAxisValueAnimation(m, _);
    });
    return Promise.all(h).then(f);
  }
  startAxisValueAnimation(t, n) {
    const o = this.getAxisMotionValue(t);
    return Fm(this.visualElement, t), o.start(Jg(t, o, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    Pn((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    Pn((t) => this.getAxisMotionValue(t).animation?.pause());
  }
  getAnimationState(t) {
    return this.getAxisMotionValue(t).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`, o = this.visualElement.getProps(), a = o[n];
    return a || this.visualElement.getValue(t, (o.initial ? o.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    Pn((n) => {
      const { drag: o } = this.getProps();
      if (!yu(n, o, this.currentDirection))
        return;
      const { projection: a } = this.visualElement, l = this.getAxisMotionValue(n);
      if (a && a.layout) {
        const { min: c, max: f } = a.layout.layoutBox[n], d = l.get() || 0;
        l.set(t[n] - ft(c, f, 0.5) + d);
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: o } = this.visualElement;
    if (!el(n) || !o || !this.constraints)
      return;
    this.stopAnimation();
    const a = { x: 0, y: 0 };
    Pn((c) => {
      const f = this.getAxisMotionValue(c);
      if (f && this.constraints !== !1) {
        const d = f.get();
        a[c] = SU({ min: d, max: d }, this.constraints[c]);
      }
    });
    const { transformTemplate: l } = this.visualElement.getProps();
    this.visualElement.current.style.transform = l ? l({}, "") : "none", o.root && o.root.updateScroll(), o.updateLayout(), this.resolveConstraints(), Pn((c) => {
      if (!yu(c, t, null))
        return;
      const f = this.getAxisMotionValue(c), { min: d, max: h } = this.constraints[c];
      f.set(ft(d, h, a[c]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    _U.set(this.visualElement, this);
    const t = this.visualElement.current, n = fl(t, "pointerdown", (d) => {
      const { drag: h, dragListener: m = !0 } = this.getProps(), g = d.target, b = g !== t && pV(g);
      h && m && !b && this.start(d);
    }), o = () => {
      const { dragConstraints: d } = this.getProps();
      el(d) && d.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: a } = this.visualElement, l = a.addEventListener("measure", o);
    a && !a.layout && (a.root && a.root.updateScroll(), a.updateLayout()), et.read(o);
    const c = Sl(window, "resize", () => this.scalePositionWithinConstraints()), f = a.addEventListener("didUpdate", (({ delta: d, hasLayoutChanged: h }) => {
      this.isDragging && h && (Pn((m) => {
        const g = this.getAxisMotionValue(m);
        g && (this.originPoint[m] += d[m].translate, g.set(g.get() + d[m].translate));
      }), this.visualElement.render());
    }));
    return () => {
      c(), n(), l(), f && f();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: o = !1, dragPropagation: a = !1, dragConstraints: l = !1, dragElastic: c = Qm, dragMomentum: f = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: o,
      dragPropagation: a,
      dragConstraints: l,
      dragElastic: c,
      dragMomentum: f
    };
  }
}
function yu(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function CU(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class AU extends Vo {
  constructor(t) {
    super(t), this.removeGroupControls = In, this.removeListeners = In, this.controls = new TU(t);
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || In;
  }
  update() {
    const { dragControls: t } = this.node.getProps(), { dragControls: n } = this.node.prevProps || {};
    t !== n && (this.removeGroupControls(), t && (this.removeGroupControls = t.subscribe(this.controls)));
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners(), this.controls.isDragging || this.controls.endPanSession();
  }
}
const em = (e) => (t, n) => {
  e && et.update(() => e(t, n), !1, !0);
};
class RU extends Vo {
  constructor() {
    super(...arguments), this.removePointerDownListener = In;
  }
  onPointerDown(t) {
    this.session = new HC(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: $C(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: o, onPanEnd: a } = this.node.getProps();
    return {
      onSessionStart: em(t),
      onStart: em(n),
      onMove: em(o),
      onEnd: (l, c) => {
        delete this.session, a && et.postRender(() => a(l, c));
      }
    };
  }
  mount() {
    this.removePointerDownListener = fl(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
let tm = !1;
class MU extends y.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: o, layoutId: a } = this.props, { projection: l } = t;
    l && (n.group && n.group.add(l), o && o.register && a && o.register(l), tm && l.root.didUpdate(), l.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), l.setOptions({
      ...l.options,
      layoutDependency: this.props.layoutDependency,
      onExitComplete: () => this.safeToRemove()
    })), ju.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: o, drag: a, isPresent: l } = this.props, { projection: c } = o;
    return c && (c.isPresent = l, t.layoutDependency !== n && c.setOptions({
      ...c.options,
      layoutDependency: n
    }), tm = !0, a || t.layoutDependency !== n || n === void 0 || t.isPresent !== l ? c.willUpdate() : this.safeToRemove(), t.isPresent !== l && (l ? c.promote() : c.relegate() || et.postRender(() => {
      const f = c.getStack();
      (!f || !f.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), nv.postRender(() => {
      !t.currentAnimation && t.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: o } = this.props, { projection: a } = t;
    tm = !0, a && (a.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(a), o && o.deregister && o.deregister(a));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function FC(e) {
  const [t, n] = NC(), o = y.useContext(Og);
  return S.jsx(MU, { ...e, layoutGroup: o, switchLayoutGroup: y.useContext(UC), isPresent: t, safeToRemove: n });
}
const zU = {
  pan: {
    Feature: RU
  },
  drag: {
    Feature: AU,
    ProjectionNode: DC,
    MeasureLayout: FC
  }
};
function O1(e, t, n) {
  const { props: o } = e;
  e.animationState && o.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const a = "onHover" + n, l = o[a];
  l && et.postRender(() => l(t, kl(t)));
}
class DU extends Vo {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = uV(t, (n, o) => (O1(this.node, o, "Start"), (a) => O1(this.node, a, "End"))));
  }
  unmount() {
  }
}
class NU extends Vo {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Nl(Sl(this.node.current, "focus", () => this.onFocus()), Sl(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function j1(e, t, n) {
  const { props: o } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled)
    return;
  e.animationState && o.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const a = "onTap" + (n === "End" ? "" : n), l = o[a];
  l && et.postRender(() => l(t, kl(t)));
}
class OU extends Vo {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = gV(t, (n, o) => (j1(this.node, o, "Start"), (a, { success: l }) => j1(this.node, a, l ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const eg = /* @__PURE__ */ new WeakMap(), nm = /* @__PURE__ */ new WeakMap(), jU = (e) => {
  const t = eg.get(e.target);
  t && t(e);
}, kU = (e) => {
  e.forEach(jU);
};
function PU({ root: e, ...t }) {
  const n = e || document;
  nm.has(n) || nm.set(n, {});
  const o = nm.get(n), a = JSON.stringify(t);
  return o[a] || (o[a] = new IntersectionObserver(kU, { root: e, ...t })), o[a];
}
function LU(e, t, n) {
  const o = PU(t);
  return eg.set(e, n), o.observe(e), () => {
    eg.delete(e), o.unobserve(e);
  };
}
const IU = {
  some: 0,
  all: 1
};
class VU extends Vo {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: o, amount: a = "some", once: l } = t, c = {
      root: n ? n.current : void 0,
      rootMargin: o,
      threshold: typeof a == "number" ? a : IU[a]
    }, f = (d) => {
      const { isIntersecting: h } = d;
      if (this.isInView === h || (this.isInView = h, l && !h && this.hasEnteredView))
        return;
      h && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", h);
      const { onViewportEnter: m, onViewportLeave: g } = this.node.getProps(), b = h ? m : g;
      b && b(d);
    };
    return LU(this.node.current, c, f);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(UU(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function UU({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const BU = {
  inView: {
    Feature: VU
  },
  tap: {
    Feature: OU
  },
  focus: {
    Feature: NU
  },
  hover: {
    Feature: DU
  }
}, $U = {
  layout: {
    ProjectionNode: DC,
    MeasureLayout: FC
  }
}, HU = {
  ...hU,
  ...BU,
  ...zU,
  ...$U
}, ku = /* @__PURE__ */ lU(HU, cU);
function k1(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function qr(...e) {
  return (t) => {
    let n = !1;
    const o = e.map((a) => {
      const l = k1(a, t);
      return !n && typeof l == "function" && (n = !0), l;
    });
    if (n)
      return () => {
        for (let a = 0; a < o.length; a++) {
          const l = o[a];
          typeof l == "function" ? l() : k1(e[a], null);
        }
      };
  };
}
function Le(...e) {
  return y.useCallback(qr(...e), e);
}
var ZU = /* @__PURE__ */ Symbol.for("react.lazy"), sf = _f[" use ".trim().toString()];
function FU(e) {
  return typeof e == "object" && e !== null && "then" in e;
}
function GC(e) {
  return e != null && typeof e == "object" && "$$typeof" in e && e.$$typeof === ZU && "_payload" in e && FU(e._payload);
}
// @__NO_SIDE_EFFECTS__
function YC(e) {
  const t = /* @__PURE__ */ GU(e), n = y.forwardRef((o, a) => {
    let { children: l, ...c } = o;
    GC(l) && typeof sf == "function" && (l = sf(l._payload));
    const f = y.Children.toArray(l), d = f.find(qU);
    if (d) {
      const h = d.props.children, m = f.map((g) => g === d ? y.Children.count(h) > 1 ? y.Children.only(null) : y.isValidElement(h) ? h.props.children : null : g);
      return /* @__PURE__ */ S.jsx(t, { ...c, ref: a, children: y.isValidElement(h) ? y.cloneElement(h, void 0, m) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...c, ref: a, children: l });
  });
  return n.displayName = `${e}.Slot`, n;
}
var qC = /* @__PURE__ */ YC("Slot");
// @__NO_SIDE_EFFECTS__
function GU(e) {
  const t = y.forwardRef((n, o) => {
    let { children: a, ...l } = n;
    if (GC(a) && typeof sf == "function" && (a = sf(a._payload)), y.isValidElement(a)) {
      const c = WU(a), f = XU(l, a.props);
      return a.type !== y.Fragment && (f.ref = o ? qr(o, c) : c), y.cloneElement(a, f);
    }
    return y.Children.count(a) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var YU = /* @__PURE__ */ Symbol("radix.slottable");
function qU(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === YU;
}
function XU(e, t) {
  const n = { ...t };
  for (const o in t) {
    const a = e[o], l = t[o];
    /^on[A-Z]/.test(o) ? a && l ? n[o] = (...f) => {
      const d = l(...f);
      return a(...f), d;
    } : a && (n[o] = a) : o === "style" ? n[o] = { ...a, ...l } : o === "className" && (n[o] = [a, l].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function WU(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function XC(e) {
  var t, n, o = "";
  if (typeof e == "string" || typeof e == "number") o += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var a = e.length;
    for (t = 0; t < a; t++) e[t] && (n = XC(e[t])) && (o && (o += " "), o += n);
  } else for (n in e) e[n] && (o && (o += " "), o += n);
  return o;
}
function WC() {
  for (var e, t, n = 0, o = "", a = arguments.length; n < a; n++) (e = arguments[n]) && (t = XC(e)) && (o && (o += " "), o += t);
  return o;
}
const P1 = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, L1 = WC, KC = (e, t) => (n) => {
  var o;
  if (t?.variants == null) return L1(e, n?.class, n?.className);
  const { variants: a, defaultVariants: l } = t, c = Object.keys(a).map((h) => {
    const m = n?.[h], g = l?.[h];
    if (m === null) return null;
    const b = P1(m) || P1(g);
    return a[h][b];
  }), f = n && Object.entries(n).reduce((h, m) => {
    let [g, b] = m;
    return b === void 0 || (h[g] = b), h;
  }, {}), d = t == null || (o = t.compoundVariants) === null || o === void 0 ? void 0 : o.reduce((h, m) => {
    let { class: g, className: b, ...x } = m;
    return Object.entries(x).every((_) => {
      let [E, T] = _;
      return Array.isArray(T) ? T.includes({
        ...l,
        ...f
      }[E]) : {
        ...l,
        ...f
      }[E] === T;
    }) ? [
      ...h,
      g,
      b
    ] : h;
  }, []);
  return L1(e, c, d, n?.class, n?.className);
}, KU = (e, t) => {
  const n = new Array(e.length + t.length);
  for (let o = 0; o < e.length; o++)
    n[o] = e[o];
  for (let o = 0; o < t.length; o++)
    n[e.length + o] = t[o];
  return n;
}, JU = (e, t) => ({
  classGroupId: e,
  validator: t
}), JC = (e = /* @__PURE__ */ new Map(), t = null, n) => ({
  nextPart: e,
  validators: t,
  classGroupId: n
}), lf = "-", I1 = [], QU = "arbitrary..", eB = (e) => {
  const t = nB(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: o
  } = e;
  return {
    getClassGroupId: (c) => {
      if (c.startsWith("[") && c.endsWith("]"))
        return tB(c);
      const f = c.split(lf), d = f[0] === "" && f.length > 1 ? 1 : 0;
      return QC(f, d, t);
    },
    getConflictingClassGroupIds: (c, f) => {
      if (f) {
        const d = o[c], h = n[c];
        return d ? h ? KU(h, d) : d : h || I1;
      }
      return n[c] || I1;
    }
  };
}, QC = (e, t, n) => {
  if (e.length - t === 0)
    return n.classGroupId;
  const a = e[t], l = n.nextPart.get(a);
  if (l) {
    const h = QC(e, t + 1, l);
    if (h) return h;
  }
  const c = n.validators;
  if (c === null)
    return;
  const f = t === 0 ? e.join(lf) : e.slice(t).join(lf), d = c.length;
  for (let h = 0; h < d; h++) {
    const m = c[h];
    if (m.validator(f))
      return m.classGroupId;
  }
}, tB = (e) => e.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const t = e.slice(1, -1), n = t.indexOf(":"), o = t.slice(0, n);
  return o ? QU + o : void 0;
})(), nB = (e) => {
  const {
    theme: t,
    classGroups: n
  } = e;
  return rB(n, t);
}, rB = (e, t) => {
  const n = JC();
  for (const o in e) {
    const a = e[o];
    fv(a, n, o, t);
  }
  return n;
}, fv = (e, t, n, o) => {
  const a = e.length;
  for (let l = 0; l < a; l++) {
    const c = e[l];
    oB(c, t, n, o);
  }
}, oB = (e, t, n, o) => {
  if (typeof e == "string") {
    iB(e, t, n);
    return;
  }
  if (typeof e == "function") {
    aB(e, t, n, o);
    return;
  }
  sB(e, t, n, o);
}, iB = (e, t, n) => {
  const o = e === "" ? t : eA(t, e);
  o.classGroupId = n;
}, aB = (e, t, n, o) => {
  if (lB(e)) {
    fv(e(o), t, n, o);
    return;
  }
  t.validators === null && (t.validators = []), t.validators.push(JU(n, e));
}, sB = (e, t, n, o) => {
  const a = Object.entries(e), l = a.length;
  for (let c = 0; c < l; c++) {
    const [f, d] = a[c];
    fv(d, eA(t, f), n, o);
  }
}, eA = (e, t) => {
  let n = e;
  const o = t.split(lf), a = o.length;
  for (let l = 0; l < a; l++) {
    const c = o[l];
    let f = n.nextPart.get(c);
    f || (f = JC(), n.nextPart.set(c, f)), n = f;
  }
  return n;
}, lB = (e) => "isThemeGetter" in e && e.isThemeGetter === !0, cB = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null);
  const a = (l, c) => {
    n[l] = c, t++, t > e && (t = 0, o = n, n = /* @__PURE__ */ Object.create(null));
  };
  return {
    get(l) {
      let c = n[l];
      if (c !== void 0)
        return c;
      if ((c = o[l]) !== void 0)
        return a(l, c), c;
    },
    set(l, c) {
      l in n ? n[l] = c : a(l, c);
    }
  };
}, tg = "!", V1 = ":", uB = [], U1 = (e, t, n, o, a) => ({
  modifiers: e,
  hasImportantModifier: t,
  baseClassName: n,
  maybePostfixModifierPosition: o,
  isExternal: a
}), fB = (e) => {
  const {
    prefix: t,
    experimentalParseClassName: n
  } = e;
  let o = (a) => {
    const l = [];
    let c = 0, f = 0, d = 0, h;
    const m = a.length;
    for (let E = 0; E < m; E++) {
      const T = a[E];
      if (c === 0 && f === 0) {
        if (T === V1) {
          l.push(a.slice(d, E)), d = E + 1;
          continue;
        }
        if (T === "/") {
          h = E;
          continue;
        }
      }
      T === "[" ? c++ : T === "]" ? c-- : T === "(" ? f++ : T === ")" && f--;
    }
    const g = l.length === 0 ? a : a.slice(d);
    let b = g, x = !1;
    g.endsWith(tg) ? (b = g.slice(0, -1), x = !0) : (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      g.startsWith(tg) && (b = g.slice(1), x = !0)
    );
    const _ = h && h > d ? h - d : void 0;
    return U1(l, x, b, _);
  };
  if (t) {
    const a = t + V1, l = o;
    o = (c) => c.startsWith(a) ? l(c.slice(a.length)) : U1(uB, !1, c, void 0, !0);
  }
  if (n) {
    const a = o;
    o = (l) => n({
      className: l,
      parseClassName: a
    });
  }
  return o;
}, dB = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.orderSensitiveModifiers.forEach((n, o) => {
    t.set(n, 1e6 + o);
  }), (n) => {
    const o = [];
    let a = [];
    for (let l = 0; l < n.length; l++) {
      const c = n[l], f = c[0] === "[", d = t.has(c);
      f || d ? (a.length > 0 && (a.sort(), o.push(...a), a = []), o.push(c)) : a.push(c);
    }
    return a.length > 0 && (a.sort(), o.push(...a)), o;
  };
}, hB = (e) => ({
  cache: cB(e.cacheSize),
  parseClassName: fB(e),
  sortModifiers: dB(e),
  ...eB(e)
}), pB = /\s+/, mB = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: o,
    getConflictingClassGroupIds: a,
    sortModifiers: l
  } = t, c = [], f = e.trim().split(pB);
  let d = "";
  for (let h = f.length - 1; h >= 0; h -= 1) {
    const m = f[h], {
      isExternal: g,
      modifiers: b,
      hasImportantModifier: x,
      baseClassName: _,
      maybePostfixModifierPosition: E
    } = n(m);
    if (g) {
      d = m + (d.length > 0 ? " " + d : d);
      continue;
    }
    let T = !!E, C = o(T ? _.substring(0, E) : _);
    if (!C) {
      if (!T) {
        d = m + (d.length > 0 ? " " + d : d);
        continue;
      }
      if (C = o(_), !C) {
        d = m + (d.length > 0 ? " " + d : d);
        continue;
      }
      T = !1;
    }
    const z = b.length === 0 ? "" : b.length === 1 ? b[0] : l(b).join(":"), A = x ? z + tg : z, R = A + C;
    if (c.indexOf(R) > -1)
      continue;
    c.push(R);
    const O = a(C, T);
    for (let L = 0; L < O.length; ++L) {
      const M = O[L];
      c.push(A + M);
    }
    d = m + (d.length > 0 ? " " + d : d);
  }
  return d;
}, gB = (...e) => {
  let t = 0, n, o, a = "";
  for (; t < e.length; )
    (n = e[t++]) && (o = tA(n)) && (a && (a += " "), a += o);
  return a;
}, tA = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let o = 0; o < e.length; o++)
    e[o] && (t = tA(e[o])) && (n && (n += " "), n += t);
  return n;
}, vB = (e, ...t) => {
  let n, o, a, l;
  const c = (d) => {
    const h = t.reduce((m, g) => g(m), e());
    return n = hB(h), o = n.cache.get, a = n.cache.set, l = f, f(d);
  }, f = (d) => {
    const h = o(d);
    if (h)
      return h;
    const m = mB(d, n);
    return a(d, m), m;
  };
  return l = c, (...d) => l(gB(...d));
}, yB = [], Rt = (e) => {
  const t = (n) => n[e] || yB;
  return t.isThemeGetter = !0, t;
}, nA = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, rA = /^\((?:(\w[\w-]*):)?(.+)\)$/i, bB = /^\d+\/\d+$/, xB = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, SB = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, wB = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, EB = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, _B = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, da = (e) => bB.test(e), Ne = (e) => !!e && !Number.isNaN(Number(e)), Eo = (e) => !!e && Number.isInteger(Number(e)), rm = (e) => e.endsWith("%") && Ne(e.slice(0, -1)), Br = (e) => xB.test(e), TB = () => !0, CB = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  SB.test(e) && !wB.test(e)
), oA = () => !1, AB = (e) => EB.test(e), RB = (e) => _B.test(e), MB = (e) => !ge(e) && !ve(e), zB = (e) => Za(e, sA, oA), ge = (e) => nA.test(e), si = (e) => Za(e, lA, CB), om = (e) => Za(e, kB, Ne), B1 = (e) => Za(e, iA, oA), DB = (e) => Za(e, aA, RB), bu = (e) => Za(e, cA, AB), ve = (e) => rA.test(e), qs = (e) => Fa(e, lA), NB = (e) => Fa(e, PB), $1 = (e) => Fa(e, iA), OB = (e) => Fa(e, sA), jB = (e) => Fa(e, aA), xu = (e) => Fa(e, cA, !0), Za = (e, t, n) => {
  const o = nA.exec(e);
  return o ? o[1] ? t(o[1]) : n(o[2]) : !1;
}, Fa = (e, t, n = !1) => {
  const o = rA.exec(e);
  return o ? o[1] ? t(o[1]) : n : !1;
}, iA = (e) => e === "position" || e === "percentage", aA = (e) => e === "image" || e === "url", sA = (e) => e === "length" || e === "size" || e === "bg-size", lA = (e) => e === "length", kB = (e) => e === "number", PB = (e) => e === "family-name", cA = (e) => e === "shadow", LB = () => {
  const e = Rt("color"), t = Rt("font"), n = Rt("text"), o = Rt("font-weight"), a = Rt("tracking"), l = Rt("leading"), c = Rt("breakpoint"), f = Rt("container"), d = Rt("spacing"), h = Rt("radius"), m = Rt("shadow"), g = Rt("inset-shadow"), b = Rt("text-shadow"), x = Rt("drop-shadow"), _ = Rt("blur"), E = Rt("perspective"), T = Rt("aspect"), C = Rt("ease"), z = Rt("animate"), A = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], R = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], O = () => [...R(), ve, ge], L = () => ["auto", "hidden", "clip", "visible", "scroll"], M = () => ["auto", "contain", "none"], N = () => [ve, ge, d], j = () => [da, "full", "auto", ...N()], Y = () => [Eo, "none", "subgrid", ve, ge], ne = () => ["auto", {
    span: ["full", Eo, ve, ge]
  }, Eo, ve, ge], J = () => [Eo, "auto", ve, ge], he = () => ["auto", "min", "max", "fr", ve, ge], fe = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], de = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], I = () => ["auto", ...N()], G = () => [da, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...N()], B = () => [e, ve, ge], te = () => [...R(), $1, B1, {
    position: [ve, ge]
  }], ae = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], k = () => ["auto", "cover", "contain", OB, zB, {
    size: [ve, ge]
  }], X = () => [rm, qs, si], H = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    h,
    ve,
    ge
  ], K = () => ["", Ne, qs, si], le = () => ["solid", "dashed", "dotted", "double"], se = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], U = () => [Ne, rm, $1, B1], ie = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    _,
    ve,
    ge
  ], ce = () => ["none", Ne, ve, ge], ue = () => ["none", Ne, ve, ge], _e = () => [Ne, ve, ge], ze = () => [da, "full", ...N()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [Br],
      breakpoint: [Br],
      color: [TB],
      container: [Br],
      "drop-shadow": [Br],
      ease: ["in", "out", "in-out"],
      font: [MB],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [Br],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [Br],
      shadow: [Br],
      spacing: ["px", Ne],
      text: [Br],
      "text-shadow": [Br],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", da, ge, ve, T]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Ne, ge, ve, f]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": A()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": A()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: O()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: L()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": L()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": L()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: M()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": M()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": M()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: j()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": j()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": j()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: j()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: j()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: j()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: j()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: j()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: j()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [Eo, "auto", ve, ge]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [da, "full", "auto", f, ...N()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [Ne, da, "auto", "initial", "none", ge]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", Ne, ve, ge]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", Ne, ve, ge]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [Eo, "first", "last", "none", ve, ge]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": Y()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ne()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": J()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": J()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": Y()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ne()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": J()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": J()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": he()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": he()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: N()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": N()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": N()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...fe(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...de(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...de()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...fe()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...de(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...de(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": fe()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...de(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...de()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: N()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: N()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: N()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: N()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: N()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: N()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: N()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: N()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: N()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: I()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: I()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: I()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: I()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: I()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: I()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: I()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: I()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: I()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": N()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": N()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: G()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [f, "screen", ...G()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          f,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...G()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          f,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [c]
          },
          ...G()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...G()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...G()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...G()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", n, qs, si]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [o, ve, om]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", rm, ge]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [NB, ge, t]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [a, ve, ge]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [Ne, "none", ve, om]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          l,
          ...N()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ve, ge]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", ve, ge]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: B()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: B()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...le(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [Ne, "from-font", "auto", ve, si]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: B()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [Ne, "auto", ve, ge]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: N()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ve, ge]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ve, ge]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: te()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ae()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: k()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, Eo, ve, ge],
          radial: ["", ve, ge],
          conic: [Eo, ve, ge]
        }, jB, DB]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: B()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: X()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: X()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: X()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: B()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: B()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: B()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: H()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": H()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": H()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": H()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": H()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": H()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": H()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": H()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": H()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": H()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": H()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": H()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": H()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": H()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": H()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: K()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": K()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": K()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": K()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": K()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": K()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": K()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": K()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": K()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": K()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": K()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...le(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...le(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: B()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": B()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": B()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": B()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": B()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": B()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": B()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": B()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": B()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: B()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...le(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Ne, ve, ge]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", Ne, qs, si]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: B()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          m,
          xu,
          bu
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: B()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", g, xu, bu]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": B()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: K()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: B()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [Ne, si]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": B()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": K()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": B()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", b, xu, bu]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": B()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [Ne, ve, ge]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...se(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": se()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [Ne]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": U()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": U()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": B()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": B()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": U()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": U()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": B()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": B()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": U()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": U()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": B()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": B()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": U()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": U()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": B()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": B()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": U()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": U()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": B()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": B()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": U()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": U()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": B()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": B()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": U()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": U()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": B()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": B()
      }],
      "mask-image-radial": [{
        "mask-radial": [ve, ge]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": U()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": U()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": B()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": B()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": R()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [Ne]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": U()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": U()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": B()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": B()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: te()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: ae()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: k()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", ve, ge]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          ve,
          ge
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: ie()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [Ne, ve, ge]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [Ne, ve, ge]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          x,
          xu,
          bu
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": B()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", Ne, ve, ge]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [Ne, ve, ge]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", Ne, ve, ge]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [Ne, ve, ge]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", Ne, ve, ge]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          ve,
          ge
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": ie()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [Ne, ve, ge]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [Ne, ve, ge]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", Ne, ve, ge]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [Ne, ve, ge]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", Ne, ve, ge]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [Ne, ve, ge]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [Ne, ve, ge]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", Ne, ve, ge]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": N()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": N()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": N()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", ve, ge]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [Ne, "initial", ve, ge]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", C, ve, ge]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [Ne, ve, ge]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", z, ve, ge]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [E, ve, ge]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": O()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: ce()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": ce()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": ce()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": ce()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: ue()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": ue()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": ue()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": ue()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: _e()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": _e()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": _e()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [ve, ge, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: O()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: ze()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": ze()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": ze()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": ze()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: B()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: B()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ve, ge]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": N()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": N()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": N()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": N()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": N()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": N()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": N()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": N()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": N()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": N()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": N()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": N()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": N()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": N()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": N()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": N()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": N()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": N()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ve, ge]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...B()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Ne, qs, si, om]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...B()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, IB = /* @__PURE__ */ vB(LB);
function Fe(...e) {
  return IB(WC(e));
}
function VB({ className: e, ...t }) {
  return /* @__PURE__ */ S.jsx(
    e2,
    {
      role: "status",
      "aria-label": "Loading",
      className: Fe("size-4 animate-spin", e),
      ...t
    }
  );
}
const UB = KC(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
function Dt({
  className: e,
  variant: t,
  size: n,
  asChild: o = !1,
  isLoading: a = !1,
  ...l
}) {
  const c = o ? qC : "button";
  return /* @__PURE__ */ S.jsxs(
    c,
    {
      "data-slot": "button",
      className: Fe(UB({ variant: t, size: n, className: e })),
      ...l,
      children: [
        l.children,
        " ",
        a && /* @__PURE__ */ S.jsx(VB, {})
      ]
    }
  );
}
function pe(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(a) {
    if (e?.(a), n === !1 || !a.defaultPrevented)
      return t?.(a);
  };
}
function BB(e, t) {
  const n = y.createContext(t), o = (l) => {
    const { children: c, ...f } = l, d = y.useMemo(() => f, Object.values(f));
    return /* @__PURE__ */ S.jsx(n.Provider, { value: d, children: c });
  };
  o.displayName = e + "Provider";
  function a(l) {
    const c = y.useContext(n);
    if (c) return c;
    if (t !== void 0) return t;
    throw new Error(`\`${l}\` must be used within \`${e}\``);
  }
  return [o, a];
}
function yr(e, t = []) {
  let n = [];
  function o(l, c) {
    const f = y.createContext(c), d = n.length;
    n = [...n, c];
    const h = (g) => {
      const { scope: b, children: x, ..._ } = g, E = b?.[e]?.[d] || f, T = y.useMemo(() => _, Object.values(_));
      return /* @__PURE__ */ S.jsx(E.Provider, { value: T, children: x });
    };
    h.displayName = l + "Provider";
    function m(g, b) {
      const x = b?.[e]?.[d] || f, _ = y.useContext(x);
      if (_) return _;
      if (c !== void 0) return c;
      throw new Error(`\`${g}\` must be used within \`${l}\``);
    }
    return [h, m];
  }
  const a = () => {
    const l = n.map((c) => y.createContext(c));
    return function(f) {
      const d = f?.[e] || l;
      return y.useMemo(
        () => ({ [`__scope${e}`]: { ...f, [e]: d } }),
        [f, d]
      );
    };
  };
  return a.scopeName = e, [o, $B(a, ...t)];
}
function $B(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const o = e.map((a) => ({
      useScope: a(),
      scopeName: a.scopeName
    }));
    return function(l) {
      const c = o.reduce((f, { useScope: d, scopeName: h }) => {
        const g = d(l)[`__scope${h}`];
        return { ...f, ...g };
      }, {});
      return y.useMemo(() => ({ [`__scope${t.scopeName}`]: c }), [c]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
// @__NO_SIDE_EFFECTS__
function HB(e) {
  const t = /* @__PURE__ */ ZB(e), n = y.forwardRef((o, a) => {
    const { children: l, ...c } = o, f = y.Children.toArray(l), d = f.find(GB);
    if (d) {
      const h = d.props.children, m = f.map((g) => g === d ? y.Children.count(h) > 1 ? y.Children.only(null) : y.isValidElement(h) ? h.props.children : null : g);
      return /* @__PURE__ */ S.jsx(t, { ...c, ref: a, children: y.isValidElement(h) ? y.cloneElement(h, void 0, m) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...c, ref: a, children: l });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function ZB(e) {
  const t = y.forwardRef((n, o) => {
    const { children: a, ...l } = n;
    if (y.isValidElement(a)) {
      const c = qB(a), f = YB(l, a.props);
      return a.type !== y.Fragment && (f.ref = o ? qr(o, c) : c), y.cloneElement(a, f);
    }
    return y.Children.count(a) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var FB = /* @__PURE__ */ Symbol("radix.slottable");
function GB(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === FB;
}
function YB(e, t) {
  const n = { ...t };
  for (const o in t) {
    const a = e[o], l = t[o];
    /^on[A-Z]/.test(o) ? a && l ? n[o] = (...f) => {
      const d = l(...f);
      return a(...f), d;
    } : a && (n[o] = a) : o === "style" ? n[o] = { ...a, ...l } : o === "className" && (n[o] = [a, l].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function qB(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var XB = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Re = XB.reduce((e, t) => {
  const n = /* @__PURE__ */ HB(`Primitive.${t}`), o = y.forwardRef((a, l) => {
    const { asChild: c, ...f } = a, d = c ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ S.jsx(d, { ...f, ref: l });
  });
  return o.displayName = `Primitive.${t}`, { ...e, [t]: o };
}, {});
function uA(e, t) {
  e && Po.flushSync(() => e.dispatchEvent(t));
}
function $t(e) {
  const t = y.useRef(e);
  return y.useEffect(() => {
    t.current = e;
  }), y.useMemo(() => (...n) => t.current?.(...n), []);
}
function WB(e, t = globalThis?.document) {
  const n = $t(e);
  y.useEffect(() => {
    const o = (a) => {
      a.key === "Escape" && n(a);
    };
    return t.addEventListener("keydown", o, { capture: !0 }), () => t.removeEventListener("keydown", o, { capture: !0 });
  }, [n, t]);
}
var KB = "DismissableLayer", ng = "dismissableLayer.update", JB = "dismissableLayer.pointerDownOutside", QB = "dismissableLayer.focusOutside", H1, fA = y.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Pl = y.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: o,
      onPointerDownOutside: a,
      onFocusOutside: l,
      onInteractOutside: c,
      onDismiss: f,
      ...d
    } = e, h = y.useContext(fA), [m, g] = y.useState(null), b = m?.ownerDocument ?? globalThis?.document, [, x] = y.useState({}), _ = Le(t, (M) => g(M)), E = Array.from(h.layers), [T] = [...h.layersWithOutsidePointerEventsDisabled].slice(-1), C = E.indexOf(T), z = m ? E.indexOf(m) : -1, A = h.layersWithOutsidePointerEventsDisabled.size > 0, R = z >= C, O = n9((M) => {
      const N = M.target, j = [...h.branches].some((Y) => Y.contains(N));
      !R || j || (a?.(M), c?.(M), M.defaultPrevented || f?.());
    }, b), L = r9((M) => {
      const N = M.target;
      [...h.branches].some((Y) => Y.contains(N)) || (l?.(M), c?.(M), M.defaultPrevented || f?.());
    }, b);
    return WB((M) => {
      z === h.layers.size - 1 && (o?.(M), !M.defaultPrevented && f && (M.preventDefault(), f()));
    }, b), y.useEffect(() => {
      if (m)
        return n && (h.layersWithOutsidePointerEventsDisabled.size === 0 && (H1 = b.body.style.pointerEvents, b.body.style.pointerEvents = "none"), h.layersWithOutsidePointerEventsDisabled.add(m)), h.layers.add(m), Z1(), () => {
          n && h.layersWithOutsidePointerEventsDisabled.size === 1 && (b.body.style.pointerEvents = H1);
        };
    }, [m, b, n, h]), y.useEffect(() => () => {
      m && (h.layers.delete(m), h.layersWithOutsidePointerEventsDisabled.delete(m), Z1());
    }, [m, h]), y.useEffect(() => {
      const M = () => x({});
      return document.addEventListener(ng, M), () => document.removeEventListener(ng, M);
    }, []), /* @__PURE__ */ S.jsx(
      Re.div,
      {
        ...d,
        ref: _,
        style: {
          pointerEvents: A ? R ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: pe(e.onFocusCapture, L.onFocusCapture),
        onBlurCapture: pe(e.onBlurCapture, L.onBlurCapture),
        onPointerDownCapture: pe(
          e.onPointerDownCapture,
          O.onPointerDownCapture
        )
      }
    );
  }
);
Pl.displayName = KB;
var e9 = "DismissableLayerBranch", t9 = y.forwardRef((e, t) => {
  const n = y.useContext(fA), o = y.useRef(null), a = Le(t, o);
  return y.useEffect(() => {
    const l = o.current;
    if (l)
      return n.branches.add(l), () => {
        n.branches.delete(l);
      };
  }, [n.branches]), /* @__PURE__ */ S.jsx(Re.div, { ...e, ref: a });
});
t9.displayName = e9;
function n9(e, t = globalThis?.document) {
  const n = $t(e), o = y.useRef(!1), a = y.useRef(() => {
  });
  return y.useEffect(() => {
    const l = (f) => {
      if (f.target && !o.current) {
        let d = function() {
          dA(
            JB,
            n,
            h,
            { discrete: !0 }
          );
        };
        const h = { originalEvent: f };
        f.pointerType === "touch" ? (t.removeEventListener("click", a.current), a.current = d, t.addEventListener("click", a.current, { once: !0 })) : d();
      } else
        t.removeEventListener("click", a.current);
      o.current = !1;
    }, c = window.setTimeout(() => {
      t.addEventListener("pointerdown", l);
    }, 0);
    return () => {
      window.clearTimeout(c), t.removeEventListener("pointerdown", l), t.removeEventListener("click", a.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => o.current = !0
  };
}
function r9(e, t = globalThis?.document) {
  const n = $t(e), o = y.useRef(!1);
  return y.useEffect(() => {
    const a = (l) => {
      l.target && !o.current && dA(QB, n, { originalEvent: l }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", a), () => t.removeEventListener("focusin", a);
  }, [t, n]), {
    onFocusCapture: () => o.current = !0,
    onBlurCapture: () => o.current = !1
  };
}
function Z1() {
  const e = new CustomEvent(ng);
  document.dispatchEvent(e);
}
function dA(e, t, n, { discrete: o }) {
  const a = n.originalEvent.target, l = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && a.addEventListener(e, t, { once: !0 }), o ? uA(a, l) : a.dispatchEvent(l);
}
var Ht = globalThis?.document ? y.useLayoutEffect : () => {
}, o9 = _f[" useId ".trim().toString()] || (() => {
}), i9 = 0;
function hr(e) {
  const [t, n] = y.useState(o9());
  return Ht(() => {
    n((o) => o ?? String(i9++));
  }, [e]), t ? `radix-${t}` : "";
}
const a9 = ["top", "right", "bottom", "left"], jo = Math.min, Sn = Math.max, cf = Math.round, Su = Math.floor, pr = (e) => ({
  x: e,
  y: e
}), s9 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, l9 = {
  start: "end",
  end: "start"
};
function rg(e, t, n) {
  return Sn(e, jo(t, n));
}
function Gr(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Yr(e) {
  return e.split("-")[0];
}
function Ga(e) {
  return e.split("-")[1];
}
function dv(e) {
  return e === "x" ? "y" : "x";
}
function hv(e) {
  return e === "y" ? "height" : "width";
}
const c9 = /* @__PURE__ */ new Set(["top", "bottom"]);
function fr(e) {
  return c9.has(Yr(e)) ? "y" : "x";
}
function pv(e) {
  return dv(fr(e));
}
function u9(e, t, n) {
  n === void 0 && (n = !1);
  const o = Ga(e), a = pv(e), l = hv(a);
  let c = a === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return t.reference[l] > t.floating[l] && (c = uf(c)), [c, uf(c)];
}
function f9(e) {
  const t = uf(e);
  return [og(e), t, og(t)];
}
function og(e) {
  return e.replace(/start|end/g, (t) => l9[t]);
}
const F1 = ["left", "right"], G1 = ["right", "left"], d9 = ["top", "bottom"], h9 = ["bottom", "top"];
function p9(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? G1 : F1 : t ? F1 : G1;
    case "left":
    case "right":
      return t ? d9 : h9;
    default:
      return [];
  }
}
function m9(e, t, n, o) {
  const a = Ga(e);
  let l = p9(Yr(e), n === "start", o);
  return a && (l = l.map((c) => c + "-" + a), t && (l = l.concat(l.map(og)))), l;
}
function uf(e) {
  return e.replace(/left|right|bottom|top/g, (t) => s9[t]);
}
function g9(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function hA(e) {
  return typeof e != "number" ? g9(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function ff(e) {
  const {
    x: t,
    y: n,
    width: o,
    height: a
  } = e;
  return {
    width: o,
    height: a,
    top: n,
    left: t,
    right: t + o,
    bottom: n + a,
    x: t,
    y: n
  };
}
function Y1(e, t, n) {
  let {
    reference: o,
    floating: a
  } = e;
  const l = fr(t), c = pv(t), f = hv(c), d = Yr(t), h = l === "y", m = o.x + o.width / 2 - a.width / 2, g = o.y + o.height / 2 - a.height / 2, b = o[f] / 2 - a[f] / 2;
  let x;
  switch (d) {
    case "top":
      x = {
        x: m,
        y: o.y - a.height
      };
      break;
    case "bottom":
      x = {
        x: m,
        y: o.y + o.height
      };
      break;
    case "right":
      x = {
        x: o.x + o.width,
        y: g
      };
      break;
    case "left":
      x = {
        x: o.x - a.width,
        y: g
      };
      break;
    default:
      x = {
        x: o.x,
        y: o.y
      };
  }
  switch (Ga(t)) {
    case "start":
      x[c] -= b * (n && h ? -1 : 1);
      break;
    case "end":
      x[c] += b * (n && h ? -1 : 1);
      break;
  }
  return x;
}
async function v9(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: o,
    y: a,
    platform: l,
    rects: c,
    elements: f,
    strategy: d
  } = e, {
    boundary: h = "clippingAncestors",
    rootBoundary: m = "viewport",
    elementContext: g = "floating",
    altBoundary: b = !1,
    padding: x = 0
  } = Gr(t, e), _ = hA(x), T = f[b ? g === "floating" ? "reference" : "floating" : g], C = ff(await l.getClippingRect({
    element: (n = await (l.isElement == null ? void 0 : l.isElement(T))) == null || n ? T : T.contextElement || await (l.getDocumentElement == null ? void 0 : l.getDocumentElement(f.floating)),
    boundary: h,
    rootBoundary: m,
    strategy: d
  })), z = g === "floating" ? {
    x: o,
    y: a,
    width: c.floating.width,
    height: c.floating.height
  } : c.reference, A = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(f.floating)), R = await (l.isElement == null ? void 0 : l.isElement(A)) ? await (l.getScale == null ? void 0 : l.getScale(A)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, O = ff(l.convertOffsetParentRelativeRectToViewportRelativeRect ? await l.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: f,
    rect: z,
    offsetParent: A,
    strategy: d
  }) : z);
  return {
    top: (C.top - O.top + _.top) / R.y,
    bottom: (O.bottom - C.bottom + _.bottom) / R.y,
    left: (C.left - O.left + _.left) / R.x,
    right: (O.right - C.right + _.right) / R.x
  };
}
const y9 = async (e, t, n) => {
  const {
    placement: o = "bottom",
    strategy: a = "absolute",
    middleware: l = [],
    platform: c
  } = n, f = l.filter(Boolean), d = await (c.isRTL == null ? void 0 : c.isRTL(t));
  let h = await c.getElementRects({
    reference: e,
    floating: t,
    strategy: a
  }), {
    x: m,
    y: g
  } = Y1(h, o, d), b = o, x = {}, _ = 0;
  for (let T = 0; T < f.length; T++) {
    var E;
    const {
      name: C,
      fn: z
    } = f[T], {
      x: A,
      y: R,
      data: O,
      reset: L
    } = await z({
      x: m,
      y: g,
      initialPlacement: o,
      placement: b,
      strategy: a,
      middlewareData: x,
      rects: h,
      platform: {
        ...c,
        detectOverflow: (E = c.detectOverflow) != null ? E : v9
      },
      elements: {
        reference: e,
        floating: t
      }
    });
    m = A ?? m, g = R ?? g, x = {
      ...x,
      [C]: {
        ...x[C],
        ...O
      }
    }, L && _ <= 50 && (_++, typeof L == "object" && (L.placement && (b = L.placement), L.rects && (h = L.rects === !0 ? await c.getElementRects({
      reference: e,
      floating: t,
      strategy: a
    }) : L.rects), {
      x: m,
      y: g
    } = Y1(h, b, d)), T = -1);
  }
  return {
    x: m,
    y: g,
    placement: b,
    strategy: a,
    middlewareData: x
  };
}, b9 = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: o,
      placement: a,
      rects: l,
      platform: c,
      elements: f,
      middlewareData: d
    } = t, {
      element: h,
      padding: m = 0
    } = Gr(e, t) || {};
    if (h == null)
      return {};
    const g = hA(m), b = {
      x: n,
      y: o
    }, x = pv(a), _ = hv(x), E = await c.getDimensions(h), T = x === "y", C = T ? "top" : "left", z = T ? "bottom" : "right", A = T ? "clientHeight" : "clientWidth", R = l.reference[_] + l.reference[x] - b[x] - l.floating[_], O = b[x] - l.reference[x], L = await (c.getOffsetParent == null ? void 0 : c.getOffsetParent(h));
    let M = L ? L[A] : 0;
    (!M || !await (c.isElement == null ? void 0 : c.isElement(L))) && (M = f.floating[A] || l.floating[_]);
    const N = R / 2 - O / 2, j = M / 2 - E[_] / 2 - 1, Y = jo(g[C], j), ne = jo(g[z], j), J = Y, he = M - E[_] - ne, fe = M / 2 - E[_] / 2 + N, de = rg(J, fe, he), I = !d.arrow && Ga(a) != null && fe !== de && l.reference[_] / 2 - (fe < J ? Y : ne) - E[_] / 2 < 0, G = I ? fe < J ? fe - J : fe - he : 0;
    return {
      [x]: b[x] + G,
      data: {
        [x]: de,
        centerOffset: fe - de - G,
        ...I && {
          alignmentOffset: G
        }
      },
      reset: I
    };
  }
}), x9 = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, o;
      const {
        placement: a,
        middlewareData: l,
        rects: c,
        initialPlacement: f,
        platform: d,
        elements: h
      } = t, {
        mainAxis: m = !0,
        crossAxis: g = !0,
        fallbackPlacements: b,
        fallbackStrategy: x = "bestFit",
        fallbackAxisSideDirection: _ = "none",
        flipAlignment: E = !0,
        ...T
      } = Gr(e, t);
      if ((n = l.arrow) != null && n.alignmentOffset)
        return {};
      const C = Yr(a), z = fr(f), A = Yr(f) === f, R = await (d.isRTL == null ? void 0 : d.isRTL(h.floating)), O = b || (A || !E ? [uf(f)] : f9(f)), L = _ !== "none";
      !b && L && O.push(...m9(f, E, _, R));
      const M = [f, ...O], N = await d.detectOverflow(t, T), j = [];
      let Y = ((o = l.flip) == null ? void 0 : o.overflows) || [];
      if (m && j.push(N[C]), g) {
        const fe = u9(a, c, R);
        j.push(N[fe[0]], N[fe[1]]);
      }
      if (Y = [...Y, {
        placement: a,
        overflows: j
      }], !j.every((fe) => fe <= 0)) {
        var ne, J;
        const fe = (((ne = l.flip) == null ? void 0 : ne.index) || 0) + 1, de = M[fe];
        if (de && (!(g === "alignment" ? z !== fr(de) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        Y.every((B) => fr(B.placement) === z ? B.overflows[0] > 0 : !0)))
          return {
            data: {
              index: fe,
              overflows: Y
            },
            reset: {
              placement: de
            }
          };
        let I = (J = Y.filter((G) => G.overflows[0] <= 0).sort((G, B) => G.overflows[1] - B.overflows[1])[0]) == null ? void 0 : J.placement;
        if (!I)
          switch (x) {
            case "bestFit": {
              var he;
              const G = (he = Y.filter((B) => {
                if (L) {
                  const te = fr(B.placement);
                  return te === z || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  te === "y";
                }
                return !0;
              }).map((B) => [B.placement, B.overflows.filter((te) => te > 0).reduce((te, ae) => te + ae, 0)]).sort((B, te) => B[1] - te[1])[0]) == null ? void 0 : he[0];
              G && (I = G);
              break;
            }
            case "initialPlacement":
              I = f;
              break;
          }
        if (a !== I)
          return {
            reset: {
              placement: I
            }
          };
      }
      return {};
    }
  };
};
function q1(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function X1(e) {
  return a9.some((t) => e[t] >= 0);
}
const S9 = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n,
        platform: o
      } = t, {
        strategy: a = "referenceHidden",
        ...l
      } = Gr(e, t);
      switch (a) {
        case "referenceHidden": {
          const c = await o.detectOverflow(t, {
            ...l,
            elementContext: "reference"
          }), f = q1(c, n.reference);
          return {
            data: {
              referenceHiddenOffsets: f,
              referenceHidden: X1(f)
            }
          };
        }
        case "escaped": {
          const c = await o.detectOverflow(t, {
            ...l,
            altBoundary: !0
          }), f = q1(c, n.floating);
          return {
            data: {
              escapedOffsets: f,
              escaped: X1(f)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, pA = /* @__PURE__ */ new Set(["left", "top"]);
async function w9(e, t) {
  const {
    placement: n,
    platform: o,
    elements: a
  } = e, l = await (o.isRTL == null ? void 0 : o.isRTL(a.floating)), c = Yr(n), f = Ga(n), d = fr(n) === "y", h = pA.has(c) ? -1 : 1, m = l && d ? -1 : 1, g = Gr(t, e);
  let {
    mainAxis: b,
    crossAxis: x,
    alignmentAxis: _
  } = typeof g == "number" ? {
    mainAxis: g,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: g.mainAxis || 0,
    crossAxis: g.crossAxis || 0,
    alignmentAxis: g.alignmentAxis
  };
  return f && typeof _ == "number" && (x = f === "end" ? _ * -1 : _), d ? {
    x: x * m,
    y: b * h
  } : {
    x: b * h,
    y: x * m
  };
}
const E9 = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, o;
      const {
        x: a,
        y: l,
        placement: c,
        middlewareData: f
      } = t, d = await w9(t, e);
      return c === ((n = f.offset) == null ? void 0 : n.placement) && (o = f.arrow) != null && o.alignmentOffset ? {} : {
        x: a + d.x,
        y: l + d.y,
        data: {
          ...d,
          placement: c
        }
      };
    }
  };
}, _9 = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: o,
        placement: a,
        platform: l
      } = t, {
        mainAxis: c = !0,
        crossAxis: f = !1,
        limiter: d = {
          fn: (C) => {
            let {
              x: z,
              y: A
            } = C;
            return {
              x: z,
              y: A
            };
          }
        },
        ...h
      } = Gr(e, t), m = {
        x: n,
        y: o
      }, g = await l.detectOverflow(t, h), b = fr(Yr(a)), x = dv(b);
      let _ = m[x], E = m[b];
      if (c) {
        const C = x === "y" ? "top" : "left", z = x === "y" ? "bottom" : "right", A = _ + g[C], R = _ - g[z];
        _ = rg(A, _, R);
      }
      if (f) {
        const C = b === "y" ? "top" : "left", z = b === "y" ? "bottom" : "right", A = E + g[C], R = E - g[z];
        E = rg(A, E, R);
      }
      const T = d.fn({
        ...t,
        [x]: _,
        [b]: E
      });
      return {
        ...T,
        data: {
          x: T.x - n,
          y: T.y - o,
          enabled: {
            [x]: c,
            [b]: f
          }
        }
      };
    }
  };
}, T9 = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: o,
        placement: a,
        rects: l,
        middlewareData: c
      } = t, {
        offset: f = 0,
        mainAxis: d = !0,
        crossAxis: h = !0
      } = Gr(e, t), m = {
        x: n,
        y: o
      }, g = fr(a), b = dv(g);
      let x = m[b], _ = m[g];
      const E = Gr(f, t), T = typeof E == "number" ? {
        mainAxis: E,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...E
      };
      if (d) {
        const A = b === "y" ? "height" : "width", R = l.reference[b] - l.floating[A] + T.mainAxis, O = l.reference[b] + l.reference[A] - T.mainAxis;
        x < R ? x = R : x > O && (x = O);
      }
      if (h) {
        var C, z;
        const A = b === "y" ? "width" : "height", R = pA.has(Yr(a)), O = l.reference[g] - l.floating[A] + (R && ((C = c.offset) == null ? void 0 : C[g]) || 0) + (R ? 0 : T.crossAxis), L = l.reference[g] + l.reference[A] + (R ? 0 : ((z = c.offset) == null ? void 0 : z[g]) || 0) - (R ? T.crossAxis : 0);
        _ < O ? _ = O : _ > L && (_ = L);
      }
      return {
        [b]: x,
        [g]: _
      };
    }
  };
}, C9 = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, o;
      const {
        placement: a,
        rects: l,
        platform: c,
        elements: f
      } = t, {
        apply: d = () => {
        },
        ...h
      } = Gr(e, t), m = await c.detectOverflow(t, h), g = Yr(a), b = Ga(a), x = fr(a) === "y", {
        width: _,
        height: E
      } = l.floating;
      let T, C;
      g === "top" || g === "bottom" ? (T = g, C = b === (await (c.isRTL == null ? void 0 : c.isRTL(f.floating)) ? "start" : "end") ? "left" : "right") : (C = g, T = b === "end" ? "top" : "bottom");
      const z = E - m.top - m.bottom, A = _ - m.left - m.right, R = jo(E - m[T], z), O = jo(_ - m[C], A), L = !t.middlewareData.shift;
      let M = R, N = O;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (N = A), (o = t.middlewareData.shift) != null && o.enabled.y && (M = z), L && !b) {
        const Y = Sn(m.left, 0), ne = Sn(m.right, 0), J = Sn(m.top, 0), he = Sn(m.bottom, 0);
        x ? N = _ - 2 * (Y !== 0 || ne !== 0 ? Y + ne : Sn(m.left, m.right)) : M = E - 2 * (J !== 0 || he !== 0 ? J + he : Sn(m.top, m.bottom));
      }
      await d({
        ...t,
        availableWidth: N,
        availableHeight: M
      });
      const j = await c.getDimensions(f.floating);
      return _ !== j.width || E !== j.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Pf() {
  return typeof window < "u";
}
function Ya(e) {
  return mA(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function wn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function br(e) {
  var t;
  return (t = (mA(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function mA(e) {
  return Pf() ? e instanceof Node || e instanceof wn(e).Node : !1;
}
function Qn(e) {
  return Pf() ? e instanceof Element || e instanceof wn(e).Element : !1;
}
function vr(e) {
  return Pf() ? e instanceof HTMLElement || e instanceof wn(e).HTMLElement : !1;
}
function W1(e) {
  return !Pf() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof wn(e).ShadowRoot;
}
const A9 = /* @__PURE__ */ new Set(["inline", "contents"]);
function Ll(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: o,
    display: a
  } = er(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !A9.has(a);
}
const R9 = /* @__PURE__ */ new Set(["table", "td", "th"]);
function M9(e) {
  return R9.has(Ya(e));
}
const z9 = [":popover-open", ":modal"];
function Lf(e) {
  return z9.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const D9 = ["transform", "translate", "scale", "rotate", "perspective"], N9 = ["transform", "translate", "scale", "rotate", "perspective", "filter"], O9 = ["paint", "layout", "strict", "content"];
function mv(e) {
  const t = gv(), n = Qn(e) ? er(e) : e;
  return D9.some((o) => n[o] ? n[o] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || N9.some((o) => (n.willChange || "").includes(o)) || O9.some((o) => (n.contain || "").includes(o));
}
function j9(e) {
  let t = ko(e);
  for (; vr(t) && !Pa(t); ) {
    if (mv(t))
      return t;
    if (Lf(t))
      return null;
    t = ko(t);
  }
  return null;
}
function gv() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const k9 = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Pa(e) {
  return k9.has(Ya(e));
}
function er(e) {
  return wn(e).getComputedStyle(e);
}
function If(e) {
  return Qn(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function ko(e) {
  if (Ya(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    W1(e) && e.host || // Fallback.
    br(e)
  );
  return W1(t) ? t.host : t;
}
function gA(e) {
  const t = ko(e);
  return Pa(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : vr(t) && Ll(t) ? t : gA(t);
}
function wl(e, t, n) {
  var o;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const a = gA(e), l = a === ((o = e.ownerDocument) == null ? void 0 : o.body), c = wn(a);
  if (l) {
    const f = ig(c);
    return t.concat(c, c.visualViewport || [], Ll(a) ? a : [], f && n ? wl(f) : []);
  }
  return t.concat(a, wl(a, [], n));
}
function ig(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function vA(e) {
  const t = er(e);
  let n = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0;
  const a = vr(e), l = a ? e.offsetWidth : n, c = a ? e.offsetHeight : o, f = cf(n) !== l || cf(o) !== c;
  return f && (n = l, o = c), {
    width: n,
    height: o,
    $: f
  };
}
function vv(e) {
  return Qn(e) ? e : e.contextElement;
}
function za(e) {
  const t = vv(e);
  if (!vr(t))
    return pr(1);
  const n = t.getBoundingClientRect(), {
    width: o,
    height: a,
    $: l
  } = vA(t);
  let c = (l ? cf(n.width) : n.width) / o, f = (l ? cf(n.height) : n.height) / a;
  return (!c || !Number.isFinite(c)) && (c = 1), (!f || !Number.isFinite(f)) && (f = 1), {
    x: c,
    y: f
  };
}
const P9 = /* @__PURE__ */ pr(0);
function yA(e) {
  const t = wn(e);
  return !gv() || !t.visualViewport ? P9 : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function L9(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== wn(e) ? !1 : t;
}
function gi(e, t, n, o) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const a = e.getBoundingClientRect(), l = vv(e);
  let c = pr(1);
  t && (o ? Qn(o) && (c = za(o)) : c = za(e));
  const f = L9(l, n, o) ? yA(l) : pr(0);
  let d = (a.left + f.x) / c.x, h = (a.top + f.y) / c.y, m = a.width / c.x, g = a.height / c.y;
  if (l) {
    const b = wn(l), x = o && Qn(o) ? wn(o) : o;
    let _ = b, E = ig(_);
    for (; E && o && x !== _; ) {
      const T = za(E), C = E.getBoundingClientRect(), z = er(E), A = C.left + (E.clientLeft + parseFloat(z.paddingLeft)) * T.x, R = C.top + (E.clientTop + parseFloat(z.paddingTop)) * T.y;
      d *= T.x, h *= T.y, m *= T.x, g *= T.y, d += A, h += R, _ = wn(E), E = ig(_);
    }
  }
  return ff({
    width: m,
    height: g,
    x: d,
    y: h
  });
}
function Vf(e, t) {
  const n = If(e).scrollLeft;
  return t ? t.left + n : gi(br(e)).left + n;
}
function bA(e, t) {
  const n = e.getBoundingClientRect(), o = n.left + t.scrollLeft - Vf(e, n), a = n.top + t.scrollTop;
  return {
    x: o,
    y: a
  };
}
function I9(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: o,
    strategy: a
  } = e;
  const l = a === "fixed", c = br(o), f = t ? Lf(t.floating) : !1;
  if (o === c || f && l)
    return n;
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  }, h = pr(1);
  const m = pr(0), g = vr(o);
  if ((g || !g && !l) && ((Ya(o) !== "body" || Ll(c)) && (d = If(o)), vr(o))) {
    const x = gi(o);
    h = za(o), m.x = x.x + o.clientLeft, m.y = x.y + o.clientTop;
  }
  const b = c && !g && !l ? bA(c, d) : pr(0);
  return {
    width: n.width * h.x,
    height: n.height * h.y,
    x: n.x * h.x - d.scrollLeft * h.x + m.x + b.x,
    y: n.y * h.y - d.scrollTop * h.y + m.y + b.y
  };
}
function V9(e) {
  return Array.from(e.getClientRects());
}
function U9(e) {
  const t = br(e), n = If(e), o = e.ownerDocument.body, a = Sn(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), l = Sn(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
  let c = -n.scrollLeft + Vf(e);
  const f = -n.scrollTop;
  return er(o).direction === "rtl" && (c += Sn(t.clientWidth, o.clientWidth) - a), {
    width: a,
    height: l,
    x: c,
    y: f
  };
}
const K1 = 25;
function B9(e, t) {
  const n = wn(e), o = br(e), a = n.visualViewport;
  let l = o.clientWidth, c = o.clientHeight, f = 0, d = 0;
  if (a) {
    l = a.width, c = a.height;
    const m = gv();
    (!m || m && t === "fixed") && (f = a.offsetLeft, d = a.offsetTop);
  }
  const h = Vf(o);
  if (h <= 0) {
    const m = o.ownerDocument, g = m.body, b = getComputedStyle(g), x = m.compatMode === "CSS1Compat" && parseFloat(b.marginLeft) + parseFloat(b.marginRight) || 0, _ = Math.abs(o.clientWidth - g.clientWidth - x);
    _ <= K1 && (l -= _);
  } else h <= K1 && (l += h);
  return {
    width: l,
    height: c,
    x: f,
    y: d
  };
}
const $9 = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function H9(e, t) {
  const n = gi(e, !0, t === "fixed"), o = n.top + e.clientTop, a = n.left + e.clientLeft, l = vr(e) ? za(e) : pr(1), c = e.clientWidth * l.x, f = e.clientHeight * l.y, d = a * l.x, h = o * l.y;
  return {
    width: c,
    height: f,
    x: d,
    y: h
  };
}
function J1(e, t, n) {
  let o;
  if (t === "viewport")
    o = B9(e, n);
  else if (t === "document")
    o = U9(br(e));
  else if (Qn(t))
    o = H9(t, n);
  else {
    const a = yA(e);
    o = {
      x: t.x - a.x,
      y: t.y - a.y,
      width: t.width,
      height: t.height
    };
  }
  return ff(o);
}
function xA(e, t) {
  const n = ko(e);
  return n === t || !Qn(n) || Pa(n) ? !1 : er(n).position === "fixed" || xA(n, t);
}
function Z9(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let o = wl(e, [], !1).filter((f) => Qn(f) && Ya(f) !== "body"), a = null;
  const l = er(e).position === "fixed";
  let c = l ? ko(e) : e;
  for (; Qn(c) && !Pa(c); ) {
    const f = er(c), d = mv(c);
    !d && f.position === "fixed" && (a = null), (l ? !d && !a : !d && f.position === "static" && !!a && $9.has(a.position) || Ll(c) && !d && xA(e, c)) ? o = o.filter((m) => m !== c) : a = f, c = ko(c);
  }
  return t.set(e, o), o;
}
function F9(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: o,
    strategy: a
  } = e;
  const c = [...n === "clippingAncestors" ? Lf(t) ? [] : Z9(t, this._c) : [].concat(n), o], f = c[0], d = c.reduce((h, m) => {
    const g = J1(t, m, a);
    return h.top = Sn(g.top, h.top), h.right = jo(g.right, h.right), h.bottom = jo(g.bottom, h.bottom), h.left = Sn(g.left, h.left), h;
  }, J1(t, f, a));
  return {
    width: d.right - d.left,
    height: d.bottom - d.top,
    x: d.left,
    y: d.top
  };
}
function G9(e) {
  const {
    width: t,
    height: n
  } = vA(e);
  return {
    width: t,
    height: n
  };
}
function Y9(e, t, n) {
  const o = vr(t), a = br(t), l = n === "fixed", c = gi(e, !0, l, t);
  let f = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const d = pr(0);
  function h() {
    d.x = Vf(a);
  }
  if (o || !o && !l)
    if ((Ya(t) !== "body" || Ll(a)) && (f = If(t)), o) {
      const x = gi(t, !0, l, t);
      d.x = x.x + t.clientLeft, d.y = x.y + t.clientTop;
    } else a && h();
  l && !o && a && h();
  const m = a && !o && !l ? bA(a, f) : pr(0), g = c.left + f.scrollLeft - d.x - m.x, b = c.top + f.scrollTop - d.y - m.y;
  return {
    x: g,
    y: b,
    width: c.width,
    height: c.height
  };
}
function im(e) {
  return er(e).position === "static";
}
function Q1(e, t) {
  if (!vr(e) || er(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return br(e) === n && (n = n.ownerDocument.body), n;
}
function SA(e, t) {
  const n = wn(e);
  if (Lf(e))
    return n;
  if (!vr(e)) {
    let a = ko(e);
    for (; a && !Pa(a); ) {
      if (Qn(a) && !im(a))
        return a;
      a = ko(a);
    }
    return n;
  }
  let o = Q1(e, t);
  for (; o && M9(o) && im(o); )
    o = Q1(o, t);
  return o && Pa(o) && im(o) && !mv(o) ? n : o || j9(e) || n;
}
const q9 = async function(e) {
  const t = this.getOffsetParent || SA, n = this.getDimensions, o = await n(e.floating);
  return {
    reference: Y9(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height
    }
  };
};
function X9(e) {
  return er(e).direction === "rtl";
}
const W9 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: I9,
  getDocumentElement: br,
  getClippingRect: F9,
  getOffsetParent: SA,
  getElementRects: q9,
  getClientRects: V9,
  getDimensions: G9,
  getScale: za,
  isElement: Qn,
  isRTL: X9
};
function wA(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function K9(e, t) {
  let n = null, o;
  const a = br(e);
  function l() {
    var f;
    clearTimeout(o), (f = n) == null || f.disconnect(), n = null;
  }
  function c(f, d) {
    f === void 0 && (f = !1), d === void 0 && (d = 1), l();
    const h = e.getBoundingClientRect(), {
      left: m,
      top: g,
      width: b,
      height: x
    } = h;
    if (f || t(), !b || !x)
      return;
    const _ = Su(g), E = Su(a.clientWidth - (m + b)), T = Su(a.clientHeight - (g + x)), C = Su(m), A = {
      rootMargin: -_ + "px " + -E + "px " + -T + "px " + -C + "px",
      threshold: Sn(0, jo(1, d)) || 1
    };
    let R = !0;
    function O(L) {
      const M = L[0].intersectionRatio;
      if (M !== d) {
        if (!R)
          return c();
        M ? c(!1, M) : o = setTimeout(() => {
          c(!1, 1e-7);
        }, 1e3);
      }
      M === 1 && !wA(h, e.getBoundingClientRect()) && c(), R = !1;
    }
    try {
      n = new IntersectionObserver(O, {
        ...A,
        // Handle <iframe>s
        root: a.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(O, A);
    }
    n.observe(e);
  }
  return c(!0), l;
}
function J9(e, t, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: a = !0,
    ancestorResize: l = !0,
    elementResize: c = typeof ResizeObserver == "function",
    layoutShift: f = typeof IntersectionObserver == "function",
    animationFrame: d = !1
  } = o, h = vv(e), m = a || l ? [...h ? wl(h) : [], ...wl(t)] : [];
  m.forEach((C) => {
    a && C.addEventListener("scroll", n, {
      passive: !0
    }), l && C.addEventListener("resize", n);
  });
  const g = h && f ? K9(h, n) : null;
  let b = -1, x = null;
  c && (x = new ResizeObserver((C) => {
    let [z] = C;
    z && z.target === h && x && (x.unobserve(t), cancelAnimationFrame(b), b = requestAnimationFrame(() => {
      var A;
      (A = x) == null || A.observe(t);
    })), n();
  }), h && !d && x.observe(h), x.observe(t));
  let _, E = d ? gi(e) : null;
  d && T();
  function T() {
    const C = gi(e);
    E && !wA(E, C) && n(), E = C, _ = requestAnimationFrame(T);
  }
  return n(), () => {
    var C;
    m.forEach((z) => {
      a && z.removeEventListener("scroll", n), l && z.removeEventListener("resize", n);
    }), g?.(), (C = x) == null || C.disconnect(), x = null, d && cancelAnimationFrame(_);
  };
}
const Q9 = E9, e$ = _9, t$ = x9, n$ = C9, r$ = S9, eE = b9, o$ = T9, i$ = (e, t, n) => {
  const o = /* @__PURE__ */ new Map(), a = {
    platform: W9,
    ...n
  }, l = {
    ...a.platform,
    _c: o
  };
  return y9(e, t, {
    ...a,
    platform: l
  });
};
var a$ = typeof document < "u", s$ = function() {
}, Pu = a$ ? y.useLayoutEffect : s$;
function df(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, o, a;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (o = n; o-- !== 0; )
        if (!df(e[o], t[o]))
          return !1;
      return !0;
    }
    if (a = Object.keys(e), n = a.length, n !== Object.keys(t).length)
      return !1;
    for (o = n; o-- !== 0; )
      if (!{}.hasOwnProperty.call(t, a[o]))
        return !1;
    for (o = n; o-- !== 0; ) {
      const l = a[o];
      if (!(l === "_owner" && e.$$typeof) && !df(e[l], t[l]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function EA(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function tE(e, t) {
  const n = EA(e);
  return Math.round(t * n) / n;
}
function am(e) {
  const t = y.useRef(e);
  return Pu(() => {
    t.current = e;
  }), t;
}
function l$(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: o = [],
    platform: a,
    elements: {
      reference: l,
      floating: c
    } = {},
    transform: f = !0,
    whileElementsMounted: d,
    open: h
  } = e, [m, g] = y.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [b, x] = y.useState(o);
  df(b, o) || x(o);
  const [_, E] = y.useState(null), [T, C] = y.useState(null), z = y.useCallback((B) => {
    B !== L.current && (L.current = B, E(B));
  }, []), A = y.useCallback((B) => {
    B !== M.current && (M.current = B, C(B));
  }, []), R = l || _, O = c || T, L = y.useRef(null), M = y.useRef(null), N = y.useRef(m), j = d != null, Y = am(d), ne = am(a), J = am(h), he = y.useCallback(() => {
    if (!L.current || !M.current)
      return;
    const B = {
      placement: t,
      strategy: n,
      middleware: b
    };
    ne.current && (B.platform = ne.current), i$(L.current, M.current, B).then((te) => {
      const ae = {
        ...te,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: J.current !== !1
      };
      fe.current && !df(N.current, ae) && (N.current = ae, Po.flushSync(() => {
        g(ae);
      }));
    });
  }, [b, t, n, ne, J]);
  Pu(() => {
    h === !1 && N.current.isPositioned && (N.current.isPositioned = !1, g((B) => ({
      ...B,
      isPositioned: !1
    })));
  }, [h]);
  const fe = y.useRef(!1);
  Pu(() => (fe.current = !0, () => {
    fe.current = !1;
  }), []), Pu(() => {
    if (R && (L.current = R), O && (M.current = O), R && O) {
      if (Y.current)
        return Y.current(R, O, he);
      he();
    }
  }, [R, O, he, Y, j]);
  const de = y.useMemo(() => ({
    reference: L,
    floating: M,
    setReference: z,
    setFloating: A
  }), [z, A]), I = y.useMemo(() => ({
    reference: R,
    floating: O
  }), [R, O]), G = y.useMemo(() => {
    const B = {
      position: n,
      left: 0,
      top: 0
    };
    if (!I.floating)
      return B;
    const te = tE(I.floating, m.x), ae = tE(I.floating, m.y);
    return f ? {
      ...B,
      transform: "translate(" + te + "px, " + ae + "px)",
      ...EA(I.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: te,
      top: ae
    };
  }, [n, f, I.floating, m.x, m.y]);
  return y.useMemo(() => ({
    ...m,
    update: he,
    refs: de,
    elements: I,
    floatingStyles: G
  }), [m, he, de, I, G]);
}
const c$ = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: o,
        padding: a
      } = typeof e == "function" ? e(n) : e;
      return o && t(o) ? o.current != null ? eE({
        element: o.current,
        padding: a
      }).fn(n) : {} : o ? eE({
        element: o,
        padding: a
      }).fn(n) : {};
    }
  };
}, u$ = (e, t) => ({
  ...Q9(e),
  options: [e, t]
}), f$ = (e, t) => ({
  ...e$(e),
  options: [e, t]
}), d$ = (e, t) => ({
  ...o$(e),
  options: [e, t]
}), h$ = (e, t) => ({
  ...t$(e),
  options: [e, t]
}), p$ = (e, t) => ({
  ...n$(e),
  options: [e, t]
}), m$ = (e, t) => ({
  ...r$(e),
  options: [e, t]
}), g$ = (e, t) => ({
  ...c$(e),
  options: [e, t]
});
var v$ = "Arrow", _A = y.forwardRef((e, t) => {
  const { children: n, width: o = 10, height: a = 5, ...l } = e;
  return /* @__PURE__ */ S.jsx(
    Re.svg,
    {
      ...l,
      ref: t,
      width: o,
      height: a,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ S.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
_A.displayName = v$;
var y$ = _A;
function TA(e) {
  const [t, n] = y.useState(void 0);
  return Ht(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const o = new ResizeObserver((a) => {
        if (!Array.isArray(a) || !a.length)
          return;
        const l = a[0];
        let c, f;
        if ("borderBoxSize" in l) {
          const d = l.borderBoxSize, h = Array.isArray(d) ? d[0] : d;
          c = h.inlineSize, f = h.blockSize;
        } else
          c = e.offsetWidth, f = e.offsetHeight;
        n({ width: c, height: f });
      });
      return o.observe(e, { box: "border-box" }), () => o.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var yv = "Popper", [CA, qa] = yr(yv), [b$, AA] = CA(yv), RA = (e) => {
  const { __scopePopper: t, children: n } = e, [o, a] = y.useState(null);
  return /* @__PURE__ */ S.jsx(b$, { scope: t, anchor: o, onAnchorChange: a, children: n });
};
RA.displayName = yv;
var MA = "PopperAnchor", zA = y.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: o, ...a } = e, l = AA(MA, n), c = y.useRef(null), f = Le(t, c), d = y.useRef(null);
    return y.useEffect(() => {
      const h = d.current;
      d.current = o?.current || c.current, h !== d.current && l.onAnchorChange(d.current);
    }), o ? null : /* @__PURE__ */ S.jsx(Re.div, { ...a, ref: f });
  }
);
zA.displayName = MA;
var bv = "PopperContent", [x$, S$] = CA(bv), DA = y.forwardRef(
  (e, t) => {
    const {
      __scopePopper: n,
      side: o = "bottom",
      sideOffset: a = 0,
      align: l = "center",
      alignOffset: c = 0,
      arrowPadding: f = 0,
      avoidCollisions: d = !0,
      collisionBoundary: h = [],
      collisionPadding: m = 0,
      sticky: g = "partial",
      hideWhenDetached: b = !1,
      updatePositionStrategy: x = "optimized",
      onPlaced: _,
      ...E
    } = e, T = AA(bv, n), [C, z] = y.useState(null), A = Le(t, (U) => z(U)), [R, O] = y.useState(null), L = TA(R), M = L?.width ?? 0, N = L?.height ?? 0, j = o + (l !== "center" ? "-" + l : ""), Y = typeof m == "number" ? m : { top: 0, right: 0, bottom: 0, left: 0, ...m }, ne = Array.isArray(h) ? h : [h], J = ne.length > 0, he = {
      padding: Y,
      boundary: ne.filter(E$),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: J
    }, { refs: fe, floatingStyles: de, placement: I, isPositioned: G, middlewareData: B } = l$({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: j,
      whileElementsMounted: (...U) => J9(...U, {
        animationFrame: x === "always"
      }),
      elements: {
        reference: T.anchor
      },
      middleware: [
        u$({ mainAxis: a + N, alignmentAxis: c }),
        d && f$({
          mainAxis: !0,
          crossAxis: !1,
          limiter: g === "partial" ? d$() : void 0,
          ...he
        }),
        d && h$({ ...he }),
        p$({
          ...he,
          apply: ({ elements: U, rects: ie, availableWidth: ce, availableHeight: ue }) => {
            const { width: _e, height: ze } = ie.reference, je = U.floating.style;
            je.setProperty("--radix-popper-available-width", `${ce}px`), je.setProperty("--radix-popper-available-height", `${ue}px`), je.setProperty("--radix-popper-anchor-width", `${_e}px`), je.setProperty("--radix-popper-anchor-height", `${ze}px`);
          }
        }),
        R && g$({ element: R, padding: f }),
        _$({ arrowWidth: M, arrowHeight: N }),
        b && m$({ strategy: "referenceHidden", ...he })
      ]
    }), [te, ae] = jA(I), k = $t(_);
    Ht(() => {
      G && k?.();
    }, [G, k]);
    const X = B.arrow?.x, H = B.arrow?.y, K = B.arrow?.centerOffset !== 0, [le, se] = y.useState();
    return Ht(() => {
      C && se(window.getComputedStyle(C).zIndex);
    }, [C]), /* @__PURE__ */ S.jsx(
      "div",
      {
        ref: fe.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...de,
          transform: G ? de.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: le,
          "--radix-popper-transform-origin": [
            B.transformOrigin?.x,
            B.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...B.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ S.jsx(
          x$,
          {
            scope: n,
            placedSide: te,
            onArrowChange: O,
            arrowX: X,
            arrowY: H,
            shouldHideArrow: K,
            children: /* @__PURE__ */ S.jsx(
              Re.div,
              {
                "data-side": te,
                "data-align": ae,
                ...E,
                ref: A,
                style: {
                  ...E.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: G ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
DA.displayName = bv;
var NA = "PopperArrow", w$ = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, OA = y.forwardRef(function(t, n) {
  const { __scopePopper: o, ...a } = t, l = S$(NA, o), c = w$[l.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ S.jsx(
      "span",
      {
        ref: l.onArrowChange,
        style: {
          position: "absolute",
          left: l.arrowX,
          top: l.arrowY,
          [c]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[l.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[l.placedSide],
          visibility: l.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ S.jsx(
          y$,
          {
            ...a,
            ref: n,
            style: {
              ...a.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
OA.displayName = NA;
function E$(e) {
  return e !== null;
}
var _$ = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    const { placement: n, rects: o, middlewareData: a } = t, c = a.arrow?.centerOffset !== 0, f = c ? 0 : e.arrowWidth, d = c ? 0 : e.arrowHeight, [h, m] = jA(n), g = { start: "0%", center: "50%", end: "100%" }[m], b = (a.arrow?.x ?? 0) + f / 2, x = (a.arrow?.y ?? 0) + d / 2;
    let _ = "", E = "";
    return h === "bottom" ? (_ = c ? g : `${b}px`, E = `${-d}px`) : h === "top" ? (_ = c ? g : `${b}px`, E = `${o.floating.height + d}px`) : h === "right" ? (_ = `${-d}px`, E = c ? g : `${x}px`) : h === "left" && (_ = `${o.floating.width + d}px`, E = c ? g : `${x}px`), { data: { x: _, y: E } };
  }
});
function jA(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var xv = RA, Sv = zA, wv = DA, Ev = OA, T$ = "Portal", Il = y.forwardRef((e, t) => {
  const { container: n, ...o } = e, [a, l] = y.useState(!1);
  Ht(() => l(!0), []);
  const c = n || a && globalThis?.document?.body;
  return c ? uO.createPortal(/* @__PURE__ */ S.jsx(Re.div, { ...o, ref: t }), c) : null;
});
Il.displayName = T$;
function C$(e, t) {
  return y.useReducer((n, o) => t[n][o] ?? n, e);
}
var ln = (e) => {
  const { present: t, children: n } = e, o = A$(t), a = typeof n == "function" ? n({ present: o.isPresent }) : y.Children.only(n), l = Le(o.ref, R$(a));
  return typeof n == "function" || o.isPresent ? y.cloneElement(a, { ref: l }) : null;
};
ln.displayName = "Presence";
function A$(e) {
  const [t, n] = y.useState(), o = y.useRef(null), a = y.useRef(e), l = y.useRef("none"), c = e ? "mounted" : "unmounted", [f, d] = C$(c, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return y.useEffect(() => {
    const h = wu(o.current);
    l.current = f === "mounted" ? h : "none";
  }, [f]), Ht(() => {
    const h = o.current, m = a.current;
    if (m !== e) {
      const b = l.current, x = wu(h);
      e ? d("MOUNT") : x === "none" || h?.display === "none" ? d("UNMOUNT") : d(m && b !== x ? "ANIMATION_OUT" : "UNMOUNT"), a.current = e;
    }
  }, [e, d]), Ht(() => {
    if (t) {
      let h;
      const m = t.ownerDocument.defaultView ?? window, g = (x) => {
        const E = wu(o.current).includes(CSS.escape(x.animationName));
        if (x.target === t && E && (d("ANIMATION_END"), !a.current)) {
          const T = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", h = m.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = T);
          });
        }
      }, b = (x) => {
        x.target === t && (l.current = wu(o.current));
      };
      return t.addEventListener("animationstart", b), t.addEventListener("animationcancel", g), t.addEventListener("animationend", g), () => {
        m.clearTimeout(h), t.removeEventListener("animationstart", b), t.removeEventListener("animationcancel", g), t.removeEventListener("animationend", g);
      };
    } else
      d("ANIMATION_END");
  }, [t, d]), {
    isPresent: ["mounted", "unmountSuspended"].includes(f),
    ref: y.useCallback((h) => {
      o.current = h ? getComputedStyle(h) : null, n(h);
    }, [])
  };
}
function wu(e) {
  return e?.animationName || "none";
}
function R$(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var M$ = /* @__PURE__ */ Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function z$(e) {
  const t = ({ children: n }) => /* @__PURE__ */ S.jsx(S.Fragment, { children: n });
  return t.displayName = `${e}.Slottable`, t.__radixId = M$, t;
}
var D$ = _f[" useInsertionEffect ".trim().toString()] || Ht;
function vi({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: o
}) {
  const [a, l, c] = N$({
    defaultProp: t,
    onChange: n
  }), f = e !== void 0, d = f ? e : a;
  {
    const m = y.useRef(e !== void 0);
    y.useEffect(() => {
      const g = m.current;
      g !== f && console.warn(
        `${o} is changing from ${g ? "controlled" : "uncontrolled"} to ${f ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), m.current = f;
    }, [f, o]);
  }
  const h = y.useCallback(
    (m) => {
      if (f) {
        const g = O$(m) ? m(e) : m;
        g !== e && c.current?.(g);
      } else
        l(m);
    },
    [f, e, l, c]
  );
  return [d, h];
}
function N$({
  defaultProp: e,
  onChange: t
}) {
  const [n, o] = y.useState(e), a = y.useRef(n), l = y.useRef(t);
  return D$(() => {
    l.current = t;
  }, [t]), y.useEffect(() => {
    a.current !== n && (l.current?.(n), a.current = n);
  }, [n, a]), [n, o, l];
}
function O$(e) {
  return typeof e == "function";
}
var kA = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), j$ = "VisuallyHidden", PA = y.forwardRef(
  (e, t) => /* @__PURE__ */ S.jsx(
    Re.span,
    {
      ...e,
      ref: t,
      style: { ...kA, ...e.style }
    }
  )
);
PA.displayName = j$;
var k$ = PA, [Uf] = yr("Tooltip", [
  qa
]), Bf = qa(), LA = "TooltipProvider", P$ = 700, ag = "tooltip.open", [L$, _v] = Uf(LA), IA = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: n = P$,
    skipDelayDuration: o = 300,
    disableHoverableContent: a = !1,
    children: l
  } = e, c = y.useRef(!0), f = y.useRef(!1), d = y.useRef(0);
  return y.useEffect(() => {
    const h = d.current;
    return () => window.clearTimeout(h);
  }, []), /* @__PURE__ */ S.jsx(
    L$,
    {
      scope: t,
      isOpenDelayedRef: c,
      delayDuration: n,
      onOpen: y.useCallback(() => {
        window.clearTimeout(d.current), c.current = !1;
      }, []),
      onClose: y.useCallback(() => {
        window.clearTimeout(d.current), d.current = window.setTimeout(
          () => c.current = !0,
          o
        );
      }, [o]),
      isPointerInTransitRef: f,
      onPointerInTransitChange: y.useCallback((h) => {
        f.current = h;
      }, []),
      disableHoverableContent: a,
      children: l
    }
  );
};
IA.displayName = LA;
var El = "Tooltip", [I$, Vl] = Uf(El), VA = (e) => {
  const {
    __scopeTooltip: t,
    children: n,
    open: o,
    defaultOpen: a,
    onOpenChange: l,
    disableHoverableContent: c,
    delayDuration: f
  } = e, d = _v(El, e.__scopeTooltip), h = Bf(t), [m, g] = y.useState(null), b = hr(), x = y.useRef(0), _ = c ?? d.disableHoverableContent, E = f ?? d.delayDuration, T = y.useRef(!1), [C, z] = vi({
    prop: o,
    defaultProp: a ?? !1,
    onChange: (M) => {
      M ? (d.onOpen(), document.dispatchEvent(new CustomEvent(ag))) : d.onClose(), l?.(M);
    },
    caller: El
  }), A = y.useMemo(() => C ? T.current ? "delayed-open" : "instant-open" : "closed", [C]), R = y.useCallback(() => {
    window.clearTimeout(x.current), x.current = 0, T.current = !1, z(!0);
  }, [z]), O = y.useCallback(() => {
    window.clearTimeout(x.current), x.current = 0, z(!1);
  }, [z]), L = y.useCallback(() => {
    window.clearTimeout(x.current), x.current = window.setTimeout(() => {
      T.current = !0, z(!0), x.current = 0;
    }, E);
  }, [E, z]);
  return y.useEffect(() => () => {
    x.current && (window.clearTimeout(x.current), x.current = 0);
  }, []), /* @__PURE__ */ S.jsx(xv, { ...h, children: /* @__PURE__ */ S.jsx(
    I$,
    {
      scope: t,
      contentId: b,
      open: C,
      stateAttribute: A,
      trigger: m,
      onTriggerChange: g,
      onTriggerEnter: y.useCallback(() => {
        d.isOpenDelayedRef.current ? L() : R();
      }, [d.isOpenDelayedRef, L, R]),
      onTriggerLeave: y.useCallback(() => {
        _ ? O() : (window.clearTimeout(x.current), x.current = 0);
      }, [O, _]),
      onOpen: R,
      onClose: O,
      disableHoverableContent: _,
      children: n
    }
  ) });
};
VA.displayName = El;
var sg = "TooltipTrigger", UA = y.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...o } = e, a = Vl(sg, n), l = _v(sg, n), c = Bf(n), f = y.useRef(null), d = Le(t, f, a.onTriggerChange), h = y.useRef(!1), m = y.useRef(!1), g = y.useCallback(() => h.current = !1, []);
    return y.useEffect(() => () => document.removeEventListener("pointerup", g), [g]), /* @__PURE__ */ S.jsx(Sv, { asChild: !0, ...c, children: /* @__PURE__ */ S.jsx(
      Re.button,
      {
        "aria-describedby": a.open ? a.contentId : void 0,
        "data-state": a.stateAttribute,
        ...o,
        ref: d,
        onPointerMove: pe(e.onPointerMove, (b) => {
          b.pointerType !== "touch" && !m.current && !l.isPointerInTransitRef.current && (a.onTriggerEnter(), m.current = !0);
        }),
        onPointerLeave: pe(e.onPointerLeave, () => {
          a.onTriggerLeave(), m.current = !1;
        }),
        onPointerDown: pe(e.onPointerDown, () => {
          a.open && a.onClose(), h.current = !0, document.addEventListener("pointerup", g, { once: !0 });
        }),
        onFocus: pe(e.onFocus, () => {
          h.current || a.onOpen();
        }),
        onBlur: pe(e.onBlur, a.onClose),
        onClick: pe(e.onClick, a.onClose)
      }
    ) });
  }
);
UA.displayName = sg;
var Tv = "TooltipPortal", [V$, U$] = Uf(Tv, {
  forceMount: void 0
}), BA = (e) => {
  const { __scopeTooltip: t, forceMount: n, children: o, container: a } = e, l = Vl(Tv, t);
  return /* @__PURE__ */ S.jsx(V$, { scope: t, forceMount: n, children: /* @__PURE__ */ S.jsx(ln, { present: n || l.open, children: /* @__PURE__ */ S.jsx(Il, { asChild: !0, container: a, children: o }) }) });
};
BA.displayName = Tv;
var La = "TooltipContent", $A = y.forwardRef(
  (e, t) => {
    const n = U$(La, e.__scopeTooltip), { forceMount: o = n.forceMount, side: a = "top", ...l } = e, c = Vl(La, e.__scopeTooltip);
    return /* @__PURE__ */ S.jsx(ln, { present: o || c.open, children: c.disableHoverableContent ? /* @__PURE__ */ S.jsx(HA, { side: a, ...l, ref: t }) : /* @__PURE__ */ S.jsx(B$, { side: a, ...l, ref: t }) });
  }
), B$ = y.forwardRef((e, t) => {
  const n = Vl(La, e.__scopeTooltip), o = _v(La, e.__scopeTooltip), a = y.useRef(null), l = Le(t, a), [c, f] = y.useState(null), { trigger: d, onClose: h } = n, m = a.current, { onPointerInTransitChange: g } = o, b = y.useCallback(() => {
    f(null), g(!1);
  }, [g]), x = y.useCallback(
    (_, E) => {
      const T = _.currentTarget, C = { x: _.clientX, y: _.clientY }, z = F$(C, T.getBoundingClientRect()), A = G$(C, z), R = Y$(E.getBoundingClientRect()), O = X$([...A, ...R]);
      f(O), g(!0);
    },
    [g]
  );
  return y.useEffect(() => () => b(), [b]), y.useEffect(() => {
    if (d && m) {
      const _ = (T) => x(T, m), E = (T) => x(T, d);
      return d.addEventListener("pointerleave", _), m.addEventListener("pointerleave", E), () => {
        d.removeEventListener("pointerleave", _), m.removeEventListener("pointerleave", E);
      };
    }
  }, [d, m, x, b]), y.useEffect(() => {
    if (c) {
      const _ = (E) => {
        const T = E.target, C = { x: E.clientX, y: E.clientY }, z = d?.contains(T) || m?.contains(T), A = !q$(C, c);
        z ? b() : A && (b(), h());
      };
      return document.addEventListener("pointermove", _), () => document.removeEventListener("pointermove", _);
    }
  }, [d, m, c, h, b]), /* @__PURE__ */ S.jsx(HA, { ...e, ref: l });
}), [$$, H$] = Uf(El, { isInside: !1 }), Z$ = /* @__PURE__ */ z$("TooltipContent"), HA = y.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: n,
      children: o,
      "aria-label": a,
      onEscapeKeyDown: l,
      onPointerDownOutside: c,
      ...f
    } = e, d = Vl(La, n), h = Bf(n), { onClose: m } = d;
    return y.useEffect(() => (document.addEventListener(ag, m), () => document.removeEventListener(ag, m)), [m]), y.useEffect(() => {
      if (d.trigger) {
        const g = (b) => {
          b.target?.contains(d.trigger) && m();
        };
        return window.addEventListener("scroll", g, { capture: !0 }), () => window.removeEventListener("scroll", g, { capture: !0 });
      }
    }, [d.trigger, m]), /* @__PURE__ */ S.jsx(
      Pl,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: l,
        onPointerDownOutside: c,
        onFocusOutside: (g) => g.preventDefault(),
        onDismiss: m,
        children: /* @__PURE__ */ S.jsxs(
          wv,
          {
            "data-state": d.stateAttribute,
            ...h,
            ...f,
            ref: t,
            style: {
              ...f.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ S.jsx(Z$, { children: o }),
              /* @__PURE__ */ S.jsx($$, { scope: n, isInside: !0, children: /* @__PURE__ */ S.jsx(k$, { id: d.contentId, role: "tooltip", children: a || o }) })
            ]
          }
        )
      }
    );
  }
);
$A.displayName = La;
var ZA = "TooltipArrow", FA = y.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...o } = e, a = Bf(n);
    return H$(
      ZA,
      n
    ).isInside ? null : /* @__PURE__ */ S.jsx(Ev, { ...a, ...o, ref: t });
  }
);
FA.displayName = ZA;
function F$(e, t) {
  const n = Math.abs(t.top - e.y), o = Math.abs(t.bottom - e.y), a = Math.abs(t.right - e.x), l = Math.abs(t.left - e.x);
  switch (Math.min(n, o, a, l)) {
    case l:
      return "left";
    case a:
      return "right";
    case n:
      return "top";
    case o:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function G$(e, t, n = 5) {
  const o = [];
  switch (t) {
    case "top":
      o.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      o.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      o.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      o.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return o;
}
function Y$(e) {
  const { top: t, right: n, bottom: o, left: a } = e;
  return [
    { x: a, y: t },
    { x: n, y: t },
    { x: n, y: o },
    { x: a, y: o }
  ];
}
function q$(e, t) {
  const { x: n, y: o } = e;
  let a = !1;
  for (let l = 0, c = t.length - 1; l < t.length; c = l++) {
    const f = t[l], d = t[c], h = f.x, m = f.y, g = d.x, b = d.y;
    m > o != b > o && n < (g - h) * (o - m) / (b - m) + h && (a = !a);
  }
  return a;
}
function X$(e) {
  const t = e.slice();
  return t.sort((n, o) => n.x < o.x ? -1 : n.x > o.x ? 1 : n.y < o.y ? -1 : n.y > o.y ? 1 : 0), W$(t);
}
function W$(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let o = 0; o < e.length; o++) {
    const a = e[o];
    for (; t.length >= 2; ) {
      const l = t[t.length - 1], c = t[t.length - 2];
      if ((l.x - c.x) * (a.y - c.y) >= (l.y - c.y) * (a.x - c.x)) t.pop();
      else break;
    }
    t.push(a);
  }
  t.pop();
  const n = [];
  for (let o = e.length - 1; o >= 0; o--) {
    const a = e[o];
    for (; n.length >= 2; ) {
      const l = n[n.length - 1], c = n[n.length - 2];
      if ((l.x - c.x) * (a.y - c.y) >= (l.y - c.y) * (a.x - c.x)) n.pop();
      else break;
    }
    n.push(a);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var K$ = IA, J$ = VA, Q$ = UA, eH = BA, tH = $A, nH = FA;
function Cv({
  delayDuration: e = 0,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    K$,
    {
      "data-slot": "tooltip-provider",
      delayDuration: e,
      ...t
    }
  );
}
function tl({ ...e }) {
  return /* @__PURE__ */ S.jsx(Cv, { children: /* @__PURE__ */ S.jsx(J$, { "data-slot": "tooltip", ...e }) });
}
function nl({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(Q$, { "data-slot": "tooltip-trigger", ...e });
}
function rl({
  className: e,
  sideOffset: t = 0,
  hasArrow: n = !1,
  children: o,
  ...a
}) {
  return /* @__PURE__ */ S.jsx(eH, { children: /* @__PURE__ */ S.jsxs(
    tH,
    {
      "data-slot": "tooltip-content",
      sideOffset: t,
      className: Fe(
        "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
        e
      ),
      ...a,
      children: [
        o,
        /* @__PURE__ */ S.jsx(
          nH,
          {
            className: "bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] opacity-0 bg-transparent"
          }
        )
      ]
    }
  ) });
}
const rH = KC(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function GA({
  className: e,
  variant: t,
  asChild: n = !1,
  ...o
}) {
  const a = n ? qC : "span";
  return /* @__PURE__ */ S.jsx(
    a,
    {
      "data-slot": "badge",
      className: Fe(rH({ variant: t }), e),
      ...o
    }
  );
}
var sm = "focusScope.autoFocusOnMount", lm = "focusScope.autoFocusOnUnmount", nE = { bubbles: !1, cancelable: !0 }, oH = "FocusScope", $f = y.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: o = !1,
    onMountAutoFocus: a,
    onUnmountAutoFocus: l,
    ...c
  } = e, [f, d] = y.useState(null), h = $t(a), m = $t(l), g = y.useRef(null), b = Le(t, (E) => d(E)), x = y.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  y.useEffect(() => {
    if (o) {
      let E = function(A) {
        if (x.paused || !f) return;
        const R = A.target;
        f.contains(R) ? g.current = R : Co(g.current, { select: !0 });
      }, T = function(A) {
        if (x.paused || !f) return;
        const R = A.relatedTarget;
        R !== null && (f.contains(R) || Co(g.current, { select: !0 }));
      }, C = function(A) {
        if (document.activeElement === document.body)
          for (const O of A)
            O.removedNodes.length > 0 && Co(f);
      };
      document.addEventListener("focusin", E), document.addEventListener("focusout", T);
      const z = new MutationObserver(C);
      return f && z.observe(f, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", E), document.removeEventListener("focusout", T), z.disconnect();
      };
    }
  }, [o, f, x.paused]), y.useEffect(() => {
    if (f) {
      oE.add(x);
      const E = document.activeElement;
      if (!f.contains(E)) {
        const C = new CustomEvent(sm, nE);
        f.addEventListener(sm, h), f.dispatchEvent(C), C.defaultPrevented || (iH(uH(YA(f)), { select: !0 }), document.activeElement === E && Co(f));
      }
      return () => {
        f.removeEventListener(sm, h), setTimeout(() => {
          const C = new CustomEvent(lm, nE);
          f.addEventListener(lm, m), f.dispatchEvent(C), C.defaultPrevented || Co(E ?? document.body, { select: !0 }), f.removeEventListener(lm, m), oE.remove(x);
        }, 0);
      };
    }
  }, [f, h, m, x]);
  const _ = y.useCallback(
    (E) => {
      if (!n && !o || x.paused) return;
      const T = E.key === "Tab" && !E.altKey && !E.ctrlKey && !E.metaKey, C = document.activeElement;
      if (T && C) {
        const z = E.currentTarget, [A, R] = aH(z);
        A && R ? !E.shiftKey && C === R ? (E.preventDefault(), n && Co(A, { select: !0 })) : E.shiftKey && C === A && (E.preventDefault(), n && Co(R, { select: !0 })) : C === z && E.preventDefault();
      }
    },
    [n, o, x.paused]
  );
  return /* @__PURE__ */ S.jsx(Re.div, { tabIndex: -1, ...c, ref: b, onKeyDown: _ });
});
$f.displayName = oH;
function iH(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const o of e)
    if (Co(o, { select: t }), document.activeElement !== n) return;
}
function aH(e) {
  const t = YA(e), n = rE(t, e), o = rE(t.reverse(), e);
  return [n, o];
}
function YA(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => {
      const a = o.tagName === "INPUT" && o.type === "hidden";
      return o.disabled || o.hidden || a ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function rE(e, t) {
  for (const n of e)
    if (!sH(n, { upTo: t })) return n;
}
function sH(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function lH(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Co(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && lH(e) && t && e.select();
  }
}
var oE = cH();
function cH() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && n?.pause(), e = iE(e, t), e.unshift(t);
    },
    remove(t) {
      e = iE(e, t), e[0]?.resume();
    }
  };
}
function iE(e, t) {
  const n = [...e], o = n.indexOf(t);
  return o !== -1 && n.splice(o, 1), n;
}
function uH(e) {
  return e.filter((t) => t.tagName !== "A");
}
var cm = 0;
function Av() {
  y.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? aE()), document.body.insertAdjacentElement("beforeend", e[1] ?? aE()), cm++, () => {
      cm === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), cm--;
    };
  }, []);
}
function aE() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var ur = function() {
  return ur = Object.assign || function(t) {
    for (var n, o = 1, a = arguments.length; o < a; o++) {
      n = arguments[o];
      for (var l in n) Object.prototype.hasOwnProperty.call(n, l) && (t[l] = n[l]);
    }
    return t;
  }, ur.apply(this, arguments);
};
function qA(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, o = Object.getOwnPropertySymbols(e); a < o.length; a++)
      t.indexOf(o[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[a]) && (n[o[a]] = e[o[a]]);
  return n;
}
function fH(e, t, n) {
  if (n || arguments.length === 2) for (var o = 0, a = t.length, l; o < a; o++)
    (l || !(o in t)) && (l || (l = Array.prototype.slice.call(t, 0, o)), l[o] = t[o]);
  return e.concat(l || Array.prototype.slice.call(t));
}
var Lu = "right-scroll-bar-position", Iu = "width-before-scroll-bar", dH = "with-scroll-bars-hidden", hH = "--removed-body-scroll-bar-size";
function um(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function pH(e, t) {
  var n = y.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(o) {
          var a = n.value;
          a !== o && (n.value = o, n.callback(o, a));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var mH = typeof window < "u" ? y.useLayoutEffect : y.useEffect, sE = /* @__PURE__ */ new WeakMap();
function gH(e, t) {
  var n = pH(null, function(o) {
    return e.forEach(function(a) {
      return um(a, o);
    });
  });
  return mH(function() {
    var o = sE.get(n);
    if (o) {
      var a = new Set(o), l = new Set(e), c = n.current;
      a.forEach(function(f) {
        l.has(f) || um(f, null);
      }), l.forEach(function(f) {
        a.has(f) || um(f, c);
      });
    }
    sE.set(n, e);
  }, [e]), n;
}
function vH(e) {
  return e;
}
function yH(e, t) {
  t === void 0 && (t = vH);
  var n = [], o = !1, a = {
    read: function() {
      if (o)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(l) {
      var c = t(l, o);
      return n.push(c), function() {
        n = n.filter(function(f) {
          return f !== c;
        });
      };
    },
    assignSyncMedium: function(l) {
      for (o = !0; n.length; ) {
        var c = n;
        n = [], c.forEach(l);
      }
      n = {
        push: function(f) {
          return l(f);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(l) {
      o = !0;
      var c = [];
      if (n.length) {
        var f = n;
        n = [], f.forEach(l), c = n;
      }
      var d = function() {
        var m = c;
        c = [], m.forEach(l);
      }, h = function() {
        return Promise.resolve().then(d);
      };
      h(), n = {
        push: function(m) {
          c.push(m), h();
        },
        filter: function(m) {
          return c = c.filter(m), n;
        }
      };
    }
  };
  return a;
}
function bH(e) {
  e === void 0 && (e = {});
  var t = yH(null);
  return t.options = ur({ async: !0, ssr: !1 }, e), t;
}
var XA = function(e) {
  var t = e.sideCar, n = qA(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var o = t.read();
  if (!o)
    throw new Error("Sidecar medium not found");
  return y.createElement(o, ur({}, n));
};
XA.isSideCarExport = !0;
function xH(e, t) {
  return e.useMedium(t), XA;
}
var WA = bH(), fm = function() {
}, Hf = y.forwardRef(function(e, t) {
  var n = y.useRef(null), o = y.useState({
    onScrollCapture: fm,
    onWheelCapture: fm,
    onTouchMoveCapture: fm
  }), a = o[0], l = o[1], c = e.forwardProps, f = e.children, d = e.className, h = e.removeScrollBar, m = e.enabled, g = e.shards, b = e.sideCar, x = e.noRelative, _ = e.noIsolation, E = e.inert, T = e.allowPinchZoom, C = e.as, z = C === void 0 ? "div" : C, A = e.gapMode, R = qA(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), O = b, L = gH([n, t]), M = ur(ur({}, R), a);
  return y.createElement(
    y.Fragment,
    null,
    m && y.createElement(O, { sideCar: WA, removeScrollBar: h, shards: g, noRelative: x, noIsolation: _, inert: E, setCallbacks: l, allowPinchZoom: !!T, lockRef: n, gapMode: A }),
    c ? y.cloneElement(y.Children.only(f), ur(ur({}, M), { ref: L })) : y.createElement(z, ur({}, M, { className: d, ref: L }), f)
  );
});
Hf.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Hf.classNames = {
  fullWidth: Iu,
  zeroRight: Lu
};
var SH = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function wH() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = SH();
  return t && e.setAttribute("nonce", t), e;
}
function EH(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function _H(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var TH = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = wH()) && (EH(t, n), _H(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, CH = function() {
  var e = TH();
  return function(t, n) {
    y.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, KA = function() {
  var e = CH(), t = function(n) {
    var o = n.styles, a = n.dynamic;
    return e(o, a), null;
  };
  return t;
}, AH = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, dm = function(e) {
  return parseInt(e || "", 10) || 0;
}, RH = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], o = t[e === "padding" ? "paddingTop" : "marginTop"], a = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [dm(n), dm(o), dm(a)];
}, MH = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return AH;
  var t = RH(e), n = document.documentElement.clientWidth, o = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, o - n + t[2] - t[0])
  };
}, zH = KA(), Da = "data-scroll-locked", DH = function(e, t, n, o) {
  var a = e.left, l = e.top, c = e.right, f = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(dH, ` {
   overflow: hidden `).concat(o, `;
   padding-right: `).concat(f, "px ").concat(o, `;
  }
  body[`).concat(Da, `] {
    overflow: hidden `).concat(o, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(o, ";"),
    n === "margin" && `
    padding-left: `.concat(a, `px;
    padding-top: `).concat(l, `px;
    padding-right: `).concat(c, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(f, "px ").concat(o, `;
    `),
    n === "padding" && "padding-right: ".concat(f, "px ").concat(o, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Lu, ` {
    right: `).concat(f, "px ").concat(o, `;
  }
  
  .`).concat(Iu, ` {
    margin-right: `).concat(f, "px ").concat(o, `;
  }
  
  .`).concat(Lu, " .").concat(Lu, ` {
    right: 0 `).concat(o, `;
  }
  
  .`).concat(Iu, " .").concat(Iu, ` {
    margin-right: 0 `).concat(o, `;
  }
  
  body[`).concat(Da, `] {
    `).concat(hH, ": ").concat(f, `px;
  }
`);
}, lE = function() {
  var e = parseInt(document.body.getAttribute(Da) || "0", 10);
  return isFinite(e) ? e : 0;
}, NH = function() {
  y.useEffect(function() {
    return document.body.setAttribute(Da, (lE() + 1).toString()), function() {
      var e = lE() - 1;
      e <= 0 ? document.body.removeAttribute(Da) : document.body.setAttribute(Da, e.toString());
    };
  }, []);
}, OH = function(e) {
  var t = e.noRelative, n = e.noImportant, o = e.gapMode, a = o === void 0 ? "margin" : o;
  NH();
  var l = y.useMemo(function() {
    return MH(a);
  }, [a]);
  return y.createElement(zH, { styles: DH(l, !t, a, n ? "" : "!important") });
}, lg = !1;
if (typeof window < "u")
  try {
    var Eu = Object.defineProperty({}, "passive", {
      get: function() {
        return lg = !0, !0;
      }
    });
    window.addEventListener("test", Eu, Eu), window.removeEventListener("test", Eu, Eu);
  } catch {
    lg = !1;
  }
var ha = lg ? { passive: !1 } : !1, jH = function(e) {
  return e.tagName === "TEXTAREA";
}, JA = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !jH(e) && n[t] === "visible")
  );
}, kH = function(e) {
  return JA(e, "overflowY");
}, PH = function(e) {
  return JA(e, "overflowX");
}, cE = function(e, t) {
  var n = t.ownerDocument, o = t;
  do {
    typeof ShadowRoot < "u" && o instanceof ShadowRoot && (o = o.host);
    var a = QA(e, o);
    if (a) {
      var l = eR(e, o), c = l[1], f = l[2];
      if (c > f)
        return !0;
    }
    o = o.parentNode;
  } while (o && o !== n.body);
  return !1;
}, LH = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, o = e.clientHeight;
  return [
    t,
    n,
    o
  ];
}, IH = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, o = e.clientWidth;
  return [
    t,
    n,
    o
  ];
}, QA = function(e, t) {
  return e === "v" ? kH(t) : PH(t);
}, eR = function(e, t) {
  return e === "v" ? LH(t) : IH(t);
}, VH = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, UH = function(e, t, n, o, a) {
  var l = VH(e, window.getComputedStyle(t).direction), c = l * o, f = n.target, d = t.contains(f), h = !1, m = c > 0, g = 0, b = 0;
  do {
    if (!f)
      break;
    var x = eR(e, f), _ = x[0], E = x[1], T = x[2], C = E - T - l * _;
    (_ || C) && QA(e, f) && (g += C, b += _);
    var z = f.parentNode;
    f = z && z.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? z.host : z;
  } while (
    // portaled content
    !d && f !== document.body || // self content
    d && (t.contains(f) || t === f)
  );
  return (m && Math.abs(g) < 1 || !m && Math.abs(b) < 1) && (h = !0), h;
}, _u = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, uE = function(e) {
  return [e.deltaX, e.deltaY];
}, fE = function(e) {
  return e && "current" in e ? e.current : e;
}, BH = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, $H = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, HH = 0, pa = [];
function ZH(e) {
  var t = y.useRef([]), n = y.useRef([0, 0]), o = y.useRef(), a = y.useState(HH++)[0], l = y.useState(KA)[0], c = y.useRef(e);
  y.useEffect(function() {
    c.current = e;
  }, [e]), y.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(a));
      var E = fH([e.lockRef.current], (e.shards || []).map(fE), !0).filter(Boolean);
      return E.forEach(function(T) {
        return T.classList.add("allow-interactivity-".concat(a));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(a)), E.forEach(function(T) {
          return T.classList.remove("allow-interactivity-".concat(a));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var f = y.useCallback(function(E, T) {
    if ("touches" in E && E.touches.length === 2 || E.type === "wheel" && E.ctrlKey)
      return !c.current.allowPinchZoom;
    var C = _u(E), z = n.current, A = "deltaX" in E ? E.deltaX : z[0] - C[0], R = "deltaY" in E ? E.deltaY : z[1] - C[1], O, L = E.target, M = Math.abs(A) > Math.abs(R) ? "h" : "v";
    if ("touches" in E && M === "h" && L.type === "range")
      return !1;
    var N = window.getSelection(), j = N && N.anchorNode, Y = j ? j === L || j.contains(L) : !1;
    if (Y)
      return !1;
    var ne = cE(M, L);
    if (!ne)
      return !0;
    if (ne ? O = M : (O = M === "v" ? "h" : "v", ne = cE(M, L)), !ne)
      return !1;
    if (!o.current && "changedTouches" in E && (A || R) && (o.current = O), !O)
      return !0;
    var J = o.current || O;
    return UH(J, T, E, J === "h" ? A : R);
  }, []), d = y.useCallback(function(E) {
    var T = E;
    if (!(!pa.length || pa[pa.length - 1] !== l)) {
      var C = "deltaY" in T ? uE(T) : _u(T), z = t.current.filter(function(O) {
        return O.name === T.type && (O.target === T.target || T.target === O.shadowParent) && BH(O.delta, C);
      })[0];
      if (z && z.should) {
        T.cancelable && T.preventDefault();
        return;
      }
      if (!z) {
        var A = (c.current.shards || []).map(fE).filter(Boolean).filter(function(O) {
          return O.contains(T.target);
        }), R = A.length > 0 ? f(T, A[0]) : !c.current.noIsolation;
        R && T.cancelable && T.preventDefault();
      }
    }
  }, []), h = y.useCallback(function(E, T, C, z) {
    var A = { name: E, delta: T, target: C, should: z, shadowParent: FH(C) };
    t.current.push(A), setTimeout(function() {
      t.current = t.current.filter(function(R) {
        return R !== A;
      });
    }, 1);
  }, []), m = y.useCallback(function(E) {
    n.current = _u(E), o.current = void 0;
  }, []), g = y.useCallback(function(E) {
    h(E.type, uE(E), E.target, f(E, e.lockRef.current));
  }, []), b = y.useCallback(function(E) {
    h(E.type, _u(E), E.target, f(E, e.lockRef.current));
  }, []);
  y.useEffect(function() {
    return pa.push(l), e.setCallbacks({
      onScrollCapture: g,
      onWheelCapture: g,
      onTouchMoveCapture: b
    }), document.addEventListener("wheel", d, ha), document.addEventListener("touchmove", d, ha), document.addEventListener("touchstart", m, ha), function() {
      pa = pa.filter(function(E) {
        return E !== l;
      }), document.removeEventListener("wheel", d, ha), document.removeEventListener("touchmove", d, ha), document.removeEventListener("touchstart", m, ha);
    };
  }, []);
  var x = e.removeScrollBar, _ = e.inert;
  return y.createElement(
    y.Fragment,
    null,
    _ ? y.createElement(l, { styles: $H(a) }) : null,
    x ? y.createElement(OH, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function FH(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const GH = xH(WA, ZH);
var Zf = y.forwardRef(function(e, t) {
  return y.createElement(Hf, ur({}, e, { ref: t, sideCar: GH }));
});
Zf.classNames = Hf.classNames;
var YH = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, ma = /* @__PURE__ */ new WeakMap(), Tu = /* @__PURE__ */ new WeakMap(), Cu = {}, hm = 0, tR = function(e) {
  return e && (e.host || tR(e.parentNode));
}, qH = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var o = tR(n);
    return o && e.contains(o) ? o : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, XH = function(e, t, n, o) {
  var a = qH(t, Array.isArray(e) ? e : [e]);
  Cu[n] || (Cu[n] = /* @__PURE__ */ new WeakMap());
  var l = Cu[n], c = [], f = /* @__PURE__ */ new Set(), d = new Set(a), h = function(g) {
    !g || f.has(g) || (f.add(g), h(g.parentNode));
  };
  a.forEach(h);
  var m = function(g) {
    !g || d.has(g) || Array.prototype.forEach.call(g.children, function(b) {
      if (f.has(b))
        m(b);
      else
        try {
          var x = b.getAttribute(o), _ = x !== null && x !== "false", E = (ma.get(b) || 0) + 1, T = (l.get(b) || 0) + 1;
          ma.set(b, E), l.set(b, T), c.push(b), E === 1 && _ && Tu.set(b, !0), T === 1 && b.setAttribute(n, "true"), _ || b.setAttribute(o, "true");
        } catch (C) {
          console.error("aria-hidden: cannot operate on ", b, C);
        }
    });
  };
  return m(t), f.clear(), hm++, function() {
    c.forEach(function(g) {
      var b = ma.get(g) - 1, x = l.get(g) - 1;
      ma.set(g, b), l.set(g, x), b || (Tu.has(g) || g.removeAttribute(o), Tu.delete(g)), x || g.removeAttribute(n);
    }), hm--, hm || (ma = /* @__PURE__ */ new WeakMap(), ma = /* @__PURE__ */ new WeakMap(), Tu = /* @__PURE__ */ new WeakMap(), Cu = {});
  };
}, Rv = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var o = Array.from(Array.isArray(e) ? e : [e]), a = YH(e);
  return a ? (o.push.apply(o, Array.from(a.querySelectorAll("[aria-live], script"))), XH(o, a, n, "aria-hidden")) : function() {
    return null;
  };
};
// @__NO_SIDE_EFFECTS__
function WH(e) {
  const t = /* @__PURE__ */ KH(e), n = y.forwardRef((o, a) => {
    const { children: l, ...c } = o, f = y.Children.toArray(l), d = f.find(QH);
    if (d) {
      const h = d.props.children, m = f.map((g) => g === d ? y.Children.count(h) > 1 ? y.Children.only(null) : y.isValidElement(h) ? h.props.children : null : g);
      return /* @__PURE__ */ S.jsx(t, { ...c, ref: a, children: y.isValidElement(h) ? y.cloneElement(h, void 0, m) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...c, ref: a, children: l });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function KH(e) {
  const t = y.forwardRef((n, o) => {
    const { children: a, ...l } = n;
    if (y.isValidElement(a)) {
      const c = t8(a), f = e8(l, a.props);
      return a.type !== y.Fragment && (f.ref = o ? qr(o, c) : c), y.cloneElement(a, f);
    }
    return y.Children.count(a) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var JH = /* @__PURE__ */ Symbol("radix.slottable");
function QH(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === JH;
}
function e8(e, t) {
  const n = { ...t };
  for (const o in t) {
    const a = e[o], l = t[o];
    /^on[A-Z]/.test(o) ? a && l ? n[o] = (...f) => {
      const d = l(...f);
      return a(...f), d;
    } : a && (n[o] = a) : o === "style" ? n[o] = { ...a, ...l } : o === "className" && (n[o] = [a, l].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function t8(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Ff = "Dialog", [nR] = yr(Ff), [n8, tr] = nR(Ff), rR = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: o,
    defaultOpen: a,
    onOpenChange: l,
    modal: c = !0
  } = e, f = y.useRef(null), d = y.useRef(null), [h, m] = vi({
    prop: o,
    defaultProp: a ?? !1,
    onChange: l,
    caller: Ff
  });
  return /* @__PURE__ */ S.jsx(
    n8,
    {
      scope: t,
      triggerRef: f,
      contentRef: d,
      contentId: hr(),
      titleId: hr(),
      descriptionId: hr(),
      open: h,
      onOpenChange: m,
      onOpenToggle: y.useCallback(() => m((g) => !g), [m]),
      modal: c,
      children: n
    }
  );
};
rR.displayName = Ff;
var oR = "DialogTrigger", r8 = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...o } = e, a = tr(oR, n), l = Le(t, a.triggerRef);
    return /* @__PURE__ */ S.jsx(
      Re.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": a.open,
        "aria-controls": a.contentId,
        "data-state": Dv(a.open),
        ...o,
        ref: l,
        onClick: pe(e.onClick, a.onOpenToggle)
      }
    );
  }
);
r8.displayName = oR;
var Mv = "DialogPortal", [o8, iR] = nR(Mv, {
  forceMount: void 0
}), aR = (e) => {
  const { __scopeDialog: t, forceMount: n, children: o, container: a } = e, l = tr(Mv, t);
  return /* @__PURE__ */ S.jsx(o8, { scope: t, forceMount: n, children: y.Children.map(o, (c) => /* @__PURE__ */ S.jsx(ln, { present: n || l.open, children: /* @__PURE__ */ S.jsx(Il, { asChild: !0, container: a, children: c }) })) });
};
aR.displayName = Mv;
var hf = "DialogOverlay", sR = y.forwardRef(
  (e, t) => {
    const n = iR(hf, e.__scopeDialog), { forceMount: o = n.forceMount, ...a } = e, l = tr(hf, e.__scopeDialog);
    return l.modal ? /* @__PURE__ */ S.jsx(ln, { present: o || l.open, children: /* @__PURE__ */ S.jsx(a8, { ...a, ref: t }) }) : null;
  }
);
sR.displayName = hf;
var i8 = /* @__PURE__ */ WH("DialogOverlay.RemoveScroll"), a8 = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...o } = e, a = tr(hf, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ S.jsx(Zf, { as: i8, allowPinchZoom: !0, shards: [a.contentRef], children: /* @__PURE__ */ S.jsx(
        Re.div,
        {
          "data-state": Dv(a.open),
          ...o,
          ref: t,
          style: { pointerEvents: "auto", ...o.style }
        }
      ) })
    );
  }
), yi = "DialogContent", lR = y.forwardRef(
  (e, t) => {
    const n = iR(yi, e.__scopeDialog), { forceMount: o = n.forceMount, ...a } = e, l = tr(yi, e.__scopeDialog);
    return /* @__PURE__ */ S.jsx(ln, { present: o || l.open, children: l.modal ? /* @__PURE__ */ S.jsx(s8, { ...a, ref: t }) : /* @__PURE__ */ S.jsx(l8, { ...a, ref: t }) });
  }
);
lR.displayName = yi;
var s8 = y.forwardRef(
  (e, t) => {
    const n = tr(yi, e.__scopeDialog), o = y.useRef(null), a = Le(t, n.contentRef, o);
    return y.useEffect(() => {
      const l = o.current;
      if (l) return Rv(l);
    }, []), /* @__PURE__ */ S.jsx(
      cR,
      {
        ...e,
        ref: a,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: pe(e.onCloseAutoFocus, (l) => {
          l.preventDefault(), n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: pe(e.onPointerDownOutside, (l) => {
          const c = l.detail.originalEvent, f = c.button === 0 && c.ctrlKey === !0;
          (c.button === 2 || f) && l.preventDefault();
        }),
        onFocusOutside: pe(
          e.onFocusOutside,
          (l) => l.preventDefault()
        )
      }
    );
  }
), l8 = y.forwardRef(
  (e, t) => {
    const n = tr(yi, e.__scopeDialog), o = y.useRef(!1), a = y.useRef(!1);
    return /* @__PURE__ */ S.jsx(
      cR,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (l) => {
          e.onCloseAutoFocus?.(l), l.defaultPrevented || (o.current || n.triggerRef.current?.focus(), l.preventDefault()), o.current = !1, a.current = !1;
        },
        onInteractOutside: (l) => {
          e.onInteractOutside?.(l), l.defaultPrevented || (o.current = !0, l.detail.originalEvent.type === "pointerdown" && (a.current = !0));
          const c = l.target;
          n.triggerRef.current?.contains(c) && l.preventDefault(), l.detail.originalEvent.type === "focusin" && a.current && l.preventDefault();
        }
      }
    );
  }
), cR = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: o, onOpenAutoFocus: a, onCloseAutoFocus: l, ...c } = e, f = tr(yi, n), d = y.useRef(null), h = Le(t, d);
    return Av(), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx(
        $f,
        {
          asChild: !0,
          loop: !0,
          trapped: o,
          onMountAutoFocus: a,
          onUnmountAutoFocus: l,
          children: /* @__PURE__ */ S.jsx(
            Pl,
            {
              role: "dialog",
              id: f.contentId,
              "aria-describedby": f.descriptionId,
              "aria-labelledby": f.titleId,
              "data-state": Dv(f.open),
              ...c,
              ref: h,
              onDismiss: () => f.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx(c8, { titleId: f.titleId }),
        /* @__PURE__ */ S.jsx(f8, { contentRef: d, descriptionId: f.descriptionId })
      ] })
    ] });
  }
), zv = "DialogTitle", uR = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...o } = e, a = tr(zv, n);
    return /* @__PURE__ */ S.jsx(Re.h2, { id: a.titleId, ...o, ref: t });
  }
);
uR.displayName = zv;
var fR = "DialogDescription", dR = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...o } = e, a = tr(fR, n);
    return /* @__PURE__ */ S.jsx(Re.p, { id: a.descriptionId, ...o, ref: t });
  }
);
dR.displayName = fR;
var hR = "DialogClose", pR = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...o } = e, a = tr(hR, n);
    return /* @__PURE__ */ S.jsx(
      Re.button,
      {
        type: "button",
        ...o,
        ref: t,
        onClick: pe(e.onClick, () => a.onOpenChange(!1))
      }
    );
  }
);
pR.displayName = hR;
function Dv(e) {
  return e ? "open" : "closed";
}
var mR = "DialogTitleWarning", [aY, gR] = BB(mR, {
  contentName: yi,
  titleName: zv,
  docsSlug: "dialog"
}), c8 = ({ titleId: e }) => {
  const t = gR(mR), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return y.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, u8 = "DialogDescriptionWarning", f8 = ({ contentRef: e, descriptionId: t }) => {
  const o = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${gR(u8).contentName}}.`;
  return y.useEffect(() => {
    const a = e.current?.getAttribute("aria-describedby");
    t && a && (document.getElementById(t) || console.warn(o));
  }, [o, e, t]), null;
}, d8 = rR, h8 = aR, p8 = sR, m8 = lR, g8 = uR, v8 = dR, y8 = pR;
function Nv({ ...e }) {
  return /* @__PURE__ */ S.jsx(d8, { "data-slot": "dialog", ...e });
}
function b8({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(h8, { "data-slot": "dialog-portal", ...e });
}
function x8({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    p8,
    {
      "data-slot": "dialog-overlay",
      className: Fe(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        e
      ),
      ...t
    }
  );
}
function Ov({
  className: e,
  children: t,
  showCloseButton: n = !0,
  ...o
}) {
  return /* @__PURE__ */ S.jsxs(b8, { "data-slot": "dialog-portal", children: [
    /* @__PURE__ */ S.jsx(x8, {}),
    /* @__PURE__ */ S.jsxs(
      m8,
      {
        "data-slot": "dialog-content",
        className: Fe(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-[1000] grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          e
        ),
        ...o,
        onCloseAutoFocus: (a) => {
          a.preventDefault(), document.body.style.pointerEvents = "";
        },
        children: [
          t,
          n && /* @__PURE__ */ S.jsxs(
            y8,
            {
              "data-slot": "dialog-close",
              className: "ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
              children: [
                /* @__PURE__ */ S.jsx(Af, {}),
                /* @__PURE__ */ S.jsx("span", { className: "sr-only", children: "Close" })
              ]
            }
          )
        ]
      }
    )
  ] });
}
function jv({ className: e, ...t }) {
  return /* @__PURE__ */ S.jsx(
    "div",
    {
      "data-slot": "dialog-header",
      className: Fe("flex flex-col gap-2 text-center sm:text-left", e),
      ...t
    }
  );
}
function vR({ className: e, ...t }) {
  return /* @__PURE__ */ S.jsx(
    "div",
    {
      "data-slot": "dialog-footer",
      className: Fe(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        e
      ),
      ...t
    }
  );
}
function kv({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    g8,
    {
      "data-slot": "dialog-title",
      className: Fe("text-lg leading-none font-semibold", e),
      ...t
    }
  );
}
function S8({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    v8,
    {
      "data-slot": "dialog-description",
      className: Fe("text-muted-foreground text-sm", e),
      ...t
    }
  );
}
var w8 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], E8 = w8.reduce((e, t) => {
  const n = /* @__PURE__ */ YC(`Primitive.${t}`), o = y.forwardRef((a, l) => {
    const { asChild: c, ...f } = a, d = c ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ S.jsx(d, { ...f, ref: l });
  });
  return o.displayName = `Primitive.${t}`, { ...e, [t]: o };
}, {}), _8 = "Label", yR = y.forwardRef((e, t) => /* @__PURE__ */ S.jsx(
  E8.label,
  {
    ...e,
    ref: t,
    onMouseDown: (n) => {
      n.target.closest("button, input, select, textarea") || (e.onMouseDown?.(n), !n.defaultPrevented && n.detail > 1 && n.preventDefault());
    }
  }
));
yR.displayName = _8;
var T8 = yR;
function C8({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    T8,
    {
      "data-slot": "label",
      className: Fe(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        e
      ),
      ...t
    }
  );
}
const A8 = { "gpt-4.1": "openai/gpt-4.1", "gpt-4.1-mini": "openai/gpt-4.1-mini", "gpt-4o-mini": "openai/gpt-4o-mini", "gpt-4o": "openai/gpt-4o", "gpt-5": "openai/gpt-5", "gpt-5.1": "openai/gpt-5.1", "gpt-5-mini": "openai/gpt-5-mini", "gpt-5-nano": "openai/gpt-5-nano", "gpt-oss-120b": "openai/gpt-oss-120b", "gpt-2.5-flash": "openai/gpt-2.5-flash" }, R8 = { "gemini-2.5-flash-lite": "google/gemini-2.5-flash-lite", "gemini-2.5-flash": "google/gemini-2.5-flash", "gemini-2.5-pro": "google/gemini-2.5-pro", "gemini-2.0-flash": "google/gemini-2.0-flash" }, M8 = { "claude-sonnet-4.5": "anthropic/claude-sonnet-4.5", "claude-sonnet-4": "anthropic/claude-sonnet-4", "claude-3.7-sonnet": "anthropic/claude-3.7-sonnet" }, z8 = { "grok-4-fast-reasoning": "xai/grok-4-fast-reasoning", "grok-4-fast-non-reasoning": "xai/grok-4-fast-non-reasoning" }, D8 = { "llama-4-maverick": "meta/llama-4-maverick" }, N8 = { "deepseek-v3.1": "deepseek/deepseek-v3.1" }, O8 = {
  openai: A8,
  google: R8,
  anthropic: M8,
  xai: z8,
  meta: D8,
  deepseek: N8
};
function cg(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
// @__NO_SIDE_EFFECTS__
function dE(e) {
  const t = /* @__PURE__ */ j8(e), n = y.forwardRef((o, a) => {
    const { children: l, ...c } = o, f = y.Children.toArray(l), d = f.find(P8);
    if (d) {
      const h = d.props.children, m = f.map((g) => g === d ? y.Children.count(h) > 1 ? y.Children.only(null) : y.isValidElement(h) ? h.props.children : null : g);
      return /* @__PURE__ */ S.jsx(t, { ...c, ref: a, children: y.isValidElement(h) ? y.cloneElement(h, void 0, m) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...c, ref: a, children: l });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function j8(e) {
  const t = y.forwardRef((n, o) => {
    const { children: a, ...l } = n;
    if (y.isValidElement(a)) {
      const c = I8(a), f = L8(l, a.props);
      return a.type !== y.Fragment && (f.ref = o ? qr(o, c) : c), y.cloneElement(a, f);
    }
    return y.Children.count(a) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var k8 = /* @__PURE__ */ Symbol("radix.slottable");
function P8(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === k8;
}
function L8(e, t) {
  const n = { ...t };
  for (const o in t) {
    const a = e[o], l = t[o];
    /^on[A-Z]/.test(o) ? a && l ? n[o] = (...f) => {
      const d = l(...f);
      return a(...f), d;
    } : a && (n[o] = a) : o === "style" ? n[o] = { ...a, ...l } : o === "className" && (n[o] = [a, l].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function I8(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function Pv(e) {
  const t = e + "CollectionProvider", [n, o] = yr(t), [a, l] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), c = (E) => {
    const { scope: T, children: C } = E, z = Kn.useRef(null), A = Kn.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ S.jsx(a, { scope: T, itemMap: A, collectionRef: z, children: C });
  };
  c.displayName = t;
  const f = e + "CollectionSlot", d = /* @__PURE__ */ dE(f), h = Kn.forwardRef(
    (E, T) => {
      const { scope: C, children: z } = E, A = l(f, C), R = Le(T, A.collectionRef);
      return /* @__PURE__ */ S.jsx(d, { ref: R, children: z });
    }
  );
  h.displayName = f;
  const m = e + "CollectionItemSlot", g = "data-radix-collection-item", b = /* @__PURE__ */ dE(m), x = Kn.forwardRef(
    (E, T) => {
      const { scope: C, children: z, ...A } = E, R = Kn.useRef(null), O = Le(T, R), L = l(m, C);
      return Kn.useEffect(() => (L.itemMap.set(R, { ref: R, ...A }), () => {
        L.itemMap.delete(R);
      })), /* @__PURE__ */ S.jsx(b, { [g]: "", ref: O, children: z });
    }
  );
  x.displayName = m;
  function _(E) {
    const T = l(e + "CollectionConsumer", E);
    return Kn.useCallback(() => {
      const z = T.collectionRef.current;
      if (!z) return [];
      const A = Array.from(z.querySelectorAll(`[${g}]`));
      return Array.from(T.itemMap.values()).sort(
        (L, M) => A.indexOf(L.ref.current) - A.indexOf(M.ref.current)
      );
    }, [T.collectionRef, T.itemMap]);
  }
  return [
    { Provider: c, Slot: h, ItemSlot: x },
    _,
    o
  ];
}
var V8 = y.createContext(void 0);
function Gf(e) {
  const t = y.useContext(V8);
  return e || t || "ltr";
}
// @__NO_SIDE_EFFECTS__
function U8(e) {
  const t = /* @__PURE__ */ B8(e), n = y.forwardRef((o, a) => {
    const { children: l, ...c } = o, f = y.Children.toArray(l), d = f.find(H8);
    if (d) {
      const h = d.props.children, m = f.map((g) => g === d ? y.Children.count(h) > 1 ? y.Children.only(null) : y.isValidElement(h) ? h.props.children : null : g);
      return /* @__PURE__ */ S.jsx(t, { ...c, ref: a, children: y.isValidElement(h) ? y.cloneElement(h, void 0, m) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...c, ref: a, children: l });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function B8(e) {
  const t = y.forwardRef((n, o) => {
    const { children: a, ...l } = n;
    if (y.isValidElement(a)) {
      const c = F8(a), f = Z8(l, a.props);
      return a.type !== y.Fragment && (f.ref = o ? qr(o, c) : c), y.cloneElement(a, f);
    }
    return y.Children.count(a) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var $8 = /* @__PURE__ */ Symbol("radix.slottable");
function H8(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === $8;
}
function Z8(e, t) {
  const n = { ...t };
  for (const o in t) {
    const a = e[o], l = t[o];
    /^on[A-Z]/.test(o) ? a && l ? n[o] = (...f) => {
      const d = l(...f);
      return a(...f), d;
    } : a && (n[o] = a) : o === "style" ? n[o] = { ...a, ...l } : o === "className" && (n[o] = [a, l].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function F8(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function bR(e) {
  const t = y.useRef({ value: e, previous: e });
  return y.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var G8 = [" ", "Enter", "ArrowUp", "ArrowDown"], Y8 = [" ", "Enter"], bi = "Select", [Yf, qf, q8] = Pv(bi), [Xa] = yr(bi, [
  q8,
  qa
]), Xf = qa(), [X8, Uo] = Xa(bi), [W8, K8] = Xa(bi), xR = (e) => {
  const {
    __scopeSelect: t,
    children: n,
    open: o,
    defaultOpen: a,
    onOpenChange: l,
    value: c,
    defaultValue: f,
    onValueChange: d,
    dir: h,
    name: m,
    autoComplete: g,
    disabled: b,
    required: x,
    form: _
  } = e, E = Xf(t), [T, C] = y.useState(null), [z, A] = y.useState(null), [R, O] = y.useState(!1), L = Gf(h), [M, N] = vi({
    prop: o,
    defaultProp: a ?? !1,
    onChange: l,
    caller: bi
  }), [j, Y] = vi({
    prop: c,
    defaultProp: f,
    onChange: d,
    caller: bi
  }), ne = y.useRef(null), J = T ? _ || !!T.closest("form") : !0, [he, fe] = y.useState(/* @__PURE__ */ new Set()), de = Array.from(he).map((I) => I.props.value).join(";");
  return /* @__PURE__ */ S.jsx(xv, { ...E, children: /* @__PURE__ */ S.jsxs(
    X8,
    {
      required: x,
      scope: t,
      trigger: T,
      onTriggerChange: C,
      valueNode: z,
      onValueNodeChange: A,
      valueNodeHasChildren: R,
      onValueNodeHasChildrenChange: O,
      contentId: hr(),
      value: j,
      onValueChange: Y,
      open: M,
      onOpenChange: N,
      dir: L,
      triggerPointerDownPosRef: ne,
      disabled: b,
      children: [
        /* @__PURE__ */ S.jsx(Yf.Provider, { scope: t, children: /* @__PURE__ */ S.jsx(
          W8,
          {
            scope: e.__scopeSelect,
            onNativeOptionAdd: y.useCallback((I) => {
              fe((G) => new Set(G).add(I));
            }, []),
            onNativeOptionRemove: y.useCallback((I) => {
              fe((G) => {
                const B = new Set(G);
                return B.delete(I), B;
              });
            }, []),
            children: n
          }
        ) }),
        J ? /* @__PURE__ */ S.jsxs(
          ZR,
          {
            "aria-hidden": !0,
            required: x,
            tabIndex: -1,
            name: m,
            autoComplete: g,
            value: j,
            onChange: (I) => Y(I.target.value),
            disabled: b,
            form: _,
            children: [
              j === void 0 ? /* @__PURE__ */ S.jsx("option", { value: "" }) : null,
              Array.from(he)
            ]
          },
          de
        ) : null
      ]
    }
  ) });
};
xR.displayName = bi;
var SR = "SelectTrigger", wR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, disabled: o = !1, ...a } = e, l = Xf(n), c = Uo(SR, n), f = c.disabled || o, d = Le(t, c.onTriggerChange), h = qf(n), m = y.useRef("touch"), [g, b, x] = GR((E) => {
      const T = h().filter((A) => !A.disabled), C = T.find((A) => A.value === c.value), z = YR(T, E, C);
      z !== void 0 && c.onValueChange(z.value);
    }), _ = (E) => {
      f || (c.onOpenChange(!0), x()), E && (c.triggerPointerDownPosRef.current = {
        x: Math.round(E.pageX),
        y: Math.round(E.pageY)
      });
    };
    return /* @__PURE__ */ S.jsx(Sv, { asChild: !0, ...l, children: /* @__PURE__ */ S.jsx(
      Re.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": c.contentId,
        "aria-expanded": c.open,
        "aria-required": c.required,
        "aria-autocomplete": "none",
        dir: c.dir,
        "data-state": c.open ? "open" : "closed",
        disabled: f,
        "data-disabled": f ? "" : void 0,
        "data-placeholder": FR(c.value) ? "" : void 0,
        ...a,
        ref: d,
        onClick: pe(a.onClick, (E) => {
          E.currentTarget.focus(), m.current !== "mouse" && _(E);
        }),
        onPointerDown: pe(a.onPointerDown, (E) => {
          m.current = E.pointerType;
          const T = E.target;
          T.hasPointerCapture(E.pointerId) && T.releasePointerCapture(E.pointerId), E.button === 0 && E.ctrlKey === !1 && E.pointerType === "mouse" && (_(E), E.preventDefault());
        }),
        onKeyDown: pe(a.onKeyDown, (E) => {
          const T = g.current !== "";
          !(E.ctrlKey || E.altKey || E.metaKey) && E.key.length === 1 && b(E.key), !(T && E.key === " ") && G8.includes(E.key) && (_(), E.preventDefault());
        })
      }
    ) });
  }
);
wR.displayName = SR;
var ER = "SelectValue", _R = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: o, style: a, children: l, placeholder: c = "", ...f } = e, d = Uo(ER, n), { onValueNodeHasChildrenChange: h } = d, m = l !== void 0, g = Le(t, d.onValueNodeChange);
    return Ht(() => {
      h(m);
    }, [h, m]), /* @__PURE__ */ S.jsx(
      Re.span,
      {
        ...f,
        ref: g,
        style: { pointerEvents: "none" },
        children: FR(d.value) ? /* @__PURE__ */ S.jsx(S.Fragment, { children: c }) : l
      }
    );
  }
);
_R.displayName = ER;
var J8 = "SelectIcon", TR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, children: o, ...a } = e;
    return /* @__PURE__ */ S.jsx(Re.span, { "aria-hidden": !0, ...a, ref: t, children: o || "" });
  }
);
TR.displayName = J8;
var Q8 = "SelectPortal", CR = (e) => /* @__PURE__ */ S.jsx(Il, { asChild: !0, ...e });
CR.displayName = Q8;
var xi = "SelectContent", AR = y.forwardRef(
  (e, t) => {
    const n = Uo(xi, e.__scopeSelect), [o, a] = y.useState();
    if (Ht(() => {
      a(new DocumentFragment());
    }, []), !n.open) {
      const l = o;
      return l ? Po.createPortal(
        /* @__PURE__ */ S.jsx(RR, { scope: e.__scopeSelect, children: /* @__PURE__ */ S.jsx(Yf.Slot, { scope: e.__scopeSelect, children: /* @__PURE__ */ S.jsx("div", { children: e.children }) }) }),
        l
      ) : null;
    }
    return /* @__PURE__ */ S.jsx(MR, { ...e, ref: t });
  }
);
AR.displayName = xi;
var Wn = 10, [RR, Bo] = Xa(xi), eZ = "SelectContentImpl", tZ = /* @__PURE__ */ U8("SelectContent.RemoveScroll"), MR = y.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      position: o = "item-aligned",
      onCloseAutoFocus: a,
      onEscapeKeyDown: l,
      onPointerDownOutside: c,
      //
      // PopperContent props
      side: f,
      sideOffset: d,
      align: h,
      alignOffset: m,
      arrowPadding: g,
      collisionBoundary: b,
      collisionPadding: x,
      sticky: _,
      hideWhenDetached: E,
      avoidCollisions: T,
      //
      ...C
    } = e, z = Uo(xi, n), [A, R] = y.useState(null), [O, L] = y.useState(null), M = Le(t, (U) => R(U)), [N, j] = y.useState(null), [Y, ne] = y.useState(
      null
    ), J = qf(n), [he, fe] = y.useState(!1), de = y.useRef(!1);
    y.useEffect(() => {
      if (A) return Rv(A);
    }, [A]), Av();
    const I = y.useCallback(
      (U) => {
        const [ie, ...ce] = J().map((ze) => ze.ref.current), [ue] = ce.slice(-1), _e = document.activeElement;
        for (const ze of U)
          if (ze === _e || (ze?.scrollIntoView({ block: "nearest" }), ze === ie && O && (O.scrollTop = 0), ze === ue && O && (O.scrollTop = O.scrollHeight), ze?.focus(), document.activeElement !== _e)) return;
      },
      [J, O]
    ), G = y.useCallback(
      () => I([N, A]),
      [I, N, A]
    );
    y.useEffect(() => {
      he && G();
    }, [he, G]);
    const { onOpenChange: B, triggerPointerDownPosRef: te } = z;
    y.useEffect(() => {
      if (A) {
        let U = { x: 0, y: 0 };
        const ie = (ue) => {
          U = {
            x: Math.abs(Math.round(ue.pageX) - (te.current?.x ?? 0)),
            y: Math.abs(Math.round(ue.pageY) - (te.current?.y ?? 0))
          };
        }, ce = (ue) => {
          U.x <= 10 && U.y <= 10 ? ue.preventDefault() : A.contains(ue.target) || B(!1), document.removeEventListener("pointermove", ie), te.current = null;
        };
        return te.current !== null && (document.addEventListener("pointermove", ie), document.addEventListener("pointerup", ce, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", ie), document.removeEventListener("pointerup", ce, { capture: !0 });
        };
      }
    }, [A, B, te]), y.useEffect(() => {
      const U = () => B(!1);
      return window.addEventListener("blur", U), window.addEventListener("resize", U), () => {
        window.removeEventListener("blur", U), window.removeEventListener("resize", U);
      };
    }, [B]);
    const [ae, k] = GR((U) => {
      const ie = J().filter((_e) => !_e.disabled), ce = ie.find((_e) => _e.ref.current === document.activeElement), ue = YR(ie, U, ce);
      ue && setTimeout(() => ue.ref.current.focus());
    }), X = y.useCallback(
      (U, ie, ce) => {
        const ue = !de.current && !ce;
        (z.value !== void 0 && z.value === ie || ue) && (j(U), ue && (de.current = !0));
      },
      [z.value]
    ), H = y.useCallback(() => A?.focus(), [A]), K = y.useCallback(
      (U, ie, ce) => {
        const ue = !de.current && !ce;
        (z.value !== void 0 && z.value === ie || ue) && ne(U);
      },
      [z.value]
    ), le = o === "popper" ? ug : zR, se = le === ug ? {
      side: f,
      sideOffset: d,
      align: h,
      alignOffset: m,
      arrowPadding: g,
      collisionBoundary: b,
      collisionPadding: x,
      sticky: _,
      hideWhenDetached: E,
      avoidCollisions: T
    } : {};
    return /* @__PURE__ */ S.jsx(
      RR,
      {
        scope: n,
        content: A,
        viewport: O,
        onViewportChange: L,
        itemRefCallback: X,
        selectedItem: N,
        onItemLeave: H,
        itemTextRefCallback: K,
        focusSelectedItem: G,
        selectedItemText: Y,
        position: o,
        isPositioned: he,
        searchRef: ae,
        children: /* @__PURE__ */ S.jsx(Zf, { as: tZ, allowPinchZoom: !0, children: /* @__PURE__ */ S.jsx(
          $f,
          {
            asChild: !0,
            trapped: z.open,
            onMountAutoFocus: (U) => {
              U.preventDefault();
            },
            onUnmountAutoFocus: pe(a, (U) => {
              z.trigger?.focus({ preventScroll: !0 }), U.preventDefault();
            }),
            children: /* @__PURE__ */ S.jsx(
              Pl,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: l,
                onPointerDownOutside: c,
                onFocusOutside: (U) => U.preventDefault(),
                onDismiss: () => z.onOpenChange(!1),
                children: /* @__PURE__ */ S.jsx(
                  le,
                  {
                    role: "listbox",
                    id: z.contentId,
                    "data-state": z.open ? "open" : "closed",
                    dir: z.dir,
                    onContextMenu: (U) => U.preventDefault(),
                    ...C,
                    ...se,
                    onPlaced: () => fe(!0),
                    ref: M,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...C.style
                    },
                    onKeyDown: pe(C.onKeyDown, (U) => {
                      const ie = U.ctrlKey || U.altKey || U.metaKey;
                      if (U.key === "Tab" && U.preventDefault(), !ie && U.key.length === 1 && k(U.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(U.key)) {
                        let ue = J().filter((_e) => !_e.disabled).map((_e) => _e.ref.current);
                        if (["ArrowUp", "End"].includes(U.key) && (ue = ue.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(U.key)) {
                          const _e = U.target, ze = ue.indexOf(_e);
                          ue = ue.slice(ze + 1);
                        }
                        setTimeout(() => I(ue)), U.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MR.displayName = eZ;
var nZ = "SelectItemAlignedPosition", zR = y.forwardRef((e, t) => {
  const { __scopeSelect: n, onPlaced: o, ...a } = e, l = Uo(xi, n), c = Bo(xi, n), [f, d] = y.useState(null), [h, m] = y.useState(null), g = Le(t, (M) => m(M)), b = qf(n), x = y.useRef(!1), _ = y.useRef(!0), { viewport: E, selectedItem: T, selectedItemText: C, focusSelectedItem: z } = c, A = y.useCallback(() => {
    if (l.trigger && l.valueNode && f && h && E && T && C) {
      const M = l.trigger.getBoundingClientRect(), N = h.getBoundingClientRect(), j = l.valueNode.getBoundingClientRect(), Y = C.getBoundingClientRect();
      if (l.dir !== "rtl") {
        const _e = Y.left - N.left, ze = j.left - _e, je = M.left - ze, Je = M.width + je, cn = Math.max(Je, N.width), _n = window.innerWidth - Wn, Sr = cg(ze, [
          Wn,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(Wn, _n - cn)
        ]);
        f.style.minWidth = Je + "px", f.style.left = Sr + "px";
      } else {
        const _e = N.right - Y.right, ze = window.innerWidth - j.right - _e, je = window.innerWidth - M.right - ze, Je = M.width + je, cn = Math.max(Je, N.width), _n = window.innerWidth - Wn, Sr = cg(ze, [
          Wn,
          Math.max(Wn, _n - cn)
        ]);
        f.style.minWidth = Je + "px", f.style.right = Sr + "px";
      }
      const ne = b(), J = window.innerHeight - Wn * 2, he = E.scrollHeight, fe = window.getComputedStyle(h), de = parseInt(fe.borderTopWidth, 10), I = parseInt(fe.paddingTop, 10), G = parseInt(fe.borderBottomWidth, 10), B = parseInt(fe.paddingBottom, 10), te = de + I + he + B + G, ae = Math.min(T.offsetHeight * 5, te), k = window.getComputedStyle(E), X = parseInt(k.paddingTop, 10), H = parseInt(k.paddingBottom, 10), K = M.top + M.height / 2 - Wn, le = J - K, se = T.offsetHeight / 2, U = T.offsetTop + se, ie = de + I + U, ce = te - ie;
      if (ie <= K) {
        const _e = ne.length > 0 && T === ne[ne.length - 1].ref.current;
        f.style.bottom = "0px";
        const ze = h.clientHeight - E.offsetTop - E.offsetHeight, je = Math.max(
          le,
          se + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (_e ? H : 0) + ze + G
        ), Je = ie + je;
        f.style.height = Je + "px";
      } else {
        const _e = ne.length > 0 && T === ne[0].ref.current;
        f.style.top = "0px";
        const je = Math.max(
          K,
          de + E.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (_e ? X : 0) + se
        ) + ce;
        f.style.height = je + "px", E.scrollTop = ie - K + E.offsetTop;
      }
      f.style.margin = `${Wn}px 0`, f.style.minHeight = ae + "px", f.style.maxHeight = J + "px", o?.(), requestAnimationFrame(() => x.current = !0);
    }
  }, [
    b,
    l.trigger,
    l.valueNode,
    f,
    h,
    E,
    T,
    C,
    l.dir,
    o
  ]);
  Ht(() => A(), [A]);
  const [R, O] = y.useState();
  Ht(() => {
    h && O(window.getComputedStyle(h).zIndex);
  }, [h]);
  const L = y.useCallback(
    (M) => {
      M && _.current === !0 && (A(), z?.(), _.current = !1);
    },
    [A, z]
  );
  return /* @__PURE__ */ S.jsx(
    oZ,
    {
      scope: n,
      contentWrapper: f,
      shouldExpandOnScrollRef: x,
      onScrollButtonChange: L,
      children: /* @__PURE__ */ S.jsx(
        "div",
        {
          ref: d,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: R
          },
          children: /* @__PURE__ */ S.jsx(
            Re.div,
            {
              ...a,
              ref: g,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...a.style
              }
            }
          )
        }
      )
    }
  );
});
zR.displayName = nZ;
var rZ = "SelectPopperPosition", ug = y.forwardRef((e, t) => {
  const {
    __scopeSelect: n,
    align: o = "start",
    collisionPadding: a = Wn,
    ...l
  } = e, c = Xf(n);
  return /* @__PURE__ */ S.jsx(
    wv,
    {
      ...c,
      ...l,
      ref: t,
      align: o,
      collisionPadding: a,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...l.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
ug.displayName = rZ;
var [oZ, Lv] = Xa(xi, {}), fg = "SelectViewport", DR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, nonce: o, ...a } = e, l = Bo(fg, n), c = Lv(fg, n), f = Le(t, l.onViewportChange), d = y.useRef(0);
    return /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: o
        }
      ),
      /* @__PURE__ */ S.jsx(Yf.Slot, { scope: n, children: /* @__PURE__ */ S.jsx(
        Re.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...a,
          ref: f,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...a.style
          },
          onScroll: pe(a.onScroll, (h) => {
            const m = h.currentTarget, { contentWrapper: g, shouldExpandOnScrollRef: b } = c;
            if (b?.current && g) {
              const x = Math.abs(d.current - m.scrollTop);
              if (x > 0) {
                const _ = window.innerHeight - Wn * 2, E = parseFloat(g.style.minHeight), T = parseFloat(g.style.height), C = Math.max(E, T);
                if (C < _) {
                  const z = C + x, A = Math.min(_, z), R = z - A;
                  g.style.height = A + "px", g.style.bottom === "0px" && (m.scrollTop = R > 0 ? R : 0, g.style.justifyContent = "flex-end");
                }
              }
            }
            d.current = m.scrollTop;
          })
        }
      ) })
    ] });
  }
);
DR.displayName = fg;
var NR = "SelectGroup", [iZ, aZ] = Xa(NR), OR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...o } = e, a = hr();
    return /* @__PURE__ */ S.jsx(iZ, { scope: n, id: a, children: /* @__PURE__ */ S.jsx(Re.div, { role: "group", "aria-labelledby": a, ...o, ref: t }) });
  }
);
OR.displayName = NR;
var jR = "SelectLabel", kR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...o } = e, a = aZ(jR, n);
    return /* @__PURE__ */ S.jsx(Re.div, { id: a.id, ...o, ref: t });
  }
);
kR.displayName = jR;
var pf = "SelectItem", [sZ, PR] = Xa(pf), LR = y.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      value: o,
      disabled: a = !1,
      textValue: l,
      ...c
    } = e, f = Uo(pf, n), d = Bo(pf, n), h = f.value === o, [m, g] = y.useState(l ?? ""), [b, x] = y.useState(!1), _ = Le(
      t,
      (z) => d.itemRefCallback?.(z, o, a)
    ), E = hr(), T = y.useRef("touch"), C = () => {
      a || (f.onValueChange(o), f.onOpenChange(!1));
    };
    if (o === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ S.jsx(
      sZ,
      {
        scope: n,
        value: o,
        disabled: a,
        textId: E,
        isSelected: h,
        onItemTextChange: y.useCallback((z) => {
          g((A) => A || (z?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ S.jsx(
          Yf.ItemSlot,
          {
            scope: n,
            value: o,
            disabled: a,
            textValue: m,
            children: /* @__PURE__ */ S.jsx(
              Re.div,
              {
                role: "option",
                "aria-labelledby": E,
                "data-highlighted": b ? "" : void 0,
                "aria-selected": h && b,
                "data-state": h ? "checked" : "unchecked",
                "aria-disabled": a || void 0,
                "data-disabled": a ? "" : void 0,
                tabIndex: a ? void 0 : -1,
                ...c,
                ref: _,
                onFocus: pe(c.onFocus, () => x(!0)),
                onBlur: pe(c.onBlur, () => x(!1)),
                onClick: pe(c.onClick, () => {
                  T.current !== "mouse" && C();
                }),
                onPointerUp: pe(c.onPointerUp, () => {
                  T.current === "mouse" && C();
                }),
                onPointerDown: pe(c.onPointerDown, (z) => {
                  T.current = z.pointerType;
                }),
                onPointerMove: pe(c.onPointerMove, (z) => {
                  T.current = z.pointerType, a ? d.onItemLeave?.() : T.current === "mouse" && z.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: pe(c.onPointerLeave, (z) => {
                  z.currentTarget === document.activeElement && d.onItemLeave?.();
                }),
                onKeyDown: pe(c.onKeyDown, (z) => {
                  d.searchRef?.current !== "" && z.key === " " || (Y8.includes(z.key) && C(), z.key === " " && z.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
LR.displayName = pf;
var ol = "SelectItemText", IR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: o, style: a, ...l } = e, c = Uo(ol, n), f = Bo(ol, n), d = PR(ol, n), h = K8(ol, n), [m, g] = y.useState(null), b = Le(
      t,
      (C) => g(C),
      d.onItemTextChange,
      (C) => f.itemTextRefCallback?.(C, d.value, d.disabled)
    ), x = m?.textContent, _ = y.useMemo(
      () => /* @__PURE__ */ S.jsx("option", { value: d.value, disabled: d.disabled, children: x }, d.value),
      [d.disabled, d.value, x]
    ), { onNativeOptionAdd: E, onNativeOptionRemove: T } = h;
    return Ht(() => (E(_), () => T(_)), [E, T, _]), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx(Re.span, { id: d.textId, ...l, ref: b }),
      d.isSelected && c.valueNode && !c.valueNodeHasChildren ? Po.createPortal(l.children, c.valueNode) : null
    ] });
  }
);
IR.displayName = ol;
var VR = "SelectItemIndicator", UR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...o } = e;
    return PR(VR, n).isSelected ? /* @__PURE__ */ S.jsx(Re.span, { "aria-hidden": !0, ...o, ref: t }) : null;
  }
);
UR.displayName = VR;
var dg = "SelectScrollUpButton", BR = y.forwardRef((e, t) => {
  const n = Bo(dg, e.__scopeSelect), o = Lv(dg, e.__scopeSelect), [a, l] = y.useState(!1), c = Le(t, o.onScrollButtonChange);
  return Ht(() => {
    if (n.viewport && n.isPositioned) {
      let f = function() {
        const h = d.scrollTop > 0;
        l(h);
      };
      const d = n.viewport;
      return f(), d.addEventListener("scroll", f), () => d.removeEventListener("scroll", f);
    }
  }, [n.viewport, n.isPositioned]), a ? /* @__PURE__ */ S.jsx(
    HR,
    {
      ...e,
      ref: c,
      onAutoScroll: () => {
        const { viewport: f, selectedItem: d } = n;
        f && d && (f.scrollTop = f.scrollTop - d.offsetHeight);
      }
    }
  ) : null;
});
BR.displayName = dg;
var hg = "SelectScrollDownButton", $R = y.forwardRef((e, t) => {
  const n = Bo(hg, e.__scopeSelect), o = Lv(hg, e.__scopeSelect), [a, l] = y.useState(!1), c = Le(t, o.onScrollButtonChange);
  return Ht(() => {
    if (n.viewport && n.isPositioned) {
      let f = function() {
        const h = d.scrollHeight - d.clientHeight, m = Math.ceil(d.scrollTop) < h;
        l(m);
      };
      const d = n.viewport;
      return f(), d.addEventListener("scroll", f), () => d.removeEventListener("scroll", f);
    }
  }, [n.viewport, n.isPositioned]), a ? /* @__PURE__ */ S.jsx(
    HR,
    {
      ...e,
      ref: c,
      onAutoScroll: () => {
        const { viewport: f, selectedItem: d } = n;
        f && d && (f.scrollTop = f.scrollTop + d.offsetHeight);
      }
    }
  ) : null;
});
$R.displayName = hg;
var HR = y.forwardRef((e, t) => {
  const { __scopeSelect: n, onAutoScroll: o, ...a } = e, l = Bo("SelectScrollButton", n), c = y.useRef(null), f = qf(n), d = y.useCallback(() => {
    c.current !== null && (window.clearInterval(c.current), c.current = null);
  }, []);
  return y.useEffect(() => () => d(), [d]), Ht(() => {
    f().find((m) => m.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [f]), /* @__PURE__ */ S.jsx(
    Re.div,
    {
      "aria-hidden": !0,
      ...a,
      ref: t,
      style: { flexShrink: 0, ...a.style },
      onPointerDown: pe(a.onPointerDown, () => {
        c.current === null && (c.current = window.setInterval(o, 50));
      }),
      onPointerMove: pe(a.onPointerMove, () => {
        l.onItemLeave?.(), c.current === null && (c.current = window.setInterval(o, 50));
      }),
      onPointerLeave: pe(a.onPointerLeave, () => {
        d();
      })
    }
  );
}), lZ = "SelectSeparator", cZ = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...o } = e;
    return /* @__PURE__ */ S.jsx(Re.div, { "aria-hidden": !0, ...o, ref: t });
  }
);
cZ.displayName = lZ;
var pg = "SelectArrow", uZ = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...o } = e, a = Xf(n), l = Uo(pg, n), c = Bo(pg, n);
    return l.open && c.position === "popper" ? /* @__PURE__ */ S.jsx(Ev, { ...a, ...o, ref: t }) : null;
  }
);
uZ.displayName = pg;
var fZ = "SelectBubbleInput", ZR = y.forwardRef(
  ({ __scopeSelect: e, value: t, ...n }, o) => {
    const a = y.useRef(null), l = Le(o, a), c = bR(t);
    return y.useEffect(() => {
      const f = a.current;
      if (!f) return;
      const d = window.HTMLSelectElement.prototype, m = Object.getOwnPropertyDescriptor(
        d,
        "value"
      ).set;
      if (c !== t && m) {
        const g = new Event("change", { bubbles: !0 });
        m.call(f, t), f.dispatchEvent(g);
      }
    }, [c, t]), /* @__PURE__ */ S.jsx(
      Re.select,
      {
        ...n,
        style: { ...kA, ...n.style },
        ref: l,
        defaultValue: t
      }
    );
  }
);
ZR.displayName = fZ;
function FR(e) {
  return e === "" || e === void 0;
}
function GR(e) {
  const t = $t(e), n = y.useRef(""), o = y.useRef(0), a = y.useCallback(
    (c) => {
      const f = n.current + c;
      t(f), (function d(h) {
        n.current = h, window.clearTimeout(o.current), h !== "" && (o.current = window.setTimeout(() => d(""), 1e3));
      })(f);
    },
    [t]
  ), l = y.useCallback(() => {
    n.current = "", window.clearTimeout(o.current);
  }, []);
  return y.useEffect(() => () => window.clearTimeout(o.current), []), [n, a, l];
}
function YR(e, t, n) {
  const a = t.length > 1 && Array.from(t).every((h) => h === t[0]) ? t[0] : t, l = n ? e.indexOf(n) : -1;
  let c = dZ(e, Math.max(l, 0));
  a.length === 1 && (c = c.filter((h) => h !== n));
  const d = c.find(
    (h) => h.textValue.toLowerCase().startsWith(a.toLowerCase())
  );
  return d !== n ? d : void 0;
}
function dZ(e, t) {
  return e.map((n, o) => e[(t + o) % e.length]);
}
var hZ = xR, pZ = wR, mZ = _R, gZ = TR, vZ = CR, yZ = AR, bZ = DR, xZ = OR, SZ = kR, wZ = LR, EZ = IR, _Z = UR, TZ = BR, CZ = $R;
function AZ({ ...e }) {
  return /* @__PURE__ */ S.jsx(hZ, { "data-slot": "select", ...e });
}
function RZ({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(xZ, { "data-slot": "select-group", ...e });
}
function MZ({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(mZ, { "data-slot": "select-value", ...e });
}
function zZ({
  className: e,
  size: t = "default",
  children: n,
  ...o
}) {
  return /* @__PURE__ */ S.jsxs(
    pZ,
    {
      "data-slot": "select-trigger",
      "data-size": t,
      className: Fe(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...o,
      children: [
        n,
        /* @__PURE__ */ S.jsx(gZ, { asChild: !0, children: /* @__PURE__ */ S.jsx(xg, { className: "size-4 opacity-50" }) })
      ]
    }
  );
}
function DZ({
  className: e,
  children: t,
  position: n = "popper",
  ...o
}) {
  return /* @__PURE__ */ S.jsx(vZ, { children: /* @__PURE__ */ S.jsxs(
    yZ,
    {
      "data-slot": "select-content",
      className: Fe(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
        n === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        e
      ),
      position: n,
      ...o,
      children: [
        /* @__PURE__ */ S.jsx(jZ, {}),
        /* @__PURE__ */ S.jsx(
          bZ,
          {
            className: Fe(
              "p-1",
              n === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
            ),
            children: t
          }
        ),
        /* @__PURE__ */ S.jsx(kZ, {})
      ]
    }
  ) });
}
function NZ({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    SZ,
    {
      "data-slot": "select-label",
      className: Fe("text-muted-foreground px-2 py-1.5 text-xs", e),
      ...t
    }
  );
}
function OZ({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ S.jsxs(
    wZ,
    {
      "data-slot": "select-item",
      className: Fe(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        e
      ),
      ...n,
      children: [
        /* @__PURE__ */ S.jsx("span", { className: "absolute right-2 flex size-3.5 items-center justify-center", children: /* @__PURE__ */ S.jsx(_Z, { children: /* @__PURE__ */ S.jsx(OE, { className: "size-4" }) }) }),
        /* @__PURE__ */ S.jsx(EZ, { children: t })
      ]
    }
  );
}
function jZ({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    TZ,
    {
      "data-slot": "select-scroll-up-button",
      className: Fe("flex cursor-default items-center justify-center py-1", e),
      ...t,
      children: /* @__PURE__ */ S.jsx(jE, { className: "size-4" })
    }
  );
}
function kZ({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    CZ,
    {
      "data-slot": "select-scroll-down-button",
      className: Fe("flex cursor-default items-center justify-center py-1", e),
      ...t,
      children: /* @__PURE__ */ S.jsx(xg, { className: "size-4" })
    }
  );
}
const qR = "claude-sonnet-4.5", PZ = ({
  open: e,
  onOpenChange: t,
  setApiKeyByName: n
}) => {
  const [o, a] = y.useState(
    localStorage.getItem("ai-name") || qR
  ), [l, c] = y.useState([]);
  y.useEffect(() => {
    const d = [];
    Object.entries(O8).forEach(([h, m]) => {
      d.push({ provider: h, models: Object.keys(m) });
    }), c(d);
  }, []);
  const f = async () => {
    try {
      localStorage.setItem("ai-name", o), window.dispatchEvent(new Event("chatbot:settings-updated")), n && await n(o), t(!1);
    } catch {
      t(!1);
    }
  };
  return /* @__PURE__ */ S.jsx(Nv, { open: e, onOpenChange: t, children: /* @__PURE__ */ S.jsxs(Ov, { className: "max-w-sm", children: [
    /* @__PURE__ */ S.jsxs(jv, { children: [
      /* @__PURE__ */ S.jsx(kv, { children: "Settings" }),
      /* @__PURE__ */ S.jsx(S8, { className: "text-xs text-muted-foreground italic", children: "Configure your chatbot model. Settings are stored locally." })
    ] }),
    /* @__PURE__ */ S.jsxs("div", { className: "flex flex-col gap-2 py-1", children: [
      /* @__PURE__ */ S.jsx(C8, { htmlFor: "openai-name", children: "Model name" }),
      /* @__PURE__ */ S.jsxs(AZ, { value: o, onValueChange: a, children: [
        /* @__PURE__ */ S.jsx(zZ, { id: "openai-name", className: "w-full", children: /* @__PURE__ */ S.jsx(MZ, { placeholder: "Select a model" }) }),
        /* @__PURE__ */ S.jsx(
          DZ,
          {
            position: "popper",
            className: "z-[9999] max-h-[30vh] overflow-y-auto",
            children: l.map((d) => /* @__PURE__ */ S.jsxs(RZ, { children: [
              /* @__PURE__ */ S.jsx(NZ, { children: d.provider }),
              d.models.map((h) => /* @__PURE__ */ S.jsx(OZ, { value: h, children: h }, h))
            ] }, d.provider))
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ S.jsx(vR, { children: /* @__PURE__ */ S.jsx(Dt, { onClick: f, type: "button", children: "Save" }) })
  ] }) });
};
function hE({ className: e }) {
  return /* @__PURE__ */ S.jsxs(
    "svg",
    {
      "aria-hidden": "true",
      viewBox: "0 0 24 24",
      version: "1.1",
      className: e,
      "data-view-component": "true",
      children: [
        /* @__PURE__ */ S.jsx(
          "path",
          {
            fill: "currentColor",
            d: "M15.688 2.343a2.588 2.588 0 00-3.61 0l-9.626 9.44a.863.863 0 01-1.203 0 .823.823 0 010-1.18l9.626-9.44a4.313 4.313 0 016.016 0 4.116 4.116 0 011.204 3.54 4.3 4.3 0 013.609 1.18l.05.05a4.115 4.115 0 010 5.9l-8.706 8.537a.274.274 0 000 .393l1.788 1.754a.823.823 0 010 1.18.863.863 0 01-1.203 0l-1.788-1.753a1.92 1.92 0 010-2.754l8.706-8.538a2.47 2.47 0 000-3.54l-.05-.049a2.588 2.588 0 00-3.607-.003l-7.172 7.034-.002.002-.098.097a.863.863 0 01-1.204 0 .823.823 0 010-1.18l7.273-7.133a2.47 2.47 0 00-.003-3.537z"
          }
        ),
        /* @__PURE__ */ S.jsx(
          "path",
          {
            fill: "currentColor",
            d: "M14.485 4.703a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a4.115 4.115 0 000 5.9 4.314 4.314 0 006.016 0l7.12-6.982a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a2.588 2.588 0 01-3.61 0 2.47 2.47 0 010-3.54l7.12-6.982z"
          }
        )
      ]
    }
  );
}
function LZ() {
  return /* @__PURE__ */ S.jsx("div", { className: "p-6", children: /* @__PURE__ */ S.jsxs("div", { className: "rounded-xl border bg-card p-6", children: [
    /* @__PURE__ */ S.jsx("div", { className: "text-base font-semibold", children: "MCP Configuration" }),
    /* @__PURE__ */ S.jsx("div", { className: "mt-2 text-sm text-muted-foreground", children: "UI placeholder (ported shell). Hook this up to your MCP server list and tools when ready." })
  ] }) });
}
function IZ({
  onClose: e,
  title: t = "Chatbot",
  version: n = "v1",
  setApiKeyByName: o,
  onToggleSidebar: a,
  isSidebarOpen: l = !1
}) {
  const [c, f] = y.useState(!1), [d, h] = y.useState(!1);
  return /* @__PURE__ */ S.jsxs(Cv, { delayDuration: 150, children: [
    /* @__PURE__ */ S.jsxs("div", { className: "chatbot-drag-handle bg-background h-12 px-4 flex items-center justify-between border-b rounded-t-2xl cursor-grab active:cursor-grabbing", children: [
      /* @__PURE__ */ S.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ S.jsx("div", { className: "h-7 w-7 inline-flex items-center justify-center rounded-lg bg-blue-100 dark:bg-[#1abcfe]/10", children: /* @__PURE__ */ S.jsx(a2, { className: "h-4 w-4 text-blue-500 dark:text-[#1abcfe]" }) }),
        /* @__PURE__ */ S.jsx("h3", { className: "text-base font-semibold leading-none text-neutral-900 dark:text-white", children: t }),
        /* @__PURE__ */ S.jsx(
          GA,
          {
            variant: "outline",
            className: "hidden sm:inline-flex border-blue-200 text-blue-500 bg-transparent dark:border-[#1abcfe]/40 dark:text-[#1abcfe]",
            children: n
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "flex items-center gap-1", children: [
        a && /* @__PURE__ */ S.jsxs(tl, { children: [
          /* @__PURE__ */ S.jsx(nl, { asChild: !0, children: /* @__PURE__ */ S.jsx(
            Dt,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-blue-500 cursor-pointer",
              onClick: a,
              "aria-label": l ? "Hide chat history" : "Show chat history",
              type: "button",
              children: /* @__PURE__ */ S.jsx(n2, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ S.jsx(rl, { children: l ? "Hide chat history" : "Show chat history" })
        ] }),
        /* @__PURE__ */ S.jsxs(tl, { children: [
          /* @__PURE__ */ S.jsx(nl, { asChild: !0, children: /* @__PURE__ */ S.jsx(
            Dt,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-blue-500 cursor-pointer",
              "aria-label": "Open settings",
              onClick: () => f(!0),
              type: "button",
              children: /* @__PURE__ */ S.jsx(S2, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ S.jsx(rl, { children: "Settings" })
        ] }),
        /* @__PURE__ */ S.jsxs(tl, { children: [
          /* @__PURE__ */ S.jsx(nl, { asChild: !0, children: /* @__PURE__ */ S.jsx(
            Dt,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-foreground cursor-pointer",
              onClick: () => h(!0),
              "aria-label": "MCP Configuration",
              type: "button",
              children: /* @__PURE__ */ S.jsx(hE, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ S.jsx(rl, { children: "MCP Configuration" })
        ] }),
        /* @__PURE__ */ S.jsxs(tl, { children: [
          /* @__PURE__ */ S.jsx(nl, { asChild: !0, children: /* @__PURE__ */ S.jsx(
            Dt,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-foreground cursor-pointer",
              onClick: e,
              "aria-label": "Close",
              type: "button",
              children: /* @__PURE__ */ S.jsx(Af, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ S.jsx(rl, { children: "Close" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ S.jsx(
      PZ,
      {
        open: c,
        onOpenChange: f,
        setApiKeyByName: o
      }
    ),
    /* @__PURE__ */ S.jsx(Nv, { open: d, onOpenChange: h, children: /* @__PURE__ */ S.jsxs(Ov, { className: "!w-[90vw] !max-w-[1400px] max-h-[85vh] overflow-hidden p-0 flex flex-col", children: [
      /* @__PURE__ */ S.jsx(jv, { className: "px-8 pt-6 pb-4 border-b bg-linear-to-r from-background to-muted/20", children: /* @__PURE__ */ S.jsxs(kv, { className: "flex items-center gap-3 text-xl font-bold", children: [
        /* @__PURE__ */ S.jsx("div", { className: "p-2 rounded-lg bg-primary/10", children: /* @__PURE__ */ S.jsx(hE, { className: "h-6 w-6 text-primary" }) }),
        "MCP Configuration"
      ] }) }),
      /* @__PURE__ */ S.jsx("div", { className: "overflow-y-auto px-4 flex-1", children: /* @__PURE__ */ S.jsx(LZ, {}) })
    ] }) })
  ] });
}
function VZ(e, t) {
  return y.useReducer((n, o) => t[n][o] ?? n, e);
}
var Iv = "ScrollArea", [XR] = yr(Iv), [UZ, $n] = XR(Iv), WR = y.forwardRef(
  (e, t) => {
    const {
      __scopeScrollArea: n,
      type: o = "hover",
      dir: a,
      scrollHideDelay: l = 600,
      ...c
    } = e, [f, d] = y.useState(null), [h, m] = y.useState(null), [g, b] = y.useState(null), [x, _] = y.useState(null), [E, T] = y.useState(null), [C, z] = y.useState(0), [A, R] = y.useState(0), [O, L] = y.useState(!1), [M, N] = y.useState(!1), j = Le(t, (ne) => d(ne)), Y = Gf(a);
    return /* @__PURE__ */ S.jsx(
      UZ,
      {
        scope: n,
        type: o,
        dir: Y,
        scrollHideDelay: l,
        scrollArea: f,
        viewport: h,
        onViewportChange: m,
        content: g,
        onContentChange: b,
        scrollbarX: x,
        onScrollbarXChange: _,
        scrollbarXEnabled: O,
        onScrollbarXEnabledChange: L,
        scrollbarY: E,
        onScrollbarYChange: T,
        scrollbarYEnabled: M,
        onScrollbarYEnabledChange: N,
        onCornerWidthChange: z,
        onCornerHeightChange: R,
        children: /* @__PURE__ */ S.jsx(
          Re.div,
          {
            dir: Y,
            ...c,
            ref: j,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": C + "px",
              "--radix-scroll-area-corner-height": A + "px",
              ...e.style
            }
          }
        )
      }
    );
  }
);
WR.displayName = Iv;
var KR = "ScrollAreaViewport", JR = y.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, children: o, nonce: a, ...l } = e, c = $n(KR, n), f = y.useRef(null), d = Le(t, f, c.onViewportChange);
    return /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: a
        }
      ),
      /* @__PURE__ */ S.jsx(
        Re.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...l,
          ref: d,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: c.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: c.scrollbarYEnabled ? "scroll" : "hidden",
            ...e.style
          },
          children: /* @__PURE__ */ S.jsx("div", { ref: c.onContentChange, style: { minWidth: "100%", display: "table" }, children: o })
        }
      )
    ] });
  }
);
JR.displayName = KR;
var xr = "ScrollAreaScrollbar", QR = y.forwardRef(
  (e, t) => {
    const { forceMount: n, ...o } = e, a = $n(xr, e.__scopeScrollArea), { onScrollbarXEnabledChange: l, onScrollbarYEnabledChange: c } = a, f = e.orientation === "horizontal";
    return y.useEffect(() => (f ? l(!0) : c(!0), () => {
      f ? l(!1) : c(!1);
    }), [f, l, c]), a.type === "hover" ? /* @__PURE__ */ S.jsx(BZ, { ...o, ref: t, forceMount: n }) : a.type === "scroll" ? /* @__PURE__ */ S.jsx($Z, { ...o, ref: t, forceMount: n }) : a.type === "auto" ? /* @__PURE__ */ S.jsx(eM, { ...o, ref: t, forceMount: n }) : a.type === "always" ? /* @__PURE__ */ S.jsx(Vv, { ...o, ref: t }) : null;
  }
);
QR.displayName = xr;
var BZ = y.forwardRef((e, t) => {
  const { forceMount: n, ...o } = e, a = $n(xr, e.__scopeScrollArea), [l, c] = y.useState(!1);
  return y.useEffect(() => {
    const f = a.scrollArea;
    let d = 0;
    if (f) {
      const h = () => {
        window.clearTimeout(d), c(!0);
      }, m = () => {
        d = window.setTimeout(() => c(!1), a.scrollHideDelay);
      };
      return f.addEventListener("pointerenter", h), f.addEventListener("pointerleave", m), () => {
        window.clearTimeout(d), f.removeEventListener("pointerenter", h), f.removeEventListener("pointerleave", m);
      };
    }
  }, [a.scrollArea, a.scrollHideDelay]), /* @__PURE__ */ S.jsx(ln, { present: n || l, children: /* @__PURE__ */ S.jsx(
    eM,
    {
      "data-state": l ? "visible" : "hidden",
      ...o,
      ref: t
    }
  ) });
}), $Z = y.forwardRef((e, t) => {
  const { forceMount: n, ...o } = e, a = $n(xr, e.__scopeScrollArea), l = e.orientation === "horizontal", c = Kf(() => d("SCROLL_END"), 100), [f, d] = VZ("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return y.useEffect(() => {
    if (f === "idle") {
      const h = window.setTimeout(() => d("HIDE"), a.scrollHideDelay);
      return () => window.clearTimeout(h);
    }
  }, [f, a.scrollHideDelay, d]), y.useEffect(() => {
    const h = a.viewport, m = l ? "scrollLeft" : "scrollTop";
    if (h) {
      let g = h[m];
      const b = () => {
        const x = h[m];
        g !== x && (d("SCROLL"), c()), g = x;
      };
      return h.addEventListener("scroll", b), () => h.removeEventListener("scroll", b);
    }
  }, [a.viewport, l, d, c]), /* @__PURE__ */ S.jsx(ln, { present: n || f !== "hidden", children: /* @__PURE__ */ S.jsx(
    Vv,
    {
      "data-state": f === "hidden" ? "hidden" : "visible",
      ...o,
      ref: t,
      onPointerEnter: pe(e.onPointerEnter, () => d("POINTER_ENTER")),
      onPointerLeave: pe(e.onPointerLeave, () => d("POINTER_LEAVE"))
    }
  ) });
}), eM = y.forwardRef((e, t) => {
  const n = $n(xr, e.__scopeScrollArea), { forceMount: o, ...a } = e, [l, c] = y.useState(!1), f = e.orientation === "horizontal", d = Kf(() => {
    if (n.viewport) {
      const h = n.viewport.offsetWidth < n.viewport.scrollWidth, m = n.viewport.offsetHeight < n.viewport.scrollHeight;
      c(f ? h : m);
    }
  }, 10);
  return Ia(n.viewport, d), Ia(n.content, d), /* @__PURE__ */ S.jsx(ln, { present: o || l, children: /* @__PURE__ */ S.jsx(
    Vv,
    {
      "data-state": l ? "visible" : "hidden",
      ...a,
      ref: t
    }
  ) });
}), Vv = y.forwardRef((e, t) => {
  const { orientation: n = "vertical", ...o } = e, a = $n(xr, e.__scopeScrollArea), l = y.useRef(null), c = y.useRef(0), [f, d] = y.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), h = iM(f.viewport, f.content), m = {
    ...o,
    sizes: f,
    onSizesChange: d,
    hasThumb: h > 0 && h < 1,
    onThumbChange: (b) => l.current = b,
    onThumbPointerUp: () => c.current = 0,
    onThumbPointerDown: (b) => c.current = b
  };
  function g(b, x) {
    return qZ(b, c.current, f, x);
  }
  return n === "horizontal" ? /* @__PURE__ */ S.jsx(
    HZ,
    {
      ...m,
      ref: t,
      onThumbPositionChange: () => {
        if (a.viewport && l.current) {
          const b = a.viewport.scrollLeft, x = pE(b, f, a.dir);
          l.current.style.transform = `translate3d(${x}px, 0, 0)`;
        }
      },
      onWheelScroll: (b) => {
        a.viewport && (a.viewport.scrollLeft = b);
      },
      onDragScroll: (b) => {
        a.viewport && (a.viewport.scrollLeft = g(b, a.dir));
      }
    }
  ) : n === "vertical" ? /* @__PURE__ */ S.jsx(
    ZZ,
    {
      ...m,
      ref: t,
      onThumbPositionChange: () => {
        if (a.viewport && l.current) {
          const b = a.viewport.scrollTop, x = pE(b, f);
          l.current.style.transform = `translate3d(0, ${x}px, 0)`;
        }
      },
      onWheelScroll: (b) => {
        a.viewport && (a.viewport.scrollTop = b);
      },
      onDragScroll: (b) => {
        a.viewport && (a.viewport.scrollTop = g(b));
      }
    }
  ) : null;
}), HZ = y.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: o, ...a } = e, l = $n(xr, e.__scopeScrollArea), [c, f] = y.useState(), d = y.useRef(null), h = Le(t, d, l.onScrollbarXChange);
  return y.useEffect(() => {
    d.current && f(getComputedStyle(d.current));
  }, [d]), /* @__PURE__ */ S.jsx(
    nM,
    {
      "data-orientation": "horizontal",
      ...a,
      ref: h,
      sizes: n,
      style: {
        bottom: 0,
        left: l.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: l.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": Wf(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (m) => e.onThumbPointerDown(m.x),
      onDragScroll: (m) => e.onDragScroll(m.x),
      onWheelScroll: (m, g) => {
        if (l.viewport) {
          const b = l.viewport.scrollLeft + m.deltaX;
          e.onWheelScroll(b), sM(b, g) && m.preventDefault();
        }
      },
      onResize: () => {
        d.current && l.viewport && c && o({
          content: l.viewport.scrollWidth,
          viewport: l.viewport.offsetWidth,
          scrollbar: {
            size: d.current.clientWidth,
            paddingStart: gf(c.paddingLeft),
            paddingEnd: gf(c.paddingRight)
          }
        });
      }
    }
  );
}), ZZ = y.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: o, ...a } = e, l = $n(xr, e.__scopeScrollArea), [c, f] = y.useState(), d = y.useRef(null), h = Le(t, d, l.onScrollbarYChange);
  return y.useEffect(() => {
    d.current && f(getComputedStyle(d.current));
  }, [d]), /* @__PURE__ */ S.jsx(
    nM,
    {
      "data-orientation": "vertical",
      ...a,
      ref: h,
      sizes: n,
      style: {
        top: 0,
        right: l.dir === "ltr" ? 0 : void 0,
        left: l.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": Wf(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (m) => e.onThumbPointerDown(m.y),
      onDragScroll: (m) => e.onDragScroll(m.y),
      onWheelScroll: (m, g) => {
        if (l.viewport) {
          const b = l.viewport.scrollTop + m.deltaY;
          e.onWheelScroll(b), sM(b, g) && m.preventDefault();
        }
      },
      onResize: () => {
        d.current && l.viewport && c && o({
          content: l.viewport.scrollHeight,
          viewport: l.viewport.offsetHeight,
          scrollbar: {
            size: d.current.clientHeight,
            paddingStart: gf(c.paddingTop),
            paddingEnd: gf(c.paddingBottom)
          }
        });
      }
    }
  );
}), [FZ, tM] = XR(xr), nM = y.forwardRef((e, t) => {
  const {
    __scopeScrollArea: n,
    sizes: o,
    hasThumb: a,
    onThumbChange: l,
    onThumbPointerUp: c,
    onThumbPointerDown: f,
    onThumbPositionChange: d,
    onDragScroll: h,
    onWheelScroll: m,
    onResize: g,
    ...b
  } = e, x = $n(xr, n), [_, E] = y.useState(null), T = Le(t, (j) => E(j)), C = y.useRef(null), z = y.useRef(""), A = x.viewport, R = o.content - o.viewport, O = $t(m), L = $t(d), M = Kf(g, 10);
  function N(j) {
    if (C.current) {
      const Y = j.clientX - C.current.left, ne = j.clientY - C.current.top;
      h({ x: Y, y: ne });
    }
  }
  return y.useEffect(() => {
    const j = (Y) => {
      const ne = Y.target;
      _?.contains(ne) && O(Y, R);
    };
    return document.addEventListener("wheel", j, { passive: !1 }), () => document.removeEventListener("wheel", j, { passive: !1 });
  }, [A, _, R, O]), y.useEffect(L, [o, L]), Ia(_, M), Ia(x.content, M), /* @__PURE__ */ S.jsx(
    FZ,
    {
      scope: n,
      scrollbar: _,
      hasThumb: a,
      onThumbChange: $t(l),
      onThumbPointerUp: $t(c),
      onThumbPositionChange: L,
      onThumbPointerDown: $t(f),
      children: /* @__PURE__ */ S.jsx(
        Re.div,
        {
          ...b,
          ref: T,
          style: { position: "absolute", ...b.style },
          onPointerDown: pe(e.onPointerDown, (j) => {
            j.button === 0 && (j.target.setPointerCapture(j.pointerId), C.current = _.getBoundingClientRect(), z.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", x.viewport && (x.viewport.style.scrollBehavior = "auto"), N(j));
          }),
          onPointerMove: pe(e.onPointerMove, N),
          onPointerUp: pe(e.onPointerUp, (j) => {
            const Y = j.target;
            Y.hasPointerCapture(j.pointerId) && Y.releasePointerCapture(j.pointerId), document.body.style.webkitUserSelect = z.current, x.viewport && (x.viewport.style.scrollBehavior = ""), C.current = null;
          })
        }
      )
    }
  );
}), mf = "ScrollAreaThumb", rM = y.forwardRef(
  (e, t) => {
    const { forceMount: n, ...o } = e, a = tM(mf, e.__scopeScrollArea);
    return /* @__PURE__ */ S.jsx(ln, { present: n || a.hasThumb, children: /* @__PURE__ */ S.jsx(GZ, { ref: t, ...o }) });
  }
), GZ = y.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, style: o, ...a } = e, l = $n(mf, n), c = tM(mf, n), { onThumbPositionChange: f } = c, d = Le(
      t,
      (g) => c.onThumbChange(g)
    ), h = y.useRef(void 0), m = Kf(() => {
      h.current && (h.current(), h.current = void 0);
    }, 100);
    return y.useEffect(() => {
      const g = l.viewport;
      if (g) {
        const b = () => {
          if (m(), !h.current) {
            const x = XZ(g, f);
            h.current = x, f();
          }
        };
        return f(), g.addEventListener("scroll", b), () => g.removeEventListener("scroll", b);
      }
    }, [l.viewport, m, f]), /* @__PURE__ */ S.jsx(
      Re.div,
      {
        "data-state": c.hasThumb ? "visible" : "hidden",
        ...a,
        ref: d,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...o
        },
        onPointerDownCapture: pe(e.onPointerDownCapture, (g) => {
          const x = g.target.getBoundingClientRect(), _ = g.clientX - x.left, E = g.clientY - x.top;
          c.onThumbPointerDown({ x: _, y: E });
        }),
        onPointerUp: pe(e.onPointerUp, c.onThumbPointerUp)
      }
    );
  }
);
rM.displayName = mf;
var Uv = "ScrollAreaCorner", oM = y.forwardRef(
  (e, t) => {
    const n = $n(Uv, e.__scopeScrollArea), o = !!(n.scrollbarX && n.scrollbarY);
    return n.type !== "scroll" && o ? /* @__PURE__ */ S.jsx(YZ, { ...e, ref: t }) : null;
  }
);
oM.displayName = Uv;
var YZ = y.forwardRef((e, t) => {
  const { __scopeScrollArea: n, ...o } = e, a = $n(Uv, n), [l, c] = y.useState(0), [f, d] = y.useState(0), h = !!(l && f);
  return Ia(a.scrollbarX, () => {
    const m = a.scrollbarX?.offsetHeight || 0;
    a.onCornerHeightChange(m), d(m);
  }), Ia(a.scrollbarY, () => {
    const m = a.scrollbarY?.offsetWidth || 0;
    a.onCornerWidthChange(m), c(m);
  }), h ? /* @__PURE__ */ S.jsx(
    Re.div,
    {
      ...o,
      ref: t,
      style: {
        width: l,
        height: f,
        position: "absolute",
        right: a.dir === "ltr" ? 0 : void 0,
        left: a.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...e.style
      }
    }
  ) : null;
});
function gf(e) {
  return e ? parseInt(e, 10) : 0;
}
function iM(e, t) {
  const n = e / t;
  return isNaN(n) ? 0 : n;
}
function Wf(e) {
  const t = iM(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, o = (e.scrollbar.size - n) * t;
  return Math.max(o, 18);
}
function qZ(e, t, n, o = "ltr") {
  const a = Wf(n), l = a / 2, c = t || l, f = a - c, d = n.scrollbar.paddingStart + c, h = n.scrollbar.size - n.scrollbar.paddingEnd - f, m = n.content - n.viewport, g = o === "ltr" ? [0, m] : [m * -1, 0];
  return aM([d, h], g)(e);
}
function pE(e, t, n = "ltr") {
  const o = Wf(t), a = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, l = t.scrollbar.size - a, c = t.content - t.viewport, f = l - o, d = n === "ltr" ? [0, c] : [c * -1, 0], h = cg(e, d);
  return aM([0, c], [0, f])(h);
}
function aM(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const o = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + o * (n - e[0]);
  };
}
function sM(e, t) {
  return e > 0 && e < t;
}
var XZ = (e, t = () => {
}) => {
  let n = { left: e.scrollLeft, top: e.scrollTop }, o = 0;
  return (function a() {
    const l = { left: e.scrollLeft, top: e.scrollTop }, c = n.left !== l.left, f = n.top !== l.top;
    (c || f) && t(), n = l, o = window.requestAnimationFrame(a);
  })(), () => window.cancelAnimationFrame(o);
};
function Kf(e, t) {
  const n = $t(e), o = y.useRef(0);
  return y.useEffect(() => () => window.clearTimeout(o.current), []), y.useCallback(() => {
    window.clearTimeout(o.current), o.current = window.setTimeout(n, t);
  }, [n, t]);
}
function Ia(e, t) {
  const n = $t(t);
  Ht(() => {
    let o = 0;
    if (e) {
      const a = new ResizeObserver(() => {
        cancelAnimationFrame(o), o = window.requestAnimationFrame(n);
      });
      return a.observe(e), () => {
        window.cancelAnimationFrame(o), a.unobserve(e);
      };
    }
  }, [e, n]);
}
var WZ = WR, KZ = JR, JZ = oM;
function lM({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ S.jsxs(
    WZ,
    {
      "data-slot": "scroll-area",
      className: Fe("relative", e),
      ...n,
      children: [
        /* @__PURE__ */ S.jsx(
          KZ,
          {
            "data-slot": "scroll-area-viewport",
            className: "focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1",
            children: t
          }
        ),
        /* @__PURE__ */ S.jsx(QZ, {}),
        /* @__PURE__ */ S.jsx(JZ, {})
      ]
    }
  );
}
function QZ({
  className: e,
  orientation: t = "vertical",
  ...n
}) {
  return /* @__PURE__ */ S.jsx(
    QR,
    {
      "data-slot": "scroll-area-scrollbar",
      orientation: t,
      className: Fe(
        "flex touch-none p-px transition-colors select-none",
        t === "vertical" && "h-full w-2.5 border-l border-l-transparent",
        t === "horizontal" && "h-2.5 flex-col border-t border-t-transparent",
        e
      ),
      ...n,
      children: /* @__PURE__ */ S.jsx(
        rM,
        {
          "data-slot": "scroll-area-thumb",
          className: "bg-border relative flex-1 rounded-full"
        }
      )
    }
  );
}
var pm = "rovingFocusGroup.onEntryFocus", e7 = { bubbles: !1, cancelable: !0 }, Ul = "RovingFocusGroup", [mg, cM, t7] = Pv(Ul), [n7, uM] = yr(
  Ul,
  [t7]
), [r7, o7] = n7(Ul), fM = y.forwardRef(
  (e, t) => /* @__PURE__ */ S.jsx(mg.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ S.jsx(mg.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ S.jsx(i7, { ...e, ref: t }) }) })
);
fM.displayName = Ul;
var i7 = y.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: o,
    loop: a = !1,
    dir: l,
    currentTabStopId: c,
    defaultCurrentTabStopId: f,
    onCurrentTabStopIdChange: d,
    onEntryFocus: h,
    preventScrollOnEntryFocus: m = !1,
    ...g
  } = e, b = y.useRef(null), x = Le(t, b), _ = Gf(l), [E, T] = vi({
    prop: c,
    defaultProp: f ?? null,
    onChange: d,
    caller: Ul
  }), [C, z] = y.useState(!1), A = $t(h), R = cM(n), O = y.useRef(!1), [L, M] = y.useState(0);
  return y.useEffect(() => {
    const N = b.current;
    if (N)
      return N.addEventListener(pm, A), () => N.removeEventListener(pm, A);
  }, [A]), /* @__PURE__ */ S.jsx(
    r7,
    {
      scope: n,
      orientation: o,
      dir: _,
      loop: a,
      currentTabStopId: E,
      onItemFocus: y.useCallback(
        (N) => T(N),
        [T]
      ),
      onItemShiftTab: y.useCallback(() => z(!0), []),
      onFocusableItemAdd: y.useCallback(
        () => M((N) => N + 1),
        []
      ),
      onFocusableItemRemove: y.useCallback(
        () => M((N) => N - 1),
        []
      ),
      children: /* @__PURE__ */ S.jsx(
        Re.div,
        {
          tabIndex: C || L === 0 ? -1 : 0,
          "data-orientation": o,
          ...g,
          ref: x,
          style: { outline: "none", ...e.style },
          onMouseDown: pe(e.onMouseDown, () => {
            O.current = !0;
          }),
          onFocus: pe(e.onFocus, (N) => {
            const j = !O.current;
            if (N.target === N.currentTarget && j && !C) {
              const Y = new CustomEvent(pm, e7);
              if (N.currentTarget.dispatchEvent(Y), !Y.defaultPrevented) {
                const ne = R().filter((I) => I.focusable), J = ne.find((I) => I.active), he = ne.find((I) => I.id === E), de = [J, he, ...ne].filter(
                  Boolean
                ).map((I) => I.ref.current);
                pM(de, m);
              }
            }
            O.current = !1;
          }),
          onBlur: pe(e.onBlur, () => z(!1))
        }
      )
    }
  );
}), dM = "RovingFocusGroupItem", hM = y.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: o = !0,
      active: a = !1,
      tabStopId: l,
      children: c,
      ...f
    } = e, d = hr(), h = l || d, m = o7(dM, n), g = m.currentTabStopId === h, b = cM(n), { onFocusableItemAdd: x, onFocusableItemRemove: _, currentTabStopId: E } = m;
    return y.useEffect(() => {
      if (o)
        return x(), () => _();
    }, [o, x, _]), /* @__PURE__ */ S.jsx(
      mg.ItemSlot,
      {
        scope: n,
        id: h,
        focusable: o,
        active: a,
        children: /* @__PURE__ */ S.jsx(
          Re.span,
          {
            tabIndex: g ? 0 : -1,
            "data-orientation": m.orientation,
            ...f,
            ref: t,
            onMouseDown: pe(e.onMouseDown, (T) => {
              o ? m.onItemFocus(h) : T.preventDefault();
            }),
            onFocus: pe(e.onFocus, () => m.onItemFocus(h)),
            onKeyDown: pe(e.onKeyDown, (T) => {
              if (T.key === "Tab" && T.shiftKey) {
                m.onItemShiftTab();
                return;
              }
              if (T.target !== T.currentTarget) return;
              const C = l7(T, m.orientation, m.dir);
              if (C !== void 0) {
                if (T.metaKey || T.ctrlKey || T.altKey || T.shiftKey) return;
                T.preventDefault();
                let A = b().filter((R) => R.focusable).map((R) => R.ref.current);
                if (C === "last") A.reverse();
                else if (C === "prev" || C === "next") {
                  C === "prev" && A.reverse();
                  const R = A.indexOf(T.currentTarget);
                  A = m.loop ? c7(A, R + 1) : A.slice(R + 1);
                }
                setTimeout(() => pM(A));
              }
            }),
            children: typeof c == "function" ? c({ isCurrentTabStop: g, hasTabStop: E != null }) : c
          }
        )
      }
    );
  }
);
hM.displayName = dM;
var a7 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function s7(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function l7(e, t, n) {
  const o = s7(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(o)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(o)))
    return a7[o];
}
function pM(e, t = !1) {
  const n = document.activeElement;
  for (const o of e)
    if (o === n || (o.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function c7(e, t) {
  return e.map((n, o) => e[(t + o) % e.length]);
}
var u7 = fM, f7 = hM;
// @__NO_SIDE_EFFECTS__
function d7(e) {
  const t = /* @__PURE__ */ h7(e), n = y.forwardRef((o, a) => {
    const { children: l, ...c } = o, f = y.Children.toArray(l), d = f.find(m7);
    if (d) {
      const h = d.props.children, m = f.map((g) => g === d ? y.Children.count(h) > 1 ? y.Children.only(null) : y.isValidElement(h) ? h.props.children : null : g);
      return /* @__PURE__ */ S.jsx(t, { ...c, ref: a, children: y.isValidElement(h) ? y.cloneElement(h, void 0, m) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...c, ref: a, children: l });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function h7(e) {
  const t = y.forwardRef((n, o) => {
    const { children: a, ...l } = n;
    if (y.isValidElement(a)) {
      const c = v7(a), f = g7(l, a.props);
      return a.type !== y.Fragment && (f.ref = o ? qr(o, c) : c), y.cloneElement(a, f);
    }
    return y.Children.count(a) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var p7 = /* @__PURE__ */ Symbol("radix.slottable");
function m7(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === p7;
}
function g7(e, t) {
  const n = { ...t };
  for (const o in t) {
    const a = e[o], l = t[o];
    /^on[A-Z]/.test(o) ? a && l ? n[o] = (...f) => {
      const d = l(...f);
      return a(...f), d;
    } : a && (n[o] = a) : o === "style" ? n[o] = { ...a, ...l } : o === "className" && (n[o] = [a, l].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function v7(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var gg = ["Enter", " "], y7 = ["ArrowDown", "PageUp", "Home"], mM = ["ArrowUp", "PageDown", "End"], b7 = [...y7, ...mM], x7 = {
  ltr: [...gg, "ArrowRight"],
  rtl: [...gg, "ArrowLeft"]
}, S7 = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, Bl = "Menu", [_l, w7, E7] = Pv(Bl), [Ei, gM] = yr(Bl, [
  E7,
  qa,
  uM
]), Jf = qa(), vM = uM(), [_7, _i] = Ei(Bl), [T7, $l] = Ei(Bl), yM = (e) => {
  const { __scopeMenu: t, open: n = !1, children: o, dir: a, onOpenChange: l, modal: c = !0 } = e, f = Jf(t), [d, h] = y.useState(null), m = y.useRef(!1), g = $t(l), b = Gf(a);
  return y.useEffect(() => {
    const x = () => {
      m.current = !0, document.addEventListener("pointerdown", _, { capture: !0, once: !0 }), document.addEventListener("pointermove", _, { capture: !0, once: !0 });
    }, _ = () => m.current = !1;
    return document.addEventListener("keydown", x, { capture: !0 }), () => {
      document.removeEventListener("keydown", x, { capture: !0 }), document.removeEventListener("pointerdown", _, { capture: !0 }), document.removeEventListener("pointermove", _, { capture: !0 });
    };
  }, []), /* @__PURE__ */ S.jsx(xv, { ...f, children: /* @__PURE__ */ S.jsx(
    _7,
    {
      scope: t,
      open: n,
      onOpenChange: g,
      content: d,
      onContentChange: h,
      children: /* @__PURE__ */ S.jsx(
        T7,
        {
          scope: t,
          onClose: y.useCallback(() => g(!1), [g]),
          isUsingKeyboardRef: m,
          dir: b,
          modal: c,
          children: o
        }
      )
    }
  ) });
};
yM.displayName = Bl;
var C7 = "MenuAnchor", Bv = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...o } = e, a = Jf(n);
    return /* @__PURE__ */ S.jsx(Sv, { ...a, ...o, ref: t });
  }
);
Bv.displayName = C7;
var $v = "MenuPortal", [A7, bM] = Ei($v, {
  forceMount: void 0
}), xM = (e) => {
  const { __scopeMenu: t, forceMount: n, children: o, container: a } = e, l = _i($v, t);
  return /* @__PURE__ */ S.jsx(A7, { scope: t, forceMount: n, children: /* @__PURE__ */ S.jsx(ln, { present: n || l.open, children: /* @__PURE__ */ S.jsx(Il, { asChild: !0, container: a, children: o }) }) });
};
xM.displayName = $v;
var Vn = "MenuContent", [R7, Hv] = Ei(Vn), SM = y.forwardRef(
  (e, t) => {
    const n = bM(Vn, e.__scopeMenu), { forceMount: o = n.forceMount, ...a } = e, l = _i(Vn, e.__scopeMenu), c = $l(Vn, e.__scopeMenu);
    return /* @__PURE__ */ S.jsx(_l.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(ln, { present: o || l.open, children: /* @__PURE__ */ S.jsx(_l.Slot, { scope: e.__scopeMenu, children: c.modal ? /* @__PURE__ */ S.jsx(M7, { ...a, ref: t }) : /* @__PURE__ */ S.jsx(z7, { ...a, ref: t }) }) }) });
  }
), M7 = y.forwardRef(
  (e, t) => {
    const n = _i(Vn, e.__scopeMenu), o = y.useRef(null), a = Le(t, o);
    return y.useEffect(() => {
      const l = o.current;
      if (l) return Rv(l);
    }, []), /* @__PURE__ */ S.jsx(
      Zv,
      {
        ...e,
        ref: a,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: pe(
          e.onFocusOutside,
          (l) => l.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), z7 = y.forwardRef((e, t) => {
  const n = _i(Vn, e.__scopeMenu);
  return /* @__PURE__ */ S.jsx(
    Zv,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), D7 = /* @__PURE__ */ d7("MenuContent.ScrollLock"), Zv = y.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: o = !1,
      trapFocus: a,
      onOpenAutoFocus: l,
      onCloseAutoFocus: c,
      disableOutsidePointerEvents: f,
      onEntryFocus: d,
      onEscapeKeyDown: h,
      onPointerDownOutside: m,
      onFocusOutside: g,
      onInteractOutside: b,
      onDismiss: x,
      disableOutsideScroll: _,
      ...E
    } = e, T = _i(Vn, n), C = $l(Vn, n), z = Jf(n), A = vM(n), R = w7(n), [O, L] = y.useState(null), M = y.useRef(null), N = Le(t, M, T.onContentChange), j = y.useRef(0), Y = y.useRef(""), ne = y.useRef(0), J = y.useRef(null), he = y.useRef("right"), fe = y.useRef(0), de = _ ? Zf : y.Fragment, I = _ ? { as: D7, allowPinchZoom: !0 } : void 0, G = (te) => {
      const ae = Y.current + te, k = R().filter((U) => !U.disabled), X = document.activeElement, H = k.find((U) => U.ref.current === X)?.textValue, K = k.map((U) => U.textValue), le = H7(K, ae, H), se = k.find((U) => U.textValue === le)?.ref.current;
      (function U(ie) {
        Y.current = ie, window.clearTimeout(j.current), ie !== "" && (j.current = window.setTimeout(() => U(""), 1e3));
      })(ae), se && setTimeout(() => se.focus());
    };
    y.useEffect(() => () => window.clearTimeout(j.current), []), Av();
    const B = y.useCallback((te) => he.current === J.current?.side && F7(te, J.current?.area), []);
    return /* @__PURE__ */ S.jsx(
      R7,
      {
        scope: n,
        searchRef: Y,
        onItemEnter: y.useCallback(
          (te) => {
            B(te) && te.preventDefault();
          },
          [B]
        ),
        onItemLeave: y.useCallback(
          (te) => {
            B(te) || (M.current?.focus(), L(null));
          },
          [B]
        ),
        onTriggerLeave: y.useCallback(
          (te) => {
            B(te) && te.preventDefault();
          },
          [B]
        ),
        pointerGraceTimerRef: ne,
        onPointerGraceIntentChange: y.useCallback((te) => {
          J.current = te;
        }, []),
        children: /* @__PURE__ */ S.jsx(de, { ...I, children: /* @__PURE__ */ S.jsx(
          $f,
          {
            asChild: !0,
            trapped: a,
            onMountAutoFocus: pe(l, (te) => {
              te.preventDefault(), M.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: c,
            children: /* @__PURE__ */ S.jsx(
              Pl,
              {
                asChild: !0,
                disableOutsidePointerEvents: f,
                onEscapeKeyDown: h,
                onPointerDownOutside: m,
                onFocusOutside: g,
                onInteractOutside: b,
                onDismiss: x,
                children: /* @__PURE__ */ S.jsx(
                  u7,
                  {
                    asChild: !0,
                    ...A,
                    dir: C.dir,
                    orientation: "vertical",
                    loop: o,
                    currentTabStopId: O,
                    onCurrentTabStopIdChange: L,
                    onEntryFocus: pe(d, (te) => {
                      C.isUsingKeyboardRef.current || te.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ S.jsx(
                      wv,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": LM(T.open),
                        "data-radix-menu-content": "",
                        dir: C.dir,
                        ...z,
                        ...E,
                        ref: N,
                        style: { outline: "none", ...E.style },
                        onKeyDown: pe(E.onKeyDown, (te) => {
                          const k = te.target.closest("[data-radix-menu-content]") === te.currentTarget, X = te.ctrlKey || te.altKey || te.metaKey, H = te.key.length === 1;
                          k && (te.key === "Tab" && te.preventDefault(), !X && H && G(te.key));
                          const K = M.current;
                          if (te.target !== K || !b7.includes(te.key)) return;
                          te.preventDefault();
                          const se = R().filter((U) => !U.disabled).map((U) => U.ref.current);
                          mM.includes(te.key) && se.reverse(), B7(se);
                        }),
                        onBlur: pe(e.onBlur, (te) => {
                          te.currentTarget.contains(te.target) || (window.clearTimeout(j.current), Y.current = "");
                        }),
                        onPointerMove: pe(
                          e.onPointerMove,
                          Tl((te) => {
                            const ae = te.target, k = fe.current !== te.clientX;
                            if (te.currentTarget.contains(ae) && k) {
                              const X = te.clientX > fe.current ? "right" : "left";
                              he.current = X, fe.current = te.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SM.displayName = Vn;
var N7 = "MenuGroup", Fv = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...o } = e;
    return /* @__PURE__ */ S.jsx(Re.div, { role: "group", ...o, ref: t });
  }
);
Fv.displayName = N7;
var O7 = "MenuLabel", wM = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...o } = e;
    return /* @__PURE__ */ S.jsx(Re.div, { ...o, ref: t });
  }
);
wM.displayName = O7;
var vf = "MenuItem", mE = "menu.itemSelect", Qf = y.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: o, ...a } = e, l = y.useRef(null), c = $l(vf, e.__scopeMenu), f = Hv(vf, e.__scopeMenu), d = Le(t, l), h = y.useRef(!1), m = () => {
      const g = l.current;
      if (!n && g) {
        const b = new CustomEvent(mE, { bubbles: !0, cancelable: !0 });
        g.addEventListener(mE, (x) => o?.(x), { once: !0 }), uA(g, b), b.defaultPrevented ? h.current = !1 : c.onClose();
      }
    };
    return /* @__PURE__ */ S.jsx(
      EM,
      {
        ...a,
        ref: d,
        disabled: n,
        onClick: pe(e.onClick, m),
        onPointerDown: (g) => {
          e.onPointerDown?.(g), h.current = !0;
        },
        onPointerUp: pe(e.onPointerUp, (g) => {
          h.current || g.currentTarget?.click();
        }),
        onKeyDown: pe(e.onKeyDown, (g) => {
          const b = f.searchRef.current !== "";
          n || b && g.key === " " || gg.includes(g.key) && (g.currentTarget.click(), g.preventDefault());
        })
      }
    );
  }
);
Qf.displayName = vf;
var EM = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: o = !1, textValue: a, ...l } = e, c = Hv(vf, n), f = vM(n), d = y.useRef(null), h = Le(t, d), [m, g] = y.useState(!1), [b, x] = y.useState("");
    return y.useEffect(() => {
      const _ = d.current;
      _ && x((_.textContent ?? "").trim());
    }, [l.children]), /* @__PURE__ */ S.jsx(
      _l.ItemSlot,
      {
        scope: n,
        disabled: o,
        textValue: a ?? b,
        children: /* @__PURE__ */ S.jsx(f7, { asChild: !0, ...f, focusable: !o, children: /* @__PURE__ */ S.jsx(
          Re.div,
          {
            role: "menuitem",
            "data-highlighted": m ? "" : void 0,
            "aria-disabled": o || void 0,
            "data-disabled": o ? "" : void 0,
            ...l,
            ref: h,
            onPointerMove: pe(
              e.onPointerMove,
              Tl((_) => {
                o ? c.onItemLeave(_) : (c.onItemEnter(_), _.defaultPrevented || _.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: pe(
              e.onPointerLeave,
              Tl((_) => c.onItemLeave(_))
            ),
            onFocus: pe(e.onFocus, () => g(!0)),
            onBlur: pe(e.onBlur, () => g(!1))
          }
        ) })
      }
    );
  }
), j7 = "MenuCheckboxItem", _M = y.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: o, ...a } = e;
    return /* @__PURE__ */ S.jsx(MM, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ S.jsx(
      Qf,
      {
        role: "menuitemcheckbox",
        "aria-checked": yf(n) ? "mixed" : n,
        ...a,
        ref: t,
        "data-state": Yv(n),
        onSelect: pe(
          a.onSelect,
          () => o?.(yf(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
_M.displayName = j7;
var TM = "MenuRadioGroup", [k7, P7] = Ei(
  TM,
  { value: void 0, onValueChange: () => {
  } }
), CM = y.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: o, ...a } = e, l = $t(o);
    return /* @__PURE__ */ S.jsx(k7, { scope: e.__scopeMenu, value: n, onValueChange: l, children: /* @__PURE__ */ S.jsx(Fv, { ...a, ref: t }) });
  }
);
CM.displayName = TM;
var AM = "MenuRadioItem", RM = y.forwardRef(
  (e, t) => {
    const { value: n, ...o } = e, a = P7(AM, e.__scopeMenu), l = n === a.value;
    return /* @__PURE__ */ S.jsx(MM, { scope: e.__scopeMenu, checked: l, children: /* @__PURE__ */ S.jsx(
      Qf,
      {
        role: "menuitemradio",
        "aria-checked": l,
        ...o,
        ref: t,
        "data-state": Yv(l),
        onSelect: pe(
          o.onSelect,
          () => a.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
RM.displayName = AM;
var Gv = "MenuItemIndicator", [MM, L7] = Ei(
  Gv,
  { checked: !1 }
), zM = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: o, ...a } = e, l = L7(Gv, n);
    return /* @__PURE__ */ S.jsx(
      ln,
      {
        present: o || yf(l.checked) || l.checked === !0,
        children: /* @__PURE__ */ S.jsx(
          Re.span,
          {
            ...a,
            ref: t,
            "data-state": Yv(l.checked)
          }
        )
      }
    );
  }
);
zM.displayName = Gv;
var I7 = "MenuSeparator", DM = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...o } = e;
    return /* @__PURE__ */ S.jsx(
      Re.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...o,
        ref: t
      }
    );
  }
);
DM.displayName = I7;
var V7 = "MenuArrow", NM = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...o } = e, a = Jf(n);
    return /* @__PURE__ */ S.jsx(Ev, { ...a, ...o, ref: t });
  }
);
NM.displayName = V7;
var U7 = "MenuSub", [sY, OM] = Ei(U7), il = "MenuSubTrigger", jM = y.forwardRef(
  (e, t) => {
    const n = _i(il, e.__scopeMenu), o = $l(il, e.__scopeMenu), a = OM(il, e.__scopeMenu), l = Hv(il, e.__scopeMenu), c = y.useRef(null), { pointerGraceTimerRef: f, onPointerGraceIntentChange: d } = l, h = { __scopeMenu: e.__scopeMenu }, m = y.useCallback(() => {
      c.current && window.clearTimeout(c.current), c.current = null;
    }, []);
    return y.useEffect(() => m, [m]), y.useEffect(() => {
      const g = f.current;
      return () => {
        window.clearTimeout(g), d(null);
      };
    }, [f, d]), /* @__PURE__ */ S.jsx(Bv, { asChild: !0, ...h, children: /* @__PURE__ */ S.jsx(
      EM,
      {
        id: a.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": a.contentId,
        "data-state": LM(n.open),
        ...e,
        ref: qr(t, a.onTriggerChange),
        onClick: (g) => {
          e.onClick?.(g), !(e.disabled || g.defaultPrevented) && (g.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: pe(
          e.onPointerMove,
          Tl((g) => {
            l.onItemEnter(g), !g.defaultPrevented && !e.disabled && !n.open && !c.current && (l.onPointerGraceIntentChange(null), c.current = window.setTimeout(() => {
              n.onOpenChange(!0), m();
            }, 100));
          })
        ),
        onPointerLeave: pe(
          e.onPointerLeave,
          Tl((g) => {
            m();
            const b = n.content?.getBoundingClientRect();
            if (b) {
              const x = n.content?.dataset.side, _ = x === "right", E = _ ? -5 : 5, T = b[_ ? "left" : "right"], C = b[_ ? "right" : "left"];
              l.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: g.clientX + E, y: g.clientY },
                  { x: T, y: b.top },
                  { x: C, y: b.top },
                  { x: C, y: b.bottom },
                  { x: T, y: b.bottom }
                ],
                side: x
              }), window.clearTimeout(f.current), f.current = window.setTimeout(
                () => l.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (l.onTriggerLeave(g), g.defaultPrevented) return;
              l.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: pe(e.onKeyDown, (g) => {
          const b = l.searchRef.current !== "";
          e.disabled || b && g.key === " " || x7[o.dir].includes(g.key) && (n.onOpenChange(!0), n.content?.focus(), g.preventDefault());
        })
      }
    ) });
  }
);
jM.displayName = il;
var kM = "MenuSubContent", PM = y.forwardRef(
  (e, t) => {
    const n = bM(Vn, e.__scopeMenu), { forceMount: o = n.forceMount, ...a } = e, l = _i(Vn, e.__scopeMenu), c = $l(Vn, e.__scopeMenu), f = OM(kM, e.__scopeMenu), d = y.useRef(null), h = Le(t, d);
    return /* @__PURE__ */ S.jsx(_l.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(ln, { present: o || l.open, children: /* @__PURE__ */ S.jsx(_l.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(
      Zv,
      {
        id: f.contentId,
        "aria-labelledby": f.triggerId,
        ...a,
        ref: h,
        align: "start",
        side: c.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (m) => {
          c.isUsingKeyboardRef.current && d.current?.focus(), m.preventDefault();
        },
        onCloseAutoFocus: (m) => m.preventDefault(),
        onFocusOutside: pe(e.onFocusOutside, (m) => {
          m.target !== f.trigger && l.onOpenChange(!1);
        }),
        onEscapeKeyDown: pe(e.onEscapeKeyDown, (m) => {
          c.onClose(), m.preventDefault();
        }),
        onKeyDown: pe(e.onKeyDown, (m) => {
          const g = m.currentTarget.contains(m.target), b = S7[c.dir].includes(m.key);
          g && b && (l.onOpenChange(!1), f.trigger?.focus(), m.preventDefault());
        })
      }
    ) }) }) });
  }
);
PM.displayName = kM;
function LM(e) {
  return e ? "open" : "closed";
}
function yf(e) {
  return e === "indeterminate";
}
function Yv(e) {
  return yf(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function B7(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function $7(e, t) {
  return e.map((n, o) => e[(t + o) % e.length]);
}
function H7(e, t, n) {
  const a = t.length > 1 && Array.from(t).every((h) => h === t[0]) ? t[0] : t, l = n ? e.indexOf(n) : -1;
  let c = $7(e, Math.max(l, 0));
  a.length === 1 && (c = c.filter((h) => h !== n));
  const d = c.find(
    (h) => h.toLowerCase().startsWith(a.toLowerCase())
  );
  return d !== n ? d : void 0;
}
function Z7(e, t) {
  const { x: n, y: o } = e;
  let a = !1;
  for (let l = 0, c = t.length - 1; l < t.length; c = l++) {
    const f = t[l], d = t[c], h = f.x, m = f.y, g = d.x, b = d.y;
    m > o != b > o && n < (g - h) * (o - m) / (b - m) + h && (a = !a);
  }
  return a;
}
function F7(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return Z7(n, t);
}
function Tl(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var G7 = yM, Y7 = Bv, q7 = xM, X7 = SM, W7 = Fv, K7 = wM, J7 = Qf, Q7 = _M, eF = CM, tF = RM, nF = zM, rF = DM, oF = NM, iF = jM, aF = PM, ed = "DropdownMenu", [sF] = yr(
  ed,
  [gM]
), Kt = gM(), [lF, IM] = sF(ed), VM = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: o,
    open: a,
    defaultOpen: l,
    onOpenChange: c,
    modal: f = !0
  } = e, d = Kt(t), h = y.useRef(null), [m, g] = vi({
    prop: a,
    defaultProp: l ?? !1,
    onChange: c,
    caller: ed
  });
  return /* @__PURE__ */ S.jsx(
    lF,
    {
      scope: t,
      triggerId: hr(),
      triggerRef: h,
      contentId: hr(),
      open: m,
      onOpenChange: g,
      onOpenToggle: y.useCallback(() => g((b) => !b), [g]),
      modal: f,
      children: /* @__PURE__ */ S.jsx(G7, { ...d, open: m, onOpenChange: g, dir: o, modal: f, children: n })
    }
  );
};
VM.displayName = ed;
var UM = "DropdownMenuTrigger", BM = y.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: o = !1, ...a } = e, l = IM(UM, n), c = Kt(n);
    return /* @__PURE__ */ S.jsx(Y7, { asChild: !0, ...c, children: /* @__PURE__ */ S.jsx(
      Re.button,
      {
        type: "button",
        id: l.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": l.open,
        "aria-controls": l.open ? l.contentId : void 0,
        "data-state": l.open ? "open" : "closed",
        "data-disabled": o ? "" : void 0,
        disabled: o,
        ...a,
        ref: qr(t, l.triggerRef),
        onPointerDown: pe(e.onPointerDown, (f) => {
          !o && f.button === 0 && f.ctrlKey === !1 && (l.onOpenToggle(), l.open || f.preventDefault());
        }),
        onKeyDown: pe(e.onKeyDown, (f) => {
          o || (["Enter", " "].includes(f.key) && l.onOpenToggle(), f.key === "ArrowDown" && l.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(f.key) && f.preventDefault());
        })
      }
    ) });
  }
);
BM.displayName = UM;
var cF = "DropdownMenuPortal", $M = (e) => {
  const { __scopeDropdownMenu: t, ...n } = e, o = Kt(t);
  return /* @__PURE__ */ S.jsx(q7, { ...o, ...n });
};
$M.displayName = cF;
var HM = "DropdownMenuContent", ZM = y.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...o } = e, a = IM(HM, n), l = Kt(n), c = y.useRef(!1);
    return /* @__PURE__ */ S.jsx(
      X7,
      {
        id: a.contentId,
        "aria-labelledby": a.triggerId,
        ...l,
        ...o,
        ref: t,
        onCloseAutoFocus: pe(e.onCloseAutoFocus, (f) => {
          c.current || a.triggerRef.current?.focus(), c.current = !1, f.preventDefault();
        }),
        onInteractOutside: pe(e.onInteractOutside, (f) => {
          const d = f.detail.originalEvent, h = d.button === 0 && d.ctrlKey === !0, m = d.button === 2 || h;
          (!a.modal || m) && (c.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
ZM.displayName = HM;
var uF = "DropdownMenuGroup", fF = y.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...o } = e, a = Kt(n);
    return /* @__PURE__ */ S.jsx(W7, { ...a, ...o, ref: t });
  }
);
fF.displayName = uF;
var dF = "DropdownMenuLabel", hF = y.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...o } = e, a = Kt(n);
    return /* @__PURE__ */ S.jsx(K7, { ...a, ...o, ref: t });
  }
);
hF.displayName = dF;
var pF = "DropdownMenuItem", FM = y.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...o } = e, a = Kt(n);
    return /* @__PURE__ */ S.jsx(J7, { ...a, ...o, ref: t });
  }
);
FM.displayName = pF;
var mF = "DropdownMenuCheckboxItem", gF = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, a = Kt(n);
  return /* @__PURE__ */ S.jsx(Q7, { ...a, ...o, ref: t });
});
gF.displayName = mF;
var vF = "DropdownMenuRadioGroup", yF = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, a = Kt(n);
  return /* @__PURE__ */ S.jsx(eF, { ...a, ...o, ref: t });
});
yF.displayName = vF;
var bF = "DropdownMenuRadioItem", xF = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, a = Kt(n);
  return /* @__PURE__ */ S.jsx(tF, { ...a, ...o, ref: t });
});
xF.displayName = bF;
var SF = "DropdownMenuItemIndicator", wF = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, a = Kt(n);
  return /* @__PURE__ */ S.jsx(nF, { ...a, ...o, ref: t });
});
wF.displayName = SF;
var EF = "DropdownMenuSeparator", _F = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, a = Kt(n);
  return /* @__PURE__ */ S.jsx(rF, { ...a, ...o, ref: t });
});
_F.displayName = EF;
var TF = "DropdownMenuArrow", CF = y.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...o } = e, a = Kt(n);
    return /* @__PURE__ */ S.jsx(oF, { ...a, ...o, ref: t });
  }
);
CF.displayName = TF;
var AF = "DropdownMenuSubTrigger", RF = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, a = Kt(n);
  return /* @__PURE__ */ S.jsx(iF, { ...a, ...o, ref: t });
});
RF.displayName = AF;
var MF = "DropdownMenuSubContent", zF = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, a = Kt(n);
  return /* @__PURE__ */ S.jsx(
    aF,
    {
      ...a,
      ...o,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
zF.displayName = MF;
var DF = VM, NF = BM, OF = $M, jF = ZM, kF = FM;
function GM({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(DF, { "data-slot": "dropdown-menu", ...e });
}
function YM({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(
    NF,
    {
      "data-slot": "dropdown-menu-trigger",
      ...e
    }
  );
}
function qM({
  className: e,
  sideOffset: t = 4,
  ...n
}) {
  return /* @__PURE__ */ S.jsx(OF, { children: /* @__PURE__ */ S.jsx(
    jF,
    {
      "data-slot": "dropdown-menu-content",
      sideOffset: t,
      className: Fe(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
        e
      ),
      ...n,
      onCloseAutoFocus: (o) => {
        o.preventDefault(), document.body.style.pointerEvents = "";
      }
    }
  ) });
}
function Vu({
  className: e,
  inset: t,
  variant: n = "default",
  ...o
}) {
  return /* @__PURE__ */ S.jsx(
    kF,
    {
      "data-slot": "dropdown-menu-item",
      "data-inset": t,
      "data-variant": n,
      className: Fe(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...o
    }
  );
}
function PF({ className: e, type: t, ...n }) {
  return /* @__PURE__ */ S.jsx(
    "input",
    {
      type: t,
      "data-slot": "input",
      className: Fe(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-sm border bg-transparent px-3 py-1 text-xs shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50",
        "focus:border-input focus-visible:border-input",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        e
      ),
      ...n
    }
  );
}
function LF({
  open: e,
  onConfirm: t,
  onCancel: n
}) {
  return /* @__PURE__ */ S.jsx(Nv, { open: e, onOpenChange: n, children: /* @__PURE__ */ S.jsxs(Ov, { className: "max-w-md", children: [
    /* @__PURE__ */ S.jsxs(jv, { children: [
      /* @__PURE__ */ S.jsx(kv, { children: "Delete Conversation" }),
      /* @__PURE__ */ S.jsx("p", { className: "text-xs italic text-muted-foreground mt-1", children: "Are you sure you want to delete this conversation? This action is irreversible and you will not be able to recover the deleted messages." })
    ] }),
    /* @__PURE__ */ S.jsxs(vR, { children: [
      /* @__PURE__ */ S.jsx(
        Dt,
        {
          variant: "outline",
          onClick: n,
          type: "button",
          className: "cursor-pointer",
          children: "Cancel"
        }
      ),
      /* @__PURE__ */ S.jsx(
        Dt,
        {
          variant: "destructive",
          onClick: t,
          type: "button",
          className: "cursor-pointer",
          children: "Delete Conversation"
        }
      )
    ] })
  ] }) });
}
const XM = ({
  message: e = "Loading..."
}) => /* @__PURE__ */ S.jsx("div", { className: "flex items-center justify-center h-full m-auto p-4", children: /* @__PURE__ */ S.jsxs("div", { className: "flex flex-col items-center gap-3", children: [
  /* @__PURE__ */ S.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-primary" }),
  /* @__PURE__ */ S.jsx("p", { className: "text-sm text-muted-foreground", children: e })
] }) }), WM = "chatbot.threads.v1", qv = "chatbot:threads-updated";
function Xv(e) {
  return `chatbot.thread.${e}.messages.v1`;
}
function KM(e) {
  if (!e) return null;
  try {
    return JSON.parse(e);
  } catch {
    return null;
  }
}
function hi() {
  const e = KM(localStorage.getItem(WM));
  return (Array.isArray(e) ? e : []).filter((n) => n && typeof n.id == "string").map((n) => ({
    id: String(n.id),
    title: typeof n.title == "string" ? n.title : "New chat",
    createdAt: typeof n.createdAt == "number" ? n.createdAt : Date.now(),
    updatedAt: typeof n.updatedAt == "number" ? n.updatedAt : Date.now()
  })).sort((n, o) => o.updatedAt - n.updatedAt);
}
function bf(e) {
  localStorage.setItem(WM, JSON.stringify(e)), window.dispatchEvent(new Event(qv));
}
function IF(e, t) {
  const n = Date.now(), o = hi(), a = o.find((d) => d.id === e), l = (t ?? "").trim();
  if (!a) {
    bf([
      {
        id: e,
        title: l || "New chat",
        createdAt: n,
        updatedAt: n
      },
      ...o
    ]);
    return;
  }
  const f = (!a.title || a.title.trim() === "" || a.title === "New chat") && l ? l : a.title;
  bf(
    o.map(
      (d) => d.id === e ? {
        ...d,
        title: f,
        updatedAt: n
      } : d
    )
  );
}
function VF(e, t) {
  const n = t.trim();
  if (!n) return;
  const o = hi();
  bf(
    o.map((a) => a.id === e ? { ...a, title: n, updatedAt: Date.now() } : a)
  );
}
function UF(e) {
  const t = hi();
  bf(t.filter((n) => n.id !== e)), localStorage.removeItem(Xv(e)), window.dispatchEvent(new Event(qv));
}
function BF(e) {
  const t = KM(localStorage.getItem(Xv(e)));
  return Array.isArray(t) ? t : [];
}
function $F(e, t) {
  localStorage.setItem(Xv(e), JSON.stringify(t)), window.dispatchEvent(new Event(qv));
}
function JM(e) {
  const t = e.trim().replace(/\/$/, "");
  return t ? /\/api\/v1$/.test(t) ? t : `${t}/api/v1` : "http://localhost:5000/api/v1";
}
function HF() {
  return "http://localhost:5000";
}
let Cl = JM(HF());
function ZF(e) {
  Cl = JM(e);
}
const FF = {
  "Content-Type": "application/json"
};
let GF = null;
function YF() {
  if (typeof window > "u") return null;
  const e = window.__CHATBOT_CONFIG__;
  return !e || typeof e != "object" ? null : e;
}
async function qF() {
  const e = YF();
  try {
    const t = e?.getAuthToken;
    if (typeof t == "function") {
      const n = await t();
      if (typeof n == "string" && n.trim()) return n.trim();
    }
  } catch {
  }
  if (typeof e?.authToken == "string" && e.authToken.trim())
    return e.authToken.trim();
  try {
    const n = await window?.Clerk?.session?.getToken?.();
    if (typeof n == "string" && n.trim()) return n.trim();
  } catch {
  }
  try {
    const t = localStorage.getItem("access_token") ?? localStorage.getItem("token") ?? localStorage.getItem("jwt") ?? "";
    return t && t.trim() ? t.trim() : null;
  } catch {
    return null;
  }
}
async function QM() {
  const e = await qF();
  return {
    ...FF,
    ...e ? { Authorization: `Bearer ${e}` } : {}
  };
}
function xf(e) {
  if (typeof e == "number" && Number.isFinite(e)) return e;
  if (typeof e == "string") {
    const t = Date.parse(e);
    if (!Number.isNaN(t)) return t;
  }
  return Date.now();
}
function ez(e) {
  if (!e || typeof e != "object") return null;
  const t = String(e.id ?? e.threadId ?? "");
  return t ? {
    id: t,
    title: typeof e.title == "string" ? e.title : null,
    createdAt: e.createdAt ?? e.created_at ?? null,
    updatedAt: e.updatedAt ?? e.updated_at ?? null
  } : null;
}
function XF(e) {
  return (Array.isArray(e) ? e : Array.isArray(e?.threads) ? e.threads : Array.isArray(e?.data) ? e.data : []).map(ez).filter((n) => !!n).map((n) => ({
    ...n,
    createdAt: xf(n.createdAt),
    updatedAt: xf(n.updatedAt)
  })).sort((n, o) => o.updatedAt - n.updatedAt);
}
async function tz() {
  return await QM();
}
function nz(e) {
  const t = e.trim().replace(/\/$/, "");
  return t ? /\/api\/v1$/.test(t) ? `${t}/` : /\/api\/v1\//.test(t) ? t.replace(/\/?$/, "/") : `${t}/api/v1/` : "http://localhost:5000/api/v1/";
}
async function WF(e = Cl, t) {
  const n = await tz(), o = new URL("thread", nz(e)), a = await fetch(o.toString(), { headers: { ...n } });
  if (!a.ok) {
    if ((a.headers.get("content-type") ?? "").includes("application/json")) {
      const d = await a.json().catch(() => null), h = d?.message || d?.error || d?.details || `Failed to fetch threads (${a.status})`;
      throw new Error(typeof h == "string" ? h : `Failed to fetch threads (${a.status})`);
    }
    const f = await a.text().catch(() => "");
    throw new Error(f || `Failed to fetch threads (${a.status})`);
  }
  const l = await a.json().catch(() => null);
  return XF(l);
}
function KF(e) {
  return (Array.isArray(e?.messages) ? e.messages : Array.isArray(e?.data) ? e.data : []).filter((n) => n && typeof n == "object").map((n) => ({
    id: String(n.id ?? ""),
    threadId: n.threadId ? String(n.threadId) : void 0,
    role: String(n.role ?? ""),
    parts: Array.isArray(n.parts) ? n.parts : [],
    metadata: n.metadata,
    createdAt: n.createdAt ?? n.created_at ?? null,
    updatedAt: n.updatedAt ?? n.updated_at ?? null
  })).filter((n) => !!n.id && !!n.role);
}
async function JF(e) {
  if (e.ok) return e.json().catch(() => null);
  if ((e.headers.get("content-type") ?? "").includes("application/json")) {
    const o = await e.json().catch(() => null), a = o?.message || o?.error || o?.details || `Request failed (${e.status})`;
    throw new Error(typeof a == "string" ? a : `Request failed (${e.status})`);
  }
  const n = await e.text().catch(() => "");
  throw new Error(n || `Request failed (${e.status})`);
}
async function QF(e, t = Cl) {
  const n = e.trim();
  if (!n) throw new Error("Missing threadId");
  const o = await tz(), a = new URL(`thread/${encodeURIComponent(n)}`, nz(t)), l = await fetch(a.toString(), { headers: { ...o } }), c = await JF(l), f = ez(c) ?? { id: n }, d = Array.isArray(c?.messages) ? c.messages : [];
  return {
    ...f,
    createdAt: xf(f.createdAt),
    updatedAt: xf(f.updatedAt),
    messages: KF({ messages: d })
  };
}
function Wv() {
  if (typeof crypto < "u") {
    const e = crypto;
    if (typeof e.randomUUID == "function") return e.randomUUID();
    if (typeof e.getRandomValues == "function") {
      const t = new Uint8Array(16);
      e.getRandomValues(t), t[6] = t[6] & 15 | 64, t[8] = t[8] & 63 | 128;
      const n = Array.from(t, (o) => o.toString(16).padStart(2, "0")).join("");
      return `${n.slice(0, 8)}-${n.slice(8, 12)}-${n.slice(12, 16)}-${n.slice(16, 20)}-${n.slice(20)}`;
    }
  }
  return `${Date.now()}_${Math.random().toString(16).slice(2)}`;
}
function Sf(e, t, n) {
  return Math.min(n, Math.max(t, e));
}
function mm() {
  return typeof window > "u" ? { width: 1024, height: 768 } : { width: window.innerWidth, height: window.innerHeight };
}
function rz(e) {
  const n = Math.max(1, e.width - 32), o = Math.max(1, e.height - 32), a = n >= 280 ? Math.min(500, n) : n, l = o >= 240 ? Math.min(400, o) : o;
  return { padding: 16, minWidth: a, minHeight: l, maxWidth: n, maxHeight: o };
}
function oz(e, t) {
  return {
    width: Sf(e.width, t.minWidth, t.maxWidth),
    height: Sf(e.height, t.minHeight, t.maxHeight)
  };
}
function iz(e, t, n, o) {
  const a = o.padding, l = o.padding, c = n.width - t.width - o.padding, f = n.height - t.height - o.padding;
  return {
    x: Sf(e.x, a, c),
    y: Sf(e.y, l, f)
  };
}
function eG(e) {
  const t = rz(e), n = oz({ width: 800, height: 600 }, t), o = iz(
    { x: e.width - n.width - t.padding, y: e.height - n.height - t.padding },
    n,
    e,
    t
  );
  return { size: n, position: o };
}
function tG(e) {
  const t = new Date(e), n = /* @__PURE__ */ new Date(), o = new Date(n.getFullYear(), n.getMonth(), n.getDate()), a = new Date(t.getFullYear(), t.getMonth(), t.getDate()), l = new Date(o);
  l.setDate(l.getDate() - 1);
  const c = o.getTime() - a.getTime(), f = Math.floor(c / (1e3 * 60 * 60 * 24));
  return f === 0 ? "Today" : f === 1 ? "Yesterday" : f < 7 ? "Last 7 days" : f < 30 ? "Last 30 days" : "Older";
}
function nG(e) {
  const t = {
    Today: [],
    Yesterday: [],
    "Last 7 days": [],
    "Last 30 days": [],
    Older: []
  };
  return e.forEach((n) => {
    const o = tG(n.updatedAt);
    t[o].push(n);
  }), t;
}
function gE(e) {
  return e.map((t) => ({
    id: t.id,
    title: t.title,
    createdAt: t.createdAt,
    updatedAt: t.updatedAt
  }));
}
function rG(e) {
  return e.map((t) => ({
    id: t.id,
    title: t.title ?? "New conversation",
    createdAt: typeof t.createdAt == "number" ? t.createdAt : Date.now(),
    updatedAt: typeof t.updatedAt == "number" ? t.updatedAt : Date.now()
  }));
}
function oG({
  isOpen: e,
  currentChatId: t,
  onThreadSelect: n,
  onNewThread: o,
  apiBaseUrl: a,
  isLoadingThread: l = !1,
  className: c
}) {
  const [f, d] = y.useState(!1), [h, m] = y.useState(
    null
  ), [g, b] = y.useState(null), [x, _] = y.useState(!1), [E, T] = y.useState(null), [C, z] = y.useState(null), [A, R] = y.useState(""), [O, L] = y.useState(""), [M, N] = y.useState(
    /* @__PURE__ */ new Set()
  ), [j, Y] = y.useState(
    /* @__PURE__ */ new Set()
  ), [ne, J] = y.useState(null), he = y.useRef(null), [fe, de] = y.useState([]);
  y.useEffect(() => {
    e && de(hi());
  }, [e]), y.useEffect(() => {
    if (!e) return;
    const U = () => de(hi());
    return window.addEventListener("chatbot:threads-updated", U), () => window.removeEventListener("chatbot:threads-updated", U);
  }, [e]), y.useEffect(() => {
    C && setTimeout(() => he.current?.focus(), 0);
  }, [C]), y.useEffect(() => {
    const U = fe.map((ue) => ue.id), ie = new Set(U), ce = U.filter((ue) => !j.has(ue));
    if (ce.length > 0) {
      N(new Set(ce));
      const ue = setTimeout(() => N(/* @__PURE__ */ new Set()), 400);
      return () => clearTimeout(ue);
    }
    (j.size !== ie.size || !Array.from(ie).every((ue) => j.has(ue))) && Y(ie);
  }, [fe, j]), y.useEffect(() => {
    if (!e) return;
    let U = !1;
    return (async () => {
      d(!0);
      try {
        const ce = await WF(a);
        if (U) return;
        m(ce);
      } catch {
        if (U) return;
        m(null);
      } finally {
        if (U) return;
        d(!1);
      }
    })(), () => {
      U = !0;
    };
  }, [a, e]);
  const I = y.useMemo(
    () => new Set((h ?? []).map((U) => U.id)),
    [h]
  ), G = y.useMemo(() => {
    if (h !== null) {
      const U = rG(h);
      return [...gE(fe).filter((ue) => !I.has(ue.id)), ...U].sort(
        (ue, _e) => _e.updatedAt - ue.updatedAt
      );
    }
    return gE(fe);
  }, [fe, I, h]), B = y.useMemo(
    () => nG(G),
    [G]
  ), te = (U, ie) => {
    ie.stopPropagation(), T(U), _(!0);
  }, ae = async () => {
    if (E)
      try {
        b(E), await new Promise((U) => setTimeout(U, 300)), UF(E), de(hi()), t === E && J(null);
      } finally {
        _(!1), b(null), T(null);
      }
  }, k = () => {
    _(!1), T(null);
  }, X = () => {
    const U = Wv();
    J(U), o?.(U), n(U);
  }, H = async (U) => {
    const ie = G.find((ce) => ce.id === U);
    if (!(!ie || !ie.title))
      try {
        await navigator.clipboard.writeText(ie.title);
      } catch {
      }
  }, K = (U) => {
    const ce = G.find((ue) => ue.id === U)?.title || "";
    z(U), R(ce), L(ce);
  }, le = (U) => {
    const ie = A.trim();
    if (!ie || ie === O.trim()) return se();
    VF(U, ie), de(hi()), z(null), R(""), L("");
  }, se = () => {
    z(null), R(""), L("");
  };
  return e ? /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
    /* @__PURE__ */ S.jsx(
      LF,
      {
        open: x,
        onConfirm: ae,
        onCancel: k
      }
    ),
    /* @__PURE__ */ S.jsx(Cv, { delayDuration: 50, children: /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: Fe(
          " h-full flex flex-col bg-background border-r border-border",
          c
        ),
        children: [
          /* @__PURE__ */ S.jsxs("div", { className: "w-full p-4 border-b border-border shrink-0", children: [
            /* @__PURE__ */ S.jsxs("div", { className: "flex items-center justify-between gap-2 flex-wrap", children: [
              /* @__PURE__ */ S.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ S.jsx(AS, { className: "h-5 w-5 text-blue-500" }),
                /* @__PURE__ */ S.jsx("h3", { className: "font-semibold text-foreground", children: "Conversations" })
              ] }),
              /* @__PURE__ */ S.jsxs(tl, { children: [
                /* @__PURE__ */ S.jsx(nl, { asChild: !0, children: /* @__PURE__ */ S.jsx(
                  Dt,
                  {
                    variant: "ghost",
                    size: "icon",
                    className: "h-4 w-4 p-1 text-revert transition-colors hover:bg-blue-100 hover:text-blue-600 dark:hover:bg-blue-950/20 cursor-pointer",
                    onClick: X,
                    disabled: f,
                    "aria-label": "Create new conversation",
                    type: "button",
                    children: /* @__PURE__ */ S.jsx(v2, { className: "h-4 w-4" })
                  }
                ) }),
                /* @__PURE__ */ S.jsx(rl, { children: "Create new conversation" })
              ] })
            ] }),
            /* @__PURE__ */ S.jsxs("p", { className: "text-sm text-muted-foreground mt-1", children: [
              G.length,
              " saved conversations"
            ] })
          ] }),
          /* @__PURE__ */ S.jsx("div", { className: "flex-1 w-full min-h-0", children: /* @__PURE__ */ S.jsx(lM, { className: "h-full w-full", children: f ? /* @__PURE__ */ S.jsx(XM, { message: "Loading conversations..." }) : G.length === 0 ? /* @__PURE__ */ S.jsxs("div", { className: "p-4 text-center text-muted-foreground", children: [
            /* @__PURE__ */ S.jsx(AS, { className: "h-12 w-12 mx-auto mb-2 opacity-50" }),
            /* @__PURE__ */ S.jsx("p", { children: "No conversations yet" }),
            /* @__PURE__ */ S.jsx("p", { className: "text-xs mt-1", children: "Start chatting to create your first conversation" })
          ] }) : /* @__PURE__ */ S.jsx("div", { className: "w-full px-2 py-1 ", children: Object.entries(B).map(([U, ie]) => ie.length === 0 ? null : /* @__PURE__ */ S.jsxs("div", { className: "mb-4 w-full ", children: [
            /* @__PURE__ */ S.jsx("h5", { className: "text-xs font-semibold text-muted-foreground px-3 py-2 uppercase tracking-wide", children: U }),
            ie.map((ce) => /* @__PURE__ */ S.jsx(
              "div",
              {
                className: Fe(
                  "group relative w-full p-2 rounded-lg cursor-pointer transition-all duration-300 ",
                  "hover:bg-blue-50/80 hover:shadow-sm ",
                  "dark:hover:bg-blue-950/30",
                  ne === ce.id || t === ce.id ? "bg-blue-50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800 shadow-sm" : "border border-transparent",
                  g === ce.id && "animate-slideOutLeft opacity-0 scale-95",
                  M.has(ce.id) && "animate-slideInLeft"
                ),
                onClick: () => {
                  J(ce.id), n(ce.id);
                },
                children: /* @__PURE__ */ S.jsxs("div", { className: "flex items-start justify-between gap-2 w-full min-w-0", children: [
                  /* @__PURE__ */ S.jsx(
                    "div",
                    {
                      className: "flex-1 min-w-0 overflow-visible p-0",
                      onDoubleClick: (ue) => {
                        ue.stopPropagation(), l || K(ce.id);
                      },
                      children: /* @__PURE__ */ S.jsx("div", { className: "flex items-center gap-2 mb-1 w-full ", children: C === ce.id ? /* @__PURE__ */ S.jsx(
                        PF,
                        {
                          ref: he,
                          type: "text",
                          value: A,
                          onChange: (ue) => R(ue.target.value),
                          onBlur: () => le(ce.id),
                          onKeyDown: (ue) => {
                            ue.key === "Enter" ? (ue.preventDefault(), le(ce.id)) : ue.key === "Escape" && (ue.preventDefault(), se());
                          },
                          onClick: (ue) => ue.stopPropagation(),
                          className: "h-9 text-sm font-semibold px-2 py-1 border-blue-400 focus:border-blue-500 focus:ring-blue-500 dark:border-blue-600 dark:focus:border-blue-500",
                          autoFocus: !0
                        }
                      ) : /* @__PURE__ */ S.jsx("div", { className: "text-ellipsis text-sm text-foreground break-all cursor-pointer w-full hover:bg-inherit dark:hover:bg-neutral-800/50 rounded transition-colors", children: ce.title || "New conversation" }) })
                    }
                  ),
                  /* @__PURE__ */ S.jsxs(GM, { children: [
                    /* @__PURE__ */ S.jsx(YM, { asChild: !0, children: /* @__PURE__ */ S.jsx(
                      Dt,
                      {
                        variant: "ghost",
                        size: "icon",
                        className: Fe(
                          "h-6 w-6 shrink-0 opacity-0 group-hover:opacity-100 transition-opacity",
                          "hover:bg-neutral-200 dark:hover:bg-neutral-700"
                        ),
                        onClick: (ue) => ue.stopPropagation(),
                        type: "button",
                        children: /* @__PURE__ */ S.jsx(qO, { className: "h-4 w-4" })
                      }
                    ) }),
                    /* @__PURE__ */ S.jsxs(qM, { align: "end", className: "w-48", children: [
                      /* @__PURE__ */ S.jsxs(
                        Vu,
                        {
                          onClick: (ue) => {
                            ue.stopPropagation(), H(ce.id);
                          },
                          className: "cursor-pointer",
                          children: [
                            /* @__PURE__ */ S.jsx(wm, { className: "h-4 w-4 mr-2" }),
                            "Copy conversation"
                          ]
                        }
                      ),
                      /* @__PURE__ */ S.jsxs(
                        Vu,
                        {
                          onClick: (ue) => {
                            ue.stopPropagation(), K(ce.id);
                          },
                          className: "cursor-pointer",
                          children: [
                            /* @__PURE__ */ S.jsx(E2, { className: "h-4 w-4 mr-2" }),
                            "Rename"
                          ]
                        }
                      ),
                      /* @__PURE__ */ S.jsxs(
                        Vu,
                        {
                          onClick: (ue) => {
                            ue.stopPropagation(), I.has(ce.id) || te(ce.id, ue);
                          },
                          className: "cursor-pointer text-red-600 focus:text-red-600 dark:text-red-400 dark:focus:text-red-400",
                          disabled: g === ce.id || I.has(ce.id),
                          children: [
                            /* @__PURE__ */ S.jsx(T2, { className: "h-4 w-4 mr-2" }),
                            "Delete"
                          ]
                        }
                      )
                    ] })
                  ] })
                ] })
              },
              ce.id
            ))
          ] }, U)) }) }) })
        ]
      }
    ) })
  ] }) : null;
}
var td = "Switch", [iG] = yr(td), [aG, sG] = iG(td), az = y.forwardRef(
  (e, t) => {
    const {
      __scopeSwitch: n,
      name: o,
      checked: a,
      defaultChecked: l,
      required: c,
      disabled: f,
      value: d = "on",
      onCheckedChange: h,
      form: m,
      ...g
    } = e, [b, x] = y.useState(null), _ = Le(t, (A) => x(A)), E = y.useRef(!1), T = b ? m || !!b.closest("form") : !0, [C, z] = vi({
      prop: a,
      defaultProp: l ?? !1,
      onChange: h,
      caller: td
    });
    return /* @__PURE__ */ S.jsxs(aG, { scope: n, checked: C, disabled: f, children: [
      /* @__PURE__ */ S.jsx(
        Re.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": C,
          "aria-required": c,
          "data-state": uz(C),
          "data-disabled": f ? "" : void 0,
          disabled: f,
          value: d,
          ...g,
          ref: _,
          onClick: pe(e.onClick, (A) => {
            z((R) => !R), T && (E.current = A.isPropagationStopped(), E.current || A.stopPropagation());
          })
        }
      ),
      T && /* @__PURE__ */ S.jsx(
        cz,
        {
          control: b,
          bubbles: !E.current,
          name: o,
          value: d,
          checked: C,
          required: c,
          disabled: f,
          form: m,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
az.displayName = td;
var sz = "SwitchThumb", lz = y.forwardRef(
  (e, t) => {
    const { __scopeSwitch: n, ...o } = e, a = sG(sz, n);
    return /* @__PURE__ */ S.jsx(
      Re.span,
      {
        "data-state": uz(a.checked),
        "data-disabled": a.disabled ? "" : void 0,
        ...o,
        ref: t
      }
    );
  }
);
lz.displayName = sz;
var lG = "SwitchBubbleInput", cz = y.forwardRef(
  ({
    __scopeSwitch: e,
    control: t,
    checked: n,
    bubbles: o = !0,
    ...a
  }, l) => {
    const c = y.useRef(null), f = Le(c, l), d = bR(n), h = TA(t);
    return y.useEffect(() => {
      const m = c.current;
      if (!m) return;
      const g = window.HTMLInputElement.prototype, x = Object.getOwnPropertyDescriptor(
        g,
        "checked"
      ).set;
      if (d !== n && x) {
        const _ = new Event("click", { bubbles: o });
        x.call(m, n), m.dispatchEvent(_);
      }
    }, [d, n, o]), /* @__PURE__ */ S.jsx(
      "input",
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: n,
        ...a,
        tabIndex: -1,
        ref: f,
        style: {
          ...a.style,
          ...h,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
cz.displayName = lG;
function uz(e) {
  return e ? "checked" : "unchecked";
}
var cG = az, uG = lz;
function fG({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    cG,
    {
      "data-slot": "switch",
      className: Fe(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        e
      ),
      ...t,
      children: /* @__PURE__ */ S.jsx(
        uG,
        {
          "data-slot": "switch-thumb",
          className: Fe(
            "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
          )
        }
      )
    }
  );
}
function dG(e) {
  if (!Number.isFinite(e)) return "";
  const t = e / 1024;
  return t < 1024 ? `${Math.round(t)} KB` : `${(t / 1024).toFixed(1)} MB`;
}
function vE(e) {
  const {
    value: t = "",
    onChange: n,
    onSend: o,
    opStop: a,
    onFilesChange: l,
    files: c,
    onStartTyping: f,
    onUseNextSuggestionChange: d,
    disabled: h = !1
  } = e, [m, g] = y.useState(t), b = y.useRef(!1), x = y.useRef(null), [_, E] = y.useState(c ?? []), [T, C] = y.useState(!1), z = y.useMemo(
    () => typeof window < "u" && "SpeechRecognition" in window,
    []
  ), [A, R] = y.useState(() => {
    try {
      const j = localStorage.getItem("useNextSuggestion");
      return j ? JSON.parse(j) : !1;
    } catch {
      return !1;
    }
  });
  y.useEffect(() => {
    g(t ?? "");
  }, [t]), y.useEffect(() => {
    Array.isArray(c) && E(c);
  }, [c]), y.useEffect(() => {
    f && (b.current || (m || "").trim().length !== 0 && (b.current = !0, f()));
  }, [m, f]), y.useEffect(() => {
    try {
      localStorage.setItem("useNextSuggestion", JSON.stringify(A));
    } catch {
    }
    d?.(A);
  }, [d, A]);
  const O = (j) => {
    E(j), l?.(j);
  }, L = (j) => {
    O(_.filter((Y, ne) => ne !== j));
  }, M = () => {
    C((j) => !j);
  }, N = async () => {
    const j = (m || "").trim();
    !j || h || (g(""), n?.(""), await o(j));
  };
  return /* @__PURE__ */ S.jsxs(
    "div",
    {
      className: "w-full border-t dark:bg-neutral-700 bg-neutral-200 backdrop-blur-md shadow-xl dark:border-0 p-2 flex flex-col gap-2 transition-all",
      children: [
        /* @__PURE__ */ S.jsxs("div", { className: "flex-1 flex flex-col", children: [
          _.length > 0 && /* @__PURE__ */ S.jsx("div", { className: "flex mt-1 w-full flex-wrap gap-2 max-h-32 overflow-y-auto wrap-break-word p-2", children: _.map((j, Y) => /* @__PURE__ */ S.jsxs(
            GA,
            {
              variant: "outline",
              className: "flex items-center justify-between gap-2 text-sm py-1 bg-background/50 dark:bg-neutral-800 rounded-md px-2 border",
              children: [
                /* @__PURE__ */ S.jsxs("div", { className: "truncate flex items-baseline gap-2", children: [
                  /* @__PURE__ */ S.jsx("div", { className: "font-medium", children: j.name }),
                  j.size ? /* @__PURE__ */ S.jsx("div", { className: "text-xs text-neutral-500", children: dG(j.size) }) : null
                ] }),
                /* @__PURE__ */ S.jsx(
                  "button",
                  {
                    onClick: () => L(Y),
                    title: "Remove",
                    className: "cursor-pointer text-neutral-400 hover:text-red-500 p-1",
                    type: "button",
                    children: /* @__PURE__ */ S.jsx(Af, { className: "h-4 w-4" })
                  }
                )
              ]
            },
            Y
          )) }),
          /* @__PURE__ */ S.jsx("div", { className: "relative", children: /* @__PURE__ */ S.jsx(
            "textarea",
            {
              value: m,
              onChange: (j) => {
                const Y = j.target.value;
                g(Y), n?.(Y);
              },
              onKeyDown: (j) => {
                j.key === "Enter" && !j.shiftKey && (j.preventDefault(), N());
              },
              placeholder: "Ask any thing",
              disabled: h,
              rows: 3,
              className: "w-full min-h-16 max-h-40 overflow-y-auto dark:bg-neutral-700 bg-neutral-200 resize-none border-0 focus-visible:ring-0 px-3 py-2 text-neutral-800 placeholder:text-neutral-600 dark:text-white dark:placeholder:text-gray-400 outline-none"
            }
          ) })
        ] }),
        /* @__PURE__ */ S.jsxs("div", { className: "flex flex-row items-center gap-2", children: [
          /* @__PURE__ */ S.jsx("div", { className: "mx-1" }),
          /* @__PURE__ */ S.jsxs("div", { className: "flex flex-row items-center gap-2 ml-auto", children: [
            /* @__PURE__ */ S.jsx(
              "input",
              {
                ref: x,
                type: "file",
                multiple: !0,
                className: "hidden",
                onChange: (j) => {
                  const Y = j.target.files ? Array.from(j.target.files) : [];
                  Y.length && O([..._, ...Y]), j.currentTarget.value = "";
                }
              }
            ),
            /* @__PURE__ */ S.jsx(
              Dt,
              {
                size: "icon",
                variant: "ghost",
                onClick: () => x.current?.click(),
                type: "button",
                disabled: h,
                title: "Upload files",
                className: "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
                children: /* @__PURE__ */ S.jsx(h2, { className: "h-5 w-5" })
              }
            ),
            /* @__PURE__ */ S.jsx(
              Dt,
              {
                size: "icon",
                variant: "ghost",
                onClick: M,
                type: "button",
                disabled: !z || h,
                "aria-pressed": T,
                title: T ? "Stop voice" : "Start voice",
                className: T ? "cursor-pointer  bg-neutral-200 dark:bg-neutral-800 text-red-500 dark:text-red-400" : "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
                children: T ? /* @__PURE__ */ S.jsx(c2, { className: "h-5 w-5" }) : /* @__PURE__ */ S.jsx(f2, { className: "h-5 w-5" })
              }
            ),
            /* @__PURE__ */ S.jsxs(GM, { children: [
              /* @__PURE__ */ S.jsx(YM, { asChild: !0, children: /* @__PURE__ */ S.jsx(
                Dt,
                {
                  size: "icon",
                  variant: "ghost",
                  disabled: h,
                  title: "Using next suggestion",
                  className: "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
                  type: "button",
                  children: /* @__PURE__ */ S.jsx(o2, { className: "h-5 w-5" })
                }
              ) }),
              /* @__PURE__ */ S.jsx(qM, { align: "end", side: "top", className: "w-72", children: /* @__PURE__ */ S.jsxs(
                Vu,
                {
                  onSelect: (j) => j.preventDefault(),
                  className: "flex items-center justify-between gap-3 cursor-pointer px-3 py-2",
                  children: [
                    /* @__PURE__ */ S.jsxs("div", { className: "flex items-center gap-2", children: [
                      /* @__PURE__ */ S.jsx(JO, { className: "h-4 w-4 text-amber-500 shrink-0" }),
                      /* @__PURE__ */ S.jsx("span", { className: "text-sm font-medium whitespace-nowrap", children: "Using next suggestion" })
                    ] }),
                    /* @__PURE__ */ S.jsx(
                      fG,
                      {
                        checked: A,
                        onCheckedChange: (j) => R(j),
                        className: "shrink-0"
                      }
                    )
                  ]
                }
              ) })
            ] }),
            h ? /* @__PURE__ */ S.jsx(
              Dt,
              {
                size: "icon",
                className: "cursor-pointer rounded-full bg-red-900 text-white hover:bg-blue-600 transition-colors shadow-md dark:bg-red-900 dark:hover:bg-neutral-800",
                onClick: a,
                disabled: !h,
                title: "Stop thinking",
                type: "button",
                children: /* @__PURE__ */ S.jsx(m2, { className: "h-5 w-5" })
              }
            ) : /* @__PURE__ */ S.jsx(
              Dt,
              {
                size: "icon",
                className: "cursor-pointer rounded-full bg-blue-500 text-white hover:bg-blue-600 transition-colors shadow-md dark:bg-green-500 dark:hover:bg-neutral-800",
                onClick: () => {
                  N();
                },
                disabled: h || !(m || "").trim(),
                title: "Send (Ctrl+End)",
                type: "button",
                children: /* @__PURE__ */ S.jsx(b2, { className: "h-5 w-5" })
              }
            )
          ] })
        ] })
      ]
    }
  );
}
function hG() {
  const [e, t] = y.useState(!1);
  return y.useEffect(() => {
    t(!0);
  }, []), e;
}
const pG = ({
  words: e,
  duration: t = 3e3,
  className: n
}) => {
  const [o, a] = y.useState(e[0]), [l, c] = y.useState(!1), f = hG(), d = y.useCallback(() => {
    const h = e[e.indexOf(o) + 1] || e[0];
    a(h), c(!0);
  }, [o, e]);
  return y.useEffect(() => {
    l || setTimeout(() => {
      d();
    }, t);
  }, [l, t, d]), f ? /* @__PURE__ */ S.jsx(
    OC,
    {
      onExitComplete: () => {
        c(!1);
      },
      children: /* @__PURE__ */ S.jsx(
        ku.div,
        {
          initial: {
            opacity: 0,
            y: 10
          },
          animate: {
            opacity: 1,
            y: 0
          },
          transition: {
            type: "spring",
            stiffness: 100,
            damping: 10
          },
          exit: {
            opacity: 0,
            y: -40,
            x: 40,
            filter: "blur(8px)",
            scale: 2,
            position: "absolute"
          },
          className: Fe(
            "z-10 inline-block relative text-left text-foreground px-2",
            n
          ),
          children: o.split(" ").map((h, m) => /* @__PURE__ */ S.jsxs(
            ku.span,
            {
              initial: { opacity: 0, y: 10, filter: "blur(4px)" },
              animate: { opacity: 1, y: 0, filter: "blur(0px)" },
              transition: {
                delay: m * 0.01,
                duration: 0.03
              },
              className: "inline-block whitespace-nowrap",
              children: [
                h.split("").map((g, b) => /* @__PURE__ */ S.jsx(
                  ku.span,
                  {
                    initial: { opacity: 0, y: 10, filter: "blur(4px)" },
                    animate: { opacity: 1, y: 0, filter: "blur(0px)" },
                    transition: {
                      delay: m * 0.2 + b * 0.08,
                      duration: 0.2
                    },
                    className: "inline-block",
                    children: g
                  },
                  h + b
                )),
                /* @__PURE__ */ S.jsx("span", { className: "inline-block", children: "" })
              ]
            },
            h + m
          ))
        },
        o
      )
    }
  ) : null;
};
function mG() {
  const e = (/* @__PURE__ */ new Date()).getHours();
  return e < 12 ? "goodMorning" : e < 18 ? "goodAfternoon" : "goodEvening";
}
function gG() {
  const e = { name: "User" }, t = y.useMemo(() => {
    if (!e) return "";
    const n = [
      `Good ${mG().replace("good", "")}, ${e.name}!`,
      `Nice to see you again, ${e.name}.`,
      `What are you working on today, ${e.name}?`,
      "Let me know when you're ready to begin.",
      "What are your thoughts today?",
      "Where would you like to start?",
      `What are you thinking, ${e.name}?`
    ];
    return n[Math.floor(Math.random() * n.length)];
  }, [e.name]);
  return /* @__PURE__ */ S.jsx(
    ku.div,
    {
      className: "max-w-3xl mx-auto my-1",
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      transition: { delay: 0.3 },
      children: /* @__PURE__ */ S.jsx("div", { className: "rounded-xl p-2 flex flex-col gap-2 leading-relaxed text-center", children: /* @__PURE__ */ S.jsx("h1", { className: "text-sm md:text-base text-blue-700 dark:text-[#1abcfe] drop-shadow-sm font-sans", children: t ? /* @__PURE__ */ S.jsx(pG, { words: [t], className: "" }) : "" }) })
    },
    "welcome"
  );
}
function yE() {
  return /* @__PURE__ */ S.jsxs("div", { className: "flex items-center gap-2 text-muted-foreground text-xs px-6 py-2 mt-1", children: [
    /* @__PURE__ */ S.jsx(bg, { className: "h-4 w-4 text-blue-400 dark:text-[#1abcfe] animate-pulse" }),
    /* @__PURE__ */ S.jsx("span", { className: "animate-pulse", children: "Thinking" })
  ] });
}
function vG({ error: e }) {
  const [t, n] = y.useState(!1), o = e?.message ?? "Unknown error", a = o.length > 200 ? o.slice(0, 200) + "" : o;
  return /* @__PURE__ */ S.jsx("div", { className: "w-full mx-auto max-w-2xl px-4 mt-6", children: /* @__PURE__ */ S.jsxs("div", { className: "flex items-start gap-3 bg-stone-50 dark:bg-stone-800/30 border border-stone-200 dark:border-stone-700 rounded-xl p-4 shadow-sm", children: [
    /* @__PURE__ */ S.jsx("div", { className: "flex-shrink-0 mt-1", children: /* @__PURE__ */ S.jsx(A2, { className: "h-6 w-6 text-amber-500" }) }),
    /* @__PURE__ */ S.jsxs("div", { className: "flex-1 min-w-0", children: [
      /* @__PURE__ */ S.jsx("div", { className: "font-semibold text-stone-800 dark:text-stone-200 mb-1", children: "Oops! Something went wrong" }),
      /* @__PURE__ */ S.jsx("div", { className: "whitespace-pre-wrap break-words text-stone-700 dark:text-stone-300 text-sm leading-relaxed", children: t ? o : a }),
      o.length > 200 && /* @__PURE__ */ S.jsx(
        "button",
        {
          className: "mt-2 text-xs text-blue-600 dark:text-blue-400 underline hover:opacity-80",
          onClick: () => n((l) => !l),
          type: "button",
          children: t ? "Show less" : "Show more"
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "mt-3 text-xs text-stone-500 dark:text-stone-400", children: "Try refreshing the page or checking your connection. If the problem keeps happening, please contact support." })
    ] })
  ] }) });
}
function yG(e) {
  return e.type === "dynamic-tool" || e.type.startsWith("tool-");
}
function bG(e) {
  return e.type === "dynamic-tool" ? e.toolName : e.type.startsWith("tool-") ? e.type.slice(5) : null;
}
function xG(e) {
  return e.filter((t) => t.type === "text").map((t) => t.text).join("");
}
function SG({
  message: e,
  isLast: t,
  messageIndex: n = 0,
  onApproveTool: o,
  onAddToolOutputDev: a
}) {
  const l = t ? "polite" : "off", c = e.role === "user", f = y.useMemo(() => xG(e.parts), [e.parts]), d = e.parts.filter(yG), [h, m] = y.useState(
    () => /* @__PURE__ */ new Set()
  ), g = (x) => {
    m((_) => {
      const E = new Set(_);
      return E.has(x) ? E.delete(x) : E.add(x), E;
    });
  }, b = async () => {
    const x = f.trim();
    if (x)
      try {
        await navigator.clipboard.writeText(x);
      } catch {
      }
  };
  return e.role === "system" || !e.parts?.length ? null : c ? /* @__PURE__ */ S.jsxs("div", { className: "w-full mx-auto max-w-3xl px-4", "data-role": e.role, children: [
    n !== 0 ? /* @__PURE__ */ S.jsxs("div", { className: "flex items-center gap-2 text-muted-foreground px-2", children: [
      /* @__PURE__ */ S.jsx(BO, { className: "w-4 h-4 opacity-50", "aria-hidden": !0 }),
      /* @__PURE__ */ S.jsx("div", { className: "flex-1 h-px border-t border-dashed border-muted-foreground/40" })
    ] }) : null,
    /* @__PURE__ */ S.jsx("div", { className: "flex justify-end my-2", "aria-live": l, children: /* @__PURE__ */ S.jsxs("div", { className: "group flex items-start gap-2", children: [
      /* @__PURE__ */ S.jsx("div", { className: "relative flex flex-col gap-2 items-end", children: /* @__PURE__ */ S.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ S.jsx("div", { className: "absolute -top-1 -left-10 opacity-0 group-hover:opacity-100 transition-opacity", children: /* @__PURE__ */ S.jsx(
          Dt,
          {
            type: "button",
            variant: "ghost",
            size: "icon",
            className: "h-7 w-7",
            onClick: () => {
              b();
            },
            "aria-label": "Copy message",
            title: "Copy",
            disabled: !f.trim(),
            children: /* @__PURE__ */ S.jsx(wm, { className: "h-4 w-4" })
          }
        ) }),
        /* @__PURE__ */ S.jsx("div", { className: "flex flex-col gap-2", children: /* @__PURE__ */ S.jsx("div", { className: "bg-neutral-200 dark:bg-neutral-700 px-3 py-2 rounded-md text-sm text-foreground wrap-break-word", children: f || /* @__PURE__ */ S.jsx("span", { className: "text-muted-foreground", children: "" }) }) })
      ] }) }),
      /* @__PURE__ */ S.jsx("span", { className: "shrink-0 mt-1", children: /* @__PURE__ */ S.jsx("div", { className: "h-8 w-8 rounded-full bg-muted flex items-center justify-center", children: /* @__PURE__ */ S.jsx(M2, { className: "h-4 w-4 text-foreground" }) }) })
    ] }) })
  ] }) : /* @__PURE__ */ S.jsx("div", { className: "w-full mx-auto max-w-3xl px-4", "data-role": e.role, "aria-live": l, children: /* @__PURE__ */ S.jsxs("div", { className: "group flex items-start gap-2", children: [
    /* @__PURE__ */ S.jsx("span", { className: "shrink-0 mt-1", children: /* @__PURE__ */ S.jsx(bg, { className: "h-5 w-5 text-blue-400 dark:text-[#1abcfe]" }) }),
    /* @__PURE__ */ S.jsxs("div", { className: "relative flex flex-col w-full", children: [
      /* @__PURE__ */ S.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ S.jsx("div", { className: "text-foreground text-sm max-w-[70vw] wrap-break-word", children: /* @__PURE__ */ S.jsx("div", { className: "prose prose-sm dark:prose-invert prose-p:my-0 prose-ul:my-1 prose-ol:my-1 prose-pre:my-1", children: f || /* @__PURE__ */ S.jsx("span", { className: "text-muted-foreground", children: "" }) }) }),
        /* @__PURE__ */ S.jsx("div", { className: "opacity-0 group-hover:opacity-100 transition-opacity ml-2", children: /* @__PURE__ */ S.jsx(
          Dt,
          {
            type: "button",
            variant: "ghost",
            size: "icon",
            className: "h-7 w-7",
            onClick: () => {
              b();
            },
            "aria-label": "Copy message",
            title: "Copy",
            disabled: !f.trim(),
            children: /* @__PURE__ */ S.jsx(wm, { className: "h-4 w-4" })
          }
        ) })
      ] }),
      d.length > 0 ? /* @__PURE__ */ S.jsx("div", { className: "mt-3 space-y-2", children: d.map((x) => {
        const _ = x, E = bG(x);
        if (!E) return null;
        const T = h.has(x.toolCallId);
        return /* @__PURE__ */ S.jsxs(
          "div",
          {
            className: "rounded-xl border bg-background/40 px-3 py-2 text-xs",
            children: [
              /* @__PURE__ */ S.jsxs("div", { className: "flex items-center justify-between gap-2", children: [
                /* @__PURE__ */ S.jsxs("div", { className: "min-w-0", children: [
                  /* @__PURE__ */ S.jsxs("div", { className: "font-medium truncate", children: [
                    "Tool: ",
                    /* @__PURE__ */ S.jsx("code", { children: E })
                  ] }),
                  /* @__PURE__ */ S.jsxs("div", { className: "text-muted-foreground", children: [
                    "State: ",
                    /* @__PURE__ */ S.jsx("code", { children: String(_?.state ?? x.state) })
                  ] })
                ] }),
                /* @__PURE__ */ S.jsx("div", { className: "flex items-center gap-1 shrink-0", children: /* @__PURE__ */ S.jsx(
                  Dt,
                  {
                    type: "button",
                    variant: "ghost",
                    size: "icon",
                    className: "h-7 w-7",
                    onClick: () => g(x.toolCallId),
                    "aria-label": T ? "Collapse tool details" : "Expand tool details",
                    children: T ? /* @__PURE__ */ S.jsx(jE, { className: "h-4 w-4" }) : /* @__PURE__ */ S.jsx(xg, { className: "h-4 w-4" })
                  }
                ) })
              ] }),
              T ? /* @__PURE__ */ S.jsxs("div", { className: "mt-2 space-y-2", children: [
                "input" in x && x.input !== void 0 ? /* @__PURE__ */ S.jsxs("div", { children: [
                  /* @__PURE__ */ S.jsx("div", { className: "text-muted-foreground", children: "Input" }),
                  /* @__PURE__ */ S.jsx("pre", { className: "mt-0.5 max-h-64 overflow-auto whitespace-pre-wrap break-words rounded-md bg-muted/30 p-2", children: JSON.stringify(x.input, null, 2) })
                ] }) : null,
                "output" in x && x.output !== void 0 ? /* @__PURE__ */ S.jsxs("div", { children: [
                  /* @__PURE__ */ S.jsx("div", { className: "text-muted-foreground", children: "Output" }),
                  /* @__PURE__ */ S.jsx("pre", { className: "mt-0.5 max-h-64 overflow-auto whitespace-pre-wrap break-words rounded-md bg-muted/30 p-2", children: JSON.stringify(x.output, null, 2) })
                ] }) : null,
                "errorText" in x && x.errorText ? /* @__PURE__ */ S.jsx("div", { className: "text-red-600", children: x.errorText }) : null
              ] }) : null,
              _.state === "approval-requested" && o ? /* @__PURE__ */ S.jsxs("div", { className: "mt-2 flex flex-wrap gap-2", children: [
                /* @__PURE__ */ S.jsxs(
                  Dt,
                  {
                    type: "button",
                    variant: "outline",
                    className: "gap-2",
                    onClick: () => o(String(_?.approval?.id ?? ""), !0),
                    children: [
                      /* @__PURE__ */ S.jsx(OE, { className: "h-4 w-4" }),
                      "Approve"
                    ]
                  }
                ),
                /* @__PURE__ */ S.jsxs(
                  Dt,
                  {
                    type: "button",
                    variant: "outline",
                    className: "gap-2 text-destructive hover:text-destructive",
                    onClick: () => o(String(_?.approval?.id ?? ""), !1),
                    children: [
                      /* @__PURE__ */ S.jsx(Af, { className: "h-4 w-4" }),
                      "Deny"
                    ]
                  }
                )
              ] }) : null,
              null
            ]
          },
          x.toolCallId
        );
      }) }) : null
    ] })
  ] }) });
}
const nd = y.createContext(null);
nd.displayName = "PanelGroupContext";
const gt = {
  group: "data-panel-group",
  groupDirection: "data-panel-group-direction",
  groupId: "data-panel-group-id",
  panel: "data-panel",
  panelCollapsible: "data-panel-collapsible",
  panelId: "data-panel-id",
  panelSize: "data-panel-size",
  resizeHandle: "data-resize-handle",
  resizeHandleActive: "data-resize-handle-active",
  resizeHandleEnabled: "data-panel-resize-handle-enabled",
  resizeHandleId: "data-panel-resize-handle-id",
  resizeHandleState: "data-resize-handle-state"
}, Kv = 10, mi = y.useLayoutEffect, bE = _f.useId, wG = typeof bE == "function" ? bE : () => null;
let EG = 0;
function Jv(e = null) {
  const t = wG(), n = y.useRef(e || t || null);
  return n.current === null && (n.current = "" + EG++), e ?? n.current;
}
function fz({
  children: e,
  className: t = "",
  collapsedSize: n,
  collapsible: o,
  defaultSize: a,
  forwardedRef: l,
  id: c,
  maxSize: f,
  minSize: d,
  onCollapse: h,
  onExpand: m,
  onResize: g,
  order: b,
  style: x,
  tagName: _ = "div",
  ...E
}) {
  const T = y.useContext(nd);
  if (T === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    collapsePanel: C,
    expandPanel: z,
    getPanelSize: A,
    getPanelStyle: R,
    groupId: O,
    isPanelCollapsed: L,
    reevaluatePanelConstraints: M,
    registerPanel: N,
    resizePanel: j,
    unregisterPanel: Y
  } = T, ne = Jv(c), J = y.useRef({
    callbacks: {
      onCollapse: h,
      onExpand: m,
      onResize: g
    },
    constraints: {
      collapsedSize: n,
      collapsible: o,
      defaultSize: a,
      maxSize: f,
      minSize: d
    },
    id: ne,
    idIsFromProps: c !== void 0,
    order: b
  });
  y.useRef({
    didLogMissingDefaultSizeWarning: !1
  }), mi(() => {
    const {
      callbacks: fe,
      constraints: de
    } = J.current, I = {
      ...de
    };
    J.current.id = ne, J.current.idIsFromProps = c !== void 0, J.current.order = b, fe.onCollapse = h, fe.onExpand = m, fe.onResize = g, de.collapsedSize = n, de.collapsible = o, de.defaultSize = a, de.maxSize = f, de.minSize = d, (I.collapsedSize !== de.collapsedSize || I.collapsible !== de.collapsible || I.maxSize !== de.maxSize || I.minSize !== de.minSize) && M(J.current, I);
  }), mi(() => {
    const fe = J.current;
    return N(fe), () => {
      Y(fe);
    };
  }, [b, ne, N, Y]), y.useImperativeHandle(l, () => ({
    collapse: () => {
      C(J.current);
    },
    expand: (fe) => {
      z(J.current, fe);
    },
    getId() {
      return ne;
    },
    getSize() {
      return A(J.current);
    },
    isCollapsed() {
      return L(J.current);
    },
    isExpanded() {
      return !L(J.current);
    },
    resize: (fe) => {
      j(J.current, fe);
    }
  }), [C, z, A, L, ne, j]);
  const he = R(J.current, a);
  return y.createElement(_, {
    ...E,
    children: e,
    className: t,
    id: ne,
    style: {
      ...he,
      ...x
    },
    // CSS selectors
    [gt.groupId]: O,
    [gt.panel]: "",
    [gt.panelCollapsible]: o || void 0,
    [gt.panelId]: ne,
    [gt.panelSize]: parseFloat("" + he.flexGrow).toFixed(1)
  });
}
const dz = y.forwardRef((e, t) => y.createElement(fz, {
  ...e,
  forwardedRef: t
}));
fz.displayName = "Panel";
dz.displayName = "forwardRef(Panel)";
let vg = null, Uu = -1, Ao = null;
function _G(e, t, n) {
  const o = (t & vz) !== 0, a = (t & yz) !== 0, l = (t & bz) !== 0, c = (t & xz) !== 0;
  if (t) {
    if (o)
      return l ? "se-resize" : c ? "ne-resize" : "e-resize";
    if (a)
      return l ? "sw-resize" : c ? "nw-resize" : "w-resize";
    if (l)
      return "s-resize";
    if (c)
      return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function TG() {
  Ao !== null && (document.head.removeChild(Ao), vg = null, Ao = null, Uu = -1);
}
function gm(e, t, n) {
  var o, a;
  const l = _G(e, t);
  if (vg !== l) {
    if (vg = l, Ao === null && (Ao = document.createElement("style"), document.head.appendChild(Ao)), Uu >= 0) {
      var c;
      (c = Ao.sheet) === null || c === void 0 || c.removeRule(Uu);
    }
    Uu = (o = (a = Ao.sheet) === null || a === void 0 ? void 0 : a.insertRule(`*{cursor: ${l} !important;}`)) !== null && o !== void 0 ? o : -1;
  }
}
function hz(e) {
  return e.type === "keydown";
}
function pz(e) {
  return e.type.startsWith("pointer");
}
function mz(e) {
  return e.type.startsWith("mouse");
}
function rd(e) {
  if (pz(e)) {
    if (e.isPrimary)
      return {
        x: e.clientX,
        y: e.clientY
      };
  } else if (mz(e))
    return {
      x: e.clientX,
      y: e.clientY
    };
  return {
    x: 1 / 0,
    y: 1 / 0
  };
}
function CG() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
function AG(e, t, n) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function RG(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: wE(e),
    b: wE(t)
  };
  let o;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), o = e;
  De(o, "Stacking order can only be calculated for elements with a common ancestor");
  const a = {
    a: SE(xE(n.a)),
    b: SE(xE(n.b))
  };
  if (a.a === a.b) {
    const l = o.childNodes, c = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let f = l.length;
    for (; f--; ) {
      const d = l[f];
      if (d === c.a) return 1;
      if (d === c.b) return -1;
    }
  }
  return Math.sign(a.a - a.b);
}
const MG = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function zG(e) {
  var t;
  const n = getComputedStyle((t = gz(e)) !== null && t !== void 0 ? t : e).display;
  return n === "flex" || n === "inline-flex";
}
function DG(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || zG(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || MG.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function xE(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (De(n, "Missing node"), DG(n)) return n;
  }
  return null;
}
function SE(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function wE(e) {
  const t = [];
  for (; e; )
    t.push(e), e = gz(e);
  return t;
}
function gz(e) {
  const {
    parentNode: t
  } = e;
  return t && t instanceof ShadowRoot ? t.host : t;
}
const vz = 1, yz = 2, bz = 4, xz = 8, NG = CG() === "coarse";
let Jn = [], Na = !1, Ro = /* @__PURE__ */ new Map(), od = /* @__PURE__ */ new Map();
const Al = /* @__PURE__ */ new Set();
function OG(e, t, n, o, a) {
  var l;
  const {
    ownerDocument: c
  } = t, f = {
    direction: n,
    element: t,
    hitAreaMargins: o,
    setResizeHandlerState: a
  }, d = (l = Ro.get(c)) !== null && l !== void 0 ? l : 0;
  return Ro.set(c, d + 1), Al.add(f), wf(), function() {
    var m;
    od.delete(e), Al.delete(f);
    const g = (m = Ro.get(c)) !== null && m !== void 0 ? m : 1;
    if (Ro.set(c, g - 1), wf(), g === 1 && Ro.delete(c), Jn.includes(f)) {
      const b = Jn.indexOf(f);
      b >= 0 && Jn.splice(b, 1), id(), a("up", !0, null);
    }
  };
}
function jG(e) {
  const {
    target: t
  } = e, {
    x: n,
    y: o
  } = rd(e);
  Na = !0, Qv({
    target: t,
    x: n,
    y: o
  }), wf(), Jn.length > 0 && (Ef("down", e), id(), e.preventDefault(), Sz(t) || e.stopImmediatePropagation());
}
function vm(e) {
  const {
    x: t,
    y: n
  } = rd(e);
  if (Na && // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
  e.type !== "pointerleave" && e.buttons === 0 && (Na = !1, Ef("up", e)), !Na) {
    const {
      target: o
    } = e;
    Qv({
      target: o,
      x: t,
      y: n
    });
  }
  Ef("move", e), id(), Jn.length > 0 && e.preventDefault();
}
function ym(e) {
  const {
    target: t
  } = e, {
    x: n,
    y: o
  } = rd(e);
  od.clear(), Na = !1, Jn.length > 0 && (e.preventDefault(), Sz(t) || e.stopImmediatePropagation()), Ef("up", e), Qv({
    target: t,
    x: n,
    y: o
  }), id(), wf();
}
function Sz(e) {
  let t = e;
  for (; t; ) {
    if (t.hasAttribute(gt.resizeHandle))
      return !0;
    t = t.parentElement;
  }
  return !1;
}
function Qv({
  target: e,
  x: t,
  y: n
}) {
  Jn.splice(0);
  let o = null;
  (e instanceof HTMLElement || e instanceof SVGElement) && (o = e), Al.forEach((a) => {
    const {
      element: l,
      hitAreaMargins: c
    } = a, f = l.getBoundingClientRect(), {
      bottom: d,
      left: h,
      right: m,
      top: g
    } = f, b = NG ? c.coarse : c.fine;
    if (t >= h - b && t <= m + b && n >= g - b && n <= d + b) {
      if (o !== null && document.contains(o) && l !== o && !l.contains(o) && !o.contains(l) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      RG(o, l) > 0) {
        let _ = o, E = !1;
        for (; _ && !_.contains(l); ) {
          if (AG(_.getBoundingClientRect(), f)) {
            E = !0;
            break;
          }
          _ = _.parentElement;
        }
        if (E)
          return;
      }
      Jn.push(a);
    }
  });
}
function bm(e, t) {
  od.set(e, t);
}
function id() {
  let e = !1, t = !1;
  Jn.forEach((o) => {
    const {
      direction: a
    } = o;
    a === "horizontal" ? e = !0 : t = !0;
  });
  let n = 0;
  od.forEach((o) => {
    n |= o;
  }), e && t ? gm("intersection", n) : e ? gm("horizontal", n) : t ? gm("vertical", n) : TG();
}
let xm;
function wf() {
  var e;
  (e = xm) === null || e === void 0 || e.abort(), xm = new AbortController();
  const t = {
    capture: !0,
    signal: xm.signal
  };
  Al.size && (Na ? (Jn.length > 0 && Ro.forEach((n, o) => {
    const {
      body: a
    } = o;
    n > 0 && (a.addEventListener("contextmenu", ym, t), a.addEventListener("pointerleave", vm, t), a.addEventListener("pointermove", vm, t));
  }), Ro.forEach((n, o) => {
    const {
      body: a
    } = o;
    a.addEventListener("pointerup", ym, t), a.addEventListener("pointercancel", ym, t);
  })) : Ro.forEach((n, o) => {
    const {
      body: a
    } = o;
    n > 0 && (a.addEventListener("pointerdown", jG, t), a.addEventListener("pointermove", vm, t));
  }));
}
function Ef(e, t) {
  Al.forEach((n) => {
    const {
      setResizeHandlerState: o
    } = n, a = Jn.includes(n);
    o(e, a, t);
  });
}
function kG() {
  const [e, t] = y.useState(0);
  return y.useCallback(() => t((n) => n + 1), []);
}
function De(e, t) {
  if (!e)
    throw console.error(t), Error(t);
}
function Si(e, t, n = Kv) {
  return e.toFixed(n) === t.toFixed(n) ? 0 : e > t ? 1 : -1;
}
function Hr(e, t, n = Kv) {
  return Si(e, t, n) === 0;
}
function xn(e, t, n) {
  return Si(e, t, n) === 0;
}
function PG(e, t, n) {
  if (e.length !== t.length)
    return !1;
  for (let o = 0; o < e.length; o++) {
    const a = e[o], l = t[o];
    if (!xn(a, l, n))
      return !1;
  }
  return !0;
}
function Ca({
  panelConstraints: e,
  panelIndex: t,
  size: n
}) {
  const o = e[t];
  De(o != null, `Panel constraints not found for index ${t}`);
  let {
    collapsedSize: a = 0,
    collapsible: l,
    maxSize: c = 100,
    minSize: f = 0
  } = o;
  if (Si(n, f) < 0)
    if (l) {
      const d = (a + f) / 2;
      Si(n, d) < 0 ? n = a : n = f;
    } else
      n = f;
  return n = Math.min(c, n), n = parseFloat(n.toFixed(Kv)), n;
}
function al({
  delta: e,
  initialLayout: t,
  panelConstraints: n,
  pivotIndices: o,
  prevLayout: a,
  trigger: l
}) {
  if (xn(e, 0))
    return t;
  const c = [...t], [f, d] = o;
  De(f != null, "Invalid first pivot index"), De(d != null, "Invalid second pivot index");
  let h = 0;
  if (l === "keyboard") {
    {
      const g = e < 0 ? d : f, b = n[g];
      De(b, `Panel constraints not found for index ${g}`);
      const {
        collapsedSize: x = 0,
        collapsible: _,
        minSize: E = 0
      } = b;
      if (_) {
        const T = t[g];
        if (De(T != null, `Previous layout not found for panel index ${g}`), xn(T, x)) {
          const C = E - T;
          Si(C, Math.abs(e)) > 0 && (e = e < 0 ? 0 - C : C);
        }
      }
    }
    {
      const g = e < 0 ? f : d, b = n[g];
      De(b, `No panel constraints found for index ${g}`);
      const {
        collapsedSize: x = 0,
        collapsible: _,
        minSize: E = 0
      } = b;
      if (_) {
        const T = t[g];
        if (De(T != null, `Previous layout not found for panel index ${g}`), xn(T, E)) {
          const C = T - x;
          Si(C, Math.abs(e)) > 0 && (e = e < 0 ? 0 - C : C);
        }
      }
    }
  }
  {
    const g = e < 0 ? 1 : -1;
    let b = e < 0 ? d : f, x = 0;
    for (; ; ) {
      const E = t[b];
      De(E != null, `Previous layout not found for panel index ${b}`);
      const C = Ca({
        panelConstraints: n,
        panelIndex: b,
        size: 100
      }) - E;
      if (x += C, b += g, b < 0 || b >= n.length)
        break;
    }
    const _ = Math.min(Math.abs(e), Math.abs(x));
    e = e < 0 ? 0 - _ : _;
  }
  {
    let b = e < 0 ? f : d;
    for (; b >= 0 && b < n.length; ) {
      const x = Math.abs(e) - Math.abs(h), _ = t[b];
      De(_ != null, `Previous layout not found for panel index ${b}`);
      const E = _ - x, T = Ca({
        panelConstraints: n,
        panelIndex: b,
        size: E
      });
      if (!xn(_, T) && (h += _ - T, c[b] = T, h.toFixed(3).localeCompare(Math.abs(e).toFixed(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? b-- : b++;
    }
  }
  if (PG(a, c))
    return a;
  {
    const g = e < 0 ? d : f, b = t[g];
    De(b != null, `Previous layout not found for panel index ${g}`);
    const x = b + h, _ = Ca({
      panelConstraints: n,
      panelIndex: g,
      size: x
    });
    if (c[g] = _, !xn(_, x)) {
      let E = x - _, C = e < 0 ? d : f;
      for (; C >= 0 && C < n.length; ) {
        const z = c[C];
        De(z != null, `Previous layout not found for panel index ${C}`);
        const A = z + E, R = Ca({
          panelConstraints: n,
          panelIndex: C,
          size: A
        });
        if (xn(z, R) || (E -= R - z, c[C] = R), xn(E, 0))
          break;
        e > 0 ? C-- : C++;
      }
    }
  }
  const m = c.reduce((g, b) => b + g, 0);
  return xn(m, 100) ? c : a;
}
function LG({
  layout: e,
  panelsArray: t,
  pivotIndices: n
}) {
  let o = 0, a = 100, l = 0, c = 0;
  const f = n[0];
  De(f != null, "No pivot index found"), t.forEach((g, b) => {
    const {
      constraints: x
    } = g, {
      maxSize: _ = 100,
      minSize: E = 0
    } = x;
    b === f ? (o = E, a = _) : (l += E, c += _);
  });
  const d = Math.min(a, 100 - l), h = Math.max(o, 100 - c), m = e[f];
  return {
    valueMax: d,
    valueMin: h,
    valueNow: m
  };
}
function Rl(e, t = document) {
  return Array.from(t.querySelectorAll(`[${gt.resizeHandleId}][data-panel-group-id="${e}"]`));
}
function wz(e, t, n = document) {
  const a = Rl(e, n).findIndex((l) => l.getAttribute(gt.resizeHandleId) === t);
  return a ?? null;
}
function Ez(e, t, n) {
  const o = wz(e, t, n);
  return o != null ? [o, o + 1] : [-1, -1];
}
function IG(e) {
  return e instanceof HTMLElement ? !0 : typeof e == "object" && e !== null && "tagName" in e && "getAttribute" in e;
}
function _z(e, t = document) {
  if (IG(t) && t.dataset.panelGroupId == e)
    return t;
  const n = t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return n || null;
}
function ad(e, t = document) {
  const n = t.querySelector(`[${gt.resizeHandleId}="${e}"]`);
  return n || null;
}
function VG(e, t, n, o = document) {
  var a, l, c, f;
  const d = ad(t, o), h = Rl(e, o), m = d ? h.indexOf(d) : -1, g = (a = (l = n[m]) === null || l === void 0 ? void 0 : l.id) !== null && a !== void 0 ? a : null, b = (c = (f = n[m + 1]) === null || f === void 0 ? void 0 : f.id) !== null && c !== void 0 ? c : null;
  return [g, b];
}
function UG({
  committedValuesRef: e,
  eagerValuesRef: t,
  groupId: n,
  layout: o,
  panelDataArray: a,
  panelGroupElement: l,
  setLayout: c
}) {
  y.useRef({
    didWarnAboutMissingResizeHandle: !1
  }), mi(() => {
    if (!l)
      return;
    const f = Rl(n, l);
    for (let d = 0; d < a.length - 1; d++) {
      const {
        valueMax: h,
        valueMin: m,
        valueNow: g
      } = LG({
        layout: o,
        panelsArray: a,
        pivotIndices: [d, d + 1]
      }), b = f[d];
      if (b != null) {
        const x = a[d];
        De(x, `No panel data found for index "${d}"`), b.setAttribute("aria-controls", x.id), b.setAttribute("aria-valuemax", "" + Math.round(h)), b.setAttribute("aria-valuemin", "" + Math.round(m)), b.setAttribute("aria-valuenow", g != null ? "" + Math.round(g) : "");
      }
    }
    return () => {
      f.forEach((d, h) => {
        d.removeAttribute("aria-controls"), d.removeAttribute("aria-valuemax"), d.removeAttribute("aria-valuemin"), d.removeAttribute("aria-valuenow");
      });
    };
  }, [n, o, a, l]), y.useEffect(() => {
    if (!l)
      return;
    const f = t.current;
    De(f, "Eager values not found");
    const {
      panelDataArray: d
    } = f, h = _z(n, l);
    De(h != null, `No group found for id "${n}"`);
    const m = Rl(n, l);
    De(m, `No resize handles found for group id "${n}"`);
    const g = m.map((b) => {
      const x = b.getAttribute(gt.resizeHandleId);
      De(x, "Resize handle element has no handle id attribute");
      const [_, E] = VG(n, x, d, l);
      if (_ == null || E == null)
        return () => {
        };
      const T = (C) => {
        if (!C.defaultPrevented)
          switch (C.key) {
            case "Enter": {
              C.preventDefault();
              const z = d.findIndex((A) => A.id === _);
              if (z >= 0) {
                const A = d[z];
                De(A, `No panel data found for index ${z}`);
                const R = o[z], {
                  collapsedSize: O = 0,
                  collapsible: L,
                  minSize: M = 0
                } = A.constraints;
                if (R != null && L) {
                  const N = al({
                    delta: xn(R, O) ? M - O : O - R,
                    initialLayout: o,
                    panelConstraints: d.map((j) => j.constraints),
                    pivotIndices: Ez(n, x, l),
                    prevLayout: o,
                    trigger: "keyboard"
                  });
                  o !== N && c(N);
                }
              }
              break;
            }
          }
      };
      return b.addEventListener("keydown", T), () => {
        b.removeEventListener("keydown", T);
      };
    });
    return () => {
      g.forEach((b) => b());
    };
  }, [l, e, t, n, o, a, c]);
}
function EE(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function Tz(e, t) {
  const n = e === "horizontal", {
    x: o,
    y: a
  } = rd(t);
  return n ? o : a;
}
function BG(e, t, n, o, a) {
  const l = n === "horizontal", c = ad(t, a);
  De(c, `No resize handle element found for id "${t}"`);
  const f = c.getAttribute(gt.groupId);
  De(f, "Resize handle element has no group id attribute");
  let {
    initialCursorPosition: d
  } = o;
  const h = Tz(n, e), m = _z(f, a);
  De(m, `No group element found for id "${f}"`);
  const g = m.getBoundingClientRect(), b = l ? g.width : g.height;
  return (h - d) / b * 100;
}
function $G(e, t, n, o, a, l) {
  if (hz(e)) {
    const c = n === "horizontal";
    let f = 0;
    e.shiftKey ? f = 100 : a != null ? f = a : f = 10;
    let d = 0;
    switch (e.key) {
      case "ArrowDown":
        d = c ? 0 : f;
        break;
      case "ArrowLeft":
        d = c ? -f : 0;
        break;
      case "ArrowRight":
        d = c ? f : 0;
        break;
      case "ArrowUp":
        d = c ? 0 : -f;
        break;
      case "End":
        d = 100;
        break;
      case "Home":
        d = -100;
        break;
    }
    return d;
  } else
    return o == null ? 0 : BG(e, t, n, o, l);
}
function HG({
  panelDataArray: e
}) {
  const t = Array(e.length), n = e.map((l) => l.constraints);
  let o = 0, a = 100;
  for (let l = 0; l < e.length; l++) {
    const c = n[l];
    De(c, `Panel constraints not found for index ${l}`);
    const {
      defaultSize: f
    } = c;
    f != null && (o++, t[l] = f, a -= f);
  }
  for (let l = 0; l < e.length; l++) {
    const c = n[l];
    De(c, `Panel constraints not found for index ${l}`);
    const {
      defaultSize: f
    } = c;
    if (f != null)
      continue;
    const d = e.length - o, h = a / d;
    o++, t[l] = h, a -= h;
  }
  return t;
}
function ga(e, t, n) {
  t.forEach((o, a) => {
    const l = e[a];
    De(l, `Panel data not found for index ${a}`);
    const {
      callbacks: c,
      constraints: f,
      id: d
    } = l, {
      collapsedSize: h = 0,
      collapsible: m
    } = f, g = n[d];
    if (g == null || o !== g) {
      n[d] = o;
      const {
        onCollapse: b,
        onExpand: x,
        onResize: _
      } = c;
      _ && _(o, g), m && (b || x) && (x && (g == null || Hr(g, h)) && !Hr(o, h) && x(), b && (g == null || !Hr(g, h)) && Hr(o, h) && b());
    }
  });
}
function Au(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n])
      return !1;
  return !0;
}
function ZG({
  defaultSize: e,
  dragState: t,
  layout: n,
  panelData: o,
  panelIndex: a,
  precision: l = 3
}) {
  const c = n[a];
  let f;
  return c == null ? f = e != null ? e.toFixed(l) : "1" : o.length === 1 ? f = "1" : f = c.toFixed(l), {
    flexBasis: 0,
    flexGrow: f,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: t !== null ? "none" : void 0
  };
}
function FG(e, t = 10) {
  let n = null;
  return (...a) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...a);
    }, t);
  };
}
function _E(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, n) => {
        localStorage.setItem(t, n);
      };
    else
      throw new Error("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function Cz(e) {
  return `react-resizable-panels:${e}`;
}
function Az(e) {
  return e.map((t) => {
    const {
      constraints: n,
      id: o,
      idIsFromProps: a,
      order: l
    } = t;
    return a ? o : l ? `${l}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((t, n) => t.localeCompare(n)).join(",");
}
function Rz(e, t) {
  try {
    const n = Cz(e), o = t.getItem(n);
    if (o) {
      const a = JSON.parse(o);
      if (typeof a == "object" && a != null)
        return a;
    }
  } catch {
  }
  return null;
}
function GG(e, t, n) {
  var o, a;
  const l = (o = Rz(e, n)) !== null && o !== void 0 ? o : {}, c = Az(t);
  return (a = l[c]) !== null && a !== void 0 ? a : null;
}
function YG(e, t, n, o, a) {
  var l;
  const c = Cz(e), f = Az(t), d = (l = Rz(e, a)) !== null && l !== void 0 ? l : {};
  d[f] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: o
  };
  try {
    a.setItem(c, JSON.stringify(d));
  } catch (h) {
    console.error(h);
  }
}
function TE({
  layout: e,
  panelConstraints: t
}) {
  const n = [...e], o = n.reduce((l, c) => l + c, 0);
  if (n.length !== t.length)
    throw Error(`Invalid ${t.length} panel layout: ${n.map((l) => `${l}%`).join(", ")}`);
  if (!xn(o, 100) && n.length > 0)
    for (let l = 0; l < t.length; l++) {
      const c = n[l];
      De(c != null, `No layout data found for index ${l}`);
      const f = 100 / o * c;
      n[l] = f;
    }
  let a = 0;
  for (let l = 0; l < t.length; l++) {
    const c = n[l];
    De(c != null, `No layout data found for index ${l}`);
    const f = Ca({
      panelConstraints: t,
      panelIndex: l,
      size: c
    });
    c != f && (a += c - f, n[l] = f);
  }
  if (!xn(a, 0))
    for (let l = 0; l < t.length; l++) {
      const c = n[l];
      De(c != null, `No layout data found for index ${l}`);
      const f = c + a, d = Ca({
        panelConstraints: t,
        panelIndex: l,
        size: f
      });
      if (c !== d && (a -= d - c, n[l] = d, xn(a, 0)))
        break;
    }
  return n;
}
const qG = 100, sl = {
  getItem: (e) => (_E(sl), sl.getItem(e)),
  setItem: (e, t) => {
    _E(sl), sl.setItem(e, t);
  }
}, CE = {};
function Mz({
  autoSaveId: e = null,
  children: t,
  className: n = "",
  direction: o,
  forwardedRef: a,
  id: l = null,
  onLayout: c = null,
  keyboardResizeBy: f = null,
  storage: d = sl,
  style: h,
  tagName: m = "div",
  ...g
}) {
  const b = Jv(l), x = y.useRef(null), [_, E] = y.useState(null), [T, C] = y.useState([]), z = kG(), A = y.useRef({}), R = y.useRef(/* @__PURE__ */ new Map()), O = y.useRef(0), L = y.useRef({
    autoSaveId: e,
    direction: o,
    dragState: _,
    id: b,
    keyboardResizeBy: f,
    onLayout: c,
    storage: d
  }), M = y.useRef({
    layout: T,
    panelDataArray: [],
    panelDataArrayChanged: !1
  });
  y.useRef({
    didLogIdAndOrderWarning: !1,
    didLogPanelConstraintsWarning: !1,
    prevPanelIds: []
  }), y.useImperativeHandle(a, () => ({
    getId: () => L.current.id,
    getLayout: () => {
      const {
        layout: H
      } = M.current;
      return H;
    },
    setLayout: (H) => {
      const {
        onLayout: K
      } = L.current, {
        layout: le,
        panelDataArray: se
      } = M.current, U = TE({
        layout: H,
        panelConstraints: se.map((ie) => ie.constraints)
      });
      EE(le, U) || (C(U), M.current.layout = U, K && K(U), ga(se, U, A.current));
    }
  }), []), mi(() => {
    L.current.autoSaveId = e, L.current.direction = o, L.current.dragState = _, L.current.id = b, L.current.onLayout = c, L.current.storage = d;
  }), UG({
    committedValuesRef: L,
    eagerValuesRef: M,
    groupId: b,
    layout: T,
    panelDataArray: M.current.panelDataArray,
    setLayout: C,
    panelGroupElement: x.current
  }), y.useEffect(() => {
    const {
      panelDataArray: H
    } = M.current;
    if (e) {
      if (T.length === 0 || T.length !== H.length)
        return;
      let K = CE[e];
      K == null && (K = FG(YG, qG), CE[e] = K);
      const le = [...H], se = new Map(R.current);
      K(e, le, se, T, d);
    }
  }, [e, T, d]), y.useEffect(() => {
  });
  const N = y.useCallback((H) => {
    const {
      onLayout: K
    } = L.current, {
      layout: le,
      panelDataArray: se
    } = M.current;
    if (H.constraints.collapsible) {
      const U = se.map((_e) => _e.constraints), {
        collapsedSize: ie = 0,
        panelSize: ce,
        pivotIndices: ue
      } = li(se, H, le);
      if (De(ce != null, `Panel size not found for panel "${H.id}"`), !Hr(ce, ie)) {
        R.current.set(H.id, ce);
        const ze = ba(se, H) === se.length - 1 ? ce - ie : ie - ce, je = al({
          delta: ze,
          initialLayout: le,
          panelConstraints: U,
          pivotIndices: ue,
          prevLayout: le,
          trigger: "imperative-api"
        });
        Au(le, je) || (C(je), M.current.layout = je, K && K(je), ga(se, je, A.current));
      }
    }
  }, []), j = y.useCallback((H, K) => {
    const {
      onLayout: le
    } = L.current, {
      layout: se,
      panelDataArray: U
    } = M.current;
    if (H.constraints.collapsible) {
      const ie = U.map((Je) => Je.constraints), {
        collapsedSize: ce = 0,
        panelSize: ue = 0,
        minSize: _e = 0,
        pivotIndices: ze
      } = li(U, H, se), je = K ?? _e;
      if (Hr(ue, ce)) {
        const Je = R.current.get(H.id), cn = Je != null && Je >= je ? Je : je, Sr = ba(U, H) === U.length - 1 ? ue - cn : cn - ue, jt = al({
          delta: Sr,
          initialLayout: se,
          panelConstraints: ie,
          pivotIndices: ze,
          prevLayout: se,
          trigger: "imperative-api"
        });
        Au(se, jt) || (C(jt), M.current.layout = jt, le && le(jt), ga(U, jt, A.current));
      }
    }
  }, []), Y = y.useCallback((H) => {
    const {
      layout: K,
      panelDataArray: le
    } = M.current, {
      panelSize: se
    } = li(le, H, K);
    return De(se != null, `Panel size not found for panel "${H.id}"`), se;
  }, []), ne = y.useCallback((H, K) => {
    const {
      panelDataArray: le
    } = M.current, se = ba(le, H);
    return ZG({
      defaultSize: K,
      dragState: _,
      layout: T,
      panelData: le,
      panelIndex: se
    });
  }, [_, T]), J = y.useCallback((H) => {
    const {
      layout: K,
      panelDataArray: le
    } = M.current, {
      collapsedSize: se = 0,
      collapsible: U,
      panelSize: ie
    } = li(le, H, K);
    return De(ie != null, `Panel size not found for panel "${H.id}"`), U === !0 && Hr(ie, se);
  }, []), he = y.useCallback((H) => {
    const {
      layout: K,
      panelDataArray: le
    } = M.current, {
      collapsedSize: se = 0,
      collapsible: U,
      panelSize: ie
    } = li(le, H, K);
    return De(ie != null, `Panel size not found for panel "${H.id}"`), !U || Si(ie, se) > 0;
  }, []), fe = y.useCallback((H) => {
    const {
      panelDataArray: K
    } = M.current;
    K.push(H), K.sort((le, se) => {
      const U = le.order, ie = se.order;
      return U == null && ie == null ? 0 : U == null ? -1 : ie == null ? 1 : U - ie;
    }), M.current.panelDataArrayChanged = !0, z();
  }, [z]);
  mi(() => {
    if (M.current.panelDataArrayChanged) {
      M.current.panelDataArrayChanged = !1;
      const {
        autoSaveId: H,
        onLayout: K,
        storage: le
      } = L.current, {
        layout: se,
        panelDataArray: U
      } = M.current;
      let ie = null;
      if (H) {
        const ue = GG(H, U, le);
        ue && (R.current = new Map(Object.entries(ue.expandToSizes)), ie = ue.layout);
      }
      ie == null && (ie = HG({
        panelDataArray: U
      }));
      const ce = TE({
        layout: ie,
        panelConstraints: U.map((ue) => ue.constraints)
      });
      EE(se, ce) || (C(ce), M.current.layout = ce, K && K(ce), ga(U, ce, A.current));
    }
  }), mi(() => {
    const H = M.current;
    return () => {
      H.layout = [];
    };
  }, []);
  const de = y.useCallback((H) => {
    let K = !1;
    const le = x.current;
    return le && window.getComputedStyle(le, null).getPropertyValue("direction") === "rtl" && (K = !0), function(U) {
      U.preventDefault();
      const ie = x.current;
      if (!ie)
        return () => null;
      const {
        direction: ce,
        dragState: ue,
        id: _e,
        keyboardResizeBy: ze,
        onLayout: je
      } = L.current, {
        layout: Je,
        panelDataArray: cn
      } = M.current, {
        initialLayout: _n
      } = ue ?? {}, Sr = Ez(_e, H, ie);
      let jt = $G(U, H, ce, ue, ze, ie);
      const Ti = ce === "horizontal";
      Ti && K && (jt = -jt);
      const Wa = cn.map((sd) => sd.constraints), wr = al({
        delta: jt,
        initialLayout: _n ?? Je,
        panelConstraints: Wa,
        pivotIndices: Sr,
        prevLayout: Je,
        trigger: hz(U) ? "keyboard" : "mouse-or-touch"
      }), Hl = !Au(Je, wr);
      (pz(U) || mz(U)) && O.current != jt && (O.current = jt, !Hl && jt !== 0 ? Ti ? bm(H, jt < 0 ? vz : yz) : bm(H, jt < 0 ? bz : xz) : bm(H, 0)), Hl && (C(wr), M.current.layout = wr, je && je(wr), ga(cn, wr, A.current));
    };
  }, []), I = y.useCallback((H, K) => {
    const {
      onLayout: le
    } = L.current, {
      layout: se,
      panelDataArray: U
    } = M.current, ie = U.map((Je) => Je.constraints), {
      panelSize: ce,
      pivotIndices: ue
    } = li(U, H, se);
    De(ce != null, `Panel size not found for panel "${H.id}"`);
    const ze = ba(U, H) === U.length - 1 ? ce - K : K - ce, je = al({
      delta: ze,
      initialLayout: se,
      panelConstraints: ie,
      pivotIndices: ue,
      prevLayout: se,
      trigger: "imperative-api"
    });
    Au(se, je) || (C(je), M.current.layout = je, le && le(je), ga(U, je, A.current));
  }, []), G = y.useCallback((H, K) => {
    const {
      layout: le,
      panelDataArray: se
    } = M.current, {
      collapsedSize: U = 0,
      collapsible: ie
    } = K, {
      collapsedSize: ce = 0,
      collapsible: ue,
      maxSize: _e = 100,
      minSize: ze = 0
    } = H.constraints, {
      panelSize: je
    } = li(se, H, le);
    je != null && (ie && ue && Hr(je, U) ? Hr(U, ce) || I(H, ce) : je < ze ? I(H, ze) : je > _e && I(H, _e));
  }, [I]), B = y.useCallback((H, K) => {
    const {
      direction: le
    } = L.current, {
      layout: se
    } = M.current;
    if (!x.current)
      return;
    const U = ad(H, x.current);
    De(U, `Drag handle element not found for id "${H}"`);
    const ie = Tz(le, K);
    E({
      dragHandleId: H,
      dragHandleRect: U.getBoundingClientRect(),
      initialCursorPosition: ie,
      initialLayout: se
    });
  }, []), te = y.useCallback(() => {
    E(null);
  }, []), ae = y.useCallback((H) => {
    const {
      panelDataArray: K
    } = M.current, le = ba(K, H);
    le >= 0 && (K.splice(le, 1), delete A.current[H.id], M.current.panelDataArrayChanged = !0, z());
  }, [z]), k = y.useMemo(() => ({
    collapsePanel: N,
    direction: o,
    dragState: _,
    expandPanel: j,
    getPanelSize: Y,
    getPanelStyle: ne,
    groupId: b,
    isPanelCollapsed: J,
    isPanelExpanded: he,
    reevaluatePanelConstraints: G,
    registerPanel: fe,
    registerResizeHandle: de,
    resizePanel: I,
    startDragging: B,
    stopDragging: te,
    unregisterPanel: ae,
    panelGroupElement: x.current
  }), [N, _, o, j, Y, ne, b, J, he, G, fe, de, I, B, te, ae]), X = {
    display: "flex",
    flexDirection: o === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return y.createElement(nd.Provider, {
    value: k
  }, y.createElement(m, {
    ...g,
    children: t,
    className: n,
    id: l,
    ref: x,
    style: {
      ...X,
      ...h
    },
    // CSS selectors
    [gt.group]: "",
    [gt.groupDirection]: o,
    [gt.groupId]: b
  }));
}
const zz = y.forwardRef((e, t) => y.createElement(Mz, {
  ...e,
  forwardedRef: t
}));
Mz.displayName = "PanelGroup";
zz.displayName = "forwardRef(PanelGroup)";
function ba(e, t) {
  return e.findIndex((n) => n === t || n.id === t.id);
}
function li(e, t, n) {
  const o = ba(e, t), l = o === e.length - 1 ? [o - 1, o] : [o, o + 1], c = n[o];
  return {
    ...t.constraints,
    panelSize: c,
    pivotIndices: l
  };
}
function XG({
  disabled: e,
  handleId: t,
  resizeHandler: n,
  panelGroupElement: o
}) {
  y.useEffect(() => {
    if (e || n == null || o == null)
      return;
    const a = ad(t, o);
    if (a == null)
      return;
    const l = (c) => {
      if (!c.defaultPrevented)
        switch (c.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            c.preventDefault(), n(c);
            break;
          }
          case "F6": {
            c.preventDefault();
            const f = a.getAttribute(gt.groupId);
            De(f, `No group element found for id "${f}"`);
            const d = Rl(f, o), h = wz(f, t, o);
            De(h !== null, `No resize element found for id "${t}"`);
            const m = c.shiftKey ? h > 0 ? h - 1 : d.length - 1 : h + 1 < d.length ? h + 1 : 0;
            d[m].focus();
            break;
          }
        }
    };
    return a.addEventListener("keydown", l), () => {
      a.removeEventListener("keydown", l);
    };
  }, [o, e, t, n]);
}
function Dz({
  children: e = null,
  className: t = "",
  disabled: n = !1,
  hitAreaMargins: o,
  id: a,
  onBlur: l,
  onClick: c,
  onDragging: f,
  onFocus: d,
  onPointerDown: h,
  onPointerUp: m,
  style: g = {},
  tabIndex: b = 0,
  tagName: x = "div",
  ..._
}) {
  var E, T;
  const C = y.useRef(null), z = y.useRef({
    onClick: c,
    onDragging: f,
    onPointerDown: h,
    onPointerUp: m
  });
  y.useEffect(() => {
    z.current.onClick = c, z.current.onDragging = f, z.current.onPointerDown = h, z.current.onPointerUp = m;
  });
  const A = y.useContext(nd);
  if (A === null)
    throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
  const {
    direction: R,
    groupId: O,
    registerResizeHandle: L,
    startDragging: M,
    stopDragging: N,
    panelGroupElement: j
  } = A, Y = Jv(a), [ne, J] = y.useState("inactive"), [he, fe] = y.useState(!1), [de, I] = y.useState(null), G = y.useRef({
    state: ne
  });
  mi(() => {
    G.current.state = ne;
  }), y.useEffect(() => {
    if (n)
      I(null);
    else {
      const k = L(Y);
      I(() => k);
    }
  }, [n, Y, L]);
  const B = (E = o?.coarse) !== null && E !== void 0 ? E : 15, te = (T = o?.fine) !== null && T !== void 0 ? T : 5;
  y.useEffect(() => {
    if (n || de == null)
      return;
    const k = C.current;
    De(k, "Element ref not attached");
    let X = !1;
    return OG(Y, k, R, {
      coarse: B,
      fine: te
    }, (K, le, se) => {
      if (!le) {
        J("inactive");
        return;
      }
      switch (K) {
        case "down": {
          J("drag"), X = !1, De(se, 'Expected event to be defined for "down" action'), M(Y, se);
          const {
            onDragging: U,
            onPointerDown: ie
          } = z.current;
          U?.(!0), ie?.();
          break;
        }
        case "move": {
          const {
            state: U
          } = G.current;
          X = !0, U !== "drag" && J("hover"), De(se, 'Expected event to be defined for "move" action'), de(se);
          break;
        }
        case "up": {
          J("hover"), N();
          const {
            onClick: U,
            onDragging: ie,
            onPointerUp: ce
          } = z.current;
          ie?.(!1), ce?.(), X || U?.();
          break;
        }
      }
    });
  }, [B, R, n, te, L, Y, de, M, N]), XG({
    disabled: n,
    handleId: Y,
    resizeHandler: de,
    panelGroupElement: j
  });
  const ae = {
    touchAction: "none",
    userSelect: "none"
  };
  return y.createElement(x, {
    ..._,
    children: e,
    className: t,
    id: a,
    onBlur: () => {
      fe(!1), l?.();
    },
    onFocus: () => {
      fe(!0), d?.();
    },
    ref: C,
    role: "separator",
    style: {
      ...ae,
      ...g
    },
    tabIndex: b,
    // CSS selectors
    [gt.groupDirection]: R,
    [gt.groupId]: O,
    [gt.resizeHandle]: "",
    [gt.resizeHandleActive]: ne === "drag" ? "pointer" : he ? "keyboard" : void 0,
    [gt.resizeHandleEnabled]: !n,
    [gt.resizeHandleId]: Y,
    [gt.resizeHandleState]: ne
  });
}
Dz.displayName = "PanelResizeHandle";
function WG({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    zz,
    {
      "data-slot": "resizable-panel-group",
      className: Fe(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        e
      ),
      ...t
    }
  );
}
function AE({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(dz, { "data-slot": "resizable-panel", ...e });
}
function KG({
  withHandle: e,
  className: t,
  ...n
}) {
  return /* @__PURE__ */ S.jsx(
    Dz,
    {
      "data-slot": "resizable-handle",
      className: Fe(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:translate-x-0 data-[panel-group-direction=vertical]:after:-translate-y-1/2 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        t
      ),
      ...n,
      children: e && /* @__PURE__ */ S.jsx("div", { className: "bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border", children: /* @__PURE__ */ S.jsx(WO, { className: "size-2.5" }) })
    }
  );
}
const JG = "You are a helpful assistant. Answer in Vietnamese unless the user asks otherwise.";
function QG(e) {
  return e.filter((t) => t.type === "text").map((t) => t.text).join("");
}
function eY(e) {
  const t = e.find((o) => o.role === "user"), n = t ? QG(t.parts).trim() : "";
  return n ? n.length > 60 ? `${n.slice(0, 60)}` : n : "";
}
function tY({
  onClose: e,
  chatId: t,
  onChatIdChange: n
}) {
  const [o, a] = y.useState(""), [l, c] = y.useState([]), [f, d] = y.useState(!1), [h, m] = y.useState(!0), [g, b] = y.useState(null), [x, _] = y.useState(!1), E = `${Cl}/ai-chat`, T = y.useMemo(() => [], []), C = iI({
    id: t,
    sendAutomaticallyWhen: Q3,
    transport: new lT({
      api: E,
      fetch: async (ae, k) => {
        const X = await QM();
        return fetch(ae, {
          ...k,
          headers: {
            ...X,
            ...k?.headers
          }
        });
      },
      prepareSendMessagesRequest: async ({
        messages: ae,
        body: k,
        id: X,
        trigger: H,
        messageId: K
      }) => {
        const le = await F3(
          ae.map(({ id: U, ...ie }) => ie),
          { ignoreIncompleteToolCalls: !0 }
        ), se = localStorage.getItem("ai-name") || qR;
        return {
          body: {
            ...k ?? {},
            id: X,
            model: se,
            system: JG,
            messages: le,
            trigger: H,
            messageId: K
          }
        };
      }
    }),
    messages: T,
    generateId: Wv,
    experimental_throttle: 100,
    onError: (ae) => {
      console.log(" onError:", ae);
    }
  }), {
    messages: z,
    status: A,
    sendMessage: R,
    setMessages: O,
    stop: L,
    error: M,
    addToolOutput: N,
    // manual tool outputs (dev / approvals)
    clearError: j
  } = C, Y = C?.addToolApprovalResponse, ne = y.useMemo(
    () => z.filter((ae) => ae.role !== "system"),
    [z]
  ), J = A === "streaming" || A === "submitted";
  y.useEffect(() => {
    $F(t, z), IF(t, eY(z));
  }, [t, z]), y.useEffect(() => {
    const ae = BF(t);
    O(ae);
  }, [t, O]), y.useEffect(() => {
    let ae = !1;
    return (async () => {
      if (t) {
        _(!0), b(null);
        try {
          const X = await QF(t);
          if (ae) return;
          const H = X.messages ?? [];
          O(H);
        } catch (X) {
          if (ae) return;
          const H = X instanceof Error ? X.message : "Failed to load thread";
          !/not found/i.test(H) && !/missing/i.test(H) && b(H);
        } finally {
          if (ae) return;
          _(!1);
        }
      }
    })(), () => {
      ae = !0;
    };
  }, [t, O]);
  const he = () => m((ae) => !ae), fe = y.useCallback(
    (ae) => {
      L(), a(""), c([]), d(!1), A === "error" && j(), n(ae);
    },
    [j, n, A, L]
  ), de = y.useCallback(
    (ae) => {
      L(), a(""), c([]), d(!1), A === "error" && j(), O([]), n(ae);
    },
    [j, n, O, A, L]
  ), I = y.useCallback(
    async (ae) => {
      const k = (ae ?? o).trim();
      !k || J || (A === "error" && j(), d(!1), a(""), await R({ text: k }));
    },
    [j, o, J, R, A]
  ), G = y.useCallback(() => {
    L();
  }, [L]), B = y.useCallback(
    async (ae) => {
      await N(ae);
    },
    [N]
  ), te = y.useRef(null);
  return y.useEffect(() => {
    te.current?.scrollIntoView({ block: "end" });
  }, [ne.length, x, J]), /* @__PURE__ */ S.jsxs("div", { className: "relative h-full w-full flex flex-col overflow-hidden", children: [
    /* @__PURE__ */ S.jsx(
      IZ,
      {
        onClose: e,
        onToggleSidebar: he,
        isSidebarOpen: h
      }
    ),
    /* @__PURE__ */ S.jsxs(WG, { direction: "horizontal", className: "flex-1 min-h-0", children: [
      /* @__PURE__ */ S.jsx(
        AE,
        {
          defaultSize: 25,
          minSize: 21,
          maxSize: 26,
          collapsible: !0,
          collapsedSize: 0,
          className: h ? "z-1000 overflow-auto-y" : "hidden",
          children: /* @__PURE__ */ S.jsx(
            oG,
            {
              isOpen: h,
              currentChatId: t,
              onThreadSelect: fe,
              onNewThread: de,
              apiBaseUrl: Cl,
              isLoadingThread: x
            }
          )
        }
      ),
      h && /* @__PURE__ */ S.jsx(KG, { withHandle: !0 }),
      /* @__PURE__ */ S.jsx(AE, { defaultSize: 80, minSize: 50, children: /* @__PURE__ */ S.jsxs("div", { className: "h-full flex flex-col gap-2 overflow-y-auto overflow-hidden", children: [
        x ? /* @__PURE__ */ S.jsx(XM, { message: "Loading thread..." }) : /* @__PURE__ */ S.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ S.jsx(
            "div",
            {
              className: "flex-1 overflow-hidden",
              "data-chatbot-text": "data-chatbot",
              tabIndex: 0,
              children: /* @__PURE__ */ S.jsx(lM, { className: "h-full pr-2 chat-scroll-area", children: /* @__PURE__ */ S.jsxs("div", { className: "flex flex-col gap-3 py-2 min-h-full justify-end overflow-x-auto wrap-break-word", children: [
                /* @__PURE__ */ S.jsx(OC, { initial: !1, children: ne.map((ae, k) => /* @__PURE__ */ S.jsx(
                  SG,
                  {
                    message: ae,
                    isLast: k === ne.length - 1,
                    messageIndex: k,
                    onApproveTool: (X, H) => Y?.({
                      id: X,
                      approved: H
                    }),
                    onAddToolOutputDev: (X, H) => {
                      B({
                        tool: H,
                        toolCallId: X,
                        output: { ok: !0 }
                      });
                    }
                  },
                  ae.id
                )) }),
                ne.length > 0 && J ? /* @__PURE__ */ S.jsx(yE, {}) : null,
                !f && M ? /* @__PURE__ */ S.jsx(vG, { error: M }) : null,
                g ? /* @__PURE__ */ S.jsxs("div", { className: "px-4 py-2 text-xs text-destructive whitespace-pre-wrap break-words", children: [
                  "Failed to load thread: ",
                  g
                ] }) : null,
                /* @__PURE__ */ S.jsx("div", { className: "min-w-0 min-h-52" }),
                /* @__PURE__ */ S.jsx("div", { ref: te })
              ] }) })
            }
          ),
          ne.length !== 0 && /* @__PURE__ */ S.jsx(
            vE,
            {
              value: o,
              onChange: a,
              onSend: I,
              onFilesChange: c,
              files: l,
              opStop: G,
              onStartTyping: () => {
              },
              onUseNextSuggestionChange: () => {
              },
              disabled: J
            }
          )
        ] }),
        ne.length === 0 && /* @__PURE__ */ S.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ S.jsx(gG, {}),
          (A === "streaming" || A === "submitted") && /* @__PURE__ */ S.jsx("div", { className: "flex justify-center py-4", children: /* @__PURE__ */ S.jsx(yE, {}) }),
          /* @__PURE__ */ S.jsx(
            vE,
            {
              value: o,
              onChange: a,
              onSend: I,
              onFilesChange: c,
              files: l,
              opStop: G,
              onStartTyping: () => {
              },
              onUseNextSuggestionChange: () => {
              },
              disabled: J
            }
          )
        ] })
      ] }) })
    ] })
  ] });
}
function nY() {
  const [e, t] = y.useState(!1), [n, o] = y.useState(() => Wv()), [a, l] = y.useState(() => mm()), [{ position: c, size: f }, d] = y.useState(() => eG(mm())), h = y.useMemo(() => rz(a), [a]);
  y.useEffect(() => {
    const g = () => l(mm());
    return window.addEventListener("resize", g), () => window.removeEventListener("resize", g);
  }, []), y.useEffect(() => {
    d((g) => {
      const b = oz(g.size, h), x = iz(g.position, b, a, h);
      return { size: b, position: x };
    });
  }, [h, a]);
  const m = typeof document < "u" ? document.body : null;
  return m ? Po.createPortal(
    /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx(
        jO,
        {
          position: c,
          size: f,
          onDragStop: (g, b) => d((x) => ({ ...x, position: { x: b.x, y: b.y } })),
          onResizeStop: (g, b, x, _, E) => {
            d((T) => ({
              ...T,
              size: {
                width: parseInt(x.style.width),
                height: parseInt(x.style.height)
              },
              position: E
            }));
          },
          minWidth: h.minWidth,
          minHeight: h.minHeight,
          maxWidth: h.maxWidth,
          maxHeight: h.maxHeight,
          bounds: "window",
          dragHandleClassName: "chatbot-drag-handle",
          className: "z-50",
          style: {
            position: "fixed",
            opacity: e ? 1 : 0,
            visibility: e ? "visible" : "hidden",
            pointerEvents: e ? "auto" : "none"
          },
          children: /* @__PURE__ */ S.jsx("div", { className: "w-full h-full rounded-2xl shadow-xl border backdrop-blur-md flex flex-col bg-background overflow-hidden z-[1000]", children: /* @__PURE__ */ S.jsx(
            tY,
            {
              onClose: () => t(!1),
              chatId: n,
              onChatIdChange: (g) => o(g)
            }
          ) })
        }
      ),
      e ? null : /* @__PURE__ */ S.jsx(
        "button",
        {
          onClick: () => t(!0),
          className: "fixed bottom-4 right-4 z-50 cursor-pointer p-3 rounded-full border-2 shadow-sm bg-background hover:bg-core-navy-60 hover:shadow-2xl transition-all",
          "aria-label": "Open chatbot",
          type: "button",
          children: /* @__PURE__ */ S.jsx(bg, { className: "h-6 w-6" })
        }
      )
    ] }),
    m
  ) : null;
}
let $r = null;
const rY = {
  init(e) {
    if (!e.apiHost) {
      console.error("ChatbotEmbed: apiHost is required");
      return;
    }
    const t = e.containerId || "chatbot-root";
    let n = document.getElementById(t);
    return n || (n = document.createElement("div"), n.id = t, document.body.appendChild(n)), window.__CHATBOT_CONFIG__ = e, ZF(e.apiHost), $r || ($r = sO.createRoot(n)), $r.render(
      Kn.createElement(
        Kn.StrictMode,
        null,
        Kn.createElement(nY)
      )
    ), {
      destroy: () => {
        $r && ($r.unmount(), $r = null), n && n.parentNode && n.parentNode.removeChild(n);
      }
    };
  },
  destroy() {
    $r && ($r.unmount(), $r = null);
  }
};
typeof window < "u" && (window.ChatbotEmbed = rY);
export {
  rY as ChatbotEmbed,
  rY as default
};
